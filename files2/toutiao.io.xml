<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>64eee690f264f68b9682379d8c9cef43</guid>
<title>一文通关苦涩难懂的 Java 泛型</title>
<link>https://toutiao.io/k/xhidp2b</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前言&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信大家对Java泛型并不陌生，无论是开源框架还是&lt;code&gt;JDK&lt;/code&gt;源码都能看到它，毫不夸张的说，泛型是通用设计上必不可少的元素，所以真正理解与正确使用泛型，是一门必修课，本文将解开大家对泛型的疑惑，并通过大量实践，让你get到泛型正确的使用姿势，下面开始进入正题吧！&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;大纲&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7120181405895691&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx4t5DlH6w3mEmibxLicsc9mBd7RGCoN4mWQqqHia8InsMyfza0YuZrRphibJLsicXXTia2RDng7md5QfHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;882&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基础&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为本文重实践，而且面对的是Java开发人员群体，大家对泛型都有基础，所以泛型基础这块会快速过，帮助大家回忆下即可，后面主要的则重点是通配符&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;编译期与运行期&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;编译期&lt;/strong&gt;是指把源码交给编译器编译成计算机可执行文件的过程，&lt;strong&gt;运行期&lt;/strong&gt;是指把编译后的文件交给计算机执行，直到程序结束。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;Java&lt;/code&gt;中就是把&lt;code&gt;.java&lt;/code&gt;文件编译成&lt;code&gt;.class&lt;/code&gt;文件，再把编译后的文件交给&lt;code&gt;J V M&lt;/code&gt;加载执行，如下图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6796805678793256&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx4t5DlH6w3mEmibxLicsc9mB6BpGy0N8RPhG9ib9gcoEicojmRiaREAtTlwiamo3NdoiadTTpO0x1as5AJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1127&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;泛型&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;泛型又叫“参数化类型”，这么抽象的专业词汇不好理解，阿星就用大白话的形式来解释。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;人是铁，饭是刚，吃饭是刚需，要吃饭自然就少不了碗筷，但是没有规定碗只能盛饭，除了盛饭它还能盛汤、盛菜，制造者只造这个碗，不关心碗盛什么，具体要盛什么由使用者来决定，这就是泛型的概念。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;泛型就是在定义类、接口、方法的时候指定某一种特定类型（&lt;span&gt;碗&lt;/span&gt;），让类、接口、方法的使用者来决定具体用哪一种类型的参数（&lt;span&gt;盛的东西&lt;/span&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Java&lt;/code&gt;的泛型是在&lt;code&gt;1.5&lt;/code&gt;引入的，只在&lt;strong&gt;编译期&lt;/strong&gt;做泛型检查，&lt;strong&gt;运行期&lt;/strong&gt;泛型就会消失，我们把这称为“泛型擦除”，最终类型都会变成 &lt;code&gt;Object&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在没有泛型之前，从集合中读取到的每一个对象都必须进行类型转换，如果不小心插入了错误的类型对象，在运行时的转换处理就会出错，有了泛型后，你可以告诉编译器每个集合接收的对象类型是什么，编译器在编译期就会做类型检查，告知是否插入了错误类型的对象，使得程序更加安全，也更加清楚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后插一句，泛型擦除与原生态类型（List就是原生态，List&lt;t&gt;非原生态）是为了照顾&lt;code&gt;1.5&lt;/code&gt;以前设计上的缺陷，为兼容非泛型代码，所作出的折中策略，&lt;span&gt;所以不推荐使用原生态类型，如果使用了原生态类型，就失去了泛型在安全性与描述性方面的优势。&lt;/span&gt;&lt;/t&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;泛型类&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5573770491803278&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx4t5DlH6w3mEmibxLicsc9mBVf19XNIRGicoI7myibkLaOuwF0vqQQPe3iaqKtk7IaibG0t1YnDopgJtibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;549&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类上定义泛型，作用于类的成员变量与函数，代码实例如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GenericClass&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//成员变量&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; T t;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;functionTwo&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//注意，这个不是泛型方法！！！&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;return&lt;/span&gt; t;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;泛型接口&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5008665511265165&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx4t5DlH6w3mEmibxLicsc9mBH7YHCTEPEk10v5uibXAu4E6zcna57ExYB22pdClibvoib1VwGicwlRiaRQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;577&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口上定义泛型，作用于函数，代码实例如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;GenericInterface&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;delete&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;default&lt;/span&gt; T &lt;span&gt;defaultFunction&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; t;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;泛型函数&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9408369408369408&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx4t5DlH6w3mEmibxLicsc9mBpIwIfD1pJYyMCAt0Haw9pGlWJ2NhWTib9tKCKF7iarapg4sfRsgc3Ziaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;693&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数返回类型旁加上泛型，作用于函数，代码实例如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GenericFunction&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;T &lt;span&gt;functionTwo&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; t;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;String &lt;span&gt;functionThree&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;通配符&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通配符是为了让&lt;code&gt;Java&lt;/code&gt;泛型支持范围限定，这样使得泛型的灵活性提升，同时也让通用性设计有了更多的空间。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt;：无界通配符，即类型不确定，任意类型&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt;：上边界通配符，即&lt;code&gt;?&lt;/code&gt;是继承自&lt;code&gt;T&lt;/code&gt;的任意子类型，遵守只读不写&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt;：下边界通配符，即&lt;code&gt;?&lt;/code&gt;是&lt;code&gt;T&lt;/code&gt;的任意父类型，遵守只写不读&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信大部分人，都是倒在通配符这块，这里多唠叨点，「&lt;strong&gt;通配符限定的范围是体现在确认“参数化类型”的时候，而不是“参数化类型”填充后&lt;/strong&gt;」，可能这句话不太好理解，来看看下面的代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 1.创建泛型为Number的List类，Integer、Double、Long等都是Number的子类&lt;br/&gt; *   new ArrayList&amp;lt;&amp;gt;() 等价于 new ArrayList&amp;lt;Number&amp;gt;()&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;List&amp;lt;Number&amp;gt; numberList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Number&amp;gt;();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 2.添加不同子类&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;numberList.add(&lt;span&gt;1&lt;/span&gt;);&lt;span&gt;//添加Integer类型&lt;/span&gt;&lt;br/&gt;numberList.add(&lt;span&gt;0.5&lt;/span&gt;);&lt;span&gt;//添加Double类型&lt;/span&gt;&lt;br/&gt;numberList.add(&lt;span&gt;10000L&lt;/span&gt;);&lt;span&gt;//添加Long类型&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 3.创建泛型为Number的List类，Integer、Double、Long等都是Number的子类&lt;br/&gt; *   引用是泛型类别是Number，但具体实现指定的泛型是Integer&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;List&amp;lt;Number&amp;gt; numberListTwo = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();&lt;span&gt;//err 异常编译不通过&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 4.创建泛型为Integer的List类，把该对象的引用地址指向泛型为Number的List&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;List&amp;lt;Integer&amp;gt; integerList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();&lt;br/&gt;List&amp;lt;Number&amp;gt; numberListThree = integerList;&lt;span&gt;//err 异常编译不通过&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一步：我们创建一个泛型为&lt;code&gt;Number&lt;/code&gt;的&lt;code&gt;List&lt;/code&gt;，编译器检查泛型类别是否一致，一致编译通过（确认参数化类型）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二步：泛型&lt;code&gt;Number&lt;/code&gt;已经填充完毕，调用&lt;code&gt;add&lt;/code&gt;函数，此时&lt;code&gt;add&lt;/code&gt;入参泛型&lt;code&gt;T&lt;/code&gt;已经填充为&lt;code&gt;Number&lt;/code&gt;，&lt;code&gt;add&lt;/code&gt;可入参&lt;code&gt;Number&lt;/code&gt;或其子类&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第三步：我们又创建一个泛型为&lt;code&gt;Number&lt;/code&gt;的&lt;code&gt;List&lt;/code&gt;，编译器检查泛型类别是否一致，不一致编译失败，提示错误（确认参数化类型）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第四步：其实与第三步一样，只是做了一个间接的引用（确认参数化类型）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要解决上面的编译不通过问题，就需要使用通配符，代码如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 1.上边界通配符，Number与Number子类&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;List&amp;lt;? extends Number&amp;gt; numberListFour = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Number&amp;gt;();&lt;br/&gt;numberListFour = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();&lt;br/&gt;numberListFour = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Double&amp;gt;();&lt;br/&gt;numberListFour = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Long&amp;gt;();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 2.下边界通配符,Integer与Integer父类&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;List&amp;lt;? &lt;span&gt;super&lt;/span&gt; Integer&amp;gt; integerList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();&lt;br/&gt;integerList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Number&amp;gt;();&lt;br/&gt;integerList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Object&amp;gt;();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 3. 无界通配符,类型不确定，任意类型&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;List&amp;lt;?&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();&lt;br/&gt;list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Number&amp;gt;();&lt;br/&gt;list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Object&amp;gt;();&lt;br/&gt;list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;();&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后再来说上边界通配符只读不写，下边界通配符只写不读到底是什么意思，用最简单的话来说&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt;上边界通配符不作为函数入参，只作为函数返回类型，比如&lt;code&gt;List&amp;lt;? extends T&amp;gt;&lt;/code&gt;的使用&lt;code&gt;add&lt;/code&gt;函数会编译不通过，&lt;code&gt;get&lt;/code&gt;函数则没问题&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt;下边界通配符不作为函数返回类型，只作为函数入参，比如&lt;code&gt;List&amp;lt;? super T&amp;gt;&lt;/code&gt;的&lt;code&gt;add&lt;/code&gt;函数正常调用，&lt;code&gt;get&lt;/code&gt;函数也没问题，但只会返回&lt;code&gt;Object&lt;/code&gt;，所以意义不大&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家只需要记住上面的规则即可，如果想知道为什么这样设计，可以去了解下&lt;code&gt;P E C S (producer-extends,consumer-super)&lt;/code&gt;原则&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;最佳实践&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信过完基础理论大家很多东西都回忆起来了，不要着急，现在开始进入正题，后面内容会有大量的代码实践，所以大家要坐稳了，别晕车了，晕车的话多看几遍，或者评论区提出你的疑问~&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/23OQmC1ia8nx4t5DlH6w3mEmibxLicsc9mBJ0TM0ic1RnvTs8TC4RjcsgQC2tzGJNYe1GITOGt1cD5kmOFyFoJV82w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;无限通配符场景&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用泛型，类型参数不确定并且不关心实际的类型参数，就可以使用&lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt;，像下面的代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 获取集合长度&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;size&lt;/span&gt;&lt;span&gt;(Collection&amp;lt;T&amp;gt; list)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; list.size();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 获取集合长度-2&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;sizeTwo&lt;/span&gt;&lt;span&gt;(Collection&amp;lt;?&amp;gt;  list)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; list.size();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 获取任意Set两个集合交集数量&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T,T2&amp;gt; &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;beMixedSum&lt;/span&gt;&lt;span&gt;(Set&amp;lt;T&amp;gt; s1,Set&amp;lt;T2&amp;gt; s2)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (T t : s1) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (s2.contains(t)) {&lt;br/&gt;            i++;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; i;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 获取任意两个Set集合交集数量-2&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; &lt;span&gt;beMixedSumTwo&lt;/span&gt;&lt;span&gt;(Set&amp;lt;?&amp;gt; s1,Set&amp;lt;?&amp;gt; s2)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Object o : s1) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (s2.contains(o)) {&lt;br/&gt;            i++;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; i;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;size&lt;/code&gt;与&lt;code&gt;sizeTwo&lt;/code&gt;这两个函数都可以正常使用，但是站在设计的角度，&lt;code&gt;sizeTwo&lt;/code&gt;会更合适，函数的目标是返回任意集合的长度，入参采用&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;或&lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt;都可以接收，但是函数本身并不关心你是什么类型参数，仅仅只要返回长度即可，所以采用&lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;beMixedSum&lt;/code&gt;与&lt;code&gt;beMixedSumTwo&lt;/code&gt;这两个函数比较，道理同上面一样，&lt;code&gt;beMixedSumTwo&lt;/code&gt;会更合适，函数的目标是返回两个任意Set集合的交集数量，&lt;code&gt;beMixedSum&lt;/code&gt;函数虽然内部有使用到&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;，但是意义不大，因为&lt;code&gt;contains&lt;/code&gt;入参是&lt;code&gt;Object&lt;/code&gt;，函数本身并不关心你是什么类型参数，所以采用&lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;忘了补充另一个场景，就是原生态类型，上述代码使用原生态类型函数使用也没问题，但是强烈不推荐，&lt;span&gt;因为使用原生态就丢失了泛型带来的安全性与描述性！！！&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;上下边界通配符场景&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先泛型是不变的，换句话说&lt;code&gt;List&amp;lt;Object&amp;gt; != List&amp;lt;String&amp;gt;&lt;/code&gt;，有时候需要更多灵活性，就可以通过上下边界通配符来做提升。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 集合工具类&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CollectionUtils&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;{&lt;br/&gt;        &lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 复制集合-泛型&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;T&amp;gt;  &lt;span&gt;listCopy&lt;/span&gt;&lt;span&gt;(Collection&amp;lt;T&amp;gt; collection)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        List&amp;lt;T&amp;gt; newCollection = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (T t : collection) {&lt;br/&gt;            newCollection.add(t);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; newCollection;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面声明了一个&lt;code&gt;CollectionUtils&lt;/code&gt;类，拥有&lt;code&gt;listCopy&lt;/code&gt;方法，传入任意一个集合返回新的集合，看似没有什么问题，也很灵活，那再看看下面这段代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    CollectionUtils&amp;lt;Number&amp;gt; collectionUtils = &lt;span&gt;new&lt;/span&gt; CollectionUtils&amp;lt;&amp;gt;();&lt;br/&gt;    List&amp;lt;Number&amp;gt;  list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//list.add....&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Integer&amp;gt;  listTwo = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//listTwo.add....&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Double&amp;gt;  listThree = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//listThree.add....&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    List&amp;lt;Number&amp;gt; list1 = collectionUtils.listCopy(list);&lt;br/&gt;    list1 = collectionUtils.listCopy(listTwo);&lt;span&gt;//err 编译异常&lt;/span&gt;&lt;br/&gt;    list1 = collectionUtils.listCopy(listThree);&lt;span&gt;//err 编译异常&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建&lt;code&gt;CollectionUtils&lt;/code&gt;类，泛型的类型参数为&lt;code&gt;Number&lt;/code&gt;，&lt;code&gt;listCopy&lt;/code&gt;函数入参的泛型填充为&lt;code&gt;Number&lt;/code&gt;，此时&lt;code&gt;listCopy&lt;/code&gt;只支持泛型为&lt;code&gt;Number&lt;/code&gt;的&lt;code&gt;List&lt;/code&gt;，如果要让它同时支持泛型为&lt;code&gt;Number&lt;/code&gt;子类的&lt;code&gt;List&lt;/code&gt;，就需要使用上边界通配符，我们再追加一个方法&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 集合工具&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CollectionUtils&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;{&lt;br/&gt;        &lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 复制集合-泛型&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;T&amp;gt;  &lt;span&gt;listCopy&lt;/span&gt;&lt;span&gt;(Collection&amp;lt;T&amp;gt; collection)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        List&amp;lt;T&amp;gt; newCollection = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (T t : collection) {&lt;br/&gt;            newCollection.add(t);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; newCollection;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 复制集合-上边界通配符&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt;  List&amp;lt;T&amp;gt;  &lt;span&gt;listCopyTwo&lt;/span&gt;&lt;span&gt;(Collection&amp;lt;? extends T&amp;gt; collection)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        List&amp;lt;T&amp;gt; newCollection = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (T t : collection) {&lt;br/&gt;            newCollection.add(t);&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; newCollection;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    CollectionUtils&amp;lt;Number&amp;gt; collectionUtils = &lt;span&gt;new&lt;/span&gt; CollectionUtils&amp;lt;&amp;gt;();&lt;br/&gt;    List&amp;lt;Number&amp;gt;  list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//list.add....&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Integer&amp;gt;  listTwo = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//listTwo.add....&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Double&amp;gt;  listThree = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//listThree.add....&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    List&amp;lt;Number&amp;gt; list1 = collectionUtils.listCopyTwo(list);&lt;br/&gt;    list1 = collectionUtils.listCopyTwo(listTwo);&lt;br/&gt;    list1 = collectionUtils.listCopyTwo(listThree);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在使用&lt;code&gt;listCopyTwo&lt;/code&gt;就没有问题，&lt;code&gt;listCopyTwo&lt;/code&gt;对比&lt;code&gt;listCopy&lt;/code&gt;它的适用范围更广泛也更灵活，&lt;code&gt;listCopy&lt;/code&gt;能做的&lt;code&gt;listCopyTwo&lt;/code&gt;能做，&lt;code&gt;listCopyTwo&lt;/code&gt;能做的&lt;code&gt;listCopy&lt;/code&gt;就不一定能做了，除此之外，细心的小伙伴肯定发现了，使用上边界通配符的&lt;code&gt;collection&lt;/code&gt;在函数内只使用到了读操作，遵循了只读不写原则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完了上边界通配符，再来看看下边界通配符，依然是复制方法&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 儿子&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Son&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Father&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 父亲&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Father&lt;/span&gt;  &lt;span&gt;extends&lt;/span&gt;  &lt;span&gt;Grandpa&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 爷爷&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Grandpa&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 集合工具&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CollectionUtils&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 复制集合-泛型&lt;br/&gt;     * target目标   src来源&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;copy&lt;/span&gt;&lt;span&gt;(List&amp;lt;T&amp;gt; target,List&amp;lt;T&amp;gt; src)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (src.size() &amp;gt; target.size()){&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; src.size(); i++) {&lt;br/&gt;                target.set(i,src.get(i));&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义了3个类，分别是&lt;code&gt;Son&lt;/code&gt;儿子、&lt;code&gt;Father&lt;/code&gt;父亲、&lt;code&gt;Grandpa&lt;/code&gt;爷爷，它们是继承关系，作为集合元素，还声明了一个&lt;code&gt;CollectionUtils&lt;/code&gt;类，拥有&lt;code&gt;copy&lt;/code&gt;方法，传入两个集合，目标集合与来源集合，把来源集合元素复制到目标集合中，再看看下面这段代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    CollectionUtils&amp;lt;Father&amp;gt; collectionUtils = &lt;span&gt;new&lt;/span&gt; CollectionUtils&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    List&amp;lt;Father&amp;gt;  fatherTargets = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    List&amp;lt;Father&amp;gt;  fatherSources = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//fatherSources.add...&lt;/span&gt;&lt;br/&gt;    collectionUtils.copy(fatherTargets,fatherSources);&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;//子类复制到父类&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Son&amp;gt; sonSources = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//sonSources.add...&lt;/span&gt;&lt;br/&gt;    collectionUtils.copy(fatherTargets,sonSources);&lt;span&gt;//err 编译异常&lt;/span&gt;&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建&lt;code&gt;CollectionUtils&lt;/code&gt;类，泛型的类型参数为&lt;code&gt;Father&lt;/code&gt;父亲，&lt;code&gt;copy&lt;/code&gt;函数入参的泛型填充为&lt;code&gt;Father&lt;/code&gt;，此时&lt;code&gt;copy&lt;/code&gt;只支持泛型为&lt;code&gt;Father&lt;/code&gt;的&lt;code&gt;List&lt;/code&gt;，也就说，只支持泛型的类型参数为&lt;code&gt;Father&lt;/code&gt;之间的复制，如果想支持把子类复制到父类要怎么做，先分析下&lt;code&gt;copy&lt;/code&gt;函数，&lt;code&gt;copy&lt;/code&gt;函数的入参&lt;code&gt;src&lt;/code&gt;在函数内部只涉及到了&lt;code&gt;get&lt;/code&gt;函数，即读操作（&lt;span&gt;泛型只作为&lt;code&gt;get&lt;/code&gt;函数返回类型&lt;/span&gt;），符合只读不写原则，可以采用上边界通配符，调整代码如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 集合工具&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CollectionUtils&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 复制集合-泛型&lt;br/&gt;     * target目标   src来源&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;copy&lt;/span&gt;&lt;span&gt;(List&amp;lt;T&amp;gt; target,List&amp;lt;? extends T&amp;gt; src)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (src.size() &amp;gt; target.size()){&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; src.size(); i++) {&lt;br/&gt;                target.set(i,src.get(i));&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    CollectionUtils&amp;lt;Father&amp;gt; collectionUtils = &lt;span&gt;new&lt;/span&gt; CollectionUtils&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    List&amp;lt;Father&amp;gt;  fatherTargets = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    List&amp;lt;Father&amp;gt;  fatherSources = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//fatherSources.add...&lt;/span&gt;&lt;br/&gt;    collectionUtils.copy(fatherTargets,fatherSources);&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;//子类复制到父类&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Son&amp;gt; sonSources = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//sonSources.add...&lt;/span&gt;&lt;br/&gt;    collectionUtils.copy(fatherTargets,sonSources);&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;//把子类复制到父类的父类&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Grandpa&amp;gt; grandpaTargets = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    collectionUtils.copy(grandpaTargets,sonSources);&lt;span&gt;//err 编译异常&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;src&lt;/code&gt;入参调整为上边界通配符后，&lt;code&gt;copy&lt;/code&gt;函数传入&lt;code&gt;List&amp;lt;Son&amp;gt; sonSources&lt;/code&gt;就没问题了，此时的&lt;code&gt;copy&lt;/code&gt;函数相较之前的更加灵活了，支持同类与父子类复制，接着又发现了一个问题，目前能复制到上一级父类，如果是多级父类，还无法支持，继续分析&lt;code&gt;copy&lt;/code&gt;函数，&lt;code&gt;copy&lt;/code&gt;函数的入参&lt;code&gt;target&lt;/code&gt;在函数内部只涉及到了&lt;code&gt;add&lt;/code&gt;函数，即写操作（泛型&lt;span&gt;只作为&lt;code&gt;add&lt;/code&gt;函数入参&lt;/span&gt;），符合只写不读原则，可以采用下边界通配符，调整代码如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 集合工具&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CollectionUtils&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 复制集合-泛型&lt;br/&gt;     * target目标   src来源&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;copy&lt;/span&gt;&lt;span&gt;(List&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt;  target,List&amp;lt;? extends T&amp;gt; src)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (src.size() &amp;gt; target.size()){&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; src.size(); i++) {&lt;br/&gt;                target.set(i,src.get(i));&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    CollectionUtils&amp;lt;Father&amp;gt; collectionUtils = &lt;span&gt;new&lt;/span&gt; CollectionUtils&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    List&amp;lt;Father&amp;gt;  fatherTargets = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    List&amp;lt;Father&amp;gt;  fatherSources = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//fatherSources.add...&lt;/span&gt;&lt;br/&gt;    collectionUtils.copy(fatherTargets,fatherSources);&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;//子类复制到父类&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Son&amp;gt; sonSources = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//sonSources.add...&lt;/span&gt;&lt;br/&gt;    collectionUtils.copy(fatherTargets,sonSources);&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;//把子类复制到父类的父类&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Grandpa&amp;gt; grandpaTargets = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    collectionUtils.copy(grandpaTargets,sonSources);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;copy&lt;/code&gt;函数终于是完善了，可以说现在是真正支持父子类复制，不难发现&lt;code&gt;copy&lt;/code&gt;函数的设计还是遵循通配符原则的，&lt;code&gt;target&lt;/code&gt;作为目标集合，只做写入，符合只写不读原则，采用了下边界通配符，&lt;code&gt;src&lt;/code&gt;作为来源集合，只做读取，符合只读不写原则，采用了上边界通配符，最后设计出来的&lt;code&gt;copy&lt;/code&gt;函数，它的灵活性与适用范围是远超&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;方式设计的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后总结一下，什么时候用通配符，&lt;strong&gt;如果参数泛型类即要读也要写，那么就不推荐使用，使用正常的泛型即可，如果参数泛型类只读或写，就可以根据原则采用对应的上下边界&lt;/strong&gt;，是不是十分简单，最后再说一次读写的含义，这块确实很容易晕&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;读：所谓读是指参数泛型类，泛型只作为该参数类的函数返回类型，那这个函数就是读，&lt;code&gt;List&lt;/code&gt;作为参数泛型类，它的&lt;code&gt;get&lt;/code&gt;函数就是读&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;写：所谓写是指参数泛型类，泛型只作为该参数类的函数入参，那这个函数就是写，&lt;code&gt;List&lt;/code&gt;作为参数泛型类，它的&lt;code&gt;add&lt;/code&gt;函数就是读&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;留给小题，大家可以思考下&lt;code&gt;Stream&lt;/code&gt;的&lt;code&gt;forEach&lt;/code&gt;函数与&lt;code&gt;map&lt;/code&gt;函数的设计，在&lt;code&gt;Java1.8 Stream&lt;/code&gt;中是大量用到了通配符设计&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-----------------------------------------------------------------&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 下边界通配符&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;forEach&lt;/span&gt;&lt;span&gt;(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt; action)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Consumer&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//写方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;accept&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;-----------------------------------------------------------------&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 上下边界通配符&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&amp;lt;R&amp;gt; &lt;span&gt;Stream&amp;lt;R&amp;gt; &lt;span&gt;map&lt;/span&gt;&lt;span&gt;(Function&amp;lt;? &lt;span&gt;super&lt;/span&gt; T, ? extends R&amp;gt; mapper)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; interface Function&amp;lt;T, R&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;     &lt;span&gt;//读写方法，T只作为入参符合写，R只作为返回值，符合读&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;R &lt;span&gt;apply&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;-----------------------------------------------------------------&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//代码案例&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;br/&gt;        List&amp;lt;Father&amp;gt; fatherList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;br/&gt;        Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; Father&amp;gt; action = &lt;span&gt;new&lt;/span&gt; Consumer&amp;lt;Father&amp;gt;() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;accept&lt;/span&gt;&lt;span&gt;(Father father)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;//执行father逻辑&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;        };&lt;br/&gt;        &lt;br/&gt;         &lt;span&gt;//下边界通配符向上转型&lt;/span&gt;&lt;br/&gt;        Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; Father&amp;gt; actionTwo = &lt;span&gt;new&lt;/span&gt; Consumer&amp;lt;Grandpa&amp;gt;() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;accept&lt;/span&gt;&lt;span&gt;(Grandpa grandpa)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;//执行grandpa逻辑&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;        };&lt;br/&gt;        &lt;br/&gt;         Function&amp;lt;? &lt;span&gt;super&lt;/span&gt; Father, ? extends Grandpa&amp;gt; mapper = &lt;span&gt;new&lt;/span&gt; Function&amp;lt;Father, Grandpa&amp;gt;() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Grandpa &lt;span&gt;apply&lt;/span&gt;&lt;span&gt;(Father father)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;//执行father逻辑后返回Grandpa&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Grandpa();&lt;br/&gt;            }&lt;br/&gt;        };&lt;br/&gt;        &lt;br/&gt;        &lt;span&gt;//下边界通配符向上转型，上边界通配符向下转型&lt;/span&gt;&lt;br/&gt;         Function&amp;lt;? &lt;span&gt;super&lt;/span&gt; Father, ? extends Grandpa&amp;gt; mapperTwo = &lt;span&gt;new&lt;/span&gt; Function&amp;lt;Grandpa, Son&amp;gt;() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Son &lt;span&gt;apply&lt;/span&gt;&lt;span&gt;(Grandpa grandpa)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;//执行grandpa逻辑后，返回Son&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Son();&lt;br/&gt;            }&lt;br/&gt;        };&lt;br/&gt;        &lt;br/&gt;        fatherList.stream().forEach(action);&lt;br/&gt;        fatherList.stream().forEach(actionTwo);&lt;br/&gt;        &lt;br/&gt;        fatherList.stream().map(mapper);&lt;br/&gt;        fatherList.stream().map(mapperTwo);&lt;br/&gt;        &lt;br/&gt;    &lt;br/&gt;    }&lt;br/&gt;-----------------------------------------------------------------&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;有限制泛型场景&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有限制泛型很简单了，应用场景就是你需要对泛型的参数类型做限制，就可以使用它，比如下面这段代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GenericClass&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Grandpa&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;   &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//....&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    GenericClass&amp;lt;Grandpa&amp;gt; grandpaGeneric = &lt;span&gt;new&lt;/span&gt; GenericClass&amp;lt;&amp;gt;();&lt;br/&gt;    grandpaGeneric.test(&lt;span&gt;new&lt;/span&gt; Grandpa());&lt;br/&gt;    grandpaGeneric.test(&lt;span&gt;new&lt;/span&gt; Father());&lt;br/&gt;    grandpaGeneric.test(&lt;span&gt;new&lt;/span&gt; Son());&lt;br/&gt;    &lt;br/&gt;    GenericClass&amp;lt;Father&amp;gt; fatherGeneric = &lt;span&gt;new&lt;/span&gt; GenericClass&amp;lt;&amp;gt;();&lt;br/&gt;    fatherGeneric.test(&lt;span&gt;new&lt;/span&gt; Father());&lt;br/&gt;    fatherGeneric.test(&lt;span&gt;new&lt;/span&gt; Son());&lt;br/&gt;&lt;br/&gt;    GenericClass&amp;lt;Son&amp;gt; sonGeneric = &lt;span&gt;new&lt;/span&gt; GenericClass&amp;lt;&amp;gt;();&lt;br/&gt;    sonGeneric.test(&lt;span&gt;new&lt;/span&gt; Son());&lt;br/&gt;    &lt;br/&gt;    GenericClass&amp;lt;Object&amp;gt; ObjectGeneric = &lt;span&gt;new&lt;/span&gt; GenericClass&amp;lt;&amp;gt;();&lt;span&gt;//err 编译异常&lt;/span&gt;&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;GenericClass&lt;/code&gt;泛型参数化类型被限制为&lt;code&gt;Grandpa&lt;/code&gt;或其子类，就这么简单，千万不要把有限制泛型与上边界通配符搞混了，这两个不是同一个东西（&lt;code&gt;&amp;lt;T extends Grandpa&amp;gt; != &amp;lt;? extends Grandpa&amp;gt;&lt;/code&gt;），&lt;code&gt;&amp;lt;T extends Grandpa&amp;gt;&lt;/code&gt;不需要遵循上边界通配符的原则，它就是简单的泛型参数化类型限制，而且没有&lt;code&gt;super&lt;/code&gt;的写法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;递归泛型场景&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在有限制泛型的基础上，又可以衍生出递归泛型，就是自身需要使用到自身，比如集合进行自定义元素大小比较的时候，通常会配合&lt;code&gt;Comparable&lt;/code&gt;接口来完成，看看下面这段代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Person&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Comparable&lt;/span&gt;&amp;lt;&lt;span&gt;Person&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; age;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Person&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; age)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.age = age;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getAge&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; age;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;compareTo&lt;/span&gt;&lt;span&gt;(Person o)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 0代表相等 1代表大于  &amp;lt;0代表小于    &lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.age - o.age;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 集合工具&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CollectionUtils&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 获取集合最大值&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;  &amp;lt;E extends Comparable&amp;lt;E&amp;gt;&amp;gt; &lt;span&gt;E &lt;span&gt;max&lt;/span&gt;&lt;span&gt;(List&amp;lt;E&amp;gt; list)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        E result = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (E e : list) {&lt;br/&gt;             &lt;span&gt;if&lt;/span&gt; (result == &lt;span&gt;null&lt;/span&gt; || e.compareTo(result) &amp;gt; &lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;                 result = e;&lt;br/&gt;             }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    List&amp;lt;Person&amp;gt; personList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    personList.add(&lt;span&gt;new&lt;/span&gt; Person(&lt;span&gt;12&lt;/span&gt;));&lt;br/&gt;    personList.add(&lt;span&gt;new&lt;/span&gt; Person(&lt;span&gt;19&lt;/span&gt;));&lt;br/&gt;    personList.add(&lt;span&gt;new&lt;/span&gt; Person(&lt;span&gt;20&lt;/span&gt;));&lt;br/&gt;    personList.add(&lt;span&gt;new&lt;/span&gt; Person(&lt;span&gt;5&lt;/span&gt;));&lt;br/&gt;    personList.add(&lt;span&gt;new&lt;/span&gt; Person(&lt;span&gt;18&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;//返回年龄最大的Person元素 &lt;/span&gt;&lt;br/&gt;    Person max = CollectionUtils.max(personList);&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重点关注&lt;code&gt;max&lt;/code&gt;泛型函数，&lt;code&gt;max&lt;/code&gt;泛型函数的目标是返回集合最大的元素，内部比较元素大小，取最大值返回，也就说需要和同类型元素做比较，&lt;code&gt;&amp;lt;E extends Comparable&amp;lt;E&amp;gt;&amp;gt;&lt;/code&gt;含义是，泛型&lt;code&gt;E&lt;/code&gt;必须是&lt;code&gt;Comparable&lt;/code&gt;或其子类/实现类，因为比较元素是同类型，所以&lt;code&gt;Comparable&lt;/code&gt;泛型也是&lt;code&gt;E&lt;/code&gt;,最终接收的&lt;code&gt;List&lt;/code&gt;泛型参数化类型必须实现了&lt;code&gt;Comparable&lt;/code&gt;接口，并且&lt;code&gt;Comparable&lt;/code&gt;接口填充的泛型也是该参数化类型，就像上述代码一样。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;关于我&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是阿星，一个热爱技术的Java程序猿，在公众号  &lt;strong&gt;&lt;span&gt;「程序猿阿星」&lt;/span&gt;&lt;/strong&gt; 里将会定期分享操作系统、计算机网络、Java、分布式、数据库等精品原创文章，2021，与您在 Be Better 的路上共同成长！。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常感谢各位人才能 看到这里，原创不易，文章有帮助可以「点个赞」或「分享与评论」，都是支持（莫要白嫖）！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;愿你我都能奔赴在各自想去的路上，我们下篇文章见！&lt;/p&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>73284fc8941ed16fcde4a5a0ec7a0586</guid>
<title>跟 Kafka 学技术系列之时间轮</title>
<link>https://toutiao.io/k/77iozz6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;src-views-article-detail-main-module__content--2qOBd markdown-body&quot;&gt;&lt;h1&gt;写在前面&lt;/h1&gt;
&lt;p&gt;kafka是一个分布式消息中间件，其高可用高吞吐的特点是大数据领域首选的消息中间件，Kafka是分布式消息队列的顺序读写文件分段组织串联起来思想的鼻祖，包括RocketMq这些消息队列都是借鉴了Kafka早期的架构和设计思路改造而来，所以在架构设计层面，Kafka有非常多值得借鉴的地方。本文是作者介绍Kafka优秀架构设计文章中的一篇，文中的代码和流程图均是base on 0.10.2.0版本。&lt;/p&gt;
&lt;h1&gt;引出环形队列和延迟队列&lt;/h1&gt;
&lt;p&gt;从2个面试题说起，第1个问题，如果一台机器上有10w个定时任务，如何做到高效触发？&lt;/p&gt;
&lt;p&gt;具体场景是：&lt;/p&gt;
&lt;p&gt;有一个APP实时消息通道系统，对每个用户会维护一个APP到服务器的TCP连接，用来实时收发消息，对这个TCP连接，有这样一个需求：“如果连续30s没有请求包（例如登录，消息，keepalive包），服务端就要将这个用户的状态置为离线”。&lt;/p&gt;
&lt;p&gt;其中，单机TCP同时在线量约在10w级别，keepalive请求包较分散大概30s一次，吞吐量约在3000qps。&lt;/p&gt;
&lt;p&gt;怎么做？&lt;/p&gt;
&lt;p&gt;常用方案使用time定时任务，每秒扫描一次所有连接的集合Map&amp;lt;uid, last_packet_time&amp;gt;，把连接时间（每次有新的请求更新对应连接的连接时间）比当前时间的差值大30s的连接找出来处理。&lt;/p&gt;
&lt;p&gt;另一种方案，使用环形队列法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200308202309477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1poaVp1aUNodW5GZW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;小桔车服 &amp;gt; 跟Kafka学技术-时间轮 &amp;gt; image2020-1-17_16-20-37.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三个重要的数据结构：&lt;/p&gt;
&lt;p&gt;1）30s超时，就创建一个index从0到30的环形队列（本质是个数组）&lt;/p&gt;
&lt;p&gt;2）环上每一个slot是一个Set&amp;lt;uid&amp;gt;，任务集合&lt;/p&gt;
&lt;p&gt;3）同时还有一个Map&amp;lt;uid, index&amp;gt;，记录uid落在环上的哪个slot里&lt;/p&gt;
&lt;p&gt;这样当有某用户uid有请求包到达时：&lt;/p&gt;
&lt;p&gt;1）从Map结构中，查找出这个uid存储在哪一个slot里&lt;/p&gt;
&lt;p&gt;2）从这个slot的Set结构中，删除这个uid&lt;/p&gt;
&lt;p&gt;3）将uid重新加入到新的slot中，具体是哪一个slot呢 =&amp;gt; Current Index指针所指向的上一个slot，因为这个slot，会被timer在30s之后扫描到&lt;/p&gt;
&lt;p&gt;4）更新Map，这个uid对应slot的index值&lt;/p&gt;
&lt;p&gt;哪些元素会被超时掉呢？&lt;/p&gt;
&lt;p&gt;Current Index每秒种移动一个slot，这个slot对应的Set&amp;lt;uid&amp;gt;中所有uid都应该被集体超时！如果最近30s有请求包来到，一定被放到Current Index的前一个slot了，Current Index所在的slot对应Set中所有元素，都是最近30s没有请求包来到的。&lt;/p&gt;
&lt;p&gt;所以，当没有超时时，Current Index扫到的每一个slot的Set中应该都没有元素。&lt;/p&gt;
&lt;p&gt;两种方案对比：&lt;/p&gt;
&lt;p&gt;方案一每次都要轮询所有数据，而方案二使用环形队列只需要轮询这一刻需要过期的数据，如果没有数据过期则没有数据要处理，并且是批量超时，并且由于是环形结构更加节约空间，这很适合高性能场景。&lt;/p&gt;
&lt;p&gt;第二个问题：在开发过程中有延迟一定时间的任务要执行，怎么做？&lt;/p&gt;
&lt;p&gt;如果不重复造轮子的话，我们的选择当然是延迟队列或者Timer。&lt;/p&gt;
&lt;p&gt;延迟队列和在Timer中增 加延时任务采用数组表示的最小堆的数据结构实现，每次放入新元素和移除队首元素时间复杂度为O(nlog(n))。&lt;/p&gt;
&lt;h1&gt;时间轮&lt;/h1&gt;
&lt;p&gt;方案二所采用的环形队列，就是时间轮的底层数据结构，它能够让需要处理的数据（任务的抽象）集中，在Kafka中存在大量的延迟操作，比如延迟生产、延迟拉取以及延迟删除等。Kafka并没有使用JDK自带的Timer或者DelayQueue来实现延迟的功能，而是基于时间轮自定义了一个用于实现延迟功能的定时器（SystemTimer）。JDK的Timer和DelayQueue插入和删除操作的平均时间复杂度为O(nlog(n))，并不能满足Kafka的高性能要求，而基于时间轮可以将插入和删除操作的时间复杂度都降为O(1)。时间轮的应用并非Kafka独有，其应用场景还有很多，在Netty、Akka、Quartz、Zookeeper等组件中都存在时间轮的踪影。&lt;/p&gt;
&lt;h2&gt;时间轮的数据结构&lt;/h2&gt;
&lt;p&gt;参考下图，Kafka中的时间轮（TimingWheel）是一个存储定时任务的环形队列，底层采用数组实现，数组中的每个元素可以存放一个定时任务列表（TimerTaskList）。TimerTaskList是一个环形的双向链表，链表中的每一项表示的都是定时任务项（TimerTaskEntry），其中封装了真正的定时任务TimerTask。在Kafka源码中对这个TimeTaskList是用一个名称为buckets的数组表示的，所以后面介绍中可能TimerTaskList也会被称为bucket。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200308202645122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1poaVp1aUNodW5GZW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;时间轮组成&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;时间轮相关名词解释&lt;/h2&gt;
&lt;p&gt;tickMs：时间轮由多个时间格组成，每个时间格就是tickMs，它代表当前时间轮的基本时间跨度。&lt;/p&gt;
&lt;p&gt;wheelSize：代表每一层时间轮的格数&lt;/p&gt;
&lt;p&gt;interval：当前时间轮的总体时间跨度，interval=tickMs × wheelSize&lt;/p&gt;
&lt;p&gt;startMs：构造当层时间轮时候的当前时间，第一层的时间轮的startMs是TimeUnit.NANOSECONDS.toMillis(nanoseconds()),上层时间轮的startMs为下层时间轮的currentTime。&lt;/p&gt;
&lt;p&gt;currentTime：表示时间轮当前所处的时间，currentTime是tickMs的整数倍（通过currentTime=startMs - (startMs % tickMs来保正currentTime一定是tickMs的整数倍），这个运算类比钟表中分钟里65秒分针指针指向的还是1分钟）。currentTime可以将整个时间轮划分为到期部分和未到期部分，currentTime当前指向的时间格也属于到期部分，表示刚好到期，需要处理此时间格所对应的TimerTaskList的所有任务。&lt;/p&gt;
&lt;h2&gt;时间轮中的任务存放&lt;/h2&gt;
&lt;p&gt;若时间轮的tickMs=1ms，wheelSize=20，那么可以计算得出interval为20ms。初始情况下表盘指针currentTime指向时间格0，此时有一个定时为2ms的任务插入进来会存放到时间格为2的TimerTaskList中。随着时间的不断推移，指针currentTime不断向前推进，过了2ms之后，当到达时间格2时，就需要将时间格2所对应的TimeTaskList中的任务做相应的到期操作。此时若又有一个定时为8ms的任务插入进来，则会存放到时间格10中，currentTime再过8ms后会指向时间格10。如果同时有一个定时为19ms的任务插入进来怎么办？新来的TimerTaskEntry会复用原来的TimerTaskList，所以它会插入到原本已经到期的时间格1中。总之，整个时间轮的总体跨度是不变的，随着指针currentTime的不断推进，当前时间轮所能处理的时间段也在不断后移，总体时间范围在currentTime和currentTime+interval之间。&lt;/p&gt;
&lt;h2&gt;时间轮的升降级&lt;/h2&gt;
&lt;p&gt;如果此时有个定时为350ms的任务该如何处理？直接扩充wheelSize的大小么？Kafka中不乏几万甚至几十万毫秒的定时任务，这个wheelSize的扩充没有底线，就算将所有的定时任务的到期时间都设定一个上限，比如100万毫秒，那么这个wheelSize为100万毫秒的时间轮不仅占用很大的内存空间，而且效率也会拉低。Kafka为此引入了层级时间轮的概念，当任务的到期时间超过了当前时间轮所表示的时间范围时，就会尝试添加到上层时间轮中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200308202605415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1poaVp1aUNodW5GZW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;时间轮升降级&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考上图，复用之前的案例，第一层的时间轮tickMs=1ms, wheelSize=20, interval=20ms。第二层的时间轮的tickMs为第一层时间轮的interval，即为20ms。每一层时间轮的wheelSize是固定的，都是20，那么第二层的时间轮的总体时间跨度interval为400ms。以此类推，这个400ms也是第三层的tickMs的大小，第三层的时间轮的总体时间跨度为8000ms。&lt;br/&gt;
刚才提到的350ms的任务，不会插入到第一层时间轮，会插入到interval=20*20的第二层时间轮中，具体插入到时间轮的哪个bucket呢？先用350/tickMs(20)=virtualId(17)，然后virtualId(17) %wheelSize (20) = 17，所以350会放在第17个bucket。如果此时有一个450ms后执行的任务，那么会放在第三层时间轮中，按照刚才的计算公式，会放在第0个bucket。第0个bucket里会包含&lt;/p&gt;
&lt;p&gt;[400,800)ms的任务。随着时间流逝，当时间过去了400ms，那么450ms后就要执行的任务还剩下50ms的时间才能执行，此时有一个时间轮降级的操作，将50ms任务重新提交到层级时间轮中，那么此时50ms的任务根据公式会放入第二个时间轮的第2个bucket中，此bucket的时间范围为[40,60)ms，然后再经过40ms，这个50ms的任务又会被监控到，此时距离任务执行还有10ms，同样将10ms的任务提交到层级时间轮，此时会加入到第一层时间轮的第10个bucket，所以再经过10ms后，此任务到期，最终执行。&lt;/p&gt;
&lt;p&gt;整个时间轮的升级降级操作是不是很类似于我们的时钟？ 第一层时间轮tickMs=1s, wheelSize=60，interval=1min，此为秒钟；第二层tickMs=1min，wheelSize=60，interval=1hour，此为分钟；第三层tickMs=1hour，wheelSize为12，interval为12hours，此为时钟。而钟表的指针就对应程序中的currentTime，这个后面分析代码时候会讲到（对这个的理解也是时间轮理解的重点和难点）。&lt;/p&gt;
&lt;p&gt;Kafka中任务添加和驱动时间轮滚动的核心流程：&lt;br/&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/20200308202809831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1poaVp1aUNodW5GZW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;任务添加和驱动时间轮滚动核心流程图&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;重点代码介绍&lt;/h2&gt;
&lt;p&gt;这是往SystenTimer中添加一个任务&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//在Systemtimer中添加一个任务，任务被包装为一个TimerTaskEntry&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; def &lt;span class=&quot;hljs-title&quot;&gt;addTimerTaskEntry&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(timerTaskEntry: TimerTaskEntry)&lt;/span&gt;: Unit &lt;/span&gt;= {
&lt;span class=&quot;hljs-comment&quot;&gt;//先判断是否可以添加进时间轮中，如果不可以添加进去代表任务已经过期或者任务被取消，注意这里的timingWheel持有上一层时间轮的引用，所以可能存在递归调用&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!timingWheel.add(timerTaskEntry)) {
    &lt;span class=&quot;hljs-comment&quot;&gt;// Already expired or cancelled&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!timerTaskEntry.cancelled)
     &lt;span class=&quot;hljs-comment&quot;&gt;//过期任务直接线程池异步执行掉&lt;/span&gt;
      taskExecutor.submit(timerTaskEntry.timerTask)
  }
}
&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;p&gt;timingWheel添加任务，递归添加直到添加该任务进合适的时间轮的bucket中&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(timerTaskEntry: TimerTaskEntry)&lt;/span&gt;: Boolean &lt;/span&gt;= {
  val expiration = timerTaskEntry.expirationMs
  &lt;span class=&quot;hljs-comment&quot;&gt;//任务取消&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (timerTaskEntry.cancelled) {
    &lt;span class=&quot;hljs-comment&quot;&gt;// Cancelled&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;
  } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (expiration &amp;lt; currentTime + tickMs) {
    &lt;span class=&quot;hljs-comment&quot;&gt;// 任务过期后会被执行&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;
  } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (expiration &amp;lt; currentTime + interval) {&lt;span class=&quot;hljs-comment&quot;&gt;//任务过期时间比当前时间轮时间加周期小说明任务过期时间在本时间轮周期内&lt;/span&gt;
    val virtualId = expiration / tickMs
    &lt;span class=&quot;hljs-comment&quot;&gt;//找到任务对应本时间轮的bucket&lt;/span&gt;
    val bucket = buckets((virtualId % wheelSize.toLong).toInt)
    bucket.add(timerTaskEntry)
    &lt;span class=&quot;hljs-comment&quot;&gt;// Set the bucket expiration time&lt;/span&gt;
   &lt;span class=&quot;hljs-comment&quot;&gt;//只有本bucket内的任务都过期后才会bucket.setExpiration返回true此时将bucket放入延迟队列&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (bucket.setExpiration(virtualId * tickMs)) {
     &lt;span class=&quot;hljs-comment&quot;&gt;//bucket是一个TimerTaskList，它实现了java.util.concurrent.Delayed接口，里面是一个多任务组成的链表，图2有说明&lt;/span&gt;
      queue.offer(bucket)
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;
  } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;hljs-comment&quot;&gt;// Out of the interval. Put it into the parent timer&lt;/span&gt;
    &lt;span class=&quot;hljs-comment&quot;&gt;//任务的过期时间不在本时间轮周期内说明需要升级时间轮，如果不存在则构造上一层时间轮，继续用上一层时间轮添加任务&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (overflowWheel == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) addOverflowWheel()
    overflowWheel.add(timerTaskEntry)
  }
}

&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;p&gt;在本层级时间轮里添加上一层时间轮里的过程，注意的是在下一层时间轮的interval为上一层时间轮的tickMs&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;[&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;] &lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;addOverflowWheel&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;: Unit &lt;/span&gt;= {
  &lt;span class=&quot;hljs-keyword&quot;&gt;synchronized&lt;/span&gt; {
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (overflowWheel == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
      overflowWheel = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TimingWheel(
        tickMs = interval,
        wheelSize = wheelSize,
        startMs = currentTime,
        taskCounter = taskCounter,
        queue
      )
    }
  }
}
&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;p&gt;驱动时间轮滚动过程：&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//注意这里会存在一个递归，一直驱动时间轮的指针滚动直到时间不足于驱动上层的时间轮滚动。&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;advanceClock&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(timeMs: Long)&lt;/span&gt;: Unit &lt;/span&gt;= {
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (timeMs &amp;gt;= currentTime + tickMs) {
   &lt;span class=&quot;hljs-comment&quot;&gt;//把当前时间打平为时间轮tickMs的整数倍&lt;/span&gt;
    currentTime = timeMs - (timeMs % tickMs)
    &lt;span class=&quot;hljs-comment&quot;&gt;// Try to advance the clock of the overflow wheel if present&lt;/span&gt;
    &lt;span class=&quot;hljs-comment&quot;&gt;//驱动上层时间轮，这里的传给上层的currentTime时间是本层时间轮打平过的，但是在上层时间轮还是会继续打平&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (overflowWheel != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) overflowWheel.advanceClock(currentTime)
  }
}
&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;p&gt;这里是驱动源代码：&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//循环bucket里面的任务列表，一个个重新添加进时间轮，对符合条件的时间轮进行升降级或者执行任务&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;[&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;] val reinsert = (timerTaskEntry: TimerTaskEntry) =&amp;gt; addTimerTaskEntry(timerTaskEntry)
 
&lt;span class=&quot;hljs-comment&quot;&gt;/*
 * Advances the clock if there is an expired bucket. If there isn&#x27;t any expired bucket when called,
 * waits up to timeoutMs before giving up.
 */&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;advanceClock&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(timeoutMs: Long)&lt;/span&gt;: Boolean &lt;/span&gt;= {
  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; bucket = delayQueue.poll(timeoutMs, TimeUnit.MILLISECONDS)
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (bucket != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
    writeLock.lock()
    &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {
      &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (bucket != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;hljs-comment&quot;&gt;//驱动时间轮&lt;/span&gt;
        timingWheel.advanceClock(bucket.getExpiration())
       &lt;span class=&quot;hljs-comment&quot;&gt;//循环buckek也就是任务列表，任务列表一个个继续添加进时间轮以此来升级或者降级时间轮，把过期任务找出来执行&lt;/span&gt;
        bucket.flush(reinsert)
       &lt;span class=&quot;hljs-comment&quot;&gt;//循环&lt;/span&gt;
        &lt;span class=&quot;hljs-comment&quot;&gt;//这里就是从延迟队列取出bucket，bucket是有延迟时间的，取出代表该bucket过期，我们通过bucket能取到bucket包含的任务列表&lt;/span&gt;
        bucket = delayQueue.poll()
      }
    } &lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt; {
      writeLock.unlock()
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;
  } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;
  }
}
&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;kafka的延迟队列使用时间轮实现，能够支持大量任务的高效触发，但是在kafka延迟队列实现方案里还是看到了delayQueue的影子，使用delayQueue是对时间轮里面的bucket放入延迟队列，以此来推动时间轮滚动，但是基于将插入和删除操作则放入时间轮中，将这些操作的时间复杂度都降为O(1)，提升效率。Kafka对性能的极致追求让它把最合适的组件放在最适合的位置。&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>104d450b8279d6693d005611b075df60</guid>
<title>Unicode、UTF-8、UTF-16，终于懂了</title>
<link>https://toutiao.io/k/0lc2auk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-source-line=&quot;1&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;计算机起源于美国，上个世纪，他们对英语字符与二进制位之间的关系做了统一规定，并制定了一套字符编码规则，这套编码规则被称为ASCII编码&lt;/p&gt;&lt;p data-source-line=&quot;5&quot;&gt;ASCII 编码一共定义了128个字符的编码规则，用七位二进制表示 ( 0x00 - 0x7F ), 这些字符组成的集合就叫做 ASCII 字符集&lt;/p&gt;&lt;p data-source-line=&quot;8&quot;&gt;随着计算机的普及，在不同的地区和国家又出现了很多字符编码，比如: 大陆的 GB2312、港台的 BIG5, 日本的 Shift JIS等等&lt;/p&gt;&lt;p data-source-line=&quot;11&quot;&gt;由于字符编码不同，计算机在不同国家之间的交流变得很困难，经常会出现乱码的问题，比如：对于同一个二进制数据，不同的编码会解析出不同的字符&lt;/p&gt;&lt;p data-source-line=&quot;14&quot;&gt;当互联网迅猛发展，地域限制打破之后，人们迫切的希望有一种统一的规则, 对所有国家和地区的字符进行编码，于是 Unicode 就出现了&lt;/p&gt;&lt;h3 data-source-line=&quot;18&quot;&gt;&lt;span&gt;Unicode 简介&lt;/span&gt;&lt;/h3&gt;&lt;p data-source-line=&quot;20&quot;&gt;Unicode 是国际标准字符集，它将世界各种语言的每个字符定义一个唯一的编码，以满足跨语言、跨平台的文本信息转换&lt;/p&gt;&lt;p data-source-line=&quot;23&quot;&gt;Unicode 字符集的编码范围是 &lt;span&gt;&lt;span&gt;0x0000 - 0x10FFFF&lt;/span&gt;&lt;/span&gt; , 可以容纳一百多万个字符， 每个字符都有一个独一无二的编码，也即每个字符都有一个二进制数值和它对应，这里的二进制数值也叫 &lt;span&gt;&lt;span&gt;码点&lt;/span&gt;&lt;/span&gt; , 比如：汉字 &lt;span&gt;&lt;span&gt;&quot;中&quot;&lt;/span&gt;&lt;/span&gt; 的 码点是 &lt;span&gt;&lt;span&gt;0x4E2D&lt;/span&gt;&lt;/span&gt;, 大写字母 &lt;span&gt;&lt;span&gt;A&lt;/span&gt;&lt;/span&gt; 的码点是 &lt;span&gt;&lt;span&gt;0x41&lt;/span&gt;&lt;/span&gt;, 具体字符对应的 Unicode 编码可以查询 Unicode字符编码表&lt;/p&gt;&lt;h3 data-source-line=&quot;27&quot;&gt;&lt;span&gt;字符集和字符编码&lt;/span&gt;&lt;/h3&gt;&lt;p data-source-line=&quot;29&quot;&gt;字符集是很多个字符的集合，例如 GB2312 是简体中文的字符集，它收录了六千多个常用的简体汉字及一些符号，数字，拼音等字符&lt;/p&gt;&lt;p data-source-line=&quot;31&quot;&gt;字符编码是 字符集的一种实现方式，把字符集中的字符映射为特定的字节或字节序列，它是一种规则&lt;/p&gt;&lt;p data-source-line=&quot;33&quot;&gt;比如：Unicode 只是字符集，UTF-8、UTF-16、UTF-32 才是真正的字符编码规则&lt;/p&gt;&lt;h3 data-source-line=&quot;36&quot;&gt;&lt;span&gt;Unicode 字符存储&lt;/span&gt;&lt;/h3&gt;&lt;p data-source-line=&quot;38&quot;&gt;Unicode 是一个符号集， 它只规定了每个符号的二进制值，但是符号具体如何存储它并没有规定&lt;/p&gt;&lt;p data-source-line=&quot;40&quot;&gt;前面提到, Unicode 字符集的编码范围是 &lt;span&gt;&lt;span&gt;0x0000 - 0x10FFFF&lt;/span&gt;&lt;/span&gt;，因此需要 1 到 3 个字节来表示&lt;/p&gt;&lt;p data-source-line=&quot;42&quot;&gt;那么，对于三个字节的 Unicode字符，计算机怎么知道它表示的是一个字符而不是三个字符呢 ？&lt;/p&gt;&lt;p data-source-line=&quot;44&quot;&gt;如果所有字符都用三个字节表示，那么对于那些一个字节就能表示的字符来说，有两个字节是无意义的，对于存储来说，这是极大的浪费，假如 , 一个普通的文本, 大部分字符都只需一个字节就能表示，现在如果需要三个字节才能表示，文本的大小会大出三倍左右&lt;/p&gt;&lt;p data-source-line=&quot;47&quot;&gt;因此，Unicode 出现了多种存储方式，常见的有 UTF-8、UTF-16、UTF-32，它们分别用不同的二进制格式来表示 Unicode 字符&lt;/p&gt;&lt;p data-source-line=&quot;49&quot;&gt;UTF-8、UTF-16、UTF-32 中的 &quot;UTF&quot; 是 &quot;Unicode Transformation Format&quot; 的缩写，意思是&quot;Unicode 转换格式&quot;，后面的数 字表明至少使用多少个比特位来存储字符, 比如：UTF-8 最少需要8个比特位也就是一个字节来存储，对应的， UTF-16 和 UTF-32 分别需要最少 2 个字节 和 4 个字节来存储&lt;/p&gt;&lt;h3 data-source-line=&quot;54&quot;&gt;&lt;span&gt;UTF-8 编码&lt;/span&gt;&lt;/h3&gt;&lt;p data-source-line=&quot;56&quot;&gt;UTF-8: 是一种变长字符编码，被定义为将码点编码为 1 至 4 个字节，具体取决于码点数值中有效二进制位的数量&lt;/p&gt;&lt;p data-source-line=&quot;58&quot;&gt;UTF-8 的编码规则:&lt;/p&gt;&lt;ol start=&quot;0&quot; data-source-line=&quot;60&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;对于单字节的符号，字节的第一位设为 &lt;span&gt;&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;，后面 7 位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的, 所以 UTF-8 能兼容 ASCII 编码，这也是互联网普遍采用 UTF-8 的原因之一&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;2&quot; data-source-line=&quot;63&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;对于 &lt;span&gt;&lt;span&gt;n&lt;/span&gt;&lt;/span&gt; 字节的符号（ &lt;span&gt;&lt;span&gt;n &amp;gt; 1&lt;/span&gt;&lt;/span&gt;），第一个字节的前 &lt;span&gt;&lt;span&gt;n&lt;/span&gt;&lt;/span&gt; 位都设为 &lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;，第 &lt;span&gt;&lt;span&gt;n + 1&lt;/span&gt;&lt;/span&gt; 位设为 &lt;span&gt;&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;，后面字节的前两位一律设为 &lt;span&gt;&lt;span&gt;10&lt;/span&gt;&lt;/span&gt; 。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;66&quot;&gt;下表是Unicode编码对应UTF-8需要的字节数量以及编码格式&lt;/p&gt;&lt;table data-source-line=&quot;69&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Unicode编码范围(16进制)&lt;/th&gt;&lt;th&gt;UTF-8编码方式(二进制)&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;000000 - 00007F&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;xxxxxxx &lt;span&gt;ASCII码&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;000080 - 0007FF&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;110&lt;/span&gt;&lt;/span&gt;xxxxx &lt;span&gt;&lt;span&gt;10&lt;/span&gt;&lt;/span&gt;xxxxxx&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;000800 - 00FFFF&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;1110&lt;/span&gt;&lt;/span&gt;xxxx &lt;span&gt;&lt;span&gt;10&lt;/span&gt;&lt;/span&gt;xxxxxx &lt;span&gt;&lt;span&gt;10&lt;/span&gt;&lt;/span&gt;xxxxxx&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;01 0000 - 10 FFFF&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;11110&lt;/span&gt;&lt;/span&gt;xxx &lt;span&gt;&lt;span&gt;10&lt;/span&gt;&lt;/span&gt;xxxxxx &lt;span&gt;&lt;span&gt;10&lt;/span&gt;&lt;/span&gt;xxxxxx &lt;span&gt;&lt;span&gt;10&lt;/span&gt;&lt;/span&gt;xxxxxx&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-source-line=&quot;77&quot;&gt;表格中第一列是Unicode编码的范围，第二列是对应UTF-8编码方式，其中红色的二进制 &lt;span&gt;&lt;span&gt;&quot;1&quot;&lt;/span&gt;&lt;/span&gt; 和 &lt;span&gt;&lt;span&gt;&quot;0&quot;&lt;/span&gt;&lt;/span&gt; 是固定的前缀, 字母 &lt;span&gt;&lt;span&gt;x&lt;/span&gt;&lt;/span&gt; 表示可用编码的二进制位&lt;/p&gt;&lt;p data-source-line=&quot;79&quot;&gt;根据上面表格，要解析 UTF-8 编码就很简单了，如果一个字节第一位是 &lt;span&gt;&lt;span&gt;0&lt;/span&gt;&lt;/span&gt; ，则这个字节就是一个单独的字符，如果第一位是 &lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt; ，则连续有多少个 &lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt; ，就表示当前字符占用多少个字节&lt;/p&gt;&lt;p data-source-line=&quot;82&quot;&gt;下面以 &lt;span&gt;&lt;span&gt;&quot;中&quot;&lt;/span&gt;&lt;/span&gt; 字 为例来说明 UTF-8 的编码，具体的步骤如下图， 为了便于说明，图中左边加了 &lt;code&gt;1，2，3，4&lt;/code&gt; 的步骤编号&lt;/p&gt;&lt;p data-source-line=&quot;85&quot;&gt;&lt;img data-ratio=&quot;1.0956937799043063&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a2ibvjLwErmkErWEOtFlvP4ABPVvBhrNGYknEUy5xtyEZneBdn8hibGu6BsrIj6ncqRP3bJNAZhicyvWCqV16vxfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;836&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;88&quot;&gt;首先查询 &lt;span&gt;&lt;span&gt;&quot;中&quot;&lt;/span&gt;&lt;/span&gt; 字的 Unicode 码 &lt;span&gt;&lt;span&gt;0x4E2D&lt;/span&gt;&lt;/span&gt;, 转成二进制, 总共有 16 个二进制位， 具体如上图 步骤1 所示&lt;/p&gt;&lt;p data-source-line=&quot;90&quot;&gt;通过前面的 Unicode 编码和 UTF-8 编码的表格知道，Unicode 码 &lt;span&gt;&lt;span&gt;0x4E2D&lt;/span&gt;&lt;/span&gt; 对应 &lt;span&gt;&lt;span&gt;000800 - 00FFFF&lt;/span&gt;&lt;/span&gt; 的范围，所以, &lt;span&gt;&lt;span&gt;&quot;中&quot;&lt;/span&gt;&lt;/span&gt; 字的 UTF-8 编码 需要 &lt;span&gt;&lt;span&gt;3&lt;/span&gt;&lt;/span&gt; 个字节，即格式是 &lt;span&gt;&lt;span&gt;1110&lt;/span&gt;&lt;/span&gt;xxxx &lt;span&gt;&lt;span&gt;10&lt;/span&gt;&lt;/span&gt;xxxxxx &lt;span&gt;&lt;span&gt;10&lt;/span&gt;&lt;/span&gt;xxxxxx&lt;/p&gt;&lt;p data-source-line=&quot;92&quot;&gt;然后从 &lt;span&gt;&lt;span&gt;&quot;中&quot;&lt;/span&gt;&lt;/span&gt; 字的最后一个二进制位开始，按照从后向前的顺序依次填入格式中的 &lt;span&gt;&lt;span&gt;x&lt;/span&gt;&lt;/span&gt; 字符，多出的二进制补为 &lt;span&gt;&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;， 具体如上图 步骤2、步骤3 所示&lt;/p&gt;&lt;p data-source-line=&quot;94&quot;&gt;于是，就得到了 &lt;span&gt;&lt;span&gt;&quot;中&quot;&lt;/span&gt;&lt;/span&gt; 的 UTF-8 编码是 &lt;span&gt;&lt;span&gt;1110&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;0100&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;10&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;111000&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;10&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;101101&lt;/span&gt;&lt;/span&gt;, 转换成十六进制就是 &lt;span&gt;&lt;span&gt;0xE4B8AD&lt;/span&gt;&lt;/span&gt;， 具体如上图 步骤4 所示&lt;/p&gt;&lt;h3 data-source-line=&quot;98&quot;&gt;&lt;span&gt;UTF-16 编码&lt;/span&gt;&lt;/h3&gt;&lt;p data-source-line=&quot;100&quot;&gt;UTF-16 也是一种变长字符编码, 这种编码方式比较特殊, 它将字符编码成 2 字节 或者 4 字节&lt;/p&gt;&lt;p data-source-line=&quot;102&quot;&gt;具体的编码规则如下:&lt;/p&gt;&lt;ol start=&quot;0&quot; data-source-line=&quot;104&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;对于 Unicode 码小于 &lt;span&gt;&lt;span&gt;0x10000&lt;/span&gt;&lt;/span&gt; 的字符， 使用 &lt;span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/span&gt; 个字节存储，并且是直接存储 Unicode 码，不用进行编码转换&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;2&quot; data-source-line=&quot;107&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;对于 Unicode 码在 &lt;span&gt;&lt;span&gt;0x10000&lt;/span&gt;&lt;/span&gt; 和 &lt;span&gt;&lt;span&gt;0x10FFFF&lt;/span&gt;&lt;/span&gt; 之间的字符，使用 &lt;span&gt;&lt;span&gt;4&lt;/span&gt;&lt;/span&gt; 个字节存储，这 &lt;span&gt;&lt;span&gt;4&lt;/span&gt;&lt;/span&gt; 个字节分成前后两部分，每个部分各两个字节，其中，前面两个字节的前 &lt;span&gt;&lt;span&gt;6&lt;/span&gt;&lt;/span&gt; 位二进制固定为 &lt;span&gt;&lt;span&gt;110110&lt;/span&gt;&lt;/span&gt;，后面两个字节的前 6 位二进制固定为 &lt;span&gt;&lt;span&gt;110111&lt;/span&gt;&lt;/span&gt;, 前后部分各剩余 10 位二进制表示符号的 Unicode 码 减去 &lt;span&gt;&lt;span&gt;0x10000&lt;/span&gt;&lt;/span&gt; 的结果&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;3&quot; data-source-line=&quot;110&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;大于 &lt;span&gt;&lt;span&gt;0x10FFFF&lt;/span&gt;&lt;/span&gt; 的 Unicode 码无法用 UTF-16 编码&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;113&quot;&gt;下表是Unicode编码对应UTF-16编码格式&lt;/p&gt;&lt;table data-source-line=&quot;116&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Unicode编码范围(16进制)&lt;/th&gt;&lt;th&gt;具体Unicode码(二进制)&lt;/th&gt;&lt;th&gt;UTF-16编码方式(二进制)&lt;/th&gt;&lt;th&gt;字节&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;0000 0000 - 0000 FFFF&lt;/td&gt;&lt;td&gt;xxxxxxxx xxxxxxxx&lt;/td&gt;&lt;td&gt;xxxxxxxx xxxxxxxx&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0001 0000 - 0010 FFFF&lt;/td&gt;&lt;td&gt;yy yyyyyyyy xx xxxxxxxx&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;110110&lt;/span&gt;&lt;/span&gt;yy yyyyyyyy &lt;span&gt;&lt;span&gt;110111&lt;/span&gt;&lt;/span&gt;xx xxxxxxxx&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-source-line=&quot;122&quot;&gt;表格中第一列是Unicode编码的范围，第二列是 具体Unicode码的二进制 ( 第二行的第二列表示的是 Unicode 码 减去 &lt;span&gt;&lt;span&gt;0x10000&lt;/span&gt;&lt;/span&gt; 后的二进制 ) , 第三列是对应UTF-16编码方式，其中红色的二进制 &lt;span&gt;&lt;span&gt;&quot;1&quot;&lt;/span&gt;&lt;/span&gt; 和 &lt;span&gt;&lt;span&gt;&quot;0&quot;&lt;/span&gt;&lt;/span&gt; 是固定的前缀, 字母 &lt;span&gt;&lt;span&gt;x&lt;/span&gt;&lt;/span&gt; 和 &lt;span&gt;&lt;span&gt;y&lt;/span&gt;&lt;/span&gt; 表示可用编码的二进制位， 第四列表示 编码占用的字节数&lt;/p&gt;&lt;p data-source-line=&quot;124&quot;&gt;前面提到过，&lt;span&gt;&lt;span&gt;&quot;中&quot;&lt;/span&gt;&lt;/span&gt; 字的 Unicode 码是 &lt;span&gt;&lt;span&gt;4E2D&lt;/span&gt;&lt;/span&gt;, 它小于 &lt;span&gt;&lt;span&gt;0x10000&lt;/span&gt;&lt;/span&gt;，根据表格可知，它的 UTF-16 编码占两个字节，并且和 Unicode 码相同，所以 &lt;span&gt;&lt;span&gt;&quot;中&quot;&lt;/span&gt;&lt;/span&gt; 字的 UTF-16 编码为 &lt;span&gt;&lt;span&gt;4E2D&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;126&quot;&gt;我从 Unicode字符表网站 找了一个老的南阿拉伯字母, 它的 Unicode 码是: &lt;span&gt;&lt;span&gt;0x10A6F&lt;/span&gt;&lt;/span&gt; , 可以访问 https://unicode-table.com/cn/10A6F/ 查看字符的说明, Unicode 码对应的字符如下图所示&lt;/p&gt;&lt;p data-source-line=&quot;128&quot;&gt;&lt;img data-ratio=&quot;0.4365781710914454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a2ibvjLwErmkErWEOtFlvP4ABPVvBhrNGbGnG7HtFuZSWfhG1iauGWr1icVq2UuWPJEIDKaBOWscqiayf91FFQ6CfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;678&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;131&quot;&gt;下面以这个 老的南阿拉伯字母的 Unicode 码 &lt;span&gt;&lt;span&gt;0x10A6F&lt;/span&gt;&lt;/span&gt; 为例来说明 UTF-16 &lt;span&gt;&lt;span&gt;4&lt;/span&gt;&lt;/span&gt; 字节的编码，具体步骤如下，为了便于说明，图中左边加了 &lt;code&gt;1，2，3，4 、5&lt;/code&gt;的步骤编号&lt;/p&gt;&lt;p data-source-line=&quot;133&quot;&gt;&lt;img data-ratio=&quot;0.9486921529175051&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/a2ibvjLwErmkErWEOtFlvP4ABPVvBhrNG7DxqFrCmfpmDnadC5kAWsbcDHSWQhkNtOJ3Vicxicq2TWuGPMl7O5Zibw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;994&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;136&quot;&gt;首先把 Unicode 码 &lt;span&gt;&lt;span&gt;0x10A6F&lt;/span&gt;&lt;/span&gt; 转成二进制, 对应上图的 步骤 1&lt;/p&gt;&lt;p data-source-line=&quot;138&quot;&gt;然后把 Unicode 码 &lt;span&gt;&lt;span&gt;0x10A6F&lt;/span&gt;&lt;/span&gt; 减去 &lt;span&gt;&lt;span&gt;0x10000&lt;/span&gt;&lt;/span&gt;, 结果为 &lt;span&gt;&lt;span&gt;0xA6F&lt;/span&gt;&lt;/span&gt; 并把这个值转成二进制 &lt;span&gt;&lt;span&gt;00 00000010&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;10 01101111&lt;/span&gt;&lt;/span&gt;，对应上图的 步骤 2&lt;/p&gt;&lt;p data-source-line=&quot;140&quot;&gt;然后 从二进制 &lt;span&gt;&lt;span&gt;00 00000010&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;10 01101111&lt;/span&gt;&lt;/span&gt; 的最后一个二进制为开始，按照从后向前的顺序依次填入格式中的 &lt;span&gt;&lt;span&gt;x&lt;/span&gt;&lt;/span&gt; 和 &lt;span&gt;&lt;span&gt;y&lt;/span&gt;&lt;/span&gt; 字符，多出的二进制补为 &lt;span&gt;&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;， 对应上图的 步骤 3、 步骤 4&lt;/p&gt;&lt;p data-source-line=&quot;143&quot;&gt;于是，就计算出了 Unicode 码 &lt;span&gt;&lt;span&gt;0x10A6F&lt;/span&gt;&lt;/span&gt; 的 UTF-16 编码是 &lt;span&gt;&lt;span&gt;110110&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;00 00000010&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;110111&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;10 01101111&lt;/span&gt;&lt;/span&gt; , 转换成十六进制就是 &lt;span&gt;&lt;span&gt;0xD802DE6F&lt;/span&gt;&lt;/span&gt;， 对应上图的 步骤 5&lt;/p&gt;&lt;h3 data-source-line=&quot;146&quot;&gt;&lt;span&gt;UTF-32 编码&lt;/span&gt;&lt;/h3&gt;&lt;p data-source-line=&quot;148&quot;&gt;UTF-32 是固定长度的编码，始终占用 4 个字节，足以容纳所有的 Unicode 字符，所以直接存储 Unicode 码即可，不需要任何编码转换。虽然浪费了空间，但提高了效率。&lt;/p&gt;&lt;h3 data-source-line=&quot;151&quot;&gt;&lt;span&gt;UTF-8、UTF-16、UTF-32 之间如何转换&lt;/span&gt;&lt;/h3&gt;&lt;p data-source-line=&quot;154&quot;&gt;前面介绍过，UTF-8、UTF-16、UTF-32 是 Unicode 码表示成不同的二进制格式的编码规则，同样，通过这三种编码的二进制表示，也能获得对应的 Unicode 码，有了字符的 Unicode 码，按照上面介绍的 UTF-8、UTF-16、UTF-32 的编码方法 就能转换成任一种编码了&lt;/p&gt;&lt;h3 data-source-line=&quot;157&quot;&gt;&lt;span&gt;UTF 字节序&lt;/span&gt;&lt;/h3&gt;&lt;p data-source-line=&quot;160&quot;&gt;最小编码单元是多字节才会有字节序的问题存在，UTF-8 最小编码单元是一字节，所以 它是没有字节序的问题，UTF-16 最小编码单元是 2 个字节，在解析一个 UTF-16 字符之前，需要知道每个编码单元的字节序&lt;/p&gt;&lt;p data-source-line=&quot;162&quot;&gt;比如：前面提到过，&lt;span&gt;&lt;span&gt;&quot;中&quot;&lt;/span&gt;&lt;/span&gt; 字的 Unicode 码是 &lt;span&gt;&lt;span&gt;4E2D&lt;/span&gt;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;&quot;ⵎ&quot;&lt;/span&gt;&lt;/span&gt; 字符的 Unicode 码是 &lt;span&gt;&lt;span&gt;2D4E&lt;/span&gt;&lt;/span&gt;， 当我们收到一个 UTF-16 字节流 &lt;span&gt;&lt;span&gt;4E2D&lt;/span&gt;&lt;/span&gt; 时，计算机如何识别它表示的是字符 &lt;span&gt;&lt;span&gt;&quot;中&quot;&lt;/span&gt;&lt;/span&gt; 还是 字符 &lt;span&gt;&lt;span&gt;&quot;ⵎ&quot;&lt;/span&gt;&lt;/span&gt; 呢 ?&lt;/p&gt;&lt;p data-source-line=&quot;165&quot;&gt;所以，对于多字节的编码单元，需要有一个标记显式的告诉计算机，按照什么样的顺序解析字符，也就是字节序，字节序分为 大端字节序 和 小端字节序&lt;/p&gt;&lt;p data-source-line=&quot;168&quot;&gt;小端字节序简写为 LE( Little-Endian ), 表示 低位字节在前，高位字节在后, 高位字节保存在内存的高地址端，而低位字节保存在内存的低地址端&lt;/p&gt;&lt;p data-source-line=&quot;171&quot;&gt;大端字节序简写为 BE( Big-Endian ), 表示 高位字节在前，低位字节在后，高位字节保存在内存的低地址端，低位字节保存在在内存的高地址端&lt;/p&gt;&lt;p data-source-line=&quot;173&quot;&gt;下面以 &lt;span&gt;&lt;span&gt;0x4E2D&lt;/span&gt;&lt;/span&gt; 为例来说明大端和小端，具体参见下图:&lt;/p&gt;&lt;p data-source-line=&quot;175&quot;&gt;&lt;img data-ratio=&quot;0.4934210526315789&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a2ibvjLwErmkErWEOtFlvP4ABPVvBhrNGs5cnWSD9YjP1ic2GiaEbAlFJbQudqM60jyOSMRKmYXbeG2UPS1PXBB8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;912&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;177&quot;&gt;数据是从高位字节到低位字节显示的，这也更符合人们阅读数据的习惯，而内存地址是从低地址向高地址增加&lt;/p&gt;&lt;p data-source-line=&quot;179&quot;&gt;所以，字符&lt;span&gt;&lt;span&gt;0x4E2D&lt;/span&gt;&lt;/span&gt; 数据的高位字节是 &lt;span&gt;&lt;span&gt;4E&lt;/span&gt;&lt;/span&gt;，低位字节是 &lt;span&gt;&lt;span&gt;2D&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;181&quot;&gt;按照大端字节序的高位字节保存内存低地址端的规则，&lt;span&gt;&lt;span&gt;4E&lt;/span&gt;&lt;/span&gt; 保存到低内存地址 &lt;span&gt;&lt;span&gt;0x10001&lt;/span&gt;&lt;/span&gt; 上，&lt;span&gt;&lt;span&gt;2D&lt;/span&gt;&lt;/span&gt; 则保存到高内存地址 &lt;span&gt;&lt;span&gt;0x10002&lt;/span&gt;&lt;/span&gt; 上&lt;/p&gt;&lt;p data-source-line=&quot;183&quot;&gt;对于小端字节序，则正好相反，数据的高位字节保存到内存的高地址端，低位字节保存到内存低地址端的，所以 &lt;span&gt;&lt;span&gt;4E&lt;/span&gt;&lt;/span&gt; 保存到高内存地址 &lt;span&gt;&lt;span&gt;0x10002&lt;/span&gt;&lt;/span&gt; 上，&lt;span&gt;&lt;span&gt;2D&lt;/span&gt;&lt;/span&gt; 则保存到低内存地址 &lt;span&gt;&lt;span&gt;0x10001&lt;/span&gt;&lt;/span&gt; 上&lt;/p&gt;&lt;h3 data-source-line=&quot;185&quot;&gt;&lt;span&gt;BOM&lt;/span&gt;&lt;/h3&gt;&lt;p data-source-line=&quot;187&quot;&gt;BOM 是 byte-order mark 的缩写，是 &quot;字节序标记&quot; 的意思, 它常被用来当做标识文件是以 UTF-8、UTF-16 或 UTF-32 编码的标记&lt;/p&gt;&lt;p data-source-line=&quot;189&quot;&gt;在 Unicode 编码中有一个叫做 &quot;零宽度非换行空格&quot; 的字符 ( ZERO WIDTH NO-BREAK SPACE ), 用字符 &lt;span&gt;&lt;span&gt;FEFF&lt;/span&gt;&lt;/span&gt; 来表示&lt;/p&gt;&lt;p data-source-line=&quot;191&quot;&gt;对于 UTF-16 ，如果接收到以 &lt;span&gt;&lt;span&gt;FE&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;FF&lt;/span&gt;&lt;/span&gt; 开头的字节流， 就表明是大端字节序，如果接收到 &lt;span&gt;&lt;span&gt;FF&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;FE&lt;/span&gt;&lt;/span&gt;， 就表明字节流 是小端字节序&lt;/p&gt;&lt;p data-source-line=&quot;193&quot;&gt;UTF-8 没有字节序问题，上述字符只是用来标识它是 UTF-8 文件，而不是用来说明字节顺序的。&quot;零宽度非换行空格&quot; 字符 的 UTF-8 编码是 &lt;span&gt;&lt;span&gt;EF BB BF&lt;/span&gt;&lt;/span&gt;, 所以如果接收到以 &lt;span&gt;&lt;span&gt;EF BB BF&lt;/span&gt;&lt;/span&gt; 开头的字节流，就知道这是UTF-8 文件&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-source-line=&quot;197&quot;&gt;下面的表格列出了不同 UTF 格式的固定文件头&lt;/p&gt;&lt;table data-source-line=&quot;199&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;UTF编码&lt;/th&gt;&lt;th&gt;固定文件头&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;UTF-8&lt;/td&gt;&lt;td&gt;EF BB BF&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;UTF-16LE&lt;/td&gt;&lt;td&gt;FF FE&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;UTF-16BE&lt;/td&gt;&lt;td&gt;FE FF&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;UTF-32LE&lt;/td&gt;&lt;td&gt;FF FE 00 00&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;UTF-32BE&lt;/td&gt;&lt;td&gt;00 00 FE FF&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-source-line=&quot;209&quot;&gt;根据上面的 固定文件头，下面列出了 &lt;span&gt;&lt;span&gt;&quot;中&quot;&lt;/span&gt;&lt;/span&gt; 字在文件中的存储 ( 包含文件头 )&lt;/p&gt;&lt;table data-source-line=&quot;213&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;编码&lt;/th&gt;&lt;th&gt;固定文件头&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Unicode 编码&lt;/span&gt;&lt;/td&gt;&lt;td&gt;0X004E2D&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;EF BB BF&lt;/span&gt;&lt;/span&gt; 4E 2D&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;UTF-16BE&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;FE FF&lt;/span&gt;&lt;/span&gt; 4E 2D&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;UTF-16LE&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;FF FE&lt;/span&gt;&lt;/span&gt; 2D 4E&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;UTF-32BE&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;00 00 FE FF&lt;/span&gt;&lt;/span&gt; 00 00 4E 2D&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;UTF-32LE&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;FF FE 00 00&lt;/span&gt;&lt;/span&gt; 2D 4E 00 00&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 data-source-line=&quot;223&quot;&gt;&lt;span&gt;常见的字符编码的问题&lt;/span&gt;&lt;/h3&gt;&lt;p data-source-line=&quot;228&quot;&gt;有时候我们需要向redis中写入含有中文的数据，然后在查看数据，但是会看到一些其他的字符，而不是我们写入的中文&lt;/p&gt;&lt;p data-source-line=&quot;230&quot;&gt;&lt;img data-ratio=&quot;0.24173027989821882&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a2ibvjLwErmkErWEOtFlvP4ABPVvBhrNG2VoHpfMog6Lq5q2CJ7NTaPD9iaP4hYANmSdtgC9VuBltFBN3UHAd0AA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;393&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;233&quot;&gt;上图中，我们向redis 写入了一个 &quot;中&quot; 字，通过 get 命令查看的时候无法显示我们写入的 &quot;中&quot; 字&lt;/p&gt;&lt;p data-source-line=&quot;236&quot;&gt;这时候加一个 --raw 参数，重新启动 redis-cli 即可，也即 执行 redis-cli --raw 命令启动redis客户端，具体的如下图所示&lt;/p&gt;&lt;p data-source-line=&quot;238&quot;&gt;&lt;img data-ratio=&quot;0.2945054945054945&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a2ibvjLwErmkErWEOtFlvP4ABPVvBhrNGTlf9CGHbBXycOp5H6eqjlibUAayjzAMTiceRSyMjtI5b9nqSmHXwW8cA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;455&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;244&quot;&gt;MySQL 中的 &quot;utf8&quot; 实际上不是真正的 UTF-8， &quot;utf8&quot; 只支持每个字符最多 3 个字节, 对于超过 3 个字节的字符就会出错, 而真正的 UTF-8 至少要支持 4 个字节&lt;/p&gt;&lt;p data-source-line=&quot;246&quot;&gt;MySQL 中的 &quot;utf8mb4&quot; 才是真正的 UTF-8&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;下面以 test 表为例来说明, 表结构如下:&lt;/span&gt;&lt;/p&gt;&lt;pre data-source-line=&quot;251&quot;&gt;&lt;code&gt;mysql&amp;gt; show create table test\G&lt;br/&gt;*************************** 1. row ***************************&lt;br/&gt;       Table: test&lt;br/&gt;Create Table: CREATE TABLE `test` (&lt;br/&gt;  `name` char(32) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;br/&gt;) &lt;span&gt;ENGINE&lt;/span&gt;=InnoDB&lt;span&gt; DEFAULT &lt;/span&gt;&lt;span&gt;CHARSET&lt;/span&gt;=utf8&lt;br/&gt;1 row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.00 sec)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;261&quot;&gt;向 &lt;code&gt;test&lt;/code&gt; 表分别插入 &lt;span&gt;&lt;span&gt;&quot;中&quot;&lt;/span&gt;&lt;/span&gt; 字 和 Unicode 码为 &lt;span&gt;&lt;span&gt;0x10A6F&lt;/span&gt;&lt;/span&gt; 的字符，这个字符需要从 https://unicode-table.com/cn/10A6F/ 直接复制到 MySQL 控制台上，手工输入会无效，具体的执行结果如下图:&lt;/p&gt;&lt;p data-source-line=&quot;263&quot;&gt;&lt;img data-ratio=&quot;0.11929170549860205&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a2ibvjLwErmkErWEOtFlvP4ABPVvBhrNGSZoaIwDZrzs8WllZibfC7OJgoa8bpZsXaNloQMgUPBRPH1sok3sa3MA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1073&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;266&quot;&gt;从上图可以看出，插入 &lt;span&gt;&lt;span&gt;&quot;中&quot;&lt;/span&gt;&lt;/span&gt; 字 成功，插入 &lt;span&gt;&lt;span&gt;0x10A6F&lt;/span&gt;&lt;/span&gt; 字符失败，错误提示无效的字符串，&lt;span&gt;&lt;span&gt;\xF0\X90\XA9\xAF&lt;/span&gt;&lt;/span&gt; 正是 &lt;span&gt;&lt;span&gt;0x10A6F&lt;/span&gt;&lt;/span&gt; 字符的 UTF-8 编码，占用 &lt;span&gt;&lt;span&gt;4&lt;/span&gt;&lt;/span&gt; 个字节, 因为 MySQL 的 utf8 编码最多只支持 &lt;span&gt;&lt;span&gt;3&lt;/span&gt;&lt;/span&gt; 个字节，所以插入会失败&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-source-line=&quot;270&quot;&gt;把 &lt;code&gt;test&lt;/code&gt; 表的字符集改成 &lt;code&gt;utf8mb4&lt;/code&gt; , 排序规则 改成 &lt;code&gt;utf8bm4_unicode_ci&lt;/code&gt;, 具体如下图所示：&lt;/p&gt;&lt;p data-source-line=&quot;272&quot;&gt;&lt;img data-ratio=&quot;0.245697896749522&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a2ibvjLwErmkErWEOtFlvP4ABPVvBhrNGndFwD1A441vhc8vyxgXJObiat3ueda7LcniaAxegjnLZTJF3l9vibicRdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1046&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-source-line=&quot;276&quot;&gt;字符集和排序方式修改之后，再次插入 &lt;span&gt;&lt;span&gt;0x10A6F&lt;/span&gt;&lt;/span&gt; 字符， 结果是成功的，具体执行结果如下图所示&lt;/p&gt;&lt;p data-source-line=&quot;279&quot;&gt;&lt;img data-ratio=&quot;0.2177293934681182&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a2ibvjLwErmkErWEOtFlvP4ABPVvBhrNGQrAqzshHPric9F3wqHmxGKskwF99ClscjkmgNmAiahWr1iaia2UznLz5MA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;643&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;281&quot;&gt;上图中，&lt;code&gt;set names utf8mb4&lt;/code&gt; 是为了测试方便，临时修改当前会话的字符集，以便保持和 服务器一致，实际解决这个问题需要修改 &lt;code&gt;my.cnf&lt;/code&gt; 配置中 服务器和客户端的字符集&lt;/p&gt;&lt;h3 data-source-line=&quot;285&quot;&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h3&gt;&lt;p data-source-line=&quot;287&quot;&gt;本文从字符编码的历史介绍了 Unicode 出现的原因，接着介绍了 Unicode 字符集中 三种不同的编码方式：UTF-8、UTF-16、UTF-32 以及它们的的编码方法，紧接着介绍了 字节序、BOM ，最后讲到了字符集在 MySQL 和 Redis 应用中常见的问题以及解决方案 ，更多关于 Unicode 的介绍请参考 Unicode 的 RFC 文档。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjEyNTA5Mw==&amp;amp;mid=2652578336&amp;amp;idx=1&amp;amp;sn=d162ea976f912dfc7d3e036715731b69&amp;amp;chksm=84650a6ab312837c7c50268cdfe6c19c7f4c2fe7c590f8f2cfa548bde543ccb8bd34d7d2e476&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;工程师在工作电脑存 64G 不雅文件，被公司开除后索赔 41 万，结果…&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjEyNTA5Mw==&amp;amp;mid=2652578331&amp;amp;idx=1&amp;amp;sn=78d9095af3f05256e31d6a678887245a&amp;amp;chksm=84650a51b312834767e5eda3bba3c798c61dff3ef388ce48fed15730c895bc018f9a0eee2364&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;腾讯最大股东收购了 Stack Overflow，以后“抄代码”都要付费了么？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjEyNTA5Mw==&amp;amp;mid=2652578284&amp;amp;idx=1&amp;amp;sn=59a5df31be4dd5cec0e795e7ee7dfd5b&amp;amp;chksm=846509a6b31280b08e9bd8621db60f4afabb1cc033c6491efb1cdb28f201be4c9922bee910ef&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;2.3 万 Star！直追微软 Visio，这个简洁实用的在线绘图工具必须推荐给你&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;觉得本文对你有帮助？请分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;推荐关注「Python开发者」，提升Python技能&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA4MjEyNTA5Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/fhujzoQe7TpvdeLibiaAmU69kV0SyJIicdHKNjs7Cj55MMnHdNdX7mLRzmODUgfYTIb6pQXe10QcibSsPpHib7Ap7rw/0?wx_fmt=png&quot; data-nickname=&quot;Python开发者&quot; data-alias=&quot;PythonCoder&quot; data-signature=&quot;点击获取精选Python开发资源。「Python开发者」日常分享 Python 相关的技术文章、实用案例、工具资源、精选课程、热点资讯等。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1a7042456df2dd7be4f4a3c2fd526ded</guid>
<title>Elasticsearch 架构选型指南：不止是搜索引擎，还有......</title>
<link>https://toutiao.io/k/j0yifcz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近被咨询到“ETC 卡口数据的存储以及车流量分析、车路线分析业务场景是否适合 Elasticsearch 去做”的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题涉及 Elasticsearch 架构选型的问题，而追根究底是：Elasticsearch 适合的业务场景的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记得我在做内部技术分享的时候，讲解 Elasticsearch 应用场景，就铺了3 页 PPT：搜索服务场景、日志实时分析场景、商业智能 BI 场景。我拿着初稿找同事讨论，我心想：“没毛病啊？！Elastic 官方、阿里云、腾讯云、金山云、京东云、百度云等介绍 Elasticsearch 都是这么说的。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同事一句话点醒了我：“是不是应该加上 Elasticsearch 不适合做什么？”，“我大呼：搜戴斯乃（原来如此）”。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、Elasticsearch 不适合做什么？&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1 不支持事务&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不支持：ACID（在写入或更新数据的过程中，为保证事务（transaction）是正确可靠的，所必须具备的四个特性：原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability））。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要有强一致场景，如：银行业务，还得采购 Oracle 等大型商业数据库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;据我不完整了解：银行使用 Elasticsearch 一般和系统日志统一规范、存储和检索、自动化运维相关，而非存储核心金融交易数据。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2 多表关联有限&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为习惯了：Mysql 多表通过外键关联检索，不免会将 Mysql 思维平移到 Elasticsearch。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的实战多表关联问题如下：“
一般大in的场景有好的解决方案么？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;比如：连锁 一个人管理了1000家门店 要去查自己管辖的商品。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;比如：企微 一个人维护了 1000个员工 要去查自己管辖的员工。”&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Elasticsearch 多表关联的解决方案一般概括如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;宽表：适合增加冗余存储、空间换时间场景。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;nested 类型：适合子文档偶尔更新、查询频繁场景。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Join 父子文档类型：适合子文档频繁更新频繁场景。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如官方文档所说：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“In particular, joins should be avoided. nested can make queries several times slower and parent-child relations can make queries hundreds of times slower.  ”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方在数据建模部分强调：“应该避免关联。嵌套可以使查询速度慢几倍，父子关系可以使查询速度慢数百倍。因此，若能使用宽表，可以明显加速。”&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3 不支持准实时&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;refresh_interval 刷新频率决定近实时而非准实时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;腾讯云黄华老师的分享《腾讯Elasticsearch海量规模背后的内核优化剖析》中强调：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“ES 是一个实时的分布式搜索分析引擎，目前很多用户对 ES 的印象还是准实时，实际上在6.8版本之后官方文档已经将 near real-time 改为了 real-time”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们直接看一下6.8版本——7.6版本官方文档的说法，的确如黄老师所说：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&quot;Elasticsearch provides real-time search and analytics for all types of data.&quot;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ES 在写入完毕刷新之前，是可以通过 getById 的方式实时获取文档的，只是在刷新之前 FST 还没有构建，还不能提供搜索的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，7.7版本——7.13版本（截止：2021-06-17最新版本）又改成：“Elasticsearch provides &lt;span&gt;&lt;strong&gt;&lt;span&gt;near&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; real-time search and analytics for all types of data. ”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再一次改回原来的说法，说明：官方文档严谨性拿捏的很到位！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;近实时而非准实时说法没毛病。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7.13 版本官方文档地址：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://www.elastic.co/guide/en/elasticsearch/reference/7.13/elasticsearch-intro.html#elasticsearch-intro&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.4 高阶功能收费&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：机器学习、Kerberos 安全认证、JDBC 客户端、ODBC客户端、Graph 探索、威胁猎捕等高阶功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是主流开源上市公司的收费模式，MongoDB、Confluent、Elastic 皆是如此。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开源版、基础版、黄金版、白金版、企业版的区别和差异，查看地址（要做到必知必会）：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://www.elastic.co/cn/subscriptions&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、Elasticsearch 认知升级&lt;/span&gt;&lt;/h1&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 Elasticsearch 早已不仅是搜索引擎了&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2418230563002681&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9ZcNaUFJicbnBibErEsESYE1DU8Dx0xArHVA7eJNazNror4sLKr8udMbnvXHZQ6M5Tbqj8z5RbuC0UQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1865&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以 Elasticsearch 起家，发展到：集成 Elasticsearch、Logstash、Beats、Kibana 四位一体的“全家桶”。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Elasticsearch：搜索和分析引擎。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Logstash：数据处理管道，能够同时从多个来源采集数据，转换数据，然后将数据发送到诸如 Elasticsearch 等“存储库”中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Beats：一系列轻量型的单一功能数据采集器（包含：Metricbeat、Filebeat等100多种）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kibana ：使用图形和图表对Elasticsearch数据进行可视化和探索分析。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 Elasticsearch 早已不单单局限搜索场景&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Elasticsearch 发展战略也在随&lt;span&gt;势&lt;/span&gt;而变。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6293103448275862&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9ZcNaUFJicbnBibErEsESYE1D6icbh5scF8qyNsBgH0n1jDW0KsL3icVNIfa9hs0licYBFQGnCh5jf1hibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1044&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“3 + 1战略”——是指在Elastic Stack 基础上在Elastic 企业搜索、Elastic 全观察、Elastic 安全三个核心业务场景发力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Elastic 已经由原来的 Elasticsearch 检索工具转变为 Elastic Stack 解决方案提供商。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://www.elastic.co/cn/products/&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3、Elasticsearch 业务场景&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是建议过一下官方文档关于 “ &lt;span&gt;What is Elasticsearch ? &lt;/span&gt;”的介绍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要强调的点如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;slogon 加了分析：由原来的“You know, for search” 改成 “You know, for search (&lt;span&gt;&lt;strong&gt;&lt;span&gt;and analysis&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;)”。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Elasticsearch 是位于 Elastic Stack 核心的分布式搜索和分析引擎。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Elasticsearch 为所有类型的数据提供高效存储和索引、近乎实时的搜索和分析。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有都指哪些？主要指：结构化文本、非结构化文本、数值数据、地理空间数据等。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Elasticsearch 的分布式特性、横向扩展能力可以应对数据、查询量的增长。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Elasticsearch 提供了在各种用例中处理数据的速度和灵活性，尽管并非所有问题都是搜索问题。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方明确点出的几种场景总结如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（1）支持各类应用、网站等的全文搜索。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（2）存储和分析日志、指标和安全事件数据。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（3）使用机器学习实时自动建模数据的行为。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（4）使用 Elasticsearch 作为存储引擎自动化业务工作流。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（5）使用 Elasticsearch 作为地理信息系统 (GIS) 管理、集成和分析空间信息。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我也不免俗，将开头提及的：搜索服务场景、日志实时分析 场景、商业智能 BI 场景以截图的形式提供给大家，更直观一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下三页 PPT 截图是基于腾讯云的分享结合了：官方文档、各大云厂商介绍结合我的理解进行了整合梳理。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 场景1：搜索服务&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1.1 典型场景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1.2 主要特性&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;高性能：高并发、低延迟的搜索体验&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;强相关：自定义打分、排序机制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高可用：机房、机架感知，异地容灾&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1.3 相关公司&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;腾讯健康码、腾讯文档全文检索、携程、拼多多、蘑菇街、滴滴、今日头条、贝壳找房…….&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5484546883184913&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9ZcNaUFJicbnBibErEsESYE1DA1Qibc3JxrE5TgNoklzfpIRNicuQI5bDmqaEAAicS1NnaxohoAuvIR4qw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1909&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2 场景2：日志实时分析&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2.1 典型场景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;业务日志：用户行为日志、应用日志&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;状态日志：慢查询、异常探测&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统日志：debug、info、warn、error、fatal&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2.2 主要特性&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实时性：从日志产生到可访问，秒级&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;全文搜索：基于倒排索引，支持灵活的搜索分析&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;交互式分析：万亿级日志，搜索秒级响应&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2.3 相关公司&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日志易等&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5450755601875977&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9ZcNaUFJicbnBibErEsESYE1Dlp2XofmibFeEfeF0ExspcLD1MNiaNzV4JDiaBTXib0k0PtIh9rd5PjSR3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1919&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3 场景3：商业智能BI&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3.1 典型场景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;电子商务、移动应用、广告媒体等业务都需要借助数据分析和数据挖掘来辅助商业决策，而规模庞大的业务数据对数据的统计分析造成了很大的挑战。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3.2 主要特性&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ES 拥有结构化查询的能力，支持复杂的过滤和聚合统计功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;帮助客户对海量数据进行高效地个性化统计分析、发现问题与机会、辅助商业决策，让数据产生真正的价值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3.3 相关公司&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;睿思BI 等。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5483028720626631&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9ZcNaUFJicbnBibErEsESYE1DkwtiaUcT04SmoO8Mmib8JHhibGCBr0iavcJNsMpWYKQbPP8tGbTJariczsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1915&quot;/&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4、小结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的座右铭之一：“自由不是你想干什么就干什么，而是你不想干什么就有能力不干什么！”。可见：不想干什么较想干什么更为牛逼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而选型 Elasticsearch 的时候也要注意：它不能干什么或者它不擅长需要优先考虑，而将它擅长的、能干什么的方面发挥到极致是我们架构选型及后续实战方面要多考虑的因素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你在架构选型方面还考虑哪些因素？欢迎留言交流分享实战心得。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ee5d231687d7b331c524ba59e340e3a2</guid>
<title>K8S 组件参数及常见问题处理</title>
<link>https://toutiao.io/k/2d8zps3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h1 cid=&quot;n1066&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Kubernetes系列：&lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxMTM1NDM0Mg==&amp;amp;action=getalbum&amp;amp;album_id=1706133605548163076&amp;amp;scene=173&amp;amp;from_msgid=2452241131&amp;amp;from_itemidx=1&amp;amp;count=3&amp;amp;nolastread=1#wechat_redirect&quot; textvalue=&quot;请点击&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;请点击&lt;/a&gt;。&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.554&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaqVSGJoMTQMQN7Z4JcCI1jwgaP17boxKODnR3q0HQDstyTibwaib7aSnWPDFlhbBtmrKF5QESHnB0P5B91a2P9hg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;/&gt;&lt;/p&gt;&lt;h1 cid=&quot;n1066&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;1. 问题说明&lt;/span&gt;&lt;/h1&gt;&lt;h1 cid=&quot;n1072&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2. 问题处理&lt;/span&gt;&lt;/h1&gt;&lt;p cid=&quot;n1073&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;先看一下Kubernetes主要架构组件图：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1074&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;E:\aa\微信公众号文章\容器加固系列\img\4.1.png&quot;/&gt;&lt;/p&gt;&lt;h2 cid=&quot;n1075&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2.1  etcd&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n1076&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Kubernetes 中的大部分概念如 Pod、ReplicaSet、Deployment、Service、Node 等都可以被 看作一种资源对象，几乎所有资源对象都可以通过 Kubernetes 提供的 kubectl 工具(或者 API 编程调用)执行增、删、改、查等操作并将其保存在 etcd 中持久化存储。从这个角度 来看，Kubernetes 其实是一个高度自动化的资源控制系统，它通过跟踪对比 etcd 库里保存 的“资源期望状态”与当前环境中的“实际资源状态”的差异来实现自动控制和自动纠错 的高级功能。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n1077&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1079&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;etcd 保存整个集群的状态信息，类比相当于k8s的数据库。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1081&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;高可用方面，etcd 需要以集群的方式进行部署，以实现 etcd 数据存储的冗余、备份与高可用。etcd 集群需要奇数形式，至少由三台组成，考虑到同步的开销，一般不推荐超过7个etcd节点。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1083&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;存储，由于etcd 的特性，应考虑使用高性能的存储设备，如 SSD 磁盘，在Kubernetes 集群较大时，必须使用PICe SSD 来提升IO性能减少读写延迟。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1085&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;etcd 性能有两个关键因素：延迟(latency)：延迟是完成操作的时间；吞吐量(throughput)：吞吐量是在某个时间期间之内完成操作的总数量。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n1086&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1087&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;压缩空间&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;shell&quot; cid=&quot;n1088&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;# 获取当前版本号&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;$ rev&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;$(ETCDCTL_API=3 etcdctl --key=/etc/kubernetes/pki/etcd/server.key --cert=/etc/kubernetes/pki/etcd/server.crt --cacert=/etc/kubernetes/pki/etcd/ca.crt endpoint status --write-out=&quot;json&quot; | egrep -o &#x27;&quot;revision&quot;:[0-9]*&#x27; | egrep -o &#x27;[0-9]*&#x27;）&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;# 压缩所有旧版本&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;$ ETCDCTL_API&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; etcdctl compact &lt;span&gt;$rev&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;# 去碎片化&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;$ ETCDCTL_API&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; etcdctl defrag&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p cid=&quot;n1089&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;时间参数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1090&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;etcd 的心跳间隔默认是 100 毫秒。Etcd 的选举超时时间默认是 1000 毫秒（即从节点等待多久没收到主节点的心跳就尝试去竞选领导者）。在网络环境吞吐量大情况下，如同步吞吐在100MB左右。可适当调整：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1091&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;--heartbeat-interval=300&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1092&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;--election-timeout=5000&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1093&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1094&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;问题一：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1095&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;etcd集群状态：不同节点上有时候结果还不一样。有时候member1 不健康，有时候 member3 不健康 —— unhealthy。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1096&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;原因：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1097&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;etcd 对系统时间很敏感，当集群节点出现时间不一致时则出现问题。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1098&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1099&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;统一 NTP 服务器校准。集群各节点使用如：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n1100&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1102&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;timedatectl set-timezone Asia/Shanghai 确保时区。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1104&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;ntpdate -u $NTP-SERVER 进行时间同步。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1106&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;使用 chronyd 进行自动时间同步。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p cid=&quot;n1107&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;问题二：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n1108&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1110&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;集群加入主机后，主机列表没有新增。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1112&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;接入主机命令执行之后，一般会报错 Node “xxx&quot; not found。（原因是添加被etcd 拒绝）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1114&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;主机状态 未知。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1116&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Kubelet 状态有 database space exceeded报错。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p cid=&quot;n1117&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;原因：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n1118&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1120&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;默认情况下，ETCD使用的空间上限是 2 GB。一般支持最大 8 GB。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1122&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;默认 etcd 的 snap 频率是 10万次提交 进行一次 Snapshot。Kubernetes 数据存储在 etcd，当 k8s load 较高时，Snap 频率会提高。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure cid=&quot;n1123&quot; mdtype=&quot;table&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr cid=&quot;n1124&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;span cid=&quot;n1125&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;--snapshot-count &#x27;100000&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n1126&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;number of committed transactions to trigger a snapshot to disk.&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n1127&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1128&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;--max-snapshots&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1129&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;maximum number of snapshot files to retain (0 is unlimited).&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p cid=&quot;n1130&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;shell&quot; cid=&quot;n1131&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;# ETCDCTL_API=3 etcdctl --key=/etc/kubernetes/pki/etcd/server.key --cert=/etc/kubernetes/pki/etcd/server.crt --cacert=/etc/kubernetes/pki/etcd/ca.crt --write-out=table endpoint status&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n1132&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;E:\aa\微信公众号文章\容器加固系列\img\4.2.png&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n1133&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;查看 节点数据存储量，通常数据量应该很小。几百K到几十M不等。出问题一般会超过2G。&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n1134&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1136&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;获取 revision，然后压缩compact&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;shell&quot; cid=&quot;n1137&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;# ETCDCTL_API=3 etcdctl --key=/etc/kubernetes/pki/etcd/server.key --cert=/etc/kubernetes/pki/etcd/server.crt --cacert=/etc/kubernetes/pki/etcd/ca.crt endpoint status --write-out=&quot;json&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;# ETCDCTL_API=3 etcdctl --key=/etc/kubernetes/pki/etcd/server.key --cert=/etc/kubernetes/pki/etcd/server.crt --cacert=/etc/kubernetes/pki/etcd/ca.crt compact 4974364&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p cid=&quot;n1138&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;E:\aa\微信公众号文章\容器加固系列\img\4.3.png&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n1139&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;  2.defrag 整理空间&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;shell&quot; cid=&quot;n1140&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;# ETCDCTL_API=3 etcdctl --key=/etc/kubernetes/pki/etcd/server.key --cert=/etc/kubernetes/pki/etcd/server.crt --cacert=/etc/kubernetes/pki/etcd/ca.crt defrag&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n1141&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n1142&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;    3.修改默认空间&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1143&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;    etcd 的硬盘存储上限（默认是 2GB）,当 etcd 数据量超过默认 quota 值后便不再接受写请求，可以通过设置 --quota-backend-bytes 参数来增加存储大小。&lt;/span&gt;&lt;/p&gt;&lt;h2 cid=&quot;n1144&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2.2  APIServer&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n1145&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;APISERVER 是整个系统的对外接口，提供一套 RESTful 的 Kubernetes API，供客户端和其它组件调用。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n1146&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1148&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;提供对k8s资源操作的唯一入口，并提供认证授权，访问控制，API注册与发现等机制。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1150&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;只有 apiserver 才能操作 etcd，其他组件通过 APISERVER 进行数据的查询和集群状态更新。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1152&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Kubernetes 所有的数据变动都会经过 APISERVER。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure cid=&quot;n1153&quot; mdtype=&quot;table&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr cid=&quot;n1154&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;span cid=&quot;n1155&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;组件参数&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n1156&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;功能描述&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n1157&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;使用建议&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n1158&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1159&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–enable-garbage-collector&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1160&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;“–enable-garbage-collector&quot;设置了是否开启garbage   collector，该选项必须和kube-controller-manager的”–enable-garbage-collector&quot;参数设置一致，该参数使用true作为默认值。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1161&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Kubernetes的garbage   collector是用来删除曾经有owner，但是现在没有owner的对象的。举个例子，一个ReplicaSet是一组Pod的owner，当这个ReplicaSet被删除后，Kubernetes的garbage   collector负责处理掉这个ReplicaSet控制下的Pod。如果这些Pod在业务中需要被保留，则&quot;–enable-garbage-collector&quot;应被设置为false，其他情况则应设置为true。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1162&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1163&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–enable-logs-handler&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1164&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;&quot;–enable-logs-handler&quot;设置了是否为apiserver安装logs   handler，该参数使用true作为默认值。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1165&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;如果不处理apiserver的log是有必要的，则将该参数设置为false。其他情况下，设置为true或者使用默认值。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1166&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1167&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–max-mutating-requests-inflight&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1168&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;“–max-mutating-requests-inflight&quot;设置了apiserver在一定时间内并行处理mutating   request的最大数量，当数量超过这个数值时，超过部分的request会被拒绝处理。当设置为0时，表示apiserver没有单位时间内请求数量的限制，该参数使用200作为默认值。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1169&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;该参数旨在限制单位时间内处理mutating requests的最大数量。因为mutating   request通常需要比non-mutating request处理更多的业务逻辑，所以mutating   request需要消耗更多内存资源，”–max-mutating-requests-inflight&quot;的值也要比&quot;–max-requests-inflight&quot;的值更低。性能测试在决定特定业务场景中&quot;–max-requests-inflight&quot;和&quot;–max-mutating-requests-inflight&quot;两个值的比例时是有必要的。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1170&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1171&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–max-requests-inflight&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1172&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;&quot;–max-requests-inflight&quot;设置了apiserver在一定时间内并行处理non-mutating   request的最大数量，当数量超过这个数值时，超过部分的request会被拒绝处理。当设置为0时，表示apiserver没有单位时间内请求数量的限制，该参数使用400作为默认值。该参数可以很好地控制kube-apiserver的内存消耗，而API   server在处理大量request时对CPU并没有很高要求。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1173&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;当该参数值过低时，系统会发生大量request-limit-exceed错误。当该参数值过高时，kube-apiserver会因试图并行处理过多request而内存不够（OOM）发生故障。总体而言，25～30个Pod并行处理15个请求是足够的。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1174&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1175&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–target-ram-mb&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1176&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;&quot;–target-ram-mb&quot;设置了apiserver的内存限制。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1177&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;实践中，32C120G可以运行2000个Node和60000个Pod，相当于60M／Node和30Pod／Node。通常而言，每20～30个Pod使用60M是比较合理的。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n1178&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1180&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;上述参数根据实际生产环境调整。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1182&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在 v1.10 以前的版本中可能出现 kubelet 连接 apiserver 超时之后不会主动 reset 掉连接进行重试，除非主动重启 kubelet 或者等待十多分钟后其进行重试。v1.14 及以上版本修复此问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1184&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Kube-APIServer模块的代码审核也是最严格的，一般不会有什么较大的改动，一旦有改动，都是需要长久的讨论才能决定怎么改，毕竟API-Server的性能，直接决定了Kubernetes整体的性能。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n1185&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;问题一：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1186&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Kubernetes 的各个组件与 Master 之间可以通过 kube-apiserver 的非安全端口 http://&lt;/span&gt;&lt;span md-inline=&quot;tag&quot; spellcheck=&quot;false&quot;&gt;&amp;lt;kube-apiserver-ip&amp;gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;:8080 进行访问。但如果 API Server 需要对外提供服务，或者集群中的某些容器也需要访问 API Server 以获取集群中的某些信息，存在安全隐患。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1187&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1188&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;安全的做法是启用 HTTPS 安全机制。设置 kube-apiserver 的启动参数“--token-auth-file”，或启用RBAC认证，使用文件提供安全认证：&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;shell&quot; cid=&quot;n1189&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;--secure-port&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;6443&lt;/span&gt; &lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;--insecure-port&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt; &lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;--basic-auth-file&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;/etc/kubernetes/basic_auth_file&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n1190&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n1193&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;8080 端口在后续的版本中将被弃用。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1194&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1195&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;问题二：&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1196&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;大量 POD 重建导致 events 增多，api server 压力较大，集群访问受到影响。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1197&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决方案 1：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1198&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;  &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;kubectl  delete events --all -n tenant1&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;  &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1202&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决方案 2：&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1203&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;  &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;kubectl  get pod -o wide --all-namespaces | awk &#x27;$5&amp;gt;0&#x27;&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1207&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h2 cid=&quot;n1208&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2.3 kube-scheduler&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n1209&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kube-scheduler，负责资源调度(Pod 调度)的进程，相当 于公交公司的“调度室”。实现 Pod 的调度， 整个调度过程通过执行一系列复杂的算法，最终为每个 Pod 都计算出一个最佳的目标节点。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n1210&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1212&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;通过 watch 到api-server 事件变化，获取需要创建并且未进行调度的 pod 进行调度，如果调度成功会把信息通过 api-server记录到etcd中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1214&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;daemonset 不经过 scheduler 调用，直接在 node 启动。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1216&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;对某些 Node 定义特定的 Label，并且在 Pod 定义文件中使用 NodeSelector 这 种标签调度策略，kube-scheduler 进程可以实现 Pod 定向调度的特性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1218&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Pod/Node Affinity &amp;amp; Anti-affinity&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1220&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Taint &amp;amp; Toleration&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1222&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Priority &amp;amp; Preemption&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1224&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Pod Disruption Budget&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n1225&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1226&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;systemd 启动参数：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1236&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;问题一：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1237&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;scheduler 默认监听 0.0.0.0，存在安全隐患。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1238&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1239&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;启用 HTTPS，指定监听地址为内网或本机127.0.0.1。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1240&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;--bind-address ip ，在 HTTPS 安全端口提供服务时监听的 IP 地址，默认值为 0.0.0.0。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1241&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;--secure-port int，设置 HTTPS 安全模式的监听端口号，设置为 0 表示不启用 HTTPS，默认值为 10257。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1242&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h2 cid=&quot;n1243&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2.4 kube-controller-manager&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n1244&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kube-manager，是 Kubernetes 中各种操作系统的管理者，是集群内部的管理控制中心，也是 Kubernetes 自动化功能的核心。作为集群内部的管理控制中心，负责集群内资源的管理。目的在于及时发现故障并自动化修复，确保集群始终处于预期的工作状况。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1250&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1251&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;通过设置 kube-controller-manager 组件的启动参数--leader-elect=true，即可实现 kube-controller-manager 组件的高可用性。&lt;/span&gt;&lt;/p&gt;&lt;figure cid=&quot;n1252&quot; mdtype=&quot;table&quot;&gt;&lt;table data-sort=&quot;sortDisabled&quot;&gt;&lt;thead&gt;&lt;tr cid=&quot;n1253&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;span cid=&quot;n1254&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;设置参数&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n1255&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;值&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n1256&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;说明&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n1257&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1258&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–feature-gates=ExperimentalCriticalPodAnnotation=true&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1259&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1260&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;关于ExperimentalCriticalPodAnnotation=true这个参数，kube-controller-manager中并没有在使用。如果确实想用CriticalPod，为保险起见，最好还是设置上。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1261&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1262&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–enable-garbage-collector&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1263&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1264&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;设置为true表示启动垃圾回收器，必须与kube-apiserver的该参数设置为相同的值。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1265&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1266&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–cluster-cidr&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1267&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1268&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;表示Pod的IP范围，用于有云提供商的公有云环境下。它的用途是桥接来自集群外的流量。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1269&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1270&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–service-cluster-ip-range&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1271&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1272&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;表示Service的IP范围，用于有云提供商的公有云环境下。目前kube-manager-controller正在重构过程中，将其与云提供商有关部分进行解耦，被解耦的部分重组成一个新的组件，组件名称为cloud-controller-manager,整个重组过程预计在kubernetes-release-1.9版本完成。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1273&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1274&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–terminated-pod-gc-threshold&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1275&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;12500&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1276&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;设置可保存的终止Pod的数量，如果超过该数量，垃圾回收器开始删除操作。设置为不大于0的值表示不启用该功能。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p cid=&quot;n1277&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;问题一：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1278&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;节点宕机，保障业务不受影响。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1279&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n1280&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1282&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Pod 应该多实例，分布不同主机。避免某个节点宕机带来的单点影响。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1284&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;当计算节点出现问题时，kube-controller 默认需要5分钟后才会驱逐计算节点上的容器并重建。这个时间不建议减少太多，避免因为网络抖动带来 pod 频繁调度和误杀问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1286&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kube-controller-manager，其中「--unhealthy-zone-threshold」参数可以设置在一个 zone 中有多少比例的 Node 失效时将被判断为 unhealthy 不进行节点驱逐，默认值为 0.55。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1288&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;如果对时间敏感度有强烈需求，以下脚本供参考。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;shell&quot; cid=&quot;n1289&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;#!/bin/sh&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;KUBECTL&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;/usr/bin/kubectl&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;# Get only nodes which are not drained yet&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;NOT_READY_NODES&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;$(&lt;/span&gt;&lt;span&gt;$KUBECTL&lt;/span&gt;&lt;span&gt; get nodes | grep -P &#x27;NotReady(?!,SchedulingDisabled)&#x27; | awk &#x27;{print &lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;}&#x27; | xargs echo)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;# Get only nodes which are still drained&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;READY_NODES&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;$(&lt;/span&gt;&lt;span&gt;$KUBECTL&lt;/span&gt;&lt;span&gt; get nodes | grep &#x27;\sReady,SchedulingDisabled&#x27; | awk &#x27;{print &lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;}&#x27; | xargs echo)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;Unready nodes that are undrained: &lt;/span&gt;&lt;span&gt;$NOT_READY_NODES&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;Ready nodes: &lt;/span&gt;&lt;span&gt;$READY_NODES&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;node&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;$NOT_READY_NODES&lt;/span&gt;; &lt;span&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;Node &lt;/span&gt;&lt;span&gt;$node&lt;/span&gt;&lt;span&gt; not drained yet, draining...&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;$KUBECTL&lt;/span&gt; drain &lt;span&gt;--delete-local-data&lt;/span&gt; &lt;span&gt;--ignore-daemonsets&lt;/span&gt; &lt;span&gt;--force&lt;/span&gt; &lt;span&gt;$node&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;Done&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;done&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;node&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;$READY_NODES&lt;/span&gt;; &lt;span&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;Node &lt;/span&gt;&lt;span&gt;$node&lt;/span&gt;&lt;span&gt; still drained, uncordoning...&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;$KUBECTL&lt;/span&gt; uncordon &lt;span&gt;$node&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;Done&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;done&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p cid=&quot;n1293&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1294&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;问题二：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1295&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Kubernetes 的关键组件除了 API Server 、 scheduler、controller-manager 是运行在 master 节点上的，其余都在普通节点上。当集群内普通节点资源被消耗完，关键组件可能没有足够的资源来运行（如网络组件），导致整个集群无法正常工作。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1296&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1297&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;将普通 Pod （非关键组件）从节点上驱逐来释放占有的资源。但是这样做，普通 Pod 与关键组件 Pod 会一起进入调度器，普通 Pod 可能会先一步被调度到机器上，重新占有释放的资源。这样事情就会陷入一个死循环。可以将被选中的节点（用于释放资源），标记一个暂时的污点（taint “CriticalAddonsOnly” ），这样不能容忍污点的 Pod 将不能调度到有污点的节点上。&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n1298&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1300&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;组件必须运行在 kube-system 命名空间下;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1302&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;1.14 前版本，可以 scheduler.alpha.kubernetes.io/critical-pod 的注解（annotation ）设置为空字符串；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1304&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;PodSpec’s 的容忍（tolerations） 设置为：[{&quot;key&quot;:&quot;CriticalAddonsOnly&quot;,&quot;operator&quot;:&quot;Exists&quot;}]；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1306&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;需要将 priorityClassName 设置为 system-cluster-critical 或 system-node-critical ，后者是整个群集的最高级别。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p cid=&quot;n1307&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n1308&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h2 cid=&quot;n1309&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2.5 kubelet&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n1310&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kubelet 负责 Pod 对应的容器的创建、启停等任务，同时与 Master 密切协作，实现集群管理的基本功能。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n1311&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1313&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kubelet 负责容器声明周期。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1315&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kubelet 服务依赖于 Docker 服务。如果 docker 进程异常或启动失败，则 kubelet 服务也随之出错。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1317&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;建议 kubelet 以主机服务进程启动运行，如 systemd。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1319&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kubelet 默认采用向 Master 自动注册本 Node 的机制。定时向 Master 汇报自身的节点情况，包括操作系统、Docker 版本、机器的 CPU 和内存情况，以 及当前有哪些 Pod 在运行等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure cid=&quot;n1320&quot; mdtype=&quot;table&quot;&gt;&lt;table data-sort=&quot;sortDisabled&quot;&gt;&lt;thead&gt;&lt;tr cid=&quot;n1321&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;span cid=&quot;n1322&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;组件参数&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n1323&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;默认值&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n1324&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;说明&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n1325&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1326&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;--experimental-allocatable-ignore-eviction&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1327&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1328&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;（1）设置为true时，当计算节点可分配资源总量时，&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;–eviction-hard参数将被忽略&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;。此时，节点可分配资源总量 [Allocatable] = [Node   Capacity] - [Kube-Reserved] - [System-Reserved]。（2）设置为false时，当计算节点可分配资源总量时，在原先的基础上还要减去–eviction-hard参数所设置的值。此时，节点可分配资源总量   [Allocatable] = [Node Capacity] - [Kube-Reserved] - [System-Reserved] -   [Hard-Eviction-Threshold]。（&amp;amp;）[Node Capacity] 表示节点的实际资源量；[Kube-Reserved]   表示为Kubernetes系统组件预留的资源量，可通过–kube-reserved参数设置；[System-Reserved]   表示为系统预留的资源量，可通过–system-reserved参数设置。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1329&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1330&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;--cgroup-root&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1331&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;’ ’ , 表示将使用容器运行时的默认值&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1332&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;为pods设置的root cgroup。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1333&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1334&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;--experimental-mounter-path&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1335&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;’ ’，空&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1336&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;（1）设置为空时，表示使用默认的挂载命令。（2）设置为绝对路径时，表示使用指定路径上的挂载命令。同时，其会将--expermental-check-node-capabilities-before-mount参数重置为false，因此，当执行挂载操作时，并不会去检查节点是否具备挂载此种类型数据卷的必要组件，如二进制可执行文件。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1337&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1338&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–experimental-check-node-capabilities-before-mount&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1339&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1340&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;(1) 设置为false时，在执行挂载操作前，不会去检查本节点是否具有挂载某种类型数据卷的必要组件，如二进制可执行文件等等。当挂载操作失败之后，会重新再执行此挂载操作。（2）设置为true时，在执行挂载操作前，会根据要挂载的数据卷类型，确定数据卷插件，并检查本节点具有此数据卷插件的必要的依赖性组件。当检查结果是不具备时，此挂载操作立即失败，对于此挂载操作，不会进行重试。（&amp;amp;）--expermental-mounter-path参数取值，会影响本参数的最终取值。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1341&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1342&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–enable-debugging-handlers&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1343&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1344&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;设置为true表示提供远程访问本节点容器的日志、进入容器执行命令等相关的REST服务。在安全性方面，还需后序调研。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1345&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1346&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–eviction-hard&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1347&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;memory.available&amp;lt;100Mi,nodefs.available&amp;lt;10%,nodes.inodesFree&amp;lt;5%&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1348&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;表示触发Pod Eviction操作的一组硬门限设置。当节点资源达至这个下限时，出于节点稳定性的考虑，kubelet会&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;立刻&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;执行Pod Eviction操作，释放资源，维护节点的稳定性。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1349&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1350&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–feature-gates&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1352&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;（1）ExperimentalCriticalPodAnnotation   默认值为false；设置为true时，表示当CriticalPod被调度器调度到本节点后，如果因为节点资源不足而无法运行时，kubelet会启用重调度机制，按qos等级删除一部分pod，释放资源来使CriticalPod可以在本节点上运行。另外，CriticalPod不会被kubelet的Pod   Eviction机制驱逐出去。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p cid=&quot;n1353&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;问题一：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1354&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kubelet 容器启动出错。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1355&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1356&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kubelet Pod status，获悉容器相关状态：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1357&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;CrashLoopBackOff：容器退出，kubelet正在将它重启&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1358&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;InvalidImageName：无法解析镜像名称&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1359&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;ImageInspectError：无法校验镜像&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1360&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;ErrImageNeverPull：策略禁止拉取镜像&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1361&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;ImagePullBackOff：正在重试拉取&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1362&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;RegistryUnavailable：连接不到镜像中心&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1363&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;ErrImagePull：通用的拉取镜像出错&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1364&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;CreateContainerConfigError：不能创建kubelet使用的容器配置&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1365&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;CreateContainerError：创建容器失败&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1366&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;m.internalLifecycle.PreStartContainer 执行hook报错&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1367&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;RunContainerError：启动容器失败&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1368&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;PostStartHookError：执行hook报错&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1369&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;ContainersNotInitialized：容器没有初始化完毕&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1370&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;ContainersNotReady：容器没有准备完毕&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1371&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;ContainerCreating：容器创建中&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1372&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;PodInitializing：pod 初始化中&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1373&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;DockerDaemonNotReady：docker还没有完全启动&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1374&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;NetworkPluginNotReady：网络插件还没有完全启动&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1375&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1376&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;问题二：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1377&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kubelet 故障引起的常见结果。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1378&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1379&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kubelet 故障对应用影响：&lt;/span&gt;&lt;/p&gt;&lt;figure cid=&quot;n1380&quot; mdtype=&quot;table&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr cid=&quot;n1381&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;span cid=&quot;n1382&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;问题 &lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n1383&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;描述 &lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n1384&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;应用&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n1385&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1386&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kubelet 出故障&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1387&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;无法在该节点启动新的容器组    crashing kubelet cannot start new   pods on the node [不会]&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1388&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;不影响&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1389&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1390&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kubelet 出故障&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1391&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kubelet might delete the pods or not&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1392&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;影响&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1393&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1394&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kubelet 出故障&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1395&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;节点被标记为不健康   node marked unhealthy&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1396&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;不影响&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1397&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1398&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kubelet 出故障&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1399&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;可能导致 RC 在其他节点启动新的容器组（Reschedule）   replication controllers start new pods elsewhere&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1400&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;不一定：  对可扩展的应用来说，没影响；  可能会影响到 无法扩展的一些应用&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p cid=&quot;n1401&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;问题三：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1402&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;重启kubelet之后，会导致节点上面的一些Pod也发生重启，并且会留下一些状态为&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;MatchNodeSelector&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;的僵尸Pod。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1403&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;原因：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1404&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;正常情况下，如果我们在某一节点上重启了kubelet，那么上面的Pod(容器)是不会重启的。这是kubelet 现存 BUG，但触发需要一定条件。&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n1405&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1407&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;某些Pod是通过NodeSelector的label给调度到某些专有label的节点上的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1409&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;当kubelet重启并且与apiServer的连接非常不稳定时，会有几率出现这些Pod被重启。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p cid=&quot;n1410&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1411&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;当重要业务节点需要重启 kubelet 时，为保证上面运行的 pod 业务。可以修改 kubelet 配置的 --node-labels 参数&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1412&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;E:\aa\微信公众号文章\容器加固系列\img\4.4.png&quot;/&gt;&lt;/p&gt;&lt;h2 cid=&quot;n1416&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2.6 kube-proxy&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n1417&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kube-proxy，实现 Kubernetes Service 的通信与负载均衡机制的重要组件。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n1418&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1420&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;负责把对 Service 的请求转发到后端的某个 Pod 实例上，自动建立每个 Service 到对应 Pod 的请求转发路由表，从而实现 Service 的负载均衡机制。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1422&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kube-proxy 服务依赖于 network 服务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1424&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;生成 service 相关网络访问规则，支持 iptables 和 ipvs 规则（最新版默认使用这个）创建。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure cid=&quot;n1425&quot; mdtype=&quot;table&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr cid=&quot;n1426&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;span cid=&quot;n1427&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;组件参数&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n1428&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;默认值&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n1429&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;说明&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n1430&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1431&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–iptables-min-sync-period&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1432&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1433&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;表示iptables规则的最小同步周期。（1）设置为非0时，kube-proxy使用令牌桶算法实现流控控制，避免频繁刷新。例如，当--iptables-min-sync-period=10s,   kube-proxy以每秒0.1个令牌的速度，向令牌桶中放入令牌，桶的容量为2。（2）设置为0时，kube-proxy则不启用流控控制。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1434&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1435&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;–iptables-sync-period&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1436&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;30s&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1437&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;表示iptables规则的最大同步周期。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1438&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1439&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;—feature-gates=   ExperimentalCriticalPodAnnotation=true&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1441&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;关于ExperimentalCriticalPodAnnotation=true这个参数，kube-proxy中并没有在使用。如果确实想用CriticalPod，为保险起见，最好还是设置上。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p cid=&quot;n1447&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;问题一：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1448&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;节点故障时，上面运行的 pod 需要较长时间才恢复正常。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1449&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;原因：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1450&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Kube-proxy 默认 30 秒就刷新一次 iptables 规则。如果主机故障或删除 iptables 规则，那就需要 30 秒后 kube-proxy 才能实现并恢复。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1451&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n1452&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1454&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;按实际调整 iptables 刷新、同步规则时间。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1456&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;pod 设置 readiness 健康检查，探测 pod 异常时可以自动去除前端 service 访问。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1458&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;调整 kubelet 的 --node-monitor-grace-period 参数，减少这个时间让节点从调度中摘除。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1460&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;上层添加硬负载，如 F5；软负载如Haproxy 可在 retries 配置中解决、Nginx在 max_fails 配置中解决。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p cid=&quot;n1461&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1462&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;问题二：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1463&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kube-proxy 不工作，导致访问某个节点的 pod 业务，服务异常。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1464&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;原因：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1465&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;iptables 规则没生成或规则没及时同步。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1466&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n1467&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1469&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;删除 kube-proxy 重建。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1471&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Service 需要的 ClusterIP 段可能有冲突，查找内网是否存在与默认10.96.0.0/12网段。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1473&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;大规模，如 service 超过5000个。使用 ipvs 模式替代 iptables。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p cid=&quot;n1474&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1475&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;问题三：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1476&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;存在 keepalived 的节点，监控脚本就不停重启keepalived&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1477&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;原因：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1478&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;kube-proxy 使用 ipvs 模式，重启会导致 ipvs 的所有规则清除。keepalived节点依靠ipvs来转发， 但是只要restart该节点的kube-proxy， ipvsadm -L -n规则就全没了。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1479&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1480&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;调整 kube-proxy 的参数：--cleanup-ipvs=false 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;内容持续更新，请扫码关注我们~&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAxMTM1NDM0Mg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/iaqVSGJoMTQMys1bEia86TW4rQFvBTOUR1eL173MLS9Fz121CziceNCMIVhWUjTBc3tPUOdcib4QByiaaPwiaibicqm6KQ/0?wx_fmt=png&quot; data-nickname=&quot;云计算架构师成长路&quot; data-alias=&quot;vincentjava&quot; data-signature=&quot;分享云计算相关知识。公众号由三人小组组成：主要记录Docker、Kubernetes、OpenStack、SpringCloud、Service Mesh等相关技术的学习历程，水平有限，知识无限，欢迎指正。用心生活，活在当下，珍惜拥有。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>