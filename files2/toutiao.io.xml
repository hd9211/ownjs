<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>810b220539785ee2355a4df72e1c341c</guid>
<title>华为鸿蒙 2.0，让我遇见未来 | 码农周刊第 318 期</title>
<link>https://toutiao.io/k/6rprzrd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;华为鸿蒙 2.0，让我遇见未来 | 码农周刊第 318 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第318期（2020-09-16）&lt;/h2&gt;
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=318&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3180&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_316.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=318&amp;amp;aid=19803&amp;amp;url=https%3A%2F%2Fwww.sheca.com%2Fassets%2Fwwx%2Fpage1.html%3Fsite%3Dkaifazhe02&quot; target=&quot;_blank&quot;&gt;SHECA 提供 SSL 证书一站式服务，为你的网络安全保驾护航，上海 CA 权威认证&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=318&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;深入讲解&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;持续更新&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;帮助大家有针对性地准备面试&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;用于播放特效动画的实现方案。具有高压缩率、硬件解码等优点。同时支持 iOS, Android, Web 平台。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;各有千秋&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;附 demo&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;收藏吧&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;经验分享&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;深入研究&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;教你用 Deployment 全搞定&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;程序员进阶系列&lt;/p&gt;
        
        &lt;p&gt;编程体系结构系列&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;看完这个视频你转头也写了一吨&lt;/p&gt;
        
        &lt;p&gt;类似微信的小程序&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;死磕Elasticsearch！&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 272620 即可&lt;/p&gt;
        
        &lt;p&gt;前端 Or NodeJs。喜欢造轮子的懒人&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 95159 即可&lt;/p&gt;
        
        &lt;p&gt;关于计算机很多很多好玩的，一些常见的使用技巧和案例，还有技术方面的&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 72425 即可&lt;/p&gt;
        
        &lt;p&gt;顺势而为; 在技术人的后场; 分享前沿「技术」和「思想」。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 56624 即可&lt;/p&gt;
        
        &lt;p&gt;五分钟不刷心里发慌&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 378 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=318&amp;amp;aid=19870&amp;amp;url=https%3A%2F%2Fu.jd.com%2FDpNS3m&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/book_318.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;采访实录&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>11009444b48ead89f6e5c569fbffb42a</guid>
<title>JDK 15 正式发布，划时代的 ZGC 同时宣布转正</title>
<link>https://toutiao.io/k/ipkoven</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.42441054091539526&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKIAXa5picIWmfJFiaauRyaNyNvibFwPoupliaWiaCGG7HHEq0zjF3lvdybhicsEslu04HicmbH7E2ZicibsMVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;721&quot;/&gt;&lt;/figure&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;点击上方“&lt;/span&gt;&lt;span&gt;BAT的乌托邦&lt;/span&gt;&lt;span&gt;”，选择“&lt;/span&gt;&lt;span&gt;设为星标&lt;/span&gt;&lt;span&gt;”&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;后台回复“&lt;/span&gt;&lt;span&gt;专栏&lt;/span&gt;&lt;span&gt;”，开启&lt;strong mpa-from-tpl=&quot;t&quot;&gt;专栏模式&lt;/strong&gt;学习&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;✍前言&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2020年9月15日，JDK15正式发布，可谓如约而至。按照Java SE的发展路线图，JDK14自此停止更新。值得注意的是JDK15并非&lt;strong&gt;「LTS」&lt;/strong&gt;版本，Oracle官方对Java SE的支持路线图如下：&lt;img data-ratio=&quot;0.2392857142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKIAXa5picIWmfJFiaauRyaNyNo4ssqg9qpwRBqYjZDnS9evSpFuDaQIZ6BeqaX3uht3PSLuncWib9ggA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1400&quot;/&gt;JDK8的扩展支持时间超过了JDK11，Oracle你是认真的吗？开个玩笑~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么自Java11之后，哪个版本才是LTS版本呢？Oracle官方并没给出具体参考路线图，但可参考OpenJDK的这张：&lt;img data-ratio=&quot;1.03125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKIAXa5picIWmfJFiaauRyaNyNFicoAkjkDl6aInJNza20EyGEOticeZ9v9iaeMsia54oBiblJhpu2tl2s8kg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;可以看到&lt;strong&gt;「JDK17」&lt;/strong&gt;将是下一个LTS版本，预计发版日期是2021年9月份。当然喽这只是OpenJDK的发版线路图，并不代表Oracle官方，因此仅供参考，不过一般八九不离十。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;小贴士：OpenJDK和Oracle JDK自从JDK11后，就共享了绝大部分代码了，节奏基本保持一致。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从JDK9之后，Oracle采用了新的发布周期：每6个月发布一个版本，每3年发布一个LTS版本。JDK14是继JDK9之后发布的第四个版本， 该版本为非LTS版本，&lt;strong&gt;「最新的LTS版本为JDK11」&lt;/strong&gt;。因为是小鹿快跑，快速迭代，因此此处解释下这两个词：孵化器模块（Incubator）和预览特性（Preview）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;孵化器模块（孵化版/实验版）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尚未定稿的API/工具，主要用于从Java社区收集使用反馈，稳定性无保障，后期有较大可能性移除&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;预览特性（预览版）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;规格已成型，实现已确定，但还未最终定稿。这些特性还是存在被移除的可能性，但一般来说最后都会被固定下来。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;✍正文&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK15是Java SE平台的第15个版本，由&lt;strong&gt;「JSR 390」&lt;/strong&gt;在Java社区进程中指定。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;OpenJDK 15是9-15发布的，Oracle同步跟上。其它厂商的对应JDK版本也会随后跟上&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该版本共提供14个新特性，通过这些JEP来表示，截图如下：&lt;img data-ratio=&quot;0.6626016260162602&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKIAXa5picIWmfJFiaauRyaNyN7Pz4RrAju2aV4FMhxmPZXbuiaVrVz10q6QwMBwQEk6sicT9icwFuzjGPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;492&quot;/&gt;下面针对其中对开发者日常编程关系较大的特性拉出来解释，并给出对应的使用示例（其实就是JEP 378喽）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JDK14新特性回顾&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老规矩，在进行JDK15的新特性介绍之前，先回顾下JDK14的主要特性有哪些。JDK 14于2020年3月17日发布。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;一、Switch表达式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新的Switch表达式其实早在JDK 12、13中都已存在了，但只是&lt;strong&gt;「预览版」&lt;/strong&gt;，到了JDK 14就彻底变为稳定版了，可以放心商用。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;小贴士：预览版特性是有可能在后续版本中被移除的，但稳定版后几乎不可能被移除&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;switch新的表达式有两个显著的特点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;支持箭头表达式返回&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持yield和return返回值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;1、箭头表达式返回&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK14之前写法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;printLetterCount&lt;/span&gt;&lt;span&gt;(DayOfWeek dayOfWeek)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;switch&lt;/span&gt; (dayOfWeek) {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; MONDAY:&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; FRIDAY:&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; SUNDAY:&lt;br/&gt;            System.out.println(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; TUESDAY:&lt;br/&gt;            System.out.println(&lt;span&gt;7&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; THURSDAY:&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; SATURDAY:&lt;br/&gt;            System.out.println(&lt;span&gt;8&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; WEDNESDAY:&lt;br/&gt;            System.out.println(&lt;span&gt;9&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要点：break可千万别忘记写，否则就是个大bug，并且还比较&lt;strong&gt;「隐蔽」&lt;/strong&gt;，定位起来稍显困难。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK14等效的新写法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;printLetterCount&lt;/span&gt;&lt;span&gt;(DayOfWeek dayOfWeek)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;switch&lt;/span&gt; (dayOfWeek) {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; MONDAY, FRIDAY, SUNDAY -&amp;gt; System.out.println(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; TUESDAY                -&amp;gt; System.out.println(&lt;span&gt;7&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; THURSDAY, SATURDAY     -&amp;gt; System.out.println(&lt;span&gt;8&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; WEDNESDAY              -&amp;gt; System.out.println(&lt;span&gt;9&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可明显看到新写法不需要一个个break了，从&lt;strong&gt;「语法层面」&lt;/strong&gt;规避了我们犯错的可能性。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;2、yield返回&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK14之前写法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getLetterCount&lt;/span&gt;&lt;span&gt;(DayOfWeek dayOfWeek)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; letterCount;&lt;br/&gt;    &lt;span&gt;switch&lt;/span&gt; (dayOfWeek) {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; MONDAY:&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; FRIDAY:&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; SUNDAY:&lt;br/&gt;            letterCount = &lt;span&gt;6&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; TUESDAY:&lt;br/&gt;            letterCount = &lt;span&gt;7&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; THURSDAY:&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; SATURDAY:&lt;br/&gt;            letterCount = &lt;span&gt;8&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; WEDNESDAY:&lt;br/&gt;            letterCount = &lt;span&gt;9&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&lt;span&gt;&quot;非法: &quot;&lt;/span&gt; + dayOfWeek);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; letterCount;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK14等效的新写法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getLetterCount&lt;/span&gt;&lt;span&gt;(DayOfWeek dayOfWeek)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;switch&lt;/span&gt; (dayOfWeek) {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; MONDAY, FRIDAY, SUNDAY -&amp;gt; &lt;span&gt;6&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; TUESDAY                -&amp;gt; &lt;span&gt;7&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; THURSDAY, SATURDAY     -&amp;gt; &lt;span&gt;8&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; WEDNESDAY              -&amp;gt; &lt;span&gt;9&lt;/span&gt;;&lt;br/&gt;    };&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用箭头操作符操作效果立竿见影。当然，你还可以使用&lt;code&gt;yield&lt;/code&gt;关键字返回：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getLetterCount&lt;/span&gt;&lt;span&gt;(DayOfWeek dayOfWeek)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;switch&lt;/span&gt; (dayOfWeek) {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; MONDAY  -&amp;gt; &lt;span&gt;6&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;default&lt;/span&gt;      -&amp;gt; {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; letterCount = dayOfWeek.toString().length();&lt;br/&gt;            yield letterCount;&lt;br/&gt;        }&lt;br/&gt;    };&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;二、instanceof的模式匹配（预览）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该功能在JDK14中处理&lt;strong&gt;「预览版」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK14之前写法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Object o = &lt;span&gt;&quot;hello world&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(o &lt;span&gt;instanceof&lt;/span&gt; String ){&lt;br/&gt;        String str = String.class.cast(o);&lt;br/&gt;        System.out.println(str);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK14等效的新写法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Object o = &lt;span&gt;&quot;hello world&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;// 屁股里直接可写个变量名，不再需要强转了&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(o &lt;span&gt;instanceof&lt;/span&gt; String str){&lt;br/&gt;        System.out.println(str);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;再如：&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (obj &lt;span&gt;instanceof&lt;/span&gt; String s &amp;amp;&amp;amp; s.length() &amp;gt; &lt;span&gt;5&lt;/span&gt;) {&lt;br/&gt; s.contains(..)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你运行时有如下错误：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java: &lt;span&gt;instanceof&lt;/span&gt; 中的模式匹配 是预览功能，默认情况下禁用。&lt;br/&gt;  （请使用 --enable-preview 以启用 &lt;span&gt;instanceof&lt;/span&gt; 中的模式匹配）&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那是因为此功能是&lt;strong&gt;「预览特性」&lt;/strong&gt;，需要你主动开启，如下：&lt;img data-ratio=&quot;0.5211678832116788&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKIAXa5picIWmfJFiaauRyaNyN4s4CicmmFdksVuM8jQ14CtUXyNvibFJR8Q73SndrTMSwiclicc457pm3EA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;685&quot;/&gt;注意：此特性在&lt;strong&gt;「JDK15」&lt;/strong&gt;中依旧为预览版。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;三、实用的NullPointerException&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;略。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;四、Record（预览）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java年纪太大，语法不够新潮，有时候确实太麻烦，因此有了Record的出现：干掉那些get/set、toString、equals等方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; record &lt;span&gt;Person&lt;/span&gt;&lt;span&gt;(String name,Integer age)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Person person= &lt;span&gt;new&lt;/span&gt; Person(&lt;span&gt;&quot;YourBatman&quot;&lt;/span&gt;, &lt;span&gt;18&lt;/span&gt;);&lt;br/&gt;    System.out.println(person);&lt;br/&gt;    System.out.println(person.name());&lt;br/&gt;    System.out.println(person.age());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行程序，结果打印：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Person[name=YourBatman, age=&lt;span&gt;18&lt;/span&gt;]&lt;br/&gt;YourBatman&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：此特性在&lt;strong&gt;「JDK15」&lt;/strong&gt;中依旧为预览版。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;五、文本块Text Blocks（二次预览）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个特性可是非常好用，它属于二次预览：已在JDK 13预览过一次。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    String html = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;br/&gt;          &amp;lt;html&amp;gt;&lt;br/&gt;              &amp;lt;body&amp;gt;&lt;br/&gt;                  &amp;lt;p&amp;gt;hello world&amp;lt;/p&amp;gt;&lt;br/&gt;              &amp;lt;/body&amp;gt;&lt;br/&gt;          &amp;lt;/html&amp;gt;&lt;br/&gt;          &quot;&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;    String query = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;br/&gt;           SELECT * from USER&lt;br/&gt;           WHERE `id` = 1&lt;br/&gt;           ORDER BY `id`, `name`;&lt;br/&gt;           &quot;&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JDK13中，这种是&lt;strong&gt;「有」&lt;/strong&gt;换行的。在JDK14中，可以加上一个符号让其不让换行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    String query = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;br/&gt;           SELECT * from USER \&lt;br/&gt;           WHERE `id` = 1 \&lt;br/&gt;           ORDER BY `id`, `name`;\&lt;br/&gt;           &quot;&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;    System.out.println(query);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行程序，输出（可以看到展示为一行了）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SELECT * from USER WHERE `id` = &lt;span&gt;1&lt;/span&gt; ORDER BY `id`, `name`;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：此特性在&lt;strong&gt;「JDK15」&lt;/strong&gt;中已经为正式版。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;六、删除CMS垃圾收集器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这款著名的垃圾回收器从这个版本就彻底被删除了。JDK9开始使用G1作为&lt;strong&gt;「默认」&lt;/strong&gt;的垃圾回收器（JDK11中ZGC开始崭露头角），就已经把CMS标记为过期了，在此版本正式删除。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;七、ZGC垃圾回收器（实验）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;革命性的ZGC：任意堆大小（TB级别）都能保证延迟在10ms以内，是以低延迟为首要目标的一款垃圾回收器。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;在JDK14之前，ZGC只能用于Linux上，现在也可使用在windows上了&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：此特性在&lt;strong&gt;「JDK15」&lt;/strong&gt;中已经为正式版（JDK11开始出现）。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JDK15新特性&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了JDK14新特性回顾做铺垫，再来了解JDK15的新特性就方便很多了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;特别说明：运行JDK15需要IDEA 2020.2才能支持哦（JDK14要求IDEA 2020.1），然后关于IDEA 2020.2的使用教程（新特性），请移步我公众号前面发的这篇文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0MTUwOTgyOQ==&amp;amp;mid=2247489897&amp;amp;idx=1&amp;amp;sn=d37f8e59beede8eec350087865b5948d&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;IntelliJ IDEA 2020.2正式发布，诸多亮点总有几款能助你提效&lt;/a&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;一、文本块Text Blocks&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Text Blocks首次是在JDK 13中以预览功能出现的，然后在JDK 14中又预览了一次，终于在JDK 15中被确定下来，可放心使用了（使用示例请参考文上）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;二、ZGC转正&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZGC是Java 11引入的新的垃圾收集器（JDK9以后默认的垃圾回收器是G1），经过了多个实验阶段，自此终于成为正式特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZGC是一个重新设计的并发的垃圾回收器，可以极大的提升GC的性能。支持任意堆大小而保持稳定的低延迟（10ms以内），性能非常可观。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打开方式：使用-XX:+UseZGC命令行参数打开，相信不久的将来它必将成为&lt;strong&gt;「默认的」&lt;/strong&gt;垃圾回收器。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;三、Shenandoah转正&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么形容Shenandoah和ZGC的关系呢？异同点大概如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;相同点：性能几乎可认为是相同的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「不同点」&lt;/strong&gt;：ZGC是Oracle JDK的，根正苗红。而Shenandoah只存在于OpenJDK中，因此使用时需注意你的JDK版本&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打开方式：使用-XX:+UseShenandoahGC命令行参数打开。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;四、删除Nashorn JavaScript Engine&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nashorn是在JDK提出的脚本执行引擎，早在JDK11就已经把它标记为过期了，JDK15完全移除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JDK11中取以代之的是GraalVM。GraalVM是一个运行时平台，它支持Java和其他基于Java字节码的语言，但也支持其他语言，如JavaScript，Ruby，Python或LLVM。&lt;strong&gt;「性能是Nashorn的2倍以上」&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;五、CharSequence新增isEmpty默认方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;啥都不说，源码一看便知：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@since&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isEmpty&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.length() == &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;String实现了CharSequence接口的，这应该地球人都知道吧。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;升级建议&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自己玩玩就行，毕竟不是LTS版本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「但是」&lt;/strong&gt;，虽然说仅限于自己玩玩就行，但不代表就没有关注的意义哈。还是那个道理，如果JDK12、13、14、15...都不关注些的话，到时候突然来个JDK17的LTS版本，接受起来就会稍显困难。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;✍总结&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK15整体来看新特性方面并不算很亮眼，它主要是对之前版本&lt;strong&gt;「预览特性」&lt;/strong&gt;的功能做了确定，如文本块、ZGC等，这么一来我们就可以放心大胆的使用啦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;半年一次的发版速度真心学不动了，不过还好我有我的坚持：&lt;strong&gt;「你发任你发，我用Java8。」&lt;/strong&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;✔推荐阅读：&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>573b11a3457f4a9b8a33f127254cd3c4</guid>
<title>Java 15 的新特性</title>
<link>https://toutiao.io/k/1zo4ozy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;article fmt article-content&quot; data-id=&quot;1190000024485709&quot; data-license=&quot;cc&quot;&gt;
                                                    &lt;blockquote&gt;Java语言特性系列&lt;/blockquote&gt;&lt;h2&gt;序&lt;/h2&gt;&lt;p&gt;本文主要讲述一下Java15的新特性&lt;/p&gt;&lt;h2&gt;版本号&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;java -version
openjdk version &quot;15&quot; 2020-09-15
OpenJDK Runtime Environment (build 15+36-1562)
OpenJDK 64-Bit Server VM (build 15+36-1562, mixed mode, sharing)&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;从version信息可以看出是build 15+36&lt;/blockquote&gt;&lt;h2&gt;特性列表&lt;/h2&gt;&lt;blockquote&gt;新增&lt;a href=&quot;https://tools.ietf.org/html/rfc8032&quot; rel=&quot;nofollow noreferrer&quot;&gt;rfc8032&lt;/a&gt;描述的Edwards-Curve Digital Signature Algorithm (EdDSA)实现&lt;br/&gt;使用示例&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;// example: generate a key pair and sign
KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;Ed25519&quot;);
KeyPair kp = kpg.generateKeyPair();
// algorithm is pure Ed25519
Signature sig = Signature.getInstance(&quot;Ed25519&quot;);
sig.initSign(kp.getPrivate());
sig.update(msg);
byte[] s = sig.sign();

// example: use KeyFactory to contruct a public key
KeyFactory kf = KeyFactory.getInstance(&quot;EdDSA&quot;);
boolean xOdd = ...
BigInteger y = ...
NamedParameterSpec paramSpec = new NamedParameterSpec(&quot;Ed25519&quot;);
EdECPublicKeySpec pubSpec = new EdECPublicKeySpec(paramSpec, new EdPoint(xOdd, y));
PublicKey pubKey = kf.generatePublic(pubSpec);&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;JDK15引入了sealed classes and interfaces.用于限定实现类，限定父类的使用，为后续的pattern matching的exhaustive analysis提供便利&lt;br/&gt;示例&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;package com.example.geometry;

public abstract sealed class Shape
    permits Circle, Rectangle, Square {...}

public final class Circle extends Shape {...}

public sealed class Rectangle extends Shape 
    permits TransparentRectangle, FilledRectangle {...}
public final class TransparentRectangle extends Rectangle {...}
public final class FilledRectangle extends Rectangle {...}

public non-sealed class Square extends Shape {...}&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;这里使用了3个关键字，一个是sealed，一个是permits，一个是non-sealed；permits的这些子类要么使用final，要么使用sealed，要么使用non-sealed修饰；针对record类型，也可以使用sealed，因为record类型暗示这final&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;package com.example.expression;

public sealed interface Expr
    permits ConstantExpr, PlusExpr, TimesExpr, NegExpr {...}

public record ConstantExpr(int i)       implements Expr {...}
public record PlusExpr(Expr a, Expr b)  implements Expr {...}
public record TimesExpr(Expr a, Expr b) implements Expr {...}
public record NegExpr(Expr e)           implements Expr {...}&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;JDK15引入了Hidden Classes，同时废弃了非标准的sun.misc.Unsafe::defineAnonymousClass，目标是为frameworks提供在运行时生成内部的class&lt;/blockquote&gt;&lt;blockquote&gt;JDK15移除了Nashorn JavaScript Engine及jjs tool，它们在JDK11的被标记为废弃；具体就是jdk.scripting.nashorn及jdk.scripting.nashorn.shell这两个模块被移除了&lt;/blockquote&gt;&lt;blockquote&gt;该特性使用更简单及更现代的方式重新实现了java.net.DatagramSocket及java.net.MulticastSocket以方便更好的维护及debug，新的实现将会更容易支持virtual threads&lt;/blockquote&gt;&lt;blockquote&gt;该特性默认禁用了biased locking(&lt;code&gt;-XX:+UseBiasedLocking&lt;/code&gt;)，并且废弃了所有相关的命令行选型(&lt;code&gt;BiasedLockingStartupDelay, BiasedLockingBulkRebiasThreshold, BiasedLockingBulkRevokeThreshold, BiasedLockingDecayTime, UseOptoBiasInlining, PrintBiasedLockingStatistics and PrintPreciseBiasedLockingStatistics&lt;/code&gt;)&lt;/blockquote&gt;&lt;blockquote&gt;instanceof的Pattern Matching在JDK15进行Second Preview，示例如下:&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;public boolean equals(Object o) { 
    return (o instanceof CaseInsensitiveString cis) &amp;amp;&amp;amp; 
        cis.s.equalsIgnoreCase(s); 
}&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;ZGC在JDK11被作为experimental feature引入，在JDK15变成Production，但是这并不是替换默认的GC，默认的GC仍然还是G1；之前需要通过&lt;code&gt;-XX:+UnlockExperimentalVMOptions -XX:+UseZGC&lt;/code&gt;来启用ZGC，现在只需要&lt;code&gt;-XX:+UseZGC&lt;/code&gt;就可以&lt;br/&gt;相关的参数有ZAllocationSpikeTolerance、ZCollectionInterval、ZFragmentationLimit、ZMarkStackSpaceLimit、ZProactive、ZUncommit、ZUncommitDelay&lt;br/&gt;ZGC-specific JFR events(&lt;code&gt;ZAllocationStall、ZPageAllocation、ZPageCacheFlush、ZRelocationSet、ZRelocationSetGroup、ZUncommit&lt;/code&gt;)也从experimental变为product&lt;/blockquote&gt;&lt;blockquote&gt;Text Blocks在JDK13被作为preview feature引入，在JDK14作为Second Preview，在JDK15变为最终版&lt;/blockquote&gt;&lt;blockquote&gt;Shenandoah在JDK12被作为experimental引入，在JDK15变为Production；之前需要通过&lt;code&gt;-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC&lt;/code&gt;来启用，现在只需要&lt;code&gt;-XX:+UseShenandoahGC&lt;/code&gt;即可启用&lt;/blockquote&gt;&lt;blockquote&gt;Solaris and SPARC Ports在JDK14被标记为废弃，在JDK15版本正式移除&lt;/blockquote&gt;&lt;blockquote&gt;Foreign-Memory Access API在JDK14被作为incubating API引入，在JDK15处于Second Incubator&lt;/blockquote&gt;&lt;blockquote&gt;Records在JDK14被作为preview引入，在JDK15处于Second Preview&lt;/blockquote&gt;&lt;blockquote&gt;JDK15废弃了RMI Activation，后续将被移除&lt;/blockquote&gt;&lt;h2&gt;细项解读&lt;/h2&gt;&lt;p&gt;上面列出的是大方面的特性，除此之外还有一些api的更新及废弃，主要见&lt;a href=&quot;http://jdk.java.net/15/release-notes&quot; rel=&quot;nofollow noreferrer&quot;&gt;JDK 15 Release Notes&lt;/a&gt;，这里举几个例子。&lt;/p&gt;&lt;h3&gt;添加项&lt;/h3&gt;&lt;blockquote&gt;升级了Unicode，支持Unicode 13.0&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;Added isEmpty Default Method to CharSequence (&lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8215401&quot; rel=&quot;nofollow noreferrer&quot;&gt;JDK-8215401&lt;/a&gt;)&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;给CharSequence新增了isEmpty方法&lt;br/&gt;java.base/java/lang/CharSequence.java&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;    /**
     * Returns {@code true} if this character sequence is empty.
     *
     * @implSpec
     * The default implementation returns the result of calling {@code length() == 0}.
     *
     * @return {@code true} if {@link #length()} is {@code 0}, otherwise
     * {@code false}
     *
     * @since 15
     */
    default boolean isEmpty() {
        return this.length() == 0;
    }&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;Added Support for SO_INCOMING_NAPI_ID Support (&lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8243099&quot; rel=&quot;nofollow noreferrer&quot;&gt;JDK-8243099&lt;/a&gt;)&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;jdk.net.ExtendedSocketOptions新增了SO_INCOMING_NAPI_ID选型&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;Specialized Implementations of TreeMap Methods (&lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8176894&quot; rel=&quot;nofollow noreferrer&quot;&gt;JDK-8176894&lt;/a&gt;)&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;JDK15对TreeMap提供了putIfAbsent, computeIfAbsent, computeIfPresent, compute, merge方法提供了overriding实现&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;New Option Added to jcmd for Writing a gzipped Heap Dump (&lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8237354&quot; rel=&quot;nofollow noreferrer&quot;&gt;JDK-8237354&lt;/a&gt;)&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;jcmd的GC.heap_dump命令现在支持gz选型，以dump出gzip压缩版的heap；compression level从1(&lt;code&gt;fastest&lt;/code&gt;)到9(&lt;code&gt;slowest, but best compression&lt;/code&gt;)，默认为1&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;New System Properties to Configure the TLS Signature Schemes (&lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8242141&quot; rel=&quot;nofollow noreferrer&quot;&gt;JDK-8242141&lt;/a&gt;)&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;新增了&lt;code&gt;jdk.tls.client.SignatureSchemes&lt;/code&gt;及&lt;code&gt;jdk.tls.server.SignatureSchemes&lt;/code&gt;用于配置TLS Signature Schemes&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;Support for certificate_authorities Extension (&lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8206925&quot; rel=&quot;nofollow noreferrer&quot;&gt;JDK-8206925&lt;/a&gt;)&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;支持certificate_authorities的扩展&lt;/blockquote&gt;&lt;h3&gt;移除项&lt;/h3&gt;&lt;blockquote&gt;淘汰了-XX:UseAdaptiveGCBoundary&lt;/blockquote&gt;&lt;h3&gt;废弃项&lt;/h3&gt;&lt;blockquote&gt;废弃了ForceNUMA选项&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;Disable Native SunEC Implementation by Default (&lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8237219&quot; rel=&quot;nofollow noreferrer&quot;&gt;JDK-8237219&lt;/a&gt;)&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;默认禁用了Native SunEC Implementation&lt;/blockquote&gt;&lt;h3&gt;已知问题&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;java.net.HttpClient Does Not Override Protocols Specified in SSLContext Default Parameters (&lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8239594&quot; rel=&quot;nofollow noreferrer&quot;&gt;JDK-8239594&lt;/a&gt;)&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;HttpClient现在没有覆盖在SSLContext Default Parameters中指定的Protocols&lt;/blockquote&gt;&lt;h3&gt;其他事项&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;DatagramPacket.getPort() Returns 0 When the Port Is Not Set (&lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8237890&quot; rel=&quot;nofollow noreferrer&quot;&gt;JDK-8237890&lt;/a&gt;)&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;当DatagramPacket没有设置port的时候，其getPort方法返回0&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;Improved Ergonomics for G1 Heap Region Size (&lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8241670&quot; rel=&quot;nofollow noreferrer&quot;&gt;JDK-8241670&lt;/a&gt;)&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;优化了默认G1 Heap Region Size的计算&lt;/blockquote&gt;&lt;h2&gt;小结&lt;/h2&gt;&lt;p&gt;Java15主要有如下几个特性&lt;/p&gt;&lt;h2&gt;doc&lt;/h2&gt;
                                                &lt;/article&gt;

                                                

                                                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5a40fe546b5db1003465bd7809db84e9</guid>
<title>分布式事务解决方案常见误区与实用建议</title>
<link>https://toutiao.io/k/h9nal21</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;CREATE TABLE `t_local_message`(&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; id BIGINT PRIMARY KEY COMMENT &#x27;主键&#x27;,&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  module INT NOT NULL COMMENT &#x27;消息模块&#x27;,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  tag VARCHAR(20) NOT NULL COMMENT &#x27;消息标签&#x27;,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  business_key VARCHAR(60) NOT NULL COMMENT &#x27;业务键&#x27;,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  queue VARCHAR(60) NOT NULL COMMENT &#x27;队列&#x27;,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  exchange VARCHAR(60) NOT NULL COMMENT &#x27;交换器&#x27;,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  exchange_type VARCHAR(10) NOT NULL COMMENT &#x27;交换器类型&#x27;,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  routing_key VARCHAR(60) NOT NULL COMMENT &#x27;路由键&#x27;,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  retry_times TINYINT NOT NULL DEFAULT 0 COMMENT &#x27;重试次数&#x27;,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建日期时间&#x27;,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  edit_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改日期时间&#x27;,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  seq_no VARCHAR(60) NOT NULL COMMENT &#x27;流水号&#x27;,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  message_status TINYINT NOT NULL DEFAULT 0 COMMENT &#x27;消息状态&#x27;,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  INDEX idx_business_key(business_key),&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  INDEX idx_create_time(create_time),&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  UNIQUE uniq_seq_no(seq_no)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;)COMMENT &#x27;本地消息表&#x27;;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CREATE TABLE `t_local_message_content`(&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  id BIGINT PRIMARY KEY COMMENT &#x27;主键&#x27;,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  message_id BIGINT NOT NULL COMMENT &#x27;本地消息表主键&#x27;,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  message_content TEXT COMMENT &#x27;消息内容&#x27;,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  UNIQUE uniq_message_id(message_id)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;)COMMENT &#x27;本地消息内容表&#x27;;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3371eb91b7fc8474b0286cbe704f9f89</guid>
<title>一份不可多得的 TS 学习指南</title>
<link>https://toutiao.io/k/9ntbcds</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阿宝哥第一次使用 TypeScript 是在 Angular 2.x 项目中，那时候 TypeScript 还没有进入大众的视野。而现在学习 TypeScript 的小伙伴越来越多了，本文阿宝哥将从 &lt;strong&gt;16&lt;/strong&gt; 个方面入手，带你一步步学习 TypeScript，感兴趣的小伙伴不要错过。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.98515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jQmwTIFl1V2pdRian6Xlm7wMdPrPspib15GK8rgIMZzZdgIFa7624sY9DQiacuPXNXUvJmfZ28qdibicMRiaV8TQCg3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;一、TypeScript 是什么&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。下图显示了 TypeScript 与 ES5、ES2015 和 ES2016 之间的关系：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jQmwTIFl1V2pdRian6Xlm7wMdPrPspib153bNjzibqnYnq2dcSo7rSAbSZp8sQT9eiblVNnH8kDsA0gW9mdEGm94jQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;383&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 TypeScript 与 JavaScript 的区别&lt;span/&gt;&lt;/h4&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;TypeScript&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;JavaScript 的超集用于解决大型项目的代码复杂性&lt;/td&gt;&lt;td&gt;一种脚本语言，用于创建动态网页&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;可以在编译期间发现并纠正错误&lt;/td&gt;&lt;td&gt;作为一种解释型语言，只能在运行时发现错误&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;强类型，支持静态和动态类型&lt;/td&gt;&lt;td&gt;弱类型，没有静态类型选项&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;最终被编译成 JavaScript 代码，使浏览器可以理解&lt;/td&gt;&lt;td&gt;可以直接在浏览器中使用&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;支持模块、泛型和接口&lt;/td&gt;&lt;td&gt;不支持模块，泛型或接口&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;社区的支持仍在增长，而且还不是很大&lt;/td&gt;&lt;td&gt;大量的社区支持以及大量文档和解决问题的支持&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 获取 TypeScript&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命令行的 TypeScript 编译器可以使用 npm 包管理器来安装。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.安装 TypeScript&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; npm install -g typescript&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.验证 TypeScript&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; tsc -v &lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Version 4.0.2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.编译 TypeScript 文件&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; tsc helloworld.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; helloworld.ts =&amp;gt; helloworld.js&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，对刚入门 TypeScript 的小伙伴来说，也可以不用安装 &lt;code&gt;typescript&lt;/code&gt;，而是直接使用线上的 TypeScript Playground 来学习新的语法或新特性。通过配置 &lt;strong&gt;TS Config&lt;/strong&gt; 的 Target，可以设置不同的编译目标，从而编译生成不同的目标代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图示例中所设置的编译目标是 ES5：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3997050147492625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2pdRian6Xlm7wMdPrPspib15n2OUlg8ordEyrWEC3EG1x1OkwjJKxicDSwk7IOsDSPqI1VWExfGahBw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1356&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（图片来源：https://www.typescriptlang.org/play）&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3 典型 TypeScript 工作流程&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2654424040066778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2pdRian6Xlm7wMdPrPspib15XjqXlmSJfc3T656NtXuNqvVISukJhvzKFWzghvPC2gQBJ9bom7UiaOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1198&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如你所见，在上图中包含 3 个 ts 文件：a.ts、b.ts 和 c.ts。这些文件将被 TypeScript 编译器，根据配置的编译选项编译成 3 个 js 文件，即 a.js、b.js 和 c.js。对于大多数使用 TypeScript 开发的 Web 项目，我们还会对编译生成的 js 文件进行打包处理，然后在进行部署。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.4 TypeScript 初体验&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新建一个 &lt;code&gt;hello.ts&lt;/code&gt; 文件，并输入以下内容：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;greet&lt;/span&gt;(&lt;span&gt;person: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&#x27;Hello, &#x27;&lt;/span&gt; + person;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(greet(&lt;span&gt;&quot;TypeScript&quot;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后执行 &lt;code&gt;tsc hello.ts&lt;/code&gt; 命令，之后会生成一个编译好的文件 &lt;code&gt;hello.js&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&quot;use strict&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;greet&lt;/span&gt;(&lt;span&gt;person&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&#x27;Hello, &#x27;&lt;/span&gt; + person;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(greet(&lt;span&gt;&quot;TypeScript&quot;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;观察以上编译后的输出结果，我们发现 &lt;code&gt;person&lt;/code&gt; 参数的类型信息在编译后被擦除了。TypeScript 只会在编译阶段对类型进行静态检查，如果发现有错误，编译时就会报错。而在运行时，编译生成的 JS 与普通的 JavaScript 文件一样，并不会进行类型检查。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;二、TypeScript 基础类型&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 Boolean 类型&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; isDone: &lt;span&gt;boolean&lt;/span&gt; = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;// ES5：var isDone = false;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 Number 类型&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; count: &lt;span&gt;number&lt;/span&gt; = &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;// ES5：var count = 10;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 String 类型&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; name: &lt;span&gt;string&lt;/span&gt; = &lt;span&gt;&quot;semliker&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;// ES5：var name = &#x27;semlinker&#x27;;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 Symbol 类型&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; sym = Symbol();&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; obj = {&lt;br/&gt;  [sym]: &lt;span&gt;&quot;semlinker&quot;&lt;/span&gt;,&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(obj[sym]); &lt;span&gt;// semlinker &lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5 Array 类型&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; list: &lt;span&gt;number&lt;/span&gt;[] = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;// ES5：var list = [1,2,3];&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; list: &lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;number&lt;/span&gt;&amp;gt; = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]; &lt;span&gt;// Array&amp;lt;number&amp;gt;泛型语法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// ES5：var list = [1,2,3];&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.6 Enum 类型&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript 支持数字的和基于字符串的枚举。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.数字枚举&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;enum&lt;/span&gt; Direction {&lt;br/&gt;  NORTH,&lt;br/&gt;  SOUTH,&lt;br/&gt;  EAST,&lt;br/&gt;  WEST,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; dir: Direction = Direction.NORTH;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下，NORTH 的初始值为 0，其余的成员会从 1 开始自动增长。换句话说，Direction.SOUTH 的值为 1，Direction.EAST 的值为 2，Direction.WEST 的值为 3。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上的枚举示例经编译后，对应的 ES5 代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&quot;use strict&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; Direction;&lt;br/&gt;(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;Direction&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  Direction[(Direction[&lt;span&gt;&quot;NORTH&quot;&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;)] = &lt;span&gt;&quot;NORTH&quot;&lt;/span&gt;;&lt;br/&gt;  Direction[(Direction[&lt;span&gt;&quot;SOUTH&quot;&lt;/span&gt;] = &lt;span&gt;1&lt;/span&gt;)] = &lt;span&gt;&quot;SOUTH&quot;&lt;/span&gt;;&lt;br/&gt;  Direction[(Direction[&lt;span&gt;&quot;EAST&quot;&lt;/span&gt;] = &lt;span&gt;2&lt;/span&gt;)] = &lt;span&gt;&quot;EAST&quot;&lt;/span&gt;;&lt;br/&gt;  Direction[(Direction[&lt;span&gt;&quot;WEST&quot;&lt;/span&gt;] = &lt;span&gt;3&lt;/span&gt;)] = &lt;span&gt;&quot;WEST&quot;&lt;/span&gt;;&lt;br/&gt;})(Direction || (Direction = {}));&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; dir = Direction.NORTH;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然我们也可以设置 NORTH 的初始值，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;enum&lt;/span&gt; Direction {&lt;br/&gt;  NORTH = &lt;span&gt;3&lt;/span&gt;,&lt;br/&gt;  SOUTH,&lt;br/&gt;  EAST,&lt;br/&gt;  WEST,&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.字符串枚举&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 TypeScript 2.4 版本，允许我们使用字符串枚举。在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;enum&lt;/span&gt; Direction {&lt;br/&gt;  NORTH = &lt;span&gt;&quot;NORTH&quot;&lt;/span&gt;,&lt;br/&gt;  SOUTH = &lt;span&gt;&quot;SOUTH&quot;&lt;/span&gt;,&lt;br/&gt;  EAST = &lt;span&gt;&quot;EAST&quot;&lt;/span&gt;,&lt;br/&gt;  WEST = &lt;span&gt;&quot;WEST&quot;&lt;/span&gt;,&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上代码对应的 ES5 代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&quot;use strict&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; Direction;&lt;br/&gt;(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;Direction&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    Direction[&lt;span&gt;&quot;NORTH&quot;&lt;/span&gt;] = &lt;span&gt;&quot;NORTH&quot;&lt;/span&gt;;&lt;br/&gt;    Direction[&lt;span&gt;&quot;SOUTH&quot;&lt;/span&gt;] = &lt;span&gt;&quot;SOUTH&quot;&lt;/span&gt;;&lt;br/&gt;    Direction[&lt;span&gt;&quot;EAST&quot;&lt;/span&gt;] = &lt;span&gt;&quot;EAST&quot;&lt;/span&gt;;&lt;br/&gt;    Direction[&lt;span&gt;&quot;WEST&quot;&lt;/span&gt;] = &lt;span&gt;&quot;WEST&quot;&lt;/span&gt;;&lt;br/&gt;})(Direction || (Direction = {}));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过观察数字枚举和字符串枚举的编译结果，我们可以知道数字枚举除了支持 &lt;strong&gt;从成员名称到成员值&lt;/strong&gt; 的普通映射之外，它还支持 &lt;strong&gt;从成员值到成员名称&lt;/strong&gt; 的反向映射：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;enum&lt;/span&gt; Direction {&lt;br/&gt;  NORTH,&lt;br/&gt;  SOUTH,&lt;br/&gt;  EAST,&lt;br/&gt;  WEST,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; dirName = Direction[&lt;span&gt;0&lt;/span&gt;]; &lt;span&gt;// NORTH&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; dirVal = Direction[&lt;span&gt;&quot;NORTH&quot;&lt;/span&gt;]; &lt;span&gt;// 0&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，对于纯字符串枚举，我们不能省略任何初始化程序。而数字枚举如果没有显式设置值时，则会使用默认规则进行初始化。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.常量枚举&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了数字枚举和字符串枚举之外，还有一种特殊的枚举 —— 常量枚举。它是使用 &lt;code&gt;const&lt;/code&gt; 关键字修饰的枚举，常量枚举会使用内联语法，不会为枚举类型编译生成任何 JavaScript。为了更好地理解这句话，我们来看一个具体的例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; Direction {&lt;br/&gt;  NORTH,&lt;br/&gt;  SOUTH,&lt;br/&gt;  EAST,&lt;br/&gt;  WEST,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; dir: Direction = Direction.NORTH;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上代码对应的 ES5 代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&quot;use strict&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; dir = &lt;span&gt;0&lt;/span&gt; &lt;span&gt;/* NORTH */&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.异构枚举&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异构枚举的成员值是数字和字符串的混合：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;enum&lt;/span&gt; Enum {&lt;br/&gt;  A,&lt;br/&gt;  B,&lt;br/&gt;  C = &lt;span&gt;&quot;C&quot;&lt;/span&gt;,&lt;br/&gt;  D = &lt;span&gt;&quot;D&quot;&lt;/span&gt;,&lt;br/&gt;  E = &lt;span&gt;8&lt;/span&gt;,&lt;br/&gt;  F,&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上代码对于的 ES5 代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&quot;use strict&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; Enum;&lt;br/&gt;(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;Enum&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    Enum[Enum[&lt;span&gt;&quot;A&quot;&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;&quot;A&quot;&lt;/span&gt;;&lt;br/&gt;    Enum[Enum[&lt;span&gt;&quot;B&quot;&lt;/span&gt;] = &lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;&quot;B&quot;&lt;/span&gt;;&lt;br/&gt;    Enum[&lt;span&gt;&quot;C&quot;&lt;/span&gt;] = &lt;span&gt;&quot;C&quot;&lt;/span&gt;;&lt;br/&gt;    Enum[&lt;span&gt;&quot;D&quot;&lt;/span&gt;] = &lt;span&gt;&quot;D&quot;&lt;/span&gt;;&lt;br/&gt;    Enum[Enum[&lt;span&gt;&quot;E&quot;&lt;/span&gt;] = &lt;span&gt;8&lt;/span&gt;] = &lt;span&gt;&quot;E&quot;&lt;/span&gt;;&lt;br/&gt;    Enum[Enum[&lt;span&gt;&quot;F&quot;&lt;/span&gt;] = &lt;span&gt;9&lt;/span&gt;] = &lt;span&gt;&quot;F&quot;&lt;/span&gt;;&lt;br/&gt;})(Enum || (Enum = {}));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过观察上述生成的 ES5 代码，我们可以发现数字枚举相对字符串枚举多了 “反向映射”：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;console&lt;/span&gt;.log(Enum.A) &lt;span&gt;//输出：0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(Enum[&lt;span&gt;0&lt;/span&gt;]) &lt;span&gt;// 输出：A&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.7 Any 类型&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 TypeScript 中，任何类型都可以被归为 any 类型。这让 any 类型成为了类型系统的顶级类型（也被称作全局超级类型）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; notSure: &lt;span&gt;any&lt;/span&gt; = &lt;span&gt;666&lt;/span&gt;;&lt;br/&gt;notSure = &lt;span&gt;&quot;semlinker&quot;&lt;/span&gt;;&lt;br/&gt;notSure = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;any&lt;/code&gt; 类型本质上是类型系统的一个逃逸舱。作为开发者，这给了我们很大的自由：TypeScript 允许我们对 &lt;code&gt;any&lt;/code&gt; 类型的值执行任何操作，而无需事先执行任何形式的检查。比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; value: &lt;span&gt;any&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;value.foo.bar; &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;value.trim(); &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;value(); &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;&lt;span&gt;new&lt;/span&gt; value(); &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;value[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;1&lt;/span&gt;]; &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在许多场景下，这太宽松了。使用 &lt;code&gt;any&lt;/code&gt; 类型，可以很容易地编写类型正确但在运行时有问题的代码。如果我们使用 &lt;code&gt;any&lt;/code&gt; 类型，就无法使用 TypeScript 提供的大量的保护机制。为了解决 &lt;code&gt;any&lt;/code&gt; 带来的问题，TypeScript 3.0 引入了 &lt;code&gt;unknown&lt;/code&gt; 类型。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.8 Unknown 类型&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就像所有类型都可以赋值给 &lt;code&gt;any&lt;/code&gt;，所有类型也都可以赋值给 &lt;code&gt;unknown&lt;/code&gt;。这使得 &lt;code&gt;unknown&lt;/code&gt; 成为 TypeScript 类型系统的另一种顶级类型（另一种是 &lt;code&gt;any&lt;/code&gt;）。下面我们来看一下 &lt;code&gt;unknown&lt;/code&gt; 类型的使用示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; value: unknown;&lt;br/&gt;&lt;br/&gt;value = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;value = &lt;span&gt;42&lt;/span&gt;; &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;value = &lt;span&gt;&quot;Hello World&quot;&lt;/span&gt;; &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;value = []; &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;value = {}; &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;value = &lt;span&gt;Math&lt;/span&gt;.random; &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;value = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;value = &lt;span&gt;undefined&lt;/span&gt;; &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;value = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;TypeError&lt;/span&gt;(); &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;value = Symbol(&lt;span&gt;&quot;type&quot;&lt;/span&gt;); &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对 &lt;code&gt;value&lt;/code&gt; 变量的所有赋值都被认为是类型正确的。但是，当我们尝试将类型为 &lt;code&gt;unknown&lt;/code&gt; 的值赋值给其他类型的变量时会发生什么？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; value: unknown;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; value1: unknown = value; &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; value2: &lt;span&gt;any&lt;/span&gt; = value; &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; value3: &lt;span&gt;boolean&lt;/span&gt; = value; &lt;span&gt;// Error&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; value4: &lt;span&gt;number&lt;/span&gt; = value; &lt;span&gt;// Error&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; value5: &lt;span&gt;string&lt;/span&gt; = value; &lt;span&gt;// Error&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; value6: object = value; &lt;span&gt;// Error&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; value7: &lt;span&gt;any&lt;/span&gt;[] = value; &lt;span&gt;// Error&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; value8: &lt;span&gt;Function&lt;/span&gt; = value; &lt;span&gt;// Error&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;unknown&lt;/code&gt; 类型只能被赋值给 &lt;code&gt;any&lt;/code&gt; 类型和 &lt;code&gt;unknown&lt;/code&gt; 类型本身。直观地说，这是有道理的：只有能够保存任意类型值的容器才能保存 &lt;code&gt;unknown&lt;/code&gt; 类型的值。毕竟我们不知道变量 &lt;code&gt;value&lt;/code&gt; 中存储了什么类型的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在让我们看看当我们尝试对类型为 &lt;code&gt;unknown&lt;/code&gt; 的值执行操作时会发生什么。以下是我们在之前 &lt;code&gt;any&lt;/code&gt; 章节看过的相同操作：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; value: unknown;&lt;br/&gt;&lt;br/&gt;value.foo.bar; &lt;span&gt;// Error&lt;/span&gt;&lt;br/&gt;value.trim(); &lt;span&gt;// Error&lt;/span&gt;&lt;br/&gt;value(); &lt;span&gt;// Error&lt;/span&gt;&lt;br/&gt;&lt;span&gt;new&lt;/span&gt; value(); &lt;span&gt;// Error&lt;/span&gt;&lt;br/&gt;value[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;1&lt;/span&gt;]; &lt;span&gt;// Error&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将 &lt;code&gt;value&lt;/code&gt; 变量类型设置为 &lt;code&gt;unknown&lt;/code&gt; 后，这些操作都不再被认为是类型正确的。通过将 &lt;code&gt;any&lt;/code&gt; 类型改变为 &lt;code&gt;unknown&lt;/code&gt; 类型，我们已将允许所有更改的默认设置，更改为禁止任何更改。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.9 Tuple 类型&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;众所周知，数组一般由同种类型的值组成，但有时我们需要在单个变量中存储不同类型的值，这时候我们就可以使用元组&lt;/strong&gt;。在 JavaScript 中是没有元组的，元组是 TypeScript 中特有的类型，其工作方式类似于数组。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;元组可用于定义具有有限数量的未命名属性的类型。每个属性都有一个关联的类型。使用元组时，必须提供每个属性的值。为了更直观地理解元组的概念，我们来看一个具体的例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; tupleType: [&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;boolean&lt;/span&gt;];&lt;br/&gt;tupleType = [&lt;span&gt;&quot;semlinker&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面代码中，我们定义了一个名为 &lt;code&gt;tupleType&lt;/code&gt; 的变量，它的类型是一个类型数组 &lt;code&gt;[string, boolean]&lt;/code&gt;，然后我们按照正确的类型依次初始化 tupleType 变量。与数组一样，我们可以通过下标来访问元组中的元素：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;console&lt;/span&gt;.log(tupleType[&lt;span&gt;0&lt;/span&gt;]); &lt;span&gt;// semlinker&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(tupleType[&lt;span&gt;1&lt;/span&gt;]); &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在元组初始化的时候，如果出现类型不匹配的话，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;tupleType = [&lt;span&gt;true&lt;/span&gt;, &lt;span&gt;&quot;semlinker&quot;&lt;/span&gt;];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，TypeScript 编译器会提示以下错误信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;[0]: Type &lt;span&gt;&#x27;true&#x27;&lt;/span&gt; is not assignable to &lt;span&gt;type&lt;/span&gt; &lt;span&gt;&#x27;string&#x27;&lt;/span&gt;.&lt;br/&gt;[1]: Type &lt;span&gt;&#x27;string&#x27;&lt;/span&gt; is not assignable to &lt;span&gt;type&lt;/span&gt; &lt;span&gt;&#x27;boolean&#x27;&lt;/span&gt;.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很明显是因为类型不匹配导致的。在元组初始化的时候，我们还必须提供每个属性的值，不然也会出现错误，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;tupleType = [&lt;span&gt;&quot;semlinker&quot;&lt;/span&gt;];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，TypeScript 编译器会提示以下错误信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Property &lt;span&gt;&#x27;1&#x27;&lt;/span&gt; is missing &lt;span&gt;in&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; &lt;span&gt;&#x27;[string]&#x27;&lt;/span&gt; but required &lt;span&gt;in&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; &lt;span&gt;&#x27;[string, boolean]&#x27;&lt;/span&gt;.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.10 Void 类型&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 void：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 声明函数返回值为void&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;warnUser&lt;/span&gt;(&lt;span/&gt;): &lt;span&gt;void&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;This is my warning message&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上代码编译生成的 ES5 代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&quot;use strict&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;warnUser&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;This is my warning message&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，声明一个 void 类型的变量没有什么作用，因为它的值只能为 &lt;code&gt;undefined&lt;/code&gt; 或 &lt;code&gt;null&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; unusable: &lt;span&gt;void&lt;/span&gt; = &lt;span&gt;undefined&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.11 Null 和 Undefined 类型&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TypeScript 里，&lt;code&gt;undefined&lt;/code&gt; 和 &lt;code&gt;null&lt;/code&gt; 两者有各自的类型分别为 &lt;code&gt;undefined&lt;/code&gt; 和 &lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; u: &lt;span&gt;undefined&lt;/span&gt; = &lt;span&gt;undefined&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; n: &lt;span&gt;null&lt;/span&gt; = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 是所有类型的子类型。 就是说你可以把 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 赋值给 &lt;code&gt;number&lt;/code&gt; 类型的变量。&lt;strong&gt;然而，如果你指定了&lt;code&gt;--strictNullChecks&lt;/code&gt; 标记，&lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 只能赋值给 &lt;code&gt;void&lt;/code&gt; 和它们各自的类型。&lt;/strong&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.12 object, Object 和 {} 类型&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.object 类型&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;object 类型是：TypeScript 2.2 引入的新类型，它用于表示非原始类型。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// node_modules/typescript/lib/lib.es5.d.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; ObjectConstructor {&lt;br/&gt;  create(o: object | &lt;span&gt;null&lt;/span&gt;): &lt;span&gt;any&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; proto = {};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;Object&lt;/span&gt;.create(proto);     &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Object&lt;/span&gt;.create(&lt;span&gt;null&lt;/span&gt;);      &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Object&lt;/span&gt;.create(&lt;span&gt;undefined&lt;/span&gt;); &lt;span&gt;// Error&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Object&lt;/span&gt;.create(&lt;span&gt;1337&lt;/span&gt;);      &lt;span&gt;// Error&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Object&lt;/span&gt;.create(&lt;span&gt;true&lt;/span&gt;);      &lt;span&gt;// Error&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Object&lt;/span&gt;.create(&lt;span&gt;&quot;oops&quot;&lt;/span&gt;);    &lt;span&gt;// Error&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.Object 类型&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Object 类型：它是所有 Object 类的实例的类型，它由以下两个接口来定义：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Object 接口定义了 Object.prototype 原型对象上的属性；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// node_modules/typescript/lib/lib.es5.d.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; Object {&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;: Function;&lt;br/&gt;  toString(&lt;span/&gt;): string;&lt;br/&gt;  toLocaleString(&lt;span/&gt;): string;&lt;br/&gt;  valueOf(&lt;span/&gt;): Object;&lt;br/&gt;  hasOwnProperty(&lt;span&gt;v: PropertyKey&lt;/span&gt;): boolean;&lt;br/&gt;  isPrototypeOf(&lt;span&gt;v: &lt;span&gt;Object&lt;/span&gt;&lt;/span&gt;): boolean;&lt;br/&gt;  propertyIsEnumerable(&lt;span&gt;v: PropertyKey&lt;/span&gt;): boolean;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ObjectConstructor 接口定义了 Object 类的属性。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// node_modules/typescript/lib/lib.es5.d.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; ObjectConstructor {&lt;br/&gt;  &lt;span&gt;/** Invocation via `new` */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;new&lt;/span&gt;(value?: &lt;span&gt;any&lt;/span&gt;): &lt;span&gt;Object&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;/** Invocation via function calls */&lt;/span&gt;&lt;br/&gt;  (value?: &lt;span&gt;any&lt;/span&gt;): &lt;span&gt;any&lt;/span&gt;;&lt;br/&gt;  readonly prototype: &lt;span&gt;Object&lt;/span&gt;;&lt;br/&gt;  getPrototypeOf(o: &lt;span&gt;any&lt;/span&gt;): &lt;span&gt;any&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// ···&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;declare&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt;: ObjectConstructor;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Object 类的所有实例都继承了 Object 接口中的所有属性。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.{} 类型&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;{} 类型描述了一个没有成员的对象。当你试图访问这样一个对象的任意属性时，TypeScript 会产生一个编译时错误。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Type {}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; obj = {};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Error: Property &#x27;prop&#x27; does not exist on type &#x27;{}&#x27;.&lt;/span&gt;&lt;br/&gt;obj.prop = &lt;span&gt;&quot;semlinker&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，你仍然可以使用在 Object 类型上定义的所有属性和方法，这些属性和方法可通过 JavaScript 的原型链隐式地使用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Type {}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; obj = {};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// &quot;[object Object]&quot;&lt;/span&gt;&lt;br/&gt;obj.toString();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.13 Never 类型&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;never&lt;/code&gt; 类型表示的是那些永不存在的值的类型。 例如，&lt;code&gt;never&lt;/code&gt; 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 返回never的函数必须存在无法达到的终点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;(&lt;span&gt;message: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;never&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(message);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;infiniteLoop&lt;/span&gt;(&lt;span/&gt;): &lt;span&gt;never&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 TypeScript 中，可以利用 never 类型的特性来实现全面性检查，具体示例如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Foo = &lt;span&gt;string&lt;/span&gt; | &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;controlFlowAnalysisWithNever&lt;/span&gt;(&lt;span&gt;foo: Foo&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; foo === &lt;span&gt;&quot;string&quot;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;// 这里 foo 被收窄为 string 类型&lt;/span&gt;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; foo === &lt;span&gt;&quot;number&quot;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;// 这里 foo 被收窄为 number 类型&lt;/span&gt;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// foo 在这里是 never&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; check: never = foo;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意在 else 分支里面，我们把收窄为 never 的 foo 赋值给一个显示声明的 never 变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事修改了 Foo 的类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Foo = &lt;span&gt;string&lt;/span&gt; | &lt;span&gt;number&lt;/span&gt; | &lt;span&gt;boolean&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而他忘记同时修改 &lt;code&gt;controlFlowAnalysisWithNever&lt;/code&gt; 方法中的控制流程，这时候 else 分支的 foo 类型会被收窄为 &lt;code&gt;boolean&lt;/code&gt; 类型，导致无法赋值给 never 类型，这时就会产生一个编译错误。通过这个方式，我们可以确保&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;controlFlowAnalysisWithNever&lt;/code&gt; 方法总是穷尽了 Foo 的所有可能类型。 通过这个示例，我们可以得出一个结论：&lt;strong&gt;使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;三、TypeScript 断言&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 类型断言&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类型断言有两种形式：&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.“尖括号” 语法&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; someValue: &lt;span&gt;any&lt;/span&gt; = &lt;span&gt;&quot;this is a string&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; strLength: &lt;span&gt;number&lt;/span&gt; = (&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;someValue).length;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.as 语法&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; someValue: &lt;span&gt;any&lt;/span&gt; = &lt;span&gt;&quot;this is a string&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; strLength: &lt;span&gt;number&lt;/span&gt; = (someValue &lt;span&gt;as&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;).length;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 非空断言&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上下文中当类型检查器无法断定类型时，一个新的后缀表达式操作符 &lt;code&gt;!&lt;/code&gt; 可以用于断言操作对象是非 null 和非 undefined 类型。&lt;strong&gt;具体而言，x! 将从 x 值域中排除 null 和 undefined 。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么非空断言操作符到底有什么用呢？下面我们先来看一下非空断言操作符的一些使用场景。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.忽略 undefined 和 null 类型&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;myFunc&lt;/span&gt;(&lt;span&gt;maybeString: &lt;span&gt;string&lt;/span&gt; | &lt;span&gt;undefined&lt;/span&gt; | &lt;span&gt;null&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// Type &#x27;string | null | undefined&#x27; is not assignable to type &#x27;string&#x27;.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// Type &#x27;undefined&#x27; is not assignable to type &#x27;string&#x27;. &lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; onlyString: &lt;span&gt;string&lt;/span&gt; = maybeString; &lt;span&gt;// Error&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; ignoreUndefinedAndNull: &lt;span&gt;string&lt;/span&gt; = maybeString!; &lt;span&gt;// Ok&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.调用函数时忽略 undefined 类型&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; NumGenerator = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;myFunc&lt;/span&gt;(&lt;span&gt;numGenerator: NumGenerator | &lt;span&gt;undefined&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// Object is possibly &#x27;undefined&#x27;.(2532)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// Cannot invoke an object which is possibly &#x27;undefined&#x27;.(2722)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; num1 = numGenerator(); &lt;span&gt;// Error&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; num2 = numGenerator!(); &lt;span&gt;//OK&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 &lt;code&gt;!&lt;/code&gt; 非空断言操作符会从编译生成的 JavaScript 代码中移除，所以在实际使用的过程中，要特别注意。比如下面这个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; a: &lt;span&gt;number&lt;/span&gt; | &lt;span&gt;undefined&lt;/span&gt; = &lt;span&gt;undefined&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; b: &lt;span&gt;number&lt;/span&gt; = a!;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(b); &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上 TS 代码会编译生成以下 ES5 代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&quot;use strict&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; a = &lt;span&gt;undefined&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; b = a;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(b);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然在 TS 代码中，我们使用了非空断言，使得 &lt;code&gt;const b: number = a!;&lt;/code&gt; 语句可以通过 TypeScript 类型检查器的检查。但在生成的 ES5 代码中，&lt;code&gt;!&lt;/code&gt; 非空断言操作符被移除了，所以在浏览器中执行以上代码，在控制台会输出 &lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 确定赋值断言&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 TypeScript 2.7 版本中引入了确定赋值断言，即允许在实例属性和变量声明后面放置一个 &lt;code&gt;!&lt;/code&gt; 号，从而告诉 TypeScript 该属性会被明确地赋值。为了更好地理解它的作用，我们来看个具体的例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; x: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;initialize();&lt;br/&gt;&lt;span&gt;// Variable &#x27;x&#x27; is used before being assigned.(2454)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;2&lt;/span&gt; * x); &lt;span&gt;// Error&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;initialize&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  x = &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很明显该异常信息是说变量 x 在赋值前被使用了，要解决该问题，我们可以使用确定赋值断言：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; x!: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;initialize();&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;2&lt;/span&gt; * x); &lt;span&gt;// Ok&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;initialize&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  x = &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 &lt;code&gt;let x!: number;&lt;/code&gt; 确定赋值断言，TypeScript 编译器就会知道该属性会被明确地赋值。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;四、类型守卫&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内。&lt;/strong&gt; 换句话说，类型保护可以保证一个字符串是一个字符串，尽管它的值也可以是一个数值。类型保护与特性检测并不是完全不同，其主要思想是尝试检测属性、方法或原型，以确定如何处理值。目前主要有四种的方式来实现类型保护：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 in 关键字&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Admin {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  privileges: &lt;span&gt;string&lt;/span&gt;[];&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; Employee {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  startDate: &lt;span&gt;Date&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; UnknownEmployee = Employee | Admin;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;printEmployeeInformation&lt;/span&gt;(&lt;span&gt;emp: UnknownEmployee&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;Name: &quot;&lt;/span&gt; + emp.name);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;privileges&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; emp) {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;Privileges: &quot;&lt;/span&gt; + emp.privileges);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;startDate&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; emp) {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;Start Date: &quot;&lt;/span&gt; + emp.startDate);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 typeof 关键字&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;padLeft&lt;/span&gt;(&lt;span&gt;value: &lt;span&gt;string&lt;/span&gt;, padding: &lt;span&gt;string&lt;/span&gt; | &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; padding === &lt;span&gt;&quot;number&quot;&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;(padding + &lt;span&gt;1&lt;/span&gt;).join(&lt;span&gt;&quot; &quot;&lt;/span&gt;) + value;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; padding === &lt;span&gt;&quot;string&quot;&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; padding + value;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;`Expected string or number, got &#x27;&lt;span&gt;${padding}&lt;/span&gt;&#x27;.`&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;typeof&lt;/code&gt; 类型保护只支持两种形式：&lt;code&gt;typeof v === &quot;typename&quot;&lt;/code&gt; 和 &lt;code&gt;typeof v !== typename&lt;/code&gt;，&lt;code&gt;&quot;typename&quot;&lt;/code&gt; 必须是 &lt;code&gt;&quot;number&quot;&lt;/code&gt;， &lt;code&gt;&quot;string&quot;&lt;/code&gt;， &lt;code&gt;&quot;boolean&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;symbol&quot;&lt;/code&gt;。 但是 TypeScript 并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.3 instanceof 关键字&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Padder {&lt;br/&gt;  getPaddingString(): &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; SpaceRepeatingPadder &lt;span&gt;implements&lt;/span&gt; Padder {&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;&lt;span&gt;private&lt;/span&gt; numSpaces: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;) {}&lt;br/&gt;  getPaddingString() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.numSpaces + &lt;span&gt;1&lt;/span&gt;).join(&lt;span&gt;&quot; &quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; StringPadder &lt;span&gt;implements&lt;/span&gt; Padder {&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;&lt;span&gt;private&lt;/span&gt; value: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) {}&lt;br/&gt;  getPaddingString() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.value;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; padder: Padder = &lt;span&gt;new&lt;/span&gt; SpaceRepeatingPadder(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (padder &lt;span&gt;instanceof&lt;/span&gt; SpaceRepeatingPadder) {&lt;br/&gt;  &lt;span&gt;// padder的类型收窄为 &#x27;SpaceRepeatingPadder&#x27;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.4 自定义类型保护的类型谓词&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;isNumber&lt;/span&gt;(&lt;span&gt;x: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;x&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;number&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;typeof&lt;/span&gt; x === &lt;span&gt;&quot;number&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;isString&lt;/span&gt;(&lt;span&gt;x: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;x&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;typeof&lt;/span&gt; x === &lt;span&gt;&quot;string&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;五、联合类型和类型别名&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1 联合类型&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;联合类型通常与 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 一起使用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; sayHello = &lt;span&gt;(&lt;span&gt;name: &lt;span&gt;string&lt;/span&gt; | &lt;span&gt;undefined&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;/* ... */&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，这里 &lt;code&gt;name&lt;/code&gt; 的类型是 &lt;code&gt;string | undefined&lt;/code&gt; 意味着可以将 &lt;code&gt;string&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 的值传递给&lt;code&gt;sayHello&lt;/code&gt; 函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sayHello(&lt;span&gt;&quot;semlinker&quot;&lt;/span&gt;);&lt;br/&gt;sayHello(&lt;span&gt;undefined&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这个示例，你可以凭直觉知道类型 A 和类型 B 联合后的类型是同时接受 A 和 B 值的类型。此外，对于联合类型来说，你可能会遇到以下的用法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; num: &lt;span&gt;1&lt;/span&gt; | &lt;span&gt;2&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; EventNames = &lt;span&gt;&#x27;click&#x27;&lt;/span&gt; | &lt;span&gt;&#x27;scroll&#x27;&lt;/span&gt; | &lt;span&gt;&#x27;mousemove&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上示例中的 &lt;code&gt;1&lt;/code&gt;、&lt;code&gt;2&lt;/code&gt; 或 &lt;code&gt;&#x27;click&#x27;&lt;/code&gt; 被称为字面量类型，用来约束取值只能是某几个值中的一个。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 可辨识联合&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TypeScript 可辨识联合（Discriminated Unions）类型，也称为代数数据类型或标签联合类型。&lt;strong&gt;它包含 3 个要点：可辨识、联合类型和类型守卫。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种类型的本质是结合联合类型和字面量类型的一种类型保护方法。&lt;strong&gt;如果一个类型是多个类型的联合类型，且多个类型含有一个公共属性，那么就可以利用这个公共属性，来创建不同的类型保护区块。&lt;/strong&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.可辨识&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可辨识要求联合类型中的每个元素都含有一个单例类型属性，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;enum&lt;/span&gt; CarTransmission {&lt;br/&gt;  Automatic = &lt;span&gt;200&lt;/span&gt;,&lt;br/&gt;  Manual = &lt;span&gt;300&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; Motorcycle {&lt;br/&gt;  vType: &lt;span&gt;&quot;motorcycle&quot;&lt;/span&gt;; &lt;span&gt;// discriminant&lt;/span&gt;&lt;br/&gt;  make: &lt;span&gt;number&lt;/span&gt;; &lt;span&gt;// year&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; Car {&lt;br/&gt;  vType: &lt;span&gt;&quot;car&quot;&lt;/span&gt;; &lt;span&gt;// discriminant&lt;/span&gt;&lt;br/&gt;  transmission: CarTransmission&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; Truck {&lt;br/&gt;  vType: &lt;span&gt;&quot;truck&quot;&lt;/span&gt;; &lt;span&gt;// discriminant&lt;/span&gt;&lt;br/&gt;  capacity: &lt;span&gt;number&lt;/span&gt;; &lt;span&gt;// in tons&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上述代码中，我们分别定义了 &lt;code&gt;Motorcycle&lt;/code&gt;、 &lt;code&gt;Car&lt;/code&gt; 和 &lt;code&gt;Truck&lt;/code&gt; 三个接口，在这些接口中都包含一个 &lt;code&gt;vType&lt;/code&gt; 属性，该属性被称为可辨识的属性，而其它的属性只跟特性的接口相关。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.联合类型&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于前面定义了三个接口，我们可以创建一个 &lt;code&gt;Vehicle&lt;/code&gt; 联合类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Vehicle = Motorcycle | Car | Truck;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们就可以开始使用 &lt;code&gt;Vehicle&lt;/code&gt; 联合类型，对于 &lt;code&gt;Vehicle&lt;/code&gt; 类型的变量，它可以表示不同类型的车辆。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.类型守卫&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来定义一个 &lt;code&gt;evaluatePrice&lt;/code&gt; 方法，该方法用于根据车辆的类型、容量和评估因子来计算价格，具体实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; EVALUATION_FACTOR = &lt;span&gt;Math&lt;/span&gt;.PI; &lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;evaluatePrice&lt;/span&gt;(&lt;span&gt;vehicle: Vehicle&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; vehicle.capacity * EVALUATION_FACTOR;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; myTruck: Truck = { vType: &lt;span&gt;&quot;truck&quot;&lt;/span&gt;, capacity: &lt;span&gt;9.5&lt;/span&gt; };&lt;br/&gt;evaluatePrice(myTruck);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于以上代码，TypeScript 编译器将会提示以下错误信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Property &lt;span&gt;&#x27;capacity&#x27;&lt;/span&gt; does not exist on &lt;span&gt;type&lt;/span&gt; &lt;span&gt;&#x27;Vehicle&#x27;&lt;/span&gt;.&lt;br/&gt;Property &lt;span&gt;&#x27;capacity&#x27;&lt;/span&gt; does not exist on &lt;span&gt;type&lt;/span&gt; &lt;span&gt;&#x27;Motorcycle&#x27;&lt;/span&gt;.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因是在 Motorcycle 接口中，并不存在 &lt;code&gt;capacity&lt;/code&gt; 属性，而对于 Car 接口来说，它也不存在 &lt;code&gt;capacity&lt;/code&gt; 属性。那么，现在我们应该如何解决以上问题呢？这时，我们可以使用类型守卫。下面我们来重构一下前面定义的 &lt;code&gt;evaluatePrice&lt;/code&gt; 方法，重构后的代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;evaluatePrice&lt;/span&gt;(&lt;span&gt;vehicle: Vehicle&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;switch&lt;/span&gt;(vehicle.vType) {&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;car&quot;&lt;/span&gt;:&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; vehicle.transmission * EVALUATION_FACTOR;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;truck&quot;&lt;/span&gt;:&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; vehicle.capacity * EVALUATION_FACTOR;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;motorcycle&quot;&lt;/span&gt;:&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; vehicle.make * EVALUATION_FACTOR;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以上代码中，我们使用 &lt;code&gt;switch&lt;/code&gt; 和 &lt;code&gt;case&lt;/code&gt; 运算符来实现类型守卫，从而确保在 &lt;code&gt;evaluatePrice&lt;/code&gt; 方法中，我们可以安全地访问 &lt;code&gt;vehicle&lt;/code&gt; 对象中的所包含的属性，来正确的计算该车辆类型所对应的价格。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3 类型别名&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类型别名用来给一个类型起个新名字。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Message = &lt;span&gt;string&lt;/span&gt; | &lt;span&gt;string&lt;/span&gt;[];&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; greet = &lt;span&gt;(&lt;span&gt;message: Message&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;六、交叉类型&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 TypeScript 中交叉类型是将多个类型合并为一个类型。通过 &lt;code&gt;&amp;amp;&lt;/code&gt; 运算符可以将现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; PartialPointX = { x: &lt;span&gt;number&lt;/span&gt;; };&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Point = PartialPointX &amp;amp; { y: &lt;span&gt;number&lt;/span&gt;; };&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; point: Point = {&lt;br/&gt;  x: &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;  y: &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面代码中我们先定义了 &lt;code&gt;PartialPointX&lt;/code&gt; 类型，接着使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 运算符创建一个新的 &lt;code&gt;Point&lt;/code&gt; 类型，表示一个含有 x 和 y 坐标的点，然后定义了一个 &lt;code&gt;Point&lt;/code&gt; 类型的变量并初始化。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.1 同名基础类型属性的合并&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么现在问题来了，假设在合并多个类型的过程中，刚好出现某些类型存在相同的成员，但对应的类型又不一致，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; X {&lt;br/&gt;  c: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  d: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; Y {&lt;br/&gt;  c: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;  e: &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; XY = X &amp;amp; Y;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; YX = Y &amp;amp; X;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; p: XY;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; q: YX;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的代码中，接口 X  和接口 Y 都含有一个相同的成员 c，但它们的类型不一致。对于这种情况，此时 XY 类型或 YX 类型中成员 c 的类型是不是可以是 &lt;code&gt;string&lt;/code&gt; 或 &lt;code&gt;number&lt;/code&gt; 类型呢？比如下面的例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;p = { c: &lt;span&gt;6&lt;/span&gt;, d: &lt;span&gt;&quot;d&quot;&lt;/span&gt;, e: &lt;span&gt;&quot;e&quot;&lt;/span&gt; }; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2736842105263158&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2pdRian6Xlm7wMdPrPspib15C4xUcPVvaAgbQcX3ItGiaThkbqv7icGTqGgofhevCuzKaDiaiaibNSNSvgQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;950&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;q = { c: &lt;span&gt;&quot;c&quot;&lt;/span&gt;, d: &lt;span&gt;&quot;d&quot;&lt;/span&gt;, e: &lt;span&gt;&quot;e&quot;&lt;/span&gt; }; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.22736842105263158&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2pdRian6Xlm7wMdPrPspib159gbr6dlk0GXx037vt3X4C2Vy9kDF5zB3sf3X8Mh8fzpSxUQYMEscgQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;950&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么接口 X 和接口 Y 混入后，成员 c 的类型会变成 &lt;code&gt;never&lt;/code&gt; 呢？这是因为混入后成员 c 的类型为 &lt;code&gt;string &amp;amp; number&lt;/code&gt;，即成员 c 的类型既可以是 &lt;code&gt;string&lt;/code&gt; 类型又可以是 &lt;code&gt;number&lt;/code&gt; 类型。很明显这种类型是不存在的，所以混入后成员 c 的类型为 &lt;code&gt;never&lt;/code&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.2 同名非基础类型属性的合并&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面示例中，刚好接口 X 和接口 Y 中内部成员 c 的类型都是基本数据类型，那么如果是非基本数据类型的话，又会是什么情形。我们来看个具体的例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; D { d: &lt;span&gt;boolean&lt;/span&gt;; }&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; E { e: &lt;span&gt;string&lt;/span&gt;; }&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; F { f: &lt;span&gt;number&lt;/span&gt;; }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; A { x: D; }&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; B { x: E; }&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; C { x: F; }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; ABC = A &amp;amp; B &amp;amp; C;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; abc: ABC = {&lt;br/&gt;  x: {&lt;br/&gt;    d: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;    e: &lt;span&gt;&#x27;semlinker&#x27;&lt;/span&gt;,&lt;br/&gt;    f: &lt;span&gt;666&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;abc:&#x27;&lt;/span&gt;, abc);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上代码成功运行后，控制台会输出以下结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3291139240506329&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2pdRian6Xlm7wMdPrPspib15KrPIsgppYvogPmqBQzHnMYdzPbPx9PtUUvD2wmtMMJhlnlakG8JwIA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;790&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由上图可知，在混入多个类型时，若存在相同的成员，且成员类型为非基本数据类型，那么是可以成功合并。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;七、TypeScript 函数&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.1 TypeScript 函数与 JavaScript 函数的区别&lt;span/&gt;&lt;/h4&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;TypeScript&lt;/th&gt;&lt;th&gt;JavaScript&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;含有类型&lt;/td&gt;&lt;td&gt;无类型&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;箭头函数&lt;/td&gt;&lt;td&gt;箭头函数（ES2015）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;函数类型&lt;/td&gt;&lt;td&gt;无函数类型&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;必填和可选参数&lt;/td&gt;&lt;td&gt;所有参数都是可选的&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;默认参数&lt;/td&gt;&lt;td&gt;默认参数&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;剩余参数&lt;/td&gt;&lt;td&gt;剩余参数&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;函数重载&lt;/td&gt;&lt;td&gt;无函数重载&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.2 箭头函数&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.常见语法&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;myBooks.forEach(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;reading&#x27;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;myBooks.forEach(&lt;span&gt;&lt;span&gt;title&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;console&lt;/span&gt;.log(title));&lt;br/&gt;&lt;br/&gt;myBooks.forEach(&lt;span&gt;(&lt;span&gt;title, idx, arr&lt;/span&gt;) =&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(idx + &lt;span&gt;&#x27;-&#x27;&lt;/span&gt; + title);&lt;br/&gt;);&lt;br/&gt;&lt;br/&gt;myBooks.forEach(&lt;span&gt;(&lt;span&gt;title, idx, arr&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(idx + &lt;span&gt;&#x27;-&#x27;&lt;/span&gt; + title);&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 未使用箭头函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Book&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; self = &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;  self.publishDate = &lt;span&gt;2016&lt;/span&gt;;&lt;br/&gt;  setInterval(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(self.publishDate);&lt;br/&gt;  }, &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 使用箭头函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Book&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.publishDate = &lt;span&gt;2016&lt;/span&gt;;&lt;br/&gt;  setInterval(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;this&lt;/span&gt;.publishDate);&lt;br/&gt;  }, &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.3 参数类型和返回类型&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;createUserId&lt;/span&gt;(&lt;span&gt;name: &lt;span&gt;string&lt;/span&gt;, id: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;string&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; name + id;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.4 函数类型&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; IdGenerator: &lt;span&gt;(&lt;span&gt;chars: &lt;span&gt;string&lt;/span&gt;, nums: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;createUserId&lt;/span&gt;(&lt;span&gt;name: &lt;span&gt;string&lt;/span&gt;, id: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;string&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; name + id;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;IdGenerator = createUserId;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.5 可选参数及默认参数&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 可选参数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;createUserId&lt;/span&gt;(&lt;span&gt;name: &lt;span&gt;string&lt;/span&gt;, id: &lt;span&gt;number&lt;/span&gt;, age?: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;string&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; name + id;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 默认参数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;createUserId&lt;/span&gt;(&lt;span&gt;&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt; = &quot;semlinker&quot;,&lt;br/&gt;  id: &lt;span&gt;number&lt;/span&gt;,&lt;br/&gt;  age?: &lt;span&gt;number&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;): &lt;span&gt;string&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; name + id;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在声明函数时，可以通过 &lt;code&gt;?&lt;/code&gt; 号来定义可选参数，比如 &lt;code&gt;age?: number&lt;/code&gt; 这种形式。&lt;strong&gt;在实际使用时，需要注意的是可选参数要放在普通参数的后面，不然会导致编译错误&lt;/strong&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.6 剩余参数&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;push&lt;/span&gt;(&lt;span&gt;array, ...items&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  items.forEach(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;item&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    array.push(item);&lt;br/&gt;  });&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; a = [];&lt;br/&gt;push(a, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.7 函数重载&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;a: &lt;span&gt;number&lt;/span&gt;, b: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;a: &lt;span&gt;string&lt;/span&gt;, b: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;a: &lt;span&gt;string&lt;/span&gt;, b: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;a: &lt;span&gt;number&lt;/span&gt;, b: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;a: Combinable, b: Combinable&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// type Combinable = string | number;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; a === &lt;span&gt;&#x27;string&#x27;&lt;/span&gt; || &lt;span&gt;typeof&lt;/span&gt; b === &lt;span&gt;&#x27;string&#x27;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; a.toString() + b.toString();&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; a + b;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以上代码中，我们为 add 函数提供了多个函数类型定义，从而实现函数的重载。在 TypeScript 中除了可以重载普通函数之外，我们还可以重载类中的成员方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法重载是指在同一个类中方法同名，参数不同（参数类型不同、参数个数不同或参数个数相同时参数的先后顺序不同），调用时根据实参的形式，选择与它匹配的方法执行操作的一种技术。所以类中成员方法满足重载的条件是：在同一个类中，方法名相同且参数列表不同。下面我们来举一个成员方法重载的例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; Calculator {&lt;br/&gt;  add(a: &lt;span&gt;number&lt;/span&gt;, b: &lt;span&gt;number&lt;/span&gt;): &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;  add(a: &lt;span&gt;string&lt;/span&gt;, b: &lt;span&gt;string&lt;/span&gt;): &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  add(a: &lt;span&gt;string&lt;/span&gt;, b: &lt;span&gt;number&lt;/span&gt;): &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  add(a: &lt;span&gt;number&lt;/span&gt;, b: &lt;span&gt;string&lt;/span&gt;): &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  add(a: Combinable, b: Combinable) {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; a === &lt;span&gt;&#x27;string&#x27;&lt;/span&gt; || &lt;span&gt;typeof&lt;/span&gt; b === &lt;span&gt;&#x27;string&#x27;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; a.toString() + b.toString();&lt;br/&gt;  }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; a + b;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; calculator = &lt;span&gt;new&lt;/span&gt; Calculator();&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; result = calculator.add(&lt;span&gt;&#x27;Semlinker&#x27;&lt;/span&gt;, &lt;span&gt;&#x27; Kakuqo&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里需要注意的是，当 TypeScript 编译器处理函数重载时，它会查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面。另外在 Calculator 类中，&lt;code&gt;add(a: Combinable, b: Combinable){ }&lt;/code&gt; 并不是重载列表的一部分，因此对于 add 成员方法来说，我们只定义了四个重载方法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;八、TypeScript 数组&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.1 数组解构&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; x: &lt;span&gt;number&lt;/span&gt;; &lt;span&gt;let&lt;/span&gt; y: &lt;span&gt;number&lt;/span&gt;; &lt;span&gt;let&lt;/span&gt; z: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; five_array = [&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;];&lt;br/&gt;[x,y,z] = five_array;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.2 数组展开运算符&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; two_array = [&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; five_array = [...two_array, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.3 数组遍历&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; colors: &lt;span&gt;string&lt;/span&gt;[] = [&lt;span&gt;&quot;red&quot;&lt;/span&gt;, &lt;span&gt;&quot;green&quot;&lt;/span&gt;, &lt;span&gt;&quot;blue&quot;&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i of colors) {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(i);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;九、TypeScript 对象&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9.1 对象解构&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; person = {&lt;br/&gt;  name: &lt;span&gt;&quot;Semlinker&quot;&lt;/span&gt;,&lt;br/&gt;  gender: &lt;span&gt;&quot;Male&quot;&lt;/span&gt;,&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; { name, gender } = person;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9.2 对象展开运算符&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; person = {&lt;br/&gt;  name: &lt;span&gt;&quot;Semlinker&quot;&lt;/span&gt;,&lt;br/&gt;  gender: &lt;span&gt;&quot;Male&quot;&lt;/span&gt;,&lt;br/&gt;  address: &lt;span&gt;&quot;Xiamen&quot;&lt;/span&gt;,&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 组装对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; personWithAge = { ...person, age: &lt;span&gt;33&lt;/span&gt; };&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 获取除了某些项外的其它项&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; { name, ...rest } = person;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;十、TypeScript 接口&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在面向对象语言中，接口是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类去实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;10.1 对象的形状&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Person {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  age: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; semlinker: Person = {&lt;br/&gt;  name: &lt;span&gt;&quot;semlinker&quot;&lt;/span&gt;,&lt;br/&gt;  age: &lt;span&gt;33&lt;/span&gt;,&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;10.2 可选 | 只读属性&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Person {&lt;br/&gt;  readonly name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  age?: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只读属性用于限制只能在对象刚刚创建的时候修改其值。此外 TypeScript 还提供了 &lt;code&gt;ReadonlyArray&amp;lt;T&amp;gt;&lt;/code&gt; 类型，它与 &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; a: &lt;span&gt;number&lt;/span&gt;[] = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; ro: ReadonlyArray&amp;lt;&lt;span&gt;number&lt;/span&gt;&amp;gt; = a;&lt;br/&gt;ro[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;12&lt;/span&gt;; &lt;span&gt;// error!&lt;/span&gt;&lt;br/&gt;ro.push(&lt;span&gt;5&lt;/span&gt;); &lt;span&gt;// error!&lt;/span&gt;&lt;br/&gt;ro.length = &lt;span&gt;100&lt;/span&gt;; &lt;span&gt;// error!&lt;/span&gt;&lt;br/&gt;a = ro; &lt;span&gt;// error!&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;10.3 任意属性&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候我们希望一个接口中除了包含必选和可选属性之外，还允许有其他的任意属性，这时我们可以使用 &lt;strong&gt;索引签名&lt;/strong&gt; 的形式来满足上述要求。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Person {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  age?: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;  [propName: &lt;span&gt;string&lt;/span&gt;]: &lt;span&gt;any&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; p1 = { name: &lt;span&gt;&quot;semlinker&quot;&lt;/span&gt; };&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; p2 = { name: &lt;span&gt;&quot;lolo&quot;&lt;/span&gt;, age: &lt;span&gt;5&lt;/span&gt; };&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; p3 = { name: &lt;span&gt;&quot;kakuqo&quot;&lt;/span&gt;, sex: &lt;span&gt;1&lt;/span&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;10.4 接口与类型别名的区别&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.Objects/Functions&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口和类型别名都可以用来描述对象的形状或函数签名：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;接口&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Point {&lt;br/&gt;  x: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;  y: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; SetPoint {&lt;br/&gt;  (x: &lt;span&gt;number&lt;/span&gt;, y: &lt;span&gt;number&lt;/span&gt;): &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;类型别名&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Point = {&lt;br/&gt;  x: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;  y: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; SetPoint = &lt;span&gt;(&lt;span&gt;x: &lt;span&gt;number&lt;/span&gt;, y: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.Other Types&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与接口类型不一样，类型别名可以用于一些其他类型，比如原始类型、联合类型和元组：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// primitive&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Name = &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// object&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; PartialPointX = { x: &lt;span&gt;number&lt;/span&gt;; };&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; PartialPointY = { y: &lt;span&gt;number&lt;/span&gt;; };&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// union&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; PartialPoint = PartialPointX | PartialPointY;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// tuple&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Data = [&lt;span&gt;number&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.Extend&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口和类型别名都能够被扩展，但语法有所不同。此外，接口和类型别名不是互斥的。接口可以扩展类型别名，而反过来是不行的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Interface extends interface&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; PartialPointX { x: &lt;span&gt;number&lt;/span&gt;; }&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; Point &lt;span&gt;extends&lt;/span&gt; PartialPointX { &lt;br/&gt;  y: &lt;span&gt;number&lt;/span&gt;; &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Type alias extends type alias&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; PartialPointX = { x: &lt;span&gt;number&lt;/span&gt;; };&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Point = PartialPointX &amp;amp; { y: &lt;span&gt;number&lt;/span&gt;; };&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Interface extends type alias&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; PartialPointX = { x: &lt;span&gt;number&lt;/span&gt;; };&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; Point &lt;span&gt;extends&lt;/span&gt; PartialPointX { y: &lt;span&gt;number&lt;/span&gt;; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Type alias extends interface&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; PartialPointX { x: &lt;span&gt;number&lt;/span&gt;; }&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Point = PartialPointX &amp;amp; { y: &lt;span&gt;number&lt;/span&gt;; };&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.Implements&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类可以以相同的方式实现接口或类型别名，但类不能实现使用类型别名定义的联合类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Point {&lt;br/&gt;  x: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;  y: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; SomePoint &lt;span&gt;implements&lt;/span&gt; Point {&lt;br/&gt;  x = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  y = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Point2 = {&lt;br/&gt;  x: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;  y: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; SomePoint2 &lt;span&gt;implements&lt;/span&gt; Point2 {&lt;br/&gt;  x = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  y = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; PartialPoint = { x: &lt;span&gt;number&lt;/span&gt;; } | { y: &lt;span&gt;number&lt;/span&gt;; };&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// A class can only implement an object type or &lt;/span&gt;&lt;br/&gt;&lt;span&gt;// intersection of object types with statically known members.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; SomePartialPoint &lt;span&gt;implements&lt;/span&gt; PartialPoint { &lt;span&gt;// Error&lt;/span&gt;&lt;br/&gt;  x = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  y = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.Declaration merging&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与类型别名不同，接口可以定义多次，会被自动合并为单个接口。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Point { x: &lt;span&gt;number&lt;/span&gt;; }&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; Point { y: &lt;span&gt;number&lt;/span&gt;; }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; point: Point = { x: &lt;span&gt;1&lt;/span&gt;, y: &lt;span&gt;2&lt;/span&gt; };&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;十一、TypeScript 类&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;11.1 类的属性与方法&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在面向对象语言中，类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 TypeScript 中，我们可以通过 &lt;code&gt;Class&lt;/code&gt; 关键字来定义一个类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; Greeter {&lt;br/&gt;  &lt;span&gt;// 静态属性&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; cname: &lt;span&gt;string&lt;/span&gt; = &lt;span&gt;&quot;Greeter&quot;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// 成员属性&lt;/span&gt;&lt;br/&gt;  greeting: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 构造函数 - 执行初始化操作&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;message: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.greeting = message;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 静态方法&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; getClassName() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Class name is Greeter&quot;&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 成员方法&lt;/span&gt;&lt;br/&gt;  greet() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Hello, &quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.greeting;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; greeter = &lt;span&gt;new&lt;/span&gt; Greeter(&lt;span&gt;&quot;world&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么成员属性与静态属性，成员方法与静态方法有什么区别呢？这里无需过多解释，我们直接看一下编译生成的 ES5 代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&quot;use strict&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; Greeter = &lt;span&gt;/** @class */&lt;/span&gt; (&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 构造函数 - 执行初始化操作&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Greeter&lt;/span&gt;(&lt;span&gt;message&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.greeting = message;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 静态方法&lt;/span&gt;&lt;br/&gt;    Greeter.getClassName = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Class name is Greeter&quot;&lt;/span&gt;;&lt;br/&gt;    };&lt;br/&gt;    &lt;span&gt;// 成员方法&lt;/span&gt;&lt;br/&gt;    Greeter.prototype.greet = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Hello, &quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.greeting;&lt;br/&gt;    };&lt;br/&gt;    &lt;span&gt;// 静态属性&lt;/span&gt;&lt;br/&gt;    Greeter.cname = &lt;span&gt;&quot;Greeter&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Greeter;&lt;br/&gt;}());&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; greeter = &lt;span&gt;new&lt;/span&gt; Greeter(&lt;span&gt;&quot;world&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;11.2 ECMAScript 私有字段&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 TypeScript 3.8 版本就开始支持&lt;strong&gt;ECMAScript 私有字段&lt;/strong&gt;，使用方式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; Person {&lt;br/&gt;  #name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;name: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.#name = name;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  greet() {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`Hello, my name is &lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.#name}&lt;/span&gt;!`&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; semlinker = &lt;span&gt;new&lt;/span&gt; Person(&lt;span&gt;&quot;Semlinker&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;semlinker.#name;&lt;br/&gt;&lt;span&gt;//     ~~~~~&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Property &#x27;#name&#x27; is not accessible outside class &#x27;Person&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// because it has a private identifier.&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与常规属性（甚至使用 &lt;code&gt;private&lt;/code&gt; 修饰符声明的属性）不同，私有字段要牢记以下规则：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;私有字段以 &lt;code&gt;#&lt;/code&gt; 字符开头，有时我们称之为私有名称；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个私有字段名称都唯一地限定于其包含的类；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不能在私有字段上使用 TypeScript 可访问性修饰符（如 public 或 private）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;私有字段不能在包含的类之外访问，甚至不能被检测到。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;11.3 访问器&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 TypeScript 中，我们可以通过 &lt;code&gt;getter&lt;/code&gt; 和 &lt;code&gt;setter&lt;/code&gt; 方法来实现数据的封装和有效性校验，防止出现异常数据。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; passcode = &lt;span&gt;&quot;Hello TypeScript&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; Employee {&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; _fullName: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;get&lt;/span&gt; fullName(): &lt;span&gt;string&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;._fullName;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;set&lt;/span&gt; fullName(newName: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (passcode &amp;amp;&amp;amp; passcode == &lt;span&gt;&quot;Hello TypeScript&quot;&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;._fullName = newName;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;Error: Unauthorized update of employee!&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; employee = &lt;span&gt;new&lt;/span&gt; Employee();&lt;br/&gt;employee.fullName = &lt;span&gt;&quot;Semlinker&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (employee.fullName) {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(employee.fullName);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;11.4 类的继承&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继承（Inheritance）是一种联结类与类的层次模型。指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继承是一种 is-a 关系：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6962457337883959&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2pdRian6Xlm7wMdPrPspib1568S0EzW7EnU8AGedgyX5wFLibicrR4eE21Bj6yXkHe1Ky6FH8Oibku4Dg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;293&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 TypeScript 中，我们可以通过 &lt;code&gt;extends&lt;/code&gt; 关键字来实现继承：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; Animal {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;theName: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.name = theName;&lt;br/&gt;  }&lt;br/&gt;  &lt;br/&gt;  move(distanceInMeters: &lt;span&gt;number&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`&lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.name}&lt;/span&gt; moved &lt;span&gt;${distanceInMeters}&lt;/span&gt;m.`&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; Snake &lt;span&gt;extends&lt;/span&gt; Animal {&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;name: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;(name); &lt;span&gt;// 调用父类的构造函数&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;br/&gt;  move(distanceInMeters = &lt;span&gt;5&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;Slithering...&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;.move(distanceInMeters);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; sam = &lt;span&gt;new&lt;/span&gt; Snake(&lt;span&gt;&quot;Sammy the Python&quot;&lt;/span&gt;);&lt;br/&gt;sam.move();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;11.5 抽象类&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;abstract&lt;/code&gt; 关键字声明的类，我们称之为抽象类。抽象类不能被实例化，因为它里面包含一个或多个抽象方法。所谓的抽象方法，是指不包含具体实现的方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Person {&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;&lt;span&gt;public&lt;/span&gt; name: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;){}&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;abstract&lt;/span&gt; say(words: &lt;span&gt;string&lt;/span&gt;) :&lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Cannot create an instance of an abstract class.(2511)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; lolo = &lt;span&gt;new&lt;/span&gt; Person(); &lt;span&gt;// Error&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;抽象类不能被直接实例化，我们只能实例化实现了所有抽象方法的子类。具体如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Person {&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;&lt;span&gt;public&lt;/span&gt; name: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;){}&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 抽象方法&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;abstract&lt;/span&gt; say(words: &lt;span&gt;string&lt;/span&gt;) :&lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; Developer &lt;span&gt;extends&lt;/span&gt; Person {&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;name: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;(name);&lt;br/&gt;  }&lt;br/&gt;  &lt;br/&gt;  say(words: &lt;span&gt;string&lt;/span&gt;): &lt;span&gt;void&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`&lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.name}&lt;/span&gt; says &lt;span&gt;${words}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; lolo = &lt;span&gt;new&lt;/span&gt; Developer(&lt;span&gt;&quot;lolo&quot;&lt;/span&gt;);&lt;br/&gt;lolo.say(&lt;span&gt;&quot;I love ts!&quot;&lt;/span&gt;); &lt;span&gt;// lolo says I love ts!&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;11.6 类方法重载&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面的章节，我们已经介绍了函数重载。对于类的方法来说，它也支持重载。比如，在以下示例中我们重载了 &lt;code&gt;ProductService&lt;/code&gt; 类的 &lt;code&gt;getProducts&lt;/code&gt; 成员方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; ProductService {&lt;br/&gt;    getProducts(): &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;    getProducts(id: &lt;span&gt;number&lt;/span&gt;): &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;    getProducts(id?: &lt;span&gt;number&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt; id === &lt;span&gt;&#x27;number&#x27;&lt;/span&gt;) {&lt;br/&gt;          &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`获取id为 &lt;span&gt;${id}&lt;/span&gt; 的产品信息`&lt;/span&gt;);&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;          &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`获取所有的产品信息`&lt;/span&gt;);&lt;br/&gt;      }  &lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; productService = &lt;span&gt;new&lt;/span&gt; ProductService();&lt;br/&gt;productService.getProducts(&lt;span&gt;666&lt;/span&gt;); &lt;span&gt;// 获取id为 666 的产品信息&lt;/span&gt;&lt;br/&gt;productService.getProducts(); &lt;span&gt;// 获取所有的产品信息 &lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;十二、TypeScript 泛型&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;泛型（Generics）是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;12.1 泛型语法&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于刚接触 TypeScript 泛型的读者来说，首次看到 &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 语法会感到陌生。其实它没有什么特别，就像传递参数一样，我们传递了我们想要用于特定函数调用的类型。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4845360824742268&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2pdRian6Xlm7wMdPrPspib15rxFj5Gy4Dp6bw9b6tbL3Ce6FfiaEibsiaIADDBR4AicsJ3SJAmKHynolaw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;776&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考上面的图片，当我们调用 &lt;code&gt;identity&amp;lt;Number&amp;gt;(1)&lt;/code&gt; ，&lt;code&gt;Number&lt;/code&gt; 类型就像参数 &lt;code&gt;1&lt;/code&gt; 一样，它将在出现 &lt;code&gt;T&lt;/code&gt; 的任何位置填充该类型。图中 &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 内部的 &lt;code&gt;T&lt;/code&gt; 被称为类型变量，它是我们希望传递给 identity 函数的类型占位符，同时它被分配给 &lt;code&gt;value&lt;/code&gt; 参数用来代替它的类型：此时 &lt;code&gt;T&lt;/code&gt; 充当的是类型，而不是特定的 Number 类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 &lt;code&gt;T&lt;/code&gt; 代表 &lt;strong&gt;Type&lt;/strong&gt;，在定义泛型时通常用作第一个类型变量名称。但实际上 &lt;code&gt;T&lt;/code&gt; 可以用任何有效名称代替。除了 &lt;code&gt;T&lt;/code&gt; 之外，以下是常见泛型变量代表的意思：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;K（Key）：表示对象中的键类型；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;V（Value）：表示对象中的值类型；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;E（Element）：表示元素类型。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量。比如我们引入一个新的类型变量 &lt;code&gt;U&lt;/code&gt;，用于扩展我们定义的 &lt;code&gt;identity&lt;/code&gt; 函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;identity&lt;/span&gt; &amp;lt;&lt;span&gt;T&lt;/span&gt;, &lt;span&gt;U&lt;/span&gt;&amp;gt;(&lt;span&gt;value: T, message: U&lt;/span&gt;) : &lt;span&gt;T&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(message);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; value;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(identity&amp;lt;&lt;span&gt;Number&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;68&lt;/span&gt;, &lt;span&gt;&quot;Semlinker&quot;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.47877758913412566&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2pdRian6Xlm7wMdPrPspib15dbCthDyOwwC4yIbHLBoRPZNqficTNlrkDwibiaUkS0fuAuxtgT9fS4sSg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1178&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了为类型变量显式设定值之外，一种更常见的做法是使编译器自动选择这些类型，从而使代码更简洁。我们可以完全省略尖括号，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;identity&lt;/span&gt; &amp;lt;&lt;span&gt;T&lt;/span&gt;, &lt;span&gt;U&lt;/span&gt;&amp;gt;(&lt;span&gt;value: T, message: U&lt;/span&gt;) : &lt;span&gt;T&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(message);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; value;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(identity(&lt;span&gt;68&lt;/span&gt;, &lt;span&gt;&quot;Semlinker&quot;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于上述代码，编译器足够聪明，能够知道我们的参数类型，并将它们赋值给 T 和 U，而不需要开发人员显式指定它们。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;12.2 泛型接口&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; GenericIdentityFn&amp;lt;T&amp;gt; {&lt;br/&gt;  (arg: T): T;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;12.3 泛型类&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; GenericNumber&amp;lt;T&amp;gt; {&lt;br/&gt;  zeroValue: T;&lt;br/&gt;  add: &lt;span&gt;(&lt;span&gt;x: T, y: T&lt;/span&gt;) =&amp;gt;&lt;/span&gt; T;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; myGenericNumber = &lt;span&gt;new&lt;/span&gt; GenericNumber&amp;lt;&lt;span&gt;number&lt;/span&gt;&amp;gt;();&lt;br/&gt;myGenericNumber.zeroValue = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;myGenericNumber.add = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;x, y&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; x + y;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;12.4 泛型工具类型&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了方便开发者 TypeScript 内置了一些常用的工具类型，比如 Partial、Required、Readonly、Record 和 ReturnType 等。出于篇幅考虑，这里我们只简单介绍 Partial 工具类型。不过在具体介绍之前，我们得先介绍一些相关的基础知识，方便读者自行学习其它的工具类型。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.typeof&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 TypeScript 中，&lt;code&gt;typeof&lt;/code&gt; 操作符可以用来获取一个变量声明或对象的类型。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Person {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  age: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; sem: Person = { name: &lt;span&gt;&#x27;semlinker&#x27;&lt;/span&gt;, age: &lt;span&gt;33&lt;/span&gt; };&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Sem= &lt;span&gt;typeof&lt;/span&gt; sem; &lt;span&gt;// -&amp;gt; Person&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;toArray&lt;/span&gt;(&lt;span&gt;x: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;number&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; [x];&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Func = &lt;span&gt;typeof&lt;/span&gt; toArray; &lt;span&gt;// -&amp;gt; (x: number) =&amp;gt; number[]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.keyof&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;keyof&lt;/code&gt; 操作符可以用来一个对象中的所有 key 值：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Person {&lt;br/&gt;    name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;    age: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; K1 = keyof Person; &lt;span&gt;// &quot;name&quot; | &quot;age&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; K2 = keyof Person[]; &lt;span&gt;// &quot;length&quot; | &quot;toString&quot; | &quot;pop&quot; | &quot;push&quot; | &quot;concat&quot; | &quot;join&quot; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; K3 = keyof { [x: &lt;span&gt;string&lt;/span&gt;]: Person };  &lt;span&gt;// string | number&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 TypeScript 中支持两种索引签名，数字索引和字符串索引：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; StringArray {&lt;br/&gt;  &lt;span&gt;// 字符串索引 -&amp;gt; keyof StringArray =&amp;gt; string | number&lt;/span&gt;&lt;br/&gt;  [index: &lt;span&gt;string&lt;/span&gt;]: &lt;span&gt;string&lt;/span&gt;; &lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; StringArray1 {&lt;br/&gt;  &lt;span&gt;// 数字索引 -&amp;gt; keyof StringArray1 =&amp;gt; number&lt;/span&gt;&lt;br/&gt;  [index: &lt;span&gt;number&lt;/span&gt;]: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了同时支持两种索引类型，就得要求数字索引的返回值必须是字符串索引返回值的子类。&lt;strong&gt;其中的原因就是当使用数值索引时，JavaScript 在执行索引操作时，会先把数值索引先转换为字符串索引&lt;/strong&gt;。所以 &lt;code&gt;keyof { [x: string]: Person }&lt;/code&gt; 的结果会返回 &lt;code&gt;string | number&lt;/code&gt;。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.in&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;in&lt;/code&gt; 用来遍历枚举类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Keys = &lt;span&gt;&quot;a&quot;&lt;/span&gt; | &lt;span&gt;&quot;b&quot;&lt;/span&gt; | &lt;span&gt;&quot;c&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Obj =  {&lt;br/&gt;  [p &lt;span&gt;in&lt;/span&gt; Keys]: &lt;span&gt;any&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;// -&amp;gt; { a: any, b: any, c: any }&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.infer&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在条件类型语句中，可以用 &lt;code&gt;infer&lt;/code&gt; 声明一个类型变量并且对它进行使用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; ReturnType&amp;lt;T&amp;gt; = T &lt;span&gt;extends&lt;/span&gt; (&lt;br/&gt;  ...args: &lt;span&gt;any&lt;/span&gt;[]&lt;br/&gt;) =&amp;gt; infer R ? R : &lt;span&gt;any&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上代码中 &lt;code&gt;infer R&lt;/code&gt; 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.extends&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Lengthwise {&lt;br/&gt;  length: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;loggingIdentity&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Lengthwise&lt;/span&gt;&amp;gt;(&lt;span&gt;arg: T&lt;/span&gt;): &lt;span&gt;T&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(arg.length);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; arg;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;loggingIdentity(&lt;span&gt;3&lt;/span&gt;);  &lt;span&gt;// Error, number doesn&#x27;t have a .length property&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时我们需要传入符合约束类型的值，必须包含必须的属性：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;loggingIdentity({length: &lt;span&gt;10&lt;/span&gt;, value: &lt;span&gt;3&lt;/span&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.Partial&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; 的作用就是将某个类型里的属性全部变为可选项 &lt;code&gt;?&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;定义：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * node_modules/typescript/lib/lib.es5.d.ts&lt;br/&gt; * Make all properties in T optional&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Partial&amp;lt;T&amp;gt; = {&lt;br/&gt;  [P &lt;span&gt;in&lt;/span&gt; keyof T]?: T[P];&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以上代码中，首先通过 &lt;code&gt;keyof T&lt;/code&gt; 拿到 &lt;code&gt;T&lt;/code&gt; 的所有属性名，然后使用 &lt;code&gt;in&lt;/code&gt; 进行遍历，将值赋给 &lt;code&gt;P&lt;/code&gt;，最后通过 &lt;code&gt;T[P]&lt;/code&gt; 取得相应的属性值。中间的 &lt;code&gt;?&lt;/code&gt; 号，用于将所有属性变为可选。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Todo {&lt;br/&gt;  title: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  description: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;updateTodo&lt;/span&gt;(&lt;span&gt;todo: Todo, fieldsToUpdate: Partial&amp;lt;Todo&amp;gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; { ...todo, ...fieldsToUpdate };&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; todo1 = {&lt;br/&gt;  title: &lt;span&gt;&quot;Learn TS&quot;&lt;/span&gt;,&lt;br/&gt;  description: &lt;span&gt;&quot;Learn TypeScript&quot;&lt;/span&gt;,&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; todo2 = updateTodo(todo1, {&lt;br/&gt;  description: &lt;span&gt;&quot;Learn TypeScript Enum&quot;&lt;/span&gt;,&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的 &lt;code&gt;updateTodo&lt;/code&gt; 方法中，我们利用 &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; 工具类型，定义 &lt;code&gt;fieldsToUpdate&lt;/code&gt; 的类型为 &lt;code&gt;Partial&amp;lt;Todo&amp;gt;&lt;/code&gt;，即：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;{&lt;br/&gt;   title?: &lt;span&gt;string&lt;/span&gt; | &lt;span&gt;undefined&lt;/span&gt;;&lt;br/&gt;   description?: &lt;span&gt;string&lt;/span&gt; | &lt;span&gt;undefined&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;十三、TypeScript 装饰器&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;13.1 装饰器是什么&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;它是一个表达式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;该表达式被执行后，返回一个函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;函数的入参分别为 target、name 和 descriptor&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行该函数后，可能返回 descriptor 对象，用于配置 target 对象&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;13.2 装饰器的分类&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;类装饰器（Class decorators）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;属性装饰器（Property decorators）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方法装饰器（Method decorators）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;参数装饰器（Parameter decorators）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，若要启用实验性的装饰器特性，你必须在命令行或 &lt;code&gt;tsconfig.json&lt;/code&gt; 里启用 &lt;code&gt;experimentalDecorators&lt;/code&gt; 编译器选项：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;命令行&lt;/strong&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;tsc --target ES5 --experimentalDecorators&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;tsconfig.json&lt;/strong&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;compilerOptions&quot;&lt;/span&gt;: {&lt;br/&gt;     &lt;span&gt;&quot;target&quot;&lt;/span&gt;: &lt;span&gt;&quot;ES5&quot;&lt;/span&gt;,&lt;br/&gt;     &lt;span&gt;&quot;experimentalDecorators&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;13.3 类装饰器&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类装饰器声明：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;declare&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; ClassDecorator = &amp;lt;TFunction &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Function&lt;/span&gt;&amp;gt;(&lt;br/&gt;  target: TFunction&lt;br/&gt;) =&amp;gt; TFunction | &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类装饰器顾名思义，就是用来装饰类的。它接收一个参数：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;target: TFunction - 被装饰的类&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完第一眼后，是不是感觉都不好了。没事，我们马上来个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Greeter&lt;/span&gt;(&lt;span&gt;target: &lt;span&gt;Function&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;void&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  target.prototype.greet = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;): &lt;span&gt;void&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;Hello Semlinker!&quot;&lt;/span&gt;);&lt;br/&gt;  };&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Greeter&lt;/span&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; Greeting {&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span/&gt;) {&lt;br/&gt;    &lt;span&gt;// 内部实现&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; myGreeting = &lt;span&gt;new&lt;/span&gt; Greeting();&lt;br/&gt;myGreeting.greet(); &lt;span&gt;// console output: &#x27;Hello Semlinker!&#x27;;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的例子中，我们定义了 &lt;code&gt;Greeter&lt;/code&gt; 类装饰器，同时我们使用了 &lt;code&gt;@Greeter&lt;/code&gt; 语法糖，来使用装饰器。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;友情提示：读者可以直接复制上面的代码，在 TypeScript Playground 中运行查看结果。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有的读者可能想问，例子中总是输出 &lt;code&gt;Hello Semlinker!&lt;/code&gt; ，能自定义输出的问候语么 ？这个问题很好，答案是可以的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Greeter&lt;/span&gt;(&lt;span&gt;greeting: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;target: &lt;span&gt;Function&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    target.prototype.greet = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;): &lt;span&gt;void&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.log(greeting);&lt;br/&gt;    };&lt;br/&gt;  };&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Greeter&lt;/span&gt;(&lt;span&gt;&quot;Hello TS!&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; Greeting {&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span/&gt;) {&lt;br/&gt;    &lt;span&gt;// 内部实现&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; myGreeting = &lt;span&gt;new&lt;/span&gt; Greeting();&lt;br/&gt;myGreeting.greet(); &lt;span&gt;// console output: &#x27;Hello TS!&#x27;;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;13.4 属性装饰器&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;属性装饰器声明：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;declare&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; PropertyDecorator = (target:&lt;span&gt;Object&lt;/span&gt;, &lt;br/&gt;  propertyKey: &lt;span&gt;string&lt;/span&gt; | symbol ) =&amp;gt; &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;属性装饰器顾名思义，用来装饰类的属性。它接收两个参数：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;target: Object - 被装饰的类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;propertyKey: string | symbol - 被装饰类的属性名&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;趁热打铁，马上来个例子热热身：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;logProperty&lt;/span&gt;(&lt;span&gt;target: &lt;span&gt;any&lt;/span&gt;, key: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;delete&lt;/span&gt; target[key];&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; backingField = &lt;span&gt;&quot;_&quot;&lt;/span&gt; + key;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;Object&lt;/span&gt;.defineProperty(target, backingField, {&lt;br/&gt;    writable: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;    enumerable: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;    configurable: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;  });&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// property getter&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; getter = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;&lt;span&gt;this&lt;/span&gt;: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; currVal = &lt;span&gt;this&lt;/span&gt;[backingField];&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`Get: &lt;span&gt;${key}&lt;/span&gt; =&amp;gt; &lt;span&gt;${currVal}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; currVal;&lt;br/&gt;  };&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// property setter&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; setter = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;&lt;span&gt;this&lt;/span&gt;: &lt;span&gt;any&lt;/span&gt;, newVal: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`Set: &lt;span&gt;${key}&lt;/span&gt; =&amp;gt; &lt;span&gt;${newVal}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;[backingField] = newVal;&lt;br/&gt;  };&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Create new property with getter and setter&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;Object&lt;/span&gt;.defineProperty(target, key, {&lt;br/&gt;    &lt;span&gt;get&lt;/span&gt;: getter,&lt;br/&gt;    &lt;span&gt;set&lt;/span&gt;: setter,&lt;br/&gt;    enumerable: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;    configurable: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;  });&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; Person { &lt;br/&gt;  &lt;span&gt;@logProperty&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;name : &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) { &lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.name = name;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; p1 = &lt;span&gt;new&lt;/span&gt; Person(&lt;span&gt;&quot;semlinker&quot;&lt;/span&gt;);&lt;br/&gt;p1.name = &lt;span&gt;&quot;kakuqo&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上代码我们定义了一个 &lt;code&gt;logProperty&lt;/code&gt; 函数，来跟踪用户对属性的操作，当代码成功运行后，在控制台会输出以下结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Set: name =&amp;gt; semlinker&lt;br/&gt;Set: name =&amp;gt; kakuqo&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;13.5 方法装饰器&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法装饰器声明：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;declare&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; MethodDecorator = &amp;lt;T&amp;gt;(target:&lt;span&gt;Object&lt;/span&gt;, propertyKey: &lt;span&gt;string&lt;/span&gt; | symbol,    &lt;br/&gt;  descriptor: TypePropertyDescript&amp;lt;T&amp;gt;) =&amp;gt; TypedPropertyDescriptor&amp;lt;T&amp;gt; | &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法装饰器顾名思义，用来装饰类的方法。它接收三个参数：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;target: Object - 被装饰的类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;propertyKey: string | symbol - 方法名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;descriptor: TypePropertyDescript - 属性描述符&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;废话不多说，直接上例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;LogOutput&lt;/span&gt;(&lt;span&gt;tarage: &lt;span&gt;Function&lt;/span&gt;, key: &lt;span&gt;string&lt;/span&gt;, descriptor: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; originalMethod = descriptor.value;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; newMethod = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;...args: &lt;span&gt;any&lt;/span&gt;[]&lt;/span&gt;): &lt;span&gt;any&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; result: &lt;span&gt;any&lt;/span&gt; = originalMethod.apply(&lt;span&gt;this&lt;/span&gt;, args);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;this&lt;/span&gt;.loggedOutput) {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.loggedOutput = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;any&lt;/span&gt;&amp;gt;();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.loggedOutput.push({&lt;br/&gt;      method: key,&lt;br/&gt;      parameters: args,&lt;br/&gt;      output: result,&lt;br/&gt;      timestamp: &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;()&lt;br/&gt;    });&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;  };&lt;br/&gt;  descriptor.value = newMethod;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; Calculator {&lt;br/&gt;  &lt;span&gt;@LogOutput&lt;/span&gt;&lt;br/&gt;  double (num: &lt;span&gt;number&lt;/span&gt;): &lt;span&gt;number&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; num * &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; calc = &lt;span&gt;new&lt;/span&gt; Calculator();&lt;br/&gt;calc.double(&lt;span&gt;11&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// console ouput: [{method: &quot;double&quot;, output: 22, ...}]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(calc.loggedOutput); &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来介绍一下参数装饰器。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;13.6 参数装饰器&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参数装饰器声明：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;declare&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; ParameterDecorator = (target: &lt;span&gt;Object&lt;/span&gt;, propertyKey: &lt;span&gt;string&lt;/span&gt; | symbol, &lt;br/&gt;  parameterIndex: &lt;span&gt;number&lt;/span&gt; ) =&amp;gt; &lt;span&gt;void&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参数装饰器顾名思义，是用来装饰函数参数，它接收三个参数：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;target: Object - 被装饰的类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;propertyKey: string | symbol - 方法名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;parameterIndex: number - 方法中参数的索引值&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Log&lt;/span&gt;(&lt;span&gt;target: &lt;span&gt;Function&lt;/span&gt;, key: &lt;span&gt;string&lt;/span&gt;, parameterIndex: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;Logged&lt;/span&gt; = &lt;span&gt;key&lt;/span&gt; || &lt;span&gt;target&lt;/span&gt;.&lt;span&gt;prototype&lt;/span&gt;.&lt;span&gt;constructor&lt;/span&gt;.&lt;span&gt;name&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`The parameter in position &lt;span&gt;${parameterIndex}&lt;/span&gt; at &lt;span&gt;${functionLogged}&lt;/span&gt; has&lt;br/&gt; been decorated`&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; Greeter {&lt;br/&gt;  greeting: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;&lt;span&gt;@Log&lt;/span&gt; phrase: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) {&lt;br/&gt; &lt;span&gt;this&lt;/span&gt;.greeting = phrase; &lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// console output: The parameter in position 0 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;// at Greeter has been decorated&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;十四、TypeScript 4.0 新特性&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TypeScript 4.0 带来了很多新的特性，这里我们只简单介绍其中的两个新特性。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;14.1 构造函数的类属性推断&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 &lt;code&gt;noImplicitAny&lt;/code&gt; 配置属性被启用之后，TypeScript 4.0 就可以使用控制流分析来确认类中的属性类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; Person {&lt;br/&gt;  fullName; &lt;span&gt;// (property) Person.fullName: string&lt;/span&gt;&lt;br/&gt;  firstName; &lt;span&gt;// (property) Person.firstName: string&lt;/span&gt;&lt;br/&gt;  lastName; &lt;span&gt;// (property) Person.lastName: string&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;fullName: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.fullName = fullName;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.firstName = fullName.split(&lt;span&gt;&quot; &quot;&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.lastName =   fullName.split(&lt;span&gt;&quot; &quot;&lt;/span&gt;)[&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;  }  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而对于以上的代码，如果在 TypeScript 4.0 以前的版本，比如在 3.9.2 版本下，编译器会提示以下错误信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; Person {&lt;br/&gt;  &lt;span&gt;// Member &#x27;fullName&#x27; implicitly has an &#x27;any&#x27; type.(7008)&lt;/span&gt;&lt;br/&gt;  fullName; &lt;span&gt;// Error&lt;/span&gt;&lt;br/&gt;  firstName; &lt;span&gt;// Error&lt;/span&gt;&lt;br/&gt;  lastName; &lt;span&gt;// Error&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;fullName: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.fullName = fullName;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.firstName = fullName.split(&lt;span&gt;&quot; &quot;&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.lastName =   fullName.split(&lt;span&gt;&quot; &quot;&lt;/span&gt;)[&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;  }  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从构造函数推断类属性的类型，该特性给我们带来了便利。但在使用过程中，如果我们没法保证对成员属性都进行赋值，那么该属性可能会被认为是 &lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; Person {&lt;br/&gt;   fullName;  &lt;span&gt;// (property) Person.fullName: string&lt;/span&gt;&lt;br/&gt;   firstName; &lt;span&gt;// (property) Person.firstName: string | undefined&lt;/span&gt;&lt;br/&gt;   lastName; &lt;span&gt;// (property) Person.lastName: string | undefined&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;fullName: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) {&lt;br/&gt;     &lt;span&gt;this&lt;/span&gt;.fullName = fullName;&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;Math&lt;/span&gt;.random()){&lt;br/&gt;       &lt;span&gt;this&lt;/span&gt;.firstName = fullName.split(&lt;span&gt;&quot; &quot;&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;       &lt;span&gt;this&lt;/span&gt;.lastName =   fullName.split(&lt;span&gt;&quot; &quot;&lt;/span&gt;)[&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;     }&lt;br/&gt;   }  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;14.2 标记的元组元素&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以下的示例中，我们使用元组类型来声明剩余参数的类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;addPerson&lt;/span&gt;(&lt;span&gt;...args: [&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;number&lt;/span&gt;]&lt;/span&gt;): &lt;span&gt;void&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`Person info: name: &lt;span&gt;${args[&lt;span&gt;0&lt;/span&gt;]}&lt;/span&gt;, age: &lt;span&gt;${args[&lt;span&gt;1&lt;/span&gt;]}&lt;/span&gt;`&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;addPerson(&lt;span&gt;&quot;lolo&quot;&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;); &lt;span&gt;// Person info: name: lolo, age: 5 &lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，对于上面的 &lt;code&gt;addPerson&lt;/code&gt; 函数，我们也可以这样实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;addPerson&lt;/span&gt;(&lt;span&gt;name: &lt;span&gt;string&lt;/span&gt;, age: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`Person info: name: &lt;span&gt;${name}&lt;/span&gt;, age: &lt;span&gt;${age}&lt;/span&gt;`&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两种方式看起来没有多大的区别，但对于第一种方式，我们没法设置第一个参数和第二个参数的名称。虽然这样对类型检查没有影响，但在元组位置上缺少标签，会使得它们难于使用。为了提高开发者使用元组的体验，TypeScript 4.0 支持为元组类型设置标签：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;addPerson&lt;/span&gt;(&lt;span&gt;...args: [name: &lt;span&gt;string&lt;/span&gt;, age: &lt;span&gt;number&lt;/span&gt;]&lt;/span&gt;): &lt;span&gt;void&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`Person info: name: &lt;span&gt;${args[&lt;span&gt;0&lt;/span&gt;]}&lt;/span&gt;, age: &lt;span&gt;${args[&lt;span&gt;1&lt;/span&gt;]}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后，当我们使用 &lt;code&gt;addPerson&lt;/code&gt; 方法时，TypeScript 的智能提示就会变得更加友好。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 未使用标签的智能提示&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// addPerson(args_0: string, args_1: number): void&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;addPerson&lt;/span&gt;(&lt;span&gt;...args: [&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;number&lt;/span&gt;]&lt;/span&gt;): &lt;span&gt;void&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`Person info: name: &lt;span&gt;${args[&lt;span&gt;0&lt;/span&gt;]}&lt;/span&gt;, age: &lt;span&gt;${args[&lt;span&gt;1&lt;/span&gt;]}&lt;/span&gt;`&lt;/span&gt;)&lt;br/&gt;} &lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 已使用标签的智能提示&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// addPerson(name: string, age: number): void&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;addPerson&lt;/span&gt;(&lt;span&gt;...args: [name: &lt;span&gt;string&lt;/span&gt;, age: &lt;span&gt;number&lt;/span&gt;]&lt;/span&gt;): &lt;span&gt;void&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`Person info: name: &lt;span&gt;${args[&lt;span&gt;0&lt;/span&gt;]}&lt;/span&gt;, age: &lt;span&gt;${args[&lt;span&gt;1&lt;/span&gt;]}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;十五、编译上下文&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;15.1 tsconfig.json 的作用&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用于标识 TypeScript 项目的根路径；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用于配置 TypeScript 编译器；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用于指定编译的文件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;15.2 tsconfig.json 重要字段&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;files - 设置要编译的文件的名称；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;include - 设置需要进行编译的文件，支持路径模式匹配；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;exclude - 设置无需进行编译的文件，支持路径模式匹配；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;compilerOptions - 设置与编译流程相关的选项。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;15.3 compilerOptions 选项&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;compilerOptions 支持很多选项，常见的有 &lt;code&gt;baseUrl&lt;/code&gt;、 &lt;code&gt;target&lt;/code&gt;、&lt;code&gt;baseUrl&lt;/code&gt;、 &lt;code&gt;moduleResolution&lt;/code&gt; 和 &lt;code&gt;lib&lt;/code&gt; 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;compilerOptions 每个选项的详细说明如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;compilerOptions&quot;&lt;/span&gt;: {&lt;br/&gt;&lt;br/&gt;    /* 基本选项 */&lt;br/&gt;    &lt;span&gt;&quot;target&quot;&lt;/span&gt;: &lt;span&gt;&quot;es5&quot;&lt;/span&gt;,                       // 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES6&#x27;/&#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27;&lt;br/&gt;    &lt;span&gt;&quot;module&quot;&lt;/span&gt;: &lt;span&gt;&quot;commonjs&quot;&lt;/span&gt;,                  // 指定使用模块: &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27; or &#x27;es2015&#x27;&lt;br/&gt;    &lt;span&gt;&quot;lib&quot;&lt;/span&gt;: [],                             // 指定要包含在编译中的库文件&lt;br/&gt;    &lt;span&gt;&quot;allowJs&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                       // 允许编译 javascript 文件&lt;br/&gt;    &lt;span&gt;&quot;checkJs&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                       // 报告 javascript 文件中的错误&lt;br/&gt;    &lt;span&gt;&quot;jsx&quot;&lt;/span&gt;: &lt;span&gt;&quot;preserve&quot;&lt;/span&gt;,                     // 指定 jsx 代码的生成: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;&lt;br/&gt;    &lt;span&gt;&quot;declaration&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                   // 生成相应的 &#x27;.d.ts&#x27; 文件&lt;br/&gt;    &lt;span&gt;&quot;sourceMap&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                     // 生成相应的 &#x27;.map&#x27; 文件&lt;br/&gt;    &lt;span&gt;&quot;outFile&quot;&lt;/span&gt;: &lt;span&gt;&quot;./&quot;&lt;/span&gt;,                       // 将输出文件合并为一个文件&lt;br/&gt;    &lt;span&gt;&quot;outDir&quot;&lt;/span&gt;: &lt;span&gt;&quot;./&quot;&lt;/span&gt;,                        // 指定输出目录&lt;br/&gt;    &lt;span&gt;&quot;rootDir&quot;&lt;/span&gt;: &lt;span&gt;&quot;./&quot;&lt;/span&gt;,                       // 用来控制输出目录结构 --outDir.&lt;br/&gt;    &lt;span&gt;&quot;removeComments&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                // 删除编译后的所有的注释&lt;br/&gt;    &lt;span&gt;&quot;noEmit&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                        // 不生成输出文件&lt;br/&gt;    &lt;span&gt;&quot;importHelpers&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                 // 从 tslib 导入辅助工具函数&lt;br/&gt;    &lt;span&gt;&quot;isolatedModules&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,               // 将每个文件做为单独的模块 （与 &#x27;ts.transpileModule&#x27; 类似）.&lt;br/&gt;&lt;br/&gt;    /* 严格的类型检查选项 */&lt;br/&gt;    &lt;span&gt;&quot;strict&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                        // 启用所有严格类型检查选项&lt;br/&gt;    &lt;span&gt;&quot;noImplicitAny&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                 // 在表达式和声明上有隐含的 any类型时报错&lt;br/&gt;    &lt;span&gt;&quot;strictNullChecks&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,              // 启用严格的 null 检查&lt;br/&gt;    &lt;span&gt;&quot;noImplicitThis&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                // 当 this 表达式值为 any 类型的时候，生成一个错误&lt;br/&gt;    &lt;span&gt;&quot;alwaysStrict&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                  // 以严格模式检查每个模块，并在每个文件里加入 &#x27;use strict&#x27;&lt;br/&gt;&lt;br/&gt;    /* 额外的检查 */&lt;br/&gt;    &lt;span&gt;&quot;noUnusedLocals&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                // 有未使用的变量时，抛出错误&lt;br/&gt;    &lt;span&gt;&quot;noUnusedParameters&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,            // 有未使用的参数时，抛出错误&lt;br/&gt;    &lt;span&gt;&quot;noImplicitReturns&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,             // 并不是所有函数里的代码都有返回值时，抛出错误&lt;br/&gt;    &lt;span&gt;&quot;noFallthroughCasesInSwitch&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）&lt;br/&gt;&lt;br/&gt;    /* 模块解析选项 */&lt;br/&gt;    &lt;span&gt;&quot;moduleResolution&quot;&lt;/span&gt;: &lt;span&gt;&quot;node&quot;&lt;/span&gt;,            // 选择模块解析策略： &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6)&lt;br/&gt;    &lt;span&gt;&quot;baseUrl&quot;&lt;/span&gt;: &lt;span&gt;&quot;./&quot;&lt;/span&gt;,                       // 用于解析非相对模块名称的基目录&lt;br/&gt;    &lt;span&gt;&quot;paths&quot;&lt;/span&gt;: {},                           // 模块名到基于 baseUrl 的路径映射的列表&lt;br/&gt;    &lt;span&gt;&quot;rootDirs&quot;&lt;/span&gt;: [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容&lt;br/&gt;    &lt;span&gt;&quot;typeRoots&quot;&lt;/span&gt;: [],                       // 包含类型声明的文件列表&lt;br/&gt;    &lt;span&gt;&quot;types&quot;&lt;/span&gt;: [],                           // 需要包含的类型声明文件名列表&lt;br/&gt;    &lt;span&gt;&quot;allowSyntheticDefaultImports&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,  // 允许从没有设置默认导出的模块中默认导入。&lt;br/&gt;&lt;br/&gt;    /* Source Map Options */&lt;br/&gt;    &lt;span&gt;&quot;sourceRoot&quot;&lt;/span&gt;: &lt;span&gt;&quot;./&quot;&lt;/span&gt;,                    // 指定调试器应该找到 TypeScript 文件而不是源文件的位置&lt;br/&gt;    &lt;span&gt;&quot;mapRoot&quot;&lt;/span&gt;: &lt;span&gt;&quot;./&quot;&lt;/span&gt;,                       // 指定调试器应该找到映射文件而不是生成文件的位置&lt;br/&gt;    &lt;span&gt;&quot;inlineSourceMap&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件&lt;br/&gt;    &lt;span&gt;&quot;inlineSources&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性&lt;br/&gt;&lt;br/&gt;    /* 其他选项 */&lt;br/&gt;    &lt;span&gt;&quot;experimentalDecorators&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,        // 启用装饰器&lt;br/&gt;    &lt;span&gt;&quot;emitDecoratorMetadata&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;          // 为装饰器提供元数据的支持&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;十六、TypeScript 开发辅助工具&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;16.1 TypeScript Playground&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;简介：TypeScript 官方提供的在线 TypeScript 运行环境，利用它你可以方便地学习 TypeScript 相关知识与不同版本的功能特性。&lt;/p&gt;&lt;p&gt;在线地址：https://www.typescriptlang.org/play/&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.22396416573348266&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2pdRian6Xlm7wMdPrPspib15zw0mAtyxYeboqn4Ph1NKR2HU2pjEnhcvMYz5wRnTUTesibqic8BHZesA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1786&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了 TypeScript 官方的 Playground 之外，你还可以选择其他的 Playground，比如 codepen.io、stackblitz 或 jsbin.com 等。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;16.2 TypeScript UML Playground&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;简介：一款在线 TypeScript UML 工具，利用它你可以为指定的 TypeScript 代码生成 UML 类图。&lt;/p&gt;&lt;p&gt;在线地址：https://tsuml-demo.firebaseapp.com/&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.42857142857142855&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2pdRian6Xlm7wMdPrPspib15Anb84ARaicDX98IZRv9Xn4qmpevs1PLQk4jRiabHq5RIiaAS1iapUKKjMg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1260&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;16.3 JSON TO TS&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;简介：一款 TypeScript 在线工具，利用它你可以为指定的 JSON 数据生成对应的 TypeScript 接口定义。&lt;/p&gt;&lt;p&gt;在线地址：http://www.jsontots.com/&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34084231145935356&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2pdRian6Xlm7wMdPrPspib15APMtEic2iaBBUwhLNe3IDZEZ17ib85S386UsTphJ5KI2TVA9oQoVKYibHQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2042&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了使用 jsontots 在线工具之外，对于使用 VSCode IDE 的小伙们还可以安装 JSON to TS 扩展来快速完成  &lt;strong&gt;JSON to TS&lt;/strong&gt; 的转换工作。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;16.4 Schemats&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;简介：利用 Schemats，你可以基于（Postgres，MySQL）SQL 数据库中的 schema 自动生成 TypeScript 接口定义。&lt;/p&gt;&lt;p&gt;在线地址：https://github.com/SweetIQ/schemats&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3559322033898305&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2pdRian6Xlm7wMdPrPspib15GzFcV663YzaAaed2GGicbDUX86BqksA8iaic5l2cibiarM0AMozTzkdrvpQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1180&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;16.5 TypeScript AST Viewer&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;简介：一款 TypeScript AST 在线工具，利用它你可以查看指定 TypeScript 代码对应的 AST（Abstract Syntax Tree）抽象语法树。&lt;/p&gt;&lt;p&gt;在线地址：https://ts-ast-viewer.com/&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.32665832290362956&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2pdRian6Xlm7wMdPrPspib15hRGSUA8cKZUCXzU3xw59fP3hRBhUtT7yyIhmz6MiceY390GfktjGJgw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1598&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于了解过 AST 的小伙伴来说，对 astexplorer 这款在线工具应该不会陌生。该工具除了支持 JavaScript 之外，还支持 CSS、JSON、RegExp、GraphQL 和 Markdown 等格式的解析。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;16.6 TypeDoc&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;简介：TypeDoc 用于将 TypeScript 源代码中的注释转换为 HTML 文档或 JSON 模型。它可灵活扩展，并支持多种配置。&lt;/p&gt;&lt;p&gt;在线地址：https://typedoc.org/&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3664&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2pdRian6Xlm7wMdPrPspib15jYkKUzGD3xPwe2u9DCjgZbCu3kkB9YbltGibL7IiciaXVQnjYzEFYMiaJQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1250&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;16.7 TypeScript ESLint&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;简介：使用 TypeScript ESLint 可以帮助我们规范代码质量，提高团队开发效率。&lt;/p&gt;&lt;p&gt;在线地址：https://typescript-eslint.io/&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.29833333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V2pdRian6Xlm7wMdPrPspib15jqkMRmnuvxruLu0XavOnzwmDcEvUBToSaPGwyRG8wJ0mBQtGtl2z6Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对 TypeScript ESLint 项目感兴趣且想在项目中应用的小伙伴，可以参考 “在Typescript项目中，如何优雅的使用ESLint和Prettier” 这篇文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;能坚持看到这里的小伙伴都是 “真爱”，如果你还意犹未尽，那就来看看阿宝哥整理的 Github 上 1.8K+ 的开源项目：awesome-typescript。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://github.com/semlinker/awesome-typescript&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;十七、参考资源&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;mariusschulz - the-unknown-type-in-typescript&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;深入理解 TypeScript - 编译上下文&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TypeScript 4.0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TypeScript Quickly&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>