<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>7e5d5481319d70c04824317c40b526b2</guid>
<title>什么是布隆过滤器？如何解决高并发缓存穿透问题？</title>
<link>https://toutiao.io/k/8klo399</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是Tom哥~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日常开发中，大家经常使用缓存，但是你知道大型的互联网公司面对高并发流量，要注意缓存穿透问题吗!!!    &lt;span&gt;本&lt;/span&gt;&lt;span&gt;文会介绍布隆过滤器，空间换时间，以较低的内存空间、高效解决这个问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇文章的目录：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;638&quot; data-backw=&quot;578&quot; data-ratio=&quot;1.1039861351819757&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwdQPcrMUlviaId4sbV7gLjDHgVwfreYQVHN37AKgGZkANkx06qK2FU5ic9BVDNz04oVUjwUibDp6by7A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1154&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg2NzYyNjQzNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwdmOC0H6kaQlnh3rvWF2hPpzBoAoibbfQkhLdXfEpQgd8frHoDJDH503rv3FaMK6las2rCNQY7icr6w/0?wx_fmt=png&quot; data-nickname=&quot;微观技术&quot; data-alias=&quot;weiguanjishu&quot; data-signature=&quot;前阿里架构师，研究生，CSDN博客专家。负责过电商交易、社区团购、流量营销等业务。分享后端架构技能、一线大厂面试经验、团队管理等话题。欢迎关注&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;1、性能不够，缓存来凑&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在的年轻人都喜欢网购，没事就逛逛淘宝，剁剁手，买些自己喜欢的东西，释放下工作压力。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6514195583596214&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwdQPcrMUlviaId4sbV7gLjDHff8jyDR6CotOX3dgI3vcbr9qlVvIbfPlatmILiauOXRicibiasegOk0K5w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1268&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;br/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;地址：&lt;/p&gt;&lt;p&gt;https://detail.tmall.com/item.htm?id=628993216729&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上图是一个天猫 iphone12 的&lt;/span&gt;&lt;code&gt;&lt;span&gt;商品详情页&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，id表示商品的编号&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们都知道淘宝的访问量是非常高的，为了提升系统的吞吐量，做了很多性能优化，其中非常重要一点是将信息异构到缓存中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有句话说的好：&lt;strong&gt;性能不够，缓存来凑。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但是，使用缓存时，我们要关注一个重要问题，如果缓存没有命中怎么办？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4590909090909091&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwdQPcrMUlviaId4sbV7gLjDH59K8oibuKMZJ1wctKjKcMhLPAOIwzxDPwcq4R88xc2zYY6cWVsfgTXQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;440&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;br/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;2、缓存没有命中，怎么办？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.952&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwdQPcrMUlviaId4sbV7gLjDHtCOfkTglGGicqZV5LoEjyV4ibIHsSKYTaPYQvWaRPCMEDnBpWBGCvy4Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;①我们先查询缓存，判断缓存中是否有数据&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;②如果有数据，直接返回&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;③如果缓存为空，我们需要再查一次数据库，并将数据格式异构化，然后预热到缓冲中，然后将结果返回&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;步骤 ③ 存在风险漏洞，如果缓存中数据不存在，压力会转嫁给数据库。假如被竞争对手利用，搞无效请求流量攻击，瞬间大量请求打到数据库中，对系统性能产生很大影响，很容易把数据库打挂，这种现象称为缓存穿透。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;3、那么如何处理缓存穿透？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们的思路是，缓存中能不能判断这个数据库值的存在性，如果真的不存在，直接返回，也避免一次数据库查询。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由于不存在是个&lt;/span&gt;&lt;code&gt;&lt;span&gt;无限边界&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，所以，我们采用反向策略，将存在的值建立一个高效的检索。每次缓存取值时，先走一次判空检索。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;简单归纳下，这个框架的要求：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;经调研，我们发现&lt;/span&gt;&lt;code&gt;&lt;span&gt;布隆过滤器&lt;/span&gt;&lt;/code&gt;&lt;span&gt;具备以上两个条件。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;4、什么是布隆过滤器？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;优点：空间效率和查询时间都远远超过一般的算法。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;缺点：有一定的误识别率，删除困难。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;5、布隆过滤器如何构建？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;布隆过滤器本质上是一个 n 位的二进制数组，用0和1表示。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假如我们以商品为例，有三件商品，商品编码分别为，&lt;/span&gt;&lt;code&gt;&lt;span&gt;id1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;id2&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;id3&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;a）首先，对&lt;/span&gt;&lt;code&gt;&lt;span&gt;id1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，进行三次哈希，并确定其在二进制数组中的位置。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.37421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwdQPcrMUlviaId4sbV7gLjDHtcKh11kV9gictsChDiaR7Mu9BAQjgUnKRQOG0iaJqVCn1o0T21ZyuOxBQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;br/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;三次哈希，对应的二进制数组下标分别是 2、5、8，将原始数据从 0 变为 1。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;b）对&lt;/span&gt;&lt;code&gt;&lt;span&gt;id2&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，进行三次哈希，并确定其在二进制数组中的位置。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.39609375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwdQPcrMUlviaId4sbV7gLjDHeAcT8xn1O2ZB7Sm83vgziammUoG1IFPyjHQOfFJMbqKDzica5N8xgDRA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;三次哈希，对应的二进制数组下标分别是 2、7、98，将原始数据从 0 变为 1。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下标 2，之前已经被操作设置成 1，则本次认为是哈希冲突，不需要改动。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Hash 规则：如果在 Hash 后，原始位它是 0 的话，将其从 0 变为 1；如果本身这一位就是 1 的话，则保持不变。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;6、布隆过滤器如何使用？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.3746958637469586&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwdQPcrMUlviaId4sbV7gLjDH7CKaPflUqzLCSNNlQ20OdJkx9JkIJbloibKxYCbNA2s5wYMq8esp47w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;822&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;br/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;跟初始化的过程有点类似，当查询一件商品的缓存信息时，我们首先要判断这件商品是否存在。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过三个哈希函数对商品id计算哈希值&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;然后，在布隆数组中查找访问对应的位值，0或1&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;判断，三个值中，只要有一个不是1，那么我们认为数据是不存在的。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;注意：布隆过滤器只能精确判断数据不存在情况，对于存在我们只能说是可能，因为存在Hash冲突情况，当然这个概率非常低。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;7、如何减少布隆过滤器的误判？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;a）&lt;/span&gt;&lt;span&gt;增加二进制位数组的长度。这样经过hash后数据会更加的离散化，出现冲突的概率会大大降低&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;b）增加Hash的次数，变相的增加数据特征，特征越多，冲突的概率越小&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;8、布隆过滤器会不会很费内存？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;带着疑问，我们来做个实验&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设有1千万个数据，我们需要记录其是否存在。存在的话标记1，不存在标记为0。技术选型，框架采用Redis的&lt;/span&gt;&lt;code&gt;&lt;span&gt;BitMap&lt;/span&gt;&lt;/code&gt;&lt;span&gt;存储。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据初始化预热代码：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;redisTemplate.executePipelined(new RedisCallback&amp;lt;Long&amp;gt;() {&lt;br/&gt;    @Nullable&lt;br/&gt;    @Override&lt;br/&gt;    public Long doInRedis(RedisConnection connection) throws DataAccessException {&lt;br/&gt;        connection.openPipeline();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (int offset = 10000000; offset &amp;gt;= 0; offset--) {&lt;br/&gt;            boolean value = offset % 2 == 0 ? &lt;span&gt;true&lt;/span&gt; : &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            connection.setBit(&lt;span&gt;&quot;bloom-filter-data-1&quot;&lt;/span&gt;.getBytes(), offset, value);&lt;br/&gt;        }&lt;br/&gt;        connection.closePipeline();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; null;&lt;br/&gt;    }&lt;br/&gt;});&lt;br/&gt;System.out.println(&lt;span&gt;&quot;数据预热完成&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;性能有点慢，我们也可以采用分组形式，10000个数一组，多批次提交。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.353125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwdQPcrMUlviaId4sbV7gLjDHQOmElTu0mpSjQgHIE0ibDYQ9VJ0ia0p3ZlyLzFM9rnINwKEcq5g1oOQg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据上传完了后，大小 1.19M，跟我们设想的一样。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;计算公式：&lt;/span&gt;&lt;span&gt; 10000000/8/1024/1024=1.19M&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;9、Java应用中，如何使用布隆过滤器？代码实例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;J&lt;/span&gt;&lt;span&gt;ava语言的生态非常繁荣，提供了很多开箱即用的开源框架供我们使用。布隆过滤器也不例外，Java 中提供了一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Redisson&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的组件，它内置了布隆过滤器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先引入依赖包&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;org.redisson&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;redisson&amp;lt;/artifactId&amp;gt;&lt;br/&gt;    &amp;lt;version&amp;gt;3.11.1&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;代码示例：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;/**&lt;br/&gt; * @author 微信公众号：微观技术&lt;br/&gt; */&lt;br/&gt;@Test&lt;br/&gt;public void &lt;span&gt;test5&lt;/span&gt;() {&lt;br/&gt;    Config config = new Config();&lt;br/&gt;    config.useSingleServer().setAddress(&lt;span&gt;&quot;redis://172.16.67.37:6379&quot;&lt;/span&gt;);&lt;br/&gt;    RedissonClient cient = Redisson.create(config);&lt;br/&gt;    RBloomFilter&amp;lt;String&amp;gt; bloomFilter = cient.getBloomFilter(&lt;span&gt;&quot;test5-bloom-filter&quot;&lt;/span&gt;);&lt;br/&gt;    // 初始化布隆过滤器，数组长度100W，误判率 1%&lt;br/&gt;    bloomFilter.tryInit(1000000L, 0.01);&lt;br/&gt;    // 添加数据&lt;br/&gt;    bloomFilter.add(&lt;span&gt;&quot;Tom哥&quot;&lt;/span&gt;);&lt;br/&gt;    // 判断是否存在&lt;br/&gt;    System.out.println(bloomFilter.contains(&lt;span&gt;&quot;微观技术&quot;&lt;/span&gt;));&lt;br/&gt;    System.out.println(bloomFilter.contains(&lt;span&gt;&quot;Tom哥&quot;&lt;/span&gt;));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;false&lt;/span&gt;   // 肯定不存在&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;    // 可能存在，有1%的误判率&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;注意：误判率设置过小，会产生更多次的 Hash 操作，降低系统的性能。通常我们的建议值是 1%&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;10、布隆过滤器二进制数组，如何处理删除？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;初始化后的布隆过滤器，可以直接拿来使用了。但是如果原始数据删除了怎么办？布隆过滤器二进制数组如何维护？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;直接删除不行吗？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;还真不行！因为这里面有Hash冲突的可能，会导致误删。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;怎么办？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;方案1：开发定时任务，每隔几个小时，自动创建一个新的布隆过滤器数组，替换老的，有点&lt;/span&gt;&lt;code&gt;&lt;span&gt;CopyOnWriteArrayList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的味道&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;方案2：布隆过滤器增加一个等长的数组，存储计数器，主要解决冲突问题，每次删除时对应的计数器减一，如果结果为0，更新主数组的二进制值为0&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;11、布隆过滤器的应用场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;本文重点介绍的，解决缓存穿透&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网页爬虫对URL的去重，避免爬取相同的URL地址&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;关于我：前阿里架构师，出过专利，竞赛拿过奖，CSDN博客专家，负责过电商交易、社区生鲜、营销、金融等业务，多年团队管理经验，爱思考，喜欢结交朋友&lt;/span&gt;&lt;/section&gt;&lt;h1 accuse=&quot;qTitle&quot;&gt;&lt;span&gt;&lt;span&gt;「长按2秒」↓↓&lt;/span&gt;&lt;span&gt;↓ 二维码，拉你进群，BAT大厂大神技术交流&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.069090909090909&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwcdJhGaQRdAk0VWLIAIU548z3Izf6mwqwwUX9X86hvNHZq158VYMEaxegjfRg8ic02O0HeWD4xIsiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247485309&amp;amp;idx=1&amp;amp;sn=1209b7e3324440f7893847a935b3af5f&amp;amp;chksm=ceb9fbd6f9ce72c0ec04b49ed36d947df9b25fecdd7266dac148bb36582b96c2792e1d15d325&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;代码写的烂，经常被同事怼，教你一招！&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247485237&amp;amp;idx=1&amp;amp;sn=e13bb954fb332221ac999e6a5d7f3127&amp;amp;chksm=ceb9fb9ef9ce72885f7a552630c2ed84badd1683019ff86459e8088fe886e89dd4b3932fb5f9&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;同事问我，SQL 语句明明命中了索引，为什么执行很慢？&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247484980&amp;amp;idx=1&amp;amp;sn=25a530689f0657750d579263800369a6&amp;amp;chksm=ceb9fa9ff9ce7389974d2f33bea9d861920cb75cca559f1f2810c89f729011bb3c2839ac46da&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;学会这10个设计原则，离架构师又进了一步！！！&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247484929&amp;amp;idx=1&amp;amp;sn=d8cb3306dea9f1b92fd30d59da3f536a&amp;amp;chksm=ceb9faaaf9ce73bca59b46021a450fdc84aa0f85d6b49ff0e5578cc3abaa1433447f7dffc5e4&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;人人都是架构师？？？谈何容易！！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d4c87217e437d8fa77733b6db03e0346</guid>
<title>Nacos 注册中心之概要设计</title>
<link>https://toutiao.io/k/ziy0cf7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前言&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在之前的文章中分析了Nacos配置中心，配置中心的核心是配置的创建、读取、推送。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注册中心的核心比配置中心多一个&lt;code&gt;服务探活&lt;/code&gt;模块，他俩的相似度非常高，甚至阿里内部的注册中心就叫&lt;code&gt;ConfigServer&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nacos注册中心打算分成几个模块来分析，本文重点在于&lt;code&gt;概要设计&lt;/code&gt;，基于2.0.0版本。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;环境搭建&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用Nacos的源码来搭建源码阅读和调试环境，可参考&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI5NjE2MDQwNg==&amp;amp;mid=2247485206&amp;amp;idx=1&amp;amp;sn=2585f5592dccf22429e6e4361e99688b&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《Nacos配置中心模块详解》&lt;/a&gt; &lt;code&gt;Nacos调试环境搭建&lt;/code&gt;部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 JVM参数可以指定只启动Naming模块，也可以不指定，默认全都启动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;example模块下将NamingExample复制一份进行测试。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;设计概要&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;服务发现模型&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端视角的服务发现模型（注意：服务端视角的模型定义与客户端视角有区别）包含以下几点内容：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Service：服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Cluster：集群&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Instance：实例&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;代码注释：We introduce a &#x27;service --&amp;gt; cluster --&amp;gt; instance&#x27; model, in which service stores a list of clusters, which contains a list of instances&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他们的关系如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5458128078817734&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0QFUmsXLf1F2roXhfSILRdJ63sVicj62h0DkgibzcQCytfqZEfRHVjo7cl9OKALWlvS1HeNnxA4iauiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2030&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Service&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6214689265536724&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0QFUmsXLf1F2roXhfSILRdJ6zV123WXw1oaCBpMRVPszLDAichpkahW12AKwAcW7nrrC5BEv8TaEDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;708&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;name：服务名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;protectThreshold：保护阈值，限制了实例被探活摘除的最大比例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;appName：服务的应用名，暂无实际用处&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;groupName：分组名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;metadata：元数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Cluster&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6031746031746031&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0QFUmsXLf1F2roXhfSILRdJ8WGBiaNJyhb5kKkeDDE6A0HpXP9uOVnbNe9hnukSB3KymYGHkguX8EA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;756&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;serviceName：所属服务名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;name：集群名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;healthChecker：服务探活配置，此处仅对服务端主动探活生效，有TCP、HTTP、MySQL、None几种方式，默认TCP&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;defaultPort：默认端口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;defaultCheckPort：默认探活端口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;useIPPort4Check：是否使用port进行探活&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;metadata：元数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Instance&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.104859335038363&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0QFUmsXLf1F2roXhfSILRdJEvk6iaWRPm1a8ERMosZIhOKc1m4U5ZlXLMsTcymyYc6ibfh0Eft8fruw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;782&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;instanceId：实例id，唯一标志，Nacos提供了&lt;code&gt;simple&lt;/code&gt;和&lt;code&gt;snowflake&lt;/code&gt;两种算法来生成，默认是&lt;code&gt;simple&lt;/code&gt;，其生成方式为&lt;code&gt;ip#port#clusterName#serviceName&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ip：实例ip&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;port：实例port&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;weight：实例权重&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;healthy：实例健康状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;clusterName：所属集群名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;serviceName：所属服务名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;metadata：元数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;enabled：是否接收请求，可用于临时禁用或摘流等场景&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ephemeral：是否为临时实例，后文会介绍该参数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;getInstanceHeartBeatInterval：获取实例心跳上报间隔时间，默认5秒，可配置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;getInstanceHeartBeatTimeOut：获取心跳超时时间，15秒，配置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;getIpDeleteTimeout：获取ip被删除的超时时间，默认30秒，可配置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;getInstanceIdGenerator：获取id生成器&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了上述的三层模型外，Nacos注册中心和配置中心有着一样的namespace设计，与client绑定，可隔离环境，租户。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;接口设计&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;registerInstance：注册实例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;deregisterInstance：注销实例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;getAllInstances：获取一个服务的所有实例（包括不健康）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;selectInstances：根据条件获取一个服务的实例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;selectOneHealthyInstance：根据负载均衡策略获取服务的一个健康的实例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;subscribe：订阅服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;unsubscribe：取消订阅服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;getServicesOfServer：根据条件分页获取所有服务&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;交互流程&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nacos 2.0 为ephemeral不同的实例提供了两套流程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ephemeral=false，永久实例，与server端的交互采用http请求，server节点间数据同步采用了raft协议，健康检查采用了server端主动探活的机制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ephemeral=true，临时实例，与server端的交互采用grpc请求，server节点间数据同步采用了distro协议，健康检查采用了TCP连接的KeepAlive模式&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;临时实例的交互流程&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;client初始化，与server建立连接&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;client 注册服务，将serviceName+ip+port+clusterName等数据打包发送grpc请求&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;同时客户端缓存已注册过的服务，当client与server连接断开重连时，client重新将这些数据注册到server端&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;server端接收到client的注册请求，将注册信息存入client对象（用于保存client的所有数据）中，并触发ClientChangedEvent、ClientRegisterServiceEvent、InstanceMetadataEvent&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ClientChangedEvent触发server节点之间的数据同步（distro协议）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ClientRegisterServiceEvent触发更新publisherIndexes（保存service =&amp;gt; clientId的Map&amp;lt;Service, Set&lt;string&gt;&amp;gt;，即哪些客户端注册了这个服务的索引），同时也触发一个ServiceChangedEvent，该事件负责向监听该服务的客户端进行推送&lt;/string&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;InstanceMetadataEvent，处理元数据，Nacos在2.0中将元数据与基础数据拆分开，分为不同的处理流程&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;client订阅服务&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;根据serviceName、groupName、clusters信息生成key，创建eventListener，同时向server端发送订阅请求，并缓存订阅信息，用于连接断开重连后再次向server端发送信息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;server端接收到client的订阅请求&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将订阅信息打包为subscribers，并存入client对象中，触发ClientSubscribeServiceEvent事件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ClientSubscribeServiceEvent事件更新subscriberIndexes（保存service =&amp;gt; clientId的Map&amp;lt;Service, Set&lt;string&gt;&amp;gt;，即哪些客户端订阅了这个服务的索引），同时触发ServiceSubscribedEvent事件&lt;/string&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ServiceSubscribedEvent事件会延时500ms向该client推送该服务的最新数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;反向的操作如注销、取消订阅与正向操作类似，不再赘述&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;最后&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文从总体上分析了Nacos 2.0的模型设计、接口设计以及交互流程，读完后对Nacos的服务发现有一个整体上的认识。后续篇幅会从细节入手，如dubbo Nacos扩展、一致性协议、探活、CMDB扩展等逐一进行分析。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;关于作者：专注后端的中间件开发，公众号&quot;捉虫大师&quot;作者，关注我，给你最纯粹的技术干货&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/xacdaKuBM0QFUmsXLf1F2roXhfSILRdJhWRY1kIib1RGO921X9Zo5saULWEtViaib5qxaMN0DY1KCS26e8NoOVd8A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/figure&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2bd217e81a7837ada280051a7d7e3330</guid>
<title>推荐两款超实用的 gRPC 客户端调试工具</title>
<link>https://toutiao.io/k/622rri2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lkVfNnnUQnlHs65Y8RHabCwhUJERZ5Y5SNVibS2GEO9xecx5Easr5WvO40Lb3PkkykLL9BmicibsDGYTtycbMOwGw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;图片拍摄于2021年7月10日，湖州安吉。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 md-src-pos=&quot;181..187&quot;&gt;介绍&lt;/h3&gt;&lt;p md-src-pos=&quot;108..158&quot;&gt;&lt;span&gt;正好看到董泽润老哥一篇关于使用&lt;/span&gt;&lt;code md-src-pos=&quot;126..137&quot;&gt;&lt;span&gt;WireShark&lt;/span&gt;&lt;/code&gt;&lt;span&gt;分析&lt;/span&gt;&lt;code md-src-pos=&quot;141..147&quot;&gt;&lt;span&gt;gRPC&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;流量的文章&lt;/span&gt;，&lt;span&gt;学到了。原文地址:&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg5MTYyNzM3OQ==&amp;amp;mid=2247484266&amp;amp;idx=1&amp;amp;sn=624672bb75251908072931f161be7d8c&amp;amp;chksm=cfcb3176f8bcb860edd532a80af4fd9fad9650bf9e84436cd1e13fa54c8c62bd50b931650584&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;小技巧！Wireshark 让调试 grpc 不再困难&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;160..194&quot;&gt;&lt;span&gt;那我就介绍使用过的两款&lt;/span&gt;&lt;code md-src-pos=&quot;178..184&quot;&gt;&lt;span&gt;gRPC&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;客户端调试工具吧&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h3 md-src-pos=&quot;181..187&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 md-src-pos=&quot;181..187&quot;&gt;Evans&lt;/h3&gt;&lt;p md-src-pos=&quot;206..271&quot;&gt;&lt;code md-src-pos=&quot;206..213&quot;&gt;&lt;span&gt;Evans&lt;sup&gt;[1&lt;/sup&gt;&lt;sup&gt;]&lt;/sup&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;有两种运行模式&lt;/span&gt;：&lt;/span&gt;&lt;code md-src-pos=&quot;220..226&quot;&gt;&lt;span&gt;REPL&lt;/span&gt;&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code md-src-pos=&quot;229..234&quot;&gt;&lt;span&gt;CLI&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;206..271&quot;&gt;&lt;span&gt;&lt;span&gt;比起其他&lt;/span&gt;&lt;/span&gt;&lt;code md-src-pos=&quot;240..246&quot;&gt;&lt;span&gt;gRPC&lt;/span&gt;&lt;/code&gt;&lt;span&gt;客户端,&lt;code md-src-pos=&quot;206..213&quot;&gt;Evans&lt;/code&gt;更具有表现力，并且它还支持自动补全功能。&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;273..307&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;code md-src-pos=&quot;206..213&quot;&gt;&lt;span&gt;Evans&lt;/span&gt;&lt;/code&gt;的安装非常方便&lt;/span&gt;，&lt;span&gt;在&lt;/span&gt;&lt;/span&gt;&lt;code md-src-pos=&quot;284..289&quot;&gt;&lt;span&gt;Mac&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;上我们只需要执行以下两行命令即可&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6306818181818182&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnlHs65Y8RHabCwhUJERZ5Y5o89yRVibBB62AgdwMsRHAibf8V5cSMwugYsy4CyLia9qhgZT9K6lr7VJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;704&quot;/&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;365..383&quot;&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;365..383&quot;&gt;&lt;span&gt;我们来学习一下&lt;/span&gt;&lt;code md-src-pos=&quot;373..379&quot;&gt;&lt;span&gt;REPL&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;模式&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;385..485&quot;&gt;&lt;span&gt;首先我们需要有一个&lt;/span&gt;&lt;code md-src-pos=&quot;395..399&quot;&gt;&lt;span&gt;pb&lt;/span&gt;&lt;/code&gt;&lt;span&gt;文件，假设你的文件在&lt;/span&gt;&lt;code md-src-pos=&quot;411..426&quot;&gt;&lt;span&gt;api/api.proto&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，&lt;span&gt;我们只需要这样：&lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7858672376873662&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/lkVfNnnUQnlHs65Y8RHabCwhUJERZ5Y5RoBztNZ2AG2TiaTyFlUex6voEVyamfQxfzyh4b7qVj9TM1ic5GK1dNQg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;934&quot;/&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;385..485&quot;&gt;&lt;span&gt;默认地址为&lt;/span&gt;&lt;code md-src-pos=&quot;493..510&quot;&gt;&lt;span&gt;127.0.0.1:50051&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，&lt;span&gt;当然你可以通过&lt;/span&gt;&lt;/span&gt;&lt;code md-src-pos=&quot;519..527&quot;&gt;&lt;span&gt;--host&lt;/span&gt;&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code md-src-pos=&quot;530..538&quot;&gt;&lt;span&gt;--port&lt;/span&gt;&lt;/code&gt;&lt;span&gt;来指定服务器。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.9702127659574468&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnlHs65Y8RHabCwhUJERZ5Y5FxxeztTlChp2TswzU7KcId6SRia4oWc3FPGvf0LdRfQGPxQUibd7nVjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;940&quot;/&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;598..604&quot;&gt;&lt;span&gt;&lt;span&gt;上图的命令&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;&lt;ul md-src-pos=&quot;605..702&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code md-src-pos=&quot;608..622&quot;&gt;&lt;span&gt;show package&lt;/span&gt;&lt;/code&gt;&lt;span&gt;读取&lt;/span&gt;&lt;code md-src-pos=&quot;626..630&quot;&gt;&lt;span&gt;pb&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;包名&lt;/span&gt;，&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code md-src-pos=&quot;637..651&quot;&gt;&lt;span&gt;show service&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;显示对应服务列表&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code md-src-pos=&quot;665..675&quot;&gt;&lt;span&gt;call xxx&lt;/span&gt;&lt;/code&gt;&lt;span&gt;调用&lt;/span&gt;&lt;code md-src-pos=&quot;679..685&quot;&gt;&lt;span&gt;gRPC&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;服务&lt;/span&gt;......&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;.....&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p md-src-pos=&quot;704..716&quot;&gt;&lt;span&gt;&lt;span&gt;更多命令可自行查阅官网&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;718..861&quot;&gt;&lt;span&gt;除了上述这种直接引入&lt;/span&gt;&lt;code md-src-pos=&quot;729..733&quot;&gt;&lt;span&gt;pb&lt;/span&gt;&lt;/code&gt;&lt;span&gt;文件外，我们还可以通过&lt;/span&gt;&lt;code md-src-pos=&quot;746..752&quot;&gt;&lt;span&gt;gRPC&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;反射包&lt;/span&gt;(&lt;/span&gt;&lt;code md-src-pos=&quot;757..769&quot;&gt;&lt;span&gt;reflection&lt;/span&gt;&lt;/code&gt;&lt;span&gt;)， &lt;span&gt;将&lt;/span&gt;&lt;/span&gt;&lt;code md-src-pos=&quot;774..787&quot;&gt;&lt;span&gt;grpc.Server&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;注册到反射服务中&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;718..861&quot;&gt;&lt;span&gt;这样的话，就可以通过&lt;/span&gt;&lt;code md-src-pos=&quot;809..821&quot;&gt;&lt;span&gt;reflection&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;提供的反射服&lt;/span&gt;务&lt;span&gt;查询到对应的&lt;/span&gt;&lt;/span&gt;&lt;code md-src-pos=&quot;836..842&quot;&gt;&lt;span&gt;gRPC&lt;/span&gt;&lt;/code&gt;&lt;span&gt;服务，或者直接调用&lt;/span&gt;&lt;code md-src-pos=&quot;850..856&quot;&gt;&lt;span&gt;gRPC&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;服务&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;863..871&quot;&gt;&lt;span&gt;注册反射服务操作也很简单，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.701123595505618&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnlHs65Y8RHabCwhUJERZ5Y54g0tMroG31tA4kzTViaS5Z9uKelFN7iciaXdEYMv3oCjnnvDdSE7ta4Dw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;890&quot;/&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;863..871&quot;&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;1021..1098&quot;&gt;&lt;span&gt;回到&lt;/span&gt;&lt;code md-src-pos=&quot;1024..1031&quot;&gt;&lt;span&gt;Evans&lt;/span&gt;&lt;/code&gt;&lt;span&gt;工具， 如果一个&lt;/span&gt;&lt;code md-src-pos=&quot;1041..1047&quot;&gt;&lt;span&gt;gRPC&lt;/span&gt;&lt;/code&gt;&lt;span&gt;服务注册了反射，我们就可以使用&lt;/span&gt;&lt;code md-src-pos=&quot;1064..1083&quot;&gt;&lt;span&gt;-r&lt;/span&gt;&lt;/code&gt;&lt;span&gt;选项来启动&lt;/span&gt;&lt;code md-src-pos=&quot;1090..1097&quot;&gt;&lt;span&gt;Evans&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;1100..1158&quot;&gt;&lt;span&gt;比如像下面这样&lt;/span&gt;： &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6867469879518072&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/lkVfNnnUQnlHs65Y8RHabCwhUJERZ5Y5SkPqgIfCn4YbiaBRhJbKnjUO2iaoUkSSGgLWTicpvRuMwrpyOLou0Ogicw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1079&quot;/&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;1100..1158&quot;&gt;&lt;span&gt;对另外一种模式感兴趣的可以自行查看官网，这里不再演示。&lt;/span&gt;&lt;/p&gt;&lt;h3 md-src-pos=&quot;181..187&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 md-src-pos=&quot;181..187&quot;&gt;BloomRPC&lt;/h3&gt;&lt;p md-src-pos=&quot;1175..1215&quot;&gt;&lt;code md-src-pos=&quot;1175..1185&quot;&gt;&lt;span&gt;BloomRPC&lt;sup&gt;[2&lt;/sup&gt;&lt;sup&gt;]&lt;/sup&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;是一个简单的&lt;/span&gt;&lt;code md-src-pos=&quot;1192..1197&quot;&gt;&lt;span&gt;GUI&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;客户端工具，使用这个那就更简单了&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;1217..1289&quot;&gt;&lt;span&gt;只需要导入&lt;/span&gt;&lt;code md-src-pos=&quot;1223..1227&quot;&gt;&lt;span&gt;pb&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;文件，然后点两下即可&lt;/span&gt;。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.552821997105644&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/lkVfNnnUQnlHs65Y8RHabCwhUJERZ5Y5ggXIlBBuBRpJTg8IGFibthsHuDPEZJ2MBp3UeUhib2ibsT1kJUcxSW5Rg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1382&quot;/&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;1291..1321&quot;&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;1291..1321&quot;&gt;&lt;span&gt;当然有个不好点在于，每次修改了&lt;/span&gt;&lt;code md-src-pos=&quot;1307..1311&quot;&gt;&lt;span&gt;pb&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，&lt;span&gt;都不得不重新导入&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;1291..1321&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;h3 md-src-pos=&quot;1324..1330&quot;&gt;总结&lt;/h3&gt;&lt;p md-src-pos=&quot;1331..1410&quot;&gt;&lt;span&gt;以上介绍了两款&lt;/span&gt;&lt;code md-src-pos=&quot;1339..1345&quot;&gt;&lt;span&gt;gRPC&lt;/span&gt;&lt;/code&gt;&lt;span&gt;客户端工具。不知道你们平常都使用&lt;/span&gt;&lt;code md-src-pos=&quot;1363..1369&quot;&gt;&lt;span&gt;gRPC&lt;/span&gt;&lt;/code&gt;&lt;span&gt;哪些周边工具，欢迎一起讨论&lt;/span&gt;。&lt;/p&gt;&lt;h3 md-src-pos=&quot;1324..1330&quot;&gt;相关文章推荐&lt;/h3&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247483901&amp;amp;idx=1&amp;amp;sn=807de1cd6962dd1ccc53e8b5ec75a5b0&amp;amp;chksm=fa80d06acdf7597c5c28884216b70bbc7f5e266443d47cdc04ffad9767803dbf264f31313472&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;gRPC入门教程汇总&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247487354&amp;amp;idx=1&amp;amp;sn=f2f1121193603f69c9fde18ece2c71b9&amp;amp;chksm=fa80deedcdf757fbfa3ce5393d473bc2a79447466423c81ee2c8feb9091825afa1a0311af985&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Interceptor拦截器 -- gRPC生态里的中间件&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247486329&amp;amp;idx=1&amp;amp;sn=04cf6ab2613ac1174808fa727b18212f&amp;amp;chksm=fa80daeecdf753f8c4625bc522bce5960383da9eadf2edd5ef57a8ae384c99f7ebb45d43e397&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;gRPC服务注册发现及负载均衡的实现方案与源码解析&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 md-src-pos=&quot;8529..8535&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 md-src-pos=&quot;8529..8535&quot;&gt;&lt;span&gt;附录&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;span&gt;https://github.com/ktr0731/evans&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;span&gt;https://github.com/uw-labs/bloomrpc&lt;/span&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;如果文章对你有所帮助，点赞、转发&lt;strong&gt;、&lt;/strong&gt;留言都是一种支持！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUzNTY5MzU2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4pGhLz2xEbRFHnAQon2QLYgbBibCJo1ibJHesLWshPJeRibateRtAqkaf6BgjlbhYiaxHLq6Zu07CRPw/0?wx_fmt=png&quot; data-nickname=&quot;网管叨bi叨&quot; data-alias=&quot;kevin_tech&quot; data-signature=&quot;分享软件开发和系统架构设计基础、Go 语言和Kubernetes。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span data-darkmode-color-16222629164135=&quot;rgb(160, 160, 160)&quot; data-darkmode-original-color-16222629164135=&quot;#fff|rgb(160, 160, 160)&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>41ce1964bde2748131e2d8396cb09632</guid>
<title>从零开始写一个微前端框架（渲染篇）</title>
<link>https://toutiao.io/k/1r35tnn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;自从微前端框架&lt;a href=&quot;https://github.com/micro-zoe/micro-app&quot;&gt;micro-app&lt;/a&gt;开源后，很多小伙伴都非常感兴趣，问我是如何实现的，但这并不是几句话可以说明白的。为了讲清楚其中的原理，我会从零开始实现一个简易的微前端框架，它的核心功能包括：渲染、JS沙箱、样式隔离、数据通信。由于内容太多，会根据功能分成四篇文章进行讲解，这是系列文章的第一篇：渲染篇。&lt;/p&gt;

&lt;p&gt;通过这些文章，你可以了解微前端框架的具体原理和实现方式，这在你以后使用微前端或者自己写一套微前端框架时会有很大的帮助。如果这篇文章对你有帮助，欢迎点赞留言。&lt;/p&gt;

&lt;h2&gt;相关推荐&lt;/h2&gt;

&lt;p&gt;micro-app源码地址：&lt;a href=&quot;https://github.com/micro-zoe/micro-app&quot;&gt;https://github.com/micro-zoe/micro-app&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;整体架构&lt;/h2&gt;

&lt;p&gt;和micro-app一样，我们的简易微前端框架设计思路是像使用iframe一样简单，而又可以避免iframe存在的问题，其使用方式如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img13.360buyimg.com/imagetools/jfs/t1/181724/1/15979/23894/60ffedfcEa74486b6/9cfeb02f4347357a.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最终效果也有点类似，整个微前端应用都被封装在自定义标签micro-app中，渲染后效果如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img11.360buyimg.com/imagetools/jfs/t1/187866/25/15336/129323/60ffc089E76d6416d/9fb1f6ee70499254.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;所以我们整体架构思路为：&lt;strong&gt;CustomElement + HTMLEntry&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;HTMLEntry就是以html文件作为入口地址进行渲染，入上图中的&lt;code&gt;http://localhost:3000/&lt;/code&gt;就是一个html地址。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;概念图：&lt;/strong&gt;
&lt;img src=&quot;https://img10.360buyimg.com/imagetools/jfs/t1/188133/39/15743/117766/61024cd2E5ed84b36/b816384088ba6ed1.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;前置工作&lt;/h2&gt;

&lt;p&gt;在正式开始之前，我们需要搭建一个开发环境，创建一个代码仓库&lt;code&gt;simple-micro-app&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;目录结构&lt;/strong&gt;
&lt;img src=&quot;https://img11.360buyimg.com/imagetools/jfs/t1/196336/1/15327/76954/6102650dE1f9d7850/3fe44809e029d4d5.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;代码仓库主要分为src主目录和examples案例目录，vue2为基座应用，react17为子应用，两个项目都是使用官方脚手架创建的，构建工具使用rollup。&lt;/p&gt;

&lt;p&gt;两个应用页面分别如下图：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;基座应用 -- vue2&lt;/strong&gt;
&lt;img src=&quot;https://img14.360buyimg.com/imagetools/jfs/t1/183486/38/17307/81178/6107bfb4E651ac3f8/37cfca6b3ca62cc1.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;子应用 -- react17&lt;/strong&gt;
&lt;img src=&quot;https://img12.360buyimg.com/imagetools/jfs/t1/183475/14/17257/107373/6107bfbaEdf0e0509/75b199e0e408040e.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在vue2项目中，配置&lt;code&gt;resolve.alias&lt;/code&gt;，将simple-micro-app指向src目录的index.js。&lt;/p&gt;

&lt;pre lang=&quot;js&quot;&gt;&lt;code&gt;// vue.config.js
...
chainWebpack: config =&amp;gt; {
    config.resolve.alias
      .set(&quot;simple-micro-app&quot;, path.join(__dirname, &#x27;../../src/index.js&#x27;))
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在react17的webpack-dev-server中配置静态资源支持跨域访问。&lt;/p&gt;

&lt;pre lang=&quot;js&quot;&gt;&lt;code&gt;// config/webpackDevServer.config.js
...
headers: {
  &#x27;Access-Control-Allow-Origin&#x27;: &#x27;*&#x27;,
},
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;正式开始&lt;/h2&gt;

&lt;p&gt;为了讲的更加明白，我们不会直接贴出已经完成的代码，而是从无到有，一步步实现整个过程，这样才能更加清晰，容易理解。&lt;/p&gt;

&lt;h3&gt;创建容器&lt;/h3&gt;

&lt;p&gt;微前端的渲染是将子应用的js、css等静态资源加载到基座应用中执行，所以基座应用和子应用本质是同一个页面。这不同于iframe，iframe则是创建一个新的窗口，由于每次加载都要初始化整个窗口信息，所以iframe的性能不高。&lt;/p&gt;

&lt;p&gt;如同每个前端框架在渲染时都要指定一个根元素，微前端渲染时也需要指定一个根元素作为容器，这个根元素可以是一个div或其它元素。&lt;/p&gt;

&lt;p&gt;这里我们使用的是通过customElements创建的自定义元素，因为它不仅提供一个元素容器，还自带了生命周期函数，我们可以在这些钩子函数中进行加载渲染等操作，从而简化步骤。&lt;/p&gt;

&lt;pre lang=&quot;js&quot;&gt;&lt;code&gt;// /src/element.js

// 自定义元素
class MyElement extends HTMLElement {
  // 声明需要监听的属性名，只有这些属性变化时才会触发attributeChangedCallback
  static get observedAttributes () {
    return [&#x27;name&#x27;, &#x27;url&#x27;]
  }

  constructor() {
    super();
  }

  connectedCallback() {
    // 元素被插入到DOM时执行，此时去加载子应用的静态资源并渲染
    console.log(&#x27;micro-app is connected&#x27;)
  }

  disconnectedCallback () {
    // 元素从DOM中删除时执行，此时进行一些卸载操作
    console.log(&#x27;micro-app has disconnected&#x27;)
  }

  attributeChangedCallback (attr, oldVal, newVal) {
    // 元素属性发生变化时执行，可以获取name、url等属性的值
    console.log(`attribute ${attrName}: ${newVal}`)
  }
}

/**
 * 注册元素
 * 注册后，就可以像普通元素一样使用micro-app，当micro-app元素被插入或删除DOM时即可触发相应的生命周期函数。
 */
window.customElements.define(&#x27;micro-app&#x27;, MyElement)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;micro-app&lt;/code&gt;元素可能存在重复定义的情况，所以我们加一层判断，并放入函数中。&lt;/p&gt;

&lt;pre lang=&quot;js&quot;&gt;&lt;code&gt;// /src/element.js

export function defineElement () {
  // 如果已经定义过，则忽略
  if (!window.customElements.get(&#x27;micro-app&#x27;)) {
    window.customElements.define(&#x27;micro-app&#x27;, MyElement)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;/src/index.js&lt;/code&gt;中定义默认对象&lt;code&gt;SimpleMicroApp&lt;/code&gt;，引入并执行&lt;code&gt;defineElement&lt;/code&gt;函数。&lt;/p&gt;

&lt;pre lang=&quot;js&quot;&gt;&lt;code&gt;// /src/index.js

import { defineElement } from &#x27;./element&#x27;

const SimpleMicroApp = {
  start () {
    defineElement()
  }
}

export default SimpleMicroApp
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;引入simple-micro-app&lt;/h3&gt;

&lt;p&gt;在vue2项目的main.js中引入simple-micro-app，执行start函数进行初始化。&lt;/p&gt;

&lt;pre lang=&quot;js&quot;&gt;&lt;code&gt;// vue2/src/main.js

import SimpleMicroApp from &#x27;simple-micro-app&#x27;

SimpleMicroApp.start()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就可以在vue2项目中的任何位置使用micro-app标签。&lt;/p&gt;

&lt;pre lang=&quot;html&quot;&gt;&lt;code&gt;&amp;lt;!-- page1.vue --&amp;gt;
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;micro-app name=&#x27;app&#x27; url=&#x27;http://localhost:3001/&#x27;&amp;gt;&amp;lt;/micro-app&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;插入micro-app标签后，就可以看到控制台打印的钩子信息。
&lt;img src=&quot;https://img14.360buyimg.com/imagetools/jfs/t1/185099/11/16261/81332/610297a1Ede21e543/999043868783cbec.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以上我们就完成了容器元素的初始化，子应用的所有元素都会放入到这个容器中。接下来我们就需要完成子应用的静态资源加载及渲染。&lt;/p&gt;

&lt;h3&gt;创建微应用实例&lt;/h3&gt;

&lt;p&gt;很显然，初始化的操作要放在&lt;code&gt;connectedCallback&lt;/code&gt; 中执行。我们声明一个类，它的每一个实例都对应一个微应用，用于控制微应用的资源加载、渲染、卸载等。&lt;/p&gt;

&lt;pre lang=&quot;js&quot;&gt;&lt;code&gt;// /src/app.js

// 创建微应用
export default class CreateApp {
  constructor () {}

  status = &#x27;created&#x27; // 组件状态，包括 created/loading/mount/unmount

  // 存放应用的静态资源
  source = { 
    links: new Map(), // link元素对应的静态资源
    scripts: new Map(), // script元素对应的静态资源
  }

  // 资源加载完时执行
  onLoad () {}

  /**
   * 资源加载完成后进行渲染
   */
  mount () {}

  /**
   * 卸载应用
   * 执行关闭沙箱，清空缓存等操作
   */
  unmount () {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在&lt;code&gt;connectedCallback&lt;/code&gt;函数中初始化实例，将name、url及元素自身作为参数传入，在&lt;code&gt;CreateApp&lt;/code&gt;的constructor中记录这些值，并根据url地址请求html。&lt;/p&gt;

&lt;pre lang=&quot;js&quot;&gt;&lt;code&gt;// /src/element.js
import CreateApp, { appInstanceMap } from &#x27;./app&#x27;

...
connectedCallback () {
  // 创建微应用实例
  const app = new CreateApp({
    name: this.name,
    url: this.url,
    container: this,
  })

  // 记入缓存，用于后续功能
  appInstanceMap.set(this.name, app)
}

attributeChangedCallback (attrName, oldVal, newVal) {
  // 分别记录name及url的值
  if (attrName === &#x27;name&#x27; &amp;amp;&amp;amp; !this.name &amp;amp;&amp;amp; newVal) {
    this.name = newVal
  } else if (attrName === &#x27;url&#x27; &amp;amp;&amp;amp; !this.url &amp;amp;&amp;amp; newVal) {
    this.url = newVal
  }
}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在初始化实例时，根据传入的参数请求静态资源。&lt;/p&gt;

&lt;pre lang=&quot;js&quot;&gt;&lt;code&gt;// /src/app.js
import loadHtml from &#x27;./source&#x27;

// 创建微应用
export default class CreateApp {
  constructor ({ name, url, container }) {
    this.name = name // 应用名称
    this.url = url  // url地址
    this.container = container // micro-app元素
    this.status = &#x27;loading&#x27;
    loadHtml(this)
  }
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;请求html&lt;/h3&gt;

&lt;p&gt;我们使用fetch请求静态资源，好处是浏览器自带且支持promise，但这也要求子应用的静态资源支持跨域访问。&lt;/p&gt;

&lt;pre lang=&quot;js&quot;&gt;&lt;code&gt;// src/source.js

export default function loadHtml (app) {
  fetch(app.url).then((res) =&amp;gt; {
    return res.text()
  }).then((html) =&amp;gt; {
    console.log(&#x27;html:&#x27;, html)
  }).catch((e) =&amp;gt; {
    console.error(&#x27;加载html出错&#x27;, e)
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为请求js、css等都需要使用到fetch，所以我们将它提取出来作为公共方法。&lt;/p&gt;

&lt;pre lang=&quot;js&quot;&gt;&lt;code&gt;// /src/utils.js

/**
 * 获取静态资源
 * @param {string} url 静态资源地址
 */
export function fetchSource (url) {
  return fetch(url).then((res) =&amp;gt; {
    return res.text()
  })
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新使用封装后的方法，并对获取到到html进行处理。&lt;/p&gt;

&lt;pre lang=&quot;js&quot;&gt;&lt;code&gt;// src/source.js
import { fetchSource } from &#x27;./utils&#x27;

export default function loadHtml (app) {
  fetchSource(app.url).then((html) =&amp;gt; {
    html = html
      .replace(/&amp;lt;head[^&amp;gt;]*&amp;gt;[\s\S]*?&amp;lt;\/head&amp;gt;/i, (match) =&amp;gt; {
        // 将head标签替换为micro-app-head，因为web页面只允许有一个head标签
        return match
          .replace(/&amp;lt;head/i, &#x27;&amp;lt;micro-app-head&#x27;)
          .replace(/&amp;lt;\/head&amp;gt;/i, &#x27;&amp;lt;/micro-app-head&amp;gt;&#x27;)
      })
      .replace(/&amp;lt;body[^&amp;gt;]*&amp;gt;[\s\S]*?&amp;lt;\/body&amp;gt;/i, (match) =&amp;gt; {
        // 将body标签替换为micro-app-body，防止与基座应用的body标签重复导致的问题。
        return match
          .replace(/&amp;lt;body/i, &#x27;&amp;lt;micro-app-body&#x27;)
          .replace(/&amp;lt;\/body&amp;gt;/i, &#x27;&amp;lt;/micro-app-body&amp;gt;&#x27;)
      })

    // 将html字符串转化为DOM结构
    const htmlDom = document.createElement(&#x27;div&#x27;)
    htmlDom.innerHTML = html
    console.log(&#x27;html:&#x27;, htmlDom)

    // 进一步提取和处理js、css等静态资源
    extractSourceDom(htmlDom, app)
  }).catch((e) =&amp;gt; {
    console.error(&#x27;加载html出错&#x27;, e)
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;html格式化后，我们就可以得到一个DOM结构。从下图可以看到，这个DOM结构包含link、style、script等标签，接下来就需要对这个DOM做进一步处理。
&lt;img src=&quot;https://img10.360buyimg.com/imagetools/jfs/t1/191546/8/15866/369938/6103a5c8E777fffb0/ca845992645ebea4.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;提取js、css等静态资源地址&lt;/h3&gt;

&lt;p&gt;我们在&lt;code&gt;extractSourceDom&lt;/code&gt;方法中循环递归处理每一个DOM节点，查询到所有link、style、script标签，提取静态资源地址并格式化标签。&lt;/p&gt;

&lt;pre lang=&quot;js&quot;&gt;&lt;code&gt;// src/source.js

/**
 * 递归处理每一个子元素
 * @param parent 父元素
 * @param app 应用实例
 */
function extractSourceDom(parent, app) {
  const children = Array.from(parent.children)

  // 递归每一个子元素
  children.length &amp;amp;&amp;amp; children.forEach((child) =&amp;gt; {
    extractSourceDom(child, app)
  })

  for (const dom of children) {
    if (dom instanceof HTMLLinkElement) {
      // 提取css地址
      const href = dom.getAttribute(&#x27;href&#x27;)
      if (dom.getAttribute(&#x27;rel&#x27;) === &#x27;stylesheet&#x27; &amp;amp;&amp;amp; href) {
        // 计入source缓存中
        app.source.links.set(href, {
          code: &#x27;&#x27;, // 代码内容
        })
      }
      // 删除原有元素
      parent.removeChild(dom)
    } else if (dom instanceof HTMLScriptElement) {
      // 并提取js地址
      const src = dom.getAttribute(&#x27;src&#x27;)
      if (src) { // 远程script
        app.source.scripts.set(src, {
          code: &#x27;&#x27;, // 代码内容
          isExternal: true, // 是否远程script
        })
      } else if (dom.textContent) { // 内联script
        const nonceStr = Math.random().toString(36).substr(2, 15)
        app.source.scripts.set(nonceStr, {
          code: dom.textContent, // 代码内容
          isExternal: false, // 是否远程script
        })
      }

      parent.removeChild(dom)
    } else if (dom instanceof HTMLStyleElement) {
      // 进行样式隔离
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;请求静态资源&lt;/h3&gt;

&lt;p&gt;上面已经拿到了html中的css、js等静态资源的地址，接下来就是请求这些地址，拿到资源的内容。&lt;/p&gt;

&lt;p&gt;接着完善&lt;code&gt;loadHtml&lt;/code&gt;，在&lt;code&gt;extractSourceDom&lt;/code&gt;下面添加请求资源的方法。&lt;/p&gt;

&lt;pre lang=&quot;js&quot;&gt;&lt;code&gt;// src/source.js
...
export default function loadHtml (app) {
  ...
  // 进一步提取和处理js、css等静态资源
  extractSourceDom(htmlDom, app)

  // 获取micro-app-head元素
  const microAppHead = htmlDom.querySelector(&#x27;micro-app-head&#x27;)
  // 如果有远程css资源，则通过fetch请求
  if (app.source.links.size) {
    fetchLinksFromHtml(app, microAppHead, htmlDom)
  } else {
    app.onLoad(htmlDom)
  }

  // 如果有远程js资源，则通过fetch请求
  if (app.source.scripts.size) {
    fetchScriptsFromHtml(app, htmlDom)
  } else {
    app.onLoad(htmlDom)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;fetchLinksFromHtml&lt;/code&gt;和&lt;code&gt;fetchScriptsFromHtml&lt;/code&gt;分别请求css和js资源，请求资源后的处理方式不同，css资源会转化为style标签插入DOM中，而js不会立即执行，我们会在应用的mount方法中执行js。&lt;/p&gt;

&lt;p&gt;两个方法的具体实现方式如下：&lt;/p&gt;

&lt;pre lang=&quot;js&quot;&gt;&lt;code&gt;// src/source.js
/**
 * 获取link远程资源
 * @param app 应用实例
 * @param microAppHead micro-app-head
 * @param htmlDom html DOM结构
 */
 export function fetchLinksFromHtml (app, microAppHead, htmlDom) {
  const linkEntries = Array.from(app.source.links.entries())
  // 通过fetch请求所有css资源
  const fetchLinkPromise = []
  for (const [url] of linkEntries) {
    fetchLinkPromise.push(fetchSource(url))
  }

  Promise.all(fetchLinkPromise).then((res) =&amp;gt; {
    for (let i = 0; i &amp;lt; res.length; i++) {
      const code = res[i]
      // 拿到css资源后放入style元素并插入到micro-app-head中
      const link2Style = document.createElement(&#x27;style&#x27;)
      link2Style.textContent = code
      microAppHead.appendChild(link2Style)

      // 将代码放入缓存，再次渲染时可以从缓存中获取
      linkEntries[i][1].code = code
    }

    // 处理完成后执行onLoad方法
    app.onLoad(htmlDom)
  }).catch((e) =&amp;gt; {
    console.error(&#x27;加载css出错&#x27;, e)
  })
}

/**
 * 获取js远程资源
 * @param app 应用实例
 * @param htmlDom html DOM结构
 */
 export function fetchScriptsFromHtml (app, htmlDom) {
  const scriptEntries = Array.from(app.source.scripts.entries())
  // 通过fetch请求所有js资源
  const fetchScriptPromise = []
  for (const [url, info] of scriptEntries) {
    // 如果是内联script，则不需要请求资源
    fetchScriptPromise.push(info.code ? Promise.resolve(info.code) :  fetchSource(url))
  }

  Promise.all(fetchScriptPromise).then((res) =&amp;gt; {
    for (let i = 0; i &amp;lt; res.length; i++) {
      const code = res[i]
      // 将代码放入缓存，再次渲染时可以从缓存中获取
      scriptEntries[i][1].code = code
    }

    // 处理完成后执行onLoad方法
    app.onLoad(htmlDom)
  }).catch((e) =&amp;gt; {
    console.error(&#x27;加载js出错&#x27;, e)
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面可以看到，css和js加载完成后都执行了&lt;code&gt;onLoad&lt;/code&gt;方法，所以&lt;code&gt;onLoad&lt;/code&gt;方法被执行了两次，接下来我们就要完善&lt;code&gt;onLoad&lt;/code&gt;方法并渲染微应用。&lt;/p&gt;

&lt;h3&gt;渲染&lt;/h3&gt;

&lt;p&gt;因为&lt;code&gt;onLoad&lt;/code&gt;被执行了两次，所以我们进行标记，当第二次执行时说明所有资源都加载完成，然后进行渲染操作。&lt;/p&gt;

&lt;pre lang=&quot;js&quot;&gt;&lt;code&gt;// /src/app.js

// 创建微应用
export default class CreateApp {
  ...
  // 资源加载完时执行
  onLoad (htmlDom) {
    this.loadCount = this.loadCount ? this.loadCount + 1 : 1
    // 第二次执行且组件未卸载时执行渲染
    if (this.loadCount === 2 &amp;amp;&amp;amp; this.status !== &#x27;unmount&#x27;) {
      // 记录DOM结构用于后续操作
      this.source.html = htmlDom
      // 执行mount方法
      this.mount()
    }
  }
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;mount&lt;/code&gt;方法中将DOM结构插入文档中，然后执行js文件进行渲染操作，此时微应用即可完成基本的渲染。&lt;/p&gt;

&lt;pre lang=&quot;js&quot;&gt;&lt;code&gt;// /src/app.js

// 创建微应用
export default class CreateApp {
  ...
  /**
   * 资源加载完成后进行渲染
   */
  mount () {
    // 克隆DOM节点
    const cloneHtml = this.source.html.cloneNode(true)
    // 创建一个fragment节点作为模版，这样不会产生冗余的元素
    const fragment = document.createDocumentFragment()
    Array.from(cloneHtml.childNodes).forEach((node) =&amp;gt; {
      fragment.appendChild(node)
    })

    // 将格式化后的DOM结构插入到容器中
    this.container.appendChild(fragment)

    // 执行js
    this.source.scripts.forEach((info) =&amp;gt; {
      (0, eval)(info.code)
    })

    // 标记应用为已渲染
    this.status = &#x27;mounted&#x27;
  }
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上步骤完成了微前端的基本渲染操作，我们看一下效果。&lt;/p&gt;

&lt;h3&gt;开始使用&lt;/h3&gt;

&lt;p&gt;我们在基座应用下面嵌入微前端：&lt;/p&gt;

&lt;pre lang=&quot;html&quot;&gt;&lt;code&gt;&amp;lt;!-- vue2/src/pages/page1.vue --&amp;gt;
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;img alt=&quot;Vue logo&quot; src=&quot;../assets/logo.png&quot;&amp;gt;
    &amp;lt;HelloWorld :msg=&quot;&#x27;基座应用vue@&#x27; + version&quot; /&amp;gt;
    &amp;lt;!-- 👇嵌入微前端 --&amp;gt;
    &amp;lt;micro-app name=&#x27;app&#x27; url=&#x27;http://localhost:3001/&#x27;&amp;gt;&amp;lt;/micro-app&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终得到的效果如下：
&lt;img src=&quot;https://img13.360buyimg.com/imagetools/jfs/t1/185669/20/17155/175504/6107c08dEa8fb8327/0aaed694618d387e.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可见react17已经正常嵌入运行了。&lt;/p&gt;

&lt;p&gt;我们给子应用react17添加一个懒加载页面&lt;code&gt;page2&lt;/code&gt;，验证一下多页面应用是否可以正常运行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img12.360buyimg.com/imagetools/jfs/t1/182096/10/17439/269998/6107c866E0db7a485/f3ccdbfa15178fe9.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;page2&lt;/code&gt;的内容也非常简单，只是一段标题：
&lt;img src=&quot;https://img14.360buyimg.com/imagetools/jfs/t1/182410/34/17370/31568/6107c8b0E5eacf97e/a1669c5dd48946f7.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在页面上添加一个按钮，点击即可跳转page2。
&lt;img src=&quot;https://img10.360buyimg.com/imagetools/jfs/t1/185081/15/17251/111042/6107c97dE0a545e05/4df4b4ac364d4cdf.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;点击按钮，得到的效果如下：
&lt;img src=&quot;https://img10.360buyimg.com/imagetools/jfs/t1/194701/15/15808/110041/6107c9e5E64b542ea/05047937cf87a814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;正常渲染！🎉🎉&lt;/p&gt;

&lt;p&gt;一个简易的微前端框架就完成了，当然此时它是非常基础的，没有JS沙箱和样式隔离。&lt;/p&gt;

&lt;p&gt;关于JS沙箱和样式隔离我们会单独做一篇文章分享，但是此时我们还有一件事情需要做 - 卸载应用。&lt;/p&gt;

&lt;h3&gt;卸载&lt;/h3&gt;

&lt;p&gt;当micro-app元素被删除时会自动执行生命周期函数&lt;code&gt;disconnectedCallback&lt;/code&gt;，我们在此处执行卸载相关操作。&lt;/p&gt;

&lt;pre lang=&quot;js&quot;&gt;&lt;code&gt;// /src/element.js

class MyElement extends HTMLElement {
  ...
  disconnectedCallback () {
    // 获取应用实例
    const app = appInstanceMap.get(this.name)
    // 如果有属性destory，则完全卸载应用包括缓存的文件
    app.unmount(this.hasAttribute(&#x27;destory&#x27;))
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来完善应用的&lt;code&gt;unmount&lt;/code&gt;方法：&lt;/p&gt;

&lt;pre lang=&quot;js&quot;&gt;&lt;code&gt;// /src/app.js

export default class CreateApp {
  ...
  /**
   * 卸载应用
   * @param destory 是否完全销毁，删除缓存资源
   */
  unmount (destory) {
    // 更新状态
    this.status = &#x27;unmount&#x27;
    // 清空容器
    this.container = null
    // destory为true，则删除应用
    if (destory) {
      appInstanceMap.delete(this.name)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当destory为true时，删除应用的实例，此时所有静态资源失去了引用，自动被浏览器回收。&lt;/p&gt;

&lt;p&gt;在基座应用vue2中添加一个按钮，切换子应用的显示/隐藏状态，验证多次渲染和卸载是否正常运行。&lt;/p&gt;

&lt;p&gt;效果如下：
&lt;img src=&quot;https://cangdu.org/img/simple-micro-app-1-1.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一且运行正常！🎉&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;到此微前端渲染篇的文章就结束了，我们完成了微前端的渲染和卸载功能，当然它的功能是非常简单的，只是叙述了微前端的基本实现思路。接下来我们会完成JS沙箱、样式隔离、数据通讯等功能，如果你能耐下心来读一遍，会对你了解微前端有很大帮助。&lt;/p&gt;

&lt;h2&gt;代码地址：&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/bailicangdu/simple-micro-app&quot;&gt;https://github.com/bailicangdu/simple-micro-app&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>631fe07f4b3ab77e4ed528c34b1a3762</guid>
<title>高效学习，我的最佳实践</title>
<link>https://toutiao.io/k/7janhds</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近奥运会，中国还是依然 NB，尤其前两天的男子百米半决赛、决赛，彻底被苏神点燃了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说是&lt;span&gt;亚洲奇迹&lt;/span&gt;，一点也不为过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看比赛，有好的，也有气人的，比如裁判，裁判适当照顾东道主也能忍了，但是有时候太过分了，直接选择性眼瞎。&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KQAV5MLKVXRuUqXXeib6viaABo7NibSLH1jbyx44SOFUeg0VcjuHFdwZ21ZaTYrI5mhE0wx2m3GJXXrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;690&quot;/&gt;说到选择性眼瞎，我想的一个事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;咱们干程序员的，经常需要应用、研究一些开源组件。研究开源组件，就少不了去看资料、看源代码。在看代码、学习的过程中，咱们可不能像那些眼瞎的裁判，咱们需要高效的学习：看清全局、主要脉络、关键细节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章就和大家说说我自己高效学习的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对我而言，做好这件事的关键就在于问自己七个问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;问题1. 组件解决了什么问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问这个问题的目的是明确组件的问题域，任何组件的出现都是为了解决某类问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在职业生涯里，遇到的技术问题其实是有限的。面对这些有限的问题，我们熟悉的组件越多，解决问题的思路和办法就越多。当你对某种技术问题，有着比别人更多的思路和办法，那自然而然，你的技术话语权就会越大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以我曾经深入研究过的 druid（阿里的开源数据库连接池）组件为例：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;druid 要解决的问题本质其实是如何降低应用和中间件交互所消耗的时间成本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道了 druid 要解决的问题，我们就等于知道了它的核心主题。druid 的主要技术思路，全部都是围绕着这个核心主题来实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，druid 本身的 LRU 策略、对一些关键对象的缓存、竞争资源的高效率利用……都是围绕着这个核心问题来设计和落地的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时，我们明确了 druid 要解决的问题后，如果我们对现在 jedis 这套东西不满意，是不是就可以利用 druid 的技术思路，重新设计和实现一套新组件，去替代 jedis，以便降低和 redis 交互的时间成本呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;问题2. 组件有什么优点&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;确认了组件需要解决的问题，只是第一步。一套开源组件，往往项目都比较庞大。所以，就得想个办法分而克之，分出各个具体的知识点去学习。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而这些知识点，往往和官方文档宣传的组件优点可以对上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，druid 的官方文档是这么说的：&lt;img data-ratio=&quot;1.3037383177570094&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KQAV5MLKVXRuUqXXeib6viaABu9jm7lHNp4Yb9ho7icdAPZj2PIZG7XN2t8kAklHczITI9hBpkSn5pVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;428&quot;/&gt;从上面这幅图，就可以看出来，druid 有如下几个特点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;能被监控&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;容易扩展&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;性能优秀&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;稳定性好&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;安全&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;运行期问题容易排查&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些就是我们要去学习的各个知识点。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;问题3. 组件的主干和分支都是哪些&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道了组件的优点，就等同于知道了需要学习的知识点。可是，知识点如果多而杂，就需要确认好哪些学哪些不学？哪些先学哪些后学？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，组件的主干和分支就需要分解出来，以便定出学习计划。而划分出主干和分支，就需要综合我们前面说的组件要解决的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过前面的学习，我们知道 druid 解决的是降低中间件的时间成本，也知道了它的特点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;能被监控&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;容易扩展&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;性能优秀&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;稳定性好&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;安全&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;运行期问题容易排查&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，我们的学习计划就是：先学习 druid 是如何实现高性能的；高性能后，如果我们研究 druid 是为了后续在工作中应用，那么，能被监控这个特点就是下一个要学习的知识点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，这一问，是为了拟定学习计划而问。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;问题4. 组件的这些优点是如何实现的&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上个问题之后，我们就可以分步骤的进行学习了。学的怎么样，就需要通过这个问题，来考察自己是否真的学懂了这些知识点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到 druid 上，让人满意的答案就是，我们能用自己的话去总结出每个知识点的技术实现。比如：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;问：druid 的监控是如何实现的？&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：druid 通过自己实现 JDBC API 自身提供的 PooledConnection、Connection、Statement、ResultSet接口，获得了可以在这些接口的关键方法中植入统计的能力。统计的数据会定期采样后存储在某些命名叫做 xxxStat 的对象里，供后面展示使用。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;问：druid 是如何实现扩展的？&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：能扩展的实现方式是第三方实现 druid 提供的一个 Filter 接口后，再被配置到 druid 的配置文件里。这样就会在 DruidDataSource 初始化的时候，去读取并初始化这些实现了 Filter 接口的实例。初始化后的 Filter 会在后面 druid 从创建数据库连接到执行 SQL 语句再到释放连接这一系列步骤后，被不断的链式执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就这样，分知识点回答出让自己满意的答案，就等同于考核了自己对每个知识点学习的质量，如果回答不满意，就再去查漏补缺即可。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;问题5. 组件的系统设计思路是什么&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们学习了各个零散的知识点之后并不够，因为学习一套开源组件，原理是基础，系统设计则是骨架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;明白了技术点，只是对当编码高手有用，但是当你自己设计组件的时候，你的底气在哪里呢？答案就在这些你看过的开源组件的系统设计思路上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，把知识点融合起来形成一个整体，再去推断出系统的设计思路，对我们成为一名优秀的架构师，是有非常大的帮助的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如,通过各个知识点的深入学习，融会贯通后，我认为 druid 的设计思路如下：&lt;img data-ratio=&quot;0.8297665369649806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KQAV5MLKVXRuUqXXeib6viaABrUN9taW4Fv6ibGL9ic1XhNTh3EIWh78JavbcQAN2DIouekKS5yibS5MQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1028&quot;/&gt;如果以后遇到为公司底层构造一套池化中间件对象的需求时，这种设计思路自然就成了我设计的重要模板之一。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;问题6. 组件的缺点是什么&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么会问组件的缺点？因为在我如此了解了一套组件之后，却还是免不了误用和踩坑，这其中最严重的就是，生产环境在组件出现问题之后，我们却没有紧急预案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种现象的原因就是没有去深入思考过一套技术的利弊。问组件的缺点，就会迫使我们去深入思考利弊，从而在以后不管是应用组件，又或者是去根据学习到的知识自己实践，都能成竹在胸，从容以对。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到 druid 身上，当我们去读它源码的时候，思考一下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;durid 的这些实现真的就是完美的吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那肯定不是， 比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;druid 的采样功能很多时候我们并不需要，但是由于 druid 的实现是写死在实现的关键代码里的，所以无法自由的对其进行插拔。这时候，就要注意，采样可能造成的内存占用问题。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;druid 是对 JDBC API 做了层层封装的，在这些封装中 druid 又添加了很多自己的实现。但是，这些实现很难避免bug，然而由于有这些封装，就会导致 Bug 很难查，又或者很难自己改。这时候，就需要在测试环境，把 druid 的日志级别调成 DEBUG 级别，然后仔细观察日志，看看是否有什么不可知的风险。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，这一问，是为了深度思考，让我们在任何新技术的学习和实战时，都能成为最稳定的那个仔。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管以后我们模仿还是应用 druid，就能提前预测到风险，从而重点监控，提前准备预案。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;问题7. 和同类别的组件之间有什么区别&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当学习完了组件，知道了组件的优缺点，理解了组件的运行原理，明白了组件的设计思路之后，一切就完整了吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对不起，还不够。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为我们还缺乏一种东西，就是学习的拓展，即学习的广度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学习组件，我们除了知道它要解决的问题域外，还需要知道它在同类组件中的地位。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么？因为以后我们去任何一个稍微成规模的公司后，需要面临一个问题，内部的竞争。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，我们写了一套消息治理中间件。如果想提升自己的技术话语权，就需要在全公司，和同类产品竞争。竞争胜出了，自己的职业生涯就有了巨大发展的可能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到 druid 上，在SpringBoot2.0时代，druid 出现了巨大的竞争对手——HiKariCP。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 HiKariCP 之所以能胜出，是因为它排除了 druid 使用的公平锁，使得性能提升了大约 &lt;span&gt;70%&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 druid 和 HiKariCP 的比较和学习，我们就能更加深入的理解高并发，能更有效率的去压榨出系统的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 druid 和 HiKariCP 作者之间的互相较量，我们还能明白如何去更好的对比竞品，去展现最为关键的数据指标，一举赢得胜利。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上列举的七个问题，是我为了解决高效高质研究开源组件，得到的最佳实践。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结一下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;先通过问组件解决了什么问题，去确定自己的学习目的和思考边界。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再问组件有什么优点，以及主干和分支是哪些，去拟定出学习计划。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再后，通过问组件的优点是如何实现的，去考察自己的学习质量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后，通过问组件的系统设计思路是什么，让自己讲学到的各种独立的知识融汇贯通，打造成体系。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后，通过问组件的缺点是什么以及和竞品的区别去迫使自己在学习之外，再行深度思考和广度思考，对学习进行查漏补缺以及进一步提升学习质量，打造出更为突出的知识体系。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IT这行业是需要不断学习的，而高效高质量学习，是让我们的职业生涯走的更稳更顺的关键所在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;希望这篇文章对大家有帮助，看完如果觉得有收获，请帮忙转发、随手点个在看，&lt;span&gt;你的支持对我很重要&lt;/span&gt;。&lt;/p&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你好，我是四猿外。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一家上市公司的技术总监，管理的技术团队一百余人。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我从一名非计算机专业的毕业生，转行到程序员，一路打拼，一路成长。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我会通过公众号，&lt;br/&gt;把自己的成长故事写成文章，&lt;br/&gt;把枯燥的技术文章写成故事。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我建了一个读者交流群，里面大部分是程序员，一起聊技术、工作、八卦。欢迎加我微信，拉你入群。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9852216748768473&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6nbNnibOq5KQibCDibpTo0kqofPehQvDDibibcb3bQUELdY3Knsl4r0RcgsV9l4icr3icmZQfaBXtSFNTxmdQlAZT1OQg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;609&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>