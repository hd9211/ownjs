<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b7660163c6eb06436b29dba6fb2b3ee1</guid>
<title>字节一面：Redis 主节点宕机，如何处理？</title>
<link>https://toutiao.io/k/0xsbfqz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是Tom哥~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天跟大家聊下，如果Redis某个节点宕机了，要怎么处理？&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8604651162790697&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9Yshwd7Yq23XicTWiaQ7eFZAaiaGPDSF1yHFmYjTUgvLhn4EgXEwut1noagJoCtAiclLficN0PHxmuNq1zhSjA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;688&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，Redis集群一般采用主从模式，主节点负责写，从节点负责读。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;从节点故障&lt;/strong&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从节点主要提供读服务，为了分摊主服务器压力，一般会有多个从节点。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.873972602739726&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9Yshwd7Yq23XicTWiaQ7eFZAaiaGPDic1dicRib66UCJPV9cxoHqCeH08vbJOmrMSSOHrg8PrKv9Zk0Yagl1Hqw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;730&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是从节点故障，不算什么大问题，客户端把该故障节点屏蔽即可，仍可访问其他的主、从节点满足正常的业务功能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;主节点故障&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是主节点宕机了，那就有点麻烦了，毕竟写操作是在主节点上，无法替代。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7975&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9Yshwd7Yq23XicTWiaQ7eFZAaiaGPDibMiayxqNic3ImxgQKAJT96r2mDDgTcdFK3OVwmfeBON1ctul0rveEZfw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候，我们要干一件事，从所有的&lt;code&gt;从库&lt;/code&gt;节点中挑选一台做为主节点。这里要介绍下Sentienl 哨兵机制了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;哨兵机制分为三个阶段：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、监控。哨兵进程会周期给所有的主库、从库发送 PING 命令，检测机器是否处于服务状态。如果没有在设置时间内收到回复，则判定为下线。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、选主。主要是看各个节点的打分情况，打分规则分为 &lt;code&gt;从库优先级&lt;/code&gt;、&lt;code&gt;从库复制进度&lt;/code&gt;、&lt;code&gt;从库ID号&lt;/code&gt;。只要有一轮，某个从库得分最高，则选举它为主库。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从库优先级，主要是考虑到不同的机器可能配置不一样，配置高的机器，优先级高一些，通过&lt;code&gt;slave-priority&lt;/code&gt; 来配置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从库复制进度，主要是看&lt;code&gt;slave_repl_offset&lt;/code&gt; 的值大小，值越大表示已经同步的数据越多，得分越高。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从库ID号，每个Redis 实例启动时，都会生成一个 ID，在优先级和复制进度相同的条件下，ID号最小的从库分数最高，会被选为新主库。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、通知。把选举后的新主库发送给所有节点，让所有的从库执行 &lt;code&gt;replicaof&lt;/code&gt; 命令，和新 master建立主从关系、数据同步复制。另外，也会把最新的主库信息同步给客户端。这样后续的写请求会打到新的 主节点上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我们知道网络存在不稳定性，所以会不会有什么特殊问题？我们继续往下看&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;网络抖动，引发误判&lt;/strong&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;问题描述：&lt;/strong&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;哨兵节点监控到主节点超时未响应，主节点不一定是真的宕机。可能是之间的网络拥堵，或者主库自身压力过大，导致响应超时。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何避免这种情况？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入哨兵集群，多个哨兵实例一起判断，降低误判率。判断标准就是，假如 n 个哨兵实例，至少有 n/2+1 个判定一致，才可以定论。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的误判只会用在主库，从库只是负责读，如果监测到未响应，直接标记为 ”下线“，并不需要集群投票验证其真实性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是主库超时未响应，则不能这么草率决定，毕竟后面的选主和通知都是一笔不小的开销，所以，标记主库”下线“，一定要慎之又慎。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那么，哨兵集群集如何投票，确认主节点是否真的下线呢？在深入这个问题之前，我们先来了解下哨兵集群&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;哨兵集群如何构建？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;首先，在redis-sentinel 的conf文件里添加两个配置项：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;sentinel monitor &amp;lt;master-name&amp;gt; &amp;lt;ip&amp;gt; &amp;lt;redis-port&amp;gt; &amp;lt;quorum&amp;gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;master-name：对某个master+slave 组合的一个区分标识（一套sentinel是可以监听多套master+slave这样的组合）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ip 和 port：就是master节点的 ip 和 端口号。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;quorum：进行客观下线的一个依据，意思是至少有 quorum 个sentinel主观的认为这个master有故障，才会对这个master下线或故障转移。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;sentinel down-after-milliseconds &amp;lt;master-name&amp;gt;  &amp;lt;timeout&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;timeout：毫秒值，如果这台sentinel超过timeout时间无法连通master或slave（slave不需要客观下线，因为不需要故障转移），就会主观认为该master已经下线（实际下线需要客观下线的判断通过才会真正下线）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8715083798882681&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9Yshwd7Yq23XicTWiaQ7eFZAaiaGPDgZP00p7Qb2awYRRyEm65a8CrafZWDOLF3xrA4cJbEHd03aO5Ode04A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1074&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;借助发布/订阅组建哨兵集群&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道Redis 有&lt;code&gt;pub/sub&lt;/code&gt; 机制，当一个哨兵与主库建立连接，可以在主库上发布自己的消息（ip、port），当然也可以在主库上订阅其他哨兵发布的消息。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;有点类似MQ的topic味道，大家基于同一个topic完成数据交换。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当所有的哨兵都完成上述动作，哨兵集群也就组建完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么要组建哨兵集群呢？因为后面的选主需要有一个leader带头操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;哨兵如何知道所有从库地址呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道每个哨兵实例的配置参数里有配置主库的ip和port，而每个主库要同步数据给从库，自然有挂载的所有从库信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，哨兵实例只需向主库发送&lt;code&gt;INFO&lt;/code&gt;命令即可获取到所需要的信息，然后哨兵实例在依次与从库建立连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;至此，一个哨兵实例便可以收集到整个Redis 集群的数据，包含三块：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;所有的哨兵节点ip、port&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主节点ip、port&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主节点挂载的所有从节点的 ip、port&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他哨兵实例也是一样道理，这里就不在赘述了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong/&gt;&lt;strong&gt;哨兵是个集群，选主需要有个带头大哥&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个哨兵实例监控到主库”主观下线“后，给其他实例发送 &lt;code&gt;is-master-down-by-addr&lt;/code&gt; 命令，其他哨兵实例根据自己与主库的连接情况，做出 Y 或 N的回复。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当这个哨兵收集到了超过 quorum 配置项的 Y 回复后，就会标记主库”客观下线“。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面，就要进入&lt;code&gt;选主&lt;/code&gt;阶段了。正所谓”一山不容二虎“，那么由哪个哨兵实例来执行选主操作呢？&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.0691244239631337&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9Yshwd7Yq23XicTWiaQ7eFZAaiaGPD7fDPMoCe3HiazmQ83WtaiaXXDflqUyIQgKicz8ic9qFIwfvqfHF2cqbIYw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;217&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是公平点，采用民主投票。先在 哨兵集群中选出一个带头大哥，由它代表大家执行后续操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何选哨兵Leader？&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9Yshwd7Yq23XicTWiaQ7eFZAaiaGPDLRKBgZ9OEldwrwyv1nNVNK3b506hib38zaTSzUmebPhCQBVOqdgKsww/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图画了个流程实例，三个哨兵节点在 t1~t6 不同时刻点的投票情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个哨兵实例收到超过 设置的&lt;code&gt;quorum&lt;/code&gt; 票Y后，它会成为新的Leader。然后由它（哨兵S3）负责后面的从库选主，通知从库与新主库建立关系并同步数据，通知客户端访问新主库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果本轮没有选出Leader节点，等哨兵故障转移超时时间的 2 倍时间后，重新发起新一轮选举。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了保证哨兵Leader选举的顺利进行，除了对网络质量有要求外，最好配置奇数个哨兵节点且最好三个以上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;哨兵也是实例，如果挂了怎么办？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哨兵主要是用来监控Redis集群的健康状况，本身并不提供服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个哨兵实例挂掉后，会影响到集群的监测。为了降低影响，我们引入哨兵集群，降低单点风险，由哨兵集群保障Redis主从集群的健康。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;举个例子：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哨兵集群配置了三个实例，&lt;code&gt;quorum&lt;/code&gt; 配置值为2。当一个哨兵实例宕机后，其余两个哨兵实例依然可以完成选举，只是可能存在一定风险而已。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;哨兵集群完成了主从切换，客户端如何感知？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道Redis有&lt;code&gt;pub/sub&lt;/code&gt;机制，为了便于外部知道当前的切换进度，哨兵提供了多个订阅频道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中就有一个新主库切换频道，（switch-master）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SUBSCRIBE +switch-master&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;订阅对应频道，可以获得切换后的新主库ip、port，并与之建立连接，继续享受Redis服务。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于我：Tom哥，前阿里P7技术专家，出过专利，多年大厂实战经验。欢迎关注，我会持续输出更多经典原创文章，为你大厂助力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;欢迎小伙伴找Tom哥唠嗑聊天， 技术交流，围观朋友圈，人生打怪不再寂寞。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100003916&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.069090909090909&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwcdJhGaQRdAk0VWLIAIU548z3Izf6mwqwwUX9X86hvNHZq158VYMEaxegjfRg8ic02O0HeWD4xIsiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247487139&amp;amp;idx=1&amp;amp;sn=4ae53bf8e20aab324f58e85deedff42a&amp;amp;chksm=ceb9f208f9ce7b1e5d2882601ff2890ae9bef5584b6730c2b0b30c527340b4529b85cc636954&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;团队管理那点破事！OKR绩效、核心人才、面试、技术分享、研发流程....&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247486515&amp;amp;idx=1&amp;amp;sn=62a75d90d76a7f0c4cb01a64db8f4e2e&amp;amp;chksm=ceb9f098f9ce798eafec5c1e01aaeaedc00163e5c4925931da7a1b6184365d474fb1562cb664&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Redis缓存那点破事 | 绝杀面试官 25 问！&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247486281&amp;amp;idx=1&amp;amp;sn=2c0fc614dd94c93aa1172413fb340c6d&amp;amp;chksm=ceb9f7e2f9ce7ef46b0832f69b2e6e6e66d1d10c6db94fedb381da886894a1a622086e64f68a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;MYSQL 那点破事！索引、SQL调优、事务、B+树、分表 ....&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247485888&amp;amp;idx=1&amp;amp;sn=60304679c226fb6b2ebaba5bb6ad5485&amp;amp;chksm=ceb9f56bf9ce7c7d7c87fa4aa7cb70aba7af6b4aefbf1f8b3e331d5a443ccc91b3ba2fb95b9e&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;TCP网络那点破事！三次握手、四次挥手、TIME-WAIT ....&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原创不易，看到这里，还请点个&lt;/span&gt;&lt;span&gt;「赞」&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;「在看」&lt;/span&gt;&lt;span&gt;，谢谢大家支持&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f030aed500134fe288c349786a3e8ef5</guid>
<title>面渣逆袭：HashMap 追魂二十三问</title>
<link>https://toutiao.io/k/xktwzye</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是老三。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HashMap作为我们熟悉的一种集合，可以说是面试必考题。简单的使用，再到原理、数据结构，还可以延伸到并发，可以说，就一个HashMap，能聊半个小时。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;1.能说一下HashMap的数据结构吗？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK1.7的数据结构是&lt;code&gt;数组&lt;/code&gt;+&lt;code&gt;链表&lt;/code&gt;，JDK1.7还有人在用？不会吧……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说一下JDK1.8的数据结构吧：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK1.8的数据结构是&lt;code&gt;数组&lt;/code&gt;+&lt;code&gt;链表&lt;/code&gt;+&lt;code&gt;红黑树&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据结构示意图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5313620071684588&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SPLvQPy6joiaYM2j3XTXGAW5iciatWrkNicib7VX7OCnSQIVLlkmLo5KkkpLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1116&quot;/&gt;&lt;figcaption&gt;jdk1.8 hashmap数据结构示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，桶数组是用来存储数据元素，链表是用来解决冲突，红黑树是为了提高查询的效率。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据元素通过映射关系，也就是散列函数，映射到桶数组对应索引的位置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果发生冲突，从冲突的位置拉一个链表，插入冲突的元素&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果链表长度&amp;gt;8&amp;amp;数组大小&amp;gt;=64，链表转为红黑树&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果红黑树节点个数&amp;lt;6 ，转为链表&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;2.你对红黑树了解多少？为什么不用二叉树/平衡树呢？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;红黑树本质上是一种二叉查找树，为了保持平衡，它又在二叉查找树的基础上增加了一些规则：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;每个节点要么是红色，要么是黑色；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根节点永远是黑色的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;所有的叶子节点都是是黑色的（注意这里说叶子节点其实是图中的 NULL 节点）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个红色节点的两个子节点一定都是黑色；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.553133514986376&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SPichCqIR19RrThjlVys74rl0hzianGzEmBVEiauG6k2GDFxdic2w9n9NibIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;734&quot;/&gt;&lt;figcaption&gt;红黑树&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;之所以不用二叉树：&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;红黑树是一种平衡的二叉树，插入、删除、查找的最坏时间复杂度都为 O(logn)，避免了二叉树最坏情况下的O(n)时间复杂度。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;之所以不用平衡二叉树：&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;平衡二叉树是比红黑树更严格的平衡树，为了保持保持平衡，需要旋转的次数更多，也就是说平衡二叉树保持平衡的效率更低，所以平衡二叉树插入和删除的效率比红黑树要低。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;3.红黑树怎么保持平衡的知道吗？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;红黑树有两种方式保持平衡：&lt;code&gt;旋转&lt;/code&gt;和&lt;code&gt;染色&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3871428571428571&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SPNzQQ38V0bQznt4QZu8jECDUwNXjkUPIKaSO6ndibMGWs22f4vSwMI5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;figcaption&gt;左旋&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42510699001426533&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SPCLynJX3JVIxuFJMeCOZTEsPBO2WAke8JpkcbmxvsQjESzQGtOv5zvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;701&quot;/&gt;&lt;figcaption&gt;右旋&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41800246609124536&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SPdvHxPewrupLshAZNIh6egRt9ZdNvaib85P3mFqDBpgao4uwV9wxibt8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;811&quot;/&gt;&lt;figcaption&gt;染色&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;4.HashMap的put流程知道吗？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先上个流程图吧:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0520059435364042&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SPVcs0Cx9D5YiaNsKfQwADVtVTsw7BfQ1ashdhLwRY4IGJPEA2Z34jDCA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1346&quot;/&gt;&lt;figcaption&gt;HashMap插入数据流程图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;首先进行哈希值的扰动，获取一个新的哈希值。&lt;code&gt;(key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;判断tab是否位空或者长度为0，如果是则进行扩容操作。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; ((tab = table) == &lt;span&gt;null&lt;/span&gt; || (n = tab.length) == &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    n = (tab = resize()).length;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据哈希值计算下标，如果对应小标正好没有存放数据，则直接插入即可否则需要覆盖。&lt;code&gt;tab[i = (n - 1) &amp;amp; hash])&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;判断tab[i]是否为树节点，否则向链表中插入数据，是则向树中插入节点。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果链表中插入节点的时候，链表长度大于等于8，则需要把链表转换为红黑树。&lt;code&gt;treeifyBin(tab, hash);&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;最后所有元素处理完成后，判断是否超过阈值；&lt;code&gt;threshold&lt;/code&gt;，超过则扩容。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;5.HashMap怎么查找元素的呢？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看流程图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.235&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SPSJIJjWrvM3BYYwtOzpYR7YHoxibvRDwnBcBAdnaXGTfA01zDXwL8muQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;figcaption&gt;HashMap查找流程图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HashMap的查找就简单很多：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用扰动函数，获取新的哈希值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;计算数组下标，获取节点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当前节点和key匹配，直接返回&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;否则，当前节点是否为树节点，查找红黑树&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;否则，遍历链表查找&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;6.HashMap的哈希/扰动函数是怎么设计的?&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HashMap的哈希函数是先拿到 key 的hashcode，是一个32位的int类型的数值，然后让hashcode的高16位和低16位进行异或操作。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;hash&lt;/span&gt;&lt;span&gt;(Object key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; h;&lt;br/&gt;        &lt;span&gt;// key的hashCode和key的hashCode右移16位做异或运算&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;0&lt;/span&gt; : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么设计是为了降低哈希碰撞的概率。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;7.为什么哈希/扰动函数能降hash碰撞？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 key.hashCode() 函数调用的是 key 键值类型自带的哈希函数，返回 int 型散列值。int 值范围为 &lt;strong&gt;-2147483648~2147483647&lt;/strong&gt;，加起来大概 40 亿的映射空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如 HashMap 数组的初始大小才 16，就需要用之前需要对数组的长度取模运算，得到的余数才能用来访问数组下标。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码中模运算就是把散列值和数组长度 - 1 做一个 &quot;&lt;code&gt;与&amp;amp;&lt;/code&gt;&quot; 操作，位运算比取余 % 运算要快。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;bucketIndex = indexFor(hash, table.length);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;indexFor&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; h, &lt;span&gt;int&lt;/span&gt; length)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; h &amp;amp; (length-&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顺便说一下，这也正好解释了为什么 HashMap 的数组长度要取 2 的整数幂。因为这样（数组长度 - 1）正好相当于一个 “低位掩码”。&lt;code&gt;与&lt;/code&gt; 操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度 16 为例，16-1=15。2 进制表示是&lt;code&gt;0000 0000 0000 0000 0000 0000 0000 1111&lt;/code&gt;。和某个散列值做 &lt;code&gt;与&lt;/code&gt; 操作如下，结果就是截取了最低的四位值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21978021978021978&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SPRlQHGdJibg0gice2qddKPPzVqz4TN5XHXMp8Cz7pWPwrEBIRp45EVkKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1456&quot;/&gt;&lt;figcaption&gt;哈希&amp;amp;运算&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样是要快捷一些，但是新的问题来了，就算散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。如果散列本身做得不好，分布上成等差数列的漏洞，如果正好让最后几个低位呈现规律性重复，那就更难搞了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候 &lt;code&gt;扰动函数&lt;/code&gt; 的价值就体现出来了，看一下扰动函数的示意图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3224724484906564&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SPKpyGTlh1iaGbSSYht0tdSESQThbHsLaZMvGWIK97CFUeuqiar3sxqFlQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;6261&quot;/&gt;&lt;figcaption&gt;扰动函数示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;右移 16 位，正好是 32bit 的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;8.为什么HashMap的容量是2的倍数呢？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将元素放在table数组上面，是用hash值%数组大小定位位置，而HashMap是用hash值&amp;amp;(数组大小-1)，却能和前面达到一样的效果，这就得益于HashMap的大小是2的倍数，2的倍数意味着该数的二进制位只有一位为1，而该数-1就可以得到二进制位上1变成0，后面的0变成1，再通过&amp;amp;运算，就可以得到和%一样的效果，并且位运算比%的效率高得多&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HashMap的容量是2的n次幂时，(n-1)的2进制也就是1111111***111这样形式的，这样与添加元素的hash值进行位运算时，能够充分的散列，使得添加的元素均匀分布在HashMap的每个位置上，减少hash碰撞。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第二个方面是在扩容时，利用扩容后的大小也是2的倍数，将已经产生hash碰撞的元素完美的转移到新的table中去&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以简单看看HashMap的扩容机制，HashMap中的元素在超过&lt;code&gt;负载因子*HashMap&lt;/code&gt;大小时就会产生扩容。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18055555555555555&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SPT3LVDbOxDpibnlar4m1WriaviaPCOJ1ibX5u1ps8HMdhaJ9sOBa6aUlVKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;792&quot;/&gt;&lt;figcaption&gt;put中的扩容&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;9.如果初始化HashMap，传一个17的值&lt;code&gt;new HashMap&amp;lt;&amp;gt;&lt;/code&gt;，它会怎么处理？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来说，就是初始化时，传的不是2的倍数时，HashMap会向上寻找&lt;code&gt;离得最近的2的倍数&lt;/code&gt;，所以传入14，但HashMap的实际容量是32。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看看详情，在HashMap的初始化中，有这样⼀段⽅法；&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; initialCapacity, &lt;span&gt;float&lt;/span&gt; loadFactor)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; ...&lt;br/&gt; &lt;span&gt;this&lt;/span&gt;.loadFactor = loadFactor;&lt;br/&gt; &lt;span&gt;this&lt;/span&gt;.threshold = tableSizeFor(initialCapacity);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;阀值 threshold ，通过⽅法&lt;code&gt;tableSizeFor&lt;/code&gt; 进⾏计算，是根据初始化传的参数来计算的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同时，这个⽅法也要要寻找⽐初始值⼤的，最⼩的那个2进制数值。⽐如传了17，我应该找到的是32。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;tableSizeFor&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; cap)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;int&lt;/span&gt; n = cap - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt; n |= n &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt; n |= n &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt; n |= n &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;4&lt;/span&gt;;&lt;br/&gt; n |= n &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;8&lt;/span&gt;;&lt;br/&gt; n |= n &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;16&lt;/span&gt;;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; (n &amp;lt; &lt;span&gt;0&lt;/span&gt;) ? &lt;span&gt;1&lt;/span&gt; : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + &lt;span&gt;1&lt;/span&gt;; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30，这个是临界范围，也就是最⼤的Map集合。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;计算过程是向右移位1、2、4、8、16，和原来的数做&lt;code&gt;|&lt;/code&gt;运算，这主要是为了把⼆进制的各个位置都填上1，当⼆进制的各个位置都是1以后，就是⼀个标准的2的倍数减1了，最后把结果加1再返回即可。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以17为例，看一下初始化计算table容量的过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5167958656330749&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SP0QugicuwSyQLxPaVT1yTcG17Dicn6hekCnuK2RtZdicFVTpCpibbzgdlzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;774&quot;/&gt;&lt;figcaption&gt;容量计算&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;10.你还知道哪些哈希函数的构造方法呢？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HashMap里哈希构造函数的方法叫：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;除留取余法&lt;/strong&gt;：H（key)=key%p（p&amp;lt;=N）,关键字除以一个不大于哈希表长度的正整数p，所得余数为地址，当然HashMap里进行了优化改造，效率更高，散列也更均衡。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，还有这几种常见的哈希函数构造方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;直接定址法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;直接根据&lt;code&gt;key&lt;/code&gt;来映射到对应的数组位置，例如1232放到下标1232的位置。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;数字分析法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;取&lt;code&gt;key&lt;/code&gt;的某些数字（例如十位和百位）作为映射的位置&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;平方取中法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;取&lt;code&gt;key&lt;/code&gt;平方的中间几位作为映射的位置&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;折叠法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;将&lt;code&gt;key&lt;/code&gt;分割成位数相同的几段，然后把它们的叠加和作为映射的位置&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4551863041289023&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SPwly1WbBtVibbbUEI7ibE8wtHFm4CnMwcia1O1dYgdK9wXib2H2hqmZy10w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;993&quot;/&gt;&lt;figcaption&gt;散列函数构造&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;11.解决哈希冲突有哪些方法呢？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们到现在已经知道，HashMap使用链表的原因为了处理哈希冲突，这种方法就是所谓的：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;链地址法&lt;/strong&gt;：在冲突的位置拉一个链表，把冲突的元素放进去。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，还有一些常见的解决冲突的办法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;开放定址法&lt;/strong&gt;：开放定址法就是从冲突的位置再接着往下找，给冲突元素找个空位。&lt;/p&gt;&lt;p&gt;找到空闲位置的方法也有很多种：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线行探查法: 从冲突的位置开始，依次判断下一个位置是否空闲，直至找到空闲位置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;平方探查法: 从冲突的位置x开始，第一次增加&lt;code&gt;1^2&lt;/code&gt;个位置，第二次增加&lt;code&gt;2^2&lt;/code&gt;…，直至找到空闲的位置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;……&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4386381631037213&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SP2LwW06ApESOjPlSDiaz4SiaYTuSbzNIqygr30tsPrgLAnFg7aIImoqYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1263&quot;/&gt;&lt;figcaption&gt;开放定址法&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;再哈希法&lt;/strong&gt;：换种哈希函数，重新计算冲突元素的地址。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;建立公共溢出区&lt;/strong&gt;：再建一个数组，把冲突的元素放进去。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;12.为什么HashMap链表转红黑树的阈值为8呢？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;树化发生在table数组的长度大于64，且链表的长度大于8的时候。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么是8呢？源码的注释也给出了答案。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9436619718309859&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SPV3qgYjw3C1f9SjzmMWziaLiakLojj24jrSTDRe1W3V9o70oTYC5WP9yA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1420&quot;/&gt;&lt;figcaption&gt;源码注释&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;红黑树节点的大小大概是普通节点大小的两倍，所以转红黑树，牺牲了空间换时间，更多的是一种兜底的策略，保证极端情况下的查找效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阈值为什么要选8呢？和统计学有关。理想情况下，使用随机哈希码，链表里的节点符合泊松分布，出现节点个数的概率是递减的，节点个数为8的情况，发生概率仅为&lt;code&gt;0.00000006&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于红黑树转回链表的阈值为什么是6，而不是8？是因为如果这个阈值也设置成8，假如发生碰撞，节点增减刚好在8附近，会发生链表和红黑树的不断转换，导致资源浪费。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;13.扩容在什么时候呢？为什么扩容因子是0.75？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了减少哈希冲突发生的概率，当当前HashMap的元素个数达到一个临界值的时候，就会触发扩容，把所有元素rehash之后再放在扩容后的容器中，这是一个相当耗时的操作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.10294117647058823&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SPLRMbVLMbGjM3ibRtyyG106lQic8nTWHLebv3R4rfCicGCFGD3TaocciavA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;612&quot;/&gt;&lt;figcaption&gt;put时，扩容&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而这个&lt;code&gt;临界值threshold&lt;/code&gt;就是由加载因子和当前容器的容量大小来确定的，假如采用默认的构造方法：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;临界值（threshold ）= 默认容量（DEFAULT_INITIAL_CAPACITY） * 默认扩容因子（DEFAULT_LOAD_FACTOR）&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35811648079306074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SP0hZpauuibZw21iadLHzBTjO4icax2a2DtF5IHNhzLk53YYxwBZf3q4D5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;807&quot;/&gt;&lt;figcaption&gt;threshold计算&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那就是大于&lt;code&gt;16x0.75=12&lt;/code&gt;时，就会触发扩容操作。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;那么为什么选择了0.75作为HashMap的默认加载因子呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来说，这是对&lt;code&gt;空间&lt;/code&gt;成本和&lt;code&gt;时间&lt;/code&gt;成本平衡的考虑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在HashMap中有这样一段注释：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5954415954415955&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SPAWZXjhY7iaJib3Vu2kt4sDeCBVcPiclEsxjNyH7AYZH7uZvkicZfHiafknA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1404&quot;/&gt;&lt;figcaption&gt;关于默认负载因子的注释&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，HashMap的散列构造方式是Hash取余，负载因子决定元素个数达到多少时候扩容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如我们设的比较大，元素比较多，空位比较少的时候才扩容，那么发生哈希冲突的概率就增加了，查找的时间成本就增加了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们设的比较小的话，元素比较少，空位比较多的时候就扩容了，发生哈希碰撞的概率就降低了，查找时间成本降低，但是就需要更多的空间去存储元素，空间成本就增加了。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;14.那扩容机制了解吗？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HashMap是基于数组+链表和红黑树实现的，但用于存放key值的桶数组的长度是固定的，由初始化参数确定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，随着数据的插入数量增加以及负载因子的作用下，就需要扩容来存放更多的数据。而扩容中有一个非常重要的点，就是jdk1.8中的优化操作，可以不需要再重新计算每一个元素的哈希值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为HashMap的初始容量是2的次幂，扩容之后的长度是原来的二倍，新的容量也是2的次幂，所以，元素，要么在原位置，要么在原位置再移动2的次幂。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看下这张图，n为table的长度，图&lt;code&gt;a&lt;/code&gt;表示扩容前的key1和key2两种key确定索引的位置，图&lt;code&gt;b&lt;/code&gt;表示扩容后key1和key2两种key确定索引位置。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.27328431372549017&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SP6BfCxZfvTKQIJeEWHFxo02zQDicVCFbZOnrMOCNG3w5hmazC21lMicnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1632&quot;/&gt;&lt;figcaption&gt;扩容之后的索引计算&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SPgzYyRU2UiaxunPFp4C6OJwXM9Qov9xwCIgBCIl4RrLuvB5SlxNUR5Jw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;876&quot;/&gt;&lt;figcaption&gt;扩容位置变化&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在扩容时，只需要看原来的hash值新增的那一位是0还是1就行了，是0的话索引没变，是1的化变成&lt;code&gt;原索引+oldCap&lt;/code&gt;，看看如16扩容为32的示意图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4817642069550466&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SPjYPV3HqibDG5DyX81J2ZCdYpxbMCejTGprxHvEia5SjGPo4Xrv42mf6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1179&quot;/&gt;&lt;figcaption&gt;扩容节点迁移示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩容节点迁移主要逻辑：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.6168384879725086&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SPialdMwxQlHV2fyha8Yib5v39zXnibC8VSPKJvs0JlbYfepmXBicb0KGKvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1164&quot;/&gt;&lt;figcaption&gt;扩容主要逻辑&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;15.jdk1.8对HashMap主要做了哪些优化呢？为什么？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jdk1.8 的HashMap主要有五点优化：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;数据结构&lt;/strong&gt;：数组 + 链表改成了数组 + 链表或红黑树&lt;/p&gt;&lt;p&gt;&lt;code&gt;原因&lt;/code&gt;：发生 hash 冲突，元素会存入链表，链表过长转为红黑树，将时间复杂度由&lt;code&gt;O(n)&lt;/code&gt;降为&lt;code&gt;O(logn)&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;链表插入方式&lt;/strong&gt;：链表的插入方式从头插法改成了尾插法&lt;/p&gt;&lt;p&gt;简单说就是插入时，如果数组位置上已经有元素，1.7 将新元素放到数组中，原始节点作为新节点的后继节点，1.8 遍历链表，将元素放置到链表的最后。&lt;/p&gt;&lt;p&gt;&lt;code&gt;原因&lt;/code&gt;：因为 1.7 头插法扩容时，头插法会使链表发生反转，多线程环境下会产生环。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;扩容rehash&lt;/strong&gt;：扩容的时候 1.7 需要对原数组中的元素进行重新 hash 定位在新数组的位置，1.8 采用更简单的判断逻辑，不需要重新通过哈希函数计算位置，新的位置不变或索引 + 新增容量大小。&lt;/p&gt;&lt;p&gt;&lt;code&gt;原因：&lt;/code&gt;提高扩容的效率，更快地扩容。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;扩容时机&lt;/strong&gt;：在插入时，1.7 先判断是否需要扩容，再插入，1.8 先进行插入，插入完成再判断是否需要扩容；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;散列函数&lt;/strong&gt;：1.7 做了四次移位和四次异或，jdk1.8只做一次。&lt;/p&gt;&lt;p&gt;&lt;code&gt;原因&lt;/code&gt;：做 4 次的话，边际效用也不大，改为一次，提升效率。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;16.你能自己设计实现一个HashMap吗？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题&lt;strong&gt;快手&lt;/strong&gt;常考。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要慌，红黑树版咱们多半是写不出来，但是数组+链表版还是问题不大的，详细可见：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247488653&amp;amp;idx=1&amp;amp;sn=3c7e29786611bb9532ab69f715eefb68&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;手写HashMap，快手面试官直呼内行！&lt;/a&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体的设计：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;散列函数：hashCode()+除留余数法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;冲突解决：链地址法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;扩容：节点重新hash获取位置&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3393829401088929&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SPfyqlgW5ymrOfAaY9LlPYL15RXpcutR5YZqI9mM9zMAD7UIAbVrazCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1102&quot;/&gt;&lt;figcaption&gt;自定义HashMap整体结构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整代码：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;5.103496503496504&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SPBRnc5IaVFDaFCMXibHH1v7dKWC7PbP2kX71u7HRBXEDtX51nG8VSNLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1430&quot;/&gt;&lt;figcaption&gt;完整代码&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;17.HashMap 是线程安全的吗？多线程下会有什么问题？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HashMap不是线程安全的，可能会发生这些问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;多线程下扩容死循环。JDK1.7 中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK1.8 使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;多线程的 put 可能导致元素的丢失。多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在 JDK 1.7 和 JDK 1.8 中都存在。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;put 和 get 并发时，可能导致 get 为 null。线程 1 执行 put 时，因为元素个数超出 threshold 而导致 rehash，线程 2 此时执行 get，有可能导致这个问题。这个问题在 JDK 1.7 和 JDK 1.8 中都存在。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;18.有什么办法能解决HashMap线程不安全的问题呢？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 中有 HashTable、Collections.synchronizedMap、以及 ConcurrentHashMap 可以实现线程安全的 Map。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;HashTable 是直接在操作方法上加 synchronized 关键字，锁住整个table数组，粒度比较大；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Collections.synchronizedMap 是使用 Collections 集合工具的内部类，通过传入 Map 封装出一个 SynchronizedMap 对象，内部定义了一个对象锁，方法内通过对象锁实现；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ConcurrentHashMap 在jdk1.7中使用分段锁，在jdk1.8中使用CAS+synchronized。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;19.能具体说一下ConcurrentHashmap的实现吗？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ConcurrentHashmap线程安全在jdk1.7版本是基于&lt;code&gt;分段锁&lt;/code&gt;实现，在jdk1.8是基于&lt;code&gt;CAS+synchronized&lt;/code&gt;实现。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.7分段锁&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从结构上说，1.7版本的ConcurrentHashMap采用分段锁机制，里面包含一个Segment数组，Segment继承于ReentrantLock，Segment则包含HashEntry的数组，HashEntry本身就是一个链表的结构，具有保存key、value的能力能指向下一个节点的指针。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上就是相当于每个Segment都是一个HashMap，默认的Segment长度是16，也就是支持16个线程的并发写，Segment之间相互不会受到影响。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35572374645222327&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SPjuW7MaiaaCe7KgJhOkw3DcW8qmYnribgsKCHBEatLctUh6AvnCfUXPyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1057&quot;/&gt;&lt;figcaption&gt;1.7ConcurrentHashMap示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;put流程&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个流程和HashMap非常类似，只不过是先定位到具体的Segment，然后通过ReentrantLock去操作而已，后面的流程，就和HashMap基本上是一样的。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;计算hash，定位到segment，segment如果是空就先初始化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用ReentrantLock加锁，如果获取锁失败则尝试自旋，自旋超过次数就阻塞获取，保证一定获取锁成功&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;遍历HashEntry，就是和HashMap一样，数组中key和hash一样就直接替换，不存在就再插入链表，链表同样操作&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.5952153110047846&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SPKAib3vEKzKyicxDu5qnIYpmxCvmwe3SSuRHS2vZOEhemn8rplxC6e9qw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1045&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;get流程&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;get也很简单，key通过hash定位到segment，再遍历链表定位到具体的元素上，需要注意的是value是volatile的，所以get是不需要加锁的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;1.8 CAS+synchronized&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jdk1.8实现线程安全不是在数据结构上下功夫，它的数据结构和HashMap是一样的，数组+链表+红黑树。它实现线程安全的关键点在于put流程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;put流程&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先计算hash，遍历node数组，如果node是空的话，就通过CAS+自旋的方式初始化&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; tab = initTable();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;node数组初始化：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt;[] initTable() {&lt;br/&gt;        Node&amp;lt;K,V&amp;gt;[] tab; &lt;span&gt;int&lt;/span&gt; sc;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; ((tab = table) == &lt;span&gt;null&lt;/span&gt; || tab.length == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;//如果正在初始化或者扩容&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((sc = sizeCtl) &amp;lt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;//等待&lt;/span&gt;&lt;br/&gt;                Thread.yield(); &lt;span&gt;// lost initialization race; just spin&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (U.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, SIZECTL, sc, -&lt;span&gt;1&lt;/span&gt;)) {   &lt;span&gt;//CAS操作&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; ((tab = table) == &lt;span&gt;null&lt;/span&gt; || tab.length == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                        &lt;span&gt;int&lt;/span&gt; n = (sc &amp;gt; &lt;span&gt;0&lt;/span&gt;) ? sc : DEFAULT_CAPACITY;&lt;br/&gt;                        &lt;span&gt;@SuppressWarnings&lt;/span&gt;(&lt;span&gt;&quot;unchecked&quot;&lt;/span&gt;)&lt;br/&gt;                        Node&amp;lt;K,V&amp;gt;[] nt = (Node&amp;lt;K,V&amp;gt;[])&lt;span&gt;new&lt;/span&gt; Node&amp;lt;?,?&amp;gt;[n];&lt;br/&gt;                        table = tab = nt;&lt;br/&gt;                        sc = n - (n &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                    sizeCtl = sc;&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; tab;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.如果当前数组位置是空则直接通过CAS自旋写入数据&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &amp;lt;K,V&amp;gt; &lt;span&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;casTabAt&lt;/span&gt;&lt;span&gt;(Node&amp;lt;K,V&amp;gt;[] tab, &lt;span&gt;int&lt;/span&gt; i,&lt;br/&gt;                                        Node&amp;lt;K,V&amp;gt; c, Node&amp;lt;K,V&amp;gt; v)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; U.compareAndSwapObject(tab, ((&lt;span&gt;long&lt;/span&gt;)i &amp;lt;&amp;lt; ASHIFT) + ABASE, c, v);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果hash==MOVED，说明需要扩容，执行扩容&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((fh = f.hash) == MOVED)&lt;br/&gt;                tab = helpTransfer(tab, f);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt;[] helpTransfer(Node&amp;lt;K,V&amp;gt;[] tab, Node&amp;lt;K,V&amp;gt; f) {&lt;br/&gt;        Node&amp;lt;K,V&amp;gt;[] nextTab; &lt;span&gt;int&lt;/span&gt; sc;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (tab != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (f &lt;span&gt;instanceof&lt;/span&gt; ForwardingNode) &amp;amp;&amp;amp;&lt;br/&gt;            (nextTab = ((ForwardingNode&amp;lt;K,V&amp;gt;)f).nextTable) != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; rs = resizeStamp(tab.length);&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (nextTab == nextTable &amp;amp;&amp;amp; table == tab &amp;amp;&amp;amp;&lt;br/&gt;                   (sc = sizeCtl) &amp;lt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; ((sc &amp;gt;&amp;gt;&amp;gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + &lt;span&gt;1&lt;/span&gt; ||&lt;br/&gt;                    sc == rs + MAX_RESIZERS || transferIndex &amp;lt;= &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;                    &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (U.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, SIZECTL, sc, sc + &lt;span&gt;1&lt;/span&gt;)) {&lt;br/&gt;                    transfer(tab, nextTab);&lt;br/&gt;                    &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; nextTab;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; table;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果都不满足，就使用synchronized写入数据，写入数据同样判断链表、红黑树，链表写入和HashMap的方式一样，key hash一样就覆盖，反之就尾插法，链表长度超过8就转换成红黑树&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; &lt;span&gt;synchronized&lt;/span&gt; (f){&lt;br/&gt;     ……&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9362244897959183&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SPOZAjMNY6FJMDFOIdXCcRZhCy5AttcicSloLIMvFbF5IVg1yThJcaib6w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;784&quot;/&gt;&lt;figcaption&gt;ConcurrentHashmap jdk1.8put流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;get查询&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;get很简单，和HashMap基本相同，通过key计算位置，table该位置key相同就返回，如果是红黑树按照红黑树获取，否则就遍历链表获取。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;20.HashMap 内部节点是有序的吗？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HashMap是无序的，根据 hash 值随机插入。如果想使用有序的Map，可以使用LinkedHashMap 或者 TreeMap。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;21.讲讲 LinkedHashMap 怎么实现有序的？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LinkedHashMap维护了一个双向链表，有头尾节点，同时 LinkedHashMap 节点 Entry 内部除了继承 HashMap 的 Node 属性，还有 before 和 after 用于标识前置节点和后置节点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48738170347003157&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SPib5Ua5Mjxzh3jfGYbowJ5krwJZv41cowtvVAicj0kMVOwWCHicJYV6g6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;634&quot;/&gt;&lt;figcaption&gt;Entry节点&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以实现按插入的顺序或访问顺序排序。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.686382393397524&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SP7TjeohMlxquEgIjzsAnpIJYEVH9dr3emQBibibXC2jDhibFhcDYNVq4Vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;727&quot;/&gt;&lt;figcaption&gt;LinkedHashMap实现原理&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;22.讲讲 TreeMap 怎么实现有序的？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TreeMap 是按照 Key 的自然顺序或者 Comprator 的顺序进行排序，内部是通过红黑树来实现。所以要么 key 所属的类实现 Comparable 接口，或者自定义一个实现了 Comparator 接口的比较器，传给 TreeMap 用于 key 的比较。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44516653127538586&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SPhAo1cvNnNmrWmPibiaSYasfcGBCjWPSpdJnL8m4LWd4r2u7dcWOTv8qQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1231&quot;/&gt;&lt;figcaption&gt;TreeMap&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;23.讲讲HashSet的底层实现？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HashSet 底层就是基于 HashMap 实现的。（ HashSet 的源码⾮常⾮常少，因为除了 clone() 、 writeObject() 、 readObject() 是 HashSet⾃⼰不得不实现之外，其他⽅法都是直接调⽤ HashMap 中的⽅法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HashSet的add方法，直接调用HashMap的put方法，将添加的元素作为key，new一个Object作为value，直接调用HashMap的put方法，它会根据返回值是否为空来判断是否插入元素成功。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(E e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; map.put(e, PRESENT)==&lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6369710467706013&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SPiccY60Bda6W1JqwKBboss9TGhjXjibDBc1JsnoROBEkUQoD8u66xZJLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;449&quot;/&gt;&lt;figcaption&gt;HashSet套娃&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在HashMap的putVal方法中，进行了一系列判断，最后的结果是，只有在key在table数组中不存在的时候，才会返回插入的值。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;            &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;// existing mapping for key&lt;/span&gt;&lt;br/&gt;                V oldValue = e.value;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (!onlyIfAbsent || oldValue == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;                    e.value = value;&lt;br/&gt;                afterNodeAccess(e);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; oldValue;&lt;br/&gt;            }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;big&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;[1]. 一个HashMap跟面试官扯了半个小时:https://blog.csdn.net/zhengwangzw/article/details/104889549/&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[2]. 小傅哥 《Java面经手册》&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[4]. 《我想进大厂》之Java基础夺命连环16问   :https://mp.weixin.qq.com/s__biz=MzkzNTEwOTAxMA==&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[5]. 数据结构之LinkedHashMap：https://www.jianshu.com/p/bbc8087bd9ce&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[6]. 面试官：为什么 HashMap 的加载因子是0.75？：https://zhuanlan.zhihu.com/p/149687607&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[7]. 面试旧敌之红黑树（直白介绍深入理解）：https://juejin.cn/post/6844903454767317005&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[8]. Java TreeMap工作原理及实现  :https://yikun.github.io/2015/04/06/Java-TreeMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[9]. 手写HashMap，快手面试官直呼内行！：https://mp.weixin.qq.com/s/Z9yoRZW5itrtgbS-cj0bUg&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[10].Java 8系列之重新认识HashMap：https://tech.meituan.com/2016/06/24/java-hashmap.html&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.73515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWdqV0bvCXPe8wVIwv8fW8SP1lGO0ZedNeu5af7RBMjicEXIlhSvCe673daInrSecPUFptMb9NSYG3Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;封面图在此&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODE5ODM0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdFLJg0sAOqwHB1mb24icMADUgxm1qZQft5aN3H37NAmQnOvpGB7J9JVHxC6NSiacxbBP1DYdhIAeyA/0?wx_fmt=png&quot; data-nickname=&quot;三分恶&quot; data-alias=&quot;Fighter3FullStack&quot; data-signature=&quot;CSDN博客专家、优质创作者，华为云云享专家；肝过外包、混过国企，目前在一家跨境电商搬砖；写过诗，打过拳，佛系小码农。认真讲技术，随性侃人生，关注我，我们一起走的更远。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3abb6d8427409c99e69e4e9a0dd2ebaa</guid>
<title>Google：12 条 Golang 最佳实践</title>
<link>https://toutiao.io/k/x06am1r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-content mb-3&quot;&gt;&lt;p&gt;这是直接总结好的 12 条，详细的再继续往下看：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先处理错误避免嵌套&lt;/li&gt;
&lt;li&gt;尽量避免重复&lt;/li&gt;
&lt;li&gt;先写最重要的代码&lt;/li&gt;
&lt;li&gt;给代码写文档注释&lt;/li&gt;
&lt;li&gt;命名尽可能简洁&lt;/li&gt;
&lt;li&gt;使用多文件包&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;go get&lt;/code&gt; 可获取你的包&lt;/li&gt;
&lt;li&gt;了解自己的需求&lt;/li&gt;
&lt;li&gt;保持包的独立性&lt;/li&gt;
&lt;li&gt;避免在内部使用并发&lt;/li&gt;
&lt;li&gt;使用 Goroutine 管理状态&lt;/li&gt;
&lt;li&gt;避免 Goroutine 泄露&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;最佳实践&quot;&gt;最佳实践&lt;/h2&gt;
&lt;p&gt;这是一篇翻译文章，为了使读者更好的理解，会在原文翻译的基础增加一些讲解或描述。&lt;/p&gt;
&lt;p&gt;来在维基百科：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;A best practice is a method or technique that has consistently shown results superior
to those achieved with other means&quot;

最佳实践是一种方法或技术，其结果始终优于其他方式。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;写 Go 代码时的技术要求：&lt;/p&gt;

&lt;h2 id=&quot;样例代码&quot;&gt;样例代码&lt;/h2&gt;
&lt;p&gt;需要优化的代码。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Gopher&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; {
    &lt;span&gt;Name&lt;/span&gt;     &lt;span&gt;string&lt;/span&gt;
    &lt;span&gt;AgeYears&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;
}

&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;g&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Gopher&lt;/span&gt;) &lt;span&gt;WriteTo&lt;/span&gt;(&lt;span&gt;w&lt;/span&gt; &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;Writer&lt;/span&gt;) (&lt;span&gt;size&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;) {
    &lt;span&gt;err&lt;/span&gt; = &lt;span&gt;binary&lt;/span&gt;.&lt;span&gt;Write&lt;/span&gt;(&lt;span&gt;w&lt;/span&gt;, &lt;span&gt;binary&lt;/span&gt;.&lt;span&gt;LittleEndian&lt;/span&gt;, int32(len(&lt;span&gt;g&lt;/span&gt;.&lt;span&gt;Name&lt;/span&gt;)))
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
        &lt;span&gt;size&lt;/span&gt; &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; &lt;span&gt;n&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;
        &lt;span&gt;n&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; = &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;Write&lt;/span&gt;([]byte(&lt;span&gt;g&lt;/span&gt;.&lt;span&gt;Name&lt;/span&gt;))
        &lt;span&gt;size&lt;/span&gt; &lt;span&gt;+=&lt;/span&gt; int64(&lt;span&gt;n&lt;/span&gt;)
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
            &lt;span&gt;err&lt;/span&gt; = &lt;span&gt;binary&lt;/span&gt;.&lt;span&gt;Write&lt;/span&gt;(&lt;span&gt;w&lt;/span&gt;, &lt;span&gt;binary&lt;/span&gt;.&lt;span&gt;LittleEndian&lt;/span&gt;, int64(&lt;span&gt;g&lt;/span&gt;.&lt;span&gt;AgeYears&lt;/span&gt;))
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
                &lt;span&gt;size&lt;/span&gt; &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;
            }
            &lt;span&gt;return&lt;/span&gt;
        }
        &lt;span&gt;return&lt;/span&gt;
    }
    &lt;span&gt;return&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;看看上面的代码，自己先思索在代码编写方式上怎么更好，我先简单说下代码意思是啥：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将 &lt;code&gt;Name&lt;/code&gt; 和 &lt;code&gt;AgeYears&lt;/code&gt; 字段数据存入 &lt;code&gt;io.Writer&lt;/code&gt; 类型中。&lt;/li&gt;
&lt;li&gt;如果存入的数据是 &lt;code&gt;string&lt;/code&gt; 或 &lt;code&gt;[]byte&lt;/code&gt; 类型，再追加其长度数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果对 &lt;code&gt;binary&lt;/code&gt; 这个标准包不知道怎么使用，就看看我的另一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s/fATns17paqbmG8Ikb3ZedA&quot; target=&quot;_blank&quot;&gt;《快速了解 “小字端” 和 “大字端” 及 Go 语言中的使用》&lt;/a&gt;
。&lt;/p&gt;
&lt;h2 id=&quot;先处理错误避免嵌套&quot;&gt;先处理错误避免嵌套&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;g&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Gopher&lt;/span&gt;) &lt;span&gt;WriteTo&lt;/span&gt;(&lt;span&gt;w&lt;/span&gt; &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;Writer&lt;/span&gt;) (&lt;span&gt;size&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;) {
    &lt;span&gt;err&lt;/span&gt; = &lt;span&gt;binary&lt;/span&gt;.&lt;span&gt;Write&lt;/span&gt;(&lt;span&gt;w&lt;/span&gt;, &lt;span&gt;binary&lt;/span&gt;.&lt;span&gt;LittleEndian&lt;/span&gt;, int32(len(&lt;span&gt;g&lt;/span&gt;.&lt;span&gt;Name&lt;/span&gt;)))
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
        &lt;span&gt;return&lt;/span&gt;
    }
    &lt;span&gt;size&lt;/span&gt; &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;
    &lt;span&gt;n&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;Write&lt;/span&gt;([]byte(&lt;span&gt;g&lt;/span&gt;.&lt;span&gt;Name&lt;/span&gt;))
    &lt;span&gt;size&lt;/span&gt; &lt;span&gt;+=&lt;/span&gt; int64(&lt;span&gt;n&lt;/span&gt;)
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
        &lt;span&gt;return&lt;/span&gt;
    }
    &lt;span&gt;err&lt;/span&gt; = &lt;span&gt;binary&lt;/span&gt;.&lt;span&gt;Write&lt;/span&gt;(&lt;span&gt;w&lt;/span&gt;, &lt;span&gt;binary&lt;/span&gt;.&lt;span&gt;LittleEndian&lt;/span&gt;, int64(&lt;span&gt;g&lt;/span&gt;.&lt;span&gt;AgeYears&lt;/span&gt;))
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
        &lt;span&gt;size&lt;/span&gt; &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;
    }
    &lt;span&gt;return&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;减少判断错误的嵌套，会使读者看起来更轻松。&lt;/p&gt;
&lt;h2 id=&quot;尽量避免重复&quot;&gt;尽量避免重复&lt;/h2&gt;
&lt;p&gt;上面代码中 &lt;code&gt;WriteTo&lt;/code&gt; 方法中的 &lt;code&gt;Write&lt;/code&gt; 出现了 3 次，比较重复，精简后如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;binWriter&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; {
    &lt;span&gt;w&lt;/span&gt;    &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;Writer&lt;/span&gt;
    &lt;span&gt;size&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt;
    &lt;span&gt;err&lt;/span&gt;  &lt;span&gt;error&lt;/span&gt;
}

&lt;span&gt;// Write writes a value to the provided writer in little endian form.
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;w&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;binWriter&lt;/span&gt;) &lt;span&gt;Write&lt;/span&gt;(&lt;span&gt;v&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;{}) {
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
        &lt;span&gt;return&lt;/span&gt;
    }
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;err&lt;/span&gt; = &lt;span&gt;binary&lt;/span&gt;.&lt;span&gt;Write&lt;/span&gt;(&lt;span&gt;w&lt;/span&gt;.&lt;span&gt;w&lt;/span&gt;, &lt;span&gt;binary&lt;/span&gt;.&lt;span&gt;LittleEndian&lt;/span&gt;, &lt;span&gt;v&lt;/span&gt;); &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;err&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
        &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;size&lt;/span&gt; &lt;span&gt;+=&lt;/span&gt; int64(&lt;span&gt;binary&lt;/span&gt;.&lt;span&gt;Size&lt;/span&gt;(&lt;span&gt;v&lt;/span&gt;))
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用 &lt;code&gt;binWriter&lt;/code&gt; 结构体。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;g&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Gopher&lt;/span&gt;) &lt;span&gt;WriteTo&lt;/span&gt;(&lt;span&gt;w&lt;/span&gt; &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;Writer&lt;/span&gt;) (&lt;span&gt;int64&lt;/span&gt;, &lt;span&gt;error&lt;/span&gt;) {
    &lt;span&gt;bw&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;binWriter&lt;/span&gt;{&lt;span&gt;w&lt;/span&gt;: &lt;span&gt;w&lt;/span&gt;}
    &lt;span&gt;bw&lt;/span&gt;.&lt;span&gt;Write&lt;/span&gt;(int32(len(&lt;span&gt;g&lt;/span&gt;.&lt;span&gt;Name&lt;/span&gt;)))
    &lt;span&gt;bw&lt;/span&gt;.&lt;span&gt;Write&lt;/span&gt;([]byte(&lt;span&gt;g&lt;/span&gt;.&lt;span&gt;Name&lt;/span&gt;))
    &lt;span&gt;bw&lt;/span&gt;.&lt;span&gt;Write&lt;/span&gt;(int64(&lt;span&gt;g&lt;/span&gt;.&lt;span&gt;AgeYears&lt;/span&gt;))
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;bw&lt;/span&gt;.&lt;span&gt;size&lt;/span&gt;, &lt;span&gt;bw&lt;/span&gt;.&lt;span&gt;err&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&quot;type-switch-处理不同类型&quot;&gt;type-switch 处理不同类型&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;w&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;binWriter&lt;/span&gt;) &lt;span&gt;Write&lt;/span&gt;(&lt;span&gt;v&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;{}) {
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
        &lt;span&gt;return&lt;/span&gt;
    }
    &lt;span&gt;switch&lt;/span&gt; &lt;span&gt;v&lt;/span&gt;.(&lt;span&gt;type&lt;/span&gt;) {
    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;:
        &lt;span&gt;s&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;v&lt;/span&gt;.(&lt;span&gt;string&lt;/span&gt;)
        &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;Write&lt;/span&gt;(int32(len(&lt;span&gt;s&lt;/span&gt;)))
        &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;Write&lt;/span&gt;([]byte(&lt;span&gt;s&lt;/span&gt;))
    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;:
        &lt;span&gt;i&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;v&lt;/span&gt;.(&lt;span&gt;int&lt;/span&gt;)
        &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;Write&lt;/span&gt;(int64(&lt;span&gt;i&lt;/span&gt;))
    &lt;span&gt;default&lt;/span&gt;:
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;err&lt;/span&gt; = &lt;span&gt;binary&lt;/span&gt;.&lt;span&gt;Write&lt;/span&gt;(&lt;span&gt;w&lt;/span&gt;.&lt;span&gt;w&lt;/span&gt;, &lt;span&gt;binary&lt;/span&gt;.&lt;span&gt;LittleEndian&lt;/span&gt;, &lt;span&gt;v&lt;/span&gt;); &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;err&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
            &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;size&lt;/span&gt; &lt;span&gt;+=&lt;/span&gt; int64(&lt;span&gt;binary&lt;/span&gt;.&lt;span&gt;Size&lt;/span&gt;(&lt;span&gt;v&lt;/span&gt;))
        }
    }
}

&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;g&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Gopher&lt;/span&gt;) &lt;span&gt;WriteTo&lt;/span&gt;(&lt;span&gt;w&lt;/span&gt; &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;Writer&lt;/span&gt;) (&lt;span&gt;int64&lt;/span&gt;, &lt;span&gt;error&lt;/span&gt;) {
    &lt;span&gt;bw&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;binWriter&lt;/span&gt;{&lt;span&gt;w&lt;/span&gt;: &lt;span&gt;w&lt;/span&gt;}
    &lt;span&gt;bw&lt;/span&gt;.&lt;span&gt;Write&lt;/span&gt;(&lt;span&gt;g&lt;/span&gt;.&lt;span&gt;Name&lt;/span&gt;)
    &lt;span&gt;bw&lt;/span&gt;.&lt;span&gt;Write&lt;/span&gt;(&lt;span&gt;g&lt;/span&gt;.&lt;span&gt;AgeYears&lt;/span&gt;)
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;bw&lt;/span&gt;.&lt;span&gt;size&lt;/span&gt;, &lt;span&gt;bw&lt;/span&gt;.&lt;span&gt;err&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&quot;type-switch-精简&quot;&gt;type-switch 精简&lt;/h2&gt;
&lt;p&gt;摒弃了上面代码的 &lt;code&gt;v.(string)&lt;/code&gt; 、&lt;code&gt;v.(int)&lt;/code&gt; 类型反射使用。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;w&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;binWriter&lt;/span&gt;) &lt;span&gt;Write&lt;/span&gt;(&lt;span&gt;v&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;{}) {
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
        &lt;span&gt;return&lt;/span&gt;
    }
    &lt;span&gt;switch&lt;/span&gt; &lt;span&gt;x&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;v&lt;/span&gt;.(&lt;span&gt;type&lt;/span&gt;) {
    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;:
        &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;Write&lt;/span&gt;(int32(len(&lt;span&gt;x&lt;/span&gt;)))
        &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;Write&lt;/span&gt;([]byte(&lt;span&gt;x&lt;/span&gt;))
    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;:
        &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;Write&lt;/span&gt;(int64(&lt;span&gt;x&lt;/span&gt;))
    &lt;span&gt;default&lt;/span&gt;:
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;err&lt;/span&gt; = &lt;span&gt;binary&lt;/span&gt;.&lt;span&gt;Write&lt;/span&gt;(&lt;span&gt;w&lt;/span&gt;.&lt;span&gt;w&lt;/span&gt;, &lt;span&gt;binary&lt;/span&gt;.&lt;span&gt;LittleEndian&lt;/span&gt;, &lt;span&gt;v&lt;/span&gt;); &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;err&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
            &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;size&lt;/span&gt; &lt;span&gt;+=&lt;/span&gt; int64(&lt;span&gt;binary&lt;/span&gt;.&lt;span&gt;Size&lt;/span&gt;(&lt;span&gt;v&lt;/span&gt;))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;进入不同分支，&lt;code&gt;x&lt;/code&gt; 变量对应的就是该分支的类型。&lt;/p&gt;
&lt;h2 id=&quot;自行决定是否写入&quot;&gt;自行决定是否写入&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;binWriter&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; {
    &lt;span&gt;w&lt;/span&gt;   &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;Writer&lt;/span&gt;
    &lt;span&gt;buf&lt;/span&gt; &lt;span&gt;bytes&lt;/span&gt;.&lt;span&gt;Buffer&lt;/span&gt;
    &lt;span&gt;err&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;
}

&lt;span&gt;// Write writes a value to the provided writer in little endian form.
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;w&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;binWriter&lt;/span&gt;) &lt;span&gt;Write&lt;/span&gt;(&lt;span&gt;v&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;{}) {
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
        &lt;span&gt;return&lt;/span&gt;
    }
    &lt;span&gt;switch&lt;/span&gt; &lt;span&gt;x&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;v&lt;/span&gt;.(&lt;span&gt;type&lt;/span&gt;) {
    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;:
        &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;Write&lt;/span&gt;(int32(len(&lt;span&gt;x&lt;/span&gt;)))
        &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;Write&lt;/span&gt;([]byte(&lt;span&gt;x&lt;/span&gt;))
    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;:
        &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;Write&lt;/span&gt;(int64(&lt;span&gt;x&lt;/span&gt;))
    &lt;span&gt;default&lt;/span&gt;:
        &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;err&lt;/span&gt; = &lt;span&gt;binary&lt;/span&gt;.&lt;span&gt;Write&lt;/span&gt;(&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;.&lt;span&gt;buf&lt;/span&gt;, &lt;span&gt;binary&lt;/span&gt;.&lt;span&gt;LittleEndian&lt;/span&gt;, &lt;span&gt;v&lt;/span&gt;)
    }
}

&lt;span&gt;// Flush writes any pending values into the writer if no error has occurred.
&lt;/span&gt;&lt;span&gt;// If an error has occurred, earlier or with a write by Flush, the error is
&lt;/span&gt;&lt;span&gt;// returned.
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;w&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;binWriter&lt;/span&gt;) &lt;span&gt;Flush&lt;/span&gt;() (&lt;span&gt;int64&lt;/span&gt;, &lt;span&gt;error&lt;/span&gt;) {
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;err&lt;/span&gt;
    }
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;w&lt;/span&gt;.&lt;span&gt;buf&lt;/span&gt;.&lt;span&gt;WriteTo&lt;/span&gt;(&lt;span&gt;w&lt;/span&gt;.&lt;span&gt;w&lt;/span&gt;)
}

&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;g&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Gopher&lt;/span&gt;) &lt;span&gt;WriteTo&lt;/span&gt;(&lt;span&gt;w&lt;/span&gt; &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;Writer&lt;/span&gt;) (&lt;span&gt;int64&lt;/span&gt;, &lt;span&gt;error&lt;/span&gt;) {
    &lt;span&gt;bw&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;binWriter&lt;/span&gt;{&lt;span&gt;w&lt;/span&gt;: &lt;span&gt;w&lt;/span&gt;}
    &lt;span&gt;bw&lt;/span&gt;.&lt;span&gt;Write&lt;/span&gt;(&lt;span&gt;g&lt;/span&gt;.&lt;span&gt;Name&lt;/span&gt;)
    &lt;span&gt;bw&lt;/span&gt;.&lt;span&gt;Write&lt;/span&gt;(&lt;span&gt;g&lt;/span&gt;.&lt;span&gt;AgeYears&lt;/span&gt;)
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;bw&lt;/span&gt;.&lt;span&gt;Flush&lt;/span&gt;()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;WriteTo&lt;/code&gt; 方法中，分了两大部分，增加了灵活性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组装信息&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;Flush&lt;/code&gt; 方法来决定是否写入 &lt;code&gt;w&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;函数适配器&quot;&gt;函数适配器&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;() {
    &lt;span&gt;http&lt;/span&gt;.&lt;span&gt;HandleFunc&lt;/span&gt;(&lt;span&gt;&quot;/&quot;&lt;/span&gt;, &lt;span&gt;handler&lt;/span&gt;)
}

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;handler&lt;/span&gt;(&lt;span&gt;w&lt;/span&gt; &lt;span&gt;http&lt;/span&gt;.&lt;span&gt;ResponseWriter&lt;/span&gt;, &lt;span&gt;r&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;.&lt;span&gt;Request&lt;/span&gt;) {
    &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;doThis&lt;/span&gt;()
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
        &lt;span&gt;http&lt;/span&gt;.&lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;w&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt;.&lt;span&gt;Error&lt;/span&gt;(), &lt;span&gt;http&lt;/span&gt;.&lt;span&gt;StatusInternalServerError&lt;/span&gt;)
        &lt;span&gt;log&lt;/span&gt;.&lt;span&gt;Printf&lt;/span&gt;(&lt;span&gt;&quot;handling %q: %v&quot;&lt;/span&gt;, &lt;span&gt;r&lt;/span&gt;.&lt;span&gt;RequestURI&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt;)
        &lt;span&gt;return&lt;/span&gt;
    }

    &lt;span&gt;err&lt;/span&gt; = &lt;span&gt;doThat&lt;/span&gt;()
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
        &lt;span&gt;http&lt;/span&gt;.&lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;w&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt;.&lt;span&gt;Error&lt;/span&gt;(), &lt;span&gt;http&lt;/span&gt;.&lt;span&gt;StatusInternalServerError&lt;/span&gt;)
        &lt;span&gt;log&lt;/span&gt;.&lt;span&gt;Printf&lt;/span&gt;(&lt;span&gt;&quot;handling %q: %v&quot;&lt;/span&gt;, &lt;span&gt;r&lt;/span&gt;.&lt;span&gt;RequestURI&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt;)
        &lt;span&gt;return&lt;/span&gt;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;函数 &lt;code&gt;handler&lt;/code&gt; 包含了业务的逻辑和错误处理，下来将错误处理单独写一个函数处理，代码修改如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;() {
    &lt;span&gt;http&lt;/span&gt;.&lt;span&gt;HandleFunc&lt;/span&gt;(&lt;span&gt;&quot;/&quot;&lt;/span&gt;, &lt;span&gt;errorHandler&lt;/span&gt;(&lt;span&gt;betterHandler&lt;/span&gt;))
}

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;errorHandler&lt;/span&gt;(&lt;span&gt;f&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;(&lt;span&gt;http&lt;/span&gt;.&lt;span&gt;ResponseWriter&lt;/span&gt;, &lt;span&gt;*&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;.&lt;span&gt;Request&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt;) &lt;span&gt;http&lt;/span&gt;.&lt;span&gt;HandlerFunc&lt;/span&gt; {
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;(&lt;span&gt;w&lt;/span&gt; &lt;span&gt;http&lt;/span&gt;.&lt;span&gt;ResponseWriter&lt;/span&gt;, &lt;span&gt;r&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;.&lt;span&gt;Request&lt;/span&gt;) {
        &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;(&lt;span&gt;w&lt;/span&gt;, &lt;span&gt;r&lt;/span&gt;)
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
            &lt;span&gt;http&lt;/span&gt;.&lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;w&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt;.&lt;span&gt;Error&lt;/span&gt;(), &lt;span&gt;http&lt;/span&gt;.&lt;span&gt;StatusInternalServerError&lt;/span&gt;)
            &lt;span&gt;log&lt;/span&gt;.&lt;span&gt;Printf&lt;/span&gt;(&lt;span&gt;&quot;handling %q: %v&quot;&lt;/span&gt;, &lt;span&gt;r&lt;/span&gt;.&lt;span&gt;RequestURI&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt;)
        }
    }
}

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;betterHandler&lt;/span&gt;(&lt;span&gt;w&lt;/span&gt; &lt;span&gt;http&lt;/span&gt;.&lt;span&gt;ResponseWriter&lt;/span&gt;, &lt;span&gt;r&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;.&lt;span&gt;Request&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt; {
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;doThis&lt;/span&gt;(); &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Errorf&lt;/span&gt;(&lt;span&gt;&quot;doing this: %v&quot;&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt;)
    }

    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;doThat&lt;/span&gt;(); &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Errorf&lt;/span&gt;(&lt;span&gt;&quot;doing that: %v&quot;&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt;)
    }
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&quot;组织你的代码&quot;&gt;组织你的代码&lt;/h2&gt;
&lt;h3 id=&quot;1-先写最重要的&quot;&gt;1. 先写最重要的&lt;/h3&gt;
&lt;p&gt;许可信息、构建信息、包文档。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;import&lt;/code&gt; 语句：相关联组使用空行分隔。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;import&lt;/span&gt; (
    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;
    &lt;span&gt;&quot;io&quot;&lt;/span&gt;
    &lt;span&gt;&quot;log&quot;&lt;/span&gt;

    &lt;span&gt;&quot;golang.org/x/net/websocket&quot;&lt;/span&gt;
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其余代码，以最重要的类型开始，以辅助函数和类型结尾。&lt;/p&gt;
&lt;h3 id=&quot;2-文档注释&quot;&gt;2. 文档注释&lt;/h3&gt;
&lt;p&gt;包名前的相关文档。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// Package playground registers an HTTP handler at &quot;/compile&quot; that
&lt;/span&gt;&lt;span&gt;// proxies requests to the golang.org playground service.
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;package&lt;/span&gt; &lt;span&gt;playground&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Go 语言中的标示符（变量、结构体等等）在 godoc 导出的文章中应该被正确的记录下来。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// Author represents the person who wrote and/or is presenting the document.
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Author&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; {
    &lt;span&gt;Elem&lt;/span&gt; []&lt;span&gt;Elem&lt;/span&gt;
}

&lt;span&gt;// TextElem returns the first text elements of the author details.
&lt;/span&gt;&lt;span&gt;// This is used to display the author&#x27; name, job title, and company
&lt;/span&gt;&lt;span&gt;// without the contact details.
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;p&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Author&lt;/span&gt;) &lt;span&gt;TextElem&lt;/span&gt;() (&lt;span&gt;elems&lt;/span&gt; []&lt;span&gt;Elem&lt;/span&gt;) {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;扩展&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;使用 godoc 工具在网页上查看 go 项目文档。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span&gt;# 安装&lt;/span&gt;
go get golang.org/x/tools/cmd/godoc

&lt;span&gt;# 启动服务&lt;/span&gt;
godoc -http&lt;span&gt;=&lt;/span&gt;:6060
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;直接在本地访问 &lt;a href=&quot;http://localhost:6060&quot; target=&quot;_blank&quot;&gt;localhost:6060&lt;/a&gt;
 查看文档。&lt;/p&gt;
&lt;h3 id=&quot;3-命名尽可能简洁&quot;&gt;3. 命名尽可能简洁&lt;/h3&gt;
&lt;p&gt;或者说，长命名不一定好。&lt;/p&gt;
&lt;p&gt;尽可能找到一个可以清晰表达的简短命名，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MarshalIndent&lt;/code&gt; 比 &lt;code&gt;MarshalWithIndentation&lt;/code&gt; 好。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不要忘了，在调用包内容时，会先写包名。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;encoding/json&lt;/code&gt; 包内，有一个结构体 &lt;code&gt;Encoder&lt;/code&gt;，不要写成 &lt;code&gt;JSONEncoder&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;这样被使用 &lt;code&gt;json.Encoder&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;4-多文件包&quot;&gt;4. 多文件包&lt;/h3&gt;
&lt;p&gt;是否应该将一个包拆分到多个文件？&lt;/p&gt;

&lt;p&gt;标准包 &lt;code&gt;net/http&lt;/code&gt; 总共 15734 行代码，被拆分到 47 个文件中。&lt;/p&gt;

&lt;p&gt;net/http/cookie.go 和 net/http/cookie_test.go 文件都放置在 http 包下。&lt;/p&gt;
&lt;p&gt;测试代码&lt;strong&gt;只有&lt;/strong&gt;在测试时才被编译。&lt;/p&gt;

&lt;p&gt;当在一个包内有多个文件时，按照惯例，创建一个 doc.go 文件编写包的文档描述。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人思考&lt;/strong&gt;：当一个包的说明信息比较多时，可以考虑创建 doc.go 文件。&lt;/p&gt;
&lt;h3 id=&quot;5-使用-go-get-可获取你的包&quot;&gt;5. 使用 go get 可获取你的包&lt;/h3&gt;
&lt;p&gt;当你的包被提供使用时，应该清晰的让使用者知道哪些可复用，哪些不可复用。&lt;/p&gt;
&lt;p&gt;所以，当一些包可能会被复用，有些则不会的情况下怎么做？&lt;/p&gt;
&lt;p&gt;例如：定义一些网络协议的包可能会复用，而定义一些可执行命令的包则不会。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-fluid&quot; src=&quot;../images/2-1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cmd&lt;/code&gt; 可执行命令的包，不提供复用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pkg&lt;/code&gt; 可复用的包&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;个人思考&lt;/strong&gt;：如果一个项目中的可执行入口比较多，建议放置在 cmd 目录中，而对于 pkg 目录目前是不太建议，所以不用借鉴。&lt;/p&gt;
&lt;h2 id=&quot;api&quot;&gt;API&lt;/h2&gt;
&lt;h3 id=&quot;1-了解自己的需求&quot;&gt;1. 了解自己的需求&lt;/h3&gt;
&lt;p&gt;我们继续使用之前的 Gopher 类型。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Gopher&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; {
    &lt;span&gt;Name&lt;/span&gt;     &lt;span&gt;string&lt;/span&gt;
    &lt;span&gt;AgeYears&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以定义这个方法。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;g&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Gopher&lt;/span&gt;) &lt;span&gt;WriteToFile&lt;/span&gt;(&lt;span&gt;f&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;os&lt;/span&gt;.&lt;span&gt;File&lt;/span&gt;) (&lt;span&gt;int64&lt;/span&gt;, &lt;span&gt;error&lt;/span&gt;) {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但方法的参数使用具体的类型时会变得难以测试，因此我们使用接口。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;g&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Gopher&lt;/span&gt;) &lt;span&gt;WriteToReadWriter&lt;/span&gt;(&lt;span&gt;rw&lt;/span&gt; &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;ReadWriter&lt;/span&gt;) (&lt;span&gt;int64&lt;/span&gt;, &lt;span&gt;error&lt;/span&gt;) {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;并且，当使用了接口后，我们应该只需定义我们所需要的方法。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;g&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Gopher&lt;/span&gt;) &lt;span&gt;WriteToWriter&lt;/span&gt;(&lt;span&gt;f&lt;/span&gt; &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;Writer&lt;/span&gt;) (&lt;span&gt;int64&lt;/span&gt;, &lt;span&gt;error&lt;/span&gt;) {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;2-保持包的独立性&quot;&gt;2. 保持包的独立性&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;import&lt;/span&gt; (
    &lt;span&gt;&quot;golang.org/x/talks/content/2013/bestpractices/funcdraw/drawer&quot;&lt;/span&gt;
    &lt;span&gt;&quot;golang.org/x/talks/content/2013/bestpractices/funcdraw/parser&quot;&lt;/span&gt;
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// Parse the text into an executable function.
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;f&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;parser&lt;/span&gt;.&lt;span&gt;Parse&lt;/span&gt;(&lt;span&gt;text&lt;/span&gt;)
  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
      &lt;span&gt;log&lt;/span&gt;.&lt;span&gt;Fatalf&lt;/span&gt;(&lt;span&gt;&quot;parse %q: %v&quot;&lt;/span&gt;, &lt;span&gt;text&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt;)
  }

  &lt;span&gt;// Create an image plotting the function.
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;m&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;drawer&lt;/span&gt;.&lt;span&gt;Draw&lt;/span&gt;(&lt;span&gt;f&lt;/span&gt;, &lt;span&gt;*&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;, &lt;span&gt;*&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;, &lt;span&gt;*&lt;/span&gt;&lt;span&gt;xmin&lt;/span&gt;, &lt;span&gt;*&lt;/span&gt;&lt;span&gt;xmax&lt;/span&gt;)

  &lt;span&gt;// Encode the image into the standard output.
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;err&lt;/span&gt; = &lt;span&gt;png&lt;/span&gt;.&lt;span&gt;Encode&lt;/span&gt;(&lt;span&gt;os&lt;/span&gt;.&lt;span&gt;Stdout&lt;/span&gt;, &lt;span&gt;m&lt;/span&gt;)
  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
      &lt;span&gt;log&lt;/span&gt;.&lt;span&gt;Fatalf&lt;/span&gt;(&lt;span&gt;&quot;encode image: %v&quot;&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt;)
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;代码中 &lt;code&gt;Draw&lt;/code&gt; 方法接受了 &lt;code&gt;Parse&lt;/code&gt; 函数返回的 &lt;code&gt;f&lt;/code&gt; 变量，从逻辑上看 &lt;code&gt;drawer&lt;/code&gt; 包依赖 &lt;code&gt;parser&lt;/code&gt; 包，下来看看如何取消这种依赖性。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;parser&lt;/code&gt; 包：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;ParsedFunc&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; {
    &lt;span&gt;text&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;
    &lt;span&gt;eval&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;(&lt;span&gt;float64&lt;/span&gt;) &lt;span&gt;float64&lt;/span&gt;
}

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Parse&lt;/span&gt;(&lt;span&gt;text&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) (&lt;span&gt;*&lt;/span&gt;&lt;span&gt;ParsedFunc&lt;/span&gt;, &lt;span&gt;error&lt;/span&gt;) {
    &lt;span&gt;f&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;parse&lt;/span&gt;(&lt;span&gt;text&lt;/span&gt;)
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt;
    }
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;ParsedFunc&lt;/span&gt;{&lt;span&gt;text&lt;/span&gt;: &lt;span&gt;text&lt;/span&gt;, &lt;span&gt;eval&lt;/span&gt;: &lt;span&gt;f&lt;/span&gt;}, &lt;span&gt;nil&lt;/span&gt;
}

&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;f&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;ParsedFunc&lt;/span&gt;) &lt;span&gt;Eval&lt;/span&gt;(&lt;span&gt;x&lt;/span&gt; &lt;span&gt;float64&lt;/span&gt;) &lt;span&gt;float64&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;.&lt;span&gt;eval&lt;/span&gt;(&lt;span&gt;x&lt;/span&gt;) }
&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;f&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;ParsedFunc&lt;/span&gt;) &lt;span&gt;String&lt;/span&gt;() &lt;span&gt;string&lt;/span&gt;         { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;.&lt;span&gt;text&lt;/span&gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;drawer&lt;/code&gt; 包：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;import&lt;/span&gt; (
    &lt;span&gt;&quot;image&quot;&lt;/span&gt;

    &lt;span&gt;&quot;golang.org/x/talks/content/2013/bestpractices/funcdraw/parser&quot;&lt;/span&gt;
)

&lt;span&gt;// Draw draws an image showing a rendering of the passed ParsedFunc.
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;DrawParsedFunc&lt;/span&gt;(&lt;span&gt;f&lt;/span&gt; &lt;span&gt;parser&lt;/span&gt;.&lt;span&gt;ParsedFunc&lt;/span&gt;) &lt;span&gt;image&lt;/span&gt;.&lt;span&gt;Image&lt;/span&gt; {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用接口类型，避免依赖。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;image&quot;&lt;/span&gt;

&lt;span&gt;// Function represent a drawable mathematical function.
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Function&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; {
    &lt;span&gt;Eval&lt;/span&gt;(&lt;span&gt;float64&lt;/span&gt;) &lt;span&gt;float64&lt;/span&gt;
}

&lt;span&gt;// Draw draws an image showing a rendering of the passed Function.
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Draw&lt;/span&gt;(&lt;span&gt;f&lt;/span&gt; &lt;span&gt;Function&lt;/span&gt;) &lt;span&gt;image&lt;/span&gt;.&lt;span&gt;Image&lt;/span&gt; {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;测试&lt;/strong&gt;：接口类型比具体类型更容易测试。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;package&lt;/span&gt; &lt;span&gt;drawer&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt; (
    &lt;span&gt;&quot;math&quot;&lt;/span&gt;
    &lt;span&gt;&quot;testing&quot;&lt;/span&gt;
)

&lt;span&gt;type&lt;/span&gt; &lt;span&gt;TestFunc&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;(&lt;span&gt;float64&lt;/span&gt;) &lt;span&gt;float64&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;f&lt;/span&gt; &lt;span&gt;TestFunc&lt;/span&gt;) &lt;span&gt;Eval&lt;/span&gt;(&lt;span&gt;x&lt;/span&gt; &lt;span&gt;float64&lt;/span&gt;) &lt;span&gt;float64&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;(&lt;span&gt;x&lt;/span&gt;) }

&lt;span&gt;var&lt;/span&gt; (
    &lt;span&gt;ident&lt;/span&gt; = &lt;span&gt;TestFunc&lt;/span&gt;(&lt;span&gt;func&lt;/span&gt;(&lt;span&gt;x&lt;/span&gt; &lt;span&gt;float64&lt;/span&gt;) &lt;span&gt;float64&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;x&lt;/span&gt; })
    &lt;span&gt;sin&lt;/span&gt;   = &lt;span&gt;TestFunc&lt;/span&gt;(&lt;span&gt;math&lt;/span&gt;.&lt;span&gt;Sin&lt;/span&gt;)
)

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestDraw_Ident&lt;/span&gt;(&lt;span&gt;t&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;testing&lt;/span&gt;.&lt;span&gt;T&lt;/span&gt;) {
    &lt;span&gt;m&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;Draw&lt;/span&gt;(&lt;span&gt;ident&lt;/span&gt;)
    &lt;span&gt;// Verify obtained image.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;4-避免在内部使用并发&quot;&gt;4. 避免在内部使用并发&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;doConcurrently&lt;/span&gt;(&lt;span&gt;job&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;) {
    &lt;span&gt;go&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;() {
        &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;&quot;doing job&quot;&lt;/span&gt;, &lt;span&gt;job&lt;/span&gt;)
        &lt;span&gt;time&lt;/span&gt;.&lt;span&gt;Sleep&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;.&lt;span&gt;Second&lt;/span&gt;)
        &lt;span&gt;err&lt;/span&gt; &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;errors&lt;/span&gt;.&lt;span&gt;New&lt;/span&gt;(&lt;span&gt;&quot;something went wrong!&quot;&lt;/span&gt;)
    }()
}

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;() {
    &lt;span&gt;jobs&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; []&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;one&quot;&lt;/span&gt;, &lt;span&gt;&quot;two&quot;&lt;/span&gt;, &lt;span&gt;&quot;three&quot;&lt;/span&gt;}

    &lt;span&gt;errc&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; make(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;)
    &lt;span&gt;for&lt;/span&gt; &lt;span&gt;_&lt;/span&gt;, &lt;span&gt;job&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt; &lt;span&gt;jobs&lt;/span&gt; {
        &lt;span&gt;doConcurrently&lt;/span&gt;(&lt;span&gt;job&lt;/span&gt;, &lt;span&gt;errc&lt;/span&gt;)
    }
    &lt;span&gt;for&lt;/span&gt; &lt;span&gt;_&lt;/span&gt; = &lt;span&gt;range&lt;/span&gt; &lt;span&gt;jobs&lt;/span&gt; {
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&amp;lt;-&lt;/span&gt;&lt;span&gt;errc&lt;/span&gt;; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
            &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;err&lt;/span&gt;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果这样做，那如果我们想同步调用 &lt;code&gt;doConcurrently&lt;/code&gt; 该如何做？&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;(&lt;span&gt;job&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt; {
    &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;&quot;doing job&quot;&lt;/span&gt;, &lt;span&gt;job&lt;/span&gt;)
    &lt;span&gt;time&lt;/span&gt;.&lt;span&gt;Sleep&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;.&lt;span&gt;Second&lt;/span&gt;)
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;errors&lt;/span&gt;.&lt;span&gt;New&lt;/span&gt;(&lt;span&gt;&quot;something went wrong!&quot;&lt;/span&gt;)
}

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;() {
    &lt;span&gt;jobs&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; []&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;one&quot;&lt;/span&gt;, &lt;span&gt;&quot;two&quot;&lt;/span&gt;, &lt;span&gt;&quot;three&quot;&lt;/span&gt;}

    &lt;span&gt;errc&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; make(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;)
    &lt;span&gt;for&lt;/span&gt; &lt;span&gt;_&lt;/span&gt;, &lt;span&gt;job&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt; &lt;span&gt;jobs&lt;/span&gt; {
        &lt;span&gt;go&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;(&lt;span&gt;job&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) {
            &lt;span&gt;errc&lt;/span&gt; &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;(&lt;span&gt;job&lt;/span&gt;)
        }(&lt;span&gt;job&lt;/span&gt;)
    }
    &lt;span&gt;for&lt;/span&gt; &lt;span&gt;_&lt;/span&gt; = &lt;span&gt;range&lt;/span&gt; &lt;span&gt;jobs&lt;/span&gt; {
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&amp;lt;-&lt;/span&gt;&lt;span&gt;errc&lt;/span&gt;; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
            &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;err&lt;/span&gt;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对外暴露同步的函数，这样并发调用时也是容易的，同样也满足同步调用。&lt;/p&gt;
&lt;h2 id=&quot;最佳的并发实践&quot;&gt;最佳的并发实践&lt;/h2&gt;
&lt;h3 id=&quot;1-使用-goroutine-管理状态&quot;&gt;1. 使用 Goroutine 管理状态&lt;/h3&gt;
&lt;p&gt;Goroutine 之间使用一个 “通道” 或带有通道字段的 “结构体” 来通信。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Server&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{ &lt;span&gt;quit&lt;/span&gt; &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; }

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewServer&lt;/span&gt;() &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Server&lt;/span&gt; {
    &lt;span&gt;s&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;Server&lt;/span&gt;{make(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;)}
    &lt;span&gt;go&lt;/span&gt; &lt;span&gt;s&lt;/span&gt;.&lt;span&gt;run&lt;/span&gt;()
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;s&lt;/span&gt;
}

&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;s&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Server&lt;/span&gt;) &lt;span&gt;run&lt;/span&gt;() {
    &lt;span&gt;for&lt;/span&gt; {
        &lt;span&gt;select&lt;/span&gt; {
        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&amp;lt;-&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;.&lt;span&gt;quit&lt;/span&gt;:
            &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;&quot;finishing task&quot;&lt;/span&gt;)
            &lt;span&gt;time&lt;/span&gt;.&lt;span&gt;Sleep&lt;/span&gt;(&lt;span&gt;time&lt;/span&gt;.&lt;span&gt;Second&lt;/span&gt;)
            &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;&quot;task done&quot;&lt;/span&gt;)
            &lt;span&gt;s&lt;/span&gt;.&lt;span&gt;quit&lt;/span&gt; &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;
        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&amp;lt;-&lt;/span&gt;&lt;span&gt;time&lt;/span&gt;.&lt;span&gt;After&lt;/span&gt;(&lt;span&gt;time&lt;/span&gt;.&lt;span&gt;Second&lt;/span&gt;):
            &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;&quot;running task&quot;&lt;/span&gt;)
        }
    }
}

&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;s&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Server&lt;/span&gt;) &lt;span&gt;Stop&lt;/span&gt;() {
    &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;&quot;server stopping&quot;&lt;/span&gt;)
    &lt;span&gt;s&lt;/span&gt;.&lt;span&gt;quit&lt;/span&gt; &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;
    &lt;span&gt;&amp;lt;-&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;.&lt;span&gt;quit&lt;/span&gt;
    &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;&quot;server stopped&quot;&lt;/span&gt;)
}

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;() {
    &lt;span&gt;s&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;NewServer&lt;/span&gt;()
    &lt;span&gt;time&lt;/span&gt;.&lt;span&gt;Sleep&lt;/span&gt;(&lt;span&gt;2&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;.&lt;span&gt;Second&lt;/span&gt;)
    &lt;span&gt;s&lt;/span&gt;.&lt;span&gt;Stop&lt;/span&gt;()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;2-使用带缓冲的通道避免-goroutine-泄露&quot;&gt;2. 使用带缓冲的通道避免 Goroutine 泄露&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;sendMsg&lt;/span&gt;(&lt;span&gt;msg&lt;/span&gt;, &lt;span&gt;addr&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt; {
    &lt;span&gt;conn&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;net&lt;/span&gt;.&lt;span&gt;Dial&lt;/span&gt;(&lt;span&gt;&quot;tcp&quot;&lt;/span&gt;, &lt;span&gt;addr&lt;/span&gt;)
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;err&lt;/span&gt;
    }
    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;conn&lt;/span&gt;.&lt;span&gt;Close&lt;/span&gt;()
    &lt;span&gt;_&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; = &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Fprint&lt;/span&gt;(&lt;span&gt;conn&lt;/span&gt;, &lt;span&gt;msg&lt;/span&gt;)
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;err&lt;/span&gt;
}

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;() {
    &lt;span&gt;addr&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; []&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;localhost:8080&quot;&lt;/span&gt;, &lt;span&gt;&quot;http://google.com&quot;&lt;/span&gt;}
    &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;broadcastMsg&lt;/span&gt;(&lt;span&gt;&quot;hi&quot;&lt;/span&gt;, &lt;span&gt;addr&lt;/span&gt;)

    &lt;span&gt;time&lt;/span&gt;.&lt;span&gt;Sleep&lt;/span&gt;(&lt;span&gt;time&lt;/span&gt;.&lt;span&gt;Second&lt;/span&gt;)

    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
        &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;err&lt;/span&gt;)
        &lt;span&gt;return&lt;/span&gt;
    }
    &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;&quot;everything went fine&quot;&lt;/span&gt;)
}

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;broadcastMsg&lt;/span&gt;(&lt;span&gt;msg&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;addrs&lt;/span&gt; []&lt;span&gt;string&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt; {
    &lt;span&gt;errc&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; make(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;)
    &lt;span&gt;for&lt;/span&gt; &lt;span&gt;_&lt;/span&gt;, &lt;span&gt;addr&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt; &lt;span&gt;addrs&lt;/span&gt; {
        &lt;span&gt;go&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;(&lt;span&gt;addr&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) {
            &lt;span&gt;errc&lt;/span&gt; &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;sendMsg&lt;/span&gt;(&lt;span&gt;msg&lt;/span&gt;, &lt;span&gt;addr&lt;/span&gt;)
            &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;&quot;done&quot;&lt;/span&gt;)
        }(&lt;span&gt;addr&lt;/span&gt;)
    }

    &lt;span&gt;for&lt;/span&gt; &lt;span&gt;_&lt;/span&gt; = &lt;span&gt;range&lt;/span&gt; &lt;span&gt;addrs&lt;/span&gt; {
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&amp;lt;-&lt;/span&gt;&lt;span&gt;errc&lt;/span&gt;; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;err&lt;/span&gt;
        }
    }
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段代码有个问题，如果提前返回了 &lt;code&gt;err&lt;/code&gt; 变量，&lt;code&gt;errc&lt;/code&gt; 通道将不会被读取，因此 Goroutine 将会阻塞。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在写入通道时 Goroutine 被阻塞。&lt;/li&gt;
&lt;li&gt;Goroutine 持有对通道的引用。&lt;/li&gt;
&lt;li&gt;通道不会被 gc 回收。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用缓冲通道解决 Goroutine 阻塞问题。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;broadcastMsg&lt;/span&gt;(&lt;span&gt;msg&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;addrs&lt;/span&gt; []&lt;span&gt;string&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt; {
    &lt;span&gt;errc&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; make(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;, len(&lt;span&gt;addrs&lt;/span&gt;))
    &lt;span&gt;for&lt;/span&gt; &lt;span&gt;_&lt;/span&gt;, &lt;span&gt;addr&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt; &lt;span&gt;addrs&lt;/span&gt; {
        &lt;span&gt;go&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;(&lt;span&gt;addr&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) {
            &lt;span&gt;errc&lt;/span&gt; &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;sendMsg&lt;/span&gt;(&lt;span&gt;msg&lt;/span&gt;, &lt;span&gt;addr&lt;/span&gt;)
            &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;&quot;done&quot;&lt;/span&gt;)
        }(&lt;span&gt;addr&lt;/span&gt;)
    }

    &lt;span&gt;for&lt;/span&gt; &lt;span&gt;_&lt;/span&gt; = &lt;span&gt;range&lt;/span&gt; &lt;span&gt;addrs&lt;/span&gt; {
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&amp;lt;-&lt;/span&gt;&lt;span&gt;errc&lt;/span&gt;; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;err&lt;/span&gt;
        }
    }
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果我们不能预知通道的缓冲大小，也称容量，那该怎么办？&lt;/p&gt;
&lt;p&gt;创建一个传递退出状态的通道来避免 Goroutine 的泄露。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;broadcastMsg&lt;/span&gt;(&lt;span&gt;msg&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;addrs&lt;/span&gt; []&lt;span&gt;string&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt; {
    &lt;span&gt;errc&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; make(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;)
    &lt;span&gt;quit&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; make(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{})

    &lt;span&gt;defer&lt;/span&gt; close(&lt;span&gt;quit&lt;/span&gt;)

    &lt;span&gt;for&lt;/span&gt; &lt;span&gt;_&lt;/span&gt;, &lt;span&gt;addr&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt; &lt;span&gt;addrs&lt;/span&gt; {
        &lt;span&gt;go&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;(&lt;span&gt;addr&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) {
            &lt;span&gt;select&lt;/span&gt; {
            &lt;span&gt;case&lt;/span&gt; &lt;span&gt;errc&lt;/span&gt; &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;sendMsg&lt;/span&gt;(&lt;span&gt;msg&lt;/span&gt;, &lt;span&gt;addr&lt;/span&gt;):
                &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;&quot;done&quot;&lt;/span&gt;)
            &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&amp;lt;-&lt;/span&gt;&lt;span&gt;quit&lt;/span&gt;:
                &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;&quot;quit&quot;&lt;/span&gt;)
            }
        }(&lt;span&gt;addr&lt;/span&gt;)
    }

    &lt;span&gt;for&lt;/span&gt; &lt;span&gt;_&lt;/span&gt; = &lt;span&gt;range&lt;/span&gt; &lt;span&gt;addrs&lt;/span&gt; {
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&amp;lt;-&lt;/span&gt;&lt;span&gt;errc&lt;/span&gt;; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;err&lt;/span&gt;
        }
    }
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://talks.golang.org/2013/bestpractices.slide#1&quot; target=&quot;_blank&quot;&gt;https://talks.golang.org/2013/bestpractices.slide#1&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;视频链接：&lt;a href=&quot;https://www.youtube.com/watch?v=8D3Vmm1BGoY&quot; target=&quot;_blank&quot;&gt;https://www.youtube.com/watch?v=8D3Vmm1BGoY&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>adeb1e4b838ac2c1b85c14df28045226</guid>
<title>如何在 Kubernetes 集群中玩转 Fluid + JuiceFS</title>
<link>https://toutiao.io/k/nia5sc1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post_content markdown&quot;&gt;&lt;p&gt;云知声 Atlas 团队在 2021 年初开始接触并跟进 JuiceFS 存储，并且在早期已经积累了丰富的 Fluid 使用经验。近期，云知声团队与 Juicedata 团队合作开发了 Fluid JuiceFS 加速引擎，使用户能够更好地在 Kubernetes 环境中使用 JuiceFS 缓存管理能力。本篇文章讲解如何在 Kubernetes 集群中玩转 Fluid + JuiceFS。&lt;/p&gt;&lt;h2 id=&quot;背景介绍&quot;&gt;背景介绍&lt;/h2&gt;&lt;h3 id=&quot;fluid-简介&quot;&gt;Fluid 简介&lt;/h3&gt;&lt;p&gt;CNCF Fluid 是一个开源的 Kubernetes 原生的分布式数据集编排和加速引擎，主要服务于云原生场景下的数据密集型应用，例如大数据应用、AI 应用等，关于 Fluid 更多信息可以&lt;a href=&quot;https://github.com/fluid-cloudnative/fluid&quot;&gt;参考地址&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;Fluid 不是全存储加速和管理，而是应用使用的数据集加速和管理。Fluid 提供了一种更加云原生的方式对数据集进行管理，通过缓存加速引擎实现将底层存储系统的数据 cache 在计算节点的内存或者硬盘上，解决了计算与存储分离架构中由于数据传输带宽限制以及底层存储带宽与 IOPS 能力限制等问题，导致的 IO 效率不高等问题。Fluid 提供缓存数据调度能力，缓存被纳入 Kubernetes 扩展资源，Kubernetes 在进行任务的调度的时候，能够参考缓存进行调度策略的分配。&lt;/p&gt;&lt;p&gt;Fluid 有 2 个重要的概念：&lt;strong&gt;Dataset 与 Runtime&lt;/strong&gt;。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Dataset：数据集是逻辑上相关的一组数据的集合，一致的文件特性，会被同一运算引擎使用。&lt;/li&gt;&lt;li&gt;Runtime：实现数据集安全性，版本管理和数据加速等能力的执行引擎的接口，定义了一系列生命周期的方法。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Fluid 的 Runtime 定义了标准化的接口，Cache Runtime Engine 可以对接多种缓存引擎，提供了用户更灵活的选择，用户能够针对不同的场景与需求，充分利用缓存引擎加速相应的场景应用。&lt;/p&gt;&lt;h3 id=&quot;juicefs-简介&quot;&gt;JuiceFS 简介&lt;/h3&gt;&lt;p&gt;JuiceFS 是一个面向云环境设计的高性能开源分布式文件系统，完全兼容 POSIX、HDFS、S3 接口，适用于大数据、AI 模型训练、Kubernetes 共享存储、海量数据归档管理等场景。&lt;/p&gt;&lt;p&gt;使用 JuiceFS 存储数据，数据本身会被持久化在对象存储（例如，Amazon S3），而数据所对应的元数据可以根据场景需求被持久化在 Redis、MySQL、TiKV 等多种数据库引擎中。JuiceFS 客户端具有数据缓存能力，当通过 JuiceFS 客户端读取数据时，这些数据将会智能地缓存到应用配置的本地缓存路径（可以是内存，也可以是磁盘），同时元数据也会缓存到客户端节点本地内存中。&lt;/p&gt;&lt;p&gt;对于 AI 模型训练场景来说，第一个 epoch 完成之后后续的计算都可以直接从缓存中获取训练数据，极大地提升了训练效率。JuiceFS 也具有预读、并发读取数据的能力，在 AI 训练场景能够保证每个 mini-batch 的生成效率，提前准备好数据。数据预热能够提前将公有云上的数据换到到本地节点，对于 AI 训练场景能够保证申请完 GPU 资源后，即有预热的数据进行运算，为宝贵的 GPU 使用节省了时间。&lt;/p&gt;&lt;h2 id=&quot;为什么使用-juicefsruntime&quot;&gt;为什么使用 JuiceFSRuntime&lt;/h2&gt;&lt;p&gt;云知声 Atlas 超算平台作为底层基础架构，支持着公司在 AI 各个领域的模型训练与推理服务的开展。云知声很早就开始布局建设业界领先的 GPU/CPU 异构 Atlas 计算平台和分布式文件存储系统，该计算集群可为 AI 计算提供高性能计算和海量数据的存储访问能力。云知声 Atlas 团队在 2021 年初开始接触并跟进 JuiceFS 存储，进行了一系列 POC 测试，在数据可靠性与业务场景的适配，都满足我们目前的需求。&lt;/p&gt;&lt;p&gt;在训练场景我们充分利用 JuiceFS 客户端的缓存能力，为 AI 模型训练做数据加速，但是在使用过程中发现了一些问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;训练 Pod 通过 hostpath 挂载，需要在每个计算节点挂载 JuiceFS 客户端，挂载需要管理员操作，挂载参数固定，不够灵活。&lt;/li&gt;&lt;li&gt;用户无法对计算节点客户端的缓存管理，缓存无法手动清理与扩容。&lt;/li&gt;&lt;li&gt;缓存数据集无法像 Kubernetes 自定义资源一样能够被 Kubernetes 进行调度。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;由于我们在生产环境已经积累了一定的 Fluid 使用经验，所以我们与 Juicedata 团队合作设计并开发了 JuiceFSRuntime，将 Fluid 对数据编排与管理能力和 JuiceFS 的缓存能力结合起来。&lt;/p&gt;&lt;h2 id=&quot;什么是-fluid-juicefs-juicefsruntime&quot;&gt;什么是 Fluid + JuiceFS（JuiceFSRuntime）&lt;/h2&gt;&lt;p&gt;JuiceFSRuntime 是 Fluid 自定义的一种 Runtime，其中可以指定 JuiceFS 的 worker、FUSE 镜像以及相应的缓存参数。其构建方式与 Fluid 其他 Runtime 一致，即通过 CRD 的方式构建，JuiceFSRuntime Controller 监听 JuiceFSRuntime 资源，实现缓存 Pod 的管理。&lt;/p&gt;&lt;p&gt;JuiceFSRuntime 支持数据亲和性调度（&lt;code&gt;nodeAffinity&lt;/code&gt;），选择合适的缓存节点，支持 FUSE pod 懒启动，支持用户以 POSIX 接口访问数据，目前只支持一个挂载点。&lt;/p&gt;&lt;p&gt;其架构图如上图所示，JuiceFSRuntime 由 FUSE Pod 与 Worker Pod 组成。Worker pod 主要实现缓存的管理，如 Runtime 退出时的缓存清理；FUSE pod 主要负责 JuiceFS 客户端的参数设置及挂载。&lt;/p&gt;&lt;h2 id=&quot;如何使用-juicefsrunime&quot;&gt;如何使用 JuiceFSRunime&lt;/h2&gt;&lt;p&gt;下面来看看如何使用 JuiceFSRuntime 进行缓存加速。&lt;/p&gt;&lt;h3 id=&quot;前期准备&quot;&gt;前期准备&lt;/h3&gt;&lt;p&gt;要使用 JuiceFSRuntime 首先需要准备元数据引擎和对象存储。&lt;/p&gt;&lt;h4 id=&quot;构建元数据引擎&quot;&gt;构建元数据引擎&lt;/h4&gt;&lt;p&gt;用户可以很容易的在云计算平台购买到各种配置的云 Redis 数据库，如果是评估测试可以使用 Docker 快速的在服务器上运行一个 Redis 数据库实例：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ sudo docker run -d --name redis \
    -v redis-data:/data \
    -p 6379:6379 \
    --restart unless-stopped \
    redis redis-server --appendonly yes
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;准备对象存储&quot;&gt;准备对象存储&lt;/h4&gt;&lt;p&gt;和 Redis 数据库一样，几乎所有的公有云计算平台都提供对象存储服务。因为 JuiceFS 支持几乎所有主流平台的对象存储服务，用户可以结合自己的情况进行部署。&lt;/p&gt;&lt;p&gt;这里评估测试使用的是 Docker 运行的 MinIO 实例：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ sudo docker run -d --name minio \
    -p 9000:9000 \
    -p 9900:9900 \
    -v $PWD/minio-data:/data \
    --restart unless-stopped \
    minio/minio server /data --console-address &quot;:9900&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对象存储初始的 Access Key 和 Secret Key 均为 &lt;code&gt;minioadmin&lt;/code&gt;。&lt;/p&gt;&lt;h3 id=&quot;下载并安装-fluid&quot;&gt;下载并安装 Fluid&lt;/h3&gt;&lt;p&gt;按照&lt;a href=&quot;https://github.com/fluid-cloudnative/fluid/blob/master/docs/zh/samples/juicefs_runtime.md&quot;&gt;文档&lt;/a&gt;步骤安装 Fluid，在 Fluid 的安装 &lt;code&gt;chart values.yaml&lt;/code&gt; 中将 &lt;code&gt;runtime.juicefs.enable&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt;，并安装 Fluid。确保 Fluid 集群正常运行：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ kubectl get po -n fluid-system
NAME                                         READY   STATUS              RESTARTS   AGE
csi-nodeplugin-fluid-ctc4l                   2/2     Running             0          113s
csi-nodeplugin-fluid-k7cqt                   2/2     Running             0          113s
csi-nodeplugin-fluid-x9dfd                   2/2     Running             0          113s
dataset-controller-57ddd56b54-9vd86          1/1     Running             0          113s
fluid-webhook-84467465f8-t65mr               1/1     Running             0          113s
juicefsruntime-controller-56df96b75f-qzq8x   1/1     Running             0          113s
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;确保 &lt;code&gt;juicefsruntime-controller&lt;/code&gt;、&lt;code&gt;dataset-controller&lt;/code&gt;、&lt;code&gt;fluid-webhook&lt;/code&gt; 的 pod 以及若干 &lt;code&gt;csi-nodeplugin&lt;/code&gt; pod 正常运行。&lt;/p&gt;&lt;h3 id=&quot;创建-dataset&quot;&gt;创建 Dataset&lt;/h3&gt;&lt;p&gt;在使用 JuiceFS 之前，需要提供元数据服务（如 Redis）及对象存储服务（如 MinIO）的参数，并创建对应的 secret:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ kubectl create secret generic jfs-secret \
    --from-literal=metaurl=redis://$IP:6379/1 \  # Redis 的地址，IP 为 Redis 所在节点的 IP
    --from-literal=access-key=minioadmin \       # 对象存储的 AK
    --from-literal=secret-key=minioadmin         # 对象存储的 SK
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建 Dataset YAML 文件：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;cat&amp;lt;&amp;lt;EOF &amp;gt;dataset.yaml
apiVersion: data.fluid.io/v1alpha1
kind: Dataset
metadata:
  name: jfsdemo
spec:
  mounts:
    - name: minio
      mountPoint: &quot;juicefs:///demo&quot;
      options:
        bucket: &quot;&amp;lt;bucket&amp;gt;&quot;
        storage: &quot;minio&quot;
      encryptOptions:
        - name: metaurl
          valueFrom:
            secretKeyRef:
              name: jfs-secret
              key: metaurl
        - name: access-key
          valueFrom:
            secretKeyRef:
              name: jfs-secret
              key: access-key
        - name: secret-key
          valueFrom:
            secretKeyRef:
              name: jfs-secret
              key: secret-key
EOF
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于 JuiceFS 采用的是本地缓存，对应的 Dataset 只支持一个 mount，且 JuiceFS 没有 UFS，&lt;code&gt;mountPoint&lt;/code&gt; 中可以指定需要挂载的子目录 (&lt;code&gt;juicefs:///&lt;/code&gt; 为根路径)，会作为根目录挂载到容器内。&lt;/p&gt;&lt;p&gt;创建 Dataset 并查看 Dataset 状态：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ kubectl create -f dataset.yaml
dataset.data.fluid.io/jfsdemo created

$ kubectl get dataset jfsdemo
NAME      UFS TOTAL SIZE   CACHED   CACHE CAPACITY   CACHED PERCENTAGE   PHASE      AGE
jfsdemo                                                                  NotBound   44s
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如上所示，status 中的 phase 属性值为 NotBound，这意味着该 Dataset 资源对象目前还未与任何 JuiceFSRuntime 资源对象绑定，接下来，我们将创建一个 JuiceFSRuntime 资源对象。&lt;/p&gt;&lt;h3 id=&quot;创建-juicefsruntime&quot;&gt;创建 JuiceFSRuntime&lt;/h3&gt;&lt;p&gt;创建 JuiceFSRuntime 的 YAML 文件：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;$ cat&amp;lt;&amp;lt;EOF &amp;gt;runtime.yaml
apiVersion: data.fluid.io/v1alpha1
kind: JuiceFSRuntime
metadata:
  name: jfsdemo
spec:
  replicas: 1
  tieredstore:
    levels:
      - mediumtype: SSD
        path: /cache
        quota: 40960   # JuiceFS 中 quota 的最小单位是 MiB，所以这里是 40GiB
        low: &quot;0.1&quot;
EOF
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建并查看 JuiceFSRuntime：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ kubectl create -f runtime.yaml
juicefsruntime.data.fluid.io/jfsdemo created

$ kubectl get juicefsruntime
NAME      WORKER PHASE   FUSE PHASE   AGE
jfsdemo   Ready              Ready        72s
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看 JuiceFS 相关组件 Pod 的状态：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ kubectl get po | grep jfs
jfsdemo-worker-mjplw                                           1/1     Running   0          4m2s
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;JuiceFSRuntime 没有 master 组件，而 FUSE 组件实现了懒启动，会在 pod 使用时再创建。&lt;/p&gt;&lt;h3 id=&quot;创建缓存加速作业&quot;&gt;创建缓存加速作业&lt;/h3&gt;&lt;p&gt;创建需要加速的应用，其中 Pod 使用上面创建的 Dataset 的方式为指定同名的 PVC：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;$ cat&amp;lt;&amp;lt;EOF &amp;gt;sample.yaml
apiVersion: v1
kind: Pod
metadata:
  name: demo-app
spec:
  containers:
    - name: demo
      image: nginx
      volumeMounts:
        - mountPath: /data
          name: demo
  volumes:
    - name: demo
      persistentVolumeClaim:
        claimName: jfsdemo
EOF
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建 Pod：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ kubectl create -f sample.yaml
pod/demo-app created
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看 pod 状态：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ kubectl get po | grep demo
demo-app                                                       1/1     Running   0          31s
jfsdemo-fuse-fx7np                                             1/1     Running   0          31s
jfsdemo-worker-mjplw                                           1/1     Running   0          10m
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到 pod 已经创建成功，同时 JuiceFS 的 FUSE 组件也启动成功。&lt;/p&gt;&lt;p&gt;进入 Pod 执行 &lt;code&gt;df -hT&lt;/code&gt; 查看缓存目录是否挂载：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ kubectl exec -it demo-app  bash -- df -h
Filesystem      Size  Used Avail Use% Mounted on
overlay          20G   14G  5.9G  71% /
tmpfs            64M     0   64M   0% /dev
tmpfs           3.9G     0  3.9G   0% /sys/fs/cgroup
JuiceFS:minio   1.0P  7.9M  1.0P   1% /data
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到这时候缓存目录已经成功挂载了。&lt;/p&gt;&lt;p&gt;接下来，我们在 demo-app 这个 pod 中测试一下写功能：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ kubectl exec -it demo-app bash
[root@demo-app /]# df
Filesystem         1K-blocks     Used     Available Use% Mounted on
overlay             20751360 14585944       6165416  71% /
tmpfs                  65536        0         65536   0% /dev
tmpfs                3995028        0       3995028   0% /sys/fs/cgroup
JuiceFS:minio  1099511627776     8000 1099511619776   1% /data
/dev/sda2           20751360 14585944       6165416  71% /etc/hosts
shm                    65536        0         65536   0% /dev/shm
tmpfs                3995028       12       3995016   1% /run/secrets/kubernetes.io/serviceaccount
tmpfs                3995028        0       3995028   0% /proc/acpi
tmpfs                3995028        0       3995028   0% /proc/scsi
tmpfs                3995028        0       3995028   0% /sys/firmware
[root@demo-app /]#
[root@demo-app /]# cd /data
[root@demo-app data]# echo &quot;hello fluid&quot; &amp;gt; hello.txt
[root@demo-app data]# cat hello.txt
hello fluid
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后再来看看缓存功能，在 demo-app 这个 pod 中的挂载目录 &lt;code&gt;/data&lt;/code&gt; 中创建一个 1G 的文件，然后再 &lt;code&gt;cp&lt;/code&gt; 出来：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ kubectl exec -it demo-app  bash
root@demo-app:~# dd if=/dev/zero of=/data/test.txt count=1024 bs=1M
1024+0 records in
1024+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 6.55431 s, 164 MB/s
root@demo-app:~# time cp /data/test.txt ./test.txt
real0m5.014s
user0m0.003s
sys0m0.702s
root@demo-app:~# time cp /data/test.txt ./test.txt
real0m0.602s
user0m0.004s
sys0m0.584s
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从执行结果来看，第一次 &lt;code&gt;cp&lt;/code&gt; 用了 5s，此时建立缓存，第二次 &lt;code&gt;cp&lt;/code&gt; 的时候由于缓存已经存在，只用了 0.6s。JuiceFS 所提供的强大的缓存能力，使得只要访问某个文件一次，该文件就会被缓存在本地缓存路径中中，所有接下来的重复访问都是从 JuiceFS 中直接获取数据。&lt;/p&gt;&lt;h2 id=&quot;后续规划&quot;&gt;后续规划&lt;/h2&gt;&lt;p&gt;目前 JuiceFSRuntime 支持的功能并不多，未来我们会继续完善，比如 FUSE Pod 以 Non-root 的方式运行，以及 Dataload 数据预热功能等。&lt;/p&gt;&lt;h2 id=&quot;作者简介&quot;&gt;作者简介&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;吕冬冬，云知声超算平台架构师， 负责大规模分布式机器学习平台架构设计与功能研发，负责深度学习算法应用的优化与 AI 模型加速。研究领域包括高性能计算、分布式文件存储、分布式缓存等。&lt;/li&gt;&lt;li&gt;朱唯唯，Juicedata 全栈工程师，负责 JuiceFS CSI Driver 的开发和维护，负责 JuiceFS 在云原生领域的发展。&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e23cf041b03f431eab91d7976364b837</guid>
<title>密码学基础：编码方式、消息摘要算法、加密算法总结</title>
<link>https://toutiao.io/k/c4zz78i</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;h2&gt;&lt;span&gt;字节码转文本的编码方式&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;在计算机中，无论是内存、磁盘、网络传输，涉及到的数据都是以二进制格式来存储或传输的。&lt;/p&gt;&lt;p&gt;每一个二进制位（bit）只能是 0 或 1。二进制位不会单独存在，而是以 8 个二进制位组成 1 个字节（byte）的方式存在，即 1 byte = 8 bit。&lt;/p&gt;&lt;p&gt;字节码无法直接转为可打印的文本字符，有时想通过文本方式配置、存储、传输一段二进制字节码，比如配置文件、HTML/XML、URL、e-mail 正文、HTTP Header 等仅支持文本的场景下，就需要将二进制字节码转为文本字符串。&lt;/p&gt;&lt;p&gt;二进制字节码转文本字符有很多种方式，最简单的方式是直接用 0 和 1 来表示。但是这样的话，8 个 0/1 字符才能表示 1 个字节，长度太长很不方便。&lt;/p&gt;&lt;p&gt;下面介绍两种更加紧凑的方式：HEX 编码和 Base64 编码。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;HEX 编码&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;HEX 是 16 进制的编码方式，所以又称为 Base16。&lt;/p&gt;&lt;p&gt;如果把一个字节中的二进制数值转为十六进制，使用 0-9 和 a-e（忽略大小写）这 16 个字符，那每个字符就可以表示 4 个二进制位（因为 2 的 4 次方等于 16），那么仅需要两个可打印字符就可以表示一个字节。&lt;/p&gt;&lt;p&gt;Java 中使用 HEX 编码（依赖 Apache Commons Codec）：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;String str = &lt;span&gt;&quot;相对论&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;byte&lt;/span&gt;[] bytes = str.getBytes(&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Hex 编码&lt;/span&gt;&lt;br/&gt;String encodeString = Hex.encodeHexString(bytes);&lt;br/&gt;System.out.println(encodeString); &lt;span&gt;// 输出：e79bb8e5afb9e8aeba&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Hex 解码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;byte&lt;/span&gt;[] decodeBytes = Hex.decodeHex(encodeString);&lt;br/&gt;System.out.println(&lt;span&gt;new&lt;/span&gt; String(decodeBytes, &lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;)); &lt;span&gt;// 输出：相对论&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;HEX 编码使用场景非常多。下面介绍几种常见的使用场景：&lt;/p&gt;&lt;h4&gt;&lt;span&gt;RGB 颜色码&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;RGB 颜色通常用 HEX 方式表示。如橘红色可以用 #FF4500 来表示：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;.orangered&lt;/span&gt; { &lt;span&gt;color&lt;/span&gt;: &lt;span&gt;#FF4500&lt;/span&gt;; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;RGB 指红(red)绿(green)蓝(blue)三原色，这三种颜色按不同比例叠加后可以得到各式各样的颜色。三种颜色每种强度取值范围是 0~255，各需要 1 个字节来表示，共 3 个字节。&lt;/p&gt;&lt;p&gt;用 HEX 编码的表示某种 RGB 颜色，是一个长度为 6 位的字符串（通常还会加上 # 作为前缀，此时长度是 7 位）。例如 #FF4500 表示红绿蓝三原色的强度分别为 255、69、0。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;URL 编码&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;由于 URL 中仅允许出现字母、数字和一些特殊符号，当 URL 中有汉字，需要经过 URL 编码才可以。&lt;/p&gt;&lt;p&gt;例如百度百科&quot;相对论&quot;的页面 URL 是：https://baike.baidu.com/item/%E7%9B%B8%E5%AF%B9%E8%AE%BA/48750&lt;/p&gt;&lt;p&gt;其中 %E7%9B%B8%E5%AF%B9%E8%AE%BA 实际上是将 &#x27;相对论&#x27; 三个字用 UTF-8 编码后得到 9 个字节，再分别对这 9 个字节使用 HEX 编码并加上 &#x27;%&#x27; 前缀得到的结果。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;IPv6 地址&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;由于 IPv4 的地址即将面临不够用的问题，取而代之的将会是 IPv6。IPv6 使用了 128 个二进制位的地址吗，通常会使用 HEX 编码方式来表示，例如：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;2001&lt;span&gt;:0db8&lt;/span&gt;&lt;span&gt;:0000&lt;/span&gt;&lt;span&gt;:0000&lt;/span&gt;&lt;span&gt;:0000&lt;/span&gt;&lt;span&gt;:ff00&lt;/span&gt;&lt;span&gt;:0042&lt;/span&gt;&lt;span&gt;:8329&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;Base64 编码&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;如果觉得 HEX 编码不够紧凑，那么还有更加紧凑的编码方式：Base64 编码。&lt;/p&gt;&lt;p&gt;Base64 编码共使用了 64 个字符来表示二进制位：26 个大写的 A-Z、26 个小写的 a-z、10 个数字 0-9、2 个特殊符号 + 和 /。这意味着每个字符可以表示 6 个二进制位，因为 64 等于 2 的 6 次方。&lt;/p&gt;&lt;p&gt;由于每个字节是 8 个二进制位，而 Base64 编码每个字符表示 6 个二进制位，那么可以每凑够 3 个字节（即 24 个二进制位），可将其编码为 4 个字符。如果被 base64 编码的原数据字节数不是 3 的倍数，那么会在末尾补上 1 或 2 个值为 0 的字节，凑到 3 的倍数后再进行 Base64 编码，编码后会在末尾添加 1 或 2 个 = 符号，表示补了多少个字节，这个在解码时会用到。&lt;/p&gt;&lt;p&gt;Java 中使用 Base64 编码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;String str = &lt;span&gt;&quot;相对论&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;byte&lt;/span&gt;[] bytes = str.getBytes(&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Base64 编码&lt;/span&gt;&lt;br/&gt;String encodeString = Base64.getEncoder().encodeToString(bytes);&lt;br/&gt;System.out.println(encodeString); &lt;span&gt;// 输出：55u45a+56K66&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Base64 解码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;byte&lt;/span&gt;[] decodeBytes = Base64.getDecoder().decode(encodeString);&lt;br/&gt;System.out.println(&lt;span&gt;new&lt;/span&gt; String(decodeBytes, &lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;)); &lt;span&gt;// 输出：相对论&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Base64 编码的使用场景也有很多。例如，由于图片文件不是文本文件，没办法直接写入到 HTML 中，而将图片经过 Base64 编码后的结果是一串文本，可以直接放到 HTML 中：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;img&lt;/span&gt; &lt;span&gt;src&lt;/span&gt;=&lt;span&gt;&quot;data:image/jpg;base64,/9j/4QMZR...&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意的是，&lt;strong&gt;Base64 不是加密算法&lt;/strong&gt;，有的开发人员把 Base64 当做加密算法来用，这是极其不安全的，因为 Base64 任何人都可以解码，不需要任何密钥。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;消息摘要算法&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;消息摘要算法（Message-Digest Algorithm），又称为密码散列函数（cryptographic hash function (CHF)），可以将任意长度的字节码数据通过哈希算法计算出一个固定大小的结果。常用的消息摘要算法有 MD5、SHA-1、SHA-2 系列（包括 SHA-256、SHA-512 等）。&lt;/p&gt;&lt;p&gt;以 MD5 为例，对任意一个数据进行 MD5 运算，结果是一个 128 个二进制位（16 个字节）的哈希值。而我们日常看到的 32 位 MD5 字符串，实际上是对 128 个二进制位的哈希值进行 HEX 编码后得到的结果。&lt;/p&gt;&lt;p&gt;例如，当使用 MD5 对 &quot;相对论&quot; 这个字符串进行运算，得到一个 32 位字符的 MD5 值，实际上是经过以下 3 个步骤（以下代码依赖 Apache Commons Codec）：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;String str = &lt;span&gt;&quot;相对论&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;// 1. 将字符串通过 UTF-8 编码转为字节数组&lt;/span&gt;&lt;br/&gt;&lt;span&gt;byte&lt;/span&gt;[] bytes = str.getBytes(&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// 2. 对原始数组进行 MD5，得到一个 128 个二进制位（16 个字节）的哈希值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;byte&lt;/span&gt;[] md5Bytes = DigestUtils.md5(bytes);&lt;br/&gt;&lt;span&gt;// 3. 将 128 位的哈希值 HEX 编码，得到一个长度为 32 的字符串&lt;/span&gt;&lt;br/&gt;String md5Hex = Hex.encodeHexString(md5Bytes);&lt;br/&gt;System.out.println(md5Hex); &lt;span&gt;// 输出：fa913fb181bc1a69513e3d05a367da49&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码仅仅是为了更清晰的看到计算一个字符串 MD5 值的整个过程。实际开发中可以使用更加便捷的 API，将上面的 3 个步骤合为 1 步：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;String str = &lt;span&gt;&quot;相对论&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;// 使用默认的 UTF-8 编码将字符串转为字节数组计算 MD5 后再进行 HEX 编码&lt;/span&gt;&lt;br/&gt;String md5Hex = DigestUtils.md5Hex(str);&lt;br/&gt;System.out.println(md5Hex); &lt;span&gt;// 输出：fa913fb181bc1a69513e3d05a367da49&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;除此之外，Apache Commons Codec 中的 &lt;code&gt;DigestUtils&lt;/code&gt; 还提供了 SHA-1、SHA-256、SHA-384、SHA-512 等消息摘要算法。&lt;/p&gt;&lt;p&gt;消息摘要算法有以下特点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;相同的消息通过消息摘要算法计算得到的结果总是相同的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不同的消息通过消息摘要算法计算得到的结果要尽可能保证是不同的。如果两个不同的数据消息摘要后的结果相同，也就是发生了哈希碰撞，哈希碰撞出现的概率越大，那么这个消息摘要算法就越不安全。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不可逆，无法通过哈希结果反向推算出原始数据。所以，我们一般认为&lt;strong&gt;消息摘要算法并不算是加密算法&lt;/strong&gt;，因为它无法解密。另外，这里的不可逆是指运算不可逆，但是攻击者通常会使用穷举法或彩虹表来找到哈希值对应的原始数据。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;下面列举一些典型的消息摘要算法的使用场景：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对用户的登录密码使用消息摘要算法得到哈希值后再存储到数据库，即使数据库被黑客攻击，拿到所有的数据，也很难获得密码的原始值。这相对明文存储密码来说更加安全。当然，直接使用哈希值存储也是不安全的，特别是对于一些弱密码，黑客可以通过彩虹表轻松的查到对应的原始值。所以通常不会直接存储哈希值，而是经过一些处理，例如加盐、HMAC 等方式。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对比两个文件是否一致，只需要对比两个文件的消息摘要是否一致即可，无需按字节一个个去对比。例如百度网盘曾经就是用文件的 MD5 来判断新上传的文件是否已存在，如果已经存在则不需要重复上传和存储，达到节省空间的目的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;用于数字签名（Digital Signature），这个在本文后续会介绍。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在安全性要求比较高的场景下，MD5、SHA-1 目前都已经不建议使用了，现在用的比较多的是 SHA-2 系列算法。&lt;span/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;HMAC&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;HMAC 全称是散列消息认证码（Hash-Based Message Authentication Code），它在消息摘要算法的基础上，加上了一个密钥（secret key）。&lt;/p&gt;&lt;p&gt;例如 HMAC-SHA256 就是在 SHA-256 算法基础上加了一个密钥。以下为代码示例（依赖 Apache Commons Codec）：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;String str = &lt;span&gt;&quot;相对论&quot;&lt;/span&gt;;&lt;br/&gt;String key = &lt;span&gt;&quot;12345678&quot;&lt;/span&gt;; &lt;span&gt;// 密钥&lt;/span&gt;&lt;br/&gt;HmacUtils hmacUtils = &lt;span&gt;new&lt;/span&gt; HmacUtils(HmacAlgorithms.HMAC_SHA_256, key.getBytes(&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;));&lt;br/&gt;String result = hmacUtils.hmacHex(str.getBytes(&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;));&lt;br/&gt;System.out.println(result); &lt;span&gt;// 输出：3bd7bbf58159a6d0bff846016b346a617a588fc1e9c43ebbdf38be53d3fc455a&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;相对于直接使用消息摘要算法，使用 HMAC 优势在于，它可以对消息进行真实性（authenticity）和完整性（integrity）验证。&lt;/p&gt;&lt;p&gt;只要密钥没有泄露，那么只有持有密钥才可以计算和验证原始数据哈希值。攻击者在没有密钥的前提下，无法发送伪造的消息，也无法篡改消息。&lt;/p&gt;&lt;p&gt;HMAC 可用于接口认证。例如一个暴露在网络环境中的 HTTP 接口，如果想要对调用方进行认证，可以将密钥发放给调用方，要求调用方调用接口时，给所有请求参数使用密钥通过 HMAC 计算一个签名，被调用方验证签名，就可以保证请求参数的真实性和完整性。&lt;/p&gt;&lt;p&gt;另外，HMAC 由于在计算哈希值时添加了密钥，相对于直接使用消息摘要算法，更加不容易被穷举法、彩虹表破解，用户密码经过 HMAC 后保存更加安全。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;JWT 中的 HMAC&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;HMAC 的一个典型的应用场景就是 JWT。JWT 全称是 JSON Web Token。&lt;/p&gt;&lt;p&gt;传统的认证方式一般会将认证用户信息保存在服务端，而 JWT 直接将认证用户信息发放给客户端保存。既然 JWT 保存在客户端，那么任何人都可以伪造或篡改。如何解决这个问题，其中一种方式就是服务端会对 JWT 的 token 使用 HMAC 进行签名，并将签名也放在 token 末尾。下次客户端带上 JWT 请求时，服务端再验证签名是否正确。只要密钥不泄露，就可以保证 token 的真实性和完整性。&lt;/p&gt;&lt;p&gt;JWT token 分为三个部分：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;HMACSHA256&lt;/span&gt;(&lt;br/&gt;    &lt;span&gt;base64UrlEncode&lt;/span&gt;(header) + &lt;span&gt;&quot;.&quot;&lt;/span&gt; +&lt;br/&gt;    &lt;span&gt;base64UrlEncode&lt;/span&gt;(payload),&lt;br/&gt;    &lt;span&gt;secret&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最终对这三个部分 Base64 编码后组合为 JWT 的 token：&lt;/p&gt;&lt;figure&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.1251303441084464&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qdfEUPqfXuy5DYiaFCVQA26ANMia1OOpLGosrqicQfmtXHqrCV6CIYX7CxPu4tic3tfq5mNzStPicNLzEoNNRaXF35A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;959&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;JWT token 的三个部分&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;span&gt;加密算法&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;加密算法分为对称加密算法和非对称加密算法：&lt;/p&gt;&lt;h3&gt;&lt;span&gt;对称加密算法&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;常见的对称加密算法有 DES、3DES、AES，其中 DES 和 3DES 标准由于安全性问题，已经逐渐被 AES 取代。&lt;/p&gt;&lt;p&gt;AES 有多种工作模式（mode of operation）和填充方式（padding）：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;工作模式：如 ECB、CBC、OFB、CFB、CTR、XTS、OCB、GCM，不同的模式参数和加密流程不同。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;填充方式：由于 AES 是一种区块加密（block cipher）算法，加密时会将原始数据按大小拆分成一个个 128 比特（即 16 字节）区块进行加密，如果需要加密的原始数据不是 16 字节的整数倍时，就需要对原始数据进行填充，使其达到 16 字节的整数倍。常用的填充方式有 PKCS5Padding、ISO10126Padding 等，另外如果能保证待加密的原始数据大小为 16 字节的整数倍，也可以选择不填充，即 NoPadding。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在实际工作中，需要跨团队跨语言对数据加密解密，经常出现使用一个语言加密后，另一个语言无法解密的情况。这一般都是两边选择的工作模式和填充方式不一致导致的。&lt;/p&gt;&lt;p&gt;下面的代码以 ECB 模式结合 PKCS5Padding 填充方式为例，对数据进行加密和解密：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] encryptECB(&lt;span&gt;byte&lt;/span&gt;[] data, &lt;span&gt;byte&lt;/span&gt;[] key) &lt;span&gt;throws&lt;/span&gt; NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {&lt;br/&gt;    Cipher cipher = Cipher.getInstance(&lt;span&gt;&quot;AES/ECB/PKCS5Padding&quot;&lt;/span&gt;);&lt;br/&gt;    cipher.init(Cipher.ENCRYPT_MODE, &lt;span&gt;new&lt;/span&gt; SecretKeySpec(key, &lt;span&gt;&quot;AES&quot;&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt;[] result = cipher.doFinal(data);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] decryptECB(&lt;span&gt;byte&lt;/span&gt;[] data, &lt;span&gt;byte&lt;/span&gt;[] key) &lt;span&gt;throws&lt;/span&gt; NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {&lt;br/&gt;    Cipher cipher = Cipher.getInstance(&lt;span&gt;&quot;AES/ECB/PKCS5Padding&quot;&lt;/span&gt;);&lt;br/&gt;    cipher.init(Cipher.DECRYPT_MODE, &lt;span&gt;new&lt;/span&gt; SecretKeySpec(key, &lt;span&gt;&quot;AES&quot;&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt;[] result = cipher.doFinal(data);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException &lt;/span&gt;{&lt;br/&gt;    String data = &lt;span&gt;&quot;Hello World&quot;&lt;/span&gt;; &lt;span&gt;// 待加密的明文&lt;/span&gt;&lt;br/&gt;    String key = &lt;span&gt;&quot;12345678abcdefgh&quot;&lt;/span&gt;; &lt;span&gt;// key 长度只能是 16、25 或 32 字节&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt;[] ciphertext = encryptECB(data.getBytes(), key.getBytes());&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;ECB 模式加密结果（Base64）：&quot;&lt;/span&gt; + Base64.getEncoder().encodeToString(ciphertext));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt;[] plaintext = decryptECB(ciphertext, key.getBytes());&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;解密结果：&quot;&lt;/span&gt; + &lt;span&gt;new&lt;/span&gt; String(plaintext));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;ECB&lt;/span&gt; 模式加密结果（Base64）：bB0gie8pCE2RBQoIAAIxeA==&lt;br/&gt;解密结果：Hello World&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的 ECB 模式虽然简单易用，但是安全性不高。由于该模式对每个 block 进行独立加密，会导致同样的明文块被加密成相同的密文块。下图就是一个很好的例子：&lt;/p&gt;&lt;figure&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qdfEUPqfXuy5DYiaFCVQA26ANMia1OOpLG8FGmicVJLqZq8CXmJGaGoapcia12rV1d5pKjLvS6XSbTZQqO9XVmy4rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;ECB 模式缺点&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;在 CBC 模式中，引入了初始向量（IV，Initialization Vector）的概念，用于解决 ECB 模式的问题。&lt;/p&gt;&lt;p&gt;下面是 CBC 模式结合 PKCS5Padding 填充方式的代码示例，加密解密时相比 ECB 模式多了一个初始向量 iv 参数：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] encryptCBC(&lt;span&gt;byte&lt;/span&gt;[] data, &lt;span&gt;byte&lt;/span&gt;[] key, &lt;span&gt;byte&lt;/span&gt;[] iv) &lt;span&gt;throws&lt;/span&gt; NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, InvalidAlgorithmParameterException {&lt;br/&gt;    Cipher cipher = Cipher.getInstance(&lt;span&gt;&quot;AES/CBC/PKCS5Padding&quot;&lt;/span&gt;);&lt;br/&gt;    cipher.init(Cipher.ENCRYPT_MODE, &lt;span&gt;new&lt;/span&gt; SecretKeySpec(key, &lt;span&gt;&quot;AES&quot;&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; IvParameterSpec(iv));&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt;[] result = cipher.doFinal(data);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] decryptCBC(&lt;span&gt;byte&lt;/span&gt;[] data, &lt;span&gt;byte&lt;/span&gt;[] key, &lt;span&gt;byte&lt;/span&gt;[] iv) &lt;span&gt;throws&lt;/span&gt; NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, InvalidAlgorithmParameterException {&lt;br/&gt;    Cipher cipher = Cipher.getInstance(&lt;span&gt;&quot;AES/CBC/PKCS5Padding&quot;&lt;/span&gt;);&lt;br/&gt;    cipher.init(Cipher.DECRYPT_MODE, &lt;span&gt;new&lt;/span&gt; SecretKeySpec(key, &lt;span&gt;&quot;AES&quot;&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; IvParameterSpec(iv));&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt;[] result = cipher.doFinal(data);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException &lt;/span&gt;{&lt;br/&gt;    String data = &lt;span&gt;&quot;Hello World&quot;&lt;/span&gt;; &lt;span&gt;// 待加密的原文&lt;/span&gt;&lt;br/&gt;    String key = &lt;span&gt;&quot;12345678abcdefgh&quot;&lt;/span&gt;; &lt;span&gt;// key 长度只能是 16、25 或 32 字节&lt;/span&gt;&lt;br/&gt;    String iv = &lt;span&gt;&quot;iviviviviviviviv&quot;&lt;/span&gt;; &lt;span&gt;// CBC 模式需要用到初始向量参数&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt;[] ciphertext = encryptCBC(data.getBytes(), key.getBytes(), iv.getBytes());&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;CBC 模式加密结果（Base64）：&quot;&lt;/span&gt; + Base64.getEncoder().encodeToString(ciphertext));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt;[] plaintext = decryptCBC(ciphertext, key.getBytes(), iv.getBytes());&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;解密结果：&quot;&lt;/span&gt; + &lt;span&gt;new&lt;/span&gt; String(plaintext));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;CBC&lt;/span&gt; 模式加密结果（Base64）：K7bSB51+KxfqaMjJOsPAQg==&lt;br/&gt;解密结果：Hello World&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;AES 使用非常广泛，可以说只要上网，无论是使用手机 APP 还是 Web 应用，几乎都离不开 AES 加密算法。目前大部分网站，包括手机 APP 后端接口，都已经使用 HTTPS 协议，而 HTTPS 在数据传输阶段大多都是使用 AES 对称加密算法。&lt;/p&gt;&lt;p&gt;但是，以 AES 为代表的的对称加密算法面临一个问题，就是如何安全的传输密钥。网络中发生数据交换的双方，需要用同一个密钥进行加密和解密，密钥一旦暴露，传输的内容就不再安全。密钥本身如果需要传输，如何保证安全？对于这个问题，就需要用到非对称加密算法。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;非对称加密算法&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;1977 年，Rivest、Shamir、Adleman 设计了 RSA 非对称加密算法，并以此获得了 2002 年的图灵奖（计算机领域的国际最高奖项，被誉为&quot;计算机界的诺贝尔奖&quot;）。至今，RSA 算法一直是最广为使用的非对称加密算法。&lt;/p&gt;&lt;p&gt;RSA 有两个密钥：公钥（public key）和私钥（private key）。&lt;/p&gt;&lt;p&gt;公钥可以完全公开，任何人都可以获取到。私钥是私有的，要保证不能被泄露出去。&lt;/p&gt;&lt;p&gt;公钥加密的内容，只有私钥可以解密。私钥加密的内容，也只有公钥可以解密。&lt;/p&gt;&lt;p&gt;基于以上规则，RSA 有两种不同的用法：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;公钥加密，私钥解密：服务端把公钥公开出去，客户端拿到公钥，把想要传输给服务端的数据通过公钥加密后传输，那么这个数据只有服务端能够解密，因为只有服务端拥有私钥，其他任何中间人即使在传输过程中拿到数据，既不能解密，也无法篡改。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;私钥签名，公钥验证签名：内容发布者将发布的内容用消息摘要算法（如 SHA-256）计算哈希值，再用私钥加密哈希值，得到一个签名，并将签名加在发布内容中一起发布，其他人得到这个内容后，可以用公开的公钥解密签名得到哈希值，再对比这个哈希值和内容生成的哈希值是否一致，来保证这份内容没有被篡改过。&lt;/p&gt;&lt;p&gt;由于只是验证数据的真实性完整性，所以无需对整个内容进行加密，仅需对内容的哈希值加密即可验证，所以通常会结合消息摘要算法。例如 SHA256 with RSA 签名，就是先用 SHA-256 计算出哈希值，再用 RSA 私钥加密。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;上面说到的私钥加密、公钥解密只是理论上成立，实际上不会直接这样用，而是只用于签名。因为一段私钥加密的数据，解密的公钥是公开的，意味着谁都可以解密，这样加密就没有任何意义了。&lt;/p&gt;&lt;p&gt;接下来通过 Java 代码来体验一下 RSA 算法。&lt;/p&gt;&lt;p&gt;首先，需要生成一对公钥和私钥。下面通过 openssl 命令来生成一对公钥和私钥：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 创建一个 PKCS#8 格式 2048 位的私钥&lt;/span&gt;&lt;br/&gt;openssl genpkey -out private_key.pem -algorithm RSA -pkeyopt rsa_keygen_bits:2048&lt;br/&gt;&lt;span&gt;# 通过私钥生成公钥&lt;/span&gt;&lt;br/&gt;openssl pkey -&lt;span&gt;in&lt;/span&gt; private_key.pem -pubout -out public_key.pem&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;生成的公钥和私钥是 Base64 编码的文本文件，可以直接用文本编辑器打开。拷贝到下面的代码中，可以验证公钥加密、私钥解密，以及私钥签名、公钥验证签名：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;    String publicKeyBase64 = &lt;span&gt;&quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0XYlulDsTzDWUb6X66Ia\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;giSn1dKriHvLHYth9hCcaGomdeIQahGnxzE1o76slEyS2HZ164QHqx8Za+LuT6IV\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;yLhU/ZNLWAZABe/sdNEkhti6vSSOdJE43KS4UVADeSgtN+7uXDuVgm35EPWZjkfV\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;5hiRX4nT5ALr1niyi1Ax4BWWyG4qX00n1HzY8MvoyiLdNob71qB+amjUNy9bDhcz\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;CDWtgA/ywOYU5Ec6vMgYfbAXPKGWwo318rS3UH8QtsO8iGcQbZ76q05LNEL8G3fo\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;0Kssj4fjrVGwSsyGztRRMLfGkW/hOPCDj82+D6dGQlGB3gyB7P1xVbkD67FujQA/\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;jwIDAQAB&quot;&lt;/span&gt;;&lt;br/&gt;    String privateKeyBase64 = &lt;span&gt;&quot;MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDRdiW6UOxPMNZR\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;vpfrohqCJKfV0quIe8sdi2H2EJxoaiZ14hBqEafHMTWjvqyUTJLYdnXrhAerHxlr\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;4u5PohXIuFT9k0tYBkAF7+x00SSG2Lq9JI50kTjcpLhRUAN5KC037u5cO5WCbfkQ\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;9ZmOR9XmGJFfidPkAuvWeLKLUDHgFZbIbipfTSfUfNjwy+jKIt02hvvWoH5qaNQ3\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;L1sOFzMINa2AD/LA5hTkRzq8yBh9sBc8oZbCjfXytLdQfxC2w7yIZxBtnvqrTks0\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;Qvwbd+jQqyyPh+OtUbBKzIbO1FEwt8aRb+E48IOPzb4Pp0ZCUYHeDIHs/XFVuQPr\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;sW6NAD+PAgMBAAECggEABT96joJ8iTdmB0JJOCQlmeElO1w94/uGCUV2vN2JrawL\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;LqTtWFr84ya+e03JsSWCAF5ncfEq6AStdGCJLAGZnh/QMVJBbwEpFXz/ZaXfzmkb\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;tKV31D/XNuABpjfk/mIdT+tymWj8w/nRZbVhlYkDOPKgoc4oOuw/0G3Ru1/VABI+\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;yulNx93A/JNFGk3Bkm4E7jRWyl0BkAqAX2BZkFbXG/u3Jc0eYXrG74JfMH+MEihG\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;GDMSpBKNyX5zWkUT6XxpG82t2erHPWYEoNSoFzAUu+7rZ4ECEXxazAQclEHTkR3r\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;duUZ/XF0GL1WB0GC7+qvV/Z0gxjXuwG9oToFO/0MQQKBgQDu4DuTPWcYwSWY0R1f\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;qZUOuYRwD+5OQnJMIlKAD32QmvYT/jnvigjss5Qf1IUwf1UMynj2FnVF4D7L+kvq\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;O7LzYvHAeDQwZGGt2xWBlqjfhumlfBqfklkkqUiH2A5DvfvtbX/kkiY3n9C+oYZp\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;2ejiOtSC+NqQeB74TluxroEkvwKBgQDgehynybpFl4KkmDhgj++BH5RR+xzXIChb\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;gtIbbspdE1EyXy7Z9iNAJ8PVjHkSwh8iEfAO4EuJFnonF8UNIsWLr3gsKbQytRxR\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;cewqaBhTL54Vgl5dmODNrYjkZva5HHDsCLioYGgljdrj5e/gPSAWBrgT6kI+HypQ\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;/5xyp+KJMQKBgQCMxut1P8eliBa/M+YqvYdR8TVC0bCwwGoZwlR6kiZ+9UQ2zimY\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;qPHPhZmzFI0V4sTdz+lvphahAqIfljftKBezZklxE6Y2KsKCMk4/W+nUKe9Cjpwm\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;FJqih31uSX9Gnw18hH7N1u/c8juUTR8o/LpJsUASm9Q7Nf+SeKODWINVgwKBgDEx\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;UXpLsPBzRYQAf8pZgKkRXJWirC1QtMdpIdY1L0+6Xf7l8QR+9janADmaMSY1OFFl\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;EPCRorwGGvraMKqyRgxYhcNX2E+MdQo8Jv8cFMiWFNSt3zQvvoQUVX2IOuVSIET5\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;nE354pjoP2HWD/1aJ9/r1Qc4PRAUEFfzzDssI27hAoGAOsYKtvW6iRn/WVduIRcy\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;UtBRHHX0U16zGv+I7nOOBIYK5Uan6AjgzG2MfPOBj3cUhMMBDPfVg1cTbonw5Y8F\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;nSO4VLOtqKy0BRxCIUFqltJXUmj1zAJs84IweCBQ3un/OLVUMgE7qGtaIQy2PBsy\n&quot;&lt;/span&gt; +&lt;br/&gt;            &lt;span&gt;&quot;M8mwuUjo3Fu7l11E2Vgz/qY=&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Base64 解码&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt;[] publicKeyBytes = Base64.getDecoder().decode(publicKeyBase64.replace(&lt;span&gt;&quot;\n&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt;[] privateKeyBytes = Base64.getDecoder().decode(privateKeyBase64.replace(&lt;span&gt;&quot;\n&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 生成 PublicKey（公钥） 和 PrivateKey（私钥） 对象&lt;/span&gt;&lt;br/&gt;    PublicKey publicKey = KeyFactory.getInstance(&lt;span&gt;&quot;RSA&quot;&lt;/span&gt;).generatePublic(&lt;span&gt;new&lt;/span&gt; X509EncodedKeySpec(publicKeyBytes));&lt;br/&gt;    PrivateKey privateKey = KeyFactory.getInstance(&lt;span&gt;&quot;RSA&quot;&lt;/span&gt;).generatePrivate(&lt;span&gt;new&lt;/span&gt; PKCS8EncodedKeySpec(privateKeyBytes));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 待加密、签名的原文&lt;/span&gt;&lt;br/&gt;    String data = &lt;span&gt;&quot;Hello World&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 公钥加密，私钥解密&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt;[] ciphertext = encrypt(data.getBytes(), publicKey);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;RSA 公钥加密结果（Base64）：&quot;&lt;/span&gt; + Base64.getEncoder().encodeToString(ciphertext));&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt;[] plaintext = decrypt(ciphertext, privateKey);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;RSA 私钥解密结果：&quot;&lt;/span&gt; + &lt;span&gt;new&lt;/span&gt; String(plaintext));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 私钥签名，公钥验证签名&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt;[] signature = sign(data.getBytes(), privateKey);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;RSA 私钥签名结果（Base64）：&quot;&lt;/span&gt; + Base64.getEncoder().encodeToString(signature));&lt;br/&gt;    &lt;span&gt;boolean&lt;/span&gt; verifySuccess = verify(data.getBytes(), signature, publicKey);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;RSA 公钥验证签名结果：&quot;&lt;/span&gt; + verifySuccess);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 公钥加密&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] encrypt(&lt;span&gt;byte&lt;/span&gt;[] data, PublicKey publicKey) &lt;span&gt;throws&lt;/span&gt; Exception {&lt;br/&gt;    Cipher cipher = Cipher.getInstance(&lt;span&gt;&quot;RSA&quot;&lt;/span&gt;);&lt;br/&gt;    cipher.init(Cipher.ENCRYPT_MODE, publicKey);&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt;[] result = cipher.doFinal(data);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 私钥解密&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] decrypt(&lt;span&gt;byte&lt;/span&gt;[] data, PrivateKey privateKey) &lt;span&gt;throws&lt;/span&gt; Exception {&lt;br/&gt;    Cipher cipher = Cipher.getInstance(&lt;span&gt;&quot;RSA&quot;&lt;/span&gt;);&lt;br/&gt;    cipher.init(Cipher.DECRYPT_MODE, privateKey);&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt;[] result = cipher.doFinal(data);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 私钥签名，使用 SHA256 with RSA 签名&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] sign(&lt;span&gt;byte&lt;/span&gt;[] data, PrivateKey privateKey) &lt;span&gt;throws&lt;/span&gt; Exception {&lt;br/&gt;    Signature signature = Signature.getInstance(&lt;span&gt;&quot;SHA256withRSA&quot;&lt;/span&gt;);&lt;br/&gt;    signature.initSign(privateKey);&lt;br/&gt;    signature.update(data);&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt;[] result = signature.sign();&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 公钥验证签名&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;verify&lt;/span&gt;&lt;span&gt;(&lt;span&gt;byte&lt;/span&gt;[] data, &lt;span&gt;byte&lt;/span&gt;[] sign, PublicKey publicKey)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;    Signature signature = Signature.getInstance(&lt;span&gt;&quot;SHA256withRSA&quot;&lt;/span&gt;);&lt;br/&gt;    signature.initVerify(publicKey);&lt;br/&gt;    signature.update(data);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; signature.verify(sign);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;RSA&lt;/span&gt; 公钥加密结果（Base64）：zoY6KM/RdCjAs7upJ9SIwqfXsSn3hAPu/z/ZPHbKgWN6+X0PpyVJVYT8jacEkzB7S2sJe/wLkO2TqXB2gqvL1AuDRgepVlxV2f6Uwx4DxM2/5RE0fAdTiICV5JEEIw81oLix0GGQ7nLjOhJxN9LaTJ2cXtwgR8gUtLtJ0tdWrxSMuN8FHLA45Nv8Ea1EAUQCvfanYZ2L39l++&lt;span&gt;3&lt;/span&gt;/zBdg2wYQwCE6XGFnWnayUsGKYjC7JIufnq5f9VDL/kguLKceLmeTHqq31ccRTOQyhuoZjHCsbfXPlW2AT9ejgAcXy7LkXhYCfma50DBM+KUCfC4YrKBg6wKRqdZee90ZPcUKTkw==&lt;br/&gt;RSA 私钥解密结果：Hello World&lt;br/&gt;RSA 私钥签名结果（Base64）：AbP5zSV/qvkF8fCseVkEaZMscvznQBUDtO3g0U/FIXVmzeR6WXFwPsMd3cC3oCHtnnqsL/aRQrpW6pHU6EzSJ5w6FgY6kD4kWREq9f8LOnyQm7CoS6CK0tUiAjIgG16rtmS+oPbG+mYaZkLzo1Cpkpz2MzuMMbWNivvXRMbj3wLiXyIMqUefawipvm+GPwrWRxesRot2sGtuZcxtMMZs3NHpJ0CXV/mQlYJWEzIiHUY4mqfqpMDL/djPf9td74ABpjk38O6r1Jt75TLnMvkwRdh7pHBQLZ0Tn/6Vx2cVD2D+sE9BuhinO66B6I0QOGVcl3a5C2whp+85zEovvdGlSg==&lt;br/&gt;RSA 公钥验证签名结果：&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;目前随处可见的 HTTPS 协议，是基于 SSL/TLS 协议的。在 SSL/TLS 协议中，建立加密的传输通道前，首先有一个握手过程。在握手过程中，客户端会生成一个随机值，并使用公钥加密后传给服务端。这个随机值用于生成对称加密算法的密钥，仅有服务端的私钥可以解密，任何第三方都无法解密，这就解决了前面所说到的对称加密算法密钥传输过程中的安全问题。而握手成功后的通信阶段，则使用对称加密算法进行通信。因为非对称加密算法更加复杂，相对于对称加密算法来说效率不高，不适合用来做大量数据的加密解密。&lt;/p&gt;&lt;p&gt;另外，SSL/TLS 中用到的数字证书（digital certificate），为了防止伪造，也会由 CA 机构进行数字签名。目前大多数 HTTPS 网站使用的数字证书都是使用 SHA256 with RSA 签名。&lt;/p&gt;&lt;p&gt;例如，在浏览器上打开 https://xxgblog.com/ ，点击地址栏左侧的小锁按钮，查看网站使用的证书，其数字签名算法就是 SHA256 with RSA ：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8533057851239669&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qdfEUPqfXuy5DYiaFCVQA26ANMia1OOpLGWCLvf66Piciboba9MIJUj2xo08ibNvtfXJXpgICZ1veW1SicExKAP5E6Rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;968&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;证书签名算法&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU3Nzg5NzM3OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/qdfEUPqfXuxDh7BT0licjaaDvMrEiazCmtybLZlPoUibHMoXAUqYEmLYd5pQkuuXPp3wELHdI604emAeN4zJFT86g/0?wx_fmt=png&quot; data-nickname=&quot;Java论道&quot; data-alias=&quot;JavaLundao&quot; data-signature=&quot;定期分享Java技术文章，囊括Spring全家桶、Linux、架构设计、分布式、微服务、消息中间件、面试题等。&quot; data-from=&quot;1&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.4552683896620278&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qdfEUPqfXuy5DYiaFCVQA26ANMia1OOpLGwBPQ78VrmdhBVN5Oyym8V6GicndCwA3k1m20icYOs2P0c7Rhdlebfibnw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;503&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>