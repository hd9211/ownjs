<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3b715b4fedb88346da57e9231c00b3ff</guid>
<title>利用 FFmpeg 将视频转换为 GIF 操作指北</title>
<link>https://toutiao.io/k/qdfhpcm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section class=&quot;toc-content post no-image&quot;&gt;
      &lt;h2 id=&quot;%E8%83%8C%E6%99%AF&quot;&gt;背景&lt;/h2&gt;&lt;p&gt;在写技术文档的时候，为了演示方便，经常需要插入一些短小的视频资源。比如一些操作的录频、一些经典视频片段、一些科普动画等。由于展示的地方通常是网页，而如果是插入视频之类的资源，通常需要占用额外的存储，而且也需要可用的视频播放器的支持，非常不便。对于命令行操作的回放，我们可能会采用 &lt;a href=&quot;https://asciinema.org/&quot;&gt;Asciinema&lt;/a&gt;，但是这个方案对非终端的操作无法模拟。一个常见的方案是把需要的资源转换成网页支持的 GIF、WEBP 格式等动图。考虑到各大浏览器对 GIF 格式的支持最稳定，因此大部分情况下我们都想将待展示的短小视频转换成 GIF 格式，方便直接插入文档中。&lt;/p&gt;&lt;p&gt;将视频转为 GIF 并对 GIF 做调整的过程中会有很多的坑，比如经常容易出现色差严重、分辨率不合适、GIF 占用的存储过大等问题。有时我们也希望在转换前做一些剪切等。处理图片的工具其实有很多，比如 &lt;a href=&quot;https://legacy.imagemagick.org/&quot;&gt;ImageMagick&lt;/a&gt; 的 convert 工具，或者 &lt;a href=&quot;https://github.com/kohler/gifsicle&quot;&gt;gifsicle&lt;/a&gt; 工具，甚至是一些在线的 GIF 格式转换工具（极不推荐，很难用）。但是在处理类视频的信息时，这些工具其实并不很适合。毕竟原始数据本身是视频，&lt;strong&gt;相比先把视频转换成 GIF 再做操作，直接在视频上做完操作最后再一步转为 GIF 造成的信息丢失会更少，效果也会更好&lt;/strong&gt;。本文主要基于 FFmpeg 总结一下转换过程中经常用到的命令，并介绍个人在处理这些问题的一些原则。&lt;/p&gt;&lt;h2 id=&quot;%E8%A7%86%E9%A2%91%E9%A2%84%E5%A4%84%E7%90%86&quot;&gt;视频预处理&lt;/h2&gt;&lt;p&gt;在典型的场景下，我们在将视频转为图片前一般会有如下步骤：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;视频采集&lt;/li&gt;&lt;li&gt;视频剪裁&lt;/li&gt;&lt;li&gt;视频分辨率调整&lt;/li&gt;&lt;li&gt;视频帧率调整&lt;/li&gt;&lt;li&gt;视频速率调整&lt;/li&gt;&lt;li&gt;视频压缩&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;下面将基于此流程，结合样例做简要介绍。本地的 ffmpeg 版本为 4.4.1 。&lt;/p&gt;&lt;h3 id=&quot;%E8%A7%86%E9%A2%91%E9%87%87%E9%9B%86&quot;&gt;视频采集&lt;/h3&gt;&lt;p&gt;如果我们能获取到视频文件，则最好。不过很多情况下还是需要我们使用一些录屏工具进行采集，不过作为系统洁癖患者，个人不建议下载一些乱七八糟来源的录频工具或者很贵但是普通人根本用不到多少功能的视频处理软件。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在 Windows 下，可以通过 Win+G 快捷键呼出 xbox 自带的录频工具。&lt;/li&gt;&lt;li&gt;在 Mac 下，可以通过 Command+Shift+5 快捷键呼出。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以上工具足够用了。&lt;/p&gt;&lt;h3 id=&quot;%E8%A7%86%E9%A2%91%E8%A3%81%E5%89%AA&quot;&gt;视频裁剪&lt;/h3&gt;&lt;p&gt;无论是自有视频，还是录屏来的视频，我们经常都希望剪裁掉头尾的一些无用片段。我们当然可以使用常见的编辑工具，例如 Mac 上的 imovie 等。不过显然我们不想杀鸡用牛刀，一两条命令就可以解决。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;截取从 00:00:10 开始的  10 秒的时间段的视频：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ffmpeg -i sample.mov -ss 00:00:10 -t 00:00:10 output1.mov&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(其中 -ss 表示开始时间，-t 表示截取的时长）&lt;/p&gt;&lt;p&gt;&lt;strong&gt;截取从 00:00:10 到 00:00:20 时间段的视频：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ffmpeg -i sample.mov -ss 00:00:10 -to 00:00:20 output2.mov&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(其中 -ss 表示开始时间，-to 表示结束时间)&lt;/p&gt;&lt;p&gt;&lt;strong&gt;确认二者相同并确认视频时长：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ diff output1.mov output2.mov
$ ffprobe -v error -show_entries format=duration sample.mov
[FORMAT]
duration=10.000000
[/FORMAT]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(其中 -v error 是为了屏蔽一开始打印的版本信息） &lt;/p&gt;&lt;h3 id=&quot;%E8%A7%86%E9%A2%91%E5%88%86%E8%BE%A8%E7%8E%87%E8%B0%83%E6%95%B4&quot;&gt;视频分辨率调整&lt;/h3&gt;&lt;p&gt;由于我们需要展示的视频本身是嵌入文档或网页里的，因此本身对图片分辨率的要求并不大。这时候适当的缩小分辨率无论是对文件占用的大小、还是对展示的便捷都是有好处的。采用的工具是 ffmpeg 的  scale filter graph。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;确认原视频的分辨率：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ffprobe -v error -show_entries stream=width,height sample.mov
[STREAM]
width=1560
height=1148
[/STREAM]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;强制比例缩放，设置长度，宽度：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ffmpeg -i sample.mov -vf scale=720:530 output1.mov&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(其中 720 为宽，530为高，且，宽高均不可为奇数）&lt;/p&gt;&lt;p&gt;&lt;strong&gt;固定比例缩放，设置宽度，高度自适应：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ffmpeg -i sample.mov -vf scale=720:-1 output2.mov&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;固定比例缩放，设置高度，宽度自适应：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ffmpeg -i sample.mov -vf scale=-1:530 output3.mov&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(将需要自适应的部分设置为-1即可，如果自适应部分再按倍缩放，则可以设置为 -2 ,-3 等)&lt;/p&gt;&lt;p&gt;&lt;strong&gt;选择自定义scale算法，可选算法可见&lt;a href=&quot;https://ffmpeg.org/ffmpeg-scaler.html#toc-Scaler-Options&quot;&gt;ScalerOptions&lt;/a&gt;：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ffmpeg -i sample.mov -vf scale=-1:530:flags=lanczos  output4.mov&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(缩放算法有很多种，如果效果不好可以换几个试试。默认是 bicubic 算法)&lt;/p&gt;&lt;h3 id=&quot;%E8%A7%86%E9%A2%91%E5%B8%A7%E7%8E%87%E8%B0%83%E6%95%B4&quot;&gt;视频帧率调整&lt;/h3&gt;&lt;p&gt;视频的帧率一般会比较高，而我们对 GIF 的要求一般没那么高。为了减少图片的体积，我们可以手动调节下帧率，以达到图片大小和用户体验的最佳平衡点。通常视频的帧率一般是 60 fps 。对普通图片来说，20 的fps早已够用，节约点的话，10 fps ，5 fps 也凑合能看，具体就自己体验喽。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;确认原视频帧率：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ ffprobe -v error -show_entries stream=r_frame_rate sample.mov
[STREAM]
r_frame_rate=60/1
[/STREAM]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(原视频的帧率就是 60 fps)&lt;/p&gt;&lt;p&gt;&lt;strong&gt;调整帧率为20：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ ffmpeg -i sample.mov -r 20 output1.mov&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;%E8%A7%86%E9%A2%91%E9%80%9F%E7%8E%87%E8%B0%83%E6%95%B4&quot;&gt;视频速率调整&lt;/h3&gt;&lt;p&gt;对于录屏而言，可能我们的动作比较慢，希望在展示的时候稍微加快点速度以提高展示效率并减少视频体积。或者视频本身很快，我们希望做一下慢放。这些时候我们最好提前就对视频速度做一些调整。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;调整视频速度变快为5倍(时长*0.2)：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ffmpeg -i sample.mov -filter:v &quot;setpts=0.2*PTS&quot; output1.mov&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;调整视频速度变慢2倍(时长x2)：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ffmpeg -i sample.mov -filter:v &quot;setpts=2*PTS&quot; output2.mov&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(原理通过调整视频帧中的 PTS 展示时间戳来调整速度）&lt;/p&gt;&lt;p&gt;需要注意的是，调整速率后，帧率仍然保持不变。因此将视频加速再减速成原视频的速度后，与原视频相比会丢失信息。&lt;/p&gt;&lt;h3 id=&quot;%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9&quot;&gt;视频压缩&lt;/h3&gt;&lt;p&gt;其实H264视频本身的压缩率已经很高了，如果想要进一步压缩，基本只能通过一些有损的形式。我们可以通过调整 x264, x265, 以及 libvpx 中的 Constant Rate Factor 参数来进行一些&lt;strong&gt;有损压缩&lt;/strong&gt;处理。该参数取值在 0 到 51 之间，值越大则有损的比例越大，压缩率越好。通常我们会取 23这个值，稍微激进一点可以调整为30+。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;调整 crf 取值到30 ：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ ffmpeg -i sample.mov -crf 30 output1.mov&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;比较二者大小：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ ls -lah sample.mov output1.mov
-rw-r--r--  1 myths  staff   1.5M May  1 17:31 sample.mov
-rw-r--r--@ 1 myths  staff   1.0M May  1 17:51 output1.mov&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可见视频的确压缩了一些，不过会发现 GIF 的质量会有一些下降。是否需要调整这个参数，需要根据实际情况进行取舍。&lt;/p&gt;&lt;h2 id=&quot;gif-%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2&quot;&gt;GIF 格式转换&lt;/h2&gt;&lt;p&gt;ffmpeg默认支持根据输出文件的后缀名自动进行格式转换，非常方便。但是如果你以为能无脑用，那就大错特错了。&lt;/p&gt;&lt;h3 id=&quot;%E5%B8%A7%E7%8E%87%E9%97%AE%E9%A2%98&quot;&gt;帧率问题&lt;/h3&gt;&lt;p&gt;一个典型的错误转换方法是：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ffmpeg -i sample.mov output.gif&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有什么问题呢？我们检查一下视频长度就知道了：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ffprobe -v error -show_entries format=duration sample.mov
[FORMAT]
duration=62.000000
[/FORMAT]

$ ffprobe -v error -show_entries format=duration output.gif
[FORMAT]
duration=173.680000
[/FORMAT]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们发现转换后的 GIF 的视频长度竟然和原视频不一样。打开检测后发现的确 GIF 相比原视频要慢了许多。&lt;/p&gt;&lt;p&gt;再检查一下帧率就发现问题了：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ffprobe -v error -show_entries stream=r_frame_rate,avg_frame_rate sample.mov
[STREAM]
r_frame_rate=60/1
avg_frame_rate=60/1
[/STREAM]

$ ffprobe -v error -show_entries stream=r_frame_rate,avg_frame_rate output.gif
[STREAM]
r_frame_rate=50/1
avg_frame_rate=257/12
[/STREAM]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;GIF 的实际帧率竟然变小了，难怪视频变长了。计算下比例也能对的上：&lt;/p&gt;&lt;p&gt;173.680000/62.000000≈(60/1)/(257/12)&lt;/p&gt;&lt;p&gt;既然如此，我们强制设置下帧率就好了：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ffmpeg -i sample.mov -r 20 output2.gif

$ ffprobe -v error -show_entries stream=r_frame_rate,avg_frame_rate,duration output2.gif
[STREAM]
r_frame_rate=20/1
avg_frame_rate=20/1
duration=62.050000
[/STREAM]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样时长就和原视频对上了，帧率也是我们设置的帧率。具体原因未知，不过结论就是&lt;strong&gt;在对视频转 GIF 时，一定要重新指定一下帧率&lt;/strong&gt;。&lt;/p&gt;&lt;h3 id=&quot;%E8%B0%83%E8%89%B2%E6%9D%BF%E4%BC%98%E5%8C%96&quot;&gt;调色板优化&lt;/h3&gt;&lt;p&gt;你可能知道，和视频不同，PNG的调色盘只有256种颜色。默认情况下，这256种颜色会尽量平均分布在整个颜色空间中。这就导致对于一些色彩区分度比较小的图片，会出现颜色模糊的情况。&lt;/p&gt;&lt;p&gt;首先我们生成一张下&lt;strong&gt;未优化&lt;/strong&gt;下的图片：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell &quot;&gt;$ ffmpeg -i sample.mov -r 20 output-raw.gif&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果如下：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2022/05/output-raw.gif&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这时候需要用对图片进行一下&lt;strong&gt;全局调色板优化&lt;/strong&gt;：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ffmpeg -i sample.mov -r 20 -vf &quot;split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse&quot; output-palette.gif&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果如下：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2022/05/output-palette-1.gif&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/figure&gt;&lt;p&gt;放大后仔细观察一下二者，你会很明显的发现&lt;strong&gt;原图的背景颜色变成了很多小颗粒，而使用调色版优化后，背景才真正显示了纯色&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;当然，如果对图片质量要求高，也可以&lt;strong&gt;对每一帧单独记录调色板&lt;/strong&gt;(代价就是图片会变大很多)：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ffmpeg -i sample.mov -r 20 -vf &quot;split[s0][s1];[s0]palettegen=stats_mode=single [p];[s1][p]paletteuse=new=1&quot; output-palette-single.gif&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果图片的运动程度比较大，也可以修改一些&lt;strong&gt;防抖参数&lt;/strong&gt;( dither = none / bayer / heckbert / floyd_steinberg / sierra2 / sierra2_4a)，如果不指定，默认是 sierra2_4a 。例如：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ ffmpeg -i sample.mov -r 20 -vf &quot;split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse=dither=none&quot; output-palette-none.gif

$ ffmpeg -i sample.mov -r 20 -vf &quot;split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse=dither=bayer&quot; output-palette-bayer.gif

$ ffmpeg -i sample.mov -r 20 -vf &quot;split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse=dither=heckbert&quot; output-palette-heckbert.gif&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后看一下添加了调色板优化后的图片大小：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ls -lah
-rw-r--r--   1 myths  staff   2.2M May  2 11:36 output-palette-bayer.gif
-rw-r--r--   1 myths  staff   2.5M May  2 11:36 output-palette-heckbert.gif
-rw-r--r--   1 myths  staff   1.9M May  2 11:40 output-palette-none.gif
-rw-r--r--   1 myths  staff    32M May  2 11:29 output-palette-single.gif
-rw-r--r--@  1 myths  staff   2.7M May  2 11:15 output-palette.gif
-rw-r--r--   1 myths  staff   1.0M May  2 11:30 output-raw.gif
-rw-r--r--@  1 myths  staff   198K May  1 22:15 sample.mov&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;显然，每帧记录调色板( output-palette-single.gif ) 最大；不进行调色板优化图片最小，但是质量最差( output-raw.gif )；而不使用防抖策略( output-palette-none.gif ) 会使图片更小一点，也不太影响图片观感。&lt;/p&gt;&lt;h3 id=&quot;gif-%E5%BE%AA%E7%8E%AF%E6%AC%A1%E6%95%B0%E8%AE%BE%E7%BD%AE&quot;&gt;GIF 循环次数设置&lt;/h3&gt;&lt;p&gt;通过 ffmpeg 还可以设置图片的循环次数。图片在播放完成后，默认会重头开始播放，如果想修改这个特性，可以通过 -loop 参数指定循环方式，也可以通过 -final_delay 参数配置间隔时间：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;设置 GIF 播放完后不重头开始：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ffmpeg -i sample.mov -r 20 -loop -1 output.gif
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;gif muxer 支持的 -loop 和 -final_delay 参数的说明可以通过命令查看：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ffmpeg -v error -h muxer=gif
Muxer gif [CompuServe Graphics Interchange Format (GIF)]:
    Common extensions: gif.
    Mime type: image/gif.
    Default video codec: gif.
GIF muxer AVOptions:
  -loop              &amp;lt;int&amp;gt;        E.......... Number of times to loop the output: -1 - no loop, 0 - infinite loop (from -1 to 65535) (default 0)
  -final_delay       &amp;lt;int&amp;gt;        E.......... Force delay (in centiseconds) after the last frame (from -1 to 65535) (default -1)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有点令人费解的是，除了无限重复(0)和不重复(-1)的值，如果你想重复 N 次，那么这个 -loop 参数就要设置为 N+1 。。。&lt;/p&gt;&lt;h2 id=&quot;%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F%E5%88%86%E6%9E%90&quot;&gt;图片大小分析&lt;/h2&gt;&lt;p&gt;最后记录一下我的一个测试资源在顺序进行以上各种处理后的大小变化情况：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;录频后的原视频：9.3M （mov格式）&lt;/li&gt;&lt;li&gt;不加任何参数转码后视频：1.5M（mov格式）&lt;/li&gt;&lt;li&gt;按需裁减后：1.2M （mov格式）&lt;/li&gt;&lt;li&gt;分辨率由 1560x1148 调整为 720x539 后：541K（mov格式）&lt;/li&gt;&lt;li&gt;帧率从 60 调整为 20 后：339K （mov格式）&lt;/li&gt;&lt;li&gt;速率 x2 后：235K （mov格式）&lt;/li&gt;&lt;li&gt;视频压缩 CRF 取值 30 后：198K （mov格式）&lt;/li&gt;&lt;li&gt;转换为 GIF ，使用全局调色板并取消防抖设置后：1.9M （gif格式）&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;GIF 格式的压缩效果和普通视频格式相比还是差很多的，不过在尽量保证图片质量的前提下，把图片大小控制在 2M 以内一般也还能够接受。&lt;/p&gt;&lt;h2 id=&quot;%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99&quot;&gt;参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zbttl-github-io.vercel.app/ya-suo-gif-tu-pian-de-fang-fa-ming-ling-xing/&quot;&gt;压缩 gif 图片的方法（命令行）&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://trac.ffmpeg.org/wiki/How%20to%20speed%20up%20/%20slow%20down%20a%20video&quot;&gt;Speeding up/slowing down video&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://slhck.info/video/2017/02/24/crf-guide.html&quot;&gt;CRF Guide&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://superuser.com/questions/556029/how-do-i-convert-a-video-to-gif-using-ffmpeg-with-reasonable-quality&quot;&gt;How do I convert a video to GIF using ffmpeg, with reasonable quality?&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://blog.pkh.me/p/21-high-quality-gif-with-ffmpeg.html#content&quot;&gt;High quality GIF with FFmpeg&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://qiita.com/yusuga/items/ba7b5c2cac3f2928f040&quot;&gt;ffmpegでとにかく綺麗なGIFを作りたい&lt;/a&gt;&lt;/p&gt;
    &lt;/section&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>550d9094b098589a2ee338d1f87c8c19</guid>
<title>欢迎加入「我爱程序员」读者圈子，一起交流！</title>
<link>https://toutiao.io/k/e1dod9e</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎加入「我爱程序员」读者圈子，一起交流！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;307&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavich3VaNkKeiaAwUhz7TQbQmic4fFsr58X9PAYleYzxqc1K1vZjeBoZDMUsmia0xH67EQYINGRvNOtLmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;圈子剧透&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、600+圈子成员，以中高级程序员为主，更有架构师、CTO坐镇交流；&lt;br/&gt;2、1000+优质主题，数十G独家资料，每日分享，精挑细选；&lt;br/&gt;3、全年52期专属邮件周报，让你轻松掌握业界资讯、技术干货，提升认知水平；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;心动不如行动，赶快加入吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dd9b00954db21a0edb0ac49cf122f4ce</guid>
<title>使用 LSTM 对销售额预测（Python代码）</title>
<link>https://toutiao.io/k/ji1yelr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;span&gt;来源：DeepHub IMBA&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;大家经常会遇到一些需要预测的场景，比如预测品牌销售额，预测产品销量。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;今天给大家分享一波使用 LSTM 进行端到端时间序列预测的完整代码和详细解释。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们先来了解两个主题：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;时间序列分析：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;时间序列表示基于时间顺序的一系列数据。它可以是秒、分钟、小时、天、周、月、年。未来的数据将取决于它以前的值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在现实世界的案例中，我们主要有两种类型的时间序列分析：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于单变量时间序列数据，我们将使用单列进行预测。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2612612612612613&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6Ph9QU9IIIq6kC0cCXOOpib8jxesdaNbyElypgkfqiaqzNLEKIRhU1ibc1IoNrHfmaxrOoKwkgAU5zYJTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;222&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;正如我们所见，只有一列，因此即将到来的未来值将仅取决于它之前的值。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是在多元时间序列数据的情况下，将有不同类型的特征值并且目标数据将依赖于这些特征。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3023255813953488&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6Ph9QU9IIIq6kC0cCXOOpib8jxA5fnDeAHAqiadfdZxau0XVOP4Xr9YEejUBnDT0CkmGgqynmdjCZDTuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;989&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;正如在图片中看到的，在多元变量中将有多个列来对目标值进行预测。（上图中“count”为目标值）&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在上面的数据中，count不仅取决于它以前的值，还取决于其他特征。因此，要预测即将到来的count值，我们必须考虑包括目标列在内的所有列来对目标值进行预测。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在执行多元时间序列分析时必须记住一件事，我们需要使用多个特征预测当前的目标，让我们通过一个例子来理解：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在训练时，如果我们使用 5 列 [feature1, feature2, feature3, feature4, target] 来训练模型，我们需要为即将到来的预测日提供 4 列 [feature1, feature2, feature3, feature4]。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;LSTM&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文中不打算详细讨论LSTM。所以只提供一些简单的描述，如果你对LSTM没有太多的了解，可以参考我们以前发布的文章。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;LSTM基本上是一个循环神经网络，能够处理长期依赖关系。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;假设你在看一部电影。所以当电影中发生任何情况时，你都已经知道之前发生了什么，并且可以理解因为过去发生的事情所以才会有新的情况发生。RNN也是以同样的方式工作，它们记住过去的信息并使用它来处理当前的输入。RNN的问题是，由于渐变消失，它们不能记住长期依赖关系。因此为了避免长期依赖问题设计了lstm。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在我们讨论了时间序列预测和LSTM理论部分。让我们开始编码。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;让我们首先导入进行预测所需的库：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre spellcheck=&quot;false&quot; cid=&quot;n52&quot; mdtype=&quot;fences&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;code-snippet__keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; pandas &lt;span class=&quot;code-snippet__keyword&quot;&gt;as&lt;/span&gt; pd&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; matplotlib &lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; pyplot &lt;span class=&quot;code-snippet__keyword&quot;&gt;as&lt;/span&gt; plt&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; tensorflow.keras.models &lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; Sequential&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; tensorflow.keras.layers &lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; LSTM&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; tensorflow.keras.layers &lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; Dense, Dropout&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; sklearn.preprocessing &lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; MinMaxScaler&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; keras.wrappers.scikit_learn &lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; KerasRegressor&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; sklearn.model_selection &lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; GridSearchCV&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;加载数据，并检查输出：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;df=pd.read_csv(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;train.csv&quot;&lt;/span&gt;,parse_dates=[&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Date&quot;&lt;/span&gt;],index_col=[0])&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;df.head()&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43586206896551727&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6Ph9QU9IIIq6kC0cCXOOpib8jxBHWH2Hl16Mto8rLwStAriamX5Fov98fnxUic98VB6tmWfuu2DbzXV9Qw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;725&quot;/&gt;&lt;/section&gt;&lt;pre spellcheck=&quot;false&quot; cid=&quot;n60&quot; mdtype=&quot;fences&quot;&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.tail&lt;/span&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre spellcheck=&quot;false&quot; cid=&quot;n60&quot; mdtype=&quot;fences&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4703656998738966&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6Ph9QU9IIIq6kC0cCXOOpib8jxyPJB6gjwHricgZy3YJ2vtLNlhoHht4lxsqT7ots97m3b1MXexxEzZsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;793&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在让我们花点时间看看数据：csv文件中包含了谷歌从2001-01-25到2021-09-29的股票数据，数据是按照天数频率的。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[如果您愿意，您可以将频率转换为“B”[工作日]或“D”，因为我们不会使用日期，我只是保持它的现状。]&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里我们试图预测“Open”列的未来值，因此“Open”是这里的目标列。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;让我们看一下数据的形状：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre spellcheck=&quot;false&quot; cid=&quot;n70&quot; mdtype=&quot;fences&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.shape&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;(5203,5)&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;现在让我们进行训练测试拆分。这里我们不能打乱数据，因为在时间序列中必须是顺序的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre spellcheck=&quot;false&quot; cid=&quot;n79&quot; mdtype=&quot;fences&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;test_split=round(len(df)*0.20)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;df_for_training=df[:-1041]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;df_for_testing=df[-1041:]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(df_for_training.shape)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(df_for_testing.shape)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;(4162, 5)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;(1041, 5)&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;可以注意到数据范围非常大，并且它们没有在相同的范围内缩放，因此为了避免预测错误，让我们先使用MinMaxScaler缩放数据。(也可以使用StandardScaler)&lt;/span&gt;&lt;/section&gt;&lt;pre spellcheck=&quot;false&quot; cid=&quot;n84&quot; mdtype=&quot;fences&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;scaler = MinMaxScaler(feature_range=(0,1))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;df_for_training_scaled = scaler.fit_transform(df_for_training)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;df_for_testing_scaled=scaler.transform(df_for_testing)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;df_for_training_scaled&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24689826302729528&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6Ph9QU9IIIq6kC0cCXOOpib8jxHnNm8rbLYbuheAFp3e4VfZpS9XpytPbiajDHUNhT0O2YAibon2Z2xz1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;806&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;将数据拆分为X和Y，这是最重要的部分，正确阅读每一个步骤。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre spellcheck=&quot;false&quot; cid=&quot;n100&quot; mdtype=&quot;fences&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;createXY&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(dataset,n_past)&lt;/span&gt;&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  dataX = []&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  dataY = []&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; range(n_past, len(dataset)):&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          dataX.append(dataset[i - &lt;span class=&quot;code-snippet__symbol&quot;&gt;n_past:&lt;/span&gt;i, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;code-snippet__symbol&quot;&gt;:dataset&lt;/span&gt;.shape[&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;]])&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          dataY.append(dataset[i,&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; np.array(dataX),np.array(dataY)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;trainX,trainY=createXY(df_for_training_scaled,&lt;span class=&quot;code-snippet__number&quot;&gt;30&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;testX,testY=createXY(df_for_testing_scaled,&lt;span class=&quot;code-snippet__number&quot;&gt;30&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;让我们看看上面的代码中做了什么：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;N_past是我们在预测下一个目标值时将在过去查看的步骤数。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里使用30，意味着将使用过去的30个值(包括目标列在内的所有特性)来预测第31个目标值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因此，在trainX中我们会有所有的特征值，而在trainY中我们只有目标值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;让我们分解for循环的每一部分：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于训练，dataset = df_for_training_scaled, n_past=30&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当i= 30：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;data_X&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.addend&lt;/span&gt; (&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;df_for_training_scaled&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[i - n_past:i, 0:df_for_training.shape[1]&lt;/span&gt;])&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从n_past开始的范围是30，所以第一次数据范围将是-[30 - 30,30,0:5] 相当于 [0:30,0:5]&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因此在dataX列表中，df_for_training_scaled[0:30,0:5]数组将第一次出现。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在, dataY.append(df_for_training_scaled[i,0])&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;i = 30，所以它将只取第30行开始的open(因为在预测中，我们只需要open列，所以列范围仅为0，表示open列)。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第一次在dataY列表中存储df_for_training_scaled[30,0]值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以包含5列的前30行存储在dataX中，只有open列的第31行存储在dataY中。然后我们将dataX和dataY列表转换为数组，它们以数组格式在LSTM中进行训练。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们来看看形状。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre spellcheck=&quot;false&quot; cid=&quot;n120&quot; mdtype=&quot;fences&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;trainX Shape-- &quot;&lt;/span&gt;,trainX.shape)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;trainY Shape-- &quot;&lt;/span&gt;,trainY.shape)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;(4132, 30, 5)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;(4132,)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;testX Shape-- &quot;&lt;/span&gt;,testX.shape)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;testY Shape-- &quot;&lt;/span&gt;,testY.shape)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;(1011, 30, 5)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;(1011,)&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;4132 是 trainX 中可用的数组总数，每个数组共有 30 行和 5 列， 在每个数组的 trainY 中，我们都有下一个目标值来训练模型。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;让我们看一下包含来自 trainX 的 (30,5) 数据的数组之一 和 trainX 数组的 trainY 值：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre spellcheck=&quot;false&quot; cid=&quot;n127&quot; mdtype=&quot;fences&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;trainX[0]-- \n&quot;&lt;/span&gt;,trainX[0])&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;trainY[0]-- &quot;&lt;/span&gt;,trainY[0])&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0254491017964071&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6Ph9QU9IIIq6kC0cCXOOpib8jxbbFyfyK2b1DTic8039b7eVnIDhicjwia8n9fRPb842RWcicGsGJXIrsQJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;668&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果查看 trainX[1] 值，会发现到它与 trainX[0] 中的数据相同（第一列除外），因为我们将看到前 30 个来预测第 31 列，在第一次预测之后它会自动移动 到第 2 列并取下一个 30 值来预测下一个目标值。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;让我们用一种简单的格式来解释这一切：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre spellcheck=&quot;false&quot; cid=&quot;n146&quot; mdtype=&quot;fences&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;trainX&lt;/span&gt; — — →&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;trainY&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[0 : 30,0:5]&lt;/span&gt; → &lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[30,0]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[1:31, 0:5]&lt;/span&gt; → &lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[31,0]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[2:32,0:5]&lt;/span&gt; →&lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[32,0]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;像这样，每个数据都将保存在 trainX 和 trainY 中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在让我们训练模型，我使用 girdsearchCV 进行一些超参数调整以找到基础模型。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre spellcheck=&quot;false&quot; cid=&quot;n154&quot; mdtype=&quot;fences&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;def &lt;span class=&quot;code-snippet__title&quot;&gt;build_model&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;optimizer&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  grid_model&lt;/span&gt; = Sequential()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  grid_model.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(LSTM(&lt;span class=&quot;code-snippet__number&quot;&gt;50&lt;/span&gt;,return_sequences=True,input_shape=(&lt;span class=&quot;code-snippet__number&quot;&gt;30&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  grid_model.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(LSTM(&lt;span class=&quot;code-snippet__number&quot;&gt;50&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  grid_model.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(Dropout(&lt;span class=&quot;code-snippet__number&quot;&gt;0.2&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  grid_model.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(Dense(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;grid_model.compile(loss = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;mse&#x27;&lt;/span&gt;,optimizer = optimizer)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; grid_modelgrid_model = KerasRegressor(build_fn=build_model,verbose=&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;,validation_data=(testX,testY))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;parameters = {&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;batch_size&#x27;&lt;/span&gt; : [&lt;span class=&quot;code-snippet__number&quot;&gt;16&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;20&lt;/span&gt;],&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;epochs&#x27;&lt;/span&gt; : [&lt;span class=&quot;code-snippet__number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;],&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;optimizer&#x27;&lt;/span&gt; : [&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;adam&#x27;&lt;/span&gt;,&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;Adadelta&#x27;&lt;/span&gt;] }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;grid_search = GridSearchCV(estimator = grid_model,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          param_grid = parameters,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          cv = &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;如果你想为你的模型做更多的超参数调整，也可以添加更多的层。但是如果数据集非常大建议增加 LSTM 模型中的时期和单位。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在第一个 LSTM 层中看到输入形状为 (30,5)。它来自 trainX 形状。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;trainX&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.shape&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[1]&lt;/span&gt;,&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;trainX&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.shape&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[2]&lt;/span&gt;) → (30,5)&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在让我们将模型拟合到 trainX 和 trainY 数据中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre spellcheck=&quot;false&quot; cid=&quot;n161&quot; mdtype=&quot;fences&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;grid_search&lt;/span&gt; = grid_search.fit(trainX,trainY)&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;由于进行了超参数搜索，所以这将需要一些时间来运行。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;你可以看到损失会像这样减少：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3142857142857143&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6Ph9QU9IIIq6kC0cCXOOpib8jx2jpglcKOPqdhLk0nV0FfXIsAgfkibuae1XHcqQQzfIa2HFxoiaicvp2zA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;875&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在让我们检查模型的最佳参数。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre spellcheck=&quot;false&quot; cid=&quot;n169&quot; mdtype=&quot;fences&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;grid_search.best_params_&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;{‘batch_size’: 20, ‘epochs’: 10, ‘optimizer’: ‘adam’}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;将最佳模型保存在 my_model 变量中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre spellcheck=&quot;false&quot; cid=&quot;n173&quot; mdtype=&quot;fences&quot;&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;my_model&lt;/span&gt;=grid_search.best_estimator_.model&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;现在可以用测试数据集测试模型。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;prediction=my_model.predict(testX)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;prediction\n&quot;&lt;/span&gt;, prediction)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;\nPrediction Shape-&quot;&lt;/span&gt;,prediction.shape)&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6378504672897196&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6Ph9QU9IIIq6kC0cCXOOpib8jx5H7jU9WqThkq76C9BU5fQEGpolF4gCuiamJ4r9Tfib9pKD5McF4pjc9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;428&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; testY 和 prediction 的长度是一样的。现在可以将 testY 与预测进行比较。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是我们一开始就对数据进行了缩放，所以首先我们必须做一些逆缩放过程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre spellcheck=&quot;false&quot; cid=&quot;n184&quot; mdtype=&quot;fences&quot;&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;scaler&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.inverse_transform&lt;/span&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;prediction&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre spellcheck=&quot;false&quot; cid=&quot;n184&quot; mdtype=&quot;fences&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2765714285714286&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6Ph9QU9IIIq6kC0cCXOOpib8jxrt8SYPQic4MV6gWfRcotxv1CutLjUrNI6UicNxeJp4YGz8LRicWuCicVKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;875&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;报错了，这是因为在缩放数据时，我们每行有 5 列，现在我们只有 1 列是目标列。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以我们必须改变形状来使用 inverse_transform：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre spellcheck=&quot;false&quot; cid=&quot;n192&quot; mdtype=&quot;fences&quot;&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;prediction_copies_array&lt;/span&gt; = np.repeat(prediction,&lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt;, axis=-&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre spellcheck=&quot;false&quot; cid=&quot;n192&quot; mdtype=&quot;fences&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.26872770511296074&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6Ph9QU9IIIq6kC0cCXOOpib8jxkQ1kwLF80h5vaM11QWtptvyIkLia4uRgLGNeJSQbrMe3ejdibCPC8K4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;841&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;5 列值是相似的，它只是将单个预测列复制了 4 次。所以现在我们有 5 列相同的值 。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre spellcheck=&quot;false&quot; cid=&quot;n202&quot; mdtype=&quot;fences&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;prediction_copies_array&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.shape&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;(1011,5)&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这样就可以使用 inverse_transform 函数。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre spellcheck=&quot;false&quot; cid=&quot;n208&quot; mdtype=&quot;fences&quot;&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;pred&lt;/span&gt;=scaler.inverse_transform(np.reshape(prediction_copies_array,(len(prediction),&lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt;)))[:,&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是逆变换后的第一列是我们需要的，所以我们在最后使用了 → [:,0]。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在将这个 pred 值与 testY 进行比较，但是 testY 也是按比例缩放的，也需要使用与上述相同的代码进行逆变换。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre spellcheck=&quot;false&quot; cid=&quot;n214&quot; mdtype=&quot;fences&quot;&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;original_copies_array&lt;/span&gt; = np.repeat(testY,&lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt;, axis=-&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;original&lt;/span&gt;=scaler.inverse_transform(np.reshape(original_copies_array,(len(testY),&lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt;)))[:,&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在让我们看一下预测值和原始值：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre spellcheck=&quot;false&quot; cid=&quot;n218&quot; mdtype=&quot;fences&quot;&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Pred Values-- &quot;&lt;/span&gt; ,pred)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;\nOriginal Values-- &quot;&lt;/span&gt; ,original)&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.10857142857142857&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6Ph9QU9IIIq6kC0cCXOOpib8jx4oibs76mK1via0AmbRn4ytibK1vY3PgiaBlAyRKPx5nvgyciaZr4zCGGIew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;875&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后绘制一个图来对比我们的 pred 和原始数据。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;plt.plot(original, color = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;red&#x27;&lt;/span&gt;, label = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;Real Stock Price&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;plt.plot(pred, color = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;blue&#x27;&lt;/span&gt;, label = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;Predicted Stock Price&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;plt.title(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;Stock Price Prediction&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;plt.xlabel(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;Time&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;plt.ylabel(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;Google Stock Price&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;plt.legend()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;plt.show()&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5903271692745377&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6Ph9QU9IIIq6kC0cCXOOpib8jxw9FtmoKxdJyybshh7hx0mCIibl5GGrfMQvzVMXK7WXwpE0GCYia6h3Dw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;703&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;看样子还不错，到目前为止，我们训练了模型并用测试值检查了该模型。现在让我们预测一些未来值。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从主 df 数据集中获取我们在开始时加载的最后 30 个值[为什么是 30？因为这是我们想要的过去值的数量，来预测第 31 个值]&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;df_30_days_past=df.iloc[-30:,:]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;df_30_days_past.tail()&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42916666666666664&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6Ph9QU9IIIq6kC0cCXOOpib8jxxqm56KPUUSZibhQh5aZSDXfdgbmMKH5e1C3r32vnHdEqDQFyLrsJoVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以看到有包括目标列（“Open”）在内的所有列。现在让我们预测未来的 30 个值。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在多元时间序列预测中，需要通过使用不同的特征来预测单列，所以在进行预测时我们需要使用特征值（目标列除外）来进行即将到来的预测。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里我们需要“High”、“Low”、“Close”、“Adj Close”列的即将到来的 30 个值来对“Open”列进行预测。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;df_30_days_future=pd.read_csv(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;test.csv&quot;&lt;/span&gt;,parse_dates=[&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Date&quot;&lt;/span&gt;],index_col=[0])&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;df_30_days_future&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5136986301369864&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6Ph9QU9IIIq6kC0cCXOOpib8jxuC1rclx5dnAl1xAokJ6enibfL0ueqAgMA84EiceJlnLUfSpLUgxSC9DA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;584&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;剔除“Open”列后，使用模型进行预测之前还需要做以下的操作：&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;缩放数据，因为删除了‘Open’列，在缩放它之前，添加一个所有值都为“0”的Open列。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;缩放后，将未来数据中的“Open”列值替换为“nan”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在附加 30 天旧值和 30 天新值（其中最后 30 个“打开”值是 nan）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre spellcheck=&quot;false&quot; cid=&quot;n263&quot; mdtype=&quot;fences&quot;&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;df_30_days_future[&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Open&quot;&lt;/span&gt;]=0&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;df_30_days_future=df_30_days_future[[&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Open&quot;&lt;/span&gt;,&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;High&quot;&lt;/span&gt;,&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Low&quot;&lt;/span&gt;,&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Close&quot;&lt;/span&gt;,&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Adj Close&quot;&lt;/span&gt;]]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;old_scaled_array=scaler.transform(df_30_days_past)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;new_scaled_array=scaler.transform(df_30_days_future)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;new_scaled_df=pd.DataFrame(new_scaled_array)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;new_scaled_df.iloc[:,0]=np.nan&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;full_df=pd.concat([pd.DataFrame(old_scaled_array),new_scaled_df]).reset_index().drop([&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;index&quot;&lt;/span&gt;],axis=1)&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre spellcheck=&quot;false&quot; cid=&quot;n263&quot; mdtype=&quot;fences&quot;&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt; full_df  形状是 (60,5)，最后第一列有 30 个 nan 值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;要进行预测必须再次使用 for 循环，我们在拆分 trainX 和 trainY 中的数据时所做的。但是这次我们只有 X，没有 Y 值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre spellcheck=&quot;false&quot; cid=&quot;n269&quot; mdtype=&quot;fences&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;full_df_scaled_array&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;full_df.values&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;all_data&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;[]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;time_step&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;30&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;i in range(time_step,len(full_df_scaled_array)):&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;data_x&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;[]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;data_x.append(&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;full_df_scaled_array[i-time_step&lt;/span&gt; :&lt;span class=&quot;code-snippet__string&quot;&gt;i , 0:full_df_scaled_array.shape[1]])&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;data_x&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;np.array(data_x)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;prediction&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;my_model.predict(data_x)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;all_data.append(prediction)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__meta&quot;&gt;full_df.iloc[i,0]&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;prediction&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt; 对于第一个预测，有之前的 30 个值，当 for 循环第一次运行时它会检查前 30 个值并预测第 31 个“Open”数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当第二个 for 循环将尝试运行时，它将跳过第一行并尝试获取下 30 个值 [1:31] 。这里会报错错误因为Open列最后一行是 “nan”，所以需要每次都用预测替换“nan”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后还需要对预测进行逆变换：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;new_array=np.array(all_data)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;new_array=new_array.reshape(-1,1)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;prediction_copies_array = np.repeat(new_array,5, axis=-1)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;y_pred_future_30_days = scaler.inverse_transform(np.reshape(prediction_copies_array,(len(new_array),5)))[:,0]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(y_pred_future_30_days)&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23558897243107768&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6Ph9QU9IIIq6kC0cCXOOpib8jxKQX9Hr3mibnH7DVCQj73s5wH16jBe81nSaUHzHKbLt1SlgyUS630TNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;798&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这样一个完整的流程就已经跑通了。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你想看完整的代码，可以在这里查看：&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;https://github.com/sksujan58/Multivariate-time-series-forecasting-using-LSTM&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;作者：Sksujanislam&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hN1l83J6Ph9yhTLzOamqiatY1c5KevJq5vdDicE3PHyAibHmlghpyZFLdgYKaKMlOqHicgzvcol2g5KThMM7kUO5Xw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>417ef39e3cf0d8fc28af9e49ccc26467</guid>
<title>Kubernetes标志着大量采用Sigstore来保护开源生态系统</title>
<link>https://toutiao.io/k/3zg33tf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;Kubernetes 1.24 是第一个正式使用 Sigstore 的版本，能够无缝验证签名，以防止 560 万开发者社区遭受供应链攻击&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;292&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5233333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJwWIABicE7pLGbypVvZe95PdvFJ80CwQwqI398iaqXewy5y1W6wu9Cp3ETzaJ2NOA7Ss53J3ULKp1nA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kubernetes 和 Sigstore 社区今天宣布，Kubernetes 将在生产中采用 Sigstore 来签署工件和验证签名，这使得 Kubernetes 用户第一次能够验证他们正在使用的发行版正是它所声称的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;去年刚刚推出的 Sigstore 是一项面向软件开发人员的免费签名服务，它通过实现由透明日志技术支持的加密软件签名的轻松采用，提高了软件供应链的安全性。它迅速成为签名、验证和保护软件的标准，因为它能够自动进行数字签名和检查软件工件，使软件具有更安全的监管链，可以追溯到源头。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天发布的 Kubernetes 1.24 以及所有未来的版本都将包括加密签名的 Sigstore 证书，使用户能够验证签名，并对每个已部署的 Kubernetes 二进制文件、源代码包和容器镜像的来源更有信心。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“这是保护 Kubernetes 生态系统完整性的巨大一步，表明由于供应链攻击的增加，大规模代码签名是可能的，坦率地说是必要的。”Chainguard 开源负责人 Tracy Miranda 表示：“这种采用和集成是与多个利益相关方数月合作的结果，也是对开源协作力量的证明。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“很高兴看到 sigstore 的采用，特别是像 Kubernetes 这样的项目，它运行许多需要最大限度保护的关键工作负载，”Red Hat CTO 安全工程主管、Kubernetes 安全响应团队成员、sigstore 项目创始人 Luke Hinds 说。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“Kubernetes 是一个众所周知并被广泛采用的开源项目，它可以激励其他开源项目通过遵循 SLSA 等级，并使用 Sigstore 签名来提高他们的软件供应链安全性，”Google 软件工程师、Sigstore TSC 成员和项目创始人 Bob Callaway 说。“我们将 Sigstore 打造得简单、免费、无缝，这样它就会被广泛采用，并保护我们免受供应链攻击。Kubernetes 选择使用 Sigstore 就是对这项工作的证明。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2021 年初，Kubernetes 发布团队开始探索 SLSA 合规性，以提高 Kubernetes 软件供应链的安全性。SLSA 是一个安全框架，包括一个标准和控制清单，以防止篡改，提高完整性，并保护你的项目，业务或企业的软件包和基础设施。Sigstore 是实现 SLSA 2 级标准的关键项目，也是实现 SLSA 3 级标准的开端，Kubernetes 社区希望在今年 8 月实现这一目标。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sigstore 还为 Kubernetes 社区带来了各种好处，包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Sigstore 的无密钥签名为开发人员提供了良好的体验，并且消除了痛苦的密钥管理需求。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Sigstore 的公共透明日志（&lt;span&gt;Rekor&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;）和 API 意味着 Kubernetes 的消费者可以很容易地验证签名的工件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Sigstore 对标准的使用，例如对任何 OCI（Open Container Initiative）工件（包括容器、Helm Charts、配置文件和策略包）和 OIDC（OpenID Connect）的支持，意味着它可以与其他工具和服务无缝集成。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非常活跃的、开源的和厂商中立的 Sigstore 社区给了我们信心，相信这个项目会很快被采用并成为事实上的行业标准。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“多年来，SIG Release 一直致力于逐步增强 Kubernetes 项目版本的健壮性。这一最新的声明，以及开源社区之间的合作使之成为可能，是在行业内越来越意识到软件供应链和开源项目发布是一个我们都必须努力改进的关键领域的背景下出现的。安全是一个永无止境的旅程，但为降低攻击者破坏我们供应链完整性的能力而采取的每一步都非常重要。”VMware 开源技术中心负责人、Kubernetes 指导委员会和荣誉退休 SIG Release 负责人 Tim Pepper 说。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“我个人为整个 SIG 发布团队感到骄傲，尤其是发布工程子项目。我们设法交付了一个重要的里程碑，作为我们总体&lt;span&gt;路线图和愿景&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;的一部分，为 Kubernetes 建立一个可消费、可内省且安全的供应链。为供应链安全树立榜样是我们目前最重要的工作之一。在 Kubernetes v1.24 发布周期中，我们设法完成了 50 多个 GitHub 问题，并且只为容器镜像签名的 MVP（最低价值产品，Minimum Valuable Product）拉请求，这对整个团队来说是一个巨大的成就！我谨代表 SIG 发布领导团队再次向你表示感谢，我们期待着供应链安全的美好未来，”Kubernetes SIG Release 主席兼 RedHat 高级软件工程师 Sascha Grunert 说道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了数百万直接或间接使用 Kubernetes 的开发人员之外，这也有利于公司中所有旨在符合最近的 NIST 安全软件开发框架（SSDF）要求的人。（参见&lt;span&gt;Sigstore + NIST SSDF&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多关于 Sigstore 的信息，请访问：&lt;span&gt;https://www.sigstore.dev/&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Rekor: &lt;em&gt;https://github.com/sigstore/rekor&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;路线图和愿景: &lt;em&gt;https://github.com/kubernetes/sig-release/blob/master/roadmap.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;Sigstore + NIST SSDF: &lt;em&gt;https://blog.chainguard.dev/how-sigstore-can-help-you-and-your-team-follow-the-nist-ssdf-recommendations/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击【阅读原文】阅读网站原文。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;161&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;161&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJx1SZdjAGMooqc4a0WyTWthibiarPRsVISmajGaia3g9E3y8k6plcfFl74Sh0ajlWRnYA5D4M08ibQMMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CNCF概况（幻灯片）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-copyright=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;161&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;161&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJxyapkOjiazruKNQ7DZ6t8TSh0QSYM4DlI86xnXiayciayIgBUaG8q8lFZ3FsibPJiaeCqAahrKicB220aA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;301&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;扫描二维码联系我们！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;CNCF (Cloud Native Computing Foundation)成立于2015年12月，隶属于Linux  Foundation，是非营利性组织。 &lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;&lt;strong&gt;&lt;em&gt;CNCF&lt;/em&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;（&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;&lt;strong&gt;&lt;em&gt;云原生计算基金会&lt;/em&gt;&lt;/strong&gt;）致力于培育和维护一个厂商中立的开源生态系统，来推广云原生技术。我们通过将最前沿的模式民主化，让这些创新为大众所用。请长按以下二维码进行关注。&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJyq2qDvc7MWGZxI4RSwuQcDYF9lD2fuOvw9rvdXWTxODu56IibWa0R8mibibhqExqurr6168Wjf2VstQ/640?wx_fmt=png&quot; data-copyright=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;165&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;165&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/GpkQxibjhkJxKPX3Ywf6bvZic6ibE8EzomstVhFq0ua8p8KI8PdVve5Q6YwRzHYQ4j63hKakYPcbqAdDoRHrgcFLg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>27fda9279b08a97009d868009a5e92eb</guid>
<title>知识图谱之第一性原理</title>
<link>https://toutiao.io/k/2d7sk19</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;知识图谱是个知识网络？是个语义图？是个关系图？好像这些都没有直达本质，那本质是什么？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5525197328476017&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uVhqWvaiaiaPM7Q3DT6IcvsB8wTC8wLfIutcYwNW8EMLfOGFNNtlLD58ZRSicNryTzmup1st3ACSdMg0TL02lKsXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1647&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们知道，数学的一个重要思维是公理思维，定义几个简单的公理，然后就可以用逻辑推出很多的引理，定理，从而完成一个完备公理体系，或严密的逻辑体系。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;比如&lt;span&gt;欧式几何，它首先定义五大公理：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 过不同两点，能作且只能作一直线（直线公理）；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;2. 线段（有限直线）可以任意地延长；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;3. 以任一点为圆心、任意长为半径，可作一圆(圆公理)；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;4. 凡是直角都相等(角公理)；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;5. 两直线被第三条直线所截，如果同侧两内角和小于两个直角，则两直线则会在该侧相交。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0285714285714285&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uVhqWvaiaiaPM7Q3DT6IcvsB8wTC8wLfIuGqMcHDHcIsMv9lU80K5tiaRUXjbLhIwa0ZBeIebah2vGZOfyflSOeWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;欧几里德把人们公认的一些事实列成定义和公理，以形式逻辑的方法，用这些定义和公理来研究各种几何图形的性质，从而建立了一套从公理、定义出发，论证命题得到定理&lt;/span&gt;&lt;span&gt;的&lt;span&gt;几何学论证方法，形成了一个严密的逻辑体系。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;知识图谱，和欧几里德的数学思维一样，也是一种公理体系。不同的知识图谱，就如不同的数学体系，分别是不同的公理体系，形成一个自洽的逻辑体系。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如，家庭关系的知识图谱，只需要定义三大关系（公理），其它的关系都可以由这三大基础关系定义出来（定理）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. &lt;strong&gt;性别关系&lt;/strong&gt;，一个人是男性还是女性；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. &lt;strong&gt;出生关系&lt;/strong&gt;，谁生了谁；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. &lt;strong&gt;婚姻关系&lt;/strong&gt;，谁和谁结婚。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8242424242424242&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uVhqWvaiaiaPM7Q3DT6IcvsB8wTC8wLfIuU0rCa1Y50rMqe4IuSbfDDyb52fFnI9TvviahbzqMc1xv8CuYibqfibNQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;825&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有了这三大关系，就可以定义儿子，女儿，父亲，母亲，哥哥，姐姐，叔叔，阿姨，爷爷，奶奶，外公，外婆，等等。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;儿子就是&lt;strong&gt;性别关系&lt;/strong&gt;是男性，和某个人有被&lt;strong&gt;出生关系&lt;/strong&gt;。女儿就是&lt;strong&gt;性别关系&lt;/strong&gt;是女性，和某个人有被&lt;strong&gt;出生关系&lt;/strong&gt;。母亲就是&lt;strong&gt;性别关系&lt;/strong&gt;是女性，和某个人有&lt;strong&gt;出生关系&lt;/strong&gt;。父亲就是&lt;strong&gt;性别关系&lt;/strong&gt;是男性，和某个&lt;strong&gt;性别关系&lt;/strong&gt;是女性的人有&lt;strong&gt;婚姻关系&lt;/strong&gt;，而且这个女性和另外一个人有&lt;strong&gt;出生关系&lt;/strong&gt;。以此类推，可以定义其他的家庭成员。想想，如何教一个小孩复杂的家庭称谓，是不是根据这种公理思维来学习的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由此可见，知识图谱的精华在于，任何的概念（本体）都是可以用精确的逻辑给定义出来的。而不是大家看到的字面的表达，比如”儿子“这个概念，不管你是用中文”儿子“，还是英文”son”来表示，还是外星人文字“%#&amp;amp;@”，它的内涵都是用公理之间的逻辑关系来精确定义的，丝毫没有歧义，不同的人，人和机器之间，都是能理解。也就是说，除了先前定义的几条公理，不需要任何其它的背景知识来完成人和人，人和机器，机器和机器的沟通，这就是知识图谱的意义所在。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;很多讲知识图谱的东西，还基本停留在表面和浅层，而没有涉及到知识图谱的深层和内涵，什么东西，都应该看到它的第一性原理。我们这里，从数学的公理思维出发，让大家真正看到知识图谱实际上是一个公理系统，一个严密的逻辑系统。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6153846153846154&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uVhqWvaiaiaPM7Q3DT6IcvsB8wTC8wLfIuKZyyGa8QtRqDo8tWhjYSuicfWFP2t35AmMrPNdicFsKqj7Ex408lYMLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有了严密的逻辑，知识图谱就能以形式逻辑，集合论，和其它数学为工具，来验证一个知识图谱建构的有效性（有没有冲突，有没有矛盾），来证明一个论断，来推理出隐含的新的知识。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>