<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3cffc86198f06ef337064d7d02780394</guid>
<title>资料 | 开源生态白皮书（2020 年）</title>
<link>https://toutiao.io/k/0s9musw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;大家好，我是周刊菌。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1113&quot; data-ratio=&quot;1.3146666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavibyM0D0HBAs4Ms1W3w0ueWFaQxoh50CBnAntj8UBL5sFia3SudpHAicqWGCq3pLFwyiaH1ia65669W4mg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;「码农周刊 VIP 会员」推出 31 周啦！感谢亲们的大力支持！第 031 期「码农周刊 VIP 会员专属邮件周报」已发送完毕，请注意查收。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;告诉大家一个好消息&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：已有数位上市公司 CTO 低调订阅了我们的「码农周刊 VIP 会员专属邮件周报」，感谢肯定！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;255&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;255&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ7PeUupLzwuuAibicnrRNxKcfCY7fIva78efKsUzANlCCAeuSQEGkGm34rKkzNRpzy6IiaiaHmBNA6DcA/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;「码农周刊 VIP 会员」是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;简介版&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;码农周刊 VIP 会员 = 全年 52 期「VIP 会员专属邮件周报」 + 只限 VIP 会员加入的交流圈子 + 大厂「内推机会」 + N 多福利&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;详细版&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击「阅读原文」即可查看详细介绍&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;加入「码农周刊 VIP 会员」，与上市公司 CTO 一起成长！&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;全年 52 期「VIP 会员专属邮件周报」 + 只限 VIP 会员加入的交流圈子 + 大厂「内推机会」 + N 多福利，你值得拥有！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;原价 365 元/年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;，现价仅需 108 元！&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;260&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;260&quot; data-ratio=&quot;1.3478260869565217&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavibNJDoLvVWUq6RKn5LwtlzRHSMFBED29234hRwibmOzJF4XxKOv5lzRVCelQJIEIOaXh3vYRHOMRzQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>661467b5cc452e52945f98432978b04b</guid>
<title>学习函数式编程 Monad</title>
<link>https://toutiao.io/k/5jrdqcv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上一篇文章中，我们讨论了常用的函数式编程案例，一些同学反馈没有讲到底层概念，想了解一下什么是 Monad？基于这个问题，我们来探究一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在函数式编程中，Monad 是一种结构化程序的抽象，我们通过三个部分来理解一下。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Monad 定义&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Monad 使用场景&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Monad 一句话解释&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Monad 定义&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据维基百科的定义，Monad 由以下三个部分组成：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个类型构造函数（M），可以构建出一元类型 &lt;code&gt;M&amp;lt;T&amp;gt;&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个类型转换函数（return or unit），能够把一个原始值装进 M 中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个组合函数 bind，能够把 M 实例中的值取出来，放入一个函数中去执行，最终得到一个新的 M 实例。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，它还遵守一些规则：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;单位元规则，通常由 unit 函数去实现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;结合律规则，通常由 bind 函数去实现。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;单位元：是集合里的一种特别的元素，与该集合里的二元运算有关。当单位元和其他元素结合时，并不会改变那些元素。&lt;/p&gt;&lt;p&gt;乘法的单位元就是 1，任何数 x 1 = 任何数本身、1 x 任何数 = 任何数本身。&lt;/p&gt;&lt;p&gt;加法的单位元就是 0，任何数 + 0 = 任何数本身、0 + 任何数 = 任何数本身。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些定义很抽象，我们用一段 js 代码来模拟一下。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Monad&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  value = &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// 构造函数&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(value) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.value = value;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// unit，把值装入 Monad 构造函数中&lt;/span&gt;&lt;br/&gt;  unit(value) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.value = value;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// bind，把值转换成一个新的 Monad&lt;/span&gt;&lt;br/&gt;  bind(fn) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; fn(&lt;span&gt;this&lt;/span&gt;.value);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 满足 x-&amp;gt; M(x) 格式的函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add1&lt;/span&gt;(&lt;span&gt;x&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Monad(x + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 满足 x-&amp;gt; M(x) 格式的函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;square&lt;/span&gt;(&lt;span&gt;x&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Monad(x * x);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 接下来，我们就能进行链式调用了&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; a = &lt;span&gt;new&lt;/span&gt; Monad(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;     .bind(square)&lt;br/&gt;     .bind(add1);&lt;br/&gt;     &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(a.value === &lt;span&gt;5&lt;/span&gt;); &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述代码就是一个最基本的 Monad，它将程序的多个步骤抽离成线性的流，通过 bind 方法对数据流进行加工处理，最终得到我们想要的结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Ok，我们已经明白了 Monad 的内部结构，接下来，我们再看一下 Monad 的使用场景。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Monad 使用场景&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 Monad 的规则，衍生出了许多使用场景。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;组装多个函数，实现链式操作。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;链式操作可以消除中间状态，实现 Pointfree 风格。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;链式操作也能避免多层函数嵌套问题 &lt;code&gt;fn1(fn2(fn3()))&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果你用过 rxjs，就能体会到链式操作带来的快乐。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;处理副作用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还记得 Jquery 时代的 ajax 操作吗？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$.ajax({&lt;br/&gt;  &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&quot;get&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;url&lt;/span&gt;: &lt;span&gt;&quot;request1&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;success&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;response1&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    $.ajax({&lt;br/&gt;      &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&quot;get&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;url&lt;/span&gt;: &lt;span&gt;&quot;request2&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;success&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;response2&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        $.ajax({&lt;br/&gt;          &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&quot;get&quot;&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;url&lt;/span&gt;: &lt;span&gt;&quot;request3&quot;&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;success&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;response3&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;console&lt;/span&gt;.log(response3); &lt;span&gt;// 得到最终结果&lt;/span&gt;&lt;br/&gt;          },&lt;br/&gt;        });&lt;br/&gt;      },&lt;br/&gt;    });&lt;br/&gt;  },&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述代码中，我们通过回调函数，串行执行了 3 个 ajax 操作，但同样也生成了 3 层代码嵌套，这样的代码不仅难以阅读，也不利于日后维护。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Promise 的出现，解决了上述问题。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;fetch(&lt;span&gt;&quot;request1&quot;&lt;/span&gt;)&lt;br/&gt;  .then(&lt;span&gt;(&lt;span&gt;response1&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; fetch(&lt;span&gt;&quot;request2&quot;&lt;/span&gt;);&lt;br/&gt;  })&lt;br/&gt;  .then(&lt;span&gt;(&lt;span&gt;response2&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; fetch(&lt;span&gt;&quot;request3&quot;&lt;/span&gt;);&lt;br/&gt;  })&lt;br/&gt;  .then(&lt;span&gt;(&lt;span&gt;response3&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(response3); &lt;span&gt;// 得到最终结果&lt;/span&gt;&lt;br/&gt;  });&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过 Promise，将多个步骤封装到多个 then 方法中去执行，不仅消除了多层代码嵌套问题，而且也让代码划分更加自然，大大提高了代码的可维护性。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;想一想，为什么 Promise 可以不断执行 then 方法？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，Promise 和 Monad 很类似，它满足了多条 Monad 规则。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Promise 本身就是一个构造函数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Monad 中的 unit，在 Promise 中可以看为：&lt;code&gt;x =&amp;gt; Promise.resolve(x)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Monad 中的 bind，在 Promise 中可以看为：&lt;code&gt;Promise.prototype.then&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们用代码来验证一下。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 首先定义 2 个异步处理函数。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 延迟 1s 然后 加一&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;delayAdd1&lt;/span&gt;(&lt;span&gt;x&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      resolve(x + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    });&lt;br/&gt;  }, &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 延迟 1s 然后 求平方&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;delaySquare&lt;/span&gt;(&lt;span&gt;x&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      resolve(x * x);&lt;br/&gt;    });&lt;br/&gt;  }, &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;/****************************************************************************************/&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 单位元 e 规则，满足：e*a = a*e = a&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; promiseA = &lt;span&gt;Promise&lt;/span&gt;.resolve(&lt;span&gt;2&lt;/span&gt;).then(delayAdd1);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; promiseB = delayAdd1(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// promiseA === promiseB，故 promise 满足左单位元。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; promiseC = &lt;span&gt;Promise&lt;/span&gt;.resolve(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; promiseD = a.then(&lt;span&gt;Promise&lt;/span&gt;.resolve);&lt;br/&gt;&lt;span&gt;// promiseC === promiseD，故 promise 满足右单位元。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// promise 既满足左单位元，又满足右单位元，故 Promise 满足单位元。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// ps：但一些特殊的情况不满足该定义，下文中会讲到&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/****************************************************************************************/&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 结合律规则：（a * b）* c = a *（b * c）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; promiseE = &lt;span&gt;Promise&lt;/span&gt;.resolve(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; promiseF = promiseE.then(delayAdd1).then(delaySquare);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; promiseG = promiseE.then(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;x&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; delayAdd1(x).then(g);&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// promiseF === promiseG，故 Promise 是满足结合律。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// ps：但一些特殊的情况不满足该定义，下文中会讲到&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完上面的代码，不禁感觉很惊讶，Promise 和 Monad 也太像了吧，不仅可以实现链式操作，也满足单位元和结合律，难道 Promise 就是一个 Monad？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实不然，Promise 并不完全满足 Monad：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Promise.resolve 如果传入一个 Promise 对象，会等待传入的 Promise 执行，并将执行结果作为外层 Promise 的值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Promise.resolve 在处理 thenable 对象时，同样不会直接返回该对象，会将对象中的 then 方法当做一个 Promise 等待结果，并作为外层 Promise 的值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是这两种情况，那就无法满足 Monad 规则。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Promise.resolve 传入一个 Promise 对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; functionA = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;p&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 这时 p === 1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; p.then(&lt;span&gt;(&lt;span&gt;n&lt;/span&gt;) =&amp;gt;&lt;/span&gt; n * &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; promiseA = &lt;span&gt;Promise&lt;/span&gt;.resolve(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;Promise&lt;/span&gt;.resolve(promiseA).then(functionA);&lt;br/&gt;&lt;span&gt;// RejectedPromise TypeError: p.then is not a function&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 由于 Promise.resolve 对传入的 Promise 进行了处理，导致直接运行报错。违背了单位元和结合律。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Promise.resolve 传入一个 thenable 对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; functionB = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;p&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 这时 p === 1&lt;/span&gt;&lt;br/&gt;  alert(p);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; p.then(&lt;span&gt;(&lt;span&gt;n&lt;/span&gt;) =&amp;gt;&lt;/span&gt; n * &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; obj = {&lt;br/&gt;  then(r) {&lt;br/&gt;    r(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;  },&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; promiseB = &lt;span&gt;Promise&lt;/span&gt;.resolve(obj);&lt;br/&gt;&lt;span&gt;Promise&lt;/span&gt;.resolve(promiseB).then(functionB);&lt;br/&gt;&lt;span&gt;// RejectedPromise TypeError: p.then is not a function&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 由于 Promise.resolve 对传入的 thenable 进行了处理，导致直接运行报错。违背了单位元和结合律。&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里，相信大家对 Promise 也有了一层新的了解，正是借助了 Monad 一样的链式操作，才使 Promise 广泛应用在了前端异步代码中，你是否也和我一样，对 Monad 充满了好感？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Monad 处理副作用&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们再看一个常见的问题：为什么 Monad 适合处理副作用？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;ps：这里说的副作用，指的是违反&lt;strong&gt;纯函数&lt;/strong&gt;原则的操作，我们应该尽可能避免这些操作，或者把这些操作放在最后去执行。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; fs = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;fs&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 纯函数，传入 filename，返回 Monad 对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; readFile = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;filename&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 副作用函数：读取文件&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; readFileFn = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; fs.readFileSync(filename, &lt;span&gt;&quot;utf-8&quot;&lt;/span&gt;);&lt;br/&gt;  };&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Monad(readFileFn);&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 纯函数，传入 x，返回 Monad 对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; print = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;x&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 副作用函数：打印日志&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; logFn = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(x);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; x;&lt;br/&gt;  };&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Monad(logFn);&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 纯函数，传入 x，返回 Monad 对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; tail = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;x&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 副作用函数：返回最后一行的数据&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; tailFn = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; x[x.length - &lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;  };&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Monad(tailFn);&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 链式操作文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; monad = readFile(&lt;span&gt;&quot;./xxx.txt&quot;&lt;/span&gt;).bind(tail).bind(print);&lt;br/&gt;&lt;span&gt;// 执行到这里，整个操作都是纯的，因为副作用函数一直被包裹在 Monad 里，并没有执行&lt;/span&gt;&lt;br/&gt;monad.value(); &lt;span&gt;// 执行副作用函数&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面代码中，我们将副作用函数封装到 Monad 里，以保证纯函数的优良特性，巧妙地化解了副作用存在的安全隐患。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Ok，到这里为止，本文的主要内容就已经分享完了，但在学习 Monad 中的某一天，突然发现有人用一句话就解释清楚了 Monad，自叹不如，简直太厉害了，我们一起来看一下吧！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Warning：下文的内容偏数学理论，不感兴趣的同学跳过即可。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;Monad 一句话解释&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;早在 10 多年前，Philip Wadler 就对 Monad 做了一句话的总结。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原文：&lt;em&gt;A monad is a monoid in the category of endofunctors&lt;/em&gt;。&lt;/p&gt;&lt;p&gt;翻译：Monad 是一个 &lt;strong&gt;自函子&lt;/strong&gt; &lt;strong&gt;范畴&lt;/strong&gt; 上的 &lt;strong&gt;幺半群&lt;/strong&gt;” 。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里标注了 3 个重要的概念：自函子、范畴、幺半群，这些都是数学知识，我们分开理解一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;任何事物都是对象，大量的对象结合起来就形成了集合，对象和对象之间存在一个或多个联系，任何一个联系就叫做态射。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一堆对象，以及对象之间的所有态射所构成的一种代数结构，便称之为 &lt;strong&gt;范畴&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们将范畴与范畴之间的映射称之为 &lt;strong&gt;函子&lt;/strong&gt;。映射是一种特殊的态射，所以函子也是一种态射。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;自函子&lt;/strong&gt;就是一个将范畴映射到自身的函子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;幺半群&lt;/strong&gt;是一个存在 单位元 的半群。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个集合，满足结合律，那么就是一个&lt;strong&gt;半群&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;单位元&lt;/strong&gt;是集合里的一种特别的元素，与该集合里的二元运算有关。当单位元和其他元素结合时，并不会改变那些元素。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;如：&lt;br/&gt;任何一个数 + 0 = 这个数本身。那么 0 就是单位元（加法单位元）&lt;br/&gt;任何一个数 * 1 = 这个数本身。那么 1 就是单位元（乘法单位元）&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Ok，我们已经了解了所有应该掌握的专业术语，那就简单串解一下这段解释吧：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个 &lt;strong&gt;自函子&lt;/strong&gt; &lt;strong&gt;范畴&lt;/strong&gt; 上的 &lt;strong&gt;幺半群&lt;/strong&gt; ，可以理解为，在一个满足结合律和单位元规则的集合中，存在一个映射关系，这个映射关系可以把集合中的元素映射成当前集合自身的元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信掌握了这些理论知识，肯定会对 Monad 有一个更加深入的理解。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文从 Monad 的维基百科开始，逐步介绍了 Monad 的内部结构以及实现原理，并通过 Promise 验证了 Monad 在实战中发挥的重大作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文中包含了许多数学定义、函数式编程的理论等知识，大多是参考网络资料和自我经验得出的，如果有错误的地方，还望大家多多指点 🙏&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，如果你对此有任何想法，欢迎留言评论！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SM05zvmibH7IPvCR1UFK0iceHtwoxDN1HMQzuMP8k9vdVicCeLRIDBibuqpG63ibia7k3WHBPo170t0icicnyibZbBanSGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b01b3881e6e06348c9f1fe99826ec77e</guid>
<title>支持百万级 TPS，Kafka 是怎么做到的？答案藏在这 10 张图里</title>
<link>https://toutiao.io/k/6vn5kqj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;谈到大数据传输都会想到 Kafka，Kafka 号称大数据的杀手锏，在业界有很多成熟的应用场景并且被主流公司认可。这款为大数据而生的消息中间件，以其百万级TPS的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在业界已经有很多成熟的消息中间件如：RabbitMQ, RocketMQ, ActiveMQ, ZeroMQ，为什么 Kafka 在众多的敌手中依然能有一席之地，当然靠的是其强悍的吞吐量。下面带领大家来揭秘。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Kafka 如何做到支持百万级 TPS ？&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先用一张思维导图直接告诉你答案：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5076923076923077&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3Eovs6UOy9VU3icxtrWffXa2d1qDDrkTMlhuklQxNpicNE3Q0RRmzpQz7vWPDWibRQWJfyajdKkELtltw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1430&quot;/&gt;&lt;figcaption&gt;Kafka 支持百万TPS的秘密&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;顺序读写磁盘&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产者写入数据和消费者读取数据都是&lt;strong&gt;顺序读写&lt;/strong&gt;的，先来一张图直观感受一下顺序读写和随机读写的速度：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.41816143497757846&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3Eovs6UOy9VU3icxtrWffXa2dvcPLrVqVa4ibVvZSaDVv5D7Zro3etVwn9K9AHG2huRkhFnYezclSibRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1784&quot;/&gt;&lt;figcaption&gt;顺序读写 VS 随机读写&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中可以看出传统硬盘或者SSD的顺序读写甚至超过了内存的随机读写，当然与内存的顺序读写对比差距还是很大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以Kafka选择顺序读写磁盘也不足为奇了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面以传统机械磁盘为例详细介绍一下什么是顺序读写和随机读写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;盘片&lt;/strong&gt;和&lt;strong&gt;盘面&lt;/strong&gt;：一块硬盘一般有多块盘片，盘片分为上下两面，其中有效面称为盘面，一般上下都有效，也就是说：&lt;strong&gt;盘面数 = 盘片数 * 2。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;磁头&lt;/strong&gt;：磁头切换磁道读写数据时是通过机械设备实现的，一般速度较慢；而磁头切换盘面读写数据是通过电子设备实现的，一般速度较快，因此磁头一般是先读写完柱面后才开始寻道的(不用切换磁道)，这样磁盘读写效率更快。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8097447795823666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3Eovs6UOy9VU3icxtrWffXa2dmgnpUyUV9ibcfLq0Nwy7qrGTV6iasQiaGObiaQsHTFCicCseHuHbQsicgWxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;862&quot;/&gt;&lt;figcaption&gt;传统机械磁盘&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;磁道&lt;/strong&gt;：磁道就是以中间轴为圆心的圆环，一个盘面有多个磁道，磁道之间有间隙，磁道也就是磁盘存储数据的介质。磁道上布有一层磁介质，通过磁头可以使磁介质的极性转换为数据信号，即磁盘的读，磁盘写刚好与之相反。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;柱面&lt;/strong&gt;：磁盘中不同盘面中半径相同的磁道组成的，也就是说柱面总数 = 某个盘面的磁道数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;扇区&lt;/strong&gt;：单个磁道就是多个弧形扇区组成的，盘面上的每个磁道拥有的扇区数量是相等。扇区是最小存储单元，一般扇区大小为512bytes。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8591065292096219&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3Eovs6UOy9VU3icxtrWffXa2d9eHOJyzHibAgQE0UF7t0k0PgTgGuB8Pnu3zw21OicnZmdTHf9UkL3REw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;582&quot;/&gt;&lt;figcaption&gt;单盘片示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果系统每次只读取一个扇区，那恐怕效率太低了，所以出现了block（块）的概念。文件读取的最小单位是block，根据不同操作系统一个block一般由多个扇区组成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了磁盘的背景知识我们就可以很容易理解顺序读写和随机读写了。&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;107&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;插播维基百科定义：&lt;/section&gt;&lt;section&gt;&lt;strong&gt;顺序读写&lt;/strong&gt;：是一种按记录的逻辑顺序进行读、写操作的存取方法 ，即按照信息在存储器中的实际位置所决定的顺序使用信息。 &lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;随机读写&lt;/strong&gt;：指的是当存储器中的消息被读取或写入时，所需要的时间与这段信息所在的位置无关。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当读取第一个block时，要经历寻道、旋转延迟、传输三个步骤才能读取完这个block的数据。而对于下一个block，如果它在磁盘的其他任意位置，访问它会同样经历寻道、旋转、延时、传输才能读取完这个block的数据，我们把这种方式叫做&lt;strong&gt;随机读写&lt;/strong&gt;。但是如果这个block的起始扇区刚好在刚才访问的block的后面，磁头就能立刻遇到，不需等待直接传输，这种就叫&lt;strong&gt;顺序读写&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好，我们再回到 Kafka，详细介绍Kafka如何实现顺序读写入数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 写入数据是顺序的，下面每一个Partition 都可以当做一个文件，每次接收到新数据后Kafka会把数据插入到文件末尾，虚框部分代表文件尾。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.28627450980392155&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3Eovs6UOy9VU3icxtrWffXa2dDXBcmpNxUdCJ70TW0l0SgibqhGOFdnatQicuPVgbY4eyQgOh27Fojguw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1530&quot;/&gt;&lt;figcaption&gt;顺序写&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方法有一个问题就是删除数据不方便，所以 Kafka 一般会把所有的数据都保留下来，每个消费者（Consumer）对每个Topic都有一个 offset 用来记录读取进度或者叫坐标。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34979973297730305&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3Eovs6UOy9VU3icxtrWffXa2dDXo6ibAQjwUlD4GqsQl1FhplcLLNOQj2nyRibJ1VwppoyOI5bXeaTT2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1498&quot;/&gt;&lt;figcaption&gt;顺序读&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Memory Mapped Files(MMAP)&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在文章开头我们看到硬盘的顺序读写基本能与内存随机读写速度媲美，但是与内存顺序读写相比还是太慢了，那 Kafka 如果有追求想进一步提升效率怎么办？可以使用现代操作系统分页存储来充分利用内存提高I/O效率，这也是下面要介绍的 MMAP 技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;MMAP&lt;/strong&gt;也就是&lt;strong&gt;内存映射文件&lt;/strong&gt;，在64位操作系统中一般可以表示 20G 的数据文件，它的工作原理是直接利用操作系统的 Page 来实现文件到物理内存的直接映射，完成映射之后对物理内存的操作会被同步到硬盘上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5508586525759577&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3Eovs6UOy9VU3icxtrWffXa2ddqicHDSicmdZgYABBPaLmSOMQ37xThxljLFW2hSPaQD012wquYqOeicdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1514&quot;/&gt;&lt;figcaption&gt;MMAP原理&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过&lt;strong&gt;MMAP&lt;/strong&gt;技术进程可以像读写硬盘一样读写内存（逻辑内存），不必关心内存的大小，因为有虚拟内存兜底。这种方式可以获取很大的I/O提升，省去了用户空间到内核空间复制的开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也有一个很明显的缺陷，写到&lt;strong&gt;MMAP&lt;/strong&gt;中的数据并没有被真正的写到硬盘，操作系统会在程序主动调用 flush 的时候才把数据真正的写到硬盘。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka提供了一个参数：producer.type 来控制是不是主动 flush，如果Kafka写入到MMAP之后就立即flush然后再返回Producer叫同步(sync)；写入MMAP之后立即返回Producer不调用flush叫异步(async)。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Zero Copy（零拷贝）&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 另外一个黑技术就是使用了零拷贝，要想深刻理解零拷贝必须得知道什么是DMA。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;什么是DMA?&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知 CPU 的速度与磁盘 IO 的速度比起来相差几个数量级，可以用乌龟和火箭做比喻。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说 IO 操作都是由 CPU 发出指令，然后等待 IO 设备完成操作后返回，那CPU会有大量的时间都在等待IO操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是CPU 的等待在很多时候并没有太多的实际意义，我们对于 I/O 设备的大量操作其实都只是把内存里面的数据传输到 I/O 设备而已。比如进行大文件复制，如果所有数据都要经过 CPU，实在是有点儿太浪费时间了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于此就有了DMA技术，翻译过来也就是直接内存访问（Direct Memory Access），有了这个可以减少 CPU 的等待时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Kafka 零拷贝原理&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不使用零拷贝技术，消费者（consumer）从Kafka消费数据，Kafka从磁盘读数据然后发送到网络上去，数据一共发生了四次传输的过程。其中两次是 DMA 的传输，另外两次，则是通过 CPU 控制的传输。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6342668863261944&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3Eovs6UOy9VU3icxtrWffXa2d4g2dR222gugicico4yrqpqQkcCxvjdicNo55WOKCyGxlSvqPgEGvGTw6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1214&quot;/&gt;&lt;figcaption&gt;四次传输过程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第一次传输&lt;/strong&gt;：从硬盘上将数据读到操作系统内核的缓冲区里，这个传输是通过 DMA 搬运的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第二次传输&lt;/strong&gt;：从内核缓冲区里面的数据复制到分配的内存里面，这个传输是通过 CPU 搬运的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第三次传输&lt;/strong&gt;：从分配的内存里面再写到操作系统的 Socket 的缓冲区里面去，这个传输是由 CPU 搬运的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第四次传输&lt;/strong&gt;：从 Socket 的缓冲区里面写到网卡的缓冲区里面去，这个传输是通过 DMA 搬运的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上在kafka中只进行了两次数据传输，如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.35&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3Eovs6UOy9VU3icxtrWffXa2d18Av17nsWedxgibyNqLE578FwEgDPbbdS1R3sqK6Kxxuknxyo3jvM8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;两次传输，零拷贝技术&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第一次传输&lt;/strong&gt;：通过 DMA从硬盘直接读到操作系统内核的读缓冲区里面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第二次传输&lt;/strong&gt;：根据 Socket 的描述符信息直接从读缓冲区里面写入到网卡的缓冲区里面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到同一份数据的传输次数从四次变成了两次，并且没有通过 CPU 来进行数据搬运，所有的数据都是通过 DMA 来进行传输的。没有在内存层面去复制（Copy）数据，这个方法称之为&lt;strong&gt;零拷贝（Zero-Copy）。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论传输数据量的大小，传输同样的数据使用了零拷贝能够缩短 65% 的时间，大幅度提升了机器传输数据的吞吐量，这也是Kafka能够支持百万TPS的一个重要原因。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Batch Data（数据批量处理）&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当消费者（consumer）需要消费数据时，首先想到的是消费者需要一条，kafka发送一条，消费者再要一条kafka再发送一条。但实际上 Kafka 不是这样做的，Kafka 耍小聪明了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 把所有的消息都存放在一个一个的文件中，当消费者需要数据的时候 Kafka 直接把文件发送给消费者。比如说100万条消息放在一个文件中可能是10M的数据量，如果消费者和Kafka之间网络良好，10MB大概1秒就能发送完，既100万TPS，Kafka每秒处理了10万条消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里你可以有疑问了，消费者只需要一条消息啊，kafka把整个文件都发送过来了，文件里面剩余的消息怎么办？不要忘了消费者可以通过offset记录消费进度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发送文件还有一个好处就是可以对文件进行批量压缩，减少网络IO损耗。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后再总结一下 Kafka 支持百万级 TPS 的秘密：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）顺序写入数据，在 Partition 末尾追加，所以速度最优。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）使用 MMAP 技术将磁盘文件与内存映射，Kafka 可以像操作磁盘一样操作内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）通过 DMA 技术实现零拷贝，减少数据传输次数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）读取数据时配合sendfile直接暴力输出，批量压缩把所有消息变成一个批量文件，合理减少网络IO损耗。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>07a14c6c1cd317851855d3948cc2d55d</guid>
<title>为什么 Go 的泛型一拖再拖？</title>
<link>https://toutiao.io/k/dvyj3mp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是从不放鸽子的煎鱼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前段时间 Go 语言的泛型讨论频频出现在各微信群，且又冲上了国内外各大文章的 “头条”：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3107932379713914&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4hrrrrCCzHYGBJibl3nJaz7CicNxWbkATfZCJicDU2D9tS2qibuWAHjYSdibptnD8fhYwdKsC0icNm6Mt4A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1538&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;信息汇总来看，Go 泛型这几年会出，但大体来讲现在 Go 泛型又又又推迟了。好家伙，我最早了解到时是考虑 Go1.16 释出，后面又推到了 Go1.17，接着现在又延期到了 Go1.18 了（2021 年底）。&lt;/p&gt;&lt;p&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4hrrrrCCzHYGBJibl3nJaz7C8APDzcLvgb98k5MFgiaZ9HmyibxcaJXz98u5TCRoLkDhhIcEX6AUwTCQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot;/&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;看到了信息的表象后，再想想为什么泛型 “这件事情” 突然醒目起来了，其原因之一是由官方 &lt;/span&gt;&lt;span&gt;Go，11 岁&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;span&gt; 的博文所引爆的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时近日举办的 GopherCon2020 大会，Robert Griesemer 分享的 Typing [Generic] Go。更正式的让 Go 泛型更面向了大众，也侧面的说明官方认为其已经到达了一个新的阶段了，进入最终实现阶段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事不宜迟，既然官方都已经摩拳擦掌了，我们的学习之路也得跟上，因此本文将会介绍 Go 泛型现在的情况，并通过在介绍过程中不断思考最后得出一个为什么。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是泛型&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;泛型程序设计（generic programming）是程序设计语言的一种风格或范式。泛型允许程序员在强类型语言中编写代码时，使用一些以后才确定的类型，其在真正实例化时才会为这些参数指确定类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外各语言和其编译器、运行环境对泛型的支持均不一样，因此需要针对来辩证。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来讲，泛型就是参数化多态。其可根据实参类型生成不同的版本，支持任意数量的调用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func F(a, b T) T{ &lt;span&gt;return&lt;/span&gt; a+b }&lt;br/&gt;&lt;br/&gt;// T 为 int&lt;br/&gt;F(1, 2)&lt;br/&gt;&lt;br/&gt;// T 为 string&lt;br/&gt;F(&lt;span&gt;&quot;1&quot;&lt;/span&gt;, &lt;span&gt;&quot;2&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在编译时期编译器便确定其 T 的入参类型。这也是 Go 泛型实现的要求之一 “编译时类型安全”。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么需要泛型&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候可能会有人说，没有泛型也可以啊...感觉写业务代码没什么影响，与其搞泛型不如搞好 errors（具体新消息可参见：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;amp;mid=2247484318&amp;amp;idx=1&amp;amp;sn=491d7fe0764e6f0de3c728a02c7d554f&amp;amp;chksm=f90416c3ce739fd55fdbfd33ef334a66cf0e38638490bde104df3fe1b3c532bf4e01e7deeab6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;重磅：Go errors 将不会有任何进一步的改进计划&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;重磅：Go errors 将不会有任何进一步的改进计划&lt;/a&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但泛型是有其所需的场景，最常见的是像基础库在处理获取配置中心数据时，就要处理类型，时常遇到下述场景：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0834879406307978&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4hrrrrCCzHYGBJibl3nJaz7Cp2dOOu2DjUicKHnQmWnKW3k5QlA6BFAibniayQ858AeJtjGTF8gx0nM9w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1078&quot;/&gt;&lt;figcaption&gt;手写一个 “泛型”&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;span&gt;如果使用接口（interface）类型来做，也得 &lt;/span&gt;&lt;code&gt;switch.(type)&lt;/code&gt;&lt;span&gt; 枚举出所有的基础类型。&lt;/span&gt;&lt;span&gt;这显然并不合理，也没法做太复杂的逻辑，而且所支持的类型还泄露。&lt;/span&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外同时单从语言层面来讲，泛型支持是一个必然事件了，因为泛型的存在对解决特定领域的问题存在一定的意义。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;接口和泛型有什么区别&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面我们有提到接口（interface）类型，这时候就出现了泛型的第二个经典问题。那就是 “接口和泛型有什么区别？”，为什么不用接口来实现 “泛型”：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; T interface { ... }&lt;br/&gt;func F(a, b T) T { &lt;span&gt;return&lt;/span&gt; a+b }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也像这么一回事，但在这里存在一个致命的缺陷。那就是接口的入参和出参均可以在运行时表现为不同的类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;F(&lt;span&gt;&quot;煎鱼&quot;&lt;/span&gt;, 233)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要做好，还得依靠内部去对参数进行断言，否则作为 string 类型的煎鱼又如何和 int 类型的 233 相加呢，那是必然报错的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而反过来看真 “泛型” 的实际使用，编译器会保证泛型函数的入参和出参必须为同一类型，有强制性的检验：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 报错：&lt;span&gt;type&lt;/span&gt; checking failed &lt;span&gt;for&lt;/span&gt; main&lt;br/&gt;F(&lt;span&gt;&quot;煎鱼&quot;&lt;/span&gt;, 233)&lt;br/&gt;&lt;br/&gt;// 必须为同一类型，才能正常运行&lt;br/&gt;F(666, 233)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两者存在本质上的区别，泛型会更安全，能够保证编译早期就发现错误，而不是等到运行时（并且可能会存在隐性的 BUG）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总体来讲，泛型相较接口有如下优点：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;过去：为什么那么久都没有泛型&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前几段在社区的微信群看到一位小伙伴吐槽 “Go 语言居然没有泛型？”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;变相来看，可能其会认为 ”Go 都已经 11 岁了，2020 年了居然还没有泛型？”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这显然是不对的，因为泛型本质上并不是绝对的必需品，更不是 Go 语言的早期目标，因此在过往的发展阶段没有过多重视这一点，而是把精力放在了其他 feature 上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外 Go 语言在以往其实进行过大量的泛型 proposal 试验，基本时间线（via @changkun）如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;简述&lt;/th&gt;&lt;th&gt;时间&lt;/th&gt;&lt;th&gt;作者&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;[Type Functions]&lt;/td&gt;&lt;td&gt;2010年&lt;/td&gt;&lt;td&gt;Ian Lance Taylor&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Generalized Types&lt;/td&gt;&lt;td&gt;2011年&lt;/td&gt;&lt;td&gt;Ian Lance Taylor&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Generalized Types v2&lt;/td&gt;&lt;td&gt;2013年&lt;/td&gt;&lt;td&gt;Ian Lance Taylor&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Type Parameters&lt;/td&gt;&lt;td&gt;2013年&lt;/td&gt;&lt;td&gt;Ian Lance Taylor&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;go:generate&lt;/td&gt;&lt;td&gt;2014年&lt;/td&gt;&lt;td&gt;Rob Pike&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;First Class Types&lt;/td&gt;&lt;td&gt;2015年&lt;/td&gt;&lt;td&gt;Bryan C.Mills&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Contracts&lt;/td&gt;&lt;td&gt;2018年&lt;/td&gt;&lt;td&gt;Ian Lance Taylor, Robert Griesemer&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Contracts&lt;/td&gt;&lt;td&gt;2019年&lt;/td&gt;&lt;td&gt;Ian Lance Taylor, Robert Griesemer&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Redundancy in Contracts(2019)&#x27;s Design&lt;/td&gt;&lt;td&gt;2019年&lt;/td&gt;&lt;td&gt;Ian Lance Taylor, Robert Griesemer&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Constrained Type Parameters(2020, v1)&lt;/td&gt;&lt;td&gt;2020年&lt;/td&gt;&lt;td&gt;Ian Lance Taylor, Robert Griesemer&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Constrained Type Parameters(2020, v2)&lt;/td&gt;&lt;td&gt;2020年&lt;/td&gt;&lt;td&gt;Ian Lance Taylor, Robert Griesemer&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Constrained Type Parameters(2020, v3)&lt;/td&gt;&lt;td&gt;2020年&lt;/td&gt;&lt;td&gt;Ian Lance Taylor, Robert Griesemer&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然偶有中断，但仔细一看，2010 年就尝试过，现在 2020 年了，也是很励志了，显然官方也是在寻路和尝试的过程中，但一直没有找到相较好的方案，大多都存在问题，社区对方案的争议也不断。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;现在：Go 泛型&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;泛型尝鲜的方式有两种方式。线上 Ian Lance Taylor 提供了一个在线编译的 &lt;span&gt;go2go&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7019543973941368&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4hrrrrCCzHYGBJibl3nJaz7CRRDZhiaAa4v284ttCwbbpjklMDw5ibwXJ7Db9471UWn6sVIygNQS2Nmg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1228&quot;/&gt;&lt;figcaption&gt;image&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外一种是线下，也就在本地安装 Go 的特定分支版本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ git &lt;span&gt;clone&lt;/span&gt; https://github.com/golang/go&lt;br/&gt;$ git checkout dev.go2go&lt;br/&gt;$ &lt;span&gt;cd&lt;/span&gt; src &amp;amp;&amp;amp; ./all.bash&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过这种本地安装的方法会耗时比较久，初步尝试的话建议使用 go2go 就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在尝鲜时，可以看到在代码块中声明了一个 &lt;code&gt;Print&lt;/code&gt; 方法，其函数签名主体分为三部分：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4489795918367347&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4hrrrrCCzHYGBJibl3nJaz7C1yF1WwjHa2S0hxV5Iqk3f6unVEu7VKcI5lxlYtU523vJsAaqGj38cA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1176&quot;/&gt;&lt;figcaption&gt;函数签名&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;咋一看，变量 T 的这个关键字 &lt;code&gt;any&lt;/code&gt; 是什么？早期泛型你可能有听说合约（Contract），难道这就是合约。其实严格意义上来讲并不是，因为为了更一步简化语法，合约在 2020.06.07 已经正式移除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其已改头换面，现在只需要写参数化的 interface。而上述的 &lt;code&gt;any&lt;/code&gt; 关键字是一个预定义的类型约束，声明后将允许任何类型用作类型实参，并且允许函数使用用于任何类型的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从语法分析的角度来讲，&lt;code&gt;Print&lt;/code&gt; 方法一共包含了如下属性（从左到右）：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;type list：声明了入参的类型列表为一个 &lt;code&gt;T&lt;/code&gt; 变量，其可以传任意类型的参数。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;parameter list：声明了入参的参数列表为 &lt;code&gt;T&lt;/code&gt; 变量的切片，且形参为 &lt;code&gt;s&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;return type list：声明了函数的返回参数列表。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述函数签名便是一个 Go 泛型的基本样子，由于本文并不是 CRUD 泛型，便不展开案例（且现有泛型还不成熟）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若大家有兴趣，强烈建议阅读提案：&lt;span&gt;Type Parameters - Draft Design&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;泛型的战争&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么不用尖括号&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在社区中很多同学在讨论的一个问题，那就是 “为什么 Go 泛型不像 C++ 和 Java 那样使用尖括号？，也出现了 “Go 一直标榜业界工程实践类的榜样，为什么就是不用尖括号” 的言论？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思考问题我们不只看表面，官方说不行，那么我们可以倒推来看，看看 Go 语言就用尖括号：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func &lt;span&gt;print&lt;/span&gt;&amp;lt;&lt;span&gt;type&lt;/span&gt; T&amp;gt;(list []T) {&lt;br/&gt;&lt;br/&gt;&lt;span&gt;print&lt;/span&gt;&amp;lt;int&amp;gt;(numbers)&lt;br/&gt;&lt;span&gt;print&lt;/span&gt;&amp;lt;string&amp;gt;(strings)&lt;br/&gt;&lt;span&gt;print&lt;/span&gt;&amp;lt;float64&amp;gt;(floats)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;普通的函数声明看上去似乎结构清晰，没有什么大问题的。接着往下看：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;a := w &amp;lt; x&lt;br/&gt;b := y &amp;gt; (z)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们继续把代码演进一下，简洁一点：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;a, b := w &amp;lt; x, y &amp;gt; (z)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候就犯难了，不仅编译器难以解析，人也很难判别，到底指的是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;a := w &amp;lt; x&lt;br/&gt;b := y &amp;gt; (z)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又或是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;a, b := w&amp;lt;x, y&amp;gt;(z)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上述代码来看，使用尖括号难以分别，因为没有类型信息，就无法确定赋值的右侧是一对表达式 &lt;code&gt;w &amp;lt; x和y &amp;gt; (z)&lt;/code&gt;，还是返回两个结果值 &lt;code&gt;w&amp;lt;x, y&amp;gt;(z)&lt;/code&gt; 的泛型函数实例化和调用，其存在歧义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要解决还要引入新的约束，会破坏 Go1 的兼容性承诺，这显然是不合理的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么不用括号&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实最早 Go 泛型的版本是使用了括号的模式，虽然能用，但是用括号会引入新的解析歧义。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;var f func(x(T))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从语法上来讲，你无法识别他是未命名参数的 &lt;code&gt;x(T)&lt;/code&gt; 函数，还是类型名为参数的 &lt;code&gt;(T)&lt;/code&gt; 函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时 Go 语言还存在强制类型转换这一语法，假设代码是 &lt;code&gt;[]T(v1)&lt;/code&gt; 和 &lt;code&gt;[]T(v2){}&lt;/code&gt; ，那么你在开括号处，就无法得知其是否代表类型转换。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;甚至在函数的完整声明上，我们都会感到困惑：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func F(T any)(v T)(r1, r2 T)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数入参、泛型、返回值声明均都是括号，造成了语义不清，这显然也是不合理的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么不用书名号（«»）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想的美，并不想使用非 ASCII，未来更没打算支持。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本文中我们从多个维度介绍了 Go 泛型的相关内容，既了解到了上段时间 Go 泛型再度火爆的信息来源是什么。也知道了 Go 泛型是什么，与接口的区别。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时我们还针对业界常见的一些疑问，例如接口和泛型的区别，泛型的历史，泛型的尖括号/括号/书名号之争进行了解释和说明。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后我们回答一下最开始的疑问，”为什么 Go 的泛型一拖再拖“，主要如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Go 语言的早期目标（工作重点）并不是泛型。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Go 语言在 2010-2020 年都有间断在做 Go 泛型的 proposal，但总是 ”失败“，在不断地吸收经验。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Go 语言社区的意见反馈是真的多，单用什么符号表示泛型，不想要泛型都争论不休。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Go 语言的泛型现在还不成熟，很多细节其实并没有支持好。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很显然，在保证 Go1 向后兼容性的同时，Go 官方也不想直接妥协出一个随便的方案，因此总是不断地在改进。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着 Go 语言的在业内的不断应用，泛型也和 errors 一样被推上风头浪尖。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;到底拖到什么时候&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那 Go 泛型到底什么时候出呢？前段时间也向欧神（@changkun）了解到：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 GopherCon 2020 Go Team AMA 时，russ cox 有聊到相关问题，&lt;strong&gt;表示在明年年底要能有生产环境的试用版上线，这是一个管理目标&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但具体真正的时间线肯定是要看泛型的实现者：robert 和 keith，可以多多关注他们，就能拿到一手信息，且可以确定的是 Go 泛型明年二月之前是不会有生产可用的试用版。&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后，&lt;strong&gt;灵魂拷问：你对 Go 语言的泛型又有什么想法和意见呢，一起留言讨论吧。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;推荐阅读&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;欧神：第 80 期 2020-03-18 带你提前玩 Go 2 新特性：泛型&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;提案：Type Parameters - Draft Design&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Go，11 岁: &lt;em&gt;https://blog.golang.org/11years&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;go2go: &lt;em&gt;https://go2goplay.golang.org/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;Type Parameters - Draft Design: &lt;em&gt;https://github.com/golang/proposal/blob/master/design/go2draft-type-parameters.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;欧神：第 80 期 2020-03-18 带你提前玩 Go 2 新特性：泛型: &lt;em&gt;https://talkgo.org/t/topic/99&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;提案：Type Parameters - Draft Design: &lt;em&gt;https://github.com/golang/proposal/blob/master/design/go2draft-type-parameters.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3d4d8a1a89c97a8f2709ee069b5b3947</guid>
<title>为什么你写的拦截器中不能注入 Java bean？</title>
<link>https://toutiao.io/k/b95pnf6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、如何实现拦截器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Spring Boot项目中，&lt;strong&gt;拦截器&lt;/strong&gt;经常被用来做登陆验证，日志记录等操作。拦截器是Spring提供的，所以可以将拦截器注成bean，由IOC容器来管理。实现拦截器的方式很简单，主要由以下两个步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;自定义拦截器类实现&lt;code&gt;HandlerInterceptor&lt;/code&gt;接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自定义WebMvc配置类实现&lt;code&gt;WebMvcConfigurer&lt;/code&gt;接口，添加自定义拦截器类&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简要实现代码如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自定义拦截器 &lt;code&gt;LoginInterceptor&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LoginInterceptor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;HandlerInterceptor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;preHandle&lt;/span&gt;&lt;span&gt;(HttpServletRequest request, HttpServletResponse response, Object handler)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        String token = request.getHeader(&lt;span&gt;&quot;token&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(StringUtils.isEmpty(token)){&lt;br/&gt;       ...&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置自定义拦截器：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WebConfiguration&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;WebMvcConfigurer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addInterceptors&lt;/span&gt;&lt;span&gt;(InterceptorRegistry registry)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        registry.addInterceptor(&lt;span&gt;new&lt;/span&gt; LoginInterceptor())&lt;br/&gt;             &lt;span&gt;// 拦截的请求&lt;/span&gt;&lt;br/&gt;                .addPathPatterns(&lt;span&gt;&quot;/**&quot;&lt;/span&gt;)&lt;br/&gt;             &lt;span&gt;// 不用拦截的请求&lt;/span&gt;&lt;br/&gt;                .excludePathPatterns(&lt;span&gt;&quot;/login&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个拦截器的主要作用就是拦截所有访问请求，验证所带&lt;code&gt;token&lt;/code&gt;是否有效，当&lt;code&gt;token&lt;/code&gt;验证成功后，才能访问我们的业务接口。这时候就需要提供一个验证&lt;code&gt;token&lt;/code&gt;有效性的接口，在拦截器中验证&lt;code&gt;token&lt;/code&gt;，由于拦截器是Spring提供的，因此很容易想到使用&lt;code&gt;@Component&lt;/code&gt;注解将拦截器注成一个 bean。然后使用&lt;code&gt;@Autowired&lt;/code&gt;注解将验证&lt;code&gt;token&lt;/code&gt;的类注入到拦截器进行验证。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改造完的代码如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;验证token接口类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TokenUtil&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 验证token 是否有效&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;checkToken&lt;/span&gt;&lt;span&gt;(String token)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        ...&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改造完的拦截器代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LoginInterceptor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;HandlerInterceptor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TokenUtil tokenUtil;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;preHandle&lt;/span&gt;&lt;span&gt;(HttpServletRequest request, HttpServletResponse response, Object handler)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(!tokenUtil.checkToken(token)){&lt;br/&gt;            ...&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用接口时发现，TokenUtil并没有被注入进来！明明代码写的没问题，为什么不能正常注入&lt;code&gt;TokenUtil&lt;/code&gt;呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仔细观察我们自定义的配置类&lt;code&gt;WebConfiguration&lt;/code&gt;，在添加拦截器的时候用的是&lt;code&gt;new LoginInterceptor()&lt;/code&gt;，&lt;strong&gt;如果想要拦截器生效，必须将拦截器配置到WebMvc的配置类中，就是我们自定义的&lt;code&gt;WebConfiguration&lt;/code&gt;类。现在添加拦截器的时候是 new 了一个拦截器，也就是说并没有将拦截器托管给IOC容器，所以就无法引入Spring的bean对象&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、如何将拦截器托管给IOC容器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决问题的思路也很简单，就是将拦截器也托管给IOC容器，这样容器内的对象就可以相互注入了。总共有以下三种方式进行处理上述问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.1 在WebConfiguration注入拦截器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拦截器代码不变，在拦截器上使用&lt;code&gt;@Component&lt;/code&gt;，同时在&lt;code&gt;WebConfiguration&lt;/code&gt;中使用&lt;code&gt;@Autowired&lt;/code&gt;注解将拦截器注入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拦截器代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LoginInterceptor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;HandlerInterceptor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置类代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WebConfiguration&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;WebMvcConfigurer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; LoginInterceptor loginInterceptor;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addInterceptors&lt;/span&gt;&lt;span&gt;(InterceptorRegistry registry)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        registry.addInterceptor(loginInterceptor);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.2 在WebConfiguration将拦截器注成bean&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拦截器无需增加&lt;code&gt;@Component&lt;/code&gt;注解，在&lt;code&gt;WebConfiguration&lt;/code&gt;类中使用&lt;code&gt;@Bean&lt;/code&gt;注解将拦截器注成bean。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拦截器代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LoginInterceptor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;HandlerInterceptor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置类代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WebConfiguration&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;WebMvcConfigurer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; LoginInterceptor &lt;span&gt;loginInterceptor&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LoginInterceptor();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addInterceptors&lt;/span&gt;&lt;span&gt;(InterceptorRegistry registry)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        registry.addInterceptor( loginInterceptor());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.3 通过构造器处理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思路是在&lt;code&gt;WebConfiguration&lt;/code&gt;类中注入需要的验证&lt;code&gt;token&lt;/code&gt;的业务类，然后在初始化拦截器的时候将业务类通过构造器带入拦截器中，这样就不用把拦截器注成Spring Bean对象了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拦截器代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LoginInterceptor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;HandlerInterceptor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TokenUtil tokenUtil;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;LoginInterceptor&lt;/span&gt;&lt;span&gt;(TokenUtil tokenUtil)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.tokenUtil = tokenUtil;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置类代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WebConfiguration&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;WebMvcConfigurer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TokenUtil tokenUtil;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addInterceptors&lt;/span&gt;&lt;span&gt;(InterceptorRegistry registry)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        registry.addInterceptor(&lt;span&gt;new&lt;/span&gt; LoginInterceptor(tokenUtil));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网上关于拦截器的代码基本都是通过new一个拦截器进行配置的，这时候就会出现无法注入其他bean的情况。很多人想当然地直接在拦截器加&lt;code&gt;@Component&lt;/code&gt;注解使其成为一个bean对象。这是一种错误的做法。我们需要保证的是&lt;strong&gt;在WebMvc配置类中添加的拦截器是Spring 的一个bean对象&lt;/strong&gt;，也就是说我们需要将拦截器注成一个bean，同时将这个bean添加的WebMvc配置类中。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>