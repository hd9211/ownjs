<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>bc6bdace829b20536e0e92336bf8f8c1</guid>
<title>中年技术人转型的几点感想</title>
<link>https://toutiao.io/k/pn1lln7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fea4940c0261851b02dcb193ed87ecf0</guid>
<title>WebRTC 和 WASM 如何给网络应用提供新机会</title>
<link>https://toutiao.io/k/oodw8i5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;elementor-widget-container&quot;&gt;

&lt;p&gt;从依靠文字短信的延迟通信，到潜力无限的实时通信多媒体平台，我们在线通信协作这一领域的成就十分可观。&lt;/p&gt;



&lt;p&gt;得益于谷歌及其开源平台WebRTC，我们可以在浏览器内使用HTML和纯JavaScript来开发像Skype、Whatsapp等视频聊天应用。&lt;/p&gt;



&lt;p&gt;谷歌提及WebAssembly适配其最近Chrome的WebRTC音频管道以及未来WebRTC NV的建设。Low Level APIs说明了WebAssembly会被用在哪些地方。&lt;/p&gt;



&lt;p&gt;这些建设使我们不再需要写那么多代码，允许我们移植代码。此外，整个网络生态系统中的每一个浏览器都可用此功能。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;WebRTC&lt;/strong&gt;&lt;strong&gt;二代（&lt;/strong&gt;&lt;strong&gt;NV&lt;/strong&gt;&lt;strong&gt;）塑造未来&lt;/strong&gt;&lt;strong/&gt;&lt;/p&gt;



&lt;p&gt;WebRTC NV是技术开发人员用的一个总括性术语。供应商和其他服务供应商都会慢慢接受这一WebRTC新版本。该版本包括以下几个要点：&lt;/p&gt;



&lt;p&gt;WASM：主流网络浏览器都支持的第二语言。那第一种语言是什么呢？当然是JavaScript；&lt;/p&gt;



&lt;p&gt;QUIC：一种流行的拥堵控制机制，它能决定你加载页面时要等多长时间；&lt;/p&gt;



&lt;p&gt;AV1：一种免税的视频编解码器，提供高性能的视频流。&lt;/p&gt;



&lt;p&gt;在深入探讨WebAssembly在WebRTC中起何种作用之前，我们先来介绍一下WebRTC、WASM以及WASM在WebRTC之外的价值。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;WebRTC&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;虽然我们很多人都因为WebRTC协助开发很拉风的游戏应用，或提高视频会议应用的可用性和性能而对其颇感兴趣，但其实WebRTC也被证明是开发社交应用的绝佳工具。&lt;/p&gt;



&lt;p&gt;采用端对端连接的社交应用通信速度极快、延迟极低，不需要用户安装外部插件或其他第三方软件，两端中间没有服务器。&lt;/p&gt;



&lt;p&gt;这样的应用是在WebRTC各种相互关联的API和协议共同作用下才能建立起来的。WebRTC的API是根据JavaScript API设计的，主要有3项，分别是：&lt;/p&gt;



&lt;p&gt;GetUserMedia，可以访问设备的摄像头和麦克风；&lt;/p&gt;



&lt;p&gt;PeerConnection，负责WebRTC中所有的媒体传输活动；&lt;/p&gt;



&lt;p&gt;数据通道，处理客户之间的专有数据传输。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;减少终端用户摩擦&lt;/strong&gt;&lt;strong/&gt;&lt;/p&gt;



&lt;p&gt;WebRTC大大增强了网络的通信能力和互动能力。数字化支持服务和网店现在可以通过网站进行沟通和 “拨号 “。这增加了使用服务的机会，同时减少了与终端用户的摩擦。市场上有很多用得到该功能的地方，比如：&lt;/p&gt;



&lt;p&gt;作为一个能和朋友语音聊天的地方（提供WebRTC屏幕共享的Talkroom.io）；&lt;/p&gt;



&lt;p&gt;用于联系导师(Prep Lesson, Kwiizi)、医生(Bridge)或专家(24sessions, ClassOnLive)进行直播连接的地方；&lt;/p&gt;



&lt;p&gt;用于实时在线讨论（Solaborate，GearCloudLabs）的地方，或者做视频采访工具（Plumvue）；&lt;/p&gt;



&lt;p&gt;用于开展商务会议（FACEmeeting、Kenja公司、UberConference）的地方，也可作为SaaS解决方案（Jell）；&lt;/p&gt;



&lt;p&gt;作为呼叫中心或客服平台，也可以作为SaaS解决方案（RichCall、Client Bee、Aircall等）。&lt;/p&gt;



&lt;p&gt;这种摩擦的减少有可能增加WebRTC服务的采用价值。让我们进一步看看大家利用WebRTC的哪些功能来探索网络应用的潜力。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;WebAssembly&lt;/strong&gt;&lt;strong&gt;的魅力&lt;/strong&gt;&lt;strong/&gt;&lt;/p&gt;



&lt;p&gt;你可以把用其他语言编写的代码（如C、C++和Rust）编译成WebAssembly，然后在浏览器中运行它。那这有什么吸引人的呢？&lt;/p&gt;



&lt;p&gt;WASM能始终保证其原始速度比JavaScript快很多。这是其一大优点。但最吸引人的地方是WASM在设计时考虑到了网络的沙盒模式，WASM基于一个开放的标准，这就意味着所有的浏览器都必须遵守相同的规则。因此，等待浏览器供应商们以不同的步调升级其标准的现象可能不复出现了。&lt;/p&gt;



&lt;p&gt;虽然WebRTC发展还处于早期阶段，WASM已经进入现今市场的应用中，比如：&lt;/p&gt;



&lt;p&gt;将整个CLI/游戏/桌面应用程序移植到网络上——AutoCAD就使用WebAssembly把他们30年的代码库移植到网络上了，省去了从头开始重写一切的麻烦；&lt;/p&gt;



&lt;p&gt;应用AutoCAD飞速加快前端计算速度——Ebay设计了一个包括C++和Javascript的编译管道，以此开发了一款基于WebAssembly的条形码扫描器，其订单完成率提高了30%；&lt;/p&gt;



&lt;p&gt;甚至在浏览器之外也能用到WASM。Cloudflare和Fastly等使用WASM模块的无服务器供应商说，他们自己功能的启动速度比大多数使用其他语言的云供应商速度要快；&lt;/p&gt;



&lt;p&gt;在不久的将来，WebAssembly能够直接操作DOM，也会获得对垃圾收集、SIMD指令和线程的支持等等。只要你想，只要我有。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;WASM&lt;/strong&gt;&lt;strong&gt;在&lt;/strong&gt;&lt;strong&gt;WebRTC&lt;/strong&gt;&lt;strong&gt;中的作用是什么？&lt;/strong&gt;&lt;strong/&gt;&lt;/p&gt;



&lt;p&gt;WebRTC正在走向成熟，随之而来的是供应商们也在试图采用WebRTC。&lt;/p&gt;



&lt;p&gt;在WebRTC中启用WebAssembly可以使开发者更好地控制媒体处理，推动其功能进步。这对于那些寻求创新和个性化的厂商，或者那些想要将WebRTC推向新的用例和新的市场，但受制于目前的实现并不可行的供应来说，这将是非常好的机会。&lt;/p&gt;



&lt;p&gt;如果开发者想要解锁类似功能的话，需要他们更透彻地理解WebRTC。&lt;/p&gt;



&lt;p&gt;聪明的的开发者会爱上WebRTC中的的WebAssembly。因为它可以让他们实现以下功能，比如：&lt;/p&gt;



&lt;p&gt;做一些他们今天做不到的事情，比如不需要依靠谷歌和其他浏览器供应商去开发；&lt;/p&gt;



&lt;p&gt;添加自己的特色功能；&lt;/p&gt;



&lt;p&gt;使用WebRTC更好控制浏览器的行为。&lt;/p&gt;



&lt;p&gt;公司一直在使用定制的WebRTC实现来解决看似与WebRTC正在做的事非常接近的，但又有所不同的问题。&lt;/p&gt;



&lt;p&gt;如果他们有低级别的API访问权限，他们就可以使用WebAssembly在浏览器中运行这些相同的用例，而不必移植、编译和运行自己的独立应用程序。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;strong/&gt;&lt;/p&gt;



&lt;p&gt;除去上述这些优点，加上通过浏览器在移动设备和多个操作系统上的可用性，WebRTC和WASM降低了项目开发和测试成本，使其回到了初心。&lt;/p&gt;



&lt;p&gt;WebRTC不再是一种可望不可及的科技，现在我们就能拥有它。它使人们获得了应对当前形势所需的工具。随着世界经济重回正轨，它能够帮助我们进行远程工作。&lt;/p&gt;



&lt;blockquote class=&quot;wp-block-quote&quot;&gt;&lt;p&gt;文章地址：&lt;a href=&quot;https://blog.rtcweb.in/how-webrtc-and-wasm-are-opening-new-opportunities-for-web-apps/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;https://blog.rtcweb.in/how-webrtc-and-wasm-are-opening-new-opportunities-for-web-apps/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;



&lt;blockquote class=&quot;wp-block-quote&quot;&gt;&lt;p&gt;原文作者：Aaditya Mandloi&lt;/p&gt;&lt;/blockquote&gt;



&lt;p/&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9ca0e4c6b4f309f06cb179310772e6b7</guid>
<title>用大白话给你解释 Zookeeper 的选举机制</title>
<link>https://toutiao.io/k/gjt6as7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Zookeeper&lt;/code&gt; 是一个分布式服务框架，主要是用来解决分布式应用中遇到的一些数据管理问题如：&lt;code&gt;统一命名服务&lt;/code&gt;、&lt;code&gt;状态同步服务&lt;/code&gt;、&lt;code&gt;集群管理&lt;/code&gt;、&lt;code&gt;分布式应用配置项的管理&lt;/code&gt;等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以简单把 &lt;code&gt;Zookeeper&lt;/code&gt; 理解为分布式家庭的大管家，那么管家团队是如何选出&lt;code&gt;Leader&lt;/code&gt;的呢？好奇吗，接下来带领大家一探究竟。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;人类选举的基本原理&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;讲解 &lt;code&gt;Zookeeper&lt;/code&gt; 选举过程前先来介绍一下人类的选举。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们每个人或多或少都经历过几次选举，在投票的过程中可能会遇到这样几种情况：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;情况1&lt;/strong&gt;：自己与几个候选人都比较熟，你会将票投给你认为&lt;code&gt;能力比较强的人&lt;/code&gt;；&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5719844357976653&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EpXZFmBor7Po6SCAW9ibMgIgWicQJ5DI8tmjS8XZ956hG4ZodeSvTwfibEQ9FkIBMQ3Sr8Q6ERVAeZiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1028&quot;/&gt;&lt;figcaption&gt;熟人选举&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;情况2&lt;/strong&gt;：自己也是候选人，并且与其他几个候选人都不熟，这个时候你肯定想着要去拉票，因为觉得自己才是最厉害的人呀，所有人都应该把票投给我。但是遗憾的是在拉票的过程中，你&lt;code&gt;发现别人比你强&lt;/code&gt;，你开始自卑了，最终还是把票投给了自己认为最强的人。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4147982062780269&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EpXZFmBor7Po6SCAW9ibMgIgBFHQMTlEcVgzQhbfic12NrC21xN2QYyC3CqicEAhTAqicciaO1laZrNiaQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;figcaption&gt;自己参与选举&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有人都投完票之后，最后从投票箱中进行统计，获得票数最多的人当选。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7966101694915254&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EpXZFmBor7Po6SCAW9ibMgIgY3X8TpnPrWZjiaF8fEyb5Jk6vibL74gPqrfBpUibgGUOjD6yUFNWT0mPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;708&quot;/&gt;&lt;figcaption&gt;思维导图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在整个投票过程中我们可以提炼出四个最核心的概念：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;候选人能力&lt;/code&gt;：投票的基本原则是选最强的人。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;遇强改投&lt;/code&gt;：如果后面发现更强的人可以改投票。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;投票箱&lt;/code&gt;：所有人的票都会放在投票箱。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;领导者&lt;/code&gt;：得票最多的人即为领导者。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从人类选举的原理我们来简单推导一下Zookeeper的选举原理。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Zookeeper选举的基本原理&lt;/h1&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意如果 Zookeeper 是单机部署是不需要选举的，集群模式下才需要选举。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zookeeper 的选举原理和人类选举的逻辑类似，套用一下人类选举的四个基本概念详细解释一下Zookeeper。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何衡量 Zookeeper 节点个人能力？答案是靠&lt;code&gt;数据是否够新&lt;/code&gt;，如果节点的数据越新就代表这个节点的个人能力越强，是不是感觉很奇怪，就是这么定的！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Zookeeper 中通常是以事务id（后面简称&lt;code&gt;zxid&lt;/code&gt;）来标识数据的新旧程度（版本），节点最新的zxid越大代表这个节点的数据越新，也就代表这个节点能力越强。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;zxid 的全称是 &lt;code&gt;ZooKeeper Transaction Id&lt;/code&gt;，即 Zookeeper 事务id。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在集群选举开始时，节点首先认为自己是最强的（即数据是最新的），然后在选票上写上自己的名字（包括&lt;code&gt;zxid&lt;/code&gt;和&lt;code&gt;sid&lt;/code&gt;），zxid 是事务id，sid 唯一标识自己。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;紧接着会将选票传递给其他节点，同时自己也会接收其他节点传过来的选票。每个节点接收到选票后会做比较，这个人是不是比我强（zxid比我大），如果比较强，那我就需要&lt;code&gt;改票&lt;/code&gt;，明明别人比我强，我也不能厚着脸皮对吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与人类选举投票箱稍微有点不一样，Zookeeper 集群会在每个节点的内存中维护一个投票箱。节点会将自己的选票以及其他节点的选票都放在这个投票箱中。由于选票是互相传阅的，所以最终每个节点投票箱中的选票会是一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在投票的过程中会去统计是否有超过一半的选票和自己选择的是同一个节点，即都认为某个节点是最强的。一旦集群中有&lt;code&gt;超过半数&lt;/code&gt;的节点都认为某个节点最强，那该节点就是领导者了，投票也宣告结束。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么场景下 Zookeeper 需要选举？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 Zookeeper 集群中的一台服务器出现以下两种情况之一时，需要进入 &lt;code&gt;Leader 选举&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）服务器初始化启动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）服务器运行期间 Leader 故障。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;启动时期的 Leader 选举&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设一个 Zookeeper 集群中有5台服务器，id从1到5编号，并且它们都是最新启动的，没有历史数据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.42679558011049723&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EpXZFmBor7Po6SCAW9ibMgIglnOXwk3Gsceic0aWhH6FLactKKqcj65htlaIIlFe8tCiaDM4vGPiaic9ibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1448&quot;/&gt;&lt;figcaption&gt;集群刚启动选举过程&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设服务器依次启动，我们来分析一下选举过程：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）服务器1启动&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发起一次选举，服务器1投自己一票，此时服务器1票数一票，不够半数以上（3票），选举无法完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;投票结果：服务器1为1票。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务器1状态保持为&lt;code&gt;LOOKING&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）服务器2启动&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发起一次选举，服务器1和2分别投自己一票，此时服务器1发现服务器2的id比自己大，更改选票投给服务器2。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;投票结果：服务器1为0票，服务器2为2票。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务器1，2状态保持&lt;code&gt;LOOKING&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（3）服务器3启动&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发起一次选举，服务器1、2、3先投自己一票，然后因为服务器3的id最大，两者更改选票投给为服务器3；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;投票结果：服务器1为0票，服务器2为0票，服务器3为3票。此时服务器3的票数已经超过半数（3票），&lt;strong&gt;服务器3当选&lt;code&gt;Leader&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务器1，2更改状态为&lt;code&gt;FOLLOWING&lt;/code&gt;，服务器3更改状态为&lt;code&gt;LEADING&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（4）服务器4启动&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发起一次选举，此时服务器1，2，3已经不是LOOKING 状态，不会更改选票信息。交换选票信息结果：服务器3为3票，服务器4为1票。此时服务器4服从多数，更改选票信息为服务器3。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务器4并更改状态为&lt;code&gt;FOLLOWING&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（5）服务器5启动&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与服务器4一样投票给3，此时服务器3一共5票，服务器5为0票。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务器5并更改状态为&lt;code&gt;FOLLOWING&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最终的结果&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务器3是 &lt;code&gt;Leader&lt;/code&gt;，状态为 &lt;code&gt;LEADING&lt;/code&gt;；其余服务器是 &lt;code&gt;Follower&lt;/code&gt;，状态为 &lt;code&gt;FOLLOWING&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;运行时期的Leader选举&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Zookeeper运行期间 &lt;code&gt;Leader&lt;/code&gt; 和 &lt;code&gt;非 Leader&lt;/code&gt; 各司其职，当有非 Leader 服务器宕机或加入不会影响 Leader，但是一旦 Leader 服务器挂了，那么整个 Zookeeper 集群将暂停对外服务，会触发新一轮的选举。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始状态下服务器3当选为&lt;code&gt;Leader&lt;/code&gt;，假设现在服务器3故障宕机了，此时每个服务器上zxid可能都不一样，server1为99，server2为102，server4为100，server5为101&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.26116373477672533&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EpXZFmBor7Po6SCAW9ibMgIgx0lf2BzgAzJWGyxiaAeQeBow4ibqTwxnR02fV5Gmb8Kx9kjfHoeKg0UA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1478&quot;/&gt;&lt;figcaption&gt;集群 Leader 节点故障&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行期选举与初始状态投票过程基本类似，大致可以分为以下几个步骤：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）状态变更。Leader 故障后，余下的&lt;code&gt;非 Observer&lt;/code&gt; 服务器都会将自己的服务器状态变更为&lt;code&gt;LOOKING&lt;/code&gt;，然后开始进入&lt;code&gt;Leader选举过程&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）每个Server会发出投票。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）接收来自各个服务器的投票，如果其他服务器的数据比自己的新会改投票。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）处理和统计投票，每一轮投票结束后都会统计投票，超过半数即可当选。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（5）改变服务器的状态，宣布当选。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;话不多说先来一张图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.422029702970297&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EpXZFmBor7Po6SCAW9ibMgIgLxUap97DMSydShdtlSK6SJeO0icibLRxYl5gqdia1HxaYmTssYMnqGsVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1616&quot;/&gt;&lt;figcaption&gt;运行器 Leader 故障后选举流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）第一次投票，每台机器都会将票投给自己。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）接着每台机器都会将自己的投票发给其他机器，如果发现其他机器的zxid比自己大，那么就需要改投票重新投一次。比如server1 收到了三张票，发现server2的xzid为102，pk一下发现自己输了，后面果断改投票选server2为老大。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;选举机制中涉及到的核心概念&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;敲黑板了，这些概念是面试必考的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）Server id（或sid）：服务器ID&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如有三台服务器，编号分别是1,2,3。编号越大在选择算法中的权重越大，比如初始化启动时就是根据服务器ID进行比较。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）Zxid：事务ID&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务器中存放的数据的事务ID，值越大说明数据越新，在选举算法中数据越新权重越大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（3）Epoch：逻辑时钟&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也叫投票的次数，同一轮投票过程中的逻辑时钟值是相同的，每投完一次票这个数据就会增加。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（4）Server状态：选举状态&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;LOOKING&lt;/code&gt;，竞选状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;FOLLOWING&lt;/code&gt;，随从状态，同步leader状态，参与投票。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;OBSERVING&lt;/code&gt;，观察状态,同步leader状态，不参与投票。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;LEADING&lt;/code&gt;，领导者状态。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）Zookeeper 选举会发生在服务器初始状态和运行状态下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）初始状态下会根据服务器sid的编号对比，编号越大权值越大，投票过半数即可选出Leader。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）Leader 故障会触发新一轮选举，&lt;code&gt;zxid&lt;/code&gt; 代表数据越新，权值也就越大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）在运行期选举还可能会遇到脑裂的情况，大家可以自行学习。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1983fa1ae3089302113bb08ec9036c6b</guid>
<title>复杂环境下落地 Service Mesh 的挑战与实践</title>
<link>https://toutiao.io/k/pd8izls</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、美团服务治理建设进展&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.1 服务治理发展史&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先讲一下 OCTO，此前美团技术团队博客也分享过很多&lt;a target=&quot;_blank&quot; href=&quot;https://tech.meituan.com/tags/octo.html&quot; textvalue=&quot;相关的文章&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;相关的文章&lt;/a&gt;，它是美团标准化的服务治理基础设施，现应用于美团所有事业线。OCTO 的治理生态非常丰富，性能及易用性表现也很优异，可整体概括为 3 个特征：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;属于公司级的标准化基础设施。技术栈高度统一，覆盖了公司 90% 以上的应用，日均调用量达数万亿次。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;经历过较大规模的技术考验。覆盖数万个服务、数十万个节点。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;治理能力丰富。协同周边治理生态，实现了 SET 化、链路级复杂路由、全链路压测、鉴权加密、限流熔断等治理能力。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;回顾美团服务治理体系的发展史，历程整体上划分为四个阶段：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第一阶段是基础治理能力统一&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。实现通信框架及注册中心的统一，由统一的治理平台支撑节点管理、流量管理、监控预警等运营能力。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第二阶段重点提升性能及易用性&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。4 核 4GB 环境下使用 1KB 数据进行 echo 测试，QPS 从 2 万提升至接近 10 万，99 分位线 1ms；也建设了分布式链路追踪、分阶段耗时精细埋点等功能。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第三阶段是全方位丰富治理能力&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。落地了全链路压测平台、性能诊断优化平台、稳定性保障平台、鉴权加密等一系列平台，也实现了链路级别的流量治理，如全链路灰度发布等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第四阶段是建设了跨地域的容灾及扩展能力&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。在每天数千万订单量级下实现了单元化，也实现了所有 PaaS 层组件及核心存储系统的打通。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.30217391304347824&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVXibOr79CicaI6vkKH7oNbXUUWbLw6cPGoYIV3KHv4cKMTqSMlevjGiaeWwBxDv8LdWue0QaZ6g8qyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1840&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.2 服务治理体系的困境&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前，美团已具备了较完善的治理体系，但仍有较多的痛点及挑战。大的背景是公司业务蓬勃发展，业务愈发多元化，治理也愈发精细化，这带来了较多新的问题：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务与中间件强耦合，制约彼此迭代。当中间件引入 Bug，可能成百上千、甚至数千个业务需要做配合升级，中间件的新特性也依赖业务升级后才能使用，成本很高。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;中间件版本碎片化严重。发布出去的组件基本托管在业务侧，很难统一进行管控，这也频繁造成业务多类的问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;异构体系融合难。新融入公司的技术体系往往与美团不兼容，治理体系打通的成本很高，难度也很大。此前，美团与大众点评打通治理，不包含业务迁移，就历时 1 年半的时间；近期，摩拜使用的 gRPC 框架也无法与系统进行通信，但打通迫在眉睫。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;非 Java 语言治理体系能力弱，多个主流语言无官方 SDK。多元业务场景下，未来多语言也是个趋势，比如在机器学习领域，Python 语言不太可能被其他语言完全代替。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、服务治理体系优化的思路与挑战&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.1 优化思路&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总结来看，OCTO 在服务层实现了统一抽象来支撑业务发展，但它并未解决这层架构可以独立演进的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.2节中问题1与问题2的本质是“耦合”，问题3与问题4的本质是“缺乏标准服务治理运行时”。在理想的架构中，异构语言、异构治理体系可以共用统一的标准治理运行时，仅在业务使用的 SDK 部分有轻微差异。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，我们整体的优化思路分为三步：&lt;strong&gt;隔离解耦&lt;/strong&gt;，&lt;strong&gt;在隔离出的基础设施层建设标准化治理运行时&lt;/strong&gt;，&lt;strong&gt;标准之上建体系&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.36525612472160357&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVXibOr79CicaI6vkKH7oNbXUNfPLEvYbMfWZJCNYicKp62GX4hlUpVrWk5Y5ia4KwsEsliaDZKhd6YevA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1796&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;上述解决方案所对应的新架构模式下，各业务进程会附属一个 Proxy 进程，SDK 发出以及接收的流量均会被附属的 Proxy 拦截。像限流、路由等治理功能均由 Proxy 和中心化的控制大脑完成，并由控制面对接所有治理子系统集成。这种模式下 SDK 很轻薄，异构的语言、异构的治理体系就很容易互通，从而实现了物理解耦，业界将这种模式称为 Service Mesh（&lt;/span&gt;&lt;span&gt;其中 Proxy 被称为数据面、中心化控制大脑被称为控制面&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5263870094722598&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVXibOr79CicaI6vkKH7oNbXUv2oMvqKQT4xFe9vkmcuoBYPAg0WW6K0jc686voH9Gf9fEgxHzMicVoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1478&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2 复杂性挑战&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;美团在实践中所面临的复杂性划主要包括以下4类：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;兼容性&lt;/strong&gt;：技术改造涉及范围较大，一方面需要通过保证现有通信方式及平台使用方式不变，从而来保障业务研发效率，另一方面也要解决运行载体多样性、运维体系兼容等问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;异构性&lt;/strong&gt;：第一是多语言互通问题；第二是打通治理体系内的众多治理子系统，像服务鉴权、注册中心等系统的存储及发布订阅机制都是不同的；第三是快速打通新融入公司的异构治理体系。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;大规模支撑&lt;/strong&gt;：出于性能方面考虑，开源 Istio 等产品不宜直接应用于大规模的生产环境，美团控制面需具备百万级链接下高吞吐、低延迟、高精确的系统能力。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;重交易型业务容错性低&lt;/strong&gt;：交易型业务场景下，业务对 Service Mesh 的性能、稳定性往往持怀疑态度；美团基础架构团队也强调在业务价值导向下，基于实际业务价值进行运营推广，而不是采用从上至下的偏政策性推广方式。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;三、美团落地 Service Mesh 的解决方案&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.1 整体架构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;美团采用数据面基于 Envoy 二次开发、控制面自研为主、SDK 协同升级的方案（&lt;/span&gt;&lt;span&gt;内部项目名是 OCTO Mesh&lt;/span&gt;&lt;span&gt; ）。架构简介如下：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;各语言轻薄的 SDK 与 Proxy 通过 UDS（&lt;/span&gt;&lt;span&gt;Unix Domain Socket&lt;/span&gt;&lt;span&gt;）交互，主要出发点是考虑到相比透明流量劫持，UDS 性能与可运维性更好。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;控制面与 Proxy 通过双向流通信，控制面与治理生态的多个子系统交互，并将计算处理过的治理数据及策略数据下发给 Proxy 执行，协同配合完成路由、限流等所有核心治理功能。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;控制面内部的 5 个模块都是自研的独立服务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;自研了的 Meta Server 系统实现 Mesh 体系内部的节点注册和寻址，通过管理控制面与数据面的链接关系，也实现了按事业群隔离、水平扩展等能力。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4744791666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVXibOr79CicaI6vkKH7oNbXUm3ANjSH2hwONkalraiaoe2L4niaLUEpln0m3lHuaib125JKVD4ic99uic5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.2 兼容性解决方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;兼容性的目标及特征用一句话来总结就是：业务接入无感知。为此，我们做了以下三件事情：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;(1) 与现有基础设施及治理体系兼容&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;(2) 协议兼容&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;服务间调用往往是多对多的关系，一般调用端与服务端无法同时升级，为支持 Mesh 与非 Mesh 的互通，增强后的协议对业务完全透明。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;与语义相关的所有内容（&lt;/span&gt;&lt;span&gt;比如异常等&lt;/span&gt;&lt;span&gt;），均在 SDK 与 Proxy 之间达成共识，保证兼容。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;无法在控制面及数据面中实现的能力，在 SDK 中执行并通过上下文传递给 Proxy，保障功能完全对齐，当然这种情况应该尽量避免的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;(3) Mesh 与非 Mesh 模式的无缝切换&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.3 异构性解决方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;异构性的目标及特征用一句话总结就是：标准化服务治理运行时。具体可拆分为3个子目标：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对上述3个子目标，我们所采取的方案如下：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将数据面 + 控制面定义为标准化的服务治理运行时，在标准运行时内打通所有治理能力。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;建设统一接入中心系统 Dispatcher ，并由其对接并屏蔽治理子系统的异构性，从而实现外部系统的差异对 Pilot 透明；下图中 Dispatcher 与 Pilot 直接交互，Meta Server 的作用是避免广播降低冗余。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;重构或从零建设 SDK，目前使用的 6 种语言 SDK 均已落地并使用。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;异构语言、异构体系均使用增强的统一协议交互，实现互通。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3007360672975815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVXibOr79CicaI6vkKH7oNbXU1Aibg1KOL6cfoPqve2GpsOkZJXUZj53ldmqfA5XZxoQyrpB2s43fbSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1902&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;通过 Service Mesh 实现体系融合的前后对比如下：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3023983315954119&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVXibOr79CicaI6vkKH7oNbXUDkODJ05MMB7LiasicK2oia4ib1HcSMt1r3Yu9SicUhxq4kwjYE7m2aSfThQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1918&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;通过上述方案，针对异构性方面取得了较好的效果：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;标准化 6 种语言治理体系，非 Java 语言的核心治理能力基本对齐 Java；新语言也很容易融入，提供的官方 Python 语言、Golang 语言的通信框架新版本（&lt;/span&gt;&lt;span&gt;依托于 OCTO Mesh&lt;/span&gt;&lt;span&gt;），开发成本均控制在1个月左右。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持异构治理子系统通过统一接入中心快速融入，架构简洁、扩展性强。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持异构治理体系快速融合并在单车侧落地，异构治理体系打通成本也从 1.5 年降低到 1 个月。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.4 规模化解决方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.4.1 开源 Istio 问题分析&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;规模化的目标及特征用一句话总结是：&lt;strong&gt;具备支撑数万服务、百万节点体量的系统能力，并支持水平扩展&lt;/strong&gt;。挑战主要有3个：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过对 Istio 架构进行深入分析，我们发现核心问题聚焦在以下3个瓶颈点：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;每个控制面实例有 ETCD 存储系统的全部数据，无法水平扩展。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;每个 Proxy 链接相当于独立与 ETCD 交互，而同一个服务的 Proxy 请求内容都相同，独立交互有大量的 I/O 冗余。当 Proxy 批量发版或网络抖动时，瞬时风暴很容易压垮控制面及 ETCD。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;每个节点都会探活所有其他节点。10 万节点规模的集群，1 个检测周期有 100 亿次探活，会引发网络风暴。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3326110509209101&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVXibOr79CicaI6vkKH7oNbXUXW7xAUz1T8mLdL6ibImCtRZqgRoqpQibbBKjOZGAE755v9x6DSnBjLicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1846&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.4.2 措施一：横向数据分片&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对 Istio 控制面各实例承载全集群数据的问题，对应的措施是通过横向逻辑数据分片支持扩展性，具体方案设计如下：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Proxy 启动时会去向 Meta Server 系统请求需要连接的 Pilot IP，Meta Server 将相同服务的 Proxy 尽量落到同一个控制面节点（&lt;/span&gt;&lt;span&gt;内部策略更为复杂，还要考虑地域、负载等情况&lt;/span&gt;&lt;span&gt;），这样每个 Pilot 实例按需加载而不必承载所有数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;控制面节点异常或发布更新时，其所管理的 Proxy 也会有规律的迁移，恢复后在一定时间后还会接管其负责的 Proxy，从而实现了会话粘滞，也就实现逻辑上面的数据分片。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3605150214592275&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVXibOr79CicaI6vkKH7oNbXUBtNWDvGrGNicic7ysOUkUT2sPQ2bBZf6cDrbv9wIScYia2NvYonSh0iaaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1864&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;通过管理链接关系实现了按事业群隔离、按服务灰度等平台能力，最关键的还是解决了 Mesh 体系水平扩展的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.4.3 措施二：纵向分层订阅&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对 Istio 独立管理各 Proxy 链接的 I/O 冗余问题，对应的措施是通过分层订阅减少冗余 I/O。Proxy 不直接与存储等系统对接，而是在中间经过一系列的处理，关键点有两个：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;关键点 1：基于快照缓存 + 索引的机制来减少 ZK watcher 同步。以注册中心为例，常规实现方式下，如果每个 Proxy 关注 100 个节点，1 万个节点就会注册 100 万个 watcher，相同服务的 Proxy 所关注内容是相同的，另外不同服务 Proxy 所关注的也有很多交集，其中包含大量的冗余。分层订阅模式下，Proxy 不与注册中心直接交互，通过中间的快照缓存与分层，确保每个 Pilot 实例中 ZK 相同路径的监听最多只用1个 watcher，获取到 watcher 通知后，Pilot 根据内部的快照缓存 + 索引向所有关注者分发，大大降低了冗余。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;关键点 2：治理能力层及会话管理层实现了类似于 I/O 多路复用能力，通过并发提升吞吐。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4609704641350211&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVXibOr79CicaI6vkKH7oNbXUnmA8MtplmwdsUeyibAmSVKcicZHprHfJZLE2lnibhZ8uYDBk2SQebcyyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1896&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;结果方面有效应对了网络抖动或批量发版的瞬间风暴压力，压测单 Pilot 实例可以承载 6 万以上的链接，时延 TP99 线 &amp;lt; 2.3ms、数据零丢失。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.4.4 措施三：集中式健康检测&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对大规模集群内指数级膨胀的节点间健康监测次数，对应的措施是摒弃了 P2P 检测模式，我们参考并优化了 Google 的 Traffic Drector 中心化管理的健康检测模式。这种模式下检测次数大大减少，一个周期内 10 万节点集群的检测次数，从 100 亿次下降到 10 万次。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，当 Pilot 感知到 Proxy 异常时，会立即通知中心化健康检测系统启动检测，而不是等待检测周期窗口的到来，这可以有效提升业务调用的成功率。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2939330543933054&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVXibOr79CicaI6vkKH7oNbXUEguvQFaQR3E4TPQ8O6yxRhBwcTgVm2iaGMicj8fkhrGxlSI6RpWbhnyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1912&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.5 交易型场景困境下的解决方案&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.5.1 业务属性分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;美团内部业务线较多，包括外卖、配送、酒店、旅游、单车、团购等，其中绝大多数业务都带有交易属性，交易链路上一个流量异常就可能影响到订单。业务系统对新技术领域的探索往往比较慎重，期望在新技术充分验证后再启动试点，所以除小语种及亟待与公司打通的单车业务外，推广的难度是非常大的。此外，基础架构部秉承“以客户为中心”的原则，研发、运维、测试人员均是我们的“客户”，所以技术升级会重点从业务价值入手，并非简单依靠从上至下的政策推动力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，我们对外的承诺是：&lt;strong&gt;通信足够快、系统足够稳定、接入足够平滑高效&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.38969616908850724&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVXibOr79CicaI6vkKH7oNbXUibwAqjibkZs3JWdF2rzQyLSztRc3fl2lcd7oL1SYoicYPXq7uQcEvtS8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1514&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.5.2 精细化运营体系建设&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对推广的困境，我们首先做了两件事情：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对上述困境，我们进行深度思考后建立了一个精细化的运营体系：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;服务接入 Mesh 前。基于 SOA 分级将服务划分为非核心与核心两类，先针对非核心服务以及所有服务的线下环境进行重点突破，实现了在广泛的业务场景下，全面且充分的验证系统能力。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;服务接入 Mesh 中。运营系统通过校验 SDK 版本、运行时环境等信息，自动筛选出满足条件的服务，业务同学只需要在平台上做（1）开启开关、（2）选择节点（3）指定 Mesh 流量比例三个步骤，就完成了到 Mesh 模式的切换，不需代码改造也不需发布服务，整个过程基本在 1 分钟左右完成；此外，通过与 IM 工具深度联动，提升了推广与数据运营的效率。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;服务接入 Mesh 后。一方面，业务侧包括架构侧的运营有详细的数据指标做对比参考；另一方面，运营系统支持预先设置稳定性策略并做准实时的检测，当某个接入服务 Mesh 模式异常时，即时自动切换回非 Mesh 模式。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;运营体系具备 “接入过程无感”、“精细化流量粒度灰度”、“异常自动回滚恢复” 三个核心能力，在运营体系建设后推广运营较为顺利，目前线上接入的 600+ 服务、线下接入的 3500+ 服务中，90% 以上是依托运营平台接入 Mesh 的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.5.3 通信性能优化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在性能损耗优化这个方向，除使用 UDS 规避网络栈外，我们也通过增量聚合下发、序列化优化两个措施减少不必要的解包，提升了通信性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过压测，去除非核心功能在 2 核 4G 环境用 1KB 数据做 echo 测试，QPS 在 34000 以上，一跳平均延迟 0.207ms，时延TP99 线 0.4ms 左右。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.5.4 流量多级保护&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;美团落地 Service Mesh 在稳定性保障方面建设投入较多，目前尚无 Service Mesh 引发的故障，具体包含三个方面：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文系统性的介绍美团在 Service Mesh 落地进程中面临的“兼容性”、“异构性”、“规模化”、“交易属性业务容错性低”这四类复杂性挑战，针对上述挑战，我们也详细介绍了大规模私有云集群场景下的优化思考及实践方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于上述实践，目前美团线上落地服务数超过 600，线下服务数超过 3500+，初步验证了模式的可行性。短期价值方面，我们支持了摩拜等异构治理体系的快速融合、多语言治理能力的统一；长期价值仍需在实践中继续探索与验证，但在标准化服务治理运行时并与业务解耦、中心化管控下更丰富的治理能力输出两个方面，是非常值得期待的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;继东、薛晨、业祥、张昀，均来自美团基础技术部-基础架构部。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e90446034c9b9f7a9103e44d5ea9b4ad</guid>
<title>一万字详解 Redis Cluster Gossip 协议</title>
<link>https://toutiao.io/k/0gpib61</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;markdown编辑器&quot; data-website=&quot;https://markdown.com.cn/editor&quot;&gt;&lt;p&gt;&lt;span&gt;点击上方&quot;&lt;span&gt;程序员历小冰&lt;/span&gt;&quot;，选择“置顶或者星标”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;   你的关注意义重大!&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;大家好，我是历小冰，今天来讲一下 Reids Cluster 的 Gossip 协议和集群操作，文章的思维导图如下所示。&lt;/p&gt;&lt;figure data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9QbuglRCMtf6luwxERWeou44CO9B0dyNtpJkQickWkmDVicLp0E1MJPz6FO4H4F6hjAVhMadBhaKZSB8mxKBPyCQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.4759259259259259&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;集群模式和 Gossip 简介&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;strong&gt;对于数据存储领域，当数据量或者请求流量大到一定程度后，就必然会引入分布式&lt;/strong&gt;。比如 Redis，虽然其单机性能十分优秀，但是因为下列原因时，也不得不引入集群。&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;单机无法保证高可用，需要引入多实例来提供高可用性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单机能够提供高达 8W 左右的QPS，再高的QPS则需要引入多实例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单机能够支持的数据量有限，处理更多的数据需要引入多实例；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单机所处理的网络流量已经超过服务器的网卡的上限值，需要引入多实例来分流。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;有集群，集群往往需要维护一定的元数据，比如实例的ip地址，缓存分片的 slots 信息等，所以需要一套分布式机制来维护元数据的一致性。这类机制一般有两个模式：分散式和集中式&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;分散式机制将元数据存储在部分或者所有节点上，不同节点之间进行不断的通信来维护元数据的变更和一致性。Redis Cluster，Consul 等都是该模式。&lt;/p&gt;&lt;figure data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtf6luwxERWeou44CO9B0dyNYe0107Oq3qWP8awXSpzaqAWXk5L8T9mTv5KJLUa20vGq1N648Y9ADA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.7052154195011338&quot; data-w=&quot;441&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;而集中式是将集群元数据集中存储在外部节点或者中间件上，比如 zookeeper。旧版本的 kafka 和 storm 等都是使用该模式。&lt;/span&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtf6luwxERWeou44CO9B0dyNfjXnl4lMhNbVV5SvicF31JxdQS3icmibOKoMmHvdn6IvUWykYyWFj4yNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6963123644251626&quot; data-w=&quot;461&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;两种模式各有优劣，具体如下表所示：&lt;/span&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;table data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;模式&lt;/th&gt;&lt;th&gt;优点&lt;/th&gt;&lt;th&gt;缺点&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;集中式&lt;/td&gt;&lt;td&gt;数据更新及时，时效好，元数据的更新和读取，时效性非常好，一旦元数据出现了变更，立即就更新到集中式的外部节点中，其他节点读取的时候立即就可以感知到;&lt;/td&gt;&lt;td&gt;较大数据更新压力，更新压力全部集中在外部节点，作为单点影响整个系统&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;分散式&lt;/td&gt;&lt;td&gt;数据更新压力分散，元数据的更新比较分散，不是集中某一个节点，更新请求比较分散，而且有不同节点处理，有一定的延时，降低了并发压力&lt;/td&gt;&lt;td&gt;数据更新延迟，可能导致集群的感知有一定的滞后&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;分散式的元数据模式有多种可选的算法进行元数据的同步，比如说 Paxos、Raft 和 Gossip。Paxos 和 Raft 等都需要全部节点或者大多数节点(超过一半)正常运行，整个集群才能稳定运行，而 Gossip 则不需要半数以上的节点运行。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;Gossip 协议，顾名思义，就像流言蜚语一样，利用一种随机、带有传染性的方式，将信息传播到整个网络中，并在一定时间内，使得系统内的所有节点数据一致。对你来说，掌握这个协议不仅能很好地理解这种最常用的，实现最终一致性的算法，也能在后续工作中得心应手地实现数据的最终一致性。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;Gossip 协议又称 epidemic 协议（epidemic protocol），是基于流行病传播方式的节点或者进程之间信息交换的协议，在P2P网络和分布式系统中应用广泛，它的方法论也特别简单：&lt;/p&gt;&lt;blockquote data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;在一个处于有界网络的集群里，如果每个节点都随机与其他节点交换特定信息，经过足够长的时间后，集群各个节点对该份信息的认知终将收敛到一致。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;这里的“特定信息”一般就是指集群状态、各节点的状态以及其他元数据等。Gossip协议是完全符合 BASE 原则，可以用在任何要求最终一致性的领域，比如分布式存储和注册中心。另外，它可以很方便地实现弹性集群，允许节点随时上下线，提供快捷的失败检测和动态负载均衡等。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;此外，Gossip 协议的最大的好处是，即使集群节点的数量增加，每个节点的负载也不会增加很多，几乎是恒定的。这就允许 Redis Cluster 或者 Consul 集群管理的节点规模能横向扩展到数千个。&lt;/p&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Redis Cluster 的 Gossip 通信机制&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;Redis Cluster 是在 3.0 版本引入集群功能。为了让让集群中的每个实例都知道其他所有实例的状态信息，Redis 集群规定各个实例之间按照 Gossip 协议来通信传递信息。&lt;/p&gt;&lt;figure data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9QbuglRCMtf6luwxERWeou44CO9B0dyNucqE1bUrhKOOibecGrbS17RVfOtcI1RLm2Ah6EMX92Uib7bgXSy6fnGg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.7175925925925926&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;上图展示了主从架构的 Redis Cluster 示意图，其中实线表示节点间的主从复制关系，而虚线表示各个节点之间的 Gossip 通信。&lt;/span&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;Redis Cluster 中的每个节点都&lt;strong&gt;维护一份自己视角下的当前整个集群的状态&lt;/strong&gt;，主要包括：&lt;/p&gt;&lt;ol data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;当前集群状态&lt;/em&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;集群中各节点所负责的 slots信息，及其migrate状态&lt;/em&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;集群中各节点的master-slave状态&lt;/em&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;集群中各节点的存活状态及怀疑Fail状态&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;也就是说上面的信息，就是集群中Node相互八卦传播流言蜚语的内容主题，而且比较全面，既有自己的更有别人的，这么一来大家都相互传，最终信息就全面而且一致了。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;Redis Cluster 的节点之间会相互发送多种消息，较为重要的如下所示：&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;MEET：通过「cluster meet ip port」命令，已有集群的节点会向新的节点发送邀请，加入现有集群，然后新节点就会开始与其他节点进行通信；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PING：节点按照配置的时间间隔向集群中其他节点发送 ping 消息，消息中带有自己的状态，还有自己维护的集群元数据，和部分其他节点的元数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PONG:  节点用于回应 PING 和 MEET 的消息，结构和 PING 消息类似，也包含自己的状态和其他信息，也可以用于信息广播和更新；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;FAIL: 节点 PING 不通某节点后，会向集群所有节点广播该节点挂掉的消息。其他节点收到消息后标记已下线。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;Redis 的源码中 cluster.h 文件定义了全部的消息类型，代码为 redis 4.0版本。&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 注意，PING 、 PONG 和 MEET 实际上是同一种消息。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// PONG 是对 PING 的回复，它的实际格式也为 PING 消息，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 而 MEET 则是一种特殊的 PING 消息，用于强制消息的接收者将消息的发送者添加到集群中（如果节点尚未在节点列表中的话）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; CLUSTERMSG_TYPE_PING 0          &lt;span&gt;/* Ping 消息 */&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; CLUSTERMSG_TYPE_PONG 1          &lt;span&gt;/* Pong 用于回复Ping */&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; CLUSTERMSG_TYPE_MEET 2          &lt;span&gt;/* Meet 请求将某个节点添加到集群中 */&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; CLUSTERMSG_TYPE_FAIL 3          &lt;span&gt;/* Fail 将某个节点标记为 FAIL */&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; CLUSTERMSG_TYPE_PUBLISH 4       &lt;span&gt;/* 通过发布与订阅功能广播消息 */&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST 5 &lt;span&gt;/* 请求进行故障转移操作，要求消息的接收者通过投票来支持消息的发送者 */&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK 6     &lt;span&gt;/* 消息的接收者同意向消息的发送者投票 */&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; CLUSTERMSG_TYPE_UPDATE 7        &lt;span&gt;/* slots 已经发生变化，消息发送者要求消息接收者进行相应的更新 */&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; CLUSTERMSG_TYPE_MFSTART 8       &lt;span&gt;/* 为了进行手动故障转移，暂停各个客户端 */&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; CLUSTERMSG_TYPE_COUNT 9         &lt;span&gt;/* 消息总数 */&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;通过上述这些消息，集群中的每一个实例都能获得其它所有实例的状态信息。这样一来，即使有新节点加入、节点故障、Slot 变更等事件发生，实例间也可以通过 PING、PONG 消息的传递，完成集群状态在每个实例上的同步。下面，我们依次来看看几种常见的场景。&lt;/p&gt;&lt;h4 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;定时 PING/PONG 消息&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;Redis Cluster 中的节点都会定时地向其他节点发送 PING 消息，来交换各个节点状态信息，检查各个节点状态，包括在线状态、疑似下线状态 PFAIL 和已下线状态 FAIL。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;Redis 集群的定时 PING/PONG 的工作原理可以概括成两点：&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一是，每个实例之间会按照一定的频率，从集群中随机挑选一些实例，把 PING 消息发送给挑选出来的实例，用来检测这些实例是否在线，并交换彼此的状态信息。PING 消息中封装了发送消息的实例自身的状态信息、部分其它实例的状态信息，以及 Slot 映射表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;二是，一个实例在接收到 PING 消息后，会给发送 PING 消息的实例，发送一个 PONG 消息。PONG 消息包含的内容和 PING 消息一样。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;下图显示了两个实例间进行 PING、PONG 消息传递的情况，其中实例一为发送节点，实例二是接收节点&lt;/p&gt;&lt;figure data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtf6luwxERWeou44CO9B0dyNMEP3uAsuwura7aQlbCakOPdfYUQfwUtnZD8ywI61wFYdapticErE7PQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.2787193973634652&quot; data-w=&quot;531&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;新节点上线&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;Redis Cluster 加入新节点时，客户端需要执行 CLUSTER MEET 命令，如下图所示。&lt;/p&gt;&lt;figure data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtf6luwxERWeou44CO9B0dyNBM0XvDUl83RHNicIKpXBYpF9xxsowQZibOXk1NWiaicVBEKtonNVXmFuPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.40850277264325324&quot; data-w=&quot;541&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;节点一在执行 CLUSTER MEET 命令时会首先为新节点创建一个 clusterNode 数据，并将其添加到自己维护的 clusterState 的 nodes 字典中。有关 clusterState 和 clusterNode 关系，我们在最后一节会有详尽的示意图和源码来讲解。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;然后节点一会根据据 CLUSTER MEET 命令中的 IP 地址和端口号，向新节点发送一条 MEET 消息。新节点接收到节点一发送的MEET消息后，新节点也会为节点一创建一个 clusterNode 结构，并将该结构添加到自己维护的 clusterState 的 nodes 字典中。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;接着，新节点向节点一返回一条PONG消息。节点一接收到节点B返回的PONG消息后，得知新节点已经成功的接收了自己发送的MEET消息。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;最后，节点一还会向新节点发送一条 PING 消息。新节点接收到该条 PING 消息后，可以知道节点A已经成功的接收到了自己返回的P ONG消息，从而完成了新节点接入的握手操作。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;MEET 操作成功之后，节点一会通过稍早时讲的定时 PING 机制将新节点的信息发送给集群中的其他节点，让其他节点也与新节点进行握手，最终，经过一段时间后，新节点会被集群中的所有节点认识。&lt;/p&gt;&lt;h4 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;节点疑似下线和真正下线&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;Redis Cluster 中的节点会定期检查已经发送 PING 消息的接收方节点是否在规定时间 ( cluster-node-timeout ) 内返回了 PONG 消息，如果没有则会将其标记为疑似下线状态，也就是 PFAIL 状态，如下图所示。&lt;/p&gt;&lt;figure data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtf6luwxERWeou44CO9B0dyNDu41hrk4h5v8oHbficKlGH6ujLpPaRReVHBIJa6EJIflVpWAnbRfwrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.2919020715630885&quot; data-w=&quot;531&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;然后，节点一会通过 PING 消息，将节点二处于疑似下线状态的信息传递给其他节点，例如节点三。节点三接收到节点一的 PING 消息得知节点二进入 PFAIL 状态后，会在自己维护的 clusterState 的 nodes 字典中找到节点二所对应的 clusterNode 结构，并将主节点一的下线报告添加到 clusterNode 结构的 fail_reports 链表中。&lt;/p&gt;&lt;figure data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtf6luwxERWeou44CO9B0dyNrwAd27ub4QbFh1Z39rtOdogxNdjVicT5D2auzgS8y2d7dHSV5KRIv2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.3211314475873544&quot; data-w=&quot;601&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;随着时间的推移，如果节点十 (举个例子) 也因为 PONG 超时而认为节点二疑似下线了，并且发现自己维护的节点二的 clusterNode 的 fail_reports 中有&lt;strong&gt;半数以上的主节点数量的未过时的将节点二标记为 PFAIL 状态报告日志&lt;/strong&gt;，那么节点十将会把节点二将被标记为已下线 FAIL 状态，并且节点十会&lt;strong&gt;立刻&lt;/strong&gt;向集群其他节点广播主节点二已经下线的 FAIL 消息，所有收到 FAIL 消息的节点都会立即将节点二状态标记为已下线。如下图所示。&lt;/p&gt;&lt;figure data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtf6luwxERWeou44CO9B0dyN2bkWrqWMJG6qOAnxFC8juGyUudcVnxicE041WqJSry4I8VdwqUqxDwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5099818511796733&quot; data-w=&quot;551&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;需要注意的是，报告疑似下线记录是由时效性的，如果超过 cluster-node-timeout *2 的时间，这个报告就会被忽略掉，让节点二又恢复成正常状态。&lt;/p&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Redis Cluster 通信源码实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;综上，我们了解了 Redis Cluster 在定时 PING/PONG、新节点上线、节点疑似下线和真正下线等环节的原理和操作流程，下面我们来真正看一下 Redis 在这些环节的源码实现和具体操作。&lt;/p&gt;&lt;h4 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;涉及的数据结构体&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;首先，我们先来讲解一下其中涉及的数据结构，也就是上文提到的 ClusterNode 等结构。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;strong&gt;每个节点都会维护一个 clusterState 结构&lt;/strong&gt;，表示当前集群的整体状态，它的定义如下所示。&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;typedef&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;clusterState&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;   clusterNode *myself;  &lt;span&gt;/* 当前节点的clusterNode信息 */&lt;/span&gt;&lt;br/&gt;   ....&lt;br/&gt;   dict *nodes;          &lt;span&gt;/* name到clusterNode的字典 */&lt;/span&gt;&lt;br/&gt;   ....&lt;br/&gt;   clusterNode *slots[CLUSTER_SLOTS]; &lt;span&gt;/* slot 和节点的对应关系*/&lt;/span&gt;&lt;br/&gt;   ....&lt;br/&gt;} clusterState;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;它有三个比较关键的字段，具体示意图如下所示：&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;myself 字段，是一个 clusterNode 结构，用来记录自己的状态；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;nodes 字典，记录一个 name 到 clusterNode 结构的映射，以此来记录其他节点的状态；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;slot 数组，记录slot 对应的节点 clusterNode结构。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtf6luwxERWeou44CO9B0dyN7oFXsf4ziaRiciapd0UOvbvY1Z0E7I2ujMObwHKYyedr4pM9agyKPK5nQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6228338430173292&quot; data-w=&quot;981&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;clusterNode 结构&lt;strong&gt;保存了一个节点的当前状态&lt;/strong&gt;，比如&lt;strong&gt;节点的创建时间、节点的名字、节点 当前的配置纪元、节点的IP地址和端口号等等&lt;/strong&gt;。除此之外，clusterNode结构的 link 属性是一个clusterLink结构，该结构保存了连接节点所需的有关信息**，比如**套接字描述符，输入缓冲区和输出缓冲区。clusterNode 还有一个 fail_report 的列表，用来记录疑似下线报告。具体定义如下所示。&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;typedef&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;clusterNode&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;mstime_t&lt;/span&gt; ctime; &lt;span&gt;/* 创建节点的时间 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; name[CLUSTER_NAMELEN]; &lt;span&gt;/* 节点的名字 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; flags;      &lt;span&gt;/* 节点标识，标记节点角色或者状态，比如主节点从节点或者在线和下线 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;uint64_t&lt;/span&gt; configEpoch; &lt;span&gt;/* 当前节点已知的集群统一epoch */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; slots[CLUSTER_SLOTS/&lt;span&gt;8&lt;/span&gt;]; &lt;span&gt;/* slots handled by this node */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; numslots;   &lt;span&gt;/* Number of slots handled by this node */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; numslaves;  &lt;span&gt;/* Number of slave nodes, if this is a master */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;clusterNode&lt;/span&gt; **&lt;span&gt;slaves&lt;/span&gt;;&lt;/span&gt; &lt;span&gt;/* pointers to slave nodes */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;clusterNode&lt;/span&gt; *&lt;span&gt;slaveof&lt;/span&gt;;&lt;/span&gt; &lt;span&gt;/* pointer to the master node. Note that it&lt;br/&gt;                                    may be NULL even if the node is a slave&lt;br/&gt;                                    if we don&#x27;t have the master node in our&lt;br/&gt;                                    tables. */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;mstime_t&lt;/span&gt; ping_sent;      &lt;span&gt;/* 当前节点最后一次向该节点发送 PING 消息的时间 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;mstime_t&lt;/span&gt; pong_received;  &lt;span&gt;/* 当前节点最后一次收到该节点 PONG 消息的时间 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;mstime_t&lt;/span&gt; fail_time;      &lt;span&gt;/* FAIL 标志位被设置的时间 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;mstime_t&lt;/span&gt; voted_time;     &lt;span&gt;/* Last time we voted for a slave of this master */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;mstime_t&lt;/span&gt; repl_offset_time;  &lt;span&gt;/* Unix time we received offset for this node */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;mstime_t&lt;/span&gt; orphaned_time;     &lt;span&gt;/* Starting time of orphaned master condition */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; repl_offset;      &lt;span&gt;/* 当前节点的repl便宜 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; ip[NET_IP_STR_LEN];  &lt;span&gt;/* 节点的IP 地址 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; port;                   &lt;span&gt;/* 端口 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; cport;                  &lt;span&gt;/* 通信端口，一般是端口+1000 */&lt;/span&gt;&lt;br/&gt;    clusterLink *link;          &lt;span&gt;/* 和该节点的 tcp 连接 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;list&lt;/span&gt; *fail_reports;         &lt;span&gt;/* 下线记录列表 */&lt;/span&gt;&lt;br/&gt;} clusterNode;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;clusterNodeFailReport 是记录节点下线报告的结构体， node 是报告节点的信息，而 time 则代表着报告时间。&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;typedef&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;clusterNodeFailReport&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;clusterNode&lt;/span&gt; *&lt;span&gt;node&lt;/span&gt;;&lt;/span&gt;  &lt;span&gt;/* 报告当前节点已经下线的节点 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;mstime_t&lt;/span&gt; time;             &lt;span&gt;/* 报告时间 */&lt;/span&gt;&lt;br/&gt;} clusterNodeFailReport;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;消息结构体&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;了解了 Reids 节点维护的数据结构体后，我们再来看节点进行通信的消息结构体。通信消息最外侧的结构体为 clusterMsg，它包括了很多消息记录信息，包括 RCmb 标志位，消息总长度，消息协议版本，消息类型；它还包括了发送该消息节点的记录信息，比如节点名称，节点负责的slot信息，节点ip和端口等；最后它包含了一个 clusterMsgData 来携带具体类型的消息。&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;typedef&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; sig[&lt;span&gt;4&lt;/span&gt;];        &lt;span&gt;/* 标志位，&quot;RCmb&quot; (Redis Cluster message bus). */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;uint32_t&lt;/span&gt; totlen;    &lt;span&gt;/* 消息总长度 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;uint16_t&lt;/span&gt; ver;       &lt;span&gt;/* 消息协议版本 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;uint16_t&lt;/span&gt; port;      &lt;span&gt;/* 端口 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;uint16_t&lt;/span&gt; type;      &lt;span&gt;/* 消息类型 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;uint16_t&lt;/span&gt; count;     &lt;span&gt;/*  */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;uint64_t&lt;/span&gt; currentEpoch;  &lt;span&gt;/* 表示本节点当前记录的整个集群的统一的epoch，用来决策选举投票等，与configEpoch不同的是：configEpoch表示的是master节点的唯一标志，currentEpoch是集群的唯一标志。 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;uint64_t&lt;/span&gt; configEpoch;   &lt;span&gt;/* 每个master节点都有一个唯一的configEpoch做标志，如果和其他master节点冲突，会强制自增使本节点在集群中唯一 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;uint64_t&lt;/span&gt; offset;    &lt;span&gt;/* 主从复制偏移相关信息，主节点和从节点含义不同 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; sender[CLUSTER_NAMELEN]; &lt;span&gt;/* 发送节点的名称 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; myslots[CLUSTER_SLOTS/&lt;span&gt;8&lt;/span&gt;]; &lt;span&gt;/* 本节点负责的slots信息,16384/8个char数组，一共为16384bit */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; slaveof[CLUSTER_NAMELEN]; &lt;span&gt;/* master信息，假如本节点是slave节点的话，协议带有master信息 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; myip[NET_IP_STR_LEN];    &lt;span&gt;/* IP */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; notused1[&lt;span&gt;34&lt;/span&gt;];  &lt;span&gt;/* 保留字段 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;uint16_t&lt;/span&gt; cport;      &lt;span&gt;/* 集群的通信端口 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;uint16_t&lt;/span&gt; flags;      &lt;span&gt;/* 本节点当前的状态，比如 CLUSTER_NODE_HANDSHAKE、CLUSTER_NODE_MEET */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; state; &lt;span&gt;/* Cluster state from the POV of the sender */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; mflags[&lt;span&gt;3&lt;/span&gt;]; &lt;span&gt;/* 本条消息的类型，目前只有两类：CLUSTERMSG_FLAG0_PAUSED、CLUSTERMSG_FLAG0_FORCEACK */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;union&lt;/span&gt; clusterMsgData data;&lt;br/&gt;} clusterMsg;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;clusterMsgData 是一个 union 结构体，它可以为 PING，MEET，PONG 或者 FAIL 等消息体。其中当消息为 PING、MEET 和 PONG 类型时，ping 字段是被赋值的，而是 FAIL 类型时，fail 字段是被赋值的。&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 注意这是 union 关键字&lt;/span&gt;&lt;br/&gt;&lt;span&gt;union&lt;/span&gt; clusterMsgData {&lt;br/&gt;    &lt;span&gt;/* PING, MEET 或者 PONG 消息时，ping 字段被赋值 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;/* Array of N clusterMsgDataGossip structures */&lt;/span&gt;&lt;br/&gt;        clusterMsgDataGossip gossip[&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;    } ping;&lt;br/&gt;    &lt;span&gt;/*  FAIL 消息时，fail 被赋值 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;        clusterMsgDataFail about;&lt;br/&gt;    } fail;&lt;br/&gt;    &lt;span&gt;// .... 省略 publish 和 update 消息的字段&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;clusterMsgDataGossip 是 PING、PONG 和 MEET 消息的结构体，它会包括发送消息节点维护的其他节点信息，也就是上文中 clusterState 中 nodes 字段包含的信息，具体代码如下所示，你也会发现二者的字段是类似的。&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;typedef&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;/* 节点的名字，默认是随机的，MEET消息发送并得到回复后，集群会为该节点设置正式的名称*/&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; nodename[CLUSTER_NAMELEN]; &lt;br/&gt;    &lt;span&gt;uint32_t&lt;/span&gt; ping_sent; &lt;span&gt;/* 发送节点最后一次给接收节点发送 PING 消息的时间戳，收到对应 PONG 回复后会被赋值为0 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;uint32_t&lt;/span&gt; pong_received; &lt;span&gt;/* 发送节点最后一次收到接收节点发送 PONG 消息的时间戳 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; ip[NET_IP_STR_LEN];  &lt;span&gt;/* IP address last time it was seen */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;uint16_t&lt;/span&gt; port;       &lt;span&gt;/* IP*/&lt;/span&gt;       &lt;br/&gt;    &lt;span&gt;uint16_t&lt;/span&gt; cport;      &lt;span&gt;/* 端口*/&lt;/span&gt;  &lt;br/&gt;    &lt;span&gt;uint16_t&lt;/span&gt; flags;      &lt;span&gt;/* 标识*/&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;uint32_t&lt;/span&gt; notused1;   &lt;span&gt;/* 对齐字符*/&lt;/span&gt;&lt;br/&gt;} clusterMsgDataGossip;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;typedef&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; nodename[CLUSTER_NAMELEN]; &lt;span&gt;/* 下线节点的名字 */&lt;/span&gt;&lt;br/&gt;} clusterMsgDataFail;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;看完了节点维护的数据结构体和发送的消息结构体后，我们就来看看 Redis 的具体行为源码了。&lt;/p&gt;&lt;h4 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;随机周期性发送PING消息&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;Redis 的 clusterCron 函数会被定时调用，每被执行10次，就会准备向随机的一个节点发送 PING 消息。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;它会先随机的选出 5 个节点，然后从中选择最久没有与之通信的节点，调用 clusterSendPing 函数发送类型为 CLUSTERMSG_TYPE_PING 的消息&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// cluster.c 文件 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;// clusterCron() 每执行 10 次（至少间隔一秒钟），就向一个随机节点发送 gossip 信息&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (!(iteration % &lt;span&gt;10&lt;/span&gt;)) {&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; j;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* 随机 5 个节点，选出其中一个 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;5&lt;/span&gt;; j++) {&lt;br/&gt;        de = dictGetRandomKey(server.cluster-&amp;gt;nodes);&lt;br/&gt;        clusterNode *&lt;span&gt;this&lt;/span&gt; = dictGetVal(de);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;/* 不要 PING 连接断开的节点，也不要 PING 最近已经 PING 过的节点 */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;-&amp;gt;link == &lt;span&gt;NULL&lt;/span&gt; || &lt;span&gt;this&lt;/span&gt;-&amp;gt;ping_sent != &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;-&amp;gt;flags &amp;amp; (CLUSTER_NODE_MYSELF|CLUSTER_NODE_HANDSHAKE))&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;/* 对比 pong_received 字段，选出更长时间未收到其 PONG 消息的节点(表示好久没有接受到该节点的PONG消息了) */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (min_pong_node == &lt;span&gt;NULL&lt;/span&gt; || min_pong &amp;gt; &lt;span&gt;this&lt;/span&gt;-&amp;gt;pong_received) {&lt;br/&gt;            min_pong_node = &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;            min_pong = &lt;span&gt;this&lt;/span&gt;-&amp;gt;pong_received;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;/* 向最久没有收到 PONG 回复的节点发送 PING 命令 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (min_pong_node) {&lt;br/&gt;        serverLog(LL_DEBUG,&lt;span&gt;&quot;Pinging node %.40s&quot;&lt;/span&gt;, min_pong_node-&amp;gt;name);&lt;br/&gt;        clusterSendPing(min_pong_node-&amp;gt;link, CLUSTERMSG_TYPE_PING);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;clusterSendPing 函数的具体行为我们后续再了解，因为该函数在其他环节也会经常用到&lt;/p&gt;&lt;h4 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;节点加入集群&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;当节点执行 CLUSTER MEET 命令后，会在自身给新节点维护一个 clusterNode 结构体，该结构体的 link 也就是TCP连接字段是 null，表示是新节点尚未建立连接。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;clusterCron 函数中也会处理这些未建立连接的新节点，调用 createClusterLink 创立连接，然后调用 clusterSendPing 函数来发送 MEET 消息&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/* cluster.c clusterCron 函数部分,为未创建连接的节点创建连接 */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (node-&amp;gt;link == &lt;span&gt;NULL&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; fd;&lt;br/&gt;    &lt;span&gt;mstime_t&lt;/span&gt; old_ping_sent;&lt;br/&gt;    clusterLink *link;&lt;br/&gt;    &lt;span&gt;/* 和该节点建立连接 */&lt;/span&gt;&lt;br/&gt;    fd = anetTcpNonBlockBindConnect(server.neterr, node-&amp;gt;ip,&lt;br/&gt;        node-&amp;gt;cport, NET_FIRST_BIND_ADDR);&lt;br/&gt;    &lt;span&gt;/* .... fd 为-1时的异常处理 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;/* 建立 link */&lt;/span&gt;&lt;br/&gt;    link = createClusterLink(node);&lt;br/&gt;    link-&amp;gt;fd = fd;&lt;br/&gt;    node-&amp;gt;link = link;&lt;br/&gt;    aeCreateFileEvent(server.el,link-&amp;gt;fd,AE_READABLE,&lt;br/&gt;            clusterReadHandler,link);&lt;br/&gt;    &lt;span&gt;/* 向新连接的节点发送 PING 命令，防止节点被识进入下线 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;/* 如果节点被标记为 MEET ，那么发送 MEET 命令，否则发送 PING 命令 */&lt;/span&gt;&lt;br/&gt;    old_ping_sent = node-&amp;gt;ping_sent;&lt;br/&gt;    clusterSendPing(link, node-&amp;gt;flags &amp;amp; CLUSTER_NODE_MEET ?&lt;br/&gt;            CLUSTERMSG_TYPE_MEET : CLUSTERMSG_TYPE_PING);&lt;br/&gt;    &lt;span&gt;/* .... */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;/* 如果当前节点（发送者）没能收到 MEET 信息的回复，那么它将不再向目标节点发送命令。*/&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;/* 如果接收到回复的话，那么节点将不再处于 HANDSHAKE 状态，并继续向目标节点发送普通 PING 命令*/&lt;/span&gt;&lt;br/&gt;    node-&amp;gt;flags &amp;amp;= ~CLUSTER_NODE_MEET;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;防止节点假超时及状态过期&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;防止节点假超时和标记疑似下线标记也是在 clusterCron 函数中，具体如下所示。它会检查当前所有的 nodes 节点列表，如果发现某个节点与自己的最后一个 PONG 通信时间超过了预定的阈值的一半时，为了防止节点是假超时，会主动释放掉与之的 link 连接，然后会主动向它发送一个 PING 消息。&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/* cluster.c clusterCron 函数部分，遍历节点来检查 fail 的节点*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;while&lt;/span&gt;((de = dictNext(di)) != &lt;span&gt;NULL&lt;/span&gt;) {&lt;br/&gt;    clusterNode *node = dictGetVal(de);&lt;br/&gt;    now = mstime(); &lt;span&gt;/* Use an updated time at every iteration. */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;mstime_t&lt;/span&gt; delay;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* 如果等到 PONG 到达的时间超过了 node timeout 一半的连接 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;/* 因为尽管节点依然正常，但连接可能已经出问题了 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (node-&amp;gt;link &amp;amp;&amp;amp; &lt;span&gt;/* is connected */&lt;/span&gt;&lt;br/&gt;        now - node-&amp;gt;link-&amp;gt;ctime &amp;gt;&lt;br/&gt;        server.cluster_node_timeout &amp;amp;&amp;amp; &lt;span&gt;/* 还未重连 */&lt;/span&gt;&lt;br/&gt;        node-&amp;gt;ping_sent &amp;amp;&amp;amp; &lt;span&gt;/* 已经发过ping消息 */&lt;/span&gt;&lt;br/&gt;        node-&amp;gt;pong_received &amp;lt; node-&amp;gt;ping_sent &amp;amp;&amp;amp; &lt;span&gt;/* 还在等待pong消息 */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;/* 等待pong消息超过了 timeout/2 */&lt;/span&gt;&lt;br/&gt;        now - node-&amp;gt;ping_sent &amp;gt; server.cluster_node_timeout/&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;/* 释放连接，下次 clusterCron() 会自动重连 */&lt;/span&gt;&lt;br/&gt;        freeClusterLink(node-&amp;gt;link);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* 如果目前没有在 PING 节点*/&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;/* 并且已经有 node timeout 一半的时间没有从节点那里收到 PONG 回复 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;/* 那么向节点发送一个 PING ，确保节点的信息不会太旧，有可能一直没有随机中 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (node-&amp;gt;link &amp;amp;&amp;amp;&lt;br/&gt;        node-&amp;gt;ping_sent == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp;&lt;br/&gt;        (now - node-&amp;gt;pong_received) &amp;gt; server.cluster_node_timeout/&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;    {&lt;br/&gt;        clusterSendPing(node-&amp;gt;link, CLUSTERMSG_TYPE_PING);&lt;br/&gt;        &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;/* .... 处理failover和标记遗失下线 */&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;处理failover和标记疑似下线&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;如果防止节点假超时处理后，节点依旧未收到目标节点的 PONG 消息，并且时间已经超过了 cluster_node_timeout，那么就将该节点标记为疑似下线状态。&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/* 如果这是一个主节点，并且有一个从服务器请求进行手动故障转移,那么向从服务器发送 PING*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (server.cluster-&amp;gt;mf_end &amp;amp;&amp;amp;&lt;br/&gt;    nodeIsMaster(myself) &amp;amp;&amp;amp;&lt;br/&gt;    server.cluster-&amp;gt;mf_slave == node &amp;amp;&amp;amp;&lt;br/&gt;    node-&amp;gt;link)&lt;br/&gt;{&lt;br/&gt;    clusterSendPing(node-&amp;gt;link, CLUSTERMSG_TYPE_PING);&lt;br/&gt;    &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/* 后续代码只在节点发送了 PING 命令的情况下执行*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (node-&amp;gt;ping_sent == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/* 计算等待 PONG 回复的时长 */&lt;/span&gt; &lt;br/&gt;delay = now - node-&amp;gt;ping_sent;&lt;br/&gt;&lt;span&gt;/* 等待 PONG 回复的时长超过了限制值，将目标节点标记为 PFAIL （疑似下线)*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (delay &amp;gt; server.cluster_node_timeout) {&lt;br/&gt;    &lt;span&gt;/* 超时了，标记为疑似下线 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!(node-&amp;gt;flags &amp;amp; (REDIS_NODE_PFAIL|REDIS_NODE_FAIL))) {&lt;br/&gt;        redisLog(REDIS_DEBUG,&lt;span&gt;&quot;*** NODE %.40s possibly failing&quot;&lt;/span&gt;,&lt;br/&gt;            node-&amp;gt;name);&lt;br/&gt;        &lt;span&gt;// 打开疑似下线标记&lt;/span&gt;&lt;br/&gt;        node-&amp;gt;flags |= REDIS_NODE_PFAIL;&lt;br/&gt;        update_state = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;实际发送Gossip消息&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;以下是前方多次调用过的clusterSendPing()方法的源码，代码中有详细的注释，大家可以自行阅读。主要的操作就是将节点自身维护的 clusterState 转换为对应的消息结构体，。&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/* 向指定节点发送一条 MEET 、 PING 或者 PONG 消息 */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;clusterSendPing&lt;/span&gt;&lt;span&gt;(clusterLink *link, &lt;span&gt;int&lt;/span&gt; type)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *buf;&lt;br/&gt;    clusterMsg *hdr;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; gossipcount = &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;/* Number of gossip sections added so far. */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; wanted; &lt;span&gt;/* Number of gossip sections we want to append if possible. */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; totlen; &lt;span&gt;/* Total packet length. */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// freshnodes 是用于发送 gossip 信息的计数器&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 每次发送一条信息时，程序将 freshnodes 的值减一&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 当 freshnodes 的数值小于等于 0 时，程序停止发送 gossip 信息&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// freshnodes 的数量是节点目前的 nodes 表中的节点数量减去 2 &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 这里的 2 指两个节点，一个是 myself 节点（也即是发送信息的这个节点）&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 另一个是接受 gossip 信息的节点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; freshnodes = dictSize(server.cluster-&amp;gt;nodes)&lt;span&gt;-2&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;/* 计算要携带多少节点的信息，最少3个，最多 1/10 集群总节点数量*/&lt;/span&gt;&lt;br/&gt;    wanted = &lt;span&gt;floor&lt;/span&gt;(dictSize(server.cluster-&amp;gt;nodes)/&lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (wanted &amp;lt; &lt;span&gt;3&lt;/span&gt;) wanted = &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (wanted &amp;gt; freshnodes) wanted = freshnodes;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* .... 省略 totlen 的计算等*/&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* 如果发送的信息是 PING ，那么更新最后一次发送 PING 命令的时间戳 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (link-&amp;gt;node &amp;amp;&amp;amp; type == CLUSTERMSG_TYPE_PING)&lt;br/&gt;        link-&amp;gt;node-&amp;gt;ping_sent = mstime();&lt;br/&gt;    &lt;span&gt;/* 将当前节点的信息（比如名字、地址、端口号、负责处理的槽）记录到消息里面 */&lt;/span&gt;&lt;br/&gt;    clusterBuildMessageHdr(hdr,type);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* Populate the gossip fields */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; maxiterations = wanted*&lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;/* 每个节点有 freshnodes 次发送 gossip 信息的机会&lt;br/&gt;       每次向目标节点发送 2 个被选中节点的 gossip 信息（gossipcount 计数） */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(freshnodes &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; gossipcount &amp;lt; wanted &amp;amp;&amp;amp; maxiterations--) {&lt;br/&gt;        &lt;span&gt;/* 从 nodes 字典中随机选出一个节点（被选中节点） */&lt;/span&gt;&lt;br/&gt;        dictEntry *de = dictGetRandomKey(server.cluster-&amp;gt;nodes);&lt;br/&gt;        clusterNode *&lt;span&gt;this&lt;/span&gt; = dictGetVal(de);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;/* 以下节点不能作为被选中节点：&lt;br/&gt;         * Myself:节点本身。&lt;br/&gt;         * PFAIL状态的节点&lt;br/&gt;         * 处于 HANDSHAKE 状态的节点。&lt;br/&gt;         * 带有 NOADDR 标识的节点&lt;br/&gt;         * 因为不处理任何 Slot 而被断开连接的节点 &lt;br/&gt;         */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt; == myself) &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;-&amp;gt;flags &amp;amp; CLUSTER_NODE_PFAIL) &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;-&amp;gt;flags &amp;amp; (CLUSTER_NODE_HANDSHAKE|CLUSTER_NODE_NOADDR) ||&lt;br/&gt;            (&lt;span&gt;this&lt;/span&gt;-&amp;gt;link == &lt;span&gt;NULL&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;-&amp;gt;numslots == &lt;span&gt;0&lt;/span&gt;))&lt;br/&gt;        {&lt;br/&gt;            freshnodes--; &lt;span&gt;/* Tecnically not correct, but saves CPU. */&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 检查被选中节点是否已经在 hdr-&amp;gt;data.ping.gossip 数组里面&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 如果是的话说明这个节点之前已经被选中了&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 不要再选中它（否则就会出现重复）&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (clusterNodeIsInGossipSection(hdr,gossipcount,&lt;span&gt;this&lt;/span&gt;)) &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;/* 这个被选中节点有效，计数器减一 */&lt;/span&gt;&lt;br/&gt;        clusterSetGossipEntry(hdr,gossipcount,&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;        freshnodes--;&lt;br/&gt;        gossipcount++;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* .... 如果有 PFAIL 节点，最后添加 */&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* 计算信息长度 */&lt;/span&gt;&lt;br/&gt;    totlen = &lt;span&gt;sizeof&lt;/span&gt;(clusterMsg)-&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;union&lt;/span&gt; clusterMsgData);&lt;br/&gt;    totlen += (&lt;span&gt;sizeof&lt;/span&gt;(clusterMsgDataGossip)*gossipcount);&lt;br/&gt;    &lt;span&gt;/* 将被选中节点的数量（gossip 信息中包含了多少个节点的信息）记录在 count 属性里面*/&lt;/span&gt;&lt;br/&gt;    hdr-&amp;gt;count = htons(gossipcount);&lt;br/&gt;    &lt;span&gt;/* 将信息的长度记录到信息里面 */&lt;/span&gt;&lt;br/&gt;    hdr-&amp;gt;totlen = htonl(totlen);&lt;br/&gt;    &lt;span&gt;/* 发送网络请求 */&lt;/span&gt;&lt;br/&gt;    clusterSendMessage(link,buf,totlen);&lt;br/&gt;    zfree(buf);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;clusterSetGossipEntry&lt;/span&gt;&lt;span&gt;(clusterMsg *hdr, &lt;span&gt;int&lt;/span&gt; i, clusterNode *n)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    clusterMsgDataGossip *gossip;&lt;br/&gt;    &lt;span&gt;/* 指向 gossip 信息结构 */&lt;/span&gt;&lt;br/&gt;    gossip = &amp;amp;(hdr-&amp;gt;data.ping.gossip[i]);&lt;br/&gt;    &lt;span&gt;/* 将被选中节点的名字记录到 gossip 信息 */&lt;/span&gt;   &lt;br/&gt;    &lt;span&gt;memcpy&lt;/span&gt;(gossip-&amp;gt;nodename,n-&amp;gt;name,CLUSTER_NAMELEN);&lt;br/&gt;    &lt;span&gt;/* 将被选中节点的 PING 命令发送时间戳记录到 gossip 信息 */&lt;/span&gt;&lt;br/&gt;    gossip-&amp;gt;ping_sent = htonl(n-&amp;gt;ping_sent/&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;/* 将被选中节点的 PONG 命令回复的时间戳记录到 gossip 信息 */&lt;/span&gt;&lt;br/&gt;    gossip-&amp;gt;pong_received = htonl(n-&amp;gt;pong_received/&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;/* 将被选中节点的 IP 记录到 gossip 信息 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;memcpy&lt;/span&gt;(gossip-&amp;gt;ip,n-&amp;gt;ip,&lt;span&gt;sizeof&lt;/span&gt;(n-&amp;gt;ip));&lt;br/&gt;    &lt;span&gt;/* 将被选中节点的端口号记录到 gossip 信息 */&lt;/span&gt;&lt;br/&gt;    gossip-&amp;gt;port = htons(n-&amp;gt;port);&lt;br/&gt;    gossip-&amp;gt;cport = htons(n-&amp;gt;cport);&lt;br/&gt;    &lt;span&gt;/* 将被选中节点的标识值记录到 gossip 信息 */&lt;/span&gt;&lt;br/&gt;    gossip-&amp;gt;flags = htons(n-&amp;gt;flags);&lt;br/&gt;    gossip-&amp;gt;notused1 = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;下面是 clusterBuildMessageHdr 函数，它主要负责填充消息结构体中的基础信息和当前节点的状态信息。&lt;/p&gt;&lt;pre data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/* 构建消息的 header */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;clusterBuildMessageHdr&lt;/span&gt;&lt;span&gt;(clusterMsg *hdr, &lt;span&gt;int&lt;/span&gt; type)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; totlen = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;uint64_t&lt;/span&gt; offset;&lt;br/&gt;    clusterNode *master;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* 如果当前节点是salve，则master为其主节点，如果当前节点是master节点，则master就是当前节点 */&lt;/span&gt;&lt;br/&gt;    master = (nodeIsSlave(myself) &amp;amp;&amp;amp; myself-&amp;gt;slaveof) ?&lt;br/&gt;              myself-&amp;gt;slaveof : myself;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;memset&lt;/span&gt;(hdr,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;(*hdr));&lt;br/&gt;    &lt;span&gt;/* 初始化协议版本、标识、及类型， */&lt;/span&gt;&lt;br/&gt;    hdr-&amp;gt;ver = htons(CLUSTER_PROTO_VER);&lt;br/&gt;    hdr-&amp;gt;sig[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;&#x27;R&#x27;&lt;/span&gt;;&lt;br/&gt;    hdr-&amp;gt;sig[&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;&#x27;C&#x27;&lt;/span&gt;;&lt;br/&gt;    hdr-&amp;gt;sig[&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;&#x27;m&#x27;&lt;/span&gt;;&lt;br/&gt;    hdr-&amp;gt;sig[&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;&#x27;b&#x27;&lt;/span&gt;;&lt;br/&gt;    hdr-&amp;gt;type = htons(type);&lt;br/&gt;    &lt;span&gt;/* 消息头设置当前节点id */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;memcpy&lt;/span&gt;(hdr-&amp;gt;sender,myself-&amp;gt;name,CLUSTER_NAMELEN);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* 消息头设置当前节点ip */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;memset&lt;/span&gt;(hdr-&amp;gt;myip,&lt;span&gt;0&lt;/span&gt;,NET_IP_STR_LEN);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (server.cluster_announce_ip) {&lt;br/&gt;        &lt;span&gt;strncpy&lt;/span&gt;(hdr-&amp;gt;myip,server.cluster_announce_ip,NET_IP_STR_LEN);&lt;br/&gt;        hdr-&amp;gt;myip[NET_IP_STR_LEN&lt;span&gt;-1&lt;/span&gt;] = &lt;span&gt;&#x27;\0&#x27;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* 基础端口及集群内节点通信端口 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; announced_port = server.cluster_announce_port ?&lt;br/&gt;                         server.cluster_announce_port : server.port;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; announced_cport = server.cluster_announce_bus_port ?&lt;br/&gt;                          server.cluster_announce_bus_port :&lt;br/&gt;                          (server.port + CLUSTER_PORT_INCR);&lt;br/&gt;    &lt;span&gt;/* 设置当前节点的槽信息 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;memcpy&lt;/span&gt;(hdr-&amp;gt;myslots,master-&amp;gt;slots,&lt;span&gt;sizeof&lt;/span&gt;(hdr-&amp;gt;myslots));&lt;br/&gt;    &lt;span&gt;memset&lt;/span&gt;(hdr-&amp;gt;slaveof,&lt;span&gt;0&lt;/span&gt;,CLUSTER_NAMELEN);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (myself-&amp;gt;slaveof != &lt;span&gt;NULL&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;memcpy&lt;/span&gt;(hdr-&amp;gt;slaveof,myself-&amp;gt;slaveof-&amp;gt;name, CLUSTER_NAMELEN);&lt;br/&gt;    hdr-&amp;gt;port = htons(announced_port);&lt;br/&gt;    hdr-&amp;gt;cport = htons(announced_cport);&lt;br/&gt;    hdr-&amp;gt;flags = htons(myself-&amp;gt;flags);&lt;br/&gt;    hdr-&amp;gt;state = server.cluster-&amp;gt;state;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* 设置 currentEpoch and configEpochs. */&lt;/span&gt;&lt;br/&gt;    hdr-&amp;gt;currentEpoch = htonu64(server.cluster-&amp;gt;currentEpoch);&lt;br/&gt;    hdr-&amp;gt;configEpoch = htonu64(master-&amp;gt;configEpoch);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* 设置复制偏移量 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (nodeIsSlave(myself))&lt;br/&gt;        offset = replicationGetSlaveOffset();&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        offset = server.master_repl_offset;&lt;br/&gt;    hdr-&amp;gt;offset = htonu64(offset);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* Set the message flags. */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (nodeIsMaster(myself) &amp;amp;&amp;amp; server.cluster-&amp;gt;mf_end)&lt;br/&gt;        hdr-&amp;gt;mflags[&lt;span&gt;0&lt;/span&gt;] |= CLUSTERMSG_FLAG0_PAUSED;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* 计算并设置消息的总长度 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (type == CLUSTERMSG_TYPE_FAIL) {&lt;br/&gt;        totlen = &lt;span&gt;sizeof&lt;/span&gt;(clusterMsg)-&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;union&lt;/span&gt; clusterMsgData);&lt;br/&gt;        totlen += &lt;span&gt;sizeof&lt;/span&gt;(clusterMsgDataFail);&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (type == CLUSTERMSG_TYPE_UPDATE) {&lt;br/&gt;        totlen = &lt;span&gt;sizeof&lt;/span&gt;(clusterMsg)-&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;union&lt;/span&gt; clusterMsgData);&lt;br/&gt;        totlen += &lt;span&gt;sizeof&lt;/span&gt;(clusterMsgDataUpdate);&lt;br/&gt;    }&lt;br/&gt;    hdr-&amp;gt;totlen = htonl(totlen);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;后记&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;本来只想写一下 Redis Cluster 的 Gossip 协议，没想到文章越写，内容越多，最后源码分析也是有点虎头蛇尾，大家就凑合看一下，也希望大家继续关注我后续的问题。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>