<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>2b41b33ad54321ffffc5cd1e2684ca7e</guid>
<title>假期别闲着，快来吧！</title>
<link>https://toutiao.io/k/sat069j</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e6574fdaafecee86cb5374a3bc7abc37</guid>
<title>如何入门技术写作？</title>
<link>https://toutiao.io/k/uunmint</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，技术写作能力是求职升职的加分项。求职时，优秀的技术博客有利于拿到 Offer。工作时，编写可读性好的技术文档，同事会感谢你。晋级时，条理清晰，有说服力的PPT，有利于晋级成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，很多程序员擅长写代码，但不擅长写技术文章。我写技术文章有 8 年了，总共写了 300 多篇文章。“倚老卖老”，我来分享一些技术写作技巧吧~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;技术写作路上的拦路虎&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;技术写作一般会遇到 5 个问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不敢写。担心写的不好，被人笑话。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;素材从哪来？想写，但不知道写些什么。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内容如何组织？主题想好了，内容有很多，哪些该写，哪些不改写。内容之间的关系是怎样的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何把内容表达清楚？如何让内容有说服力？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何坚持写作？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于问题1，没人天生都能写出好文章，都需要一个成长的过程。不要太在意别人的看法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于问题2，3，4，对应的是写作过程中的问题。写作的过程可以分为 3 个步骤：选主题，列大纲，写内容。本文在后面会着重聊这块。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于问题5，把写作培养成习惯后，坚持就容易了。按 &lt;span&gt;SMART 原则&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;，来给自己的写作定计划。每次达成目标，给自己奖励。把写作计划告诉什么的好友，也利于目标的达成(我们都是爱面子的人-_-)。给自己一些成功暗示，如果能成为了大V后，会。。。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mEakJnD74m8ydhazWopVdOhR83dhwjJHDGwDdUWlMvsW7lrFAOyN5sz3uqSaUWS2L4C4M6CpIlHZITLhXhekYg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;270&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;选主题&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选主题包含 3 块内容：找素材，定主题，起标题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;找素材&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;素材从哪来？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;素材从日常中来。按来源可以分为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;经验分享。如：工作中遇到的技术问题，把解决的过程记录下来。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;学习笔记。如：框架，第三方库，工具的学习笔记。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;复盘反思。如：做完项目的复盘，月度，年度复盘。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主动找。如: 从当前技术趋势的中找: 指数(&lt;span&gt;GitHub 趋势&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;，&lt;span&gt;百度指数&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;，Google 指数等)，行业会议，技术文章，热门问答等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按主题类型可以分为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;技术类。包括：代码质量，开发效率，性能优化，安全，用户体验等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;管理类。包括：团队文化建设，制度的设计，团队目标的沟通，人员的育，选，留等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;软技能。包括：协作能力，解决问题的能力，学习能力等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;定主题&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了素材后，要把素材做一定的抽象，提炼成一个主题。比如：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNzIyMTYzNA==&amp;amp;mid=2247484014&amp;amp;idx=1&amp;amp;sn=f9b54707fbbc3f375148f57380f3db89&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;前端异常的处理方法汇总&lt;/a&gt;，&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNzIyMTYzNA==&amp;amp;mid=2247483819&amp;amp;idx=1&amp;amp;sn=2bec1443e321a8b7a4f6b24a9ab2929e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;省空间的包管理神器 - pnpm&lt;/a&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;太大的主题，不适合阅读。对于大主题，可以将其拆分成多个小主题，或者缩小主题的范围。比如：主题是 《前端性能优化》。可以拆分成至少 5 个主题：《前端加载性能优化》，《CSS 性能优化》，《JavaScript 性能优化》，《Vue 性能优化》，《React 性能优化》。缩小主题的范围：《前端性能优化最重要的 3 个技巧》。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;起标题&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标题是主题的直观体现。标题明了直观就好。如：《JavaScript 简明教程》，《导致内存泄漏的原因分析》。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要起个吸睛的标题，有一些套路。具体自行百度，我这里就不展开了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;列大纲&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大纲是文章的结构。技术文章，一般包含这些要素：背景/提出问题，是什么，为什么，怎么做，结果是怎样，总结。大纲就是列出这些要素，控制这些要素的先后顺序。我们来看 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNzIyMTYzNA==&amp;amp;mid=2247483819&amp;amp;idx=1&amp;amp;sn=2bec1443e321a8b7a4f6b24a9ab2929e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《省空间的包管理神器 - pnpm》&lt;/a&gt; 的大纲：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;pnpm 出现的背景介绍。=&amp;gt; 背景。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;pnpm 介绍。=&amp;gt; pnpm 是什么。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;pnpm 的优势。=&amp;gt; 为什么用 pnpm。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;pnpm 的使用方法。=&amp;gt; 怎么用 pnpm。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;pnpm 实际使用的体验。=&amp;gt; 结果怎么样。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;组织内容的常见结构&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结构是内容之间的关系。不同的内容，适合用不同的结构。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;时序结构&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;时序结构就是按照时间顺序来描述。当介绍的内容和时间有关系时，考虑用时序结构。如：介绍技术的演进过程。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总分总结构&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总分总结构就是先介绍整体(总论点)，再介绍局部(分论点)，最后再做个总结。介绍局部时，可以采用 MECE 法则：相互独立，完全穷尽(Mutually Exclusive Collectively Exhaustive)。用总分总结构让内容显得清晰，有条理。因此，总分总结构是在文章中最常见的结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐阅读：&lt;span&gt;《金字塔原理》&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;分论点的结构&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分论点的结构，有并列结构，对比结构和递进结构。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;写内容&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;列完大纲，就开始写内容了。写内容有如下的技巧。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;结论先行&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结论先行就是先写结论，然后再说理由。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有个同事到你电脑旁边，然后说：“进入A页面，点这个按钮，然后怎么没反应了？”你可能会一脸蒙，这是要干嘛？只是告诉我下，还是我的代码出 bug 了？还是需要我协助？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用结论先行的说法: “我这个有个技术问题搞不定。你有空帮我看下吗？过程是:...， 我期望:...，但实际情况是...&quot;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结论先行，让读者心里有个预设，知道下面会说什么。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;逻辑正确&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;技术文章的逻辑正确性特别重要。常见的有问题的逻辑：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;以偏概全。比如：我身边的程序员都很少加班，因此程序员很少加班。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;偷换概念。比如：钱可以买到爱情，因为约会啊、生孩子啊都要钱。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;必要概念的解释&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些概念，你知道，但别人不一定知道。因此，要对一些概念做解释。如果觉得某概念不是一两句话说的清的，可以做个简要的介绍，并附上详细解释的链接。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;用数据和例子来表明观点&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用数据能提升观点的说服力。用例子能帮助读者理解你的观点。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;合理的使用图片&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些时候，一图胜千言。比如：用流程图来描述算法，用饼图来展示各个成分的占比情况。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9990281827016521&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mEakJnD74m8ydhazWopVdOhR83dhwjJHQicC5ULgfuCPuyNauhGl57cYicnohqXxkhCAerIOmibhiceUERJT8yfuww/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1029&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在文章中穿插些 GIF，可以让内容显得轻松。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/mEakJnD74m8ydhazWopVdOhR83dhwjJHGXW29OPsME8K2Z65GsYyiarD5gsNibkgIUKE4QI1Vbgr5Z26RP6icsexA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;270&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;保证语句通顺&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写完后要多读几遍，保证语句的通顺。顺带把错别字修了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;特别长的句子，不容易理解。可以拆成若干个短句。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;书写规范&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。与大家共勉之。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;书写规范的目的是为了提升内容的可读性。书写规范和代码风格很像。主要包括：空格，标点，大小写，专有词的拼写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐阅读：&lt;span&gt;《中文技术文档的写作规范》&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;最后&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;道理知道的再多，不行动也是白费。所以，赶紧写起来吧~ 我这边准备做个技术写作的微信群，和大伙一起来点亮写作技能。关注本公众号，发消息：“写作”，来加入吧~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;SMART 原则: &lt;em&gt;https://baike.baidu.com/item/SMART%E5%8E%9F%E5%88%99/8575850&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;GitHub 趋势: &lt;em&gt;https://github.com/trending&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;百度指数: &lt;em&gt;https://index.baidu.com/v2/main/index.html#/demand/%E5%89%8D%E7%AB%AF?words=%E5%89%8D%E7%AB%AF&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;《金字塔原理》: &lt;em&gt;https://book.douban.com/subject/1020644/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;《中文技术文档的写作规范》: &lt;em&gt;https://www.ruanyifeng.com/blog/2016/10/document_style_guide.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8566a8fc21ff96055394150425955a68</guid>
<title>如何优雅地记录操作日志？</title>
<link>https://toutiao.io/k/l5h2n30</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;48&quot; data-ratio=&quot;0.10078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUrXicw2VXTQTVVN5yxXWEacdY1ZdxTH195Pgibtib8EENJRMia3tzEnyVfgyfAgRibMssKqwlE186TLSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总第471&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2021年 第041篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;img border=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;93&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;93&quot; data-ratio=&quot;0.9966329966329966&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVLR21NicmyQxcmiaqQ2KOJJj2JLwgJL4KSbo7CcuMF1hLf4xFjGQiaDRhSPyERxWGChWYP47Oc4sKGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;594&quot; data-width=&quot;100%&quot; opacity=&quot;&quot; title=&quot;undefined&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; data-style=&quot;text-align: left; font-size: 14px; color: inherit;&quot;&gt;&lt;section&gt;&lt;span&gt;操作日志几乎存在于每个系统中，而这些系统都有记录操作日志的一套 API。操作日志和系统日志不一样，操作日志必须要做到简单易懂。所以如何让操作日志不跟业务逻辑耦合，如何让操作日志的内容易于理解，如何让操作日志的接入更加简单？上面这些都是本文要回答的问题。我们主要围绕着如何“优雅”地记录操作日志展开描述，希望对从事相关工作的同学能够有所帮助或者启发。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1. 操作日志的使用场景&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2. 实现方式&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2.1 使用 Canal 监听数据库记录操作日志&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2.2 通过日志文件的方式记录&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2.3 通过 LogUtil 的方式记录日志&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2.4 方法注解实现操作日志&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3. 优雅地支持 AOP 生成动态的操作日志&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4. 代码实现解析&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;5. 总结&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 操作日志的使用场景&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;103&quot; data-ratio=&quot;0.18588399720475193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXehNsNY76lXs1L1HwaLESxyp4WDCzpf9V5MbCTCN0czdptehicA5TUy0TCKoQoOfqzHUH7AtcDXdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1431&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;例子&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;系统日志和操作日志的区别&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;系统日志&lt;/strong&gt;：系统日志主要是为开发排查问题提供依据，一般打印在日志文件中；系统日志的可读性要求没那么高，日志中会包含代码的信息，比如在某个类的某一行打印了一个日志。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;操作日志&lt;/strong&gt;：主要是对某个对象进行新增操作或者修改操作后记录下这个新增或者修改，操作日志要求可读性比较强，因为它主要是给用户看的，比如订单的物流信息，用户需要知道在什么时间发生了什么事情。再比如，客服对工单的处理记录信息。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;操作日志的记录格式大概分为下面几种：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;单纯的文字记录，比如：2021-09-16 10:00 订单创建。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;简单的动态的文本记录，比如：2021-09-16 10:00 订单创建，订单号：NO.11089999，其中涉及变量订单号“NO.11089999”。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;修改类型的文本，包含修改前和修改后的值，比如：2021-09-16 10:00 用户小明修改了订单的配送地址：从“金灿灿小区”修改到“银盏盏小区” ，其中涉及变量配送的原地址“金灿灿小区”和新地址“银盏盏小区”。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;修改表单，一次会修改多个字段。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. 实现方式&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1 使用 Canal 监听数据库记录操作日志&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://github.com/alibaba/canal&quot; textvalue=&quot;Canal&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Canal&lt;/span&gt;&lt;/a&gt;&lt;span&gt; 是一款基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费的开源组件，通过采用监听数据库 Binlog 的方式，这样可以从底层知道是哪些数据做了修改，然后根据更改的数据记录操作日志。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这种方式的优点是和业务逻辑完全分离。缺点也很明显，局限性太高，只能针对数据库的更改做操作日志记录，如果修改涉及到其他团队的 RPC 的调用，就没办法监听数据库了。举个例子：给用户发送通知，通知服务一般都是公司内部的公共组件，这时候只能在调用 RPC 的时候手工记录发送通知的操作日志了。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2 通过日志文件的方式记录&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;log.info(&lt;span&gt;&quot;订单创建&quot;&lt;/span&gt;)&lt;br/&gt;log.info(&lt;span&gt;&quot;订单已经创建，订单编号:{}&quot;&lt;/span&gt;, orderNo)&lt;br/&gt;log.info(&lt;span&gt;&quot;修改了订单的配送地址：从“{}”修改到“{}”， &quot;&lt;/span&gt;金灿灿小区&lt;span&gt;&quot;, &quot;&lt;/span&gt;银盏盏小区&lt;span&gt;&quot;)&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这种方式的操作记录需要解决三个问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;问题一：操作人如何记录&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;借助 SLF4J 中的 MDC 工具类，把操作人放在日志中，然后在日志中统一打印出来。首先在用户的拦截器中把用户的标识 Put 到 MDC 中。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserInterceptor&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;HandlerInterceptorAdapter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;preHandle&lt;/span&gt;&lt;span&gt;(HttpServletRequest request, HttpServletResponse response, Object handler)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//获取到用户标识&lt;/span&gt;&lt;br/&gt;    String userNo = getUserNo(request);&lt;br/&gt;    &lt;span&gt;//把用户 ID 放到 MDC 上下文中&lt;/span&gt;&lt;br/&gt;    MDC.put(&lt;span&gt;&quot;userId&quot;&lt;/span&gt;, userNo);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;.preHandle(request, response, handler);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;private&lt;/span&gt; String &lt;span&gt;getUserNo&lt;/span&gt;&lt;span&gt;(HttpServletRequest request)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 通过 SSO 或者Cookie 或者 Auth信息获取到 当前登陆的用户信息&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;其次，把 userId 格式化到日志中，使用 %X{userId} 可以取到 MDC 中用户标识。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&amp;lt;pattern&amp;gt;&lt;span&gt;&quot;%d{yyyy-MM-dd HH:mm:ss.SSS} %t %-5level %X{userId} %logger{30}.%method:%L - %msg%n&quot;&lt;/span&gt;&amp;lt;/pattern&amp;gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;问题二：操作日志如何和系统日志区分开&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过配置 Log 的配置文件，把有关操作日志的 Log 单独放到一日志文件中。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;//不同业务日志记录到不同的文件&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;appender&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;businessLogAppender&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;File&lt;/span&gt;&amp;gt;&lt;/span&gt;logs/business.log&lt;span&gt;&amp;lt;/&lt;span&gt;File&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;append&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;span&gt;append&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;filter&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;level&lt;/span&gt;&amp;gt;&lt;/span&gt;INFO&lt;span&gt;&amp;lt;/&lt;span&gt;level&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;onMatch&lt;/span&gt;&amp;gt;&lt;/span&gt;ACCEPT&lt;span&gt;&amp;lt;/&lt;span&gt;onMatch&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;onMismatch&lt;/span&gt;&amp;gt;&lt;/span&gt;DENY&lt;span&gt;&amp;lt;/&lt;span&gt;onMismatch&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;filter&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;rollingPolicy&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;fileNamePattern&lt;/span&gt;&amp;gt;&lt;/span&gt;logs/业务A.%d.%i.log&lt;span&gt;&amp;lt;/&lt;span&gt;fileNamePattern&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;maxHistory&lt;/span&gt;&amp;gt;&lt;/span&gt;90&lt;span&gt;&amp;lt;/&lt;span&gt;maxHistory&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;timeBasedFileNamingAndTriggeringPolicy&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;maxFileSize&lt;/span&gt;&amp;gt;&lt;/span&gt;10MB&lt;span&gt;&amp;lt;/&lt;span&gt;maxFileSize&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;timeBasedFileNamingAndTriggeringPolicy&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;rollingPolicy&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;encoder&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;&quot;%d{yyyy-MM-dd HH:mm:ss.SSS} %t %-5level %X{userId} %logger{30}.%method:%L - %msg%n&quot;&lt;span&gt;&amp;lt;/&lt;span&gt;pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;charset&lt;/span&gt;&amp;gt;&lt;/span&gt;UTF-8&lt;span&gt;&amp;lt;/&lt;span&gt;charset&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;encoder&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;appender&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;logger&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;businessLog&quot;&lt;/span&gt; &lt;span&gt;additivity&lt;/span&gt;=&lt;span&gt;&quot;false&quot;&lt;/span&gt; &lt;span&gt;level&lt;/span&gt;=&lt;span&gt;&quot;INFO&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;appender-ref&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;businessLogAppender&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;logger&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;然后在 Java 代码中单独的记录业务日志。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;//记录特定日志的声明&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger businessLog = LoggerFactory.getLogger(&lt;span&gt;&quot;businessLog&quot;&lt;/span&gt;);&lt;br/&gt; &lt;br/&gt;&lt;span&gt;//日志存储&lt;/span&gt;&lt;br/&gt;businessLog.info(&lt;span&gt;&quot;修改了配送地址&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;问题三：如何生成可读懂的日志文案&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以采用 LogUtil 的方式，也可以采用切面的方式生成日志模板，后续内容将会进行介绍。这样就可以把日志单独保存在一个文件中，然后通过日志收集可以把日志保存在 Elasticsearch 或者数据库中，接下来我们看下如何生成可读的操作日志。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.3 通过 LogUtil 的方式记录日志&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;  LogUtil.log(orderNo, &lt;span&gt;&quot;订单创建&quot;&lt;/span&gt;, &lt;span&gt;&quot;小明&quot;&lt;/span&gt;)&lt;br/&gt;  LogUtil.log(orderNo, &lt;span&gt;&quot;订单创建，订单号&quot;&lt;/span&gt;+&lt;span&gt;&quot;NO.11089999&quot;&lt;/span&gt;,  &lt;span&gt;&quot;小明&quot;&lt;/span&gt;)&lt;br/&gt;  String template = &lt;span&gt;&quot;用户%s修改了订单的配送地址：从“%s”修改到“%s”&quot;&lt;/span&gt;&lt;br/&gt;  LogUtil.log(orderNo, String.format(tempalte, &lt;span&gt;&quot;小明&quot;&lt;/span&gt;, &lt;span&gt;&quot;金灿灿小区&quot;&lt;/span&gt;, &lt;span&gt;&quot;银盏盏小区&quot;&lt;/span&gt;),  &lt;span&gt;&quot;小明&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;这里解释下为什么记录操作日志的时候都绑定了一个 OrderNo，因为操作日志记录的是：某一个“时间”“谁”对“什么”做了什么“事情”。当查询业务的操作日志的时候，会查询针对这个订单的的所有操作，所以代码中加上了 OrderNo，记录操作日志的时候需要记录下操作人，所以传了操作人“小明”进来。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;上面看起来问题并不大，在修改地址的业务逻辑方法中使用一行代码记录了操作日志，接下来再看一个更复杂的例子：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; OnesIssueDO &lt;span&gt;updateAddress&lt;/span&gt;&lt;span&gt;(updateDeliveryRequest request)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    DeliveryOrder deliveryOrder = deliveryQueryService.queryOldAddress(request.getDeliveryOrderNo());&lt;br/&gt;    &lt;span&gt;// 更新派送信息，电话，收件人，地址&lt;/span&gt;&lt;br/&gt;    doUpdate(request);&lt;br/&gt;    String logContent = getLogContent(request, deliveryOrder);&lt;br/&gt;    LogUtils.logRecord(request.getOrderNo(), logContent, request.getOperator);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; onesIssueDO;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; String &lt;span&gt;getLogContent&lt;/span&gt;&lt;span&gt;(updateDeliveryRequest request, DeliveryOrder deliveryOrder)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    String template = &lt;span&gt;&quot;用户%s修改了订单的配送地址：从“%s”修改到“%s”&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; String.format(tempalte, request.getUserName(), deliveryOrder.getAddress(), request.getAddress);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;可以看到上面的例子使用了两个方法代码，外加一个 getLogContent 的函数实现了操作日志的记录。当业务变得复杂后，记录操作日志放在业务代码中会导致业务的逻辑比较繁杂，最后导致 LogUtils.logRecord() 方法的调用存在于很多业务的代码中，而且类似 getLogContent() 这样的方法也散落在各个业务类中，对于代码的可读性和可维护性来说是一个灾难。下面介绍下如何避免这个灾难。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.4 方法注解实现操作日志&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;为了解决上面问题，一般采用 AOP 的方式记录日志，让操作日志和业务逻辑解耦，接下来看一个简单的 AOP 日志的例子。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@LogRecord&lt;/span&gt;(content=&lt;span&gt;&quot;修改了配送地址&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;modifyAddress&lt;/span&gt;&lt;span&gt;(updateDeliveryRequest request)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 更新派送信息 电话，收件人、地址&lt;/span&gt;&lt;br/&gt;    doUpdate(request);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;我们可以在注解的操作日志上记录固定文案，这样业务逻辑和业务代码可以做到解耦，让我们的业务代码变得纯净起来。可能有同学注意到，上面的方式虽然解耦了操作日志的代码，但是记录的文案并不符合我们的预期，文案是静态的，没有包含动态的文案，因为我们需要记录的操作日志是：用户%s修改了订单的配送地址，从“%s”修改到“%s”。接下来，我们介绍一下如何优雅地使用 AOP 生成动态的操作日志。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 优雅地支持 AOP 生成动态的操作日志&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1 动态模板&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;一提到动态模板，就会涉及到让变量通过占位符的方式解析模板，从而达到通过注解记录操作日志的目的。模板解析的方式有很多种，这里使用了 SpEL（&lt;/span&gt;&lt;span&gt;Spring Expression Language，Spring表达式语言&lt;/span&gt;&lt;span&gt;）来实现。我们可以先写下期望的记录日志的方式，然后再看看能否实现这样的功能。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@LogRecord&lt;/span&gt;(content = &lt;span&gt;&quot;修改了订单的配送地址：从“#oldAddress”, 修改到“#request.address”&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;modifyAddress&lt;/span&gt;&lt;span&gt;(updateDeliveryRequest request, String oldAddress)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 更新派送信息 电话，收件人、地址&lt;/span&gt;&lt;br/&gt;    doUpdate(request);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;通过 SpEL 表达式引用方法上的参数，可以让变量填充到模板中达到动态的操作日志文本内容。但是现在还有几个问题需要解决：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;操作日志需要知道是哪个操作人修改的订单配送地址。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;修改订单配送地址的操作日志需要绑定在配送的订单上，从而可以根据配送订单号查询出对这个配送订单的所有操作。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;为了在注解上记录之前的配送地址是什么，在方法签名上添加了一个和业务无关的 oldAddress 的变量，这样就不优雅了。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;为了解决前两个问题，我们需要把期望的操作日志使用形式改成下面的方式：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@LogRecord&lt;/span&gt;(&lt;br/&gt;     content = &lt;span&gt;&quot;修改了订单的配送地址：从“#oldAddress”, 修改到“#request.address”&quot;&lt;/span&gt;,&lt;br/&gt;     operator = &lt;span&gt;&quot;#request.userName&quot;&lt;/span&gt;, bizNo=&lt;span&gt;&quot;#request.deliveryOrderNo&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;modifyAddress&lt;/span&gt;&lt;span&gt;(updateDeliveryRequest request, String oldAddress)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 更新派送信息 电话，收件人、地址&lt;/span&gt;&lt;br/&gt;    doUpdate(request);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;修改后的代码在注解上添加两个参数，一个是操作人，一个是操作日志需要绑定的对象。但是，在普通的 Web 应用中用户信息都是保存在一个线程上下文的静态方法中，所以 operator 一般是这样的写法（&lt;/span&gt;&lt;span&gt;假定获取当前登陆用户的方式是 UserContext.getCurrentUser()&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;operator = &lt;span&gt;&quot;#{T(com.meituan.user.UserContext).getCurrentUser()}&quot;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这样的话，每个 @LogRecord 的注解上的操作人都是这么长一串。为了避免过多的重复代码，我们可以把注解上的 operator 参数设置为非必填，这样用户可以填写操作人。但是，如果用户不填写我们就取 UserContext 的 user（&lt;/span&gt;&lt;span&gt;下文会介绍如何取 user&lt;/span&gt;&lt;span&gt;）。最后，最简单的日志变成了下面的形式：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@LogRecord&lt;/span&gt;(content = &lt;span&gt;&quot;修改了订单的配送地址：从“#oldAddress”, 修改到“#request.address”&quot;&lt;/span&gt;, &lt;br/&gt;           bizNo=&lt;span&gt;&quot;#request.deliveryOrderNo&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;modifyAddress&lt;/span&gt;&lt;span&gt;(updateDeliveryRequest request, String oldAddress)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 更新派送信息 电话，收件人、地址&lt;/span&gt;&lt;br/&gt;    doUpdate(request);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;接下来，我们需要解决第三个问题：为了记录业务操作记录添加了一个 oldAddress 变量，不管怎么样这都不是一个好的实现方式，所以接下来，我们需要把 oldAddress 变量从修改地址的方法签名上去掉。但是操作日志确实需要 oldAddress 变量，怎么办呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;要么和产品经理 PK 一下，让产品经理把文案从“修改了订单的配送地址：从 xx 修改到 yy” 改为 “修改了订单的配送地址为：yy”。但是从用户体验上来看，第一种文案更人性化一些，显然我们不会 PK 成功的。那么我们就必须要把这个 oldAddress 查询出来然后供操作日志使用了。还有一种解决办法是：把这个参数放到操作日志的线程上下文中，供注解上的模板使用。我们按照这个思路再改下操作日志的实现代码。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@LogRecord&lt;/span&gt;(content = &lt;span&gt;&quot;修改了订单的配送地址：从“#oldAddress”, 修改到“#request.address”&quot;&lt;/span&gt;,&lt;br/&gt;        bizNo=&lt;span&gt;&quot;#request.deliveryOrderNo&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;modifyAddress&lt;/span&gt;&lt;span&gt;(updateDeliveryRequest request)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 查询出原来的地址是什么&lt;/span&gt;&lt;br/&gt;    LogRecordContext.putVariable(&lt;span&gt;&quot;oldAddress&quot;&lt;/span&gt;, DeliveryService.queryOldAddress(request.getDeliveryOrderNo()));&lt;br/&gt;    &lt;span&gt;// 更新派送信息 电话，收件人、地址&lt;/span&gt;&lt;br/&gt;    doUpdate(request);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这时候可以看到，LogRecordContext 解决了操作日志模板上使用方法参数以外变量的问题，同时避免了为了记录操作日志修改方法签名的设计。虽然已经比之前的代码好了些，但是依然需要在业务代码里面加了一行业务逻辑无关的代码，如果有“强迫症”的同学还可以继续往下看，接下来我们会讲解自定义函数的解决方案。下面再看另一个例子：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@LogRecord&lt;/span&gt;(content = &lt;span&gt;&quot;修改了订单的配送员：从“#oldDeliveryUserId”, 修改到“#request.userId”&quot;&lt;/span&gt;,&lt;br/&gt;        bizNo=&lt;span&gt;&quot;#request.deliveryOrderNo&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;modifyAddress&lt;/span&gt;&lt;span&gt;(updateDeliveryRequest request)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 查询出原来的地址是什么&lt;/span&gt;&lt;br/&gt;    LogRecordContext.putVariable(&lt;span&gt;&quot;oldDeliveryUserId&quot;&lt;/span&gt;, DeliveryService.queryOldDeliveryUserId(request.getDeliveryOrderNo()));&lt;br/&gt;    &lt;span&gt;// 更新派送信息 电话，收件人、地址&lt;/span&gt;&lt;br/&gt;    doUpdate(request);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这个操作日志的模板最后记录的内容是这样的格式：修改了订单的配送员：从 “10090”，修改到 “10099”，显然用户看到这样的操作日志是不明白的。用户对于用户 ID 是 10090 还是 10099 并不了解，用户期望看到的是：修改了订单的配送员：从“张三（&lt;/span&gt;&lt;span&gt;18910008888&lt;/span&gt;&lt;span&gt;）”，修改到“小明（&lt;/span&gt;&lt;span&gt;13910006666&lt;/span&gt;&lt;span&gt;）”。用户关心的是配送员的姓名和电话。但是我们方法中传递的参数只有配送员的 ID，没有配送员的姓名可电话。我们可以通过上面的方法，把用户的姓名和电话查询出来，然后通过 LogRecordContext 实现。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是，“强迫症”是不期望操作日志的代码嵌入在业务逻辑中的。接下来，我们考虑另一种实现方式：自定义函数。如果我们可以通过自定义函数把用户 ID 转换为用户姓名和电话，那么就能解决这一问题，按照这个思路，我们把模板修改为下面的形式：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@LogRecord&lt;/span&gt;(content = &lt;span&gt;&quot;修改了订单的配送员：从“{deliveryUser{#oldDeliveryUserId}}”, 修改到“{deveryUser{#request.userId}}”&quot;&lt;/span&gt;,&lt;br/&gt;        bizNo=&lt;span&gt;&quot;#request.deliveryOrderNo&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;modifyAddress&lt;/span&gt;&lt;span&gt;(updateDeliveryRequest request)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 查询出原来的地址是什么&lt;/span&gt;&lt;br/&gt;    LogRecordContext.putVariable(&lt;span&gt;&quot;oldDeliveryUserId&quot;&lt;/span&gt;, DeliveryService.queryOldDeliveryUserId(request.getDeliveryOrderNo()));&lt;br/&gt;    &lt;span&gt;// 更新派送信息 电话，收件人、地址&lt;/span&gt;&lt;br/&gt;    doUpdate(request);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;其中 deliveryUser 是自定义函数，使用大括号把 Spring 的 SpEL 表达式包裹起来，这样做的好处：一是把 Spring EL 表达式和自定义函数区分开便于解析；二是如果模板中不需要 SpEL 表达式解析可以容易的识别出来，减少 SpEL 的解析提高性能。这时候我们发现上面代码还可以优化成下面的形式：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@LogRecord&lt;/span&gt;(content = &lt;span&gt;&quot;修改了订单的配送员：从“{queryOldUser{#request.deliveryOrderNo()}}”, 修改到“{deveryUser{#request.userId}}”&quot;&lt;/span&gt;,&lt;br/&gt;        bizNo=&lt;span&gt;&quot;#request.deliveryOrderNo&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;modifyAddress&lt;/span&gt;&lt;span&gt;(updateDeliveryRequest request)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 更新派送信息 电话，收件人、地址&lt;/span&gt;&lt;br/&gt;    doUpdate(request);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这样就不需要在 modifyAddress 方法中通过 LogRecordContext.putVariable() 设置老的快递员了，通过直接新加一个自定义函数 queryOldUser() 参数把派送订单传递进去，就能查到之前的配送人了，只需要让方法的解析在 modifyAddress() 方法执行之前运行。这样的话，我们让业务代码又变得纯净了起来，同时也让“强迫症”不再感到难受了。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4. 代码实现解析&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.1 代码结构&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;1&quot; data-cropselx2=&quot;381&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;280&quot; data-ratio=&quot;0.7357142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXehNsNY76lXs1L1HwaLESxxB1clIphWXBh14KpvDXYacpJ8stVhwiaa8gMySwDH6ofDJSBeINeatg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上面的操作日志主要是通过一个 AOP 拦截器实现的，整体主要分为 AOP 模块、日志解析模块、日志保存模块、Starter 模块；组件提供了4个扩展点，分别是：自定义函数、默认处理人、业务保存和查询；业务可以根据自己的业务特性定制符合自己业务的逻辑。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2 模块介绍&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;有了上面的分析，已经得出一种我们期望的操作日志记录的方式，接下来我们看下如何实现上面的逻辑。实现主要分为下面几个步骤：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;AOP 拦截逻辑&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;解析逻辑&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;模板解析&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;LogContext 逻辑&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;默认的 operator 逻辑&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;自定义函数逻辑&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;默认的日志持久化逻辑&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Starter 封装逻辑&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2.1 AOP 拦截逻辑&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;这块逻辑主要是一个拦截器，针对 @LogRecord 注解分析出需要记录的操作日志，然后把操作日志持久化，这里把注解命名为 @LogRecordAnnotation。接下来，我们看下注解的定义：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@Target&lt;/span&gt;({ElementType.METHOD})&lt;br/&gt;&lt;span&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;br/&gt;&lt;span&gt;@Inherited&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Documented&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;@interface&lt;/span&gt; LogRecordAnnotation {&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;success&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;fail&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;operator&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;bizNo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;category&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;detail&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;condition&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;注解中除了上面提到参数外，还增加了 fail、category、detail、condition 等参数，这几个参数是为了满足特定的场景，后面还会给出具体的例子。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6634844868735084&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXehNsNY76lXs1L1HwaLESx9u9lj0hx2aROhb7VqiajrQBqLqVoOUGqYOwRsJF1hCXvauatHM1d1Iw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;838&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;为了保持简单，组件的必填参数就两个。业务中的 AOP 逻辑大部分是使用 @Aspect 注解实现的，但是基于注解的 AOP 在 Spring boot 1.5 中兼容性是有问题的，组件为了兼容 Spring boot1.5 的版本我们手工实现 Spring 的 AOP 逻辑。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;550&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;382&quot; data-ratio=&quot;0.6945454545454546&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXehNsNY76lXs1L1HwaLESxguasPnQdjmQ7GEI5micOBcxrnPXo82a5D3gZMBvxw8UE8nib3TpGwPwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;切面选择 &lt;/span&gt;&lt;code&gt;&lt;span&gt;AbstractBeanFactoryPointcutAdvisor&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 实现，切点是通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;StaticMethodMatcherPointcut&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 匹配包含 &lt;/span&gt;&lt;code&gt;&lt;span&gt;LogRecordAnnotation&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 注解的方法。通过实现 &lt;/span&gt;&lt;code&gt;&lt;span&gt;MethodInterceptor&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 接口实现操作日志的增强逻辑。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下面是拦截器的切点逻辑：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LogRecordPointcut&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;StaticMethodMatcherPointcut&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Serializable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// LogRecord的解析类&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; LogRecordOperationSource logRecordOperationSource;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;matches&lt;/span&gt;&lt;span&gt;(@NonNull Method method, @NonNull Class&amp;lt;?&amp;gt; targetClass)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;          &lt;span&gt;// 解析 这个 method 上有没有 @LogRecordAnnotation 注解，有的话会解析出来注解上的各个参数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; !CollectionUtils.isEmpty(logRecordOperationSource.computeLogRecordOperations(method, targetClass));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;setLogRecordOperationSource&lt;/span&gt;&lt;span&gt;(LogRecordOperationSource logRecordOperationSource)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.logRecordOperationSource = logRecordOperationSource;&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;切面的增强逻辑主要代码如下：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;invoke&lt;/span&gt;&lt;span&gt;(MethodInvocation invocation)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{&lt;br/&gt;    Method method = invocation.getMethod();&lt;br/&gt;    &lt;span&gt;// 记录日志&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; execute(invocation, invocation.getThis(), method, invocation.getArguments());&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; Object &lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(MethodInvocation invoker, Object target, Method method, Object[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{&lt;br/&gt;    Class&amp;lt;?&amp;gt; targetClass = getTargetClass(target);&lt;br/&gt;    Object ret = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    MethodExecuteResult methodExecuteResult = &lt;span&gt;new&lt;/span&gt; MethodExecuteResult(&lt;span&gt;true&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;);&lt;br/&gt;    LogRecordContext.putEmptySpan();&lt;br/&gt;    Collection&amp;lt;LogRecordOps&amp;gt; operations = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    Map&amp;lt;String, String&amp;gt; functionNameAndReturnMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        operations = logRecordOperationSource.computeLogRecordOperations(method, targetClass);&lt;br/&gt;        List&amp;lt;String&amp;gt; spElTemplates = getBeforeExecuteFunctionTemplate(operations);&lt;br/&gt;        &lt;span&gt;//业务逻辑执行前的自定义函数解析&lt;/span&gt;&lt;br/&gt;        functionNameAndReturnMap = processBeforeExecuteFunctionTemplate(spElTemplates, targetClass, method, args);&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        log.error(&lt;span&gt;&quot;log record parse before function exception&quot;&lt;/span&gt;, e);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        ret = invoker.proceed();&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        methodExecuteResult = &lt;span&gt;new&lt;/span&gt; MethodExecuteResult(&lt;span&gt;false&lt;/span&gt;, e, e.getMessage());&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!CollectionUtils.isEmpty(operations)) {&lt;br/&gt;            recordExecute(ret, method, args, operations, targetClass,&lt;br/&gt;                    methodExecuteResult.isSuccess(), methodExecuteResult.getErrorMsg(), functionNameAndReturnMap);&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception t) {&lt;br/&gt;        &lt;span&gt;//记录日志错误不要影响业务&lt;/span&gt;&lt;br/&gt;        log.error(&lt;span&gt;&quot;log record parse exception&quot;&lt;/span&gt;, t);&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        LogRecordContext.clear();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (methodExecuteResult.throwable != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; methodExecuteResult.throwable;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; ret;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;拦截逻辑的流程：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.4030710172744723&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXehNsNY76lXs1L1HwaLESxz4XX5lXISsv5uiag5X5eM9PIMD9ktEv8HgKwV8U5dDibx6IWJE7fzibCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;521&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;可以看到，操作日志的记录持久化是在方法执行完之后执行的，当方法抛出异常之后会先捕获异常，等操作日志持久化完成后再抛出异常。在业务的方法执行之前，会对提前解析的自定义函数求值，解决了前面提到的需要查询修改之前的内容。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2.2 解析逻辑&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;模板解析&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Spring 3 中提供了一个非常强大的功能：SpEL，SpEL 在 Spring 产品中是作为表达式求值的核心基础模块，它本身是可以脱离 Spring 独立使用的。举个例子：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        SpelExpressionParser parser = &lt;span&gt;new&lt;/span&gt; SpelExpressionParser();&lt;br/&gt;        Expression expression = parser.parseExpression(&lt;span&gt;&quot;#root.purchaseName&quot;&lt;/span&gt;);&lt;br/&gt;        Order order = &lt;span&gt;new&lt;/span&gt; Order();&lt;br/&gt;        order.setPurchaseName(&lt;span&gt;&quot;张三&quot;&lt;/span&gt;);&lt;br/&gt;        System.out.println(expression.getValue(order));&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这个方法将打印 “张三”。LogRecord 解析的类图如下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6542893725992317&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXehNsNY76lXs1L1HwaLESxGO8zJZoibAzrYg9Amez2aJ9vChyiaMG3txfbSicg8qboxfzdw0PQBRPpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;781&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;解析核心类&lt;/strong&gt;：&lt;/span&gt;&lt;code&gt;&lt;span&gt;LogRecordValueParser&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 里面封装了自定义函数和 SpEL 解析类 &lt;/span&gt;&lt;code&gt;&lt;span&gt;LogRecordExpressionEvaluator&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LogRecordExpressionEvaluator&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;CachedExpressionEvaluator&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;ExpressionKey, Expression&amp;gt; expressionCache = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;(&lt;span&gt;64&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;AnnotatedElementKey, Method&amp;gt; targetMethodCache = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;(&lt;span&gt;64&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;parseExpression&lt;/span&gt;&lt;span&gt;(String conditionExpression, AnnotatedElementKey methodKey, EvaluationContext evalContext)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; getExpression(&lt;span&gt;this&lt;/span&gt;.expressionCache, methodKey, conditionExpression).getValue(evalContext, String&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;LogRecordExpressionEvaluator&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 继承自 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CachedExpressionEvaluator&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 类，这个类里面有两个 Map，一个是 expressionCache 一个是 targetMethodCache。在上面的例子中可以看到，SpEL 会解析成一个 Expression 表达式，然后根据传入的 Object 获取到对应的值，所以 expressionCache 是为了缓存方法、表达式和 SpEL 的 Expression 的对应关系，让方法注解上添加的 SpEL 表达式只解析一次。下面的 targetMethodCache 是为了缓存传入到 Expression 表达式的 Object。核心的解析逻辑是上面最后一行代码。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;getExpression(&lt;span&gt;this&lt;/span&gt;.expressionCache, methodKey, conditionExpression).getValue(evalContext, String&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;getExpression&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法会从 expressionCache 中获取到 @LogRecordAnnotation 注解上的表达式的解析 Expression 的实例，然后调用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;getValue&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法，&lt;/span&gt;&lt;code&gt;&lt;span&gt;getValue&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 传入一个 evalContext 就是类似上面例子中的 order 对象。其中 Context 的实现将会在下文介绍。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;日志上下文实现&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下面的例子把变量放到了 LogRecordContext 中，然后 SpEL 表达式就可以顺利的解析方法上不存在的参数了，通过上面的 SpEL 的例子可以看出，要把方法的参数和 LogRecordContext 中的变量都放到 SpEL 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;getValue&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法的 Object 中才可以顺利的解析表达式的值。下面看看如何实现：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@LogRecord&lt;/span&gt;(content = &lt;span&gt;&quot;修改了订单的配送员：从“{deveryUser{#oldDeliveryUserId}}”, 修改到“{deveryUser{#request.getUserId()}}”&quot;&lt;/span&gt;,&lt;br/&gt;            bizNo=&lt;span&gt;&quot;#request.getDeliveryOrderNo()&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;modifyAddress&lt;/span&gt;&lt;span&gt;(updateDeliveryRequest request)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 查询出原来的地址是什么&lt;/span&gt;&lt;br/&gt;    LogRecordContext.putVariable(&lt;span&gt;&quot;oldDeliveryUserId&quot;&lt;/span&gt;, DeliveryService.queryOldDeliveryUserId(request.getDeliveryOrderNo()));&lt;br/&gt;    &lt;span&gt;// 更新派送信息 电话，收件人、地址&lt;/span&gt;&lt;br/&gt;    doUpdate(request);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;在 LogRecordValueParser 中创建了一个 EvaluationContext，用来给 SpEL 解析方法参数和 Context 中的变量。相关代码如下：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;EvaluationContext evaluationContext = expressionEvaluator.createEvaluationContext(method, args, targetClass, ret, errorMsg, beanFactory);&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;在解析的时候调用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;getValue&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法传入的参数 evalContext，就是上面这个 EvaluationContext 对象。下面是 LogRecordEvaluationContext 对象的继承体系：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;440&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;457&quot; data-ratio=&quot;1.0386363636363636&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXehNsNY76lXs1L1HwaLESxPy2ibjbGKbEyEbaSibS2slBW1Whcg3ibJyLWL0zx8FUGEQTq0xCgH3RbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;440&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;LogRecordEvaluationContext 做了三个事情：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;把方法的参数都放到 SpEL 解析的 RootObject 中。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;把 LogRecordContext 中的变量都放到 RootObject 中。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;把方法的返回值和 ErrorMsg 都放到 RootObject 中。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;LogRecordEvaluationContext 的代码如下：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LogRecordEvaluationContext&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;MethodBasedEvaluationContext&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;LogRecordEvaluationContext&lt;/span&gt;&lt;span&gt;(Object rootObject, Method method, Object[] arguments,&lt;br/&gt;                                      ParameterNameDiscoverer parameterNameDiscoverer, Object ret, String errorMsg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       &lt;span&gt;//把方法的参数都放到 SpEL 解析的 RootObject 中&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;super&lt;/span&gt;(rootObject, method, arguments, parameterNameDiscoverer);&lt;br/&gt;       &lt;span&gt;//把 LogRecordContext 中的变量都放到 RootObject 中&lt;/span&gt;&lt;br/&gt;        Map&amp;lt;String, Object&amp;gt; variables = LogRecordContext.getVariables();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (variables != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; variables.size() &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;String, Object&amp;gt; entry : variables.entrySet()) {&lt;br/&gt;                setVariable(entry.getKey(), entry.getValue());&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//把方法的返回值和 ErrorMsg 都放到 RootObject 中&lt;/span&gt;&lt;br/&gt;        setVariable(&lt;span&gt;&quot;_ret&quot;&lt;/span&gt;, ret);&lt;br/&gt;        setVariable(&lt;span&gt;&quot;_errorMsg&quot;&lt;/span&gt;, errorMsg);&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;下面是 LogRecordContext 的实现，这个类里面通过一个 ThreadLocal 变量保持了一个栈，栈里面是个 Map，Map 对应了变量的名称和变量的值。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LogRecordContext&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; InheritableThreadLocal&amp;lt;Stack&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt;&amp;gt; variableMapStack = &lt;span&gt;new&lt;/span&gt; InheritableThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;   &lt;span&gt;//其他省略....&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;上面使用了 InheritableThreadLocal，所以在线程池的场景下使用 LogRecordContext 会出现问题，如果支持线程池可以使用阿里巴巴开源的 TTL 框架。那这里为什么不直接设置一个 ThreadLocal&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; 对象，而是要设置一个 Stack 结构呢？我们看一下这么做的原因是什么。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@LogRecord&lt;/span&gt;(content = &lt;span&gt;&quot;修改了订单的配送员：从“{deveryUser{#oldDeliveryUserId}}”, 修改到“{deveryUser{#request.getUserId()}}”&quot;&lt;/span&gt;,&lt;br/&gt;        bizNo=&lt;span&gt;&quot;#request.getDeliveryOrderNo()&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;modifyAddress&lt;/span&gt;&lt;span&gt;(updateDeliveryRequest request)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 查询出原来的地址是什么&lt;/span&gt;&lt;br/&gt;    LogRecordContext.putVariable(&lt;span&gt;&quot;oldDeliveryUserId&quot;&lt;/span&gt;, DeliveryService.queryOldDeliveryUserId(request.getDeliveryOrderNo()));&lt;br/&gt;    &lt;span&gt;// 更新派送信息 电话，收件人、地址&lt;/span&gt;&lt;br/&gt;    doUpdate(request);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;上面代码的执行流程如下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.837620578778135&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXehNsNY76lXs1L1HwaLESxLcgBXtru4cjE68q2vHorVRhyXziaAV8V2G2icZg7BUIExGO8Td0QfUlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1244&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;看起来没有什么问题，但是使用 LogRecordAnnotation 的方法里面嵌套了另一个使用 LogRecordAnnotation 方法的时候，流程就变成下面的形式：&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8894230769230769&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXehNsNY76lXs1L1HwaLESxqGNT1JtY0uhKbK9CdeocO9X0UEficFLyn6xMGV0S1ZYlrMEG2OQkcZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1248&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;可以看到，当方法二执行了释放变量后，继续执行方法一的 logRecord 逻辑，此时解析的时候 ThreadLocal&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt;的 Map 已经被释放掉，所以方法一就获取不到对应的变量了。方法一和方法二共用一个变量 Map 还有个问题是：如果方法二设置了和方法一相同的变量两个方法的变量就会被相互覆盖。所以最终 LogRecordContext 的变量的生命周期需要是下面的形式：&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXehNsNY76lXs1L1HwaLESxnf8JSC6vgFAUkGq7C4jlvPMPbBUotl6WnXtp79rL3C0vlfX6Ke2xXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;371&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;LogRecordContext 每执行一个方法都会压栈一个 Map，方法执行完之后会 Pop 掉这个 Map，从而避免变量共享和覆盖问题。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;默认操作人逻辑&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在 LogRecordInterceptor 中 IOperatorGetService 接口，这个接口可以获取到当前的用户。下面是接口的定义：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IOperatorGetService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 可以在里面外部的获取当前登陆的用户，比如 UserContext.getCurrentUser()&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; 转换成Operator返回&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;Operator &lt;span&gt;getUser&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;下面给出了从用户上下文中获取用户的例子：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DefaultOperatorGetServiceImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IOperatorGetService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Operator &lt;span&gt;getUser&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//UserUtils 是获取用户上下文的方法&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; Optional.ofNullable(UserUtils.getUser())&lt;br/&gt;                        .map(a -&amp;gt; &lt;span&gt;new&lt;/span&gt; Operator(a.getName(), a.getLogin()))&lt;br/&gt;                        .orElseThrow(()-&amp;gt;&lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span&gt;&quot;user is null&quot;&lt;/span&gt;));&lt;br/&gt;        &lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;组件在解析 operator 的时候，就判断注解上的 operator 是否是空，如果注解上没有指定，我们就从 IOperatorGetService 的 getUser 方法获取了。如果都获取不到，就会报错。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;String realOperatorId = &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (StringUtils.isEmpty(operatorId)) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (operatorGetService.getUser() == &lt;span&gt;null&lt;/span&gt; || StringUtils.isEmpty(operatorGetService.getUser().getOperatorId())) {&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span&gt;&quot;user is null&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    realOperatorId = operatorGetService.getUser().getOperatorId();&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    spElTemplates = Lists.newArrayList(bizKey, bizNo, action, operatorId, detail);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;自定义函数逻辑&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;自定义函数的类图如下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.30807248764415157&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXehNsNY76lXs1L1HwaLESxKrpOdFKJX6OIg0AqeCc5luGlJxkdgRUgYyNOHSCcWKVVZIRE0l0EIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1214&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;下面是 IParseFunction 的接口定义：&lt;/span&gt;&lt;code&gt;&lt;span&gt;executeBefore&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数代表了自定义函数是否在业务代码执行之前解析，上面提到的查询修改之前的内容。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IParseFunction&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;executeBefore&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;String &lt;span&gt;functionName&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;String &lt;span&gt;apply&lt;/span&gt;&lt;span&gt;(String value)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;ParseFunctionFactory 的代码比较简单，它的功能是把所有的 IParseFunction 注入到函数工厂中。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ParseFunctionFactory&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, IParseFunction&amp;gt; allFunctionMap;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ParseFunctionFactory&lt;/span&gt;&lt;span&gt;(List&amp;lt;IParseFunction&amp;gt; parseFunctions)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (CollectionUtils.isEmpty(parseFunctions)) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    allFunctionMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (IParseFunction parseFunction : parseFunctions) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (StringUtils.isEmpty(parseFunction.functionName())) {&lt;br/&gt;        &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;      allFunctionMap.put(parseFunction.functionName(), parseFunction);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; IParseFunction &lt;span&gt;getFunction&lt;/span&gt;&lt;span&gt;(String functionName)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; allFunctionMap.get(functionName);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isBeforeFunction&lt;/span&gt;&lt;span&gt;(String functionName)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; allFunctionMap.get(functionName) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; allFunctionMap.get(functionName).executeBefore();&lt;br/&gt;  }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;DefaultFunctionServiceImpl 的逻辑就是根据传入的函数名称 functionName 找到对应的 IParseFunction，然后把参数传入到 IParseFunction 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;apply&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法上最后返回函数的值。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DefaultFunctionServiceImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IFunctionService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ParseFunctionFactory parseFunctionFactory;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;DefaultFunctionServiceImpl&lt;/span&gt;&lt;span&gt;(ParseFunctionFactory parseFunctionFactory)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.parseFunctionFactory = parseFunctionFactory;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;apply&lt;/span&gt;&lt;span&gt;(String functionName, String value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    IParseFunction function = parseFunctionFactory.getFunction(functionName);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (function == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; value;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; function.apply(value);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;beforeFunction&lt;/span&gt;&lt;span&gt;(String functionName)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; parseFunctionFactory.isBeforeFunction(functionName);&lt;br/&gt;  }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2.3 日志持久化逻辑&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;同样在 LogRecordInterceptor 的代码中引用了 ILogRecordService，这个 Service 主要包含了日志记录的接口。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ILogRecordService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 保存 log&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; logRecord 日志实体&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;record&lt;/span&gt;&lt;span&gt;(LogRecord logRecord)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;业务可以实现这个保存接口，然后把日志保存在任何存储介质上。这里给了一个 2.2 节介绍的通过 log.info 保存在日志文件中的例子，业务可以把保存设置成异步或者同步，可以和业务放在一个事务中保证操作日志和业务的一致性，也可以新开辟一个事务，保证日志的错误不影响业务的事务。业务可以保存在 Elasticsearch、数据库或者文件中，用户可以根据日志结构和日志的存储实现相应的查询逻辑。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DefaultLogRecordServiceImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ILogRecordService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//    @Transactional(propagation = Propagation.REQUIRES_NEW)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;record&lt;/span&gt;&lt;span&gt;(LogRecord logRecord)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.info(&lt;span&gt;&quot;【logRecord】log={}&quot;&lt;/span&gt;, logRecord);&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2.4 Starter 逻辑封装&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;上面逻辑代码已经介绍完毕，那么接下来需要把这些组件组装起来，然后让用户去使用。在使用这个组件的时候只需要在 Springboot 的入口上添加一个注解 @EnableLogRecord(tenant = &quot;com.mzt.test&quot;)。其中 tenant 代表租户，是为了多租户使用的。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@SpringBootApplication&lt;/span&gt;(exclude = DataSourceAutoConfiguration&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;@&lt;span&gt;EnableTransactionManagement&lt;/span&gt;&lt;br/&gt;@&lt;span&gt;EnableLogRecord&lt;/span&gt;(&lt;span&gt;tenant&lt;/span&gt; &lt;/span&gt;= &lt;span&gt;&quot;com.mzt.test&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Main&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        SpringApplication.run(Main&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;args&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;我们再看下 EnableLogRecord 的代码，代码中 Import 了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;LogRecordConfigureSelector.class&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;LogRecordConfigureSelector&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 类中暴露了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;LogRecordProxyAutoConfiguration&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 类。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@Target&lt;/span&gt;(ElementType.TYPE)&lt;br/&gt;&lt;span&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;br/&gt;&lt;span&gt;@Documented&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Import&lt;/span&gt;(LogRecordConfigureSelector&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;EnableLogRecord&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;tenant&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;AdviceMode &lt;span&gt;mode&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; AdviceMode.PROXY&lt;/span&gt;;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;LogRecordProxyAutoConfiguration&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 就是装配上面组件的核心类了，代码如下：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LogRecordProxyAutoConfiguration&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ImportAware&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; AnnotationAttributes enableLogRecord;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@Role&lt;/span&gt;(BeanDefinition.ROLE_INFRASTRUCTURE)&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; LogRecordOperationSource &lt;span&gt;logRecordOperationSource&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LogRecordOperationSource();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@ConditionalOnMissingBean&lt;/span&gt;(IFunctionService&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;IFunctionService&lt;/span&gt; &lt;span&gt;functionService&lt;/span&gt;(&lt;span&gt;ParseFunctionFactory&lt;/span&gt; &lt;span&gt;parseFunctionFactory&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; DefaultFunctionServiceImpl(parseFunctionFactory);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ParseFunctionFactory &lt;span&gt;parseFunctionFactory&lt;/span&gt;&lt;span&gt;(@Autowired List&amp;lt;IParseFunction&amp;gt; parseFunctions)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ParseFunctionFactory(parseFunctions);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@ConditionalOnMissingBean&lt;/span&gt;(IParseFunction&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;DefaultParseFunction&lt;/span&gt; &lt;span&gt;parseFunction&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; DefaultParseFunction();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@Role&lt;/span&gt;(BeanDefinition.ROLE_INFRASTRUCTURE)&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; BeanFactoryLogRecordAdvisor &lt;span&gt;logRecordAdvisor&lt;/span&gt;&lt;span&gt;(IFunctionService functionService)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    BeanFactoryLogRecordAdvisor advisor =&lt;br/&gt;            &lt;span&gt;new&lt;/span&gt; BeanFactoryLogRecordAdvisor();&lt;br/&gt;    advisor.setLogRecordOperationSource(logRecordOperationSource());&lt;br/&gt;    advisor.setAdvice(logRecordInterceptor(functionService));&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; advisor;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@Role&lt;/span&gt;(BeanDefinition.ROLE_INFRASTRUCTURE)&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; LogRecordInterceptor &lt;span&gt;logRecordInterceptor&lt;/span&gt;&lt;span&gt;(IFunctionService functionService)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    LogRecordInterceptor interceptor = &lt;span&gt;new&lt;/span&gt; LogRecordInterceptor();&lt;br/&gt;    interceptor.setLogRecordOperationSource(logRecordOperationSource());&lt;br/&gt;    interceptor.setTenant(enableLogRecord.getString(&lt;span&gt;&quot;tenant&quot;&lt;/span&gt;));&lt;br/&gt;    interceptor.setFunctionService(functionService);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; interceptor;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@ConditionalOnMissingBean&lt;/span&gt;(IOperatorGetService&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;  @&lt;span&gt;Role&lt;/span&gt;(&lt;span&gt;BeanDefinition&lt;/span&gt;.&lt;span&gt;ROLE_APPLICATION&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;IOperatorGetService&lt;/span&gt; &lt;span&gt;operatorGetService&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; DefaultOperatorGetServiceImpl();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@ConditionalOnMissingBean&lt;/span&gt;(ILogRecordService&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;  @&lt;span&gt;Role&lt;/span&gt;(&lt;span&gt;BeanDefinition&lt;/span&gt;.&lt;span&gt;ROLE_APPLICATION&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;ILogRecordService&lt;/span&gt; &lt;span&gt;recordService&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; DefaultLogRecordServiceImpl();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setImportMetadata&lt;/span&gt;&lt;span&gt;(AnnotationMetadata importMetadata)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.enableLogRecord = AnnotationAttributes.fromMap(&lt;br/&gt;            importMetadata.getAnnotationAttributes(EnableLogRecord&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;getName&lt;/span&gt;(), &lt;span&gt;false&lt;/span&gt;))&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.enableLogRecord == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      log.info(&lt;span&gt;&quot;@EnableCaching is not present on importing class&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这个类继承 ImportAware 是为了拿到 EnableLogRecord 上的租户属性，这个类使用变量 logRecordAdvisor 和 logRecordInterceptor 装配了 AOP，同时把自定义函数注入到了 logRecordAdvisor 中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;对外扩展类&lt;/strong&gt;：分别是&lt;/span&gt;&lt;code&gt;&lt;span&gt;IOperatorGetService&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;ILogRecordService&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;IParseFunction&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。业务可以自己实现相应的接口，因为配置了 @ConditionalOnMissingBean，所以用户的实现类会覆盖组件内的默认实现。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5. 总结&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;这篇文章介绍了操作日志的常见写法，以及如何让操作日志的实现更加简单、易懂，通过组件的四个模块，介绍了组件的具体实现。对于上面的组件介绍，大家如果有疑问，也欢迎在文末留言，我们会进行答疑。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6. 作者简介&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;站通，2020年加入美团，基础研发平台/研发质量及效率部工程师。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7. 参考资料&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;----------  END  ----------&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;招聘信息&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section data-source=&quot;bj.96weixin.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;美团研发质量及效率部 ，致力于建设业界一流的持续交付平台，现招聘基础组件方向相关的工程师，坐标北京/上海。欢迎感兴趣的同学加入，大家可投递简历至：&lt;/span&gt;&lt;span&gt;chao.yu@meituan.com&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;邮件主题请注明：美团研发质量及效率部&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;strong/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;也许你还想看&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;  | &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651751273&amp;amp;idx=1&amp;amp;sn=388f666fd1bce3413d8564662b120b71&amp;amp;chksm=bd125a248a65d332417c729d9e434157236a41c380fb5ca5b2b3efa7bf6e980273cc544757a9&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651751273&amp;amp;idx=1&amp;amp;sn=388f666fd1bce3413d8564662b120b71&amp;amp;chksm=bd125a248a65d332417c729d9e434157236a41c380fb5ca5b2b3efa7bf6e980273cc544757a9&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Logan Web：前端日志在Web端的实现&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;  |&lt;/strong&gt;&lt;/span&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651748960&amp;amp;idx=1&amp;amp;sn=2bd11c883ecc787e634bc3c29dfbbe50&amp;amp;chksm=bd12a32d8a652a3b25f26de739555341937697e02f2f01017129514624cdb0dd2e2bdd844acb&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Logan：美团开源移动端基础日志库&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;  |&lt;/strong&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651747596&amp;amp;idx=2&amp;amp;sn=6e08a25d203c3e05461b3c1c5f238e82&amp;amp;chksm=bd12ac418a65255743ac6e7758b65f8d5369fde0bb902cee62bbe627f6a4bb307edf76287477&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Android动态日志系统Holmes&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;阅读更多&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;---&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7r&quot; textvalue=&quot;前端&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;前端&lt;/a&gt;&lt;strong&gt;&lt;span&gt; |&lt;/span&gt;&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7v&quot; textvalue=&quot; 安全&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt; &lt;/strong&gt; &lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jsdG&quot; textvalue=&quot;算法&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;算法&lt;/a&gt;&lt;strong&gt; |&lt;/strong&gt;&lt;span&gt; &lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jsWK&quot; textvalue=&quot;后端&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;后端&lt;/a&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt; | &lt;/span&gt;&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jqRZ&quot; textvalue=&quot;数据&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;数据&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7v&quot; textvalue=&quot; 安全&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;安全&lt;/a&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jui4&quot; textvalue=&quot;Android&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;Android&lt;/a&gt;&lt;strong&gt; |&lt;/strong&gt; &lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jtXE&quot; textvalue=&quot;iOS&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;iOS&lt;/a&gt; &lt;strong&gt; |&lt;/strong&gt; &lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7K&quot; textvalue=&quot;运维&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;运维&lt;/a&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jtsX&quot; textvalue=&quot;测试&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;测试&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5NjQ5MTI5OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVGibnsaEib3aNlqF0tOrA2RGEmNSbia2nnohE4Tpf95UyTiaSjDVbHRfY8WNBeTuLLTaVdSckkNyEx1Q/0?wx_fmt=png&quot; data-nickname=&quot;美团技术团队&quot; data-alias=&quot;meituantech&quot; data-signature=&quot;10000+工程师，如何支撑中国领先的生活服务电子商务平台？数亿消费者、数百万商户、2000多个行业、几千亿交易额背后是哪些技术在支撑？这里是美团、大众点评、美团外卖、美团配送、美团优选等技术团队的对外窗口。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d1e2bf94fc82d5ef493d6cf8834fcdd9</guid>
<title>不就是分布式事务，这下彻底清楚了</title>
<link>https://toutiao.io/k/uojgtaj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是老三，上次发文的时候还是上次发文的时候，这篇文章分享分布式事务，看完要是你们不懂，那一定是不明白。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从本地事务到分布式事务&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务大家应该都知道，事务将一组操作纳入到一个不可分割的执行单元，这个执行单元里的操作都成功时才能提交成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单地说，事务提供一种&lt;code&gt;要么不做，要么全做&lt;/code&gt;机制。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ACID&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先简单了解一下事务的四大特性：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7776141384388807&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcejvmIydIIflOyuuTyJgBwC2FXZ85CQrAIUibicGBoJuvq7IN0ibt2SJD7RmDZq8eQUeC9oXUWkibR8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;679&quot;/&gt;&lt;figcaption&gt;ACID&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会出现部分成功部分失败的情况。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;单体事务&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在单体架构时代，所有的业务只用一个数据库。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3812849162011173&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcejvmIydIIflOyuuTyJgBw8mwBtKlYVpg5dqSfibozK4LRvwibe4fflYMpaJnphiaNT655ticCLOhdAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;716&quot;/&gt;&lt;figcaption&gt;单体服务&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单体架构时代事务的是实现很简单，我们操作的是同一个数据库，利用数据库本身提供的事务机制支持就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如我们比较熟悉的MySQL数据库：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;事务的隔离性是通过数据库锁的机制实现的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务的一致性由undo log来保证：undo log是逻辑日志，记录了事务的&lt;code&gt;insert&lt;/code&gt;、&lt;code&gt;update&lt;/code&gt;、&lt;code&gt;deltete&lt;/code&gt;操作，回滚的时候做相反的&lt;code&gt;delete&lt;/code&gt;、&lt;code&gt;update&lt;/code&gt;、&lt;code&gt;insert&lt;/code&gt;操作来恢复数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务的原子性和一持久性由redo log来保证：&lt;code&gt;redolog&lt;/code&gt;被称作重做日志，是物理日志，事务提交的时候，必须先将事务的所有日志写入redo log持久化，到事务的提交操作才算完成。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5432960893854749&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcejvmIydIIflOyuuTyJgBwMf3eGKn57dfMSWE58YgULdH9U3yGRKhT8c5UhYHJD5Bgc3NsF9jhlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;716&quot;/&gt;&lt;figcaption&gt;ACID实现&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;详细了解建议阅读《MySQL技术内幕  InnoDB存储引擎》7.2节。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分布式事务&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着业务发展，单体架构顶不住了，慢慢进入分布式时代——&lt;code&gt;SOA&lt;/code&gt;或者粒度更细的&lt;code&gt;微服务&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然伴随而来的就是分库分表。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;我们可能会根据业务服务拆分的方式，对应地&lt;code&gt;垂直拆分&lt;/code&gt;大库，例如原始大库拆分成订单库、商品库、支付库。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同时由于业务数据可能会高速增加，很快就成了亿级，我们不得不又&lt;code&gt;水平分库&lt;/code&gt;，来减轻单个数据库的压力。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7109677419354838&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcejvmIydIIflOyuuTyJgBwwlpkreNUaAAvFtSK8GS5p9P4iaGaUfL82mTvLnX2vhvdaygRsfDUBOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;775&quot;/&gt;&lt;figcaption&gt;分布式情况下数据库&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管是怎么分库的，最后的结果就是我们一个操作可能要横跨多个数据库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库本身的事务机制只能保证它自己这个库的事务，但是没法保证到其它的库。我们要保证跨多个库的操作还具备事务的特性，就不得不上分布式事务了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247488224&amp;amp;idx=1&amp;amp;sn=0631d97efbf9786755742c0b4b15f21f&amp;amp;chksm=c0ccfa45f7bb7353e6a4086ecc3c8cfdd75d8aaf9a2bc953fb0ee5ce63c7711ea3ac9981219e&amp;amp;token=1023763357&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;分布式必备理论基础：CAP和BASE &lt;/a&gt;  里，讲了分布式的理论基础——&lt;code&gt;CAP&lt;/code&gt;和&lt;code&gt;BASE&lt;/code&gt;，这里就不再多讲。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们只需要知道，BASE理论是对CAP中AP的一个延申，在没法保证强一致性的前提下，尽可能达到最终的一致性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的分布式事务通常也做不到本地事务那么强的一致性，一般都是对&lt;code&gt;一致性(Consistency)&lt;/code&gt;适当做了一些放宽，只需要达到最终的一致性。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分布式事务解决方案&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;XA /2PC两阶段提交&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;XA&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;XA是一个分布式事务协议，由Tuxedo提出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个协议里，有三个角色：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;AP（Application）&lt;/strong&gt;：应用系统（服务）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;TM（Transaction Manager）&lt;/strong&gt;：事务管理器（全局事务管理）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;RM（Resource Manager）&lt;/strong&gt;：资源管理器（数据库）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;XA规范主要定义了 事务管理器（Transaction  Manager）和资源管理器（Resource Manager）之间的接口。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6090604026845637&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcejvmIydIIflOyuuTyJgBwohzPUTeV5tzXha0hg60efBibudz4tMthP8XBoLyiaAcbw3Sib8UAvNSRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;596&quot;/&gt;&lt;figcaption&gt;XA规范&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;XA协议采用&lt;strong&gt;两阶段提交&lt;/strong&gt;方式来管理分布式事务。XA接口提供资源管理器与事务管理器之间进行通信的标准接口。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2PC 两阶段提交&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两阶段提交的思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情况决定各参与者是否要提交操作还是中止操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两阶段提交的两个阶段：第一阶段：准备阶段，第二阶段：提交阶段&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5746864310148233&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/PMZOEonJxWcejvmIydIIflOyuuTyJgBw7poddHyqLlg0Sjcx6YdxnpUY2113mv5rRZricHP2T1L0Ez8cLR4xEyg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;877&quot;/&gt;&lt;figcaption&gt;两阶段-参考[2]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;准备阶段 Prepares&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;协调者向所有参与者询问是否可以执行提交操作，所有参与者执行事务，将结果返回给协调者。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2127659574468086&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcejvmIydIIflOyuuTyJgBw1lic1ibpKDmwFNibYYvAlotLKNovTek8M8FOdNHxiau49ORx2vbd15DqZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;423&quot;/&gt;&lt;figcaption&gt;第一阶段&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;提交阶段 commit&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果第一阶段中所有参与者都返回yes响应，协调者向所有参与者发出提交请求，所有参与者提交事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果第一阶段中有一个或者多个参与者返回no响应，协调者向所有参与者发出回滚请求，所有参与者进行回滚操作&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1938534278959811&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcejvmIydIIflOyuuTyJgBwcWkcMIOGB5FPE0nKpbdSlibQTCrOiaJGNkia5Y8AVtfWVBASSSiaKric8ibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;423&quot;/&gt;&lt;figcaption&gt;第二阶段&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两阶段提交优点：尽量保证了数据的强一致，但不是100%一致&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两阶段提交同样有一些缺点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;单点故障&lt;/p&gt;&lt;p&gt;由于协调者的重要性，一旦协调者发生故障，参与者会一直阻塞，尤其是在第二阶段，协调者发生故障，那么所有的参与者都处于锁定事务资源的状态中，而无法继续完成事务操作。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;同步阻塞&lt;/p&gt;&lt;p&gt;它是一个强一致性的同步阻塞协议，也就是所谓&lt;code&gt;刚性事务&lt;/code&gt;，事务执⾏过程中需要将所需资源全部锁定，会比较影响性能。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;数据不一致&lt;/p&gt;&lt;p&gt;在第二阶段中，当协调者向参与者发送提交事务请求之后，由于网络抖动，如果第二阶段只有部分参与者收到提交请求，那么就会导致数据不一致。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3PC 三阶段提交&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三阶段提交（&lt;code&gt;3PC&lt;/code&gt;）是二阶段提交（&lt;code&gt;2PC&lt;/code&gt;）的一种改进版本 ，为解决两阶段提交协议的单点故障和同步阻塞问题。上边提到两阶段提交，当协调者崩溃时，参与者不能做出最后的选择，就会一直保持阻塞锁定资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;2PC&lt;/code&gt; 中只有协调者有超时机制，&lt;code&gt;3PC&lt;/code&gt; 在协调者和参与者中都引入了超时机制，协调者出现故障后，参与者就不会一直阻塞。而且在第一阶段和第二阶段中又插入了一个预提交阶段，保证了在最后提交阶段之前各参与节点的状态是一致的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三阶段提交的三个阶段：&lt;code&gt;CanCommit&lt;/code&gt;，&lt;code&gt;PreCommit&lt;/code&gt;，&lt;code&gt;DoCommit&lt;/code&gt;三个阶段&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7331932773109243&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcejvmIydIIflOyuuTyJgBwBFbTxeefz8EFMia3j78de0IwK78ico3Wo6J2MLpQxNsdPRtYZkheJYcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;952&quot;/&gt;&lt;figcaption&gt;三阶段协议-参考[2]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;准备阶段 CanCommit&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;预提交阶段 PreCommit&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;协调者根据参与者在&lt;strong&gt;准备阶段&lt;/strong&gt;的响应判断是否执行事务还是中断事务&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果所有参与者都返回Yes，则执行事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果参与者有一个或多个参与者返回No或者超时，则中断事务&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参与者执行完操作之后返回ACK响应，同时开始等待最终指令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;提交阶段 DoCommit&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;协调者根据参与者在&lt;strong&gt;准备阶段&lt;/strong&gt;的响应判断是否执行事务还是中断事务&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果所有参与者都返回正确的&lt;code&gt;ACK&lt;/code&gt;响应，则提交事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果参与者有一个或多个参与者收到错误的&lt;code&gt;ACK&lt;/code&gt;响应或者超时，则中断事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果参与者无法及时接收到来自协调者的提交或者中断事务请求时，在等待超时之后，会继续进行事务提交&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;协调者收到所有参与者的ACK响应，完成事务。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.42789598108747046&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcejvmIydIIflOyuuTyJgBwuwWTDOpO16kpPtjHV6cXu3u4993FM80uuHEZFNjePoScCib7mUiaKCiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1269&quot;/&gt;&lt;figcaption&gt;3PC&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出，三阶段提交解决的只是两阶段提交中 单体故障和同步阻塞的问题，因为加入了超时机制，这里的超时的机制作用于 &lt;strong&gt;预提交阶段&lt;/strong&gt; 和 &lt;strong&gt;提交阶段&lt;/strong&gt;。如果等待 &lt;strong&gt;预提交请求&lt;/strong&gt; 超时，参与者直接回到准备阶段之前。如果等到&lt;strong&gt;提交请求&lt;/strong&gt;超时，那参与者就会提交事务了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;无论是2PC还是3PC都不能保证分布式系统中的数据100%一致&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;TCC补偿事务&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;TCC  Try-Confirm-Cancel&lt;/strong&gt; 的简称，是两阶段提交的一个变种，针对每个操作，都需要有一个其对应的确认和取消操作，当操作成功时调用确认操作，当操作失败时调用取消操作，类似于二阶段提交，只不过是这里的提交和回滚是针对业务上的，所以基于TCC实现的分布式事务也可以看做是对业务的一种补偿机制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCC的三阶段：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Try 阶段&lt;/strong&gt;：对业务系统做检测及资源预留&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Confirm 阶段&lt;/strong&gt;：对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Cancel 阶段&lt;/strong&gt;：在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Try阶段，是对业务系统进行检查及资源预览，比如订单和库存操作，需要检查库存剩余数量是否够用，并进行预留，预留操作的话就是新建一个可用库存数量字段，Try阶段操作是对这个可用库存数量进行操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如下单减库存的操作：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5322434150772025&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcejvmIydIIflOyuuTyJgBw6AvySrU439grTdyNWZLBhoQTruJJE1iaHGKC1R52zy3O6J9MBXCibxtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1101&quot;/&gt;&lt;figcaption&gt;TCC下单减库存&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;执行流程：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Try阶段：订单系统将当前订单状态设置为支付中，库存系统校验当前剩余库存数量是否大于1，然后将可用库存数量设置为库存剩余数量-1，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果Try阶段执行成功，执行Confirm 阶段，将订单状态修改为支付成功，库存剩余数量修改为可用库存数量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果Try阶段执行失败，执行Cancel 阶段，将订单状态修改为支付失败，可用库存数量修改为库存剩余数量&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCC 不存在资源阻塞的问题，因为每个方法都直接进行事务的提交，一旦出现异常通过则 &lt;code&gt;Cancel&lt;/code&gt; 来进行回滚补偿，这也就是常说的补偿性事务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，使用TCC，原本一个方法，现在却需要三个方法来支持，可以看到 TCC 对业务的侵入性很强，而且这种模式并不能很好地被复用，会导致开发量激增。还要考虑到网络波动等原因，为保证请求一定送达都会有重试机制，所以还需要考虑接口的幂等性。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本地消息表&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地消息表的核心思想是将分布式事务拆分成本地事务进行处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，可以在订单库新增一个消息表，将新增订单和新增消息放到一个事务里完成，然后通过轮询的方式去查询消息表，将消息推送到MQ，库存系统去消费MQ。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.29365598430346634&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcejvmIydIIflOyuuTyJgBw6cjdJYyy89SXIMFVqZu2lkUoAngmSPDMZD6L94FKjlKbAPznGuUzWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1529&quot;/&gt;&lt;figcaption&gt;本地消息表&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;执行流程：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;订单服务，添加一条订单和一条消息，在一个事务里提交&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;订单服务，使用定时任务轮询查询状态为未同步的消息表，发送到MQ，如果发送失败，就重试发送&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;库存服务，接收MQ消息，修改库存表，需要保证幂等操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果修改成功，调用rpc接口修改订单系统消息表的状态为已完成或者直接删除这条消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果修改失败，可以不做处理，等待重试&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;订单服务中的消息有可能由于业务问题会一直重复发送，所以为了避免这种情况可以记录一下发送次数，当达到次数限制之后报警，人工接入处理；库存服务需要保证幂等，避免同一条消息被多次消费造成数据不一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地消息表这种方案实现了最终一致性，需要在业务系统里增加消息表，业务逻辑中多一次插入的DB操作，所以性能会有损耗，而且最终一致性的间隔主要由定时任务的间隔时间决定。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MQ消息事务&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息事务的原理是将两个事务通过消息中间件进行异步解耦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;订单服务执行自己的本地事务，并发送MQ消息，库存服务接收消息，执行自己的本地事务，乍一看，好像跟本地消息表的实现方案类似，只是省去 了对本地消息表的操作和轮询发送MQ的操作，但实际上两种方案的实现是不一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息事务一定要保证业务操作与消息发送的一致性，如果业务操作成功，这条消息也一定投递成功。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6848541862652869&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcejvmIydIIflOyuuTyJgBwPyojAicROw0M1VZbMZ231htAaB9s4WUkEk0DkHzdEwRyBGJCekOA5Tg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1063&quot;/&gt;&lt;figcaption&gt;MQ消息事务&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;执行流程：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;发送prepare消息到消息中间件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发送成功后，执行本地事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果事务执行成功，则commit，消息中间件将消息下发至消费端&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果事务执行失败，则回滚，消息中间件将这条prepare消息删除&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费端接收到消息进行消费，如果消费失败，则不断重试&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息事务依赖于消息中间件的事务消息，例如我们熟悉的RocketMQ就支持事务消息（半消息），也就是只有收到发送方确定才会正常投递的消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方案也是实现了最终一致性，对比本地消息表实现方案，不需要再建消息表，对性能的损耗和业务的入侵更小。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最大努力通知&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最大努力通知相比实现会简单一些，适用于一些最终一致性要求较低的业务，比如支付通知，短信通知这种业务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以支付通知为例，业务系统调用支付平台进行支付，支付平台进行支付，进行操作支付之后支付平台会去同步通知业务系统支付操作是否成功，如果不成功，会一直异步重试，但是会有一个最大通知次数，如果超过这个次数后还是通知失败，就不再通知，业务系统自行调用支付平台提供一个查询接口，供业务系统进行查询支付操作是否成功&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6316568047337278&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcejvmIydIIflOyuuTyJgBwpRficz6rxPuL3PYs0x6Bnu8rPSjOQKM1pjTbuGuxUjtDRsfvVz74qrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;676&quot;/&gt;&lt;figcaption&gt;最大努力通知&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;执行流程：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;业务系统调用支付平台支付接口， 并在本地进行记录，支付状态为支付中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支付平台进行支付操作之后，无论成功还是失败，同步给业务系统一个结果通知&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果通知一直失败则根据重试规则异步进行重试，达到最大通知次数后，不再通知&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支付平台提供查询订单支付操作结果接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务系统根据一定业务规则去支付平台查询支付结果&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Saga事务&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Saga事务，核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和本地事务undo log有点像，出问题了，逆向操作来挽救。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sega简介：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Saga = Long Live Transaction (LLT，长活事务)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LLT = T1 + T2 + T3 + ... + Ti（Ti为本地短事务）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个本地事务Ti 有对应的补偿 Ci&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sega的执行顺序：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;正常情况：T1 T2 T3 ... Tn&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异常情况：T1 T2 T3 C3 C2 C1&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Saga两种恢复策略&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;向后恢复，如果任意本地子事务失败，补偿已完成的事务。如异常情况的执行顺序T1 T2 Ti Ci C2 C1.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;向前恢复，即重试失败的事务，假设最后每个子事务都会成功。执行顺序：T1, T2, ..., Tj(失败), Tj(重试),..., Tn。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，假设用户下订单，花50块钱购买了10瓶可乐，则有这么一些短事务和回滚操作：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;T1=下订单  =&amp;gt; T2=用户扣50块钱 =&amp;gt; T3=用户加10瓶可乐= &amp;gt; T4=库存减10瓶可乐&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C1=取消订单 =&amp;gt; C2= 给用户加50块钱 =&amp;gt; C3 =用户减10朵玫瑰 = &amp;gt; C4=库存加10朵玫瑰&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4125113327289211&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcejvmIydIIflOyuuTyJgBwMXgiaJ0yuPUXxBjDfh95lvFEwLxkTy9aDbKKYCpFfku4d8sOuz3DtXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1103&quot;/&gt;&lt;figcaption&gt;Sega事务&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Seata&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看了这么些事务的方案，介绍了相关的原理，但是这些原理怎么落地呢？各种各样的坑怎么处理呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;—— 人生苦短，我用开源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阿里巴巴开源了一套开源分布式事务解决方案——Seata。Seata可能并不称之为完美，但对代码入侵性非常小，基本环境搭建完成的话，使用的时候在只需要方法上添加一个注解&lt;code&gt;@GlobalTransactional&lt;/code&gt;就可以开启全局事务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Seata&lt;/code&gt; 也是从两段提交演变而来的一种分布式事务解决方案，提供了 &lt;code&gt;AT&lt;/code&gt;、&lt;code&gt;TCC&lt;/code&gt;、&lt;code&gt;SAGA&lt;/code&gt; 和 &lt;code&gt;XA&lt;/code&gt; 等事务模式，我们来看一下&lt;code&gt;AT&lt;/code&gt;模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Seata&lt;/strong&gt; 中主要有这么几种角色：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;TC（Transaction Coordinator）&lt;/strong&gt;：事务协调者。管理全局的分支事务的状态，用于全局性事务的提交和回滚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;TM（Transaction Manager）&lt;/strong&gt;：事务管理者。用于开启、提交或回滚事务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;RM（Resource Manager）&lt;/strong&gt;：资源管理器。用于分支事务上的资源管理，向 &lt;strong&gt;TC&lt;/strong&gt; 注册分支事务，上报分支事务的状态，接收 &lt;strong&gt;TC&lt;/strong&gt; 的命令来提交或者回滚分支事务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看一下Seata大概的一个工作流程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7764589515331355&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcejvmIydIIflOyuuTyJgBw6P22ibO4OwA7KSSXWAoEgt8uVN8AjE0ZRdzAAGA2o7xBM3b8XQmwVVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1011&quot;/&gt;&lt;figcaption&gt;Seata&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行流程：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;服务A中的 &lt;strong&gt;TM&lt;/strong&gt; 向 &lt;strong&gt;TC&lt;/strong&gt; 申请开启一个全局事务，&lt;strong&gt;TC&lt;/strong&gt; 就会创建一个全局事务并返回一个唯一的 &lt;strong&gt;XID&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务A中的 &lt;strong&gt;RM&lt;/strong&gt; 向 &lt;strong&gt;TC&lt;/strong&gt; 注册分支事务，然后将这个分支事务纳入 &lt;strong&gt;XID&lt;/strong&gt; 对应的全局事务管辖中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务A开始执行分支事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务A开始远程调用B服务，此时 &lt;strong&gt;XID&lt;/strong&gt; 会根据调用链传播&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务B中的 &lt;strong&gt;RM&lt;/strong&gt; 也向 &lt;strong&gt;TC&lt;/strong&gt; 注册分支事务，然后将这个分支事务纳入 &lt;strong&gt;XID&lt;/strong&gt; 对应的全局事务管辖中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务B开始执行分支事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;全局事务调用处理结束后，&lt;strong&gt;TM&lt;/strong&gt; 会根据有误异常情况，向 &lt;strong&gt;TC&lt;/strong&gt; 发起全局事务的提交或回滚&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;TC&lt;/strong&gt; 协调其管辖之下的所有分支事务，决定是提交还是回滚&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于Seata的使用，和更详细的原理，这里挖个坑，以后有时间再细讲。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上边简单介绍了 &lt;code&gt;2PC&lt;/code&gt;、&lt;code&gt;3PC&lt;/code&gt;、&lt;code&gt;TCC&lt;/code&gt;、&lt;code&gt;本地消息表&lt;/code&gt;、&lt;code&gt;最大努力通知&lt;/code&gt;、&lt;code&gt;MQ&lt;/code&gt;、&lt;code&gt;Sega&lt;/code&gt;、&lt;code&gt;Seata&lt;/code&gt; 这8种分布式事务解决方案，但不管我们选哪一种方案，我们可以看到真要落地要考虑的点都很多，一个不慎，可能踩坑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使是看起来很省心的&lt;code&gt;Seata&lt;/code&gt;，我之前的项目花了不少w买了它的商业化版本&lt;code&gt;GTS&lt;/code&gt;，但是支持方仍然列出了一些“禁忌”，像长事务、大量数据、热点数据、异步调用等等，都可能会出现问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在项目中应用分布式事务要谨慎再谨慎，除非真的有一致性要求比较强的场景，能不用就尽量不用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0739644970414202&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcejvmIydIIflOyuuTyJgBwss5QY1GjXAJFSF775NEMBiaiaQFVwFgLsEC9hFYyeZmxQOQUic5UyO9gA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;338&quot;/&gt;&lt;figcaption&gt;尽量别用分布式事务&lt;/figcaption&gt;&lt;/figure&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果觉得文章有帮助， &lt;strong&gt;点赞&lt;/strong&gt;、&lt;strong&gt;在看&lt;/strong&gt;、&lt;strong&gt;关注&lt;/strong&gt;、&lt;strong&gt;转发&lt;/strong&gt;  素质四连，抱拳！&lt;/p&gt;&lt;/blockquote&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[1]. 再有人问你分布式事务，把这篇扔给他:https://juejin.cn/post/6844903647197806605&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[2]. 让我们聊一聊分布式事务:https://chenmingyu.top/distributed-transaction/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[3]. 分布式事务，这一篇就够了:https://xiaomi-info.github.io/2020/01/02/distributed-transaction/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[4].&lt;/span&gt;&lt;span&gt;从分布式事务解决到Seata使用，一梭子给你整明&lt;/span&gt;&lt;span&gt;了:https://juejin.cn/post/6944882663148748807&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[5]. 看了 5种分布式事务方案，我司最终选择了 Seata，真香！:https://juejin.cn/post/6899645923024355336#heading-3&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[6]. 后端程序员必备：分布式事务基础篇:https://juejin.cn/post/6844904077646626823#heading-28&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;推荐阅读：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>00d5f75a5bf0b9c2d96373f8162ec740</guid>
<title>什么是 SQL 注入，这些坑得避开</title>
<link>https://toutiao.io/k/7t4fr53</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1、sql 注入是什么&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sql 注入就是用户通过输入的参数，拼接到原先的 sql 中，成为 sql 的一部分，从而影响 sql 的功能和执行结果&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2、sql 注入破坏力&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;- &lt;strong&gt;小兵破坏力&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如原先 sql 如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&#x27;用户名&#x27;&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;password&lt;/span&gt;=&lt;span&gt;&#x27;密码&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户输入&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;name：臻大虾&lt;span&gt;&#x27;-- &#x27;&lt;/span&gt;注释&lt;br/&gt;password：密码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那最终的结果猜猜是什么？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&#x27;臻大虾&#x27;&lt;/span&gt;&lt;span&gt;-- &#x27;注释&#x27; and password=&#x27;密码&#x27;;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两个-- 代表注释，所以这条 sql 只需要输入用户名，就可以获取用户信息，跳过了密码的校验&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;- &lt;strong&gt;boss 破坏力&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来个厉害的，比如用户输入以下参数&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;name:臻大虾&lt;br/&gt;password:&lt;span&gt;&#x27;; drop table user;-- &#x27;&lt;/span&gt;注释&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终的 sql：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&#x27;臻大虾&#x27;&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;password&lt;/span&gt;=&lt;span&gt;&#x27;&#x27;&lt;/span&gt;; &lt;span&gt;drop&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;;&lt;span&gt;-- &#x27;注释&#x27;;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;user 表居然被删除了，看到这，此时的你可能想原地爆炸。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3、对策&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1、PreparedStatement 预编译&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用预编译，这样传入的参数，会被当作字符串，也就是被引号包起来&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拿刚才的例子，用户输入&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;name：臻大虾&lt;span&gt;&#x27;-- &#x27;&lt;/span&gt;注释&lt;br/&gt;password：密码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果使用了预编译，那最终的 sql&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&#x27;臻大虾\&#x27;&lt;/span&gt;&lt;span&gt;-- \&#x27;注释&#x27; and password=&#x27;密码&#x27;;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参数中的引号被转义，从而避免成为 sql 的一部分。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2、有些语句不能预编译&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;预编译获取参数是根据#，而$ 是拼接的意思&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;#{}:解析为预编译语句的一个参数占位符&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;${}:仅仅作为一个字符串，在动态 sql 中直接替换变量，传入什么值，就是什么值&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如传入：&#x27;臻大虾&#x27; or 1=1&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;#{name} //SELECT * FROM user WHERE name=&#x27;\&#x27;臻大虾\&#x27; or 1=1&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;、&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=${&lt;span&gt;name&lt;/span&gt;} //&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&#x27;臻大虾&#x27;&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是有些情况使用#会报错，比如 like、in 如果使用#会报错，而使用&lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot; 则不会，所以有些人就直接使用&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 13083.4 950&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mo&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot; font-size=&quot;934.6px&quot; font-family=&quot;serif&quot;&gt;则&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(934.5, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;934.6px&quot; font-family=&quot;serif&quot;&gt;不&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(1869.1, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;934.6px&quot; font-family=&quot;serif&quot;&gt;会&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(2803.6, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;934.6px&quot; font-family=&quot;serif&quot;&gt;，&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(3738.1, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;934.6px&quot; font-family=&quot;serif&quot;&gt;所&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(4672.7, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;934.6px&quot; font-family=&quot;serif&quot;&gt;以&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(5607.2, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;934.6px&quot; font-family=&quot;serif&quot;&gt;有&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(6541.7, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;934.6px&quot; font-family=&quot;serif&quot;&gt;些&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(7476.3, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;934.6px&quot; font-family=&quot;serif&quot;&gt;人&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(8410.8, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;934.6px&quot; font-family=&quot;serif&quot;&gt;就&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(9345.3, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;934.6px&quot; font-family=&quot;serif&quot;&gt;直&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(10279.8, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;934.6px&quot; font-family=&quot;serif&quot;&gt;接&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(11214.4, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;934.6px&quot; font-family=&quot;serif&quot;&gt;使&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(12148.9, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;934.6px&quot; font-family=&quot;serif&quot;&gt;用&lt;/text&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有 order by，根据传入的参数排序，这些情况就会有 sql 注入的危险，那怎么办呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;name&lt;/span&gt; &lt;span&gt;like&lt;/span&gt; &lt;span&gt;&#x27;%#{name}%&#x27;&lt;/span&gt; //会报错&lt;br/&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;name&lt;/span&gt; &lt;span&gt;like&lt;/span&gt; &lt;span&gt;&#x27;%${name}%&#x27;&lt;/span&gt; //正常&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正确写法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 mysql 的字符串拼接函数 concat&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;name&lt;/span&gt; &lt;span&gt;like&lt;/span&gt; &lt;span&gt;concat&lt;/span&gt;(&lt;span&gt;&#x27;%&#x27;&lt;/span&gt;,&lt;span&gt;#{name},&#x27;%&#x27;)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正确写法，使用 foreach&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@&lt;span&gt;Select&lt;/span&gt;(&lt;span&gt;&quot;&amp;lt;script&amp;gt;&quot;&lt;/span&gt; +&lt;br/&gt;        &lt;span&gt;&quot;select * from user where id in &quot;&lt;/span&gt;+&lt;br/&gt;        &lt;span&gt;&quot;&amp;lt;foreach item=&#x27;item&#x27; index=&#x27;index&#x27; collection=&#x27;userIds&#x27; open=&#x27;(&#x27; separator=&#x27;,&#x27; close=&#x27;)&#x27;&amp;gt; &quot;&lt;/span&gt; +&lt;br/&gt;        &lt;span&gt;&quot;#{item}&quot;&lt;/span&gt; +&lt;br/&gt;        &lt;span&gt;&quot;&amp;lt;/foreach&amp;gt;&quot;&lt;/span&gt;+&lt;br/&gt;        &lt;span&gt;&quot;&amp;lt;/script&amp;gt;&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;List&lt;/span&gt;&amp;lt;&lt;span&gt;User&lt;/span&gt;&amp;gt; getByIds(@Param(&lt;span&gt;&quot;userIds&quot;&lt;/span&gt;) &lt;span&gt;List&lt;/span&gt;&amp;lt;&lt;span&gt;Long&lt;/span&gt;&amp;gt; userIds);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时需要根据前端传入的参数来排序，此时就会有 sql 注入的危险，此时可以使用白名单&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;String&amp;gt; allowSortColumnList= Lists.newArrayList(&lt;span&gt;&quot;age&quot;&lt;/span&gt;,&lt;span&gt;&quot;score&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(!allowSortColumnList.contains(sortParam)){&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&lt;span&gt;&quot;can not sort by &quot;&lt;/span&gt;+sortParam);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>