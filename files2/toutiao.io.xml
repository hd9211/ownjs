<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ed1a3f9574dc4a82f905bed79de88918</guid>
<title>解析分布式系统的缓存设计</title>
<link>https://toutiao.io/k/pucrtli</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;25&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;作者：vivo互联网服务器团队-Zhang Peng&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、缓存简介&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.1 什么是缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存就是数据交换的缓冲区。缓存的本质是一个内存 Hash。缓存是一种利用空间换时间的设计，其目标就是更快、更近：极大的提高。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;将数据写入/读取速度更快的存储（设备）；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将数据缓存到离应用最近的位置；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将数据缓存到离用户最近的位置。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;缓存是用于存储数据的硬件或软件的组成部分，以使得后续更快访问相应的数据。缓存中的数据可能是提前计算好的结果、数据的副本等。典型的应用场景：有 cpu cache, 磁盘 cache 等。本文中提及到缓存主要是指互联网应用中所使用的缓存组件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;缓存命中率是缓存的重要度量指标，命中率越高越好。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;24&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;缓存命中率 = 从缓存中读取次数 / 总读取次数&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.2 何时需要缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;引入缓存，会增加系统的复杂度。所以，引入缓存前，需要先权衡是否值得，考量点如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在数据层引入缓存，有以下几个好处：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.3 缓存的基本原理&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;根据业务场景，通常缓存有以下几种使用方式：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;懒汉式(读时触发)：先查询 DB 里的数据, 然后把相关的数据写入 Cache。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;饥饿式(写时触发)：写入 DB 后, 然后把相关的数据也写入 Cache。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;定期刷新：适合周期性的跑数据的任务，或者列表型的数据，而且不要求绝对实时性。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.4 缓存淘汰策略&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存淘汰的类型：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1）基于空间&lt;/strong&gt;：设置缓存空间大小。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）基于容量&lt;/strong&gt;：设置缓存存储记录数。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3）基于时间&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;缓存淘汰算法：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1）FIFO：先进先出&lt;/strong&gt;。在这种淘汰算法中，先进入缓存的会先被淘汰。这种可谓是最简单的了，但是会导致我们命中率很低。试想一下我们如果有个访问频率很高的数据是所有数据第一个访问的，而那些不是很高的是后面再访问的，那这样就会把我们的首个数据但是他的访问频率很高给挤出。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）LRU：最近最少使用算法&lt;/strong&gt;。在这种算法中避免了上面的问题，每次访问数据都会将其放在我们的队尾，如果需要淘汰数据，就只需要淘汰队首即可。但是这个依然有个问题，如果有个数据在 1 个小时的前 59 分钟访问了 1 万次(可见这是个热点数据),再后一分钟没有访问这个数据，但是有其他的数据访问，就导致了我们这个热点数据被淘汰。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3）LFU：最近最少频率使用&lt;/strong&gt;。在这种算法中又对上面进行了优化，利用额外的空间记录每个数据的使用频率，然后选出频率最低进行淘汰。这样就避免了 LRU 不能处理时间段的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这三种缓存淘汰算法，实现复杂度一个比一个高，同样的命中率也是一个比一个好。而我们一般来说选择的方案居中即可，即实现成本不是太高，而命中率也还行的 LRU。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、缓存的分类&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存从部署角度，可以分为客户端缓存和服务端缓存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;客户端缓存&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;HTTP 缓存&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;浏览器缓存&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;APP 缓存（1、&lt;span&gt;Android  2、&lt;/span&gt;&lt;span&gt;IOS）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;服务端缓存&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;CDN 缓存：存放 HTML、CSS、JS 等静态资源。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;反向代理缓存：动静分离，只缓存用户请求的静态资源。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据库缓存：数据库（如 MySQL）自身一般也有缓存，但因为命中率和更新频率问题，不推荐使用。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;进程内缓存：缓存应用字典等常用数据。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;分布式缓存：缓存数据库中的热点数据。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其中，CDN 缓存、反向代理缓存、数据库缓存一般由专职人员维护（运维、DBA）。&lt;span&gt;后端开发一般聚焦于进程内缓存、分布式缓存。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.1 HTTP 缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.2 CDN 缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;CDN 将数据缓存到离用户物理距离最近的服务器，使得用户可以就近获取请求内容。CDN 一般缓存静态资源文件（页面，脚本，图片，视频，文件等）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;国内网络异常复杂，跨运营商的网络访问会很慢。为了解决跨运营商或各地用户访问问题，可以在重要的城市，部署 CDN 应用。使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;321&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtyib8hzr838nIZicibTqibaqzR6WloDHz8S5o3bG5f06v6F97dv8f3wwghvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图片引用自：&lt;/span&gt;&lt;a href=&quot;https://www.creative-artworks.eu/why-use-a-content-delivery-network-cdn/&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Why use a CDN&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.1.1 CDN 原理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;CDN 的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1）未部署 CDN 应用前的网络路径：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在不考虑复杂网络的情况下，从请求到响应需要经过 3 个节点，6 个步骤完成一次用户访问操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2）部署 CDN 应用后网络路径：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;请求&lt;/strong&gt;：本机网络（局域网） =&amp;gt; 运营商网络&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;响应&lt;/strong&gt;：运营商网络 =&amp;gt; 本机网络（局域网）&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在不考虑复杂网络的情况下，从请求到响应需要经过 2 个节点，2 个步骤完成一次用户访问操作。与不部署 CDN 服务相比，减少了 1 个节点，4 个步骤的访问。极大的提高了系统的响应速度。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.1.2 CDN 特点&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;本地 Cache 加速&lt;/strong&gt;：提升访问速度，尤其含有大量图片和静态页面站点；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;实现跨运营商的网络加速&lt;/strong&gt;：消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;远程加速&lt;/strong&gt;：远程访问用户根据 DNS 负载均衡技术智能自动选择 Cache 服务器，选择最快的 Cache 服务器，加快远程访问的速度；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;带宽优化&lt;/strong&gt;：自动生成服务器的远程 Mirror（镜像）cache 服务器，远程用户访问时从 cache 服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点 WEB 服务器负载等功能。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;集群抗攻击&lt;/strong&gt;：广泛分布的 CDN 节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种 D.D.o.S 攻击对网站的影响，同时保证较好的服务质量。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;31&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;解决方案：主要缓存静态资源，动态资源建立多级缓存或准实时同步；&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;67&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;1.解决方案（主要是在性能和数据一致性二者间寻找一个平衡）。&lt;/p&gt;&lt;p&gt;2.设置缓存失效时间（1 个小时，过期后同步数据）。&lt;/p&gt;&lt;p&gt;3.针对资源设置版本号。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.2 反向代理缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;340&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5885558583106267&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtykNRn1bK3lEibicbVgYibCHgxSYn62bxI0h7kulr8D0PxXibbfkAagbEic7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1101&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.2.1 反向代理缓存原理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;反向代理位于应用服务器同一网络，处理所有对 WEB 服务器的请求。反向代理缓存的原理：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这种方式通过降低向 WEB 服务器的请求数，从而降低了 WEB 服务器的负载。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;反向代理缓存一般针对的是静态资源，而将动态资源请求转发到应用服务器处理。常用的缓存应用服务器有 Varnish，Ngnix，Squid。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.2.2 反向代理缓存比较&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;常用的代理缓存有 Varnish，Squid，Ngnix，简单比较如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Varnish 和 Squid 是专业的 cache 服务，Ngnix 需要第三方模块支持；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Varnish 采用内存型缓存，避免了频繁在内存、磁盘中交换文件，性能比 Squid 高；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Varnish 由于是内存 cache，所以对小文件如 css、js、小图片的支持很棒，后端的持久化缓存可以采用的是 Squid 或 ATS；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Squid 功能全而大，适合于各种静态的文件缓存，一般会在前端挂一个 HAProxy 或 Ngnix 做负载均衡跑多个实例；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Nginx 采用第三方模块 ncache 做的缓冲，性能基本达到 Varnish，一般作为反向代理使用，可以实现简单的缓存。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、进程内缓存&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;进程内缓存是指应用内部的缓存，标准的分布式系统，一般有多级缓存构成。本地缓存是离应用最近的缓存，一般可以将数据缓存到硬盘或内存。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;常见的本地缓存实现方案：HashMap、Guava Cache、Caffeine、Ehcache。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;3.1 ConcurrentHashMap&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;最简单的进程内缓存可以通过 JDK 自带的 HashMap 或 ConcurrentHashMap 实现。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;适用场景：不需要淘汰的缓存数据。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缺点：无法进行缓存淘汰，内存会无限制的增长。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.2 LRUHashMap&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;可以通过继承 LinkedHashMap 来实现一个简单的 LRUHashMap。重写 removeEldestEntry 方法，即可完成一个简单的最近最少使用算法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;锁竞争严重，性能比较低。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不支持过期时间。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;不支持自动刷新。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.3  Guava Cache&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;解决了LRUHashMap 中的几个缺点。Guava Cache 采用了类似 ConcurrentHashMap 的思想，分段加锁，减少锁竞争。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Guava Cache 对于过期的 Entry 并没有马上过期(也就是并没有后台线程一直在扫)，而是通过进行读写操作的时候进行过期处理，这样做的好处是避免后台线程扫描的时候进行全局加锁。直接通过查询，判断其是否满足刷新条件，进行刷新。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.4  Caffeine&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Caffeine 实现了 W-TinyLFU(LFU + LRU 算法的变种)，其命中率和读写吞吐量大大优于 Guava Cache。其实现原理较复杂，可以&lt;a target=&quot;_blank&quot; href=&quot;https://juejin.cn/post/6844903660653117447#comment&quot; textvalue=&quot;参考你应该知道的缓存进化史&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;参考你应该知道的缓存进化史&lt;/a&gt;。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.5 Ehcache&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;EhCache 是一个纯 Java 的进程内缓存框架，具有快速、精干等特点，是 Hibernate 中默认的 CacheProvider。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;快速、简单;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;支持多种缓存策略：LRU、LFU、FIFO 淘汰算法；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;缓存数据有两级：内存和磁盘，因此无需担心容量问题；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;缓存数据会在虚拟机重启的过程中写入磁盘；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可以通过 RMI、可插入 API 等方式进行分布式缓存；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;具有缓存和缓存管理器的侦听接口；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;支持多缓存管理器实例，以及一个实例的多个缓存区域；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;提供 Hibernate 的缓存实现。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.6 进程内缓存对比&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;常用进程内缓存技术对比：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;340&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5877502944640753&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFty1y6mRsm9kwvAyrPuwQSoajLA97CwMauXsASQA8LPUZxug5yZ7iawIgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;849&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;总结一下：如果不需要淘汰算法则选择 ConcurrentHashMap，如果需要淘汰算法和一些丰富的 API，推荐选择。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、分布式缓存&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;分布式缓存解决了进程内缓存最大的问题：如果应用是分布式系统，节点之间无法共享彼此的进程内缓存。&lt;span&gt;分布式缓存的应用场景：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;缓存经过复杂计算得到的数据。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;缓存系统中频繁访问的热点数据，减轻数据库压力。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不同分布式缓存的实现原理往往有比较大的差异。本文主要针对 Memcached 和 Redis 进行说明。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.1 Memcached&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Memcached 是一个高性能，分布式内存对象缓存系统，通过在内存里维护一个统一的巨大的 &lt;span&gt;Hash&lt;/span&gt; 表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;简单的说就是：将数据缓存到内存中，然后从内存中读取，从而大大提高读取速度。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;4.1.1 Memcached 特性&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;4.1.2 Memcached 工作原理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;1）内存管理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Memcached 利用 slab allocation 机制来分配和管理内存，它按照预先规定的大小，将分配的内存分割成特定长度的内存块，再把尺寸相同的内存块分成组，数据在存放时，根据键值 大小去匹配 slab 大小，找就近的 slab 存放，所以存在空间浪费现象。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这套内存管理效率很高，而且不会造成内存碎片，但是它最大的缺点就是会导致空间浪费。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）缓存淘汰策略&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Memcached 的缓存淘汰策略是 LRU + 到期失效策略。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当你在 Memcached 内存储数据项时，你有可能会指定它在缓存的失效时间，默认为永久。当 Memcached 服务器用完分配的内时，失效的数据被首先替换，然后是最近未使用的数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在 LRU 中，Memcached 使用的是一种 Lazy Expiration 策略：Memcached 不会监控存入的 key/vlue 对是否过期，而是在获取 key 值时查看记录的时间戳，检查 key/value 对空间是否过期，这样可减轻服务器的负载。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3）分区&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Memcached 服务器之间彼此不通信，它的分布式能力是依赖客户端来实现。具体来说，就是在客户端实现一种算法，根据 key 来计算出数据应该向哪个服务器节点读/写。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而这种选取集群节点的算法常见的有三种：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.2 Redis&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Redis 是一个开源（BSD 许可）的，基于内存的，多数据结构存储系统。可以用作数据库、缓存和消息中间件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Redis 还可以使用客户端分片来扩展写性能。内置了 复制（replication），LUA 脚本（Lua scripting），LRU 驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis 哨兵（Sentinel）和自动分区（Cluster）提供高可用性（high availability）。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;4.2.1 Redis 特性&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;201&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;volatile-lru&lt;/strong&gt;：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;volatile-ttl &lt;/strong&gt;：从已设置过期时间的数据集中挑选将要过期的数据淘汰；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;volatile-random&lt;/strong&gt;：从已设置过期时间的数据集中任意选择数据淘汰；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;allkeys-lru&lt;/strong&gt;：从所有数据集中挑选最近最少使用的数据淘汰；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;allkeys-random&lt;/strong&gt;：从所有数据集中任意选择数据进行淘汰；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;noeviction&lt;/strong&gt; ：禁止驱逐数据。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;提供两种持久化方式 - RDB 和 AOF。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过 Redis cluster 提供集群模式。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;4.2.2 Redis 原理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;1）缓存淘汰&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis 有两种数据淘汰实现；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）分区&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3）主从复制&lt;/strong&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;174&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;完整重同步&lt;/strong&gt;（full resychronization） - 用于初次复制。执行步骤与 SYNC 命令基本一致。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;部分重同步&lt;/strong&gt;（partial resychronization） - 用于断线后重复制。如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只需接收并执行这些写命令，即可将主从服务器的数据库状态保持一致。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4）数据一致性&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.3  分布式缓存对比&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;不同的分布式缓存功能特性和实现原理方面有很大的差异，因此他们所适应的场景也有所不同。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;95&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.16484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtyicZQSWfYwFXlF57YX4OpaqoO9wzrCuJKPrtBhTnAP4Nicica79UrXj0iaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这里选取三个比较出名的分布式缓存（MemCache，Redis，Tair）来作为比较：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;242&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.41813898704358066&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtyEXK2WQ488siamOyMcia9c5C6XSxBl3sNXNEmWs2N3ykTiam3iamVYdOJuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;849&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;MemCache&lt;/strong&gt;：只适合基于内存的缓存框架；且不支持数据持久化和容灾。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Redis&lt;/strong&gt;：支持丰富的数据结构，读写性能很高，但是数据全内存，必须要考虑资源成本，支持持久化。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Tair&lt;/strong&gt;：支持丰富的数据结构，读写性能较高，部分类型比较慢，理论上容量可以无限扩充。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;总结：如果服务对延迟比较敏感，Map/Set 数据也比较多的话，比较适合 Redis。如果服务需要放入缓存量的数据很大，对延迟又不是特别敏感的话，那就可以选择 Memcached。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、多级缓存&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.1 整体缓存框架&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;通常，一个大型软件系统的缓存采用多级缓存方案：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;278&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.48125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtyEELHaavtTEhnoTRJxcOYWqAicciaDZFop5TQiamRhS7FVeEMOHkTYic00A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;请求过程：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;浏览器向客户端发起请求，如果 CDN 有缓存则直接返回；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果 CDN 无缓存，则访问反向代理服务器；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果反向代理服务器有缓存则直接返回；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果反向代理服务器无缓存或动态请求，则访问应用服务器；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;应用服务器访问进程内缓存；如果有缓存，则返回代理服务器，并缓存数据（动态请求不缓存）；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果进程内缓存无数据，则读取分布式缓存；并返回应用服务器；应用服务器将数据缓存到本地缓存（部分）；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果分布式缓存无数据，则应用程序读取数据库数据，并放入分布式缓存；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.2 使用进程内缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如果应用服务是单点应用，那么进程内缓存当然是缓存的首选方案。对于进程内缓存，其本来受限于内存的大小的限制，以及进程缓存更新后其他缓存无法得知，所以一般来说进程缓存适用于:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这种方案存在以下问题：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.3 使用分布式缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如果应用服务是分布式系统，那么最简单的缓存方案就是直接使用分布式缓存。&lt;span&gt;其应用场景如图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;567&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.9809220985691574&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtyXVxSdRPbjQ3rpicCIYf2icAbUVZdaAsuKsugfX86sqtc64hrLB3FGIEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;629&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Redis 用来存储热点数据，如果缓存不命中，则去查询数据库，并更新缓存。&lt;span&gt;这种方案存在以下问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.4 使用多级缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;单纯使用进程内缓存和分布式缓存都存在各自的不足。如果需要更高的性能以及更好的可用性，我们可以将缓存设计为多级结构。将最热的数据使用进程内缓存存储在内存中，进一步提升访问速度。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个设计思路在计算机系统中也存在，比如 CPU 使用 L1、L2、L3 多级缓存，用来减少对内存的直接访问，从而加快访问速度。一般来说，多级缓存架构使用二级缓存已可以满足大部分业务需求，过多的分级会增加系统的复杂度以及维护的成本。因此，多级缓存不是分级越多越好，需要根据实际情况进行权衡。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一个典型的二级缓存架构，可以使用进程内缓存（如：Caffeine/Google Guava/Ehcache/HashMap）作为一级缓存；使用分布式缓存（如：Redis/Memcached）作为二级缓存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;5.4.1 多级缓存查询&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;612&quot; data-backw=&quot;578&quot; data-ratio=&quot;1.0585683297180044&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFty5dhCH92Ldn6I0qenjQySsWum1jkibRPVJuic8lmNOEia64HJ3YfnYRB1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;922&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;多级缓存查询流程如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;5.4.2 多级缓存更新&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对于 L1 缓存，如果有数据更新，只能删除并更新所在机器上的缓存，其他机器只能通过超时机制来刷新缓存。超时设定可以有两种策略:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;设置成写入后多少时间后过期；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;设置成写入后多少时间刷新。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于 L2 缓存，如果有数据更新，其他机器立马可见。但是，也必须要设置超时时间，其时间应该比 L1 缓存的有效时间长。&lt;span&gt;为了解决进程内缓存不一致的问题，设计可以进一步优化；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;405&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtyqZ7ZgCgtHDE3cMEACcd83kDoO3ichSdvuSPpJ65gCdiaEoaicLpCBLGWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;通过消息队列的发布、订阅机制，可以通知其他应用节点对进程内缓存进行更新。使用这种方案，即使消息队列服务挂了或不可靠，由于先执行了数据库更新，但进程内缓存过期，刷新缓存时，也能保证数据的最终一致性。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;六、缓存问题&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;6.1 缓存雪崩&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存雪崩是指缓存不可用或者大量缓存由于超时时间相同在同一时间段失效，大量请求直接访问数据库，数据库压力过大导致系统雪崩。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;举例来说，对于系统 A，假设每天高峰期每秒 5000 个请求，本来缓存在高峰期可以扛住每秒 4000 个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000 个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没有采用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解决缓存雪崩的主要手段如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;增加缓存系统可用性（事前）&lt;/strong&gt;。例如：部署 Redis Cluster（主从+哨兵），以实现 Redis 的高可用，避免全盘崩溃。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;采用多级缓存方案（事中）&lt;/strong&gt;。例如：本地缓存（Ehcache/Caffine/Guava Cache） + 分布式缓存（Redis/ Memcached）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;限流、降级、熔断方案&lt;/strong&gt;（事中），避免被流量打死。如：使用 Hystrix 进行熔断、降级。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;缓存如果支持&lt;strong&gt;持久化&lt;/strong&gt;，可以在恢复工作后恢复数据（事后）。如：Redis 支持持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上面的解决方案简单来说，就是多级缓存方案。系统收到一个查询请求，先查本地缓存，再查分布式缓存，最后查数据库，只要命中，立即返回。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解决缓存雪崩的辅助手段如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;6.2 缓存穿透&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存穿透是指：查询的数据在数据库中不存在，那么缓存中自然也不存在。所以，应用在缓存中查不到，则会去查询数据库。当这样的请求多了后，数据库的压力就会增大。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;解决缓存穿透，一般有两种方法：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1）缓存空值&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于返回为 NULL 的依然缓存，对于抛出异常的返回不进行缓存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.5835095137420718&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtyxQnpuZxFgzLpeDup59ZN9XLZlMqoXS2UI7NF0Hj185hAUcpZlHW1uw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;473&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;采用这种手段的会增加我们缓存的维护成本，需要在插入缓存的时候删除这个空缓存，当然我们可以通过设置较短的超时时间来解决这个问题。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2）过滤不可能存在的数据&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.5483193277310925&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtylc4NiaR6gRAtojMPBV1eM7gFNZaHHXyoMMWQvZVnsp0LSrUvQPGVGrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;制定一些规则过滤一些不可能存在的数据。可以使用布隆过滤器（针对二进制操作的数据结构，所以性能高），比如你的订单 ID 明显是在一个范围 1-1000，如果不是 1-1000 之内的数据那其实可以直接给过滤掉。&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;193&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;针对于一些恶意攻击，攻击带过来的大量 key 是不存在的，那么我们采用第一种方案就会缓存大量不存在 key 的数据。此时我们采用第一种方案就不合适了，我们完全可以先对使用第二种方案进行过滤掉这些 key。针对这种 key 异常多、请求重复率比较低的数据，我们就没有必要进行缓存，使用第二种方案直接过滤掉。而对于空数据的 key 有限的，重复率比较高的，我们则可以采用第一种方式进行缓存。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;6.3 缓存击穿&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存击穿是指，热点数据失效瞬间，大量请求直接访问数据库。例如，某些 key 是热点数据，访问非常频繁。如果某个 key 失效的瞬间，大量的请求过来，缓存未命中，然后去数据库访问，此时数据库访问量会急剧增加。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了避免这个问题，我们可以采取下面的两个手段:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;6.4 小结&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;上面逐一介绍了缓存使用中常见的问题。这里，从发生时间段的角度整体归纳一下缓存问题解决方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;事前&lt;/strong&gt;：Redis 高可用方案（Redis Cluster + 主从 + 哨兵），避免缓存全面崩溃。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;事中&lt;/strong&gt;：（一）采用多级缓存方案，本地缓存（Ehcache/Caffine/Guava Cache） + 分布式缓存（Redis/ Memcached）。（二）限流 + 熔断 + 降级（Hystrix），避免极端情况下，数据库被打死。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;事后&lt;/strong&gt;：Redis 持久化（RDB+AOF），一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;分布式缓存 Memcached ，由于数据类型不如 Redis 丰富，并且不支持持久化、容灾。所以，一般会选择 Redis 做分布式缓存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;七、缓存策略&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;7.1 缓存预热&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存预热是指系统启动后，直接查询热点数据并缓存。这样就可以避免用户请求的时候，先查询数据库，然后再更新缓存的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解决方案：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;7.2 如何缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;7.2.1 不过期缓存&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;缓存更新模式：&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;开启事务；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;写 SQL；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;提交事务；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;写缓存；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不要把写缓存操作放在事务中，尤其是写分布式缓存。因为网络抖动可能导致写缓存响应时间很慢，引起数据库事务阻塞。如果对缓存数据一致性要求不是那么高，数据量也不是很大，可以考虑定期全量同步缓存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这种模式存在这样的情况：存在事务成功，但缓存写失败的可能。但这种情况相对于上面的问题，影响较小。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;7.2.2 过期缓存&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;采用懒加载。对于热点数据，可以设置较短的缓存时间，并定期异步加载。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;7.3 缓存更新&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;一般来说，系统如果不是严格要求缓存和数据库保持一致性的话，尽量不要将读请求和写请求串行化。串行化可以保证一定不会出现数据不一致的情况，但是它会导致系统的吞吐量大幅度下降。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一般来说缓存的更新有两种情况:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;先删除缓存，再更新数据库；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;先更新数据库，再删除缓存；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;97&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;为什么是删除缓存，而不是更新缓存呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;你可以想想当有多个并发的请求更新数据，你并不能保证更新数据库的顺序和更新缓存的顺序一致，那就会出现数据库中和缓存中数据不一致的情况。所以一般来说考虑删除缓存。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于一个更新操作简单来说，就是先去各级缓存进行删除，然后更新数据库。&lt;span&gt;这个操作有一个比较大的问题，在对缓存删除完之后，有一个读请求，这个时候由于缓存被删除所以直接会读库，读操作的数据是老的并且会被加载进入缓存当中，后续读请求全部访问的老数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.2846580406654344&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtyeLibVGWQibiciaWia5xaR1wt5bohatPaf9GfialNMlWPlRmEeegdCYQzYomg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;541&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对缓存的操作不论成功失败都不能阻塞我们对数据库的操作，那么很多时候删除缓存可以用异步的操作，但是先删除缓存不能很好的适用于这个场景。先删除缓存也有一个好处是，如果对数据库操作失败了，那么由于先删除的缓存，最多只是造成 Cache Miss。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1）先更新数据库，再删除缓存&lt;/strong&gt;（注：更推荐使用这种策略）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果我们使用更新数据库，再删除缓存就能避免上面的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是同样的引入了新的问题：假设执行更新操作时，又接收到查询请求，此时就会返回缓存中的老数据。更麻烦的是，如果数据库更新操作执行失败，则缓存中可能永远是脏数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）应该选择哪种更新策略&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过上面的内容，我们知道，两种更新策略都存在并发问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;但是建议选择先更新数据库，再删除缓存，因为其并发问题出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且同时有一个并发写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果需要数据库和缓存保证强一致性，则可以通过 2PC 或 Paxos 协议来实现。但是 2PC 太慢，而 Paxos 太复杂，所以如果不是非常重要的数据，不建议使用强一致性方案。更详细的分析可以参考：&lt;a target=&quot;_blank&quot; href=&quot;https://www.cnblogs.com/rjzheng/p/9041659.html&quot; textvalue=&quot;分布式之数据库和缓存双写一致性方案解析&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;分布式之数据库和缓存双写一致性方案解析&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;八、总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;最后，通过一张思维导图来总结一下本文所述的知识点，帮助大家对缓存有一个系统性的认识。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;247&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.4265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtyczlLSaLVPgEsh7ick39BQ7S9aPzrtsicrKZ4Pv1ON7l8p9GP8WICZo8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;九、参考资料&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;https://book.douban.com/subject/25723064/&quot; textvalue=&quot;《大型网站技术架构：核心原理与案例分析》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;《大型网站技术架构：核心原理与案例分析》&lt;/a&gt;&lt;/p&gt;&lt;p&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;https://juejin.cn/post/6844903660653117447&quot; textvalue=&quot;你应该知道的缓存进化史&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;你应该知道的缓存进化史&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;https://juejin.cn/post/6844903665845665805&quot; textvalue=&quot;如何优雅的设计和使用缓存？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;如何优雅的设计和使用缓存？&lt;/a&gt;&lt;/p&gt;&lt;p&gt;4、&lt;a target=&quot;_blank&quot; href=&quot;https://www.jianshu.com/p/73ce0ef820f9&quot; textvalue=&quot;理解分布式系统中的缓存架构(上)&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;理解分布式系统中的缓存架构(上)&lt;/span&gt;&lt;/a&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;5、&lt;a target=&quot;_blank&quot; href=&quot;https://tech.meituan.com/2017/03/17/cache-about.html&quot; textvalue=&quot;缓存那些事&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;缓存那些事&lt;/a&gt;&lt;/p&gt;&lt;p&gt;6、&lt;a target=&quot;_blank&quot; href=&quot;https://www.cnblogs.com/rjzheng/p/9041659.html&quot; textvalue=&quot;分布式之数据库和缓存双写一致性方案解析&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;分布式之数据库和缓存双写一致性方案解析&lt;/span&gt;&lt;/a&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:203.title1&quot;&gt;&lt;p&gt;猜你喜欢&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>562cc9a42b9444c5bd359425cdcb2153</guid>
<title>Go 内存泄漏排查实战</title>
<link>https://toutiao.io/k/6dmhylq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;例1：&lt;/span&gt;&lt;span&gt;Goroutine 泄漏&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;现象&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NumGoroutine 指标持续上涨，且低峰期未下降，判断出现了 Goroutine 泄漏现象。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2786885245901639&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqZQ2cxK3UYReXcgiaxYbtpV8s9j5x5AtuZzX3UcDicNV8at2I9nCfxwgczicyzhZ5GJMnbPd6YOVsrIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;排查&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过访问线上服务 pprof 暴露出来的 HTTP 接口，拿到当前所有协程的堆栈信息；curl http://「ip:port」/debug/pprof/goroutine?debug=2&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5887978142076503&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqZQ2cxK3UYReXcgiaxYbtpV8icd5vibqpaTVQ3BjDwYVCFTbibl5dyTic9pl88SDUS9mQpEzQdVqiam9odQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;发现存在大量存活时间超过上千分钟的 Goroutine，观察堆栈疑似是 http 连接未释放导致，通过对下图 net.sockets.tcp.inuse（正在使用的tcp socket数量）指标的观察进行了进一步的确认；&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28825136612021857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqZQ2cxK3UYReXcgiaxYbtpV8ZPe7BMpAHYgqfwiax3ghjZ1YVKNgJSE17lzNOIogZPxEXJFUN9BUy9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;结论&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;http&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面以本次 case http 服务为例，做简单介绍：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;上游服务作为客户端使用了 http1.1 并且将连接设置为 keepalive；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本服务作为服务端未设置 idletimeout 与 readtimeout；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当这两种情况同时发生时，如果上游持有对本服务的连接不进行释放，那么服务端会一直维持这个连接的存在，不进行回收，进而导致协程泄漏；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;client&lt;/strong&gt;上游客户端可能为 GO、Java 等，以下为 GO 语言 http 客户端的空闲连接超时设置；&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2398843930635838&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqZQ2cxK3UYReXcgiaxYbtpV8x2ssG80ydbST6eeNHLbe4VSEE5VGevYlbZCcNOTUFEXLI9pHzmuf4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;692&quot;/&gt;&lt;strong&gt;server&lt;/strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23319027181688126&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqZQ2cxK3UYReXcgiaxYbtpV88f4Xia4hm4fJOk6ibvSxm959dYMJibU6qAV4lpmNYZ09zsP4PfiaCGu7Lg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;699&quot;/&gt;&lt;strong&gt;解决&lt;/strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18442622950819673&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqZQ2cxK3UYReXcgiaxYbtpV8KAq6DOmrqEy3J7vOhI5CAJgOXtoaB5ibChic3gYTJKW4ab4qgz73WnYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;建议启动 http server 尽量用后者，前者虽然简单，但是服务不够健壮；&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;thrift&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;server&lt;/strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24180327868852458&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqZQ2cxK3UYReXcgiaxYbtpV86F1r18JxHIu80QPrH76atCpqiacozj2ptMOVDeZibzXWaf8zm6SlLHsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.19672131147540983&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqZQ2cxK3UYReXcgiaxYbtpV8Aj1QOpSTRVnUMxeBeGaIFjxQ5C0ugiaGdwHqQafMf4sqY3ymR80UkIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Tips&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的一点是，这个 Goroutine 泄漏问题不止在 http 下会发生，在 thrift、grpc 中也是同样的道理，如果服务端不对连接设置 timeout，某些情况下就会被上游拖死。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Reference&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一起 goroutine 泄漏问题的排查&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例2：&lt;/span&gt;&lt;span&gt;内存居高不下&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;现象&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存使用量（mem.rss）居高不下，且低峰期未下降，怀疑发生了内存泄漏现象；&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3975409836065574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqZQ2cxK3UYReXcgiaxYbtpV81rhgxEMichNGXst0uM1Ut4bGGErftqibrXzZAg5BUTdUCRtAICqGTu7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;排查&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;刚开始怀疑时内存泄漏，但是抓取 pprof heap 图观察后，未发现泄露问题，且内存分配符合预期；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发现内存使用虽然居高不下，但未呈上涨趋势，因此修改关键字为“go 内存占用居高不下”，发现有相同问题；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;结论&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题来自于 GO 在将内存归还给操作系统时的内存释放策略，详情见官方 &lt;span&gt;issues&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;，以下做简单介绍。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;GO 内存释放策略&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（此节内容整理自 &lt;span&gt;压测后go服务内存暴涨&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同策略的释放机制&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;MADV_DONTNEED：内核将会在合适的时机去释放内存，但进程的 RSS（常驻内存）将会立即减少。如果再次申请内存，内核会重新分配一块新的空间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MADV_FREE：只能在 linux 内核版本 4.5 以上才能使用，此操作理论上只是打了一个标记位，只有在内核感觉到内存压力的时候才会将这些打标记的内存回收掉，分配给其他进程使用。这个策略下进程的 RSS 不会立即减少。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同策略的实际差别&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;理论上 MADV_FREE 效率要高一些，通过在页表中做标记的方式，延迟内存的分配和回收，可以提高内存管理的效率，毕竟内存的回收和分配都是会消耗系统性能的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;导致的 RSS 指标变化
MADV_DONTNEED 会导致进程 RSS 会有明显的下降；MADV_FREE 会导致进程 RSS 平稳在高峰，不会得到立即释放；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同 GO 版本的释放策略&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在 GO1.12 之前，默认均选择的 MADV_DONTNEED 策略进行内存回收；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 GO1.12~GO1.15，官方默认选择 MADV_FREE 策略进行内存回收；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 GO1.16 及之后，又改回了 MADV_DONTNEED 策略进行回收内存。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;在 GO1.12~GO1.15 且内核版本 4.5 以上，mem.rss 指标已经无法准确观测服务内存占用；&lt;/strong&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解决方法&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;不解决，对程序性能有利，但是会降低一些可观测性；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;以下任一方法可以解决，但会损失一定性能
把 export GODEBUG=madvdontneed=1 写进服务 control.sh 脚本；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;升级 GO 版本至 1.16 及以上；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;一起 goroutine 泄漏问题的排查: &lt;span&gt;https://zhuanlan.zhihu.com/p/100740270&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;issues: &lt;span&gt;https://github.com/golang/go/issues/42330&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;压测后go服务内存暴涨: &lt;span&gt;http://soiiy.com/go/17114.html&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span&gt;&lt;strong&gt;福利&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span/&gt;&lt;span&gt;我为大家整理了一份&lt;/span&gt;&lt;span&gt;从入门到进阶的Go学习资料礼包&lt;/span&gt;&lt;span&gt;，包含学习建议：入门看什么，进阶看什么。&lt;/span&gt;&lt;span&gt;关注公众号 「polarisxu」，回复 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;ebook&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 获取；还可以回复「&lt;strong&gt;进群&lt;/strong&gt;」，和数万 Gopher 交流学习。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UWba2ryLMqm8cgtrMXjG1BLGg46vQNmUompBL02uYYwic9RicPbCnlKdZiacBF5Wv6RLgmGIqnBnwuWyP82ibYusiag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7ad9e74da4a2ab152030830fc291f410</guid>
<title>深度解密（三）：OpenYurt边缘容器架构与原理</title>
<link>https://toutiao.io/k/r0ac2aw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;巨子嘉&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;juzijia-club&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;容器，微服务及开源产品在大企业中的平台产品化建设之路&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cb0a51d8ebddc6b71980236f4745b12e</guid>
<title>「码农周刊 VIP 会员专属邮件周报」每周五发送，赶紧上车吧！</title>
<link>https://toutiao.io/k/5tfu473</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>31c8998ea53315048eb1848ff0355d13</guid>
<title>终端新玩法：“零代码”的剧本式引导</title>
<link>https://toutiao.io/k/jst3urb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;48&quot; data-ratio=&quot;0.10078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUrXicw2VXTQTVVN5yxXWEacdY1ZdxTH195Pgibtib8EENJRMia3tzEnyVfgyfAgRibMssKqwlE186TLSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总第500&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2022年 第017篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;img border=&quot;0&quot; class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;93&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;93&quot; data-ratio=&quot;0.9966329966329966&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVLR21NicmyQxcmiaqQ2KOJJj2JLwgJL4KSbo7CcuMF1hLf4xFjGQiaDRhSPyERxWGChWYP47Oc4sKGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;594&quot; data-width=&quot;100%&quot; opacity=&quot;&quot; title=&quot;undefined&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; data-style=&quot;text-align: left; font-size: 14px; color: inherit;&quot;&gt;&lt;section&gt;&lt;span&gt;App引导是端上做心智建设的重要手段，我们尝试了“剧本式”思维获得了较好效果。在想法落地时，相关研发工作量较大，而且终端技术栈多样化，需要做到“零代码”和“技术栈无关”。最终我们通过“图像匹配”与“标准协议”等核心方案实现了突破。本文将介绍该项目的思考过程，并会对关键技术方案进行剖析和解读，希望能给从事相关开发工作的同学以启发。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;现状&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;目标与挑战&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;整体设计&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;部分技术方案剖析&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;基于视觉智能的区域定位方案&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;保证任务执行的健壮性&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;零代码完成剧本创作与编辑&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;阶段成果&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;总结与展望&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;互联网行业节奏偏快，App 的更新愈发频繁，如何让用户跟上更新节奏，理解产品功能，完成认知迭代，是业务发展中不可忽视的一环。同时“低代码/零代码”的理念也逐步被大众认可，相关调研报告指出“低代码/零代码”可以加速企业的数字化转型。以美团到家事业群为例，在宅经济再度升温后，即时配送应用的增长速度高于其他配送时长的应用。大量新用户的涌入既是机遇，也是挑战。目前美团到家事业群已经涵盖了医药、团餐、闪购、跑腿、团好货、无人配送等 10+ 业务线。新的商业模式意味着新领域的尝试，主业务外卖平均数日也会上线新的功能模块，这些都需要关注用户心智建设与效率提升。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现状&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;在提升用户心智，获得服务认同方面，业界内也做了很多尝试，包括丰富多样的轻交互，也有“保姆式”的游戏引导教学。这些实现方式归结到技术层面，都是 App 中的功能引导，它可以让用户在短时间内快速了解产品特色以及产品使用方式。相对于 “广告投放”、“口号传播”、“地推介绍”等传统方案，App 中的功能引导，具备成本低、覆盖准、可复用等特点。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;175&quot; data-ratio=&quot;0.31399317406143346&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUJpAh67zpRGics7fLRzSh8ucqjkpTM7FfapXVQQeVQdGvyOTRKAMlTXnSCBHJfeZmFp0XjzAmSMQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1758&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;常见的功能引导&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;App 功能引导是用户心智建设的“敲门砖”，只有让用户熟悉平台操作、了解产品特色作为前提，才能进一步借助情感化、场景识别、运营技巧等手段来做用户心智建设。随着 App 功能的不断迭代，在用户中逐渐出现了“用不明白”的现象，这个现象在美团外卖商家客户端尤为突出。作为商家生产运营的主要工具，客户端承载的业务功能复杂多样，设置项更是品类繁杂，如果商家用不明白，就会对整个运营体系造成非常不利的影响。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了让商户“用得明白”，2021 年第一季度，美团外卖商家端在功能引导类需求层面耗费了大量人力，平台产品侧重点对商家进行了扶持，并试点了“情感化引导”等项目，虽然业务效果取得了正向收益，但由于后续的研发估时较大，空有想法却难以落地。类似的营销、广告、商品、订单等业务也由于快速迭代，也需要配套生产一系列产品功能的引导需求，也因为人力问题而一直处于积压状态。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;144&quot; data-ratio=&quot;0.258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUJpAh67zpRGics7fLRzSh8uGCYTpf4HOfqWygT6zeW3f7WZV9LTzP4mlwBX5aLaqI1OFOWsP9svAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;部分引导类需求&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;目标与挑战&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;基于上述背景与现状，我们迫切需要提供一种解决方案，让业务方可以更快捷地落地自己的想法，在控制好成本的情况下，更好地建设用户心智。同时，解决目前积压的业务任务，包括但不限操作教学、功能介绍、情感化、严肃化等等场景。于是 ASG（&lt;/span&gt;&lt;span&gt;Application Scripted Guidance&lt;/span&gt;&lt;span&gt;） 剧本式引导项目就应运而生了。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;项目目标&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;我们的项目目标是搭建一套好用的剧本式引导工具，即便是非技术同学也能独立完成生产与投放，并且相比传统方案的成本更低、效果更好，目前主要应用在“操作引导”与“心智建设”等场景。&lt;/span&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;这里的“剧本”怎么理解？就是带入一个实际场景，模拟一个期望达成的目标，带领用户为此目标而进行一系列的操作指引。用户可感受整体流程以及其中的关联与时序关系。也可以理解为，这是一个预先安排好的小节目，一步一步展示给用户，可能需要交互也可能不需要。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;而剧本化的引导方式，之前在游戏类 App 应用比较常见，比如遇到了一个火属性敌人，所以要去武器界面，选中某武器，换上水属性宝石。近两年，剧本化的引导逐步在展示类 App 与工具类 App 中也开始被使用起来。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;此前，美团外卖商家端的“开门营业”、“模拟接单”等引导需求就使用了类似的思想，这种方式更加先进，但开发成本较高，所以导致后续引导类需求的积压。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;收益测算逻辑&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;ASG 剧本式引导项目的收益测算逻辑是“降本增效”，这里的“效” 既指“效率”也指“效果”，结果数据测算公式为：提效倍数 x =（ 1  / ( 1 - 成本缩减比)）*（ 1 + 产品指标增长比），因此目标可拆解为如下两个方向：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;更低的生产成本&lt;/strong&gt;，借助一些端能力和配置能力，通过简易的交互，就可以让产品与运营同学独立上线剧本。“零代码”与“技术栈无关” 作为项目的核心竞争力。我们提供标准化的框架，并通过一些参数与类型的调配来应对不同的需求场景，在大框架中提供有限的定制能力。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;更高的应用效果&lt;/strong&gt;，相比于传统的功能引导，剧本式引导可以更加生动，能够融合更多元素（&lt;/span&gt;&lt;span&gt;不僵硬的语音、恰逢时机的动效、和蔼的IP形象&lt;/span&gt;&lt;span&gt;），从而带来沉浸式的体验，增强用户感知。更加关注与用户的交互/互动，操作后的反馈最好是真实页面的变化，加深用户的理解。时机更加可控，在满足规则后自动触发，后台可筛选特定特征的用户（&lt;/span&gt;&lt;span&gt;比如用不明白的用户&lt;/span&gt;&lt;span&gt;）定向下发剧本引导。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;面临的挑战&lt;/span&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;目前，Flutter/React Native/小程序/PWA等终端技术栈各有各的适用场景，App 大多数为几种技术栈的组合，如何抹平差异，做到技术栈无关？（&lt;/span&gt;&lt;span&gt;即容器无关性 &lt;/span&gt;&lt;a href=&quot;https://tech.meituan.com/2021/11/11/meituan-waimai-containerless-framework.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Containerless&lt;/span&gt;&lt;/a&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;剧本执行的成功率与健壮性如何保证？（&lt;/span&gt;&lt;span&gt;MVP 版 Demo 的成功率仅达到 50%，稳定版目标要达到 99% 以上&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;怎样落实“零代码”的剧本生产方案，以支持产运独立发布？（&lt;/span&gt;&lt;span&gt;之前类似单任务需要研发 20 ~ 50人日&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;整体设计&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;展示形式选择&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;项目主体应该选择基于什么样的形式？我们的思路是先确定“好的效果”，再去尝试在此形式下做到“更低的成本”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“好的效果”自然是期望体现在产品指标上，但是前期，在数据对比上不同的场景落地指标跨度较大，对于不同的形式也难以拉齐标准横向比较。所以我们从“学的越多才能会的越多”的角度推演，通过平台传递的信息能否更多的被用户接受，来衡量最终产品效果。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;78&quot; data-ratio=&quot;0.13877952755905512&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUJpAh67zpRGics7fLRzSh8uLSkOzjaaickCEVz08mGtkicRuwtnonUF8651FV956294LiaZVMPYiajVWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2032&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们选取了一些之前含视频教学的业务数据，平均播放时长比例在 50% ~ 66% 左右，大多数用户没有看完整个视频。我们分析后认为，因为用户理解的速度有慢有快，稍长的视频内容如果吸引力不够大，或不能贴合用户理解的节奏，就很难被看完。同时，视频传播是单向的，缺乏互动，且不是剧本式思路。于是我们与产品商议后，在一些引导需求上试点了基于真实页面开发、带有一定剧本、可交互的引导（&lt;/span&gt;&lt;span&gt;左上角设有常驻按钮，用户可以随时退出引导&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;81&quot; data-ratio=&quot;0.140177690029615&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUJpAh67zpRGics7fLRzSh8uuxOOsic0vjkrlicHjhJMYPYm0ChtGcfPBe4ahAjgf10SN5R5T3HVODiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2026&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;试点的结果符合我们的预期。基于真实页面开发且可交互的引导，的确可以更好地被用户所接受。引导完成步数比例达到 76% ~ 83%，相比于平均，播放时长比例明显更高。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其实，常规的展示形式上还包括图片组，这个基本是强制用户点完才能进入该功能，可以应用于一些建议的引导场景，但对于一些中等复杂度及以上的引导案例，这里的数据就不具备参考意义了。 我们基于一些采集到的数据和基本认知，对以上三类做了一个对比，表格如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;108&quot; data-ratio=&quot;0.18581418581418582&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUySMuhpjs2BBPPz59h6WuIEWic59LnwYJglLnLGLDbmrSUiaSyHOukP5Jp5hhJNvkz1jdYZdFhQILQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2002&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们得到结论是：如果想要拿到更好的效果，想以用户为中心设计一些更能被用户所接受的引导，基于真实页面研发有着明显的优势，但是这么做的缺点是开发成本较高。目前，简易的试点已经获得了不错的提升效果，所以产研同学有信心在引入更多客户端能力与调优后，整体效果还有更大的提升空间。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;方案描述&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;ASG 剧本式引导项目的目标受众是产品运营同学，我们尝试从他们的角度思考了：&lt;strong&gt;怎样才算是一个便捷且高效的“剧本式引导生产与投放工具”？&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;131&quot; data-ratio=&quot;0.225625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUJpAh67zpRGics7fLRzSh8u9gTeOd9VOlBzCqNFaOyPknz0INTyZMnGGE2a0j84778dFjuYUG1hDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;产品运营视角&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如上图所示，我们提供给产品运营同学的交互仅有：录制、编辑、预览、发布等四个步骤，当产品运营同学需要在业务模块上线引导时，只需拟定一个剧本，然后四步即可完成这个“需求”，整个流程几乎不需要研发和设计同学的参与。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在具体的执行方案中，我们对剧本引导进行了模板化的设计编排，将每个引导动作抽象成一个事件，多个事件组合形成一个剧本。同时为保证不同终端的兼容性，我们设计了一套标准且易扩展的协议描述剧本元素，运行时 PC 管理后台和 App 可自动将剧本解析成可执行的事件（&lt;/span&gt;&lt;span&gt;如坐标点击、页面导航、语音播放等&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;核心的功能模块在剧本的执行侧。为了保证更高的应用效果，我们要求引导过程与用户的交互，均操作在真实的业务页面，播放展示的元素也要求是实时计算与绘制的，这对系统性能与准确性提出了更高的要求。系统的全景图如下图所示，由终端侧、管理后台与云服务三个部分组成：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;314&quot; data-ratio=&quot;0.5438311688311688&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUJpAh67zpRGics7fLRzSh8uKcEA1HAX7S82JMJjibXnr4QZUVAYqqbaBBQ9lE6S2FempOQM11ibic9eQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2464&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;系统全景图&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;终端侧&lt;/strong&gt;：包括两个职能，既具备剧本的录制能力，也具备剧本的播放能力，由四个功能模块构成。预处理模块负责剧本的资源下载、协议解析、编解码等操作，是保障剧本成功执行的前置环节；实时计算模块则通过屏幕捕获、特征匹配、图像智能，完成动态获取剧本锚点元素的信息，保证了剧本引导的精准展示，是实现剧本引导技术栈无关的核心环节；任务调度模块主要通过事件队列的实现方式，保证剧本有序、正确的执行；多媒体模块负责语音合成和动效绘制，在特定业务场景为剧本播放提供沉浸式的体验。同时 PC 端在客户端的基础上进行了能力的扩展，对于常见的 React/Vue/Svelte 网页应用都可以低成本地接入和使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;管理后台：&lt;/strong&gt;包括剧本编辑、导入和发布、权限控制、数据看板等功能模块。其中剧本编辑模块，承载了剧本协议的解析、编辑、预览等关键功能，操作界面按功能划分为以下区域：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;事件流控制区域&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：以页面帧的形式展示剧本流程中的事件，提供动态添加与删除、调整页面帧顺序等编辑功能。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;协议配置区域&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：依照剧本的标准协议，通过可视化页面帧配置项，生成满足需要的引导事件；同时提供丰富的物料，满足心智类剧本的情感化创作。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;剧本预览区域&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：支持通过二维码扫描，实现便捷、无差别地效果预览，保证与最终呈现给用户的引导效果一致。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;162&quot; data-ratio=&quot;0.28&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUJpAh67zpRGics7fLRzSh8ubnXfrm6pRHufs3xOyaBKemOFaNQPcMnHrH5GpNuVZpicDDXzPZrGc0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;管理后台&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;云服务：&lt;/strong&gt;依赖美团的底层云服务平台，在剧本编辑完成后，需要资源托管服务、CDN 等进行资源的管理及分发，完成剧本的下发及更新。业务中台在端侧 SDK 和后台策略配置的共同作用下，提供了更细粒度的下发配置，更丰富的触达时机，满足业务侧按时间、城市、账号与门店、业务标签等维度配置的诉求。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;部分技术方案剖析&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基于视觉智能的区域定位方案&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;在引导过程中，需要对关键路径上目标区域设置高亮效果。在技术栈无关的前提下，基本思路是线下截取目标区域，线上运行时全屏截图，通过图像匹配算法，查找目标区域在全屏截图中的位置，从而获得该区域坐标，如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;561&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;248&quot; data-ratio=&quot;0.44222222222222224&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUJpAh67zpRGics7fLRzSh8uSUAW38z4jVHcLGyuGuC1Ve2A6oGdfbuDJhA3Rmg8Oompszs1SckY7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;高亮识别效果&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;整体思路看起简单，但在具体的实践中却面临着诸多的挑战：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;圆角类图标的 UI 元素（&lt;/span&gt;&lt;span&gt;RadioButton 、Switch&lt;/span&gt;&lt;span&gt;）在边缘区域能检测到的特征点过少，导致匹配成功率低。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;小字体的区域，在低分辨率情况下无法检测到足够的特征点，放大分辨率可以提升匹配精度，但是耗时也会成倍增加。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在不提供初始位置的条件下，只能做全图检测和暴力匹配，需要检测和存储的特征点数量太庞大，尤其是复杂画面和高分辨率图像，移动设备上性能和内存开销无法接受。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;终端手机设备屏幕分辨率目前有几十种，算法需要适配多种分辨率。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;端侧部署，对算法库的包大小、性能、内存占用都有要求，例如 OpenCV，即使经过精心的裁剪之后仍然有 10 ~ 15 MB，无法直接集成到线上 App 中。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;经过理论研究与实践试点，最终我们采用的是传统 CV（&lt;/span&gt;&lt;span&gt;Computer Vision&lt;/span&gt;&lt;span&gt;）+ AI 的解决方案，大部分场景可以基于传统 CV 的角点特征检测和匹配得到结果，未命中的则继续通过深度学习网络的检测和跟踪来获取结果。在工程部署方面也做了相应的优化。接下来将详细介绍这个方案的实现。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;图像匹配流程概要&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;图像匹配算法由信息提取、匹配准则两部分组成。根据信息载体的二维结构特征是否保留，匹配算法可分为基于区域的信息匹配与基于特征的信息匹配，如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;350&quot; data-ratio=&quot;0.6059027777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUJpAh67zpRGics7fLRzSh8u4LYBkicnAmZSpCHMcEwicdVuyO0kZWSwyfDiajDlnhnwVszViaXf4rfcXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1152&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图像匹配流程概要&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基于区域的图像匹配方法，采用原始图片或域变化后的图片作为载体，选取最小信息差异区域作为匹配结果，该方法对于图像形变、噪声敏感等处理不佳。而基于特征的图像匹配方法，丢弃了图像二维结构信息，提取图片的纹理、形状、颜色等特征及位置信息描述，进而得到匹配结果。基于特征的算法鲁棒性好、信息匹配步骤速度快、适应性强，应用也更加广泛。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基于传统 CV 特征的图像匹配&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;其实该项目的应用场景，属于典型的 ROI（&lt;/span&gt;&lt;span&gt;Region Of Interesting&lt;/span&gt;&lt;span&gt;）区域检测、定位，传统 CV 算法针对不同的使用场景已经有很多比较成熟的算法，比如轮廓特征、连通区域、基于颜色特征、角点检测等。角点特征是基于中心像素与周围像素亮度差异变化剧烈，且基本不受旋转、缩放、明暗等变化影响的特征点，经典的角点检测有 SIFT、SURF、ORB 等，相关研究业界已经有很多。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;E Karami [5] 等人在 2017 年发表的一份对比研究结果（&lt;/span&gt;&lt;span&gt;如下图所示&lt;/span&gt;&lt;span&gt;）表明：绝大多数情况下，ORB 最快，SIFT 匹配结果最好，ORB 特征点分布集中在图像中心区域，而 SIFT、SURF、FAST 则分布在整张图上。在美团到家的场景下，目标区域可能位于图片的中心、四角等任何位置，所以 ORB 对于边缘区域的目标区域匹配失败的概率会偏大，需要特殊处理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;345&quot; data-ratio=&quot;0.5965&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUJpAh67zpRGics7fLRzSh8uIwmM7LZ2KKl2AN1libaeWZKNcPrcic75sknjgWKOqMgFbRZlZZic7aicIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;(a) SIFT (b) SURF (c) ORB 的匹配结果：不同强度（左）缩放（中）旋转（右）&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;总体来讲，一个效果好的特征检测匹配算法，需要同时具备：尺度不变性、旋转不变性、亮度不变性，这样才能适应更多的应用场景，具有较好的鲁棒性。下面我们以 ORB 为例，来简单阐述一下算法的计算过程（&lt;/span&gt;&lt;span&gt;感兴趣可以查阅更多的相关资料&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;ORB = Oriented FAST + Rotated BRIEF&lt;/strong&gt; （&lt;/span&gt;&lt;span&gt;下文用 OFAST 与 rBRIEF 代替&lt;/span&gt;&lt;span&gt;），ORB 融合了 FAST 特征检测和 BRIEF 特征描述算法，并做了一些改进，即采用改进的 OFAST 特征检测算法，使其具有方向性，并采用具有旋转不变性的 rBRIEF 特征描述子。FAST 和 BRIEF 都是非常快速的特征计算方法，因此 ORB 获得了比较明显的性能提升。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;要想判断一个像素点 p 是不是 FAST 特征点，只需要判断其周围 7x7 邻域内的 16 个像素点中是否有连续 N 个点的灰度值与 p 的差的绝对值超出阈值。此外，FAST 之所以快，是因为首先根据上、下、左、右 4 个点的结果做判断，如果不满足角点条件则直接剔除，如果满足再计算其余 12 个点，由于图像中绝大多数像素点都不是特征点，所以这样做的结果，用深度学习”炼丹师“的话来说，就是“基本不掉点”，且计算时间大大减少。对于相邻的特征点存在重复的问题，可以采用极大值抑制来去除。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;163&quot; data-ratio=&quot;0.2817733990147783&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUJpAh67zpRGics7fLRzSh8ulNlKaialF4E6WIu66xbvlC15vkuL8xfKlfrEfhZ3dCK5TicHXTUicXM0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2030&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;邻域 16 个点的位置（左）；上、下、左、右 4 个点（右）&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;改进后的 OFAST 会针对每个特征点计算一个方向向量。研究表明，通过从亮度中心至几何中心连接的向量作为特征点的方向，会比直方图算法和 MAX 算法有更好的效果。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;198&quot; data-ratio=&quot;0.3429906542056075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUJpAh67zpRGics7fLRzSh8urQYZM6EC5O7NLxBmQ5Oic0N59rMRrq9W7mnGDUyQqqTQkmGdeErN16A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2140&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;OFAST 方向向量的计算&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;ORB 算法的第二步是计算特征描述符。这一步采用的是 rBRIEF 算法，每个特征描述符是仅包含 1 和 0 的长度为 128 - 512 位的向量。得到特征点和特征描述符之后，就可以做特征匹配了。此外，特征匹配算法也比较多，为了简化计算，我们这里采用了 LPM [6]算法。得到筛选后的特征对后，计算它们的外接矩形包围框，反变换到原图坐标系就可以得到目标的区域位置坐标。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基于纯传统 CV 算法测试的结果表明，特征点数量对匹配的召回率有直接影响，特征点较少，召回率偏低无法满足业务需求；特征点超过 10000 点则会严重影响算法性能，尤其是在移动端设备上的性能，高端机型上耗时在 1 秒以上。我们针对目标区域小图和原图设定不同特征点数量，然后做匹配，这样可以兼顾性能和匹配精度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不同配置参数实测的特征点和匹配结果如下图所示，针对大多数图像、文字内容的区域，特征点在 5000 以上，匹配结果不错，但还存在常见区域匹配失败的情况；特征点在 10000 以上，除了一些特殊 Case，大多数场景匹配结果都比较满意。如果不提供目标区域的大概的初始位置（&lt;/span&gt;&lt;span&gt;真实情况&lt;/span&gt;&lt;span&gt;），基本上大多区域需要 10000 ~ 20000 特征点才能匹配，端侧性能就是个问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;234&quot; data-ratio=&quot;0.40449775112443775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUJpAh67zpRGics7fLRzSh8up1dOJNLfhBibJKBg9IibKdG1vZGN3e3eNcgeToSyyrlFPCDOvdhhYgog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3335&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;实测结果：匹配的召回率与特征点数量直接相关&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基于深度学习的图像匹配&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;基于传统 CV 存在的弊端和一些无法解决的问题，我们需要具有更强图像特征表达能力的算法来进行图像匹配。近些年，深度学习算法取得了巨大的突破，同样在图像的特征匹配领域中也取得了较大的成功。在本应用场景中，我们需要算法在全屏截图中快速定位一个子区域的具体位置，即需要一个模型通过一个区域中局部区域的特征快速定位其在全局特征中对应的位置。该问题看似可以使用目标检测的相关算法进行求解，但是一般目标检测算法需要目标的类别/语义信息，而我们这里需要匹配的是目标区域的表观特征。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;针对该问题，我们采用了基于目标检测的图像跟踪算法，即将目标区域视为算法需要跟踪的目标，在全屏截图中找到我们要跟踪的目标。在具体实现过程中，我们使用类似于 GlobalTrack[7] 的算法，首先会提取目标区域对应的特征，并使用目标区域的特征来对全屏截图的特征进行调制，并根据调制之后的特征来对目标区域进行定位。并根据移动端计算量受限的特性，我们在 GlobalTrack 的基础上设计了一个单阶段的目标检测器来对该过程进行加速。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;153&quot; data-ratio=&quot;0.26484375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUJpAh67zpRGics7fLRzSh8uYS0tdZLjia6kn4jflh0AvwQciakrSKNP4XuBz8etRorowFzkNnj6ngKw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;GlobalTrack 示意图&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于我们直接使用目标区域的特征来引导目标检测的过程，所以其能够处理更为复杂的目标区域，比如纯文本、纯图像或图标、文字图像混编等，凡是能在 UI 上出现的元素都可能是目标区域，如下图所示的一些示例。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;128&quot; data-ratio=&quot;0.2215&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUJpAh67zpRGics7fLRzSh8uZahVZBUdNUc2ZSa2OWEJthKKm8REOY6gN05MfILueakicZ2RRsnLQPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;目标区域示例与包含不同尺寸类别组合的训练数据&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;结合业务场景，要求针对移动设备上 App UI 画面的任何局部区域做到精确定位。如上述的分析，该问题既可以看作是一个目标检测和匹配的问题，又可以看作是一个目标跟踪问题。同时算法需要能够适配不同内容的 ROI 区域、不同的屏幕分辨率、不同的移动设备。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们选择的方案&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;前文提到，我们采用的是 CV + AI 解决方案，这样的优点是：一方面解决传统 CV 检测无法覆盖全场景的问题；另一方面优化性能，减少移动端设备的耗时。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在工程部署方面，我们采用纯 C 实现检测和匹配算法，并且对 ORB 算法做了一些定制化修改。此外，我们采用多线程、Neon 优化等手段提升性能，从 800 毫秒优化到 100 毫秒左右。最终的版本不依赖 OpenCV 及第三方库，大大减小了算法库的包大小。深度学习模型基于 MTNN 端侧推理引擎获得了最优的推理性能和精度。在中高端机型上，可以启用异构硬件并行加速，CV 与 AI 并行计算，在 CPU 上执行特征检测的计算，同时在 GPU 或 NPU 上执行模型推理，然后做融合，这样可以在不增加 CPU 负载的情况下提升性能和准确率。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;保证任务执行的健壮性&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;任务执行感知&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;传统方案在做开发引导时，我们可以通过函数回调、广播、组件变化等多种方式获取任务执行状态。但在技术栈无关前提下，感知引导过程失败、感知用户执行/点击是否正确，相比之下就比较困难。同时还要精确甄别出错误类型，增加特定步骤的重试方案，尽可能保证剧本的执行通畅，在极少数遇到阻塞是错误时，需要及时确认，上报错误并退出引导，减少对用户的影响。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;136&quot; data-ratio=&quot;0.23586744639376217&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUJpAh67zpRGics7fLRzSh8uqhQFgaxdOENGPGztTDOECXHI674Be0kdfchSO9fnXXc33dab9TOXbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3078&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;任务执行流程图&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先，比较优雅的“黑盒”方案是使用图像相似度对比技术，此能力模型在视觉智能中比较基础，在通过跳转来到目标页面后，会截图与目标特征进行比较，进行快速容错。根据线下的大量测试数据，去除一些极端情况，我们发现在不同的阈值下是有规律的：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;相似度 80% 以上的区间，基本可以确定目标页面准确，受一些角标或图片区块加载的影响没达到更高。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;相似度 60% ~ 80% 的区间，是在一些列表样式或背景图、Banner图有些许差异导致的，可以模糊判定命中（&lt;/span&gt;&lt;span&gt;上报数据但不用上报异常&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;相似度 40% ~ 60% 的区间，大概率遇到了对应模块的 UI 界面改版，或者有局部弹窗，这时就需要进行一些重试策略适时上报异常。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;相似度 40% 以下，基本确定跳转的是错误页面，可以直接终止引导流程，并上报异常。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;254&quot; data-ratio=&quot;0.43952412425644416&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUJpAh67zpRGics7fLRzSh8un15YLicmgjRE6ELkVpFkeyVEiaKfPsFvgsGiaIDTaPr9icmFxicgAsN1DUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3026&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图片相似度部分 Case 实测效果&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同时，我们在端侧也有一些判定规则来辅助图像对比的决策，比如&lt;strong&gt;容器路由 URL 比对&lt;/strong&gt;，当图像对比不匹配但容器路由 URL 准确时，会有一些策略调整并进行重试逻辑。在确认页面准确后，才会进行高亮区域寻找以及后续的绘制逻辑。最后兜底可以通过&lt;strong&gt;超时失败&lt;/strong&gt;的方式自然验证，一个剧本关键帧的完整判定流程，我们设置了 5 秒的超时策略。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关于尺度与旋转不变性&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;为了在尺度上具有更好的健壮性，计算过程首先会对图像做高斯模糊，去除噪声的影响，并且对图像做下采样生成多层图像金字塔，对每一层都做特征检测，所有特征点集合作为检测到的特征点结果输出，参与后续特征匹配计算。为了应对图像旋转的情况，可以加入 rBRIEF，rBRIEF 从给定特征点的 31 x 31 邻域内（&lt;/span&gt;&lt;span&gt;称为一个 Patch&lt;/span&gt;&lt;span&gt;）随机选择一个像素对。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下图展示了采用高斯分布采样随机点对的方法，蓝色正方形像素，是从以关键点为中心的高斯分布中抽取的一个像素，标准偏差 σ；黄色正方形的像素，是随机对中的第二个像素，它是从以蓝色正方形像素为中心的高斯分布中抽取的像素，标准偏差为 σ/2，经验表明，这种高斯选择提高了特征匹配率。当然也有其它选择方式，我们这里就不一一列举了。首先，根据特征点方向向量构造旋转矩阵，并对 N 个点对做旋转变换，使得每个点对与该特征点的主方向一致，然后再根据点对来计算特征向量。因为特征向量的主方向与特征点一致，意味着 rBRIEF 可以在朝着任何角度旋转的图像中检测到相同的特征点。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;141&quot; data-ratio=&quot;0.24477064220183486&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUJpAh67zpRGics7fLRzSh8uHaFJ8GCeNNWCx00MdYUNEiavafP81BTwgndclXCbTFYPIBhHyP6RYCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2725&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图rBRIEF 随机像素对的选择（左）；图像金字塔（右）&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其他容错处理&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;对于页面中存在多个相同或类似元素的场景，不能草率地选择任意一个区域。因此在进行目标区域定位时，我们需要在检索目标区域的基础上，结合目标周围信息，提供一个参考区域。运行时，提供目标区域图像信息及参考区域图像信息，查询到多个目标结果后，再查询参考区域所在位置，通过计算，离参考区域最近的目标区域则为最终目标区域。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于页面中出现的不同技术栈弹窗场景，由于出现时机也不确定，一旦出现，容易对目标区域造成遮挡，影响整个引导流程，需要对各类弹窗进行过滤和拦截。针对 Native 技术栈，我们通过对统一弹窗组件进行拦截，判断执行过程中禁止弹窗弹出，引导过程中业务认为非常重要的弹窗则通过加白处理。在 Flutter 上则采用全局拦截 &lt;/span&gt;&lt;code&gt;&lt;span&gt;NavigatorObserver &lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中的&lt;/span&gt;&lt;code&gt;&lt;span&gt;didPush &lt;/span&gt;&lt;/code&gt;&lt;span&gt; 过程，拦截及过滤 Flutter 的各类 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Widget &lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;Dialog &lt;/span&gt;&lt;/code&gt;&lt;span&gt; 及 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Alert &lt;/span&gt;&lt;/code&gt;&lt;span&gt; 弹窗。关于 Web 上的处理，由于 Web 弹窗业务方比较多，没有特别统一的弹窗规范，特征比较难取；目前是在 Web 容器中注入一段 JavaScript 代码，给部分有弹窗特征和指定类型的组件设置隐藏，考虑到拓展性，JavaScript 代码设置成可动态更新。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于部分页面元素复杂导致加载时间稍长的场景，剧本播放时也会基于录制侧提供的 delayInfo 字段，进行一些延迟判定策略。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基于前面的努力，剧本的执行链路成功率（&lt;/span&gt;&lt;span&gt;如下图所示&lt;/span&gt;&lt;span&gt;）基本可以达到 98% 以上，部分成功率较低的剧本可以根据维度下钻，查询具体的异常原因。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;314&quot; data-ratio=&quot;0.5428994082840237&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUySMuhpjs2BBPPz59h6WuIDicmxia0TY539dlVw8lRNjkdzFgJ6gP0JeMDqYYXQJ5OjuCNW7146I9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1352&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;部分链路指标监控&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;零代码完成剧本创作与编辑&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;把一个剧本的生命周期划分为“生产”和“消费”两个阶段，“生产”阶段对应的是剧本录制完成并上传至管理后台进行编辑的过程，“消费”阶段则对应下发与播放。如果说前两个挑战主要聚焦在“消费”，那么这里的挑战则主要聚焦在“生产”方面。接下来，我们将从“录制端侧赋能”与“标准协议设计”两个方面进行详细的介绍。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;录制端侧赋能&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;集成录制 SDK 在移动端受限于屏幕尺寸，不易进行精细化创作，所以它的定位是进行基础剧本框架的创作与录制。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在此过程中，录制 SDK 首先要记录用户的操作信息和页面的基础信息，信息录入者在使用录制功能时，录制 SDK 会同步记录当前页面信息及与之相对应的音频录入，形成一个关键帧，后续录制以此类推，当所有信息录入完成之后，生成的多个关键帧会组成关键帧序列，结合一些基本信息，形成一个剧本框架，上传至服务器，便于录制者在后台进行精细化的创作。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同时录制 SDK 需要主动推断用户意图，减少录入者编辑。我们将关键帧的录入，按照是否产生页面跳转分为两种类型，对应不同类型，自动生成相异的路径。当录入者的操作产生页面跳转时，录制 SDK 在确定该操作的分类同时，主动将该处的语音输入标记为下一关键帧的描述，以减少录制者的操作。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;录制全程，每个页面的打开时间也被作为关键帧的一部分记录下来，作为参考信息，帮助录入者调整剧本节奏。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;208&quot; data-ratio=&quot;0.36045494313210846&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUJpAh67zpRGics7fLRzSh8u16LWWlHRt3RpNACRAk1TIj7mqGg8E7Fkanp53LgAOjT8O5bu9lbZicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2286&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;剧本录制侧示意图&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;标准协议设计&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;标准协议作为 “零代码” 的基石串联了录制到编辑的整个过程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当前 App 中，操作类引导场景有数十种，我们通过传输模型和视图模型的结合，将核心字段提取，冗余字段剥离。在保证标准化与兼容性的前提下，将数十种场景抽象为四种通用事件类型，为关键帧的编排及业务场景的覆盖提供了便利。对心智类剧本而言，会随着用户的交互操作不断产生新的分支，最终成为一个复杂且冗余的二叉树结构。我们在设计此类协议时，将二叉树节点进行拍平，存储为一个 HashMap，两个关键帧的衔接可以以 id 为标识。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;用户在使用 App 时，在某些需求指引下，会产生心智类和操作类剧本引导交替出现的情况。例如，商家（&lt;/span&gt;&lt;span&gt;用户&lt;/span&gt;&lt;span&gt;）打开推广页面后，出现一个心智类剧本——小袋动画伴随着语音：“老板好，小袋发现您开店 3 个月了，还没有使用过门店推广功能呢，请问您是不会操作还是担心推广效果不明显呢？”屏幕中会伴随两个按钮选择（1）不会操作；（2）担心推广效果。此时，如果用户点击了1，会转向“操作类”剧本，所以我们在设计协议时，要尤为关注两种剧本的衔接。在这里，我们将协议进行了细化，将基础能力协议与展示类协议进行拆分。两种剧本共用一套基础能力协议，防止出现兼容性的问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;140&quot; data-ratio=&quot;0.2423076923076923&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUJpAh67zpRGics7fLRzSh8ugymfAiciaibhqqdoM9WlSQFIvOJicjCrI0hsFkXyRGN4gnE5zfYI85N7EQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1560&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;部分协议节点设计&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;管理后台的编辑器引擎解析剧本协议后，完成内置逻辑的初始化，以及引导剧本中事件关键帧的渲染。编辑器引擎内部基于事件机制实现了可订阅的能力，当关键帧触发插入、编辑、调整顺序等事件时，所有其他的关键帧都可以订阅以上核心事件，实现完整的联动效果。编辑加工后的剧本协议，通过接入美团统一的动态下发平台，实现剧本的灰度、全量、补丁的动态化发布能力。编辑器内建完整的生命周期，在操作的不同阶段暴露完整的事件勾子，支持良好的接入和扩展能力。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;阶段成果&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;能力建设&lt;span&gt;‍&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;figure&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.08843537414966&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/hEx03cFgUsUySMuhpjs2BBPPz59h6WuIpfr62ouWoCzg3Mzzfz4oP5Jab2iaNBdyMPicpAaicQDTrrLGuDMTj6xEw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;588&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;span&gt;我们抽象了如上图两种标准样式的剧本，线上使用较多的是操作引导类剧本，大多是之前积压的任务。目前，我们已经迭代出了一种标准化形态，接入方便，一般在新模块的提测期&lt;/span&gt;&lt;span&gt;间，产运快速为此需求安排操作引导剧本跟随需求同步上线。也可以针对现有复杂模块设置引导，默认藏在 导航栏的 “?” 图标里，在合适的时机进行触发。&lt;/span&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同时，用户心智建设不仅仅是常规的产品操作引导，我们也提供了&lt;strong&gt;心智类剧本&lt;/strong&gt;（&lt;/span&gt;&lt;span&gt;也叫概念类剧本&lt;/span&gt;&lt;span&gt;），可以应用在需要“理念传递”或“概念植入”的场景里。在合适业务场景以拟人化的方式给用户传递平台的制度与规范，让用户更容易接受平台的理念进而遵守经营的规范；比如可以在商家阅读差评时，执行一个情感化剧本（&lt;/span&gt;&lt;span&gt;大概内容为差评是普遍现象，每 xx 条订单就容易产生一条差评，所以不用过于担心，平台也有公正的差评防护与差评申诉规则&lt;/span&gt;&lt;span&gt;）；如果商家出现违规经营，也可以执行一个概念强化的严肃类剧本（&lt;/span&gt;&lt;span&gt;大概内容为平台非常公正且有多重检查措施，不要试图在申诉中上传不实材料侥幸过关&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;值得一提的是，在这个过程中产出的图像特征定位、去Alpha通道的视频动画等能力也完成了技术储备，可以提供给其他场景使用。前文核心技术内容也申请了两项国家发明专利。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;部分业务线上效果&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;新店成长计划，是剧本式引导应用的首个大需求。支撑新店成长计划项目顺利上线，目前的结果非常正向。ASG 支撑了整个项目 78.1% 的引导播放量，单个剧本开发成本 &amp;lt; 0.5d。综合观测指标“商家任务完成度”同比观测周期内，从 18% 提升至 35.7%，其他过程指标也有不同程度的提升。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;超值换购，提供了心智类指引，是指导商家用最优的方式创建换购活动，结合过程数据预估访购率从 4% 提升至 5.5%，活动商家订单渗透率从 2.95% 提升至 4%，均有 35% 左右的涨幅。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;配送信息任务引导，优化配送信息任务整体流程的行动点引导，避免引起商家行为阻塞，降低了用户操作成本与理解成本，提升商家在开门营业阶段满意度，同时提升商家对配送服务的认知度水平。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;...&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;自 2021 年 11 月上线以来，ASG 已经支撑了新店、活动、营销、广告等多个业务，在美团超过 20 个业务场景中进行了落地。总体看来，ASG 剧本式引导相比于传统引导方案，粗略估计的话，可以用约先前 1 / 10 的成本来提升约 20% 的效果。带入之前的结果测算公式，提效倍数（&lt;/span&gt;&lt;span&gt;x = ( 1 /（1 - 90%）) * (1 + 20%) &lt;/span&gt;&lt;span&gt;）就是12倍。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从最终的结果来看，成本的降低，远比效果提升更加明显，所以本文对前者的论述篇幅明显多于后者。目前，在效果提升层面，我们主要是对一些端能力比较基础的组合使用，对于效果提升我们并不担心，业内前沿的创新技术还有很多可以探索的可能，我们也会逐步跟进，使剧本效果更具有同理心、更加沉浸化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;406&quot; data-ratio=&quot;0.7024793388429752&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUJpAh67zpRGics7fLRzSh8uyFbhsEj2TicaFV1hQib26FznE8MBoTevsiaBGedv2HuIpQTHbeoibKsHww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1694&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;99&quot; data-ratio=&quot;0.17130488559059986&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUJpAh67zpRGics7fLRzSh8u6UoAoplo69jT0Aia2iagvoLNSGwE3xhkEGzJOUAXQhXib9cDJ5mRM9Mibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3234&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结与展望&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;本文介绍了美团外卖终端团队在用户心智建设领域的探索与实践。从业务现状与剧本式思维的思考出发，谈到了终端加管理后台的一站式设计，简化剧本接入门槛。后续，我们还谈到了传统 CV 与深度学习在剧本执行上起到的关键作用。整体看来，这个项目是基于终端能力拓展的一次大胆尝试，我们体会业务视角，通过不设限的跨团队的协作，完成对非技术人员的赋能。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;结合目前的阶段性成果，我们验证了之前方向的正确性，下一步我们会继续从“更低的生产成本”与“更高的应用效果”两个角度进行深耕（&lt;/span&gt;&lt;span&gt;例如组合元素剧本的易用性、剧本更新成本优化、引导时机结合规则引擎与意图猜测、折叠与再次唤醒逻辑等&lt;/span&gt;&lt;span&gt;），以支撑更多类似场景的需求。并且，我们欣喜地看到终端的“容器无关性”收益杠杆明显，接下来还有很大的发挥空间。欢迎大家跟我们一起探讨交流。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;作者简介&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;松涛、尚先、成浩、张雪、庆斌等，来自美团到家研发平台/外卖技术部；筱斌、民钦、德榜等，来自美团基础研发平台/视觉智能部。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考文献&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;[1] &lt;/span&gt;&lt;a href=&quot;https://www.data.ai/cn/go/state-of-mobile-2022&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;App Annie. 2022 年移动市场报告&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[2] &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://hbr.org/2021/06/when-low-code-no-code-development-works-and-when-it-doesnt&quot; textvalue=&quot;Google. Flutter arch‍itectural&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;span&gt;HBR. When Low-Code/No-Code Development Works and When It Doesn’t&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[3] &lt;/span&gt;&lt;a href=&quot;https://developers.google.com/speed/webp/docs/compression&quot; data-linktype=&quot;2&quot;&gt;Google. Compression Techniques&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[4] &lt;/span&gt;&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Apple. Quartz 2D Programming Guide&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[5] E. Karami, S. Prasad, M. Shehata &quot;Image Matching Using SIFT, SURF, BRIEF and ORB: Performance Comparison for Distorted Images&quot; Newfoundland Electrical and Computer Engineering Conference,St. johns, Canada, October, 2017&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[6] Jiayi Ma, Ji Zhao, Junjun Jiang, Huabing Zhou, and Xiaojie Guo. &quot;Locality Preserving Matching&quot;, International Journal of Computer Vision, 127(5), pp. 512-531, May 2019.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[7] Huang, Lianghua, et al. Globaltrack: A simple and strong baseline for long-term tracking[C]//Proceedings of the AAAI Conference on Artificial Intelligence. 2020, 34(07): 11037-11044.&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;----------  END  ----------&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;也许你还想看&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;  | &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765882&amp;amp;idx=2&amp;amp;sn=341aabe7b15100e2a5b461f1ef150d0e&amp;amp;chksm=bd1265378a65ec218b8f86117916164e411c263ea820847303d2acad77f47601ab6a00412220&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;美团外卖终端容器无关化研发框架&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765882&amp;amp;idx=2&amp;amp;sn=341aabe7b15100e2a5b461f1ef150d0e&amp;amp;chksm=bd1265378a65ec218b8f86117916164e411c263ea820847303d2acad77f47601ab6a00412220&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;美团外卖终端容器无关化研发框架&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;美团外卖终端容器无关化研发框架&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;  |&lt;/span&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651761029&amp;amp;idx=1&amp;amp;sn=1aee4aa8c6b8e508d25136ab33d1dc5b&amp;amp;chksm=bd1270c88a65f9dea24d2ffaa8c9bd16e48e5018d7ef49291a8dde9ffd05a914aaa35ab04841&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Flutter Web在美团外卖的实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Flutter Web在美团外卖的实践&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;  |&lt;/strong&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651753413&amp;amp;idx=1&amp;amp;sn=e987b6a105d65952de35c86e5f19ba03&amp;amp;chksm=bd1252888a65db9e9aac10fb930f5ad6a2f62b47b6df868c7cb975ebf613650ad3c4b8ade51e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;外卖客户端容器化架构的演进&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;外卖客户端容器化架构的演进&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;阅读更多&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;---&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765958&amp;amp;idx=1&amp;amp;sn=8201546812e5a95a2bee9dffc6d12f00&amp;amp;chksm=bd12658b8a65ec9de2f5be1e96796dfb3c8f1a374d4b7bd91266072f557caf8118d4ddb72b07&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;前‍端&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;前端&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7v&quot; textvalue=&quot; 安全&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt; &lt;/strong&gt; &lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765981&amp;amp;idx=1&amp;amp;sn=c2dd86f15dee2cbbc89e27677d985060&amp;amp;chksm=bd1265908a65ec86d4d08f7600d1518b61c90f6453074f9b308c96861c045712280a73751c73&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;算‍法&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;算法&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765982&amp;amp;idx=1&amp;amp;sn=231b41f653ac7959f3e3b8213dcec2b0&amp;amp;chksm=bd1265938a65ec85630c546169444d56377bc2f11401d251da7ca50e5d07e353aa01580c7216&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;后‍端&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;后端&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765964&amp;amp;idx=1&amp;amp;sn=ab6d8db147234fe57f27dd46eec40fef&amp;amp;chksm=bd1265818a65ec9749246dd1a2eb3bf7798772cc4d5b4283b15eae2f80bc6db63a1471a9e61e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;数‍据&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;数据&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765965&amp;amp;idx=1&amp;amp;sn=37e0c56c8b080146ce5249243bfd84d8&amp;amp;chksm=bd1265808a65ec96d3a2b2c87c6e27c910d49cb6b149970fb2db8bf88045a0a85fed2e6a0b84&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;安‍全&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;安全&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765972&amp;amp;idx=1&amp;amp;sn=afe02ec92762c1ce18740d03324c4ac3&amp;amp;chksm=bd1265998a65ec8f10d5f58d0f3681ddfc5325137218e568e1cda3a50e427749edb5c6a7dcf5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;And‍roid&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;Android&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765973&amp;amp;idx=1&amp;amp;sn=32a23bf1d278dda0398f993ab60a697e&amp;amp;chksm=bd1265988a65ec8e630ef4d24b4946ab6bd7e66702c1d712481cf3c471468a059c470a14c30d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;iO‍S&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;iOS&lt;/a&gt;&lt;span&gt; &lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765963&amp;amp;idx=1&amp;amp;sn=a3de9ef267d07d94118c1611776a4b28&amp;amp;chksm=bd1265868a65ec906592d25ad65f2a8516338d07ec3217059e6975fc131fc0107d66a8cd2612&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;运‍维&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;运维&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765974&amp;amp;idx=1&amp;amp;sn=763c1e37d04acffd0142a2852ecfb000&amp;amp;chksm=bd12659b8a65ec8dfcfeb2028ef287fae7c38f134a665375ba420556ce5d2e4cf398147bd12e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;测‍试&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;测试&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5NjQ5MTI5OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVGibnsaEib3aNlqF0tOrA2RGEmNSbia2nnohE4Tpf95UyTiaSjDVbHRfY8WNBeTuLLTaVdSckkNyEx1Q/0?wx_fmt=png&quot; data-nickname=&quot;美团技术团队&quot; data-alias=&quot;meituantech&quot; data-signature=&quot;10000+工程师，如何支撑中国领先的生活服务电子商务平台？数亿消费者、数百万商户、2000多个行业、几千亿交易额背后是哪些技术在支撑？这里是美团、大众点评、美团外卖、美团配送、美团优选等技术团队的对外窗口。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>