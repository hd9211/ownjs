<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>439d191b0f2b207cf79e985d5458f4ce</guid>
<title>什么是真正的程序员？| 码农周刊第 323 期</title>
<link>https://toutiao.io/k/v08ikpz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;什么是真正的程序员？| 码农周刊第 323 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第323期（2020-10-28）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=323&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3230&quot; target=&quot;_blank&quot;&gt;薪资翻番如何实现？程序员的涨薪秘诀&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=323&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3230&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_321.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=323&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;适合入门&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;该框架由阿里云机器学习 PAI 团队研发，让自然语言处理场景的模型预训练和迁移学习开发与部署更加简单和高效。&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;硬核&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;论文笔记&lt;/p&gt;
        
        &lt;p&gt;系列文章&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;因子分解机算法&lt;/p&gt;
        
        &lt;p&gt;深入讲解&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;Yahoo 开源的 Kafka 集群管理平台&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;更多可能&lt;/p&gt;
        
        &lt;p&gt;实战经验&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;源码分析&lt;/p&gt;
        
        &lt;p&gt;一个 Android Jetpack 扩展库&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;一步步教你&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;倾向于使用 Less 或 Stylus&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;这里有最接地气的架构师一线实战经验、核心技能的分享。运营和产品的总结。以及一些个人的深度思考。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 268968 即可&lt;/p&gt;
        
        &lt;p&gt;GO PHP JS 一网打尽&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 146415 即可&lt;/p&gt;
        
        &lt;p&gt;分享技术，专注程序员成长&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 137785 即可&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;Coding虽易，debug不易....&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 98777 即可&lt;/p&gt;
        
        &lt;p&gt;专注分享Java实战技术、Java基础原理、微服务实战技术、分布式系统架构&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 22887 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;本书为对基本概率论感兴趣的读者以及之前未接触过此方向的人提供了一个坚实的基础。通过对话的方式和详细的数学推导，在迷人的风格和信息丰富的讨论上取得了平衡。欢迎到&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;兑换阅读。&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;真实&lt;/p&gt;
        
        &lt;p&gt;值得思考&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>046175068ffef38fbfd0f7dd84e3520d</guid>
<title>gRPC 初探与简单使用</title>
<link>https://toutiao.io/k/sekzpby</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0374331550802138&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gf7zJ2NXUibEatLJbcDLrEklG7PpIJibibEZ243hQfTYAOnUKKO8WJGtNK0FtNOyibfohow3qklfpW5e7l6y8hXefA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;748&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;概念&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 gRPC 中，客户端应用程序可以直接在另一台计算机上的服务器应用程序上调用方法，就好像它是本地对象一样，从而使您更轻松地创建分布式应用程序和服务。与许多 RPC 系统一样，gRPC 围绕定义服务的思想，指定可通过其参数和返回类型远程调用的方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;gRPC 可以将 protocol buffers 用作其接口定义语言（IDL）和其基础消息交换格式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;service HelloService {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  rpc SayHello (HelloRequest) returns (HelloResponse);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;message HelloRequest {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  string greeting = 1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;message HelloResponse {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  string reply = 1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;gRPC 架构&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在服务器端，服务器实现此接口并运行 gRPC 服务器以处理客户端调用。在客户端，客户端具有一个存根（在某些语言中仅称为客户端），提供与服务器相同的方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gf7zJ2NXUibFTaTlpc0v4MiaG523h6CrVg4JLOJQf7yj1SEhLSyiakmdTPphXhpH1y9FPIpic5z7AlYYTvliaGDN9Hg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从 Google 内部的服务器到您自己的计算机，gRPC 客户端和服务器都可以在各种环境中运行并相互通信，并且可以使用 gRPC 支持的任何语言编写。因此，例如，您可以使用 Go，Python 或 Ruby 的客户端轻松地用 Java 创建gRPC 服务器。此外，最新的 Google API 的接口将具有 gRPC 版本，可让您轻松地在应用程序中内置 Google 功能。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;关于 protocol buffers，可以阅读⎡&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247483968&amp;amp;idx=1&amp;amp;sn=e899a0efca008b6d490b01fe203feb89&amp;amp;chksm=9f81a82ea8f621382190cbee9dc49260290a176bf3a6275c5b78824adb59ae40915c6ad2f63d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Protobuf - 更小、更快、更简单的交互式数据语言&lt;/a&gt;⎦，此处不再赘述。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;gRPC 可以定义四种服务方法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1. 一元 RPC，客户端向服务器发送单个请求并获得单个响应，就像普通函数调用一样。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;rpc SayHello(HelloRequest) returns (HelloResponse);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;2. 服务器流式 RPC，客户端在其中向服务器发送请求，并获取流以读取回一系列消息。客户端从返回的流中读取，直到没有更多消息为止。gRPC 保证单个 RPC 调用中的消息顺序。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;3. 客户端流式RPC，客户端在其中编写一系列消息，然后再次使用提供的流将它们发送到服务器。客户端写完消息后，它将等待服务器读取消息并返回响应。gRPC再次保证了在单个RPC调用中的消息顺序。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;4. 双向流式RPC，双方都使用读写流发送一系列消息。这两个流是独立运行的，因此客户端和服务器可以按照自己喜欢的顺序进行读写：例如，服务器可以在写响应之前等待接收所有客户端消息，或者可以先读取消息再写入消息，或其他一些读写组合。每个流中的消息顺序都会保留。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;使用API&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从 .proto 文件中的服务定义开始，gRPC 提供了protocol buffers 编译器插件，这些插件可生成客户端和服务器端代码。gRPC 用户通常在客户端调用这些 API，并在服务器端实现相应的 API。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;在服务器端，服务器实现服务声明的方法，并运行 gRPC 服务器来处理客户端调用。gRPC 基础结构解码传入的请求，执行服务方法，并对服务响应进行编码。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在客户端，客户端具有一个称为 stub 的本地对象（对于某些语言，首选术语是 client），该对象实现与服务相同的方法。然后，客户端可以只在本地对象上调用这些方法，将调用的参数包装在适当的 protocol buffers消息类型中- gRPC 再将请求发送到服务器并返回服务器的 protocol buffers 响应之后进行查找。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;同步与异步&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;阻塞的同步 RPC 调用直到从服务器收到响应为止是最接近 RPC 所追求的过程调用抽象的近似方法。另一方面，网络本质上是异步的，因此在许多情况下能够启动 RPC 而不阻塞当前线程很有用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;RPC 生命周期&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;一元 RPC &lt;/span&gt;&lt;/strong&gt;- &lt;span&gt;最简单的 RPC 类型，其中客户端发送单个请求并返回单个响应。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;客户端调用存根方法后，会通知服务器已使用该调用的客户端元数据，方法名称和指定的期限（如果适用）来调用 RPC。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;然后，服务器可以立即发送自己的初始元数据（必须在发送任何响应之前发送），或者等待客户端的请求消息。首先发生的是特定于应用程序的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;服务器收到客户的请求消息后，它将完成创建和填充响应所必需的一切工作。然后将响应（如果成功）连同状态详细信息（状态代码和可选状态消息）以及可选尾随元数据一起返回（如果成功）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果响应状态为 OK，则客户端将获得响应，从而在客户端完成呼叫。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;服务器流式 RPC&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;服务器流式 RPC 与一元 RPC 相似，不同之处在于服务器响应客户端的请求返回消息流。发送所有消息后，服务器的状态详细信息（状态代码和可选状态消息）和可选尾随元数据将发送到客户端。这样就完成了服务器端的处理。客户端收到所有服务器的消息后即完成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;客户端流式 RPC&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;客户端流式 RPC 与一元 RPC 相似，不同之处在于客户端将消息流发送到服务器而不是单个消息。服务器以一条消息（以及其状态详细信息和可选的尾随元数据）作为响应，通常（但不一定）是在它收到所有客户端的消息之后。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;双向流式RPC&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在双向流式 RPC 中，调用由客户端调用方法启动，服务器接收客户端元数据，方法名称和期限。服务器可以选择发回其初始元数据，也可以等待客户端开始流式传输消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;客户端和服务器端流处理是特定于应用程序的。由于两个流是独立的，因此客户端和服务器可以按任何顺序读取和写入消息。例如，服务器可以等到收到客户端的所有消息后再写消息，或者服务器和客户端可以打“ping-pong” – 服务器收到请求，然后发回响应，然后客户端发送基于响应的另一个请求，依此类推。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;截止时间 / 超时&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;gRPC 允许客户端指定在 RPC 因 DEADLINE_EXCEEDED 错误终止之前，他们愿意等待 RPC 完成多长时间。在服务器端，服务器可以查询以查看特定的RPC 是否超时，或者还剩下多少时间来完成 RPC。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;指定期限或超时是特定于语言的：某些语言 API 按照超时（时间长度）工作，而某些语言 API 按照期限（固定时间点）工作，并且可能有也可能没有默认期限。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;RPC 终止&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 gRPC 中，客户端和服务器均对呼叫成功进行独立和本地确定，其结论可能不匹配。这意味着，例如，您可能拥有一个在服务器端成功完成 RPC 的RPC（“我已经发送了所有响应！”），但是在客户端却失败了（“响应在我的截止日期之后到达！”）。服务器也有可能在客户端发送所有请求之前决定完成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;取消 RPC&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;客户端或服务器都可以随时取消 RPC。取消操作会立即终止 RPC，因此不再进行任何工作。并且取消之前所做的更改不会回滚。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;元数据&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;元数据是以键值对列表的形式提供的有关特定 RPC 调用的信息（例如身份验证详细信息），其中键是字符串，值通常是字符串，但可以是二进制数据。元数据对于 gRPC 本身是不透明的-它允许客户端向服务器提供与调用相关的信息，反之亦然。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对元数据的访问取决于语言。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;通道&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;gRPC 通道提供到指定主机和端口上的 gRPC 服务器的连接。创建客户端存根时使用。客户可以指定通道参数来修改 gRPC 的默认行为，例如打开或关闭消息压缩。通道具有状态，包括已连接和空闲。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;gRPC 如何处理关闭通道取决于语言。某些语言还允许查询通道状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;04&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Golang 语言中的 gPRC&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;准备工作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;简单示例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;RPC 应用的开发流程：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;编写.proto文件。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用 protoc 编译.proto文件，生成.go文件。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;编写服务器端代码。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;编写客户端代码。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;示例代码：&lt;/p&gt;&lt;p&gt;限于篇幅，示例代码可以点击「阅读原文」链接，访问 Github 阅读示例代码中只包含一元 RPC 和双向流 RPC。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.5405405405405406&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gf7zJ2NXUibHrBBNc13c09hsck0LRuBWagGRXUlOPE7Nto7kj7M5peJTpdZlgatE5HwOkQibCPDOjUC0FfcboIbA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;370&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;参考资料：&lt;/p&gt;&lt;p&gt;https://grpc.io/docs/&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;推荐阅读：&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247483968&amp;amp;idx=1&amp;amp;sn=e899a0efca008b6d490b01fe203feb89&amp;amp;chksm=9f81a82ea8f621382190cbee9dc49260290a176bf3a6275c5b78824adb59ae40915c6ad2f63d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Protobuf - 更小、更快、更简单的交互式数据语言&lt;/a&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>82f2cb1ca9eadc85ddf2773073692552</guid>
<title>DevOps 视角的前后端分离与实战</title>
<link>https://toutiao.io/k/k4sds4w</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;腾云 CODING&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;微信号&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;coding_net&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;功能介绍&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;CODING 提供给企业用户全套 DevOps 研发管理工具，包括项目管理，代码托管，持续集成，制品管理等功能，有效提高软件研发团队的代码质量和交付速度。&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>20ba9668dfac1d9eacc67105cb49addf</guid>
<title>我对云原生软件架构的观察与思考</title>
<link>https://toutiao.io/k/pw9ted3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e1d1c21d6e0c2ecdb8b9967e3c6e33c4</guid>
<title>Flink 面试题大全</title>
<link>https://toutiao.io/k/nrw0wqs</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-id=&quot;91525&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;概述&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;2019 年是大数据实时计算领域最不平凡的一年，2019 年 1 月阿里巴巴 Blink （内部的 Flink 分支版本）开源，大数据领域一夜间从 Spark 独步天下走向了两强争霸的时代。Flink 因为其天然的流式计算特性以及强大的处理性能成为炙手可热的大数据处理框架。&lt;/section&gt;&lt;section&gt;时至今日，Flink 已经发展到 1.9 版本，在大数据开发领域，面试中对于 Flink 的考察已经是大数据开发求职者必须面对的，本文结合自己作为面试官过程中的经验详细总结了近 50 个关于 Flink 的面试考察点。&lt;/section&gt;&lt;section&gt;在本文中，分为以下几个部分：&lt;/section&gt;&lt;section&gt;第一部分：Flink 中的核心概念和基础篇，包含了 Flink 的整体介绍、核心概念、算子等考察点。&lt;/section&gt;&lt;section&gt;第二部分：Flink 进阶篇，包含了 Flink 中的数据传输、容错机制、序列化、数据热点、反压等实际生产环境中遇到的问题等考察点。&lt;/section&gt;&lt;section&gt;第三部分：Flink 源码篇，包含了 Flink 的核心代码实现、Job 提交流程、数据交换、分布式快照机制、Flink SQL 的原理等考察点。&lt;/section&gt;&lt;h2&gt;第一部分：Flink 中的核心概念和基础考察&lt;/h2&gt;&lt;section&gt;&lt;span&gt;一、 简单介绍一下 Flink&lt;/span&gt;&lt;/section&gt;&lt;section&gt;Flink 是一个框架和分布式处理引擎，用于对无界和有界数据流进行有状态计算。并且 Flink 提供了数据分布、容错机制以及资源管理等核心功能。&lt;/section&gt;&lt;section&gt;&lt;span&gt;Flink提供了诸多高抽象层的API以便用户编写分布式任务：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DataSet API， 对静态数据进行批处理操作，将静态数据抽象成分布式的数据集，用户可以方便地使用Flink提供的各种操作符对分布式数据集进行处理，支持Java、Scala和Python。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DataStream API，对数据流进行流处理操作，将流式的数据抽象成分布式的数据流，用户可以方便地对分布式数据流进行各种操作，支持Java和Scala。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Table API，对结构化数据进行查询操作，将结构化数据抽象成关系表，并通过类SQL的DSL对关系表进行各种查询操作，支持Java和Scala。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;此外，Flink 还针对特定的应用领域提供了领域库，例如：&lt;/span&gt;&lt;span&gt; Flink ML，Flink 的机器学习库，提供了机器学习Pipelines API并实现了多种机器学习算法。&lt;/span&gt;&lt;span&gt; Gelly，Flink 的图计算库，提供了图计算的相关API及多种图计算算法实现。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;根据官网的介绍，Flink 的特性包含：&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;code&gt;支持高吞吐、低延迟、高性能的流处理&lt;br/&gt;支持带有事件时间的窗口 （Window） 操作&lt;br/&gt;支持有状态计算的 Exactly-once 语义&lt;br/&gt;支持高度灵活的窗口 （Window） 操作，支持基于 time、&lt;span&gt;count&lt;/span&gt;、session 以及 data-driven 的窗口操作&lt;br/&gt;支持具有 Backpressure 功能的持续流模型&lt;br/&gt;支持基于轻量级分布式快照（Snapshot）实现的容错&lt;br/&gt;一个运行时同时支持 Batch &lt;span&gt;on&lt;/span&gt; Streaming 处理和 Streaming 处理&lt;br/&gt;Flink 在 JVM 内部实现了自己的内存管理&lt;br/&gt;支持迭代计算&lt;br/&gt;支持程序自动优化：避免特定情况下 Shuffle、排序等昂贵操作，中间结果有必要进行缓存&lt;br/&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;二、 Flink 相比传统的 Spark Streaming 有什么区别?&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个问题是一个非常宏观的问题，因为两个框架的不同点非常之多。&lt;/span&gt;&lt;span&gt;但是在面试时有非常重要的一点一定要回答出来：&lt;/span&gt;&lt;span&gt;Flink 是标准的实时处理引擎，基于事件驱动。而 Spark Streaming 是微批（Micro-Batch）的模型。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下面我们就分几个方面介绍两个框架的主要区别：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1. 架构模型&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Spark Streaming 在运行时的主要角色包括：&lt;/span&gt;&lt;span&gt;Master、Worker、Driver、Executor，Flink 在运行时主要包含：&lt;/span&gt;&lt;span&gt;Jobmanager、Taskmanager和Slot。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. 任务调度&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Spark Streaming 连续不断的生成微小的数据批次，构建有向无环图DAG，Spark Streaming 会依次创建 DStreamGraph、JobGenerator、JobScheduler。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Flink 根据用户提交的代码生成 StreamGraph，经过优化生成 JobGraph，然后提交给 JobManager进行处理，JobManager 会根据 JobGraph 生成 ExecutionGraph，ExecutionGraph 是 Flink 调度最核心的数据结构，JobManager 根据 ExecutionGraph 对 Job 进行调度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3. 时间机制&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Spark Streaming 支持的时间机制有限，只支持&lt;span&gt;处理时间&lt;/span&gt;。&lt;/span&gt;&lt;span&gt; Flink 支持了流处理程序在时间上的三个定义：&lt;/span&gt;&lt;span&gt;&lt;span&gt;处理时间、事件时间、注入时间&lt;/span&gt;。&lt;/span&gt;&lt;span&gt;同时也支持 &lt;span&gt;watermark&lt;/span&gt; 机制来处理滞后数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4. 容错机制&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于 Spark Streaming 任务，我们可以设置 checkpoint，然后假如发生故障并重启，我们可以从上次 checkpoint 之处恢复，但是这个行为只能使得数据不丢失，可能会重复处理，不能做到恰好一次处理语义。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Flink 则使用两阶段提交协议来解决这个问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;三、 Flink 的组件栈有哪些？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;根据 Flink 官网描述，Flink 是一个分层架构的系统，每一层所包含的组件都提供了特定的抽象，用来服务于上层组件。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXMcQyfq7HzfuHWQBXAt6RZn9Vz7zpFhYNdZxd4WkwicJictWlCBJHe1JOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5915492957746479&quot; data-w=&quot;781&quot;/&gt;&lt;/p&gt;&lt;section&gt;图片来源于：https://flink.apache.org&lt;/section&gt;&lt;section&gt;自下而上，每一层分别代表：Deploy 层：该层主要涉及了Flink的部署模式，在上图中我们可以看出，Flink 支持包括local、Standalone、Cluster、Cloud等多种部署模式。Runtime 层：Runtime层提供了支持 Flink 计算的核心实现，比如：支持分布式 Stream 处理、JobGraph到ExecutionGraph的映射、调度等等，为上层API层提供基础服务。API层：API 层主要实现了面向流（Stream）处理和批（Batch）处理API，其中面向流处理对应DataStream API，面向批处理对应DataSet API，后续版本，Flink有计划将DataStream和DataSet API进行统一。Libraries层：该层称为Flink应用框架层，根据API层的划分，在API层之上构建的满足特定应用的实现计算框架，也分别对应于面向流处理和面向批处理两类。面向流处理支持：CEP（复杂事件处理）、基于SQL-like的操作（基于Table的关系操作）；面向批处理支持：FlinkML（机器学习库）、Gelly（图处理）。&lt;/section&gt;&lt;section&gt;&lt;span&gt;四、Flink 的运行必须依赖 Hadoop组件吗？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;Flink可以完全独立于Hadoop，在不依赖Hadoop组件下运行。但是做为大数据的基础设施，Hadoop体系是任何大数据框架都绕不过去的。Flink可以集成众多Hadooop 组件，例如Yarn、Hbase、HDFS等等。例如，Flink可以和Yarn集成做资源调度，也可以读写HDFS，或者利用HDFS做检查点。&lt;/section&gt;&lt;section&gt;&lt;span&gt;五、你们的Flink集群规模多大？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;大家注意，这个问题看起来是问你实际应用中的Flink集群规模，其实还隐藏着另一个问题：Flink可以支持多少节点的集群规模？&lt;/section&gt;&lt;section&gt;在回答这个问题时候，可以将自己生产环节中的集群规模、节点、内存情况说明，同时说明部署模式（一般是Flink on Yarn），除此之外，用户也可以同时在小集群（少于5个节点）和拥有 TB 级别状态的上千个节点上运行 Flink 任务。&lt;/section&gt;&lt;section&gt;&lt;span&gt;六、Flink的基础编程模型了解吗？&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXMSv9LzyFwiahRxVS0U49iaH6vEhvNw8HOlbK4ibW787pThGMicydQ2atypA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.7835703001579779&quot; data-w=&quot;633&quot;/&gt;&lt;/p&gt;&lt;section&gt;上图是来自Flink官网的运行流程图。通过上图我们可以得知，Flink 程序的基本构建是数据输入来自一个 Source，Source 代表数据的输入端，经过 Transformation 进行转换，然后在一个或者多个Sink接收器中结束。数据流（stream）就是一组永远不会停止的数据记录流，而转换（transformation）是将一个或多个流作为输入，并生成一个或多个输出流的操作。执行时，Flink程序映射到 streaming dataflows，由流（streams）和转换操作（transformation operators）组成。&lt;/section&gt;&lt;section&gt;&lt;span&gt;七、Flink集群有哪些角色？各自有什么作用？&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXM5dFneFZCBXORRSiaicl4vPnVRH57iaOvBjrwHq8QicXZ5oRcUjpoa2M4WA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.72375&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;section&gt;Flink 程序在运行时主要有 TaskManager，JobManager，Client三种角色。其中JobManager扮演着集群中的管理者Master的角色，它是整个集群的协调者，负责接收Flink Job，协调检查点，Failover 故障恢复等，同时管理Flink集群中从节点TaskManager。&lt;/section&gt;&lt;section&gt;TaskManager是实际负责执行计算的Worker，在其上执行Flink Job的一组Task，每个TaskManager负责管理其所在节点上的资源信息，如内存、磁盘、网络，在启动的时候将资源的状态向JobManager汇报。&lt;/section&gt;&lt;section&gt;Client是Flink程序提交的客户端，当用户提交一个Flink程序时，会首先创建一个Client，该Client首先会对用户提交的Flink程序进行预处理，并提交到Flink集群中处理，所以Client需要从用户提交的Flink程序配置中获取JobManager的地址，并建立到JobManager的连接，将Flink Job提交给JobManager。&lt;/section&gt;&lt;section&gt;&lt;span&gt;八、说说 Flink 资源管理中 Task Slot 的概念&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXMPRlFygGWuGo0rcibAfNOYSe4NGUmlSqictx9ZuJia3CANxicuSSicpyzdKA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.37875&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;section&gt;在Flink架构角色中我们提到，TaskManager是实际负责执行计算的Worker，TaskManager 是一个 JVM 进程，并会以独立的线程来执行一个task或多个subtask。为了控制一个 TaskManager 能接受多少个 task，Flink 提出了 Task Slot 的概念。&lt;/section&gt;&lt;section&gt;简单的说，TaskManager会将自己节点上管理的资源分为不同的Slot：固定大小的资源子集。这样就避免了不同Job的Task互相竞争内存资源，但是需要主要的是，Slot只会做内存的隔离。没有做CPU的隔离。&lt;/section&gt;&lt;section&gt;&lt;span&gt;九、说说 Flink 的常用算子？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;Flink 最常用的常用算子包括：Map：DataStream → DataStream，输入一个参数产生一个参数，map的功能是对输入的参数进行转换操作。Filter：过滤掉指定条件的数据。KeyBy：按照指定的key进行分组。Reduce：用来进行结果汇总合并。Window：窗口函数，根据某些特性将每个key的数据进行分组（例如：在5s内到达的数据）&lt;/section&gt;&lt;section&gt;&lt;span&gt;十、说说你知道的Flink分区策略？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;什么要搞懂什么是分区策略。分区策略是用来决定数据如何发送至下游。目前 Flink 支持了8中分区策略的实现。&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXM5XRH2ypxAAGkwt1iaJKelpYVC9jq2sMGaFFiaMH0X87KZcb6H3qkXBZA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.12625&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;section&gt;上图是整个Flink实现的分区策略继承图：&lt;/section&gt;&lt;section&gt;&lt;span&gt;GlobalPartitioner&lt;/span&gt; 数据会被分发到下游算子的第一个实例中进行处理。&lt;/section&gt;&lt;section&gt;&lt;span&gt;ShufflePartitioner&lt;/span&gt; 数据会被随机分发到下游算子的每一个实例中进行处理。&lt;/section&gt;&lt;section&gt;&lt;span&gt;RebalancePartitioner&lt;/span&gt; 数据会被循环发送到下游的每一个实例中进行处理。&lt;/section&gt;&lt;section&gt;&lt;span&gt;RescalePartitioner&lt;/span&gt; 这种分区器会根据上下游算子的并行度，循环的方式输出到下游算子的每个实例。这里有点难以理解，假设上游并行度为2，编号为A和B。下游并行度为4，编号为1，2，3，4。那么A则把数据循环发送给1和2，B则把数据循环发送给3和4。假设上游并行度为4，编号为A，B，C，D。下游并行度为2，编号为1，2。那么A和B则把数据发送给1，C和D则把数据发送给2。&lt;/section&gt;&lt;section&gt;&lt;span&gt;BroadcastPartitioner&lt;/span&gt; 广播分区会将上游数据输出到下游算子的每个实例中。适合于大数据集和小数据集做Jion的场景。&lt;/section&gt;&lt;section&gt;&lt;span&gt;ForwardPartitioner&lt;/span&gt; ForwardPartitioner 用于将记录输出到下游本地的算子实例。它要求上下游算子并行度一样。简单的说，ForwardPartitioner用来做数据的控制台打印。&lt;/section&gt;&lt;section&gt;&lt;span&gt;KeyGroupStreamPartitioner&lt;/span&gt; Hash分区器。会将数据按 Key 的 Hash 值输出到下游算子实例中。&lt;/section&gt;&lt;section&gt;&lt;span&gt;CustomPartitionerWrapper&lt;/span&gt; 用户自定义分区器。需要用户自己实现Partitioner接口，来定义自己的分区逻辑。例如：&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;classCustomPartitionerimplementsPartitioner&amp;lt;String&amp;gt; &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;publicintpartition&lt;span&gt;(String key, int numPartitions)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;          &lt;span&gt;switch&lt;/span&gt; (key){&lt;br/&gt;              &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;1&quot;&lt;/span&gt;:&lt;br/&gt;                  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;              &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;2&quot;&lt;/span&gt;:&lt;br/&gt;                  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;              &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;3&quot;&lt;/span&gt;:&lt;br/&gt;                  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;              &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;                  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;;&lt;br/&gt;          }&lt;br/&gt;      }&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;十一、Flink的并行度了解吗？Flink的并行度设置是怎样的？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Flink中的任务被分为多个并行任务来执行，其中每个并行的实例处理一部分数据。&lt;/span&gt;&lt;span&gt;这些并行实例的数量被称为并行度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们在实际生产环境中可以从四个不同层面设置并行度：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;需要注意的优先级：&lt;/span&gt;&lt;span&gt;算子层面&amp;gt;环境层面&amp;gt;客户端层面&amp;gt;系统层面。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;十二、Flink的Slot和parallelism有什么区别？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;官网上十分经典的图：&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXMVgSHLMa8pGKcpdLLQpyXlwQFZ0CX4cfsHUutONt2DsqyTdLrn6aL9Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.375&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;section&gt;slot是指taskmanager的并发执行能力，假设我们将 taskmanager.numberOfTaskSlots 配置为3 那么每一个 taskmanager 中分配3个 TaskSlot, 3个 taskmanager 一共有9个TaskSlot。&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXMVhqjdpLSJTia5qQp8dzAb5KZTBMKmLKCnJfuibNkaicMJqYTeHqrb1New/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.29375&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;section&gt;parallelism是指taskmanager实际使用的并发能力。假设我们把 parallelism.default 设置为1，那么9个 TaskSlot 只能用1个，有8个空闲。&lt;/section&gt;&lt;section&gt;&lt;span&gt;十三、Flink有没有重启策略？说说有哪几种？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Flink 实现了多种重启策略。&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;固定延迟重启策略（Fixed Delay Restart Strategy）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;故障率重启策略（Failure Rate Restart Strategy）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;没有重启策略（No Restart Strategy）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Fallback重启策略（Fallback Restart Strategy）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;十四、用过Flink中的分布式缓存吗？如何使用？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Flink实现的分布式缓存和Hadoop有异曲同工之妙。&lt;/span&gt;&lt;span&gt;目的是在本地读取文件，并把他放在 taskmanager 节点中，防止task重复拉取。&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;code&gt;val env = ExecutionEnvironment.getExecutionEnvironment&lt;br/&gt;&lt;br/&gt;// register &lt;span&gt;a&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; from HDFS&lt;br/&gt;env.registerCachedFile(&lt;span&gt;&quot;hdfs:///path/to/your/file&quot;&lt;/span&gt;, &lt;span&gt;&quot;hdfsFile&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;// register &lt;span&gt;a&lt;/span&gt; local &lt;span&gt;executable&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; (script, &lt;span&gt;executable&lt;/span&gt;, ...)&lt;br/&gt;env.registerCachedFile(&lt;span&gt;&quot;file:///path/to/exec/file&quot;&lt;/span&gt;, &lt;span&gt;&quot;localExecFile&quot;&lt;/span&gt;, true)&lt;br/&gt;&lt;br/&gt;// define your program &lt;span&gt;and&lt;/span&gt; &lt;span&gt;execute&lt;/span&gt;&lt;br/&gt;...&lt;br/&gt;val inpu&lt;span&gt;t:&lt;/span&gt; DataSet[String] = ...&lt;br/&gt;val resul&lt;span&gt;t:&lt;/span&gt; DataSet[Integer] = &lt;span&gt;input&lt;/span&gt;.&lt;span&gt;map&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; MyMapper())&lt;br/&gt;...&lt;br/&gt;env.&lt;span&gt;execute&lt;/span&gt;()&lt;br/&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;十五、说说Flink中的广播变量，使用时需要注意什么？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;我们知道Flink是并行的，计算过程可能不在一个 Slot 中进行，那么有一种情况即：当我们需要访问同一份数据。那么Flink中的广播变量就是为了解决这种情况。&lt;/section&gt;&lt;section&gt;我们可以把广播变量理解为是一个公共的共享变量，我们可以把一个dataset 数据集广播出去，然后不同的task在节点上都能够获取到，这个数据在每个节点上只会存在一份。&lt;/section&gt;&lt;section&gt;&lt;span&gt;十六、说说Flink中的窗口？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;来一张官网经典的图：&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXMyJVRJPiaXBOe9VrPRZYqSKnb7EoPkFZ6ljB5ZJf7I4v5A6TveWNDDwA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.6175&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;section&gt;Flink 支持两种划分窗口的方式，按照time和count。如果根据时间划分窗口，那么它就是一个time-window 如果根据数据划分窗口，那么它就是一个count-window。&lt;/section&gt;&lt;section&gt;flink支持窗口的两个重要属性（size和interval）&lt;/section&gt;&lt;section&gt;如果size=interval,那么就会形成tumbling-window(无重叠数据) 如果size&amp;gt;interval,那么就会形成sliding-window(有重叠数据) 如果size&amp;lt; interval, 那么这种窗口将会丢失数据。比如每5秒钟，统计过去3秒的通过路口汽车的数据，将会漏掉2秒钟的数据。&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过组合可以得出四种基本窗口：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;time-tumbling-window 无重叠数据的时间窗口，设置方式举例：&lt;/span&gt;&lt;span&gt;timeWindow(Time.seconds(5))&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;time-sliding-window 有重叠数据的时间窗口，设置方式举例：&lt;/span&gt;&lt;span&gt;timeWindow(Time.seconds(5), Time.seconds(3))&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;count-tumbling-window无重叠数据的数量窗口，设置方式举例：&lt;/span&gt;&lt;span&gt;countWindow(5)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;count-sliding-window 有重叠数据的数量窗口，设置方式举例：&lt;/span&gt;&lt;span&gt;countWindow(5,3)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;十七、说说Flink中的状态存储？&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;Flink在做计算的过程中经常需要存储中间状态，来避免数据丢失和状态恢复。选择的状态存储策略不同，会影响状态持久化如何和 checkpoint 交互。&lt;/section&gt;&lt;section&gt;Flink提供了三种状态存储方式：MemoryStateBackend、FsStateBackend、RocksDBStateBackend。&lt;/section&gt;&lt;section&gt;&lt;span&gt;十八、Flink 中的时间有哪几类&lt;/span&gt;&lt;/section&gt;&lt;section&gt;Flink 中的时间和其他流式计算系统的时间一样分为三类：事件时间，摄入时间，处理时间三种。&lt;/section&gt;&lt;section&gt;如果以 EventTime 为基准来定义时间窗口将形成EventTimeWindow,要求消息本身就应该携带EventTime。如果以 IngesingtTime 为基准来定义时间窗口将形成 IngestingTimeWindow,以 source 的systemTime为准。如果以 ProcessingTime 基准来定义时间窗口将形成 ProcessingTimeWindow，以 operator 的systemTime 为准。&lt;/section&gt;&lt;section&gt;&lt;span&gt;十九、Flink 中水印是什么概念，起到什么作用？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Watermark 是 Apache Flink 为了处理 EventTime 窗口计算提出的一种机制, 本质上是一种时间戳。&lt;/span&gt;&lt;span&gt; 一般来讲Watermark经常和Window一起被用来处理乱序事件。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;二十、Flink Table &amp;amp; SQL 熟悉吗？TableEnvironment这个类有什么作用&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;TableEnvironment是Table API和SQL集成的核心概念。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个类主要用来：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;二十、Flink SQL的实现原理是什么？是如何实现 SQL 解析的呢？&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;首先大家要知道 Flink 的SQL解析是基于Apache Calcite这个开源框架。&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXMFEU6zxQCVb1AjPC2aOPh9nwLQhqvAntXFA5eKuZVZibJBibefNCRjiavw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.63125&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;基于此，一次完整的SQL解析过程如下：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;用户使用对外提供Stream SQL的语法开发业务应用&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;用calcite对StreamSQL进行语法检验，语法检验通过后，转换成calcite的逻辑树节点；&lt;/span&gt;&lt;span&gt;最终形成calcite的逻辑计划&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;采用Flink自定义的优化规则和calcite火山模型、启发式模型共同对逻辑树进行优化，生成最优的Flink物理计划&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对物理计划采用janino codegen生成代码，生成用低阶API DataStream 描述的流应用，提交到Flink平台执行&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;第二部分：Flink 面试进阶篇&lt;/h2&gt;&lt;section&gt;&lt;span&gt;一、Flink是如何支持批流一体的？&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXMyAoEBdQjAFLPIdOzImibKDS521iakbT5nokTm1etxOw0ZLoeAE0d5pRg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.79625&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;section&gt;本道面试题考察的其实就是一句话：Flink的开发者认为批处理是流处理的一种特殊情况。批处理是有限的流处理。Flink 使用一个引擎支持了DataSet API 和 DataStream API。&lt;/section&gt;&lt;section&gt;&lt;span&gt;二、Flink是如何做到高效的数据交换的？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;在一个Flink Job中，数据需要在不同的task中进行交换，整个数据交换是有 TaskManager 负责的，TaskManager 的网络组件首先从缓冲buffer中收集records，然后再发送。Records 并不是一个一个被发送的，二是积累一个批次再发送，batch 技术可以更加高效的利用网络资源。&lt;/section&gt;&lt;section&gt;&lt;span&gt;三、Flink是如何做容错的？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;Flink 实现容错主要靠强大的CheckPoint机制和State机制。Checkpoint 负责定时制作分布式快照、对程序中的状态进行备份；State 用来存储计算过程中的中间状态。&lt;/section&gt;&lt;section&gt;&lt;span&gt;四、Flink 分布式快照的原理是什么？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;Flink的分布式快照是根据Chandy-Lamport算法量身定做的。简单来说就是持续创建分布式数据流及其状态的一致快照。&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXMDlHuFjGJ2TJRMSKamciaqEPDkVqu1m39ko56CnU3DEqiblXDkzuBnx6w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.32375&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;section&gt;核心思想是在 input source 端插入 barrier，控制 barrier 的同步来实现 snapshot 的备份和 exactly-once 语义。&lt;/section&gt;&lt;section&gt;&lt;span&gt;五、Flink 是如何保证Exactly-once语义的？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Flink通过实现两阶段提交和状态保存来实现端到端的一致性语义。&lt;/span&gt;&lt;span&gt; 分为以下几个步骤：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;开始事务（beginTransaction）创建一个临时文件夹，来写把数据写入到这个文件夹里面&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;预提交（preCommit）将内存中缓存的数据写入文件并关闭&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;正式提交（commit）将之前写完的临时文件放入目标目录下。&lt;/span&gt;&lt;span&gt;这代表着最终的数据会有一些延迟&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;丢弃（abort）丢弃临时文件&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;若失败发生在预提交成功后，正式提交前。&lt;/span&gt;&lt;span&gt;可以根据&lt;/span&gt;状态来提交预提交的数据，也可删除预提交的数据。&lt;/section&gt;&lt;section&gt;&lt;span&gt;六、Flink 的 kafka 连接器有什么特别的地方？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;Flink源码中有一个独立的connector模块，所有的其他connector都依赖于此模块，Flink 在1.9版本发布的全新kafka连接器，摒弃了之前连接不同版本的kafka集群需要依赖不同版本的connector这种做法，只需要依赖一个connector即可。&lt;/section&gt;&lt;section&gt;&lt;span&gt;七、说说 Flink的内存管理是如何做的?&lt;/span&gt;&lt;/section&gt;&lt;section&gt;Flink 并不是将大量对象存在堆上，而是将对象都序列化到一个预分配的内存块上。此外，Flink大量的使用了堆外内存。如果需要处理的数据超出了内存限制，则会将部分数据存储到硬盘上。Flink 为了直接操作二进制数据实现了自己的序列化框架。&lt;/section&gt;&lt;section&gt;&lt;span&gt;理论上Flink的内存管理分为三部分：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Network Buffers：&lt;/span&gt;&lt;span&gt;这个是在TaskManager启动的时候分配的，这是一组用于缓存网络数据的内存，每个块是32K，默认分配2048个，可以通过“taskmanager.network.numberOfBuffers”修改&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Memory Manage pool：&lt;/span&gt;&lt;span&gt;大量的Memory Segment块，用于运行时的算法（Sort/Join/Shuffle等），这部分启动的时候就会分配。&lt;/span&gt;&lt;span&gt;下面这段代码，根据配置文件中的各种参数来计算内存的分配方法。&lt;/span&gt;&lt;span&gt;（heap or off-heap，这个放到下节谈），内存的分配支持预分配和lazy load，默认懒加载的方式。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;User Code，这部分是除了Memory Manager之外的内存用于User code和TaskManager本身的数据结构。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;八、说说 Flink的序列化如何做的?&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;Java本身自带的序列化和反序列化的功能，但是辅助信息占用空间比较大，在序列化对象时记录了过多的类信息。&lt;/section&gt;&lt;section&gt;Apache Flink摒弃了Java原生的序列化方法，以独特的方式处理数据类型和序列化，包含自己的类型描述符，泛型类型提取和类型序列化框架。&lt;/section&gt;&lt;section&gt;&lt;span&gt;TypeInformation 是所有类型描述符的基类。&lt;/span&gt;&lt;span&gt;它揭示了该类型的一些基本属性，并且可以生成序列化器。&lt;/span&gt;&lt;span&gt;TypeInformation 支持以下几种类型：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;BasicTypeInfo: 任意Java 基本类型或 String 类型&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;BasicArrayTypeInfo: 任意Java基本类型数组或 String 数组&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;WritableTypeInfo: 任意 Hadoop Writable 接口的实现类&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;TupleTypeInfo: 任意的 Flink Tuple 类型(支持Tuple1 to Tuple25)。&lt;/span&gt;&lt;span&gt;Flink tuples 是固定长度固定类型的Java Tuple实现&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CaseClassTypeInfo: 任意的 Scala CaseClass(包括 Scala tuples)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;PojoTypeInfo: 任意的 POJO (Java or Scala)，例如，Java对象的所有成员变量，要么是 public 修饰符定义，要么有 getter/setter 方法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;GenericTypeInfo: 任意无法匹配之前几种类型的类&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;针对前六种类型数据集，Flink皆可以自动生成对应的TypeSerializer，能非常高效地对数据集进行序列化和反序列化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;九、 Flink中的Window出现了数据倾斜，你有什么解决办法？&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;window产生数据倾斜指的是数据在不同的窗口内堆积的数据量相差过多。&lt;/span&gt;&lt;span&gt;本质上产生这种情况的原因是数据源头发送的数据量速度不同导致的。&lt;/span&gt;&lt;span&gt;出现这种情况一般通过两种方式来解决：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;十、 Flink中在使用聚合函数 GroupBy、Distinct、KeyBy 等函数时出现数据热点该如何解决？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据倾斜和数据热点是所有大数据框架绕不过去的问题。&lt;/span&gt;&lt;span&gt;处理这类问题主要从3个方面入手：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;例如一个假设订单场景，北京和上海两个城市订单量增长几十倍，其余城市的数据量不变。&lt;/span&gt;&lt;span&gt;这时候我们在进行聚合的时候，北京和上海就会出现数据堆积，我们可以单独数据北京和上海的数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;把热key进行拆分，比如上个例子中的北京和上海，可以把北京和上海按照地区进行拆分聚合。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Flink 1.9.0 SQL(Blink Planner) 性能优化中一项重要的改进就是升级了微批模型，即 MiniBatch。&lt;/span&gt;&lt;span&gt;原理是缓存一定的数据后再触发处理，以减少对State的访问，从而提升吞吐和减少数据的输出量。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;十一、Flink任务延迟高，想解决这个问题，你会如何入手？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在Flink的后台任务管理中，我们可以看到Flink的哪个算子和task出现了反压。&lt;/span&gt;&lt;span&gt;最主要的手段是资源调优和算子调优。&lt;/span&gt;&lt;span&gt;资源调优即是对作业中的Operator的并发数（parallelism）、CPU（core）、堆内存（heap_memory）等参数进行调优。&lt;/span&gt;&lt;span&gt;作业参数调优包括：&lt;/span&gt;&lt;span&gt;并行度的设置，State的设置，checkpoint的设置。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;十二、Flink是如何处理反压的？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Flink 内部是基于 producer-consumer 模型来进行消息传递的，Flink的反压设计也是基于这个模型。&lt;/span&gt;&lt;span&gt;Flink 使用了高效有界的分布式阻塞队列，就像 Java 通用的阻塞队列（BlockingQueue）一样。&lt;/span&gt;&lt;span&gt;下游消费者消费变慢，上游就会受到阻塞。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;十三、Flink的反压和Strom有哪些不同？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Storm 是通过监控 Bolt 中的接收队列负载情况，如果超过高水位值就会将反压信息写到 Zookeeper ，Zookeeper 上的 watch 会通知该拓扑的所有 Worker 都进入反压状态，最后 Spout 停止发送 tuple。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Flink中的反压使用了高效有界的分布式阻塞队列，下游消费变慢会导致发送端阻塞。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;二者最大的区别是Flink是逐级反压，而Storm是直接从源头降速。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;十四、 Operator Chains（算子链）这个概念你了解吗？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了更高效地分布式执行，Flink会尽可能地将operator的subtask链接（chain）在一起形成task。&lt;/span&gt;&lt;span&gt;每个task在一个线程中执行。&lt;/span&gt;&lt;span&gt;将operators链接成task是非常有效的优化：&lt;/span&gt;&lt;span&gt;它能减少线程之间的切换，减少消息的序列化/反序列化，减少数据在缓冲区的交换，减少了延迟的同时提高整体的吞吐量。&lt;/span&gt;&lt;span&gt;这就是我们所说的算子链。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;十五、 Flink什么情况下才会把Operator chain在一起形成算子链？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;两个operator chain在一起的的条件：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;上下游的并行度一致&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;下游节点的入度为1 （也就是说下游节点没有来自其他节点的输入）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;上下游节点都在同一个 slot group 中（下面会解释 slot group）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;下游节点的 chain 策略为 ALWAYS（可以与上下游链接，map、flatmap、filter等默认是ALWAYS）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;上游节点的 chain 策略为 ALWAYS 或 HEAD（只能与下游链接，不能与上游链接，Source默认是HEAD）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;两个节点间数据分区方式是 forward（参考理解数据流的分区）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;用户没有禁用 chain&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;十六、 说说Flink1.9的新特性？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;十七、消费kafka数据的时候，如何处理脏数据？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以在处理前加一个fliter算子，将不符合规则的数据过滤出去。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;第三部分：Flink 面试源码篇&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;一、Flink Job的提交流程 &lt;/span&gt;用户提交的Flink Job会被转化成一个DAG任务运行，分别是：&lt;/span&gt;&lt;span&gt;StreamGraph、JobGraph、ExecutionGraph，Flink中JobManager与TaskManager，JobManager与Client的交互是基于Akka工具包的，是通过消息驱动。&lt;/span&gt;&lt;span&gt;整个Flink Job的提交还包含着ActorSystem的创建，JobManager的启动，TaskManager的启动和注册。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;二、Flink所谓&quot;三层图&quot;结构是哪几个&quot;图&quot;？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一个Flink任务的DAG生成计算图大致经历以下三个过程：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;StreamGraph 最接近代码所表达的逻辑层面的计算拓扑结构，按照用户代码的执行顺序向StreamExecutionEnvironment添加StreamTransformation构成流式图。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;JobGraph 从StreamGraph生成，将可以串联合并的节点进行合并，设置节点之间的边，安排资源共享slot槽位和放置相关联的节点，上传任务所需的文件，设置检查点配置等。&lt;/span&gt;&lt;span&gt;相当于经过部分初始化和优化处理的任务图。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ExecutionGraph 由JobGraph转换而来，包含了任务具体执行所需的内容，是最贴近底层实现的执行图。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;三、JobManger在集群中扮演了什么角色？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;JobManager 负责整个 Flink 集群任务的调度以及资源的管理，从客户端中获取提交的应用，然后根据集群中 TaskManager 上 TaskSlot 的使用情况，为提交的应用分配相应的 TaskSlot 资源并命令 TaskManager 启动从客户端中获取的应用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;JobManager 相当于整个集群的 Master 节点，且整个集群有且只有一个活跃的 JobManager ，负责整个集群的任务管理和资源管理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;JobManager 和 TaskManager 之间通过 Actor System 进行通信，获取任务执行的情况并通过 Actor System 将应用的任务执行情况发送给客户端。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同时在任务执行的过程中，Flink JobManager 会触发 Checkpoint 操作，每个 TaskManager 节点 收到 Checkpoint 触发指令后，完成 Checkpoint 操作，所有的 Checkpoint 协调过程都是在 Fink JobManager 中完成。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当任务完成后，Flink 会将任务执行的信息反馈给客户端，并且释放掉 TaskManager 中的资源以供下一次提交任务使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;四、JobManger在集群启动过程中起到什么作用？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;JobManager的职责主要是接收Flink作业，调度Task，收集作业状态和管理TaskManager。&lt;/span&gt;&lt;span&gt;它包含一个Actor，并且做如下操作：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;RegisterTaskManager: 它由想要注册到JobManager的TaskManager发送。&lt;/span&gt;&lt;span&gt;注册成功会通过AcknowledgeRegistration消息进行Ack。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;SubmitJob: 由提交作业到系统的Client发送。&lt;/span&gt;&lt;span&gt;提交的信息是JobGraph形式的作业描述信息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CancelJob: 请求取消指定id的作业。&lt;/span&gt;&lt;span&gt;成功会返回CancellationSuccess，否则返回CancellationFailure。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;UpdateTaskExecutionState: 由TaskManager发送，用来更新执行节点(ExecutionVertex)的状态。&lt;/span&gt;&lt;span&gt;成功则返回true，否则返回false。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;RequestNextInputSplit: TaskManager上的Task请求下一个输入split，成功则返回NextInputSplit，否则返回null。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;JobStatusChanged：&lt;/span&gt;&lt;span&gt; 它意味着作业的状态(RUNNING, CANCELING, FINISHED,等)发生变化。&lt;/span&gt;&lt;span&gt;这个消息由ExecutionGraph发送。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;五、TaskManager在集群中扮演了什么角色？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;TaskManager 相当于整个集群的 Slave 节点，负责具体的任务执行和对应任务在每个节点上的资源申请和管理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;客户端通过将编写好的 Flink 应用编译打包，提交到 JobManager，然后 JobManager 会根据已注册在 JobManager 中 TaskManager 的资源情况，将任务分配给有资源的 TaskManager节点，然后启动并运行任务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;TaskManager 从 JobManager 接收需要部署的任务，然后使用 Slot 资源启动 Task，建立数据接入的网络连接，接收数据并开始数据处理。&lt;/span&gt;&lt;span&gt;同时 TaskManager 之间的数据交互都是通过数据流的方式进行的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以看出，Flink 的任务运行其实是采用多线程的方式，这和 MapReduce 多 JVM 进行的方式有很大的区别，Flink 能够极大提高 CPU 使用效率，在多个任务和 Task 之间通过 TaskSlot 方式共享系统资源，每个 TaskManager 中通过管理多个 TaskSlot 资源池进行对资源进行有效管理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;六、TaskManager在集群启动过程中起到什么作用？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;TaskManager的启动流程较为简单：&lt;/span&gt;&lt;span&gt; 启动类：&lt;/span&gt;&lt;span&gt;org.apache.flink.runtime.taskmanager.TaskManager 核心启动方法 ：&lt;/span&gt;&lt;span&gt; selectNetworkInterfaceAndRunTaskManager 启动后直接向JobManager注册自己，注册完成后，进行部分模块的初始化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;七、Flink 计算资源的调度是如何实现的？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;TaskManager中最细粒度的资源是Task slot，代表了一个固定大小的资源子集，每个TaskManager会将其所占有的资源平分给它的slot。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过调整 task slot 的数量，用户可以定义task之间是如何相互隔离的。&lt;/span&gt;&lt;span&gt;每个 TaskManager 有一个slot，也就意味着每个task运行在独立的 JVM 中。&lt;/span&gt;&lt;span&gt;每个 TaskManager 有多个slot的话，也就是说多个task运行在同一个JVM中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而在同一个JVM进程中的task，可以共享TCP连接（基于多路复用）和心跳消息，可以减少数据的网络传输，也能共享一些数据结构，一定程度上减少了每个task的消耗。&lt;/span&gt;&lt;span&gt; 每个slot可以接受单个task，也可以接受多个连续task组成的pipeline，如下图所示，FlatMap函数占用一个taskslot，而key Agg函数和sink函数共用一个taskslot：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXMgSf0RBtFFwETL4Oq5xy3wId4baJGCtM0ibe6oCxgGAeIEBib5Kib8O74A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.35125&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;八、简述Flink的数据抽象及数据交换过程？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Flink 为了避免JVM的固有缺陷例如java对象存储密度低，FGC影响吞吐和响应等，实现了自主管理内存。&lt;/span&gt;&lt;span&gt;MemorySegment就是Flink的内存抽象。&lt;/span&gt;&lt;span&gt;默认情况下，一个MemorySegment可以被看做是一个32kb大的内存块的抽象。&lt;/span&gt;&lt;span&gt;这块内存既可以是JVM里的一个byte[]，也可以是堆外内存（DirectByteBuffer）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在MemorySegment这个抽象之上，Flink在数据从operator内的数据对象在向TaskManager上转移，预备被发给下个节点的过程中，使用的抽象或者说内存对象是Buffer。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对接从Java对象转为Buffer的中间对象是另一个抽象StreamRecord。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;九、Flink 中的分布式快照机制是如何实现的？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Flink的容错机制的核心部分是制作分布式数据流和操作算子状态的一致性快照。&lt;/span&gt;&lt;span&gt; 这些快照充当一致性checkpoint，系统可以在发生故障时回滚。&lt;/span&gt;&lt;span&gt; Flink用于制作这些快照的机制在“分布式数据流的轻量级异步快照”中进行了描述。&lt;/span&gt;&lt;span&gt; 它受到分布式快照的标准Chandy-Lamport算法的启发，专门针对Flink的执行模型而定制。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXM0DcyyS7succVwHWDLEDZc6bG21yrG1I4kSLWnRebVdy7foc5IWT7tA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.30618401206636503&quot; data-w=&quot;663&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;barriers在数据流源处被注入并行数据流中。&lt;/span&gt;&lt;span&gt;快照n的barriers被插入的位置（我们称之为Sn）是快照所包含的数据在数据源中最大位置。&lt;/span&gt;&lt;span&gt;例如，在Apache Kafka中，此位置将是分区中最后一条记录的偏移量。&lt;/span&gt;&lt;span&gt; 将该位置Sn报告给checkpoint协调器（Flink的JobManager）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;然后barriers向下游流动。&lt;/span&gt;&lt;span&gt;当一个中间操作算子从其所有输入流中收到快照n的barriers时，它会为快照n发出barriers进入其所有输出流中。&lt;/span&gt;&lt;span&gt; 一旦sink操作算子（流式DAG的末端）从其所有输入流接收到barriers n，它就向checkpoint协调器确认快照n完成。&lt;/span&gt;&lt;span&gt;在所有sink确认快照后，意味快照着已完成。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一旦完成快照n，job将永远不再向数据源请求Sn之前的记录，因为此时这些记录（及其后续记录）将已经通过整个数据流拓扑，也即是已经被处理结束。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;十、简单说说FlinkSQL的是如何实现的？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Flink 将 SQL 校验、SQL 解析以及 SQL 优化交给了Apache Calcite。&lt;/span&gt;&lt;span&gt;Calcite 在其他很多开源项目里也都应用到了，譬如 Apache Hive, Apache Drill, Apache Kylin, Cascading。&lt;/span&gt;&lt;span&gt;Calcite 在新的架构中处于核心的地位，如下图所示。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UdK9ByfMT2OKoDp7OuQQE0fccQQrNYXMFY0dSU2hAUq4DiceqIcOpB1BgibvPw3sE2BnCU3zWVBtqwpsjgdP0xpw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.6460587326120556&quot; data-w=&quot;647&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;构建抽象语法树的事情交给了 Calcite 去做。&lt;/span&gt;&lt;span&gt;SQL query 会经过 Calcite 解析器转变成 SQL 节点树，通过验证后构建成 Calcite 的抽象语法树（也就是图中的 Logical Plan）。&lt;/span&gt;&lt;span&gt;另一边，Table API 上的调用会构建成 Table API 的抽象语法树，并通过 Calcite 提供的 RelBuilder 转变成 Calcite 的抽象语法树。&lt;/span&gt;&lt;span&gt;然后依次被转换成逻辑执行计划和物理执行计划。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在提交任务后会分发到各个 TaskManager 中运行，在运行时会使用 Janino 编译器编译代码后运行。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;--end--&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;扫描下方二维码&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;添加好友，备注【&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;交流群&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;】&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;拉你到学习路线和资源丰富的交流群&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.0037037037037038&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/W5ic5oJ9K6NIVt837iblHR65hQafEE29ia1HE3z19iaZthwgcMhkiaEcxSkycZJYBPAVagvibdZICavZ5ovvScz8Wibuw/640?wx_fmt=jpeg&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>