<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b224fc1a7aed33b92399627e1629adac</guid>
<title>Hadoop 学习与面试 8000 字，收藏这一篇就够了</title>
<link>https://toutiao.io/k/xagkm7n</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;span&gt;现在在脑海过一遍以下问题，是否能够回忆清楚（后附解析参考）&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt; 1.&lt;/strong&gt; HDFS读流程和写流程？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt; 2.&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; NameNode和Secondary NameNode工作机制？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt; 3.&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; HA NameNode如何工作？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;strong&gt;4. &lt;/strong&gt;DataNode工作机制？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;strong&gt;5.&lt;/strong&gt; DataNode数据损坏怎么办？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;strong&gt;6.&lt;/strong&gt; 压缩方式怎么选择？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt; 7.&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; MapReduce工作流程？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt; 8.&lt;/strong&gt; Yarn工作机制（作业提交全过程）是什么？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;strong&gt;9.&lt;/strong&gt; Yarn调度器了解多少？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;10.&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; HDFS小文件怎么处理？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;11.&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; Shuffle及优化？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;12.&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; Hadoop解决数据倾斜方法？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;13.&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; Hadoop的参数优化？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;14.&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 异构存储（冷热数据分离）你了解吗？&lt;/span&gt;&lt;/section&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;以下总结仅供参考&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;HDFS读流程和写流程&lt;/span&gt;&lt;/h2&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;HDFS写数据流程&lt;span/&gt;&lt;/h6&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4530612244897959&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dRXPfxlVQkvDmENXeqxDJGibEybWuPialfwLdB0BDWSHWSjoJ4CAvUFVKxttH4MKc86scITeLFe7sag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;735&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）客户端通过Distributed FileSystem模块向NameNode请求上传文件，NameNode检查目标文件是否已存在，父目录是否存在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）NameNode返回是否可以上传。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）客户端请求第一个 Block上传到哪几个DataNode服务器上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）NameNode返回3个DataNode节点，分别为dn1、dn2、dn3。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（5）客户端通过FSDataOutputStream模块请求dn1上传数据，dn1收到请求会继续调用dn2，然后dn2调用dn3，将这个通信管道建立完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（6）dn1、dn2、dn3逐级应答客户端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（7）客户端开始往dn1上传第一个Block（先从磁盘读取数据放到一个本地内存缓存），以Packet为单位，dn1收到一个Packet就会传给dn2，dn2传给dn3；dn1每传一个packet会放入一个应答队列等待应答。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（8）当一个Block传输完成之后，客户端再次请求NameNode上传第二个Block的服务器。（重复执行3-7步）。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;HDFS读数据流程&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.47919655667144906&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dRXPfxlVQkvDmENXeqxDJGibYAar4tw8MEE0xfQ0pYsibwfJjYwXESAhcmXicEZrjXtfnOBQ6CIWk5OQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;697&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）客户端通过Distributed FileSystem向NameNode请求下载文件，NameNode通过查询元数据，找到文件块所在的DataNode地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）挑选一台DataNode（就近原则，然后随机）服务器，请求读取数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）DataNode开始传输数据给客户端（从磁盘里面读取数据输入流，以Packet为单位来做校验）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）客户端以Packet为单位接收，先在本地缓存，然后写入目标文件。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;NameNode和Secondary NameNode工作机制&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先认识NameNode的结构&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.23563218390804597&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dRXPfxlVQkvDmENXeqxDJGibVpO6PbAIPsIMbf528DoP4NmgD9NMI6UCvSg1hKcViapcjM6THOM2LhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;348&quot;/&gt;&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Fsimage&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Fsimage文件是HDFS文件系统元数据的一个永久性检查点，其中包含HDFS文件系统的所有目录和文件inode的序列化信息。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Edits文件&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;存放HDFS文件系统的所有更新操作的逻辑，文件系统客户端执行的所有写操作首先会记录大Edits文件中。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Seen_txid&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文件保存是一个数字，就是最后一个edits_的数字。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思考：NameNode中的元数据是存储在哪里的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们做个假设，如果存储在NameNode节点的磁盘中，因为经常需要进行随机访问，还有响应客户请求，必然是效率过低。因此，元数据需要存放在内存中。但如果只存在内存中，一旦断电，元数据丢失，整个集群就无法工作了。因此产生在磁盘中备份元数据的FsImage。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样又会带来新的问题，当在内存中的元数据更新时，如果同时更新FsImage，就会导致效率过低，但如果不更新，就会发生一致性问题，一旦NameNode节点断电，就会产生数据丢失。因此，引入Edits文件(只进行追加操作，效率很高)。每当元数据有更新或者添加元数据时，修改内存中的元数据并追加到Edits中。这样，一旦NameNode节点断电，可以通过FsImage和Edits的合并，合成元数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，如果长时间添加数据到Edits中，会导致该文件数据过大，效率降低，而且一旦断电，恢复元数据需要的时间过长。因此，需要定期进行FsImage和Edits的合并，如果这个操作由NameNode节点完成，又会效率过低。因此，引入一个新的节点SecondaryNamenode，专门用于FsImage和Edits的合并。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以NameNode的工作机制是这样的：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5372714486638537&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dRXPfxlVQkvDmENXeqxDJGib3g1gPfN4dgibobC6HUcFTHcuVwUiaSgyBBxPic3vdyL4wiav1IyBOibTfKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;711&quot;/&gt;&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第一阶段：NameNode启动&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）第一次启动NameNode格式化后，创建Fsimage和Edits文件。如果不是第一次启动，直接加载编辑日志和镜像文件到内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）客户端对元数据进行增删改的请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）NameNode记录操作日志，更新滚动日志。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）NameNode在内存中对元数据进行增删改。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第二阶段：Secondary NameNode工作&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）Secondary NameNode询问NameNode是否需要CheckPoint。直接带回NameNode是否检查结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）Secondary NameNode请求执行CheckPoint。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）NameNode滚动正在写的Edits日志。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）将滚动前的编辑日志和镜像文件拷贝到Secondary NameNode。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（5）Secondary NameNode加载编辑日志和镜像文件到内存，并合并。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（6）生成新的镜像文件fsimage.chkpoint。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（7）拷贝fsimage.chkpoint到NameNode。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（8）NameNode将fsimage.chkpoint重新命名成fsimage。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;HA NameNode如何工作（原理挺多，这里简单介绍）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在一个典型的HA集群中，每个NameNode是一台独立的服务器。在任一时刻，只有一个NameNode处于active状态，另一个处于standby状态。其中，active状态的NameNode负责所有的客户端操作，standby状态的NameNode处于从属地位，维护着数据状态，随时准备切换。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两个NameNode为了数据同步，会通过一组称作JournalNodes的独立进程进行相互通信。当active状态的NameNode的命名空间有任何修改时，会告知大部分的JournalNodes进程。standby状态的NameNode有能力读取JNs中的变更信息，并且一直监控edit log的变化，把变化应用于自己的命名空间。standby可以确保在集群出错时，命名空间状态已经完全同步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了确保快速切换，standby状态的NameNode有必要知道集群中所有数据块的位置。为了做到这点，所有的datanodes必须配置两个NameNode的地址，发送数据块位置信息和心跳给他们两个。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于HA集群而言，确保同一时刻只有一个NameNode处于active状态是至关重要的。否则，两个NameNode的数据状态就会产生分歧，可能丢失数据，或者产生错误的结果。为了保证这点，JNs必须确保同一时刻只有一个NameNode可以向自己写数据。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8963815789473685&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dRXPfxlVQkvDmENXeqxDJGibG9UjFoSb4MtxT63ZxZiaTAl8zJf04rNeRgjNibJUSXIV96qMvNplxRLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;608&quot;/&gt;&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ZKFC&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZKFC即ZKFailoverController，作为独立进程存在，负责控制NameNode的主备切换，ZKFC会监测NameNode的健康状况，当发现Active NameNode出现异常时会通过Zookeeper集群进行一次主备选举，完成Active和Standby状态的切换。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;HealthMonitor&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定时调用NameNode的HAServiceProtocol RPC接口(monitorHealth和getServiceStatus)，监控NameNode的健康状态并向ZKFC反馈。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ActiveStandbyElector&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接收ZKFC的选举请求，通过Zookeeper自动完成主备选举，选举完成后回调ZKFC的主备切换方法对NameNode进行Active和Standby状态的切换。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;JouranlNode集群&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;共享存储系统，负责存储HDFS的元数据，Active NameNode(写入)和Standby NameNode(读取)通过共享存储系统实现元数据同步，在主备切换过程中，新的Active NameNode必须确保元数据同步完成才能对外提供服务。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;DataNode工作机制&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.46016483516483514&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dRXPfxlVQkvDmENXeqxDJGibK8DSMYUbicVT3icYlAj76DQdHDtunUdCE17QDicJmw4FIwAN7I6ApcowQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;728&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）一个数据块在DataNode上以文件形式存储在磁盘上，包括两个文件，一个是数据本身，一个是元数据包括数据块的长度，块数据的校验和，以及时间戳。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）DataNode启动后向NameNode注册，通过后，周期性（1小时）的向NameNode上报所有的块信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）心跳是每3秒一次，心跳返回结果带有NameNode给该DataNode的命令如复制块数据到另一台机器，或删除某个数据块。如果超过10分钟没有收到某个DataNode的心跳，则认为该节点不可用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）集群运行中可以安全加入和退出一些机器。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;DataNode数据损坏&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）当DataNode读取Block的时候，它会计算CheckSum。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）如果计算后的CheckSum，与Block创建时值不一样，说明Block已经损坏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）Client读取其他DataNode上的Block。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）DataNode在其文件创建后周期验证CheckSum。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;压缩&lt;/span&gt;&lt;/h2&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;gzip压缩&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「应用场景」&lt;/strong&gt;&lt;/span&gt;：当每个文件压缩之后在130M以内的（1个块大小内），都可以考虑用gzip压缩格式。譬如说一天或者一个小时的日志压缩成一个gzip文件，运行mapreduce程序的时候通过多个gzip文件达到并发。hive程序，streaming程序，和java写的mapreduce程序完全和文本处理一样，压缩之后原来的程序不需要做任何修改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「优点」&lt;/strong&gt;&lt;/span&gt;：压缩率比较高，而且压缩/解压速度也比较快；hadoop本身支持，在应用中处理gzip格式的文件就和直接处理文本一样；有hadoop native库；大部分linux系统都自带gzip命令，使用方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「缺点」&lt;/strong&gt;&lt;/span&gt;：不支持split。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;snappy压缩&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「应用场景」&lt;/strong&gt;&lt;/span&gt;：当mapreduce作业的map输出的数据比较大的时候，作为map到reduce的中间数据的压缩格式；或者作为一个mapreduce作业的输出和另外一个mapreduce作业的输入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「优点」&lt;/strong&gt;&lt;/span&gt;：高速压缩速度和合理的压缩率；支持hadoop native库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「缺点」&lt;/strong&gt;&lt;/span&gt;：不支持split；压缩率比gzip要低；hadoop本身不支持，需要安装；linux系统下没有对应的命令。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;lzo压缩&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「应用场景」&lt;/strong&gt;&lt;/span&gt;：一个很大的文本文件，压缩之后还大于200M以上的可以考虑，而且单个文件越大，lzo优点越越明显。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「优点」&lt;/strong&gt;&lt;/span&gt;：压缩/解压速度也比较快，合理的压缩率；支持split，是hadoop中最流行的压缩格式；支持hadoop native库；可以在linux系统下安装lzop命令，使用方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「缺点」&lt;/strong&gt;&lt;/span&gt;：压缩率比gzip要低一些；hadoop本身不支持，需要安装；在应用中对lzo格式的文件需要做一些特殊处理（为了支持split需要建索引，还需要指定inputformat为lzo格式）。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;bzip2压缩&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「应用场景」&lt;/strong&gt;&lt;/span&gt;：适合对速度要求不高，但需要较高的压缩率的时候，可以作为mapreduce作业的输出格式；或者输出之后的数据比较大，处理之后的数据需要压缩存档减少磁盘空间并且以后数据用得比较少的情况；或者对单个很大的文本文件想压缩减少存储空间，同时又需要支持split，而且兼容之前的应用程序（即应用程序不需要修改）的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「优点」&lt;/strong&gt;&lt;/span&gt;：支持split；具有很高的压缩率，比gzip压缩率都高；hadoop本身支持，但不支持native；在linux系统下自带bzip2命令，使用方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「缺点」&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：压缩/解压速度慢&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;MapReduce工作流程&lt;/span&gt;&lt;/h2&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;MapTask工作流&lt;span/&gt;&lt;/h6&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.49643705463182897&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dRXPfxlVQkvDmENXeqxDJGib1ttian1GtlwKT0cXD5CvSaSRapKaUcovnzGWQs2iblThicbBicIAo9JB1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;842&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）Read阶段：MapTask通过用户编写的RecordReader，从输入InputSplit中解析出一个个key/value。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）Map阶段：该节点主要是将解析出的key/value交给用户编写map()函数处理，并产生一系列新的key/value。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）Collect收集阶段：在用户编写map()函数中，当数据处理完成后，一般会调用OutputCollector.collect()输出结果。在该函数内部，它会将生成的key/value分区（调用Partitioner），并写入一个环形内存缓冲区中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）Spill阶段：即“溢写”，当环形缓冲区满后，MapReduce会将数据写到本地磁盘上，生成一个临时文件。需要注意的是，将数据写入本地磁盘之前，先要对数据进行一次本地排序，并在必要时对数据进行合并、压缩等操作。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;pre data-source-line=&quot;170&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;溢写阶段详情：&lt;br/&gt;步骤1：利用快速排序算法对缓存区内的数据进行排序，排序方式是，先按照分区编号Partition进行排序，然后按照&lt;span&gt;key&lt;/span&gt;进行排序。这样，经过排序后，数据以分区为单位聚集在一起，且同一分区内所有数据按照&lt;span&gt;key&lt;/span&gt;有序。&lt;br/&gt;步骤2：按照分区编号由小到大依次将每个分区中的数据写入任务工作目录下的临时文件&lt;span&gt;output&lt;/span&gt;/spillN.&lt;span&gt;out&lt;/span&gt;（N表示当前溢写次数）中。如果用户设置了Combiner，则写入文件之前，对每个分区中的数据进行一次聚集操作。&lt;br/&gt;步骤3：将分区数据的元信息写到内存索引数据结构SpillRecord中，其中每个分区的元信息包括在临时文件中的偏移量、压缩前数据大小和压缩后数据大小。如果当前内存索引大小超过1MB，则将内存索引写到文件&lt;span&gt;output&lt;/span&gt;/spillN.&lt;span&gt;out&lt;/span&gt;.&lt;span&gt;index&lt;/span&gt;中。&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（5）Combine阶段：当所有数据处理完成后，MapTask对所有临时文件进行一次合并，以确保最终只会生成一个数据文件。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ReduceTask工作流&lt;span/&gt;&lt;/h6&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4604651162790698&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dRXPfxlVQkvDmENXeqxDJGibyyt7Aibat0X8mR6rkx86FZaF63fp4LjWpvHYagIxC5m7zgggZsBA1og/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;860&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）Copy阶段：ReduceTask从各个MapTask上远程拷贝一片数据，并针对某一片数据，如果其大小超过一定阈值，则写到磁盘上，否则直接放到内存中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）Merge阶段：在远程拷贝数据的同时，ReduceTask启动了两个后台线程对内存和磁盘上的文件进行合并，以防止内存使用过多或磁盘上文件过多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）Sort阶段：按照MapReduce语义，用户编写reduce()函数输入数据是按key进行聚集的一组数据。为了将key相同的数据聚在一起，Hadoop采用了基于排序的策略。由于各个MapTask已经实现对自己的处理结果进行了局部排序，因此，ReduceTask只需对所有数据进行一次归并排序即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）Reduce阶段：reduce()函数将计算结果写到HDFS上。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Yarn工作流（作业提交全过程）&lt;/span&gt;&lt;/h2&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.49759615384615385&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dRXPfxlVQkvDmENXeqxDJGibbx370qcxuMOVUNaLNCLehDz3wZeraTKI5G2c8ar8ZnNGj8LqwJtsug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;832&quot;/&gt;&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;1.作业提交&lt;span/&gt;&lt;br/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）Client调用job.waitForCompletion方法，向整个集群提交MapReduce作业。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）Client向RM申请一个作业id。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）RM给Client返回该job资源的提交路径和作业id。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）Client提交jar包、切片信息和配置文件到指定的资源提交路径。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（5）Client提交完资源后，向RM申请运行MrAppMaster。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.作业初始化&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（6）当RM收到Client的请求后，将该job添加到容量调度器中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（7）某一个空闲的NM领取到该Job。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（8）该NM创建Container，并产生MRAppmaster。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（9）下载Client提交的资源到本地。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.任务分配&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（10）MrAppMaster向RM申请运行多个MapTask任务资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（11）RM将运行MapTask任务分配给另外两个NodeManager，另两个NodeManager分别领取任务并创建容器。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.任务运行&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（12）MR向两个接收到任务的NodeManager发送程序启动脚本，这两个NodeManager分别启动MapTask，MapTask对数据分区排序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（13）MrAppMaster等待所有MapTask运行完毕后，向RM申请容器，运行ReduceTask。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（14）ReduceTask向MapTask获取相应分区的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（15）程序运行完毕后，MR会向RM申请注销自己。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.进度和状态更新&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;YARN中的任务将其进度和状态(包括counter)返回给应用管理器, 客户端每秒(通过mapreduce.client.progressmonitor.pollinterval设置)向应用管理器请求进度更新, 展示给用户。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.作业完成&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了向应用管理器请求作业进度外, 客户端每5秒都会通过调用waitForCompletion()来检查作业是否完成。时间间隔可以通过mapreduce.client.completion.pollinterval来设置。作业完成之后, 应用管理器和Container会清理工作状态。作业的信息会被作业历史服务器存储以备之后用户核查。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Yarn调度器&lt;/span&gt;&lt;/h2&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;先进先出调度器（FIFO）&lt;span/&gt;&lt;/h6&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.48091603053435117&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dRXPfxlVQkvDmENXeqxDJGibtMxzETJ4iahFmBb0x2BmrXEIKGkmiaSrjURHibVSJqGIdaBha9AuAq62w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;786&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;把应用按提交的顺序排成一个队列，这是一个先进先出队列，在进行资源分配的时候，先给队列中最头上的应用进行分配资源，待最头上的应用需求满足后再给下一个分配。&lt;/span&gt;&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;容量调度器（Capacity Scheduler）&lt;span/&gt;&lt;/h6&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.30453879941434847&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dRXPfxlVQkvDmENXeqxDJGibqZ8QwjpgXT0z7CR8IPtGHOic3qoxqicIoyAxLxM8s1w1gExX9kUg9azQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;683&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以队列为单位划分资源，每个队列可设定一定比例的资源最低保证和使用上限，同时，每个用户也可设定一定的资源使用上限以防止资源滥用。而当一个队列的资源有剩余时，可暂时将剩余资源共享给其他队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;特点 &lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）可为每个队列设置资源最低保证和资源使用上限，而所有提交到该队列的应用程序共享这些资源&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）：如果一个队列中的资源有剩余，可以暂时共享给那些需要资源的队列，而一旦该队列有新的应用程序提交，则其他队列释放的资源会归还给该队列&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）支持多用户共享集群和多应用程序同时运行。为防止单个应用程序、用户或队列独占集群中的资源，可为之增加多重约束（比如单个应用程序同时运行的任务数等）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）每个队列有严格的ACL列表规定它的访问用户，每个用户可指定哪些用户允许查看自己应用程序的运行状态或者控制应用程序（比如杀死应用程序）。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;公平调度器（Fair Scheduler）&lt;span/&gt;&lt;/h6&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2926470588235294&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dRXPfxlVQkvDmENXeqxDJGibMiaO0msLiaZfyJy1f0OGLY3nNRmpl8uhmg1mmC3nzDTVhOBibo4YTic5wA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;680&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公平调度器可以为所有的应用“平均公平”分配资源，当然，这种“公平”是可以配置的，称为权重，可以在分配文件中为每一个队列设置分配资源的权重，如果没有设置，默认是1（由于默认权重相同，因此，在不做配置的情况下，作业（队列）之间的资源占比相同）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;具有以下特点：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）允许资源共享,即当一个APP运行时,如果其它队列没有任务执行,则可以使用其它队列(不属于该APP的队列),当其它队列有APP需要资源时再将占用的队列释放出来.所有的APP都从资源队列中分配资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）当队列中有任务,该队列将至少获得最小资源.当队列资源使用不完时,可以给其它队列使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）当队列不能满足最小资源时,可以从其它队列抢占。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;HDFS小文件处理&lt;/span&gt;&lt;/h2&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;HDFS小文件弊端&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HDFS上每个文件都要在NameNode上建立一个索引，这个索引的大小约为150byte，这样当小文件比较多的时候，就会产生很多的索引文件，一方面会大量占用NameNode的内存空间，另一方面就是索引文件过大使得索引速度变慢。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;HDFS小文件解决方案&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1） Hadoop Archive
Hadoop Archive或者HAR，是一个高效地将小文件放入HDFS块中的文件存档工具，它能够将多个小文件打包成一个HAR文件，这样在减少namenode内存使用的同时，仍然允许对文件进行透明的访问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2） Sequence file
sequence file由一系列的二进制key/value组成，如果为key小文件名，value为文件内容，则可以将大批小文件合并成一个大文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）CombineFileInputFormat
用于将多个文件合并出成单独的Split，另外，它会考虑数据的存储位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）开启JVM重用
原理：一个Map运行在一个JVM上，开启重用的话，该Map在JVM上运行完毕后，JVM继续运行其他Map。（mapreduce.job.jvm.numtasks）
，对于大量小文件Job，可以减少45%运行时间&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Shuffle及优化&lt;/span&gt;&lt;/h2&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Shuffle过程&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Map方法之后，Reduce方法之前的数据处理过程称之为Shuffle&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考上面：&lt;strong&gt;MapReduce工作流程&lt;/strong&gt;&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Map阶段优化&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）增大环形缓冲区大小。由100m扩大到200m
（2）增大环形缓冲区溢写的比例。由80%扩大到90%
（3）减少对溢写文件的merge次数。（10个文件，一次20个merge）
（4）不影响实际业务的前提下，采用Combiner提前合并，减少 I/O。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Reduce阶段优化&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）合理设置Map和Reduce数：两个都不能设置太少，也不能设置太多。太少，会导致Task等待，延长处理时间；太多，会导致 Map、Reduce任务间竞争资源，造成处理超时等错误。（2）设置Map、Reduce共存：调整slowstart.completedmaps参数，使Map运行到一定程度后，Reduce也开始运行，减少Reduce的等待时间。（3）规避使用Reduce，因为Reduce在用于连接数据集的时候将会产生大量的网络消耗。（4）增加每个Reduce去Map中拿数据的并行数
（5）集群性能可以的前提下，增大Reduce端存储数据内存的大小。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;IO传输&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采用数据压缩的方式，减少网络IO的的时间。安装Snappy和LZOP压缩编码器。压缩：（1）map输入端主要考虑数据量大小和切片，支持切片的有Bzip2、LZO。注意：LZO要想支持切片必须创建索引；（2）map输出端主要考虑速度，速度快的snappy、LZO；（3）reduce输出端主要看具体需求，例如作为下一个mr输入需要考虑切片，永久保存考虑压缩率比较大的gzip。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;其他Shuffle优化参考下文：参数优化&lt;span/&gt;&lt;/h6&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Hadoop解决数据倾斜方法&lt;/span&gt;&lt;/h2&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;可以参考hive，spark，flink数据倾斜&lt;span/&gt;&lt;/h6&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;提前在map进行combine，减少传输的数据量&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Mapper加上combiner相当于提前进行reduce，即把一个Mapper中的相同key进行了聚合，减少shuffle过程中传输的数据量，以及Reducer端的计算量。如果导致数据倾斜的key大量分布在不同的mapper的时候，这种方法就不是很有效了。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;导致数据倾斜的key 大量分布在不同的mapper&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）局部聚合加全局聚合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次在map阶段对那些导致了数据倾斜的key 加上1到n的随机前缀，这样本来相同的key
也会被分到多个Reducer中进行局部聚合，数量就会大大降低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二次mapreduce，去掉key的随机前缀，进行全局聚合。思想：二次mr，第一次将key随机散列到不同reducer进行处理达到负载均衡目的。第二次再根据去掉key的随机前缀，按原key进行reduce处理。这个方法进行两次mapreduce，性能稍差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2） 增加Reducer，提升并行度:JobConf.setNumReduceTasks(int)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）实现自定义分区:根据数据分布情况，自定义散列函数，将key均匀分配到不同Reducer&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Hadoop的参数优化&lt;/span&gt;&lt;/h2&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;资源相关参数&lt;span/&gt;&lt;/h6&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;配置参数&lt;/th&gt;&lt;th&gt;参数说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;mapreduce.map.memory.mb&lt;/td&gt;&lt;td&gt;一个MapTask可使用的资源上限（单位:MB），默认为1024。如果MapTask实际使用的资源量超过该值，则会被强制杀死。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mapreduce.reduce.memory.mb&lt;/td&gt;&lt;td&gt;一个ReduceTask可使用的资源上限（单位:MB），默认为1024。如果ReduceTask实际使用的资源量超过该值，则会被强制杀死。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mapreduce.map.cpu.vcores&lt;/td&gt;&lt;td&gt;每个MapTask可使用的最多cpu core数目，默认值: 1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mapreduce.reduce.shuffle.parallelcopies&lt;/td&gt;&lt;td&gt;每个ReduceTask可使用的最多cpu core数目，默认值: 1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mapreduce.reduce.shuffle.merge.percent&lt;/td&gt;&lt;td&gt;每个Reduce去Map中取数据的并行数。默认值是5&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mapreduce.reduce.shuffle.input.buffer.percent&lt;/td&gt;&lt;td&gt;Buffer中的数据达到多少比例开始写入磁盘。默认值0.66&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mapreduce.reduce.input.buffer.percent&lt;/td&gt;&lt;td&gt;Buffer大小占Reduce可用内存的比例。默认值0.7 指定多少比例的内存用来存放Buffer中的数据，默认值是0.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;YARN&lt;span/&gt;&lt;/h6&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;配置参数&lt;/th&gt;&lt;th&gt;参数说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;yarn.scheduler.minimum-allocation-mb&lt;/td&gt;&lt;td&gt;给应用程序Container分配的最小内存，默认值：1024&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;yarn.scheduler.maximum-allocation-mb&lt;/td&gt;&lt;td&gt;给应用程序Container分配的最大内存，默认值：8192&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;yarn.scheduler.minimum-allocation-vcores&lt;/td&gt;&lt;td&gt;每个Container申请的最小CPU核数，默认值：1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;yarn.scheduler.maximum-allocation-vcores&lt;/td&gt;&lt;td&gt;每个Container申请的最大CPU核数，默认值：32&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;yarn.nodemanager.resource.memory-mb&lt;/td&gt;&lt;td&gt;给Containers分配的最大物理内存，默认值：8192&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Shuffle&lt;span/&gt;&lt;/h6&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;配置参数&lt;/th&gt;&lt;th&gt;参数说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;mapreduce.task.io.sort.mb&lt;/td&gt;&lt;td&gt;Shuffle的环形缓冲区大小，默认100m&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mapreduce.map.sort.spill.percent&lt;/td&gt;&lt;td&gt;环形缓冲区溢出的阈值，默认80%&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;容错相关参数&lt;span/&gt;&lt;/h6&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;配置参数&lt;/th&gt;&lt;th&gt;参数说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;mapreduce.map.maxattempts&lt;/td&gt;&lt;td&gt;每个Map Task最大重试次数，一旦重试参数超过该值，则认为Map Task运行失败，默认值：4。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mapreduce.reduce.maxattempts&lt;/td&gt;&lt;td&gt;每个Reduce Task最大重试次数，一旦重试参数超过该值，则认为Map Task运行失败，默认值：4。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mapreduce.task.timeout&lt;/td&gt;&lt;td&gt;Task超时时间，经常需要设置的一个参数，该参数表达的意思为：如果一个Task在一定时间内没有任何进入，即不会读取新的数据，也没有输出数据，则认为该Task处于Block状态，可能是卡住了，也许永远会卡住，为了防止因为用户程序永远Block住不退出，则强制设置了一个该超时时间（单位毫秒），默认是600000。如果你的程序对每条输入数据的处理时间过长（比如会访问数据库，通过网络拉取数据等），建议将该参数调大。&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0ca07aea47926e0a360f75be319c127a</guid>
<title>有备无患（GitHub 热点速览 v.21.38）</title>
<link>https://toutiao.io/k/c2uwe7a</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.66640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNMmZlibFPGes79kgyPUciaMc6mUNPeicclKJ4qwnQldQibicBY66IY0aeglOH7ic1iapfObHKFCwHeMsvwXQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：HelloGitHub-小鱼干&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库最重要的一个功能是容灾备份，备份不只是对数据库重要，对日常工作生活的我们一样重要，比如花了一个工作日写的代码没有备份（虽然可能只有 1 行…）总归是一个让人不爽的事情，Restic 是一个备份系统，可以帮备份自托管或线上服务，支持只备份变更部分内容。Atmosphere 可能对于一些 Switch 高玩并不陌生，它也能让你备份 Switch 相册以及游戏资料内容…&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下内容摘录自微博@HelloGitHub 的 GitHub Trending 及 Hacker News 热帖（简称 HN 热帖），选项标准：&lt;code&gt;新发布&lt;/code&gt; | &lt;code&gt;实用&lt;/code&gt; | &lt;code&gt;有趣&lt;/code&gt;，根据项目 release 时间分类，发布时间不超过 14 day 的项目会标注 &lt;code&gt;New&lt;/code&gt;，无该标志则说明项目 release 超过半月。由于本文篇幅有限，还有部分项目未能在本文展示，望周知 🌝&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8807947019867549&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMmZlibFPGes79kgyPUciaMc6ERp4pjIU8Vyo4r6M4EG2WmicPyXQQcvIfYIWeWJLV7ELnApgeSqxibAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;906&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;1. 本周特推&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 Switch 固件：Atmosphere&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：450+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Atmosphere 是一个非常知名的 Switch 破解系统，你可以用它来破解 Switch，然后备份相册里的内容，或者其他游戏资料。网上也有很多相关操作 Atmosphere 来破解 Switch 后进行例如安装 Android 系统之类的“骚操作”。如果你想玩点不一样的 Switch，也许可以试试 Atmosphere。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/Atmosphere-NX/Atmosphere&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMmZlibFPGes79kgyPUciaMc6nX43xoFwKl9xzEo3ZGArwX23MmbWhW2nbs7ISibaEFs3ia27ExxQic9oQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.20495495495495494&quot; data-w=&quot;888&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 图解 React 源码：react-illustration-series&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：800+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;react-illustration-series 是一个配大量图片来讲解 React 源码的项目，希望用图解的方式讲清楚 React 的背后原理。目前分为了 v16.13.1 和 v17.0.1 两个版本。下图为包结构配图。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/7kms/react-illustration-series&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7203703703703703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMmZlibFPGes79kgyPUciaMc6CbEfZnnw3xhKwKfjNU53qdroyqiakoeugknJRXgo7OY39dgNpfSkaaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;2. GitHub Trending 周榜&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 Python 小技巧：python-mini-projects&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：2,050+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python-Mini-Projects 收录了大量能提升你 Python 技能的小项目，从最简单的 Hello World，到 json 和 csv 的转换，到捕获视频帧等等 100+ 小项目。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/Python-World/python-mini-projects&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMmZlibFPGes79kgyPUciaMc6PHkozeOw8U2lJGTRWda7OJuAlicQ6jSCzxTzGSuA8p41wnvAFOysibCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.35051546391752575&quot; data-w=&quot;970&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 开源日历：calendso&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：1,300+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;calendso 是一款开源的日历组件，你可以基于它管理你的日常事项，例如备忘、会议事项，可基于自己的个人爱好来定制日历 UI。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/calendso/calendso&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMmZlibFPGes79kgyPUciaMc6q8nroHrnKEYHyhDNaOXnJy8Tqt2DomaH9Pzn7P3PqvhrWiciaiaHa4Hkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 AI 量化：Qlib&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：600+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Qlib 是一个面向人工智能的量化平台，旨在实现人工智能技术在量化的潜能。有了 Qlib 可以轻松尝试想法，以创建更好的量化策略。&lt;strong&gt;即便有 AI 帮忙，量化也需谨慎&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/microsoft/qlib&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMmZlibFPGes79kgyPUciaMc6RD7G2BvL6MnW52yWE9oXysGfDPcEkTZkk6UyTcI3P2w7bTvdgAbhKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.38636363636363635&quot; data-w=&quot;352&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 备份工具：restic&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：200+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Restic 是一个备份系统，用来备份文件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;支持 Linux、BSD、Mac 和 Windows 系统&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持多种存储类型，自托管的或者是线上服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;易用，不需要复杂的安装过程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高效，只备份文件中变更过的部分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;安全加密&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;校验系统&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;免费&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/restic/restic&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.42757417102966844&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMmZlibFPGes79kgyPUciaMc6VoiaqoF31auPEJzSrg9jicxtLjcpvuGnBlfaUy8v3cicpahTu4EUc8j7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1146&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5 单点登录：authelia&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：1,700+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Authelia 是一个开源的身份验证和授权工具，通过 Web 为应用程序提供双因素身份验证和单点登录（SSO）。它可搭配 Nginx、Traefik 或 HAProxy 等反向代理，让它们知道是否应该允许或重定向请求到 Authelia 进行身份验证。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/authelia/authelia&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMmZlibFPGes79kgyPUciaMc6d7ck9FBOibrBnQd2gkmne5UoIt4kqic61WesVZHZKZicqX3TXpx5eC3icQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.46131805157593125&quot; data-w=&quot;698&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;3. 往期回顾&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回顾之前，先来回复下 Elysium 的评论既然你已经提到了 OpenPose 这个项目这里不做赘述了，引用下 HelloGitHub vol.037 期卤蛋的项目介绍:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;OpenPose 基于卷积神经网络和监督学习的开源库，可以实现人的面部、躯干和四肢甚至手指的跟踪。适用于多人，且标记准确，同时具有较好的鲁棒性&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和他类似的项目，这里推荐一个 HyperPose，和 OpenPose 类似也是一个用来检测动态人体姿势的库。不过不清楚你具体想要了解的是哪块东西，推荐的项目有不错的文档，通过阅读文档来学习下实现也是一个不错的方式。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;HyperPose GitHub 地址：https://github.com/tensorlayer/hyperpose&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5633333333333334&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xBgIbW1vdNMmZlibFPGes79kgyPUciaMc6ZsUDuiaehKM0BalV2BmQHruiaTfAFzW8ajgeQ5tbHPvfdyvfe2pxC1kQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;往期回顾：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上为 2021 年第 38 个工作周的 GitHub Trending 🎉如果你 Pick 其他好玩、实用的 GitHub 项目，记得来 HelloGitHub issue 区和我们分享下哟 🌝&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，记得你在本文留言区留下你想看的主题 Repo（限公众号），例如：AI 换头。👀 和之前的送书活动类似，留言点赞 Top5 的小伙伴(&lt;span&gt;棒&lt;/span&gt;），小鱼干会努力去找 Repo 的^^&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub001 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~&lt;/p&gt;&lt;/blockquote&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA5MzYyNzQ0MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOqkqThUJBICyFBlvLvTyOCgBpibwWotSxGExfnOYFfPiaL9yn3GMUOCEVYN2RNslGCdQwgZy6ticdyA/0?wx_fmt=png&quot; data-nickname=&quot;HelloGitHub&quot; data-alias=&quot;GitHub520&quot; data-signature=&quot;分享 GitHub 上有趣、入门级的开源项目。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;👆 关注「HelloGitHub」第一时间收到更新&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;👆&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>27ae7164fa30f5cc799cb32d2dd4058c</guid>
<title>开源浪潮下程序员的职业规划和成长</title>
<link>https://toutiao.io/k/jqs1x8f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-hnrfcf&quot; options=&quot;[object Object]&quot;&gt;&lt;p&gt;无论从年初开源社发布的《2020 中国开源年度报告》还是整体的大环境，不难看到中国的开源正在崛起，越来越多的来自中国的开源项目和开发者们正在走入大家的视野。在开源浪潮的大趋势下，程序员又该如何规划自己的职业以及个人成长呢？不如听听正在全职做开源的工程师张晋涛怎么说。&lt;/p&gt;&lt;p&gt;大家好，今天我分享的主题是《开源浪潮下程序员的职业规划和成长》。今天在这里聊两个项目，一个是 Apache APISIX，APISIX 是 Apache 基金会旗下的顶级开源项目。第二个项目是 ingress-nginx，它是 Kubernetes 整个生态圈里头，除去 Kubernetes 自身以外使用频率最高的软件之一了。搞过 Kubernetes 的同学应该基本上都用过这个项目。&lt;/p&gt;&lt;p&gt;今天我分享的内容主要从四个方面来聊：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;开源的文化&lt;/li&gt;&lt;li&gt;如何参与开源&lt;/li&gt;&lt;li&gt;关于我的故事&lt;/li&gt;&lt;li&gt;职业规划相关的内容&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;了解开源文化&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;自由软件运动&lt;/b&gt;&lt;/p&gt;&lt;p&gt;提到开源文化，首先需要了解自由软件运动。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3e949cb619c4c8505966274a08fdd96d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;670&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-3e949cb619c4c8505966274a08fdd96d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;670&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-3e949cb619c4c8505966274a08fdd96d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-3e949cb619c4c8505966274a08fdd96d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;图右是被称为自由软件之父的斯托曼，他在 1983 年提出了 GNU 计划。1984 年，斯托曼提出了 Copyleft 的概念，Copyleft 跟我们平时用到的版权 Copyright 是相对应的，它放弃了 Copyright 类似对版权的严格限制。&lt;/p&gt;&lt;p&gt;1985 年，斯托曼成立了自由软件基金会，目的是为了能够让自由软件更好地发展。在当时，很多软件都是专有软件或者商用软件，任何人使用这些软件都是需要付费的。斯托曼认为随着计算机的发展，如果商用软件、付费软件掌握在极少数公司的情况下，那么我们将会逐步失去自由。因为很多商业软件或者专用软件都是由商业公司，或者是极少数的人掌握着，如果你依赖这些软件，都必须依赖于其他人，你的命脉就掌握在了他们手中，就不可能获得自由。&lt;/p&gt;&lt;p&gt;1989 年，出现了第一个 GNU 的通用协议，叫做 GPL。&lt;/p&gt;&lt;p&gt;接下来，我们来看下在自由软件运动之后发生了什么事情。想必大家都接触过 Linux 操作系统。Linux 操作系统的创始人是林纳斯·托瓦兹，他在 1991 年首次发布了 Linux 操作系统，并且选择了将它的源代码直接发布到网络上，供其他人去使用和分享。&lt;/p&gt;&lt;p&gt;在这个时候，斯托曼找到了林纳斯。GNU 自由软件基金会的主要目标是希望能够创建出所有人都可以使用的基础软件，包括操作系统。直到 1991 年 Linux 操作系统发布的时候，GNU 自由软件基金会已经完成了所有基础类的自由软件开发，但是它没完成最核心的操作系统的开发。所以，斯托曼找上了林纳斯。结果我们都知道，Linux 操作系统的完整名字是 GNU/Linux。&lt;/p&gt;&lt;p&gt;&lt;b&gt;开源协作与文化&lt;/b&gt;&lt;/p&gt;&lt;p&gt;聊完自由软件运动、Linux 操作系统，来看下我们现在所接触到的开源协作和开源文化。&lt;/p&gt;&lt;p&gt;&lt;b&gt;开放&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在开源协作中，基本的理念就是开放。但很多人可能对此有误解，认为开放源代码就等于开放，其实不然。源代码的开放和真正的开放并不一样。举个简单的例子：MongoDB。&lt;/p&gt;&lt;p&gt;MongoDB 是一个文档类型的数据库。近几年，MongoDB 修改了一次协议 SSPL，称之为服务端公共许可证，协议更改之后有什么变化呢？它的协议规定任何一个云厂商，如果在云服务上使用了 MongoDB，就必须把在 MongoDB 之上所做的更改，包括管控端的源代码都开源出来。&lt;/p&gt;&lt;p&gt;大家想一下这个事情可能吗？&lt;/p&gt;&lt;p&gt;其实不可能，任何一个云厂商，它对所有基础软件，或者所有开源软件的变更，都是它的核心，是它的命脉。所以说，MongoDB 这一次修改其实是带有针对性的，它针对的是这些云厂商。在开源软件的基本协定之下，这其实属于不开放的协议。&lt;/p&gt;&lt;p&gt;再有就是前段时间，Elasticsearch 也宣布其使用 SSPL，这导致 AWS 基于之前 Apache 协议的代码直接 fork 了一个版本，并称之为 OpenSearch 。这也是对这种不开放的行为的一种应对方式。&lt;/p&gt;&lt;p&gt;&lt;b&gt;协同&lt;/b&gt;&lt;/p&gt;&lt;p&gt;开源文化当中提到另外一点，就是协作。Linux 操作系统为什么能够获得成功？因为 1991 年的时候林纳斯发布了第一个 Linux 的版本，把源代码直接公开到了互联网上，其他人可以直接下载源代码，并且对这些源代码进行修改。&lt;/p&gt;&lt;p&gt;在 1991 年，林纳斯发布完 Linux 第一个可供下载和使用的版本时，其实自由软件基金会旗下还有其他人也在写给 GNU 使用的内核，只是没有 Linux 的完成度高。&lt;/p&gt;&lt;p&gt;为什么它没有发展起来呢？因为它是由固定的几个人在做这个事情，且仅有那么几个人，只有它真正对外公开发布了一个版本，外界才会了解到。这里就不得不提到一种思想，那就是大教堂与集市。这是一个什么概念呢？&lt;/p&gt;&lt;p&gt;可以这样理解，传统的软件开发过程像大家在修建一个大教堂一样，只有极少数的精英工匠参与其中。而开源软件提倡的开放和协同，主要指将软件当成一个大集市，每个人都是自由的，大家都可以互相协作，每个人贡献自己的一份力量。有专门一本书，来阐述这些理念，就叫做《大教堂与集市》，感兴趣可以看看。&lt;/p&gt;&lt;p&gt;&lt;b&gt;开源软件&lt;/b&gt;&lt;/p&gt;&lt;p&gt;聊完开源理念，我们最后来说说开源软件。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-67b0d49c80312016c3021bd8c063e26b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;627&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-67b0d49c80312016c3021bd8c063e26b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;627&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-67b0d49c80312016c3021bd8c063e26b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-67b0d49c80312016c3021bd8c063e26b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;开源软件的前提是开放源代码，这是必不可少的。另外，其实每个开源软件都是有开源许可证的，刚才我们聊 MongoDB 的时候也提到了，它的许可证是不被认可的。&lt;b&gt;开源软件核心价值观就是不歧视、中立、开放。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;目前国内开源生态整体向好，有很多进入开源软件基金会的项目，无论是进入 Apache 软件基金会，还是 CNCF，亦或 Linux 的基金会。其中有很多的项目例如 ApacheAPISIX 就是 Apache 基金会旗下的顶级开源项目，通过 Apache-2.0 License 进行分发，这是一种非常开放且友好的协议。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;如何参与开源&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;很多人对于参与开源有一些误解。有些人认为，我在使用一个开源软件，并且在它的 GitHub 上面提交了 issue，提交了 pull request 之类的，认为就是在参与开源项目了。还有一些人认为，我写了一个软件或者程序，我把它放在 GitHub 上面，代码是公开的，认为自己在做开源了。其实不然（尽管我们也认可为开源项目所做的贡献）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;做开源的前提是基于你对开源文化的认同。&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a25a43d07010fda57fdaf255b0412935_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;607&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-a25a43d07010fda57fdaf255b0412935_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;607&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-a25a43d07010fda57fdaf255b0412935_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a25a43d07010fda57fdaf255b0412935_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;开源文化的最主要是平等、中立、开放、一致、文档优先。一致是什么意思呢？意味着你的软件在这个环境和在另外一个环境当中产生的结果是一样的。&lt;/p&gt;&lt;p&gt;那么如何选择一个开源项目呢？&lt;/p&gt;&lt;p&gt;从我个人角度来讲，&lt;b&gt;首先一定是兴趣使然的。&lt;/b&gt;我不会选择一个自己并不太感兴趣的项目去参与。因为这样子是不可持续的。也有很多人问过我，参与开源你能收获什么？为什么你愿意花费那么多的时间和精力在这个事情上面？在参与开源项目的前期，或者很长的一段时间，其实没有任何收获，尤其是物质上的收获一点都没有。所以这也是我为什么提了一定是要自己感兴趣的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;其次，持续投入非常重要。&lt;/b&gt;在一个开源项目中，如果你只是想起来了参与一下，而不是持续地投入，也不会有较高的价值产生。&lt;/p&gt;&lt;p&gt;&lt;b&gt;最后，应该选择一个比较活跃的社区。&lt;/b&gt;如果项目的社区已经非常的不活跃，你参与到这个项目当中就很难。比如你提交 issue，提交 pull request，很少有人会给你对应的回复。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-621165ea526ca7cc5f601bf0a8ee067a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1164&quot; data-rawheight=&quot;710&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-621165ea526ca7cc5f601bf0a8ee067a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1164&quot; data-rawheight=&quot;710&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-621165ea526ca7cc5f601bf0a8ee067a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-621165ea526ca7cc5f601bf0a8ee067a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这里我选取了三个项目做对比，ApacheAPISIX、Kong 和 tyk。目前可以看到活跃度最高的是 Apache APISIX，每天都有很多的开发者会参与到 Apache APISIX 的社区中，帮助别人解答问题，或者为 Apache APISIX 提交 PR 等，大家彼此都会在这么活跃的社区中成长和收获。&lt;/p&gt;&lt;p&gt;&lt;b&gt;开源协作的中立也是一种很重要的价值观。&lt;/b&gt;无论你是提交代码，或者回复别人的 issue，这些我认为是其次的。最重要的是应该基于平等、尊重、中立的心态去参与到项目当中。&lt;/p&gt;&lt;p&gt;我现在主要参与的是 Apache APISIX 当中的一个子项目 APISIX ingress，还有一个是 Kubernetes ingress-nginx。这两个项目都是 Kubernetes controller 的项目，做的事情是类似的，但是参与开源项目过程中，我始终保持着中立的态度，而不会因为我在支流科技就大力发展 APISIX ingress 项目，限制 ingress-nginx 项目的发展，这是不存在的。所以心态很重要，只有保持中立的心态才能持续地参与到开源项目当中。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;聊聊我的故事&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;我的职业路径&lt;/b&gt;&lt;/p&gt;&lt;p&gt;接下来聊一下我发展的过程和职业规划上的选择。&lt;/p&gt;&lt;p&gt;我的第一份工作 title 是 Web 开发工程师，主要是在做后端开发，也会兼顾一部分的前端开发工作，以及运维及 DBA 的任务。第二份工作是在做运维开发，会涉及一部分的运维工作，主业也还是在做开发。再后来就是做容器化的开发，现在我是支流科技的技术专家，做的事情主要是做开源基础软件。这些年前端、后端、运维、数据库、中间件，基础软件，容器化技术基本都有涉及到，这是我的职业整体路线。&lt;/p&gt;&lt;p&gt;很多人问过我这样的问题，特别是在跟 HR 沟通的时候。他们会问我，你为什么从 Web 开发做了运维开发，这是第一个时间点。第二个时间点，为什么从运维开发，到做基础软件以及全职做开源的事情。&lt;/p&gt;&lt;p&gt;我做 Web 开发，大概是七八年前，那个时候像服务器通常是 32G 或者 64G 的内存。但是现在，我的笔记本已经是 32G 的内存了，可以想象当时硬件资源是比较紧张的。在实际做后端开发中，当业务量上来的时候，我们会去做很多性能优化相关的工作。&lt;/p&gt;&lt;p&gt;那个时候，我们会花很多的时间去做优化，现在遇到性能的问题可能很简单，加一台机器扩容一下就搞定了。但在那个时候大家的第一想法就是做性能优化，怎么样可以充分地压榨资源，这是我们当时做的事情。在这个过程当中，偏底层的事情我做得更多些。&lt;/p&gt;&lt;p&gt;在 2014 年，我开始接触 Docker。2013 年Docker 首次开源，我在国内算是比较早一批接触到 Docker 的。我很喜欢这些底层的技术，包括容器化的技术。在职业选择的时候，我就从 Web 开发转向了运维开发。做运维开发的时候，前期是做运维平台化的开发，运维平台化、运维自动化、包括 GitOps 和ChatOps 等等。&lt;/p&gt;&lt;p&gt;随着 Kubernetes 在容器化编排技术争夺战中成为了王者。很多公司开始做容器化改造，我们也选择了 Kubernetes 做自己的容器平台。这个时候，由于我在容器化技术这方面，积淀相对比较多一些，自然也就承担了相关的工作内容。&lt;/p&gt;&lt;p&gt;再后来工作的选择，因为我想要更多的自由，也想更倾向于自己的兴趣，而在公司做项目的话，确实不够自由，所以我现在的工作是全职做开源，我可以在任何一个我喜欢工作的时间，或者想要工作的时间去工作。&lt;/p&gt;&lt;p&gt;&lt;b&gt;有一些人评价我说，我是把我的兴趣做成了我的工作。&lt;/b&gt;其实是的，即使没有这份工作，我也会持续地去做开源。工作时间做开源，闲暇的时间也在做开源，这个本身来讲也没有什么界限。这是我目前的现状，自由、全职做开源的工程师。&lt;/p&gt;&lt;p&gt;&lt;b&gt;职业规划&lt;/b&gt;&lt;/p&gt;&lt;p&gt;接下来，我们来看一下职业规划。大家可能对于我到底是什么样的情况并不关心，更应该想知道在开源的场景里如何做职业规划。&lt;/p&gt;&lt;p&gt;我现在一方面是做开源相关的工作，再有一方面，也在做自媒体。&lt;b&gt;我认为做职业规划最重要的一点是基于自己的兴趣。&lt;/b&gt;一天一共就 24 小时，除去睡觉的时间，剩下的几个小时如果做的是自己不感兴趣的工作，一直处于不开心的状态，那真是太惨了。所以一定要选择自己喜欢的、感兴趣的工作，这是第一点。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第二点就是核心竞争力。&lt;/b&gt;既然是程序员，无论是前端、后端、运维，还是其他开发，自身的技术实力才是核心竞争力。现在有个词很流行，那就是“内卷”，为什么内卷会让人产生焦虑感呢？焦虑到底是怎么来的？&lt;/p&gt;&lt;p&gt;我是这么理解的，焦虑就是别人在学，我不学，我可能会很焦虑；别人会，我不会，我也会焦虑；别人知道，我不知道，那更焦虑；还有就是别人在聊这些，我听的一脸懵逼，这些都是焦虑的产生原因。&lt;/p&gt;&lt;p&gt;那如何应对这个问题呢？那就是提升你的核心竞争力。首先选一个自己最感兴趣的方向，提升自己的技术深度，这样才能持续地提升自己的核心竞争力。技术深度就跟海面上的冰山差不多，海面上你可以看到的只有那么一小点，但在海面之下还有很多很多。&lt;/p&gt;&lt;p&gt;技术的深度是无限的，当你把技术深度提升到一定程度之后，你会发现好像我不知道的东西越来越多，这是一个技术人常常会有的感觉。如果你很长时间没有这种感觉了，认为好像所有的东西我都知道，所有面临的问题我都能解决。这个情况我认为，你可能需要去参与一些开源项目，或者出去跟别人交流一下，或者换一份工作，开阔一下自己的眼界。&lt;b&gt;当你的技术深度到了一定程度，例如能 cover 住面临的绝大多数问题时，我建议你在这个时候尽量提升一下自己的技术广度。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;第三点我要说的是价值。&lt;/b&gt;价值这个概念非常宽泛，在做工作中最直观体现价值的，那就是薪资。当然，薪资只是一方面，另一方面在于你能够收获到什么。&lt;/p&gt;&lt;p&gt;我们回到刚才第一点，也就是工作开不开心的事情。如果说你的工作薪资是令人满意的，同时你又能收获一些开心，那就赚到了。因为公司本来给你提供的，是一种雇佣关系，他给到你的本质上来讲只有你的薪资。而你做这份工作的同时，收获了一些乐趣，其实也就是赚到了。&lt;b&gt;收获开心，这是我要提到价值当中的第一点。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;此外，在工作的过程当中，你肯定不是一个人在独自战斗，&lt;b&gt;你也会收获到一些伙伴，这是第二点。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;第三点，在这份工作当中，你还实现自己价值的提升。这些价值可以理解为心理学当中或者社会学当中提到的认可，&lt;b&gt;当你获得别人或者社会的一些认可。&lt;/b&gt;这也是价值的一部分。&lt;/p&gt;&lt;p&gt;&lt;b&gt;程序员的副业&lt;/b&gt;&lt;/p&gt;&lt;p&gt;最后我们来聊聊程序员的副业，这个事情也许大家会比较感兴趣一些。在谈到副业的时候，你要先评估一下自己能做什么，量力而行在任何情况下都是比较正确的。承认自己在某些方面不擅长，或者某些方面不太懂这个事情其实没有什么的，如果强行做不擅长的事情，可能得到的结果并不太好。&lt;/p&gt;&lt;p&gt;我来聊一下我自己个人做的一些东西。我之前写了一个专栏，叫 《Kubernetes 上手实践》。后来又写了一个专栏，叫做 《Docker 核心知识必会》。我自己在这方面相对来说积累比较多一点，这里就不多说了，说多了就变成广告了（笑），不过你可以关注下我的公众号：MoeLove ，我会跟你分享一些有价值的技术和内容。&lt;/p&gt;&lt;p&gt;很多人可能会问我能做什么？我认为其实还是有很多的事情可以做，具体肯定看个人的选择。做副业能为自己带来最直观的，大家可能认为是金钱收益。但实际上如果你把耗费的时间精力折算一下，可能会发现这个事情收益很少。陪陪家人、跟爱人约个会，出去玩一趟，可能能收获的更多。现在整体来说就是两种选择，一是用时间换钱，另一种是用钱换时间。很多事情如果年轻的时候错过了还是会很遗憾的。所以还是要建议大家根据自己的情况衡量一下。&lt;/p&gt;&lt;p&gt;以上是今天的全部分享内容，来简单总结下：第一部分聊了平等、中立、自由的开源文化；接着谈了如何参与开源，心态一定要摆正，同时要基于自己个人的兴趣；最后聊到一些个人成长，还是建议大家应根据自己的实际情况，合理地规划一下自己的的职业生涯，谢谢大家。&lt;/p&gt;&lt;p&gt;&lt;b&gt;视频与PPT请戳：&lt;/b&gt;&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/opentalk/463.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic3.zhimg.com/v2-5fff19c93245b8d497f7205401414536_180x120.jpg&quot; data-image-width=&quot;960&quot; data-image-height=&quot;540&quot; data-text=&quot;开源浪潮下程序员的职业规划和成长&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>062b9f1f557599b5ef228e9b6d1bf64e</guid>
<title>详解：为可折叠设备构建响应式 UI</title>
<link>https://toutiao.io/k/qp8mttr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-hnrfcf&quot; options=&quot;[object Object]&quot;&gt;&lt;blockquote&gt;&lt;i&gt;为可折叠设备和大屏设备优化您的应用&lt;/i&gt;&lt;/blockquote&gt;&lt;p&gt;Android 设备的屏幕尺寸日新月异，随着平板和可折叠设备的普及度越来越高，在开发响应式用户界面时，了解您应用的窗口尺寸和状态显得尤为重要。&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/jetpack/androidx/releases/window&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Jetpack WindowManager&lt;/a&gt;&lt;/b&gt; 现已进入 beta 测试阶段，这个库提供了与 Android 框架中 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/android/view/WindowManager&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;WindowManager&lt;/a&gt;&lt;/b&gt; 比较相似的功能，包括了对支持响应式 UI、检测屏幕改变的回调适配器和测试窗口 API 的支持。但 Jetpack WindowManager 还新增了对可折叠设备和 ChromeOS 这类窗口环境的支持。&lt;/p&gt;&lt;p&gt;新的 WindowManager API 包含了以下内容:&lt;/p&gt;&lt;p&gt;Jetpack WindowManager 不与 Android 绑定，这让 API 能够迅速地迭代以支持快速发展的市场，还让开发者们能够通过更新库而不必等待 Android 版本更新来获得支持。&lt;/p&gt;&lt;p&gt;现在，Jetpack WindowManager 库已进入 beta 测试阶段，我们鼓励所有开发者来使用 Jetpack WindowManager，其与设备无关 API、测试 API 以及它引入的 WindowMetrics，使您的应用能够轻松响应窗口尺寸的变化。已经进入 beta 测试阶段，意味着您可以安心地专注于在这些设备上打造激动人心的体验，Jetpack WindowManager 最低支持到 API 14。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;关于 Jetpack WindowManager&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Jetpack WindowManager 是一个以 Kotlin 优先的现代化库，它支持不同形态的新设备，并提供 &quot;类 AppCompat&quot; 的功能以构建具有响应式 UI 的应用。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;折叠状态&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;支持可折叠设备是 Jetpack WindowManager 库最直观的功能。当设备的折叠状态变化时，应用将收到相应的事件，进而更新 UI 界面以支持新的用户交互。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-40fdb52f1682a0f6369d3bd2270f7e89_b.gif&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;400&quot; data-thumbnail=&quot;https://pic2.zhimg.com/v2-40fdb52f1682a0f6369d3bd2270f7e89_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-40fdb52f1682a0f6369d3bd2270f7e89_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;400&quot; data-thumbnail=&quot;https://pic2.zhimg.com/v2-40fdb52f1682a0f6369d3bd2270f7e89_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-40fdb52f1682a0f6369d3bd2270f7e89_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-40fdb52f1682a0f6369d3bd2270f7e89_b.gif&quot;/&gt;&lt;figcaption&gt;△ 在 Samsung Galaxy Z Fold2 上运行的 Google Duo&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;您可以通过 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/stories/apps/google-duo&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Google Duo 学习案例&lt;/a&gt;&lt;/b&gt; 来了解如何支持可折叠设备。&lt;/p&gt;&lt;p&gt;折叠状态有两种，分别是 FLAT (展平) 和 HALF_OPENED (半开)。对于 FLAT，您可以认为表面是完全平整打开的，尽管有些情况下它有可能被铰链分割。对于 HALF_OPENED，窗口中有至少两个逻辑区域。我们在下方用图片说明了每种状态各自可能的情况。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0630a1cd34c997a498a16990189dd1fe_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;700&quot; data-rawheight=&quot;350&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-0630a1cd34c997a498a16990189dd1fe_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;700&quot; data-rawheight=&quot;350&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-0630a1cd34c997a498a16990189dd1fe_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0630a1cd34c997a498a16990189dd1fe_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;△ 折叠状态: &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/androidx/window/layout/FoldingFeature.State.Companion%23FLAT%28%29&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;FLAT&lt;/a&gt;&lt;/b&gt; 和 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/androidx/window/layout/FoldingFeature.State.Companion%23HALF_OPENED%28%29&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;HALF-OPENED&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在应用活跃的状态下，可以通过 Kotlin 数据流收集事件来获得折叠状态改变的信息。&lt;/p&gt;&lt;p&gt;我们通过 lifecycleScope 来控制事件收集的开始和结束，正如文章《&lt;b&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/404496482&quot; class=&quot;internal&quot;&gt;设计 repeatOnLifeCycle API 背后的故事&lt;/a&gt;&lt;/b&gt;》和示例代码所述:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;&lt;span class=&quot;n&quot;&gt;lifecycleScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 传递给 repeatOnLifecycle 的代码块将在生命周期进入 STARTED 时执行
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;c1&quot;&gt;// 并在生命周期为 STOPPED 时取消
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;c1&quot;&gt;// repeatOnLifecycle 将会在生命周期再次进入 STARTED 时自动重启代码块
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;n&quot;&gt;lifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;repeatOnLifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;STARTED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 当生命周期处于 STARTED 时安全地从 windowInfoRepository 中收集数据
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;        &lt;span class=&quot;c1&quot;&gt;// 当生命周期进入 STOPPED 时停止收集数据
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;        &lt;span class=&quot;n&quot;&gt;windowInfoRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;windowLayoutInfo&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;collect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newLayoutInfo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;updateStateLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newLayoutInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;updateCurrentState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newLayoutInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当用户可以看到应用时，应用可以使用其接收到的 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/androidx/window/layout/WindowLayoutInfo&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;WindowLayoutInfo&lt;/a&gt;&lt;/b&gt; 对象中包含的信息更新布局。&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/androidx/window/layout/FoldingFeature&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;FoldingFeature&lt;/a&gt;&lt;/b&gt; 包括了诸如铰链 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/androidx/window/layout/FoldingFeature%23orientation%28%29&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;方向&lt;/a&gt;&lt;/b&gt;，及折叠功能是否创建了两个逻辑屏幕区域 (&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/androidx/window/layout/FoldingFeature%23isSeparating%28%29&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;isSeparating&lt;/a&gt;&lt;/b&gt; 属性) 这类信息。我们能使用这些值来检查设备是否处于桌面模式 (屏幕半开并且铰链处于水平方向):&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-42c9ba1f1c95ec280efa48e0ada455dd_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;273&quot; data-rawheight=&quot;144&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;273&quot; data-rawheight=&quot;144&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-42c9ba1f1c95ec280efa48e0ada455dd_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 设备处于 TableTop 模式&lt;/figcaption&gt;&lt;/figure&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isTableTopMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foldFeature&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FoldingFeature&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;foldFeature&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isSeparating&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; 
            &lt;span class=&quot;n&quot;&gt;foldFeature&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;orientation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FoldingFeature&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Orientation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HORIZONTAL&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或者书本模式 (屏幕半开并且铰链处于垂直方向):&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b55082e90258dfd70d2975626b5641aa_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;166&quot; data-rawheight=&quot;180&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;166&quot; data-rawheight=&quot;180&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b55082e90258dfd70d2975626b5641aa_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 设备处于 Book 模式&lt;/figcaption&gt;&lt;/figure&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isBookMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foldFeature&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FoldingFeature&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;foldFeature&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isSeparating&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;foldFeature&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;orientation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FoldingFeature&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Orientation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;VERTICAL&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;请参阅: &lt;b&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/404026291&quot; class=&quot;internal&quot;&gt;可折叠设备中的桌面模式&lt;/a&gt;&lt;/b&gt;，文内示例介绍了如何在媒体播放器应用中实现这样的功能。&lt;/p&gt;&lt;blockquote&gt;&lt;i&gt;&lt;b&gt;注意:&lt;/b&gt;&lt;/i&gt; &lt;i&gt;在主线程/UI 线程中收集事件这点十分重要，这能避免在 UI 和事件处理之间的同步问题。&lt;/i&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;支持响应式 UI&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Android 设备的屏幕尺寸变化十分频繁，因此着手设计能够完全自适应和响应式的 UI 非常重要。Jetpack WindowManager 库中包含的另一个功能——能够检索当前窗口和最大窗口的指标信息。这和 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/android/view/WindowMetrics&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;API 30 当中的 WindowMetrics API&lt;/a&gt;&lt;/b&gt; 类似，但它向后兼容到 API 14。&lt;/p&gt;&lt;p&gt;Jetpack WindowManager 提供了两种途径来检索 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/androidx/window/layout/WindowMetrics&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;WindowMetrics&lt;/a&gt;&lt;/b&gt; 信息，通过数据流事件中的流或者通过 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/androidx/window/layout/WindowMetricsCalculator&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;WindowMetricsCalculator&lt;/a&gt;&lt;/b&gt; 类进行同步处理。&lt;/p&gt;&lt;p&gt;当在编写视图代码时，使用异步 API 可能比较困难 (比如 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/android/view/View%23onMeasure%28int%2C%2520int%29&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;onMeasure&lt;/a&gt;&lt;/b&gt;)，此时可以使用 WindowMetricsCalculator。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;windowMetrics&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;WindowMetricsCalculator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getOrCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;computeCurrentWindowMetrics&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另一个使用场景是用于测试中 (详见下面的测试一节)。&lt;/p&gt;&lt;p&gt;在处理应用 UI 的高阶用法中，通过该库提供的 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/androidx/window/layout/WindowInfoRepository%23currentWindowMetrics%28%29&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;WindowInfoRepository#currentWindowMetrics&lt;/a&gt;&lt;/b&gt; 能够在窗口尺寸变更时收到通知，这与是否触发配置变更无关。&lt;/p&gt;&lt;p&gt;这个例子是关于如何根据可用区域来切换您的布局:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 因为 repeatOnLifecycle 是挂起函数，所以创建一个新的协程
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;n&quot;&gt;lifecycleScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;c1&quot;&gt;// 传递给 repeatOnLifecycle 的代码块将在生命周期进入 STARTED 时执行
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;c1&quot;&gt;// 并在生命周期为 STOPPED 时取消
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;c1&quot;&gt;// 它将会在生命周期再次进入 STARTED 时自动重启
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;   &lt;span class=&quot;n&quot;&gt;lifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;repeatOnLifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;STARTED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;c1&quot;&gt;// 当生命周期处于 STARTED 时安全地从 windowInfoRepository 中收集数据
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;       &lt;span class=&quot;c1&quot;&gt;// 当生命周期进入 STOPPED 时停止收集数据
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;       &lt;span class=&quot;n&quot;&gt;windowInfoRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentWindowMetrics&lt;/span&gt;
           &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;collect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;windowMetrics&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
               &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;currentBounds&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;windowMetrics&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bounds&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TAG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;New bounds: {$currentBounds}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
               &lt;span class=&quot;c1&quot;&gt;// 我们可以根据需要在这里更新布局
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;           &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;回调适配器&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;要在 Java 编程语言中使用这个库或者使用回调接口，请在您的应用中添加 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/jetpack/androidx/releases/window%23declaring_dependencies&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;androidx.window:window-java&lt;/a&gt;&lt;/b&gt;依赖。该组件提供了 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/androidx/window/java/layout/WindowInfoRepositoryCallbackAdapter&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;WindowInfoRepositoryCallbackAdapter&lt;/a&gt;&lt;/b&gt;，您可以通过它注册 (取消注册) 一个用以接收设备姿态及窗口指标信息更新的回调。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SplitLayoutActivity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AppCompatActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

   &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WindowInfoRepositoryCallbackAdapter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;windowInfoRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ActivitySplitLayoutBinding&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LayoutStateChangeCallback&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;layoutStateChangeCallback&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LayoutStateChangeCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

   &lt;span class=&quot;n&quot;&gt;@Override&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;@Nullable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bundle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

       &lt;span class=&quot;n&quot;&gt;binding&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ActivitySplitLayoutBinding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inflate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLayoutInflater&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;setContentView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRoot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

       &lt;span class=&quot;n&quot;&gt;windowInfoRepository&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WindowInfoRepositoryCallbackAdapter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WindowInfoRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getOrCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;n&quot;&gt;@Override&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;windowInfoRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addWindowLayoutInfoListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;layoutStateChangeCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;n&quot;&gt;@Override&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onStop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onStop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;windowInfoRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;removeWindowLayoutInfoListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layoutStateChangeCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LayoutStateChangeCallback&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WindowLayoutInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;@Override&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;accept&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WindowLayoutInfo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;windowLayoutInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;splitLayout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;updateWindowLayout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;windowLayoutInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;测试&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;开发者们讲到，更健壮的测试 API 对于维护 LTS (长期支持) 是十分关键的。让我们来聊聊如何在普通设备上测试可折叠设备姿态。&lt;/p&gt;&lt;p&gt;现在，我们已经知道 Jetpack WindowManager 库可以在设备姿态改变时，向您的应用发送通知，以便您修改应用的布局。&lt;/p&gt;&lt;p&gt;该库在 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/jetpack/androidx/releases/window%23declaring_dependencies&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;androidx.window:window-testing&lt;/a&gt;&lt;/b&gt; 中提供了 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/androidx/window/testing/layout/WindowLayoutInfoPublisherRule&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;WindowLayoutInfoPublisherRule&lt;/a&gt;&lt;/b&gt; 让您能够发布一个 &lt;code&gt;WindowInfoLayout&lt;/code&gt; 以支持测试 FoldingFeature:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;androidx.window.testing.layout.FoldingFeature&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;androidx.window.testing.layout.WindowLayoutInfoPublisherRule&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以在测试中虚拟一个 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/androidx/window/testing/layout/DisplayFeatureTesting&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;FoldingFeature&lt;/a&gt;&lt;/b&gt;:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;feature&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FoldingFeature&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;activity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;activity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;center&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;orientation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VERTICAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HALF_OPENED&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;expected&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;WindowLayoutInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Builder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setDisplayFeatures&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;listOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;publisherRule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;overrideWindowLayoutInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后使用 &lt;code&gt;WindowLayoutInfoPublisherRule&lt;/code&gt; 来发布它:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;publisherRule&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WindowLayoutInfoPublisherRule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;publisherRule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;overrideWindowLayoutInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后，使用可用的 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/testing/espresso/cheat-sheet&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Espresso 匹配器&lt;/a&gt;&lt;/b&gt; 来检查我们正在测试的 Activity 的布局是否符合预期。&lt;/p&gt;&lt;p&gt;下面这个测试中发布了一个处于 &lt;code&gt;HALF_OPENED&lt;/code&gt; 状态并且铰链垂直于屏幕中心的 FoldingFeature:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;&lt;span class=&quot;n&quot;&gt;@Test&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;testDeviceOpen_Vertical&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Unit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;runBlockingTest&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;activityRule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scenario&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;activity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;feature&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FoldingFeature&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;activity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;activity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;orientation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VERTICAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HALF_OPENED&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;expected&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;WindowLayoutInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Builder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setDisplayFeatures&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;listOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

       &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;activity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;windowInfoRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;windowLayoutInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;publisherRule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;overrideWindowLayoutInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;runBlockingTest&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;Assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;assertEquals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
           &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 检查在有垂直折叠特性时 start_layout 在 end_layout 的左侧
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;c1&quot;&gt;// 这需要在足够大的屏幕上运行测试以适应屏幕上的两个视图
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;   &lt;span class=&quot;n&quot;&gt;onView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;withId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start_layout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;check&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isCompletelyLeftOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;withId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end_layout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;查看示例代码&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Github 上的 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/android/user-interface-samples/tree/main/WindowManager&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;最新示例&lt;/a&gt;&lt;/b&gt; 展示了如何使用 Jetpack WindowManager 库从 &lt;code&gt;WindowLayoutInfo&lt;/code&gt; 流收集信息，或者通过向 &lt;code&gt;WindowInfoRepositoryCallbackAdapter&lt;/code&gt; 注册回调来获取显示姿态信息。&lt;/p&gt;&lt;p&gt;该实例还包含一些测试，它们可以在任何设备或模拟器中运行。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;在您的应用中使用 WindowManager&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;可折叠设备及双屏设备不再仅仅是实验性的或前瞻的——大屏幕空间和额外的设备姿态已经被证实是具有用户价值的，而且现在有更多的设备可供您的用户选择。可折叠设备和双屏设备代表了智能手机的自然进化。对于 Android 开发者来说，这提供了一个进入正在增长的高端市场的机会，感谢设备制造商们重新开始关注大屏设备。&lt;/p&gt;&lt;p&gt;我们去年推出了 &lt;b&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/388825565&quot; class=&quot;internal&quot;&gt;Jetpack WindowManager alpha01 版本&lt;/a&gt;&lt;/b&gt;。该库自那时起开始稳步地发展，早期的反馈让其有了很大的改进。现在，它已经拥抱了 Android 的 Kotlin 优先理念，从回调驱动模型逐渐过渡到协程和数据流。随着 WindowManager 进入测试阶段，API 已经稳定，我们强烈建议使用它。&lt;/p&gt;&lt;p&gt;更新并不仅限于此。我们计划为该库添加更多功能，并使其发展成为与 AppCompat 解绑的系统 UI 库，使开发者能够在所有的 Android 设备上轻松实现现代化的、响应式的 UI。&lt;/p&gt;&lt;p&gt;欢迎您 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//services.google.cn/fb/forms/androiddevswechat2/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;点击这里&lt;/a&gt;&lt;/b&gt; 向我们提交反馈，或分享您喜欢的内容、发现的问题。您的反馈对我们非常重要，感谢您的支持！&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>604f5474b0a5f8d96fe63f0db6ebd045</guid>
<title>16 张图解锁 Spring 的整体脉络</title>
<link>https://toutiao.io/k/bynegiy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天来梳理下 &lt;strong&gt;Spring&lt;/strong&gt; 的整体脉络啦，为后面的文章做个铺垫~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面几篇文章应该会讲讲这些内容啦 😆&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Spring  AOP 插件 🐖  （🕊了好久都忘了 😅）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分享下  &lt;strong&gt;4ye&lt;/strong&gt; 在项目中利用  &lt;strong&gt;AOP + MybatisPlus&lt;/strong&gt;   对项目进行重构，优化系统中特殊的日志模块的故事&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring &lt;strong&gt;属性注入&lt;/strong&gt; , &lt;strong&gt;循环依赖&lt;/strong&gt;，&lt;strong&gt;事务&lt;/strong&gt; 等这几个比较重要的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring  源码中的要点  &lt;strong&gt;AbstractApplicationContext&lt;/strong&gt;  中的 &lt;strong&gt;refresh&lt;/strong&gt; 方法里的 12 个方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring 中的设计模式  等等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;目前就想到这么多啦🐷&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;话说咱们一直都在用这个 Spring  ，你们对它的感受是啥呀？还是说说不出来 哈哈&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4ye 的感觉也是零零散散的，而且印象中一直都在用 Springboot ，不用再配置一堆东西呀，管理依赖啥的，方便太多了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以借此机会简单梳理下其中的一些脉络，这样去看源码就有条理多啦，更能知道一些扩展点的使用等😝&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;目录&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文会先大概介绍下这些知识点 👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6292372881355932&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYRAzh9fXT7e7ep8M5yAtf18ibz4LM6uaGicwxvXNXTT3w9ZSgNU2ic20iaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;944&quot;/&gt;&lt;figcaption&gt;image-20210904200622280&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;印象中的 Spring&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;脑海中有这么一条公式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;👉  IOC  = 工厂模式 + XML + 反射&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;👉 而 DI ,  AOP ， &lt;strong&gt;事务&lt;/strong&gt; 等也都在  XML  中很直观的表现出来&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然我们现在大部分用这个注解来代替，但是原理还是基本一样的🐖&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注解使用起来很方便，但是学习的话，还是建议先通过这个 XML ，毕竟结构性的文档，有层次感，可以留下更深的印象~ 😄&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小小Spring&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把 Spring 浓缩一下，就有了这么一点小东西🐖&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6832116788321168&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYJaPwb8Q4qfnumnrqKuMEhtibm3Z2BuomvIuVBgsbjVMzsj6wISZSgBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;685&quot;/&gt;&lt;figcaption&gt;image-20210831215104931&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想了下，我们用 Spring ，其中最主要的一点，就是用它来帮我们管理，创建这个 Bean 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么先从源头看起  —— Bean 从哪来 (＠_＠;)&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Bean 解析流程&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.49678012879484823&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYaQvLdLoiazvicj4nswAZQv3Z13yLnQo0h3576OYntY2juqicJWrwbwggQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1087&quot;/&gt;&lt;figcaption&gt;image-20210901220458461&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图所示，就是通过 &lt;strong&gt;解析器&lt;/strong&gt;，对我们的 XML 文件或者注解进行解析，最后将这些信息封装在  BeanDefinition 类中，并通过 BeanDefinitionRegistry 接口将这些信息 &lt;strong&gt;注册&lt;/strong&gt; 起来，放在 beanDefinitionMap 变量中, key : beanName , value ：BeanDefinition &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单看看  BeanDefinition 中的属性叭&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;BeanDefinition&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;beanClass  :  bean 的类型 ，实例化时用的 🐖&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;scope  :  作用范围有 singleton，prototype&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;isLazy   :  &lt;strong&gt;懒加载&lt;/strong&gt; ，true  的话 会在 getBean 时生成，而且 scope 的 prototype 无效，false 在 Spring 启动过程中直接生成&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;initMethodName  :  初始化方法，当然是初始化时调用🐖&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;primary  :  主要的，有多个 Bean 时使用它&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;dependsOn  :   依赖的Bean，必须等依赖Bean 创建好才可以创建&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;PS: @Component ，@Bean ,&lt;bean&gt;都会被解析成 BeanDefinition&lt;/bean&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;反射&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了原料后呢，&lt;span&gt;咱&lt;/span&gt;们再来看看这个 &lt;strong&gt;工厂&lt;/strong&gt; BeanFactory&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先简单想一想这个工厂要怎么创建这个 Bean 呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，肯定就是这个 &lt;strong&gt;反射&lt;/strong&gt; 啦 😄&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，结合我们从原料中获取的重要属性之一的 beanClass ，我们可以画出这么一张图 👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.44776119402985076&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYnoKibDt7iaoUBBYYLZDmiaUuVp0qNbLC9iaqNpO5Rk8E0ErObSePlPnQUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;670&quot;/&gt;&lt;figcaption&gt;image-20210901221544464&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们再来看看这个 BeanFactory 叭 😄&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;BeanFactory&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来看看 作为IOC 容器的&lt;strong&gt;根接口&lt;/strong&gt; 的 BeanFactory  提供了什么方法吧👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9006849315068494&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYFS4iafIWZH0GvxNiaVUCfmR0Ce9kDcSB2sibXUu4Ug9km7pRxnRA4RhBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;584&quot;/&gt;&lt;figcaption&gt;image-20210904162844126&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要是这个 getBean 方法，以及 &lt;strong&gt;别名获取&lt;/strong&gt;，&lt;strong&gt;类型获取&lt;/strong&gt; 方法和其他一些判断方法如 ：&lt;strong&gt;单例&lt;/strong&gt;，&lt;strong&gt;多例&lt;/strong&gt;，&lt;strong&gt;类型匹配&lt;/strong&gt;，&lt;strong&gt;包含bean&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来简单看看它的子接口都有哪些叭~😄&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里分享个小技巧叭🐖&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看源码的时候，一般就直接看这个&lt;strong&gt;默认&lt;/strong&gt;接口 如这里的 DefaultListableBeanFactory&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.488013698630137&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYgdSZWQ2TcpeDVImcK6jrrI0PiapV1Gy2AjJ0eh5mRzz9u2tBXC6Kozw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1168&quot;/&gt;&lt;figcaption&gt;image-20210904161436139&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本上看个类名就知道大概作用了，那么先对号入座下👇&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ListableBeanFactory&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;👉 遍历 bean&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;HierarchicalBeanFactory&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;👉  提供 父子关系，可以获取上一级的 BeanFactory&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ConfigurableBeanFactory&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;👉  实现了 SingletonBeanRegistry ，主要是 单例Bean的注册，生成&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;AutowireCapableBeanFactory&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;👉  和自动装配有关的&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;AbstractBeanFactory&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;👉  单例缓存，以及 FactoryBean 相关的&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ConfigurableListableBeanFactory&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;👉  预实例化单例Bean，分析，修改 BeanDefinition&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;AbstractAutowireCapableBeanFactory&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;👉 创建 Bean ，属性注入，实例化，调用初始化方法 等等&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;DefaultListableBeanFactory&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;👉 支持单例Bean ，Bean别名 ，父子BeanFactory，Bean 类型转化 ，Bean 后置处理，FactoryBean，自动装配等&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是不是非常丰富 😄&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;FactoryBean&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FactoryBean  ，它本身就是个 Bean，算是小工厂 ，归 BeanFactory 这个大工厂管理的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3247863247863248&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYdicclg8dIQDH1qozmmDEPPg9EjiayyuJoGfco6eyoKiaAtibYxLmcvJBHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;585&quot;/&gt;&lt;figcaption&gt;image-20210904174616712&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到它就只有三个方法&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;getObject() 获取对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;isSingleton() 单例对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;getObjectType()  返回的是 Bean 对象的类型&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比大工厂 BeanFactory 少了特别多东西，没有严格的 Bean 生命周期流程&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 👉 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MjUzODc5Mw==&amp;amp;mid=2247488639&amp;amp;idx=1&amp;amp;sn=e772f1c8ba3110b4311df9ce39837966&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《三分钟快速了解Spring中的工厂模式》&lt;/a&gt; 一文中有介绍到 😄&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FacotryBean 对象本身也是一个Bean，是一个小工厂，可以生产另外的 Bean&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BeanFactory 是 Spring 容器的根接口，是大工厂，生产各种各样的Bean&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;beanName  就是正常对象&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“&amp;amp;”+beanName   ， 获取的是实现了该接口的 FacotryBean 工厂对象&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大致如下 👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3133874239350913&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYP30NxrKoDOyLibRPheGib5vznatgWyfJY7Z4RqBWWUNMUKQFDlickrf7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;986&quot;/&gt;&lt;figcaption&gt;image-20210904180204105&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ApplicationContext&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看看这个 ApplicationContext&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2833904109589041&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYypLS6YT6DXTW5ibwicrvV6VmFCmsZBVtzpl6gIZvdfGBPG5gTzWibzmBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1168&quot;/&gt;&lt;figcaption&gt;image-20210904161808341&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到它扩展了很多功能，除了 BeanFactory ，它还可以&lt;strong&gt;创建 , 获取 Bean&lt;/strong&gt;，以及处理&lt;strong&gt;国际化&lt;/strong&gt;，&lt;strong&gt;事件&lt;/strong&gt;，&lt;strong&gt;获取资源&lt;/strong&gt;等&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;EnvironmentCapable  获取 环境变量 的功能，可以获取到 &lt;strong&gt;操作系统变量&lt;/strong&gt; 和 &lt;strong&gt;JVM 环境变量&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ListableBeanFactory 获取所有 BeanNames，判断某个 BeanName 是否存在 BeanDefinition 对象，统计 BeanDefinition 对象，获取某个类型对应的所有 beanNames 等功能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HierarchicalBeanFactory  获取父 BeanFactory ，判断某个 name 是否存在 bean 对象的功能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MessageSource  &lt;strong&gt;国际化功能&lt;/strong&gt;，获取某个国际化资源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ApplicationEventPublisher &lt;strong&gt;事件发布功能&lt;/strong&gt;（重点）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ResourcePatternResolver &lt;strong&gt;加载，获取资源的功能&lt;/strong&gt;，这里的资源可能是文件，图片 等某个URL资源都可以&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有这三个重要的类👇,就不一一介绍先啦😄&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ClassPathXmlApplicationContext&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AnnotationConfigApplicationContext&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;FileSystemXmlApplicationContext&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;赶紧来看看这个核心叭！&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;IOC 容器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，这时候出场的肯定是 IOC 啦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道 IOC 是 &lt;strong&gt;控制反转&lt;/strong&gt;  ，但是别忘了 &lt;strong&gt;容器&lt;/strong&gt; 这个词，比如 **容器的根接口 **BeanFactory  ，&lt;strong&gt;容器的实现&lt;/strong&gt; 👇&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ClassPathXmlApplicationContext&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AnnotationConfigApplicationContext&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;FileSystemXmlApplicationContext&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时我们要注意这里无处不在的 &lt;strong&gt;后置处理器&lt;/strong&gt;  xxxPostProcessor 🐷&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是 Spring 中扩展性强的原因了！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以在各个过程中合理应用这些 PostProcessor 来扩展，或者修改 Bean 定义信息等等&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6658986175115207&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYg6Y9Fxiae2KkD8NmzAuBpdz8Yh1rZ9rocHMjVQj91bnbC0oiam7VMaQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;868&quot;/&gt;&lt;figcaption&gt;image-20210901222805351&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到在这个容器中，完成了 Bean 的初始化，而这个过程还有很多细节 ，请往下看看👇&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DI 到时写 &lt;strong&gt;属性填充&lt;/strong&gt; 时再介绍🐷&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;BeanFactory 后置处理器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为 IOC 容器根接口的 BeanFactory ，有着非常高的扩展性，比如最开始获取原料 BeanDefinition  时，就出现了两个针对 BeanFactory  工厂的后置处理器 👇&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BeanDefinitionRegistryPostProcessor&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;通过该接口，我们可以自己掌控我们的 &lt;strong&gt;原料&lt;/strong&gt;，通过 BeanDefinitionRegistry  接口去 &lt;strong&gt;新增&lt;/strong&gt;，&lt;strong&gt;删除&lt;/strong&gt;，&lt;strong&gt;获取&lt;/strong&gt;我们这个 BeanDefinition&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BeanFactoryPostProcessor&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;通过该接口，可以在 &lt;strong&gt;实例化对象前&lt;/strong&gt;，对  BeanDefinition 进行修改 ，&lt;strong&gt;冻结&lt;/strong&gt; ，&lt;strong&gt;预实例化单例Bean&lt;/strong&gt; 等&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过上面层层阻碍后，我们最终会来到目标方法 getBean ，将原料投入生产，最终获取一个个 Bean 对象出来&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么随之而来的就是这个 Bean 的生命周期啦 😄&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Bean 生命周期&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Bean 的创建和管理有&lt;strong&gt;标准化的流程&lt;/strong&gt;！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里在我们的工厂 BeanFactory 中写得很清楚 👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4824175824175824&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYfPibFKooIQG2PEdib1xYveWicQCicFwZDoMGyNKrHajBVtlq94DwocnFOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;910&quot;/&gt;&lt;figcaption&gt;image-20210902072224002&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总共 &lt;strong&gt;14&lt;/strong&gt; 个步骤，是不是一下子就清晰多了😄&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9222560975609756&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYFI0Fnpur6bqA4mOw29kiaV75OLMYYt6wUo40fKASNic6NcZkxRZhLa1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;656&quot;/&gt;&lt;figcaption&gt;image-20210902073122559&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在看这部分的源码时，要多注意两个英文单词 😝&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;实例化&lt;/strong&gt; 👉 &lt;strong&gt;Instantiation&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;初始化&lt;/strong&gt; 👉 &lt;strong&gt;Initialization&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ps: 别看快搞错了 哈哈😝&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仔细阅读上面这14个步骤，会发现前面 &lt;strong&gt;8&lt;/strong&gt; 个都是 Aware 接口，而他们的作用也很简单，就是获取 xxAware 这个单词的前缀 xx 😄&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们在上文 👉 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MjUzODc5Mw==&amp;amp;mid=2247488730&amp;amp;idx=1&amp;amp;sn=ec8d1155ef4a400a791cf89ef8aa633c&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《三分钟快速上手Spring事件机制》&lt;/a&gt; 中提到的事件发布器 ApplicationEventPublisher ，只要你实现了 ApplicationEventPublisherAware 接口，就可以&lt;strong&gt;获取&lt;/strong&gt; 事件发布器 ApplicationEventPublisher  ！&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Bean 后置处理器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实例化 和 初始化流程中，把这个Bean 的后置处理器 BeanPostProcessor 安排上，就得到下图啦 👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9026946107784432&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYQYlpLYjcJYrSYDu1uGegt8KXWiaSibYm5icxguPUK4RXjRFcibz6iaq8FLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;668&quot;/&gt;&lt;figcaption&gt;image-20210902082034253&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里留意下 &lt;strong&gt;实例化&lt;/strong&gt; 有扩展点  InstantiationAwareBeanPostProcessor ， &lt;strong&gt;初始化&lt;/strong&gt; 扩展点 BeanPostProcessor 就非常多啦，我们主要来关注下这个 AOP&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;AOP&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么 AOP 是在哪个步骤代理对象的呢？👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5630885122410546&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYLkJSplLjNHavws9BfGqrEuWribcU59sm2icG5ichsSaSs8GXT8mwUkOcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1062&quot;/&gt;&lt;figcaption&gt;image-20210903080503505&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以在 AbstractAutoProxyCreator 类中看到 👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.40595238095238095&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYrbsibTib7CiaOHQBysMOzzozIy1AnvpVUJQvsnbTXJa86R3crk6SLtO1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;840&quot;/&gt;&lt;figcaption&gt;image-20210903080803199&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他具体信息在下文的 &lt;strong&gt;AOP插件&lt;/strong&gt; 一文中再讲一下😄&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于代理的知识点可以看看这里&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;👉  &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MjUzODc5Mw==&amp;amp;mid=2247487968&amp;amp;idx=1&amp;amp;sn=c2dbbdc444461b3568712119c170242e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《Java代理模式和字节码的探索》&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;👉  &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MjUzODc5Mw==&amp;amp;mid=2247488415&amp;amp;idx=1&amp;amp;sn=2ac254a9862f49a7bb1d3b94cba27b86&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《Cglib动态代理探索(ASM，Spring)》&lt;/a&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文就先介绍到这里啦🐖&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要介绍了 Spring 里面的这些脉络，方便小伙伴们对它有个整体的印象先~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再介绍其中的一些扩展点，比如从源材料的 BeanFactoryPostprocessor ，到产物 Bean 的 BeanPostprocessor 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例化，初始化的顺序，Bean的生命周期，以及 BeanFactory 及子类扩展的功能，再到 ApplicationContext 的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有这个核心机制：&lt;strong&gt;工厂+XML+反射&lt;/strong&gt;，以及引出下文要说的 AOP &lt;strong&gt;发生的地方&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.43116883116883115&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYuqBRQM6e9uz1wrwZE5h4UepOHEeOD8yrGMObGx28H83AbcglnLKcsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1155&quot;/&gt;&lt;figcaption&gt;image-20210904203613899&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本期的思维导图会和后面的章节汇总一起再分享哦😋&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ps&lt;/strong&gt;：最近忙起来啦，更文速度会慢一些哦~ ，喜欢的话可以 &lt;strong&gt;星标&lt;/strong&gt; 哦，这样可以第一时间收到更文消息🐷&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我是4ye 咱们下期应该……很快再见！！&lt;/strong&gt; 😆&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;喜欢的话还可以关注下公众号 &lt;strong&gt;Java4ye&lt;/strong&gt; 支持下 &lt;strong&gt;4ye&lt;/strong&gt; 呀😝&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>