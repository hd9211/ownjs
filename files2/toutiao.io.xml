<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>6042538f0474403a28e93784414314ab</guid>
<title>后台开发面试必看：后台服务器开发高性能最佳实践</title>
<link>https://toutiao.io/k/w76nnho</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-topic-des nc-post-content&quot;&gt;
&lt;h2&gt;前言&lt;/h2&gt; 
&lt;p&gt;&lt;span&gt;在互联网公司技术面试上，除了&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;和网络、操作系统这种基础之外，还有一类&lt;/span&gt;&lt;strong&gt;系统设计和优化&lt;/strong&gt;的问题。这类问题需要你有一个全局的技术视野，以及熟悉一些常用的系统优化方法论，也就是工程上的一些 &lt;strong&gt;Best Practice&lt;/strong&gt;，而不至于自己临时拍脑袋瞎设计。&lt;/p&gt; 
&lt;p&gt;在互联网公司，经常面临一个“三高”问题：&lt;/p&gt; 
 
&lt;p&gt;这篇文章将总结一下后台服务器开发中有哪些常用的解决“三高”问题的方法和思想。&lt;/p&gt; 
&lt;p&gt;希望这些知识，能够给你一丝启发和帮助，助力你收割 各大公司 Offer~&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;先上本文思维导图:&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;如何解决三高&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873447931_007S8ZIlgy1gifsdthgvpj315p0u0aia.jpg&quot;/&gt;&lt;/p&gt; 
&lt;h2&gt;正文&lt;/h2&gt; 
&lt;h3&gt;一、缓存&lt;/h3&gt; 
&lt;p&gt;什么是缓存？看看维基百科怎么说：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;In computing, a cache is a hardware or software component that stores data so that future requests for that data can be served faster; the data stored in a cache might be the result of an earlier computation or a copy of data stored elsewhere.&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;在计算机中，&lt;strong&gt;缓存&lt;/strong&gt;是存储数据的硬件或软件组件，以便可以更快地满足将来对该数据的请求。 存储在缓存中的数据可能是之前&lt;strong&gt;计算结果&lt;/strong&gt;，也可能是存储在其他位置的&lt;strong&gt;数据副本&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;缓存本质来说是使用&lt;strong&gt;空间换时间&lt;/strong&gt;的思想，它在计算机世界中无处不在， 比如 CPU 就自带 L1、L2、L3 Cache，这个一般应用开发可能关注较少。但是在一些实时系统、大规模计算模拟、图像处理等追求极致性能的领域，就特别注重编写&lt;strong&gt;缓存友好&lt;/strong&gt;的代码。&lt;/p&gt; 
&lt;p&gt;什么是缓存友好？简单来说，就是代码在访问数据的时候，尽量使用缓存命中率高的方式。这个后面可以单独写一篇 CPU 缓存系统以及如何编写缓存友好代码的文章。&lt;/p&gt; 
&lt;h4&gt;1.1 缓存为什么有效？&lt;/h4&gt; 
&lt;p&gt;缓存之所以能够大幅提高系统的性能，关键在于数据的访问具有&lt;strong&gt;局部性&lt;/strong&gt;，也就是二八定律：「百分之八十的数据访问是集中在 20% 的数据上」。这部分数据也被叫做&lt;strong&gt;热点数据。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;缓存一般使用内存作为存储，内存读写速度快于磁盘，但容量有限，十分宝贵，不可能将所有数据都缓存起来。&lt;/p&gt; 
&lt;p&gt;如果应用访问数据没有热点，不遵循二八定律，即大部分数据访问并没有集中在小部分数据上，那么缓存就没有意义，因为大部分数据还没有被再次访问就已经被挤出缓存了。每次访问都会回源到数据库查询，那么反而会降低数据访问效率。&lt;/p&gt; 
&lt;h4&gt;1.2 缓存分类&lt;/h4&gt; 
 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;&lt;strong&gt;2. 分布式缓存:&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;当缓存的数据量增大以后，单机不足以承载缓存服务时，就要考虑对缓存服务做&lt;strong&gt;水平扩展&lt;/strong&gt;，引入缓存集群。&lt;/p&gt; &lt;p&gt;将数据分片后分散存储在不同机器中，如何决定每个数据分片存放在哪台机器呢？一般是采用&lt;strong&gt;&lt;span&gt;一致性 Hash &lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，它能够保证在缓存集群动态调整，不断增加或者减少机器后，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;访问时依然能够根据 key 访问到数据。&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;一致性 Hash &lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;也是值得用一篇文章来讲的，如果暂时还不懂的话可以去搜一下。&lt;/span&gt;&lt;/p&gt; &lt;p&gt;常用的组件有 &lt;strong&gt;Memcache&lt;/strong&gt;、 &lt;strong&gt;Redis Cluster&lt;/strong&gt; 等，第二个是在高性能内存存储 Redis 的基础上，提供分布式存储的解决方案。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;h4&gt;1.3 缓存使用指南&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;1. 适合缓存的场景：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;&lt;strong&gt;读多写少：&lt;/strong&gt; &lt;/p&gt; &lt;p&gt;比如电商里的商品详情页面，访问频率很高，但是一般写入只在店家上架商品和修改信息的时候发生。如果把热点商品的信息缓存起来，这将拦截掉很多对数据库的访问，提高系统整体的吞吐量。&lt;/p&gt; &lt;p&gt;因为一般数据库的 QPS 由于有「ACID」约束、并且数据是持久化在硬盘的，所以比 Redis 这类基于内存的 NoSQL 存储低不少。常常是一个系统的瓶颈，如果我们把大部分的查询都在 Redis 缓存中命中了，那么系统整体的 QPS 也就上去了。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;&lt;strong&gt;计算耗时大，且实时性不高：&lt;/strong&gt;&lt;br/&gt;比如王者荣耀里的全区排行榜，一般一周更新一次，并且计算的数据量也比较大，所以计算后缓存起来，请求排行榜直接从缓存中取出，就不用实时计算了。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;2. 不适合缓存的场景&lt;/strong&gt;：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;写多读少，频繁更新。&lt;/strong&gt; &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;对数据一致性要求严格：&lt;/strong&gt; 因为缓存会有更新策略，所以很难做到和数据库实时同步。 &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;数据访问完全随机：&lt;/strong&gt; 因为这样会导致缓存的命中率极低。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;h4&gt;1.4 缓存更新的策略&lt;/h4&gt; 
&lt;p&gt;如何更新缓存其实已经有总结得非常好的「最佳实践」，我们按照套路来，大概率不会犯错。&lt;/p&gt; 
&lt;p&gt;主要分为两类 &lt;strong&gt;Cache-Aside&lt;/strong&gt; 和 &lt;strong&gt;Cache-As-SoR。&lt;/strong&gt; SoR 即「System Of Record，记录系统」，表示数据源，一般就是指数据库。&lt;/p&gt; 
&lt;h5&gt;1、Cache-Aside：&lt;/h5&gt; 
&lt;p&gt;&lt;img alt=&quot;Cache-Aside架构图&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873447897_007S8ZIlgy1gifjt5j889j31540tuq5x.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;这应该是最容易想到的模式了，获取数据时先从缓存读，如果 &lt;strong&gt;cache hit&lt;/strong&gt; 则直接返回，没命中就从数据源获取，然后更新缓存。&lt;/p&gt; 
&lt;p&gt;写数据的时候则先更新数据源，然后设置缓存失效，下一次获取数据的时候必然 &lt;strong&gt;cache miss&lt;/strong&gt;，然后触发&lt;strong&gt;回源&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;直接看伪代码：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;Cache-Aside 代码示范&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873447891_007S8ZIlgy1gift5f4ajcj30u00wmgvc.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;可以看到这种方式对于缓存的使用者是&lt;strong&gt;不透明&lt;/strong&gt;的，需要使用者手动维护缓存。&lt;/p&gt; 
&lt;h5&gt;2、Cache-As-SoR：&lt;/h5&gt; 
&lt;p&gt;&lt;img alt=&quot;Cache-As-SoR架构图&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873447929_007S8ZIlgy1gifj60t7g9j319w0tuta8.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;从字面上来看，就是把 Cache 当作 SoR，也就是数据源，所以一切读写操作都是针对 Cache 的，由 &lt;strong&gt;Cache 内部自己维护和数据源的一致性。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;这样对于使用者来说就和直接操作 SoR 没有区别了，完全感知不到 Cache 的存在。&lt;/p&gt; 
&lt;p&gt;CPU 内部的 L1、L2、L3 Cache 就是这种方式，作为数据的使用方应用程序，是完全感知不到在内存和我们之间还存在几层的 Cache，但是我们之前又提到编写 “缓存友好”的代码，不是透明的吗？这是不是冲突呢？&lt;/p&gt; 
&lt;p&gt;其实不然，缓存友好是指我们通过学习了解缓存内部实现、更新策略之后，通过调整数据访问顺序提高缓存的命中率。&lt;/p&gt; 
&lt;p&gt;Cache-As-SoR 又分为以下三种方式:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Read Through&lt;/strong&gt;：这种方式和 Cache-Aside 非常相似，都是在查询时发生 cache miss 去更新缓存，但是区别在于 Cache-Aside 需要调用方手动更新缓存，而 Cache-As-SoR 则是由缓存内部实现自己负责，对应用层透明。 &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;Write Through&lt;/strong&gt;： 直写式，就是在将数据写入缓存的同时，缓存也去更新后面的数据源，并且必须等到数据源被更新成功后才可返回。这样保证了缓存和数据库里的&lt;strong&gt;数据一致性&lt;/strong&gt;。 &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;Write Back&lt;/strong&gt;：回写式，数据写入缓存即可返回，缓存内部会异步的去更新数据源，这样好处是&lt;strong&gt;写操作特别快&lt;/strong&gt;，因为只需要更新缓存。并且缓存内部可以合并对相同数据项的多次更新，但是带来的问题就是&lt;strong&gt;数据不一致&lt;/strong&gt;，可能发生写丢失。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;h3&gt;二、预处理和延后处理&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;预先延后&lt;/strong&gt;，这其实是一个事物的两面，不管是预先还是延后核心思想都是将本来该在实时链路上处理的事情剥离，要么提前要么延后处理。&lt;strong&gt;降低实时链路的路径长度，&lt;/strong&gt; 这样能有效提高系统性能。&lt;/p&gt; 
&lt;h4&gt;2.1 预处理&lt;/h4&gt; 
&lt;p&gt;举个我们团队实际中遇到的问题：&lt;/p&gt; 
&lt;p&gt;前两个月支付宝联合杭州市政府发放消费劵，但是要求只有杭州市常驻居民才能领取，那么需要在抢卷请求进入后台的时候就判断一下用户是否是杭州常驻居民。&lt;/p&gt; 
&lt;p&gt;而判断用户是否是常驻居民这个是另外一个微服务接口，如果直接实时的去调用那个接口，短时的高并发很有可能把这个服务也拖挂，最终导致整个系统不可用，并且 RPC 本身也是比较耗时的，所以就考虑在这里进行优化。&lt;/p&gt; 
&lt;p&gt;那么该怎么做呢？很简单的一个思路，&lt;strong&gt;提前将杭州所有常驻居民的 user_id 存到缓存中，&lt;/strong&gt;&lt;span&gt; 比如可以直接存到 Redis。大概就是千万量级，这样，当请求到来的时候我们直接通过缓存可以快速判断是否来自杭州常驻居民。如果不是则直接在这里返回&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%89%8D%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;前端&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;这里通过预先处理减少了实时链路上的 RPC 调用，既减少了系统的外部依赖，也极大的提高了系统的吞吐量。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;预处理在 CPU 和操作系统中也广泛使用，比如 CPU 基于历史访存信息，将内存中的&lt;strong&gt;指令和数据预取&lt;/strong&gt;到 Cache 中，这样可以大大提高&lt;strong&gt;Cache 命中率。&lt;/strong&gt; 还比如在 Linux 文件系统中，预读算***预测即将访问的 page，然后批量加载比当前读请求更多的数据缓存在 page cache 中，这样当下次读请求到来时可以直接从 cache 中返回，大大减少了访问磁盘的时间。&lt;/p&gt; 
&lt;h4&gt;2.2 延后处理&lt;/h4&gt; 
&lt;p&gt;还是支付宝，上栗子：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;集五福活动&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873448256_007S8ZIlgy1gifje6vocvj30iy0s0qhh.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;这是支付宝春节集五福活动开奖当晚，不过，作为非酋的我一般是不屑于参与这种活动的。&lt;/p&gt; 
&lt;p&gt;大家发现没有，这类活动中奖奖金一般会显示 &lt;strong&gt;「稍后到账」&lt;/strong&gt;，为什么呢？那当然是到账这个操作不简单！&lt;/p&gt; 
&lt;p&gt;到账即转账，A 账户给 B 账户转钱，A 减钱， B 就必须要同时加上钱，也就是说不能 A 减了钱但 B 没有加上，这就会导致资金损失。资金安全是支付业务的生命线，这可不行。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;这两个动作必须一起成功或是一起都不成功，不能只成功一半，这是保证数据一致性。&lt;/strong&gt; 保证两个操作同时成功或者失败就需要用到&lt;strong&gt;事务&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;如果去实时的做到账，那么大概率数据库的 &lt;strong&gt;TPS（每秒处理的事务数）&lt;/strong&gt; 会是瓶颈。通过产品提示，将到账操作延后处理，解决了数据库 TPS 瓶颈。&lt;/p&gt; 
&lt;p&gt;延后处理还有一个非常著名的例子，&lt;strong&gt;COW（Copy On Write，写时复制）。&lt;/strong&gt; Linux 创建进程的系统调用 fork，fork 产生的子进程只会创建虚拟地址空间，而不会分配真正的物理内存，子进程共享父进程的物理空间，只有当某个进程需要写入的时候，才会真正分配物理页，拷贝该物理页，通过 COW 减少了很多不必要的数据拷贝。&lt;/p&gt; 
&lt;h3&gt;三、池化&lt;/h3&gt; 
&lt;p&gt;后台开发过程中你一定离不开各种 &lt;strong&gt;「池子」：&lt;/strong&gt; 内存池、连接池、线程池、对象池......&lt;/p&gt; 
&lt;p&gt;内存、连接、线程这些都是资源，创建线程、分配内存、数据库连接这些操作都有一个特征， 那就是&lt;strong&gt;创建和销毁过程都会涉及到很多系统调用或者网络 IO。&lt;/strong&gt; 每次都在请求中去申请创建这些资源，就会增加请求处理耗时，但是如果我们用一个 &lt;strong&gt;容器（池）&lt;/strong&gt; 把它们保存起来，下次需要的时候，直接拿出来使用，避免重复创建和销毁浪费的时间。&lt;/p&gt; 
&lt;h4&gt;3.1 内存池&lt;/h4&gt; 
&lt;p&gt;在 C/C++ 中，经常使用 malloc、new 等 API 动态申请内存。由于申请的内存块大小不一，如果频繁的申请、释放会导致大量的&lt;strong&gt;内存碎片&lt;/strong&gt;，并且这些 API 底层依赖系统调用，会有额外的开销。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;内存池就是在使用内存前，先向系统申请一块空间留做备用，使用者需要内池时向内存池申请，用完后还回来。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;内存池的思想非常简单，实现却不简单，难点在于以下几点:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;如何快速分配内存&lt;/strong&gt; &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;降低内存碎片率&lt;/strong&gt; &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;维护内存池所需的额外空间尽量少&lt;/strong&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;&lt;span&gt;如果不考虑效率，我们完全可以将内存分为不同大小的块，然后用&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;链表&lt;/a&gt;连接起来，分配的时候找到大小最合适的返回，释放的时候直接添加进&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;链表&lt;/a&gt;。如:&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;空闲链表&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873448286_007S8ZIlgy1gifk4wterkj31ii0s6abs.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;当然这只是玩具级别的实现，业界有性能非常好的实现了，我们可以直接拿来学习和使用。&lt;/p&gt; 
&lt;p&gt;比如 Google 的 「tcmalloc」 和 Facebook 的 「jemalloc」。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;限于篇幅我们不在这里详细讲解它们的实现原理，如果感兴趣可以搜来看看，也推荐去看看被誉为神书的 CSAPP（《深入理解计算机系统》）第 10 章，那里也讲到了动态内存分配&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;h4&gt;3.2 线程池&lt;/h4&gt; 
&lt;p&gt;线程是干嘛的？线程就是我们&lt;strong&gt;程序执行的实体&lt;/strong&gt;。在服务器开发领域，我们经常会为每个请求分配一个线程去处理，但是线程的创建销毁、调度都会带来额外的开销，线程太多也会导致系统整体性能下降。在这种场景下，我们通常会提前创建若干个线程，通过线程池来进行管理。当请求到来时，只需从线程池选一个线程去执行处理任务即可。&lt;/p&gt; 
&lt;p&gt;线程池常常和&lt;strong&gt;队列&lt;/strong&gt;一起使用来实现&lt;strong&gt;任务调度&lt;/strong&gt;，主线程收到请求后将创建对应的任务，然后放到队列里，线程池中的工作线程等待队列里的任务。&lt;/p&gt; 
&lt;p&gt;线程池实现上一般有四个核心组成部分:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;管理器（Manager）:&lt;/strong&gt; 用于创建并管理线程池。 &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;工作线程（Worker）:&lt;/strong&gt; 执行任务的线程。 &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;任务接口（Task）:&lt;/strong&gt; 每个具体的任务必须实现任务接口，工作线程将调用该接口来完成具体的任务。 &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;任务队列（TaskQueue）:&lt;/strong&gt; 存放还未执行的任务。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;&lt;img alt=&quot;线程池模型&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873448290_007S8ZIlgy1gifknuico6j31er0u0u0x.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;线程池在 C、C++ 中没有具体的实现，需要应用开发者手动实现上诉几个部分。&lt;/p&gt; 
&lt;p&gt;在 Java 中 &lt;strong&gt;「ThreadPoolExecutor」&lt;/strong&gt; 类就是线程池的实现。后续我也会写文章分析 C++ 如何写一个简单的线程池以及 Java 中线程池是如何实现的。&lt;/p&gt; 
&lt;h4&gt;3.3 连接池&lt;/h4&gt; 
&lt;p&gt;顾名思义，连接池是创建和管理连接的。&lt;/p&gt; 
&lt;p&gt;大家最熟悉的莫过于数据库连接池，这里我们简单分析下如果不用数据库连接池，一次 SQL 查询请求会经过哪些步骤:&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;strong&gt;和 MySQL server 建立 TCP 连接:&lt;/strong&gt;
   &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;MySQL 权限认证：&lt;/strong&gt;
  &lt;ul&gt; 
   &lt;li&gt;Server 向 Client 发送 密钥 &lt;/li&gt;
   &lt;li&gt;Client 使用密钥加密用户名、密码等信息，将加密后的报文发送给 Server &lt;/li&gt;
   &lt;li&gt;Server 根据 Client 请求包，验证是否是合法用户，然后给 Client 发送认证结果 &lt;/li&gt;
  &lt;/ul&gt; &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;Client 发送 SQL 语句&lt;/strong&gt; &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;Server 返回语句执行结果&lt;/strong&gt; &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;MySQL 关闭&lt;/strong&gt; &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;TCP 连接断开&lt;/strong&gt;
   &lt;/li&gt;
&lt;/ol&gt; 
&lt;p&gt;可以看出不使用连接池的话，为了执行一条 SQL，会花很多时间在安全认证、网络IO上。&lt;/p&gt; 
&lt;p&gt;如果使用连接池，执行一条 SQL 就省去了建立连接和断开连接所需的额外开销。&lt;/p&gt; 
&lt;p&gt;还能想起哪里用到了连接池的思想吗？我认为 &lt;strong&gt;HTTP 长链接&lt;/strong&gt;也算一个变相的链接池，虽然它本质上只有一个连接，但是思想却和连接池不谋而合，都是为了复用同一个连接发送多个 HTTP 请求，避免建立和断开连接的开销。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;池化实际上是预处理和延后处理的一种应用场景，通过池子将各类资源的创建提前和销毁延后。&lt;/strong&gt;&lt;/p&gt; 
&lt;h3&gt;四、同步变异步&lt;/h3&gt; 
&lt;p&gt;对于处理耗时的任务，如果采用同步的方式，那么会增加任务耗时，降低系统并发度。&lt;/p&gt; 
&lt;p&gt;可以通过将同步任务变为异步进行优化。&lt;/p&gt; 
&lt;p&gt;举个例子，比如我们去 KFC 点餐，遇到排队的人很多，当点完餐后，大多情况下我们会隔几分钟就去问好了没，反复去问了好几次才拿到，在这期间我们也没法干活了，这时候我们是这样的：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;同步写法&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873448286_007S8ZIlgy1gifvfsljxrj30u018ijyn.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;这个就叫&lt;strong&gt;同步轮训，&lt;/strong&gt; 这样效率显然太低了。&lt;/p&gt; 
&lt;p&gt;服务员被问烦了，就在点完餐后给我们一个号码牌，每次准备好了就会在服务台叫号，这样我们就可以在被叫到的时候再去取餐，中途可以继续干自己的事。&lt;/p&gt; 
&lt;p&gt;这就叫异步,在很多编程语言中有异步编程的库，比如 C++ std::future、Python asyncio 等，但是异步编程往往需要&lt;strong&gt;回调函数（Callback function）&lt;/strong&gt;，如果回调函数的层级太深，这就是&lt;strong&gt;回调地狱（Callback hell）&lt;/strong&gt;。回调地狱如何优化又是一个庞大的话题。。。。&lt;/p&gt; 
&lt;p&gt;这个例子相当于函数调用的异步化，还有的是情况是处理流程异步化，这个会在接下来消息队列中讲到。&lt;/p&gt; 
&lt;h3&gt;五、消息队列&lt;/h3&gt; 
&lt;p&gt;&lt;img alt=&quot;消息队列示意图&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873448360_007S8ZIlgy1gifwp4n129j31880lwmy6.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;这是一个非常简化的消息队列模型，上游生产者将消息通过队列发送给下游消费者。在这之间，消息队列可以发挥很多作用，比如：&lt;/p&gt; 
&lt;h4&gt;5.1 服务解耦&lt;/h4&gt; 
&lt;p&gt;有些服务被其它很多服务依赖，比如一个论坛网站，当用户成功发布一条帖子有一系列的流程要做，有积分服务计算积分，推送服务向发布者的粉丝推送一条消息..... 对于这类需求，常见的实现方式是直接调用：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;直接调用&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873448525_007S8ZIlgy1gifwm2nlw8j313e0k675u.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;这样如果需要新增一个&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90&quot; target=&quot;_blank&quot;&gt;数据分析&lt;/a&gt;的服务，那么又得改动发布服务，这违背了&lt;/span&gt;&lt;strong&gt;依赖倒置原则&lt;/strong&gt;，&lt;strong&gt;即上层服务不应该依赖下层服务，那么怎么办呢？&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;发布订阅模式&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873448603_007S8ZIlgy1gifwo36vdzj319e0k8765.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;引入消息队列作为中间层，当帖子发布完成后，发送一个事件到消息队列里，而关心&lt;strong&gt;帖子发布成功&lt;/strong&gt;这件事的下游服务就可以订阅这个事件，这样即使后续继续增加新的下游服务，只需要订阅该事件即可，完全不用改动发布服务，完成系统解耦。&lt;/p&gt; 
&lt;h4&gt;5.2 异步处理&lt;/h4&gt; 
&lt;p&gt;有些业务涉及到的处理流程非常多，但是很多步骤并不要求实时性。那么我们就可以通过消息队列异步处理。比如淘宝下单，一般包括了&lt;strong&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A3%8E%E6%8E%A7&quot; target=&quot;_blank&quot;&gt;风控&lt;/a&gt;、锁库存、生成订单、短信/邮件通知&lt;/span&gt;&lt;/strong&gt;等步骤。但是&lt;strong&gt;&lt;span&gt;核心的就&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A3%8E%E6%8E%A7&quot; target=&quot;_blank&quot;&gt;风控&lt;/a&gt;和锁库存，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 只要&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A3%8E%E6%8E%A7&quot; target=&quot;_blank&quot;&gt;风控&lt;/a&gt;和扣减库存成功，那么就可以返回结果通知用户成功下单了。&lt;/span&gt;&lt;strong&gt;后续的生成订单，短信通知都可以通过消息队列发送给下游服务异步处理。大大提高了系统响应速度。&lt;/strong&gt; &lt;/p&gt; 
&lt;p&gt;这就是处理流程异步化。&lt;/p&gt; 
&lt;h4&gt;5.3 流量削峰&lt;/h4&gt; 
&lt;p&gt;一般像秒杀、抽奖、抢卷这种活动都伴随着&lt;strong&gt;短时间海量的请求，&lt;/strong&gt; 一般超过后端的处理能力，那么我们就可以在接入层将请求放到消息队列里，后端根据自己的处理能力不断从队列里取出请求进行业务处理。&lt;/p&gt; 
&lt;p&gt;就像最近长江汛期，上游短时间大量的洪水汇聚直奔下游，但是通过三峡大坝将这些水缓存起来，然后匀速的向下游释放，起到了很好的削峰作用。&lt;/p&gt; 
&lt;p&gt;起到了平均流量的作用。&lt;/p&gt; 
&lt;h4&gt;5.4 总结&lt;/h4&gt; 
&lt;p&gt;消息队列的核心思想就是把同步的操作变成异步处理，异步处理会带来相应的好处，比如:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;服务解耦 &lt;/li&gt;
 &lt;li&gt;提高系统的并发度，将非核心操作异步处理，不会阻塞住主流程 &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;但是软件开发没有银弹，所有的方案选择都是一种 &lt;strong&gt;trade-off。&lt;/strong&gt; 同样，异步处理也不全是好处，也会导致一些问题：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;降低了数据一致性，从强一致性变为最终一致性 &lt;/li&gt;
 &lt;li&gt;有消息丢失的风险，比如宕机，需要有容灾机制 &lt;/li&gt;
&lt;/ul&gt; 
&lt;h3&gt;六、批量处理&lt;/h3&gt; 
&lt;p&gt;在涉及到网络连接、IO等情况时，将操作批量进行处理能够有效提高系统的传输速率和吞吐量。&lt;/p&gt; 
&lt;p&gt;在前后端通信中，&lt;strong&gt;通过合并一些频繁请求的小资源可以获得更快的加载速度。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;比如我们后台 RPC 框架，经常有更新数据的需求，而有的数据更新的接口往往只接受一项，这个时候我们往往会优化下更新接口，&lt;/p&gt; 
&lt;p&gt;使其能够接受批量更新的请求，这样可以将批量的数据一次性发送，大大缩短网络 RPC 调用耗时。&lt;/p&gt; 
&lt;h3&gt;七、数据库&lt;/h3&gt; 
&lt;p&gt;我们常把后台开发调侃为「CRUD」，数据库在整个应用开发过程中的重要性不言而喻。&lt;/p&gt; 
&lt;p&gt;而且很多时候系统的瓶颈也往往处在数据库这里，慢的原因也有很多，比如可能是没用索引、没用对索引、读写锁冲突等等。&lt;/p&gt; 
&lt;p&gt;那么如何使用数据才能又快又好呢？下面这几点需要重点关注：&lt;/p&gt; 
&lt;h4&gt;7.1 索引&lt;/h4&gt; 
&lt;p&gt;索引可能是我们平时在使用数据库过程中接触得最多的优化方式。索引好比图书馆里的书籍索引号，想象一下，如果我让你去一个没有书籍索引号的图书馆找《人生》这本书，你是什么样的感受？当然是怀疑人生，同理，你应该可以理解当你查询数据，却不用索引的时候数据库该有多崩溃了吧。&lt;/p&gt; 
&lt;p&gt;数据库表的索引就像图书馆里的书籍索引号一样，可以提高我们检索数据的效率。索引能提高查找效率，可是你有没有想过为什么呢？&lt;strong&gt;&lt;span&gt;这是因为索引一般而言是一个&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;列表，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;意味着可以基于二分思想进行查找，将查询时间复杂度做到 O(log(N))，快速的支持等值查询和范围查询。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;二叉搜索树查询效率无疑是最高的，因为平均来说每次比较都能缩小一半的搜索范围，但是一般在数据库索引的实现上却会选择 B 树或 B+ 树而不用二叉搜索树，为什么呢？&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;这就涉及到数据库的存储介质了，数据库的数据和索引都是存放在磁盘，并且是 InnoDB 引擎是以页为基本单位管理磁盘的，一页一般为 16 KB。AVL 或&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;搜索效率虽然非常高，&lt;/span&gt;&lt;strong&gt;但是同样数据项，它也会比 B、B+ 树更高，高就意味着平均来说会访问更多的节点，即磁盘IO次数！&lt;/strong&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;根据 Google 工程师 Jeff Dean 的统计，访问内存数据耗时大概在 100 ns，访问磁盘则是 10,000,000 ns。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;所以表面上来看我们使用 B、B+ 树没有 二叉查找树效率高，但是实际上由于 B、B+ 树降低了树高，减少了磁盘 IO 次数，反而大大提升了速度。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;这也告诉我们，没有绝对的快和慢，系统分析要抓主要矛盾，先分析出决定系统瓶颈的到底是什么，然后才是针对瓶颈的优化。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;其实关于索引想写的也还有很多，但还是受限于篇幅，以后再单独写。&lt;/p&gt; 
&lt;p&gt;先把我认为索引必知必会的知识列出来，大家可以查漏补缺:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;主键索引和普通索引，以及它们之间的区别&lt;/strong&gt; &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;最左前缀匹配原则&lt;/strong&gt; &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;索引下推&lt;/strong&gt; &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;覆盖索引、联合索引&lt;/strong&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;h4&gt;7.2 读写分离&lt;/h4&gt; 
&lt;p&gt;一般业务刚上线的时候，直接使用单机数据库就够了，但是随着用户量上来之后，系统就面临着大量的写操作和读操作，单机数据库处理能力有限，容易成为系统瓶颈。&lt;/p&gt; 
&lt;p&gt;由于存在读写锁冲突，并且很多大型互联网业务往往&lt;strong&gt;读多写少&lt;/strong&gt;，读操作会首先成为数据库瓶颈，我们希望消除读写锁冲突从而提升数据库整体的读写能力。&lt;/p&gt; 
&lt;p&gt;那么就需要采用读写分离的数据库集群方式，一主多从，主库会同步数据到从库。写操作都到主库，读操作都去从库。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;读写分离&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873448685_007S8ZIlgy1gifs6y545lj317m0tygpu.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;读写分离到之后就避免了读写锁争用，这里解释一下，什么叫读写锁争用：&lt;/p&gt; 
&lt;p&gt; MySQL 中有两种锁: &lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;排它锁( X 锁)：&lt;/strong&gt; 事务 T 对数据 A 加上 X 锁时，&lt;strong&gt;只允许事务 T 读取和修改数据 A。&lt;/strong&gt; &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;共享锁( S 锁)：&lt;/strong&gt; 事务 T 对数据 A 加上 S 锁时，&lt;strong&gt;其他事务只能再对数据 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁。&lt;/strong&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;读写分离解决问题的同时也会带来新问题，比如主库和从库数据不一致&lt;/p&gt; 
&lt;p&gt;MySQL 的主从同步依赖于 binlog，binlog(二进制日志)是 MySQL Server 层维护的一种二进制日志，是独立于具体的存储引擎。它主要存储对数据库更新(insert、delete、update)的 SQL 语句，由于记录了完整的 SQL 更新信息，所以 binlog 是可以用来数据恢复和主从同步复制的。&lt;/p&gt; 
&lt;p&gt;从库从主库拉取 binlog 然后依次执行其中的 SQL 即可达到复制主库的目的，由于从库拉取 binlog 存在网络延迟等，所以主从数据存在延迟问题。&lt;/p&gt; 
&lt;p&gt;那么这里就要看业务是否允许短时间内的数据不一致，如果不能容忍，那么可以通过如果读从库没获取到数据就去主库读一次来解决。&lt;/p&gt; 
&lt;h4&gt;7.3 分库分表&lt;/h4&gt; 
&lt;p&gt;如果用户越来越多，写请求暴涨，对于上面的单 Master 节点肯定扛不住，那么该怎么办呢？多加几个 Master？不行，这样会带来更多的数据不一致的问题，增加系统的复杂度。那该怎么办？就只能对库表进行拆分了。&lt;/p&gt; 
&lt;p&gt;常见的拆分类型有&lt;strong&gt;垂直拆分和水平拆分。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;考虑拼夕夕电商系统，一般有 &lt;strong&gt;订单表、用户表、支付表、商品表、商家表等，&lt;/strong&gt; 最初这些表都在一个数据库里。&lt;br/&gt;后来随着砍一刀带来的海量用户，拼夕夕后台扛不住了! 于是紧急从阿狸粑粑那里挖来了几个 P8、P9 大佬对系统进行重构。&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;p&gt;P9 大佬第一步先对数据库进行垂直分库，&lt;br/&gt;&lt;strong&gt;根据业务关联性强弱，将它们分到不同的数据库，&lt;/strong&gt; 比如订单库，商家库、支付库、用户库。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;第二步是对一些大表进行垂直分表，&lt;strong&gt;将一个表按照字段分成多表，每个表存储其中一部分字段。&lt;/strong&gt; 比如商品详情表可能最初包含了几十个字段，但是往往最多访问的是商品名称、价格、产地、图片、介绍等信息，所以我们将不常访问的字段单独拆成一个表。&lt;/p&gt; &lt;/li&gt;
&lt;/ol&gt; 
&lt;ul&gt; 
 &lt;li&gt;由于垂直分库已经按照业务关联切分到了最小粒度，数据量任然非常大，&lt;strong&gt;P9 大佬开始水平分库，比如可以把订单库分为订单1库、订单2库、订单3库......&lt;/strong&gt;&lt;span&gt; 那么如何决定某个订单放在哪个订单库呢？可以考虑对主键通过哈希&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;计算放在哪个库。 &lt;/span&gt;&lt;/li&gt;
 &lt;li&gt;分完库，单表数据量任然很大，查询起来非常慢，&lt;strong&gt;P9 大佬决定按日或者按月将订单分表，叫做日表、月表。&lt;/strong&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;分库分表同时会带来一些问题，比如平时单库单表使用的主键自增特性将作废，因为某个分区库表生成的主键无法保证全局唯一，这就需要引入全局 UUID 服务了。&lt;/p&gt; 
&lt;p&gt;经过一番大刀阔斧的重构，拼夕夕恢复了往日的活力，大家又可以愉快的在上面互相砍一刀了。&lt;/p&gt; 
&lt;p&gt;(分库分表会引入很多问题，并没有一一介绍，这里只是为了讲解什么是分库分表)&lt;/p&gt; 
&lt;h3&gt;八、具体技法&lt;/h3&gt; 
&lt;h4&gt;8.1 零拷贝&lt;/h4&gt; 
&lt;p&gt;高性能的服务器应当避免不必要数据复制，特别是在&lt;strong&gt;用户空间和内核空间之间的数据复制。&lt;/strong&gt; 比如 HTTP 静态服务器发送静态文件的时候，一般我们会这样写:&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;发送文件&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873448662_007S8ZIlgy1gifp0trcwkj31ix0u0qbr.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;如果了解 Linux IO 的话就知道这个过程包含了内核空间和用户空间之间的多次拷贝：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;IO示意图&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873448748_007S8ZIlgy1gifp2f3hmgj319m0to0vo.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;内核空间和用户空间之间数据拷贝需要 CPU 亲自完成，但是对于这类&lt;strong&gt;数据不需要在用户空间进行处理&lt;/strong&gt;的程序来说，这样的两次拷贝显然是浪费。什么叫 &lt;strong&gt;「不需要在用户空间进行处理」？&lt;/strong&gt; &lt;/p&gt; 
&lt;p&gt;比如 FTP 或者 HTTP 静态服务器，它们的作用只是将文件从磁盘发送到网络，不需要在中途对数据进行编解码之类的计算操作。&lt;/p&gt; 
&lt;p&gt;如果能够直接将数据在内核缓存之间移动，那么除了减少拷贝次数以外，还能避免内核态和用户态之间的上下文切换。&lt;/p&gt; 
&lt;p&gt;而这正是零拷贝（Zero copy）干的事，主要就是利用各种零拷贝技术，减少不必要的数据拷贝，将 CPU 从数据拷贝这样简单的任务解脱出来，让 CPU 专注于别的任务。&lt;/p&gt; 
&lt;p&gt;常用的零拷贝技术:&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;p&gt;&lt;strong&gt;mmap&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;&amp;lt;kbd&amp;gt;mmap&amp;lt;/kbd&amp;gt; 通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数。&lt;/p&gt; &lt;/li&gt;
&lt;/ol&gt; 
&lt;p&gt;&lt;img alt=&quot;mmap&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873448841_007S8ZIlgy1gifpjzd2fqj319b0u0tbk.jpg&quot;/&gt;&lt;/p&gt; 
&lt;ol start=&quot;2&quot;&gt; 
 &lt;li&gt;&lt;p&gt;&lt;strong&gt;sendfile&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;&amp;lt;kbd&amp;gt;sendfile&amp;lt;/kbd&amp;gt; 是 Linux2.1 版本提供的，数据不经过用户态，直接从页缓存拷贝到 socket 缓存，同时由于和用户态完全无关，就减少了一次上下文切换。&lt;/p&gt; &lt;p&gt;在 Linux 2.4 版本，对 sendfile 进行了优化，直接通过 DMA 将磁盘文件数据读取到 socket 缓存，真正实现了 ”0” 拷贝。前面 mmap 和 2.1 版本的 sendfile 实际上只是消除了用户空间和内核空间之间拷贝，而页缓存和 socket 缓存之间的拷贝依然存在。&lt;/p&gt; &lt;/li&gt;
&lt;/ol&gt; 
&lt;h4&gt;8.2 无锁化&lt;/h4&gt; 
&lt;p&gt;在多线程环境下，为了避免 &lt;strong&gt;竞态条件（race condition），&lt;/strong&gt; 我们通常会采用加锁来进行并发控制，锁的代价也是比较高的，锁会导致上线文切换，甚至被挂起直到锁被释放。&lt;/p&gt; 
&lt;p&gt;基于硬件提供的原子操作 &lt;strong&gt;CAS(Compare And Swap)&lt;/strong&gt; 实现一些高性能无锁的数据结构，比如无锁队列，可以在保证并发安全的情况下，提供更高的性能。&lt;/p&gt; 
&lt;p&gt;首先需要理解什么是 CAS，CAS 有三个操作数，内存里当前值M，预期值 E，修改的新值 N，CAS 的语义就是：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;如果当前值等于预期值，则将内存修改为新值，否则不做任何操作&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;用 C 语言来表达就是:&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;CAS&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873448878_007S8ZIlgy1gifr9ideb7j31oo0u0dot.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;注意，上面 CAS 函数实际上是一条原子指令，那么是如何用的呢？&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;假设我需要实现这样一个功能：&lt;/p&gt; 
&lt;p&gt; 对一个全局变量 global 在两个不同线程分别对它加 100 次，这里多线程访问一个全局变量存在 race condition，所以我们需要采用线程同步操作，下面我分别用锁和CAS的方法来实现这个功能。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;CAS和锁示范&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873448874_007S8ZIlgy1gifrq8av5vj30u014z1dw.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;通过使用原子操作大大降低了锁冲突的可能性，提高了程序的性能。&lt;/p&gt; 
&lt;p&gt;除了 CAS，还有一些硬件原子指令：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Fetch-And-Add，对变量原子性 + 1 &lt;/li&gt;
 &lt;li&gt;&lt;span&gt;Test-And-Set，这是各种锁&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;的核心，在 AT&amp;amp;T/GNU 汇编语法下，叫 xchg 指令，我会单独写一篇如何使用 xchg 实现各种锁。 &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt; 
&lt;h4&gt;8.3 序列化与反序列化&lt;/h4&gt; 
&lt;p&gt;先看看维基百科怎么定义的序列化：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;In computing, serialization (US spelling) or serialisation (UK spelling) is the process of translating a data structure or object state into a format that can be stored (for example, in a file or memory data buffer) or transmitted (for example, across a computer network) and reconstructed later (possibly in a different computer environment). When the resulting series of bits is reread according to the serialization format, it can be used to create a semantically identical clone of the original object. For many complex objects, such as those that make extensive use of references, this process is not straightforward. Serialization of object-oriented objects does not include any of their associated methods with which they were previously linked.&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;我相信你大概率没有看完上面的英文描述，其实我也不爱看英文资料，总觉得很慢，但是计算机领域一手的学习资料都是美帝那边的，所以没办法，必须逼自己去试着读一些英文的资料。&lt;/p&gt; 
&lt;p&gt;实际上也没有那么难，熟悉常用的几百个专业名词，句子都是非常简单的一些从句。没看的话，再倒回去看看？&lt;/p&gt; 
&lt;p&gt;这里我就不做翻译了，主要是水平太低，估计做到「信达雅」的信都很难。&lt;/p&gt; 
&lt;p&gt;扯远了，还是回到序列化来。&lt;/p&gt; 
&lt;p&gt;所有的编程一定是围绕数据展开的，而数据呈现形式往往是结构化的，比如&lt;strong&gt;结构体（Struct）、类（Class）。&lt;/strong&gt; 但是当我们 &lt;strong&gt;通过网络、磁盘等传输、存储数据的时候却要求是二进制流。&lt;/strong&gt; 比如 TCP 连接，它提供给上层应用的是面向连接的可靠字节流服务。那么如何将这些结构体和类转化为可存储和可传输的字节流呢？这就是序列化要干的事情，反之，从字节流如何恢复为结构化的数据就是反序列化。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;序列化解决了对象持久化和跨网络数据交换的问题。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;序列化一般按照序列化后的结果是否可读，可分为以下两类：&lt;/p&gt; 
 
&lt;p&gt;还有 Java 、Go 这类语言内置了序列化方式，比如在 Java 里实现了 Serializable 接口即表示该对象可序列化。&lt;/p&gt; 
&lt;p&gt;说到这让我想起了大一写的的两个程序，一个是用刚 C 语言写的公交管理系统，当时需要将公交线路、站点信息持久化保存，当时的方案就是每个公交线路写在一行，用 &quot;|&quot;分割信息，比如：&lt;/p&gt; 
&lt;pre class=&quot;prettyprint&quot; from-niu=&quot;default&quot;&gt;5|6:00-22:00|大学城｜南山站｜北京站
123|6:30-23:00｜南湖大道｜茶山刘｜世界&lt;/pre&gt;
&lt;p&gt;第一列就是线路编号、第二项是发车时间、后面就是途径的站点。是不是非常原始？实际上这也是一种序列化方式，只是效率很低，也不通用。而且存在一个问题就是如果信息中包含 “｜”怎么办？当然是用转义。&lt;/p&gt; 
&lt;p&gt;第二个程序是用 Java 写的网络五子棋，当时需要通过网络传输表示棋子位置的对象，查了一圈最后发现只需要实现 Serializable 接口，自己什么都不用干，就能自己完成对象的序列化，然后通过网络传输后反序列化。当时哪懂得这就叫序列化，只觉得牛逼、神奇！&lt;/p&gt; 
&lt;p&gt;最后完成了一个可以网络五子棋，拉着隔壁室友一起玩。。。真的是成就感满满哈哈哈。&lt;/p&gt; 
&lt;p&gt;说来在编程方面，已经很久没有这样的成就感了。&lt;/p&gt; 
&lt;h2&gt;总结&lt;/h2&gt; 
&lt;p&gt;这篇文章主要是粗浅的介绍了一些系统设计、系统优化的套路和最佳实践。&lt;/p&gt; 
&lt;p&gt;不知道你发现没有，从缓存到消息队列、CAS......，很多看起来很牛逼的架构设计其实都来源于操作系统、体系结构。&lt;/p&gt; 
&lt;p&gt;所以我非常热衷学习一些底层的基础知识，这些看似古老的技术是经过时间洗礼留下来的好东西。现在很多的新技术、框架看似非常厉害，实则不少都是新瓶装旧酒，每几年又会被淘汰一批。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span&gt;来自我的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%89%9B%E5%AE%A2&quot; target=&quot;_blank&quot;&gt;牛客&lt;/a&gt;博客:&lt;/span&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.nowcoder.net/n/8de2902353c5438eafe95ce8f475cdbd&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;后台服务器高性能架构设计&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h2&gt;最后说一句（求赞）&lt;/h2&gt; 
&lt;p&gt;小伙伴们如果觉得写得不错, 顺便帮我点个赞呗~&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d901213929ddb9effbfb2c955e99d23a</guid>
<title>[推荐] [译] 如何优化您的日常决策</title>
<link>https://toutiao.io/k/88ebc7h</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;Post-body&quot;&gt;
                    &lt;p&gt;当今的生活和工作都是&lt;strong&gt;快节奏&lt;/strong&gt;的，人们每天都会遇到各种各样的事情，并需要做出做相应的&lt;strong&gt;决策&lt;/strong&gt;：哪些事情先做，哪些事情后做，哪些事情应该做，哪些事情不应该做。前些天有读到一篇文章：&lt;a href=&quot;https://jamesclear.com/design-default&quot; rel=&quot; nofollow ugc&quot;&gt;How to Optimize Your Daily Decisions&lt;/a&gt;，作者所做的思考，以及给出的建议，不仅通俗易懂，而且也方便用于日常工作、生活。因此有翻译成中文，分享给有需要的朋友；以下是原文。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lovejade.oss-cn-shenzhen.aliyuncs.com/decisions.png&quot; title=&quot;&quot; alt=&quot;如何优化您的日常决策&quot;/&gt;&lt;/p&gt;

&lt;p&gt;您可能会假设人们购买产品是因为它们是什么，但事实是，我们经常购买东西是因为它们的位置。例如，与视线齐平的商店货架上的商品往往比不太显眼的货架上的商品购买得更多。&lt;/p&gt;

&lt;p&gt;在畅销书 &lt;a href=&quot;https://jamesclear.com/book/nudge&quot; rel=&quot; nofollow ugc&quot; title=&quot;理查德·塞勒 (Richard Thaler) 和卡斯·桑斯坦 (Cass Sunstein) 的推动&quot;&gt;Nudge&lt;/a&gt; ( &lt;a href=&quot;https://jamesclear.com/ebook/nudge&quot; rel=&quot; nofollow ugc&quot; title=&quot;轻推电子书&quot;&gt;Kindle&lt;/a&gt; | &lt;a href=&quot;https://jamesclear.com/audiobook/nudge&quot; rel=&quot; nofollow ugc&quot; title=&quot;轻推有声读物&quot;&gt;Audiobook&lt;/a&gt; ) 中，作者 Richard Thaler 和 Cass Sunstein 解释了我们日常决策受周围世界影响的各种方式。视线水平的货架对我们购买习惯的影响只是一个例子。&lt;/p&gt;

&lt;p&gt;这是另一个：&lt;/p&gt;

&lt;p&gt;过道的尽头是零售商的赚钱机器。根据《纽约时报》引用的数据，可口可乐 45% 的销售额专门来自过道尽头的货架。&lt;/p&gt;

&lt;p&gt;这就是为什么这很重要：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一些东西&lt;/strong&gt;必须放在与视线齐平的架子上。必须在过道尽头的架子上放&lt;em&gt;一些东西&lt;/em&gt;。某些东西必须是默认选择。某些东西必须是最能见度和最突出的选项。这不仅适用于商店，而且适用于我们生活的几乎每个领域。您的办公室、汽车、厨房和客厅都有默认选择。&lt;/p&gt;

&lt;p&gt;我的论点是这样的：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果你为生活中的默认而设计，而不是接受交给你的任何东西，那么过上更好的生活会更容易&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;现在让我们谈谈如何做到这一点。&lt;/p&gt;

&lt;h2&gt;默认设计&lt;/h2&gt;

&lt;p&gt;尽管我们中的大多数人在任何特定时刻都有做出广泛选择的自由，但我们经常根据所处的环境做出决定。&lt;/p&gt;

&lt;p&gt;例如，如果我想这样做，我可以在写这篇文章时喝一杯啤酒。但是，我目前坐在办公桌前，旁边放着一杯水。看不到啤酒。虽然我有能力起床、步行到我的车、开车去商店和买啤酒，但我可能不会，因为我周围有更简单的选择——即饮用水。在这种情况下，喝一口水是默认的决定，很容易的决定。&lt;/p&gt;

&lt;p&gt;考虑在您的个人和职业生涯中如何设计您的默认决定。例如：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;如果您睡觉时将手机放在床边，那么醒来后立即查看社交媒体和电子邮件可能是默认决定。&lt;/li&gt;
&lt;li&gt;如果你走进你的客厅，你的沙发和椅子都面向电视机，那么看电视很可能是默认的决定。&lt;/li&gt;
&lt;li&gt;如果您在厨房里放酒，那么持续饮酒更有可能成为默认决定。&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;当然，默认值也可以是正数。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;如果你在工作时在办公桌旁边放一个哑铃，那么做一些快速的弯举更有可能是默认的决定。&lt;/li&gt;
&lt;li&gt;如果你全天都带着水瓶，那么喝水而不是苏打水更有可能是默认的决定。&lt;/li&gt;
&lt;li&gt;如果您将牙线放在可见的位置（例如牙刷旁边），则使用牙线更可能是默认决定。&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;研究人员将环境违约对我们决策的影响称为&lt;a href=&quot;https://jamesclear.com/choice-architecture&quot; rel=&quot; nofollow ugc&quot; title=&quot;选择架构&quot;&gt;选择架构&lt;/a&gt;。重要的是要意识到您可以成为您选择的架构师。您可以设计为默认。&lt;/p&gt;

&lt;h2&gt;如何优化您的默认决策&lt;/h2&gt;

&lt;p&gt;以下是我在尝试为我的生活中的默认设计时发现的一些有用的策略：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;简单&lt;/strong&gt;。当您经常被噪音包围时，很难将注意力集中在信号上。当你的厨房里堆满垃圾食品时，要吃得健康就更难了。当您在浏览器中打开 10 个选项卡时，更难以专注于阅读博客文章。当您陷入&lt;a href=&quot;https://jamesclear.com/multitasking-myth&quot; rel=&quot; nofollow ugc&quot; title=&quot;多任务处理的神话：为什么更少的优先级会导致更好的工作&quot;&gt;一心多用的神话&lt;/a&gt;时，完成最重要的任务就更加困难了。如有疑问，消除选项。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;视觉提示&lt;/strong&gt;。在超市中，将商品放在与视线齐平的货架上会使它们更具视觉效果并且更有可能被购买。在超市之外，您可以使用诸如&lt;a href=&quot;https://jamesclear.com/paper-clips&quot; rel=&quot; nofollow ugc&quot; title=&quot;如何通过使用回形针策略坚持每天的好习惯&quot;&gt;回形针法&lt;/a&gt;或&lt;a href=&quot;https://jamesclear.com/stop-procrastinating-seinfeld-strategy&quot; rel=&quot; nofollow ugc&quot; title=&quot;如何使用宋飞正传策略停止拖延你的目标&quot;&gt;宋飞策略之&lt;/a&gt;类的视觉提示来创建一个环境，在视觉上将您的行为推向正确的方向。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;选择退出与选择加入&lt;/strong&gt;。有一项&lt;a href=&quot;https://jamesclear.com/environment-design-organ-donation&quot; rel=&quot; nofollow ugc&quot; title=&quot;器官捐献与环境设计&quot;&gt;著名的器官捐赠研究&lt;/a&gt;揭示了多个欧洲国家如何提高器官捐赠率：他们要求公民选择不捐赠而不是选择捐赠。通过提前让未来的自己养成更好的习惯，你可以在生活中做一些类似的事情。例如，您可以将瑜伽课程安排在下周，而您今天感到有动力。当您的锻炼开始时，您必须证明选择退出是合理的，而不是激励自己选择加入。&lt;/p&gt;

&lt;p&gt;默认设计归结为一个非常简单的前提：改变你的环境，让好的行为更容易，坏的行为更难。&lt;/p&gt;

&lt;h2&gt;为您设计与由您设计&lt;/h2&gt;

&lt;p&gt;默认选择本身并不坏，但整个世界的设计都没有考虑到您的目标。事实上，许多公司的目标与您的目标直接竞争（食品公司可能希望您购买他们的薯片袋，而您想减肥）。出于这个原因，您应该谨慎接受每一个默认值，就好像它应该是最佳选择一样。&lt;/p&gt;

&lt;p&gt;我通过过自己设计的生活而不是接受别人给我的标准生活，从而获得了更多的成功。质疑一切。你需要改变、调整和改变你的环境，直到它符合你想要的生活。&lt;/p&gt;

&lt;p&gt;是的，你周围的世界塑造了你的习惯和选择，但有一件重要的事情需要意识到：首先必须有人来塑造这个世界。现在，有人可以是你。&lt;/p&gt;

&lt;p&gt;如果你想要更多关于改掉坏习惯和养成好习惯的实用想法，请查看我的书&lt;a href=&quot;https://jamesclear.com/book/atomic-habits&quot; rel=&quot; nofollow ugc&quot;&gt;原子习惯&lt;/a&gt;，它会告诉你习惯的微小改变如何带来显着的结果。&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;通过该文的阅读，可以给生活、工作带来哪些启示？下面跟大家分享一些（如您有更多建议，欢迎留言分享）：&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;定时对浏览器所打开的页面，加以阅读、消化、整理，然后关闭；从而提升专注；&lt;/li&gt;
&lt;li&gt;不再将短视频、微信等浪费时间，却没有太大价值的应用，放置手机桌面显眼位置；&lt;/li&gt;
&lt;li&gt;如您也有游戏瘾，周末将至，列出读一本书，或看几部电影的计划，尽量不去想玩游戏这事儿；&lt;/li&gt;
&lt;li&gt;如一定要玩儿，那么再玩了几盘，尽兴之后，删除游戏，让下次打开游戏，变得困难......&lt;/li&gt;&lt;/ol&gt;
                &lt;/div&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a9d2dc9667671b974fdc13380b207a27</guid>
<title>[推荐] 95% 的算法都是基于这 6 种算法思想</title>
<link>https://toutiao.io/k/pbwl6pl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section class=&quot;mp_profile_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg2NjUxOTM2Mg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKmTRcFWKB5pLtwz9auwyvjn6nhiaSydyGVuAfOfGmdpTBaqLJyLHVwDgXKNicS1VHhJSBADHCk2dib4Q/0?wx_fmt=png&quot; data-nickname=&quot;三分钟学前端&quot; data-alias=&quot;&quot; data-signature=&quot;每日三分钟，学习一个前端小 Tip！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;点击上方 &lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(0, 128, 255)&quot;&gt;三分钟学前端&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;，关注公众号&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回复&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(0, 128, 255)&quot;&gt;交流&lt;/span&gt;&lt;span&gt;，加入前端编程面试算法每日一题群&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;weapp_text_link js_weapp_entry&quot; data-miniprogram-appid=&quot;wx27c980b913cbfb08&quot; data-miniprogram-path=&quot;pages/index/index&quot; data-miniprogram-nickname=&quot;高级前端面试&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-servicetype=&quot;0&quot; href=&quot;&quot;&gt;面试官也在看的前端面试资料&lt;/a&gt;&lt;/p&gt;&lt;p&gt;算法思想是解决问题的核心，万丈高楼起于平地，在算法中也是如此，95% 的算法都是基于这 6 种算法思想，结下了介绍一下这 6 种算法思想，帮助你理解及解决各种算法问题。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;1 递归算法&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;1.1 算法策略&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;递归算法是一种直接或者间接调用自身函数或者方法的算法。&lt;/p&gt;&lt;p&gt;递归算法的实质是把问题分解成规模缩小的同类问题的子问题，然后递归调用方法来表示问题的解。递归算法对解决一大类问题很有效，它可以使算法简洁和易于理解。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;优缺点：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;优点：实现简单易上手&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缺点：递归算法对常用的算法如普通循环等，运行效率较低；并且在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储，递归太深，容易发生栈溢出&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;1.2 适用场景&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;递归算法一般用于解决三类问题：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据的定义是按递归定义的。（斐波那契数列）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;问题解法按递归算法实现。（回溯）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据的结构形式是按递归定义的。（树的遍历，图的搜索）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;递归的解题策略：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一步：明确你这个函数的输入输出，先不管函数里面的代码什么，而是要先明白，你这个函数的输入是什么，输出为何什么，功能是什么，要完成什么样的一件事。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二步：寻找递归结束条件，我们需要找出什么时候递归结束，之后直接把结果返回&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三步：明确递归关系式，怎么通过各种递归调用来组合解决当前问题&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;1.3 使用递归算法求解的一些经典问题&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;DOM树为例&lt;/h4&gt;&lt;p&gt;下面以以 DOM 🌲为例，实现一个 &lt;code&gt;document.getElementById&lt;/code&gt; 功能&lt;/p&gt;&lt;p&gt;由于DOM是一棵树，而树的定义本身就是用的递归定义，所以用递归的方法处理树，会非常地简单自然。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第一步：明确你这个函数的输入输出&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从 DOM 🌲根节点一层层往下递归，判断当前节点的 id 是否是我们要寻找的 &lt;code&gt;id=&#x27;d-cal&#x27;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输入：DOM 🌲根节点 &lt;code&gt;document&lt;/code&gt; ，我们要寻找的 &lt;code&gt;id=&#x27;d-cal&#x27;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出：返回满足 &lt;code&gt;id=&#x27;sisteran&#x27;&lt;/code&gt; 的子结点&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getElementById&lt;/span&gt;(&lt;span&gt;node, id&lt;/span&gt;)&lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第二步：寻找递归结束条件&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从document开始往下找，对所有子结点递归查找他们的子结点，一层一层地往下查找：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果当前结点的 id 符合查找条件，则返回当前结点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果已经到了叶子结点了还没有找到，则返回 null&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getElementById&lt;/span&gt;(&lt;span&gt;node, id&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 当前结点不存在，已经到了叶子结点了还没有找到，返回 null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(!node) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 当前结点的 id 符合查找条件，返回当前结点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(node.id === id) &lt;span&gt;return&lt;/span&gt; node&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第三步：明确递归关系式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当前结点的 id 不符合查找条件，递归查找它的每一个子结点&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getElementById&lt;/span&gt;(&lt;span&gt;node, id&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 当前结点不存在，已经到了叶子结点了还没有找到，返回 null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(!node) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 当前结点的 id 符合查找条件，返回当前结点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(node.id === id) &lt;span&gt;return&lt;/span&gt; node&lt;br/&gt;    &lt;span&gt;// 前结点的 id 不符合查找条件，继续查找它的每一个子结点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; node.childNodes.length; i++){&lt;br/&gt;        &lt;span&gt;// 递归查找它的每一个子结点&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; found = getElementById(node.childNodes[i], id);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(found) &lt;span&gt;return&lt;/span&gt; found;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就这样，我们的一个 &lt;code&gt;document.getElementById&lt;/code&gt; 功能已经实现了：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getElementById&lt;/span&gt;(&lt;span&gt;node, id&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(!node) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(node.id === id) &lt;span&gt;return&lt;/span&gt; node;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; node.childNodes.length; i++){&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; found = getElementById(node.childNodes[i], id);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(found) &lt;span&gt;return&lt;/span&gt; found;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;getElementById(&lt;span&gt;document&lt;/span&gt;, &lt;span&gt;&quot;d-cal&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后在控制台验证一下，执行结果如下图所示：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.15047021943573669&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgjAl3KN8xL01fGUYkLliaQeV28Qf6gficmIPbTGPuBeXEgdiaRR5N9W1Qjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;319&quot;/&gt;&lt;/figure&gt;&lt;p&gt;使用递归的优点是代码简单易懂，缺点是效率比不上非递归的实现。Chrome浏览器的查DOM是使用非递归实现。非递归要怎么实现呢？&lt;/p&gt;&lt;p&gt;如下代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getByElementId&lt;/span&gt;(&lt;span&gt;node, id&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//遍历所有的Node&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(node){&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(node.id === id) &lt;span&gt;return&lt;/span&gt; node;&lt;br/&gt;        node = nextElement(node);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;还是依次遍历所有的 &lt;code&gt;DOM&lt;/code&gt; 结点，只是这一次改成一个 &lt;code&gt;while&lt;/code&gt; 循环，函数 &lt;code&gt;nextElement&lt;/code&gt; 负责找到下一个结点。所以关键在于这个 &lt;code&gt;nextElement&lt;/code&gt; 如何实现非递归查找结点功能：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 深度遍历&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;nextElement&lt;/span&gt;(&lt;span&gt;node&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 先判断是否有子结点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(node.children.length) {&lt;br/&gt;        &lt;span&gt;// 有则返回第一个子结点&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; node.children[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 再判断是否有相邻结点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(node.nextElementSibling){&lt;br/&gt;        &lt;span&gt;// 有则返回它的下一个相邻结点&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; node.nextElementSibling;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 否则，往上返回它的父结点的下一个相邻元素，相当于上面递归实现里面的for循环的i加1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(node.parentNode){&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(node.parentNode.nextElementSibling) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; node.parentNode.nextElementSibling;&lt;br/&gt;        }&lt;br/&gt;        node = node.parentNode;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在控制台里面运行这段代码，同样也可以正确地输出结果。不管是非递归还是递归，它们都是深度优先遍历，这个过程如下图所示。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.734375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgjd6ic73IhdCfhuBp5nM2vCQdkT2D3D8h4JrG1Kib0APPJviaApib8ZsAkpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p&gt;实际上 getElementById 浏览器是用的一个哈希 map 存储的，根据 id 直接映射到 DOM 结点，而 getElementsByClassName 就是用的这样的非递归查找。&lt;/p&gt;&lt;p&gt;参考：我接触过的前端数据结构与算法&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2 分治算法&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;2.1 算法策略&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;在计算机科学中，分治算法是一个很重要的算法，快速排序、归并排序等都是基于分治策略进行实现的，所以，建议理解掌握它。&lt;/p&gt;&lt;p&gt;分治，顾名思义，就是 &lt;strong&gt;分而治之&lt;/strong&gt; ，将一个复杂的问题，分成两个或多个相似的子问题，在把子问题分成更小的子问题，直到更小的子问题可以简单求解，求解子问题，则原问题的解则为阿子问题解的合并。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;2.2 适用场景&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;当出现满足以下条件的问题，可以尝试只用分治策略进行求解：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;原始问题可以分成多个相似的子问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子问题可以很简单的求解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;原始问题的解是子问题解的合并&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;各个子问题是相互独立的，不包含相同的子问题&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;分治的解题策略：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一步：分解，将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二步：解决，解决各个子问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三步：合并，将各个子问题的解合并为原问题的解&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;2.3 &lt;strong&gt;使用分治法求解的一些经典问题&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;二分查找&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;归并排序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;快速排序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;汉诺塔问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;React 时间分片&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;二分查找&lt;/h4&gt;&lt;p&gt;也称折半查找算法，它是一种简单易懂的快速查找算法。例如我随机写0-100之间的一个数字，让你猜我写的是什么？你每猜一次，我就会告诉你猜的大了还是小了，直到猜中为止。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第一步：分解&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;每次猜拳都把上一次的结果分出大的一组和小的一组，两组相互独立&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;binarySearch&lt;/span&gt;(&lt;span&gt;items, item&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// low、mid、high将数组分成两组&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; low = &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;        high = items.length - &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;        mid = &lt;span&gt;Math&lt;/span&gt;.floor((low+high)/&lt;span&gt;2&lt;/span&gt;),&lt;br/&gt;        elem = items[mid]&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第二步：解决子问题&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;查找数与中间数对比&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;比中间数低，则去中间数左边的子数组中寻找；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;比中间数高，则去中间数右边的子数组中寻找；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;相等则返回查找成功&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;while&lt;/span&gt;(low &amp;lt;= high) {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt;(elem &amp;lt; item) { &lt;span&gt;// 比中间数高&lt;/span&gt;&lt;br/&gt;  low = mid + &lt;span&gt;1&lt;/span&gt;&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(elem &amp;gt; item) { &lt;span&gt;// 比中间数低&lt;/span&gt;&lt;br/&gt;  high = mid - &lt;span&gt;1&lt;/span&gt;&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; { &lt;span&gt;// 相等&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; mid&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第三步：合并&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;binarySearch&lt;/span&gt;(&lt;span&gt;items, item&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; low = &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;        high = items.length - &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;        mid, elem&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(low &amp;lt;= high) {&lt;br/&gt;        mid = &lt;span&gt;Math&lt;/span&gt;.floor((low+high)/&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        elem = items[mid]&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(elem &amp;lt; item) {&lt;br/&gt;            low = mid + &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(elem &amp;gt; item) {&lt;br/&gt;            high = mid - &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; mid&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后，二分法只能应用于数组有序的情况，如果数组无序，二分查找就不能起作用了&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;binarySearch&lt;/span&gt;(&lt;span&gt;items, item&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 快排&lt;/span&gt;&lt;br/&gt;    quickSort(items)&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; low = &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;        high = items.length - &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;        mid, elem&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(low &amp;lt;= high) {&lt;br/&gt;        mid = &lt;span&gt;Math&lt;/span&gt;.floor((low+high)/&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        elem = items[mid]&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(elem &amp;lt; item) {&lt;br/&gt;            low = mid + &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(elem &amp;gt; item) {&lt;br/&gt;            high = mid - &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; mid&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 测试&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; arr = [&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;]&lt;br/&gt;binarySearch(arr, &lt;span&gt;3&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;// 2&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;binarySearch(arr, &lt;span&gt;5&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;// -1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;测试成功&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3 贪心算法&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;3.1 算法策略&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;贪心算法，故名思义，总是做出当前的最优选择，即期望通过局部的最优选择获得整体的最优选择。&lt;/p&gt;&lt;p&gt;某种意义上说，贪心算法是很贪婪、很目光短浅的，它不从整体考虑，仅仅只关注当前的最大利益，所以说它做出的选择仅仅是某种意义上的局部最优，但是贪心算法在很多问题上还是能够拿到最优解或较优解，所以它的存在还是有意义的。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;3.2 适用场景&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;在日常生活中，我们使用到贪心算法的时候还是挺多的，例如：&lt;/p&gt;&lt;p&gt;从100章面值不等的钞票中，抽出 10 张，怎样才能获得最多的价值？&lt;/p&gt;&lt;p&gt;我们只需要每次都选择剩下的钞票中最大的面值，最后一定拿到的就是最优解，这就是使用的贪心算法，并且最后得到了整体最优解。&lt;/p&gt;&lt;p&gt;但是，我们任然需要明确的是，期望通过局部的最优选择获得整体的最优选择，仅仅是期望而已，也可能最终得到的结果并不一定不能是整体最优解。&lt;/p&gt;&lt;p&gt;例如：求取A到G最短路径：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.45131086142322097&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgj8nz3CUJ0yel7n0cL6hl2u6HuN8JmQK2xicriaVlSRTibsv2c7YRicN3BSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1068&quot;/&gt;&lt;/figure&gt;&lt;p&gt;根据贪心算法总是选择当前最优选择，所以它首先选择的路径是 AB，然后 BE、EG，所得到的路径总长为 1 + 5 + 4 = 10，然而这并不是最短路径，最短路径为 A-&amp;gt;C-&amp;gt;G : 2 + 2 = 4，所以说，贪心算法得到得并不一定是最优解。&lt;/p&gt;&lt;p&gt;那么一般在什么时候可以尝试选择使用贪心算法喃？&lt;/p&gt;&lt;p&gt;当满足一下条件时，可以使用：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;原问题复杂度过高&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;求全局最优解的数学模型难以建立或计算量过大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有太大必要一定要求出全局最优解，“比较优”就可以&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果使用贪心算法求最优解，可以按照以下 &lt;strong&gt;步骤求解&lt;/strong&gt; ：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先，我们需要明确什么是最优解（期望）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后，把问题分成多个步骤，每一步都需要满足：&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;- 不可取消：选择一旦做出，在后面遇到任何情况都不可取消&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后，叠加所有步骤的最优解，就是全局最优解&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;3.3 经典案例：活动选择问题&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;使用贪心算法求解的经典问题有：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;最小生成树算法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单源最短路径的 Dijkstra 算法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Huffman 压缩编码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;背包问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;活动选择问题等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;其中活动选择问题是最简单的，这里详细介绍这个。&lt;/p&gt;&lt;p&gt;活动选择问题是《算法导论》上的例子，也是一个非常经典的问题。有 n 个活动（a1,a2,…,an）需要使用同一个资源（例如教室），资源在某个时刻只能供一个活动使用。每个活动 ai 都有一个开始时间 si 和结束时间 fi 。一旦被选择后，活动 ai 就占据半开时间区间 [si,fi) 。如果 [si,fi) 和 [sj,fj) 互不重叠，ai 和 aj 两个活动就可以被安排在这一天。&lt;/p&gt;&lt;p&gt;该问题就是要安排这些活动，使得尽量多的活动能不冲突的举行。例如下图所示的活动集合S，其中各项活动按照结束时间单调递增排序。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.55&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgjE2QHwZsdIbcH8Qqib0bpI6iciaCaRcCNnWxZJVmibzkVLnhdN8RHsrjvHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot;/&gt;&lt;/figure&gt;&lt;p&gt;共有 7 个活动，它们在 18 个小时内需要占用的时间如上图，如何选择活动，能让这间教室利用率最高喃（能够举行更多的活动）？&lt;/p&gt;&lt;p&gt;贪心算法对这种问题的解决很简单的，它开始时刻开始选择，每次选择开始时间与与已选择活动不冲突的，结束时间又比较靠前的活动，这样会让剩下的时间区间更长。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgj5rHSHmzhnYj2X9wh1B1OE9chyvTIUib10QZxyHe51fEeeFqsx6Ng7Og/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot;/&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先 a1 活动的结束时间最早，选择 a1 活动&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;a1 结束后，a2 有时间冲突，不可选择，a3、a4 都可选择，但 a4 结束时间最早，选择 a4&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;依次选择时间没有冲突的，又结束时间最早的活动&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;最终选择活动为 a1，a4，a5，a7。为最优解。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;4 回溯算法&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;4.1 算法策略&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;回溯算法是一种搜索法，试探法，它会在每一步做出选择，一旦发现这个选择无法得到期望结果，就回溯回去，重新做出选择。深度优先搜索利用的就是回溯算法思想。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;4.2 适用场景&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;回溯算法很简单，它就是不断的尝试，直到拿到解。它的这种算法思想，使它通常用于解决广度的搜索问题，即从一组可能的解中，选择一个满足要求的解。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;4.3 使用回溯算法的经典案例&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;深度优先搜索&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;0-1背包问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;正则表达式匹配&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;八皇后&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数独&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;全排列&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;等等，深度优先搜索我们在图那一章已经介绍过，这里以正则表达式匹配为例，介绍一下&lt;/p&gt;&lt;h4&gt;正则表达式匹配&lt;/h4&gt;&lt;blockquote&gt;&lt;p&gt;var string = &quot;abbc&quot;&lt;/p&gt;&lt;p&gt;var regex = /ab{1,3}c/&lt;/p&gt;&lt;p&gt;console.log( string.match(regex) )&lt;/p&gt;&lt;p&gt;// [&quot;abbc&quot;, index: 0, input: &quot;abbc&quot;, groups: undefined]&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;它的匹配过程：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8680445151033387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgjc1PczkYecKZVGhyibXe5pHNaexicB9XQx65zwicysE4XGFibQaBXYxZFoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;629&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在第 5 步匹配失败，此时 &lt;code&gt;b{1,3}&lt;/code&gt; 已经匹配到了两个 &lt;code&gt;b&lt;/code&gt; 正在尝试第三个 &lt;code&gt;b&lt;/code&gt; ，结果发现接下来是 &lt;code&gt;c&lt;/code&gt; 。此时就需要回溯到上一步， &lt;code&gt;b{1,3}&lt;/code&gt; 匹配完毕（匹配到了 &lt;code&gt;bb&lt;/code&gt; ），然后再匹配 &lt;code&gt;c&lt;/code&gt; ，匹配到了 &lt;code&gt;c&lt;/code&gt; 匹配结束。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;5 动态规划&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;5.1 算法策略&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;动态规划也是将复杂问题分解成小问题求解的策略，与分治算法不同的是，分治算法要求各子问题是相互独立的，而动态规划各子问题是相互关联的。&lt;/p&gt;&lt;p&gt;所以，动态规划适用于子问题重叠的情况，即不同的子问题具有公共的子子问题，在这种情况下，分治策略会做出很多不必要的工作，它会反复求解那些公共子子问题，而动态规划会对每个子子问题求解一次，然后保存在表格中，如果遇到一致的问题，从表格中获取既可，所以它无需求解每一个子子问题，避免了大量的不必要操作。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;5.2 适用场景&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;动态规划适用于求解最优解问题，比如，从面额不定的100个硬币中任意选取多个凑成10元，求怎样选取硬币才可以使最后选取的硬币数最少又刚好凑够了10元。这就是一个典型的动态规划问题。它可以分成一个个子问题（每次选取硬币），每个子问题又有公共的子子问题（选取硬币），子问题之间相互关联（已选取的硬币总金额不能超过10元），边界条件就是最终选取的硬币总金额为 10 元。&lt;/p&gt;&lt;p&gt;针对上例，也许你也可以说，我们可以使用回溯算法，不断的去试探，但回溯算法是使用与求解广度的解（满足要求的解），如果是用回溯算法，我们需要尝试去找所有满足条件的解，然后找到最优解，时间复杂度为 O(2^n^) ，这性能是相当差的。大多数适用于动态规划的问题，都可以使用回溯算法，只是使用回溯算法的时间复杂度比较高而已。&lt;/p&gt;&lt;p&gt;最后，总结一下，我们使用动态规划求解问题时，需要遵循以下几个重要步骤：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;定义子问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实现需要反复执行解决的子子问题部分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;识别并求解出边界条件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;5.3 使用动态规划求解的一些经典问题&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;爬楼梯问题：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;背包问题：给出一些资源（有总量及价值），给一个背包（有总容量），往背包里装资源，目标是在背包不超过总容量的情况下，装入更多的价值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;硬币找零：给出面额不定的一定数量的零钱，以及需要找零的钱数，找出有多少种找零方案&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;图的全源最短路径：一个图中包含 u、v 顶点，找出从顶点 u 到顶点 v 的最短路径&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变剩下元素的顺序实现）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这里以最长公共子序列为例。&lt;/p&gt;&lt;h4&gt;爬楼梯问题&lt;/h4&gt;&lt;p&gt;这里以动态规划经典问题爬楼梯问题为例，介绍求解动态规划问题的步骤。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第一步：定义子问题&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如果用 &lt;code&gt;dp[n]&lt;/code&gt; 表示第 &lt;code&gt;n&lt;/code&gt; 级台阶的方案数，并且由题目知：最后一步可能迈 2 个台阶，也可迈 1 个台阶，即第 &lt;code&gt;n&lt;/code&gt; 级台阶的方案数等于第 &lt;code&gt;n-1&lt;/code&gt; 级台阶的方案数加上第 &lt;code&gt;n-2&lt;/code&gt; 级台阶的方案数&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二步：实现需要反复执行解决的子子问题部分&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[n] = dp[n−&lt;span&gt;1&lt;/span&gt;] + dp[n−&lt;span&gt;2&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第三步：识别并求解出边界条件&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 第 0 级 1 种方案 &lt;/span&gt;&lt;br/&gt;dp[&lt;span&gt;0&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 第 1 级也是 1 种方案 &lt;/span&gt;&lt;br/&gt;dp[&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;最后一步：把尾码翻译成代码，处理一些边界情况&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; climbStairs = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; dp = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;2&lt;/span&gt;; i &amp;lt;= n; i++) {&lt;br/&gt;        dp[i] = dp[i - &lt;span&gt;1&lt;/span&gt;] + dp[i - &lt;span&gt;2&lt;/span&gt;]&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; dp[n]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;优化空间复杂度：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; climbStairs = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; res = &lt;span&gt;1&lt;/span&gt;, n1 = &lt;span&gt;1&lt;/span&gt;, n2 = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;2&lt;/span&gt;; i &amp;lt;= n; i++) {&lt;br/&gt;        res = n1 + n2&lt;br/&gt;        n1 = n2&lt;br/&gt;        n2 = res&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;空间复杂度：O(1)&lt;/p&gt;&lt;h2&gt;&lt;span&gt;6 枚举算法&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;6.1 算法策略&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;枚举算法的思想是：将问题的所有可能的答案一一列举，然后根据条件判断此答案是否合适，保留合适的，丢弃不合适的。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;6.2 解题思路&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;确定枚举对象、枚举范围和判定条件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;逐一列举可能的解，验证每个解是否是问题的解。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;7 刷题&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;7.1 爬楼梯问题&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;假设你正在爬楼梯。需要 n 阶你才能到达楼顶。&lt;/p&gt;&lt;p&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 给定 n 是一个正整数。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入： &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;输出： &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;解释： 有两种方法可以爬到楼顶。&lt;br/&gt;&lt;span&gt;1.&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; 阶 + &lt;span&gt;1&lt;/span&gt; 阶&lt;br/&gt;&lt;span&gt;2.&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; 阶&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入： &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;输出： &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;解释： 有三种方法可以爬到楼顶。&lt;br/&gt;&lt;span&gt;1.&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; 阶 + &lt;span&gt;1&lt;/span&gt; 阶 + &lt;span&gt;1&lt;/span&gt; 阶&lt;br/&gt;&lt;span&gt;2.&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; 阶 + &lt;span&gt;2&lt;/span&gt; 阶&lt;br/&gt;&lt;span&gt;3.&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; 阶 + &lt;span&gt;1&lt;/span&gt; 阶&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;解法：动态规划&lt;/h4&gt;&lt;p&gt;动态规划（Dynamic Programming，DP）是一种将复杂问题分解成小问题求解的策略，但与分治算法不同的是，分治算法要求各子问题是相互独立的，而动态规划各子问题是相互关联的。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;分治，顾名思义，就是分而治之，将一个复杂的问题，分成两个或多个相似的子问题，在把子问题分成更小的子问题，直到更小的子问题可以简单求解，求解子问题，则原问题的解则为子问题解的合并。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我们使用动态规划求解问题时，需要遵循以下几个重要步骤：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;定义子问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实现需要反复执行解决的子子问题部分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;识别并求解出边界条件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;第一步：定义子问题&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如果用 &lt;code&gt;dp[n]&lt;/code&gt; 表示第 &lt;code&gt;n&lt;/code&gt; 级台阶的方案数，并且由题目知：最后一步可能迈 2 个台阶，也可迈 1 个台阶，即第 &lt;code&gt;n&lt;/code&gt; 级台阶的方案数等于第 &lt;code&gt;n-1&lt;/code&gt; 级台阶的方案数加上第 &lt;code&gt;n-2&lt;/code&gt; 级台阶的方案数&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二步：实现需要反复执行解决的子子问题部分&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[n] = dp[n−&lt;span&gt;1&lt;/span&gt;] + dp[n−&lt;span&gt;2&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第三步：识别并求解出边界条件&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 第 0 级 1 种方案 &lt;/span&gt;&lt;br/&gt;dp[&lt;span&gt;0&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 第 1 级也是 1 种方案 &lt;/span&gt;&lt;br/&gt;dp[&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;最后一步：把尾码翻译成代码，处理一些边界情况&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; climbStairs = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; dp = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;2&lt;/span&gt;; i &amp;lt;= n; i++) {&lt;br/&gt;        dp[i] = dp[i - &lt;span&gt;1&lt;/span&gt;] + dp[i - &lt;span&gt;2&lt;/span&gt;]&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; dp[n]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;优化空间复杂度：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; climbStairs = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; res = &lt;span&gt;1&lt;/span&gt;, n1 = &lt;span&gt;1&lt;/span&gt;, n2 = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;2&lt;/span&gt;; i &amp;lt;= n; i++) {&lt;br/&gt;        res = n1 + n2&lt;br/&gt;        n1 = n2&lt;br/&gt;        n2 = res&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;空间复杂度：O(1)&lt;/p&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.2 使用最小花费爬楼梯&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;数组的每个索引作为一个阶梯，第 &lt;code&gt;i&lt;/code&gt; 个阶梯对应着一个非负数的体力花费值 &lt;code&gt;cost[i]&lt;/code&gt; (索引从0开始)。&lt;/p&gt;&lt;p&gt;每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。&lt;/p&gt;&lt;p&gt;您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: cost = [&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;15&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;]&lt;br/&gt;输出: &lt;span&gt;15&lt;/span&gt;&lt;br/&gt;解释: 最低花费是从cost[&lt;span&gt;1&lt;/span&gt;]开始，然后走两步即可到阶梯顶，一共花费&lt;span&gt;15&lt;/span&gt;。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: cost = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;输出: &lt;span&gt;6&lt;/span&gt;&lt;br/&gt;解释: 最低花费方式是从cost[&lt;span&gt;0&lt;/span&gt;]开始，逐个经过那些&lt;span&gt;1&lt;/span&gt;，跳过cost[&lt;span&gt;3&lt;/span&gt;]，一共花费&lt;span&gt;6&lt;/span&gt;。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;cost&lt;/code&gt; 的长度将会在 &lt;code&gt;[2, 1000]&lt;/code&gt; 。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每一个 &lt;code&gt;cost[i]&lt;/code&gt; 将会是一个Integer类型，范围为 &lt;code&gt;[0, 999]&lt;/code&gt; 。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;解法：动态规划&lt;/h4&gt;&lt;p&gt;本题注意理解题意：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第 &lt;code&gt;i&lt;/code&gt; 级台阶是第 &lt;code&gt;i-1&lt;/code&gt; 级台阶的阶梯顶部。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;踏上第 &lt;code&gt;i&lt;/code&gt; 级台阶花费 &lt;code&gt;cost[i]&lt;/code&gt; ，直接迈一大步跨过而不踏上去则不用花费。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;楼梯顶部在数组之外，如果数组长度为 &lt;code&gt;len&lt;/code&gt;，那么楼顶就在下标为 &lt;code&gt;len&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;第一步：定义子问题&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;踏上第 &lt;code&gt;i&lt;/code&gt; 级台阶的体力消耗为到达前两个阶梯的最小体力消耗加上本层体力消耗：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;最后迈 1 步踏上第 &lt;code&gt;i&lt;/code&gt; 级台阶：&lt;code&gt;dp[i-1] + cost[i]&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后迈 1 步踏上第 &lt;code&gt;i&lt;/code&gt; 级台阶：&lt;code&gt;dp[i-2] + cost[i]&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;第二步：实现需要反复执行解决的子子问题部分&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;所以踏上第 &lt;code&gt;i&lt;/code&gt; 级台阶的最小花费为：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[i] = min(dp[i&lt;span&gt;-2&lt;/span&gt;], dp[i&lt;span&gt;-1&lt;/span&gt;]) + cost[i]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第三步：识别并求解出边界条件&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 第 0 级 cost[0] 种方案 &lt;/span&gt;&lt;br/&gt;dp[&lt;span&gt;0&lt;/span&gt;] = cost[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;// 第 1 级，有两种情况&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 1：分别踏上第0级与第1级台阶，花费cost[0] + cost[1]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 2：直接从地面开始迈两步直接踏上第1级台阶，花费cost[1]&lt;/span&gt;&lt;br/&gt;dp[&lt;span&gt;1&lt;/span&gt;] = min(cost[&lt;span&gt;0&lt;/span&gt;] + cost[&lt;span&gt;1&lt;/span&gt;], cost[&lt;span&gt;1&lt;/span&gt;]) = cost[&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;最后一步：把尾码翻译成代码，处理一些边界情况&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; minCostClimbingStairs = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;cost&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    cost.push(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; dp = [], n = cost.length&lt;br/&gt;    dp[&lt;span&gt;0&lt;/span&gt;] = cost[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;    dp[&lt;span&gt;1&lt;/span&gt;] = cost[&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;2&lt;/span&gt;; i &amp;lt; n; i++){&lt;br/&gt;        dp[i] = &lt;span&gt;Math&lt;/span&gt;.min(dp[i&lt;span&gt;-2&lt;/span&gt;] , dp[i&lt;span&gt;-1&lt;/span&gt;]) + cost[i]&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; dp[n&lt;span&gt;-1&lt;/span&gt;]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;优化：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; minCostClimbingStairs = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;cost&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; n = cost.length,&lt;br/&gt;        n1 = cost[&lt;span&gt;0&lt;/span&gt;],&lt;br/&gt;        n2 = cost[&lt;span&gt;1&lt;/span&gt;] &lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;2&lt;/span&gt;;i &amp;lt; n;i++){&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; tmp = n2&lt;br/&gt;        n2 = &lt;span&gt;Math&lt;/span&gt;.min(n1,n2)+cost[i]&lt;br/&gt;        n1 = tmp&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Math&lt;/span&gt;.min(n1,n2)&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.3 最大子序和&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [&lt;span&gt;-2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;-3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;-1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;-5&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;]&lt;br/&gt;输出: &lt;span&gt;6&lt;/span&gt;&lt;br/&gt;解释: 连续子数组 [&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;-1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;] 的和最大，为 &lt;span&gt;6&lt;/span&gt;。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;进阶:&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第一步：定义子问题&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;动态规划是将整个数组归纳考虑，假设我们已经知道了以第 &lt;code&gt;i-1&lt;/code&gt; 个数结尾的连续子数组的最大和 &lt;code&gt;dp[i-1]&lt;/code&gt;，显然以第&lt;code&gt;i&lt;/code&gt;个数结尾的连续子数组的最大和的可能取值要么为 &lt;code&gt;dp[i-1]+nums[i]&lt;/code&gt;，要么就是 &lt;code&gt;nums[i]&lt;/code&gt; 单独成一组，也就是 &lt;code&gt;nums[i]&lt;/code&gt; ，在这两个数中我们取最大值&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二步：实现需要反复执行解决的子子问题部分&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[n] = &lt;span&gt;Math&lt;/span&gt;.max(dp[n−&lt;span&gt;1&lt;/span&gt;]+nums[n], nums[n])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第三步：识别并求解出边界条件&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[&lt;span&gt;0&lt;/span&gt;]=nums[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;最后一步：把尾码翻译成代码，处理一些边界情况&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;因为我们在计算 &lt;code&gt;dp[i]&lt;/code&gt; 的时候，只关心 &lt;code&gt;dp[i-1]&lt;/code&gt; 与 &lt;code&gt;nums[i]&lt;/code&gt;，因此不用把整个 &lt;code&gt;dp&lt;/code&gt; 数组保存下来，只需设置一个 &lt;code&gt;pre&lt;/code&gt; 保存 &lt;code&gt;dp[i-1]&lt;/code&gt; 就好了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;代码实现（优化）：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; maxSubArray = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;nums&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; max = nums[&lt;span&gt;0&lt;/span&gt;], pre = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;const&lt;/span&gt; num &lt;span&gt;of&lt;/span&gt; nums) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(pre &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            pre += num&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            pre = num&lt;br/&gt;        }&lt;br/&gt;        max = &lt;span&gt;Math&lt;/span&gt;.max(max, pre)&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; max&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.4 买卖股票的最佳时机&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。&lt;/p&gt;&lt;p&gt;如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。&lt;/p&gt;&lt;p&gt;注意：你不能在买入股票前卖出股票。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;]&lt;br/&gt;输出: &lt;span&gt;5&lt;/span&gt;&lt;br/&gt;解释: 在第 &lt;span&gt;2&lt;/span&gt; 天（股票价格 = &lt;span&gt;1&lt;/span&gt;）的时候买入，在第 &lt;span&gt;5&lt;/span&gt; 天（股票价格 = &lt;span&gt;6&lt;/span&gt;）的时候卖出，最大利润 = &lt;span&gt;6&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt; = &lt;span&gt;5&lt;/span&gt; 。&lt;br/&gt;     注意利润不能是 &lt;span&gt;7&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt; = &lt;span&gt;6&lt;/span&gt;, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;输出: &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;解释: 在这种情况下, 没有交易完成, 所以最大利润为 &lt;span&gt;0&lt;/span&gt;。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;解法：动态规划&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;第一步：定义子问题&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;动态规划是将整个数组归纳考虑，假设我们已经知道了 &lt;code&gt;i-1&lt;/code&gt; 个股票的最大利润为 &lt;code&gt;dp[i-1]&lt;/code&gt;，显然 &lt;code&gt;i&lt;/code&gt; 个连续股票的最大利润为 &lt;code&gt;dp[i-1]&lt;/code&gt; ，要么就是就是 &lt;code&gt;prices[i] - minprice&lt;/code&gt; （ &lt;code&gt;minprice&lt;/code&gt; 为前 &lt;code&gt;i-1&lt;/code&gt; 支股票的最小值 ），在这两个数中我们取最大值&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二步：实现需要反复执行解决的子子问题部分&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[i] = &lt;span&gt;Math&lt;/span&gt;.max(dp[i−&lt;span&gt;1&lt;/span&gt;], prices[i] - minprice)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第三步：识别并求解出边界条件&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[&lt;span&gt;0&lt;/span&gt;]=&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;最后一步：把尾码翻译成代码，处理一些边界情况&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;因为我们在计算 &lt;code&gt;dp[i]&lt;/code&gt; 的时候，只关心 &lt;code&gt;dp[i-1]&lt;/code&gt; 与 &lt;code&gt;prices[i]&lt;/code&gt;，因此不用把整个 &lt;code&gt;dp&lt;/code&gt; 数组保存下来，只需设置一个 &lt;code&gt;max&lt;/code&gt; 保存 &lt;code&gt;dp[i-1]&lt;/code&gt; 就好了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;代码实现（优化）：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; maxProfit = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;prices&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; max = &lt;span&gt;0&lt;/span&gt;, minprice = prices[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; prices.length; i++) {&lt;br/&gt;        minprice = &lt;span&gt;Math&lt;/span&gt;.min(prices[i], minprice)&lt;br/&gt;        max = &lt;span&gt;Math&lt;/span&gt;.max(max, prices[i] - minprice)&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; max&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.5 回文子串&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。&lt;/p&gt;&lt;p&gt;具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入：&lt;span&gt;&quot;abc&quot;&lt;/span&gt;&lt;br/&gt;输出：3&lt;br/&gt;解释：三个回文子串: &lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入：&lt;span&gt;&quot;aaa&quot;&lt;/span&gt;&lt;br/&gt;输出：6&lt;br/&gt;解释：6个回文子串: &lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;aa&quot;&lt;/span&gt;, &lt;span&gt;&quot;aa&quot;&lt;/span&gt;, &lt;span&gt;&quot;aaa&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;&lt;h4&gt;解法一：暴力法&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; countSubstrings = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;s&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; s.length; i++) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; j = i; j &amp;lt; s.length; j++) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (isPalindrome(s.substring(i, j + &lt;span&gt;1&lt;/span&gt;))) {&lt;br/&gt;        count++&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; count&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; isPalindrome = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;s&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, j = s.length - &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (i &amp;lt; j) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (s[i] != s[j]) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    i++&lt;br/&gt;    j--&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;h4&gt;解法二：动态规划&lt;/h4&gt;&lt;p&gt;一个字符串是回文串，它的首尾字符相同，且剩余子串也是一个回文串。其中，剩余子串是否为回文串，就是规模小一点的子问题，它的结果影响大问题的结果。&lt;/p&gt;&lt;p&gt;我们怎么去描述子问题呢？&lt;/p&gt;&lt;p&gt;显然，一个子串由两端的 &lt;code&gt;i&lt;/code&gt; 、&lt;code&gt;j&lt;/code&gt; 指针确定，就是描述子问题的变量，子串 &lt;code&gt;s[i...j]&lt;/code&gt; （ &lt;code&gt;dp[i][j]&lt;/code&gt; ） 是否是回文串，就是子问题。&lt;/p&gt;&lt;p&gt;我们用二维数组记录计算过的子问题的结果，从base case出发，像填表一样递推出每个子问题的解。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    j&lt;br/&gt;    a  a  b  a&lt;br/&gt;i a ✅&lt;br/&gt;  a    ✅  &lt;br/&gt;  b       ✅&lt;br/&gt;  a          ✅&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意： &lt;code&gt;i&amp;lt;=j&lt;/code&gt; ，只需用半张表，竖向扫描&lt;/p&gt;&lt;p&gt;所以：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;i === j：dp[i][j]=&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;j - i == &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; s[i] == s[j]：dp[i][j] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;j - i &amp;gt; &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; s[i] == s[j] &amp;amp;&amp;amp; dp[i + &lt;span&gt;1&lt;/span&gt;][j - &lt;span&gt;1&lt;/span&gt;]：dp[i][j] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;s[i] == s[j] &amp;amp;&amp;amp; (j - i &amp;lt;= &lt;span&gt;1&lt;/span&gt; || dp[i + &lt;span&gt;1&lt;/span&gt;][j - &lt;span&gt;1&lt;/span&gt;]): dp[i][j]=&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;否则为 &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; countSubstrings = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;s&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; len = s.length&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; dp = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;(len)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; len; i++) {&lt;br/&gt;    dp[i] = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;(len).fill(&lt;span&gt;false&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; len; j++) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt;= j; i++) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (s[i] == s[j] &amp;amp;&amp;amp; (j - i &amp;lt;= &lt;span&gt;1&lt;/span&gt; || dp[i + &lt;span&gt;1&lt;/span&gt;][j - &lt;span&gt;1&lt;/span&gt;])) {&lt;br/&gt;        dp[i][j] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;        count++&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        dp[i][j] = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; count&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;代码实现（优化）：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;把上图的表格竖向一列看作一维数组，还是竖向扫描，此时仅仅需要将 &lt;code&gt;dp&lt;/code&gt; 定义为一维数组即可&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; countSubstrings = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;s&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; len = s.length&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; dp = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;(len)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; len; j++) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt;= j; i++) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (s[i] === s[j] &amp;amp;&amp;amp; (j - i &amp;lt;= &lt;span&gt;1&lt;/span&gt; || dp[i + &lt;span&gt;1&lt;/span&gt;])) {&lt;br/&gt;        dp[i] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;        count++&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        dp[i] = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; count;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.6 最长回文子串&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: &lt;span&gt;&quot;babad&quot;&lt;/span&gt;&lt;br/&gt;输出: &lt;span&gt;&quot;bab&quot;&lt;/span&gt;&lt;br/&gt;注意: &lt;span&gt;&quot;aba&quot;&lt;/span&gt; 也是一个有效答案。&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: &lt;span&gt;&quot;cbbd&quot;&lt;/span&gt;&lt;br/&gt;输出: &lt;span&gt;&quot;bb&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;解法：动态规划&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;第 1 步：定义状态&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;dp[i][j]&lt;/code&gt; 表示子串 &lt;code&gt;s[i..j]&lt;/code&gt; 是否为回文子串，这里子串 &lt;code&gt;s[i..j]&lt;/code&gt; 定义为左闭右闭区间，可以取到 &lt;code&gt;s[i]&lt;/code&gt; 和 &lt;code&gt;s[j]&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第 2 步：思考状态转移方程&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;对于一个子串而言，如果它是回文串，那么在它的首尾增加一个相同字符，它仍然是个回文串&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[i][j] = (s[i] === s[j]) &amp;amp;&amp;amp; dp[i+&lt;span&gt;1&lt;/span&gt;][j&lt;span&gt;-1&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第 3 步：初始状态&lt;/strong&gt;：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[i][i] = &lt;span&gt;true&lt;/span&gt; &lt;span&gt;// 单个字符是回文串&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(s[i] === s[i+&lt;span&gt;1&lt;/span&gt;]) dp[i][i+&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;true&lt;/span&gt; &lt;span&gt;// 连续两个相同字符是回文串 &lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; longestPalindrome = &lt;span&gt;(&lt;span&gt;s&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (s.length &amp;lt; &lt;span&gt;2&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; s&lt;br/&gt;  &lt;span&gt;// res: 最长回文子串&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; res = s[&lt;span&gt;0&lt;/span&gt;], dp = []&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; s.length; i++) {&lt;br/&gt;    dp[i][i] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt; s.length; j++) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; j; i++) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (j - i === &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; s[i] === s[j]) {&lt;br/&gt;        dp[i][j] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (s[i] === s[j] &amp;amp;&amp;amp; dp[i + &lt;span&gt;1&lt;/span&gt;][j - &lt;span&gt;1&lt;/span&gt;]) {&lt;br/&gt;        dp[i][j] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;      }   &lt;br/&gt;      &lt;span&gt;// 获取当前最长回文子串&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (dp[i][j] &amp;amp;&amp;amp; j - i + &lt;span&gt;1&lt;/span&gt; &amp;gt; res.length) {&lt;br/&gt;        res = s.substring(i, j + &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;时间复杂度：O(n^2^)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;空间复杂度：O(n^2^)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.7 最小路径和&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;给定一个包含非负整数的 &lt;code&gt;m x n&lt;/code&gt; 网格 &lt;code&gt;grid&lt;/code&gt; ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。&lt;/p&gt;&lt;p&gt;说明：每次只能向下或者向右移动一步。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgjD5nBiaBYpbXPy8fhkwdKOYfxkKTjcR6mlzWHVKM8aTlfwBbGH9coOLw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;242&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入：grid = [[1,3,1],[1,5,1],[4,2,1]]&lt;br/&gt;输出：7&lt;br/&gt;解释：因为路径 1→3→1→1→1 的总和最小。&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入：grid = [[1,2,3],[4,5,6]]&lt;br/&gt;输出：12&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;m == grid.length&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;n == grid[i].length&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;1 &amp;lt;= m, n &amp;lt;= 200&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;0 &amp;lt;= grid[i][j] &amp;lt;= 100&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;1、DP方程&lt;/strong&gt; 当前项最小路径和 = 当前项值 + 上项或左项中的最小值 &lt;code&gt;grid[i][j] += Math.min( grid[i - 1][j], grid[i][j - 1] )&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、边界处理&lt;/strong&gt; grid的第一行与第一列 分别没有上项与左项 故单独处理计算起项最小路径和 计算第一行：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt; col; j++) grid[&lt;span&gt;0&lt;/span&gt;][j] += grid[&lt;span&gt;0&lt;/span&gt;][j - &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;计算第一列：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; row; i++) grid[i][&lt;span&gt;0&lt;/span&gt;] += grid[i - &lt;span&gt;1&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;3、代码实现&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; minPathSum = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;grid&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; row = grid.length, col = grid[&lt;span&gt;0&lt;/span&gt;].length&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// calc boundary&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; row; i++)&lt;br/&gt;        &lt;span&gt;// calc first col&lt;/span&gt;&lt;br/&gt;        grid[i][&lt;span&gt;0&lt;/span&gt;] += grid[i - &lt;span&gt;1&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt; col; j++)&lt;br/&gt;        &lt;span&gt;// calc first row&lt;/span&gt;&lt;br/&gt;        grid[&lt;span&gt;0&lt;/span&gt;][j] += grid[&lt;span&gt;0&lt;/span&gt;][j - &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; row; i++)&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt; col; j++)&lt;br/&gt;            grid[i][j] += &lt;span&gt;Math&lt;/span&gt;.min(grid[i - &lt;span&gt;1&lt;/span&gt;][j], grid[i][j - &lt;span&gt;1&lt;/span&gt;])&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; grid[row - &lt;span&gt;1&lt;/span&gt;][col - &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.8 买卖股票的最佳时机 II&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。&lt;/p&gt;&lt;p&gt;设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;]&lt;br/&gt;输出: &lt;span&gt;7&lt;/span&gt;&lt;br/&gt;解释: 在第 &lt;span&gt;2&lt;/span&gt; 天（股票价格 = &lt;span&gt;1&lt;/span&gt;）的时候买入，在第 &lt;span&gt;3&lt;/span&gt; 天（股票价格 = &lt;span&gt;5&lt;/span&gt;）的时候卖出, 这笔交易所能获得利润 = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt; = &lt;span&gt;4&lt;/span&gt; 。&lt;br/&gt;     随后，在第 &lt;span&gt;4&lt;/span&gt; 天（股票价格 = &lt;span&gt;3&lt;/span&gt;）的时候买入，在第 &lt;span&gt;5&lt;/span&gt; 天（股票价格 = &lt;span&gt;6&lt;/span&gt;）的时候卖出, 这笔交易所能获得利润 = &lt;span&gt;6&lt;/span&gt;&lt;span&gt;-3&lt;/span&gt; = &lt;span&gt;3&lt;/span&gt; 。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;]&lt;br/&gt;输出: &lt;span&gt;4&lt;/span&gt;&lt;br/&gt;解释: 在第 &lt;span&gt;1&lt;/span&gt; 天（股票价格 = &lt;span&gt;1&lt;/span&gt;）的时候买入，在第 &lt;span&gt;5&lt;/span&gt; 天 （股票价格 = &lt;span&gt;5&lt;/span&gt;）的时候卖出, 这笔交易所能获得利润 = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt; = &lt;span&gt;4&lt;/span&gt; 。&lt;br/&gt;     注意你不能在第 &lt;span&gt;1&lt;/span&gt; 天和第 &lt;span&gt;2&lt;/span&gt; 天接连购买股票，之后再将它们卖出。&lt;br/&gt;     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;输出: &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;解释: 在这种情况下, 没有交易完成, 所以最大利润为 &lt;span&gt;0&lt;/span&gt;。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;1 &amp;lt;= prices.length &amp;lt;= 3 * 10 ^ 4&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;0 &amp;lt;= prices[i] &amp;lt;= 10 ^ 4&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;解法一：峰底买入，峰顶卖出&lt;/h4&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6175&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgjP7RDxmGAicjUsWiaxTshwHfmGlpZAxf6FXF3yry4MOIdmibzibDZfa5hVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如图，在第二天买入，第三天卖出，第四天买入，第五天卖出获利最高，此处代码不再赘述，可以自己尝试写一下&lt;/p&gt;&lt;h4&gt;解法二：贪心算法&lt;/h4&gt;&lt;p&gt;贪心算法，故名思义，总是做出当前的最优选择，即期望通过局部的最优选择获得整体的最优选择。&lt;/p&gt;&lt;p&gt;某种意义上说，贪心算法是很贪婪、很目光短浅的，它不从整体考虑，仅仅只关注当前的最大利益，所以说它做出的选择仅仅是某种意义上的局部最优，但是贪心算法在很多问题上还是能够拿到最优解或较优解，所以它的存在还是有意义的。&lt;/p&gt;&lt;p&gt;对应于该题，第一天买入，第二天卖出，…，第 &lt;code&gt;i&lt;/code&gt; 天买入，第 &lt;code&gt;i+1&lt;/code&gt; 天卖出，如果 &lt;code&gt;i&lt;/code&gt; 天买入第 &lt;code&gt;i+1&lt;/code&gt; 天卖出有利润则买入，否则不买&lt;/p&gt;&lt;p&gt;第 &lt;code&gt;i-1&lt;/code&gt; 天买入第 &lt;code&gt;i&lt;/code&gt; 天卖出获利 &lt;code&gt;prices[i+1]-prices[i]&lt;/code&gt; ，我们仅仅需要将 &lt;code&gt;prices[i+1]-prices[i]&lt;/code&gt; 的所有正值加起来就是可获取的最大利益&lt;/p&gt;&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; maxProfit = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;prices&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; profit = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; prices.length - &lt;span&gt;1&lt;/span&gt;; i++) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (prices[i + &lt;span&gt;1&lt;/span&gt;] &amp;gt; prices[i]) {&lt;br/&gt;            profit += prices[i + &lt;span&gt;1&lt;/span&gt;] - prices[i]&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; profit&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.9 分发饼干&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 g~i~ ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 s~j~。如果 s~j~ &amp;gt;= g~i~ ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;你可以假设胃口值为正。一个小朋友最多只能拥有一块饼干。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [1,2,3], [1,1]&lt;br/&gt;&lt;br/&gt;输出: 1&lt;br/&gt;&lt;br/&gt;解释: &lt;br/&gt;你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。&lt;br/&gt;虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。&lt;br/&gt;所以你应该输出1。&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [1,2], [1,2,3]&lt;br/&gt;&lt;br/&gt;输出: 2&lt;br/&gt;&lt;br/&gt;解释: &lt;br/&gt;你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。&lt;br/&gt;你拥有的饼干数量和尺寸都足以让所有孩子满足。&lt;br/&gt;所以你应该输出2.&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;解法：贪心算法&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; findContentChildren = &lt;span&gt;(&lt;span&gt;g, s&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!g.length || !s.length) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;    &lt;br/&gt;    g.sort(&lt;span&gt;(&lt;span&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; a - b)&lt;br/&gt;    s.sort(&lt;span&gt;(&lt;span&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; a - b)&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; gi = &lt;span&gt;0&lt;/span&gt;, si = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (gi &amp;lt; g.length &amp;amp;&amp;amp; si &amp;lt; s.length) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (g[gi] &amp;lt;= s[si++]) gi++&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; gi&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.10 分割数组为连续子序列&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;给你一个按升序排序的整数数组 &lt;code&gt;num&lt;/code&gt;（可能包含重复数字），请你将它们分割成一个或多个子序列，其中每个子序列都由连续整数组成且长度至少为 3 。&lt;/p&gt;&lt;p&gt;如果可以完成上述分割，则返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [1,2,3,3,4,5]&lt;br/&gt;输出: True&lt;br/&gt;解释:&lt;br/&gt;你可以分割出这样两个连续子序列 : &lt;br/&gt;1, 2, 3&lt;br/&gt;3, 4, 5&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [1,2,3,3,4,4,5,5]&lt;br/&gt;输出: True&lt;br/&gt;解释:&lt;br/&gt;你可以分割出这样两个连续子序列 : &lt;br/&gt;1, 2, 3, 4, 5&lt;br/&gt;3, 4, 5&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [1,2,3,4,4,5]&lt;br/&gt;输出: False&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;&lt;h4&gt;解法：贪心算法&lt;/h4&gt;&lt;p&gt;从头开始，我们每次仅仅寻找满足条件的序列（连续子序列长度为3），剔除之后，依次往后遍历：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;判断当前元素是否能够拼接到前一个满足条件的连续子序列上，可以的话，则拼接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果不可以，则判断以当前元素开始能否构成连续子序列（长度为3），可以的话，则剔除连续子序列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;否则，返回 false&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; isPossible = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;nums&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; max = nums[nums.length - &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;    &lt;span&gt;// arr：存储原数组中数字每个数字出现的次数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// tail：存储以数字num结尾的且符合题意的连续子序列个数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; arr = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;(max + &lt;span&gt;2&lt;/span&gt;).fill(&lt;span&gt;0&lt;/span&gt;), &lt;br/&gt;        tail = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;(max + &lt;span&gt;2&lt;/span&gt;).fill(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; num &lt;span&gt;of&lt;/span&gt; nums) {&lt;br/&gt;        arr[num] ++&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; num &lt;span&gt;of&lt;/span&gt; nums) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(arr[num] === &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(tail[num&lt;span&gt;-1&lt;/span&gt;] &amp;gt; &lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;            tail[num&lt;span&gt;-1&lt;/span&gt;]--&lt;br/&gt;            tail[num]++&lt;br/&gt;        }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(arr[num+&lt;span&gt;1&lt;/span&gt;] &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; arr[num+&lt;span&gt;2&lt;/span&gt;] &amp;gt; &lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;            arr[num+&lt;span&gt;1&lt;/span&gt;]--&lt;br/&gt;            arr[num+&lt;span&gt;2&lt;/span&gt;]--&lt;br/&gt;            tail[num+&lt;span&gt;2&lt;/span&gt;]++&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        arr[num]--&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.11 全排列问题&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;给定一个 &lt;strong&gt;没有重复&lt;/strong&gt; 数字的序列，返回其所有可能的全排列。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;]&lt;br/&gt;输出:&lt;br/&gt;[&lt;br/&gt;  [&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;解法：回溯算法&lt;/h4&gt;&lt;p&gt;本题是回溯算法的经典应用场景&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1. 算法策略&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;回溯算法是一种搜索法，试探法，它会在每一步做出选择，一旦发现这个选择无法得到期望结果，就回溯回去，重新做出选择。深度优先搜索利用的就是回溯算法思想。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2. 适用场景&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;回溯算法很简单，它就是不断的尝试，直到拿到解。它的这种算法思想，使它通常用于解决广度的搜索问题，即从一组可能的解中，选择一个满足要求的解。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3. 代码实现&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们可以写一下，数组 [1, 2, 3] 的全排列有：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;先写以 1 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]，即 1 + [2, 3] 的全排列；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再写以 2 开头的全排列，它们是：[2, 1, 3], [2, 3, 1]，即 2 + [1, 3] 的全排列；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后写以 3 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]，即 3 + [1, 2] 的全排列。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;即回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。&lt;/p&gt;&lt;p&gt;这显然是一个 &lt;strong&gt;递归&lt;/strong&gt; 结构；&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;递归的终止条件是：一个排列中的数字已经选够了 ，因此我们需要一个变量来表示当前程序递归到第几层，我们把这个变量叫做 &lt;code&gt;depth&lt;/code&gt; ，或者命名为 &lt;code&gt;index&lt;/code&gt; ，表示当前要确定的是某个全排列中下标为 &lt;code&gt;index&lt;/code&gt; 的那个数是多少；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;used（object）：用于把表示一个数是否被选中，如果这个数字(num)被选择这设置为 &lt;code&gt;used[num] = true&lt;/code&gt; ，这样在考虑下一个位置的时候，就能够以 O(1)的时间复杂度判断这个数是否被选择过，这是一种「以空间换时间」的思想。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; permute = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;nums&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 使用一个数组保存所有可能的全排列&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; res = []&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (nums.length === &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; used = {}, path = []&lt;br/&gt;    dfs(nums, nums.length, &lt;span&gt;0&lt;/span&gt;, path, used, res)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; dfs = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;nums, len, depth, path, used, res&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 所有数都填完了&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (depth === len) {&lt;br/&gt;        res.push([...path])&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; len; i++) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!used[i]) {&lt;br/&gt;            &lt;span&gt;// 动态维护数组&lt;/span&gt;&lt;br/&gt;            path.push(nums[i])&lt;br/&gt;            used[i] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// 继续递归填下一个数&lt;/span&gt;&lt;br/&gt;            dfs(nums, len, depth + &lt;span&gt;1&lt;/span&gt;, path, used, res)&lt;br/&gt;            &lt;span&gt;// 撤销操作&lt;/span&gt;&lt;br/&gt;            used[i] = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;            path.pop()&lt;br/&gt;        }&lt;br/&gt;      &lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;4. 复杂度分析&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;时间复杂度：O(n∗n!)，其中 n 为序列的长度&lt;/p&gt;&lt;p&gt;这是一个排列组合，每层的排列组合数为：A^m^ ~n~=n!/(n−m)! ，故而所有的排列有 ：&lt;/p&gt;&lt;p&gt;A^1^ ~n~ + A^2^ ~n~ + … + A^n-1^ ~n~ = n!/(n−1)! + n!/(n−2)! + … + n! = n! * (1/(n−1)! + 1/(n−2)! + … + 1) &amp;lt;= n! * (1 + 1/2 + 1/4 + … + 1/2^n-1^) &amp;lt; 2 * n!&lt;/p&gt;&lt;p&gt;并且每个内部结点循环 n 次，故非叶子结点的时间复杂度为 O(n∗n!)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;空间复杂度：O(n)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.12 括号生成&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;数字 &lt;code&gt;n&lt;/code&gt; 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 &lt;strong&gt;有效的&lt;/strong&gt; 括号组合。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入：n = &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;输出：[&lt;br/&gt;       &lt;span&gt;&quot;((()))&quot;&lt;/span&gt;,&lt;br/&gt;       &lt;span&gt;&quot;(()())&quot;&lt;/span&gt;,&lt;br/&gt;       &lt;span&gt;&quot;(())()&quot;&lt;/span&gt;,&lt;br/&gt;       &lt;span&gt;&quot;()(())&quot;&lt;/span&gt;,&lt;br/&gt;       &lt;span&gt;&quot;()()()&quot;&lt;/span&gt;&lt;br/&gt;     ]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;解答：回溯算法（深度优先遍历）&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;算法策略：&lt;/strong&gt; 回溯算法是一种搜索法，试探法，它会在每一步做出选择，一旦发现这个选择无法得到期望结果，就回溯回去，重新做出选择。深度优先搜索利用的就是回溯算法思想。&lt;/p&gt;&lt;p&gt;对应于本题，我们可以每次试探增加 &lt;code&gt;(&lt;/code&gt; 或 &lt;code&gt;)&lt;/code&gt; ，注意：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;加入 &lt;code&gt;(&lt;/code&gt; 的条件是，当前是否还有 &lt;code&gt;(&lt;/code&gt; 可以选择&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加入 &lt;code&gt;)&lt;/code&gt; 的时候，受到 &lt;code&gt;(&lt;/code&gt; 的限制，如果已选择的结果里的 &lt;code&gt;(&lt;/code&gt; 小于等于已选择里的 &lt;code&gt;)&lt;/code&gt; 时，此时是不能选择 &lt;code&gt;)&lt;/code&gt; 的，例如如果当前是 &lt;code&gt;()&lt;/code&gt; ，继续选择 &lt;code&gt;)&lt;/code&gt; 就是 &lt;code&gt;())&lt;/code&gt; ，是不合法的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; generateParenthesis = &lt;span&gt;(&lt;span&gt;n&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; res = []&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; dfs = &lt;span&gt;(&lt;span&gt;path, left, right&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 肯定不合法，提前结束&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (left &amp;gt; n || left &amp;lt; right) &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 到达结束条件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (left + right === &lt;span&gt;2&lt;/span&gt; * n) {&lt;br/&gt;            res.push(path)&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 选择&lt;/span&gt;&lt;br/&gt;        dfs(path + &lt;span&gt;&#x27;(&#x27;&lt;/span&gt;, left + &lt;span&gt;1&lt;/span&gt;, right)&lt;br/&gt;        dfs(path + &lt;span&gt;&#x27;)&#x27;&lt;/span&gt;, left, right + &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;    dfs(&lt;span&gt;&#x27;&#x27;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析（来源leetcode官方题解）：&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.24057217165149544&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgj2ZzfgK706a8fGSYEL3egXoHlb82mKFreHYTckX7IeAnlJsP76438sA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1538&quot;/&gt;&lt;/figure&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最近开源&lt;/span&gt;&lt;span&gt;了一个github仓库：&lt;/span&gt;&lt;span&gt;百问百答，在工作中很难做到对社群问题进行立即解答，所以可以将问题提交至 https://github.com/Advanced-Frontend/Just-Now-QA ，我会在每晚花费 1 个小时左右进行处理，更多的是鼓励与欢迎更多人一起参与探讨与解答🌹&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading-13&quot;&gt;最后&lt;/h2&gt;&lt;section&gt;&lt;span&gt;欢迎关注「&lt;/span&gt;&lt;span&gt;三分钟学前端&lt;/span&gt;&lt;span&gt;」，回复「&lt;/span&gt;&lt;span&gt;交流&lt;/span&gt;&lt;span&gt;」自动加入&lt;/span&gt;&lt;span&gt;前端三分钟进阶群，每日一道编程算法面试题（含解答），助力你成为更优秀的前端开发！&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg2NjUxOTM2Mg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKmTRcFWKB5pLtwz9auwyvjn6nhiaSydyGVuAfOfGmdpTBaqLJyLHVwDgXKNicS1VHhJSBADHCk2dib4Q/0?wx_fmt=png&quot; data-nickname=&quot;三分钟学前端&quot; data-alias=&quot;&quot; data-signature=&quot;每日三分钟，学习一个前端小 Tip！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;号内回复：&lt;/p&gt;&lt;section&gt;「&lt;strong&gt;网络&lt;/strong&gt;」，自动获取三分钟学前端网络篇小书（90+页）&lt;/section&gt;&lt;section&gt;「&lt;strong&gt;JS&lt;/strong&gt;」，自动获取三分钟学前端 JS 篇小书（120+页）&lt;/section&gt;&lt;section&gt;「&lt;strong&gt;算法&lt;/strong&gt;」，自动获取 github 2.9k+ 的前端算法小书&lt;/section&gt;&lt;section&gt;「&lt;strong&gt;面试&lt;/strong&gt;」，自动获取 github 23.2k+ 的前端面试小书&lt;/section&gt;&lt;section&gt;「&lt;strong&gt;简历&lt;/strong&gt;」，自动获取程序员系列的 &lt;code&gt;120&lt;/code&gt; 套模版&lt;/section&gt;&lt;section&gt;&lt;a class=&quot;weapp_text_link js_weapp_entry&quot; data-miniprogram-appid=&quot;wx27c980b913cbfb08&quot; data-miniprogram-path=&quot;pages/index/index&quot; data-miniprogram-nickname=&quot;高级前端面试&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-servicetype=&quot;0&quot; href=&quot;&quot;&gt;》》面试官也在看的前端面试资料《《&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;“在看和转发”&lt;/span&gt;&lt;span&gt;就是最大的&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a58359a40bbe89e732dfab34be6a05c2</guid>
<title>[推荐] 近期做的稳定性建设总结</title>
<link>https://toutiao.io/k/ic0wg6u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;背景&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;近期业界频繁出现较大的稳定性事故，引发社会舆情。湖北十堰也发生了安全的大事故。海因里希法则告诉我们：一件重大事故的背后总是有29件轻微事故+300件潜在隐患。我们要把这些事件当做镜子做好自身的稳定性建设。&lt;/section&gt;&lt;section&gt;我们的项目目前平稳运行，架构设计上也能满足现阶段的需求。所以近期做的稳定性建设并非轰轰烈烈的大事件，却对未来的长远稳定性至关重要。如果一个工程或者项目需要做大手术了，甚至派上了公司级的专家一起来建设，那直接说明之前做的太烂了，遇到了大问题，估计要走马换将了。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;很多朋友听到这里就会很无奈，在上一篇&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485721&amp;amp;idx=1&amp;amp;sn=8cac3b1db8338b9f0ba4e50db65945ce&amp;amp;chksm=fafde3b7cd8a6aa1805193fc1b2115285ad1c5362dcaa4097fc11de4947e2e37d4449e2d9602&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《社招面试的架构分析》&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《社招面试的架构分析》&lt;/a&gt;里，我也提到社招面试中很大一部分比重是要介绍自己实际做的项目业绩。做这些小事能有业绩吗？以后有什么值得说的吗？我的回答是：太有了。&lt;/section&gt;&lt;section&gt;&lt;img data-backh=&quot;210&quot; data-backw=&quot;509&quot; data-ratio=&quot;0.4125560538116592&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicnnsx1NRszaH7tOYc9e8rLjmC7iccpGjLMvGQ14R30a2DWg1UbjdibWrviakwU0PjOBpNic6NHhRibyNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;/section&gt;&lt;section&gt;一个好的项目从功能演进方面大体经历：支撑业务、快速支撑业务、引领业务三个阶段。从稳定性建设来说，大体经历从0-1的基本稳定阶段和1到无限的稳定性加固阶段。“稳定性是第一性”，一旦稳定性出现问题，我们的功能演进就会回退到疲于奔命的支撑业务阶段。由于本篇文章功能演进不是重心，所以只告诉大家可以在面试中这么跟面试官讲：&lt;br/&gt;&lt;/section&gt;&lt;section&gt;我们的项目稳定性不错，日交易量十几个亿的情况下，SLA5个9以上。假设我们的系统连续5分钟系统成功率低于50%，就需要上报科技司、国务院了，所以我们有严格的事故定级标准，从最高的s0到最低的s9。s9定级要求影响总交易在5笔以下。实际上我在任的三年没有出过s9及以上的事故。(这里只是举个例子，大家还是要照自己的实际情况描述，要点是我们的系统很重要，对稳定性要求很高，这个场景下还做的不错。做的都是交易量不大的项目也不用担心，面试官关心的是从表述中体现出来的：格局、站位、层面和视野)&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总体思路&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;1、独立出运维工程，将保障逻辑和业务逻辑分离，保障逻辑频繁迭代更新不影响业务逻辑稳定性&lt;/p&gt;&lt;p&gt;2、制定日志规范，新增集中采集日志，并据此新增监控告警，比外部先发现问题，并可以方便的进行问题排查和统计&lt;/p&gt;&lt;p&gt;3、规范和梳理现有监控告警，查缺补漏，合理设定告警阈值和级别，提高告警敏感度&lt;/p&gt;&lt;p&gt;4、告警治理，现有隐患各个击破，将平时告警数降为0&lt;/p&gt;&lt;p&gt;5、合理根据业务增长情况进行扩容&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;细节FAQ&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;这里举几个在方案评审时被问到的问题和回复以及具体实施过程中遇到问题的排查的解决思路用问答的形式表述如下：&lt;br/&gt;&lt;/section&gt;&lt;p&gt;Q1：在日志规范中规定在请求的开始和结束都需要打印日志，结束日志的内容包含了开始日志的内容，打印开始日志的意义是什么？&lt;/p&gt;&lt;p&gt;A：快速排查定位问题的需要&lt;/p&gt;&lt;section&gt;在需要对问题进行排查定位的场景，可以快速清晰的看到整个请求的过程。包括什么时间点接收到请求、什么时间点处理请求。&lt;/section&gt;&lt;section&gt;针对这个问题同学发起了连环问，问我结束时间-cost不就是开始时间吗？&lt;br/&gt;&lt;/section&gt;&lt;section&gt;是的，但是在实际排查问题的场景，需要尽量减少人工转换，快速定位，牺牲一点存储降低排查难度是值得的。同时，针对处理中间出现了问题，没有达到请求结束的场景，也可以定位到出现问题的环节。&lt;/section&gt;&lt;section&gt;连环问继续：如果是请求没有达到结束，直接try catch finally来处理，或者是通过请求成功率就可以定位了呀？&lt;br/&gt;&lt;/section&gt;&lt;section&gt;我们的try catch建议是catch exception，但是实际情况中有可能发生error级别的异常，这时候未必可以走到finally。我们没有必要在所有的场景都加上try catch还是要根据实际需要。如果请求出现成功率下降，那么影响的不是一笔交易，在需要针对具体一笔进行排查的时候，我们怎么知道请求成功率影响的是哪一笔呢？当然，通过复杂的排查和计算是可以最终实现定位的，但是我们要快速定位，尽量减少对开发人员的技术要求。同时，从容灾容错上考虑，我们需要对监控机制进行容灾，万一一个监控机制发生了问题，也可以最终定位到问题。这就是为什么系统有zabbix监控、&lt;span&gt;Prometheus监控等多项监控共存，指标上和角度上有区别也有重复，区别是为了根据具体场景快速定位，重复是为了容灾一个监控组件出现了问题也能定位。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Q2：收到一个可用内存不足10%的告警，经过了两个小时才自动恢复到87%，所在的机器出现一笔请求超时&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;A：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现象&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1&amp;gt;对业务进行了解发现开始出现问题的时间点，有收到外部MQ发过来的大报文，虽然报文做了分片但是每个分片还是有几M大并且下发条数多，集中下发。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2&amp;gt;分别在问题机器和其他相同应用的不同机器上执行top命令，观察到问题机器和其他机器上jvm内存占用差不多并且稳定。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3&amp;gt;执行free -h命令观察到cache/buffer下降到1G以下，内存使用率的计算规则是(1-available)/total。available虽然大家都说是大体上等于free+buffer/cache。因为buffe/cache可以快速被释放。但是实际上当cache/buffer下降到一定数值，available的值远远小于&lt;span&gt;free&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;buffer&lt;/span&gt;&lt;span&gt;/cach&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;。本次问题发生的时间点，机器可用内存7.6G，&lt;span&gt;free&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;buffer&lt;/span&gt;&lt;span&gt;/cach&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;下降了200M，但是available却下降了500M多。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4&amp;gt;&lt;span&gt;收到外部MQ发过来的大报文&lt;/span&gt;时间段网卡占用情况从平时0.5M以下飙升到20M TPS&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;5&amp;gt;&lt;span&gt;出现一笔请求超&lt;/span&gt;&lt;span&gt;时正在下发大报文的高峰期，请求方发请求到机器接收到请求时间间隔是几毫秒。收到请求后机器会将请求转发给MQ，用了3秒多。而请求方设置了5秒超时。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;6&amp;gt;所有环节cpu使用率都很低&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;7&amp;gt;20天前在另外一台机器上也发生了内存升高到90%以上的现象&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;分析&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;此问题的根本原因是外部短时间内下发大量大报文(受节假日影响当天的报文略高于其他天)，从根本上治理需要和外部(大佬级别，我们完全没有主动权)一起进行架构方面的调整，不现实也没有必要用此牛刀。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;表现为虚机层面内存资源不足，影响了IO速率。因为高峰IO TPS20M，针对现在的千兆网卡、万兆网卡来说，并不大。问题并不在网络通道上，而在机器本身。而IO需要大量内存：内核态和用户态之间数据传输等环节的数据拷贝。研究过NIO、netty、linux内核等技术的应该都知道：IO无非就是分配内存、操作fd文件描述符和调用中断等命令的过程。因为现象中可以看到&lt;span&gt;jvm&lt;/span&gt;&lt;span&gt;内存&lt;/span&gt;&lt;span&gt;是没有问题的&lt;/span&gt;，这里的瓶颈就在系统内存不足上。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以短期我们制定SOP/EOP，应对临时问题。中期提申请进行纵向扩容。纵向扩容说白了就是增加物理内存。有人就要问了是不是扩机器数量也能解决问题。这种处理方式大概是能治病但是不一定对症。意思可以理解为吃广谱抗菌药来治疗感冒，有一定帮助但不是针对性的处理。因为扩机器是减少了请求数从而减少了内存占用量。但是万一有个大请求就是把内存飚高了呢？linux的设计如果内存高到一定程度自身的很多功能会受到影响，导致不符合预期。需要从根本上升高内存。并且扩内存实施成本更低，不需要程序的发布。就是低峰期暂停程序，插个内存条。当然，长期上业务量在上涨，但是我们还没有进行水平扩容。需要我们计算业务增长量进行合理扩机器。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有的朋友会觉得这个处理方式并不高大上。牛逼的处理方式是调整个linux参数啥的。现在也算比较流行的一个词叫做：不可变服务器。&lt;span&gt;“传统”的部署方式中，对系统的改动都会呈现在服务器上，从而增加了风险。&lt;/span&gt;&lt;span&gt;采用不可变部署方式，&lt;/span&gt;服务器都是公司统一标准化的，那么变更只要考虑应用程序的发布，而应用程序一旦发布也不允许改变，就成了不可变服务。不可变性可以增加系统的稳定性。在一个规模比较大的公司，就算可以通过技术解决资源的问题，从整体角度，还是通用方案更加可取。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Q3：有个MQ服务偶尔会在并发量高的情况下有响应耗时高的问题，这个MQ是闭源的收费服务。怀疑是内部实现用的是短连接造成的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;A：排查人员review代码发现每次发送消息都调用了close方法，怀疑是短连接造成的。首先来说close方法有没有直接把连接关闭不能从名称上来判断，还是需要看实现。比如连接池方式的close实现实际上是把连接归还了连接池。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以使用netstat命令观察连接的状态，如果状态一直是established，应该是长连接。具体建立了几个长连接就看对应的&lt;span&gt;establish&lt;/span&gt;&lt;span&gt;ed&lt;/span&gt;的数量。具体原理就是常见的一个面试考题了：TCP三次握手：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6014418125643667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicBQKq12r4ibHKbDaRFmvNFSAQuhJKibWW5XtIQuqECVa8ZOSGokiarl0e0LUXsbVb0BUm0HR4atE1nw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;971&quot;/&gt;&lt;/p&gt;&lt;p&gt;TCP四次挥手：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6495238095238095&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicBQKq12r4ibHKbDaRFmvNFSrwEuqibuaZJZmwx2Jcm4yia3mHHtuib3BEhKic4ZI5YFDibvzb0lyFOmMOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;525&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;看netstat的状态就可以了解处于TCP的哪个阶段了。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;相关阅读&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c972bb51558761f732292c0d3715a45a</guid>
<title>[推荐] 进程和线程这 19 个问题太强了</title>
<link>https://toutiao.io/k/93vqd5f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由于各个进程不共享相同的地址空间，任何一个进程的全局变量在另一个进程中都不可见，所以如果想要在进程之间传递数据就需要通过内核，在内核中开辟出一块区域，该区域对多个进程都可见，即可用于进程间通信。有读者可能有疑问了，文件方式也是进程间通信啊，也要在内核开辟区域吗？这里说的内核区域其实是一段缓冲区，文件方式传输数据也有内核缓冲区的参与（零拷贝除外）。&lt;/p&gt;&lt;section&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;524&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;367&quot; data-ratio=&quot;0.672093023255814&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9lFFFiaKpEr8Pnej5HSUaPCia1zguc4KbhpwgTSdVNZzic70zs5zOicoscMB7QxxSOlAtZriaNDWjOxSiafxSS2gJ9kw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;430&quot;/&gt;&lt;/section&gt;&lt;p&gt;如何开辟这种公共区域来进行进程间通信呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;匿名管道&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;匿名管道就是&lt;strong&gt;&lt;span&gt;pipe&lt;/span&gt;&lt;/strong&gt;，pipe只能在父子进程间通信，而且数据只能&lt;span&gt;&lt;strong&gt;&lt;span&gt;单向流动&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;（半双工通信）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用方式&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1）父进程创建管道，会得到两个文件描述符，分别指向管道的两端；&lt;/p&gt;&lt;section&gt;2）父进程创建子进程，从而子进程也有两个文件描述符指向同一管道；&lt;/section&gt;&lt;p&gt;3）父进程可写数据到管道，子进程就可从管道中读出数据，从而实现进程间通信，下面的示例代码中通过pipe实现了每秒钟父进程向子进程都发送消息的功能。&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; _pipe[&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; ret = pipe(_pipe);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (ret &amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        perror(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;pipe\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;pid_t&lt;/span&gt; id = fork();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (id &amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        perror(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;fork\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (id == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        close(_pipe[&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;]);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt; _mesg[&lt;span class=&quot;code-snippet__number&quot;&gt;100&lt;/span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (j &amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;100&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;memset&lt;/span&gt;(_mesg, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;\0&#x27;&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;sizeof&lt;/span&gt;(_mesg));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            read(_pipe[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;], _mesg, &lt;span class=&quot;code-snippet__keyword&quot;&gt;sizeof&lt;/span&gt;(_mesg));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;%s\n&quot;&lt;/span&gt;, _mesg);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            j++;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        close(_pipe[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;]);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt; *mesg = &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (i &amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;100&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mesg = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;父进程来写消息了&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            write(_pipe[&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;], mesg, &lt;span class=&quot;code-snippet__built_in&quot;&gt;strlen&lt;/span&gt;(mesg) + &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            ++i;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-theme=&quot;default&quot; data-language=&quot;javascript&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;我们平时也经常使用关于管道的命令行：&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ls | less&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;该命令行的流向图如下：&lt;br/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;524&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;266&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9lFFFiaKpEr8Pnej5HSUaPCia1zguc4KbhYxKQXoK9p50n8B2haIEPrLxTfvHVbc4MBApdfddOHF6HKCicxPq5QLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.3908701854493581&quot; data-w=&quot;701&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;1：创建管道&lt;/p&gt;&lt;p&gt;2：为ls创建一个进程，设置stdout为管理写端&lt;/p&gt;&lt;p&gt;3：为less创建一个进程，设置stdin为管道读端&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;高级管道&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过&lt;span&gt;&lt;strong&gt;&lt;span&gt;popen&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;将另一个程序当作一个新的进程在当前进程中启动，它算作当前进程的子进程，高级管道只能用在有亲缘关系的进程间通信，这种亲缘关系通常指父子进程，下面的GetCmdResult函数可以获取某个Linux命令执行的结果，实现方式就是通过popen。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;GetCmdResult&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt; &amp;amp;cmd, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; max_size = &lt;span class=&quot;code-snippet__number&quot;&gt;10240&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt; *data = (&lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt; *)&lt;span class=&quot;code-snippet__built_in&quot;&gt;malloc&lt;/span&gt;(max_size);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (data == &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;malloc fail&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;memset&lt;/span&gt;(data, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, max_size);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; max_buffer = &lt;span class=&quot;code-snippet__number&quot;&gt;256&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt; buffer[max_buffer];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    FILE *fdp = popen((cmd + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot; 2&amp;gt;&amp;amp;1&quot;&lt;/span&gt;).c_str(), &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;r&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; data_len = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (fdp) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (!feof(fdp)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (fgets(buffer, max_buffer, fdp)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; len = &lt;span class=&quot;code-snippet__built_in&quot;&gt;strlen&lt;/span&gt;(buffer);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (data_len + len &amp;gt; max_size) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;data size larger than &quot;&lt;/span&gt; &amp;lt;&amp;lt; max_size;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__built_in&quot;&gt;memcpy&lt;/span&gt;(data + data_len, buffer, len);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                data_len += len;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        pclose(fdp);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(data, data_len)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;free&lt;/span&gt;(data);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; ret;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-theme=&quot;default&quot; data-language=&quot;javascript&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;命名管道&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;匿名管道有个缺点就是通信的进程一定要有亲缘关系，而命名管道就不需要这种限制。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;命名管道其实就是一种特殊类型的文件，所谓的命名其实就是文件名，文件对各个进程都可见，通过命名管道创建好特殊文件后，就可以实现进程间通信。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;可以通过mkfifo创建一个特殊的类型的文件，参数读者看名字应该就了解，一个是文件名，一个是文件的读写权限：&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;mkfifo&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt;* filename, &lt;span class=&quot;code-snippet__keyword&quot;&gt;mode_t&lt;/span&gt; mode)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-theme=&quot;default&quot; data-language=&quot;javascript&quot;&gt;当返回值为0时，表示该命名管道创建成功，至于如何通信，其实就是个读写文件的问题！&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;消息队列&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;队列想必大家都知道，像FIFO一样，这里可以有多个进程写入数据，也可以有多个进程从队列里读出数据，但消息队列有一点比FIFO还更高级，它读消息不一定要使用先进先出的顺序，每个消息可以赋予类型，可以按消息的类型读取，不是指定类型的数据还存在队列中。本质上MessageQueue是存放在内核中的消息链表，每个消息队列链表会由消息队列标识符表示，这个消息队列存于内核中，只有主动的删除该消息队列或者内核重启时，消息队列才会被删除。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;在Linux中消息队列相关的函数调用如下：&lt;br/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;msgget&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;key_t&lt;/span&gt;, key, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; msgflg)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;msgsend&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; msgid, &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; *msg_ptr, &lt;span class=&quot;code-snippet__keyword&quot;&gt;size_t&lt;/span&gt; msg_sz, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; msgflg)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; message_type;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;msgrcv&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; msgid, &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; *msg_ptr, &lt;span class=&quot;code-snippet__keyword&quot;&gt;size_t&lt;/span&gt; msg_st, &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; msgtype, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; msgflg)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;msgctl&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; msgid, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; command, struct msgid_ds *buf)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-theme=&quot;default&quot; data-language=&quot;javascript&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;示例代码如下：&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;sys/msg.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;chrono&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;thread&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;define&lt;/span&gt; BUFFER_SIZ 20&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; msg_type;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt; text[BUFFER_SIZ];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} MsgWrapper;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Receive&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    MsgWrapper data;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; msgtype = &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; msgid = msgget((&lt;span class=&quot;code-snippet__keyword&quot;&gt;key_t&lt;/span&gt;)&lt;span class=&quot;code-snippet__number&quot;&gt;1024&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0666&lt;/span&gt; | IPC_CREAT);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (msgid == &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;msgget error \n&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (msgrcv(msgid, (&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; *)&amp;amp;data, BUFFER_SIZ, msgtype, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) == &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;error &quot;&lt;/span&gt; &amp;lt;&amp;lt; errno &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;read data &quot;&lt;/span&gt; &amp;lt;&amp;lt; data.text &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__built_in&quot;&gt;strlen&lt;/span&gt;(data.text) &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;6&lt;/span&gt;) {  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (msgctl(msgid, IPC_RMID, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) == &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;msgctl error \n&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Receive ok \n&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Send&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    MsgWrapper data;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; msgtype = &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; msgid = msgget((&lt;span class=&quot;code-snippet__keyword&quot;&gt;key_t&lt;/span&gt;)&lt;span class=&quot;code-snippet__number&quot;&gt;1024&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0666&lt;/span&gt; | IPC_CREAT);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (msgid == &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;msgget error \n&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    data.msg_type = msgtype;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;; ++i) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;memset&lt;/span&gt;(data.text, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, BUFFER_SIZ);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt; a = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;a&#x27;&lt;/span&gt; + i;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;memset&lt;/span&gt;(data.text, a, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (msgsnd(msgid, (&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; *)&amp;amp;data, BUFFER_SIZ, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) == &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;msgsnd error \n&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::this_thread::sleep_for(&lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::chrono::seconds(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;memcpy&lt;/span&gt;(data.text, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;1234567&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;7&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (msgsnd(msgid, (&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; *)&amp;amp;data, BUFFER_SIZ, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) == &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;msgsnd error \n&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__function&quot;&gt;thread &lt;span class=&quot;code-snippet__title&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Receive)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    r.detach();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__function&quot;&gt;thread &lt;span class=&quot;code-snippet__title&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Send)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    s.detach();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::this_thread::sleep_for(&lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::chrono::seconds(&lt;span class=&quot;code-snippet__number&quot;&gt;20&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;输出：root@iZuf64idor3ej648ciairaZ:~# ./a.out&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;read data a&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;read data b&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;read data c&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;read data d&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;read data e&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;read data f&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;read data g&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;read data h&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;read data i&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;read data j&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;read data &lt;span class=&quot;code-snippet__number&quot;&gt;1234567&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Receive ok&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;br/&gt;&lt;p&gt;代码中为了演示方便使用消息队列进行的线程间通信，该代码同样用于进程间通信，消息队列的实现依赖于内核的支持，上述代码可能在某些系统（WSL）上不能运行，在正常的Ubuntu上可以正常运行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;消息队列VS命名管道&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;消息队列&amp;gt;命名管道&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1）消息队列收发消息自动保证了同步，不需要由进程自己来提供同步方法，而命名管道需要自行处理同步问题；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;2）消息队列接收数据可以根据消息类型有选择的接收特定类型的数据，不需要像命名管道一样默认接收数据。&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;消息队列&amp;lt;命名管道&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;消息队列有一个缺点就是发送和接收的每个数据都有最大长度的限制。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;共享内存&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;可开辟中一块内存，用于各个进程间共享，使得各个进程可以直接读写同一块内存空间，就像线程共享同一块地址空间一样，该方式基本上是最快的进程间通信方式，因为没有系统调用干预，也没有数据的拷贝操作，但由于共享同一块地址空间，数据竞争的问题就会出现，需要自己引入同步机制解决数据竞争问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;共享内存只是一种方式，它的实现方式有很多种，主要的有mmap系统调用、Posix共享内存以及System V共享内存等。通过这三种“工具”共享地址空间后，通信的目的自然就会达到。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;信号&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;信号也是进程间通信的一种方式，信号可以在任何时候发送给某一个进程，如果进程当前并未处于执行状态，内核将信号保存，直到进程恢复到执行态再发送给进程，进程可以对信号设置预处理方式，如果对信号设置了阻塞处理，则信号的传递会被延迟直到阻塞被取消，如果进程结束，那信号就被丢弃。我们常用的CTRL+C和kill等就是信号的一种，也达到了进程间通信的目的，进程也可以对信号设置signal捕获函数自定义处理逻辑。这种方式有很大的&lt;span&gt;缺点&lt;/span&gt;：只有通知的作用，通知了一下消息的类型，但不能传输要交换的任何数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Linux系统中常见的信号有：&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86261&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86261&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;SIGHUP：该信号在用户终端结束时发出，通常在中断的控制进程结束时，所有进程组都将收到该信号，该信号的默认操作是终止进程；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;SIGINT：程序终止信号，通常的CTRL+C产生该信号来通知终止进程；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;SIGQUIT：类似于程序错误信号，通常的CTRL+\产生该信号通知进程退出时产生core文件；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86261&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86261&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;SIGILL：执行了非法指令，通常数据段或者堆栈溢出可能产生该信号；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;SIGTRAP：供调试器使用，由断电指令或其它陷阱指令产生；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;SIGABRT：使程序非正常结束，调用abort函数会产生该信号；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86261&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86261&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;SIGBUS：非法地址，通常是地址对齐问题导致，比如访问一个4字节长的整数，但其地址不是4的倍数；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;SIGSEGV：合理地址的非法访问，访问了未分配的内存或者没有权限的内存区域；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;SIGPIPE：管道破裂信号，socket通信时经常会遇到，进程写入了一个无读者的管道；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86261&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86261&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;SIGALRM：时钟定时信号，由alarm函数设置的时间终止时产生；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86261&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86261&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;SIGFPE：出现浮点错误（比如除0操作）；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86261&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86261&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;SIGKILL：杀死进程（不能被捕捉和忽略）；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;信号量&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;想必大家都听过信号量，信号量就是一个特殊的变量，程序对其访问都是原子操作，每个信号量开始都有个初始值。最简单最常见的信号量是只能取0和1的变量，也叫二值信号量。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;信号量有两个操作，P和V：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;P：如果信号量变量值大于0，则变量值减1，如果值为0，则阻塞进程；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;V：如果有进程阻塞在该信号量上，则唤醒阻塞的进程，如果没有进程阻塞，则变量值加1&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;93831&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-bcless=&quot;spin&quot; data-bclessp=&quot;120&quot; data-bdopacity=&quot;1%&quot;&gt;&lt;section data-bcless=&quot;spin&quot; data-bclessp=&quot;120&quot; data-bdopacity=&quot;1%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-bcless=&quot;spin&quot; data-bclessp=&quot;120&quot; data-bdopacity=&quot;1%&quot;&gt;&lt;section&gt;Q&lt;/section&gt;&lt;/section&gt;&lt;section data-bcless=&quot;spin&quot; data-bclessp=&quot;120&quot; data-bdopacity=&quot;1%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;信号量和信号有什么关系&lt;/span&gt;？&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-bcless=&quot;spin&quot; data-bclessp=&quot;120&quot; data-bdopacity=&quot;1%&quot;&gt;&lt;section&gt;A&lt;/section&gt;&lt;/section&gt;&lt;section data-bcless=&quot;spin&quot; data-bclessp=&quot;120&quot; data-bdopacity=&quot;1%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;没有任何关系，完全是不同的东西。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;93831&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-bcless=&quot;spin&quot; data-bclessp=&quot;120&quot; data-bdopacity=&quot;1%&quot;&gt;&lt;section data-bcless=&quot;spin&quot; data-bclessp=&quot;120&quot; data-bdopacity=&quot;1%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-bcless=&quot;spin&quot; data-bclessp=&quot;120&quot; data-bdopacity=&quot;1%&quot;&gt;&lt;section&gt;Q&lt;/section&gt;&lt;/section&gt;&lt;section data-bcless=&quot;spin&quot; data-bclessp=&quot;120&quot; data-bdopacity=&quot;1%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;信号量与互斥量有什么区别？&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-bcless=&quot;spin&quot; data-bclessp=&quot;120&quot; data-bdopacity=&quot;1%&quot;&gt;&lt;section&gt;A&lt;/section&gt;&lt;/section&gt;&lt;section data-bcless=&quot;spin&quot; data-bclessp=&quot;120&quot; data-bdopacity=&quot;1%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;互斥量用于&lt;/span&gt;&lt;strong&gt;&lt;span&gt;互斥&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，信号量用于&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同步&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，互斥指的是某一资源同一时间只允许一个访问者访问，但无法限制访问顺序，访问是无序的，而同步在互斥的基础上可以控制访问者对资源的顺序。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;套接字&lt;/span&gt;&lt;/strong&gt;：就是网络传输，不用多说，网络通信都可以多机通信呢，更不用说进程间通信啦，你能看到程序喵的文章也是套接字的功劳。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;文件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;：显而易见，多个进程可以操作同一个文件，所以也可以通过文件来进行进程间通信。&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>