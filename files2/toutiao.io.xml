<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1e22e4414b07b7f0d29b33c0799106a1</guid>
<title>2022 年别再焦虑啦！加入我们！</title>
<link>https://toutiao.io/k/obimloc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4a2ecfd101c9a8b157a7eded7768cf07</guid>
<title>腾讯课堂 H5 直播间点赞动效实现</title>
<link>https://toutiao.io/k/s9wmei7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section class=&quot;mp_profile_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU2Mzk1NzkwOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibpVQtdHw0UaW5glBQ3RRqy8rYolxkF0tOaAqTUGW9MXPIGvLUGAJ7jB2JicLxJd6xvvWicThNSWFgg/0?wx_fmt=png&quot; data-nickname=&quot;趣谈前端&quot; data-alias=&quot;beautifulFront&quot; data-signature=&quot;徐小夕【知乎专栏作家】掘金签约作者，定期分享前端工程化，可视化，企业实战项目知识，深度复盘企业中经常遇到的500+技术问题解决方案。【关注趣谈前端，前端路上不迷茫】&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;职业规划&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;高级前端&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;可视化低代码&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;点击上方 &lt;strong&gt;趣谈前端&lt;/strong&gt;&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;，关注公众号&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回复&lt;/span&gt;&lt;span&gt;&lt;span&gt;进群&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，加入前端交流群&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;1. 前言&lt;/strong&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;以前在看微信视频号直播的时候，经常点击右下角的点赞按钮。看着它的数字慢慢从一位数变成五位数，还是挺有氛围感的。特别是长按的时候，有个手机震动的反馈，很带感。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.14375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnZAVNKXV6pohRgZHxYe68hicnejt0jqiaJQ4Dr9FLdJFJicb199s9RcOrQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;320&quot;/&gt;&lt;/p&gt;&lt;p&gt;虽然之前很好奇这些飘动的点赞动效是怎么实现的，但没有特别去钻研。直到前阵子投入腾讯课堂 H5 直播间的需求，需要自己去实现一个这样的效果时，才开始摸索。&lt;/p&gt;&lt;p&gt;先看看最后的效果：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.7890625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnNYSbDhHmnWxASR45B7zGmFbnRjsiaolyCEXj9trb2XI35UzMNlibbZpg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;256&quot;/&gt;&lt;/p&gt;&lt;p&gt;相比视频号的点赞动效，轨迹复杂了很多。可以看到课堂直播间的这一段点赞动效，大概分为这么三个阶段：&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;从无到有，在上升过程中&lt;strong&gt;放大&lt;/strong&gt;成正常大小&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;上升过程中&lt;strong&gt;左右摇曳&lt;/strong&gt;，且&lt;strong&gt;摇曳的幅度随机&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;左右摇曳上升的过程中，&lt;strong&gt;渐隐并缩小&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;p&gt;在动手之前，我先想到了使用 &lt;strong&gt;CSS animation&lt;/strong&gt; 去实现这种运动轨迹。在完成之后，又用 &lt;strong&gt;Canvas&lt;/strong&gt; 重构了一版，优化了性能。&lt;/p&gt;&lt;p&gt;接下来我们分别来看看这两种实现方式。&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;2. CSS 实现点赞动效&lt;/strong&gt;&lt;/h2&gt;&lt;h3&gt;&lt;strong&gt;2.1 轨迹分析&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;由于点赞动画是在一个二维平面上的，我们可以将它的运动轨迹拆分为 &lt;strong&gt;x 轴&lt;/strong&gt; 和 &lt;strong&gt;y 轴&lt;/strong&gt; 上的两段。&lt;/p&gt;&lt;p&gt;在 &lt;strong&gt;y 轴&lt;/strong&gt; 上非常简单，我们的点赞图标会做一段&lt;span&gt;垂直上升的&lt;/span&gt;匀速运动，从容器底部上升到容器顶部。&lt;/p&gt;&lt;p&gt;而 &lt;strong&gt;x 轴&lt;/strong&gt; 上是左右摇曳的，用数学的角度说，是一段简谐运动。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5864485981308412&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3Cn2ZYgnv2KkzoW2WoNHFD5PSDsaAiabyfxA6qK8MwRfyWWL1U0Ab8M0Ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;428&quot;/&gt;&lt;/p&gt;&lt;p&gt;但用 css 实现的时候，其实不用这么精细。为了简化计算，我们可以用几个关键帧来串联这段运动轨迹，例如：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;@keyframes&lt;/strong&gt;&lt;/span&gt; bubble_swing {&lt;br/&gt;  &lt;span&gt;0%&lt;/span&gt; {&lt;br/&gt;    中间&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;25%&lt;/span&gt; {&lt;br/&gt;    最左&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;75%&lt;/span&gt; {&lt;br/&gt;    最右&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;100%&lt;/span&gt; {&lt;br/&gt;    中间&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;2.2 轨迹设计&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;根据上面的分析，我们可以设计一段相同的上升轨迹，以及几段不同的左右摇曳轨迹。&lt;/p&gt;&lt;p&gt;上升轨迹很简单，&lt;span&gt;同时&lt;/span&gt;我们还可以加上透明度（opacity）、大小（transform）的变化，如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;@keyframes&lt;/strong&gt;&lt;/span&gt; bubble_y {&lt;br/&gt;  &lt;span&gt;0%&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;transform&lt;/span&gt;: &lt;span&gt;scale&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;margin-bottom&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;5%&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;transform&lt;/span&gt;: &lt;span&gt;scale&lt;/span&gt;(&lt;span&gt;1.5&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;80%&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;transform&lt;/span&gt;: &lt;span&gt;scale&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;100%&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;margin-bottom&lt;/span&gt;: &lt;span&gt;var&lt;/span&gt;(--cntHeight);&lt;br/&gt;    &lt;span&gt;transform&lt;/span&gt;: &lt;span&gt;scale&lt;/span&gt;(&lt;span&gt;0.8&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中，--cntHeight 指的是容器的高度。也就是说，我们通过让 margin-bottom 不断增大，来控制点赞图标从容器底部上升到容器顶部。&lt;/p&gt;&lt;p&gt;而对于横向运动的轨迹，为了增加运动轨迹的多样性，我们&lt;span&gt;可&lt;/span&gt;&lt;span&gt;以设计多段&lt;/span&gt;左右摇曳的轨迹，比如说一段 “中间 -&amp;gt; 最左 -&amp;gt; 中间 -&amp;gt; 最右” 的轨迹：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;@keyframes&lt;/strong&gt;&lt;/span&gt; bubble_swing_1 {&lt;br/&gt;  &lt;span&gt;0%&lt;/span&gt; {&lt;br/&gt;    // 中间&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;25%&lt;/span&gt; {&lt;br/&gt;    // 最左&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: -&lt;span&gt;12px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;75%&lt;/span&gt; {&lt;br/&gt;    // 最右&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;12px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;100%&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里同样使用 margin 来控制图标的左右移动。类似的，我们还可以设计几段别的轨迹：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 任意轨迹&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;@keyframes&lt;/strong&gt;&lt;/span&gt; bubble_swing_2 {&lt;br/&gt;  0% {&lt;br/&gt;    &lt;span&gt;// 中间&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  33% {&lt;br/&gt;    &lt;span&gt;// 最左&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: -&lt;span&gt;12px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  100% {&lt;br/&gt;    &lt;span&gt;// 随机位置&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;6px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 简谐反向&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;@keyframes&lt;/strong&gt;&lt;/span&gt; bubble_swing_3 {&lt;br/&gt;  0% {&lt;br/&gt;    &lt;span&gt;// 中间&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  25% {&lt;br/&gt;    &lt;span&gt;// 最右&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;12px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  75% {&lt;br/&gt;    &lt;span&gt;// 最左&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: -&lt;span&gt;12px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  100% {&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来我们把 &lt;strong&gt;x 轴&lt;/strong&gt; 和 &lt;strong&gt;y 轴&lt;/strong&gt; 的轨迹（@keyframes）结合起来，并设置一个随机的动画时间，比如说：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;@for&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;$i&lt;/span&gt; from &lt;span&gt;1&lt;/span&gt; through &lt;span&gt;3&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;@for&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;$j&lt;/span&gt; from &lt;span&gt;1&lt;/span&gt; through &lt;span&gt;2&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;.bl_&lt;/span&gt;#{&lt;span&gt;$i&lt;/span&gt;}_#{&lt;span&gt;$j&lt;/span&gt;} {&lt;br/&gt;      &lt;span&gt;animation&lt;/span&gt;: bubble_y calc(&lt;span&gt;1.5s&lt;/span&gt; + &lt;span&gt;$j&lt;/span&gt; * &lt;span&gt;0.5s&lt;/span&gt;) linear &lt;span&gt;1&lt;/span&gt; forwards,&lt;br/&gt;        bubble_swing_#{&lt;span&gt;$i&lt;/span&gt;} calc(&lt;span&gt;1.5s&lt;/span&gt; + &lt;span&gt;$j&lt;/span&gt; * &lt;span&gt;0.5s&lt;/span&gt;) linear &lt;span&gt;1&lt;/span&gt; forwards;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里生成了 3 * 2 = 6 种不同的轨迹。针对这类重复的选择器，用 SCSS 中的循环语法，可以少写很多代码。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;2.3 随机选择图片（雪碧图）&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;我们每次点赞会出现不同的图标，于是这里设计了一系列选择器给不同的图标，让它们呈现不同的图片。首先我们要准备一张雪碧图，保持所有图标的大小一致，然后同样使用 SCSS 的循环语法：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;@for&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;$i&lt;/span&gt; from &lt;span&gt;0&lt;/span&gt; through &lt;span&gt;7&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;.b&lt;/span&gt;#{&lt;span&gt;$i&lt;/span&gt;} {&lt;br/&gt;    &lt;span&gt;background&lt;/span&gt;: url(&lt;span&gt;&#x27;../../images/like_sprites.png&#x27;&lt;/span&gt;) calc(#{&lt;span&gt;$i&lt;/span&gt;} * -&lt;span&gt;24px&lt;/span&gt;) &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;像上面生成了 8 个选择器，我们在程序执行时就可以随机给图标赋予一个选择器。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;2.4 生成一个点赞图标&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;CSS 的部分差不多了，我们现在来看 JS 是怎么执行的。我们需要有一个容器 div，让它来装载要生成的点赞图标。以及一个按钮来绑定点击事件：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;const cacheRef = useRef&amp;lt;LikeCache&amp;gt;({&lt;br/&gt;    bubbleCnt: &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;    likeIcon: &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;    bubbleIndex: &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;    timer: &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;useEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    cacheRef.current.bubbleCnt = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;like-bubble-cnt&#x27;&lt;/span&gt;);&lt;br/&gt;    cacheRef.current.likeIcon = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;like-icon&#x27;&lt;/span&gt;);&lt;br/&gt;}, []);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在点击事件中，生成一个新的 div 元素，并为它设置 className。接着将它 append 到容器下，最后在一段时间后销毁这个点赞图标元素。如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 添加 bubble&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; addBubble = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; { bubbleCnt } = cacheRef.current;&lt;br/&gt;&lt;br/&gt;  cacheRef.current.bubbleIndex %= maxBubble;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; d = &lt;span&gt;document&lt;/span&gt;.createElement(&lt;span&gt;&#x27;div&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 图片类 b0 - b7&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 随机动画类 bl_1_1 - bl_3_2&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; swing = &lt;span&gt;Math&lt;/span&gt;.floor(&lt;span&gt;Math&lt;/span&gt;.random() * &lt;span&gt;3&lt;/span&gt;) + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; speed = &lt;span&gt;Math&lt;/span&gt;.floor(&lt;span&gt;Math&lt;/span&gt;.random() * &lt;span&gt;2&lt;/span&gt;) + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  d.className = &lt;span&gt;`like-bubble b&lt;span&gt;${cacheRef.current.bubbleIndex}&lt;/span&gt; bl_&lt;span&gt;${swing}&lt;/span&gt;_&lt;span&gt;${speed}&lt;/span&gt;`&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  bubbleCnt?.appendChild(d);&lt;br/&gt;  cacheRef.current.bubbleIndex++;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 动画结束后销毁元素&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;setTimeout&lt;/span&gt;(&lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    bubbleCnt?.removeChild(d);&lt;br/&gt;  }, &lt;span&gt;2600&lt;/span&gt;);&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;到这里，我们就实现得差不多了。不过，我们还可以给点击的图标加点动画，让它有一个被按压后弹起的效果：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 点击“喜欢”&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; onClick = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; { timer, likeIcon } = cacheRef.current;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (!likeIcon) {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (timer) {&lt;br/&gt;    &lt;span&gt;clearTimeout&lt;/span&gt;(timer);&lt;br/&gt;    cacheRef.current.timer = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  likeIcon.classList.remove(&lt;span&gt;&#x27;bounce-click&#x27;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;// 删除并重新添加类，需要延迟添加&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;setTimeout&lt;/span&gt;(&lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    likeIcon.classList.add(&lt;span&gt;&#x27;bounce-click&#x27;&lt;/span&gt;);&lt;br/&gt;  }, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;  cacheRef.current.timer = &lt;span&gt;window&lt;/span&gt;.setTimeout(&lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    likeIcon.classList.remove(&lt;span&gt;&#x27;bounce-click&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;clearTimeout&lt;/span&gt;(timer!);&lt;br/&gt;    cacheRef.current.timer = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  }, &lt;span&gt;300&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  addBubble();&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;2.5 最终效果&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;最后来看看效果吧！&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.3728813559322033&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnKMM9EDicGnPXbFbLpMNpr4JMGcT53f2hbKZjW68KbtSACvXxibu3gI3g/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;177&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;3. Canvas 实现点赞动效&lt;/strong&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;我们都知道 Canvas 的绘制更流畅一些，能够带来更好的体验。但苦于编码比较复杂，也有一定的学习成本，实现起来要比 CSS 复杂不少。&lt;/p&gt;&lt;p&gt;接下来我们看看基于 &lt;span&gt;C&lt;/span&gt;&lt;span&gt;anvas&lt;/span&gt; 的点赞动效实现。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;3.1 画布创建&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;首先我们读取一个 &lt;span&gt;C&lt;/span&gt;&lt;span&gt;anvas&lt;/span&gt; 元素的 id，并通过 getContext 获取它的上下文。除此之外，还传入了一个 canvasScale，指的是画布放大的比例，这个在之后会用到：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;constructor&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;canvasId: string, canvasScale: number&lt;/span&gt;)&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; canvas = &lt;span&gt;document&lt;/span&gt;.getElementById(canvasId) &lt;span&gt;&lt;strong&gt;as&lt;/strong&gt;&lt;/span&gt; HTMLCanvasElement;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.context = canvas.getContext(&lt;span&gt;&#x27;2d&#x27;&lt;/span&gt;)!;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.width = canvas.width;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.height = canvas.height;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.canvasScale = canvasScale;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.img = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.loadImages();&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.2 预加载图片（雪碧图）&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;在 constructor 这里，我们还通过 loadImages 这个函数，预加载了雪碧图：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;import&lt;/strong&gt;&lt;/span&gt; likeSprites &lt;span&gt;&lt;strong&gt;from&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&#x27;../../images/like_sprites.png&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 预加载图片&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;loadImages = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; p = &lt;span&gt;&lt;strong&gt;new&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve: (image: HTMLImageElement) =&amp;gt; &lt;span&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; img = &lt;span&gt;&lt;strong&gt;new&lt;/strong&gt;&lt;/span&gt; Image();&lt;br/&gt;    img.onerror = &lt;span&gt;() =&amp;gt;&lt;/span&gt; resolve(img);&lt;br/&gt;    img.onload = &lt;span&gt;() =&amp;gt;&lt;/span&gt; resolve(img);&lt;br/&gt;    img.src = likeSprites;&lt;br/&gt;  });&lt;br/&gt;  p.then(&lt;span&gt;(&lt;span&gt;img&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (img &amp;amp;&amp;amp; img.width &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.img = img;&lt;br/&gt;    } &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// error(&#x27;[live-connect]预加载喜欢动效图片失败&#x27;);&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  });&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.3 轨迹拆解&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;同样的，我们需要从 Canvas 的视角来拆解点赞图标的运动轨迹。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;y 轴&lt;/strong&gt; 的运动和 CSS 一样，我们知道起始位置和终止位置就可以得出。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;x 轴&lt;/strong&gt; 的运动可以好好推敲。由于 Canvas 是逐帧绘制的，我们可以模拟出一个比较逼真的简谐运动。这里要来讲一讲大家耳熟能详的初中数学了，下面是我们要使用的一条正弦函数的公式：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;y = A sin(Bx + C) + D&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参数说明：&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;振幅是 &lt;strong&gt;A&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;周期是 &lt;strong&gt;2π/B&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;相移是 &lt;strong&gt;−C/B&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;垂直移位是 &lt;strong&gt;D&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;套入点赞动效：&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;赋予图标元素随机的振幅 A。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;赋予图标元素随机的周期，即 B 是随机的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;取 C = 0，即相移为 0。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;取 D = 0，即不需要垂直移位。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;y = A sinBx。&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.4 横竖位移计算&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;确定位移轨迹之后，我们先定义一些常量，如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/** 图片显示宽高 */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; IMAGE_WIDTH = &lt;span&gt;30&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/** 图片原始宽高 */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; SOURCE_IMAGE_WIDTH = &lt;span&gt;144&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/** 图片数量 */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; IMG_NUM = &lt;span&gt;8&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/** 放大阶段（百分比）*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; ENLARGE_STAGE = &lt;span&gt;0.1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/** 收缩渐隐阶段（百分比）*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; FADE_OUT_STAGE = &lt;span&gt;0.8&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先我们可以设计 &lt;strong&gt;x 轴&lt;/strong&gt; 和 &lt;strong&gt;y 轴&lt;/strong&gt; 两个方向上的位移计算函数，函数参数 progress 是 0 到 1 之间的数值，表示一个过程量（0 -&amp;gt; 1）。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 起始位置&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; basicX = &lt;span&gt;this&lt;/span&gt;.width / &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 正弦频率&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; frequency = random(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 正弦振幅&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; amplitude = random(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;) * (random(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) ? &lt;span&gt;1&lt;/span&gt; : -&lt;span&gt;1&lt;/span&gt;) * &lt;span&gt;this&lt;/span&gt;.canvasScale;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 获取横向位移（x轴）&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; getTranslateX = &lt;span&gt;(&lt;span&gt;progress: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (progress &amp;lt; ENLARGE_STAGE) {&lt;br/&gt;    &lt;span&gt;// 放大期间，不进行摇摆位移&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; basicX;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; basicX + amplitude * &lt;span&gt;Math&lt;/span&gt;.sin(frequency * (progress - ENLARGE_STAGE));&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 获取竖向位移（y轴）&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; getTranslateY = &lt;span&gt;(&lt;span&gt;progress: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; IMAGE_WIDTH / &lt;span&gt;2&lt;/span&gt; + (&lt;span&gt;this&lt;/span&gt;.height - IMAGE_WIDTH / &lt;span&gt;2&lt;/span&gt;) * (&lt;span&gt;1&lt;/span&gt; - progress);&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.5 大小和透明度计算&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;要绘制的图标大小怎么控制呢？在 Canvas 中，其实就是计算一个 scale，表示放缩的比例。&lt;/p&gt;&lt;p&gt;我们根据放大/收缩阶段的过程常量和 progress 变量来调节它的大小。起始阶段先线性放大至 1，最后阶段再线性缩小至 0。&lt;/p&gt;&lt;p&gt;透明度同理，在消失之前都是返回 1，其余时刻线性缩小。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 获取放缩比例&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; getScale = &lt;span&gt;(&lt;span&gt;progress: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;let&lt;/strong&gt;&lt;/span&gt; r = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (progress &amp;lt; ENLARGE_STAGE) {&lt;br/&gt;    &lt;span&gt;// 放大&lt;/span&gt;&lt;br/&gt;    r = progress / ENLARGE_STAGE;&lt;br/&gt;  } &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (progress &amp;gt; FADE_OUT_STAGE) {&lt;br/&gt;    &lt;span&gt;// 缩小&lt;/span&gt;&lt;br/&gt;    r = (&lt;span&gt;1&lt;/span&gt; - progress) / (&lt;span&gt;1&lt;/span&gt; - FADE_OUT_STAGE);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; r;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 获取透明度&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; getAlpha = &lt;span&gt;(&lt;span&gt;progress: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (progress &amp;lt; FADE_OUT_STAGE) {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;return &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; - (progress - FADE_OUT_STAGE) / (&lt;span&gt;1&lt;/span&gt; - FADE_OUT_STAGE);&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.6 Canvas 绘制&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;绘制时，我们先挑选一张图片。如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 按顺序读取图片&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; { curImgIndex } = &lt;span&gt;&lt;strong&gt;this&lt;/strong&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 更新顺序&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;this&lt;/strong&gt;&lt;/span&gt;.curImgIndex = ++&lt;span&gt;&lt;strong&gt;this&lt;/strong&gt;&lt;/span&gt;.curImgIndex % IMG_NUM;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;strong&gt;3.6.1 画布元素清晰度&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;接下来需要用到我们之前提到的 canvasScale 了：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; newWidth = IMAGE_WIDTH * &lt;span&gt;this&lt;/span&gt;.canvasScale;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为什么这里要乘以一个 canvasScale 呢？因为 Canvas 是&lt;strong&gt;位图模式&lt;/strong&gt;的，它会根据设备的 &lt;strong&gt;dpi&lt;/strong&gt; 来渲染图片。&lt;/p&gt;&lt;p&gt;首先先介绍一下高分屏的概念：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;高分屏：在同样大小的屏幕面积上显示更多的像素点，也就是更多的可视信息。常见的就是 SXGA（1400 * 1050），UXGA（1600 * 1200）。1024 * 768 分辨率的屏幕叫普通屏，也就是 XGA 的屏幕，这个分辨率以上的屏幕叫高分屏。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在高分屏上，每平方英寸会有更多的像素。原来在普通屏上绘制的 1 个像素，为了适应高分屏，被迫放大，变成了 4 个像素或者更多。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;可以想象成，一张清晰度正常的普通图片为了布满整个背景被强行放大 n 倍，所以看起来模糊了&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7434869739478958&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnbPNrjWlfSpuw7eSdysHUzPsroUKbjBBCf0f6Ik4MAkF99lOAqf1gRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;499&quot;/&gt;&lt;/p&gt;&lt;p&gt;为了解决这个问题，就需要我们将绘制的图片放大。同时还要控制 Canvas 画布在 CSS 中的宽高。做到绘制内容变大的同时，画布依然呈现原来的大小。这样一来，图片就会因为绘制了更多的内容，而在高分屏上变得清晰且细腻。&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;3.6.2 绘制元素&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;绘制我们用到了 drawImage。在调用它之前，我们需要&lt;span&gt;根据计算出的 translateX 和 translateY，&lt;/span&gt;&lt;span&gt;调&lt;/span&gt;&lt;span&gt;整绘制的起&lt;/span&gt;&lt;span&gt;点&lt;/span&gt;。并且调整放缩比例和透明度，即 &lt;code&gt;context.scale()&lt;/code&gt; 和 &lt;code&gt;context.globalAlpha&lt;/code&gt;。如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;(&lt;span&gt;progress: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 动画过程 0 -&amp;gt; 1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (progress &amp;gt;= &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;&lt;strong&gt;return &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  context.save();&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; scale = getScale(progress);&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; translateX = getTranslateX(progress);&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; translateY = getTranslateY(progress);&lt;br/&gt;  context.translate(translateX, translateY);&lt;br/&gt;  context.scale(scale, scale);&lt;br/&gt;  context.globalAlpha = getAlpha(progress);&lt;br/&gt;  context.drawImage(&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.img!,&lt;br/&gt;    SOURCE_IMAGE_WIDTH * curImgIndex,&lt;br/&gt;    &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;    SOURCE_IMAGE_WIDTH,&lt;br/&gt;    SOURCE_IMAGE_WIDTH,&lt;br/&gt;    -newWidth / &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt;    -newWidth / &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt;    newWidth,&lt;br/&gt;    newWidth,&lt;br/&gt;  );&lt;br/&gt;  context.restore();&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;strong&gt;3.6.3 创建绘制实例&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;我们用一个 start 函数来生成点赞动画，每当调用它时，都会创建一个 render 方法，并塞入一个 renderList。renderList 中存放的就是当前所有点赞图标的绘制任务。如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;start = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; render = &lt;span&gt;this&lt;/span&gt;.createRender();&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; duration = random(&lt;span&gt;2100&lt;/span&gt;, &lt;span&gt;2600&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (!render) {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.renderList.push({&lt;br/&gt;    render,&lt;br/&gt;    duration,&lt;br/&gt;    &lt;span&gt;timestamp&lt;/span&gt;: &lt;span&gt;Date&lt;/span&gt;.now(),&lt;br/&gt;  });&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.scanning) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.scanning = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    requestAnimationFrame(&lt;span&gt;this&lt;/span&gt;.scan);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;strong&gt;3.6.4 实时绘制&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;知道了需要绘制哪些对象之后，就需要通过下面的 scan 方法，让 Canvas 在每一帧都去绘制内容。&lt;/p&gt;&lt;p&gt;每次绘制分为这么几个过程：&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;清空画布为透明。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;从绘制列表中取出一个点赞图标的 render 方法，并调用它。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;假如它返回了 true，代表点赞图标已经完整经历了整个动效的过程，需要将它从绘制列表中剔除出去。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;重复 2、3 过程，直至列表中没有任务需要执行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;requestAnimationFrame&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 调用 scan 方法自身，等待下一帧重新调用 scan 绘制内容。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;scan = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.context.clearRect(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.width, &lt;span&gt;this&lt;/span&gt;.height);&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;let&lt;/strong&gt;&lt;/span&gt; index = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;let&lt;/strong&gt;&lt;/span&gt; { length } = &lt;span&gt;this&lt;/span&gt;.renderList;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (length &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    requestAnimationFrame(&lt;span&gt;this&lt;/span&gt;.scan);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.scanning = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  } &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.scanning = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;while&lt;/strong&gt;&lt;/span&gt; (index &amp;lt; length) {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; child = &lt;span&gt;this&lt;/span&gt;.renderList[index];&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (!child || !child.render || child.render.call(&lt;span&gt;null&lt;/span&gt;, (&lt;span&gt;Date&lt;/span&gt;.now() - child.timestamp) / child.duration)) {&lt;br/&gt;      &lt;span&gt;// 结束了，删除该动画&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.renderList.splice(index, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;      length--;&lt;br/&gt;    } &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;/span&gt; {&lt;br/&gt;      index++;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.7 调用&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;接下来我们只需要在点击的时候，调用一下 &lt;code&gt;start&lt;/code&gt; 方法即可。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 点击“喜欢”&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; onClick = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  cacheRef.current.LikeAni?.start?.();&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; (&lt;br/&gt;  &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;{cn(&lt;/span&gt;&#x27;&lt;span&gt;like-wrap&lt;/span&gt;&#x27;, &lt;span&gt;className&lt;/span&gt;)}&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;canvas&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;{CANVAS_ID}&lt;/span&gt; &lt;span&gt;width&lt;/span&gt;=&lt;span&gt;{CANVAS_WIDTH}&lt;/span&gt; &lt;span&gt;height&lt;/span&gt;=&lt;span&gt;{CANVAS_HEIGHT}&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;like-bubble-cnt&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;{cn(&lt;/span&gt;&#x27;&lt;span&gt;like-icon-cnt&lt;/span&gt;&#x27;, &lt;span&gt;className&lt;/span&gt;)} &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{onClick}&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;i&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;like-icon&quot;&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;like-icon&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在直播场景下，还有很多不同的触发方式。除了自己点击，我们还可以接受来自其他用户的反馈（网络请求）来触发&lt;span&gt; &lt;/span&gt;&lt;code&gt;start&lt;/code&gt;&lt;span&gt; 方法&lt;/span&gt;。或者根据在线人数，多次调用 &lt;code&gt;start&lt;/code&gt; 方法来生成一定数量的点赞图标。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;3.8 最终效果&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.3728813559322033&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnYP7LBJLR62gxgcnGSICWb4VWTXCy1PFJEvticiaLXO5TWh19eA5M2xZQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;177&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;4. 性能比较&lt;/strong&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;以下内容是在 MacBook Pro 16 的屏幕上测试的。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;4.1 Frame Rendering Stats&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;在 chrome devtools 中，有两个小功能可以来观察我们绘制的性能情况：&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;这两个功能，可以在 chrome devtools 中使用快捷键 Command + Shift + P，呼起命令搜索的 Panel 来搜索到。&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;CSS 性能&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;我们可以看到高亮区域在频繁闪动，以及 GPU 内存的使用比率较高，这是因为 CSS 的实现方式是不断生成新的元素（并在随后销毁），会消耗更多的内存。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0235690235690236&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3Cn61PuKHuVcJY64I0ciaw5Yib7aKR0QeczWS6w7Vov2EtcKhruOHEXIuAw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;297&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Canvas 性能&lt;/strong&gt;&lt;br/&gt;&lt;/h4&gt;&lt;p&gt;相反，Canvas 是集中在画布上绘制并输出的，不会反复创建和销毁元素。会比 CSS 的实现更加流畅，性能更好一点。&lt;/p&gt;&lt;p&gt;除了流畅以外，Canvas 还能够放大画布和画布元素，这也是一个非常重要的优势。这意味着 Canvas 能够绘制出更清晰的内容，生成出来的点赞图标更加细腻。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0235690235690236&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CneXgmLZDgbvcd17KZ2etPibicNN9GTMoSaib6cFxiaHuCRAlrB4tkvuibrLw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;297&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;4.2 Performance&lt;/strong&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;在 chrome devtools 中切换到 Performance 面板，还可以观察动画绘制过程中，页面的一些性能指标。&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;CSS 性能&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;CSS 的实现之所以看起比较卡顿，主要是因为绘制任务太频繁。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1705790297339593&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnUB3NiciafG8nmTuKibbRQ4OKZVeJicHbvMxclwKsmicZ6k6jQwumiaFCb9Wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1278&quot;/&gt;&lt;/p&gt;&lt;p&gt;具体到每一帧，我们可以观察到 LayoutShift 的警告。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.50431654676259&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3Cnh2hVHf4azOrrBKM4A1mHibNyeGI0x6ad3ze5OtdPuPBZuBQ5ogzfYaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1390&quot;/&gt;&lt;/p&gt;&lt;p&gt;每次可视元素在两次渲染帧中的起始位置不同时，就说是发生了 LS（Layout Shift）。&lt;strong&gt;改变了起始位置的元素被认为是不稳定元素&lt;/strong&gt;。&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Canvas 性能&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;Canvas 实现的性能情况看起来就比较正常，即使绘制清晰一些的图片也不在话下。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0332409972299168&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnKibqyoXGwzYP3IPzDj3bfosticSBNhal4Nr1rrz5HjibvRDqsJ1kHT5iag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1444&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;5. 相关&lt;/strong&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;实现参考：&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fgithub.com%2Fantiter%2Fpraise-animation&amp;amp;title=&quot; href=&quot;&quot;&gt;https://github.com/antiter/praise-animation&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;更多推荐&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;点个在看 你最好看&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.8&quot; data-type=&quot;png&quot; data-w=&quot;50&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ImtD1PjRzRibmwqBpXL6icIKqbwdwwR26NfB89hJ09AJCorfLHxNdGlIIKr02IiajJ3O6t3qzXFXcJZ1lUxUnibTIA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3d72e318487d132076cd450672afbf2b</guid>
<title>2022春节贺岁档电影开分，水门桥不理想，四海崩了！用Python一探究竟</title>
<link>https://toutiao.io/k/877cd6d</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管受到疫情影响，部分地区被迫关闭了电影院，但从大年初一中国影史第二单日总票房的数据来看，2022 年春节期间大家的观影热情还是十分高涨的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大年初一上映当天，从票房数据来看，《长津湖之水门桥》一马当先，《四海》《这个杀手不太冷静》《奇迹·笨小孩》你追我赶，动画片《熊出没》表现强势，《狙击手》令人遗憾。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.902687673772011&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2ozNacoHjicGBv5GWSAUWzUcDsPcwLNdFhJf9YOU3VTBib67xh8fYb9qHQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1079&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前，几部真人电影豆瓣已经开分了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32421875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2opOvlOiabnvTV7V4pFT65gBINUefyz5co2fLwp7mtMs8eDtqosJHTHrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们用 Python 爬取这几部豆瓣开分的电影评论，爬取的具体分析过程这里就不说了，不了解的可以参考一下：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU3Mzk1ODA5OQ==&amp;amp;mid=2247484101&amp;amp;idx=1&amp;amp;sn=2367e5f51ca00e35717d8ab7340c5aad&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;豆瓣影评爬取参考&lt;/a&gt;，主要实现代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;spider&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    url = &lt;span&gt;&#x27;https://accounts.douban.com/j/mobile/login/basic&#x27;&lt;/span&gt;&lt;br/&gt;    headers = {&lt;span&gt;&quot;User-Agent&quot;&lt;/span&gt;: &lt;span&gt;&#x27;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)&#x27;&lt;/span&gt;}&lt;br/&gt;    &lt;span&gt;# 龙岭迷窟网址，为了动态翻页，start 后加了格式化数字，短评页面有 20 条数据，每页增加 20 条&lt;/span&gt;&lt;br/&gt;    url_comment = &lt;span&gt;&#x27;https://movie.douban.com/subject/35215390/comments?start=%d&amp;amp;limit=20&amp;amp;sort=new_score&amp;amp;status=P&#x27;&lt;/span&gt;&lt;br/&gt;    data = {&lt;br/&gt;        &lt;span&gt;&#x27;ck&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;用户名&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&#x27;password&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;密码&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&#x27;remember&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;false&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&#x27;ticket&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    session = requests.session()&lt;br/&gt;    session.post(url=url, headers=headers, data=data)&lt;br/&gt;    &lt;span&gt;# 初始化 4 个 list 分别存用户名、评星、时间、评论文字&lt;/span&gt;&lt;br/&gt;    users = []&lt;br/&gt;    stars = []&lt;br/&gt;    times = []&lt;br/&gt;    content = []&lt;br/&gt;    &lt;span&gt;# 抓取 500 条，每页 20 条，这也是豆瓣给的上限&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;500&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;):&lt;br/&gt;        &lt;span&gt;# 获取 HTML&lt;/span&gt;&lt;br/&gt;        data = session.get(url_comment % i, headers=headers)&lt;br/&gt;        &lt;span&gt;# 状态码 200 表是成功&lt;/span&gt;&lt;br/&gt;        print(&lt;span&gt;&#x27;第&#x27;&lt;/span&gt;, i, &lt;span&gt;&#x27;页&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;状态码：&#x27;&lt;/span&gt;,data.status_code)&lt;br/&gt;        &lt;span&gt;# 暂停 0-1 秒时间，防止IP被封&lt;/span&gt;&lt;br/&gt;        time.sleep(random.random())&lt;br/&gt;        &lt;span&gt;# 解析 HTML&lt;/span&gt;&lt;br/&gt;        selector = etree.HTML(data.text)&lt;br/&gt;        &lt;span&gt;# 用 xpath 获取单页所有评论&lt;/span&gt;&lt;br/&gt;        comments = selector.xpath(&lt;span&gt;&#x27;//div[@class=&quot;comment&quot;]&#x27;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;# 遍历所有评论，获取详细信息&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; comment &lt;span&gt;in&lt;/span&gt; comments:&lt;br/&gt;            &lt;span&gt;# 获取用户名&lt;/span&gt;&lt;br/&gt;            user = comment.xpath(&lt;span&gt;&#x27;.//h3/span[2]/a/text()&#x27;&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;            &lt;span&gt;# 获取评星&lt;/span&gt;&lt;br/&gt;            star = comment.xpath(&lt;span&gt;&#x27;.//h3/span[2]/span[2]/@class&#x27;&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;7&lt;/span&gt;:&lt;span&gt;8&lt;/span&gt;]&lt;br/&gt;            &lt;span&gt;# 获取时间&lt;/span&gt;&lt;br/&gt;            date_time = comment.xpath(&lt;span&gt;&#x27;.//h3/span[2]/span[3]/@title&#x27;&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;# 有的时间为空，需要判断下&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; len(date_time) != &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;                date_time = date_time[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;                date_time = date_time[:&lt;span&gt;10&lt;/span&gt;]&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;                date_time = &lt;span&gt;None&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;# 获取评论文字&lt;/span&gt;&lt;br/&gt;            comment_text = comment.xpath(&lt;span&gt;&#x27;.//p/span/text()&#x27;&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;].strip()&lt;br/&gt;            &lt;span&gt;# 添加所有信息到列表&lt;/span&gt;&lt;br/&gt;            users.append(user)&lt;br/&gt;            stars.append(star)&lt;br/&gt;            times.append(date_time)&lt;br/&gt;            content.append(comment_text)&lt;br/&gt;    &lt;span&gt;# 用字典包装&lt;/span&gt;&lt;br/&gt;    comment_dic = {&lt;span&gt;&#x27;user&#x27;&lt;/span&gt;: users, &lt;span&gt;&#x27;star&#x27;&lt;/span&gt;: stars, &lt;span&gt;&#x27;time&#x27;&lt;/span&gt;: times, &lt;span&gt;&#x27;comments&#x27;&lt;/span&gt;: content}&lt;br/&gt;    &lt;span&gt;# 转换成 DataFrame 格式&lt;/span&gt;&lt;br/&gt;    comment_df = pd.DataFrame(comment_dic)&lt;br/&gt;    &lt;span&gt;# 保存数据&lt;/span&gt;&lt;br/&gt;    comment_df.to_csv(&lt;span&gt;&#x27;data.csv&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了评论数据，我们再通过词云直观的感受一下，主要代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;df = pd.read_csv(&lt;span&gt;&quot;comment.csv&quot;&lt;/span&gt;, index_col = &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;cts_list = df[&lt;span&gt;&#x27;comments&#x27;&lt;/span&gt;].values.tolist()&lt;br/&gt;cts_str =&lt;span&gt;&quot;&quot;&lt;/span&gt;.join([str(i).replace(&lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;&#x27;&lt;/span&gt;).replace(&lt;span&gt;&#x27; &#x27;&lt;/span&gt;, &lt;span&gt;&#x27;&#x27;&lt;/span&gt;) &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; cts_list])&lt;br/&gt;stop_words = []&lt;br/&gt;&lt;span&gt;with&lt;/span&gt; open(&lt;span&gt;&#x27;stop_words.txt&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;r&#x27;&lt;/span&gt;, encoding=&lt;span&gt;&#x27;utf-8&#x27;&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; f:&lt;br/&gt;    lines = f.readlines()&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; lines:&lt;br/&gt;        stop_words.append(line.strip())&lt;br/&gt;&lt;span&gt;# jieba 分词&lt;/span&gt;&lt;br/&gt;word_list = jieba.cut(cts_str)&lt;br/&gt;words = []&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; word &lt;span&gt;in&lt;/span&gt; word_list:&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; word &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; stop_words:&lt;br/&gt;        words.append(word)&lt;br/&gt;cts_str = &lt;span&gt;&#x27;，&#x27;&lt;/span&gt;.join(words)&lt;br/&gt;print(cts_str)&lt;br/&gt;stylecloud.gen_stylecloud(text=cts_str, max_words=&lt;span&gt;300&lt;/span&gt;,&lt;br/&gt;                          collocations=&lt;span&gt;False&lt;/span&gt;,&lt;br/&gt;                          font_path=&lt;span&gt;&quot;SIMLI.TTF&quot;&lt;/span&gt;,&lt;br/&gt;                          icon_name=&lt;span&gt;&quot;fas fa-arrow-circle-right&quot;&lt;/span&gt;,&lt;br/&gt;                          size=&lt;span&gt;800&lt;/span&gt;,&lt;br/&gt;                          output_name=&lt;span&gt;&quot;comment.png&quot;&lt;/span&gt;)&lt;br/&gt;Image(filename=&lt;span&gt;&quot;comment.png&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们来看《四海》，《四海》的口碑为什么没有纵横四海？看看观众怎么说的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2oakEHR4kNg4GhTmaNibeNj1myqrop4wor1HgjWHAQMylrjWhRxFCpFaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着看《这个杀手不太冷静》，作为一部喜剧片，豆瓣这个评分还算可以，看看观众怎么说的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2oJhxrv81ibiapiaGNd9vw8Z7LHJZNow1BRoJb56TotK16Pw38G9OqrRHDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再接着看《长津湖之水门桥》，目前评分是低于第一部的，看看观众怎么说的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2oicHZecIeGxqlTd7KYaOylx4297QdeLJonpTpdufHO6EablaZGZ1rMeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再接着看《奇迹·笨小孩》，评分和票房都算是中规中矩，看看观众怎么说的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2oc2zJS8V2YoDfCUaP3pkBibFSEkgkOLUcRz8OeMN9oKLBpNtN3mTDY6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再接着看《狙击手》，国师父女指导，票房不佳，评分暂列第一，看看观众怎么说的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2ok6LupiaY4Svw5VY3zET2Q2w8J3UJ4cUOnstKLrmCiczicTYd5tzGI3RpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码已经打包整理好了，有需要的小伙伴可以在公众号&lt;strong&gt;Python数据分析之美&lt;/strong&gt;后台回复&lt;strong&gt;m2022&lt;/strong&gt;直接获取~&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>88fc3a94c26386a53dfe4cd50daf5aa3</guid>
<title>现代软件架构师的 10 个技巧</title>
<link>https://toutiao.io/k/7ormdqi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote&gt;&lt;p&gt;&lt;em&gt;作为软件架构师，我们既需要了解广受验证的设计方法，也需要知道业界的发展趋势，从而为业务提供前瞻性的架构设计，帮助实现业务成功。原文：Top 10 Tips You Should Know As A Modern Software Architect&lt;span&gt;[1]&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;随着技术的快速发展，软件架构每天都有新的模式和技术诞生。本文总结了作为一名现代软件架构师应该知道的10个技巧。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;1 — 关注那些为微服务架构（MSA，Microservices Architecture）提供支持的框架&lt;/span&gt;&lt;/h1&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;随着微服务架构成为主流，大多数框架已经开始按照微服务架构的要求重塑自己。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;框架需要支持的关键功能是轻量级的、拥有最小的内存占用、易于学习、支持容错、具有可观察性（跟踪、度量、日志）、支持安全性（认证和授权）等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;虽然Java生态中已经有Spring&lt;span&gt;[2]&lt;/span&gt;和Play Framework&lt;span&gt;[3]&lt;/span&gt;这样的框架，但是仍然需要关注新的框架（如Helidon&lt;span&gt;[4]&lt;/span&gt;、Quarkus&lt;span&gt;[5]&lt;/span&gt;或Micronaut&lt;span&gt;[6]&lt;/span&gt;），并随时准备根据需求进行调整，。此外，像Spring这样的成熟玩家也提供了新的选择，比如用于微服务的Reactive Stack&lt;span&gt;[7]&lt;/span&gt;、Spring GraphQL&lt;span&gt;[8]&lt;/span&gt;、RSocket with Spring Boot&lt;span&gt;[9]&lt;/span&gt;等，需要根据具体的用例来选择应用。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;其他语言也有类似的趋势，比如Golang的Gokit&lt;span&gt;[10]&lt;/span&gt;和Gomicro&lt;span&gt;[11]&lt;/span&gt;, Python的Flask&lt;span&gt;[12]&lt;/span&gt;, Bottle&lt;span&gt;[13]&lt;/span&gt;, Falcon&lt;span&gt;[14]&lt;/span&gt;和Nameko&lt;span&gt;[15]&lt;/span&gt;，以及NodeJS的Molecular&lt;span&gt;[16]&lt;/span&gt;和Nest&lt;span&gt;[17]&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;微服务架构的另一个关键点是，不需要为所有微服务采用单一框架或技术，可以根据特定微服务的机制和需求选择合适的编程语言和框架。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;阅读这篇关于Java中微服务演变的文章：https://vedcraft.com/architecture/evolution-of-microservices-frameworks-in-java/。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;&lt;span&gt;2 — 选择适合微服务通信的模式和技术&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span&gt;3 — 对API采用标准化和设计优先的方法&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span&gt;4 — 考虑将服务网格作为加速器&lt;/span&gt;&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;在软件架构中，服务网格是一个专用的基础设施层，通过代理为服务之间或微服务之间的通信提供帮助。——维基百科&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4742857142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0WLAbshmUfsaZgsYkpT2eaUcCquGL7iaKLoQQvPl9zicH7K7jDtFOzOEElw9ysyt0gMKKKV62ibxL6aQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;875&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图C - 服务网格核心能力&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;服务网格正在成为处理微服务通信和网络的标准。此外，它还可以提供其他辅助功能，如服务发现、客户端负载平衡、超时、重试和熔断、安全性等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;注意，虽然服务网格一开始是作为一种更好的解决方案帮助RPC风格的服务间通信，但现在已经出现了一些新的模式，比如用于事件驱动微服务的Event Mesh&lt;span&gt;[18]&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;另外一点是服务网格与API管理/网关解决方案有部分功能重叠，不同方向的专家对它们的适用性有着不同的观点。好的解决方案可以在两者之间取得平衡，让两者协作完成各自适用的职责。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;&lt;span&gt;5 — 在任何合适的地方使用云原生架构&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;通常，云原生与云服务提供商（如AWS、Azure、Google Cloud等）提供的云服务是一个意思，但最重要的是构建云原生的架构。云原生计算基金会（CNCF，Cloud Native Computing Foundation）&lt;span&gt;[19]&lt;/span&gt;是Linux基金会的下属项目（成立于2015年），专注于云原生软件的发展。&lt;/p&gt;&lt;p&gt;根据他们的章程&lt;span&gt;[20]&lt;/span&gt;，云原生技术可以定义为:&lt;/p&gt;&lt;p&gt;作为软件架构师，我们需要了解云原生技术。目前由CNCF分享的云原生技术地图囊括了系统的方方面面，请开始在未来的架构设计中考虑云原生技术。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5622857142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0WLAbshmUfsaZgsYkpT2eaU4kuv8D4fiaVs7UOjj1rwpBWtksa6BFrMuLzIj8UM4Jj1z1YmweSygJQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;875&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图D - 来源:https://landscape.cncf.io/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;6 — 将可观测性应用于端到端可见性&lt;/span&gt;&lt;/h1&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;可观测性被定义为一种度量方法，用来衡量基于系统外部输出可以推断出系统内部状态的程度。简单来说，可观测性决定了我们能在多大程度上理解复杂系统。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可观测性将监控的概念扩展到了新的层次，包括四个关键支柱——端到端可见性的度量、跟踪、事件和日志(如下所示)。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;作为一种软件架构，与可观测性相关的SRE实践对于确保所考虑的系统在上线之后能够维持业务需求至关重要。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.684&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0WLAbshmUfsaZgsYkpT2eaU6nup7mGfgM5CaDhYV2PJIKagTZpZogvBbJCq6KDLxRcgyibHVXFSy1w/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图E - 可观测性四大支柱(MELT)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;&lt;span&gt;7 — 应用Kubernetes作为基础平台&lt;/span&gt;&lt;/h1&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Kubernetes是新的Linux，并逐渐成为事实上的应用程序通用平台标准。作为&lt;span&gt;混合云引擎（hybrid cloud engine）&lt;/span&gt;和&lt;span&gt;平台即服务的微服务及云原生架构（platform-as-a-service for Microservices &amp;amp; cloud-native architecture）&lt;/span&gt;，Kubernetes得到了快速的普及。阅读这篇文章（https://vedcraft.com/tech-trends/solution-options-for-choosing-kubernetes-management-strategy/）可以获得更多关于Kubernetes管理策略和方法的细节（如下所示）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;作为软件架构师，考虑到Kubernetes在行业中的广泛接受度以及作为多种技术解决方案中的基础作用，我们需要确保自己很好的掌握了Kubernetes。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39085714285714285&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0WLAbshmUfsaZgsYkpT2eaUl90icia30QpibeK8KQCicsnbKucXq6uLMtlcAob12mANXicScmyXjNK3w2w/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;875&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图F - 来源:https://vedcraft.com/tech-trends/solution-options-for-choosing-kubernetes-management-strategy/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;8 — 利用托管服务和无服务器作为基础模块&lt;/span&gt;&lt;/h1&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;作为软件架构师，重点是解决业务问题，而不仅仅是技术挑战。在云时代，托管服务是专注于交付业务价值、将技术管理留给专家的关键因素。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;云服务提供商（如AWS、Azure、Google Cloud）提供了全面的服务目录，然而作为架构师，也应该探索其他专业供应商和解决方案创业公司提供的服务。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;CNCF将托管服务和无服务器技术大致分为四个部分——工具、框架、平台和托管平台（如下所示）：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5634285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0WLAbshmUfsaZgsYkpT2eaUDcyeUPvicdS7V9rj3IDNhnmOFyIlIibbaP7092LS3MJW55PpYZ9mZB2A/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;875&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图G - 来源:https://landscape.cncf.io/serverless&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;&lt;span&gt;9 — 关注并应用零信任架构实践&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6220839813374806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0WLAbshmUfsaZgsYkpT2eaU32C09xQjMTzbVvkJaJSQLCbgEK6nL4f9XLLLWBRribDniaRKSsxH65qw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;643&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图H -来源: https://csrc.nist.gov/publications/detail/sp/800-207/archive/2019-09-23&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;10 — 试验和应用自动化趋势&lt;/span&gt;&lt;/h1&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;最后，软件架构师需要了解行业中发生的自动化趋势。对现代软件架构师来说，不断试验和应用新趋势是一项重要的工程技能。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;与构建和发布、质量工程（软件测试）以及软件部署和基础设施管理相关的自动化是作为软件架构师需要注意的三个关键领域。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;GitOps&lt;span&gt;[23]&lt;/span&gt;（一种为云原生应用实现持续部署的方法）和MLOps&lt;span&gt;[24]&lt;/span&gt;（一组为企业成功运行AI的最佳实践）是根据需要应用新趋势的新例子。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;总之，这些技巧可以帮助我们建立基于现代实践的解决方案体系架构，但本质上它取决于所考虑的系统和相关的上下文。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49333333333333335&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0WLAbshmUfsaZgsYkpT2eaUg5HorS8BBQRxYxKZhXv6fthDQQHoIAPQEvXSDvFSyfaBEOpXgYeCxQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现代软件架构师的10个技巧&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;References:&lt;/span&gt;&lt;br/&gt;[1] Top 10 Tips You Should Know As A Modern Software Architect: https://ankurkumarz.medium.com/top-10-tips-you-should-know-as-a-modern-software-architect-8e602c6c998f&lt;br/&gt;[2] Spring: https://spring.io/&lt;br/&gt;[3] Play Framework: https://www.playframework.com/&lt;br/&gt;[4] Helidon：https://helidon.io/&lt;br/&gt;[5] Quarkus：https://quarkus.io/&lt;br/&gt;[6] Micronaut：https://micronaut.io/&lt;br/&gt;[7] Reactive Stack: https://spring.io/reactive&lt;br/&gt;[8] Spring GraphQL：https://spring.io/projects/spring-graphql&lt;br/&gt;[9] RSocket with Spring Boot：https://spring.io/blog/2020/03/02/getting-started-with-rsocket-spring-boot-server&lt;br/&gt;[10] Gokit：https://gokit.io/&lt;br/&gt;[11] Gomicro：https://github.com/asim/go-micro&lt;br/&gt;[12] Flask：https://flask.palletsprojects.com/&lt;br/&gt;[13] Bottle：https://bottlepy.org/docs/dev/&lt;br/&gt;[14] Falcon：https://falcon.readthedocs.io/&lt;br/&gt;[15] Nameko：https://github.com/nameko/nameko&lt;br/&gt;[16] Molecular：https://moleculer.services/&lt;br/&gt;[17] Nest：https://nestjs.com/&lt;br/&gt;[18] Event Mesh：https://solace.com/what-is-an-event-mesh/&lt;br/&gt;[19] Cloud Native Computing Foundation：https://www.cncf.io/&lt;br/&gt;[20] CNCF Charter：https://github.com/cncf/foundation/blob/master/charter.md&lt;br/&gt;[21] NIST（National Institute of Standards and Technology)：https://www.nist.gov/&lt;br/&gt;[22] Zero-Trust Architecture White Paper：https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-207.pdf&lt;br/&gt;[23] GitOps：https://about.gitlab.com/topics/gitops/&lt;br/&gt;[24] MLOps：https://blogs.nvidia.com/blog/2020/09/03/what-is-mlops/&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。&lt;br/&gt;微信公众号：DeepNoMind&lt;/p&gt;&lt;/blockquote&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dde41aa2cc425d46d3c4982929361011</guid>
<title>Spring Boot 使用的经典错误-找不到Bean了</title>
<link>https://toutiao.io/k/iedn9f7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;Spring对于Java开发者来说，熟悉程度大概与word、excel这些office软件相当。这是个人猜测，大家也可以来投个票：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;span class=&quot;vote_area&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;它简单易用，极大降低了开发人员的门槛。&lt;span&gt;但是，它毕竟是建立在很多约定俗成的规则之上。&lt;span&gt;而这些约定并不一定是你所熟悉的。所以，当你遇到问题时，很有可能就抓狂了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;前段时间我做了网络编程的系列课程，过年了，咱们换换脑子。争取不太烧脑的情况下，来一个spring避坑指南的系列课程。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在使用 @Autowired 时，不管你是菜鸟级还是专家级的 Spring 使用者，都应该制造或者遭遇过类似的错误：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;required a bean of type &#x27;xxx&#x27; that could not be found&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在构建 Web 服务时，我们常使用 Spring Boot 来快速构建。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如，使用下面的包结构和相关代码来完成一个简易的 Web 版 HelloWorld：其中，负责启动程序的 Application 类定义如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@SpringBootApplication&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Application&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        SpringApplication.run(Application.class, args);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;提供接口的 HelloWorldController 代码如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@RestController&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;HelloWorldController&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@GetMapping(path = &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&quot;hi&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; String hi() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;新年快乐！&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不出意外，访问时结果应该如下所示：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3583690987124464&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;466&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlib9s4YRCefQopMmSOqAx9auVm9qnkpqAok5FGFSohN0OIoEWbR8V11Z4hj0zCVlaZ3CDHescw82nA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其中 HelloWorldController 因为添加了 @RestController，最终被识别成一个 Controller 的 Bean。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是，假设有一天，我们希望用更清晰的包层次和结构来管理时，可能将&lt;span class=&quot;code-snippet__title&quot;&gt;Application&lt;/span&gt;&lt;span&gt; &lt;/span&gt;移动到一个单独的目录下，比如下面这样：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6904231625835189&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;449&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlib9s4YRCefQopMmSOqAx9au0Xb27MKGKEU6xUI4dEGHibORsl60iaiaHt1ty69oQuEZleS2UHUEA5Wvg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;这时候访问就404了：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2914622178606477&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1019&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlib9s4YRCefQopMmSOqAx9auBXmjgvzfXQ8WZVL65tIngEbXjOzAf687J6UbW2WXicHoYUpVDMoMY1g/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;实际上，我们没有改变任何代码，只是改变了包的结构，但是我们会发现这个 Web 应用失效了，即不能识别出 HelloWorldController 了。也就是说，我们找不到 HelloWorldController 这个 Bean 了。这是为何？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;解析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;要了解 HelloWorldController 为什么会失效，就需要先了解之前是如何生效的。对于 Spring Boot 而言，关键点在于 Application.java 中使用了 SpringBootApplication 注解。而这个注解继承了另外一些注解，具体定义如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@&lt;span class=&quot;code-snippet__keyword&quot;&gt;EnableAutoConfiguration&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@ComponentScan(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    excludeFilters = {@&lt;span class=&quot;code-snippet__keyword&quot;&gt;Filter&lt;/span&gt;(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    type = FilterType.CUSTOM,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    classes = {&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;TypeExcludeFilter&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.class&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;), @&lt;span class=&quot;code-snippet__keyword&quot;&gt;Filter&lt;/span&gt;(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    type = FilterType.CUSTOM,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    classes = {&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;AutoConfigurationExcludeFilter&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.class&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;public&lt;/span&gt; @&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; SpringBootApplication {&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从定义可以看出，SpringBootApplication 开启了很多功能，其中一个关键功能就是 ComponentScan&lt;/span&gt;。&lt;span&gt;当 Spring Boot 启动时，ComponentScan 的启用意味着会去扫描出所有定义的 Bean，那么扫描什么位置呢？这是由 ComponentScan 注解的 basePackages 属性指定的&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;直接使用的是 SpringBootApplication 注解定义的 ComponentScan，它的 basePackages 没有指定，所以默认为空（即{}）。此时扫描的是什么包？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当 basePackages 为空时，扫描的包会是 declaringClass 所在的包，在本案例中，declaringClass&lt;/span&gt; 就是 Application，所以扫描的包其实就是它所在的包。因为后来移动目录后 Application 所在的包为 com.brmayi.concise.startup ，没有包含   HelloWorldController  所在的 com.brmayi.concise 。就扫描不到了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这就是为什么一般咱们都会把 Application 放到项目最外层目录。这样，它所在的目录以及子目录都可以扫描到。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6872146118721462&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;438&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlib9s4YRCefQopMmSOqAx9au5cWDpArOZeicccJljxnFibhLQLk06OhNzktu6cNhASOgwA4sa5PicGiaMw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，我们也可以使用 @ComponentScans 来修复问题&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;福利时间&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有朋友让我拉群发红包。问题是：拉了群我说点啥呢。12月份的时候，我一看今年用户量增长很少，发力写了几篇文章。同时，也得到了贵人相助，用户增长终于完成了“KPI”。虽然我不知道贵人具体是谁，但是肯定和咱们用户朋友有很大的关系。答谢是应该的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;要做就做大的，我拉群，大家帮忙拉人进去，争取拉满500人。聊天你们聊，我只管过年发红包。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2700296735905046&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;674&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlib9s4YRCefQopMmSOqAx9aunSzJvdzevtQUggImbDBM6v7yicctUzN3mKjSBodUr5Xmcu70DjYq4Tw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>