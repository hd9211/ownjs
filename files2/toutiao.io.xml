<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>dd3b3e681d4b6791d7f56e763dbba2f6</guid>
<title>Spring Kafka的bug导致超时问题</title>
<link>https://toutiao.io/k/eq9tsj2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这是我们团队负责的一个不太核心的服务。之前与外部交互时应外部要求由普通kafka集群改成加密kafka集群。我们是数据生产端。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.20833333333333334&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicwfQ6ibI3fHObwX9RzQHFBSt3qaTuH9dmVOE5MbT9U1PbmDu4EBMrIJDbqgkQHmp68JUBIw2klKqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;576&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;改的过程中并跑上线，60%的请求耗时增加了2倍，也还是在百毫秒的量级可以接受。但是每次重启的第一个请求要5s以上，会超过；运行过程中，一两个月也会有一次超时。因为我们有三次重试，整体没有影响成功率。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上线的时候我们问过网络组，还专门请教过公司专业负责kafka的团队。结论是：第一，这个慢是外部交互方的问题，不是咱们这边可以处理的；第二，参数上也没有什么可以调优的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们团队内部还是不信邪，调了几个参数，加测之后上线了。频繁度降到了现在的一两个月一次超时，但是没有根治。因为本身这个服务不是特别核心，本身外部是允许有一定失败率的，而且现在实际上也没有失败，几年内业务量也是很平稳的：1分钟4笔。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而我上班时间的状态基本上是我站在两个人中间，我目的是想问一个人问题，结果却先要回答另外一个人的问题，这时候还会出现第四个人说别的事。这个优先级排不上。但是心疼开发小哥哥，每一两个月就要处理一下因为这件事引起的告警。虽然实际不影响，告警出来了，我们就要排查核对是否还是这个问题，并且确实通过重试将消息推送出去了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以本次利用周末，希望可以根治这个疑难杂症，减少运维成本。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;思路&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;前期已经明确了这个外部的加密集群建立连接和数据传输速度都慢于之前的普通集群。之所以第一次慢和每一两个月会慢一次都是连接断开重连造成的。之前我们进行过参数调优，调优做的就是因为1分钟4笔请求，线上以最小部署单元3台机器部署，每台机器1分钟预计处理一笔请求。根据这个数据调整了空闲自动断开连接的时间间隔，保证连接不会因为空闲自动断开。线上验证有效，也侧面证实了是连接过程慢引起的超时。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因为建立连接过程慢，这个主要是外部提供的集群就是如此。既然目前并不影响实际发送成功率。人家代表的是大佬，我们也不好太强硬的去推他们解决。所以我的思路有两个：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第一，探索将建立连接与发送数据分离的可行性：程序启动后先将连接建立好再提供服务。如果生产端是这样实现的。那也许还可以进行连接自动探测，如果连接断开则自动重连，不要等发送数据时再发现连接已断开。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第二，其实第一种思路的可行性渺茫，只是需要验证一下自己的想法。一般的这种消息中间件，消费端是这样实现的。但是生产端采用了更简单的方式：读写数据的时候再探测连接是否可用，不可用则重新建立连接。这种用在发送本来就是异步的，对发送延迟本身敏感度也不高的场景。生产端本来就是这种场景，并且通过测试实际上也确实是在发送时建立的第一次连接。kafka生产端原本就是这种设计的可能性极大。如果是这种情况，那就在生产端真正使用异步，给调用方返回“受理成功”，保证调用方不超时。自己再通过接受回调保证实际的成功。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个事情真要做，还有两个隐形需求：&lt;/p&gt;&lt;p&gt;1、因为外部有需求，数据可以偶尔少发，但是不能重复发送。所以不能使用业务级别的数据发送来实现探测功能。重试也要保证上条确实没有收到。&lt;/p&gt;&lt;p&gt;2、改造不能太大，研发成本要小。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;过程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因为我在网上搜到的这方面都是入门级，没有什么解决这个问题的相关资料。所以采用的主要方法是读源码和官方文档。当然，本文的方法是有前提知识储备基础的。就是&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486403&amp;amp;idx=1&amp;amp;sn=9dbbda3df1deeb5f43c8b7f2cdd87b97&amp;amp;chksm=fafde16dcd8a687be735bf315fa50773cd61ac48f47cd1a1304c792bc1fafa31b4a3705dd9a3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《白话TCP/IP原理》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《白话TCP/IP原理》&lt;/a&gt;系列的相关内容。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;步骤一，查询版本特性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们目前用到的kafka客户端版本是&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.kafka&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-kafka&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.5.8.RELEASE&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.kafka&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;kafka-clients&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.5.0&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;spring-kafka对应的官网的大版本是2.5，所以先点开了2.5.17.RELEASE对应的参考文档。看到一句有用信息：&lt;span/&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;123&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;The default consumer and producer factories can now invoke a callback whenever a consumer or producer is created or closed.&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;默认消费者和生产者工厂现在已经可以在生产者和消费者创建和关闭时引发一个回调。耗时的连接建立过程是可以监听的，我们可以通过打日志进行监控。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤二，查源码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.25217391304347825&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8NPJ8mQAQ1q8sXqPQuGrJ4Ha3K1TVibiat2DibURc51ic33R2pcTPXeQSu5SAmQreTP0tML8HiaBu6DFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;805&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先我们看一下类图，看不清楚没有关系。看这里就好：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先发现Producer、Consumer和Sender都是通过KafkaClient（接口），也就是NetworkClient（实现类）进行网络活动的。其次发现NetworkClient是在传输层和应用层之间起了一个缓冲的作用，解耦了各个部件。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;Producer、Consumer和AdminClient主要管理requests；NetworkClient主要管理connection；Selector主要管理sockets channel。这些被管理对象我在之前的网络系列里都讲过。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果不看代码，我站在设计者角度结合类图猜想：生产端实际使用的是KafkaTemplate的send方法，具体的参数都是由DefaultKafkaProducerFactory接收。实际上连接的建立是Producer类进行。而在Producer类依赖于NetworkClient。而实际上进行连接应该在Sender类。Sender是一个Runnable异步线程来做，那实际建立连接的是run方法中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我跟踪源码验证了猜想。NetworkClient里有个initiateConnect的私有方法，是建立连接用的，跟踪它就可以知道调用的地方。跟踪下来，主要入口在NetworkClient的poll方法，注释如下：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     *                must be non-negative. The actual timeout will be the minimum of timeout, request timeout and&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     *                metadata timeout&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     * &lt;span class=&quot;code-snippet__doctag&quot;&gt;@param&lt;/span&gt; now The current time in milliseconds&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     * &lt;span class=&quot;code-snippet__doctag&quot;&gt;@return&lt;/span&gt; The list of responses received&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;ClientResponse&amp;gt; &lt;span class=&quot;code-snippet__title&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; timeout, &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; now)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;人家明确说了是读写时才会调用。证实了思路一不可行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;步骤三，查自身的代码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;按照思路二，进行异步化。本身生产端就应该是异步的，为什么异步没有生效呢？结合KafkaTemplate的send方法源代码和项目中自己写的代码。异步部分大体是这样：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; SettableListenableFuture future = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; SettableListenableFuture();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        future.&lt;span class=&quot;code-snippet__keyword&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;OK&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        future.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        future.addCallback((sendResult) -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;成功&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }, r -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;失败&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;============end==============&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;就是说KafkaTemplate的异步是靠使用SettableListenableFuture实现的，实际上它的set方法会马上触发callback，是同步的。代码是先同步调用set，并且还手动调用了get（这个方法会等待直到返回结果）。所以整体是同步的。或者直接这么看，future实现异步要有一个Callable或者Runnable的线程方法，人家SettableListenableFuture第一行源码就禁用了Callable。这个我看了2.5.17.RELEASE这个更高版本的spring-kafka，实现没有做更改。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;也就是说spring-kafka自身起码在2.5.X版本里异步没有起到作用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;问题清楚了修改也很简单，比如可以加个异步注解将整个发送方法做异步，重试等逻辑也放到这个方法中。给调用方只返回受理成功。具体怎么解决交给开发小哥哥。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;幸亏我上周已经提前规划好周一要休假。否则现在都2点半了明天上班也没精神。主要时间花在异步不生效的问题上。其实排查异步不生效的思路是很简单清晰的。耗时长是因为：第一，不敢相信spring官方实现的，竟然使用异步的代码实际效果没有异步；第二，关于异步我在网上搜索了一下，都是按照项目中配置的那样。官方这样说，大家这样说，我总得考虑是不是自己搞错了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以我反复的验证、反复的debug之后也不敢下结论。仔细研究了源码仍然不敢下结论。直到终于搜索到一篇文章说要实现异步除了要使用addCallback之外还要加异步标签。人间清醒的我，马上意识到文章实际用了两种不同方法实现异步。作者之所以认为这是一个方法的两个部分大概也是发现其实spring-kafka的异步没好使吧。&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>772d677df0be63a20103914914a8ee21</guid>
<title>如何使用 Prometheus 和 Grafana 优雅的实现服务器可视化</title>
<link>https://toutiao.io/k/ypeezzt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Prometheus 简介&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Prometheus 是一个开源监控工具，实现了高维数据模型。Prometheus 有多种数据可视化模式，其中一种是集成 Grafana。Prometheus 以高效的自定义格式将时间序列数据存储在内存和本地磁盘上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Prometheus 有许多客户端可用于轻松监控服务，也可以轻松创建自定义客户端。每台服务器的可靠性都是独立的，仅依赖本地存储。用 Golang 编程语言编写，所有二进制文件都是静态链接的，易于部署。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Prometheus 采用拉取策略而不是推送策略，即 Prometheus 以一定的时间间隔从 exporter 那里拉取数据，而不是 exporter推送数据到 Prometheus。这种方式有其自身的优点和缺点，但我们不讨论这些细节。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Grafana 简介&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Grafana 是一款开源可视化和分析软件，它允许你查询、可视化、提醒和探索您的指标，无论这些指标存储在哪里。Grafana 支持数十种数据库，我们可以创建一个仪表盘来可视化它们全部。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Grafana 还提供报警，直观地定义阀值，并通过 Slack、 PagerDuty 和其他平台获得通知。Grafana 还提供了多种选项来查看我们的数据，从热力图到直方图，从图形到地理地图。Grafana 有大量的可视化选项可以帮助我们更好地理解数据。我正在使用 Ubuntu 18.04，并将显示与其相关的整个配置。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;3&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Prometheus 安装&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41714285714285715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP24RZHuSIxUnft3eGzkVmfpSss4GP3xvyicPP9t9kKZCllCuGGahTiaBfhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ wget https://github.com/prometheus/prometheus/releases/download/v2.21.0/prometheus-2.21.0.linux-amd64.tar.gz&lt;br/&gt;&lt;br/&gt;$ tar -xzf prometheus-2.21.0.linux-amd64.tar.gz&lt;br/&gt;&lt;br/&gt;$ &lt;span&gt;cd&lt;/span&gt; prometheus-2.21.0.linux-amd64/&lt;br/&gt;&lt;br/&gt;$ ./prometheus&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装非常简单，执行这些命令将会让 Prometheus 服务器在端口 9090 中运行。Prometheus 在端口9090上的仪表板如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2757142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP241aE4Ha3IovXDFnfDbqRL7mRAVP3KticyxulHY3hBQ1MAAXZbiamGhicFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如前所述，从 Prometheus 中抓取的指标发生在恒定的时间段内，因此可以在路径 /metrics 中查看它们。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5171428571428571&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP24kFzrGez6AFyw7RjE5ibCRjf9m2HMhibkjhQOsic6bGlXORJjicj4JIwEaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44571428571428573&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP24nzMibL76Ro9J4hQ2l4ibGZIUJKTtbYeWHicrqHWWiaXiayVvYrwHhhrSI6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些指标用于形成具有各种聚合函数的复杂表达式，以我们想要的形式进行可视化，这在 promql 的帮助下基本上是可能的。Prometheus 中的图形可视化非常基本，没有提供太多自定义，因此我们将使用 Grafana。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;4&lt;/span&gt;&lt;/span&gt;&lt;span&gt;节点 Exporter 安装&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5357142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP24icpAI64JDPMq6GQw1YagUQqgvy0WMoKzBzIXLwy0mZ81sRMUk9SUD1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ wget https://github.com/prometheus/node_exporter/releases/download/v1.0.1/node_exporter-1.0.1.linux-amd64.tar.gz&lt;br/&gt;$ tar -xzf node_exporter-1.0.1.linux-amd64.tar.gz&lt;br/&gt;$ &lt;span&gt;cd&lt;/span&gt; node_exporter-1.0.1.linux-amd64/&lt;br/&gt;$ ./node_exporter&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述命令将安装节点 exporter 并在端口 9100 上运行，并且可以从 /metrics 扩展中抓取指标。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我创建了 3 个虚拟机并在所有虚拟机中安装了节点 exporter，以提供更好的可视化效果。所以在安装之后，我们必须告诉 Prometheus 从哪里抓取指标，这可以通过编辑 prometheus.yml 文件来完成。我们只需要在 scrape_configs 中添加一个新作业，指定目标中的 IP 地址和端口。在 prometheus.yml 文件中添加目标并重新启动 Prometheus 服务器后，我们可以在仪表板以及 /targets 路径中看到新目标及其状态。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP24sZIWYlgmHFyTKFje3hvDqA5Wkqb2naicX5PkAt98nUZfWWQUfZmPfGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3242857142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP248CoewibKticMOHCCsNf3Hawq16hsSickuQDzic5MW9HQYslNOcGRm2M3ag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;确保所有目标都已启动，如果没有，请检查是否为该 VM 实例开放了 9100 端口。你还可以查看 Prometheus 从每个 exporter 抓取的时间以及上次抓取的时间。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;5&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Grafana 安装&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5357142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP24RwzzPAyNeAialDEYIYJdVSaQO907FkT8TMNSMuV0twGicyxIpJNfclIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$wget&lt;/span&gt; https://dl.grafana.com/oss/release/grafana-7.1.5.linux-amd64.tar.gz&lt;br/&gt;&lt;span&gt;$tar&lt;/span&gt; -xzf grafana-7.1.5.linux-amd64.tar.gz&lt;br/&gt;&lt;span&gt;$cd&lt;/span&gt; grafana-7.1.5.linux-amd64/&lt;br/&gt;$./bin/grafana-server&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过运行上述命令即可完成安装，Grafana 运行在端口 3000。默认的用户名和密码均为“admin”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们进入仪表板，我们需要添加一个数据源，在我们的例子中是 Prometheus。我们只需要提供 Prometheus URL 并点击保存和测试按钮。如果我们看到一个成功的提示框，说数据源正在工作，那么我们就可以开始了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.51&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP24gXr0aWmWapKkCLMJ2jN9zEMC4l692YvYvmJNKYYbg917ONLf9VkqWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用自定义的查询语句创建自己的仪表板和面板，但这是一项乏味的工作。因此，为了简化我们的工作，其他用户已经创建了一些仪表板，我们可以使用相同的仪表板并根据我们的需要调整表达式。我使用的是 1860 和 405，这些是我们导入仪表板的唯一ID。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.58&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP24vj5gzbaIP3JIzSkwkrRDGH41dia38Jekm5pibiaHLkGfIibzYoS1xHy6Tw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP24u5Bsnmlhu0IiaG4EMMueZRibXicIl4cYt2qAiatXZdlo93IYJQrx947O4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;导入完成后，我们会看到基于其表达式和时间范围的图表。你可以通过将时间范围减少到 5 分钟来深入了解。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48714285714285716&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP244ADAW9ZB4iaYftWKm1cONuficgKXsbL1ibenj2Z4PlFVDd8svNo07vmNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4857142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP24ZdE24lrmYDI14FFKrJbDaZLKBysT236W3FKjWsO1luJIaLCKL9FAwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48428571428571426&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP24uLKib2s8nYgeRFApT4YVUkmiaRyjJJHrFxxS8LeqVcGrltcYl2vicmzuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Grafana 还允许我们查看合并多个 exporter的表单，以便更好地进行比较。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48428571428571426&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP24L8omeTepzneFS0tR2PXqKibyOKrLIjKmltQTJFExtVLGoibxI7NZpibyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4857142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP24kjSCVicvT1wGticLthjLKCVTXGBESgEOibZHJBiaDH0EskBqFsnJ1DgwUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在上面的图片中，我们可以看到所有三个节点 exporter 的数据都被可视化了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上总结了 Prometheus 和 Grafana 的基本设置，用来可视化节点指标数据。如果你觉得有帮助，请点赞分享。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;原文链接：https://medium.com/javarevisited/prometheus-grafana-setup-to-visualize-your-servers-924773b83f3f&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>029f60a4841bb2d94646153a6f775e21</guid>
<title>新一代消息队列 Pulsar</title>
<link>https://toutiao.io/k/k4n6m77</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：joylei，腾讯 PCG 后台开发工程师&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在信息流场景，内容的请求处理、原子模块调度、结果的分发等至关重要，直接影响到内容的外显、推荐、排序等。基于消息 100% 成功的要求，我们团队对 Pulsar 进行了调研，并采用腾讯云的 TDMQ（Pulsar 版）实现消息的可靠处理。本文主要参考 Pulsar 的官方文档和技术文章，对 Pulsar 的特性、机制、原理等进行整理总结。后续我们团队计划产出多篇文章，重点聚焦分析 Pulsar 与其他消息队列(Kafka、RocketMQ 等) 的调度和写盘等，以及 Pulsar 在信息流内容链路场景的使用实践。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. Pulsar 概述&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Apache Pulsar 是 Apache 软件基金会顶级项目，是下一代云原生分布式消息流平台，集消息、存储、轻量化函数式计算为一体，采用计算与存储分离架构设计，支持多租户、持久化存储、多机房跨区域数据复制，具有强一致性、高吞吐、低延时及高可扩展性等流数据存储特性，被看作是云原生时代实时消息流传输、存储和计算最佳解决方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 是一个 pub-sub (发布-订阅)模型的消息队列系统。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1. Pulsar 架构&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 由 Producer、Consumer、多个 Broker 、一个 BookKeeper 集群、一个 Zookeeper 集群构成，具体如下图所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7134587554269175&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasqeyVq3SFb7MawCsAKX9Eg3VprUAqwQGbAhlBGiaQVyd3D7OQUgevp7CkGCaZP1nwwFiaIUtJg6o2Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;691&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Producer：数据生成者，即发送消息的一方。生产者负责创建消息，将其投递到 Pulsar 中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Consumer：数据消费者，即接收消息的一方。消费者连接到 Pulsar 并接收消息，进行相应的业务处理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Broker：无状态的服务层，负责接收消息、传递消息、集群负载均衡等操作，Broker 不会持久化保存元数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;BookKeeper：有状态的持久层，负责持久化地存储消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ZooKeeper：存储 Pulsar 、 BookKeeper 的元数据，集群配置等信息，负责集群间的协调(例如：Topic 与 Broker 的关系)、服务发现等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 Pulsar 的架构图上可以看出， Pulsar 在架构设计上采用了计算与存储分离的模式，发布/订阅相关的计算逻辑在 Broker 上完成，而数据的持久化存储交由 BookKeeper 去实现。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1.1. Broker 扩展&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Pulsar 中 Broker 是无状态的，当需要支持更多的消费者或生产者时，可以简单地添加更多的 Broker 节点来满足业务需求。Pulsar 支持自动的分区负载均衡，在 Broker 节点的资源使用率达到阈值时，会将负载迁移到负载较低的 Broker 节点，这个过程中分区也将在多个 Broker 节点中做平衡迁移，一些分区的所有权会转移到新的 Broker 节点。在后面 Bundle 小节会具体介绍这部分的实现。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1.2. Bookie 扩展&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;存储层的扩容，通过增加 Bookie 节点来实现。在 BooKie 扩容的阶段，由于分片机制，整个过程不会涉及到不必要的数据搬迁，即不需要将旧数据从现有存储节点重新复制到新存储节点。在后续的 Bookkeeper 小节中会具体介绍。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2. Topic&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和其他消息队列类似，Pulsar 中也有 Topic。Topic 即在生产者与消费者中传输消息的通道。消息可以以 Topic 为单位进行归类，生产者负责将消息发送到特定的 Topic，而消费者指定特定的 Topic 进行消费。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2.1. 分区 Topic（Topic-Partition）&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 的 Topic 可以分为非分区 Topic 和分区 Topic 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;普通的 Topic 仅仅被保存在单个 Broker 中，这限制了 Topic 的最大吞吐量。分区 Topic 是一种特殊类型的主题，支持被多个 Broker 处理，从而实现更高的吞吐量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对一个 Topic ，可以设置多个 Topic 分区来提高 Topic 的吞吐量。每个 Topic Partition 由 Pulsar 分配给某个 Broker ，该 Broker 称为该 Topic Partition 的所有者。生成者和消费者会与每个 Topic 分区的 Broker 创建链接，发送消息并消费消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示， Topic1 有 Partition1、 Partition2、 Partition3、 Partition4 、 Partition5 五个分区， Partition1 和 Partition4 由 Broker1 处理， Partition2 和 Partition5 由 Broker2 处理， Partition3 由 Broker3 处理。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.598&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasqeyVq3SFb7MawCsAKX9Ego23nV0FhFk3BsVVUsLYFia1qX061NmbxEm5UkNYnpDZhutt3kWKtHTQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 Pulsar 社区版的 golang-sdk 可以看出，客户端的 Producer 和 Consumer 在初始化的时候，都会与每一个 Topic-Partition 创建链接，并且会监听是否有新的 Partition，以创建新的连接。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2.2. 非持久 topic&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下， Pulsar 会保存所有没确认的消息到 BookKeeper 中。持久 Topic 的消息在 Broker 重启或者 Consumer 出现问题时保存下来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了持久 Topic ， Pulsar 也支持非持久 Topic 。这些 Topic 的消息只存在于内存中，不会存储到磁盘。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 Broker 不会对消息进行持久化存储，当 Producer 将消息发送到 Broker 时， Broker 可以立即将 ack 返回给 Producer ，所以非持久 Topic 的消息传递会比持久 Topic 的消息传递更快一些。相对的，当 Broker 因为一些原因宕机、重启后，非持久 Topic 的消息都会消失，订阅者将无法收到这些消息。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2.3. 重试 topic&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于业务逻辑处理出现异常，消息一般需要被重新消费。Pulsar 支持生产者同时将消息发送到普通的 Topic 和重试 Topic ，并指定允许延时和最大重试次数。当配置了允许消费者自动重试时，如果消息没有被消费成功，会被保存到重试 Topic 中，并在指定延时时间后，重新被消费。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2.4. 死信 topic&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 Consumer 消费消息出错时，可以通过配置重试 Topic 对消息进行重试，但是，如果当消息超过了最大的重试次数仍处理失败时，该怎么办呢？Pulsar 提供了死信 Topic ，通过配置 deadLetterTopic，当消息达到最大重试次数的时候， Pulsar 会将消息推送到死信 Topic 中进行保存。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3. 订阅（subscription）&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过订阅的方式，我们可以指定消息如何投递给消费者。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3.1. 订阅类型（Subscription type）&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 支持独占（Exclusive）、灾备（Failover）、共享（Shared）、Key_Shared 这四种订阅类型。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;独占（Exclusive）SinglePartition&lt;/p&gt;&lt;p&gt;Exclusive 下，只允许 Subscription 存在一个消费者，如果多个消费者使用同一个订阅名称去订阅同一个 Topic ，则会报错。&lt;/p&gt;&lt;p&gt;如下图，只有 Consumer A-0 可以消费数据。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3468085106382979&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasqeyVq3SFb7MawCsAKX9EgvhYSicnDpfr8U0OC8Z0iarPyEQRLibJHs9qQIzZI13NSVQBd1pBG0ITxw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;940&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;灾备（Failover）&lt;/p&gt;&lt;p&gt;Failover 下，一个 Subscription 中可以有多个消费者，但只有 Master Consumer 可以消费数据。当 Master Consumer 断开连接时，消息会由下一个被选中的 Consumer 进行消费。&lt;/p&gt;&lt;p&gt;如下图，Consumer-B-0 是 Master Consumer 。当 Consumer -B-0 发生问题与 Broker 断开连接时， Consumer-B-1 将成为下一个 Master Consumer 来消费数据。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3707165109034268&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasqeyVq3SFb7MawCsAKX9EgKe4HE7fkj5RRJIlKnv3HUJOSTmG8VbMSIPiaSRiaCu4nvJf5O8mzWPUw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;963&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;分区 Topic：Broker 会按照消费者的优先级和消费名的顺序对消费者进行排序，将 Topic 均匀地分配给优先级最高的消费者。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非分区 Topic：Broker 会根据消费者订阅的非分区 Topic 的时间顺序选择消费者。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;共享（Shared）&lt;/p&gt;&lt;p&gt;Shared 中，多个消费者可以绑定到同一个 Subscription 上。消息通过 round robin 即轮询机制分发给不同的消费者，并且每个消息仅会被分发给一个消费者。当消费者断开连接，所有被发送给消费者但没有被确认的消息将被重新处理，分发给其它存活的消费者。&lt;/p&gt;&lt;p&gt;如下图, Consumer-C-1 、 Consumer-C-2 、 Consumer-C-3 都可以订阅 Topic 消费数据。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4095634095634096&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasqeyVq3SFb7MawCsAKX9EgesL9R4icjsEkxPCqa5NBA4Mkqibcaqm3FNpk337ycrticQF6Y4poxeYDw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;962&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Key_Shared&lt;/p&gt;&lt;p&gt;Key_Shared 中，多个 Consumer 可以绑定到同一个 Subscription 。消息在传递给 Consumer 时，具有相同键的消息只会传递给同一个 Consumer 。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4315443592552026&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasqeyVq3SFb7MawCsAKX9EghokPY1XzVc0bI7bHI4ib83cr6aXoiaxfHcmNVA4IMuvQ5gIoMaWoW0nw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;913&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3.2. 订阅模式（Subscription modes）&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;订阅模式有持久化和非持久化两种。订阅模式取决于游标(cursor)的类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建订阅时，将创建一个相关的游标来记录最后使用的位置。当订阅的 consumer 重新启动时，它可以从它所消费的最后一条消息继续消费。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Durable （持久订阅）：游标是持久性的，会保留消息并保持游标记录的位置。当 Broker 重新启动时，可以从 BookKeeper 中恢复游标，消息可以从游标上次记录的位置继续消费。默认情况下，都是持久化订阅。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NonDurable（非持久订阅）：游标不是持久性的，当 Broker 宕机时，游标会丢失并无法恢复，所以消息无法继续从上次消费的位置开始继续消费。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个订阅可以有一个或多个消费者。当使用者订阅主题时，它必须指定订阅名称。持久订阅和非持久订阅可以具有相同的名称，它们彼此独立。如果使用者指定了以前不存在的订阅，则会自动创建订阅。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下，没有任何持久订阅的 Topic 的消息将被标记为已删除。如果要防止消息被标记为已删除，可以为此 Topic 创建持久订阅。在这种情况下，只有被确认的消息才会被标记为已删除。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3.3. 多主题订阅&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 Consumer 订阅 Topic 时，默认指定订阅一个主题。从 Pulsar 的 1.23.0-incubating 的版本开始， Pulsar 消费者可以同时订阅多个 Topic 。可以通过两种方式进行订阅：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;正则表达式，例如：persistent://public/default/finance-.*&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;明确指定 Topic 列表&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. Pulsar 生产者 （Producer）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Producer 是连接 topic 的程序，它将消息发布到一个 Pulsar broker 上。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1. 访问模式&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息生成者有多种模式访问 Topic ，可以使用以下几种方式将消息发送到 Topic 。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Shared：默认情况下，多个生成者可以将消息发送到同一个 Topic。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Exclusive：在这种模式下，只有一个生产者可以将消息发送到 Topic ，当其他生产者尝试发送消息到这个 Topic 时，会发生错误。只有独占 Topic 的生产者发生宕机时（Network Partition ）该生产者会被驱逐，新的生产者才能产生并向 Topic 发送消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;WaitForExclusive：在这种模式下，只有一个生产者可以将消息发送到 Topic 。当已有生成者和 Topic 建立连接时，其他生产者的创建会被挂起而不会产生错误。如果想要采用领导者选举机制来选择消费者的话，可以采用这种模式。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2. 路由模式&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当将消息发送到分区 Topic 时，需要指定消息的路由模式，这决定了消息将会被发送到哪个分区 Topic 。Pulsar 有以下三种消息路由模式，RoundRobinPartition 为默认路由模式。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;RoundRobinPartition：如果消息没有指定 key，为了达到最大吞吐量，生产者会以 round-robin （轮询）方式将消息发布到所有分区。请注意 round-robin 并不是作用于每条单独的消息，而是作用于延迟处理的批次边界，以确保批处理有效。如果消息指定了 key，分区生产者会根据 key 的 hash 值将该消息分配到对应的分区。这是默认的模式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SinglePartition：如果消息没有指定 key，生产者将会随机选择一个分区，并发布所有消息到这个分区。如果消息指定了 key，分区生产者会根据 key 的 hash 值将该消息分配到对应的分区。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CustomPartition：自定义模式，用户可以创建自定义路由模式，通过实现 MessageRouter 接口实现自定义路由规则。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3. 批量处理&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 支持对消息进行批量处理。批量处理启用后， Producer 会在一次请求中累积并发送一批消息。批量处理时的消息数量取决于最大消息数（单次批量处理请求可以发送的最大消息数）和最大发布延迟（单个请求的最大发布延迟时间）决定。开启批量处理后，积压的数量是批量处理的请求总数，而不是消息总数。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3.1. 索引确认机制&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下，只有 Consumer 确认了批量请求中的所有消息，这个批量请求才会被认定为已处理。当这批消息没有全部被确认的情况下，发生故障时，会导致一些已确认的消息被重复确认。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了避免 Consumer 重复消费已确认的消息， Pulsar 从 Pulsar 2.6.0 开始采用批量索引确认机制。如果启用批量索引确认机制， Consumer 将筛选出已被确认的批量索引，并将批量索引确认请求发送给 Broker 。Broker 维护批量索引的确认状态并跟踪每批索引的确认状态，以避免向 Consumer 发送已确认的消息。当该批信息的所有索引都被确认后，该批信息将被删除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下，索引确认机制处于关闭状态。开启索引确认机制将产生导致更多内存开销。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3.2. key-based batching&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;key_shared 模式下，Broker 会根据消息的 key 来分发消息，但默认的批量处理模式，无法保证将所有的相同的 key 都打包到同一批中，而且 Consumer 在接收到批数据时，会默认把第一个消息的 key 当作这批消息的 key ，这会导致消息的错乱。因此 key_shared 模式下，不支持默认的批量处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;key-based batching 能够确保 Producer 在打包消息时，将相同 key 的消息打包到同一批中，从而 consumer 在消费的时候，也能够消费到指定 key 的批数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没有指定 key 的消息在打包成批后，这一批数据也是没有 key 的， Broker 在分发这批消息时，会使用 NON_KEY 作为这批消息的 key 。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4. 消息分块&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启用分块后，如果消息大小超过允许发送的最大消息大小时， Producer 会将原始消息分割成多个分块消息，并将分块消息与消息的元数据按顺序发送到 Broker。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Broker 中，分块消息会和普通消息以相同的方式存储在 Ledger 中。唯一的区别是， Consumer 需要缓存分块消息，并在接收到所有的分块消息后将其合并成真正的消息。如果 Producer 不能及时发布消息的所有分块， Consumer 不能在消息的过期时间内接收到所有的分块，那么 Consumer 已接收到的分块消息就会过期。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Consumer 会将分块的消息拼接在一起，并将它们放入接收器队列中。客户端从接收器队列中消费消息。当 Consumer 消费到原始的大消息并确认后， Consumer 就会发送与该大消息关联的所有分块消息的确认。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4.1. 处理一个 producer 和一个订阅 consumer 的分块消息&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示，当生产者向主题发送一批大的分块消息和普通的非分块消息时。假设生产者发送的消息为 M1，M1 有三个分块 M1-C1，M1-C2 和 M1-C3。这个 Broker 在其管理的 Ledger 里面保存所有的三个块消息，然后以相同的顺序分发给消费者（独占/灾备模式）。消费者将在内存缓存所有的块消息，直到收到所有的消息块。将这些消息合并成为原始的消息 M1，发送给处理进程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2538265306122449&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasqeyVq3SFb7MawCsAKX9EgAUmoAEDdXEup3KTG2qbAPXibUEBzH7087EYDAC0kxZC8xEVp8Gxgj2g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;784&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4.2. 多个生产者和一个生产者处理块消息&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当多个生产者发布块消息到单个主题，这个 Broker 在同一个 Ledger 里面保存来自不同生产者的所有块消息。如下所示，生产者 1 发布的消息 M1，M1 由 M1-C1, M1-C2 和 M1-C3 三个块组成。生产者 2 发布的消息 M2，M2 由 M2-C1, M2-C2 和 M2-C3 三个块组成。这些特定消息的所有分块是顺序排列的，但是其在 Ledger 里面可能不是连续的。这种方式会给消费者带来一定的内存负担。因为消费者会为每个大消息在内存开辟一块缓冲区，以便将所有的块消息合并为原始的大消息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39878048780487807&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasqeyVq3SFb7MawCsAKX9EgVtFT238xHrSH182e6k3QkkmSDyz59ItfL6vHNhKnbSaFm6DVMIB6EQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;820&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. Pulsar 消费者 （Consumer）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Consumer 是通过订阅关系连接 Topic ，接收消息的程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Consumer 向 Broker 发送 flow permit request 以获取消息。在 Consumer 端有一个队列，用于接收从 Broker 推送来的消息。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1. 消息确认&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 提供两种确认模式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;累积确认：消费者只需要确认最后一条收到的消息，在此之前的消息，都不会被再次发送给消费者。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单条确认：消费者需要确认每条消息并发送 ack 给 Broker 。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7605633802816901&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasqeyVq3SFb7MawCsAKX9EgFcjMguIs1mq4VHNpyJAb1WialUlaLoE8EkKjwRnVveJgjEXcnDR21cQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1420&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图，上方为累积确认模式，当消费者发送 M12 的确认消息给 Broker 后， Broker 会把 M12 之前的消息和 M12 一样都标记为已确认。下方为单条确认模式，当消费者发送 M7 的确认消息给 Broker 后， Broker 会把 M7 这条消息标记为已确认。当消费者发送 M12 的确认消息给 Broker 后， Broker 会把 M12 这条消息标记为已确认。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，订阅模式中的 shared 模式是不支持累积确认的。因为该订阅模式下的每个消费者都能消费数据，无法保证单个消费者的消费消息的时序和顺序。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1.1. AcknowledgmentsGroupingTracker&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息的单条确认和累积确认并不是直接发送确认请求给 Broker，而是把请求转交给 AcknowledgmentsGroupingTracker 处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了保证消息确认的性能，并避免 Broker 接收到非常高并发的 ack 请求，Tracker 默认支持批量确认，即使是单条消息的确认，也会先进入队列，然后再一批发往 Broker。在创建 consumer 的时候，可以设置 acknowledgementGroupTimeMicros，默认情况下，每 100ms 或者堆积超过 1000 时，AcknowledgmentsGroupingTracker 会发送一批确认请求。如果设置为 0，则每次确认消息后，Consumer 都会立即发送确认请求。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2. 取消确认&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 Consumer 无法处理一条消息并想重新消费时， Consumer 可以发送一个取消确认的消息给 Broker ， Broker 会重新将这条消息发送给 Consumer 。如果启用了批量处理，那这一批中的所有消息都会重新发送给消费者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息取消确认也有单条取消模式和累积取消模式 ，取决于消费者使用的订阅模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Exclusive 模式和 Failover 订阅模式中，消费者仅仅只能对收到的最后一条消息进行取消确认。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Shared 和 Key_Shared 的订阅类型中，消费者可以单独否定确认消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果启用了批量处理，那这一批中的所有消息都会重新发送给消费者。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2.1. NegativeAcksTracker&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;取消确认和其他消息确认一样，不会立即请求 Broker，而是把请求转交给 NegativeAcksTracker 进行处理。Tracker 中记录着每条消息以及需要延迟的时间。Tracker 默认是 33ms 左右一个时间刻度进行检查，默认延迟时间是 1 分钟，抽取出已经到期的消息并触发重新投递。Tracker 存在的意义是为了合并请求。另外如果延迟时间还没到，消息会暂存在内存，如果业务侧有大量的消息需要延迟消费，还是建议使用 reconsumeLater 接口。NegativeAck 唯一的好处是不需要每条消息都指定时间，可以全局设置延迟时间。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3. redelivery backoff 机制&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下可以使用取消确认来达到处理消息失败后重新处理消息的目的，但通过 redelivery backoff 可以更好的实现这种目的。可以通过指定消息重试的次数、消息重发的延迟来重新消费处理失败的消息。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4. 确认超时&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了取消确认和 redelivery backoff 机制外，还可以通过开启自动重传递机制来处理未确认的消息。启用自动重传递后，client 会在 ackTimeout 时间内跟踪未确认的消息，并在消息确认超时后自动向代理重新发送未确认的消息请求。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果开启了批量处理，那这批消息都会重新发送给 Consumer 。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;与确认超时相比，取消确认会更合适。因为取消确认能更精确地控制单个消息的再交付，并避免在消息处理时引起的超过确认超时而导致无效的再重传。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.5. 消息预拉取&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Consumer 客户端 SDK 会默认预先拉取消息到 Consumer 本地，Broker 侧会把这些已经推送到 Consumer 本地的消息记录为 pendingAck，这些消息既不会再投递给别的消费者，也不会 ack 超时，除非当前 Consumer 被关闭，消息才会被重新投递。Broker 侧有一个 RedeliveryTracker 接口，这个 Tracker 会记录消息到底被重新投递了多少次，每条消息推送给消费者时，会先从 Tracker 的哈希表中查询一下重投递的次数，和消息一并推送给消费者。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.6. 未确认的消息处理&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果消息被消费者消费后一直没有确认怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;unAckedMessageTracker 中维护了一个时间轮，时间轮的刻度根据 ackTimeout 、tickDurationInMs 这两个参数生成，每个刻度时间= ackTimeout / tickDurationInMs。新追踪的消息会放入最后一个刻度，每次调度都会移除队列头第一个刻度，并新增一个刻度放入队列尾，保证刻度总数不变。每次调度，队列头刻度里的消息将会被清理，unAckedMessageTracker 会自动把这些消息做重投递。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重投递就是客户端发送一个 redeliverUnacknowledgedMessages 命令给 Broker。每一条推送给消费者但是未 ack 的消息，在 Broker 侧都会有一个集合来记录（pengdingAck），这是用来避免重复投递的。触发重投递后，Broker 会把对应的消息从这个集合里移除，然后这些消息就可以再次被消费了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. Pulsar 服务端&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Broker 是 Pulsar 的一个无状态组件，主要负责运行以下两个组件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;http 服务：提供为生产者和消费者管理任务和 Topic 查找的 REST API。Producer 通过连接到 Broker 来发送消息， Consumer 通过连接到 Broker 来接收消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调度器；提供异步 http 服务，用于二进制数据的传输。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1. 消息确认与留存&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar Broker 会默认删除已经被所有 Consumer 确认的消息，并以 backlog 的方式持久化存储所有未被确认的内消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 的 message retention(消息留存) 和 message expiry (消息过期)这两个特性可以调整 Broker 的默认设置。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Message retention: 保留 Consumer 已确认的消息。&lt;/p&gt;&lt;p&gt;通过留存规则的设定，可以保证已经被确认且符合留存规则的消息持久地保存在 Pulsar 中，而没有被留存规则覆盖、已经被确认的消息会被删除。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.22319262493934983&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasqeyVq3SFb7MawCsAKX9EgE4IKdD3OSgUficmr7v6yAiaRUwhlfQs06LApL861HdiaSxqic9jqg7icsBQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2061&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Message expire（消息过期）：设置未确认消息的存活时长（TTL）。&lt;/p&gt;&lt;p&gt;通过设置消息的 TTL，有些即使还没有被确认，但已经超过 TTL 的消息，也会被删除。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24155844155844156&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasqeyVq3SFb7MawCsAKX9EgeKR1wn6xXAGytse23o1MlXIlmxYGunA31gXFKFrwaQq0sCjh2lxmog/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1925&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2. 消息去重&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现消息去重的一种方式是确保消息仅生成一次，即生产者幂等。这种方式的缺点是把消息去重的工作交由应用去做。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Pulsar 中， Broker 支持配置开启消息去重，用户不需要为了消息去重去调整 Producer 的代码。启用消息去重后，即使一条消息被多次发送到 Topic 上，这条消息也只会被持久化到磁盘一次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图，未开启消息去重时， Producer 发送消息 1 到 Topic 后， Broker 会把消息 1 持久化到 BookKeeper ，当 Producer 又发送消息 1 时， Broker 会把消息 1 再一次持久化到 BookKeeper 。开启消息去重后，当 Producer 再次发送消息 1 时， Broker 不会把消息 1 再一次持久化到磁盘。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.823170731707317&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasqeyVq3SFb7MawCsAKX9Eg0f2Z23ic3uxPM7pz8IlEyeEkxiajk7nyQDRqGM1icCicFZpx9SWFo7aO2Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1312&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2.1. 去重原理&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Producer 对每一个发送的消息，都会采用递增的方式生成一个唯一的 sequenceID，这个消息会放在 message 的元数据中传递给 Broker 。同时， Broker 也会维护一个 PendingMessage 队列，当 Broker 返回发送成功 ack 后， Producer 会将 PendingMessage 队列中的对于的 Sequence ID 删除，表示 Producer 任务这个消息生产成功。Broker 会记录针对每个 Producer 接收到的最大 Sequence ID 和已经处理完的最大 Sequence ID。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 Broker 开启消息去重后， Broker 会对每个消息请求进行是否去重的判断。收到的最新的 Sequence ID 是否大于 Broker 端记录的两个维度的最大 Sequence ID，如果大于则不重复，如果小于或等于则消息重复。消息重复时， Broker 端会直接返回 ack，不会继续走后续的存储处理流程。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.3. 消息延迟传递&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;延时消息功能允许 Consumer 能够在消息发送到 Topic 后过一段时间才能消费到这条消息。在这种机制中，消息在发布到 Broker 后，会被存储在 BookKeeper 中，当到消息特定的延迟时间时，消息就会传递给 Consumer 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图为消息延迟传递的机制。Broker 在存储延迟消息的时候不会进行特殊的处理。当 Consumer 消费消息的时候，如果这条消息设置了延迟时间，则会把这条消息加入 DelayedDeliveryTracker 中，当到了指定的发送时间时，DelayedDeliveryTracker 才会把这条消息推送给消费者。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4470588235294118&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasqeyVq3SFb7MawCsAKX9Egr3e8vibG9hMS8ysRe7Fb2QcskwJ2b6eEeBibydEONgtIKbh505iaLMsRg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1530&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.3.1. 延迟投递原理&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Pulsar 中，可以通过两种方式实现延迟投递。分别为 deliverAfter 和 deliverAt。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;deliverAfter 可以指定具体的延迟时间戳，deliverAt 可以指定消息在多长时间后消费。两种方式本质时一样的，deliverAt 方式下，客户端会计算出具体的延迟时间戳发送给 Broker 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DelayedDeliveryTracker 会记录所有需要延迟投递的消息的 index 。index 由 Timestamp、 Ledger ID、 Entry ID 三部分组成，其中 Ledger ID 和 Entry ID 用于定位该消息，Timestamp 除了记录需要投递的时间，还用于延迟优先级队列排序。DelayedDeliveryTracker 会根据延迟时间对消息进行排序，延迟时间最短的放在前面。当 Consumer 在消费时，如果有到期的消息需要消费，则根据 DelayedDeliveryTracker index 的 Ledger ID、 Entry ID 找到对应的消息进行消费。如下图， Producer 依次投递 m1、m2、m3、m4、m5 这五条消息，m2 没有设置延迟时间，所以会被 Consumer 直接消费。m1、m3、m4、m5 在 DelayedDeliveryTracker 会根据延迟时间进行排序，并在到达延迟时间时，依次被 Consumer 进行消费。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6721938775510204&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasqeyVq3SFb7MawCsAKX9EgUt6riaQxawqVAicVrLwBVoZhCFaicwQZAK7VejUs9ia5bT2yGiaQcvMTqMg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1568&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.4. Bundle&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道， Topic 分区会散落在不同的 Broker 中，那 Topic 分区和 Broker 的关系是如何维护的呢？当某个 Broker 负载过高时， Pulsar 怎么处理呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Topic 分区与 Broker 的关联是通过 Bundle 机制进行管理的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个 namespace 存在一个 Bundle 列表，在 namesapce 创建时可以指定 Bundle 的数量。Bundle 其实是一个分片机制，每个 Bundle 拥有 namespace 整个 hash 范围的一部分。每个 Topic (分区) 通过 hash 运算落到相应的 Bundle 区间，进而找到当前区间关联的 Broker 。每个 Bundle 绑定唯一的一个 Broker ，但一个 Broker 可以有多个 Bundle 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图，T1、T2 这两个 Topic 的 hash 结果落在[0x0000000L——0x4000000L]中，这个 hash 范围的 Bundle 对应 Broker 2， Broker 2 会对 T1、T2 进行处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理，T4 的 hash 结果落在[0x4000000L——0x8000000L]中，这个 hash 范围的 Bundle 对应 Broker 1， Broker 1 会对 T4 进行处理；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;T5 的 hash 结果落在[0x8000000L——0xC000000L]中，这个 hash 范围的 Bundle 对应 Broker 3， Broker 3 会对 T5 进行处理；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;T3 的 hash 结果落在[0xC000000L——0x0000000L]中，这个 hash 范围的 Bundle 对应 Broker 3， Broker 3 会对 T3 进行处理。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5175675675675676&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasqeyVq3SFb7MawCsAKX9EgxnBcAuXCVa0iakMsbjhrnbmqDibtT7grv6TicMKHoZo3iaeKbjJmib8MwtQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1480&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Bundle 可以根据绑定的 Broker 的负载进行动态的调整、绑定。当 Bundle 绑定的 Broker 的 Topic 数过多、负载过高时，都会触发 Bundle 拆分，将原有的 Bundle 拆分成 2 个 Bundle ，并将其中一个 Bundle 重新分配给不同的 Broker ，以降低原 Broker 的 Topic 数或负载。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. Pulsar 存储层（Bookkeeper）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BookKeeper 是 Pulsar 的存储组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 Pulsar 的每个 Topic（分区），其数据并不会固定的分配在某个 Bookie 上，具体的逻辑实现我们在 Bundle 一节已经讨论过，而 Topic 的物理存储，实际上是通过 BookKeeper 组件来实现的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1. 分片存储&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;概念：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Bookie：BookKeeper 的一部分，处理需要持久化的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Ledger：BookKeeper 的存储逻辑单元，可用于追加写数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Entry：写入 BookKeeper 的数据实体。当批量生产时，Entry 为多条消息，当非批量生产时，Entry 为单条数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 在物理上采用分片存储的模式，存储粒度比分区更细化、存储负载更均衡。如图，一个分区 Topic-Partition 2 的数据由多个分片组成。每个分片作为 BookKeeper 中的一个 Ledger ，均匀的分布并存储在 BookKeeper 的多个 Bookie 节点中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于分配存储的机制，使得 Bookie 的扩容可以即时完成，无需任何数据复制或者迁移。当 Bookie 扩容时，Broker 可以立刻发现并感知新的 Bookie ，并尝试将新的分片 Segment 写入新增加的 Bookie 中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6253807106598985&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasqeyVq3SFb7MawCsAKX9EgO2dq8R7DNzHINTicqaI6amjhxABRQb6enhuJV69I5d9Nc8QC1CntzDg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;985&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图，在 Broker 中，消息以 Entry 的形式追加的形式写入 Ledger 中，每个 Topic 分区都有多个非连续 ID 的 Ledger，Topic 分区的 Ledger 同一时刻只有一个处于可写状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Topic 分区在存储消息时，会先找到当前使用的 Ledger ，生成 Entry ID（每个 Entry ID 在同一个 Ledger 内是递增的）。当 Ledger 的长度或 Entry 个数超过阈值时，新消息会存储到新 Ledger 中。每个 messageID 由[Ledger ID， Entry ID， Partition 编号，batch-index]组成。( Partition :消息所属的 Topic 分区，batch-index:是否为批量消息)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个 Ledger 会根据 Topic 指定的副本数量存储到多个 Bookie 中。一个 Bookie 可以存放多个不连续的 Ledger。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2. 读写数据的流程&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Journals ：Journals 文件包含 BookKeeper 的事务日志信息。在对 Ledger 更新之前， Bookie 会保证更新的事务信息已经写入 Journals 。当 Bookie 启动或者旧的 Journals 大小达到阈值时，就会创建一个新的 Journals 。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Entry Logs：Entry Logs 管理从 Bookie 收到的 Entry 数据。来自不同 Ledger 的 Entry 会按顺序聚合并写入 Entry Logs ，这些 Entry 在 Entry Logs 中的偏移量会作为指针保存在 Ledger Cache 中，以便快速查找。当 Bookie 启动或者旧的 Entry Logs 大小达到阈值时，就会创建一个新的 Entry Logs 。当旧的 Entry Logs 没有与任何活跃的 Ledger 关联时，就会被垃圾回收器删除。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Index Files：每个 Ledger 都会创建一个 Index file，它包括一个头和几个固定长度的 Index page，这些 Index page 记录存储在 Entry Logs 中的 Entry 的偏移量。由于更新索引文件会引入随机的磁盘 I/O，所以索引文件由后台运行的同步线程延迟更新。这确保了更新的快速性能。在索引页持久化到磁盘之前，将它们聚集在 Ledger Cache 中以方便查找。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Ledger Cache：Ledger Cache 存放在内存池中，这样可以更高效地管理磁盘头调度。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4151260504201681&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasqeyVq3SFb7MawCsAKX9EgVQNTHlicFQFpZ7LxfGlVZ4mj1JcKh4oJfZQJs7Pwb7huZiaIfkUkHoXQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;595&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.2.1. 消息的写入&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.将 Entry 追加写入 Ledger 中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将这次 Entry 的更新操作写入 Journal 日志中，当由多个数据写入时，可以批量提交，将数据刷到 Journal 磁盘中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将 Entry 数据写入写缓存中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回写入成功响应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，消息写入的同步流程已经完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3-A. 内存中的 Entry 数据会根据 Ledger 和写入 Ledger 的时间顺序进行排序，批量写入 Entry Log 中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3-B. Entry 在 Entry log 中的偏移量以 Index Page 的方式写入 Ledger Cache 中，即 iIdex Files。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Entry Log 和 Ledger Cache 中的 Index File 会 Flush 到磁盘中。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.2.2. 消息的读取&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;A.先从写缓存中以尾部读的方式读取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;B.如果写缓存未命中，则从读缓存中读取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C.如果读缓存未命中，则从磁盘中读取。磁盘读取有三步：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C-1.读取 Index Disk，获取 Entry 的偏移量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C-2.根据 Entry 的偏移量，在 Entry Disk 中快速找到 Entry 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C-3.将 Entry 数据写入读缓存中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;6. 参考文献&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAg5YjhtxVywAAAAstQy6ubaLX4KHWvLEZgBPE1KIwRD9cbvb8zNPgMItb4FJQnMOX_c5LQ1j2iCIs&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7Ym3K77SEULgkiaKAG07Zw5kBgHdI7c5eOkfJ4jScKbrMIZk502ypRXTMzoXYABcbiaIxnlbiaViavMw0AIzUsicBO2pgicAJd3boicicJeQ&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SZ&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=x5Y29zUxcibCwyJTztcZP4jibIWibIoEGFDDJB7j83meXLAChfqE9iaHJoP4ic5NOomH9I5F38CIhcJs&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;一款很棒的免费、体积小和多平台都可以使用的视频剪辑工具&quot; data-nonceid=&quot;14349975478346291574&quot; data-type=&quot;video&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5ODYwMjI2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasvpPfMrktl2xvC9A325p8Qa9dFeEzxZmZ2O1XuFGsVXyQhG9Dia8J8nTXVtzNcHozr0umH3R4iboXg/0?wx_fmt=png&quot; data-nickname=&quot;腾讯技术工程&quot; data-alias=&quot;Tencent_TEG&quot; data-signature=&quot;腾讯技术官方号。腾讯技术创新、前沿领域发布解读平台。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1cff26ad7bfb8392aa59134b4cb402f6</guid>
<title>前端领域的 “干净架构”</title>
<link>https://toutiao.io/k/aazavob</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是 &lt;code&gt;ConardLi&lt;/code&gt;，前端有架构吗？这可能是很多人心里的疑惑，因为在实际业务开发里我们很少为前端去设计标准规范的代码架构，可能更多的去关注的是工程化、目录层级、以及业务代码的实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们来看一种前端架构的模式，原作者称它为“干净架构（&lt;code&gt;Clean Architecture&lt;/code&gt;）”，文章很长，讲的也很详细，我花了很长时间去读完了它，看完很有收获，翻译给大家，文中也融入了很多我自己的思考，推荐大家看完。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;https://dev.to/bespoyasov/clean-architecture-on-frontend-4311&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本文中示例的源码：&lt;code&gt;https://github.com/bespoyasov/frontend-clean-architecture/&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们会简单介绍一下什么是干净架构（&lt;code&gt;Clean architecture&lt;/code&gt;），比如领域、用例和应用层这些概念。然后就是怎么把干净架构应用于前端，以及值不值得这么做。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们会用干净架构的原则来设计一个商店应用，并从头实现一下，看看它能不能运行起来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个应用将使用 &lt;code&gt;React&lt;/code&gt; 作为它的 UI 框架，这只是为了表明这种开发方式是可以和 &lt;code&gt;React&lt;/code&gt; 一起使用的。你也可以选择其他任何一种 UI 库去实现它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码中会用到一些 &lt;code&gt;TypeScript&lt;/code&gt;，这只是为了展示怎么使用类型和接口来描述实体。其实所有的代码都可以不用 &lt;code&gt;TypeScript&lt;/code&gt; 实现，只是代码不会看起来那么富有表现力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;架构和设计&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;设计本质上就是以一种可以将它们重新组合在一起的方式将事物拆开…… 将事物拆分成可以重新组合的事物，这就是设计。— Rich Hickey《设计、重构和性能》&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;系统设计其实就是系统的拆分，最重要的是我们可以在不耗费太多时间的情况下重新把它们组起来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我同意上面这个观点，但我认为系统架构的另一个主要目标是系统的可扩展性。我们应用的需求是不断变化的。我们希望我们的程序可以非常易于更新和修改以满足持续变化的新需求。干净的架构就可以帮助我们实现这一目标。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是干净的架构？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;干净架构是一种根据应用程序的领域（&lt;code&gt;domain&lt;/code&gt;）的相似程度来拆分职责和功能的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;领域（&lt;code&gt;domain&lt;/code&gt;）是由真实世界抽象而来的程序模型。可以反映现实世界和程序中数据的映射。比如，如果我们更新了一个产品的名称，用新名称来替换旧名称就是领域转换。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;干净架构的功能通常被分为三层，我们可以看下面这张图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7344559585492227&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdSVsOBdTDYE1jb5O9TQoMouDZlqowgl1Pbribz4wybCBeQhBlovSdeOJ4nJacft1B1xoGxLyvnGXOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;772&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;领域层&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在在中心的是领域层层，这里会描述应用程序主题区域的实体和数据，以及转换该数据的代码。领域是区分不同程序的核心。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以把领域理解为当我们从 &lt;code&gt;React&lt;/code&gt; 迁移到 &lt;code&gt;Angular&lt;/code&gt;，或者改变某些用例的时候不会变的那一部分。在商店这个应用中，领域就是产品、订单、用户、购物车以及更新这些数据的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据结构和他们之间的转化与外部世界是相互隔离的。外部的事件调用会触发领域的转换，但是并不会决定他们如何运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：将商品添加到购物车的功能并不关心商品添加到购物车的方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户自己通过点击“购买”按钮添加&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户使用了优惠券自动添加。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这两种情况下，都会返回一个更新之后的购物车对象。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;应用层&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;围在领域外面的是应用层，这一层描述了用例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，“添加到购物车”这个场景就是一个用例。它描述了单击按钮后应执行的具体操作，像是一种“协调者”：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;向服务器发送一个请求；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行领域转换；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用响应的数据更新 UI。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，在应用层中还有端口 — 它描述了应用层如何和外部通信。通常一个端口就是一个接口（&lt;code&gt;interface&lt;/code&gt;），一个行为契约。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;端口也可以被认为是一个现实世界和应用程序之间的“缓冲区”。输入端口会告诉我们应用要如何接受外部的输入，同样输出端口会说明如何与外部通信做好准备。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;适配器层&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最外层包含了外部服务的适配器，我们通过适配器来转换外部服务的不兼容 &lt;code&gt;API&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;适配器可以降低我们的代码和外部第三方服务的耦合，适配器一般分为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;驱动型 - 向我们的应用发消息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;被动型 - 接受我们的应用所发送的消息。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般用户最常和驱动型适配器进行交互，例如，处理UI框架发送的点击事件就是一个驱动型适配器。它与浏览器 &lt;code&gt;API&lt;/code&gt; 一起将事件转换为我们的应用程序可以理解的信号。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;驱动型会和我们的基础设施交互。在前端，大部分的基础设施就是后端服务器，但有时我们也可能会直接与其他的一些服务交互，例如搜索引擎。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，离中心越远，代码的功能就越 “面向服务”，离应用的领域就越远，这在后面我们要决定一个模块是哪一层的时候是非常重要的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;依赖规则&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三层架构有一个依赖规则：只有外层可以依赖内层。这意味着：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;领域必须独立&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;应用层可以依赖领域&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最外层可以依赖任何东西&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6840909090909091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdSVsOBdTDYE1jb5O9TQoMoudJaJ2ePRwDhL0bLVdwmAreT7uWyu6r9ib9hI3DxicricWOKdOicFheKSqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;880&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然有些特殊的情况可能会违反这个规则，但最好不要滥用它。例如，在领域中也有可能会用到一些第三方库，即使不应该存在这样的依赖关系。下面看代码时会有这样一个例子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不控制依赖方向的代码可能会变得非常复杂和难以维护。比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;循环依赖，模块 A 依赖于 B，B 依赖于 C，C 依赖于 A。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可测试性差，即使测试一小块功能也不得不模拟整个系统。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;耦合度太高，因此模块之间的交互会很脆弱。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;干净架构的优势&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;独立领域&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有应用的核心功能都被拆分并统一维护在一个地方—领域&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;领域中的功能是独立的，这意味着它更容易测试。模块的依赖越少，测试所需的基础设施就越少。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;独立的领域也更容易根据业务的期望进行测试。这有助于让新手理解起来更容易。此外，独立的域也让从需求到代码实现中出现的错误更容易排除。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;独立用例&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用的使用场景和用例都是独立描述的。它决定了我们所需要哪些第三方服务。我们让外部服务更适应我们的需求，这让我们有更多的空间可以选择合适的第三方服务。比如，现在我们调用的支付系统涨价了，我们可以很快的换掉它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用例的代码也是扁平的，并且容易测试，扩展性强。我们会在后面的示例中看到这一点。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;可替换的第三方服务&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;适配器让外部第三方服务更容易替换。只要我们不改接口，那么实现这个接口的是哪个第三方服务都没关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样如果其他人改动了代码，不会直接影响我们。适配器也会减少应用运行时错误的传播。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实现干净架构的成本&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;架构首先是一种工具。像任何其他工具一样，干净的架构除了好处之外还会带来额外的成本。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;需要更多时间&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先是时间，设计、实现都需要更多的时间，因为直接调用第三方服务总是比写适配器简单。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们很难在一开始就把模块所有的交互和需求都想的很明白，我们设计的时候需要时刻留意哪些地方可能发生变化，所以要考虑更多的可扩展性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;有时会显得多余&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，干净架构并不适用于所有场景、甚至有的时候是有害的。如果本身就是一个很小的项目，你还要按照干净架构进行设计，这会大大增加上手门槛。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;上手更困难&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完全按照干净架构进行设计和实现会让新手上手更加困难，因为他首先要了解清楚应用是怎么运行起来的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代码量增加&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是前端会特有的一个问题，干净架构会增加最终打包的产物体积。产物越大，浏览器下载和解释的时间越长，所以代码量一定要把控好，适当删减代码：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将用例描述的得更简单一些；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;直接从适配器和领域交互，绕过用例；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;进行代码拆分&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何降低这些成本&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以通过适当的偷工减料和牺牲架构的“干净度”来减少一些实现时间和代码量。如果舍弃一些东西会获得更大的收益，我会毫不犹豫的去做。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，不必在所有方面走遵守干净架构的设计准则，把核心准则遵守好即可。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;抽象领域&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对领域的抽象可以帮助我们理解整体的设计，以及它们是怎么工作的，同时也会让其他开发人员更容易理解程序、实体以及它们之间的关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使我们直接跳过其他层，抽象的领域也更加容易重构。因为它们的代码是集中封装在一个地方的，其他层需要的时候可以方便添加。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;遵守依赖规则&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二条不应该放弃的规则是依赖规则，或者说是它们的依赖方向。外部的服务需要适配内部，而不是反方向的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你尝试直接去调用一个外部 API，这就是有问题的，最好在还没出问题之前写个适配器。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;商店应用的设计&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说完了理论，我们就可以开始实践了，下面我们来实际设计一个商店应用的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;商店会出售不同种类的饼干，用户可以自己选择要购买的饼干，并通过三方支付服务进行付款。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户可以在首页看到所有饼干，但是只有登录后才能购买，点击登录按钮可以跳转到登录页。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6522727272727272&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdSVsOBdTDYE1jb5O9TQoMouO2J1z2EGsTkCr7tael7vBgVrsjlGZzHXFZgxuq5I3kwMqgl9ZYnHAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;880&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;登录成功后，用户就可以把饼干加进购物车了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8693181818181818&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdSVsOBdTDYE1jb5O9TQoMou5xzkMVCb54dS5wvVGAYbMRvR1WGDbOuYHBymBXic3JmN8CXhfd8KXibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;880&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把饼干加进购物车后，用户就可以付款了。付款后，购物车会清空，并产生一个新的订单。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们来对实体、用例和功能进行定义，并对它们进行分层。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;设计领域&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序设计中最重要的就是领域设计，它们表示了实体到数据的转换。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;商店的领域可能包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;每个实体的数据类型：用户、饼干、购物车和订单；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果你是用OOP（面向对象思想）实现的，那么也要设计生成实体的工厂和类；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据转换的函数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;领域中的转换方法应该只依赖于领域的规则，而不依赖于其他任何东西。比如方法应该是这样的：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;计算总价的方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;检测用户口味的方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;检测商品是否在购物车的方法&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8829545454545454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdSVsOBdTDYE1jb5O9TQoMoudnO9oVFSVapfRvsuHzYLeFK092c77vdl8mVmKicwuYDoMSibQPE0HBjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;880&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;设计应用层&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用层包含用例，一个用包含一个参与者、一个动作和一个结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在商店应用里，我们可以这样区分：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个产品购买场景；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支付，调用第三方支付系统；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;与产品和订单的交互：更新、查询；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据角色访问不同页面。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们一般都是用主题领域来描述用例，比如“购买”包括下面的步骤:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从购物车中查询商品并创建新订单；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建支付订单；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支付失败时通知用户；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支付成功，清空购物车，显示订单。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用例方法就是描述这个场景的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，在应用层中还有端口—用于与外界通信的接口。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8829545454545454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdSVsOBdTDYE1jb5O9TQoMouYgOVQpDHpZSqK5swCnP0EypKIuKicibMLicCYKZQkuTX5kG5QaF3zaGkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;880&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;设计适配器层&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在适配器层，我们为外部服务声明适配器。适配器可以为我们的系统兼容各种不兼容的外部服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前端，适配器一般是UI框架和对后端的API请求模块。比如在我们的商店程序中会用到：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户界面；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;API请求模块；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本地存储的适配器；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;API返回到应用层的适配器。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8838797814207651&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdSVsOBdTDYE1jb5O9TQoMouTwuYK9eqEZmvbSVULuR4k1xUp46qad4BCiajngJ4TuMbe8pKnpYk8qw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;对比 MVC 架构&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时我们很难判断某些数据属于哪一层，这里可以和 MVC 架构做个小对比：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Model 一般都是领域实体&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Controller 一般是与转换或者应用层&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;View 是驱动适配器&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些概念虽然在细节上不太相同，但是非常相似。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实现细节—领域&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一旦我们确定了我们需要哪些实体，我们就可以开始定义它们的行为了，下面就是我们项目的目录结构：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;src/&lt;br/&gt;|_domain/&lt;br/&gt;  |_user.ts&lt;br/&gt;  |_product.ts&lt;br/&gt;  |_order.ts&lt;br/&gt;  |_cart.ts&lt;br/&gt;|_application/&lt;br/&gt;  |_addToCart.ts&lt;br/&gt;  |_authenticate.ts&lt;br/&gt;  |_orderProducts.ts&lt;br/&gt;  |_ports.ts&lt;br/&gt;|_services/&lt;br/&gt;  |_authAdapter.ts&lt;br/&gt;  |_notificationAdapter.ts&lt;br/&gt;  |_paymentAdapter.ts&lt;br/&gt;  |_storageAdapter.ts&lt;br/&gt;  |_api.ts&lt;br/&gt;  |_store.tsx&lt;br/&gt;|_lib/&lt;br/&gt;|_ui/&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;领域都定义在 &lt;code&gt;domain&lt;/code&gt; 目录下，应用层定义在 &lt;code&gt;application&lt;/code&gt; 目录下，适配器都定义在 &lt;code&gt;service&lt;/code&gt; 目录下。最后我们还会讨论目录结构是否会有其他的替代方案。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;创建领域实体&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在领域中有 4 个实体：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;product（产品）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;user（用户）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;order（订单）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cart（购物车）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中最重要的就是 &lt;code&gt;user&lt;/code&gt;，在回话中，我们会把用户信息存起来，所以我们单独在领域中设计一个用户类型，用户类型包括以下数据：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// domain/user.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; UserName = &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; User = {&lt;br/&gt;  id: UniqueId;&lt;br/&gt;  name: UserName;&lt;br/&gt;  email: Email;&lt;br/&gt;  preferences: Ingredient[];&lt;br/&gt;  allergies: Ingredient[];&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户可以把饼干放进购物车，我们也给购物车和饼干加上类型。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// domain/product.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; ProductTitle = &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; Product = {&lt;br/&gt;  id: UniqueId;&lt;br/&gt;  title: ProductTitle;&lt;br/&gt;  price: PriceCents;&lt;br/&gt;  toppings: Ingredient[];&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// domain/cart.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { Product } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./product&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; Cart = {&lt;br/&gt;  products: Product[];&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;付款成功后，将创建一个新订单，我们再来添加一个订单实体类型。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// domain/order.ts  — ConardLi&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; OrderStatus = &lt;span&gt;&quot;new&quot;&lt;/span&gt; | &lt;span&gt;&quot;delivery&quot;&lt;/span&gt; | &lt;span&gt;&quot;completed&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; Order = {&lt;br/&gt;  user: UniqueId;&lt;br/&gt;  cart: Cart;&lt;br/&gt;  created: DateTimeString;&lt;br/&gt;  status: OrderStatus;&lt;br/&gt;  total: PriceCents;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;理解实体之间的关系&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以这种方式设计实体类型的好处是我们可以检查它们的关系图是否和符合实际情况：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6931818181818182&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdSVsOBdTDYE1jb5O9TQoMoujiaTTlR3wFdaCKurLsaXePWvURMiaGKJA7EdF4KJcQFrLaYXX4ib9KeHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;880&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以检查以下几点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;参与者是否是一个用户&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;订单里是否有足够的信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有些实体是否需要扩展&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在未来是否有足够的可扩展性&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，在这个阶段，类型可以帮助识别实体之间的兼容性和调用方向的错误。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一切都符合我们预期的，我们就可以开始设计领域转换了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;创建数据转换&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们刚刚设计的这些类型数据会发生各种各样的事情。我们可以添加商品到购物车、清空购物车、更新商品和用户名等。下面我们分别来为这些数据转换创建对应的函数：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，为了判断某个用户是喜欢还是厌恶某个口味，我们可以创建两个函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// domain/user.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;hasAllergy&lt;/span&gt;(&lt;span&gt;user: User, ingredient: Ingredient&lt;/span&gt;): &lt;span&gt;boolean&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; user.allergies.includes(ingredient);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;hasPreference&lt;/span&gt;(&lt;span&gt;user: User, ingredient: Ingredient&lt;/span&gt;): &lt;span&gt;boolean&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; user.preferences.includes(ingredient);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将商品添加到购物车并检查商品是否在购物车中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// domain/cart.ts  — ConardLi&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;addProduct&lt;/span&gt;(&lt;span&gt;cart: Cart, product: Product&lt;/span&gt;): &lt;span&gt;Cart&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; { ...cart, products: [...cart.products, product] };&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;contains&lt;/span&gt;(&lt;span&gt;cart: Cart, product: Product&lt;/span&gt;): &lt;span&gt;boolean&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; cart.products.some(&lt;span&gt;(&lt;span&gt;{ id }&lt;/span&gt;) =&amp;gt;&lt;/span&gt; id === product.id);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是计算总价（如果需要的话我们还可以设计更多的功能，比如配打折、优惠券等场景）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// domain/product.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;totalPrice&lt;/span&gt;(&lt;span&gt;products: Product[]&lt;/span&gt;): &lt;span&gt;PriceCents&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; products.reduce(&lt;span&gt;(&lt;span&gt;total, { price }&lt;/span&gt;) =&amp;gt;&lt;/span&gt; total + price, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建新订单，并和对应用户以及他的购物车建立关联。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// domain/order.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;createOrder&lt;/span&gt;(&lt;span&gt;user: User, cart: Cart&lt;/span&gt;): &lt;span&gt;Order&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    user: user.id,&lt;br/&gt;    cart,&lt;br/&gt;    created: &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;().toISOString(),&lt;br/&gt;    status: &lt;span&gt;&quot;new&quot;&lt;/span&gt;,&lt;br/&gt;    total: totalPrice(products),&lt;br/&gt;  };&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;详细设计—共享内核&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可能已经注意到我们在描述领域类型的时候使用的一些类型。例如 &lt;code&gt;Email&lt;/code&gt;，&lt;code&gt;UniqueId&lt;/code&gt; 或 &lt;code&gt;DateTimeString&lt;/code&gt; 。这些其实都是类型别名：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// shared-kernel.d.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Email = &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; UniqueId = &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; DateTimeString = &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; PriceCents = &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我用 &lt;code&gt;DateTimeString&lt;/code&gt; 代替 &lt;code&gt;string&lt;/code&gt; 来更清晰的表明这个字符串是用来做什么的。这些类型越贴近实际，就更容易排查问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些类型都定义在 &lt;code&gt;shared-kernel.d.ts&lt;/code&gt; 文件里。共享内核指的是一些代码和数据，对他们的依赖不会增加模块之间的耦合度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实践中，共享内核可以这样解释：我们用到 &lt;code&gt;TypeScript&lt;/code&gt;，使用它的标准类型库，但我们不会把它们看作是一个依赖项。这是因为使用它们的模块互相不会产生影响并且可以保持解耦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并不是所有代码都可以被看作是共享内核，最主要的原则是这样的代码必须和系统处处都是兼容的。如果程序的一部分是用 &lt;code&gt;TypeScript&lt;/code&gt; 编写的，而另一部分是用另一种语言编写的，共享核心只可以包含两种语言都可以工作的部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们的例子中，整个应用程序都是用 &lt;code&gt;TypeScript&lt;/code&gt; 编写的，所以内置类型的别名完全可以当做共享内核的一部分。这种全局都可用的类型不会增加模块之间的耦合，并且在程序的任何部分都可以使用到。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实现细节—应用层&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们已经完成了领域的设计，下面可以设计应用层了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一层会包含具体的用例设计，比如一个用例是将商品添加到购物车并支付的完整过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用例会涉及应用和外部服务的交互，与外部服务的交互都是副作用。我们都知道调用或者调试没有副作用的方法会更简单一些，所以大部分领域函数都实现为成纯函数了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了将无副作用的纯函数和与有副作用的交互结合起来，我们可以将应用层用作有副作用的非纯上下文。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;非纯上下文纯数据转换&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个包含副作用的非纯上下文和纯数据转换是这样一种代码组织方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先执行一个副作用来获取一些数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后对数据执行纯函数进行数据处理；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后再执行一个副作用，存储或传递这个结果。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，“将商品放入购物车”这个用例：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先，从数据库里获取购物车的状态；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后调用购物车更新函数，把要添加的商品信息传进去；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后将更新的购物车保存到数据库中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个过程就像一个“三明治”：副作用、纯函数、副作用。所有主要的逻辑处理都在调用纯函数进行数据转换上，所有与外部的通信都隔离在一个命令式的外壳中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdSVsOBdTDYE1jb5O9TQoMoutPksfc9wib5tpF7IFxcWIMr7aFbeUM97OsyBTVIyDzdG5pmctdCOE2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;设计用例&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们选择结账这个场景来做用例设计，它更具代表性，因为它是异步的，而且会与很多第三方服务进行交互。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以想一想，通过整个用例我们要表达什么。用户的购物车里有一些饼干，当用户点击购买按钮的时候：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;要创建一个新订单；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在第三方支付系统中支付；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果支付失败，通知用户；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果支付成功，将订单保存在服务器上；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在本地存储保存订单数据，并在页面上显示；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计函数的时候，我们会把用户和购物车都作为参数，然后让这个方法完成整个过程。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; OrderProducts = &lt;span&gt;(&lt;span&gt;user: User, cart: Cart&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;&amp;lt;&lt;span&gt;void&lt;/span&gt;&amp;gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，理想情况下，用例不应该接收两个单独的参数，而是接收一个封装后的对象，为了精简代码，我们先这样处理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;编写应用层的接口&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来仔细看看用例的步骤：订单创建本身就是一个领域函数，其他一切操作我们都要调用外部服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们要牢记，外部方法永远要适配我们的需求。所以，在应用层，我们不仅要描述用例本身，也要定义调用外部服务的通信方式—端口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想一想我们可能会用到的服务：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第三方支付服务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通知用户事件和错误的服务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将数据保存到本地存储的服务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2735294117647058&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdSVsOBdTDYE1jb5O9TQoMoudEOBaC8JHU7IJVewHOpQRLkdGIaA6fwTjVokw8ic4BEBXY55sRjO8zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;680&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，我们现在讨论的是这些服务的 &lt;code&gt;interface&lt;/code&gt; ，而不是它们的具体实现。在这个阶段，描述必要的行为对我们来说很重要，因为这是我们在描述场景时在应用层所依赖的行为。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何实现现在不是重点，我们可以在最后再考虑调用哪些外部服务，这样代码才能尽量保证低耦合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外还要注意，我们按功能拆分接口。与支付相关的一切都在同一个模块中，与存储相关的都在另一个模块中。这样更容易确保不的同第三方服务的功能不会混在一起。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;支付系统接口&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们这个商店应用只是个小 &lt;code&gt;Demo&lt;/code&gt;，所以支付系统会很简单。它会有一个 &lt;code&gt;tryPay&lt;/code&gt; 方法，这个方法将接受需要支付的金额，然后返回一个布尔值来表明支付的结果。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// application/ports.ts  — ConardLi&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; PaymentService {&lt;br/&gt;  tryPay(amount: PriceCents): &lt;span&gt;Promise&lt;/span&gt;&amp;lt;&lt;span&gt;boolean&lt;/span&gt;&amp;gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，付款的处理是在服务端。但我们只是简单演示一下，所以在前端就直接处理了。后面我们也会调用一些简单的API，而不是直接和支付系统进行通信。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;通知服务接口&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果出现一些问题，我们必须通知到用户。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以用各种不同的方式通知用户。比如使用 UI，发送邮件，甚至可以让用户的手机振动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，通知服务最好也抽象出来，这样我们现在就不用考虑实现了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给用户发送一条通知：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// application/ports.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; interface NotificationService {&lt;br/&gt;  notify(message: string): &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;本地存储接口&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们会将新的订单保存在本地的存储库中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个存储可以是任何东西：Redux、MobX、任何存储都可以。存储库可以在不同实体上进行拆分，也可以是整个应用程序的数据都维护在一起。不过现在都不重要，因为这些都是实现细节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我习惯的做法是为每个实体都创建一个单独的存储接口：一个单独的接口存储用户数据，一个存储购物车，一个存储订单：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// application/ports.ts    — ConardLi&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; OrdersStorageService {&lt;br/&gt;  orders: Order[];&lt;br/&gt;  updateOrders(orders: Order[]): &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;用例方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看看能不能用现有的领域方法和刚刚建的接口来构建一个用例。脚本将包含如下步骤：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;验证数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建订单；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支付订单；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通知问题；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;保存结果。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9063324538258575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdSVsOBdTDYE1jb5O9TQoMoukkmC1fCEXkPibiaF4GnEvS80yVmZiaCJicArEP0Q2HjBOL8mhcM0lZjPsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;758&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们声明出来我们要调用的服务的模块。&lt;code&gt;TypeScript&lt;/code&gt; 会提示我们没有给出接口的实现，先不要管他。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// application/orderProducts.ts — ConardLi&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; payment: PaymentService = {};&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; notifier: NotificationService = {};&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; orderStorage: OrdersStorageService = {};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们可以像使用真正的服务一样使用这些模块。我们可以访问他们的字段，调用他们的方法。这在把用例转换为代码的时候非常有用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，我们创建一个名为 &lt;code&gt;orderProducts&lt;/code&gt; 的方法来创建一个订单：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// application/orderProducts.ts  — ConardLi&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;orderProducts&lt;/span&gt;(&lt;span&gt;user: User, cart: Cart&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; order = createOrder(user, cart);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里，我们把接口当作是行为的约定。也就是说以模块示例会真正执行我们期望的操作：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// application/orderProducts.ts  — ConardLi&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;orderProducts&lt;/span&gt;(&lt;span&gt;user: User, cart: Cart&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; order = createOrder(user, cart);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Try to pay for the order;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// Notify the user if something is wrong:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; paid = &lt;span&gt;await&lt;/span&gt; payment.tryPay(order.total);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!paid) &lt;span&gt;return&lt;/span&gt; notifier.notify(&lt;span&gt;&quot;Oops! 🤷&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Save the result and clear the cart:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { orders } = orderStorage;&lt;br/&gt;  orderStorage.updateOrders([...orders, order]);&lt;br/&gt;  cartStorage.emptyCart();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，用例不会直接调用第三方服务。它依赖于接口中描述的行为，所以只要接口保持不变，我们就不需要关心哪个模块来实现它以及如何实现它，这样的模块就是可替换的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实现细节—适配器层&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们已经把用例“翻译”成 &lt;code&gt;TypeScript&lt;/code&gt; 了，现在我们来检查一下现实是否符合我们的需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下是不会的，所以我们要通过封装适配器来调用第三方服务。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;添加UI和用例&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，第一个适配器就是一个 UI 框架。它把浏览器的 API 与我们的应用程序连接起来。在订单创建的这个场景，就是“结帐”按钮和点击事件的处理方法，这里会调用具体用例的功能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// ui/components/Buy.tsx  — ConardLi&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Buy&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// Get access to the use case in the component:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { orderProducts } = useOrderProducts();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;handleSubmit&lt;/span&gt;(&lt;span&gt;e: React.FormEvent&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    setLoading(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;    e.preventDefault();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Call the use case function:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;await&lt;/span&gt; orderProducts(user!, cart);&lt;br/&gt;    setLoading(&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;section&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;h2&lt;/span&gt;&amp;gt;&lt;/span&gt;Checkout&lt;span&gt;&amp;lt;/&lt;span&gt;h2&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;form&lt;/span&gt; &lt;span&gt;onSubmit&lt;/span&gt;=&lt;span&gt;{handleSubmit}&lt;/span&gt;&amp;gt;&lt;/span&gt;{/* ... */}&lt;span&gt;&amp;lt;/&lt;span&gt;form&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;section&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;  );&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过一个 &lt;code&gt;Hook&lt;/code&gt; 来封装用例，建议把所有的服务都封装到里面，最后返回用例的方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// application/orderProducts.ts  — ConardLi&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;useOrderProducts&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; notifier = useNotifier();&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; payment = usePayment();&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; orderStorage = useOrdersStorage();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;orderProducts&lt;/span&gt;(&lt;span&gt;user: User, cookies: Cookie[]&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// …&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; { orderProducts };&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用 &lt;code&gt;hook&lt;/code&gt; 来作为一个依赖注入。首先我们使用 &lt;code&gt;useNotifier，usePayment，useOrdersStorage&lt;/code&gt; 这几个 &lt;code&gt;hook&lt;/code&gt; 来获取服务的实例，然后我们用函数 &lt;code&gt;useOrderProducts&lt;/code&gt; 创建一个闭包，让他们可以在 &lt;code&gt;orderProducts&lt;/code&gt; 函数中被调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外需要注意的是，用例函数和其他的代码是分离的，这样对测试更加友好。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;支付服务实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用例使用 &lt;code&gt;PaymentService&lt;/code&gt; 接口，我们先来实现一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于付款操作，我们依然使用一个假的 API 。同样的，我们现在还是没必要编写全部的服务，我们可以之后再实现，现在最重要的是实现指定的行为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// services/paymentAdapter.ts  — ConardLi&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { fakeApi } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./api&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { PaymentService } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;../application/ports&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;usePayment&lt;/span&gt;(&lt;span/&gt;): &lt;span&gt;PaymentService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    tryPay(amount: PriceCents) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; fakeApi(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;    },&lt;br/&gt;  };&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;fakeApi&lt;/code&gt; 这个函数会在 &lt;code&gt;450&lt;/code&gt; 毫秒后触发的超时，模拟来自服务器的延迟响应，它返回我们传入的参数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// services/api.ts  — ConardLi&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;fakeApi&lt;/span&gt;&amp;lt;&lt;span&gt;TResponse&lt;/span&gt;&amp;gt;(&lt;span&gt;response: TResponse&lt;/span&gt;): &lt;span&gt;Promise&lt;/span&gt;&amp;lt;&lt;span&gt;TResponse&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;res&lt;/span&gt;) =&amp;gt;&lt;/span&gt; setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; res(response), &lt;span&gt;450&lt;/span&gt;));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;通知服务实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们就简单使用 &lt;code&gt;alert&lt;/code&gt; 来实现通知，因为代码是解耦的，以后再来重写这个服务也不成问题。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// services/notificationAdapter.ts  — ConardLi&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { NotificationService } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;../application/ports&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;useNotifier&lt;/span&gt;(&lt;span/&gt;): &lt;span&gt;NotificationService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    notify: &lt;span&gt;(&lt;span&gt;message: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;window&lt;/span&gt;.alert(message),&lt;br/&gt;  };&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;本地存储实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们就通过 &lt;code&gt;React.Context&lt;/code&gt; 和 &lt;code&gt;Hooks&lt;/code&gt; 来实现本地存储。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们创建一个新的 &lt;code&gt;context&lt;/code&gt;，然后把它传给 &lt;code&gt;provider&lt;/code&gt;，然后导出让其他的模块可以通过 &lt;code&gt;Hooks&lt;/code&gt; 使用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// store.tsx  — ConardLi&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; StoreContext = React.createContext&amp;lt;any&amp;gt;({});&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; useStore = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; useContext(StoreContext);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; Provider: React.FC = &lt;span&gt;(&lt;span&gt;{ children }&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// ...Other entities...&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; [orders, setOrders] = useState([]);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; value = {&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    orders,&lt;br/&gt;    &lt;span&gt;updateOrders&lt;/span&gt;: setOrders,&lt;br/&gt;  };&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;StoreContext.Provider&lt;/span&gt; &lt;span&gt;value&lt;/span&gt;=&lt;span&gt;{value}&lt;/span&gt;&amp;gt;&lt;/span&gt;{children}&lt;span&gt;&amp;lt;/&lt;span&gt;StoreContext.Provider&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;  );&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以给每一个功能点都实现一个 &lt;code&gt;Hook&lt;/code&gt; 。这样我们就不会破坏服务接口和存储，至少在接口的角度来说他们是分离的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// services/storageAdapter.ts&lt;br/&gt;&lt;br/&gt;export function useOrdersStorage(): OrdersStorageService {&lt;br/&gt;  return useStore();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，这种方法还可以使我们能够为每个商店定制额外的优化：创建选择器、缓存等。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;验证数据流程图&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在让我们验证一下用户是怎么和应用程序通信的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23636363636363636&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdSVsOBdTDYE1jb5O9TQoMouMeibrosKh8Moqfk6B2BhchDpZJvJPYjUQITrXVYCYsM5b0oeGMQaobQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;880&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户与 UI 层交互，但是 UI 只能通过端口访问服务接口。也就是说，我们可以随时替换 UI。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用例是在应用层处理的，它可以准确地告诉我们需要哪些外部服务。所有主要的逻辑和数据都封装在领域中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有外部服务都隐藏在基础设施中，并且遵守我们的规范。如果我们需要更改发送消息的服务，只需要修改发送消息服务的适配器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的方案让代码更方便替换、更容易测试、扩展性更强，以适应不断变化的需求。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;有什么可以改进的&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面介绍的这些已经可以让你开始并初步了解干净的架构了，但是我想指出上面我为了让示例更简单做的一些偷工减料的事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读完下面的内容，大家可以理解 “没有偷工减料”的干净架构是什么样子的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用对象而不是数字来表示价格&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可能已经注意到我用一个数字来描述价格，这不是一个好习惯。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// shared-kernel.d.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; PriceCents = &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数字只能表示数量，不能表示货币，没有货币的价格是没有意义的。理想情况下，价格应该是具有两个字段的对象：价值和货币。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Currency = &lt;span&gt;&quot;RUB&quot;&lt;/span&gt; | &lt;span&gt;&quot;USD&quot;&lt;/span&gt; | &lt;span&gt;&quot;EUR&quot;&lt;/span&gt; | &lt;span&gt;&quot;SEK&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; AmountCents = &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Price = {&lt;br/&gt;  value: AmountCents;&lt;br/&gt;  currency: Currency;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就能解决存储货币的问题了，并可以省去大量的存储和处理货币的精力。在示例中我没有这么做是为了让这个例子尽量简单。在真实的情况里，价格的结构定义会更加接近上面的写法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，值得一提的是价格的单位，比如美元的最小单位是美分。以这种方式显示价格让我可以避免考虑浮点数计算的问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;按功能拆分代码，而不是按层&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码可以 “按功能” 拆分到文件夹中，而不是“按层”，一块功能就是下面饼图的一部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种结构更清晰，因为它可以让你分别部署不同的功能点：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6840909090909091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdSVsOBdTDYE1jb5O9TQoMoudJaJ2ePRwDhL0bLVdwmAreT7uWyu6r9ib9hI3DxicricWOKdOicFheKSqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;880&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;注意跨组件使用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们正在讨论将系统拆分为组件，就不得不考虑跨组件代码使用的问题。我们再来看看创建订单的代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { Product, totalPrice } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./product&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;createOrder&lt;/span&gt;(&lt;span&gt;user: User, cart: Cart&lt;/span&gt;): &lt;span&gt;Order&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    user: user.id,&lt;br/&gt;    cart,&lt;br/&gt;    created: &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;().toISOString(),&lt;br/&gt;    status: &lt;span&gt;&quot;new&quot;&lt;/span&gt;,&lt;br/&gt;    total: totalPrice(products),&lt;br/&gt;  };&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个函数用到了从另一个 &lt;code&gt;Product&lt;/code&gt; 模块引入的 &lt;code&gt;totalPrice&lt;/code&gt; 方法。这样使用本身没有什么问题，但是如果我们要考虑把代码拆分到独立的功能的时候，我们不能直接访问其他模块的代码。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用 ts-brand ，而不是类型别名&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在共享内核的编写中，我使用了类型别名。它们很容易实现，但缺点是 &lt;code&gt;TypeScript&lt;/code&gt; 没有监控并强制执行它们的机制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这看起来也不是个问题：你是用 &lt;code&gt;string&lt;/code&gt; 类型去替代 &lt;code&gt;DateTimeString&lt;/code&gt; 也不会怎么样，代码还是会编译成功。但是，这样会让代码变得脆弱、可读性也很差，因为这样你可以用任意的字符串，导致错误的可能性会增加。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一种方法可以让 &lt;code&gt;TypeScript&lt;/code&gt; 理解我们想要一个特定的类型 — &lt;code&gt;ts-brand&lt;/code&gt;（&lt;code&gt;https://github.com/kourge/ts-brand&lt;/code&gt;）。它可以准确的跟踪类型的使用方式，但会使代码更复杂一些。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;注意领域中可能的依赖&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来的问题是我们在 &lt;code&gt;createOrder&lt;/code&gt; 函数的领域中创建了一个日期：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { Product, totalPrice } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./product&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;createOrder&lt;/span&gt;(&lt;span&gt;user: User, cart: Cart&lt;/span&gt;): &lt;span&gt;Order&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    user: user.id,&lt;br/&gt;    cart,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Вот эта строка:&lt;/span&gt;&lt;br/&gt;    created: &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;().toISOString(),&lt;br/&gt;&lt;br/&gt;    status: &lt;span&gt;&quot;new&quot;&lt;/span&gt;,&lt;br/&gt;    total: totalPrice(products),&lt;br/&gt;  };&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;new Date().toISOString()&lt;/code&gt; 这样的函数可能会被重复调用很多次，我们可以把它封装到一个 &lt;code&gt;hleper&lt;/code&gt; 里面：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// lib/datetime.ts  — ConardLi&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;currentDatetime&lt;/span&gt;(&lt;span/&gt;): &lt;span&gt;DateTimeString&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;().toISOString();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在领域中调用它：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// domain/order.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { currentDatetime } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;../lib/datetime&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { Product, totalPrice } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./product&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;createOrder&lt;/span&gt;(&lt;span&gt;user: User, cart: Cart&lt;/span&gt;): &lt;span&gt;Order&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    user: user.id,&lt;br/&gt;    cart,&lt;br/&gt;    created: currentDatetime(),&lt;br/&gt;    status: &lt;span&gt;&quot;new&quot;&lt;/span&gt;,&lt;br/&gt;    total: totalPrice(products),&lt;br/&gt;  };&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是领域的原则是不能依赖其他任何东西，所以 &lt;code&gt;createOrder&lt;/code&gt; 函数最好是所有数据都从外面传进来，日期可以作为最后一个参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// domain/order.ts  — ConardLi&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;createOrder&lt;/span&gt;(&lt;span&gt;&lt;br/&gt;  user: User,&lt;br/&gt;  cart: Cart,&lt;br/&gt;  created: DateTimeString&lt;br/&gt;&lt;/span&gt;): &lt;span&gt;Order&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    user: user.id,&lt;br/&gt;    products,&lt;br/&gt;    created,&lt;br/&gt;    status: &lt;span&gt;&quot;new&quot;&lt;/span&gt;,&lt;br/&gt;    total: totalPrice(products),&lt;br/&gt;  };&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样我们就不会破坏依赖规则，即使创建日期也需要依赖第三方库：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;someUserCase&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// Use the `dateTimeSource` adapter,&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// to get the current date in the desired format:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; createdOn = dateTimeSource.currentDatetime();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Pass already created date to the domain function:&lt;/span&gt;&lt;br/&gt;  createOrder(user, cart, createdOn);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这会让领域保持独立，也使测试更容易。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面的示例中，我不这样做有两个原因：它会分散我们的重点，如果它只使用语言本身的特性，我认为依赖你自己的 &lt;code&gt;Helper&lt;/code&gt; 没有任何问题。这样的 &lt;code&gt;Helper&lt;/code&gt; 甚至可以被视为共享内核，因为它们只会减少代码的重复度。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;注意购物车与订单的关系&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个小例子中，&lt;code&gt;Order&lt;/code&gt; 会包含 &lt;code&gt;Cart&lt;/code&gt;, 因为购物车只表示 &lt;code&gt;Product&lt;/code&gt; 列表：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; Cart = {&lt;br/&gt;  products: Product[];&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; Order = {&lt;br/&gt;  user: UniqueId;&lt;br/&gt;  cart: Cart;&lt;br/&gt;  created: DateTimeString;&lt;br/&gt;  status: OrderStatus;&lt;br/&gt;  total: PriceCents;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果购物车有其他的和订单没有关联的属性，可能会出问题，所以直接用 &lt;code&gt;ProductList&lt;/code&gt; 会更合理：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; ProductList = Product[];&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Cart = {&lt;br/&gt;  products: ProductList;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Order = {&lt;br/&gt;  user: UniqueId;&lt;br/&gt;  products: ProductList;&lt;br/&gt;  created: DateTimeString;&lt;br/&gt;  status: OrderStatus;&lt;br/&gt;  total: PriceCents;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;让用例更方便测试&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用例也有很多要讨论的地方。比如，&lt;code&gt;orderProducts&lt;/code&gt; 函数很难独立于 &lt;code&gt;React&lt;/code&gt; 来测试，这不太好。理想情况下，测试不应该消耗太多的成本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题的根本原因我们使用 &lt;code&gt;Hooks&lt;/code&gt; 来实现了用例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// application/orderProducts.ts  — ConardLi&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;useOrderProducts&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; notifier = useNotifier();&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; payment = usePayment();&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; orderStorage = useOrdersStorage();&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; cartStorage = useCartStorage();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;orderProducts&lt;/span&gt;(&lt;span&gt;user: User, cart: Cart&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; order = createOrder(user, cart);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; paid = &lt;span&gt;await&lt;/span&gt; payment.tryPay(order.total);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!paid) &lt;span&gt;return&lt;/span&gt; notifier.notify(&lt;span&gt;&quot;Oops! 🤷&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; { orders } = orderStorage;&lt;br/&gt;    orderStorage.updateOrders([...orders, order]);&lt;br/&gt;    cartStorage.emptyCart();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; { orderProducts };&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在规范的实现中，用例方法可以放在 &lt;code&gt;Hooks&lt;/code&gt; 的外面，服务通过参数或者使用依赖注入传入用例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Dependencies = {&lt;br/&gt;  notifier?: NotificationService;&lt;br/&gt;  payment?: PaymentService;&lt;br/&gt;  orderStorage?: OrderStorageService;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;orderProducts&lt;/span&gt;(&lt;span&gt;&lt;br/&gt;  user: User,&lt;br/&gt;  cart: Cart,&lt;br/&gt;  dependencies: Dependencies = defaultDependencies&lt;br/&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { notifier, payment, orderStorage } = dependencies;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后 &lt;code&gt;Hooks&lt;/code&gt; 的代码就可以当做一个适配器，只有用例会留在应用层。&lt;code&gt;orderProdeucts&lt;/code&gt; 方法很容易就可以被测试了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;useOrderProducts&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; notifier = useNotifier();&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; payment = usePayment();&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; orderStorage = useOrdersStorage();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;(&lt;span&gt;user: User, cart: Cart&lt;/span&gt;) =&amp;gt;&lt;/span&gt;&lt;br/&gt;    orderProducts(user, cart, {&lt;br/&gt;      notifier,&lt;br/&gt;      payment,&lt;br/&gt;      orderStorage,&lt;br/&gt;    });&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;配置自动依赖注入&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在应用层，我们是手动将依赖注入服务的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;useOrderProducts&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// Here we use hooks to get the instances of each service,&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// which will be used inside the orderProducts use case:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; notifier = useNotifier();&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; payment = usePayment();&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; orderStorage = useOrdersStorage();&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; cartStorage = useCartStorage();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;orderProducts&lt;/span&gt;(&lt;span&gt;user: User, cart: Cart&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// ...Inside the use case we use those services.&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; { orderProducts };&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然还有更好的做法，依赖注入可以自动完成。我们前面已经通过最后一个参数实现了最简单的注入版本，下面可以进一步配置自动依赖注入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个特定的应用程序中，我认为设置依赖注入没有多大意义。它会分散我们的注意力并使代码过于复杂。在使用了 &lt;code&gt;React&lt;/code&gt; 和 &lt;code&gt;hooks&lt;/code&gt; 的情况下，我们可以将它们用作“容器”，返回指定接口的实现。是的，虽然还是手动实现的，但它不会增加上手门槛，并且对于新手开发人员来说阅读速度更快。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实际项目中的情况可能更复杂&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章中的示例是经过精简的而且需求也比较简单。很明显，我们实际开发中比这个例子要复杂的多。所以我还想谈谈实际开发中使用干净架构时可能出现的常见问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分支业务逻辑&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最重要的问题是我们对需求的实际场景研究不够深入。想象一下，一家商店有一个产品、一个打折产品和一种已经注销的产品。我们怎么准确描述这些实体？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是不是应该有一个可扩展的“基础”实体呢？这个实体究竟应该怎么扩展？应该有额外的字段吗？这些实体是否应该互斥？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能有太多的问题和太多的答案，如果只是假设，我们不可能考虑到所有的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体解决方法还要视具体情况而定，我只能推荐几个我的经验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不建议使用继承，即使它看起来可“扩展”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;复制粘贴的代码并不一定都不好，有时候甚至能发挥更大的作用。创建两个几乎相同的实体，观察它们在现实中的行为。在某些时候，它们的行为可能区别很大，有时候也可能只有一两个字段的区别。合并两个非常相似的实体比写大量的的检查要容易很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你一定要扩展一些内容的话。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记住协变、逆变和不变，这样你就不会多出一些意想不到的工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在不同的实体和可扩展之间选择，推荐使用类似于 &lt;code&gt;BEM&lt;/code&gt; 中的块和修饰符概念来帮助你思考，如果我在 &lt;code&gt;BEM&lt;/code&gt; 的上下文中考虑它，它可以帮助我确定我是否有一个单独的实体或代码的“修饰符扩展”。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.304&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdSVsOBdTDYE1jb5O9TQoMou12DtichjSeWIJnpJ07tGb61xoeoQZ7J9nbIluZBAyn44icHqL8GOWKkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;BEM - Block Element Modfier（块元素编辑器）是一个很有用的方法，它可以帮助你创建出可以复用的前端组件和前端代码。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;相互依赖的用例&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个问题是用例相关的，通过一个用例的事件触发另一个用例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我知道并且对我有帮助的处理这个问题的唯一方法是将用例分解为更小的原子用例。它们将更容易组合在一起。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常，出现这个问题是编程中另外一个大问题的结果。这就是实体组合。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本文里，我们介绍了前端的“干净架构”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这不是一个黄金标准，而是一个在很多的项目、规范和语言上积累的经验汇总。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我发现它是一种非常方便的方案，可以帮助你解耦你的代码。让层、模块和服务尽量独立。不仅可以独立发布、部署，还可以让你从一个项目迁移另一个项目的时候也更加容易。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你理想下的前端架构是什么样的呢？&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;447&quot; data-index=&quot;8540&quot;&gt; - &lt;/span&gt;&lt;span data-raw-text=&quot;E&quot; data-textnode-index=&quot;447&quot; data-index=&quot;8541&quot;&gt;E&lt;/span&gt;&lt;span data-raw-text=&quot;N&quot; data-textnode-index=&quot;447&quot; data-index=&quot;8542&quot;&gt;N&lt;/span&gt;&lt;span data-raw-text=&quot;D&quot; data-textnode-index=&quot;447&quot; data-index=&quot;8543&quot;&gt;D&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;447&quot; data-index=&quot;8544&quot;&gt; &lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;447&quot; data-index=&quot;8545&quot;&gt;-&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4MTYwMzY1Mw==&amp;amp;mid=2247496626&amp;amp;idx=1&amp;amp;sn=699dc2b117d43674b9e80a616199d5b6&amp;amp;chksm=cf61d698f8165f8e2b7f6cf4a638347c3b55b035e6c2095e477b217723cce34acbbe943ad537&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;197&quot; data-backw=&quot;578&quot; data-fileid=&quot;100016124&quot; data-ratio=&quot;0.3404255319148936&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MpGQUHiaib4ib44VcWJtWJHE1rbIx4WLwG6Wicxpy9V4SCLxLHqW2SVoibogZU9FTyiaTkZgTCwQVsk1iao7Vot4yibZjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1175&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span data-raw-text=&quot;关&quot; data-textnode-index=&quot;448&quot; data-index=&quot;8546&quot;&gt;关&lt;/span&gt;&lt;span data-raw-text=&quot;于&quot; data-textnode-index=&quot;448&quot; data-index=&quot;8547&quot;&gt;于&lt;/span&gt;&lt;span data-raw-text=&quot;奇&quot; data-textnode-index=&quot;448&quot; data-index=&quot;8548&quot;&gt;奇&lt;/span&gt;&lt;span data-raw-text=&quot;舞&quot; data-textnode-index=&quot;448&quot; data-index=&quot;8549&quot;&gt;舞&lt;/span&gt;&lt;span data-raw-text=&quot;团&quot; data-textnode-index=&quot;448&quot; data-index=&quot;8550&quot;&gt;团&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span data-raw-text=&quot;奇&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8551&quot;&gt;奇&lt;/span&gt;&lt;span data-raw-text=&quot;舞&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8552&quot;&gt;舞&lt;/span&gt;&lt;span data-raw-text=&quot;团&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8553&quot;&gt;团&lt;/span&gt;&lt;span data-raw-text=&quot;是&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8554&quot;&gt;是&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;449&quot; data-index=&quot;8555&quot;&gt; &lt;/span&gt;&lt;span data-raw-text=&quot;3&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8556&quot;&gt;3&lt;/span&gt;&lt;span data-raw-text=&quot;6&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8557&quot;&gt;6&lt;/span&gt;&lt;span data-raw-text=&quot;0&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8558&quot;&gt;0&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;449&quot; data-index=&quot;8559&quot;&gt; &lt;/span&gt;&lt;span data-raw-text=&quot;集&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8560&quot;&gt;集&lt;/span&gt;&lt;span data-raw-text=&quot;团&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8561&quot;&gt;团&lt;/span&gt;&lt;span data-raw-text=&quot;最&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8562&quot;&gt;最&lt;/span&gt;&lt;span data-raw-text=&quot;大&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8563&quot;&gt;大&lt;/span&gt;&lt;span data-raw-text=&quot;的&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8564&quot;&gt;的&lt;/span&gt;&lt;span data-raw-text=&quot;大&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8565&quot;&gt;大&lt;/span&gt;&lt;span data-raw-text=&quot;前&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8566&quot;&gt;前&lt;/span&gt;&lt;span data-raw-text=&quot;端&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8567&quot;&gt;端&lt;/span&gt;&lt;span data-raw-text=&quot;团&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8568&quot;&gt;团&lt;/span&gt;&lt;span data-raw-text=&quot;队&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8569&quot;&gt;队&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8570&quot;&gt;，&lt;/span&gt;&lt;span data-raw-text=&quot;代&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8571&quot;&gt;代&lt;/span&gt;&lt;span data-raw-text=&quot;表&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8572&quot;&gt;表&lt;/span&gt;&lt;span data-raw-text=&quot;集&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8573&quot;&gt;集&lt;/span&gt;&lt;span data-raw-text=&quot;团&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8574&quot;&gt;团&lt;/span&gt;&lt;span data-raw-text=&quot;参&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8575&quot;&gt;参&lt;/span&gt;&lt;span data-raw-text=&quot;与&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8576&quot;&gt;与&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;449&quot; data-index=&quot;8577&quot;&gt; &lt;/span&gt;&lt;span data-raw-text=&quot;W&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8578&quot;&gt;W&lt;/span&gt;&lt;span data-raw-text=&quot;3&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8579&quot;&gt;3&lt;/span&gt;&lt;span data-raw-text=&quot;C&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8580&quot;&gt;C&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;449&quot; data-index=&quot;8581&quot;&gt; &lt;/span&gt;&lt;span data-raw-text=&quot;和&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8582&quot;&gt;和&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;449&quot; data-index=&quot;8583&quot;&gt; &lt;/span&gt;&lt;span data-raw-text=&quot;E&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8584&quot;&gt;E&lt;/span&gt;&lt;span data-raw-text=&quot;C&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8585&quot;&gt;C&lt;/span&gt;&lt;span data-raw-text=&quot;M&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8586&quot;&gt;M&lt;/span&gt;&lt;span data-raw-text=&quot;A&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8587&quot;&gt;A&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;449&quot; data-index=&quot;8588&quot;&gt; &lt;/span&gt;&lt;span data-raw-text=&quot;会&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8589&quot;&gt;会&lt;/span&gt;&lt;span data-raw-text=&quot;员&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8590&quot;&gt;员&lt;/span&gt;&lt;span data-raw-text=&quot;（&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8591&quot;&gt;（&lt;/span&gt;&lt;span data-raw-text=&quot;T&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8592&quot;&gt;T&lt;/span&gt;&lt;span data-raw-text=&quot;C&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8593&quot;&gt;C&lt;/span&gt;&lt;span data-raw-text=&quot;3&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8594&quot;&gt;3&lt;/span&gt;&lt;span data-raw-text=&quot;9&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8595&quot;&gt;9&lt;/span&gt;&lt;span data-raw-text=&quot;）&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8596&quot;&gt;）&lt;/span&gt;&lt;span data-raw-text=&quot;工&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8597&quot;&gt;工&lt;/span&gt;&lt;span data-raw-text=&quot;作&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8598&quot;&gt;作&lt;/span&gt;&lt;span data-raw-text=&quot;。&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8599&quot;&gt;。&lt;/span&gt;&lt;span data-raw-text=&quot;奇&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8600&quot;&gt;奇&lt;/span&gt;&lt;span data-raw-text=&quot;舞&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8601&quot;&gt;舞&lt;/span&gt;&lt;span data-raw-text=&quot;团&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8602&quot;&gt;团&lt;/span&gt;&lt;span data-raw-text=&quot;非&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8603&quot;&gt;非&lt;/span&gt;&lt;span data-raw-text=&quot;常&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8604&quot;&gt;常&lt;/span&gt;&lt;span data-raw-text=&quot;重&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8605&quot;&gt;重&lt;/span&gt;&lt;span data-raw-text=&quot;视&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8606&quot;&gt;视&lt;/span&gt;&lt;span data-raw-text=&quot;人&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8607&quot;&gt;人&lt;/span&gt;&lt;span data-raw-text=&quot;才&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8608&quot;&gt;才&lt;/span&gt;&lt;span data-raw-text=&quot;培&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8609&quot;&gt;培&lt;/span&gt;&lt;span data-raw-text=&quot;养&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8610&quot;&gt;养&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8611&quot;&gt;，&lt;/span&gt;&lt;span data-raw-text=&quot;有&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8612&quot;&gt;有&lt;/span&gt;&lt;span data-raw-text=&quot;工&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8613&quot;&gt;工&lt;/span&gt;&lt;span data-raw-text=&quot;程&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8614&quot;&gt;程&lt;/span&gt;&lt;span data-raw-text=&quot;师&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8615&quot;&gt;师&lt;/span&gt;&lt;span data-raw-text=&quot;、&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8616&quot;&gt;、&lt;/span&gt;&lt;span data-raw-text=&quot;讲&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8617&quot;&gt;讲&lt;/span&gt;&lt;span data-raw-text=&quot;师&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8618&quot;&gt;师&lt;/span&gt;&lt;span data-raw-text=&quot;、&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8619&quot;&gt;、&lt;/span&gt;&lt;span data-raw-text=&quot;翻&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8620&quot;&gt;翻&lt;/span&gt;&lt;span data-raw-text=&quot;译&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8621&quot;&gt;译&lt;/span&gt;&lt;span data-raw-text=&quot;官&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8622&quot;&gt;官&lt;/span&gt;&lt;span data-raw-text=&quot;、&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8623&quot;&gt;、&lt;/span&gt;&lt;span data-raw-text=&quot;业&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8624&quot;&gt;业&lt;/span&gt;&lt;span data-raw-text=&quot;务&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8625&quot;&gt;务&lt;/span&gt;&lt;span data-raw-text=&quot;接&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8626&quot;&gt;接&lt;/span&gt;&lt;span data-raw-text=&quot;口&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8627&quot;&gt;口&lt;/span&gt;&lt;span data-raw-text=&quot;人&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8628&quot;&gt;人&lt;/span&gt;&lt;span data-raw-text=&quot;、&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8629&quot;&gt;、&lt;/span&gt;&lt;span data-raw-text=&quot;团&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8630&quot;&gt;团&lt;/span&gt;&lt;span data-raw-text=&quot;队&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8631&quot;&gt;队&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;449&quot; data-index=&quot;8632&quot;&gt; &lt;/span&gt;&lt;span data-raw-text=&quot;L&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8633&quot;&gt;L&lt;/span&gt;&lt;span data-raw-text=&quot;e&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8634&quot;&gt;e&lt;/span&gt;&lt;span data-raw-text=&quot;a&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8635&quot;&gt;a&lt;/span&gt;&lt;span data-raw-text=&quot;d&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8636&quot;&gt;d&lt;/span&gt;&lt;span data-raw-text=&quot;e&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8637&quot;&gt;e&lt;/span&gt;&lt;span data-raw-text=&quot;r&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8638&quot;&gt;r&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;449&quot; data-index=&quot;8639&quot;&gt; &lt;/span&gt;&lt;span data-raw-text=&quot;等&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8640&quot;&gt;等&lt;/span&gt;&lt;span data-raw-text=&quot;多&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8641&quot;&gt;多&lt;/span&gt;&lt;span data-raw-text=&quot;种&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8642&quot;&gt;种&lt;/span&gt;&lt;span data-raw-text=&quot;发&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8643&quot;&gt;发&lt;/span&gt;&lt;span data-raw-text=&quot;展&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8644&quot;&gt;展&lt;/span&gt;&lt;span data-raw-text=&quot;方&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8645&quot;&gt;方&lt;/span&gt;&lt;span data-raw-text=&quot;向&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8646&quot;&gt;向&lt;/span&gt;&lt;span data-raw-text=&quot;供&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8647&quot;&gt;供&lt;/span&gt;&lt;span data-raw-text=&quot;员&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8648&quot;&gt;员&lt;/span&gt;&lt;span data-raw-text=&quot;工&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8649&quot;&gt;工&lt;/span&gt;&lt;span data-raw-text=&quot;选&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8650&quot;&gt;选&lt;/span&gt;&lt;span data-raw-text=&quot;择&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8651&quot;&gt;择&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8652&quot;&gt;，&lt;/span&gt;&lt;span data-raw-text=&quot;并&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8653&quot;&gt;并&lt;/span&gt;&lt;span data-raw-text=&quot;辅&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8654&quot;&gt;辅&lt;/span&gt;&lt;span data-raw-text=&quot;以&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8655&quot;&gt;以&lt;/span&gt;&lt;span data-raw-text=&quot;提&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8656&quot;&gt;提&lt;/span&gt;&lt;span data-raw-text=&quot;供&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8657&quot;&gt;供&lt;/span&gt;&lt;span data-raw-text=&quot;相&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8658&quot;&gt;相&lt;/span&gt;&lt;span data-raw-text=&quot;应&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8659&quot;&gt;应&lt;/span&gt;&lt;span data-raw-text=&quot;的&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8660&quot;&gt;的&lt;/span&gt;&lt;span data-raw-text=&quot;技&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8661&quot;&gt;技&lt;/span&gt;&lt;span data-raw-text=&quot;术&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8662&quot;&gt;术&lt;/span&gt;&lt;span data-raw-text=&quot;力&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8663&quot;&gt;力&lt;/span&gt;&lt;span data-raw-text=&quot;、&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8664&quot;&gt;、&lt;/span&gt;&lt;span data-raw-text=&quot;专&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8665&quot;&gt;专&lt;/span&gt;&lt;span data-raw-text=&quot;业&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8666&quot;&gt;业&lt;/span&gt;&lt;span data-raw-text=&quot;力&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8667&quot;&gt;力&lt;/span&gt;&lt;span data-raw-text=&quot;、&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8668&quot;&gt;、&lt;/span&gt;&lt;span data-raw-text=&quot;通&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8669&quot;&gt;通&lt;/span&gt;&lt;span data-raw-text=&quot;用&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8670&quot;&gt;用&lt;/span&gt;&lt;span data-raw-text=&quot;力&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8671&quot;&gt;力&lt;/span&gt;&lt;span data-raw-text=&quot;、&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8672&quot;&gt;、&lt;/span&gt;&lt;span data-raw-text=&quot;领&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8673&quot;&gt;领&lt;/span&gt;&lt;span data-raw-text=&quot;导&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8674&quot;&gt;导&lt;/span&gt;&lt;span data-raw-text=&quot;力&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8675&quot;&gt;力&lt;/span&gt;&lt;span data-raw-text=&quot;等&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8676&quot;&gt;等&lt;/span&gt;&lt;span data-raw-text=&quot;培&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8677&quot;&gt;培&lt;/span&gt;&lt;span data-raw-text=&quot;训&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8678&quot;&gt;训&lt;/span&gt;&lt;span data-raw-text=&quot;课&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8679&quot;&gt;课&lt;/span&gt;&lt;span data-raw-text=&quot;程&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8680&quot;&gt;程&lt;/span&gt;&lt;span data-raw-text=&quot;。&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8681&quot;&gt;。&lt;/span&gt;&lt;span data-raw-text=&quot;奇&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8682&quot;&gt;奇&lt;/span&gt;&lt;span data-raw-text=&quot;舞&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8683&quot;&gt;舞&lt;/span&gt;&lt;span data-raw-text=&quot;团&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8684&quot;&gt;团&lt;/span&gt;&lt;span data-raw-text=&quot;以&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8685&quot;&gt;以&lt;/span&gt;&lt;span data-raw-text=&quot;开&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8686&quot;&gt;开&lt;/span&gt;&lt;span data-raw-text=&quot;放&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8687&quot;&gt;放&lt;/span&gt;&lt;span data-raw-text=&quot;和&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8688&quot;&gt;和&lt;/span&gt;&lt;span data-raw-text=&quot;求&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8689&quot;&gt;求&lt;/span&gt;&lt;span data-raw-text=&quot;贤&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8690&quot;&gt;贤&lt;/span&gt;&lt;span data-raw-text=&quot;的&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8691&quot;&gt;的&lt;/span&gt;&lt;span data-raw-text=&quot;心&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8692&quot;&gt;心&lt;/span&gt;&lt;span data-raw-text=&quot;态&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8693&quot;&gt;态&lt;/span&gt;&lt;span data-raw-text=&quot;欢&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8694&quot;&gt;欢&lt;/span&gt;&lt;span data-raw-text=&quot;迎&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8695&quot;&gt;迎&lt;/span&gt;&lt;span data-raw-text=&quot;各&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8696&quot;&gt;各&lt;/span&gt;&lt;span data-raw-text=&quot;种&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8697&quot;&gt;种&lt;/span&gt;&lt;span data-raw-text=&quot;优&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8698&quot;&gt;优&lt;/span&gt;&lt;span data-raw-text=&quot;秀&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8699&quot;&gt;秀&lt;/span&gt;&lt;span data-raw-text=&quot;人&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8700&quot;&gt;人&lt;/span&gt;&lt;span data-raw-text=&quot;才&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8701&quot;&gt;才&lt;/span&gt;&lt;span data-raw-text=&quot;关&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8702&quot;&gt;关&lt;/span&gt;&lt;span data-raw-text=&quot;注&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8703&quot;&gt;注&lt;/span&gt;&lt;span data-raw-text=&quot;和&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8704&quot;&gt;和&lt;/span&gt;&lt;span data-raw-text=&quot;加&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8705&quot;&gt;加&lt;/span&gt;&lt;span data-raw-text=&quot;入&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8706&quot;&gt;入&lt;/span&gt;&lt;span data-raw-text=&quot;奇&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8707&quot;&gt;奇&lt;/span&gt;&lt;span data-raw-text=&quot;舞&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8708&quot;&gt;舞&lt;/span&gt;&lt;span data-raw-text=&quot;团&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8709&quot;&gt;团&lt;/span&gt;&lt;span data-raw-text=&quot;。&quot; data-textnode-index=&quot;449&quot; data-index=&quot;8710&quot;&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34490238611713664&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cAd6ObKOzECqoVbtplgn1lGUicQXib1OKicq8iaxkE3PtFkU0vKvjPRn87LrAgYXw6wJfxiaSQgXiaE3DWSBRDJG39bA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1844&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f5aa5ca2d6290de7ee1c822f8a3d2e4e</guid>
<title>抖音生猛，张小龙以退为进；30天JS编程挑战；解读Go语言的2021——码农周刊VIP会员专属邮件周报 Vol.077</title>
<link>https://toutiao.io/k/bu7r4pt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>