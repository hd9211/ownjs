<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ee4b15e708027c32360dd304a4a03028</guid>
<title>工具 | 英伟达开源的一个新的 PyTorch 库</title>
<link>https://toutiao.io/k/5wg0hgp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>98fe28c2683d82e0fd6a02b2f952c8f4</guid>
<title>[推荐] CPU 飙高，系统性能问题如何排查？</title>
<link>https://toutiao.io/k/h1mu8e9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLqLGSRLxM4Z2QKpUVWyztuKkVz6qy2UISPOun8iau5GjXBzLmzJJ9RdPvbI4jWU08IpfibRLQ9deAQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;p&gt;&lt;span&gt;阿里妹导读：&lt;/span&gt;&lt;span&gt;压测时或多或少都收到过CPU或者Load高的告警，如果是单机偶发性的，经常会认为是“宿主机抢占导致的”，那事实是否真是如此呢？是什么引起了这些指标的飙高？网络、磁盘还是高并发？有什么工具可以定位？TOP、PS还是vmstat？CPU高&amp;amp;Load高和CPU低&amp;amp;Load高，不同的表征又代表着什么？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;文末福利：&lt;span&gt;免费下载&lt;/span&gt;《ECS运维指南之Linux系统诊断&lt;span&gt;》电子书&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6076146076146076&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs13Xt6rh8gdsx0AnzhRjVq2OkzxjxVtXvBLQvzozfYA4WSykPJ51QVuFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1287&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;一  背景知识&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;LINUX进程状态&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;LINUX 2.6以后的内核中，进程一般存在7种基础状态：D-不可中断睡眠、R-可执行、S-可中断睡眠、T-暂停态、t-跟踪态、X-死亡态、Z-僵尸态，这几种状态在PS命令中有对应解释。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1806853582554517&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs13UqwyJDBg37hT8swox1Cln6BYWH2LWfA3P9VPEq6E3dbcBxys1cZmWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1284&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Load Average &amp;amp; CPU使用率&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;谈到系统性能，Load和CPU使用率是最直观的两个指标，那么这两个指标是怎么被计算出来的呢？是否能互相等价呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Load Average&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不少人都认为，Load代表正在CPU上运行&amp;amp;等待运行的进程数，即&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.09817671809256662&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs13OldyMmZCBicJAfEnL1NHOzqOs1iaiaeCoHLpkjk6FemialiaGDxWwAHDYww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;713&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但Linux系统中，这种描述并不完全准确。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下为Linux内核源码中Load Average计算方法，可以看出来，因此除了可执行态进程，不可中断睡眠态进程也会被一起纳入计算，即：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.05236907730673317&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs13p6Hniaw9aBVgDiaTCtqgu7Rr6pKicfR3SOniaaDA9FVSic1vAgAYOaC98jQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1203&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;602staticunsignedlongcount_active_tasks(void)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;603&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;604structtask_struct*p;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;605unsignedlongnr&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;0;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;606607read_lock(&amp;amp;tasklist_lock);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;608for_each_task(p)&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;609if&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;((p-&amp;gt;state==TASK_RUNNING610 (p-&amp;gt;state&amp;amp;TASK_UNINTERRUPTIBLE)))&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;611nr+&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;FIXED_1;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;612&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;613read_unlock(&amp;amp;tasklist_lock);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;614returnnr;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;615&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;......&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;625staticinlinevoidcalc_load(unsignedlongticks)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;626&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;627unsignedlongactive_tasks;&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;/* fixed-point */628staticintcount=LOAD_FREQ;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;629630count-&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;ticks;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;631if&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;(count&amp;lt;0) {&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;632count+&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;LOAD_FREQ;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;633active_tasks&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;count_active_tasks();&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;634CALC_LOAD(avenrun[0],&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;EXP_1, active_tasks);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;635CALC_LOAD(avenrun[1],&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;EXP_5, active_tasks);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;636CALC_LOAD(avenrun[2],&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;EXP_15, active_tasks);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;637&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;638&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在前文 Linux进程状态 中有提到过，不可中断睡眠态的进程(TASK_UNINTERRUTED)一般都在进行I/O等待，比如磁盘、网络或者其他外设等待。由此我们可以看出，Load Average在Linux中体现的是整体系统负载，即CPU负载 + Disk负载 + 网络负载 + 其余外设负载，并不能完全等同于CPU使用率(这种情况只出现在Linux中，其余系统比如Unix，Load还是只代表CPU负载)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;CPU使用率&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CPU的时间分片一般可分为4大类：用户进程运行时间 - User Time, 系统内核运行时间 - System Time, 空闲时间 - Idle Time, 被抢占时间 - Steal Time。除了Idle Time外，其余时间CPU都处于工作运行状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8610526315789474&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs13NkGgIGfVJdeM86ibhXy8wklbRAS9oPoEw3JzXw3EkOIInWichAEXQGQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;950&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通常而言，我们泛指的整体CPU使用率为User Time 和 Systime占比之和(例如tsar中CPU util)，即：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.13093525179856116&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs13xsnAXZlZNwDNzxd39WtKr02SOqoaC7xwBfsgPR2km18or5lemBDH9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;695&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了便于定位问题，大多数性能统计工具都将这4类时间片进一步细化成了8类，如下为TOP对CPU时间片的分类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.14093428345209819&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs134JwQO9X9fvRnbtiaksKXdQCfljEGYyt77fm3HWvtZ7iaCZeWhicwQtn3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1263&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这8类分片中，除wa和id外，其余分片CPU都处于工作态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;二  资源&amp;amp;瓶颈分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上文我们了解到，Load Average和CPU使用率可被细分为不同的子域指标，指向不同的资源瓶颈。总体来说，指标与资源瓶颈的对应关系基本如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6057319907048799&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs13ka70PfcOPtzMkwt17mbEicabmxnT8b91nvIPXPUot4CENjO2RGRibHuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1291&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Load高 &amp;amp; CPU高&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是我们最常遇到的一类情况，即load上涨是CPU负载上升导致。根据CPU具体资源分配表现，可分为以下几类：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;CPU sys高&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种情况CPU主要开销在于系统内核，可进一步查看上下文切换情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;CPU si高&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种情况CPU大量消耗在软中断，可进一步查看软中断类型。一般而言，网络I/O或者线程调度引起软中断最为常见：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;CPU us高&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种情况说明资源主要消耗在应用进程，可能引发的原因有以下几类：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Load高 &amp;amp; CPU低&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种情况出现的根本原因在于不可中断睡眠态(TASK_UNINTERRUPTIBLE)进程数较多，即CPU负载不高，但I/O负载较高。可进一步定位是磁盘I/O还是网络I/O导致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;三  排查策略&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;利用现有常用的工具，我们常用的排查策略基本如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6327467482785004&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs13jMZeGFd94Twb8icTwibADmSehCDqGrCymSR5myUEic5WN09ribH90nJnCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1307&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从问题发现到最终定位，基本可分为四个阶段：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;资源瓶颈定位&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一阶段通过全局性能检测工具，初步定位资源消耗异常位点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;常用的工具有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;热点进程定位&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;定位到资源瓶颈后，可进一步分析具体进程资源消耗情况，找到热点进程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;常用工具有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;上下文切换：pidstat -w&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CPU&lt;span&gt;：&lt;/span&gt;pidstat -u&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;I/O&lt;span&gt;：&lt;/span&gt;iotop、pidstat -d&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;僵尸进程&lt;span&gt;：&lt;/span&gt;ps&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;线程&amp;amp;进程内部资源定位&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;找到具体进程后，可细化分析进程内部资源开销情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;常用工具有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;热点事件&amp;amp;方法分析&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;获取到热点线程后，我们可用trace或者dump工具，将线程反向关联，将问题范围定位到具体方法&amp;amp;堆栈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;常用的工具有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;相关阅读&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[1]Linux Load Averages: Solving the Mystery&lt;br/&gt;http://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[2]What exactly is a load average?&lt;br/&gt;http://linuxtechsupport.blogspot.com/2008/10/what-exactly-is-load-average.html&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;电子书免费下载&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;《ECS运维指南 之 Linux系统诊断》&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.4143490528012899&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs13mFxuOHQUtPOc74R27jQmckLEMKEcsuBxoGo7qAVxDuD1IMNbKAiayzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2481&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本书以浅显易懂的案例带领您进入Linux的世界，由浅入深，由表及里，层层推进，从运维工作的实际需求出发，全面讲解相关的技术、经典案例，以及常见问题的解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;点击“阅读原文”&lt;/span&gt;，立即下载吧！  &lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot; data-s=&quot;300,640&quot; data-copyright=&quot;0&quot; data-cropsely2=&quot;182&quot; data-cropsely1=&quot;0&quot; data-cropselx2=&quot;180&quot; data-cropselx1=&quot;0&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naKjYl1NicXGw20r286y3CF1Jc5iafxBBXzN9GyerB7AMQAPeGCGZA57Ha7w75vickdc4aFAsBNicyVfgg/640?wx_fmt=jpeg&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;关注&lt;/span&gt;&lt;span&gt;「阿里技术」&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;把握前沿技术脉搏&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Z6bicxIx5naLWBBEcl44aIic1Mthe1nZiaramW5s4e8WwyCYYbTzu6uPBpgI6sxNXNymEnOYKpJpcrItUia7lS64mA/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;戳我，下载电子书。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>48a2b4a963a88c82afdefd34c1e3866d</guid>
<title>[推荐] 45 张图庖丁解牛 18 种 Queue，你知道几种？</title>
<link>https://toutiao.io/k/fvryjlb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在讲&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&amp;amp;mid=2451944303&amp;amp;idx=1&amp;amp;sn=6fc5a3198e4216eed667a26648028b71&amp;amp;chksm=8d1c4af0ba6bc3e6c5b4638c8e33deac79f8646343a03ba44e10dcb14a0eeb7095f437e9c554&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《集合的线程不安全》&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《21张图讲解集合的线程不安全》&lt;/a&gt;那一篇，我留了一个彩蛋，就是&lt;span&gt;&lt;strong&gt;Queue（队列）&lt;/strong&gt;&lt;/span&gt;还没有讲，这次我们重点来看看Java中的Queue家族，总共涉及到&lt;strong&gt;18&lt;/strong&gt;种Queue。这篇恐怕是市面上&lt;span&gt;&lt;strong&gt;最全最细&lt;/strong&gt;&lt;/span&gt;讲解Queue的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本篇主要内容如下：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9628712871287128&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJhNWArwClvXEychM1SLu16haahZJutLlwmmNLdlICS0mOCst9z1SZYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;808&quot;/&gt;&lt;figcaption&gt;本篇主要内容&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;帮你总结好的阻塞队列：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8221830985915493&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJk9SYIaS9gMG3vSJeTVaZJ0rRQp4d1dbgU5YlrQXsM2Ha5z02bnYAZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;568&quot;/&gt;&lt;figcaption&gt;18种Queue总结&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、Queue自我介绍&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3476764199655766&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJZwicYhUaj40hMochInxf003SmMGtLQb5afaOZ0juicy2PT5ESicpYKw7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;581&quot;/&gt;&lt;figcaption&gt;队列原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 Queue自我介绍&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;hi，大家好，我的英文名叫&lt;code&gt;Queue&lt;/code&gt;，中文名叫&lt;code&gt;队列&lt;/code&gt;，无论现实生活中还是计算机的世界中，我都是一个很重要的角色哦~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是一种&lt;code&gt;数据结构&lt;/code&gt;，大家可以把我想象成一个数组，元素从我的一头进入、从另外一头出去，称为FIFO原则（先进先出原则）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我还有两个亲兄弟：&lt;code&gt;List&lt;/code&gt;（列表）、&lt;code&gt;Set&lt;/code&gt;（集），他们都是&lt;code&gt;Collection&lt;/code&gt;的儿子，我还有一个远房亲戚：&lt;code&gt;Map&lt;/code&gt;（映射）。他们都是&lt;code&gt;java.util&lt;/code&gt;包这个大家庭的成员哦~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 现实生活中的场景&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;海底捞排号等位（先排号的优先进餐厅）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;邮政员寄送信件（信箱是队列）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3 计算机世界中的场景&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;消息队列 RabbitMQ&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;UDP协议（接收端将消息存放在队列中，从队列中读取数据）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、高屋建瓴，纵览全局&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;18种队列分为三大类：&lt;/strong&gt; 接口、抽象类、普通类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;弄清楚下面的继承实现关系对后面理解18种队列有很大帮助。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4917946003176284&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJibwxGsgkDzdicE71NGtiaYTurP4uq2TvvOytNDEYzxvreJ2UKUI8q8SUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1889&quot;/&gt;&lt;figcaption&gt;18个Queue的继承实现关系图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Queue&lt;/code&gt;接口&lt;strong&gt;继承&lt;/strong&gt; &lt;code&gt;Collection&lt;/code&gt;接口，&lt;code&gt;Collection&lt;/code&gt;接口&lt;strong&gt;继承&lt;/strong&gt;  &lt;code&gt;Iterable&lt;/code&gt;接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;BlockingQueue&lt;/code&gt;接口、&lt;code&gt;Deque&lt;/code&gt;接口 &lt;strong&gt;继承&lt;/strong&gt; &lt;code&gt;Queue&lt;/code&gt;接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;AbstractQueue&lt;/code&gt;抽象类&lt;strong&gt;实现&lt;/strong&gt; &lt;code&gt;Queue&lt;/code&gt;接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;BlockingDeque&lt;/code&gt;接口、&lt;code&gt;TransferQueue&lt;/code&gt;接口&lt;strong&gt;继承&lt;/strong&gt; &lt;code&gt;BlockingQueue&lt;/code&gt;接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;BlockingDeque&lt;/code&gt;接口继承&lt;code&gt;Deque&lt;/code&gt;接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;LinkedBlockingDeque&lt;/code&gt;类&lt;strong&gt;实现&lt;/strong&gt; &lt;code&gt;BlockingDeque&lt;/code&gt;接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;LinkedTransferQueue&lt;/code&gt;类接口&lt;strong&gt;实现&lt;/strong&gt; &lt;code&gt;TransferQueue&lt;/code&gt;接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;LinkedList&lt;/code&gt;类、&lt;code&gt;ArrayDeque&lt;/code&gt;类、&lt;code&gt;ConcurrentLinkedDeque&lt;/code&gt;类&lt;strong&gt;实现&lt;/strong&gt; 了&lt;code&gt;Deque&lt;/code&gt;接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;类、&lt;code&gt;LinkendBlockingQueue&lt;/code&gt;类、&lt;code&gt;LinkedBlockingDeque&lt;/code&gt;类、&lt;code&gt;LinkedTransferQueue&lt;/code&gt;类、&lt;code&gt;SynchronousQueue&lt;/code&gt;类、&lt;code&gt;PriorityBlockQueue&lt;/code&gt;类、&lt;code&gt;DelayQueue类&lt;/code&gt;&lt;strong&gt;继承&lt;/strong&gt; 了&lt;code&gt;AbstractQueue&lt;/code&gt;抽象类和&lt;strong&gt;实现&lt;/strong&gt;了BlockingQueue接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;PriorityQueue&lt;/code&gt;类和&lt;code&gt;ConcurrentLinkedQueue&lt;/code&gt;类&lt;strong&gt;继承&lt;/strong&gt; 了&lt;code&gt;AbstractQueue&lt;/code&gt;抽象类&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Deque：全称Double-Ended queue，表示双端队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类实现接口，用implements&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接口继承接口，用 extends&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类继承类，用extends&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、万物归宗Queue接口&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 深入理解Queue接口的本质&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Queue接口是一种Collection，被设计用于处理之前临时保存在某处的元素。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;除了基本的Collection操作之外，队列还提供了额外的插入、提取和检查操作。每一种操作都有两种形式：如果操作失败，则抛出一个异常；如果操作失败，则返回一个特殊值（null或false，取决于是什么操作）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;队列通常是以FIFO（先进先出）的方式排序元素，但是这不是必须的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;只有优先级队列可以根据提供的比较器对元素进行排序或者是采用正常的排序。无论怎么排序，队列的头将通过调用remove()或poll()方法进行移除。在FIFO队列种，所有新的元素被插入到队尾。其他种类的队列可能使用不同的布局来存放元素。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;每个Queue必须指定排序属性。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 Queue接口的核心方法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总共有3组方法，每一组方法对应两个方法。如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.47738693467336685&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJLhZBYql2pbJmya4wqficx8OPibDUPYwQEicadiaJWPhoz8fczkkH8BlnCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;398&quot;/&gt;&lt;figcaption&gt;Queue的核心方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;动作&lt;/th&gt;&lt;th&gt;抛异常&lt;/th&gt;&lt;th&gt;返回特殊值&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Insert&lt;/td&gt;&lt;td&gt;add(e)&lt;/td&gt;&lt;td&gt;offer(e)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Remove&lt;/td&gt;&lt;td&gt;remove()&lt;/td&gt;&lt;td&gt;poll&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Examine&lt;/td&gt;&lt;td&gt;element()&lt;/td&gt;&lt;td&gt;peek()&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（1）比如&lt;code&gt;添加（Insert）&lt;/code&gt;元素的动作，会有两种方式：&lt;code&gt;add(e)&lt;/code&gt;和&lt;code&gt;offer(e)&lt;/code&gt;。如果调用add(e)方法时，添加失败，则会&lt;code&gt;抛异常&lt;/code&gt;，而如果调用的是offer(e)方法失败时，则会&lt;code&gt;返回false&lt;/code&gt;。offer方法用于异常是正常的情况下使用，比如在有界队列中，优先使用offer方法。假如队列满了，不能添加元素，offer方法返回false，这样我们就知道是队列满了，而不是去handle运行时抛出的异常。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（2）同理，移除（Remove）元素的动作，队列为空时，remove方法抛异常，而poll返回null。如果移除头部的元素成功，则返回移除的元素。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（3）同理，检测（Examine）元素的动作，返回头部元素（最开始加入的元素），但不删除元素， 如果队列为空，则element()方法抛异常，而peek()返回false。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（4）Queue接口没有定义阻塞队列的方法，这些方法在BlockQueue接口中定义了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（5）Queue实现类通常不允许插入null元素，尽管一些实现类比如LinkedList不禁止插入null，但是还是不建议插入null，因为null也被用在poll方法的特殊返回值，以说明队列不包含元素。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、双端可用Deque接口&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 深入理解Deque接口的原理&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.33224043715846996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ8MLQ9wiaulv3bYib3zOLuvnfbFnkgrFB8fkriaHqFTN2ntuWOFLWlsWvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;915&quot;/&gt;&lt;figcaption&gt;双端队列Deque&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）Deque概念：&lt;/strong&gt; 支持两端元素插入和移除的线性集合。名称&lt;code&gt;deque&lt;/code&gt;是双端队列的缩写，通常发音为&lt;code&gt;deck&lt;/code&gt;。大多数实现Deque的类，对它们包含的元素的数量没有固定的限制的，支持有界和无界。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）Deque方法说明：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2430406852248394&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ7VI8ibWPsGfZpsUnuSFc2hNNI7B3zzdjLZtbRMJVlHKcVv5vLl9FBlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;934&quot;/&gt;&lt;figcaption&gt;Deque方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;该列表包含包含访问deque两端元素的方法，提供了插入，移除和检查元素的方法。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;这些方法种的每一种都存在两种形式：如果操作失败，则会抛出异常，另一种方法返回一个特殊值（null或false，取决于具体操作）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;插入操作的后一种形式专门设计用于容量限制的Deque实现，大多数实现中，插入操作不能失败，所以可以用插入操作的后一种形式。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Deque接口扩展了Queue接口，当使用deque作为队列时，作为FIFO。元素将添加到deque的末尾，并从头开始删除。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;作为FIFO时等价于Queue的方法如下表所示：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;img data-ratio=&quot;0.68&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJxX9R0yafxvXwyEBIB4rrib2jadpUefEHicqkiaat5U9zrA5cyXibG8MAlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;450&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如Queue的add方法和Deque的addLast方法等价。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Deque也可以用作LIFO（后进先出）栈，这个接口优于传统的Stack类。当作为栈使用时，元素被push到deque队列的头，而pop也是从队列的头pop出来。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Stack（栈）的方法正好等同于Deque的如下方法：&lt;/p&gt;&lt;img data-ratio=&quot;0.4048140043763676&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJroxMuwzueQmTSuNEQQaShTCbAElicDW4XIWG7SaXwtEBPvIYLdIGNcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;457&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：peek方法不论是作为栈还是队列，都是从队列的检测队列的头，返回最先加入的元素。比如第一次put 100，第二次put 200，则peek返回的是100。如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.27247191011235955&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ3LF89TibshJvvIP8oxB1dlc0ic1tJzkia6GGibZ876pbe1rkh4MicHxbeCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;712&quot;/&gt;&lt;figcaption&gt;示例代码&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 哪些类实现了Deque接口&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LinkedList类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ArrayDeque类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ConcurrentLinkedDeque类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingDeque类&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 哪些类继承了Deque接口&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;五、队列骨架AbstractQueue抽象类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1  深入理解AbstractQueue抽象类&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AbstractQueue是一个抽象类，继承了Queue接口，提供了一些Queue操作的骨架实现。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ2G9kCia1e7kyZwhzd0zt1TOiaUzWSuQ4iaZDsfX4hVIiciaSJhsU1MjCucw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;432&quot;/&gt;&lt;figcaption&gt;AbstractQueue的方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法add、remove、element方法基于offer、poll和peek。也就是说如果不能正常操作，则抛出异常。我们来看下AbstactQueue是怎么做到的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(E e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (offer(e))&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&lt;span&gt;&quot;Queue full&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; E &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    E x = poll();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (x != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; x;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NoSuchElementException();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; E &lt;span&gt;element&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    E x = peek();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (x != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; x;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NoSuchElementException();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果继承AbstractQueue抽象类则必须保证offer方法不允许null值插入。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 哪些类继承了AbstractQueue抽象类&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;类、&lt;code&gt;LinkendBlockingQueue&lt;/code&gt;类、&lt;code&gt;LinkedBlockingDeque&lt;/code&gt;类、&lt;code&gt;LinkedTransferQueue&lt;/code&gt;类、&lt;code&gt;SynchronousQueue&lt;/code&gt;类、&lt;code&gt;PriorityBlockQueue&lt;/code&gt;类、&lt;code&gt;DelayQueue类&lt;/code&gt;&lt;strong&gt;继承&lt;/strong&gt; 了&lt;code&gt;AbstractQueue&lt;/code&gt;抽象类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;PriorityQueue&lt;/code&gt;类和&lt;code&gt;ConcurrentLinkedQueue&lt;/code&gt;类&lt;strong&gt;继承&lt;/strong&gt; 了&lt;code&gt;AbstractQueue&lt;/code&gt;抽象类&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;六、阻塞缓冲BlockingQueue接口&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.1 宏观来看BlockingQueue（阻塞队列）&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.43462897526501765&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJqnaw8XAaeRAcAro3oBsdRJ9jJurTk1reGiaswo8ygXEHxLlbvQjqECw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;566&quot;/&gt;&lt;figcaption&gt;阻塞队列满了的情况&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.33223684210526316&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJPN2K0wCQK8JicbZwicCWWB1P7iaicWickQQpfDm5BnAdNyw1HCBn2abMaWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;608&quot;/&gt;&lt;figcaption&gt;阻塞队列为空的情况&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）BlockingQueue（阻塞队列）也是一种队列，支持阻塞的插入和移除方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）阻塞的插入：当队列满时，队列会阻塞插入元素的线程，直到队列不满。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）阻塞的移除：当队列为空，获取元素的线程会等待队列变为非空。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（5）应用场景：生产者和消费者，生产者线程向队列里添加元素，消费者线程从队列里移除元素，阻塞队列时获取和存放元素的容器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（6）为什么要用阻塞队列：生产者生产和消费者消费的速率不一样，需要用队列来解决速率差问题，当队列满了或空的时候，则需要阻塞生产或消费动作来解决队列满或空的问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.2 案例解析&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程A往阻塞队列（Blocking Queue）中&lt;code&gt;添加&lt;/code&gt;元素，而线程B从阻塞队列中&lt;code&gt;移除&lt;/code&gt;元素。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;当阻塞队列为空的时候&lt;/strong&gt; （一个元素都没有），则从队列中获取元素的操作将会被阻塞。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;生活中的案例：去海底捞吃火锅的时候，早上8点没人来吃火锅，所以需要等客人过来。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;翻译成线程：现在没有元素需要添加，而且阻塞队列为空，所以线程B不需要从队列中拿元素出来，所以线程B获取元素的操作被阻塞了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;当阻塞队列满了的时候&lt;/strong&gt; （所有位置都放有元素），则从队列中添加元素的操作将会被阻塞。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;生活中的案例：去海底捞吃火锅的时候，人太多了，需要排号，等其他桌空出来了才能进去。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;翻译成线程：线程A往阻塞队列中添加元素，将队列填满了，线程B现在正在忙，无法拿出队列中的元素，所以阻塞队列没有地方再放元素了，这个时候线程A添加元素的操作就被阻塞了&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.3 操刀BlockingQueue接口&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;BlockingQueue接口的10个核心方法：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.264935064935065&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJTx6DnvptfKQWLJvicgKze5mmJ4ahicOZdV9dFN2eFm6YcECEzSotVXkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;385&quot;/&gt;&lt;figcaption&gt;继承的方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;10个核心方法总结如下：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4692218350754936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ3gcghRqzJ1yE6VxxNLK5Op0jIKpDPwZCRPiaSLQmia1sW9e7JzaGyJxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;861&quot;/&gt;&lt;figcaption&gt;BlockingQueue接口的10个核心方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有三大类操作：插入、移除、检查。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;插入有四种方法：&lt;/strong&gt; add、offer、put、offer超时版。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;IllegalStateException&lt;/code&gt; - 队列满了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ClassCastException&lt;/code&gt; - 添加的元素类型不匹配&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;NullPointerException&lt;/code&gt; - 添加的元素为null&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt; - 添加的元素某些属性不匹配&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;add方法特别之处用于添加失败时抛出异常，共有四种异常：&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;offer方法特别之处用于添加失败时只返回false&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;put方法特别之处用于当阻塞队列满时，生产者如果往队列里put元素，则队列会一直阻塞生产者线程，直到队列可用或者响应中断退出&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;offer超时方法特别之处用于当阻塞队列满时，生产者如果往队列里面插入元素，队列会阻塞生产者线程一段时间，如果超过了指定时间，生产者线程会退出，并返回false。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;移除有四种方法：&lt;/strong&gt; remove、poll、take、poll超时版&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;NoSuchElementException&lt;/code&gt; - 如果这个队列是空的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;remove方法特别之处用于移除失败时抛出异常&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;poll方法特别之处用于移除失败时返回null&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;take方法特别之处用于当阻塞队列为空时，消费者线程如果从队列里面移除元素，则队列会一直阻塞消费者线程，直到队列不为空&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;poll超时方法特别之处用于当阻塞队列空时，消费者如果从队列里面删除元素，则队列会一直阻塞消费者线程，如果超过了指定时间，消费者线程会退出，并返回null&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;检查有两种方法：&lt;/strong&gt; element、peek&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;element方法用于检测头部元素的存在性，如果队列为空，则抛出异常，否则返回头部元素。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;peek方法用于检测头部元素的存在性，如果队列为空，返回特殊值null，否则返回头部的元素。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.4 BlockingQueue通过什么来阻塞插入和移除的？&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当往队列里插入一个元素时，如果队列不可用，那么阻塞生产者主要通过LockSupport. park（this）来实现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;park这个方法会阻塞当前线程，只有以下4种情况中的一种发生时，该方法才会返回。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;与park对应的unpark执行或已经执行时。“已经执行”是指unpark先执行，然后再执行park的情况。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程被中断时。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;等待完time参数指定的毫秒数时。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异常现象发生时，这个异常现象没有任何原因。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.5 哪些类继承了BlockingQueue接口？&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;BlockingDeque接口 - 双端阻塞队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TransferQueue接口 - 传输队列&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.6 哪些类实现了BlockingQueue接口？&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ArrayBlockingQueue类 - 由数组构成的有界阻塞队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue类 - 由链表构成的有界阻塞队列，界限默认大小为Integer.MAX_Value（2^31-1），值非常大，相当于无界。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingDeque类 - 由链表构成的双向阻塞队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedTransferQueue类 - 由链表构成的无界阻塞队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SynchronousQueue类 - 不存储元素的阻塞队列，只有一个元素进行数据传递。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedTransferQueue类 - 由链表构成的无界阻塞TransferQueue队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DelayQueue类 - 使用优先级队列实现的延迟无界阻塞队列&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.6 BlockingQueue接口继承了哪些接口&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;BlockingQueue接口继承了Queue接口，可作为队列使用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;七、双端阻塞BlockingDeque接口&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.1 从原理图上理解BlockDeque&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;BlockQueue满了，两端的Take操作被阻塞&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3497142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJu0Jg2A69ic93bxxdFjpsLsFIguhbK9Ke82mqjiaswzzwK2xXicZicVUAQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;875&quot;/&gt;&lt;figcaption&gt;BlockingDeque满了&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;BlockQueue为空，两端的Take操作被阻塞&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.38426453819840367&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJAiabUoZo3H9L6zP16Zeq6139w2jxIcnU7ZeE7bcfug0UFbo0iaLbj8OQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;877&quot;/&gt;&lt;figcaption&gt;BlockQueue为空&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.2 BlockingDeque接口方法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是阻塞队列&lt;code&gt;BlockingQueue&lt;/code&gt;和双向队列&lt;code&gt;Deque&lt;/code&gt;接口的结合。有如下方法：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJqO622N0N9UqV3AXvbJ2PDYIaCiahWq1OYibGaZ8n0MqeoicibPXPd3QHrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;figcaption&gt;BlockingDeque接口方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尝试执行以下方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;LinkedBlockingDeque queue = &lt;span&gt;new&lt;/span&gt; LinkedBlockingDeque();&lt;br/&gt;queue.addFirst(&lt;span&gt;&quot;test1&quot;&lt;/span&gt;);&lt;br/&gt;queue.addFirst(&lt;span&gt;300&lt;/span&gt;);&lt;br/&gt;queue.addLast(&lt;span&gt;&quot;400&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后队列中的元素顺序如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;300, test1, 400。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先添加了test1放到队列的头部，然后在头部的前面放入300，所以300在最前面，成为头部，然后将400放入队列的尾部，所以最后的结果是300, test1, 400。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4056737588652482&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ6oonNqOfibNa8YwtexzxUzXPgFDtfVLehI0yFCt1zQl7NoT4MdOTtPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;705&quot;/&gt;&lt;figcaption&gt;队列种的元素&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.3 BlockDeque和BlockQueue的对等方法&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9040767386091128&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJdvRsiaEcrAbBsgbZW0dq7nB1JJj8Me072ic4m71emBpauL6IXpIpHesQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;417&quot;/&gt;&lt;figcaption&gt;BlockDeque和BlockQueue的对等方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.4 BlockingDeque的特点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程安全。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不允许使用null元素。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;无界和有界都可以。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.5 BlockingDeque接口继承了哪些接口？&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Queue接口，具有队列的功能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Deque接口，具有双端队列的功能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;BlockingQueue接口，可作为阻塞队列使用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.6 哪些类实现了BlockDeque接口？&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;八、使命必达TransferQueue接口&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.1 Transfer怎么理解？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有消费者正在获取元素，则将队列中的元素传递给消费者。如果没有消费者，则等待消费者消费。我把它称作使命必达队列，必须将任务完成才能返回。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.2 生活中的案例&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;针对TransferQueue的transfer方法&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;圆通快递员要将小明的2个快递送货到门，韵达快递员也想将小明的2个快递送货到门。小明一次只能拿一个，快递员必须等小明拿了一个后，才能继续给第二个。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;针对TransferQueue的tryTransfer方法&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;圆通快递员要将小明的2个快递送货到门，韵达快递员也想将小明的2个快递送货到门。发现小明不在家，就把快递直接放到菜鸟驿站了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;针对TransferQueue的tryTransfer超时方法&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;圆通快递员要将小明的2个快递送货到门，韵达快递员也想将小明的2个快递送货到门。发现小明不在家，于是先等了5分钟，发现小明还没有回来，就把快递直接放到菜鸟驿站了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.3 TransferQueue的原理解析&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;transfer(E e)&lt;/code&gt;&lt;/p&gt;&lt;p&gt;原理如下图所示：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.1124807395993837&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJHichW8Licd6XGq1yuzqVshsJ5bZz5iclmEjtNPSPEL4licLI7kN8OKMXvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;649&quot;/&gt;&lt;figcaption&gt;transfer方法的原理&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;原理图解释：生产者线程Producer Thread尝试将元素B传给消费者线程，如果没有消费者线程，则将元素B放到尾节点。并且生产者线程等待元素B被消费。当元素B被消费后，生产者线程返回。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果当前有消费者正在等待接收元素（消费者通过take方法或超时限制的poll方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果没有消费者等待接收元素，transfer方法会将元素放在队列的tail（尾）节点，并等到该元素被消费者消费了才返回。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;tryTransfer(E e)&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;试探生产者传入的元素是否能直接传给消费者。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果没有消费者等待接收元素，则返回false。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;和transfer方法的区别是，无论消费者是否接收，方法立即返回。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;tryTransfer(E e, long timeout, TimeUnit unit)&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;带有时间限制的tryTransfer方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;试图把生产者传入的元素直接传给消费者。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果没有消费者消费该元素则等待指定的时间再返回。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果超时了还没有消费元素，则返回false。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果在超时时间内消费了元素，则返回true。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;getWaitingConsumerCount()&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取通过BlockingQueue.take()方法或超时限制poll方法等待接受元素的消费者数量。近似值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回等待接收元素的消费者数量。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;hasWaitingConsumer()&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取是否有通过BlockingQueue.tabke()方法或超时限制poll方法等待接受元素的消费者。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回true则表示至少有一个等待消费者。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.3 TransferQueue接口继承了哪些接口？&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;BlockingQueue接口，可作为阻塞队列使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Queue接口，可作为队列使用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.4 哪些类实现了TransferQueue接口？&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;九、优先由你PriorityQueue类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9.1 理解PriorityQueue类&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2513020833333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJTcwqRggrf6iaIosrWcyFECoksV0icLMMuic2EpowLF4wWSaq0wOpDiauUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;768&quot;/&gt;&lt;figcaption&gt;本应该按照升序排序&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.40618955512572535&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ5zW3eJWFWe4bqiaud3ysVKjK6nD4e9bhaWOSChp3En8Xj07saMBokmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;517&quot;/&gt;&lt;figcaption&gt;按照自定义优先级排序&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;PriorityQueue是一个支持优先级的无界阻塞队列。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;默认自然顺序升序排序。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;可以通过构造参数Comparator来对元素进行排序。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;PriorityQueue&lt;/span&gt;&lt;span&gt;(Comparator&amp;lt;? &lt;span&gt;super&lt;/span&gt; E&amp;gt; comparator)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;this&lt;/span&gt;(DEFAULT_INITIAL_CAPACITY, comparator);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;自定义实现comapreTo()方法来指定元素排序规则。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; Comparator&amp;lt;? &lt;span&gt;super&lt;/span&gt; E&amp;gt; comparator() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; comparator;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不允许插入null元素。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实现PriorityQueue接口的类，不保证线程安全，除非是PriorityBlockingQueue。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PriorityQueue的迭代器不能保证以任何特定顺序遍历元素，如果需要有序遍历，请考虑使用&lt;code&gt;Arrays.sort(pq.toArray)&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;进列(&lt;code&gt;offer&lt;/code&gt;、&lt;code&gt;add&lt;/code&gt;)和出列（ &lt;code&gt;poll&lt;/code&gt;、&lt;code&gt;remove()&lt;/code&gt;）的时间复杂度O(log(n))。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;remove(Object) 和 contains(Object)的算法时间复杂度O(n)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;peek、element、size的算法时间复杂度为O(1)。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9.2 PriorityQueue类继承了哪些类？&lt;span/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9.2 PriorityQueue类实现了哪些接口？&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十、双向链表LinkedList类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;10.1 LinkedList的结构&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LinkedList实现了List和Deque接口，所以是一种双链表结构，可以当作堆栈、队列、双向队列使用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个双向列表的每一个元素都有三个整数值：元素、向后的节点链接、向前的节点链接&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4586709886547812&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJKmXvYjJLMscqianGo1L4esvfux0WQJB49X2G0IWRRaviaNF9d8ZgibRHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;617&quot;/&gt;&lt;figcaption&gt;LinkedList的结构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看下节点类Node&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    E item; &lt;span&gt;//元素&lt;/span&gt;&lt;br/&gt;    Node&amp;lt;E&amp;gt; next; &lt;span&gt;//向后的节点链接&lt;/span&gt;&lt;br/&gt;    Node&amp;lt;E&amp;gt; prev; &lt;span&gt;//向前的节点链接&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.item = element;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.next = next;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.prev = prev;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;10.2 与ArrayList的区别&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;1.LinkedList的增加和删除效率相对较高，而查找和修改的效率相对较低。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;2.以下情况建议使用ArrayList&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;频繁访问列表中的一个元素。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;只在列表的首尾添加元素。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;3.以下情况建议使用LinkedList&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;频繁地在列表开头、中间、末尾添加和删除元素。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要通过循环迭代来访问列表中的元素。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;10.3 LinkedList不是线程安全的&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LinkedList不是线程安全的，所以可以使用如下方式保证线程安全。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List list = Collections.synchronizedList(&lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;10.4 LinkedList的家庭成员关系&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedList 继承了 AbstractSequentialList 类。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedList 实现了 Queue 接口，可作为队列使用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedList 继承了 AbstractQueue抽象类，具有队列的功能。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedList 实现了 List 接口，可进行列表的相关操作。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedList 实现了 Deque 接口，可作为双向队列使用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedList 实现了 Cloneable 接口，可实现克隆。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十一、并发安全ConcurrentLinkedQueue类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;11.1 理解ConcurrentLinkedQueue&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.29554655870445345&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJEiaia1ZAyqIo9wdTIHSMwz086HxMSR9Pk8kr5ryOXocdOGBXYOyBgmXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1235&quot;/&gt;&lt;figcaption&gt;ConcurrentLinkedQueue原理&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ConcurrentLinked是由链表结构组成的线程安全的先进先出无界队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当多线程要共享访问集合时，ConcurrentLinkedQueue是一个比较好的选择。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不允许插入null元素&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持非阻塞地访问并发安全的队列，不会抛出ConcurrentModifiationException异常。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;size方法不是准确的，因为在统计集合的时候，队列可能正在添加元素，导致统计不准。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;批量操作addAll、removeAll、retainAll、containsAll、equals和toArray不保证原子性（操作不可分割）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;添加元素happen-before其他线程移除元素。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用法如下：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ConcurrentLinkedQueue queue = &lt;span&gt;new&lt;/span&gt; ConcurrentLinkedQueue();&lt;br/&gt;BuildingBlockWithName buildingBlock = &lt;span&gt;new&lt;/span&gt; BuildingBlockWithName(&lt;span&gt;&quot;三角形&quot;&lt;/span&gt;, &lt;span&gt;&quot;A&quot;&lt;/span&gt;);&lt;br/&gt;concurrentLinkedQueue.add(buildingBlock);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;11.2 ConcurrentLinkedQueue类继承了哪些类？&lt;span/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;11.3 ConcurrentLinkedQueue类实现了哪些接口？&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十二、双向数组ArrayDeque类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3778538812785388&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJMmrib4dwnWGTsygrFwTWibVUrswCHBI2QgUwZ8iaSl8RQ4cGKlR90ib2iaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;876&quot;/&gt;&lt;figcaption&gt;ArrayDeque原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;12.1 理解ArrayDeque&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;由数组组成的双端队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有容量限制，根据需要扩容。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不是线程安全的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;禁止插入null元素。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当用作栈时，比栈速度快，当用作队列时，速度比LinkList快。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;大部分方法的算法时间复杂度为O(1)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;remove、removeFirstOccurrence、removeLastOccurrence、contains、remove 和批量操作的算法时间复杂度O(n)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;12.2 使用方法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个ArrayDeque，往arrayDeque队尾添加元素。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ArrayDeque arrayDeque = &lt;span&gt;new&lt;/span&gt; ArrayDeque();&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;50&lt;/span&gt;; i++) {&lt;br/&gt;    arrayDeque.add(buildingBlock); &lt;span&gt;// add方法等价于addLast方法&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;12.3 ArrayDeque实现了哪些接口&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十三、双向并发ConcurrentLinkedDeque类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;13.1 理解ConcurrentLinkedDeque类&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.31805555555555554&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ9xj2FHI5oYumlvYFMqTqrl0HZ4pSU16GKmTE05BRVjrwNFkxgJ6ZPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1440&quot;/&gt;&lt;figcaption&gt;ConcurrentLinkedDeque原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;由链表结构组成的双向无界阻塞队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;插入、删除和访问操作可以并发进行，线程安全的类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不允许插入null元素&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在并发场景下，计算队列的大小是不准确的，因为计算时，可能有元素加入队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;批量操作addAll、removeAll、retainAll、containsAll、equals和toArray不保证原子性（操作不可分割）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;13.2 ConcurrentLinkedDeque使用示例&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建两个积木：三角形、四边形，然后添加到队列：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BuildingBlockWithName buildingBlock1 = &lt;span&gt;new&lt;/span&gt; BuildingBlockWithName(&lt;span&gt;&quot;三角形&quot;&lt;/span&gt;, &lt;span&gt;&quot;A&quot;&lt;/span&gt;);&lt;br/&gt;BuildingBlockWithName buildingBlock2 = &lt;span&gt;new&lt;/span&gt; BuildingBlockWithName(&lt;span&gt;&quot;四边形&quot;&lt;/span&gt;, &lt;span&gt;&quot;B&quot;&lt;/span&gt;);&lt;br/&gt;ConcurrentLinkedDeque concurrentLinkedDeque = &lt;span&gt;new&lt;/span&gt; ConcurrentLinkedDeque();&lt;br/&gt;concurrentLinkedDeque.addFirst(buildingBlock1);&lt;br/&gt;concurrentLinkedDeque.addLast(buildingBlock2);&lt;br/&gt;&lt;span&gt;//结果：顺序：三角形、四边形&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;13.3 ConcurrentLinkedDeque实现了哪些接口&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十四、数组阻塞ArrayBlockingQueue类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;14.1 理解ArrayBlockingQueue&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7349768875192604&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ4AelrbnDcEVoibNIKYw2v7b7FfnjMbYWKuicPlXm1TjbfJ2eZTvRsgicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;649&quot;/&gt;&lt;figcaption&gt;ArrayBlockingQueuey原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ArrayBlockingQueue是一个用数组实现的有界阻塞队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;队列慢时插入操作被阻塞，队列空时，移除操作被阻塞。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;按照先进先出（FIFO）原则对元素进行排序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;默认不保证线程公平的访问队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;公平访问队列：按照阻塞的先后顺序访问队列，即先阻塞的线程先访问队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格。有可能先阻塞的线程最后才访问访问队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;公平性会降低吞吐量。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;14.2 ArrayBlockingQueue使用示例&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建两个积木：三角形、四边形，然后添加到队列：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BuildingBlockWithName buildingBlock1 = &lt;span&gt;new&lt;/span&gt; BuildingBlockWithName(&lt;span&gt;&quot;三角形&quot;&lt;/span&gt;, &lt;span&gt;&quot;A&quot;&lt;/span&gt;);&lt;br/&gt;BuildingBlockWithName buildingBlock2 = &lt;span&gt;new&lt;/span&gt; BuildingBlockWithName(&lt;span&gt;&quot;四边形&quot;&lt;/span&gt;, &lt;span&gt;&quot;B&quot;&lt;/span&gt;);&lt;br/&gt;ArrayBlockingQueue arrayBlockingQueue = &lt;span&gt;new&lt;/span&gt; ArrayBlockingQueue(&lt;span&gt;100&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;arrayBlockingQueue.add(buildingBlock1);&lt;br/&gt;arrayBlockingQueue.add(buildingBlock2);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;14.3 ArrayBlockQueue实现了哪些接口&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十五、链表阻塞LinkedBlockingQueue类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;15.1 理解LinkedBlockingQueue&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.502906976744186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ52Nwoq0ticKZDgBHXwCC1rrweeTm36fsXzu2tqKF2c80rrK4xdMbK1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1032&quot;/&gt;&lt;figcaption&gt;LinkedBlockingQueue原理&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue具有单链表和有界阻塞队列的功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;队列慢时插入操作被阻塞，队列空时，移除操作被阻塞。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;默认和最大长度为Integer.MAX_VALUE，相当于无界(值非常大：2^31-1)。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;15.2 LinkedBlockingQueue使用示例&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;LinkedList linkedList1 = &lt;span&gt;new&lt;/span&gt; LinkedList();&lt;br/&gt;linkedList1.add(&lt;span&gt;&quot;A&quot;&lt;/span&gt;);&lt;br/&gt;linkedList1.add(&lt;span&gt;&quot;B&quot;&lt;/span&gt;);&lt;br/&gt;linkedList1.add(&lt;span&gt;&quot;C&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;15.3 LinkedBlockingQueue的应用场景&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;吞吐量通常要高于ArrayBlockingQueue。创建线程池时，参数runnableTaskQueue（任务队列），用于保存等待执行的任务的阻塞队列可以选择LinkedBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;15.4 LinkedBlockingQueue实现了哪些接口&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue继承了 BlockingQueue类，可作为阻塞队列使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue继承了 AbstractQueue抽象类，具有队列的功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十六、双向阻塞LinkedBlockingDeque类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;16.1 理解LinkedBlockingDeque类&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5433422698838248&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJUO5lMaTjDSMYJR8jqF6a8usvYR83tVtgMHicRqialNUOIqPyFypFJyicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1119&quot;/&gt;&lt;figcaption&gt;LinkedBlockingDeque原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;由链LinkedBlockingDeque = 阻塞队列+链表+双端访问&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程安全。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多线程同时入队时，因多了一端访问入口，所以减少了一半的竞争。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;默认容量大小为Integer.MAX_VALUE。可指定容量大小。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;16.2 LinkedBlockingDeque的应用场景&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LinkedBlockingDeque可以用在“工作窃取“模式中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;工作窃取算法&lt;/code&gt;：某个线程比较空闲，从其他线程的工作队列中的队尾窃取任务来帮忙执行。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;16.3 LinkedBlockingDeque实现了哪些接口&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingDeque继承了 BlockingDeque类，可作为阻塞队列使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingDeque继承了 AbstractQueue抽象类，具有队列的功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingDeque实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十七、链表阻塞LinkedTransferQueue类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;17.1 理解LinkedTransferQueue类&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8032608695652174&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJnuEia8W6DDz933PxpIibNqficRq8X2BvNXenMZaDiaw3DZWB7gvr0UoaCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;920&quot;/&gt;&lt;figcaption&gt;LinkedTransferQueue原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LinkedTransferQueue = 阻塞队列+链表结构+TransferQueue&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前我们讲“使命必达TransferQueue接口时&lt;strong&gt;已经介绍过了TransferQueue接口&lt;/strong&gt; ，所以LinkedTransferQueue接口跟它相似，只是加入了阻塞插入和移除的功能，以及结构是链表结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前的TransferQueue也讲到了3个案例来说明TransferQueue的原理，大家可以回看TransferQueue。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;17.2 LinkedTransferQueue接口比其他阻塞队列多了5个方法&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;transfer(E e)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tryTransfer(E e)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tryTransfer(E e, long timeout, TimeUnit unit)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;getWaitingConsumerCount()&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;hasWaitingConsumer()&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;17.3 LinkedTransferQueue代码示例&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;创建一个LinkedTransferQueue，生产者1 依次往队列中添加 A、B、C&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5511450381679389&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJzic0OgKOb0PGhzpkWvLPdlk7UULKw5catOfQnCMm29xbCcH9vHRWBng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;655&quot;/&gt;&lt;figcaption&gt;生产者1 依次往队列中添加 A、B、C&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5583941605839416&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJQMia0eDcicAuEhAfvPlQSlSjn9BKcreqro9J3ia0tt7SPz1N4GKPjbktg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;548&quot;/&gt;&lt;figcaption&gt;生产者2 依次往队列中添加 D、E、F&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;消费者依次从队列首部开始消费元素，每次消费前，先sleep 2s，来演示transfer方法是否进行了等待。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9723926380368099&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJTJYFibiaqtLNDECfEkHg2Zk1zzkEIlQJcaVKvtR1v3Nx7kWN7iaNskfVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;652&quot;/&gt;&lt;figcaption&gt;消费者消费元素&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;生产者&lt;span&gt;1&lt;/span&gt;     transfer A &lt;br/&gt;生产者&lt;span&gt;2&lt;/span&gt;     transfer D &lt;br/&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;s后...&lt;br/&gt;  &lt;br/&gt;消费者      take A&lt;br/&gt;生产者&lt;span&gt;1&lt;/span&gt;     put B &lt;br/&gt; &lt;br/&gt;&lt;span&gt;2&lt;/span&gt;s后...&lt;br/&gt;     &lt;br/&gt;消费者      take D&lt;br/&gt;生产者&lt;span&gt;2&lt;/span&gt;     transfer E &lt;br/&gt;    &lt;br/&gt;&lt;span&gt;2&lt;/span&gt;s后...&lt;br/&gt;  &lt;br/&gt;消费者      take B&lt;br/&gt;生产者&lt;span&gt;1&lt;/span&gt;     transfer C &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）首先生产者线程1和2 调用transfer方法来传输A和D，发现没有消费者线程接收，所以被阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）消费者线程过了2s后将A拿走了，然后生产者1 被释放继续执行，传输元素B，发现又没有消费者消费，所以进行了等待。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）消费者线程过了2s后，将排在队列首部的D元素拿走，生产者2继续往下执行，传输元素E，发现没有消费者，所以进行了等待。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）消费者线程过了2s后，将排在队列首部的B元素拿走，生产者1传输C元素，等待消费者拿走。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（5）消费者不再消费了，所以生产者1和生产者2都被阻塞了，元素C和，元素E都没有被拿走，而且生产者2的F元素还没有开始传输，因为在等待元素D被拿走。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（6）看下队列里面确实有C和E元素，而且E排在队列的首部。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3099787685774947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJpyZN59TpEbAz3fVWVF9I2iaibdlVbCypZ2MFI9ShP1Ap5TLhdzSzR82g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;471&quot;/&gt;&lt;figcaption&gt;队列里面的元素&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;17.4 LinkedTransferQueue实现了哪些接口&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingDeque继承了 BlockingQeque类，可作为阻塞队列使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingDeque继承了 AbstractQueue抽象类，具有队列的功能。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十八、传球好手SynchronousQueue类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;18.1 理解SynchronousQueue类&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ6zTDxpibX2gqloNEdHILkibMVpfiacObUMGxV3RHVZ5Ou42nVwpFEvqjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;810&quot;/&gt;&lt;figcaption&gt;SynchronousQueue原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;我称SynchronousQueue为”传球好手“。想象一下这个场景：小明抱着一个篮球想传给小花，如果小花没有将球拿走，则小明是不能再拿其他球的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;SynchronousQueue负责把生产者产生的数据传递给消费者线程。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;SynchronousQueue本身不存储数据，调用了put方法后，队列里面也是空的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;每一个put操作必须等待一个take操作完成，否则不能添加元素。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;适合传递性场景。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;性能高于ArrayBlockingQueue和LinkedBlockingQueue。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;18.2 SynchronousQueue示例&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们创建了两个线程，一个线程用于生产，一个线程用于消费&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.587378640776699&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJLhibG0DhicSTdXTiaohQ3axf7ibEsXKI8W2ibPjiaKFcJDT1unibdoCibbS1WA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;618&quot;/&gt;&lt;figcaption&gt;生产的线程依次put A、B、C三个值&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;消费线程使用take来消费阻塞队列中的内容，每次消费前，等待5秒&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.151291512915129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJccAiaDxjRjEND19qvu7LxwJPBq5icG2zq2icJn8jOGkA5f807RxicSYEPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;542&quot;/&gt;&lt;figcaption&gt;消费线程每隔5s调用take方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;t1     put A &lt;br/&gt;t2     take A &lt;br/&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;秒后...&lt;br/&gt;&lt;br/&gt;t1     put B &lt;br/&gt;t2     take B &lt;br/&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;秒后...&lt;br/&gt;&lt;br/&gt;t1     put C &lt;br/&gt;t2     take C &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小结：说明生产线程执行put第一个元素&quot;A&quot; 操作后，需要等待消费者线程take完“A”后，才能继续往下执行代码。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;18.1 SynchronousQueue应用场景&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;吞吐量通常要高于LinkedBlockingQueue。创建线程池时，参数runnableTaskQueue（任务队列），用于保存等待执行的任务的阻塞队列可以选择SynchronousQueue。静态工厂方法Executors.newCachedThreadPool()使用了这个队列&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;18.2 SynchronousQueue和LinkedTransferQueue的区别&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;SynchronousQueue 不存储元素，而LinkedTransferQueue存储元素。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SynchronousQueue 队列里面没有元素，而LinkedTransferQueue可以有多个存储在队列等待传输。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedTransferQueue还支持若传输不了，则丢到队列里面去。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedTransferQueue还支持若超过一定时间传输不了，则丢到队列里面去。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十九、优先级阻塞PriorityBlockingQueue类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;19.1 理解PriorityBlockQueue类&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5834333733493398&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJv5KNjwGPMD1vcFKu1LQ1pCiaAQARA1icReSHTNCHo2QDic3kUpxDe022Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;833&quot;/&gt;&lt;figcaption&gt;PriorityBlockQueue的原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;PriorityBlockQueue = PriorityQueue + BlockingQueue&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;之前我们也讲到了PriorityQueue的原理，支持对元素排序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;元素默认自然排序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以自定义CompareTo()方法来指定元素排序规则。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以通过构造函数构造参数Comparator来对元素进行排序。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;19.2 PriorityBlockQueue实现了哪些接口&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue继承了 BlockingQueue接口，可作为阻塞队列使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue继承了 AbstractQueue抽象类，具有队列的功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二十、延时阻塞DelayQueue类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;20.1 理解DelayQueue&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5750736015701668&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJV6rM80dYpyq576annxX1MbRC67ERbDEdFLRT9fDyeWavoJ0zYPjuTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1019&quot;/&gt;&lt;figcaption&gt;DelayQueue原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;DelayQueue = Delayed + BlockingQueue。队列中的元素必须实现Delayed接口。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DelayQueue&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Delayed&lt;/span&gt;&amp;gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractQueue&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt;&lt;br/&gt;    &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BlockingQueue&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在创建元素时，可以指定多久可以从队列中获取到当前元素。只有在延时期满才能从队列中获取到当前元素。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;20.2 源码解析&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;offer&lt;/span&gt;&lt;span&gt;(E e, &lt;span&gt;long&lt;/span&gt; timeout, TimeUnit unit)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; offer(e);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取元素的方法poll需要等待延时时间过了才能获取到元素&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (first == &lt;span&gt;null&lt;/span&gt; || first.getDelay(NANOSECONDS) &amp;gt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; q.poll();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5941043083900227&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJpdu4xyQQfQw7VlejFelbv6XeicsWK4Igiaiac1oDmMlSicOLtKvfXGb34g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;441&quot;/&gt;&lt;figcaption&gt;poll方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;20.3 应用场景&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;缓存系统的设计：可以用DelayQueue保存缓存元素的有效期。然后用一个线程循环的查询DelayQueue队列，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;定时任务调度：使用DelayQueue队列保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行。比如Java中的TimerQueue就是使用DelayQueue实现的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;20.4 DelayQueue实现了哪些接口&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;DelayQueue实现了 BlockingQueue接口，可作为阻塞队列使用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一篇&lt;span&gt;花了很多心思&lt;/span&gt;在上面，看&lt;strong&gt;官方英文文档、画原理图、写demo代码，排版&lt;/strong&gt;。这恐怕是市面上&lt;strong&gt;&lt;span&gt;最全最细&lt;/span&gt;&lt;/strong&gt;讲解Queue的。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cf234f3b7b9c84f459013622b73435d6</guid>
<title>[推荐] 30 个 Go 语言常用文件操作汇总，总有一个你会用的到</title>
<link>https://toutiao.io/k/kps7o16</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go官方提供的文件操作标准库分散在&lt;code&gt;os&lt;/code&gt;、&lt;code&gt;ioutil&lt;/code&gt;等多个包中，里面有非常多的方法涵盖了文件操作的所有场景，不过因为我平时开发过程中需要直接操作文件的场景其实并不多，在加上Go标准库的文档太难搜索，每次遇到要使用文件函数时都是直接Google查对应的函数。偶然查到国外一个人在2015年写的博客，他&lt;strong&gt;用常用的文件函数汇总了30个文件操作场景&lt;/strong&gt;，包括四大类：&lt;strong&gt;基本操作、读写操作、文件压缩、其他操作&lt;/strong&gt;。每一个文件操作都给了代码示例。写的非常好，强烈推荐你阅读一下，浏览一下它的目录，然后放到收藏夹里吃灰&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f7Tw3INC9Rd88gnNnkkS2vFC7zpghkgHo1G2iaQZ1NN7H1iaJW3mgT3icjQomPM8V3Z9ibQk6gDvuFsDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f7Tw3INC9Rd88gnNnkkS2vFVPPjOOrNGypc1mEiciao4zQZhpwhfibBibUhxlpQMxONWu0eZ2RuNV8D6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;，万一哪天用到了还能拿来参考一下。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原文链接：https://www.devdungeon.com/content/working-files-go&lt;/p&gt;&lt;p&gt;作者：&lt;strong&gt;NanoDano&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;作者主页：https://www.devdungeon.com/users/nanodano&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;介绍&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;一切皆文件&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;UNIX 的一个基础设计就是&quot;万物皆文件&quot;(everything is a file)。我们不必知道操作系统的设备驱动把什么映射给了一个文件描述符，操作系统为设备提供了文件格式的接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go语言中的reader和writer接口也类似。我们只需简单的读写字节，不必知道reader的数据来自哪里，也不必知道writer将数据发送到哪里。你可以在&lt;code&gt;/dev&lt;/code&gt;下查看可用的设备，有些可能需要较高的权限才能访问。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;文件基本操作&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;创建空文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;var (&lt;br/&gt;    newFile *os.File&lt;br/&gt;    err     error&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    newFile, err = os.Create(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Println(newFile)&lt;br/&gt;    newFile.Close()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Truncate裁剪文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 裁剪一个文件到100个字节。&lt;br/&gt;    // 如果文件本来就少于100个字节，则文件中原始内容得以保留，剩余的字节以null字节填充。&lt;br/&gt;    // 如果文件本来超过100个字节，则超过的字节会被抛弃。&lt;br/&gt;    // 这样我们总是得到精确的100个字节的文件。&lt;br/&gt;    // 传入0则会清空文件。&lt;br/&gt;&lt;br/&gt;    err := os.Truncate(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, 100)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;获取文件信息&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;var (&lt;br/&gt;    fileInfo os.FileInfo&lt;br/&gt;    err      error&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 如果文件不存在，则返回错误&lt;br/&gt;    fileInfo, err = os.Stat(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;File name:&quot;&lt;/span&gt;, fileInfo.Name())&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Size in bytes:&quot;&lt;/span&gt;, fileInfo.Size())&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Permissions:&quot;&lt;/span&gt;, fileInfo.Mode())&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Last modified:&quot;&lt;/span&gt;, fileInfo.ModTime())&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Is Directory: &quot;&lt;/span&gt;, fileInfo.IsDir())&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;System interface type: %T\n&quot;&lt;/span&gt;, fileInfo.Sys())&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;System info: %+v\n\n&quot;&lt;/span&gt;, fileInfo.Sys())&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重命名和移动&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    originalPath := &lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;&lt;br/&gt;    newPath := &lt;span&gt;&quot;test2.txt&quot;&lt;/span&gt;&lt;br/&gt;    err := os.Rename(originalPath, newPath)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;删除文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    err := os.Remove(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;打开和关闭文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 简单地以只读的方式打开。下面的例子会介绍读写的例子。&lt;br/&gt;    file, err := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    file.Close()&lt;br/&gt;&lt;br/&gt;    // OpenFile提供更多的选项。&lt;br/&gt;    // 最后一个参数是权限模式permission mode&lt;br/&gt;    // 第二个是打开时的属性    &lt;br/&gt;    file, err = os.OpenFile(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, os.O_APPEND, 0666)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    file.Close()&lt;br/&gt;&lt;br/&gt;    // 下面的属性可以单独使用，也可以组合使用。&lt;br/&gt;    // 组合使用时可以使用 OR 操作设置 OpenFile的第二个参数，例如：&lt;br/&gt;    // os.O_CREATE|os.O_APPEND&lt;br/&gt;    // 或者 os.O_CREATE|os.O_TRUNC|os.O_WRONLY&lt;br/&gt;&lt;br/&gt;    // os.O_RDONLY // 只读&lt;br/&gt;    // os.O_WRONLY // 只写&lt;br/&gt;    // os.O_RDWR // 读写&lt;br/&gt;    // os.O_APPEND // 往文件中添建（Append）&lt;br/&gt;    // os.O_CREATE // 如果文件不存在则先创建&lt;br/&gt;    // os.O_TRUNC // 文件打开时裁剪文件&lt;br/&gt;    // os.O_EXCL // 和O_CREATE一起使用，文件不能存在&lt;br/&gt;    // os.O_SYNC // 以同步I/O的方式打开&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;检查文件是否存在&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;var (&lt;br/&gt;    fileInfo *os.FileInfo&lt;br/&gt;    err      error&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 文件不存在则返回error&lt;br/&gt;    fileInfo, err := os.Stat(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; os.IsNotExist(err) {&lt;br/&gt;            log.Fatal(&lt;span&gt;&quot;File does not exist.&quot;&lt;/span&gt;)&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    log.Println(&lt;span&gt;&quot;File does exist. File information:&quot;&lt;/span&gt;)&lt;br/&gt;    log.Println(fileInfo)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;检查读写权限&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 这个例子测试写权限，如果没有写权限则返回error。&lt;br/&gt;    // 注意文件不存在也会返回error，需要检查error的信息来获取到底是哪个错误导致。&lt;br/&gt;    file, err := os.OpenFile(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, os.O_WRONLY, 0666)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; os.IsPermission(err) {&lt;br/&gt;            log.Println(&lt;span&gt;&quot;Error: Write permission denied.&quot;&lt;/span&gt;)&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    file.Close()&lt;br/&gt;&lt;br/&gt;    // 测试读权限&lt;br/&gt;    file, err = os.OpenFile(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, os.O_RDONLY, 0666)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; os.IsPermission(err) {&lt;br/&gt;            log.Println(&lt;span&gt;&quot;Error: Read permission denied.&quot;&lt;/span&gt;)&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    file.Close()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;改变权限、拥有者、时间戳&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 使用Linux风格改变文件权限&lt;br/&gt;    err := os.Chmod(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, 0777)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Println(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 改变文件所有者&lt;br/&gt;    err = os.Chown(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, os.Getuid(), os.Getgid())&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Println(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 改变时间戳&lt;br/&gt;    twoDaysFromNow := time.Now().Add(48 * time.Hour)&lt;br/&gt;    lastAccessTime := twoDaysFromNow&lt;br/&gt;    lastModifyTime := twoDaysFromNow&lt;br/&gt;    err = os.Chtimes(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, lastAccessTime, lastModifyTime)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Println(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;创建硬链接和软链接&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个普通的文件是一个指向硬盘的inode的地方。硬链接创建一个新的指针指向同一个地方。只有所有的链接被删除后文件才会被删除。硬链接只在相同的文件系统中才工作。你可以认为一个硬链接是一个正常的链接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;symbolic link，又叫软连接，和硬链接有点不一样，它不直接指向硬盘中的相同的地方，而是通过名字引用其它文件。他们可以指向不同的文件系统中的不同文件。并不是所有的操作系统都支持软链接。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 创建一个硬链接。&lt;br/&gt;    // 创建后同一个文件内容会有两个文件名，改变一个文件的内容会影响另一个。&lt;br/&gt;    // 删除和重命名不会影响另一个。&lt;br/&gt;    err := os.Link(&lt;span&gt;&quot;original.txt&quot;&lt;/span&gt;, &lt;span&gt;&quot;original_also.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;creating sym&quot;&lt;/span&gt;)&lt;br/&gt;    // Create a symlink&lt;br/&gt;    err = os.Symlink(&lt;span&gt;&quot;original.txt&quot;&lt;/span&gt;, &lt;span&gt;&quot;original_sym.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // Lstat返回一个文件的信息，但是当文件是一个软链接时，它返回软链接的信息，而不是引用的文件的信息。&lt;br/&gt;    // Symlink在Windows中不工作。&lt;br/&gt;    fileInfo, err := os.Lstat(&lt;span&gt;&quot;original_sym.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Link info: %+v&quot;&lt;/span&gt;, fileInfo)&lt;br/&gt;&lt;br/&gt;    //改变软链接的拥有者不会影响原始文件。&lt;br/&gt;    err = os.Lchown(&lt;span&gt;&quot;original_sym.txt&quot;&lt;/span&gt;, os.Getuid(), os.Getgid())&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;文件读写&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;复制文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 打开原始文件&lt;br/&gt;    originalFile, err := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer originalFile.Close()&lt;br/&gt;&lt;br/&gt;    // 创建新的文件作为目标文件&lt;br/&gt;    newFile, err := os.Create(&lt;span&gt;&quot;test_copy.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer newFile.Close()&lt;br/&gt;&lt;br/&gt;    // 从源中复制字节到目标文件&lt;br/&gt;    bytesWritten, err := io.Copy(newFile, originalFile)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Copied %d bytes.&quot;&lt;/span&gt;, bytesWritten)&lt;br/&gt;&lt;br/&gt;    // 将文件内容flush到硬盘中&lt;br/&gt;    err = newFile.Sync()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;跳转到文件指定位置(Seek)&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    file, _ := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    defer file.Close()&lt;br/&gt;&lt;br/&gt;    // 偏离位置，可以是正数也可以是负数&lt;br/&gt;    var offset int64 = 5&lt;br/&gt;&lt;br/&gt;    // 用来计算offset的初始位置&lt;br/&gt;    // 0 = 文件开始位置&lt;br/&gt;    // 1 = 当前位置&lt;br/&gt;    // 2 = 文件结尾处&lt;br/&gt;    var &lt;span&gt;whence&lt;/span&gt; int = 0&lt;br/&gt;    newPosition, err := file.Seek(offset, &lt;span&gt;whence&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Just moved to 5:&quot;&lt;/span&gt;, newPosition)&lt;br/&gt;&lt;br/&gt;    // 从当前位置回退两个字节&lt;br/&gt;    newPosition, err = file.Seek(-2, 1)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Just moved back two:&quot;&lt;/span&gt;, newPosition)&lt;br/&gt;&lt;br/&gt;    // 使用下面的技巧得到当前的位置&lt;br/&gt;    currentPosition, err := file.Seek(0, 1)&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Current position:&quot;&lt;/span&gt;, currentPosition)&lt;br/&gt;&lt;br/&gt;    // 转到文件开始处&lt;br/&gt;    newPosition, err = file.Seek(0, 0)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Position after seeking 0,0:&quot;&lt;/span&gt;, newPosition)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;写文件&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用&lt;code&gt;os&lt;/code&gt;包写入一个打开的文件。因为Go可执行包是静态链接的可执行文件，你import的每一个包都会增加你的可执行文件的大小。其它的包如&lt;code&gt;io&lt;/code&gt;、｀ioutil｀、｀bufio｀提供了一些方法，但是它们不是必须的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 可写方式打开文件&lt;br/&gt;    file, err := os.OpenFile(&lt;br/&gt;        &lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;,&lt;br/&gt;        os.O_WRONLY|os.O_TRUNC|os.O_CREATE,&lt;br/&gt;        0666,&lt;br/&gt;    )&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer file.Close()&lt;br/&gt;&lt;br/&gt;    // 写字节到文件中&lt;br/&gt;    byteSlice := []byte(&lt;span&gt;&quot;Bytes!\n&quot;&lt;/span&gt;)&lt;br/&gt;    bytesWritten, err := file.Write(byteSlice)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Wrote %d bytes.\n&quot;&lt;/span&gt;, bytesWritten)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;快写文件&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ioutil&lt;/code&gt;包有一个非常有用的方法&lt;code&gt;WriteFile()&lt;/code&gt;可以处理创建或者打开文件、写入字节切片和关闭文件一系列的操作。如果你需要简洁快速地写字节切片到文件中，你可以使用它。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;io/ioutil&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    err := ioutil.WriteFile(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, []byte(&lt;span&gt;&quot;Hi\n&quot;&lt;/span&gt;), 0666)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;使用缓存写&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;bufio&lt;/code&gt;包提供了带缓存功能的writer，所以你可以在写字节到硬盘前使用内存缓存。当你处理很多的数据很有用，因为它可以节省操作硬盘I/O的时间。在其它一些情况下它也很有用，比如你每次写一个字节，把它们攒在内存缓存中，然后一次写入到硬盘中，减少硬盘的磨损以及提升性能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;bufio&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 打开文件，只写&lt;br/&gt;    file, err := os.OpenFile(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, os.O_WRONLY, 0666)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer file.Close()&lt;br/&gt;&lt;br/&gt;    // 为这个文件创建buffered writer&lt;br/&gt;    bufferedWriter := bufio.NewWriter(file)&lt;br/&gt;&lt;br/&gt;    // 写字节到buffer&lt;br/&gt;    bytesWritten, err := bufferedWriter.Write(&lt;br/&gt;        []byte{65, 66, 67},&lt;br/&gt;    )&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Bytes written: %d\n&quot;&lt;/span&gt;, bytesWritten)&lt;br/&gt;&lt;br/&gt;    // 写字符串到buffer&lt;br/&gt;    // 也可以使用 WriteRune() 和 WriteByte()   &lt;br/&gt;    bytesWritten, err = bufferedWriter.WriteString(&lt;br/&gt;        &lt;span&gt;&quot;Buffered string\n&quot;&lt;/span&gt;,&lt;br/&gt;    )&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Bytes written: %d\n&quot;&lt;/span&gt;, bytesWritten)&lt;br/&gt;&lt;br/&gt;    // 检查缓存中的字节数&lt;br/&gt;    unflushedBufferSize := bufferedWriter.Buffered()&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Bytes buffered: %d\n&quot;&lt;/span&gt;, unflushedBufferSize)&lt;br/&gt;&lt;br/&gt;    // 还有多少字节可用（未使用的缓存大小）&lt;br/&gt;    bytesAvailable := bufferedWriter.Available()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Available buffer: %d\n&quot;&lt;/span&gt;, bytesAvailable)&lt;br/&gt;&lt;br/&gt;    // 写内存buffer到硬盘&lt;br/&gt;    bufferedWriter.Flush()&lt;br/&gt;&lt;br/&gt;    // 丢弃还没有flush的缓存的内容，清除错误并把它的输出传给参数中的writer&lt;br/&gt;    // 当你想将缓存传给另外一个writer时有用&lt;br/&gt;    bufferedWriter.Reset(bufferedWriter)&lt;br/&gt;&lt;br/&gt;    bytesAvailable = bufferedWriter.Available()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Available buffer: %d\n&quot;&lt;/span&gt;, bytesAvailable)&lt;br/&gt;&lt;br/&gt;    // 重新设置缓存的大小。&lt;br/&gt;    // 第一个参数是缓存应该输出到哪里，这个例子中我们使用相同的writer。&lt;br/&gt;    // 如果我们设置的新的大小小于第一个参数writer的缓存大小， 比如10，我们不会得到一个10字节大小的缓存，&lt;br/&gt;    // 而是writer的原始大小的缓存，默认是4096。&lt;br/&gt;    // 它的功能主要还是为了扩容。&lt;br/&gt;    bufferedWriter = bufio.NewWriterSize(&lt;br/&gt;        bufferedWriter,&lt;br/&gt;        8000,&lt;br/&gt;    )&lt;br/&gt;&lt;br/&gt;    // resize后检查缓存的大小&lt;br/&gt;    bytesAvailable = bufferedWriter.Available()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Available buffer: %d\n&quot;&lt;/span&gt;, bytesAvailable)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;读取最多N个字节&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;os.File&lt;/code&gt;提供了文件操作的基本功能， 而&lt;code&gt;io&lt;/code&gt;、&lt;code&gt;ioutil&lt;/code&gt;、&lt;code&gt;bufio&lt;/code&gt;提供了额外的辅助函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 打开文件，只读&lt;br/&gt;    file, err := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer file.Close()&lt;br/&gt;&lt;br/&gt;    // 从文件中读取len(b)字节的文件。&lt;br/&gt;    // 返回0字节意味着读取到文件尾了&lt;br/&gt;    // 读取到文件会返回io.EOF的error&lt;br/&gt;    byteSlice := make([]byte, 16)&lt;br/&gt;    bytesRead, err := file.Read(byteSlice)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Number of bytes read: %d\n&quot;&lt;/span&gt;, bytesRead)&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Data read: %s\n&quot;&lt;/span&gt;, byteSlice)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;读取正好N个字节&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // Open file &lt;span&gt;for&lt;/span&gt; reading&lt;br/&gt;    file, err := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // file.Read()可以读取一个小文件到大的byte slice中，&lt;br/&gt;    // 但是io.ReadFull()在文件的字节数小于byte slice字节数的时候会返回错误&lt;br/&gt;    byteSlice := make([]byte, 2)&lt;br/&gt;    numBytesRead, err := io.ReadFull(file, byteSlice)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Number of bytes read: %d\n&quot;&lt;/span&gt;, numBytesRead)&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Data read: %s\n&quot;&lt;/span&gt;, byteSlice)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;读取至少N个字节&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 打开文件，只读&lt;br/&gt;    file, err := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    byteSlice := make([]byte, 512)&lt;br/&gt;    minBytes := 8&lt;br/&gt;    // io.ReadAtLeast()在不能得到最小的字节的时候会返回错误，但会把已读的文件保留&lt;br/&gt;    numBytesRead, err := io.ReadAtLeast(file, byteSlice, minBytes)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Number of bytes read: %d\n&quot;&lt;/span&gt;, numBytesRead)&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Data read: %s\n&quot;&lt;/span&gt;, byteSlice)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;读取全部字节&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io/ioutil&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    file, err := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // os.File.Read(), io.ReadFull() 和&lt;br/&gt;    // io.ReadAtLeast() 在读取之前都需要一个固定大小的byte slice。&lt;br/&gt;    // 但ioutil.ReadAll()会读取reader(这个例子中是file)的每一个字节，然后把字节slice返回。&lt;br/&gt;    data, err := ioutil.ReadAll(file)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Data as hex: %x\n&quot;&lt;/span&gt;, data)&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Data as string: %s\n&quot;&lt;/span&gt;, data)&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Number of bytes read:&quot;&lt;/span&gt;, len(data))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;快读到内存&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io/ioutil&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 读取文件到byte slice中&lt;br/&gt;    data, err := ioutil.ReadFile(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Data read: %s\n&quot;&lt;/span&gt;, data)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;使用缓存读&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有缓存写也有缓存读。缓存reader会把一些内容缓存在内存中。它会提供比&lt;code&gt;os.File&lt;/code&gt;和&lt;code&gt;io.Reader&lt;/code&gt;更多的函数,缺省的缓存大小是4096，最小缓存是16。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;bufio&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 打开文件，创建buffered reader&lt;br/&gt;    file, err := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    bufferedReader := bufio.NewReader(file)&lt;br/&gt;&lt;br/&gt;    // 得到字节，当前指针不变&lt;br/&gt;    byteSlice := make([]byte, 5)&lt;br/&gt;    byteSlice, err = bufferedReader.Peek(5)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Peeked at 5 bytes: %s\n&quot;&lt;/span&gt;, byteSlice)&lt;br/&gt;&lt;br/&gt;    // 读取，指针同时移动&lt;br/&gt;    numBytesRead, err := bufferedReader.Read(byteSlice)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Read %d bytes: %s\n&quot;&lt;/span&gt;, numBytesRead, byteSlice)&lt;br/&gt;&lt;br/&gt;    // 读取一个字节, 如果读取不成功会返回Error&lt;br/&gt;    myByte, err := bufferedReader.ReadByte()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Read 1 byte: %c\n&quot;&lt;/span&gt;, myByte)     &lt;br/&gt;&lt;br/&gt;    // 读取到分隔符，包含分隔符，返回byte slice&lt;br/&gt;    dataBytes, err := bufferedReader.ReadBytes(&lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Read bytes: %s\n&quot;&lt;/span&gt;, dataBytes)           &lt;br/&gt;&lt;br/&gt;    // 读取到分隔符，包含分隔符，返回字符串&lt;br/&gt;    dataString, err := bufferedReader.ReadString(&lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Read string: %s\n&quot;&lt;/span&gt;, dataString)     &lt;br/&gt;&lt;br/&gt;    //这个例子读取了很多行，所以test.txt应该包含多行文本才不至于出错&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;使用 scanner&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Scanner&lt;/code&gt;是&lt;code&gt;bufio&lt;/code&gt;包下的类型,在处理文件中以分隔符分隔的文本时很有用。通常我们使用换行符作为分隔符将文件内容分成多行。在CSV文件中，逗号一般作为分隔符。&lt;code&gt;os.File&lt;/code&gt;文件可以被包装成&lt;code&gt;bufio.Scanner&lt;/code&gt;，它就像一个缓存reader。我们会调用&lt;code&gt;Scan()&lt;/code&gt;方法去读取下一个分隔符，使用&lt;code&gt;Text()&lt;/code&gt;或者&lt;code&gt;Bytes()&lt;/code&gt;获取读取的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分隔符可以不是一个简单的字节或者字符，有一个特殊的方法可以实现分隔符的功能，以及将指针移动多少，返回什么数据。如果没有定制的&lt;code&gt;SplitFunc&lt;/code&gt;提供，缺省的&lt;code&gt;ScanLines&lt;/code&gt;会使用&lt;code&gt;newline&lt;/code&gt;字符作为分隔符，其它的分隔函数还包括&lt;code&gt;ScanRunes&lt;/code&gt;和&lt;code&gt;ScanWords&lt;/code&gt;,皆在&lt;code&gt;bufio&lt;/code&gt;包中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// To define your own split &lt;span&gt;function&lt;/span&gt;, match this fingerprint&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)&lt;br/&gt;&lt;br/&gt;// Returning (0, nil, nil) will tell the scanner&lt;br/&gt;// to scan again, but with a bigger buffer because&lt;br/&gt;// it wasn&lt;span&gt;&#x27;t enough data to reach the delimiter&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面的例子中，为一个文件创建了&lt;code&gt;bufio.Scanner&lt;/code&gt;，并按照单词逐个读取：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;bufio&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    file, err := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    scanner := bufio.NewScanner(file)&lt;br/&gt;&lt;br/&gt;    // 缺省的分隔函数是bufio.ScanLines,我们这里使用ScanWords。&lt;br/&gt;    // 也可以定制一个SplitFunc类型的分隔函数&lt;br/&gt;    scanner.Split(bufio.ScanWords)&lt;br/&gt;&lt;br/&gt;    // scan下一个token.&lt;br/&gt;    success := scanner.Scan()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; success == &lt;span&gt;false&lt;/span&gt; {&lt;br/&gt;        // 出现错误或者EOF是返回Error&lt;br/&gt;        err = scanner.Err()&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; err == nil {&lt;br/&gt;            log.Println(&lt;span&gt;&quot;Scan completed and reached EOF&quot;&lt;/span&gt;)&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            log.Fatal(err)&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 得到数据，Bytes() 或者 Text()&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;First word found:&quot;&lt;/span&gt;, scanner.Text())&lt;br/&gt;&lt;br/&gt;    // 再次调用scanner.Scan()发现下一个token&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;文件压缩&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;打包(zip) 文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// This example uses zip but standard library&lt;br/&gt;// also supports tar archives&lt;br/&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;archive/zip&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 创建一个打包文件&lt;br/&gt;    outFile, err := os.Create(&lt;span&gt;&quot;test.zip&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer outFile.Close()&lt;br/&gt;&lt;br/&gt;    // 创建zip writer&lt;br/&gt;    zipWriter := zip.NewWriter(outFile)&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    // 往打包文件中写文件。&lt;br/&gt;    // 这里我们使用硬编码的内容，你可以遍历一个文件夹，把文件夹下的文件以及它们的内容写入到这个打包文件中。&lt;br/&gt;    var filesToArchive = []struct {&lt;br/&gt;        Name, Body string&lt;br/&gt;    } {&lt;br/&gt;        {&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, &lt;span&gt;&quot;String contents of file&quot;&lt;/span&gt;},&lt;br/&gt;        {&lt;span&gt;&quot;test2.txt&quot;&lt;/span&gt;, &lt;span&gt;&quot;\x61\x62\x63\n&quot;&lt;/span&gt;},&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 下面将要打包的内容写入到打包文件中，依次写入。&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; _, file := range filesToArchive {&lt;br/&gt;            fileWriter, err := zipWriter.Create(file.Name)&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;                    log.Fatal(err)&lt;br/&gt;            }&lt;br/&gt;            _, err = fileWriter.Write([]byte(file.Body))&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;                    log.Fatal(err)&lt;br/&gt;            }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 清理&lt;br/&gt;    err = zipWriter.Close()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;            log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;抽取(unzip) 文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// This example uses zip but standard library&lt;br/&gt;// also supports tar archives&lt;br/&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;archive/zip&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;path/filepath&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    zipReader, err := zip.OpenReader(&lt;span&gt;&quot;test.zip&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer zipReader.Close()&lt;br/&gt;&lt;br/&gt;    // 遍历打包文件中的每一文件/文件夹&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; _, file := range zipReader.Reader.File {&lt;br/&gt;        // 打包文件中的文件就像普通的一个文件对象一样&lt;br/&gt;        zippedFile, err := file.Open()&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;            log.Fatal(err)&lt;br/&gt;        }&lt;br/&gt;        defer zippedFile.Close()&lt;br/&gt;&lt;br/&gt;        // 指定抽取的文件名。&lt;br/&gt;        // 你可以指定全路径名或者一个前缀，这样可以把它们放在不同的文件夹中。&lt;br/&gt;        // 我们这个例子使用打包文件中相同的文件名。&lt;br/&gt;        targetDir := &lt;span&gt;&quot;./&quot;&lt;/span&gt;&lt;br/&gt;        extractedFilePath := filepath.Join(&lt;br/&gt;            targetDir,&lt;br/&gt;            file.Name,&lt;br/&gt;        )&lt;br/&gt;&lt;br/&gt;        // 抽取项目或者创建文件夹&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; file.FileInfo().&lt;span&gt;&lt;span&gt;IsDir&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;            // 创建文件夹并设置同样的权限&lt;br/&gt;            log.Println(&lt;span&gt;&quot;Creating directory:&quot;&lt;/span&gt;, extractedFilePath)&lt;br/&gt;            os.MkdirAll(extractedFilePath, file.Mode())&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            //抽取正常的文件&lt;br/&gt;            log.Println(&lt;span&gt;&quot;Extracting file:&quot;&lt;/span&gt;, file.Name)&lt;br/&gt;&lt;br/&gt;            outputFile, err := os.OpenFile(&lt;br/&gt;                extractedFilePath,&lt;br/&gt;                os.O_WRONLY|os.O_CREATE|os.O_TRUNC,&lt;br/&gt;                file.Mode(),&lt;br/&gt;            )&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;                log.Fatal(err)&lt;br/&gt;            }&lt;br/&gt;            defer outputFile.Close()&lt;br/&gt;&lt;br/&gt;            // 通过io.Copy简洁地复制文件内容&lt;br/&gt;            _, err = io.Copy(outputFile, zippedFile)&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;                log.Fatal(err)&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;压缩文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 这个例子中使用gzip压缩格式，标准库还支持zlib, bz2, flate, lzw&lt;br/&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;compress/gzip&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    outputFile, err := os.Create(&lt;span&gt;&quot;test.txt.gz&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    gzipWriter := gzip.NewWriter(outputFile)&lt;br/&gt;    defer gzipWriter.Close()&lt;br/&gt;&lt;br/&gt;    // 当我们写如到gizp writer数据时，它会依次压缩数据并写入到底层的文件中。&lt;br/&gt;    // 我们不必关心它是如何压缩的，还是像普通的writer一样操作即可。&lt;br/&gt;    _, err = gzipWriter.Write([]byte(&lt;span&gt;&quot;Gophers rule!\n&quot;&lt;/span&gt;))&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    log.Println(&lt;span&gt;&quot;Compressed data written to file.&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解压缩文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 这个例子中使用gzip压缩格式，标准库还支持zlib, bz2, flate, lzw&lt;br/&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;compress/gzip&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 打开一个gzip文件。&lt;br/&gt;    // 文件是一个reader,但是我们可以使用各种数据源，比如web服务器返回的gzipped内容，&lt;br/&gt;    // 它的内容不是一个文件，而是一个内存流&lt;br/&gt;    gzipFile, err := os.Open(&lt;span&gt;&quot;test.txt.gz&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    gzipReader, err := gzip.NewReader(gzipFile)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer gzipReader.Close()&lt;br/&gt;&lt;br/&gt;    // 解压缩到一个writer,它是一个file writer&lt;br/&gt;    outfileWriter, err := os.Create(&lt;span&gt;&quot;unzipped.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer outfileWriter.Close()&lt;br/&gt;&lt;br/&gt;    // 复制内容&lt;br/&gt;    _, err = io.Copy(outfileWriter, gzipReader)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;文件其它操作&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;临时文件和目录&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ioutil&lt;/code&gt;提供了两个函数: &lt;code&gt;TempDir()&lt;/code&gt; 和 &lt;code&gt;TempFile()&lt;/code&gt;。使用完毕后，调用者负责删除这些临时文件和文件夹。有一点好处就是当你传递一个空字符串作为文件夹名的时候，它会在操作系统的临时文件夹中创建这些项目（/tmp on Linux）。&lt;code&gt;os.TempDir()&lt;/code&gt;返回当前操作系统的临时文件夹。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;     &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&quot;io/ioutil&quot;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;     // 在系统临时文件夹中创建一个临时文件夹&lt;br/&gt;     tempDirPath, err := ioutil.TempDir(&lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;&quot;myTempDir&quot;&lt;/span&gt;)&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;          log.Fatal(err)&lt;br/&gt;     }&lt;br/&gt;     fmt.Println(&lt;span&gt;&quot;Temp dir created:&quot;&lt;/span&gt;, tempDirPath)&lt;br/&gt;&lt;br/&gt;     // 在临时文件夹中创建临时文件&lt;br/&gt;     tempFile, err := ioutil.TempFile(tempDirPath, &lt;span&gt;&quot;myTempFile.txt&quot;&lt;/span&gt;)&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;          log.Fatal(err)&lt;br/&gt;     }&lt;br/&gt;     fmt.Println(&lt;span&gt;&quot;Temp file created:&quot;&lt;/span&gt;, tempFile.Name())&lt;br/&gt;&lt;br/&gt;     // ... 做一些操作 ...&lt;br/&gt;&lt;br/&gt;     // 关闭文件&lt;br/&gt;     err = tempFile.Close()&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 删除我们创建的资源&lt;br/&gt;     err = os.Remove(tempFile.Name())&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;     err = os.Remove(tempDirPath)&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;通过HTTP下载文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;     &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&quot;net/http&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;     newFile, err := os.Create(&lt;span&gt;&quot;devdungeon.html&quot;&lt;/span&gt;)&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;          log.Fatal(err)&lt;br/&gt;     }&lt;br/&gt;     defer newFile.Close()&lt;br/&gt;&lt;br/&gt;     url := &lt;span&gt;&quot;http://www.devdungeon.com/archive&quot;&lt;/span&gt;&lt;br/&gt;     response, err := http.Get(url)&lt;br/&gt;     defer response.Body.Close()&lt;br/&gt;&lt;br/&gt;     // 将HTTP response Body中的内容写入到文件&lt;br/&gt;     // Body满足reader接口，因此我们可以使用ioutil.Copy&lt;br/&gt;     numBytesWritten, err := io.Copy(newFile, response.Body)&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;          log.Fatal(err)&lt;br/&gt;     }&lt;br/&gt;     log.Printf(&lt;span&gt;&quot;Downloaded %d byte file.\n&quot;&lt;/span&gt;, numBytesWritten)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;哈希和摘要&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;crypto/md5&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;crypto/sha1&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;crypto/sha256&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;crypto/sha512&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io/ioutil&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 得到文件内容&lt;br/&gt;    data, err := ioutil.ReadFile(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 计算Hash&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Md5: %x\n\n&quot;&lt;/span&gt;, md5.Sum(data))&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Sha1: %x\n\n&quot;&lt;/span&gt;, sha1.Sum(data))&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Sha256: %x\n\n&quot;&lt;/span&gt;, sha256.Sum256(data))&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Sha512: %x\n\n&quot;&lt;/span&gt;, sha512.Sum512(data))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的例子复制整个文件内容到内存中，传递给hash函数。另一个方式是创建一个hash writer, 使用&lt;code&gt;Write&lt;/code&gt;、&lt;code&gt;WriteString&lt;/code&gt;、&lt;code&gt;Copy&lt;/code&gt;将数据传给它。下面的例子使用 md5 hash,但你可以使用其它的Writer。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;crypto/md5&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    file, err := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer file.Close()&lt;br/&gt;&lt;br/&gt;    //创建一个新的hasher,满足writer接口&lt;br/&gt;    hasher := md5.New()&lt;br/&gt;    _, err = io.Copy(hasher, file)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 计算&lt;span&gt;hash&lt;/span&gt;并打印结果。&lt;br/&gt;    // 传递 nil 作为参数，因为我们不通参数传递数据，而是通过writer接口。&lt;br/&gt;    sum := hasher.Sum(nil)&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Md5 checksum: %x\n&quot;&lt;/span&gt;, sum)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注公众号，获取更多精选技术原创文章&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0188679245283019&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;318&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4icJbGAQ8RjXUUVdUZsGADuMBVWePgn7tfrWjjHyc6b8kXTQ7Sdkp0QQFFK4mel5tniczqooMna1CA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bc81cb54f9b3065cc99593a2f3db6be8</guid>
<title>[推荐] 浅谈如何搭建知识体系 | 码农周刊第 319 期</title>
<link>https://toutiao.io/k/dufazik</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;浅谈如何搭建知识体系 | 码农周刊第 319 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第319期（2020-09-23）&lt;/h2&gt;
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=319&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3190&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_316.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=319&amp;amp;aid=19803&amp;amp;url=https%3A%2F%2Fwww.sheca.com%2Fassets%2Fwwx%2Fpage1.html%3Fsite%3Dkaifazhe02&quot; target=&quot;_blank&quot;&gt;SHECA 提供 SSL 证书一站式服务，为你的网络安全保驾护航，上海 CA 权威认证&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=319&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;HDFS + Clickhouse + Spark&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;致力于提供一套简单方便、专业可靠、无限可能的 H5 落地页最佳实践。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;9NFL 是京东自研的联邦学习平台。整个平台的内核基于 TensorFlow，并根据业务进行了性能优化，调度则基于 k8s。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;ChatUI 是由达摩院阿里小蜜孵化的对话式界面组件，目前支持阿里经济体 80 多个事业部，数千个 Chatbot，承载着达摩院前沿技术，专注于智能对话领域的设计和技术研发体系，应用至消费者可体验的对话式界面。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;适合新手&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;模型性能杀器解读&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;有用&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;详细介绍&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;深入讲解&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;第二弹&lt;/p&gt;
        
        &lt;p&gt;customize personal network&lt;/p&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://github.com/aweiu/scroll-switch&quot; target=&quot;_blank&quot;&gt;GitHub 地址&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;两种不错的思路&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://golang.design/history/&quot; target=&quot;_blank&quot;&gt;文档地址&lt;/a&gt;&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;一枚有趣的程序员&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 436138 即可&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;致力于为企业提供性能优化领域的全方位解决方案&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 423497 即可&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;分享一些信息安全相关的文章&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 393298 即可&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;编程、成长、正能量！&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 381811 即可&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;分享Go语言相关内容&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 133906 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=319&amp;amp;aid=19892&amp;amp;url=http%3A%2F%2Fstore.dangdang.com%2Fgys_04001_3tk3&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/book_319.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;擦亮慧眼&lt;/p&gt;
        
        &lt;p&gt;个人经历&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>