<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>d283a1dec40fcbcce4ee7ac29d8188d0</guid>
<title>Redis 存储对象信息是用 Hash 还是 String</title>
<link>https://toutiao.io/k/2rcud9q</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;Redis 内部使用一个 RedisObject 对象来表示所有的 key 和 value，RedisObject 中的 type，则是代表一个 value 对象具体是何种数据类型，它包含字符串（String）、链表（List）、哈希结构（Hash）、集合（Set）、有序集合（Sorted set）。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b188fc9df3bb28ffbbc456f00ee63233_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;671&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-b188fc9df3bb28ffbbc456f00ee63233_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;671&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-b188fc9df3bb28ffbbc456f00ee63233_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b188fc9df3bb28ffbbc456f00ee63233_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;日常工作中我们存储对象信息的时候，一般有两种做法，一种是用 Hash 存储，另一种是 String 存储。但好像并没有所谓的最佳实践，那么实际上到底用什么数据结构存储更好呢？&lt;/p&gt;&lt;p&gt;首先简单回顾下，Redis 的 Hash 和 String 结构。&lt;/p&gt;&lt;h2&gt;String&lt;/h2&gt;&lt;p&gt;String 数据结构是简单的 key-value 类型，value 其实不仅是 String，也可以是数字。Redis 中的 String 可以表示很多语义：&lt;/p&gt;&lt;p&gt;这三种类型，Redis 会根据具体的场景完成自动转换，并且根据需要选取底层的承载方式。String 在Redis 内部存储默认就是一个字符串，被 RedisObject 所引用，当遇到 incr、decr 等操作时会转成数值型进行计算，此时 RedisObject 的 encoding 字段为int。&lt;/p&gt;&lt;p&gt;在存储过程中，我们可以将用户信息使用 Json 序列化成字符串，然后将序列化后的字符串存入 Redis 进行缓存。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-27f8be534bfc97f96460328e94a72c8e_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;964&quot; data-rawheight=&quot;402&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-27f8be534bfc97f96460328e94a72c8e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;964&quot; data-rawheight=&quot;402&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-27f8be534bfc97f96460328e94a72c8e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-27f8be534bfc97f96460328e94a72c8e_b.jpg&quot;/&gt;&lt;figcaption&gt;String 数据结构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;由于 Redis 的字符串是动态字符串，可以修改，内部结构类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。如上图所示，内部为当前字符串实际分配的空间 capacity，一般高于实际字符串长度 len。&lt;/p&gt;&lt;p&gt;假设我们要存储的结构是：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;1 {
2   &quot;name&quot;: &quot;xiaowang&quot;,
3   &quot;age&quot;: &quot;35&quot;
4 }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果此时将此用户信息的 name 改为“xiaoli”，再存到 Redis 中，Redis 是不需要重新分配空间的。而且我们在读取和存储数据的时候只需要对做 Json 序列化与反序列化，比较方便。&lt;/p&gt;&lt;h2&gt;Hash&lt;/h2&gt;&lt;p&gt;Hash 在很多编程语言中都有着很广泛的应用，而在 Redis 中也是如此。在 Redis 中，Hash 常常用来缓存一些对象信息，如用户信息、商品信息、配置信息等，因此也被称为字典（dictionary），Redis 的字典使用 Hash table 作为底层实现， 一个 Hash table 里面可以有多个哈希表节点，而每个哈希表节点保存了字典中的一个键值对。实际上，Redis 数据库底层也是采用 Hash table 来存储键值对的。&lt;/p&gt;&lt;p&gt;Redis 的 Hash 相当于 Java 的 HashMap，内部结构实现与 HashMap 一致，即数组+链表结构。只是 reHash 方式不一样。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b4bc1aa71667b1b437671aad442daf0d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;370&quot; data-rawheight=&quot;244&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;370&quot; data-rawheight=&quot;244&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b4bc1aa71667b1b437671aad442daf0d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;前面说到 String 适合存储用户信息，而 Hash 结构也可以存储用户信息，不过是对每个字段单独存储，因此可以在查询时获取部分字段的信息，节省网络流量。不过 Redis 的 Hash 的值只能是字符串，存储上面的那个例子还好，如果存储的用户信息变为：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;1 {
2   &quot;name&quot;: &quot;xiaowang&quot;,
3   &quot;age&quot;: 25,
4   &quot;clothes&quot;: {
5     &quot;shirt&quot;: &quot;gray&quot;,
6     &quot;pants&quot;: &quot;read&quot;
7   }
8 }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么该如何存储&quot;clothes&quot;属性又变成了该用 String 还是 Hash 的问题。&lt;/p&gt;&lt;h2&gt;String 和 Hash 占用内存的比较&lt;/h2&gt;&lt;p&gt;既然两种数据结构都可以存储结构体信息。到底哪种更加合适呢？&lt;/p&gt;&lt;p&gt;首先我们用代码先插入 10000 条数据，然后用可视化工具来看看内存的占用情况。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;1  const Redis = require(&quot;ioRedis&quot;);
2  const Redis0 = new Redis({port: 6370});
3  const Redis1 = new Redis({port: 6371});
4
5
6  const user = {
7   name: &#x27;name12345&#x27;,
8   age: 16,
9   avatar: &#x27;https://dss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=256767015,24101428&amp;amp;fm=26&amp;amp;gp=0.jpg&#x27;,
10  phone: &#x27;13111111111&#x27;,
11  email: &#x27;1111111@11.email&#x27;,
12  lastLogon: &#x27;2021-04-28 10:00:00&#x27;,
13 }
14
15
16 async function main() {
17  for (let i = 0; i &amp;lt; 10000; i++) {
18     await Redis0.set(`String:user:${i}`, Json.Stringify(user));
19     await Redis1.hmset(`Hash:user:${i}`, user);
20   }
21 }
22
23 main().then(process.exit);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;先看 Redis0：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-bb939848be9abcf4bd68095d4940f139_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;630&quot; data-rawheight=&quot;534&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-bb939848be9abcf4bd68095d4940f139_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;630&quot; data-rawheight=&quot;534&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-bb939848be9abcf4bd68095d4940f139_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-bb939848be9abcf4bd68095d4940f139_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;再来看看 Redis1：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-32e8929036b707955e9337668c57eaf3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;652&quot; data-rawheight=&quot;554&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-32e8929036b707955e9337668c57eaf3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;652&quot; data-rawheight=&quot;554&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-32e8929036b707955e9337668c57eaf3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-32e8929036b707955e9337668c57eaf3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;可以看到还是有点差距的，但是差距并不明显。&lt;/p&gt;&lt;h2&gt;网友讨论&lt;/h2&gt;&lt;p&gt;网上的用户也有同样的疑问， 因为值的长度是不确定的，所以不知道采用 String 还是 Hash 存储更有效率。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2ec5a5fc745eecba2893edb5a6572f9d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;765&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-2ec5a5fc745eecba2893edb5a6572f9d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;765&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-2ec5a5fc745eecba2893edb5a6572f9d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-2ec5a5fc745eecba2893edb5a6572f9d_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 截图来源于 StackOverflow（Redis Strings vs Redis Hashes to represent Json: efficiency?）&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这里我主要给大家翻译下该问题下优质的答案：&lt;/p&gt;&lt;p&gt;&lt;b&gt;适合用 String 存储的情况：&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;每次需要访问大量的字段&lt;/li&gt;&lt;li&gt;存储的结构具有多层嵌套的时候&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;适合用 Hash 存储的情况：&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在大多数情况中只需要访问少量字段&lt;/li&gt;&lt;li&gt;自己始终知道哪些字段可用，防止使用 mget 时获取不到想要的数据&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;本文主要介绍了Redis 存储对象信息是用 Hash 还是 String，我的建议是大部分情况下使用 String 存储就好，毕竟在存储具有多层嵌套的对象时方便很多，占用的空间也比 Hash 小。当我们需要存储一个特别大的对象时，而且在大多数情况中只需要访问该对象少量的字段时，可以考虑使用 Hash。&lt;/p&gt;&lt;p&gt;&lt;b&gt;推荐阅读：&lt;/b&gt;&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/563/%25E4%25B8%2589%25E5%2588%2586%25E9%2592%259F%25E4%25BA%2586%25E8%25A7%25A3%2520Python3%2520%25E7%259A%2584%25E5%25BC%2582%25E6%25AD%25A5%2520Web%2520%25E6%25A1%2586%25E6%259E%25B6%2520FastAPI.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic4.zhimg.com/v2-32db835da87060ffdd805ef17d07aec3_180x120.jpg&quot; data-image-width=&quot;957&quot; data-image-height=&quot;620&quot; class=&quot;LinkCard old LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;三分钟了解 Python3 的异步 Web 框架 FastAPI&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.upyun.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic4.zhimg.com/v2-32db835da87060ffdd805ef17d07aec3_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/558/QUIC%252FHTTP3%2520%25E5%258D%258F%25E8%25AE%25AE%25E7%25AE%2580%25E6%259E%2590.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic1.zhimg.com/v2-7a88939758f822892186586001fb0d2c_180x120.jpg&quot; data-image-width=&quot;1080&quot; data-image-height=&quot;608&quot; class=&quot;LinkCard old LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;QUIC/HTTP3 协议简析&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.upyun.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic1.zhimg.com/v2-7a88939758f822892186586001fb0d2c_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ea1682da98fa7e4bcf3c3cc85a3989a9</guid>
<title>终于明白什么是区块链了</title>
<link>https://toutiao.io/k/tzdqnhc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5620853080568721&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMou2EfEVz1Qm53BaBvM7NIS3qicCmgNK7H519nIwbsQeK4debSEwITwSeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2110&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.541015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouIGJdROuwqbenfurGHHuefD8yShWub02m8lic6EEbTDspkFPZtdSgicFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2048&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5785288270377733&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouvd5hneobWqQdwP87TUSszBl9iagj2uN00xibBBGesMic0YMERw7Wn5zicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2012&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5920344456404736&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMoux3NJvUNqIT6lzuDCtdL5hzia9ibZWSQ9LPicxib4TTrEDvYpQzXSw1QpibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1858&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5208768267223383&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouLO3GWczJzPgVUXv7aeKMXgTK7ibLGZGFVQuPP90DhUYcWwoZMSOicliaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1916&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如在幸福村，一天，张三想去李四那里买&lt;span&gt;1&lt;/span&gt;斤肉，但是兜里没有钱，于是跟李四说：我先欠着你的钱，让村里的帐房先生记一下，到了年底一起结账。李四觉得可以，于是就答应了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5804195804195804&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouJdbun5pXdShDlbA5oIBl7LXiaepfdsc3LNicdNctKWibOkVFDMwIe1JRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;572&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6787709497206704&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouLDiauWP543nn7A43yicGmmI7iapbNGdicu1iaRnJoriaDsPRxV5ODAcHQK2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;716&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;刚开始帐房先生不负众望，村里的大大小小的账目记的清清楚楚，可是后来意外发生了，由于账房先生家里电器老化失修，引起了大火，把账本烧的干干净净，村里人都慌了，大家都不知道欠了彼此多少钱。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3763837638376384&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouTkibkcsCEPNyhym1xhW5BYYU7bzA6JMjPtLEMhsSorx68NKICussyCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1626&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了不让这种事情再次发生，有人提议，村民每周轮番记账，这样可以降低账本被损毁的概率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7156488549618321&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMou7XW1BOAoPOKFWJafn43rmYuj1ln8DNHgtXFcicibSu7RoZuEpick87eWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1048&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可是没过多久又出事了，有人偷偷改了账本的数据，导致数据对不上，大家不得不再次想办法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5285714285714286&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouRqTqQwa4DJs6smmhmO42WtsG1DWxo4v8yZgjH8TCltr3Ury4DeMpPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;980&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这时，村里一个叫&lt;span&gt;中本聪&lt;/span&gt;的村民想了一个办法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7683982683982684&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouvn65PMbjiaAcICibdehVafEd92Lj90Sib5UtzhiccQpibCVlKBBYLicjR8Xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;924&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;村民每个人都维护自己的账本，当村里每次发生交易时，就在拿着广播喊一声。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4081041968162084&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouuX9GMMyPMQmpicx6mdibpm9NacoescuicxshBhIPMAGT8YrXps09GgnvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1382&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全村人都知道，然后记在自己的账本上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8134490238611713&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouRxex8qloPxhKq1z0WNiczbfn12L8F2eB4bRCUUXSliaFmqdo8x62g9Gw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;922&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样，就算一个被毁掉或者偷改了账本也不要紧，因为大部分账本是没有问题的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7888198757763976&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouMKMqb5qTUSAO8WUHABQ51ibW6SrfUdFIjz7biaiahHhulia8XzFeyNIVCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;966&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可是，大家谁会主动的愿意记帐呢？&lt;span&gt;中本聪&lt;/span&gt;说了，交易的人需要缴纳一点点的手续费，凡是第一个抢到记账权利的人，记账就可以得到该手续费，而且，还额外得到村里发的奖励，这样一来，村民都抢着记账。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7368421052631579&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouO9LVRzeDDZlvOxBm934VEwTI3sFaoJYqIQYXGbriaCwII9CqjNJgcFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;988&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如，&lt;span&gt;x&lt;/span&gt;年&lt;span&gt;x&lt;/span&gt;月&lt;span&gt;x&lt;/span&gt;日，发生了&lt;span&gt;3&lt;/span&gt;次交易。参与记账的村民一边确认该交易信息是否是真实的，一边抢记账权利。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8234265734265734&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouVPvfDzO7xCDafJcGPG3icVJ9z7IKIicBtnlJEZk2mTrzNPQn42YKr6Sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1144&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;抢到记账权利的人将自己的记账信息告诉其他人，其他人需要将信息写到自己的账本上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8765432098765432&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouk0CWoBVcmfiauWHDt7w66CMCFc8JuicibYPG01TkTkRf2ZOAzMibziaiblYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;810&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9973045822102425&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouVFSgmPQ5fFYgzoGC4GV0HShgWa3DurB72HHJFOqaE8oICCPV1sibXoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;742&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着账本记的越来越多，大家把各自的账本按照时间的先后顺序串在一起，这就是&lt;span&gt;区块链&lt;/span&gt;的雏形。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5796568627450981&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouvLdmjHOhKaPH7Ty8RjictXwpDicPbTp7llE71PjrZ6KGsjmUpchUO95g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1632&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.562429696287964&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouXvhd7Al6GMkSFmRJcFW4YcmrDv05GdsLojfIdc8u1SfXqj6SJ7mzFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1778&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5658536585365853&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMouiaic37iau6k7ZStoGpYibPyIT8THEyHDVYDyKHj4efM0tqzMyICfXh2vCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2050&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5976768743400211&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z0afv6EauTNw9RBcHEymdzYftf0OVMoupAXPYyt6t2NJBjMjrpTny4yydcqasgWKz03TWdBmtfZ4A12nMEa36Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1894&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f75102d8eb1b3f0a514348b5ea86f6b2</guid>
<title>一文理解 JVM 线程属于用户态还是内核态</title>
<link>https://toutiao.io/k/gfo3iba</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-source-line=&quot;1&quot;&gt;Linux操作系统的体系架构分为用户态和内核态（或者用户空间和内核）。&lt;/p&gt;&lt;p data-source-line=&quot;3&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7EQtQo2B1Fh96B5msCib1X1DYldoiaOIatiaNOErl9Y8Q7pfxwstmWtLnhNIt2VEibRKCMWV093jA7uuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;344&quot;/&gt;&lt;/p&gt;&lt;h2 data-source-line=&quot;5&quot;&gt;用户态与内核态&lt;/h2&gt;&lt;p data-source-line=&quot;7&quot;&gt;内核从本质上看是一种软件——控制计算机的硬件资源，并提供上层应用程序运行的环境。用户态即上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源，包括CPU资源、存储资源、I/O资源等。&lt;/p&gt;&lt;blockquote data-source-line=&quot;9&quot;&gt;&lt;p&gt;注：对操作系统来说，用户态线程具有不可见性，也称透明性。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;用户态线程调度完全由进程负责，通常就是由进程的主线程负责（用户可以为应用程序定制调度算法），相当于进程主线程的延展，使用的是操作系统分配给进程主线程的时间片段；内核线程由内核维护，由操作系统调度。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户态线程无法跨核心，一个进程的多个用户态线程不能并发，阻塞一个用户态线程会导致进程的主线程阻塞，直接交出执行权限。这些都是用户态线程的劣势。内核线程可以独立执行，操作系统会分配时间片段。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p data-source-line=&quot;13&quot;&gt;用户态的应用程序可以通过三种方式来访问内核态的资源：&lt;/p&gt;&lt;h3 data-source-line=&quot;19&quot;&gt;为什么需要区分用户态和内核态&lt;/h3&gt;&lt;p data-source-line=&quot;21&quot;&gt;在 CPU 的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃，比如清内存、设置时钟等。如果允许所有的程序都可以使用这些指令，那么系统崩溃的概率将大大增加。&lt;/p&gt;&lt;p data-source-line=&quot;23&quot;&gt;所以，CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用，普通应用程序只能使用那些不会造成灾难的指令。&lt;/p&gt;&lt;p data-source-line=&quot;25&quot;&gt;比如Intel的CPU将特权等级分为4个级别：Ring0~Ring3；Linux 系统只使用了Ring0和Ring3两个运行级别。&lt;/p&gt;&lt;p data-source-line=&quot;27&quot;&gt;当进程运行在Ring3级别时被称为运行在用户态，而运行在 Ring0 级别时被称为运行在内核态。&lt;/p&gt;&lt;h3 data-source-line=&quot;29&quot;&gt;从用户态到内核态的切换的时机&lt;/h3&gt;&lt;p data-source-line=&quot;31&quot;&gt;&lt;img data-ratio=&quot;0.4371584699453552&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7EQtQo2B1Fh96B5msCib1X1DDRmM8iaSFunVuN92ibV8o22eW6TfPZrF6xXiaP7JCBvP3W1oA6OPA0G2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;33&quot;&gt;很多程序开始时运行于用户态，但在执行的过程中，一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程。&lt;/p&gt;&lt;ol data-source-line=&quot;35&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;系统调用。操作系统对内核级别的指令进行封装，统一管理硬件资源，然后向用户程序提供系统服务，用户程序进行系统调用后，操作系统执行一系列的检查验证，确保这次调用是安全的，再进行相应的资源访问操作。比如C函数库中的内存分配函数malloc()，它具体是使用sbrk()系统调用来分配内存；当malloc调用sbrk()的时候就涉及一次从用户态到内核态的切换；类似的函数还有printf()，调用的是wirte()系统调用来输出字符串等等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;异常事件。当CPU正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，如缺页异常。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;外围设备的中断。当外围设备完成用户的请求操作后，会向CPU发出中断信号，此时，CPU就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;41&quot;&gt;注意：系统调用的本质其实也是中断，相对于外围设备的硬中断，这种中断称为软中断，这是操作系统为用户特别开放的一种中断。所以，从触发方式和效果上来看，这三种切换方式是完全一样的，都相当于是执行了一个中断响应的过程。但是从触发的对象来看，系统调用是进程主动请求切换的，而异常和硬中断则是被动的。&lt;/p&gt;&lt;p data-source-line=&quot;43&quot;&gt;理解了这里，推荐看下《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyNzgyNzAwNg==&amp;amp;mid=2247483933&amp;amp;idx=1&amp;amp;sn=d9776b9efe054b30523adbe60cb7524a&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;NIO效率高的原理之零拷贝与直接内存映射&lt;/a&gt;》中有关NIO零拷贝优化的知识。&lt;/p&gt;&lt;h2 data-source-line=&quot;46&quot;&gt;用户线程与内核线程的映射关系&lt;/h2&gt;&lt;p data-source-line=&quot;48&quot;&gt;用户线程一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程(Light Weight Process，LWP)。因此对于用户线程来说，用户程序必须让它的调度器采用用户线程，然后在内核线程上运行它。&lt;/p&gt;&lt;p data-source-line=&quot;50&quot;&gt;用户线程与内核线程的映射关系有三种模型：一对一模型、多对一模型、多对多模型。&lt;/p&gt;&lt;h3 data-source-line=&quot;52&quot;&gt;一对一模型&lt;/h3&gt;&lt;p data-source-line=&quot;54&quot;&gt;&lt;img data-ratio=&quot;0.5983606557377049&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OqTAl3WTC7EQtQo2B1Fh96B5msCib1X1DmmTaLwb2ibFHkvqj5FtGdUlsDmH690iaI3saDpKyKmolaewSkLwODAWA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;57&quot;&gt;有了内核线程，每个用户线程被映射到一个内核线程。用户线程在其生命期内都会映射到该内核线程。一旦用户线程终止，两个线程都将离开系统。这被称作&quot;一对一&quot;线程映射。&lt;/p&gt;&lt;p data-source-line=&quot;59&quot;&gt;缺点：&lt;/p&gt;&lt;ol data-source-line=&quot;61&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;操作系统限制了内核线程的数量，因此一对一模型会使用户线程的数量受到限制。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;操作系统内核线程调度时，上下文切换的开销较大，导致用户线程的执行效率下降。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-source-line=&quot;64&quot;&gt;多对一模型&lt;/h3&gt;&lt;p data-source-line=&quot;66&quot;&gt;&lt;img data-ratio=&quot;0.5737704918032787&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OqTAl3WTC7EQtQo2B1Fh96B5msCib1X1DsD6mJOMiaHTArGwfgwCpU9btl7hGuZ2cicNC8KXO0CPB0g0aNIBCSM8g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;69&quot;&gt;多对一模型将多个用户线程映射到一个内核线程上，线程之间的切换由用户态的代码来进行，因此相对一对一模型，多对一模型的线程切换速度要快许多。此外，多对一模型对用户线程的数量几乎无限制。&lt;/p&gt;&lt;p data-source-line=&quot;71&quot;&gt;缺点：&lt;/p&gt;&lt;ol data-source-line=&quot;73&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;如果其中一个用户线程阻塞，那么其它所有线程都将无法执行，因为此时内核线程也随之阻塞了。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在多处理器系统上，处理器数量的增加对多对一模型的线程性能不会有明显的增加，因为所有的用户线程都映射到一个处理器上了。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-source-line=&quot;76&quot;&gt;多对多模型&lt;/h3&gt;&lt;p data-source-line=&quot;78&quot;&gt;&lt;img data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OqTAl3WTC7EQtQo2B1Fh96B5msCib1X1D6mal6ziakQZzDHf88xlYrHTicnuiamUkICJz2Yc6tAiccOgY3icNe92vo0w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;80&quot;&gt;多对多模型（又称为M对N模型）结合了一对一模型和多对一模型的优点，将多个用户线程映射到多个内核线程上。&lt;/p&gt;&lt;p data-source-line=&quot;82&quot;&gt;优点：&lt;/p&gt;&lt;ol data-source-line=&quot;83&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;一个用户线程的阻塞不会导致所有线程的阻塞，因为此时还有别的内核线程被调度来执行。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;多对多模型对用户线程的数量没有限制。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在多处理器的操作系统中，多对多模型的线程也能得到一定的性能提升，但提升的幅度不如一对一模型的高。在现在流行的操作系统中，大都采用多对多的模型。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-source-line=&quot;87&quot;&gt;JVM线程属于用户态还是内核态&lt;/h2&gt;&lt;p data-source-line=&quot;89&quot;&gt;java线程在jdk1.2之前，是基于名为“绿色线程”的用户线程实现的，这导致绿色线程只能同主线程共享CPU分片，从而无法利用多核CPU的优势。&lt;/p&gt;&lt;p data-source-line=&quot;91&quot;&gt;由于绿色线程和原生线程比起来在使用时有一些限制， jdk1.2中放弃绿色线程，转而使用原生线程。&lt;/p&gt;&lt;p data-source-line=&quot;93&quot;&gt;在目前的jdk版本中，操作系统支持怎样的线程模型，很大程度上决定了java虚拟机的线程是怎样映射的，这点在不同的平台上都没有办法达成一致。&lt;/p&gt;&lt;p data-source-line=&quot;95&quot;&gt;总的来说就是，虚拟机规范中并没有限定java线程需要使用哪种线程模型，要根据不同的平台来说，但是无论使用哪种线程模型，java程序的编码和运行都是没有差异的。&lt;/p&gt;&lt;p data-source-line=&quot;97&quot;&gt;例如，Java SE最常用的JVM是Oracle/Sun研发的HotSpot VM。在这个JVM所支持的所有平台上都是采用一对一的线程模型的，除了Solaris平台。&lt;/p&gt;&lt;p data-source-line=&quot;99&quot;&gt;参考文档：&lt;/p&gt;&lt;ol data-source-line=&quot;100&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;《深入理解Java虚拟机》&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5da716dcede5110864128db4499f8477</guid>
<title>Presto 在腾讯资讯业务中的应用</title>
<link>https://toutiao.io/k/w9fekde</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;团队：腾讯医疗资讯与服务部-技术研发中心&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;前言：随着产品矩阵和团队规模的扩张，跨业务、APP的数据处理、分析总是不可避免。一个显而易见的问题就是异构数据源的连通。我们基于PrestoDB构建了业务线内适应腾讯生态的联邦查询引擎，连通了部门内部20+数据源实例，涵盖了90%的查询场景。同时，我们参与公司级的Presto Oteam进行协同共建，在引擎层面做了诸多改造。在实际使用Presto的过程中，也发现其SQL表达能力的过人之处。本文将从Presto使用者和开发者两种角度，给大家分享一些技术落地过程中的干货。&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 简介&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Presto是facebook研发的基于SQL进行大数据分析的高性能分布式计算引擎，最开始是用来解决Hive速度慢以及异构数据源互通的问题。在大数据家族中属于MPP（Massive Parallel Processing）计算引擎范畴，其原理是火山（Volcano）模型：将SQL抽象成一个个算子（Operator），形成管线（Pipeline）。目前能够支持Hive、HBase、ES、Kudu、Kafka、MySQL、Redis等几十种数据源的读取。它有如下特点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;基于SQL语言，上手成本低，而且功能强大，支持reduce和lambda函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;纯计算引擎，解耦底层存储，可快速缩扩容&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;纯内存计算，速度快，提供交互式的查询体验&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过插件的方式实现拓展功能，二次开发友好&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过不同的连接器（Connector）插件读取异构数据源，进行联邦查询&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4916129032258065&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41mhKiaPoTgTvVIwOxDGgFDJ4m6JjyZnDEYqWGlxXjdciaXBL7gERa0f2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1550&quot;/&gt;&lt;figcaption&gt;1.Presto架构图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 业务现状&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是传统信息流业务，或是医疗业务，或多或少都会遇到&lt;strong&gt;异构数据源整合&lt;/strong&gt;问题。比如医生、患者的状态数据，由后台维护，前端上报数据则在Hive中。另外，由于相同数据源不同版本间差异较大，往往没有完整的解决方案，导致&lt;strong&gt;查询分析速度慢&lt;/strong&gt;，业务叫苦不迭，e.g. Hive不同实例仅通过MR引擎进行互通。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 业务构成&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前，个人接触过的业务包括资讯类的腾讯看点、腾讯医典，以及医生问诊相关的腾讯云医。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6112&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41F8S0fsQPK8EVSHxcLBwDzqCpwfjDWx9wXBN4iaQmLywoAegg7BbEicUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1250&quot;/&gt;&lt;figcaption&gt;2.业务构成&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 痛点问题&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据互通的时候，底层的数据源可能是同一数据源的多个实例，或是不同版本、魔改版本，e.g. 司内tHive与Venus都是Hive数据源。在跨业务/APP分析时，这种问题会更加明显。同时，由于应用场景的不同（离线计算、快速索引），天然也会存在多数据源问题。原因总结如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;团队技术栈差异&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同类产品较多&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;架构、历史遗留&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;应用场景不同&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6969253294289898&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41CtL0wIBcnbeZRatvMHC9Jpib5LQkuAURaWqoHx2ia7bvic0SzcGJ4YE3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1366&quot;/&gt;&lt;figcaption&gt;3.异构数据源问题&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 主要工作&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对Hive查询提速的问题，我们在联邦查询引擎中适配了内部的Hive数据源，并且参与中台Oteam项目进行Hive兼容、Presto引擎层优化、改造。同时，我们进行了技术运营工作来帮助大家更好地使用Presto。针对异构数据源打通的问题，我们进行了联邦查询引擎的调研与开发，在引擎层面对内部不同种类的数据源进行适配。最后是一些技术输出的规划工作。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Presto技术运营&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;联邦查询引擎改造适配&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Presto Oteam引擎研发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;技术输出&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 技术运营&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于身处业务的数据团队中，除了参与中台的技术研发，平时也会使用Presto，并且负责SQL相关问题的答疑，既是开发者，也是使用者。大多数人对Presto的印象，仅仅停留在“都是SQL引擎”上，其实不然。Presto的SQL语言能力非常出色。如slogan说宣传的那样，&lt;code&gt;SQL on Everything&lt;/code&gt;：不仅能够连接各种数据源，还能满足复杂的处理逻辑。如果认为“Presto在SQL层面上做到兼容Hive就差不多了”，那就没有真正发挥出Presto的威力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 Reduce + Lambda&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下来自一个真实案例，数据分析同学根据APP上报的用户行为日志进行清理、建模。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;v1版本：对用户路径按时间排序，然后输入模型进行建模。通过以下SQL片段可以满足需求。首先用array_agg将用户所有行为按照event_time排序，收集成数组，然后用&#x27;/&#x27;连接符进行拼接。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;array_join(array_agg(data order by event_time asc), &#x27;/&#x27;)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;v2版本：
由于上报时机的原因，总是会有些相邻的重复上报，分析同学希望把这些相邻数据剔除掉，例如有些行为定时10s上报一次，期望达到如下的效果：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不是别人问，自己是不会想到可以用SQL来完成这种操作的。&lt;strong&gt;数组相邻元素去重&lt;/strong&gt;，乍看是非常特化的需求，SQL不太可能满足，但后来发现还真的可以实现。不得不说Presto的reduce函数，加上自由度极高的lambda表达式，以及可以承载多个变量的&lt;code&gt;Row&lt;/code&gt;类型，使得我们几乎可以在SQL中“编程”（这里使用针对array类型的reduce函数，更通用的聚合函数为reduce_agg）。最终解法如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;-- 逻辑：6/4/6/6/10/20 -&amp;gt; 6/4/6/10/20&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-- distinct adjacent elements&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; reduce(&lt;br/&gt;                &lt;span&gt;ARRAY&lt;/span&gt; [&lt;span&gt;&#x27;6&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;4&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;6&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;6&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;10&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;20&#x27;&lt;/span&gt;], &lt;span&gt;-- 输入&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;CAST&lt;/span&gt;(&lt;br/&gt;                        &lt;span&gt;ROW&lt;/span&gt;(&lt;span&gt;ARRAY&lt;/span&gt;[], &lt;span&gt;&#x27;&#x27;&lt;/span&gt;) &lt;br/&gt;                        &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;ROW&lt;/span&gt;(arr &lt;span&gt;ARRAY&lt;/span&gt;(&lt;span&gt;VARCHAR&lt;/span&gt;), prev_ele &lt;span&gt;VARCHAR&lt;/span&gt;)&lt;br/&gt;                    ),  &lt;span&gt;-- 初始状态S&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                (S, T) -&amp;gt; &lt;span&gt;CAST&lt;/span&gt;(&lt;br/&gt;                                &lt;span&gt;ROW&lt;/span&gt;(&lt;span&gt;IF&lt;/span&gt;(S.prev_ele=T, S.arr, S.arr||T), T) &lt;br/&gt;                                &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;ROW&lt;/span&gt;(arr &lt;span&gt;ARRAY&lt;/span&gt;(&lt;span&gt;VARCHAR&lt;/span&gt;), prev_ele &lt;span&gt;VARCHAR&lt;/span&gt;)&lt;br/&gt;                              ),  &lt;span&gt;-- lambda输入函数I&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                S -&amp;gt; array_join(S.arr, &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;) &lt;span&gt;-- lambda输出函数O&lt;/span&gt;&lt;br/&gt;             );&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以作用对象为数组的reduce函数为例，包含以下4个参数：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;长度为N的数组。每个元素将会依次送入lambda输入函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;初始状态。第一个元素和该状态作为lambda输入函数第一次调用的参数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个lambda输入函数。调用N次。它接收一个状态和一个元素，产生一个新的状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个lambda输出函数。调用一次。对3中处理完的最终状态做一次变换&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;reduce(array(T), initialState S, inputFunction(S, T, S), outputFunction(S, R)) → R&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，示例中的状态S是一个&lt;code&gt;Row&lt;/code&gt;类型的变量，它可以存储多个元素。第一个是去重数组arr，第二个是上一个元素的值prev_ele。lambda输入函数每次接收到一个新的值，和prev_ele比较，相等则什么也也不做，不等则将新值放入去重数组中，同时更新prev_ele。reduce是一种通用的模型，lambda则最大程度地利用了SQL的现有能力，使得Presto的SQL表现力更加强大。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 窗口函数&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Presto中的聚合函数都可以被用在窗口函数中，使用array_agg可以把当前的窗口截取下来，结合Window Frame可以操纵窗口大小，衍生出很多窗口类型。主要由两个维度组成：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先是相同行的处理方式，记为dim1：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;RANGE: 当前窗口&lt;strong&gt;会&lt;/strong&gt;包含值相同的相邻行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ROWS: 当前窗口&lt;strong&gt;不会&lt;/strong&gt;包含值相同的相邻行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后是窗口的边界指定，最后两种仅支持与ROWS连用，记为dim2：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;UNBOUND PRECEDING: 排序后第一个元素&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;UNBOUND FOLLOWING: 排序后最后一个元素&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;N PRECEDING: 排序后，当前行的前N行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;N FOLLOWING: 排序后，当前行的后N行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.655705996131528&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41Y2Ky2XpDP0Kf1LlGARbXrJxJ1nPu1tzU8IEXibzXTDfVmEnc6rlQYkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;517&quot;/&gt;&lt;figcaption&gt;4. window frame[1]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过以下SQL的结果，应该能对窗口函数有更进一步的认识。为了简化我们假设只有一个partition，排序为asc。列名取值如下所示方便大家理解：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46676737160120846&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41cMM53GsINKRbdjVF0bqNwficxeBaQBTwiaxRX2YzMR0W3TE1DOBZ2O4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;662&quot;/&gt;&lt;figcaption&gt;5. 命名方式&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;-- value为关心的值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-- 以index进行排序&lt;/span&gt;&lt;br/&gt;&lt;span&gt;WITH&lt;/span&gt;&lt;br/&gt;    t1 (&lt;span&gt;value&lt;/span&gt;, &lt;span&gt;index&lt;/span&gt;) &lt;span&gt;AS&lt;/span&gt; &lt;br/&gt;    (&lt;br/&gt;        &lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; (&lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;&#x27;a&#x27;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;),&lt;br/&gt;        (&lt;span&gt;&#x27;b&#x27;&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;),&lt;br/&gt;        (&lt;span&gt;&#x27;c&#x27;&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;),&lt;br/&gt;        (&lt;span&gt;&#x27;d&#x27;&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;),&lt;br/&gt;        (&lt;span&gt;&#x27;e&#x27;&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;),&lt;br/&gt;        (&lt;span&gt;&#x27;f&#x27;&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;),&lt;br/&gt;        (&lt;span&gt;&#x27;g&#x27;&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;),&lt;br/&gt;        (&lt;span&gt;&#x27;h&#x27;&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;))&lt;br/&gt;    )&lt;br/&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; *,&lt;br/&gt;    &lt;span&gt;-- 默认&lt;/span&gt;&lt;br/&gt;    array_agg(&lt;span&gt;value&lt;/span&gt;) &lt;span&gt;OVER&lt;/span&gt; &lt;br/&gt;        (&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;index&lt;/span&gt;) res, &lt;br/&gt;    &lt;span&gt;-- [开头, 当前值]&lt;/span&gt;&lt;br/&gt;    array_agg(&lt;span&gt;value&lt;/span&gt;) &lt;span&gt;OVER&lt;/span&gt; &lt;br/&gt;        (&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; &lt;span&gt;RANGE&lt;/span&gt; &lt;span&gt;BETWEEN&lt;/span&gt; &lt;span&gt;UNBOUNDED&lt;/span&gt; &lt;span&gt;PRECEDING&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; &lt;span&gt;CURRENT&lt;/span&gt; &lt;span&gt;ROW&lt;/span&gt;) res_range_uc,&lt;br/&gt;    &lt;span&gt;-- [开头, 当前行]&lt;/span&gt;&lt;br/&gt;    array_agg(&lt;span&gt;value&lt;/span&gt;) &lt;span&gt;OVER&lt;/span&gt; &lt;br/&gt;        (&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; &lt;span&gt;ROWS&lt;/span&gt;  &lt;span&gt;BETWEEN&lt;/span&gt; &lt;span&gt;UNBOUNDED&lt;/span&gt; &lt;span&gt;PRECEDING&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; &lt;span&gt;CURRENT&lt;/span&gt; &lt;span&gt;ROW&lt;/span&gt;) res_rows_uc,&lt;br/&gt;    &lt;span&gt;-- [当前值, 末尾]&lt;/span&gt;&lt;br/&gt;    array_agg(&lt;span&gt;value&lt;/span&gt;) &lt;span&gt;OVER&lt;/span&gt; &lt;br/&gt;        (&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; &lt;span&gt;RANGE&lt;/span&gt; &lt;span&gt;BETWEEN&lt;/span&gt; &lt;span&gt;CURRENT&lt;/span&gt; &lt;span&gt;ROW&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; &lt;span&gt;UNBOUNDED&lt;/span&gt; &lt;span&gt;FOLLOWING&lt;/span&gt;) res_range_cu,&lt;br/&gt;    &lt;span&gt;-- [当前行, 末尾]&lt;/span&gt;&lt;br/&gt;    array_agg(&lt;span&gt;value&lt;/span&gt;) &lt;span&gt;OVER&lt;/span&gt; &lt;br/&gt;        (&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; &lt;span&gt;ROWS&lt;/span&gt;  &lt;span&gt;BETWEEN&lt;/span&gt; &lt;span&gt;CURRENT&lt;/span&gt; &lt;span&gt;ROW&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; &lt;span&gt;UNBOUNDED&lt;/span&gt; &lt;span&gt;FOLLOWING&lt;/span&gt;) res_rows_cu,&lt;br/&gt;    &lt;span&gt;-- [前1个值，后1个值] 不支持&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-- array_agg(value) OVER (ORDER BY index RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING) res_range_11, not support&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-- [前1行，后1行]&lt;/span&gt;&lt;br/&gt;    array_agg(&lt;span&gt;value&lt;/span&gt;) &lt;span&gt;OVER&lt;/span&gt; &lt;br/&gt;        (&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; &lt;span&gt;ROWS&lt;/span&gt;  &lt;span&gt;BETWEEN&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;PRECEDING&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;FOLLOWING&lt;/span&gt;) res_rows_11&lt;br/&gt;&lt;span&gt;FROM&lt;/span&gt; t1;&lt;br/&gt;&lt;br/&gt;presto&amp;gt;&lt;br/&gt;&lt;br/&gt; value | index |           res            |       res_range_uc       |       res_rows_uc        |       res_range_cu       |       res_rows_cu        | res_rows_11 &lt;br/&gt;&lt;span&gt;-------+-------+--------------------------+--------------------------+--------------------------+--------------------------+--------------------------+-------------&lt;/span&gt;&lt;br/&gt; a     |     1 | [a]                      | [a]                      | [a]                      | [a, b, c, d, e, f, g, h] | [a, b, c, d, e, f, g, h] | [a, b]      &lt;br/&gt; b     |     2 | [a, b]                   | [a, b]                   | [a, b]                   | [b, c, d, e, f, g, h]    | [b, c, d, e, f, g, h]    | [a, b, c]   &lt;br/&gt; c     |     3 | [a, b, c]                | [a, b, c]                | [a, b, c]                | [c, d, e, f, g, h]       | [c, d, e, f, g, h]       | [b, c, d]   &lt;br/&gt; d     |     4 | [a, b, c, d, e]          | [a, b, c, d, e]          | [a, b, c, d]             | [d, e, f, g, h]          | [d, e, f, g, h]          | [c, d, e]   &lt;br/&gt; e     |     4 | [a, b, c, d, e]          | [a, b, c, d, e]          | [a, b, c, d, e]          | [d, e, f, g, h]          | [e, f, g, h]             | [d, e, f]   &lt;br/&gt; f     |     5 | [a, b, c, d, e, f, g]    | [a, b, c, d, e, f, g]    | [a, b, c, d, e, f]       | [f, g, h]                | [f, g, h]                | [e, f, g]   &lt;br/&gt; g     |     5 | [a, b, c, d, e, f, g]    | [a, b, c, d, e, f, g]    | [a, b, c, d, e, f, g]    | [f, g, h]                | [g, h]                   | [f, g, h]   &lt;br/&gt; h     |     6 | [a, b, c, d, e, f, g, h] | [a, b, c, d, e, f, g, h] | [a, b, c, d, e, f, g, h] | [h]                      | [h]                      | [g, h]      &lt;br/&gt;(8 rows)&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 高阶运营&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，通过官方文档就可以解答大部分问题。但有时候文档也没说明的细节，只能看源码了。关于语法特点的问题，需要查看&lt;code&gt;SqlBase.g4&lt;/code&gt;。比如以下SQL为什么可以运行？不是所有查询语句都需要select开头：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;presto&amp;gt; (&lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;&#x27;a&#x27;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;),(&lt;span&gt;&#x27;b&#x27;&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;));&lt;br/&gt; _col0 | _col1 &lt;br/&gt;&lt;span&gt;-------+-------&lt;/span&gt;&lt;br/&gt; a     |     1 &lt;br/&gt; b     |     2 &lt;br/&gt;(2 rows)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;语义分析中的问题，需要查看&lt;code&gt;StatementAnalyzer&lt;/code&gt;。比如窗口函数执行完成后，用标量函数做一些加工处理，必须写在整个窗口函数&lt;code&gt;func2(func1() over ())&lt;/code&gt;的外面，而不是&lt;code&gt;func2(func1()) over ()&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;--报错&lt;/span&gt;&lt;br/&gt;array_join(array_agg(concat(col1, col2)), &#x27;/&#x27;) &lt;br/&gt;  over (partition by user_id order by event_time)&lt;br/&gt;&lt;br/&gt;vs&lt;br/&gt;&lt;br/&gt;&lt;span&gt;--成功&lt;/span&gt;&lt;br/&gt;array_join(&lt;br/&gt;  array_agg(concat(col1, col2)) &lt;br/&gt;    over (partition by user_id order by event_time),&lt;br/&gt;  &#x27;/&#x27;)&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4 语法、语义错误&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有个问题，到底怎么区分语法、语义错误？对于使用者而言，不建议了解。对于开发者来说，还是很有必要了解的。语法错误是指通过简单规则捕获的SQL错误，在Antlr层面就可以截获，跟上下文关系不大，e.g. select * from from table1;
语义错误需要上下文信息，比如库表、字段是否合法？对于Presto而言，lambda表达式出现的位置是否合法？了解语法、语义的区别，对问题的排查也是十分高效的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 联邦查询引擎&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异构数据源导致的问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;搭建各种ETL Pipeline，维护成本高&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据分析速度&lt;strong&gt;严重拖慢&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为此，我们引入Presto作为联邦查询引擎，一方面利用多数据源能力，减少ETL相关工作量。另一方面，利用Presto的速度为业务分析提速。本次介绍两个数据源适配的工作：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为了适配内部的tHive，我们在MetaStore的Thrift RPC协议中植入了内部鉴权机制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;针对云上ES的网络情况，禁用了自动嗅探逻辑。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 tHive连接器适配&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Presto的Hive连接器通过与HMS（Hive MetaStore）通信获取Hive库表的位置信息，然后拉取数据。腾讯tHive有自己的一套鉴权体系TAUTH，我们需要将这种鉴权机制引入到Hive连接器中。外部一般通过Thrift RPC协议与HMS通信。那么如何加入鉴权能力呢？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7191011235955056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41XWek6YZTkpiaO91cCLHYTAguiauAt9C2dkzdBicpCdRxQKUwv6Nof5WJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1068&quot;/&gt;&lt;figcaption&gt;6.获取Hive库表元数据&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考Hive连接器中&lt;code&gt;Kerberos&lt;/code&gt;机制的实现（下图），可以看到rawTransport作为参数，用来构建一个新的SaslTransport。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5427083333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41ds7NGucogVctqjoHsODsIsgSrnP7ia3vsicAldoReSQn9qFTtlgYC0lQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;figcaption&gt;7. KerberosHiveMetastoreAuthentication&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合&lt;code&gt;TSaslClientTransport&lt;/code&gt;的源码可以发现，这里其实是计算机网络分层思想的典型应用。在可靠传输层rawTransport的基础上，再包装了一个Sasl层。利用底层rawTransport提供的可靠传输能力，进一步提供安全策略。e.g. 某些QoS条件下，调用Sasl层的&lt;code&gt;write()&lt;/code&gt;，会对数据进行加密，Sasl进而调用下一层的&lt;code&gt;write()&lt;/code&gt;函数，将加密后的数据发送到可靠的传输通道中。它们都实现了&lt;code&gt;TTtransport&lt;/code&gt;接口，I/O函数如下所示：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;open()&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;close()&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;flush()&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;readAll()&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;write()&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.47&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD410bajuuqDDRic80xMVe4iaXibESzFI1xLEFQ2AoibS3IpFxAxWTllVpiaxxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;figcaption&gt;8.本质为网络协议栈&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sasl层本身并不绑定特定的鉴权机制，它是一个框架。通过JCA注册的鉴权机制都可以在运行时被指定。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3568&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41Hxibrl3hRrWONw26yDnEJgw8uH4MHQZd3iauTMKte2o7iagYHD2mbbQMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;625&quot;/&gt;&lt;figcaption&gt;9.鉴权机制插件化&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以如果想整合自定义的鉴权机制，需要注册对应的&lt;code&gt;SecurityProvider&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.45592705167173253&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41eEAQltvoibGdu2icv7r3TKEzFIvOzOicuzPs94EJ0f6FZkBibDGfESTzcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1316&quot;/&gt;&lt;figcaption&gt;10.底层原理&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结：对于小白来说，“为Hive连接器增加一种鉴权机制”是个很难理解的技术需求，通过前文的探索，我们发现其本质是：“如何在HMS的Thrift RPC中，为SASL鉴权层增加一种自定义的安全协议。”这里的上下文比较多，需要对HMS、THrift RPC、SASL、JCA、Kerberos等概念有个大概的了解，才知道需要做什么。对技术的提升还是很有帮助的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 ES连接器踩坑&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个case：调研ES连接器的时候，发现Presto启动时第一次连接ES集群是成功的。但是后面哪怕没有执行ES相关查询也会无故报错，堆栈信息显示网络连接失败。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2173076923076923&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD4108NicBFYA452dsSdhhwTaWgZtw3cehVibhXEsV8gYARcuLgicR0JwlhKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1040&quot;/&gt;&lt;figcaption&gt;11. 报错信息&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过排查，发现与定时嗅探逻辑有关。Presto底层依赖了facebook内部的&lt;code&gt;Airlift&lt;/code&gt;后台框架。在这个场景下，通过&lt;code&gt;Bootstrap&lt;/code&gt;注册的类会被生命周期管理器识别，&lt;code&gt;@PostConstruct&lt;/code&gt;注解（Annotation）标记的函数会在类实例化后被自动调用。可以看到，一个&lt;code&gt;refreshNodes()&lt;/code&gt;函数被定期调用了，该函数会获取ES集群中所有的可用节点IP，并在下次将请求发送到其中一个节点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34173669467787116&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41Ya6z8SyMoP6cF1IqqXdz2YPrQabUGvOyXDKByxCCjsnEgWDG28PlbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;714&quot;/&gt;&lt;figcaption&gt;12. @PostConstruct&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于云上ES集群只开放了一个主节点的访问端口，嗅探获得的IP其实是不能用的。这也解释了为什么第一次访问是成功的（第一次访问的主节点开放），后续访问大概率是失败的（其它节点端口不开放）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.963924963924964&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41u6gBZJiaAnhHVZUJ26ZMvJiadjTgsHNrq7nAaYl9SR3ia1F92BWXqnn7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;693&quot;/&gt;&lt;figcaption&gt;13.自动嗅探逻辑&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要的改造就是禁用自动更新节点逻辑，位于&lt;code&gt;ElasticSearchClint&lt;/code&gt;文件。在改造的过程中，发现已经有参数&lt;code&gt;elasticsearch.ignore-publish-address&lt;/code&gt;可以满足需求，但是在去年8月的时候DB、SQL的文档里竟然没有记录这个参数，github上搜索一波发现已有issue了，目前社区已经补齐了文档。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5464547677261614&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41hBcibkEoxHBSLvlu9YWBNyEYgbJwVj8b2DM9PUXLvdPmBC0GDOpEUSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;818&quot;/&gt;&lt;figcaption&gt;14.忽略嗅探IP&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结：&lt;code&gt;Airlift&lt;/code&gt;后台框架虽然没有文档，但开发者还是要认真看。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. Oteam共建&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在去年，随着Presto在腾讯内部的应用场景越来越多，为了整合各部门的研发能力和技术成果，公司内部由PCG欧拉数据中台牵头发起了Presto Oteam项目，主要for Presto引擎的研发。作为资讯业务的数据工程同学，我们也有幸参与共建。Oteam部分工作内容如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Hive语义兼容，函数迁移&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RBO/CBO执行解析器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Worker Tag能力&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分析函数开发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;语法/语义扩展&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;动态数据源支持&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;查询性能优化专项&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Coordinator执行流程优化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;bug fix
...&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;限于篇幅，简单介绍第一点：标量函数开发原理。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1 函数开发&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同于Hive UDF函数可以由用户直接上传，在Presto引擎中所有扩展部件都以插件形式被统一整合。除了最常见的连接器（Connector）插件以外，函数也是一种插件。如果业务需要自定义函数，就需要单独开发函数插件。Presto引擎自带了很多函数，可以作为开发者的参考。总共有两种函数开发方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用注解框架的普通函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用字节码适配的变长参数函数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一种方式需要使用Presto引擎的注解框架，官网给的例子比较简单，各种注解搭配使用的方式实际比较复杂。同时函数的数据类型需要涉及到Presto引擎的&lt;code&gt;Slice&lt;/code&gt;，&lt;code&gt;Block&lt;/code&gt;等类型，有一定学习成本。第二种方式比较少见，而且不支持通过插件进行开发，只能写到&lt;code&gt;presto-main&lt;/code&gt;模块中，它基于Presto自带的字节码框架动态生成字节码（包&lt;code&gt;com.facebook.presto.sql.gen&lt;/code&gt;），是比较hack的实现，可以参考&lt;code&gt;ArrayConcatFunction&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 函数注解框架&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以标量函数为例。函数开发和普通的Java方法编写本质上是一样的，但是也有很多差异点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;需要使用注解（annotation）标记出该函数是一个可供调用的标量函数，包括函数名，返回类型、参数类型等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;java原生类型和Presto类型有一一对应的关系。Java的&lt;code&gt;Slice&lt;/code&gt;对应Presto中的&lt;code&gt;Varchar&lt;/code&gt;类型，Java的&lt;code&gt;Block&lt;/code&gt;对应Presto中的&lt;code&gt;Array&lt;/code&gt;类型。（下文分别称为Java类型和SQL类型）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这些特定的Java类型逻辑上等价于&lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Array数组&lt;/code&gt;，但是API差别很大，前期有一定的上手成本。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;函数有两套签名。基于反射可以获取Java类型的形参、返回值类型，称为&lt;strong&gt;方法签名&lt;/strong&gt;。基于&lt;code&gt;@SqlType&lt;/code&gt;注解可以获取Presto引擎使用的参数、返回值类型，称为&lt;strong&gt;函数签名&lt;/strong&gt;。这里做个严格的区分。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以使用&lt;code&gt;@TypeParameter&lt;/code&gt;函数注解引入&lt;strong&gt;泛型变量&lt;/strong&gt;。在函数体声明相关的泛型参数，供&lt;code&gt;SqlType&lt;/code&gt;引用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以使用&lt;code&gt;@LiteralParameter&lt;/code&gt;函数注解引入字面量变量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以使用形参注解&lt;code&gt;@TypeParameter&lt;/code&gt;、&lt;code&gt;@LiteralParameter&lt;/code&gt;、&lt;code&gt;@FunctionDependency&lt;/code&gt;、&lt;code&gt;@OperatorDependency&lt;/code&gt;声明一些&lt;strong&gt;依赖型参数&lt;/strong&gt;，在调用函数之前，Presto会根据解析出来的元数据，自动注入参数依赖。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们把写在函数体/类名上的注解称为&lt;strong&gt;函数注解&lt;/strong&gt;，写在函数形参前面的注解称为&lt;strong&gt;形参注解&lt;/strong&gt;，方便下文引用。一般来说，关注前四点就够了。后面是一些进阶的使用技巧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按注解类型区分：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;函数注解&lt;/th&gt;&lt;th&gt;形参注解&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;@SqlScalarFunction&lt;/td&gt;&lt;td&gt;定义函数名，函数属性&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Description&lt;/td&gt;&lt;td&gt;定义函数描述信息&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@SqlNullale&lt;/td&gt;&lt;td&gt;返回值是否可以是null&lt;/td&gt;&lt;td&gt;形参是否接收null&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@SqlType&lt;/td&gt;&lt;td&gt;返回值的SQL类型&lt;/td&gt;&lt;td&gt;形参的SQL类型&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@TypeParameter&lt;/td&gt;&lt;td&gt;定义泛型变量&lt;/td&gt;&lt;td&gt;引入依赖型参数&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@LiteralParameters&lt;/td&gt;&lt;td&gt;定义字面量变量&lt;/td&gt;&lt;td&gt;引入依赖型参数&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是官网[2]的一个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ExampleNullFunction&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@ScalarFunction&lt;/span&gt;(&lt;span&gt;&quot;is_null&quot;&lt;/span&gt;, calledOnNullInput = &lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;@Description&lt;/span&gt;(&lt;span&gt;&quot;Returns TRUE if the argument is NULL&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;@SqlType&lt;/span&gt;(StandardTypes.BOOLEAN)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isNull&lt;/span&gt;&lt;span&gt;(@SqlNullable @SqlType(StandardTypes.VARCHAR)&lt;/span&gt; Slice string)&lt;br/&gt;    &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (string == &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应刚刚说到的几点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;isNull函数体有三个注解，&lt;code&gt;@ScalarFunction&lt;/code&gt;定义了函数名和&lt;code&gt;calledOnNullInput&lt;/code&gt;属性。&lt;code&gt;@Description&lt;/code&gt;定义了函数的描述字段，在Presto客户端用show functions命令可以看到函数的描述信息。&lt;code&gt;@SqlType&lt;/code&gt;描述了函数的返回值类型。这些是&lt;strong&gt;函数注解&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;形参的SQL类型是VARCHAR，Java类型是Slice。如果Slice换成其它类型，函数调用会失败。这个是&lt;strong&gt;形参注解&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回值、形参都有&lt;code&gt;@SqlType&lt;/code&gt;注解，它们定义了SQL类型。在Presto引擎层面，基本都是使用SQL类型来进行解析。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来看另外一个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@ScalarFunction&lt;/span&gt;(name = &lt;span&gt;&quot;is_null&quot;&lt;/span&gt;, calledOnNullInput = &lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@Description&lt;/span&gt;(&lt;span&gt;&quot;Returns TRUE if the argument is NULL&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;IsNullFunction&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@TypeParameter&lt;/span&gt;(&lt;span&gt;&quot;T&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;@SqlType&lt;/span&gt;(StandardTypes.BOOLEAN)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isNullSlice&lt;/span&gt;&lt;span&gt;(@SqlNullable @SqlType(&lt;span&gt;&quot;T&quot;&lt;/span&gt;)&lt;/span&gt; Slice value)&lt;br/&gt;    &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@TypeParameter&lt;/span&gt;(&lt;span&gt;&quot;T&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;@SqlType&lt;/span&gt;(StandardTypes.BOOLEAN)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isNullLong&lt;/span&gt;&lt;span&gt;(@SqlNullable @SqlType(&lt;span&gt;&quot;T&quot;&lt;/span&gt;)&lt;/span&gt; Long value)&lt;br/&gt;    &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@TypeParameter&lt;/span&gt;(&lt;span&gt;&quot;T&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;@SqlType&lt;/span&gt;(StandardTypes.BOOLEAN)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isNullDouble&lt;/span&gt;&lt;span&gt;(@SqlNullable @SqlType(&lt;span&gt;&quot;T&quot;&lt;/span&gt;)&lt;/span&gt; Double value)&lt;br/&gt;    &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// ...and so on for each native container type&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在函数体，多了&lt;code&gt;@TypeParameter&lt;/code&gt;&lt;strong&gt;函数注解&lt;/strong&gt;，引入了一个泛型变量&lt;code&gt;T&lt;/code&gt;，可以在&lt;strong&gt;形参注解&lt;/strong&gt;中被@SqlType引用。&lt;code&gt;@SqlType&lt;/code&gt;注解的类型声明为&lt;code&gt;T&lt;/code&gt;以后，这几个函数的&lt;strong&gt;函数签名&lt;/strong&gt;都是一样的。在&lt;code&gt;Presto&lt;/code&gt;引擎看来，这几个函数拥有相同的函数签名，是一类函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，有很多细节的问题其实需要看源码才知道需要怎么写。比如，细心的同学从上面两个例子可以发现：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;问：为什么第二个例子的&lt;code&gt;@ScalarFunction&lt;/code&gt;和&lt;code&gt;@Description&lt;/code&gt;注解是写在类名上面而不是函数名上面？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;答：写在类名上，代表这个类中的所有方法的函数签名都是一样的，由一个&lt;code&gt;ParameticScalar&lt;/code&gt;类进行管理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;问：Slice和Java的String是什么关系，需要怎么处理转换？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;答：参考其它函数的实现，可以调用&lt;code&gt;toStringUtf8()&lt;/code&gt;转换成&lt;code&gt;String&lt;/code&gt;类型再做处理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;问：哪些注解是一定要写的？哪些是可选的？哪些是在某些条件下需要同时出现的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;答：比如说&lt;code&gt;@ScalarFunction&lt;/code&gt;中的&lt;code&gt;calledOnNullInput&lt;/code&gt;属性，当形参中有以下任意注解(&lt;code&gt;@SqlNullable&lt;/code&gt;,&lt;code&gt;@BlockPosition&lt;/code&gt;,&lt;code&gt;@IsNull&lt;/code&gt;)的时候，需要指定为true，默认为false。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然Presto文档只讲了冰山一角，但是引擎内部自带了很多函数，是非常有价值的参考资料。这里有很多细节，需要看Presto源码才能得到答案。以上只是注解的使用，具体这个自定义函数后续如何被Presto引擎解析，不关注问题也不大，注解写错了大部分case也会在插件装载的时候被识别出来。推荐高阶开发者看看&lt;code&gt;ParametricScalarImplementation&lt;/code&gt;中标量函数的解析流程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3 常用注解参考手册&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下总结了注解框架中的一些常用注解。建议有一定基础后作为参考来看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;@ScalarFunction&lt;/strong&gt;: 函数注解。定义函数的名称，别名，可见性，纯函数性，是否处理空值。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;元数据&lt;/th&gt;&lt;th&gt;含义&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;value&lt;/td&gt;&lt;td&gt;函数名&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;alias&lt;/td&gt;&lt;td&gt;函数别名&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;visibility&lt;/td&gt;&lt;td&gt;函数可见性&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;deterministic&lt;/td&gt;&lt;td&gt;纯函数性&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;calledOnNullInput&lt;/td&gt;&lt;td&gt;函数的形参是否可以处理空值&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;@Description&lt;/strong&gt;: 函数注解。描述函数功能的字符串。在presto客户端使用&lt;code&gt;show functions&lt;/code&gt;命令可以查看。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;@TypeParameter&lt;/strong&gt;: 函数注解、形参注解。对于函数注解，声明一个泛型变量，形参注解中的@SqlType可以使用它，在解析函数调用的时候会尝试将泛型类型和具体类型进行绑定。对于形参注解，它引入一个依赖型参数。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;@LiteralParameters&lt;/strong&gt;: 函数注解、形参注解。对于函数注解，定义一些字面量变量，长整数类型。如果有&lt;code&gt;@Constraint&lt;/code&gt;函数注解，则需要满足它定义的表达式条件。对于形参注解，它引入一个依赖型参数。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;@SqlType&lt;/strong&gt;: 函数注解、形参注解。定义形参、返回值的SQL类型。大概可以分以下几种：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型&lt;/th&gt;&lt;th&gt;含义&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;varchar&lt;/td&gt;&lt;td&gt;原始类型，无参数，无字面量变量或泛型变量。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;array(varchar)&lt;/td&gt;&lt;td&gt;原始类型，有一个参数varchar，无字面量变量或泛型变量。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;T&lt;/td&gt;&lt;td&gt;泛型，必须是@TypeParameter声明的泛型变量，不能带参数&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;varchar(x)&lt;/td&gt;&lt;td&gt;原始类型，带参数(字面量变量)&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;@SqlNullale&lt;/strong&gt;：函数注解、形参注解。对于函数注解，表示返回值类型是否可能为空。原始类型（e.g. int）不需要注解，包装类型和其它类型需要声明该注解。对于形参注解，如果该位置的实参是null，依然执行函数体。默认情况遇到null直接返回null。参考&lt;code&gt;InterpretedFunctionInvoker&lt;/code&gt;的空值处理逻辑。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;依赖型参数&lt;/strong&gt;：一种形参注解。函数中需要用到的一些变量，从SQL语句自动推导而来。这些形参由框架处理，用户不感知。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.535687453042825&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41ibcuCG1GffGc1o7dkozLwkAvc8nuO4uL8wZu0eZhUJ1oktQpDVKTxgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1331&quot;/&gt;&lt;figcaption&gt;15.contains函数&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，&lt;code&gt;contains&lt;/code&gt;函数有多种类型，但是&lt;strong&gt;函数签名&lt;/strong&gt;都是一样的。由于在函数中需要根据实际类型来调用接口读取元素，T的实际类型必须通过形参的方式传递进来，但是用户写SQL的时候并不用显式指定类型，因为它可以自动推导出来，这里涉及到methodHandle的绑定参数，就不详细展开了。总之，虽然&lt;code&gt;contains()&lt;/code&gt;有四个参数，但是用户只感知最后两个。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.4 变长参数函数&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一些变长参数的函数，比如tHive中的&lt;code&gt;parse_simple_json&lt;/code&gt;函数，在ETL任务中一次调用解多个key，是比较高效的。虽然是变长参数，但是这里的变长，是相对不同用户提交的SQL语句而言。而用户每一次提交的SQL，其实参数个数都是确定的，没有必要用变长参数，e.g. 对于一个SQL，代码中的&lt;code&gt;parse_simple_json(d4, &#x27;key1&#x27;, &#x27;key2&#x27;)&lt;/code&gt;，其实参数就是三个。函数声明为变长，但是实际中根据每个SQL语句转成定长参数。针对这种情况，Presto引擎并没有使用注解框架。而是采用了比较hack的方式，直接定义一个内部函数类，里面有一个形参为数组的业务函数。通过引擎自带的字节码生成模块，把它适配成一个定长参数函数。大概原理如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4307692307692308&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41fiakiaFQVwcRgVMRJoiaG80X81Cqb9JXCflvHKDdicYEusfpJCtVOpDO4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1690&quot;/&gt;&lt;figcaption&gt;16.字节码动态适配&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后附上标量函数注册的流程图，希望能对函数注册的流程有更直观的理解。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4776006074411541&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41GtwQLich80ukibOicib7UNlAF5NFpJlP1jD7yUqHibr4acO11yaySwAR8gQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1317&quot;/&gt;&lt;figcaption&gt;17.函数注册流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. 技术输出&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从去年下半年开始入门Presto引擎开发，接触下来感觉从零起步确实不易。虽然仔细搜索还是能找到一些不错的资料，但是Presto相关的官方文档相对于其他大数据组件来说是偏少的。比如基础的Airlift框架，官方文档仅有一句话介绍。为了降低后续同事的学习成本，这里特地把一些知识点梳理成脑图（逐步完善中），也供大家参考。大多数子节点都能用一章的篇幅来展开描述，可见快速培养出一个优秀的Presto开发者还是不太容易。以后有机会我们也会输出一系列技术文集。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.989522700814901&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41n4EjPdRBQt6F9Gz6HgUicKNDjm2FE0zvIGlhHoU7wLb6Lcia6p3Aw6rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;859&quot;/&gt;&lt;figcaption&gt;18.基础知识&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.6054054054054054&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41lXWsgn28sXeXCHvWz1REeOVlOXYEzmBdFMibTmLIw7nSVZpU4KV752Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;925&quot;/&gt;&lt;figcaption&gt;19.执行相关概念&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7. 腾讯内部应用概览&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后列出部分腾讯内部应用的Presto情况。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.1 应用场景&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;TEG-大数据平台统一SQL引擎SuperSQL，Presto作为计算引擎融合的一部分，实现联邦数据访问，计算加速等功能，支持交互式数据分析场景&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PCG-欧拉中台，在数据质量监控和资产洞察以及在线数据服务的数据装载中，作为计算查询引擎&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TEG/CSIG联合-云原生数据湖计算DLC，用户使用标准 SQL 即可完成对象存储服务（COS）及其他云端数据设施的联合建模、分析，无服务器架构（Serverless Presto）作为底层计算引擎&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CSIG-云日志服务CLS，扩展了大量自定义SQL函数，以丰富PB级日志实时SQL分析能力。Presto支持底层存储解耦，提供不同场景日志需求，以及异构存储联合查询&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CSIG-医疗资讯与服务部，作为业务线数据服务平台联邦查询引擎，统一查询前端语言，计划打通用户状态存储的MySQL、流水日志存储的ES、用户行为数仓的Hive/Clickhouse/Iceberg等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PCG-腾讯看点，连接部门内20余个异构数据源的联邦查询引擎，适配了腾讯内部的Hive/ES/CH/Redis等数据源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;IEG-数据中台，作为数据查询服务联邦查询，Adhoc场景执行引擎&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.2 合作生态&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;腾讯内部通过&lt;code&gt;Oteam&lt;/code&gt;的方式来组织跨BG/部门的开源协同共建。目前和Presto关系比较密切的Oteam有Alluxio、Iceberg、Impala。Alluxio缓存技术已经在TEG的部分场景落地使用了。TEG大数据团队也和Presto/Trino社区同时提出了各自的Iceberg Connector PR。Impala在腾讯灯塔平台已经有非常成熟的应用落地，未来和Presto一起加强对MPP引擎发展的探讨。期待未来Oteam组织以及其它大数据团队能有更深入的合作，助力Presto在更多业务中落地推广。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8. 后续计划&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了继续在Presto引擎层面进行深耕优化，联邦查询引擎的应用层功能需要继续丰富，还有很多用例需要去探索。基于数据分析同学的反馈，很多复杂的预处理逻辑以往需要spark scala或者pyspark进行处理，现在基本都可以用Presto代替了，后续如果能把模型训练等调包流程整合到一起，也许能够提供上手成本更低的数据分析体验，也是一个值得探索的方向。最后，我们希望在服务好业务的前提下，进行一系列高质量的技术输出来提升部门的技术影响力。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;结合业务场景，完成引擎和相关连接器的优化改造&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;丰富联邦查询引擎应用层功能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据科学引擎&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;强化技术输出&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9. 新书推荐&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;封面第一印象：Presto运行SQL，就像青蛙吃虫子一样快？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本书的内容质量是毋庸置疑的。对于初学者来说，左手官网文档，右手《Presto实战》进行入门应该是标准姿势。其行文的层次性、结构性，内容的完整性、权威性，对高手来说是一本非常好的字典。推荐给有兴趣的同学～&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Matt Fuller、Manfred Moser、Martin Traverso 著&lt;br/&gt;张晨 黄鹏程 傅宇 译&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;SQL领域重磅力作，Presto官方指南&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Presto创始团队、Kafka联合创作者推荐&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多位国内一线技术大咖力荐&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;亚马逊全五星好评&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8472222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD41pnpzFJ3lUSvCSWibcqogQqZyAB4iav0YhxW5gBibtzuFcWdEcsibyJAnhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.402659069325736&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rPZicKSmd9phhsN9ud6RnicicCphxChLD4146vMgK1kPLq2icBfbHMJ52xzgnj3sCrqwHyj29ibZQUqicujgXUGbquMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1053&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;文章封面介绍：CH-54 Tarhe “塔赫”运输直升机。虽然没有运输舱，仅是一个飞行载具，但是它可以灵活运输集装箱、火炮、轻型载具、直升机等物资，如果真要丢个炸弹，也是可以的。这和Presto存算分离的思想如出一辙，结合当前部门特性选择了挂载医疗舱的“塔赫”作为封面。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3c0e7daafc64723d0f91730fb47a6260</guid>
<title>数仓：谁说 ODS 层就是简单的数据同步？</title>
<link>https://toutiao.io/k/wl3klwr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ODS层辨析&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ODS全称是Operational Data Store，即操作数据存储。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Inmon VS Kimball&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Bill.Inmon的定义：ODS是一个面向主题的、集成的、可变的、当前的细节数据集合，用于支持企业对于即时性的、操作性的、集成的全体信息的需求。常常被作为数据仓库的过渡，也是数据仓库项目的可选项之一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而Kimball的定义：操作型系统的集成，用于当前、历史以及其它细节查询(业务系统的一部分)；为决策支持提供当前细节数据(数据仓库的一部分)。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ODS VS DB VS EDW&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ODS是用于支持企业日常的全局应用的数据集合，ODS的数据具有&lt;strong&gt;面向主题、集成的、可变的以及数据是当前的或是接近当前的&lt;/strong&gt;特点。同样也可以看出ODS是介于DB和DW之间的一种过渡存储。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得注意的是，Kimball所说的ODS是物理落地关系型数据库中，但是在实际生产应用中，ODS往往是物理落地在数据仓库中，比如Hive。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常来说ODS是在数据仓库中存储业务系统源数据，所以从数据粒度、数据结构、数据关系等各个方面都与业务系统的数据源保持一致。但是，也不能仅仅将ODS层看做是业务系统数据源的一个简单备份，ODS和业务系统数据源的差异主要是由于两者之间面向业务需求是不同的，业务系统是面向多并发读写同时有需要满足数据的一致性，而ODS数据通常是面向数据报表等批量数据查询需求。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ODS层的设计思路&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ODS层数据同步&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文提到ODS的数据来源于业务系统，且ODS落地的系统通常和业务系统是不同的，比如常见的将数据落到Hive中。所以，首先我们就需要将业务系统的数据抽取到ODS表中。一般来说，数据同步的方式大概可以分为三大类：&lt;strong&gt;文件抽取&lt;/strong&gt;、&lt;strong&gt;数据库表的抽取&lt;/strong&gt;和&lt;strong&gt;原始日志的抽取&lt;/strong&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;文件抽取&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下，ODS层表的存储位置与业务系统表的存储位置是不一样的，比如业务表存在MySQL中，而ODS层存储在Hive中。另外，有的时候，ODS层需要对接多个不同类型的业务系统库，比如DB2、Oracle、Mysql等等，一种比较简单实用的做法是和各个业务系统约定好数据接口，并让业务系统按照数据接口格式生成数据文件和完结标示文件给到ODS。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式有两个明显的优势：一方面可以降低ODS处理多种类型数据库系统能力需求，另一方面也减少了对业务系统的性能影响。但是这种方式也存在一些不足：数据的抽取过程和加载过程是分开的，由业务系统和ODS分别负责，同时接口新增和变更比较麻烦，需要较大的沟通维护成本，另外，数据落地到文件增加了额外的上传下载工作，会造成效率比较低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际的生产过程中，这种方式的数据同步也很少被使用。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;直连同步&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直连同步是指通过定义好的规范接口API和基于动态链接库的方式直接连接业务库，比如ODBC/JDBC等规定了统一的标准接口，不同的数据库基于这套标准提供规范的驱动，从而支持完全相同的函数调用和SQL实现。比如经常使用的Sqoop就是采取这种方式进行批量数据同步的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直连同步的方式配置十分简单，很容易上手操作，比较适合操作型业务系统的数据同步，但是会存在以下问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;数据同步时间：随着业务规模的增长，数据同步花费的时间会越来越长，无法满足下游数仓生产的时间要求。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;性能瓶颈：直连数据库查询数据，对数据库影响非常大，容易造成慢查询，如果业务库没有采取主备策略，则会影响业务线上的正常服务，如果采取了主备策略，虽然可以避免对业务系统的性能影响，但当数据量较大时，性能依然会很差。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;抽取增量数据需要依靠修改业务系统，新增时间戳字段，并且按时间戳增量抽取的数据准确性不能得到保障，业务系统做数据补丁不更新时间戳字段将会导致漏数；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;实时性差，只能在某个时刻抽取数据，不能满足准实时数据需求；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际的生产过程中，这种方式的数据同步经常被使用，值得注意的是：数据库直连抽取比较适用于小批量表的数据抽取，对于大批量的数据而言，性能会比较差。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;日志解析&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;据库日志抽取是指通过分析数据库日志，将业务系统的DDL和DML语句在一个镜像系统还原，并通过数据流的方式对外提供实时数据服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓日志解析，即解析数据库的变更日志，比如MySQL的Binlog日志，Oracle的归档日志文件。通过读取这些日志信息，收集变化的数据并将其解析到目标存储中即可完成数据的实时同步。这种读操作是在操作系统层面完成的，不需要通过数据库，因此不会给源数据库带来性能上的瓶颈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于是数据库日志抽取是获取所有的变更记录，落地到ODS表的时候我们需要根据主键去重按照日志时间倒排序获取最后状态的变化情况。通常使FULL OUTER JOIN全外连接的方式进行Merge数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库日志解析的同步方式可以实现实时与准实时的同步，延迟可以控制在毫秒级别的，其最大的优势就是性能好、效率高，不会对源数据库造成影响，目前，从业务系统到数据仓库中的实时增量同步，广泛采取这种方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，任何方式都不是完美的，使用日志解析的方式进行数据同步也会存在一些已知的问题：比如在业务系统做批量补数时会造成数据更新量超过处理的能力，从而导致数据延迟。另外，这种方式需要额外补数一个实时抽取的系统，从而也增加了投入和处理的复杂性。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;该如何选择同步方式&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际的生产环境中，直连同步和日志解析是非常普遍的两种数据同步方式，随着实时技术的发展，使得实时数据同步的方式变得越来越方便，越来越多的企业开始尝试使用日志解析的方式进行数据同步。这里需要注意的是，每种方式都有其优缺点及适用的场景，找到合适的方式就是最好的方式，切不可一味的追求狂拽酷炫的同步技术，这也是很多技术人员经常犯的错误，应用和钻研新技术是技术人的追求，但是过犹不及，在解决具体问题的时候，要多方面权衡。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，数仓的建设是为业务服务的，应该把时间和精力放在如何支持业务、如何发挥数仓的价值、如何用数据为业务提供支持决策上来。笔者认为，数仓的建设不是一堆大数据技术的简单堆砌，深入理解业务和数据才是数仓建设的第一要义。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ODS层数据清洗&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于ODS层是否做数据清洗一直是存在争议的，但有一点是可以确定的，对于比较重的清洗工作是要留到后面数仓的ETL过程中进行处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，有这么一种情况：我们在长期的生产实际过程中，发现部分已知的数据问题的处理可以通过自动化的方式来处理，这种方式通常在数据入库之前，做额外的加工处理后再做入库操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据清洗的主要工作是处理那些不符合要求的数据，从而提升数据质量，比如一些常见的问题：错误的数据、重复的数据&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;错误的数据&lt;/p&gt;&lt;p&gt;这种错误通常是业务系统处理不够健全造成的，比如字符串数据后面有回车空格、日期格式不正确、日期越界等等，这些问题如果不在ODS层做处理，后续的解析处理过程中也是要留意处理的&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;重复的数据&lt;/p&gt;&lt;p&gt;例如，一些前端系统迁移过后的新老表融合可能会存在大量的重复历史数据，这也可以在数据清洗这一步骤中完成消除重复数据的操作。需要注意的是，在数据清洗后还需要对ODS的数据做稽核，还需要对脏数据做稽核校验，脏数据的校验主要集中在数据量上，如果数据量波动特别大则需要人工介入处理。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，在大多数的情况下，是不需要做数据清洗处理的，可以把这个清洗环节放到后面的明细层ETL中进行处理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ODS层表设计&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常而言，ODS层表跟业务系统保持一致，但又不完全等同于业务系统。在设计ODS物理表时，在&lt;strong&gt;表命名&lt;/strong&gt;、&lt;strong&gt;数据存储&lt;/strong&gt;等方面都需要遵循一定的准则。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;命名&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：不管是表命名还是字段命名尽量和业务系统保持一致，但是需要通过额外的标识来区分增量和全量表，”_delta”来标识该表为增量表。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;存储&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，为了满足历史数据分析需求，我们需要在ODS表中加一个时间维度，这个维度通常在ODS表中作为分区字段。如果是增量存储，则可以按天为单位使用业务日期作为分区，每个分区存放日增量的业务数据。如果是全量存储，只可以按天为单位使用业务日期作为分区，每个分区存储截止到当前业务时间的全量快照数据。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ODS层常见的问题&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实时和准实时数据需求、数据飘移处理、巨型数据量表处理、如何有效控制数据存储。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实时性&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实时数据仓库的主要思想就是：在数据仓库中，将保存的数据分为两类，一种为静态数据，一种为动态数据，静态数据满足用户的查询分析要求；而动态数据就是为了适应实时性，数据源中发生的更新可以立刻传送到数据仓库的动态数据中，再经过响应的转换，满足实时的要求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于实时处理的特殊性及复杂性，很多情况下实时分析是建立在ODS上而不是数据仓库上，因为ODS处理逻辑简单，数据链路相对较短，产出更快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据表的刷新频率，可以将ODS层的表分为三大类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;实时ODS&lt;/p&gt;&lt;p&gt;接近实时地与业务库的数据保持同步刷新，主要用于实时分析计算，比如实时的反欺诈，天猫双11实时大屏等等。这类表的ETL是实时进行的，一般情况下，这类表会存储在消息中间件中，比如Kafka，指的注意的是：&lt;strong&gt;要求涉及的业务过程不能过多，处理的业务逻辑不能过于复杂&lt;/strong&gt;。这类ODS的表一般只是用于实时计算，相比批处理的表而言，其维护成本是相对较高的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;准实时ODS&lt;/p&gt;&lt;p&gt;例如15分钟到1小时刷新一次,这类ODS比实时ODS成本要低些，基本可以满足大部分的准实时需求。并且可以根据实际需求调整刷新频率，具有较好的灵活性。在做处理这类准实时的ODS表时，需要特别注意ETL任务的产出效率，通常这类任务的产出时间最多不能超过ODS表的刷新周期时间。例如小时级别的表，任务不能超过1个小时。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;传统ODS&lt;/p&gt;&lt;p&gt;这是离线数仓最常见的一种表，即T+1，其数据一天刷新一次,可以利用业务系统的空闲时间进行刷新（通常是每天凌晨0-2点）,可实现所有业务系统的数据集成和刷新。刷新频率的下降也给系统有更多的时间进行数据更正和清洗。该类ODS层的表是最容易维护的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;数据漂移&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓数据漂移，指的是这样一种现象：ODS表的同一个业务日期数据中包含前一天或后一天凌晨附近的数据或者丢失当天的变更数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于ODS需要承接面向历史的细节数据查询需求，这就需要物理落地到数据仓库的ODS表按时间段来切分进行分区存储，通常的做法是按某些时间戳字段来切分，实际往往由于时间戳字段的准确性问题导致数据飘移问题的发生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般情况下，我们使用的时间戳分为三类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;数据库表中用来标示数据记录更新的时间戳字段（即数据记录的update时间，如modified_time）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;数据库日志中标示数据记录的更新时间的时间戳字段（如log_time）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;数据库表中的用来记录具体业务过程的发生时间（如proc_time）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际的生产过程中，以上三个时间戳往往会存在差异：比如由于网络或者系统压力问题，log_time或者modified_time会晚于proc_time。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当时用数据库记录更新时间或者数据库日志更新时间进行切分数据分区时，有可能会导致凌晨时间产生的数据记录漂移到后一天，如果使用业务时间进行限制，则会遗漏很多其他过程的变化记录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，该如何解决上述的问题呢？常见的方式有两种：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本原则是宁多勿少，即ODS每个时间分区中向前向后都多冗余一些数据，具体的数据切分让下游根据自身不同的业务场景根据不同的业务时间proc_time来限制。这种情况同样也会存在一些误差：比如一个订单是在6.1日支付的，但在6.2号凌晨申请退款关闭了该条订单，那该条订单记录就会被更新，下游再统计支付订单状态时会错误统计。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;多个时间戳字段限制时间来获取相对准确的数据&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先确保数据不遗漏，根据log_time分别冗余前一天最后15分钟的数据和后一天凌晨开始15分钟的数据，并用modified_time过滤非当天数据，此时会过滤掉一部分后一天凌晨开始15分钟的数据，但是还是会冗余一部分前一天的数据，由于log数据保存了多个状态的数据，所以还需要根据log_time进行降序排列，获取最新状态的记录，这样就去掉了中间状态的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;下一步就是处理漂移到后一天的数据，根据log_time取后一天的15分钟数据；针对此数据，按照主键根据log_time作&lt;strong&gt;升序&lt;/strong&gt;排列去重。因为我们需要获取的最接近当天记录变化情况（数据库日志数据将保留所有变化的数据，但是落地到ODS的表是需要根据主键去重获取最后状态的变化情况)，这样就会把漂移到后一天的最初状态的数据筛选出来了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后将前两步的结果数据作全外连接，限定业务时间proc_time来获取我们需要的数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;数据存储&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;避免重复抽取数据，&lt;/p&gt;&lt;p&gt;这种情况在中小公司基本上不会存在，但是在大型的集团公司，不同的数据团队负责不同的数据集市或者业务，会存在重复同步数据源的情况，解决这类问题的首要措施不是技术上而是管理上的，必须建立统一的ODS层，收拢权限，由专门的团队统一管控。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;表的生命周期管理&lt;/p&gt;&lt;p&gt;一般而言，全量表保存3~7天，增量表要永久保存&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;无下游任务的表&lt;/p&gt;&lt;p&gt;比如一些表上源表不产生数据了，或者该表没有被下游任务使用，这种情况下要及时下线同步任务，避免造成资源的浪费&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;关注公众号【大数据技术与数仓】，回复【资料】，免费领取大数据学习礼包。扫描二维码入大数据技术交流群&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>