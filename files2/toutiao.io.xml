<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>7eab494e0e1bc4925810038c716ab83f</guid>
<title>一周上线百万级高并发系统！鹅厂真实爆肝经验分享</title>
<link>https://toutiao.io/k/ojer153</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;花 5 分钟阅读本文，你将收获：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section label=&quot;Copyright © 2015 Yead All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1. 加深对实际工作环境、工作状态的了解&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 学习高并发系统的设计思路、技术选型及理解&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. 学习工作中对接多方的沟通技巧&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 学会与测试打配合的技巧&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5. 学习紧急事故的处理方式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;6. 事后如何进行归纳总结&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;7. 感受笔者爆肝工作的痛苦与挣扎&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86318&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从年前开始和导师二人接手了一个紧急项目，年前加班做完一期后项目效果显著，于是年后开工立刻加急开发二期，目标是一周上线。由于项目业务逻辑复杂、工期紧、人手缺、对接方多，难度很大，极具挑战性，因此和导师二人开始了 007 的爆肝工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;远程办公无疑为 007 无休工作制提供了有利条件，那段时间，我做梦都在敲代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0517241379310345&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpR9scLygIvchPFvDLTpd5pjPLq2UweG9zEWufH2VS8S4pqWHMMy7utBaIqY79XuKvVMkSbDvPQia4KXGQSmVvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;116&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86318&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;项目介绍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先要介绍下负责的项目及系统。项目背景、业务等信息自然不能透露，这里剥离业务，仅介绍关键系统模型，如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;409&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.7200647249190939&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpR9scLygIvchPFvDLTpd5pjPLq2UweGlUPYUQWA6NLTIrZVOxjDdF1H9ciaZTTcMG4C6XhX12APtONbFk66SiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1236&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如图，我负责的是一个状态流转系统和查询系统，以及它们依赖的数据库服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;状态流转系统的作用是按照逻辑修改数据库中某条数据的状态字段，并在修改成功后依据状态向其他业务侧发送通知。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;401&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.7062706270627063&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpR9scLygIvchPFvDLTpd5pjPLq2UweGXNHW64uGVNxEomWhf2sG8bkVuGPmXEnA7WOm0IffL7k0nbHibKB7ccg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;606&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;查询系统，顾名思义就是从数据库中查询数据，包括最基础的鉴权、查询等功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先分析一下系统中一些&lt;strong&gt;难点&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;高并发：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;将各业务侧请求量聚集，经评估，会产生百万量级的高并发请求；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;兼容性：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;如何设计一套 API，满足各业务侧需求的同时容易被理解；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;对接复杂：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;要同时与多个业务侧的同学沟通来讨论接口，想想就是一件很复杂的事情。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8892988929889298&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/GpR9scLygIvchPFvDLTpd5pjPLq2UweGsSwxiaoLE0fIuUEtJhqYn8lBgOVPjndmkn1wr4g50SCsVpXzQcBRDMw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;271&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分析出了难点，在写代码之前，要先编写可行的技术方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86318&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;设计思路&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在实际工作中，编写详细的技术方案是非常有必要的。优秀的工程师会在技术方案中考虑到各种场景、评估各种风险、工作量估时、记录各种问题等，不仅帮助自己梳理思路、归纳总结，同时也给其他人提供了参照以及说服力（比如你预期7天上线，没有方案谁信你？）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据二八定理，复杂的系统中，编写技术方案、梳理设计思路的时间和实际敲代码开发的时间比例为 8 : 2。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;设计遵循的原则是 &lt;strong&gt;“贴合业务”，没有最好的架构，只有最适合业务的架构。&lt;/strong&gt;切忌过度设计！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，还要考虑项目的紧急程度和人力成本，先保证可用，再追求极致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一些简单的设计这里就略过了，下面针对系统难点和业务需求，列举几个&lt;strong&gt;重点设计及技术选型&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;1、高并发&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;提到高并发，大家首先想到的是缓存和负载均衡，缺一不可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;负载均衡说白了就是 “砸钱，加机器！”，但是为公司省机器、节约成本是每位后端工程师的信仰，这就要靠技术选型和架构设计来实现了。目标是尽可能利用每台机器的资源，抗住最大的并发请求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;选型如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;编程框架：选择轻量级的 Restful 框架 Jersey，搭配轻量级依赖注入库 Guice；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Web服务器：选择高性能的轻量级 NIO 服务器 Grizzly；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;缓存：腾讯自研海量分布式存储系统 CKV+（支持Redis协议，有数据监控平台）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据库分库分表：选用公司自研的基础设施，不细说了；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;负载均衡：轻量级反向代理服务器 Nginx 和 L5 负载均衡，百万并发需要增加十余台机器；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CDN 及预热：能够支持高效的文件下载服务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中，缓存是抗住高并发流量的关键，须重点设计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3757142857142857&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/GpR9scLygIvchPFvDLTpd5pjPLq2UweGSvXR0HnKHc22N4dU6GKZ8W88vNsql4aHlJSKk3UL300dIcJ7WE7fcg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;缓存方案&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用过缓存的同学都了解，关于缓存 Key 的设计是很重要的。根据业务来，保证缓存 key 之间不冲突、便于查找就好。此处我选择请求参数 + 接口唯一 id 来拼接 key。并且分页查询接口可复用全量查询接口的缓存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;找不到对应 key / redis 连接失败时直接查库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当数据库发生修改时，需要对缓存进行删除。由于存在非必填的请求参数，因此缓存 key 可能是一个模糊值。比如有 a、b 两个请求参数，key 可能为 “a”，也可能为 “ab”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对请求字段固定（所有字段必填）的接口，更新缓存时，直接拼接出唯一的 key 进行删除即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而针对请求字段不固定（存在非必填字段）的接口，可使用 redis 的 scan 命令范围扫描（不要用 keys 命令！）或者通过循环拼接出所有可能的 key。比如使用 scan 命令清除所有 key 前缀为 user1 的缓存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;无论查询出的列表是否为空，都写入缓存。但在业务会返回多种错误码时，不建议采用这种方式，复杂度高，成本太大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;2、兼容性&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;兼容性主要考察接口的设计，为兼容多个业务侧，需要将请求参数以及响应参数设置的尽可能灵活。在设计接口时，切忌一定要和所有的业务侧对齐，否则一个字段设计不当可能导致满盘皆输！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里有三个技巧：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;提供可访问链接的文档，供调用方即时查阅（比如腾讯文档）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;请求参数不能过多，且要易于理解，不能为了强制兼容而设置过于复杂的参数，必要时可针对某一业务侧定制接口；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;响应参数尽量多（多不是滥），要知道每次增加返回字段都要修改代码，而适当冗余的字段避免了此问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;3、消息通知&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面介绍难点时提到：状态流转系统与查询系统、其他业务侧存在互相发送通知的交互。当状态流转时，需要通知其他业务，还要查询系统立即更新缓存。对消息的实时性要求很高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里最初有两种方案：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;最后还是采取了第二种方案，并选用腾讯自研的 TubeMQ（万亿级分布式消息中间件，已开源Apache孵化），原因如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6590909090909091&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpR9scLygIvchPFvDLTpd5pjPLq2UweGTsmBO01nGPgBJwB8ypD2fYlfOpwbycI14lmjhyy6KickC7YOicbjwHBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;176&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在技术选型和确定方案时，不仅要关注当前的业务需求，也要有一定的前沿视角。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;4、风险评估&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;切记，在选用中间件 / 框架前，要尽可能多的进行了解，评估其可能带来的风险。一般公司内都有自己的知识库，可以利用好内部资源或者找谷歌度娘。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里我评估了 TubeMQ 带来的风险，从消息可靠性、消息顺序性、消息重复、监控告警等多个角度进行了分析，还是发现了一些可能的风险。比如当消费方消费数据状态改变的消息失败时，缓存未被及时更新，导致数据库和缓存中的数据不一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，如何规避风险呢？我从消息队列生产方和消费方的角度设计了消息可靠性和数据一致性的解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;解决方案&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;生产方消息可靠性：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;消费方消息可靠性和数据一致性：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86318&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;开发过程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实开发过程没什么好说的，就是按照技术方案去敲代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里也有几个小窍门：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86318&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;问题解决&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多问题在本地开发时是察觉不到的，在测试及线上环境才会被发现。问题解决的过程就像坐过山车，经常的状态是：测试 =&amp;gt; 开发 =&amp;gt; 测试 =&amp;gt; 上线 =&amp;gt; 开发 =&amp;gt; 测试，循环往复。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;两个温馨小贴士：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/GpR9scLygIvchPFvDLTpd5pjPLq2UweGpIfphicS9zaqoW7IIk2FmDx3R141FMF0DgMPr9R85BOjXI80Sk84bXA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面分享一些让鱼皮印象深刻的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 事务提交时报错？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原因：事务中调用的函数里也有事务，因此事务里套了事务，破坏了隔离性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解决：修改代码，保证事务隔离性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 依赖包存在，项目启动却报错？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原因：存在多版本 jar 包，导致 Java 代码使用反射机制动态生成类时不知道使用哪个 jar 包里的类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解决：删掉多余版本 jar 包。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. 缓存未即时更新&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原因：经排查，是由于实际的缓存 key 数量可达千万级，导致更新缓存时使用 scan 命令扫描的效率过低，长达20多秒！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解决：修改更新缓存的方案，不再使用 scan 命令，而是在业务代码中拼凑出所有可能的 keys，依次删除。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以为这个问题这样就结束了？不要忘记上面的小贴士：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“解决问题后，千万别激动，可以先深呼吸几口气，因为你还会产生新的问题，而且往往新问题更严重！”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4. 缓存仍未即时更新？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原因：某业务侧要求数据强一致性，缓存和数据库中的状态必须完全一致！而缓存虽然是毫秒级更新，但无法做到实时一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解决：为该业务侧定制一个接口，该接口不查询缓存，直接查数据库，保证查到的数据一定是最新值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5. 请求卡死&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;服务运行一段时间后，发现所有的请求都被阻塞了！心脏受不了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原因：使用 jstack 打印线程信息后分析 thread_dump 文件，发现是由于缓存类库 Jedis 未手动释放连接导致连接数耗尽，导致新的请求线程会不断等待 Jedis 连接释放，从而卡死。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解决：补充释放 Jedis 连接的代码即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;6. 线上环境分析日志时突然告警，磁盘 IO 占用超过 99%！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原因：误用 cat 命令查看未分割的原始日志文件，由于日志文件太大（几十 GB），导致磁盘 IO 直接刷爆！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解决：使用 less、tail、head等命令代替 cat，并删除已备份的大日志文件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;7. 进程闪退&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;排查：通常 JVM 进程闪退是有错误日志的，但是并没有找到，排查陷入绝境。没办法，只能祈祷问题不再复现。后来问题真的没出现过了，谢谢！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原因：后来，经询问，是有人手动 kill 掉了这个进程。好的，***。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/GpR9scLygIvchPFvDLTpd5pjPLq2UweGumuFj8U1d58776v5sVzd37TdLlICXUFMf87iaUI3sSZuE0OgxzULOPw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;8. 线上环境的消息通知发送成功了，怎么没有预期的数据更新效果？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;定位思路：先看消息是否被消费，再看对消息的处理是否正确。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;排查：查看线上日志，发现消息并未被消费；但是查看监控界面，发现消息被测试环境的机器消费了！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原因：由于测试环境和线上环境属于同一个消费组，当消息到达时，同一个消费组只有一个消费者能够成功消费该消息，被测试环境消费掉了，导致线上环境数据没更新。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;发现这个问题的时候，已经是上线前一天的深夜。再申请一个消费组已经来不及了，情急之下，只能先下掉测试环境的服务。第二天申请好消费组后，根据环境去区分使用哪个消费组就可以了，这样每个消费组都会独立消费消息，成功避免了消息竞争。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;9. 报告！流量太大，撑不住啊！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原因：机器不够，需进行紧急扩容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解决：紧急新申请了 10 台机器，完成初始化配置，成功部署新机器后，成功增大了并发度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;305&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5363881401617251&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpR9scLygIvchPFvDLTpd5pjPLq2UweGwCCnK9IjFwHIsMKgqIicqk0Ent39QLP4sC8S0iaf1ToNTaYTRrOwoMZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;742&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小技巧：多个机器做相同操作时，有两种快捷的做法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;10. 上线前一天你跟我说接口设计有问题？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原因：沟通出现严重问题！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;工作中，一些同事因为自身业务繁忙，可能在核对接口设计方案的时候没有注意。等他们忙完了，会反复 @ 你、私聊你询问。我们一定不要这样！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解决：紧急电话会议，拉群核对方案&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;11. 线上出 bug 了！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;线上出 bug，是一件很大的事，必须紧急响应。在梦里也得给我爬起来！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原因：测试环境和线上环境未必完全一致，且测试环境未必能测出所有问题。因此验证时通常需要预发布环境，数据使用线上数据，但却是独立的服务器，保证不影响线上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解决：紧急排查定位问题，三分钟成功修复！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9757412398921833&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpR9scLygIvchPFvDLTpd5pjPLq2UweGQMNV2LnhgUUoOBXwfzPL2qS8SXqoiaGE37usgiaoPnSdSqtGjKDdISxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;742&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;修复 bug 有一定的技巧&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，分享下个人的排错路径：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;截图 / 问题 =&amp;gt; 请求 =&amp;gt; bug 是否可复现，和测试紧密配合 =&amp;gt; 数据 =&amp;gt; 数据源（真实数据与接口数据是否一致） =&amp;gt; 数据处理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解释一下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通常发现问题的是运维、用户或者测试，他们会抛出一个问题或者问题的相关的截图，这时，我们要快速想到这个问题对应的功能（即对应的请求/接口），然后让问题描述者尽可能多的提供信息（比如请求参数、问题时间等）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果问题时间较久，看日志及监控不易排查，可以询问是否可以造一个复现该问题的case，这样只需观察最新的日志即可，方便排错。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;定位到请求后，我们要分析请求及响应的哪些数据是异常的，即定位关键数据，然后定位数据来源（是从数据库查的，还是从缓存查的），并观察响应数据与真实数据源是否一致。如果不一致，可能是业务逻辑中对数据的处理出现了问题，再进一步去做分析。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;高效沟通建议：描述问题，尽量用数据说话，给出截图的同时，要提供完整的数据、请求等信息，有助他人分析。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;12. 线上出现部分错误数据&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一个可以预见的问题。还好已经在项目中配置了邮件告警，能够报告错误数据的信息，错误数据量也不大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解决：修复导致错误数据的 bug 后，编写程序循环所有错误信息并生成请求代码，然后手动执行请求代码，刷新线上不同步数据即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;建议：设计时还是要尽可能考虑到风险，可以按照问题的严重程度做分级报警策略（短信 &amp;gt; 邮件 &amp;gt; 通讯软件）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;13. 线上机器 OOM！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上线三天后发现的问题，部分线上机器竟然出现了OOM（堆内存溢出）的情况，导致服务不可用。经排查，是使用的第三方中间件的当前版本存在 bug， 所以说在使用组件前要充分调研和风险评估，选择正确的版本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86318&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;血泪教训&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;有问题一定尽可能在测试环境去解决，否则线上出问题对心脏很不友好；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不要盲目乐观，以为上线就没问题，要多验证，保持警惕；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;使用第三方依赖时，一定要严格核对依赖版本号，确保稳定版本。使用老版本或版本不一致可能导致严重 bug！&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上线后如果发现问题，会经历如下流程，我称它为 hapy 流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如当发现 DB 服务的 bug 后，你只需要改 DB 服务的一行代码。然而还要做：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 修改DB服务的一行代码&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 跑单元测试&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. DB服务打成依赖包&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 修改“状态流转系统”、“查询系统”对DB服务的依赖包（改动版本号/更新本地缓存拉取最新包）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5. 重新发布“状态流转系统”、“查询系统”至测试环境&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;6. 可能还要重新交给测试的同学进行回归测试&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;7. 测试通过，再次提交“状态流转系统”、“查询系统”的代码，发起 CR（代码审查）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;8. 找同事或 Leader 读代码，通过 CR&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;9. 合并分支&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;10. 发布 “状态流转系统”、“查询系统” 至线上环境，每发一台机器，都要进行一次验证（滚动部署）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;11. 再次发现新的bug&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;566&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.997867803837953&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpR9scLygIvchPFvDLTpd5pjPLq2UweGeR6ibJnvZVqShQ9cBrhpkqKWkicWicktJNj074RhnfeSHdNXYJQRsv5Lg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;938&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一件恶心到爆炸的事情，但是在第 2、6、8 步骤时，是存在空余等待时间的。这时我们可以做做其他工作，记录一下工作内容、问题等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86318&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先总结一下这个项目各阶段的耗时：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;理解需求：5%&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;开发：15%&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;沟通确认问题：30%&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;测试及验证：30%&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;上线及验证：20%&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中，修复 bug 贯穿后面的几个流程，大概占了总时间的60%。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.45385779122541603&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/GpR9scLygIvchPFvDLTpd5pjPLq2UweGq1ebLSPRYgCtwT5kZTSdo1SOEttlBuFHr325M1gbHMtn7o5erctiaJQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;661&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;项目过程存在的问题：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;前期未参与需求评审，了解的信息较少；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;上线前一天晚上，竟然还在临时对齐接口？这是在沟通方案阶段应该确认好的；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;大约 80% 的时间花在沟通、查询数据、提供数据及验证；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;自己没测试完，就开始串测，导致同一个 bug 被多方发现，反复 @，导致改 bug 效率低下；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对自研中间件的不熟悉，导致花费的时间成本较高；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;全局观还不够，不能提前预见到一些可能的问题；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对中间件调研不够，在最初未核对依赖版本号导致线上机器 OOM。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;自我感觉良好的地方：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;成长与收获：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;抗压熬夜能力 ↑&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;设计思维能力 ↑&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;沟通能力 ↑&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;解决问题能力 ↑&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;高级命令熟悉度 ↑&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;中间件熟悉度 ↑&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;集群管理能力 ↑&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;拒绝需求能力 ↑&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;吐槽能力 ↑&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;吹 🐂 能力 ↑&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8660550458715597&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpR9scLygIvchPFvDLTpd5pjPLq2UweGZkIqZIQXIwmjuy6KO5LQgxia7oyFXUapmPHNakqsONeFrl5197nKwaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1090&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86318&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;后续&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;项目上线后，通过总结复盘，发现了项目中值得优化的地方，也思考到了一些更健全的机制，将逐渐去实现。比如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前采用复制粘贴的方式去同步相同的配置，这种方式的优点是比较简单。但缺点也很明显，如果一个系统的配置改了，而忘了修改另一个系统的配置，就会出现错误。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;事实上，可以引入一个配置中心，集中管理多个系统的配置文件，并且支持手动修改、多环境、灰度、配置版本回退等功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以采用阿里的 Nacos 或携程的 Apollo，提供了界面来管理配置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;345&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.60703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpR9scLygIvchPFvDLTpd5pjPLq2UweGvlgB3rYmYgYYMlgy7NQh4QebZU0Fy6d6bWzId5Z0urTG2gjBG4jCuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;无法保证进程不闪退，但是可以对进程实时监控，并自动对闪退进程进行重启。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实现方式有两种：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;工作真是简单而不简单，谁说后端只是 CRUD（增删改查）？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6183206106870229&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpR9scLygIvchPFvDLTpd5pjPLq2UweGNfib543KmKpDaMo0Q0zFJtcFSWnibGoSibqcZJVXYdiaP5plAZafGJvMQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;524&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d19dfe6ce351c7bc13d5d313dcaec85d</guid>
<title>治疗磁盘空间不足焦虑症，释放容器占用空间：Win10 + Docker 篇</title>
<link>https://toutiao.io/k/2ezimog</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img data-ratio=&quot;0.5426439232409381&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8uJ0ic6nAagic4SbmVzrnhXuc14vFJjUNTF6c2jD2qjAOzjibmOISWvWXfdhCrRCPZp8UiamjAcbAMdZeFebKMNhHg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;938&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在之前的文章里（《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3MDU3OTc1Nw==&amp;amp;mid=2247485144&amp;amp;idx=1&amp;amp;sn=ab4b0e14d929b58b895290071dfa71c2&amp;amp;chksm=eacfa79addb82e8c6780e9efe119de5a2b58d9d9ac6cba056b58d5d3afe698cca767238d3fee&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;在Win10使用WSL2跑Docker，C盘空间不足焦虑症你有吗？&lt;/a&gt;》）我们治好了C盘不足焦虑症。Docker这个磨人的小妖精，让我舒服了没几天...&lt;/p&gt;&lt;p&gt;  &lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2723735408560311&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAagic4SbmVzrnhXuc14vFJjUNTVklVJ2FTWQgVTFMicyrgpYXUe4SAHdwAaHXPu55KeB9EbwiaCNAUdU9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;257&quot;/&gt;&lt;/p&gt;&lt;p&gt;磁盘焦虑症，又要发作了...&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这主要还是因为有了docker，部署测试环境实在太方便了，然后毫无节制的拉镜像，最后导致了磁盘空间不足，但是你直接在控制面板里删除image，也不会释放wsl的空间，那么我们该怎么办呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.576&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAagic4SbmVzrnhXuc14vFJjUNTY6Ffhtrf2rFIa0AKL6gniahSwqSKFwRUujaVWjYfbnMNBr1q52vPHbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1250&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;释放空间&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;Optimize&lt;/span&gt;-VHD -&lt;span class=&quot;code-snippet__keyword&quot;&gt;Path&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;e:\wsl_swap_dir\wsl-docker-data\ext4.vhdx&quot;&lt;/span&gt; -&lt;span class=&quot;code-snippet__keyword&quot;&gt;Mode&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;Full&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;重启服务&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;net &lt;span class=&quot;code-snippet__keyword&quot;&gt;start&lt;/span&gt; LxssManager&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;start&lt;/span&gt;-vm DockerDesktopVM&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;C:\Program Files\Docker\Docker\Docker Desktop.exe&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;net &lt;span class=&quot;code-snippet__keyword&quot;&gt;start&lt;/span&gt; com.docker.service&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;然后再看看效果吧。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;————————————华丽的分割线——————————&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;新春就要到了，在此恭祝朋友们在新的一年里，万事如意，财源广进，身体健康，阖家欢乐。如果我的文章，对你有一点点帮助的话，也希望你帮我多多转发，评论。 &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;敬礼！&lt;br/&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关注 【&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;麒思妙想&lt;/span&gt;&lt;span&gt;】解锁更多硬核。&lt;/span&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;历史文章导读&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果文章对您有那么一点点帮助，我将倍感荣幸&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;欢迎  &lt;span&gt;&lt;strong&gt;关注、在看、点赞、转发 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8uJ0ic6nAag8EItgzqIEhe3GbK3ibibrSC3kGNLaCYoEXEEEV8vatdHqibkazrs7oLJERAG1cldW9pbVmcTKvXL3fA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b40a3dc7734ba68e9286b63f176da729</guid>
<title>Netty 非池化内存分配</title>
<link>https://toutiao.io/k/xffmbdf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section label=&quot;Copyright © 2015 Yead All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非池化内存的分配由UnpooledByteBufAllocator负责，本文梳理下由其负责分配的堆内存和堆外内存如何实现的 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Netty在非池化堆内存分配上Java9与Java8以下版本有啥不同呢？Netty堆外内存回收默认机制使用JDK提供的Cleaner吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家随便看看，可以添加老梁微信「gaoliang1719」建立链接。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-custom=&quot;#138bde&quot; data-id=&quot;86122&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;一、&lt;span&gt;非池化堆内内存分配&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面这小段代码摘自UnpooledByteBufAllocator#newHeapBuffer，通过此方法分析非池化堆内存的分配。&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; ByteBuf &lt;span&gt;newHeapBuffer&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; initialCapacity, &lt;span&gt;int&lt;/span&gt; maxCapacity)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; PlatformDependent.hasUnsafe() ?&lt;br/&gt;  &lt;span&gt;new&lt;/span&gt; InstrumentedUnpooledUnsafeHeapByteBuf(&lt;span&gt;this&lt;/span&gt;, initialCapacity, maxCapacity) :&lt;br/&gt;  &lt;span&gt;new&lt;/span&gt; InstrumentedUnpooledHeapByteBuf(&lt;span&gt;this&lt;/span&gt;, initialCapacity, maxCapacity);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解读：&lt;/strong&gt; 堆内内存分配由newHeapBuffer方法负责，如果平台支持Unsafe则创建InstrumentedUnpooledUnsafeHeapByteBuf，否则创建&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;InstrumentedUnpooledHeapByteBuf，下图为非池化相关类图，分别从两个类UnpooledDirectByteBuf和UnpooledHeapByteBuf延伸开来。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4067796610169492&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/aCASXoK2nU44gRavfSg4BicP31GiaZofprNSiaZs5zEd0Hzvvma9qZXpWO9BRsfzicXJog8efX5ibN2BIa2k5cUK2Bg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1416&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是聚集到堆内存的分配上来，主要分析上图中红色部分。InstrumentedUnpooledUnsafeHeapByteBuf和InstrumentedUnpooledHeapByteBuf有啥区别？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;InstrumentedUnpooledUnsafeHeapByteBuf&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面看下InstrumentedUnpooledUnsafeHeapByteBuf其内存分配的行为allocateArray().&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.36987951807228914&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/aCASXoK2nU44gRavfSg4BicP31GiaZofprlw0WySzQHcsuFgvbyDUKtnLLXtNV0C7xURYfoqrlZt5yplcp6dF6Gg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1660&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.11202185792349727&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/aCASXoK2nU44gRavfSg4BicP31GiaZofprTxbKOaJMAPAl5QrriaLUO96UuSgfVOafEkuicW0sOMDvszG5F1hpuGyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1464&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.18081180811808117&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/aCASXoK2nU44gRavfSg4BicP31GiaZofprOx3fiaX8lbbtLibp0K1C8MsRVcksm2IelrxNBMc4vCOABUoelb8IvcnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1626&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.12721238938053098&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/aCASXoK2nU44gRavfSg4BicP31GiaZofprxtdviabNBXvXwiakwzYjN3dsDQezqRwbXy7URPDjLsF5sOgCUCxeIOug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1808&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注解@1&lt;/strong&gt; 调用了父类UnpooledUnsafeHeapByteBuf的allocateArray()&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注解@2&lt;/strong&gt; 父类UnpooledUnsafeHeapByteBuf调用了PlatformDependent#allocateUninitializedArray&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注解@3/@4&lt;/strong&gt;  Java9以上版本：如果待分配的内存小于1K使用堆内存，待分配的内存大于等于1K使用堆外内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java8以及以下版本全部在堆内存分配&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;小结：&lt;/strong&gt;  使用InstrumentedUnpooledUnsafeHeapByteBuf进行内存分配时：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Java9以及以上版本：如果待分配的内存小于1K使用堆内存；待分配的内存大于等于1K使用堆外内存（调用底层PlatformDependent#allocateUninitializedArray）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Java8以及以下版本：使用堆内存分配。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;InstrumentedUnpooledHeapByteBuf&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面为InstrumentedUnpooledHeapByteBuf的内存分配allocateArray().&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.36319612590799033&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/aCASXoK2nU44gRavfSg4BicP31GiaZofprCb8rDmNvM70AWedQ9ocTU37epPSNKwSbRGvzArWe2JqFRPy5nQicq0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1652&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.10223642172523961&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/aCASXoK2nU44gRavfSg4BicP31GiaZofprdC2jfTaYjrNoCFTw22pC5namXfysBKRjxDDtCJC6cc83vpsyeiaUIeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1252&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注解@1&lt;/strong&gt; 调用父类 UnpooledHeapByteBuf的内存分配&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注解@2&lt;/strong&gt; UnpooledHeapByteBuf的通过new byte直接在堆内存分配&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;小结：&lt;/strong&gt; InstrumentedUnpooledHeapByteBuf直接在堆内存分配空间。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;数据获取方式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;UnpooledUnsafeHeapByteBuf数据获取&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;UnpooledUnsafeHeapByteBuf的数据获取方式getByte()&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; &lt;span&gt;_getByte&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; UnsafeByteBufUtil.getByte(array, index);&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法调用UnsafeByteBufUtil的getByte，跟进去看下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; &lt;span&gt;getByte&lt;/span&gt;&lt;span&gt;(&lt;span&gt;byte&lt;/span&gt;[] array, &lt;span&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; PlatformDependent.getByte(array, index);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;底层通过UNSAFE.getByte这种地址+偏移量的方式获取内存中的数据。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; &lt;span&gt;getByte&lt;/span&gt;&lt;span&gt;(&lt;span&gt;byte&lt;/span&gt;[] data, &lt;span&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; UNSAFE.getByte(data, BYTE_ARRAY_BASE_OFFSET + index);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;UnpooledHeapByteBuf数据获取&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;UnpooledHeapByteBuf数据获取方式_getByte()&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; &lt;span&gt;_getByte&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; HeapByteBufUtil.getByte(array, index);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法调用HeapByteBufUtil.getByte，跟进去看下，即直接从数组中获取数据。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; &lt;span&gt;getByte&lt;/span&gt;&lt;span&gt;(&lt;span&gt;byte&lt;/span&gt;[] memory, &lt;span&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; memory[index];&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;小结：&lt;/strong&gt; UnpooledUnsafeHeapByteBuf通过UNSAFE.getByte这种地址+偏移量的方式获取内存中的数据；UnpooledHeapByteBuf通过数组直接从堆内存获取。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;非池化堆内存分配总结&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当使用Netty非池化进行堆内存分配时：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.Java8及其以下版本：直接在堆空间分配内存。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.Java9及其以上版本：如果系统支持Unsafe时（通常都是支持的），对于小于1K（默认）的在堆内存分配，大于1K的分配堆外内存；如果系统不支持Unsafe直接在堆内存分配；默认大小阈值可以通过-Dio.netty.uninitializedArrayAllocationThreshold来指定，默认为1024字节。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.堆内存数据获取通过数组实现；堆外内存获取通过UNSAFE.getByte这种地址+偏移量的方式获取。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-custom=&quot;#138bde&quot; data-id=&quot;86122&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;二、非池化堆外内存分配&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面这段代码摘自UnpooledByteBufAllocator#newDirectBuffer方法，通过此方法分析非池化堆外存的分配。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; ByteBuf &lt;span&gt;newDirectBuffer&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; initialCapacity, &lt;span&gt;int&lt;/span&gt; maxCapacity)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;final&lt;/span&gt; ByteBuf buf;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (PlatformDependent.hasUnsafe()) {&lt;br/&gt;   buf = noCleaner ? &lt;span&gt;new&lt;/span&gt; InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf(&lt;span&gt;this&lt;/span&gt;, initialCapacity, maxCapacity) :&lt;br/&gt;   &lt;span&gt;new&lt;/span&gt; InstrumentedUnpooledUnsafeDirectByteBuf(&lt;span&gt;this&lt;/span&gt;, initialCapacity, maxCapacity);&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;   buf = &lt;span&gt;new&lt;/span&gt; InstrumentedUnpooledDirectByteBuf(&lt;span&gt;this&lt;/span&gt;, initialCapacity, maxCapacity);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; disableLeakDetector ? buf : toLeakAwareBuffer(buf);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解读：&lt;/strong&gt; 平台不支持支持Unsafe，构造InstrumentedUnpooledDirectByteBuf；平台支持Unsafe并且noCleaner=true构造InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf；平台支持Unsafe并且noCleaner=false，构造InstrumentedUnpooledUnsafeDirectByteBuf。那问题来了，这三个有啥区别呢？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;noCleaner&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; noCleaner = tryNoCleaner &amp;amp;&amp;amp; PlatformDependent.hasUnsafe()&lt;br/&gt;                &amp;amp;&amp;amp; PlatformDependent.hasDirectBufferNoCleanerConstructor();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解读&lt;/strong&gt; ：三个判断条件一个一个来看：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;@1 tryNoCleaner=PlatformDependent.useDirectBufferNoCleaner()该方法在前一篇文章中也分析过，当maxDirectMemory!=0 &amp;amp;&amp;amp; 支持Unsafe &amp;amp;&amp;amp; DirectByteBuffer的构造函数可用时，tryNoCleaner = true。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;@2 PlatformDependent.hasUnsafe() 在上一篇文章中分析过具体 UNSAFE_UNAVAILABILITY_CAUSE == null，平台不支持UNSAFE会将异常封装在UNSAFE_UNAVAILABILITY_CAUSE中，等于null意味着平台支持Unsafe。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;@3 PlatformDependent.hasDirectBufferNoCleanerConstructor() 指的是通过反射DirectByteBuffer构造器对象是否可用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以看出，通常在实践中（Linux、JDK8）上面这些条件都是支持的，也就是Netty默认noCleaner为true。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面看下堆外内存的分配和回收：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48596112311015116&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/aCASXoK2nU44gRavfSg4BicP31GiaZofpruHvLVIWcY3BB3cAYOavkzlcr5aOeCwTTvibkUKNiadEnRuj7tZ6aMw8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;926&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注解@1&lt;/strong&gt;  堆外内存分配底层调用了PlatformDependent0#allocateDirectNoCleaner方法，malloc()返回获得内存空间的首地址，失败返回null，然后根据返回的内存地址调用DirectByteBuffer构造函数分配堆外内存。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; ByteBuffer &lt;span&gt;allocateDirectNoCleaner&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; capacity)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// Calling malloc with capacity of 0 may return a null ptr or a memory address that can be used.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// Just use 1 to make it safe to use in all cases:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// See: http://pubs.opengroup.org/onlinepubs/009695399/functions/malloc.html&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;  * malloc()返回获得内存空间的首地址，失败返回null&lt;br/&gt;  */&lt;/span&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; newDirectBuffer(UNSAFE.allocateMemory(Math.max(&lt;span&gt;1&lt;/span&gt;, capacity)), capacity);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注解@2&lt;/strong&gt; 堆外内存释放底层调用了PlatformDependent0#freeMemory方法，通过UNSAFE.freeMemory释放堆外内存。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;freeMemory&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; address)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    UNSAFE.freeMemory(address);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;InstrumentedUnpooledUnsafeDirectByteBuf&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面看下堆外内存的分配与回收&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.33585313174946&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/aCASXoK2nU44gRavfSg4BicP31GiaZofpr426W1uXOnGs1cJo4m8wkcvMI7868SzhXLgcC7YJ8uquP5qljNPhV6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;926&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注解@1&lt;/strong&gt; 底层调用ByteBuffer#allocateDirect来分配堆外内存，具体为直接new DirectByteBuffer()&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ByteBuffer &lt;span&gt;allocateDirect&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; capacity)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; DirectByteBuffer(capacity);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注解@2&lt;/strong&gt; 释放堆外内存调用了PlatformDependent#freeDirectBuffer()底层调用CLEANER.freeDirectBuffer实现&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;freeDirectBuffer&lt;/span&gt;&lt;span&gt;(ByteBuffer buffer)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   CLEANER.freeDirectBuffer(buffer);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;nstrumentedUnpooledDirectByteBuf&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.35085714285714287&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/aCASXoK2nU44gRavfSg4BicP31GiaZofprLRBiatJqGhiarsmnGxiasuOjuVOA7vIiao9Zv7ibFBtN49HDbp3wMXa6TZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1750&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注解@1&lt;/strong&gt; 堆外内存分配同InstrumentedUnpooledUnsafeDirectByteBuf，通过父类UnpooledDirectByteBuf#allocateDirect调用ByteBuffer#allocateDirect来分配堆外内存，堆内存直接new DirectByteBuffer&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ByteBuffer &lt;span&gt;allocateDirect&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; capacity)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; DirectByteBuffer(capacity);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注解@2&lt;/strong&gt; 堆外内存释放同InstrumentedUnpooledUnsafeDirectByteBuf，通过父类UnpooledDirectByteBuf#freeDirect调用底层调用CLEANER.freeDirectBuffer实现。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;freeDirectBuffer&lt;/span&gt;&lt;span&gt;(ByteBuffer buffer)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    CLEANER.freeDirectBuffer(buffer);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;小结：&lt;/strong&gt; @1 InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf的内存释放调用UNSAFE.freeMemory(address)实现&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;@2 InstrumentedUnpooledUnsafeDirectByteBuf和nstrumentedUnpooledDirectByteBuf的内存释放是一样的，使用了JDK提供的CLEANER.freeDirectBuffer(buffer)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;@3 Netty默认自行管理堆外内存的分配与释放，并未使用JDK提供的释放方式，而是通过底层API自行释放。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;堆外内存数据获取&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是三个buffer获取内存数据的方式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf通过UnpooledUnsafeDirectByteBuf#_getByte()获取数据&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;InstrumentedUnpooledUnsafeDirectByteBuf通过UnpooledUnsafeDirectByteBuf#_getByte()获取数据&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nstrumentedUnpooledDirectByteBuf通过UnpooledDirectByteBuf#_getByte()获取数据&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf和InstrumentedUnpooledUnsafeDirectByteBuf获取方式一样；下面看下这两类获取方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;UnpooledUnsafeDirectByteBuf获取内存数据&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; &lt;span&gt;_getByte&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; UnsafeByteBufUtil.getByte(addr(index)); &lt;span&gt;// 注解@1&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注解@1&lt;/strong&gt; 底层通过UNSAFE.getByte(address)这种“地址+偏移量” 的方式获取内存数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;UnpooledDirectByteBuf获取内存数据&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; &lt;span&gt;_getByte&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; buffer.get(index); &lt;span&gt;// 注解@2&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注解@2&lt;/strong&gt; 通过ByteBuffer#get方式获取，底层通过Bits#unsafe.getByte(address)获取内存数据。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;非池化堆外内存总结&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Netty在堆外内存分配上，在系统支持的情况下，默认自己通过UNSAFE.freeMemory去释放内存，也就是noCleaner，没有使用JDK提供的Cleaner释放机制。至于为啥netty选择自己实现，不用JDK提供的方式，主要考虑性能原因，与JDK Bits设计有关系。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a150118905fe66226029a72b8dbdd517</guid>
<title>Go 实现项目内链路追踪（二）</title>
<link>https://toutiao.io/k/bau5b4x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上篇文章 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;amp;mid=2448835846&amp;amp;idx=1&amp;amp;sn=3d98a94141233d6745fbf902cbdad1bb&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Go - 实现项目内链路追踪&lt;/a&gt; 分享了，通过 &lt;code&gt;链路 ID&lt;/code&gt; 可以将 &lt;code&gt;请求信息&lt;/code&gt;、&lt;code&gt;响应信息&lt;/code&gt;、&lt;code&gt;调用第三方接口的信息&lt;/code&gt;、&lt;code&gt;调试信息&lt;/code&gt;、&lt;code&gt;执行的 SQL 信息&lt;/code&gt;、&lt;code&gt;执行的 Redis 信息&lt;/code&gt; 串起来，记录的具体参数在文件中都有介绍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章在上面的基础上，&lt;span&gt;新增 2 个功能点&lt;/span&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;新增将 &lt;code&gt;调用 gRPC 接口信息&lt;/code&gt; 记录到 &lt;code&gt;Trace&lt;/code&gt; 中；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;新增对记录的敏感信息进行脱敏处理；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;调用 gRPC 接口信息&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;记录参数&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Object&lt;/code&gt;，结构如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Grpc struct {&lt;br/&gt; Timestamp   string                 `json:&lt;span&gt;&quot;timestamp&quot;&lt;/span&gt;`             // 时间，格式：2006-01-02 15:04:05&lt;br/&gt; Addr        string                 `json:&lt;span&gt;&quot;addr&quot;&lt;/span&gt;`                  // 地址&lt;br/&gt; Method      string                 `json:&lt;span&gt;&quot;method&quot;&lt;/span&gt;`                // 操作方法&lt;br/&gt; Meta        metadata.MD            `json:&lt;span&gt;&quot;meta&quot;&lt;/span&gt;`                  // Mate 信息&lt;br/&gt; Request     map[string]interface{} `json:&lt;span&gt;&quot;request&quot;&lt;/span&gt;`               // 请求信息&lt;br/&gt; Response    map[string]interface{} `json:&lt;span&gt;&quot;response&quot;&lt;/span&gt;`              // 返回信息&lt;br/&gt; CostSeconds float64                `json:&lt;span&gt;&quot;cost_seconds&quot;&lt;/span&gt;`          // 执行时间(单位秒)&lt;br/&gt; Code        string                 `json:&lt;span&gt;&quot;err_code,omitempty&quot;&lt;/span&gt;`    // 错误码&lt;br/&gt; Message     string                 `json:&lt;span&gt;&quot;err_message,omitempty&quot;&lt;/span&gt;` // 错误信息&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;如何收集参数&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;封装了一个 &lt;code&gt;grpclient&lt;/code&gt; 包：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;支持设置 &lt;code&gt;DialTimeout&lt;/code&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持设置 &lt;code&gt;UnaryInterceptor&lt;/code&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持设置 &lt;code&gt;KeepaliveParams&lt;/code&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持设置 &lt;code&gt;TransportCredentials&lt;/code&gt;；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要是在拦截器 &lt;code&gt;Interceptor&lt;/code&gt; 中进行收集。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;示例代码&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实例化 gRPC client&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// TODO 需从配置文件中获取&lt;br/&gt;target := &lt;span&gt;&quot;127.0.0.1:9988&quot;&lt;/span&gt;&lt;br/&gt;secret := &lt;span&gt;&quot;abcdef&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;clientInterceptor := NewClientInterceptor(func(message []byte) (authorization string, err error) {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; GenerateSign(secret, message)&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;conn, err := grpclient.New(target,&lt;br/&gt; grpclient.WithKeepAlive(keepAlive),&lt;br/&gt; grpclient.WithDialTimeout(time.Second*5),&lt;br/&gt; grpclient.WithUnaryInterceptor(clientInterceptor.UnaryInterceptor),&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &amp;amp;clientConn{&lt;br/&gt; conn: conn,&lt;br/&gt;}, err&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;调用具体方法&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 核心：传递 core.Context 给 Interceptor 使用&lt;br/&gt;client := hello.NewHelloClient(d.grpconn.Conn())&lt;br/&gt;client.SayHello(grpc.ContextWithValueAndTimeout(c, time.Second*3), &amp;amp;hello.HelloRequest{Name: &lt;span&gt;&quot;Hello World&quot;&lt;/span&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;敏感信息脱敏&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;敏感信息脱敏又称为动态数据掩码（Dynamic Data Masking，简称为DDM）能够防止把敏感数据暴露给未经授权的用户。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据项目要求可以约定一些规范，例如：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型&lt;/th&gt;&lt;th&gt;要求&lt;/th&gt;&lt;th&gt;示例&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;手机号&lt;/td&gt;&lt;td&gt;前 3 后 4&lt;/td&gt;&lt;td&gt;132****7986&lt;/td&gt;&lt;td&gt;定长 11 位数字&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;邮箱地址&lt;/td&gt;&lt;td&gt;前 1 后 1&lt;/td&gt;&lt;td&gt;l**w@gmail.com&lt;/td&gt;&lt;td&gt;仅对 @ 之前的邮箱名称进行掩码&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;姓名&lt;/td&gt;&lt;td&gt;隐姓&lt;/td&gt;&lt;td&gt;*鸿章&lt;/td&gt;&lt;td&gt;将姓氏隐藏&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;密码&lt;/td&gt;&lt;td&gt;不输出&lt;/td&gt;&lt;td&gt;******&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;银行卡卡号&lt;/td&gt;&lt;td&gt;前 6 后 4&lt;/td&gt;&lt;td&gt;622888******5676&lt;/td&gt;&lt;td&gt;银行卡卡号最多 19 位数字&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;身份证号&lt;/td&gt;&lt;td&gt;前 1 后 1&lt;/td&gt;&lt;td&gt;1******7&lt;/td&gt;&lt;td&gt;定长 18 位&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;如何实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我现在的实现方案是：&lt;span&gt;自定义 MarshalJSON()&lt;/span&gt;，欢迎大佬们提出更好的方案。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;示例代码&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 定义 Mobile 类型&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Mobile string&lt;br/&gt;&lt;br/&gt;// 自定义 MarshalJSON()&lt;br/&gt;func (m Mobile) MarshalJSON() ([]byte, error) {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; len(m) != 11 {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; []byte(`&lt;span&gt;&quot;` + m + `&quot;&lt;/span&gt;`), nil&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; v := fmt.Sprintf(&lt;span&gt;&quot;%s****%s&quot;&lt;/span&gt;, m[:3], m[len(m)-4:])&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; []byte(`&lt;span&gt;&quot;` + v + `&quot;&lt;/span&gt;`), nil&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;测试&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; message struct {&lt;br/&gt; Mobile    ddm.Mobile   `json:&lt;span&gt;&quot;mobile&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;msg := new(message)&lt;br/&gt;msg.Mobile = ddm.Mobile(&lt;span&gt;&quot;13288889999&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;marshal, _ := json.Marshal(msg)&lt;br/&gt;fmt.Println(string(marshal))&lt;br/&gt;&lt;br/&gt;// 输出：{&lt;span&gt;&quot;mobile&quot;&lt;/span&gt;:&lt;span&gt;&quot;132****9999&quot;&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇文章新增了 2 个实用的功能点，大家赶紧使用起来吧。关于 &lt;code&gt;敏感信息脱敏&lt;/code&gt; 期待各位大佬不吝赐教，提出更好的解决方案，谢谢！&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;以上代码都在 go-gin-api 项目中，地址：https://github.com/xinliangnote/go-gin-api&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5NDM4MDIwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/go9jpG3BuhQHrM0sshKxdaibyDNjXooZvnwwy0yRjdhlXrtVUkJSvQib4Ppwib1v5HucaRc8WPtgvhPBicMeiadAv9Q/0?wx_fmt=png&quot; data-nickname=&quot;新亮笔记&quot; data-alias=&quot;XinLiangTalk&quot; data-signature=&quot;程序猿的打怪升级之路。&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e71cf4e4a30822ff01c1c20ed768273c</guid>
<title>使用服务网格来实现 Kubernetes 可观察性</title>
<link>https://toutiao.io/k/e52p42t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;客座文章作者：Buoyant软件工程师Risha Mars。文章最初在&lt;span&gt;Buoyant的博客上&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;发表。&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本文中，我们将向你展示如何完成基本的Kubernetes可观察性任务：从运行在Kubernetes集群上的应用程序获得“黄金指标”（或“黄金信号”）。我们不需要修改任何代码，也不需要进行任何配置，只要安装&lt;span&gt;Linkerd（一个开源的超轻服务网格）&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;就可以做到这一点。我们将介绍服务网格是什么，术语“可观察性”是什么意思，以及这两者在Kubernetes上下文中是如何关联的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;使用服务网格监控Kubernetes应用程序&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你们刚刚采用了Kubernetes。恭喜你！但是现在要做什么？任何Kubernetes采用者的第一个可观察性任务之一是监控——至少，你需要知道什么时候出现了问题，以便你可以快速地修复它们。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kubernetes可观察性是一个非常广泛的话题，网上有很多关于可观察性与监控、分布式跟踪与日志记录等之间的细微差别的讨论。在本文中，我们将重点讨论一个基本问题：在不更改任何代码的情况下，从运行在集群上的应用程序获得“黄金指标”（或“黄金信号”）。我们将安装一个Linkerd，一个开源的超轻&lt;span&gt;服务网格&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;。与大多数服务网格不同，Linkerd只需要在集群上安装几分钟，不需要配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然简单，但Linkerd包含了一个非常强大的指标管道。当安装完毕，它将通过观察与集群上运行的所有组件之间的HTTP（或gRPC）和TCP通信，自动检测并报告成功率、流量级别和响应延迟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linkerd可以自动为服务报告的指标通常被引用为服务的黄金指标。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;黄金指标是什么和为什么很重要？&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你已经知道黄金指标是什么，请跳过到下一节！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;黄金指标（或“黄金信号”）是你需要了解应用程序是否按预期启动和运行的首要指标。这些指标为你提供了有关服务运行状况的粗略信号，而不需要知道服务的实际功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Cindy Sridharan在她关于监控和可观察性的&lt;span&gt;博文&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;中写道：“当不直接驱动警报时，监控数据应该被优化，以提供系统整体健康状况的鸟瞰图。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;谷歌SRE书&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;定义的“黄金指标”为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;延迟——一种衡量服务速度快慢的方法。它是服务请求所花费的时间，通常以百分比来度量。第99百分位延迟为5ms意味着99%的请求在5ms或更短的时间内得到服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;流量——让你知道某项服务有多忙或“有需求”。通常用每秒对服务的请求数来衡量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;错误——请求失败的数量。通常与总流量相结合来生成一个“成功率”——成功请求与遇到错误请求的比率。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;饱和度——根据系统的主要约束条件，衡量系统的负载情况。如果系统受到内存限制，这可能是当前使用的最大内存百分比的度量。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过观察服务的流量，Linkerd可以简单地提供延迟、流量和错误的测量——Linkerd以成功率的形式提供了这些数据。（第四个指标，饱和度，在监控讨论中经常被忽略，因为它需要了解服务的内部情况，通常跟踪其他指标，如流量和延迟。）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时这些指标也被称为服务的“RED”指标:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;R&lt;/strong&gt;ate——你的服务每秒正在处理的请求数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;E&lt;/strong&gt;rrors——每秒失败的请求数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;D&lt;/strong&gt;uration——每个请求所花费时间的分布。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管你怎么称呼它们，Linkerd的美妙之处在于，它不仅记录这些指标的流量，而且汇总和报告它们，这样我们就可以轻松地使用它们。（我们将在下面看到。）这使我们能够&lt;span&gt;监控&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;我们的应用程序。当我们能够监控我们的应用程序，我们就可以在出错时收到警报；研究其长期性能；并对其可靠性和性能进行测试和改进。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;黄金指标：最简单的方法&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;安装：访问Kubernetes集群并安装Linkerd CLI&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们假设你有一个正常运行的Kubernetes集群和一个指向它的&lt;code&gt;kubectl&lt;/code&gt;命令。在本节中，我们将带你浏览&lt;span&gt;Linkerd入门指南&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;的缩写版本，以便在这个集群上安装Linkerd和一个演示应用程序（我们将获得黄金指标的应用程序）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，安装Linkerd命令行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;curl -sL https://run.linkerd.io/install | sh&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; PATH=&lt;span&gt;$PATH&lt;/span&gt;:&lt;span&gt;$HOME&lt;/span&gt;/.linkerd2/bin&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（或者，直接从&lt;span&gt;Linkerd发行页面&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;下载。）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;验证Kubernetes集群是否能够支持Linkerd；安装Linkerd；并验证安装：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;linkerd check --pre&lt;br/&gt;linkerd install | kubectl apply -f -&lt;br/&gt;linkerd check&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，安装“Emojivoto”演示应用程序，这是我们希望获得黄金指标的应用程序。如果仔细观察下面的命令，你将看到我们实际上是在向应用程序添加linkerd（我们称之为“注入”），然后将应用程序部署到Kubernetes。（如果你想知道这是如何工作的，请查看我们的&lt;span&gt;文档&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;curl -sL https://run.linkerd.io/emojivoto.yml \&lt;br/&gt;| linkerd inject - \&lt;br/&gt;| kubectl apply -f -&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;嗯，就是这样。这就是你需要的所有工具，你的应用程序，并能够访问你的黄金指标！现在让我们来看看他们。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;在Grafana查看指标&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想要看到所有这些有用的图表和仪表板吗？不是一个问题！运行&lt;code&gt;linkerd dashboard –show grafana&lt;/code&gt;并打开命令输出的链接。你将看到Linkerd的Top Line仪表板，其中包含它所收集的指标的总体和每个命名空间的细分。向下滚动到我们应用的命名空间（ns/emojivoto），观察以下图表：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.34765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJzuJn1v4qKiag2bV31sCvOaDAUosu0Tth5urzMK06XauOn2XS1Iibt4EiaUDPVrwLl4U4JbZpaphv79Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;通过Linkerd CLI查看指标&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还可以使用&lt;code&gt;linkerd stat&lt;/code&gt;命令查看应用程序的指标。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1648177496038035&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJzuJn1v4qKiag2bV31sCvOaDPzS1vdulzgu9fhCOpy9KK8qc3TiaLwL7OEXbYekuPjWpfic1GHn3GkQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1262&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有这些数据也可以在Linkerd的dashboard中找到，通过运行&lt;code&gt;linkerd dashboard&lt;/code&gt;来访问：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJzuJn1v4qKiag2bV31sCvOaDy3ibvbkTfk4dspouibZxZPJjqvbP6vtcuU7S0bLmdYP2ayNib23NvSicxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看看Grafana图表（或Linkerd仪表盘），你可以立即看到“voting”服务做得不是很好-它的成功率相当低！向我们的应用程序中添加黄金指标可以立即让我们看到应用程序中可能出现的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;真的这么简单吗？答案是肯定的！我们所需要做的就是安装Linkerd并将其注入到我们的应用程序中。在底层，当Linkerd被添加到一个服务时，它会自动检测与服务的pod之间的任何HTTP和gRPC调用。由于它理解这些协议，它可以记录这些调用的响应类和延迟，并将它们聚合在一起，在这种情况下，将它们合并到一个名为&lt;span&gt;Prometheus&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt;的时间序列数据库的小型内部实例中。当你通过Linkerd的仪表板和CLI查看黄金指标时，Linkerd会从这个内部的Prometheus实例中获取它们，在不修改应用程序代码的情况下为你提供所有这些指标。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Linkerd还能做什么？&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们已经看到了如何使用Linkerd来获得黄金指标，这是获得系统&lt;span&gt;可观察性&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt;的第一步，也就是说，获得复杂应用程序中正在发生的事情的高级视图。但指标只是个开始。当你继续你的监控和可观察性旅程时，你一定会遇到另外两个常用的工具：日志和分布式跟踪。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式跟踪涉及到检测应用程序，以便测量请求在服务中花费的时间长度。当我们的应用程序使用许多相互通信的微服务时，跟踪是一个很好的工具，可以用来调试缓慢的请求，并找出哪个服务是瓶颈。&lt;span&gt;Linkerd可以帮助分布式跟踪&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt;，尽管&lt;span&gt;一个服务网格在分布式跟踪方面最终只能做这么多&lt;/span&gt;&lt;sup&gt;[13]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类似于分布式跟踪，Linkerd也提供了一个强大的动态请求跟踪工具tap。tap命令类似于“用于微服务的tcpdump”：它允许你查看发送到或来自特定服务的实时请求（部分）。Tap是&lt;span&gt;在生产中调试Kubernetes服务&lt;/span&gt;&lt;sup&gt;[14]&lt;/sup&gt;的强大工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，应用程序日志当然是开发人员在怀疑某个特定进程不正常时首先要做的事情之一。当运行一个服务网格时，有时候查看网格内部发生了什么是很有用的。虽然Linkerd不能为你提供应用程序日志，但&lt;code&gt;Linkerd logs&lt;/code&gt;&lt;span&gt;命令&lt;/span&gt;&lt;sup&gt;[15]&lt;/sup&gt;提供了一种简单的方法，至少可以查看Linkerd内部发生了什么。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这篇博文中，我们讨论了如何轻松获得运行在Kubernetes集群上的应用程序和服务的黄金指标。这是你被观察之旅坚实的第一步。当然，在你成为经过认证的Kubernetes可观察性专家之前，还有很多东西需要学习和实现！最近一个特别令人兴奋的可观察性话题是关于SLO，或者“服务水平目标（service level objective）”——不要错过我们关于&lt;span&gt;如何使用Prometheus和Linkerd来设置SLO的指南&lt;/span&gt;&lt;sup&gt;[16]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们希望这篇博文中的信息能够帮助你启动并运行Kubernetes服务。祝你旅途好运！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;Buoyant是Linkerd和Buoyant Cloud的创建者，后者是Kubernetes的全自动、基于Linkerd的平台健康仪表盘。&lt;span&gt;立即注册抢先体验&lt;/span&gt;&lt;sup&gt;[17]&lt;/sup&gt;！&lt;/em&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Buoyant的博客上: &lt;em&gt;https://buoyant.io/2021/01/11/kubernetes-monitoring-with-a-service-mesh/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;Linkerd（一个开源的超轻服务网格）: &lt;em&gt;https://buoyant.io/2021/01/11/kubernetes-monitoring-with-a-service-mesh/linkerd.io&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;服务网格: &lt;em&gt;https://buoyant.io/service-mesh-manifesto/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;博文: &lt;em&gt;https://copyconstruct.medium.com/monitoring-and-observability-8417d1952e1c&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;谷歌SRE书: &lt;em&gt;https://sre.google/sre-book/monitoring-distributed-systems/#xref_monitoring_golden-signals&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;监控: &lt;em&gt;https://sre.google/sre-book/monitoring-distributed-systems/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;Linkerd入门指南: &lt;em&gt;https://linkerd.io/2/getting-started&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;Linkerd发行页面: &lt;em&gt;https://github.com/linkerd/linkerd2/releases/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;文档: &lt;em&gt;https://linkerd.io/2/tasks/adding-your-service/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10]&lt;/span&gt;&lt;p&gt;Prometheus: &lt;em&gt;https://prometheus.io/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11]&lt;/span&gt;&lt;p&gt;可观察性: &lt;em&gt;https://thenewstack.io/monitoring-vs-observability-whats-the-difference/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12]&lt;/span&gt;&lt;p&gt;Linkerd可以帮助分布式跟踪: &lt;em&gt;https://linkerd.io/2/features/distributed-tracing/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[13]&lt;/span&gt;&lt;p&gt;一个服务网格在分布式跟踪方面最终只能做这么多: &lt;em&gt;https://linkerd.io/2019/08/09/service-mesh-distributed-tracing-myths/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[14]&lt;/span&gt;&lt;p&gt;在生产中调试Kubernetes服务: &lt;em&gt;https://linkerd.io/2/tasks/debugging-your-service/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[15]&lt;/span&gt;&lt;p&gt;命令: &lt;em&gt;https://linkerd.io/2/reference/cli/logs/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[16]&lt;/span&gt;&lt;p&gt;如何使用Prometheus和Linkerd来设置SLO的指南: &lt;em&gt;https://buoyant.io/2020/10/21/kubernetes-slos-with-prometheus-linkerd/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[17]&lt;/span&gt;&lt;p&gt;立即注册抢先体验: &lt;em&gt;https://buoyant.io/cloud&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>