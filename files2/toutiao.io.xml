<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>2ee39ce857145be62bcf3fc62091d2bf</guid>
<title>乒乓球自练网红神器，缓解程序员视力疲劳，全家都适用！</title>
<link>https://toutiao.io/k/six5ocz</link>
<content:encoded>&lt;div&gt;&lt;body id=&quot;readabilityBody&quot;&gt;


&lt;/body&gt;
&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>05dd7b7079a9f6167b5ae9ccca2f1256</guid>
<title>[推荐] 用规则引擎让你一天上线十个需求</title>
<link>https://toutiao.io/k/ldd1cse</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;各位读者朋友大家好，我是薯条，好久没更文章，不知还有多少读者记得这个号，这篇文章写的有点精分，如果你有耐心看完本文，可以翻翻留言区，我会发个新年红包。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;业务背景&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是本号老读者，可能知道我是做数据系统的，作为一个在线数据服务组，我们这边承接的需求是小而多的。我在一家打车公司上班，运营大佬们认为不同用户在不同场景下有不同打车需求，设计出来很多子品类。于是我们组会承接这样一类需求：计算用户不同品类的各种实时单量，如：快车呼单量、拼车完单量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的需求，一般处理流程是这样的：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2546419098143236&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR9Ct85IUoD4jW0aicGeicJV5hHuUicxxAkYbxqPehPYWNK9iauXQ6z8mgu3P2qmrh1YXcz7qJ2SbWeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1508&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;描述一下这个图：用户在订单流转状态关键节点发生动作时，系统会发一个MQ消息让供其他系统消费。其他系统通过一个明确的据口径判断这条msg是否符合当前业务逻辑，进而存db或是丢弃。比如一个需求要计算：拼车完单量，一个靠谱的拼车rd告诉你口径是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;If aa.bb.cc == &lt;span&gt;1&lt;/span&gt;  &lt;span&gt;// 说明是多车型发单&lt;/span&gt;&lt;br/&gt;  Unmarshal(bb.cc.ee)&lt;br/&gt;  看&lt;span&gt;type&lt;/span&gt;是否为 &lt;span&gt;4&lt;/span&gt; &lt;br/&gt;&lt;span&gt;else&lt;/span&gt;  &lt;span&gt;// 单车型发单&lt;/span&gt;&lt;br/&gt; Unmarshal(bb.cc.ff)&lt;br/&gt;  看&lt;span&gt;type&lt;/span&gt;是否为 &lt;span&gt;4&lt;/span&gt; &lt;br/&gt;(&lt;span&gt;type&lt;/span&gt; = &lt;span&gt;4&lt;/span&gt; 的是拼车)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你对着这个口径，订阅mq，写数据提取和订单判断的逻辑，整个流程写代码1小时，自测一小时，由于你们机器太多，上线花了1整天，整体研发效率还行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二天，产品又给你提了个需求，想计算拼车的发单量，你又去找对应业务线的开发同学寻求一个取数口径，然后重复上面的过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三天，产品上线了，效果不错，数据涨了3个点，老板非常开心，在周会上让PM讲两句他的心路历程，PM同学重点感谢了老板的栽培，然后轻描淡写的说了产品的底层逻辑和关键抓手。而他的几个精明的同事都get到了抓手是你，于是连夜赶PRD，要求你这个抓手把他们负责品类的各种实时单量全给抓出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第四天，你崩溃了，因为你收到4个PM并行的8个单量需求，正当你奋笔疾书再次准备重复上述流程时，你睿智的老板告诉你这样做有不妥之处：来一个坑填一个萝卜是小农时代的做法，现在都21世纪了，时代变了，让你想一种通用解决方案，让系统走向工业时代！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你似懂非懂点了点头，查了各种CSDN、博客园、知乎、github，又在技术交流群各种@群里大佬有没有遇到这种场景。一番折腾后终于有了头绪，于是你高兴的向老板汇报：老板，我懂了，这个场景可以用&lt;strong&gt;JPATH&lt;/strong&gt; + &lt;strong&gt;Expression Eval来&lt;/strong&gt;解决！这样一来，再来新的需求只需要写在db里插入俩表达式就可以了，20个需求提过来也不用怕。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你的老板微笑着点了点头，看了一眼自己手上的劳力士，有意无意的晃了晃，说：小伙子很上道，自己也琢磨出解法了，赶紧设计方案，争取本周上线，尽快拿到业务结果，到时候升职加薪少不了你的！&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实现方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个系统的核心需求有两点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据提取&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;规则判断&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据提取即ETL，把mq的msg中关键信息提取出来，提取之后可能还需要简单处理一下(比如msg中事件时间是timestamp，你想转化为RFC3339格式) ，这里可以用JPATH 做数据提取 (如果你写过爬虫，一定知道用xpath去提取HTML中的node消息，jpath就是json数据的提取规则)。配置一个ETL rule，如图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.38917525773195877&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR9Ct85IUoD4jW0aicGeicJVtLzqUc9akicgbQ1OFibse5e31kG40pNo832CiaVfCIpjzgiaw95bFPWTBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1552&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后是数据规则判断，即题目中提到的规则引擎，我们这里使用 开源库govaluate，比如上面拼车完单的例子，我们可以配置这样的规则：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cc == &lt;span&gt;1&lt;/span&gt; ? ( in(&lt;span&gt;4&lt;/span&gt;, ee)? &lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt; ) : ( ff ==&lt;span&gt;4&lt;/span&gt; ? &lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;govaluate会把这个表达式构建出一颗ast，然后输入参数进行求值(是不是回忆起来了编译原理？)。接下来让我们研究一下这个库~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;govaluate介绍与使用注意&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;govaluate支持对C风格的算数/字符串的表达式进行求值。比如这些例子(例子来源于&lt;code&gt;evaluation_test.go&lt;/code&gt;):&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1. 100 ^ (23 * (2 | 5))&lt;br/&gt;2. 5 &amp;lt; 10 &amp;amp;&amp;amp; 1 &amp;lt; 5&lt;br/&gt;3. (foo == &lt;span&gt;true&lt;/span&gt;) || (bar == &lt;span&gt;true&lt;/span&gt;) // foo、bar为变量&lt;br/&gt;4. theft &amp;amp;&amp;amp; period == 24 ? 60     // theft、period为变量&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个库几乎支持你能想象到的任何表达式，有兴趣可以去这个test文件。除此之外它支持拓展UDF， 你可以自己写一些函数支持你的定制业务逻辑，它还支持执行类方法，更多信息可以看README。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们需要使用它时，只需要这几行代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;expression, err := govaluate.NewEvaluableExpression(&lt;span&gt;&quot;foo &amp;gt; 0&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;parameters := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;interface&lt;/span&gt;{}, &lt;span&gt;8&lt;/span&gt;)&lt;br/&gt;parameters[&lt;span&gt;&quot;foo&quot;&lt;/span&gt;] = &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;result, err := expression.Evaluate(parameters);&lt;br/&gt;&lt;span&gt;// result is now set to &quot;false&quot;, the bool value.&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这个demo我们可以看到它的api被设计成了两步， 第一步&lt;strong&gt;NewEvaluableExpression&lt;/strong&gt;的功能主要是把表达式拓展为一颗AST，&lt;strong&gt;Evaluate&lt;/strong&gt;的主要功能是把用户参数填入ast求值。。举个例子：比如&lt;code&gt;1 + foo + 4 * boo&lt;/code&gt;这个表达式，在两个阶段分别做的事情是这样：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4743083003952569&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR9Ct85IUoD4jW0aicGeicJViaTrpK0mHXiaEqJRfGYM6LQBgELYEjdIOaB4OBF17m2Luw8clkia7wib5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1518&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6153846153846154&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR9Ct85IUoD4jW0aicGeicJVQ47mBDJ15xPpZBLoaVlErkDZgZWS18sShbA8HY3ocnMheZLmCiaD8KA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1456&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么生产项目代码中直接把这两步抄进去就可以了吗？显然不是。通过观察就可以发现， 第一步构造ast依赖的表达式其实是可以预先确定的，且表达式一般不会变化，没有必要用户每次传一个api就构造一颗ast然后求值。可以把表达式存入db，在项目启动or更新配置时加载到内存中， 比如搞一个&lt;code&gt;map[string]*EvaluableExpression&lt;/code&gt;, 把不同表达式的ast进行cache，这样用户每次请求时只需遍历ast进行求值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;预编译所带来的收益很显著，尤其是在你表达式比较复杂的情况下。我对&lt;code&gt;foo &amp;gt; 2? 1:0&lt;/code&gt;这个表达式分别做了现编译和预编译的benchmark，结果如下：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;现编译&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5235404896421846&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR9Ct85IUoD4jW0aicGeicJVBmgEDSBEUcmdquNUTQY1icbiatlz2hb3qLjrqpsIGomzYEh3fuicicibK8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2124&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(现编译 构建ast占用62.3%的cpu开销，而eval只占2%)&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;预编译&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.25850965961361544&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR9Ct85IUoD4jW0aicGeicJVurkaBVl2OZia4oWZFplicCuQgYibgCgYAB2fESplOm1fY6Yq7xKsnKMZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2174&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(预编译省掉了构建ast的成本，节约了大量cpu资源) &lt;span&gt;建议大&lt;/span&gt;&lt;span&gt;家如果使用这个库，有条件要用预编译版本。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;govaluate 原理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看起来govaluate很有意思， 接下来让我们挖一下它的源码。首先来看第一阶段，把表达式拓展为AST时的逻辑，我简单画了一张图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3270321361058601&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR9Ct85IUoD4jW0aicGeicJVPWYf6YphgOuqBfLlcPFw1N6bKjlfib5LZ0GMudopibibAyavS6BaV9eYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2116&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面以&lt;code&gt;1 + foo + 4 * boo&lt;/code&gt;为例，&lt;strong&gt;parserToken&lt;/strong&gt;后，我们可以得到一堆token:&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6916376306620209&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR9Ct85IUoD4jW0aicGeicJVWVpWX2KssfbBMLBpDMMQNUR9b3TRZibXVTQc0OuUhJ45oSiaBia15Dq6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1148&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;checkBalance&lt;/strong&gt;没啥好说的，核心功能就看小括号是否成对出现：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5913312693498453&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR9Ct85IUoD4jW0aicGeicJViavNCicMTqhBuDiatVrAys0omkQnJWE5ARKY0HrDsZPNAcxGLloFK8sjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;646&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而&lt;strong&gt;checkExpressionSyntax&lt;/strong&gt;阶段主要是check token之间是否符合预设规则，核心是这个函数：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.34539473684210525&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR9Ct85IUoD4jW0aicGeicJVtgibKaazibATy4A9TAxq5oPgzWvCqNK45OmxzyPD3drsTRLHCOVDGV2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1216&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个函数会check当前的token是否是上一个token的合法值，合法值是预设的，比如NUMERIC的合法值是后面这些：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8816425120772947&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR9Ct85IUoD4jW0aicGeicJVsict9CppqvyWZ0skSKzmiaPFM7HXEGicOicCuplx4zaI5yVVgmVphlfic1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来的 &lt;strong&gt;optimizeTokens&lt;/strong&gt; 函数没啥好说的，主要就是编译一下正则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比较有意思的是&lt;strong&gt;planStages&lt;/strong&gt;这个步骤。&lt;strong&gt;planStages&lt;/strong&gt;这个大步骤内部大概分成了planTokens、reorderStages、elideLiterals这三个小步骤，下面来一一介绍：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2201834862385321&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR9Ct85IUoD4jW0aicGeicJVRdBQjRfibKJTYjOz4AgyZVUKhj81uL3GcPryszIZ4BySTYbkOicbot3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;872&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;planTokens&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个函数写的让我大开眼界，首先它用func做不同运算符的优先级计算，原理是func接收struct作为参数，而参数中的next为这个函数连接的下一个优先级的func。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2540880503144654&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR9Ct85IUoD4jW0aicGeicJV2T1JicV3Vh6so8Y3xVgZRXAe8ZCX0b8qWibkgQuz1Za1bD7jEYQOJTJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1590&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个func优先级打印出来是这样的：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3244274809160305&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR9Ct85IUoD4jW0aicGeicJV17VVTWv4icTGWnn3dzuibk8LM33xVIQeWMeLtnicGj6SgzoLnLia1YwjMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1572&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了运算符优先级之后，对于具体的节点，会继续看节点类型，比如是func，accesser还是valueType，valueType的节点对于不同的详细类型也有不同策略，比如数字节点会构建一个Node，而小括号节点会直接parser下一个token来构建优先级更高的树。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于不同的运算符，在这个函数链上会下沉构建出优先级比较高的节点，保证符合数学计算的规律。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;reorderStages&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里主要把ast重排序，让ast由普通tree变成avl tree，树旋转的代码写的特别骚气，比如&lt;code&gt;1 + foo + 4 * boo&lt;/code&gt; 这个表达式，planToken执行完后，会变成这样一颗树：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0653753026634383&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR9Ct85IUoD4jW0aicGeicJVJOVlURLoZfVh4sicdItpJ5IdFEe38N1VMe2icjxt2oLdvYXdmbUeSOzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;826&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重排序的过程是把相同优先级的节点进行旋转，第一步是交换左右节点：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5721518987341773&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR9Ct85IUoD4jW0aicGeicJVvrdKuDK3hz1aibicOYtxy8C9ZibryNJ3oGDbzmoTeEIyj3cRakRuwdicdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1580&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步是LL左旋：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5102564102564102&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR9Ct85IUoD4jW0aicGeicJV1VFuKKcBNzI6LZlR0zCO9ericmh7nQaicIg7ficszQibV3zLBCWHiaibVsBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1560&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就平衡了，一个非常骚气的算法。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;elideLiterals&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个步骤是看叶子节点是否为&lt;code&gt;LITERAL&lt;/code&gt;，比如这棵树：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7185929648241206&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR9Ct85IUoD4jW0aicGeicJVXPA8iaJ3DDgKPSd0UXLliatRdtWLZaXRKDfN99yOybdNGkRYcg2bIYnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;796&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个阶段，各个子节点会进行dfs计算直接变成：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7753623188405797&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR9Ct85IUoD4jW0aicGeicJVqHBP0nHmszp7FEdpt3A9jYkfETxmexCL87V5Y31BerIVfzkltyU6cQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;276&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此第一阶段的逻辑梳理完毕。而第二个阶段&lt;strong&gt;Evaluate&lt;/strong&gt;的主要功能是把用户参数填入ast，进行求值。这个过程比较简单，本文不在赘述。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;govaluate 不足&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;govaluate 看起来很美好，真的是这样吗？其实不然，这个项目最后一次commit是2017年，距今已经6年了。我们在使用期间也发现了很多小bug和代码优美度欠缺的地方。下面来简单列举几个：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;弱类型&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;govaluate所有数字类型都是被解析为float64进行计算的，这么玩写代码爽了，但是当你用&lt;code&gt;1+2+9&lt;/code&gt;做表达式时，可能会得到一个类型为fload64的interface{}结果。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08793103448275862&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR9Ct85IUoD4jW0aicGeicJVKjs28yHVsKeuI3uHM26TzQerJ4z239ibnsy7RbgicFoFBMt2DNCItn1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1160&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;函数限制&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;govaluate的函数有的返回值无法继续做运算。比如这个case：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5785340314136126&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR9Ct85IUoD4jW0aicGeicJVBPKG5Zqib9gzWFGYXlKaEo9YmeM09h9J1m9u8CtyzibLxG208tKdyaTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1528&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看起来没有任何问题，但是执行会报错：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.042416452442159386&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR9Ct85IUoD4jW0aicGeicJVAW4fbHuadR8PCdWyntnunjupgdjP8kHlECcm4TMRGXvtr1UMX7XVBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1556&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;参数会去除转义符&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如这段代码：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.23166023166023167&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR9Ct85IUoD4jW0aicGeicJVb78dAme4YlVPnvXpoW5aNRxIL2lrQIic8PAdMib9zelN3AGW5tC2ZXUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1554&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理论上结果应该含有转义符，实际上结果是:&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.10996563573883161&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR9Ct85IUoD4jW0aicGeicJVIukrf7ydrVpF4SW97teCcRDl23V8ibI1q15MGVUlPqecXUNCYKIY5Jw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1164&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上是这段代码搞的鬼，代码比较简单，就不解释了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.33509234828496043&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR9Ct85IUoD4jW0aicGeicJVqOWSWZxkuozM9uIaDbtgicx7WaIzvRMOynjRE20u3ibGS6PVZANNe3Ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1516&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;奇奇怪怪的代码&lt;span/&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;this关键字：这个就不举例子了，这个库里所有方法的接收者都是this，被官方建议熏陶过的我，看的我着实蛋疼...&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;双重否定表肯定：token解析阶段有这样的代码，不知道作者为啥要搞个双重否定，我的话，会用一个&lt;code&gt;isQuote&lt;/code&gt;代替。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.12251655629139073&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IR9Ct85IUoD4jW0aicGeicJVlenic8mFQf9y5c8J2IQ9koKQoo3GTnmMNKwSBbQvEGsOoBySMHic0mxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1208&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;govaluate改进&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为一个17年后就没更新过的项目， 也不知道作者还会不会维护。业务发展是不等人，govaluate对于我们服务来说并不能满足需求，很多时候用起来比较别扭，所以我基于我们的场景对于govaluate做了一些定制改造。我个人还是非常喜欢这个库的，于是把代码fork了一份，加了个eplus后缀，改造了上面那几个匪夷所思的问题。并加了个比较定制化的feature：type promotion。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个听起来比较唬人， 其实就是支持更弱类型的表达式运算，比如我的库支持：&#x27;2&#x27; -1, &#x27;4&#x27; * 3，要支持这种功能，核心需要改两种地方：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一种地方是typeCheck。比如subStage会check两个字节点必须是float64类型， 我们要支持string operator num， 可以把typeCheck扩大为可以是chek node是否为 floatOrStr。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二种地方是OpeatorOperate。前面我们把String类型也放进来让它支持计算了，但是在go里str和float终究是无法计算的， 所以到了计算阶段需要做一个type promotion，即把string类型转化为数字类型之后再计算。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结与反思&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;govaluate在我心中还是有一些不完美的地方，我们这里用它也是因为项目初期就引入了这个库，在大量的线上用例使用后要迁移这个库成本巨大， 对于用的不爽的地方只能改了。如果读者朋友有需求， 可以看一下市面上其他的表达式开源库， 比如gval。当然，如果你的场景比较复杂， 需要很多if else 或者for循环，那简单的规则引擎可能满足不了你的需求，此时可以考虑内嵌个更完整的脚本库或者嵌入lua， 不过这样就更复杂了， 慎重考虑把这样的东西直接放在db里面， 后期不好维护。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;反思&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;govaluate这个库对我有很多启发，最主要就是表达式的预编译可以节省大量CPU开销，组内某个项目目前的运行方式是随着请求现编译，构建执行计划dag图，理论上如果能预编译，请求到来只是对于对应param访问存储，可以节省大量CPU开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跳脱出govaluate本身，我们系统选择JPATH + Expr做数据提取和条件描述做需求，本质上是因为这边的mq数据是JSON格式，JSON有一定的局限性，描述数据没啥问题，但是描述条件就比较困难了，理论上如果用XML这种技能描述条件，又能描述数据的交互形式，那我们可能会构建一个完全不同的系统。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后稍微打个广告吧， 如果你也想使用govaluate，又有一些定制化的需求，欢迎star我的库然后提个issue， 我想试着维护一个开源库， 嘿嘿。&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欢迎加入 &lt;strong&gt;随波逐流的薯条&lt;/strong&gt; 微信群。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;薯条目前有草帽群、木叶群、琦玉群，群交流内容不限于技术、投资、趣闻分享等话题。欢迎感兴趣的同学入群交流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;入群请加薯条的个人微信：709834997。并备注：加入薯条微信群。&lt;/p&gt;&lt;p&gt;欢迎关注我的公众号~&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c23d048cdaa3a668d501f399e25bacf1</guid>
<title>[推荐] 再见了 VMware，一款更轻量级的虚拟机！</title>
<link>https://toutiao.io/k/xw2lnva</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;pre&gt;&lt;section class=&quot;js_darkmode__1&quot;&gt;&lt;span&gt;公众号关注&lt;/span&gt;&lt;span&gt; “GitHubDaily”&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;设为 “&lt;/span&gt;&lt;span&gt;星标&lt;/span&gt;&lt;span&gt;”，每天带你逛 GitHub！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcs8C07b1Ih2doNmiaicSttMccejE1onYNcszau24r6lIzHr6Fib3XlicibHcg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;大家好，我是小 G。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最近，打算在 &lt;/span&gt;&lt;strong&gt;Mac&lt;/strong&gt;&lt;span&gt; 电脑上安装一个虚拟机，用来学习 &lt;/span&gt;&lt;strong&gt;K8S&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;首先想到的是 &lt;strong&gt;Vmware&lt;/strong&gt; 和 &lt;strong&gt;Parallels Desktop&lt;/strong&gt;，然后打开浏览器找了找，发现都只提供付费版本，只有 &lt;strong&gt;Parallels Desktop&lt;/strong&gt; 提供了 &lt;strong&gt;14&lt;/strong&gt; 天的免费试用。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcsCKOCmkQFvjvr9uqCL45fUVicA4uFf5iaNiaicY6kcTXK9rxfOWicwicWwh4Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot; title=&quot;无法白嫖&quot;/&gt;&lt;figcaption&gt;无法白嫖&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;然后，开始尝试使用免费 &lt;strong&gt;VirtualBox&lt;/strong&gt;，但是在安装 &lt;strong&gt;CentOS&lt;/strong&gt; 的时候，貌似因为 &lt;strong&gt;MacOS&lt;/strong&gt; 最新版本的原因，总是报错，花费了好几天的时间，试过各种方案，最终解决无果，就放弃了。。&lt;/p&gt;&lt;p&gt;就在陌溪要放弃的时候，突然在 &lt;strong&gt;Ubuntu&lt;/strong&gt; 官网进行冲浪的时候，发现了一款叫 &lt;strong&gt;Multipass&lt;/strong&gt; 的东西。&lt;/p&gt;&lt;p&gt;它可以快速在电脑上快速搭建一个轻量级的虚拟机，并且相比于 &lt;strong&gt;Vmware&lt;/strong&gt; 更加轻量，只需一行命令快速创建 &lt;strong&gt;Ubuntu&lt;/strong&gt; 虚拟机。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Multipass&lt;/strong&gt; 是一个轻量虚拟机管理器，是由 &lt;strong&gt;Ubuntu&lt;/strong&gt; 运营公司 &lt;strong&gt;Canonical&lt;/strong&gt; 所推出的开源项目。运行环境支持 &lt;strong&gt;Linux&lt;/strong&gt;、&lt;strong&gt;Windows&lt;/strong&gt;、&lt;strong&gt;macOS&lt;/strong&gt;。在不同的操作系统上，使用的是不同的虚拟化技术。在 &lt;strong&gt;Linux&lt;/strong&gt; 上使用的是 &lt;strong&gt;KVM&lt;/strong&gt;、&lt;strong&gt;Window&lt;/strong&gt; 上使用 &lt;strong&gt;Hyper-V&lt;/strong&gt;、&lt;strong&gt;macOS&lt;/strong&gt; 中使用 &lt;strong&gt;HyperKit&lt;/strong&gt; 以最小开销运行VM，支持在笔记本模拟小型云。&lt;/p&gt;&lt;p&gt;同时，&lt;strong&gt;Multipass&lt;/strong&gt; 提供了一个命令行界面来启动和管理 &lt;strong&gt;Linux&lt;/strong&gt; 实例。下载一个全新的镜像需要几秒钟的时间，并且在几分钟内就可以启动并运行 &lt;strong&gt;VM&lt;/strong&gt;。（直呼好家伙，大大降低的我们安装虚拟机的成本了）&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Multipass官网：https://multipass.run/&lt;/p&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5435185185185185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcsQ45NQiaofsON9YRJTedbwFRuqjGRIxDJ3icaxa7jicJRXoxrI4iapRSyGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;Multipass官网&quot;/&gt;&lt;figcaption&gt;Multipass官网&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;span&gt;开始使用&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;在使用 &lt;strong&gt;Multipass&lt;/strong&gt; 之前 ，首先需要安装 &lt;strong&gt;Multipass&lt;/strong&gt; 工具，可以打开官网进行下载&lt;/p&gt;&lt;pre&gt;&lt;code&gt;https:&lt;span&gt;//multipass.run/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;选择对应的操作系统，因为我的是 &lt;strong&gt;Mac&lt;/strong&gt; 电脑，所以选择 MacOS，点击 &lt;strong&gt;Download&lt;/strong&gt; 开始下载&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36018518518518516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcsw2biaGewZU8V4TKK2tE67EnX91WqwFBhLu1lbMewrialrl419NIdwfIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;image-20211120120019913&quot;/&gt;&lt;figcaption&gt;选择对应版本安装&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;如果电脑装了 &lt;strong&gt;brew&lt;/strong&gt; 可以直接命令行下载安装:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;brew&lt;/span&gt; cask install multipass&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下载安装成功后, 执行以下命令可以查看当前软件版本:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; --version&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装成功后，点击运行，即可打开 &lt;strong&gt;Multipass&lt;/strong&gt; 客户端，这里能够快速的通过 &lt;strong&gt;Open Shell&lt;/strong&gt; 创建和启动一个虚拟机&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7735849056603774&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcs8hqCKQmRFhia7ic3pgBhtL2gd9M55Rf0Gib3icFE6YeqZ28P2b7hiaNyf5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;424&quot; title=&quot;Multipass客户端&quot;/&gt;&lt;figcaption&gt;Multipass客户端&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;下面，我们来介绍如何通过命令的方式，创建一台虚拟机&lt;/p&gt;&lt;h2&gt;&lt;span&gt;创建Ubuntu虚拟机&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;首先，通过以下指令查看可供下载的 &lt;strong&gt;Ubuntu&lt;/strong&gt; 镜像&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; find&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行成功后，可以看到下面的这些镜像列表，包含各种版本的&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;Image&lt;/span&gt;                       &lt;span&gt;Aliases&lt;/span&gt;           &lt;span&gt;Version&lt;/span&gt;          &lt;span&gt;Description&lt;/span&gt;&lt;br/&gt;&lt;span&gt;core&lt;/span&gt;                        &lt;span&gt;core16&lt;/span&gt;            20200818         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;Core&lt;/span&gt; 16&lt;br/&gt;&lt;span&gt;core18&lt;/span&gt;                                        20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;Core&lt;/span&gt; 18&lt;br/&gt;18&lt;span&gt;.04&lt;/span&gt;                       &lt;span&gt;bionic&lt;/span&gt;            20211109         &lt;span&gt;Ubuntu&lt;/span&gt; 18&lt;span&gt;.04&lt;/span&gt; &lt;span&gt;LTS&lt;/span&gt;&lt;br/&gt;20&lt;span&gt;.04&lt;/span&gt;                       &lt;span&gt;focal&lt;/span&gt;,&lt;span&gt;lts&lt;/span&gt;         20211118         &lt;span&gt;Ubuntu&lt;/span&gt; 20&lt;span&gt;.04&lt;/span&gt; &lt;span&gt;LTS&lt;/span&gt;&lt;br/&gt;21&lt;span&gt;.04&lt;/span&gt;                       &lt;span&gt;hirsute&lt;/span&gt;           20211119         &lt;span&gt;Ubuntu&lt;/span&gt; 21&lt;span&gt;.04&lt;/span&gt;&lt;br/&gt;21&lt;span&gt;.10&lt;/span&gt;                       &lt;span&gt;impish&lt;/span&gt;            20211103         &lt;span&gt;Ubuntu&lt;/span&gt; 21&lt;span&gt;.10&lt;/span&gt;&lt;br/&gt;&lt;span&gt;appliance&lt;/span&gt;&lt;span&gt;:adguard-home&lt;/span&gt;                        20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;AdGuard&lt;/span&gt; &lt;span&gt;Home&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;appliance&lt;/span&gt;&lt;span&gt;:mosquitto&lt;/span&gt;                           20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;Mosquitto&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;appliance&lt;/span&gt;&lt;span&gt;:nextcloud&lt;/span&gt;                           20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;Nextcloud&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;appliance&lt;/span&gt;&lt;span&gt;:openhab&lt;/span&gt;                             20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;openHAB&lt;/span&gt; &lt;span&gt;Home&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;appliance&lt;/span&gt;&lt;span&gt;:plexmediaserver&lt;/span&gt;                     20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;Plex&lt;/span&gt; &lt;span&gt;Media&lt;/span&gt; &lt;span&gt;Server&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;anbox-cloud-appliance&lt;/span&gt;                         &lt;span&gt;latest&lt;/span&gt;           &lt;span&gt;Anbox&lt;/span&gt; &lt;span&gt;Cloud&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;minikube&lt;/span&gt;                                      &lt;span&gt;latest&lt;/span&gt;           &lt;span&gt;minikube&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; &lt;span&gt;Kubernetes&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下载最新版的 &lt;strong&gt;Ubuntu&lt;/strong&gt; 镜像并运行，初次创建时需要下载 &lt;strong&gt;Ubuntu&lt;/strong&gt; 镜像，网络畅通的情况下，稍等片刻即可。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; launch -n vm01 -c &lt;span&gt;1&lt;/span&gt; -m &lt;span&gt;1G&lt;/span&gt; -d &lt;span&gt;10G&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;自定义配置创建可以参考如下方式:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;-n, --name: 名称&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-c, --cpus: cpu核心数, 默认: 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-m, --mem: 内存大小, 默认: 1G&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-d, --disk: 硬盘大小, 默认: 5G&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;操作虚拟机&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;查看虚拟机列表&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;虚拟机创建完成后，可以使用 &lt;strong&gt;multipass list&lt;/strong&gt; 命令进行查看虚拟机列表&lt;/p&gt;&lt;pre&gt;&lt;code&gt;% &lt;span&gt;multipass&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Name&lt;/span&gt;                    &lt;span&gt;State&lt;/span&gt;             &lt;span&gt;IPv4&lt;/span&gt;             &lt;span&gt;Image&lt;/span&gt;&lt;br/&gt;&lt;span&gt;vm01&lt;/span&gt;                    &lt;span&gt;Running&lt;/span&gt;           192&lt;span&gt;.168.64.2&lt;/span&gt;     &lt;span&gt;Ubuntu&lt;/span&gt; 20&lt;span&gt;.04&lt;/span&gt; &lt;span&gt;LTS&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到目前正在运行一台 &lt;strong&gt;Ubuntu 20.04&lt;/strong&gt; 版本的虚拟机，并且对应的 &lt;strong&gt;IP&lt;/strong&gt; 地址为 &lt;strong&gt;192.168.64.2&lt;/strong&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;外部操作虚拟机&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;通过 &lt;strong&gt;multipass exec&lt;/strong&gt; 命令在实例内执行给定的命令。第一个参数是运行命令的实例，也就是 &lt;strong&gt;vm01&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们通过 &lt;strong&gt;exec&lt;/strong&gt; 命令，就可以在外部操作刚刚创建的虚拟机，例如查看内部所处的目录，执行 &lt;strong&gt;pwd&lt;/strong&gt; 命令&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; multipass &lt;span&gt;exec&lt;/span&gt; vm01 &lt;span&gt;pwd&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;/home/ubuntu&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;查看虚拟机信息&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;通过 &lt;strong&gt;multipass info&lt;/strong&gt; 命令，即可查看当前运行的虚拟机信息&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# &lt;span&gt;multipass&lt;/span&gt; &lt;span&gt;info&lt;/span&gt; &lt;span&gt;vm01&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Name&lt;/span&gt;:           &lt;span&gt;vm01&lt;/span&gt;&lt;br/&gt;&lt;span&gt;State&lt;/span&gt;:          &lt;span&gt;Running&lt;/span&gt;&lt;br/&gt;&lt;span&gt;IPv4&lt;/span&gt;:           192&lt;span&gt;.168.64.2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Release&lt;/span&gt;:        &lt;span&gt;Ubuntu&lt;/span&gt; 20&lt;span&gt;.04.3&lt;/span&gt; &lt;span&gt;LTS&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Image&lt;/span&gt; &lt;span&gt;hash&lt;/span&gt;:     91740&lt;span&gt;d72ffff&lt;/span&gt; (&lt;span&gt;Ubuntu&lt;/span&gt; 20&lt;span&gt;.04&lt;/span&gt; &lt;span&gt;LTS&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;Load&lt;/span&gt;:           0&lt;span&gt;.00&lt;/span&gt; 0&lt;span&gt;.00&lt;/span&gt; 0&lt;span&gt;.00&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Disk&lt;/span&gt; &lt;span&gt;usage&lt;/span&gt;:     1&lt;span&gt;.3G&lt;/span&gt; &lt;span&gt;out&lt;/span&gt; &lt;span&gt;of&lt;/span&gt; 9&lt;span&gt;.5G&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Memory&lt;/span&gt; &lt;span&gt;usage&lt;/span&gt;:   170&lt;span&gt;.9M&lt;/span&gt; &lt;span&gt;out&lt;/span&gt; &lt;span&gt;of&lt;/span&gt; 1&lt;span&gt;.9G&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Mounts&lt;/span&gt;:         &lt;span&gt;--&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;进入虚拟机&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;通过 &lt;strong&gt;multipass shell&lt;/strong&gt; 命令，即可进入到虚拟机内部&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; shell vm01&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行后的结果如下所示，可以看到目前虚拟机的一些系统配置信息，以及内存和磁盘的使用情况&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7129629629629629&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcskVp6KUe7Mm9HbLT6dmUhJzpnabyPt7rKHAbulLKO6ib1UUMNrsN0xXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;image-20211121085114961&quot;/&gt;&lt;figcaption&gt;进入虚拟机内部&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;同时会运行一个新的 &lt;strong&gt;Ubuntu&lt;/strong&gt; 系统，此时便进入到了&lt;strong&gt;Ubuntu&lt;/strong&gt; 环境中, 在里面可以执行相关的 &lt;strong&gt;linux&lt;/strong&gt; 指令&lt;/p&gt;&lt;p&gt;当然如果不想进入系统内部，也可以通过上述提到的 &lt;strong&gt;multipass exce&lt;/strong&gt; 命令，来操作 &lt;strong&gt;Ubuntu&lt;/strong&gt; 系统&lt;/p&gt;&lt;p&gt;首先执行下面命令，给系统设置一个 &lt;strong&gt;root&lt;/strong&gt; 密码，设置好密码后，使用 &lt;strong&gt;su root&lt;/strong&gt; 切换到 &lt;strong&gt;root&lt;/strong&gt; 用户&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 设置密码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;sudo&lt;/span&gt; passwd&lt;br/&gt;&lt;span&gt;# 切换 root&lt;/span&gt;&lt;br/&gt;su root&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;ubuntu&lt;/strong&gt; 是使用 &lt;strong&gt;apt-get&lt;/strong&gt; 来进行包管理的，首先更新一下 &lt;strong&gt;apt-get&lt;/strong&gt;，然后安装 &lt;strong&gt;nginx&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 更新apt&lt;/span&gt;&lt;br/&gt;apt-get &lt;span&gt;update&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 安装 nginx&lt;/span&gt;&lt;br/&gt;apt-&lt;span&gt;get&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; nginx&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装好 &lt;strong&gt;nginx&lt;/strong&gt; 后，可以到 /etc/nginx 目录即可看到刚刚的 &lt;strong&gt;nginx&lt;/strong&gt; 配置信息&lt;/p&gt;&lt;pre&gt;&lt;code&gt;root@vm01&lt;span&gt;:/lost+found&lt;/span&gt;&lt;span&gt;# cd /etc/nginx/&lt;/span&gt;&lt;br/&gt;root@vm01&lt;span&gt;:/etc/nginx&lt;/span&gt;&lt;span&gt;# ls&lt;/span&gt;&lt;br/&gt;conf.d        fastcgi_params  koi-win     modules-available  nginx.conf    scgi_params      sites-enabled  uwsgi_params&lt;br/&gt;fastcgi.conf  koi-utf         mime.types  modules-enabled    proxy_params  sites-available  snippets       win-utf&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面我们可以测试一下，&lt;strong&gt;nginx&lt;/strong&gt; 是否安装成功，在 &lt;strong&gt;mac&lt;/strong&gt; 上打开浏览器，输入虚拟机的 &lt;strong&gt;ip&lt;/strong&gt; 地址 &lt;strong&gt;192.168.64.2&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2759259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcsUBdjGbOeCEodmicmTpQIYIe9oBNlhExhKudlB5HqryPI1YeAa5UKvGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;image-20211121094727506&quot;/&gt;&lt;figcaption&gt;nginx安装成功&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;可以看出，目前 &lt;strong&gt;nginx&lt;/strong&gt; 已经成功运行了，后续的话，可能会考虑在上面部署更多的应用，感兴趣的小伙伴欢迎关注～&lt;/p&gt;&lt;h3&gt;&lt;span&gt;挂载数据卷&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;multipass&lt;/strong&gt; 还提供和 &lt;strong&gt;Docker&lt;/strong&gt; 一样的挂载数据卷的功能，能够与外部宿主机的文件保持同步。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 挂载格式&lt;/span&gt;&lt;br/&gt;&lt;span&gt;multipass&lt;/span&gt; mount 宿主机目录  实例名:虚拟机目录&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面，我在用户的目录下，创建一个 &lt;strong&gt;hello&lt;/strong&gt; 目录&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 创建hello目录&lt;/span&gt;&lt;br/&gt;&lt;span&gt;mkdir&lt;/span&gt; hello&lt;br/&gt;&lt;span&gt;# 挂载&lt;/span&gt;&lt;br/&gt;multipass mount /Users/moxi/hello  vm01:/hello&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;挂载完成后，我们回到实例 vm01 中，可以看出多了一个 &lt;strong&gt;hello&lt;/strong&gt; 文件夹，说明已经成功挂载～&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18181818181818182&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcsWKnic6p04c1vu5iaTib7bziaz2iaZwXCZutNm18U6wng3t7ljIBUldLHiayA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;528&quot; title=&quot;image-20211121110217283&quot;/&gt;&lt;figcaption&gt;挂载成功&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;因此，以后在 &lt;strong&gt;vm01&lt;/strong&gt; 的 &lt;strong&gt;hello文件夹&lt;/strong&gt; 中创建的文件，都会在的宿主机的 &lt;strong&gt;hello 文件夹&lt;/strong&gt;同步显示&lt;/p&gt;&lt;h3&gt;&lt;span&gt;卸载数据卷&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;如果以后不需要用到挂载了，可以使用 &lt;strong&gt;unmount&lt;/strong&gt; 命令卸载&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#卸载数据卷&lt;/span&gt;&lt;br/&gt;&lt;span&gt;multipass&lt;/span&gt; umount 容器名&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;传输文件&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;除了使用上述的 &lt;strong&gt;mount&lt;/strong&gt; 挂载卷的方式实现文件的交互，同时还可以通过 transfer 命令，将宿主机的文件，发送到虚拟机内部&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; transfer 主机文件 容器名:容器目录&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如，将 &lt;strong&gt;hello.txt&lt;/strong&gt; 发送到&lt;/p&gt;&lt;pre&gt;&lt;code&gt;multipass transfer hello.txt vm01:&lt;span&gt;/home/ubuntu/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;删除和释放实例&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;使用下面的命令，可以开启、停止、删除和释放实例&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 启动实例&lt;/span&gt;&lt;br/&gt;multipass &lt;span&gt;start&lt;/span&gt; vm01&lt;br/&gt;&lt;span&gt;# 停止实例&lt;/span&gt;&lt;br/&gt;multipass &lt;span&gt;stop&lt;/span&gt; vm01&lt;br/&gt;&lt;span&gt;# 删除实例（删除后，还会存在）&lt;/span&gt;&lt;br/&gt;multipass &lt;span&gt;delete&lt;/span&gt; vm01&lt;br/&gt;&lt;span&gt;# 释放实例（彻底删除）&lt;/span&gt;&lt;br/&gt;multipass &lt;span&gt;purge&lt;/span&gt; vm01&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;容器配置自动化&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;为了保持开发环境和线上环境一致性 同时节省部署时间 &lt;strong&gt;multipass&lt;/strong&gt; 给我们提供了 &lt;strong&gt;--cloud-init&lt;/strong&gt; 选项进行容器启动初始化配置:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; &lt;span&gt;launch&lt;/span&gt; &lt;span&gt;--name&lt;/span&gt; &lt;span&gt;ubuntu&lt;/span&gt; &lt;span&gt;--cloud-init&lt;/span&gt; &lt;span&gt;config&lt;/span&gt;&lt;span&gt;.yaml&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面 &lt;strong&gt;config.yaml&lt;/strong&gt; 则是容器的初始化配置文件，例如，我们想在初始化容器的时候，自动下载安装 &lt;strong&gt;Node.js&lt;/strong&gt;，内容如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#cloud-config&lt;/span&gt;&lt;br/&gt;runcmd:&lt;br/&gt;  - curl -sL https:&lt;span&gt;//deb.nodesource.com/setup_12.x | sudo -E bash -&lt;/span&gt;&lt;br/&gt;  - sudo apt-&lt;span&gt;get&lt;/span&gt; install -y nodejs&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;runcmd&lt;/code&gt; 可以指定容器 &lt;strong&gt;首次启动&lt;/strong&gt; 时运行的命令&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;凡是用户自定义的cloud-init的配置文件,必须以#cloud-config开头，这是cloud-init识别它的方式。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;yaml&lt;/strong&gt; 配置文件可以参考下面的文章&lt;/p&gt;&lt;pre&gt;&lt;code&gt;https://cloudinit.readthedocs.io/en/latest/topics/examples.html?highlight=&lt;span&gt;lock&lt;/span&gt;-passwd&lt;span&gt;#including-users-and-groups&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更多关于 &lt;strong&gt;multipass&lt;/strong&gt; 的高阶的技巧，欢迎访问 &lt;strong&gt;multipass&lt;/strong&gt; 官方文档&lt;/p&gt;&lt;pre&gt;&lt;code&gt;https:&lt;span&gt;//m&lt;/span&gt;ultipass.run&lt;span&gt;/docs/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;好了，本期关于 &lt;strong&gt;Multipass&lt;/strong&gt; 的基础学习就到这里了，感兴趣的小伙伴环境下载自己动手学习呢～&lt;/p&gt;&lt;h2&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;使用了一阵子后，&lt;strong&gt;Multipass&lt;/strong&gt; 在使用起来很简洁直观，在整体操作上和 &lt;strong&gt;docker&lt;/strong&gt; 类似，如果想在自己电脑上快速搭建一个 &lt;strong&gt;Linux&lt;/strong&gt; 系统用于学习的话，选择使用 &lt;strong&gt;Multipass&lt;/strong&gt; 还是非常方便的。&lt;/p&gt;&lt;p&gt;唯一不足的地方就是，&lt;strong&gt;Multipass&lt;/strong&gt; 是由 &lt;strong&gt;Ubuntu&lt;/strong&gt; 背后的 &lt;strong&gt;Canonical&lt;/strong&gt; 公司开发的，因此 &lt;strong&gt;Multipass&lt;/strong&gt; 所使用的镜像也都是 &lt;strong&gt;Ubuntu&lt;/strong&gt; 镜像（这也可以理解，毕竟支持自家的产品），不过对于习惯了使用 &lt;strong&gt;CentOS&lt;/strong&gt; 的用户来说，还是用些许不太习惯。&lt;/p&gt;&lt;p&gt;不过瑕不掩瑜，&lt;strong&gt;Multipass&lt;/strong&gt; 在我看来还是一款非常棒的软件～&lt;/p&gt;&lt;p&gt;另外，它的代码也在 GitHub 开源了，需要进一步研究的小伙伴也可以看下：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;GitHub：https://github.com/canonical/multipass&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAxOTcxNTIwNQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28ia8xsyOClt8NDDCTAZNaDsEic4EEpUG1FPduFr5TUMK1GbDiaFX0qNCJiaS2XPfHzWlFicK95v1a9ic7Vg/0?wx_fmt=png&quot; data-nickname=&quot;GitHubDaily&quot; data-alias=&quot;GitHubDaily&quot; data-signature=&quot;专注于分享 GitHub 上知名的 Python、Java、Web、AI、数据分析等多个领域的优质学习资源、开源项目及开发者工具，为 GitHub 开发者提供优质编程资讯。&quot; data-from=&quot;0&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ed3d9fa7bba99675b1043635ce0d67d2</guid>
<title>[推荐] 网络编程怎么做才算是优雅？</title>
<link>https://toutiao.io/k/zylzzpi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;174&quot; data-backw=&quot;365&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4767123287671233&quot; data-type=&quot;gif&quot; data-w=&quot;365&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/cvQbJDZsKLp6wejHtKTRbqqQyt0wMk9K1wNtuwRqQTJAPOJ1KiaqSeSRbIJRTicVicKpDKRndBodY2DBNN20tvWwA/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原创：小姐姐味道（微信公众号ID：xjjdog），欢迎分享，转载请保留出处。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;据说，web2.0的魅力在于由静态资源变成交互性资源，web3.0的魅力在于其去中心化的资源，大家都可以参与其中得享时代的福利。但是，无论上层概念玩的再花哨，最下层的通信还是基于web1.0所形成的技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的终极目标，其实就是打着去中心化的名义，做实际上的中心化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当流量增加到一定程度，网络编程会发生各种怪异的场景。下面将以十几个实际的案例，来说明xjjdog平常在工作中遇到的与网络相关的高频问题，希望能够助你一臂之力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 大量客户端上线注意躲避&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论你的服务器能力多强，在大批量连接到来，进行业务服务的时候，都会产生瞬时的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，如果你的MQTT服务器连接了几十万台设备。当你的MQTT服务器宕机重启的时候，就要接受几十万的并发，这几乎没有任何服务能够受得了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在xjjdog以往的经验中，因为服务端重启问题而造成的阻塞事故，数不胜数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个场景，其实和缓存的击穿概念非常的相似。当缓存中的热点数据集中失效的时候，请求就会全部击穿到数据库层面，造成问题。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4798807749627422&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1342&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLr2VuKPZxnONlCFrhAIg0Agc6t3LlnbibUrKk6UCDUnCzAfqntNh0mz60QcMVpNHaDPMFfyDp0aj5A/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图，解决缓存击穿问题就是给每个key加个失效时间的随机值，让它们不要在同一时间失效。类似的，我们可以在客户端重连服务端的时候，加上一个随机的时间。随机数是个好东西，它能让我们的海量连接在随机时间窗口内保持类线性的增长。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 多网卡队列&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在类似openstack等虚拟平台上假设的虚拟机，往往因为网卡能力不强而造成流量在达到一定程度之后，服务发生卡顿。这是因为单个cpu在处理中断时，产生了瓶颈。通过dstat或者iftop命令，可以看到当前的网络流量。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4381551362683438&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;954&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLraeg3qV1NqYqicNYpXMukH2HSibZc6bRbZyvIKzHKsczuuwpRuviamELTCT78oUQaUkmZzLnvPXricYQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，Kafka新机器上线之后，会进行大规模的数据拷贝，这个时候如果你去ping相关的机器，会发现ping值变的非常大。同时，&lt;code&gt;Recv-Q&lt;/code&gt;和&lt;code&gt;Send-Q&lt;/code&gt;的值也会增大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候，就需要开启网卡多队列模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;ethtool&lt;/code&gt;可以看到网卡的队列信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ethtool -l eth0 | grep &lt;span&gt;&#x27;Combined&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;Combined: 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，通过下面的命令，可以增加网卡的队列。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ethtool -L eth0 combined 2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建议同时开启中断平衡服务。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;systemctl start irqbalance&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 不定时的切断一下长连接&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果客户端和服务端连接上了，并一直保持连接不关闭对方，那么它就是一条长连接。长连接可以避免频繁的连接创建所产生的开销。从HTTP1到HTTP2再到HTTP3，一直在向减少连接，复用连接方面去努力。通常情况下，长连接是第一选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但有一些特殊情况，我们希望长连接并不要一直在那里保持着，需要给它增加TTL。这种情况通常发生在负载均衡场景里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如LVS、HAProxy等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果后端有A、B、C三台机器，经过LVS负载之后，90条连接被分散到三台机器。但某个时刻，A宕机了，它所持有的30个连接就会被重新负载到B、C上，这时候它们都持有45条连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当A重启之后，它却再也拿不到新的连接。如果LVS运算一次再平衡的话，产生的影响也比较大。所以我们希望创建的长连接能够有一个生存时长的属性，在某个时间间隔内达到渐进式的再平衡。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. k8s端口范围&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了k8s和别的程序不起冲突，默认端口的范围是 30000-32767。如果你在使用k8s平台，配置了nodeport但是无法访问到，要注意是不是设置的端口号太小了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. TIME_WAIT&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TIME_WAIT是主动关闭连接的一方保持的状态，像nginx、爬虫服务器，经常发生大量处于time_wait状态的连接。TCP一般在主动关闭连接后，会等待2MS，然后彻底关闭连接。由于HTTP使用了TCP协议，所以在这些频繁开关连接的服务器上，就积压了非常多的TIME_WAIT状态连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;某些系统通过dmesg可以看到以下信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;__ratelimit: 2170 callbacks suppressed&lt;br/&gt;TCP: time &lt;span&gt;wait&lt;/span&gt; bucket table overflow&lt;br/&gt;TCP: time &lt;span&gt;wait&lt;/span&gt; bucket table overflow&lt;br/&gt;TCP: time &lt;span&gt;wait&lt;/span&gt; bucket table overflow&lt;br/&gt;TCP: time &lt;span&gt;wait&lt;/span&gt; bucket table overflow&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sysctl命令可以设置这些参数，如果想要重启生效的话，加入/etc/sysctl.conf文件中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# 修改阈值&lt;/span&gt;&lt;br/&gt;net.ipv4.tcp_max_tw_buckets = 50000 &lt;br/&gt;&lt;span&gt;# 表示开启TCP连接中TIME-WAIT sockets的快速回收&lt;/span&gt;&lt;br/&gt;net.ipv4.tcp_tw_reuse = 1&lt;br/&gt;&lt;span&gt;#启用timewait 快速回收。这个一定要开启，默认是关闭的。&lt;/span&gt;&lt;br/&gt;net.ipv4.tcp_tw_recycle= 1   &lt;br/&gt;&lt;span&gt;# 修改系統默认的TIMEOUT时间,默认是60s&lt;/span&gt;&lt;br/&gt;net.ipv4.tcp_fin_timeout = 10&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试参数的话，可以使用 sysctl -w net.ipv4.tcp_tw_reuse = 1 这样的命令。如果是写入进文件的，则使用sysctl -p生效。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. CLOSE_WAIT&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CLOSE_WAIT一般是由于对端主动关闭，而我方没有正确处理的原因引起的。说白了，就是程序写的有问题，属于危害比较大的一种。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家都知道TCP的连接是三次握手四次挥手，这是由于TCP连接允许单向关闭。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0374707259953162&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;427&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLraeg3qV1NqYqicNYpXMukH2Hic8Rj6p5VFicDO6n01u1CNMWO3db3SdCibKMqOz8u3yv9wOicoWyS5sPQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图，当一个连接发起主动关闭之后，它将进入fin_wait_1状态。同时，收到fin报文的被动关闭方，进入close_wait状态，然后回复ack后，主动关闭方进入fin_wait_2状态。这就是单向的关闭。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，如果被动关闭方因为某些原因，没有发送fin报文给主动关闭方，那么它就会一直处于close_wait状态。比如，收到了EOF但没有发起close操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然，这多数是一种编程bug，只能通过代码review来解决。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7. 一个进程能够打开的网络连接&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4233576642335766&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;685&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLraeg3qV1NqYqicNYpXMukH2hIibPMZfiaXutYUhHiaqpYdg2bKY24g6Nj96l0KpdV7JUC1041pEO0Aiag/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux即使放开一个端口，能够接受的连接也是海量的。这些连接的上限，受到单进程文件句柄数量和操作系统文件句柄数量的限制，也就是ulimit和file-max。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了能够将参数修改持久化，我们倾向于将改动写入到文件里。进程的文件句柄限制，可以放在&lt;code&gt;/etc/security/limits.conf&lt;/code&gt;中，它的上限受到&lt;code&gt;fs.nr_open&lt;/code&gt;的制约；操作系统的文件句柄限制，可以放到&lt;code&gt;/etc/sysctl.conf&lt;/code&gt;文件中。最后，别忘了在&lt;code&gt;/proc/$id/limits&lt;/code&gt;文件中，确认修改是否对进程生效了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;/etc/security/limits.conf配置案例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;root soft nofile 1000000&lt;br/&gt;root hard nofile 1000000&lt;br/&gt;* soft nofile 1000000&lt;br/&gt;* hard nofile 1000000&lt;br/&gt;es  -  nofile  65535&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8. SO_KEEPALIVE&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果将这个Socket选项打开，客户端Socket每隔段的时间（大约两个小时）就会利用空闲的连接向服务器发送一个数据包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个数据包并没有其它的作用，只是为了检测一下服务器是否仍处于活动状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果服务器未响应这个数据包，在大约11分钟后，客户端Socket再发送一个数据包，如果在12分钟内，服务器还没响应，那么客户端Socket将关闭。如果将Socket选项关闭，客户端Socket在服务器无效的情况下可能会长时间不会关闭。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9. SO_REUSEADDR是为了解决什么问题&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们在网络开发时，时常会碰到&lt;code&gt;address already in use&lt;/code&gt;的异常，这是由于关闭应用程序时，还有对应端口的网络连接处于&lt;code&gt;TIME_WAIT&lt;/code&gt;状态而造成的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TIME_WAIT状态通常会持续一段时间（2ML），设置SO_REUSEADDR可以支持快速端口复用，支持应用的快速重启。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;10. 健康检查采用应用心跳&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;tcp自身的keepalived机制非常的鸡肋，它静悄悄的在底层运行，无法产生应用层的语义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们的想象里，连接就应该是一条线。但其实，它只是2个点，而且每次走的路径都可能不一样。一个点，需要在发出心跳包然后收到回复之后，才能知道对方是否存活。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;tcp自带的心跳机制，仅仅能知道对方是否存活，对于服务是否可用，健康状况这些东西一概不知，而且超时配置常常与超时重传机制相冲突。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，有确切含义的应用层心跳是必要的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;11. SO_LINGER&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个Socket选项可以影响close方法的行为。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在默认情况下，当调用close方法后，将立即返回；如果这时仍然有未被送出的数据包，那么这些数据包将被丢弃。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果将linger参数设为一个正整数n时（n的值最大是65，535），在调用close方法后，将最多被阻塞n秒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这n秒内，系统将尽量将未送出的数据包发送出去；如果超过了n秒，如果还有未发送的数据包，这些数据包将全部被丢弃；而close方法会立即返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果将linger设为0，和关闭SO_LINGER选项的作用是一样的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;12. SO_TIMEOUT&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过这个选项来设置读取数据超时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当输入流的read方法被阻塞时，如果设置timeout（timeout的单位是毫秒），那么系统在等待了timeout毫秒后会抛出一个InterruptedIOException例外。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在抛出例外后，输入流并未关闭，你可以继续通过read方法读取数据。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;13. SO_SNDBUF，SO_RCVBUF&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在默认情况下，输出流的发送缓冲区是8096个字节（8K）。这个值是Java所建议的输出缓冲区的大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这个默认值不能满足要求，可以用setSendBufferSize方法来重新设置缓冲区的大小。但最好不要将输出缓冲区设得太小，否则会导致传输数据过于频繁，从而降低网络传输的效率。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;14. SO_OOBINLINE&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这个Socket选项打开，可以通过Socket类的sendUrgentData方法向服务器发送一个单字节的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个单字节数据并不经过输出缓冲区，而是立即发出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然在客户端并不是使用OutputStream向服务器发送数据，但在服务端程序中这个单字节的数据是和其它的普通数据混在一起的。因此，在服务端程序中并不知道由客户端发过来的数据是由OutputStream还是由sendUrgentData发过来的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;End&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我非常惊讶的发现，现在有些网络环境，依然还是千兆网卡，包括一些比较专业的测试环境。当在这些环境上进行实际的压测时，当流量突破了网卡的限制，应用响应将会变的异常缓慢。计算机系统是一个整体，CPU、内存、网络、IO，任何一环出现瓶颈，都会造成问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式系统中，网络是一个非常重要的因素。但由于它相对来说比较底层，所以大多数开发对其了解较少。加上现在各种云原生组件的流行，接触这些底层设施的机会就越来越少。但如果系统真的发生了问题，在排除掉其他最可能出问题的组件后，千万别忘了--&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有网络这一摊子等着你。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;作者简介：&lt;strong&gt;小姐姐味道&lt;/strong&gt;  (xjjdog)，一个不允许程序员走弯路的公众号。聚焦基础架构和Linux。十年架构，日百亿流量，与你探讨高并发世界，给你不一样的味道。我的个人微信xjjdog0，欢迎添加好友，进一步交流。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3a676082c2425e9d5ae55a5f471e09b6</guid>
<title>[推荐] 缓存一致性最佳实践</title>
<link>https://toutiao.io/k/ymscqc1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4382826&quot; data-w=&quot;559&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbbFu7n3GktsBgczeVd0RHngWc5I6Wvf01FzUtDwQibTQEpYeZSM64W8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;背景 &lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;最近团队里我们在密集的讨论Redis缓存一致性相关的问题，电商核心的域如商品、营销、库存、订单等实际上在缓存的选择上各有特色，那么在这些差异的业务背后，我们有没有一些最佳实践可供参考呢？&lt;/p&gt;&lt;p&gt;本文尝试着来讨论这个问题，并给出一些建议。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在讨论之前，有两个重点我们需要达成一致：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分布式场景下无法做到强一致&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不同于CPU硬件缓存体系采用的MESI协议以及硬件的强时钟控制，分布式场景下我们无法做到缓存与底层数据库的强一致，即把缓存和数据库的数据变更做成一个原子操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;硬件工程师设计了内存屏障（Memory Barrier）的概念，提供给软件开发者不同的一致性选项在性能与一致性上进行权衡。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;就算是达到最终一致性也很难&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;分布式场景下，要做到最终一致性，就要求缓存中存储的是最新版本的数据（或者缓存为空），而且是在数据库更新后很迅速的就要达到这个一致性的状态，要做到是极其困难的。&lt;/p&gt;&lt;p&gt;我们会面临硬件、软件、通信等等组件非常多的异常情况。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5409836&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbvSxeCUz3xV2YIUErVqjzgbHHKuhWXsU0JyWT3jfkpKJPI1Z14xiatxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;976&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;CPU的缓存结构&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;缓存的一致性问题&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;一般化来说，我们面临的是这样的一个问题，如下图所示，数据库的数据会有5次更新，产生6个版本，V1~V6，图中每个方框的长度代表这个版本持续的时间。&lt;/p&gt;&lt;p&gt;我们期望，在数据库中的数据变化后，缓存层需要尽快的感知到并作出反应，如下图所示，缓存层方框中的间隔代表这个时间段缓存数据不存在，V2、V3以及V5版本在缓存中不存在并不会破坏我们的最终一致性要求，只要数据库的最终版本和缓存的最终版本是相同的就可以了。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2796296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbpcFMVGBvhuLoH4m6rYIj8yhttcP7lbiaonk7s2MgEjNyQmj9zOCXE1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;缓存是如何写入的&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存写入的代码通常情况下都是和缓存使用的代码放在一起的，包含4个步骤，如下图所示：W1读取缓存，W2判断缓存是否存在，W3组装缓存数据（这通常需要向数据库进行查询），W4写入缓存。&lt;/p&gt;&lt;p&gt;每一个步骤间可能会停顿多久是没有办法控制的，尤其是W3、W4之间的停顿最为要命，它很可能让我们将旧版本的数据写入到缓存中。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;我们可能会想，W4步的写入，带上W2的假设，即使用WriteIfNotExists语义，会不会有所改善？&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3916667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTb20FjhyT48qhUfho2h4bwblJcIsFVibcSh0dgWLCqB0hicJ8EDgk8VUyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;考虑如下的情形，假设有3个缓存写入的并发执行，由于短时间数据库大量的更新，它们分别组装的是V1、V2、V3版本的数据。&lt;/p&gt;&lt;p&gt;使用WriteIfNotExists语义，其中必然有2个执行会失败，哪一个会成功根本无法保证。&lt;/p&gt;&lt;p&gt;我们无法简单的做决策，需要再次将缓存读取出来，然后判断是否我们即将写入的一样，如果一样那就很简单；如果不一样的话，我们有两种选择：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;将缓存删除，让后续别的请求来处理写入。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用缓存提供的原子操作，仅在我们的数据是较新版本时写入。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.27833&quot; data-w=&quot;1006&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbxFk3v9PuJ3VBXYmdBKGOcvrMXAyRjrqiaXlId1X7Q849lA9Gbon5dpg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;如何感知数据库的变化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;数据库的数据发生变化后，我们如何感知到并进行有效的缓存管理呢？&lt;/p&gt;&lt;p&gt;通常情况下有如下的3种做法：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用代码执行流&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通常我们会在数据库操作完成后，执行一些缓存操作的代码。&lt;/p&gt;&lt;p&gt;这种方式最大的问题是可靠性不高，应用重启、机器意外当机等情况都会导致后续的代码无法执行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用事务消息&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;作为使用代码执行流的改进，在数据库操作完成后发出事务消息，然后在消息的消费逻辑里执行缓存的管理操作。&lt;/p&gt;&lt;p&gt;可靠性的问题就解决了，只是业务侧要为此增加事务消息的逻辑，以及运行成本。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用数据变更日志&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;数据库产品通常都支持在数据变更后产生变更日志，比如MySQL的binlog。&lt;/p&gt;&lt;p&gt;可以让中间件团队写一款产品，在接收到变更后执行缓存的管理操作，比如阿里的精卫。&lt;/p&gt;&lt;p&gt;可靠性有保证，同时还可以进行某个时间段变更日志的回放，功能就比较强大了。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;最佳实践一：数据库变更后失效缓存&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这是最常用和简单的方式，应该被作为首选的方案，整体的执行逻辑如下图所示：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5731481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbuFnDYpEbhQKFJQVPGlOAZaJibTSPEQ0ag8mIn1J78yhhBfdYOlLhBibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;W4步使用最基本的put语义，这里的假设是写入较晚的请求往往也是携带的最新的数据，这在大多的情形下都是成立的。&lt;/p&gt;&lt;p&gt;D1步使用监听DB binlog的方式来删除缓存，即前述使用数据变更日志中介绍的方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;这个方案的缺点是&lt;/strong&gt;：在数据库数据存在高并发更新且缓存读取流量较大的情况下，会有小概率存在缓存中存储的是旧版本数据的情况。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通常的解法有四种：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;限制缓存有效时间&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;设定缓存的过期时间，比如15分钟。即表示我们最多接受缓存在15分钟的时间范围内是旧的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;小概率缓存重加载&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;根据流量比设定一定比例的缓存重加载，以保证大流量情况下的缓存数据的一致性。&lt;/p&gt;&lt;p&gt;比如1%的比例，这同时还可以帮助数据库得到充分的预热。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;结合业务特点&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;根据业务的特点做一些设计，比如：&lt;/p&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;针对营销的场景&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;在商品详情页/确认订单页的优惠计算时使用缓存，而在下单时不使用缓存。&lt;/p&gt;&lt;p&gt;这可以让极端情况发生时，不产生过大的业务损失。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;针对库存的场景&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;读取到旧版本的数据只是会在商品已售罄的情况下让多余的流量进入到下单而已，下单时的库存扣减是操作数据库的，所以不会有业务上的损失。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;两次删除&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;D1步删除缓存的操作执行两次，且中间有一定的间隔，比如30秒。&lt;/p&gt;&lt;p&gt;这两次动作的触发都是由“缓存管理组件”发起的，所以可以由它支持。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;最佳实践二：带版本写入&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;针对象商品信息缓存这种更新频率低、数据一致性要求较高且缓存读取流量很高的场景，通常会采用带版本更新的方式，整体的执行逻辑如下图如示：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6055556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTblN4aNHDMTub6GiboN4tIj5MlIj1sSpEiamGf0A9Pu2VBmPRF9fjxcayA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;和“数据库变更后失效缓存”方案最大的差异在W4步和D1步，需要缓存层提供带版本写入的API，即仅当写入数据版本较新时可以写入成功，否则写入失败。&lt;/p&gt;&lt;p&gt;这同时也要求我们在数据库增加数据版本的信息。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个方案的最终一致性效果比较好，仅在极端情况下（新版本写入后数据丢失了，后续旧版本的写入就会成功）存在缓存中存储的是旧版本数据的可能。&lt;/p&gt;&lt;p&gt;在D1步使用写入而不是使用删除可以极大程度的避免这个极端情况的出现，同时由于该方案适用于缓存读取流量很高的场景，还可以避免缓存被删除后W3步短时间大量请求穿透到DB。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;总结与展望&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对于缓存与数据库分离的场景，在结合了业界多家公司的实践经验以及ROI权衡之后，前述的两个最佳实践是被应用的最为广泛的，尤其是最佳实践一，应该作为我们日常应用的首选。&lt;/p&gt;&lt;p&gt;同时，为了最大限度的避免每个最佳实践背后可能发生的不一致性问题，我们还需要切合业务的特点，在关键的场景上做一些保障一致性的设计（比如前述的营销在下单时使用数据库读而不是缓存读），这也显得尤为重要（毕竟如“背景”中所述，并不存在完美的技术方案）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;除了缓存与数据库分离的方案，还有两个业界已经应用的方案也值得我们借鉴：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;阿里XKV&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;简单来讲就是在数据库上部署一个Memcache的Server，它直接绕过数据库层直接访问存储引擎层（如：InnoDB），同时使用KV client来进行数据的访问。&lt;/p&gt;&lt;p&gt;它的特点是数据实际上与数据库是强一致的，性能可以比使用SQL访问数据库提升5～10倍。&lt;/p&gt;&lt;p&gt;缺点也很明显，只能通过主键或者唯一键来访问数据（这只是相对SQL来说的，大多数缓存本来也就是KV访问协议）。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;腾讯DCache&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;不用自行维护缓存与数据库两套存储，给开发人员统一的一套数据视图，由DCache在缓存更新后自行持久化数据。&lt;/p&gt;&lt;p&gt;缺点是支持的数据结构有限（ key-value，k-k-row，list，set，zset ），未来也很难支持形如数据库表一样复杂的数据结构。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.004&quot; data-w=&quot;1000&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/n4p7ssmqwmGHOiaBs4TLdiacnZ6Ub3E6Oqia4cJNlwjuvAI6fuDuXvUGb9FX2wTNgvRtdpqlSf4V780atTia0eorag/640?wx_fmt=gif&quot; data-type=&quot;gif&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;*文/苏木&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkxNTE3ODU0NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74Diclic7XyegA4UmC0SqoT4jDEpdzibjkibmAvz8svbJwfsufiaBqOWx9sskIrickxzGfCwkjuMBiaNLDxNA/0?wx_fmt=png&quot; data-nickname=&quot;得物技术&quot; data-signature=&quot;技术知识分享交流平台，与你一同走向技术的云端。&quot;/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>