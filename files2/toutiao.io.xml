<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>669a92365a6ba08a08a27d53ef409a8b</guid>
<title>Spring 是如何解析 &lt;bean&gt; 标签的？</title>
<link>https://toutiao.io/k/tk6aq1f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前情回顾&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上回「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4NzYyMDE4MQ==&amp;amp;mid=2247484614&amp;amp;idx=1&amp;amp;sn=4083d7d8cbc2b35af97f0fd053732f4e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Spring IoC 容器初始化（2）&lt;/a&gt;」说到了 Spring 如何解析我们定义的 &amp;lt;bean&amp;gt; 标签，代码跟进了一层又一层，跋山涉水，最终来到了 BeanDefinitionParserDelegate#parseBeanDefinitionElement 方法。不过这个方法只是表面，并未深入解析 &amp;lt;bean&amp;gt; 中的 class 等属性以及 property 等子标签。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文继续跟进。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;嗯，还是要耐着点性子，最好写个 demo 打断点跟踪一下，这样理解起来才更深刻。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何解析 &amp;lt;bean&amp;gt; 的内容？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续看代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BeanDefinitionParserDelegate&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; AbstractBeanDefinition &lt;span&gt;parseBeanDefinitionElement&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;        Element ele, String beanName, @Nullable BeanDefinition containingBean)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;      String className = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;// 读取 &amp;lt;bean&amp;gt; 标签的 class 属性&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (ele.hasAttribute(CLASS_ATTRIBUTE)) {&lt;br/&gt;        className = ele.getAttribute(CLASS_ATTRIBUTE).trim();&lt;br/&gt;      }&lt;br/&gt;      String parent = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;// 读取 &amp;lt;bean&amp;gt; 标签的 parent 属性&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (ele.hasAttribute(PARENT_ATTRIBUTE)) {&lt;br/&gt;        parent = ele.getAttribute(PARENT_ATTRIBUTE);&lt;br/&gt;      }&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 创建 BeanDefinition 对象（GenericBeanDefinition）&lt;/span&gt;&lt;br/&gt;        AbstractBeanDefinition bd = createBeanDefinition(className, parent);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 解析 scope、lazy-init、autowire 等属性&lt;/span&gt;&lt;br/&gt;        parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);&lt;br/&gt;        bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 解析 meta 标签&lt;/span&gt;&lt;br/&gt;        parseMetaElements(ele, bd);&lt;br/&gt;            &lt;br/&gt;        &lt;span&gt;// 解析 lookup-method 标签&lt;/span&gt;&lt;br/&gt;        parseLookupOverrideSubElements(ele, bd.getMethodOverrides());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 解析 replace-method 标签&lt;/span&gt;&lt;br/&gt;        parseReplacedMethodSubElements(ele, bd.getMethodOverrides());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 解析 constructor-arg 标签&lt;/span&gt;&lt;br/&gt;        parseConstructorArgElements(ele, bd);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 解析 property 标签&lt;/span&gt;&lt;br/&gt;        parsePropertyElements(ele, bd);&lt;br/&gt;            &lt;br/&gt;        &lt;span&gt;// 解析 qualifier 标签&lt;/span&gt;&lt;br/&gt;        parseQualifierElements(ele, bd);&lt;br/&gt;&lt;br/&gt;        bd.setResource(&lt;span&gt;this&lt;/span&gt;.readerContext.getResource());&lt;br/&gt;        bd.setSource(extractSource(ele));&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; bd;&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;// catch ...&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里才是真正解析 &amp;lt;bean&amp;gt; 标签内容的地方，比如常见的 class、parent、scope、lazy-init、autowire、property、constructor-arg 等，还有不常见的 lookup-method、replace-method 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法内部调用了一个个方法去解析不同的标签。这里我们只跟进常见的 property 如何解析，其他方法大体也都差不多，有兴趣可以自行研究。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;parsePropertyElements 方法代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BeanDefinitionParserDelegate&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 解析 property 标签&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;parsePropertyElements&lt;/span&gt;&lt;span&gt;(Element beanEle, BeanDefinition bd)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    NodeList nl = beanEle.getChildNodes();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; nl.getLength(); i++) {&lt;br/&gt;      Node node = nl.item(i);&lt;br/&gt;      &lt;span&gt;// 筛选 &amp;lt;property&amp;gt; 标签&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (isCandidateElement(node) &amp;amp;&amp;amp; nodeNameEquals(node, PROPERTY_ELEMENT)) {&lt;br/&gt;        parsePropertyElement((Element) node, bd);&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;parsePropertyElement&lt;/span&gt;&lt;span&gt;(Element ele, BeanDefinition bd)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// property 标签的 name 属性&lt;/span&gt;&lt;br/&gt;    String propertyName = ele.getAttribute(NAME_ATTRIBUTE);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!StringUtils.hasLength(propertyName)) {&lt;br/&gt;      &lt;span&gt;// error&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.parseState.push(&lt;span&gt;new&lt;/span&gt; PropertyEntry(propertyName));&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (bd.getPropertyValues().contains(propertyName)) {&lt;br/&gt;        &lt;span&gt;// error&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;// 这里解析得到的是 RuntimeBeanReference 或者 TypedStringValue&lt;/span&gt;&lt;br/&gt;      Object val = parsePropertyValue(ele, bd, propertyName);&lt;br/&gt;      PropertyValue pv = &lt;span&gt;new&lt;/span&gt; PropertyValue(propertyName, val);&lt;br/&gt;      parseMetaElements(ele, pv);&lt;br/&gt;      pv.setSource(extractSource(ele));&lt;br/&gt;      &lt;span&gt;// 将解析到的值添加到 BeanDefinition 的属性列表&lt;/span&gt;&lt;br/&gt;      bd.getPropertyValues().addPropertyValue(pv);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.parseState.pop();&lt;br/&gt;    }&lt;br/&gt;  }    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法主要做了什么呢？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;遍历节点并找到 property 标签&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;解析 property 标签的 name 属性，将它对应的值封装为 RuntimeBeanReference 类型或者 TypedStringValue 类型（其中前者对应 ref 属性，后者对应 value 属性，可参考前文 application-ioc.xml 文件），然后再封装为 PropertyValue 类型，并保存到 BeanDefinition 的属性列表中。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解析 ref 和 value 的过程如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BeanDefinitionParserDelegate&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;  public&lt;/span&gt; Object &lt;span&gt;parsePropertyValue&lt;/span&gt;&lt;span&gt;(Element ele, BeanDefinition bd, @Nullable String propertyName)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    String elementName = (propertyName != &lt;span&gt;null&lt;/span&gt; ?&lt;br/&gt;        &lt;span&gt;    &quot;&amp;lt;property&amp;gt; element for property &#x27;&quot;&lt;/span&gt; + propertyName + &lt;span&gt;&quot;&#x27;&quot;&lt;/span&gt; :&lt;br/&gt;            &lt;span&gt;&quot;&amp;lt;constructor-arg&amp;gt; element&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Should only have one child element: ref, value, list, etc.&lt;/span&gt;&lt;br/&gt;    NodeList nl = ele.getChildNodes();&lt;br/&gt;    Element subElement = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; nl.getLength(); i++) {&lt;br/&gt;      Node node = nl.item(i);&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (node &lt;span&gt;instanceof&lt;/span&gt; Element &amp;amp;&amp;amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;amp;&amp;amp;&lt;br/&gt;          !nodeNameEquals(node, META_ELEMENT)) {&lt;br/&gt;        &lt;span&gt;// Child element is what we&#x27;re looking for.&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (subElement != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;          error(elementName + &lt;span&gt;&quot; must not contain more than one sub-element&quot;&lt;/span&gt;, ele);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;          subElement = (Element) node;&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// ref 和 value 属性，二者不能并存&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;boolean&lt;/span&gt; hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);&lt;br/&gt;    &lt;span&gt;boolean&lt;/span&gt; hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; ((hasRefAttribute &amp;amp;&amp;amp; hasValueAttribute) ||&lt;br/&gt;        ((hasRefAttribute || hasValueAttribute) &amp;amp;&amp;amp; subElement != &lt;span&gt;null&lt;/span&gt;)) {&lt;br/&gt;      error(elementName +&lt;br/&gt;        &lt;span&gt;&quot; is only allowed to contain either &#x27;ref&#x27; attribute OR &#x27;value&#x27; attribute OR sub-element&quot;&lt;/span&gt;, ele);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// ref 属性&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (hasRefAttribute) {&lt;br/&gt;      String refName = ele.getAttribute(REF_ATTRIBUTE);&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (!StringUtils.hasText(refName)) {&lt;br/&gt;        error(elementName + &lt;span&gt;&quot; contains empty &#x27;ref&#x27; attribute&quot;&lt;/span&gt;, ele);&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;// 封装为 RuntimeBeanReference 类型&lt;/span&gt;&lt;br/&gt;      RuntimeBeanReference ref = &lt;span&gt;new&lt;/span&gt; RuntimeBeanReference(refName);&lt;br/&gt;      ref.setSource(extractSource(ele));&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; ref;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// value 属性&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (hasValueAttribute) {&lt;br/&gt;      &lt;span&gt;// 封装为 TypedStringValue 类型&lt;/span&gt;&lt;br/&gt;      TypedStringValue valueHolder = &lt;span&gt;new&lt;/span&gt; TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));&lt;br/&gt;      valueHolder.setSource(extractSource(ele));&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; valueHolder;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 若还有子元素，继续解析&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (subElement != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;// 这里包含了 property 标签的子标签，例如 list、map、set 等&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; parsePropertySubElement(subElement, bd);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      error(elementName + &lt;span&gt;&quot; must specify a ref or value&quot;&lt;/span&gt;, ele);&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;property 标签的解析算是相对复杂的，其他标签（meta、constructor-arg 等）的解析过程大体是类似的，不再一一分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过 BeanDefinitionParserDelegate#parseBeanDefinitionElement 方法的解析和封装后，就得到了保存我们自定义 bean 信息的 BeanDefinition，即 GenericBeanDefinition。Spring 又把 BeanDefinition 和别名信息封装成了 BeanDefinitionHolder：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BeanDefinitionParserDelegate&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; BeanDefinitionHolder &lt;span&gt;parseBeanDefinitionElement&lt;/span&gt;&lt;span&gt;(Element ele, @Nullable BeanDefinition containingBean)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    String id = ele.getAttribute(ID_ATTRIBUTE);&lt;br/&gt;    String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 解析后得到的 BeanDefinition&lt;/span&gt;&lt;br/&gt;    AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (beanDefinition != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;      String[] aliasesArray = StringUtils.toStringArray(aliases);&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，在向 IoC 容器注册之前，还有一个 decorateBeanDefinitionIfRequired 方法，它主要是用来处理默认名称空间（即 http://www.springframework.org/schema/beans）之外的 bean 定义，比如 &amp;lt;tx&amp;gt;、&amp;lt;context&amp;gt; 等，这里仍然先沿着主线走，暂不深入分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来就是将 BeanDefinition 注册到 IoC 容器：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DefaultBeanDefinitionDocumentReader&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BeanDefinitionDocumentReader&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;  // ...&lt;/span&gt;&lt;br/&gt;    &lt;br/&gt;  &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;processBeanDefinition&lt;/span&gt;&lt;span&gt;(Element ele, BeanDefinitionParserDelegate delegate)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 解析后的 BeanDefinition 封装成的 BeanDefinitionHolder&lt;/span&gt;&lt;br/&gt;    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (bdHolder != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);&lt;br/&gt;      &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// Register the final decorated instance.&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 注册 BeanDefinition&lt;/span&gt;&lt;br/&gt;        BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;catch&lt;/span&gt; (BeanDefinitionStoreException ex) {&lt;br/&gt;        getReaderContext().error(&lt;span&gt;&quot;Failed to register bean definition with name &#x27;&quot;&lt;/span&gt; +&lt;br/&gt;        bdHolder.getBeanName() + &lt;span&gt;&quot;&#x27;&quot;&lt;/span&gt;, ele, ex);&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;// Send registration event.&lt;/span&gt;&lt;br/&gt;      getReaderContext().fireComponentRegistered(&lt;span&gt;new&lt;/span&gt; BeanComponentDefinition(bdHolder));&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BeanDefinitionReaderUtils&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;registerBeanDefinition&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;throws&lt;/span&gt; BeanDefinitionStoreException &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Register bean definition under primary name.&lt;/span&gt;&lt;br/&gt;    String beanName = definitionHolder.getBeanName();&lt;br/&gt;    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Register aliases for bean name, if any.&lt;/span&gt;&lt;br/&gt;    String[] aliases = definitionHolder.getAliases();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (aliases != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;for&lt;/span&gt; (String alias : aliases) {&lt;br/&gt;        registry.registerAlias(beanName, alias);&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IoC 容器是哪个？如何注册呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前文提到过，Spring 默认的 IoC 容器是 DefaultListableBeanFactory，来看下它的继承结构：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.53046875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ophTb90oYCSQXV27XgPhoHD5xMXWZokcfQDdhNics8917ka9ncSTCjxnItFuMelWXfnT1FiaL2wVXQrdVHvJ0sjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到 DefaultListableBeanFactory 实现了 BeanDefinitionRegistry 接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓的“注册”到 IoC 容器，其实就是把 BeanDefinition 保存到了 DefaultListableBeanFactory  持有的一个 Map 中，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DefaultListableBeanFactory&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractAutowireCapableBeanFactory&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ConfigurableListableBeanFactory&lt;/span&gt;, &lt;span&gt;BeanDefinitionRegistry&lt;/span&gt;, &lt;span&gt;Serializable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;registerBeanDefinition&lt;/span&gt;&lt;span&gt;(String beanName, BeanDefinition beanDefinition)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;throws&lt;/span&gt; BeanDefinitionStoreException &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    Assert.hasText(beanName, &lt;span&gt;&quot;Bean name must not be empty&quot;&lt;/span&gt;);&lt;br/&gt;    Assert.notNull(beanDefinition, &lt;span&gt;&quot;BeanDefinition must not be null&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (beanDefinition &lt;span&gt;instanceof&lt;/span&gt; AbstractBeanDefinition) {&lt;br/&gt;    &lt;span&gt;  try&lt;/span&gt; {&lt;br/&gt;        ((AbstractBeanDefinition) beanDefinition).validate();&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;catch&lt;/span&gt; (BeanDefinitionValidationException ex) {&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,&lt;br/&gt;          &lt;span&gt;&quot;Validation of bean definition failed&quot;&lt;/span&gt;, ex);&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取已存在的 BeanDefinition&lt;/span&gt;&lt;br/&gt;    BeanDefinition existingDefinition = &lt;span&gt;this&lt;/span&gt;.beanDefinitionMap.get(beanName);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (existingDefinition != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (!isAllowBeanDefinitionOverriding()) {&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;// 这几个异常信息是不是有点眼熟？&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (existingDefinition.getRole() &amp;lt; beanDefinition.getRole()) {&lt;br/&gt;        &lt;span&gt;// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (logger.isInfoEnabled()) {&lt;br/&gt;          logger.info(&lt;span&gt;&quot;Overriding user-defined bean definition for bean &#x27;&quot;&lt;/span&gt; + beanName +&lt;br/&gt;            &lt;span&gt;&quot;&#x27; with a framework-generated bean definition: replacing [&quot;&lt;/span&gt; +&lt;br/&gt;            existingDefinition + &lt;span&gt;&quot;] with [&quot;&lt;/span&gt; + beanDefinition + &lt;span&gt;&quot;]&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!beanDefinition.equals(existingDefinition)) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (logger.isDebugEnabled()) {&lt;br/&gt;          logger.debug(&lt;span&gt;&quot;Overriding bean definition for bean &#x27;&quot;&lt;/span&gt; + beanName +&lt;br/&gt;            &lt;span&gt;&quot;&#x27; with a different definition: replacing [&quot;&lt;/span&gt; + existingDefinition +&lt;br/&gt;            &lt;span&gt;&quot;] with [&quot;&lt;/span&gt; + beanDefinition + &lt;span&gt;&quot;]&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (logger.isTraceEnabled()) {&lt;br/&gt;          logger.trace(&lt;span&gt;&quot;Overriding bean definition for bean &#x27;&quot;&lt;/span&gt; + beanName +&lt;br/&gt;            &lt;span&gt;&quot;&#x27; with an equivalent definition: replacing [&quot;&lt;/span&gt; + existingDefinition +&lt;br/&gt;            &lt;span&gt;&quot;] with [&quot;&lt;/span&gt; + beanDefinition + &lt;span&gt;&quot;]&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.beanDefinitionMap.put(beanName, beanDefinition);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (hasBeanCreationStarted()) {&lt;br/&gt;        &lt;span&gt;// Cannot modify startup-time collection elements anymore (for stable iteration)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.beanDefinitionMap) {&lt;br/&gt;          &lt;span&gt;this&lt;/span&gt;.beanDefinitionMap.put(beanName, beanDefinition);&lt;br/&gt;          List&amp;lt;String&amp;gt; updatedDefinitions = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;this&lt;/span&gt;.beanDefinitionNames.size() + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;          updatedDefinitions.addAll(&lt;span&gt;this&lt;/span&gt;.beanDefinitionNames);&lt;br/&gt;          updatedDefinitions.add(beanName);&lt;br/&gt;          &lt;span&gt;this&lt;/span&gt;.beanDefinitionNames = updatedDefinitions;&lt;br/&gt;          removeManualSingletonName(beanName);&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 注册到 Map 中&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// Still in startup registration phase&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.beanDefinitionMap.put(beanName, beanDefinition);&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.beanDefinitionNames.add(beanName);&lt;br/&gt;        removeManualSingletonName(beanName);&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.frozenBeanDefinitionNames = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;    if&lt;/span&gt; (existingDefinition != &lt;span&gt;null&lt;/span&gt; || containsSingleton(beanName)) {&lt;br/&gt;      resetBeanDefinition(beanName);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (isConfigurationFrozen()) {&lt;br/&gt;      clearByTypeCache();&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面几个异常信息是不是有点眼熟？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个 beanDefinitionMap 是个什么呢？它就是个 Map：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/** Map of bean definition objects, keyed by bean name. */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;String, BeanDefinition&amp;gt; beanDefinitionMap = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;(&lt;span&gt;256&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，Spring 已经从我们定义的 application-ioc.xml 文件中读取和解析到了 &amp;lt;bean&amp;gt; 标签的信息，并将其转换为内部的数据结构 BeanDefinition，然后注册到了 IoC 容器（也就是 DefaultListableBeanFactory）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了有个整体的把握，这里把主要流程梳理成了一个思维导图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.421011673151751&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ophTb90oYCSQXV27XgPhoHD5xMXWZokcuf6gmFZnXo2KoBFdTInuLm5wJDFSFrSN9CT1m81RUTfGobTiaQ1em0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2570&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实前面几篇文章主要是第一个步骤，也就是「初始化 BeanFactory，注册 Bean 定义」，而且只是沿着一条主线走下来的，其它细节部分有兴趣的小伙伴可以自行研究。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IoC 容器已经建立，而且 BeanDefinition 也放进去了，如何从容器拿到我们想要的对象呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欲知后事如何，且听下回分解~&lt;/p&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;咱也来体验一下这个名片&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4NzYyMDE4MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/ophTb90oYCSstvZP4AJ5fAFSlibueYhriaZdtxJfOb7OwWTdFVS044kDFlH2xgGSJxWEjdO24QTSp2ukBbnjIeFA/0?wx_fmt=png&quot; data-nickname=&quot;WriteOnRead&quot; data-alias=&quot;WriteOnRead&quot; data-signature=&quot;Java学习与分享。知易行难，坚持更难。加油！&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>faa0ad1bd56aaa7281309ae879d4acda</guid>
<title>春节大礼，Vite 2.0 正式发布，中文手册同步更新</title>
<link>https://toutiao.io/k/307qp2v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;h2&gt;&lt;b&gt;  Vite 中文文档祝全体读者 2021 春节快乐！  &lt;/b&gt;&lt;/h2&gt;&lt;p&gt;打开 github 的 vite 中文文档首页，首先看到的就是这句祝福，vue 团队有心了；大家也可以亲自去github 感受一下： &lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/vitejs/docs-cn&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/vitejs/docs-&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;cn&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/u&gt; &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-89c063492af034120f4f5352e3ded39e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;884&quot; data-rawheight=&quot;343&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-89c063492af034120f4f5352e3ded39e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;884&quot; data-rawheight=&quot;343&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-89c063492af034120f4f5352e3ded39e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-89c063492af034120f4f5352e3ded39e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;因为目前文档正处于活跃的更新状态，中文文档是英文的翻译版，所以，首先更新的肯定是英文，也建议大家直接查看英文文档，因为翻译更新的不确定性，所以，官方并没有部署中文文档的站点，但是，我知道大家都是爱学习的积极分子，英语阅读可能有点不太方便，本地部署也有点繁琐，所以，大帅哥 西岭老湿 为了帮助大家学习 Vite ，特意将 Vite 中文版做了静态部署，方便大家查阅；&lt;/p&gt;&lt;p&gt;如果你觉得还不错，建议收藏，同时，西岭老湿说会不定期更新文档内容，欢迎关注 西岭老湿 微信公众号接受更新通知提醒；&lt;/p&gt;&lt;p&gt;祝各位学习愉快……&lt;/p&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c96ea45cf8a4cbbc43c417a9384c3c90</guid>
<title>读《演进式架构》学习笔记</title>
<link>https://toutiao.io/k/pdyq1ir</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;td class=&quot;blog_detail&quot;&gt;
&lt;input id=&quot;js_detail&quot; type=&quot;hidden&quot; value=&quot;![](http://misc.linkedkeeper.com/misc/img/blog/202102/linkedkeeper0_36c35b03-623e-49e5-9a78-f1d442eb5bce.jpg)&amp;#10;&amp;#10;&amp;lt;i&amp;gt;本笔记不是书的摘抄，内容是通过笔者阅读书之后，对知识内容的消化提炼而成，故不敢以此文指导他人学习，但愿与读者多多交流，如有错误还望多多指点。&amp;lt;/i&amp;gt;&amp;#10;&amp;#10;## 01 什么是演进式架构？&amp;#10;&amp;#10;外文技术书翻译后通常很难理解，此书也不例外，首先，书中对演进式架构的定义就很晦涩 —— 演进式架构是支持跨多个维度进行**引导性**增量变更的架构。&amp;#10;&amp;#10;第一，先多读几遍，念顺了；&amp;#10;&amp;#10;第二，通过拆解关键词，来理解定义。&amp;#10;&amp;#10;**定义中的关键字一**：多个维度。&amp;#10;&amp;#10;所谓多个维度，指的是架构师不要只关注技术维度对架构演进的影响，也要关注数据、安全、运维等纬度的变化影响。除此之外，康威也提醒架构师，还应关注团队之间的协同纬度的变化影响。在现实情况下，一次组织架构的调整，将很大程度影响着架构演进的路径。&amp;#10;&amp;#10;**定义中的关键字二**：增量和引导。&amp;#10;&amp;#10;“增量和引导”是演进式架构包含的两个关键特征，其中“增量”表达了架构随时间不断变化的概念，而“引导”的含义反映了我们期望的架构演进方向。&amp;#10;&amp;#10;回到生物学的隐喻，演进是这样一个过程：建立一个适用的并能在其所处的不断变化的环境中持续运行的系统。&amp;#10;&amp;#10;&amp;lt;br/&amp;gt;&amp;#10;&amp;#10;理解了引导的含义，那么“引导”引导的是什么？引导的原则又是什么？&amp;#10;&amp;#10;我们知道，安全性、吞吐量、低延迟、故障恢复能力都可以定义为系统的架构特征，由于这些特征有的是相互冲突的，比如安全性与性能。所以，对架构师而言，在架构演进过程中需要评估和权衡这些不同的特征，而所谓引导就是评估这些不同架构特征，让架构演进中不随着时间而磨损掉这些特征。简单说，引导就是架构师期望架构具备那些特征。&amp;#10;&amp;#10;关于引导的原则，本书引入了进化计算中的概念 —— 适应度函数，让架构师可以通过适应度函数来解释什么方案更好，并用它衡量何时能达到目标，但笔者通读之后，没有理解，故不过多阐述。&amp;#10;&amp;#10;之后，本书又重点介绍了增量变更、架构耦合对演进式架构的影响，内容围绕持续交付、领域驱动设计、架构演进等方面，内容并不新鲜，故也不做罗列。&amp;#10;&amp;#10;## 02 如何构建可演进的架构&amp;#10;&amp;#10;如何构建？本书的逻辑是这样的。&amp;#10;&amp;#10;架构耦合很大程序决定了技术架构的演进能力，清晰解耦的架构易于演进，反之则会妨碍演进。回答如何构建演进式架构，我理解的是从微服务架构开始，后面的内容基本也都是在围绕着微服务和领域驱动设计再说，有兴趣的读者可以去读一下本书。&quot;/&gt;
&lt;p id=&quot;markdown_detail&quot;/&gt;
&lt;br/&gt;
&lt;p&gt;本文受原创保护，未经作者授权，禁止转载。 linkedkeeper.com (文／张松然)  &lt;a href=&quot;/site/copyright.action&quot;&gt;©著作权归作者所有&lt;/a&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>770d4700fcf9b5a6b02f91a3541dd684</guid>
<title>gRPC 的 4 种基础通信模式</title>
<link>https://toutiao.io/k/3sn14va</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;题图 |  from freepik&lt;/span&gt;&lt;/p&gt;&lt;p&gt;本文将讨论 gRPC 应用程序的 4 种基础通信模式：一元 RPC、服务器端流 RPC、客户端流 RPC 以及双向流 RPC。在这个过程中，我们会使用一些真实用例来展示每种模式，使用 gRPC IDL 进行服务定义，并使用 Go 语言来实现服务和客户端。&lt;/p&gt;&lt;h2&gt;1. 一元RPC模式&lt;/h2&gt;&lt;p&gt;我们从最简单的 RPC 风格开始讨论 gRPC 通信模式。一元 RPC 模式也被称为简单 RPC 模式。在该模式中，当客户端调用服务器端的远程方法时，客户端发送请求至服务器端并获得一个响应，与响应一起发送的还有状态细节以及 trailer 元数据。接下来看一个真实的用例，来进一步了解一元 RPC 模式。&lt;/p&gt;&lt;p&gt;假设需要为基于 gRPC 的在线零售应用程序构建 &lt;code&gt;OrderManagement&lt;/code&gt; 服务，并在该服务中实现 &lt;code&gt;getOrder&lt;/code&gt; 方法。借助该方法，客户端可以通过订单 ID 检索已有的订单。如图1 所示，客户端发送一个带有订单 ID 的请求，服务器端给出响应，响应中包含订单的信息。因此，它遵循一元 RPC 模式。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3290566037735849&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/riafuBXuN2hrcssibTO5WbZ6iaMP9HULQO6NOxv5icuGOIicMk3lLIJ989zO7j2uXLIsLKHr7O9Qc7udkJibxqzB2XpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1325&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1：一元 RPC 模式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;下面来实现这种模式。第一步就是为 &lt;code&gt;OrderManagement&lt;/code&gt; 服务及其 &lt;code&gt;getOrder&lt;/code&gt; 方法创建服务定义。如代码清单1 所示，可以使用 protocol buffers 进行服务定义，&lt;code&gt;getOrder&lt;/code&gt; 远程方法接受一个订单 ID 的请求，并且会给出一个包含 &lt;code&gt;Order&lt;/code&gt; 消息的响应。在本用例中，&lt;code&gt;Order&lt;/code&gt; 消息具有描述订单所需的结构。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;代码清单1&lt;/span&gt;　&lt;code&gt;OrderManagement&lt;/code&gt; 服务定义，服务中的 &lt;code&gt;getOrder&lt;/code&gt; 方法遵循一元 RPC 模式&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;syntax = &quot;proto3&quot;;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;import &quot;google/protobuf/wrappers.proto&quot;; ➊&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;package ecommerce;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;service OrderManagement {&lt;/p&gt;&lt;p&gt;    rpc getOrder(google.protobuf.StringValue) returns (Order); ➋&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;message Order { ➌&lt;/p&gt;&lt;p&gt;    string id = 1;&lt;/p&gt;&lt;p&gt;    repeated string items = 2; ➍&lt;/p&gt;&lt;p&gt;    string description = 3;&lt;/p&gt;&lt;p&gt;    float price = 4;&lt;/p&gt;&lt;p&gt;    string destination = 5;&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;❶ 导入这个包，从而使用常见的类型，如 &lt;code&gt;StringValue&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;❷ 检索订单的远程方法。&lt;/p&gt;&lt;p&gt;❸ 定义 &lt;code&gt;Order&lt;/code&gt; 类型。&lt;/p&gt;&lt;p&gt;❹ 使用 &lt;code&gt;repeated&lt;/code&gt; 表明这个字段在消息中可以重复出现任意次，包括 0 次。在这里，一条订单消息可以有任意数量的条目。&lt;/p&gt;&lt;p&gt;然后，借助 gRPC 服务定义的 proto 文件，就可以生成服务器端骨架代码并实现 &lt;code&gt;GetOrder&lt;/code&gt; 方法的逻辑了。代码清单2 展示了 &lt;code&gt;OrderManagement&lt;/code&gt; 服务的 Go 实现。作为 &lt;code&gt;GetOrder&lt;/code&gt; 方法的输入，单个订单 ID（&lt;code&gt;String&lt;/code&gt;）用来组成请求，这样做可以很容易地在服务器端找到订单并以 &lt;code&gt;Order&lt;/code&gt; 消息（&lt;code&gt;Order&lt;/code&gt; 结构体）的形式进行响应。&lt;code&gt;Order&lt;/code&gt; 消息可以和 &lt;code&gt;nil&lt;/code&gt; 错误一起返回，从而告诉 gRPC，我们已经处理完 RPC，可以将 &lt;code&gt;Order&lt;/code&gt; 返回到客户端了。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;代码清单2&lt;/span&gt;　使用 Go 语言编写的 &lt;code&gt;OrderManagement&lt;/code&gt; 服务的 &lt;code&gt;GetOrder&lt;/code&gt; 方法实现&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;p&gt;// server/main.go&lt;/p&gt;&lt;p&gt;func (s *server) GetOrder(ctx context.Context,&lt;/p&gt;&lt;p&gt;        orderId *wrapper.StringValue) (*pb.Order, error) {&lt;/p&gt;&lt;p&gt;    // 服务实现&lt;/p&gt;&lt;p&gt;       ord := orderMap[orderId.Value]&lt;/p&gt;&lt;p&gt;       return &amp;amp;ord, nil&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;现在来实现客户端的逻辑，从而远程调用 &lt;code&gt;GetOrder&lt;/code&gt; 方法。与服务器端的实现一样，可以为自己喜欢的语言生成代码来创建客户端存根，然后使用该存根调用服务，代码清单3 使用 Go gRPC 客户端调用 &lt;code&gt;OrderManagement&lt;/code&gt; 服务。当然，首先要创建到服务器端的连接并初始化调用服务的客户端存根。然后，就可以调用客户端存根的 &lt;code&gt;GetOrder&lt;/code&gt; 方法，从而实现对远程方法的调用。这时会得到一个 &lt;code&gt;Order&lt;/code&gt; 消息作为响应，其中包含服务定义中使用 protocol buffers 所定义的订单信息。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;代码清单3&lt;/span&gt;　使用 Go 语言调用远程 &lt;code&gt;GetOrder&lt;/code&gt; 方法的客户端实现&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;p&gt;// 建立到服务器端的连接.&lt;/p&gt;&lt;p&gt;...&lt;/p&gt;&lt;p&gt;orderMgtClient := pb.NewOrderManagementClient(conn)&lt;/p&gt;&lt;p&gt;...&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;// 获取订单&lt;/p&gt;&lt;p&gt;retrievedOrder , err := orderMgtClient.GetOrder(ctx,&lt;/p&gt;&lt;p&gt;       &amp;amp;wrapper.StringValue{Value: &quot;106&quot;})&lt;/p&gt;&lt;p&gt;log.Print(&quot;GetOrder Response -&amp;gt; : &quot;, retrievedOrder)&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;这种一元 RPC 模式非常容易实现，适用于大多数进程间通信用例。在多种语言间，实现方式都是非常类似的，本文的示例代码仓库提供了 Go 和 Java 的源代码。&lt;/p&gt;&lt;p&gt;现在，我们已经对一元 RPC 模式有了大致的了解，接下来看一下服务器端流 RPC 模式。&lt;/p&gt;&lt;h2&gt;2. 服务器端流RPC模式&lt;/h2&gt;&lt;p&gt;在一元 RPC 模式中，gRPC 服务器端和 gRPC 客户端在通信时始终只有一个请求和一个响应。在服务器端流 RPC 模式中，服务器端在接收到客户端的请求消息后，会发回一个响应的序列。这种多个响应所组成的序列也被称为“流”。在将所有的服务器端响应发送完毕之后，服务器端会以 trailer 元数据的形式将其状态发送给客户端，从而标记流的结束。&lt;/p&gt;&lt;p&gt;下面通过一个真实的用例来进一步了解服务器端流。在 &lt;code&gt;OrderManagement&lt;/code&gt; 服务中，假设需要实现一个订单搜索功能，利用该功能，只要提供一个搜索词就能得到匹配的结果，如图2 所示。&lt;code&gt;OrderManagement&lt;/code&gt; 服务不会将所有匹配的订单一次性地发送给客户端，而是在找到匹配的订单时，逐步将其发送出去。这意味着当订单服务的客户端发出一个请求之后，会接收到多条响应消息。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/riafuBXuN2hrcssibTO5WbZ6iaMP9HULQO6FDVB6fOia8jEHrcnVZtg4NIib5J9BnJibKfxVpm6B8EYticRTgfWoJyjJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1326&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2：服务器端流 RPC 模式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;现在，在 &lt;code&gt;OrderManagement&lt;/code&gt; 服务的 gRPC 服务定义中新增 &lt;code&gt;searchOrders&lt;/code&gt; 方法。如代码清单4 所示，&lt;code&gt;searchOrders&lt;/code&gt; 方法定义与代码清单 3-1 中的 &lt;code&gt;getOrder&lt;/code&gt; 方法非常类似，但是在服务定义的 proto 文件中，我们通过使用 &lt;code&gt;returns (stream Order)&lt;/code&gt; 将返回参数指定为订单的流。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;代码清单4&lt;/span&gt;　使用服务器端流 RPC 模式的服务定义&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;p&gt;syntax = &quot;proto3&quot;;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;import &quot;google/protobuf/wrappers.proto&quot;;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;package ecommerce;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;service OrderManagement {&lt;/p&gt;&lt;p&gt;    ...&lt;/p&gt;&lt;p&gt;    rpc searchOrders(google.protobuf.StringValue) returns (stream Order); ➊&lt;/p&gt;&lt;p&gt;    ...&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;message Order {&lt;/p&gt;&lt;p&gt;    string id = 1;&lt;/p&gt;&lt;p&gt;    repeated string items = 2;&lt;/p&gt;&lt;p&gt;    string description = 3;&lt;/p&gt;&lt;p&gt;    float price = 4;&lt;/p&gt;&lt;p&gt;    string destination = 5;&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;➊ 通过返回 &lt;code&gt;Order&lt;/code&gt; 消息的 &lt;code&gt;stream&lt;/code&gt; 定义服务器端流。&lt;/p&gt;&lt;p&gt;通过服务定义，可以生成服务器端的代码，然后通过实现所生成的接口，就可以为 &lt;code&gt;OrderManagement&lt;/code&gt; 服务的 &lt;code&gt;searchOrders&lt;/code&gt; 方法构建逻辑了。在代码清单5 所示的 Go 实现中，&lt;code&gt;SearchOrders&lt;/code&gt; 方法有两个参数，分别是字符串类型的 &lt;code&gt;searchQuery&lt;/code&gt; 和用来写入响应的特殊参数 &lt;code&gt;OrderManagement_SearchOrdersServer&lt;/code&gt;。&lt;code&gt;OrderManagement_SearchOrdersServer&lt;/code&gt; 是流的引用对象，可以写入多个响应。这里的业务逻辑是找到匹配的订单，并通过流将其依次发送出去。当找到新的订单时，使用流引用对象的 &lt;code&gt;Send(...)&lt;/code&gt; 方法将其写入流。一旦所有响应都写到了流中，就可以通过返回 &lt;code&gt;nil&lt;/code&gt; 来标记流已经结束，服务器端的状态和其他 trailer 元数据会发送给客户端。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;代码清单5&lt;/span&gt;　使用 Go 语言编写的 &lt;code&gt;SearchOrders&lt;/code&gt; 方法的 &lt;code&gt;OrderManagement&lt;/code&gt; 服务实现&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;p&gt;func (s *server) SearchOrders(searchQuery *wrappers.StringValue,&lt;/p&gt;&lt;p&gt;        stream pb.OrderManagement_SearchOrdersServer) error {&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;        for key, order := range orderMap {&lt;/p&gt;&lt;p&gt;                log.Print(key, order)&lt;/p&gt;&lt;p&gt;                for _, itemStr := range order.Items {&lt;/p&gt;&lt;p&gt;                        log.Print(itemStr)&lt;/p&gt;&lt;p&gt;                        if strings.Contains(&lt;/p&gt;&lt;p&gt;                                itemStr, searchQuery.Value) { ➊&lt;/p&gt;&lt;p&gt;                                // 在流中发送匹配的订单&lt;/p&gt;&lt;p&gt;                                err := stream.Send(&amp;amp;order) ➋&lt;/p&gt;&lt;p&gt;                                if err != nil {&lt;/p&gt;&lt;p&gt;                                   return fmt.Errorf(&lt;/p&gt;&lt;p&gt;                                            &quot;error sending message to stream : %v&quot;,&lt;/p&gt;&lt;p&gt;                                                    err) ➌&lt;/p&gt;&lt;p&gt;                                }&lt;/p&gt;&lt;p&gt;                                log.Print(&quot;Matching Order Found : &quot; + key)&lt;/p&gt;&lt;p&gt;                                break&lt;/p&gt;&lt;p&gt;                        }&lt;/p&gt;&lt;p&gt;                }&lt;/p&gt;&lt;p&gt;        }&lt;/p&gt;&lt;p&gt;        return nil&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;❶ 查找匹配的订单。&lt;/p&gt;&lt;p&gt;❷ 通过流发送匹配的订单。&lt;/p&gt;&lt;p&gt;❸ 检查在将消息以流的形式发送给客户端的过程中可能出现的错误。&lt;/p&gt;&lt;p&gt;客户端的远程方法调用和一元 RPC 模式中的非常类似。但是，因为服务器端往流中写入了多个响应，所以这里必须处理多个响应。因此，我们在 gRPC 客户端的 Go 语言实现中使用 &lt;code&gt;Recv&lt;/code&gt; 方法从客户端流中检索消息，并且持续检索，直到流结束为止，如代码清单6 所示。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;代码清单6&lt;/span&gt;　使用 Go 语言编写的 &lt;code&gt;SearchOrders&lt;/code&gt; 方法的 &lt;code&gt;OrderManagement&lt;/code&gt; 客户端实现&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;p&gt;// 建立到服务器端的连接&lt;/p&gt;&lt;p&gt;...&lt;/p&gt;&lt;p&gt;        c := pb.NewOrderManagementClient(conn)&lt;/p&gt;&lt;p&gt;...&lt;/p&gt;&lt;p&gt;     searchStream, _ := c.SearchOrders(ctx,&lt;/p&gt;&lt;p&gt;        &amp;amp;wrapper.StringValue{Value: &quot;Google&quot;}) ➊&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;        for {&lt;/p&gt;&lt;p&gt;                searchOrder, err := searchStream.Recv() ➋&lt;/p&gt;&lt;p&gt;                if err == io.EOF { ➌&lt;/p&gt;&lt;p&gt;                        break&lt;/p&gt;&lt;p&gt;                }&lt;/p&gt;&lt;p&gt;        // 处理可能出现的错误&lt;/p&gt;&lt;p&gt;                log.Print(&quot;Search Result : &quot;, searchOrder)&lt;/p&gt;&lt;p&gt;     }&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;❶ &lt;code&gt;SearchOrders&lt;/code&gt; 方法返回 &lt;code&gt;OrderManagement_SearchOrdersClient&lt;/code&gt; 的客户端流，它有一个名为 &lt;code&gt;Recv&lt;/code&gt; 的方法。&lt;/p&gt;&lt;p&gt;❷ 调用客户端流的 &lt;code&gt;Recv&lt;/code&gt; 方法，逐个检索 &lt;code&gt;Order&lt;/code&gt; 响应。&lt;/p&gt;&lt;p&gt;❸ 当发现流结束的时候，&lt;code&gt;Recv&lt;/code&gt; 会返回 &lt;code&gt;io.EOF&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;下面看一下客户端流 RPC 模式，它恰好与服务器端流 RPC 模式相反。&lt;/p&gt;&lt;h2&gt;3. 客户端流RPC模式&lt;/h2&gt;&lt;p&gt;在客户端流 RPC 模式中，客户端会发送多个请求给服务器端，而不再是单个请求。服务器端则会发送一个响应给客户端。但是，服务器端不一定要等到从客户端接收到所有消息后才发送响应。基于这样的逻辑，我们可以在接收到流中的一条消息或几条消息之后就发送响应，也可以在读取完流中的所有消息之后再发送响应。&lt;/p&gt;&lt;p&gt;现在进一步扩展 &lt;code&gt;OrderManagement&lt;/code&gt; 服务，从而更好地理解客户端流 RPC 模式。假设希望在 &lt;code&gt;OrderManagement&lt;/code&gt; 服务中添加新的 &lt;code&gt;updateOrders&lt;/code&gt; 方法，从而更新一个订单集合，如图3 所示。在这里，我们想以消息流的形式发送订单列表到服务器端，服务器端会处理这个流并发送一条带有已更新订单状态的消息给客户端。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/riafuBXuN2hrcssibTO5WbZ6iaMP9HULQO6kF4TRPDxjNsDsbficxtoBSaVmSU4oLIBRgguegmFcSzzWHBf7jMd43A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1326&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3：客户端流 RPC 模式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;然后，可以将 &lt;code&gt;updateOrders&lt;/code&gt; 方法添加到 &lt;code&gt;OrderManagement&lt;/code&gt; 服务的服务定义文件中，如代码清单7 所示。只需使用 &lt;code&gt;stream Order&lt;/code&gt; 作为 &lt;code&gt;updateOrders&lt;/code&gt; 方法的参数，就能表明 &lt;code&gt;updateOrders&lt;/code&gt; 会接收来自客户端的多条消息作为输入。因为服务器端只发送一个响应，所以返回值是单一的字符串消息。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;代码清单7&lt;/span&gt;　具有客户端流 RPC 功能的服务定义&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;p&gt;syntax = &quot;proto3&quot;;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;import &quot;google/protobuf/wrappers.proto&quot;;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;package ecommerce;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;service OrderManagement {&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;...&lt;/p&gt;&lt;p&gt;    rpc updateOrders(stream Order) returns (google.protobuf.StringValue);&lt;/p&gt;&lt;p&gt;...&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;message Order {&lt;/p&gt;&lt;p&gt;    string id = 1;&lt;/p&gt;&lt;p&gt;    repeated string items = 2;&lt;/p&gt;&lt;p&gt;    string description = 3;&lt;/p&gt;&lt;p&gt;    float price = 4;&lt;/p&gt;&lt;p&gt;    string destination = 5;&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;当更新完服务定义文件之后，就可以生成服务器端和客户端的代码了。在服务器端，需要实现 &lt;code&gt;OrderManagement&lt;/code&gt; 服务中所生成的 &lt;code&gt;updateOrders&lt;/code&gt; 方法接口。在代码清单8 所示的 Go 实现中，&lt;code&gt;UpdateOrders&lt;/code&gt; 方法有一个 &lt;code&gt;OrderManagement_UpdateOrdersServer&lt;/code&gt; 参数，它是客户端传入消息流的引用对象。因此，可以通过调用该对象的 &lt;code&gt;Recv&lt;/code&gt; 方法来读取消息。根据业务逻辑，可以读取其中一些消息，也可以读取所有的消息。服务只需调用 &lt;code&gt;OrderManagement_UpdateOrdersServer&lt;/code&gt; 对象的 &lt;code&gt;SendAndClose&lt;/code&gt; 方法就可以发送响应，它同时也标记服务器端消息终结了流。如果要提前停止读取客户端流，那么服务器端应该取消客户端流，这样客户端就知道停止生成消息了。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;代码清单8&lt;/span&gt;　使用 Go 语言编写的 &lt;code&gt;UpdateOrders&lt;/code&gt; 方法的 &lt;code&gt;OrderManagement&lt;/code&gt; 服务实现&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;p&gt;func (s *server) UpdateOrders(stream pb.OrderManagement_UpdateOrdersServer) error {&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;        ordersStr := &quot;Updated Order IDs : &quot;&lt;/p&gt;&lt;p&gt;        for {&lt;/p&gt;&lt;p&gt;                order, err := stream.Recv() ➊&lt;/p&gt;&lt;p&gt;                if err == io.EOF { ➋&lt;/p&gt;&lt;p&gt;                        // 完成读取订单流&lt;/p&gt;&lt;p&gt;                        return stream.SendAndClose(&lt;/p&gt;&lt;p&gt;                                &amp;amp;wrapper.StringValue{Value: &quot;Orders processed &quot;&lt;/p&gt;&lt;p&gt;                                + ordersStr})&lt;/p&gt;&lt;p&gt;                 }&lt;/p&gt;&lt;p&gt;                 // 更新订单&lt;/p&gt;&lt;p&gt;                 orderMap[order.Id] = *order&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;                 log.Printf(&quot;Order ID &quot;, order.Id, &quot;: Updated&quot;)&lt;/p&gt;&lt;p&gt;                 ordersStr += order.Id + &quot;, &quot;&lt;/p&gt;&lt;p&gt;        }&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;❶ 从客户端流中读取消息。&lt;/p&gt;&lt;p&gt;❷ 检查流是否已经结束。&lt;/p&gt;&lt;p&gt;下面来看这个客户端流用例的客户端实现。如代码清单9 中的 Go 实现所示，客户端可以通过客户端流引用，借助 &lt;code&gt;updateStream.Send&lt;/code&gt; 方法发送多条消息。一旦所有消息都以流的形式发送出去，客户端就可以将流标记为已完成，并接收来自服务器端的响应。这是通过流引用的 &lt;code&gt;CloseAndRecv&lt;/code&gt; 方法实现的。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;代码清单9&lt;/span&gt;　使用 Go 语言编写的 &lt;code&gt;UpdateOrders&lt;/code&gt; 方法的 &lt;code&gt;OrderManagement&lt;/code&gt; 客户端实现&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;p&gt;// 建立到服务器端的连接&lt;/p&gt;&lt;p&gt;...&lt;/p&gt;&lt;p&gt;        c := pb.NewOrderManagementClient(conn)&lt;/p&gt;&lt;p&gt;...&lt;/p&gt;&lt;p&gt;updateStream, err := client.UpdateOrders(ctx) ➊&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;   if err != nil { ➋&lt;/p&gt;&lt;p&gt;           log.Fatalf(&quot;%v.UpdateOrders(_) = _, %v&quot;, client, err)&lt;/p&gt;&lt;p&gt;   }&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;   // 更新订单1&lt;/p&gt;&lt;p&gt;   if err := updateStream.Send(&amp;amp;updOrder1); err != nil { ➌&lt;/p&gt;&lt;p&gt;           log.Fatalf(&quot;%v.Send(%v) = %v&quot;,&lt;/p&gt;&lt;p&gt;                   updateStream, updOrder1, err) ➍&lt;/p&gt;&lt;p&gt;   }&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;   // 更新订单2&lt;/p&gt;&lt;p&gt;   if err := updateStream.Send(&amp;amp;updOrder2); err != nil {&lt;/p&gt;&lt;p&gt;           log.Fatalf(&quot;%v.Send(%v) = %v&quot;,&lt;/p&gt;&lt;p&gt;                   updateStream, updOrder2, err)&lt;/p&gt;&lt;p&gt;   }&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;   // 更新订单3&lt;/p&gt;&lt;p&gt;   if err := updateStream.Send(&amp;amp;updOrder3); err != nil {&lt;/p&gt;&lt;p&gt;           log.Fatalf(&quot;%v.Send(%v) = %v&quot;,&lt;/p&gt;&lt;p&gt;                   updateStream, updOrder3, err)&lt;/p&gt;&lt;p&gt;   }&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;   updateRes, err := updateStream.CloseAndRecv() ➎&lt;/p&gt;&lt;p&gt;   if err != nil {&lt;/p&gt;&lt;p&gt;           log.Fatalf(&quot;%v.CloseAndRecv() got error %v, want %v&quot;,&lt;/p&gt;&lt;p&gt;                   updateStream, err, nil)&lt;/p&gt;&lt;p&gt;   }&lt;/p&gt;&lt;p&gt;   log.Printf(&quot;Update Orders Res : %s&quot;, updateRes)&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;❶ 调用 &lt;code&gt;UpdateOrders&lt;/code&gt; 远程方法。&lt;/p&gt;&lt;p&gt;❷ 处理与 &lt;code&gt;UpdateOrders&lt;/code&gt; 相关的错误。&lt;/p&gt;&lt;p&gt;❸ 通过客户端流发送订单更新的请求。&lt;/p&gt;&lt;p&gt;❹ 处理在发送消息到流时发生的错误。&lt;/p&gt;&lt;p&gt;❺ 关闭流并接收响应。&lt;/p&gt;&lt;p&gt;当调用这个方法后，会收到服务的响应消息。现在，我们对服务器端流 RPC 模式和客户端流 RPC 模式都有了非常好的了解。接下来将介绍双向流 RPC 模式，它是前面讨论的不同 RPC 风格的一种组合。&lt;/p&gt;&lt;h2&gt;4. 双向流RPC模式&lt;/h2&gt;&lt;p&gt;在双向流 RPC 模式中，客户端以消息流的形式发送请求到服务器端，服务器端也以消息流的形式进行响应。调用必须由客户端发起，但在此之后，通信完全基于 gRPC 客户端和服务器端的应用程序逻辑。下面通过一个示例来进一步了解双向流 RPC 模式。如图4 所示，在 &lt;code&gt;OrderManagement&lt;/code&gt; 服务用例中，假设需要一个订单处理功能，通过该功能，用户可以发送连续的订单集合（订单流），并根据投递地址对它们进行组合发货，也就是说，订单要根据投递目的地进行组织和发货。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3574660633484163&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/riafuBXuN2hrcssibTO5WbZ6iaMP9HULQO6c2pRRlvemY4eBWY0ZZebyq3k7Qh79jEn2ichftKGhbrIiccwKGL2Ldaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1326&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4：双向流 RPC 模式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;可以看到，这个业务用例的关键步骤如下所示。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;客户端应用程序通过建立与服务器端的连接并发送调用元数据（头信息）初始化业务用例。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;一旦连接成功建立，客户端应用程序就发送连续的订单 ID 集合，这些订单需要由 &lt;code&gt;OrderManagement&lt;/code&gt; 服务进行处理。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每个订单 ID 以独立的 gRPC 消息的形式发送至服务器端。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;服务会处理给定订单 ID 所对应的每个订单，并根据订单的投递位置将它们组织到发货组合中。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每个发货组合可能会包含多个订单，它们应该被投递到相同的目的地。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;订单是成批处理的。当达到指定的批次大小时，当前创建的所有发货组合都会被发送至客户端。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;假设流中有 4 个订单，其中有 2 个订单要发送至位置 &lt;code&gt;X&lt;/code&gt;，另外两个要发送至位置 &lt;code&gt;Y&lt;/code&gt;，则可以将其表示为 &lt;code&gt;X&lt;/code&gt;、&lt;code&gt;Y&lt;/code&gt;、&lt;code&gt;X&lt;/code&gt;、&lt;code&gt;Y&lt;/code&gt;。如果批次大小为 3，那么所创建的订单发货组合会是 &lt;code&gt;[X, X]&lt;/code&gt;、&lt;code&gt;[Y]&lt;/code&gt; 和 &lt;code&gt;[Y]&lt;/code&gt;。这些发货组合也会以流的形式发送至客户端。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这个业务用例的核心理念就是一旦调用 RPC 方法，那么无论是客户端还是服务器端，都可以在任意时间发送消息。这也包括来自任意一端的流结束标记。&lt;/p&gt;&lt;p&gt;下面看一下上述用例的服务定义。如代码清单10 所示，可以定义一个 &lt;code&gt;processOrders&lt;/code&gt; 方法，该方法接受一个字符串流作为方法参数，代表了订单流 ID 并且以 &lt;code&gt;CombinedShipment&lt;/code&gt; 流作为方法的返回值。因此，通过将方法参数和返回参数均声明为 &lt;code&gt;stream&lt;/code&gt;，可以定义双向流的 RPC 方法。发货组合的消息也是通过服务定义声明的，它包含了订单元素的列表。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;代码清单10&lt;/span&gt;　具有双向流 RPC 功能的服务定义&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;p&gt;syntax = &quot;proto3&quot;;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;import &quot;google/protobuf/wrappers.proto&quot;;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;package ecommerce;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;service OrderManagement {&lt;/p&gt;&lt;p&gt;    ...&lt;/p&gt;&lt;p&gt;    rpc processOrders(stream google.protobuf.StringValue)&lt;/p&gt;&lt;p&gt;        returns (stream CombinedShipment); ➊&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;message Order { ➋&lt;/p&gt;&lt;p&gt;    string id = 1;&lt;/p&gt;&lt;p&gt;    repeated string items = 2;&lt;/p&gt;&lt;p&gt;    string description = 3;&lt;/p&gt;&lt;p&gt;    float price = 4;&lt;/p&gt;&lt;p&gt;    string destination = 5;&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;message CombinedShipment { ➌&lt;/p&gt;&lt;p&gt;    string id = 1;&lt;/p&gt;&lt;p&gt;    string status = 2;&lt;/p&gt;&lt;p&gt;    repeated Order ordersList = 3;&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;❶ 在双向流 RPC 模式中，将方法参数和返回参数均声明为 &lt;code&gt;stream&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;❷ &lt;code&gt;Order&lt;/code&gt; 消息的结构。&lt;/p&gt;&lt;p&gt;❸ &lt;code&gt;CombinedShipment&lt;/code&gt; 消息的结构。&lt;/p&gt;&lt;p&gt;接下来，就可以根据更新后的服务定义生成服务器端的代码了。服务应该实现 &lt;code&gt;OrderManagement&lt;/code&gt; 服务中的 &lt;code&gt;processOrders&lt;/code&gt; 方法。如代码清单11 所示，在 Go 实现中，&lt;code&gt;ProcessOrders&lt;/code&gt; 方法有一个 &lt;code&gt;OrderManagement_ProcessOrdersServer&lt;/code&gt; 参数，它是客户端和服务器端之间消息流的对象引用。借助这个流对象，服务器端可以读取客户端以流的方式发送的消息，也能写入服务器端的流消息并返回给客户端。传入的消息流可以通过该引用对象的 &lt;code&gt;Recv&lt;/code&gt; 方法来读取。在 &lt;code&gt;ProcessOrders&lt;/code&gt; 方法中，服务可在持续读取传入消息流的同时，使用 &lt;code&gt;Send&lt;/code&gt; 方法将消息写入同一个流中。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;代码清单11&lt;/span&gt;　使用 Go 语言编写的 &lt;code&gt;ProcessOrders&lt;/code&gt; 方法的 &lt;code&gt;OrderManagement&lt;/code&gt; 服务实现&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;p&gt;func (s *server) ProcessOrders(&lt;/p&gt;&lt;p&gt;        stream pb.OrderManagement_ProcessOrdersServer) error {&lt;/p&gt;&lt;p&gt;        ...&lt;/p&gt;&lt;p&gt;        for {&lt;/p&gt;&lt;p&gt;                orderId, err := stream.Recv() ➊&lt;/p&gt;&lt;p&gt;                if err == io.EOF { ➋&lt;/p&gt;&lt;p&gt;                        ...&lt;/p&gt;&lt;p&gt;                        for _, comb := range combinedShipmentMap {&lt;/p&gt;&lt;p&gt;                                stream.Send(&amp;amp;comb) ➌&lt;/p&gt;&lt;p&gt;                        }&lt;/p&gt;&lt;p&gt;                        return nil                ➍&lt;/p&gt;&lt;p&gt;                }&lt;/p&gt;&lt;p&gt;                if err != nil {&lt;/p&gt;&lt;p&gt;                        return err&lt;/p&gt;&lt;p&gt;                }&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;                // 基于目的地位置，&lt;/p&gt;&lt;p&gt;                // 将订单组织到发货组合中的逻辑&lt;/p&gt;&lt;p&gt;                ...&lt;/p&gt;&lt;p&gt;                //&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;                if batchMarker == orderBatchSize { ➎&lt;/p&gt;&lt;p&gt;                        // 将组合后的订单以流的形式分批发送至客户端&lt;/p&gt;&lt;p&gt;                        for _, comb := range combinedShipmentMap {&lt;/p&gt;&lt;p&gt;                                // 将发货组合发送到客户端&lt;/p&gt;&lt;p&gt;                                stream.Send(&amp;amp;comb)     ➏&lt;/p&gt;&lt;p&gt;                        }&lt;/p&gt;&lt;p&gt;                        batchMarker = 0&lt;/p&gt;&lt;p&gt;                        combinedShipmentMap = make(&lt;/p&gt;&lt;p&gt;                                map[string]pb.CombinedShipment)&lt;/p&gt;&lt;p&gt;                } else {&lt;/p&gt;&lt;p&gt;                        batchMarker++&lt;/p&gt;&lt;p&gt;                }&lt;/p&gt;&lt;p&gt;        }&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;❶ 从传入的流中读取订单 ID。&lt;/p&gt;&lt;p&gt;❷ 持续读取，直到流结束为止。&lt;/p&gt;&lt;p&gt;❸ 当流结束时，将所有剩余的发货组合发送给客户端。&lt;/p&gt;&lt;p&gt;❹ 通过返回 &lt;code&gt;nil&lt;/code&gt; 标记服务器端流已经结束。&lt;/p&gt;&lt;p&gt;❺ 按批次处理订单。当达到该批次的规模时，将所有已创建的发货组合以流的形式发送给客户端。&lt;/p&gt;&lt;p&gt;❻ 将发货组合写入流中。&lt;/p&gt;&lt;p&gt;这里是基于订单 ID 来处理传入的订单的，当创建新的发货组合后，服务会将其写入相同的流中。这与客户端流 RPC 模式不同，当时服务通过 &lt;code&gt;SendAndClose&lt;/code&gt; 方法写入流并将其关闭。当发现客户端流已经结束时，发送 &lt;code&gt;nil&lt;/code&gt; 标记服务器端流的结束。&lt;/p&gt;&lt;p&gt;如代码清单12 所示，客户端实现与之前的示例非常相似。当客户端通过 &lt;code&gt;OrderManagement&lt;/code&gt; 对象调用 &lt;code&gt;ProcessOrders&lt;/code&gt; 方法时，它会得到一个对流的引用（&lt;code&gt;streamProcOrder&lt;/code&gt;），这个引用可以用来发送消息到服务器端，也能读取来自服务器端的消息。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;代码清单12&lt;/span&gt;　使用 Go 语言编写的 &lt;code&gt;ProcessOrders&lt;/code&gt; 方法的 &lt;code&gt;OrderManagement&lt;/code&gt; 客户端实现&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;p&gt;// 处理订单&lt;/p&gt;&lt;p&gt;streamProcOrder, _ := c.ProcessOrders(ctx) ➊&lt;/p&gt;&lt;p&gt;        if err := streamProcOrder.Send(&lt;/p&gt;&lt;p&gt;                &amp;amp;wrapper.StringValue{Value:&quot;102&quot;}); err != nil { ➋&lt;/p&gt;&lt;p&gt;                log.Fatalf(&quot;%v.Send(%v) = %v&quot;, client, &quot;102&quot;, err)&lt;/p&gt;&lt;p&gt;        }&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;        if err := streamProcOrder.Send(&lt;/p&gt;&lt;p&gt;                &amp;amp;wrapper.StringValue{Value:&quot;103&quot;}); err != nil {&lt;/p&gt;&lt;p&gt;                log.Fatalf(&quot;%v.Send(%v) = %v&quot;, client, &quot;103&quot;, err)&lt;/p&gt;&lt;p&gt;        }&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;        if err := streamProcOrder.Send(&lt;/p&gt;&lt;p&gt;                &amp;amp;wrapper.StringValue{Value:&quot;104&quot;}); err != nil {&lt;/p&gt;&lt;p&gt;                log.Fatalf(&quot;%v.Send(%v) = %v&quot;, client, &quot;104&quot;, err)&lt;/p&gt;&lt;p&gt;        }&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;        channel := make(chan struct{}) ➌&lt;/p&gt;&lt;p&gt;    go asncClientBidirectionalRPC(streamProcOrder, channel) ➍&lt;/p&gt;&lt;p&gt;    time.Sleep(time.Millisecond * 1000) ➎&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;        if err := streamProcOrder.Send(&lt;/p&gt;&lt;p&gt;                &amp;amp;wrapper.StringValue{Value:&quot;101&quot;}); err != nil {&lt;/p&gt;&lt;p&gt;                log.Fatalf(&quot;%v.Send(%v) = %v&quot;, client, &quot;101&quot;, err)&lt;/p&gt;&lt;p&gt;        }&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;        if err := streamProcOrder.CloseSend(); err != nil { ➏&lt;/p&gt;&lt;p&gt;                log.Fatal(err)&lt;/p&gt;&lt;p&gt;        }&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;lt;- channel&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;func asncClientBidirectionalRPC (&lt;/p&gt;&lt;p&gt;            streamProcOrder pb.OrderManagement_ProcessOrdersClient,&lt;/p&gt;&lt;p&gt;            c chan struct{}) {&lt;/p&gt;&lt;p&gt;        for {&lt;/p&gt;&lt;p&gt;                combinedShipment, errProcOrder := streamProcOrder.Recv() ➐&lt;/p&gt;&lt;p&gt;                if errProcOrder == io.EOF { ➑&lt;/p&gt;&lt;p&gt;                        break&lt;/p&gt;&lt;p&gt;                }&lt;/p&gt;&lt;p&gt;                log.Printf(&quot;Combined shipment : &quot;, combinedShipment.OrdersList)&lt;/p&gt;&lt;p&gt;        }&lt;/p&gt;&lt;p&gt;        &amp;lt;-c&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;❶ 调用远程方法并获取流引用，以便在客户端写入和读取。&lt;/p&gt;&lt;p&gt;❷ 向服务发送消息。&lt;/p&gt;&lt;p&gt;❸ 创建 &lt;code&gt;Goroutines&lt;/code&gt; 所使用的通道。&lt;/p&gt;&lt;p&gt;❹ 使用 &lt;code&gt;Goroutines&lt;/code&gt; 调用函数，以便并行读取来自服务的消息。&lt;/p&gt;&lt;p&gt;❺ 模拟向服务发送消息的延迟。&lt;/p&gt;&lt;p&gt;❻ 为客户端流标记流的结束（订单 ID）。&lt;/p&gt;&lt;p&gt;❼ 在客户端读取服务的消息。&lt;/p&gt;&lt;p&gt;❽ 该条件探测流是否已经结束。&lt;/p&gt;&lt;p&gt;客户端可以在任意时间发送消息给服务并关闭流。读取消息也是同样的道理。前面的示例使用了 Go 语言中的 &lt;code&gt;Goroutines&lt;/code&gt;，在两个并发线程中执行客户端的消息写入逻辑和消息服务逻辑。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.3348264277715565&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/riafuBXuN2hrcssibTO5WbZ6iaMP9HULQO6NelAgibg2fPVphcicObHGJU45TA0u5YnYicV72Kka1Yq4v2NzWzOAiaPicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;893&quot;/&gt;　&lt;span&gt;&lt;code&gt;Goroutines&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在 Go 语言中，&lt;code&gt;Goroutines&lt;/code&gt; 是能够与其他函数或方法并行运行的函数或方法，可以将它们视为轻量级的线程。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;客户端可以并发读取和写入同一个流，输入流和输出流可以独立进行操作。这里所展示的是稍微复杂的示例，它展现了双向流 RPC 模式的威力。流的操作完全独立，客户端和服务器端可以按照任意顺序进行读取和写入，理解这一点非常重要。一旦建立连接，客户端和服务器端之间的通信模式就完全取决于客户端和服务器端本身。&lt;/p&gt;&lt;p&gt;目前我们已经讨论了所有可能的通信模式，可以使用它们实现基于 gRPC 的应用程序之间的交互。至于具体选择哪种通信模式，并没有硬性的规定，但是最好的办法就是分析业务用例，并据此选择最合适的模式。&lt;/p&gt;&lt;p&gt;在结束关于 gRPC 通信模式的讨论之前，还有一个重要的方面需要了解，即 gRPC 是如何应用于微服务通信的。&lt;/p&gt;&lt;h2&gt;5. 使用gRPC实现微服务通信&lt;/h2&gt;&lt;p&gt;gRPC 的主要用途之一就是实现微服务以及服务之间的通信。在微服务的服务间通信中，gRPC 会与其他通信协议一同使用，并且 gRPC 服务通常会实现为多语言服务（由不同的语言实现）。为了进一步理解该技术，下面来看在线零售系统这样一个真实的场景，如图5 所示，它是对前述内容的扩展。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.65832531280077&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/riafuBXuN2hrcssibTO5WbZ6iaMP9HULQO6PKiaMBia6a792WgrOZE6xyCdYkUyHIMxb8ktHVLWqJIk1Cv5E7ibXumNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2078&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图5：使用 gRPC 和其他协议的通用微服务部署模式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;该场景中有许多微服务，每个微服务都面向在线零售系统的特定业务能力。有一些服务的实现形式是 gRPC 服务，如 &lt;code&gt;Product&lt;/code&gt; 服务；另外还有一些组合服务，如 &lt;code&gt;Catalog&lt;/code&gt; 服务，它会调用底层的服务来构建其业务能力。大多数同步消息可以使用 gRPC 来传递。如果有特定的异步消息场景，可能需要持久化消息，那么就可以使用事件代理或消息代理，如 Kafka、Active MQ、RabbitMQ 和 NATS。当需要将特定的业务功能暴露到外部时，可以使用传统的基于 REST 或 OpenAPI 的服务或者 GraphQL 服务。因此，&lt;code&gt;Catalog&lt;/code&gt; 和 &lt;code&gt;Checkout&lt;/code&gt; 等服务消费基于 gRPC 的后端服务，同时暴露基于 REST 或 GraphQL 的外部接口。&lt;/p&gt;&lt;p&gt;在大多数实际用例中，这些面向外部的服务是通过 API 网关暴露的。这里可以应用各种非功能性的能力，如安全性、节流、版本化等。大多数这样的 API 使用像 REST 或 GraphQL 这样的协议，但还有一种可能，这种情况不太常见，那就是只要 API 网关支持暴露 gRPC 接口，gRPC 就可以作为对外的接口。API 网关实现了横切性的功能，如认证、日志、版本化、节流和负载均衡。通过组合使用 API 网关与 gRPC API，可以将这些功能部署到核心 gRPC 服务之外。这种架构还有另外一个重要方面，那就是可以使用多种编程语言，但共享相同的服务契约，比如通过相同的 gRPC 服务定义来生成代码。这样一来，便可以根据服务的业务能力来选择适当的实现技术。&lt;/p&gt;&lt;h2&gt;6. 小结&lt;/h2&gt;&lt;p&gt;gRPC 提供了一组不同的 RPC 通信风格，用于在基于 gRPC 的应用程序之间构建进程间通信。本文探讨了 4 种主要的通信模式，其中一元 RPC 模式是最基本的一种模式，它是一种非常简单的请求–响应式 RPC；服务器端流 RPC 模式可以在第一次调用远程方法后从服务向消费者发送多条消息；客户端流 RPC 模式可以从客户端向服务发送多条消息；双向流 RPC 模式有一点复杂，其中流的操作是完全独立的，客户端和服务器端可以按照任意顺序进行读取和写入。另外，本文深入研究了如何通过一些真实的用例来实现这些模式。&lt;/p&gt;&lt;p&gt;本文内容对实现任何 gRPC 用例都非常有用，你可以根据实际情况选择最合适的通信模式。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;7. 新书推荐&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;本文引自《 gRPC与云原生应用开发：以Go和Java为例》，刚上架的新书，欢迎有需要的朋友关注。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.5733333333333333&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;600&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/riafuBXuN2ho8Hribw6biaGFfwVs23B3ibk4SFVeB0t7HzQNg0xed0uXytVuIFH2MLKOQ9KAv2icicibJUNuDaVOrGxVA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;8. 留言福利&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小伙伴们，今天是开工第一天，请大家来聊聊开工后最想读的书是哪一本，理由是什么？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;留言告诉我们，随机选取 3 位读者，可从图灵 2021 年出版的新书中任选一本，作为你的开工礼物。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;统计截止时间：2021 年 2 月 22 日 12：00。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;图 灵 社 群&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.38248337028824836&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;902&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/riafuBXuN2hp0zZiaATs03SXyiazbWvib91XJvU5LRCfVxc3uYX6dsh74FtP5QtkRMnwBneJD1AWGiaTYHSiaYF6hp2w/640?wx_fmt=png&quot;/&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2222222222222222&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;900&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/riafuBXuN2hokWPAAOxh38PFianicYLkjmIK9BSciaeDvzbbl3RcEumDAjpMJEqljN3NTbIuiaEwnRr1JpadGlOmHrw/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9333333333333333&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;180&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/riafuBXuN2hoDbHDiaq3MURo3oAkfX8uRnzgvriaS0eREu0RU09ficjxDOjEc3eaPYVXakr0mMVEviciac15CibKXcztw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;点个&lt;/span&gt;&lt;strong&gt;&lt;span&gt;「在看」&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dfacfb5943ad5fad6e5a95c65bea23db</guid>
<title>哲少荐书：鞋狗</title>
<link>https://toutiao.io/k/nxf9osw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很久没来荐书了，主要原因是最近读到的值得推荐的书比较少（其实是偷懒了，读书少了）。还好春节假期来临，也趁着难得的假期时间读完了一本书——《鞋狗》。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一本读完就想要推荐给大家的书（没错，我就是刚刚读完就来推荐了）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提到《鞋狗》相信还有些朋友不太熟悉，但是提到耐克，相信大家一定都知道。即使没有买过耐克的东西，也一定在商场看到过耐克的线下门店。而《鞋狗》这本书就是耐克的创始人菲尔·奈特的亲笔自传。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这本书讲述了耐克“从0到1”的过程，书中讲述了菲尔·奈特在面对合作伙伴背叛，开户行的翻脸，权利的压迫等问题时是如何应对并化解难题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中的一些思考与想法对生活和工作都会有所帮助。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面照例聊几点书中令我印象比较深刻的内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一点是在耐克创立时，奈特说的一句话：“懦夫从不启程，弱者死于路中，只剩我们前行。”没错，这是一句鸡汤，但是人在低谷的时候往往需要这样的鸡汤。在前一段时间我几乎已经变成了一个弱者，被各种事情所困扰，逐渐停下脚步，停留在舒适区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也正是这句鸡汤，让我想要重新开始自己之前坚持的一些事情，比如写作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我想要变成强者，我需要不断前行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提到坚持，书中的一位重要人物非常好的诠释了什么是坚持，他就是耐克（最开始叫蓝带）的第一名正式员工，杰夫·约翰逊（Jeff Johnson）。在处理一些具体问题时（销售或设计等），我认为他的作用要高于奈特。作为耐克的第一名正式员工，他把自己的全部精力投入到了工作中，即使面对家庭变故，遭遇车祸，他也依然保持着对工作的热情，他在坚持做着自己认为有意义的事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然老板总是对他爱答不理，但是他却从未放弃。耐克的成功离不开奈特，更加离不开约翰逊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创业的路上也需要一名这样有着无限精力的伙伴，他能帮你处理很多杂事，从而让你的精力聚焦到一些更加重要的问题上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三点要提到的就是奈特的一些管理方法。其中令我印象比较深刻的是一次经典的“运营反转”。奈特发现自己有两名员工被放到了错误的岗位上，因此当机立断，给他们的岗位进行了调换。这是一种非常大胆的举措，因为两人在各自的岗位上都扮演着非常重要的角色，他们并不熟悉彼此的工作，甚至不了解彼此的工作环境。在这样的情况下直接让两人调换岗位，难免会引起员工的不满，甚至会影响公司的发展。但是奈特做决定时却没有什么犹豫。发现问题就立即想办法解决，这就是他的风格，我认为也是耐克的风格（Just do it）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把员工安排在正确的岗位上，这也是一名管理者需要做到的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于这本书大概先介绍这么多，如果你也是耐克的粉丝，或者你对耐克的创办历史比较感兴趣，都可以来读一读这本书。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;喜欢电子书的同学可以直接到微信读书搜索&lt;strong&gt;「鞋狗」&lt;/strong&gt;，想要实体书的同学可以通过点击原文链接来进行购买。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>