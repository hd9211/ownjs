<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3ca34d4329b4a3246ca681130982e124</guid>
<title>一款前端性能监控系统</title>
<link>https://toutiao.io/k/r0ghwnu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;大家好，我是周刊菌。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Njk2NDAzMA==&amp;amp;mid=2660215615&amp;amp;idx=2&amp;amp;sn=844e0251c92fa230434af84b6e49d5d9&amp;amp;chksm=84bba96eb3cc2078f8bf59ced9b7909530f69cb94e8c5405f7d05fb731e4711b7362bdf7b6c0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;加入「码农周刊VIP会员」，一起牛起来！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1014&quot; data-ratio=&quot;1.512&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/t8lpVibticjQ5akDVbyFRcrK98pUqmWkBP3UyVjfABXJ8IMtbjJpPheS8YXJia8nUP5WhOtib1dEUaBD4lOfZjs1Pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;34&quot; data-cropselx2=&quot;356&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;425&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ6h6x4EnYInRLic6PibFNWw4zSv28rAxcJu9dumVJF03PwHGOWxOzeJKIsydVa7UJuTo4jOjrct9NZw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>796d9392b2ae1d4250f31d460e843428</guid>
<title>Android 性能优化：从卡顿和 ANR 来彻底理解内存泄露原理和优化</title>
<link>https://toutiao.io/k/dje4uo8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;JAVA程序，因为有垃圾回收机制，应该没有内存泄露。我们已经知道了，如果某个对象，从根节点可到达，也就是存在从根节点到该对象的引用链，那么该对象是不会被 GC 回收的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果说这个对象已经不会再被使用到了，是无用的，我们依然持有他的引用的话，就会造成内存泄漏，例如 一个长期在后台运行的线程持有 Activity 的引用，这个时 候 Activity 执行了 onDestroy 方法，那么这个 Activity 就是从根节点可到达并且无用的对象， 这个 Activity 对象就是泄漏的对象，给这个对象分配的内存将无法被回收。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果我们的java运行很久,而这种内存泄露不断的发生，最后就没内存可用了。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当然java的，内存泄漏和C/C++是不一样的。如果java程序完全结束后，它所有的对象就都不可达了，系统就可以对他们进行垃圾回收，它的内存泄露仅仅限于它本身，而不会影响整个系统的。C/C++的内存泄露就比较糟糕了，它的内存泄露是系统级，即使该C/C++程序退出，它的泄露的内存也无法被系统回收，永远不可用了，除非重启机器。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;我们这篇文章就开始对Android内存泄露进行总结；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、Android内存泄露介绍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、什么是内存泄露？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;内存泄漏缺陷具有隐蔽性、积累性的特征，比其他内存非法访问错误更难检测。因为内存泄漏的产生原因是内存块未被释放，属于遗漏型缺陷而不是过错型缺陷。此外，内存泄漏通常不会直接产生可观察的错误症状，而是逐渐积累，降低系统整体性能，极端的情况下可能使系统崩溃；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Android的一个应用程序的内存泄露对别的应用程序影响不大。为了能够使得Android应用程序安全且快速的运行，Android的每个应用程序都会使用一个专有的Dalvik虚拟机实例来运行，它是由Zygote服务进程孵化出来的，也就是说每个应用程序都是在属于自己的进程中运行的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Android为不同类型的进程分配了不同的内存使用上限，如果程序在运行过程中出现了内存泄漏的而造成应用进程使用的内存超过了这个上限，则会被系统视为内存泄漏，从而被kill掉，这使得仅仅自己的进程被kill掉，而不会影响其他进程（如果是system_process等系统进程出问题的话，则会引起系统重启）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、内存泄露的危害&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;用户对单次的内存泄漏并没有什么感知，但是当泄漏积累到内存都被消耗完，就会导致卡顿，甚至崩溃；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;gc回收频繁 造成应用卡顿ANR：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当内存不足的时候,gc会主动回收没用的内存.但是,内存回收也是需要时间的.&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;内存回收和gc回收垃圾资源之间高频率交替的执行.就会产生内存抖动.&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;很多数据就会污染内存堆，马上就会有许多GCs启动，由于这一额外的内存压力，也会产生突然增加的运算造成卡顿现象，&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;任何线程的任何操作都会需要暂停，等待GC操作完成之后，其他操作才能够继续运行,所以垃圾回收运行的次数越少，对性能的影响就越少；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、内存泄漏的原因&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;①内存空间使用完毕后没有被回收，就会导致内存泄漏。虽然Java有垃圾回收机制，但是Java中任然存在很多造成内存泄漏的代码逻辑，垃圾回收器会回收掉大部分的内存空间，&lt;/span&gt;&lt;span&gt;但是有一些内存空间还保持着引用，但是在逻辑上已经不会再用到的对象，这时候垃圾回收器就很无能为力，不能回收它们，比如：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;span&gt;②Android（Java）平台的内存泄漏是指没用的对象资源与GC Roots之间保持可达路径，导致系统无法进行回收；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6013363028953229&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kyDL16ViavhFpiafRZPpfGqjDkYQ2VCRjHERrPNDHicPnxUE1bRYYxhXjYtPPKmP4G4jxqZTGNhFzMej1ae3fhUFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;898&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6347826086956522&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kyDL16ViavhFpiafRZPpfGqjDkYQ2VCRjHemMMOXfuCV5rdibtvdwlpLahicOw0bSLtwZhkgaasGQGAQRVofkPibZ1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;920&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;③那么从栈中弹出的对象将不会被当作垃圾回收，即使程序不再使用栈中的这些队象，他们也不会回收，因为栈中仍然保存这对象的引用，俗称过期引用，这个内存泄露很隐蔽；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、检测内存泄露检测工具 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;①Memory Monitor&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6206415620641562&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kyDL16ViavhFpiafRZPpfGqjDkYQ2VCRjHkWlmsFsFcouu0Xiak74tVmaNapDoE6n9prqQO4YdP6tW2Vug70YPTGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;717&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;位于 Android Monitor 中，该工具可以：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;方便的显示内存使用和 GC 情况&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;快速定位卡顿是否和 GC 有关&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;快速定位 Crash 是否和内存占用过高有关&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;快速定位潜在的内存泄露问题（内存占用一直在增长）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;但是不能准确的定位问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;②Allocation Tracker&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该工具用途：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以定位代码中分配的对象类型、大小、时间、线程、堆栈等信息&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以定位内存抖动问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;配合 Heap Viewer 定位内存泄露问题（可以找出来泄露的对象是在哪创建的等等）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;使用方法：在 Memory Monitor 中有个 Start Allocation Tracking 按钮即可开始跟踪 在点击停止跟踪后会显示统计结果。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;③Heap Viewer&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该工具用于：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;④LeakCanary&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;dependencies {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  debugImplementation &#x27;com.squareup.leakcanary:leakcanary-android:1.6.3&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  releaseImplementation &#x27;com.squareup.leakcanary:leakcanary-android-no-op:1.6.3&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  // Optional, if you use support library fragments:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  debugImplementation &#x27;com.squareup.leakcanary:leakcanary-support-fragment:1.6.3&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;直接在Application中使用，然后运行APP就会自动检测，检测到会在另一个APP上通知，显示详情&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class ExampleApplication extends Application {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  @Override public void onCreate() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    super.onCreate();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (LeakCanary.isInAnalyzerProcess(this)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      // This process is dedicated to LeakCanary for heap analysis.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      // You should not init your app in this process.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      return;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    LeakCanary.install(this);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // Normal app init code...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、常见的内存泄露场景详解&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.单例导致内存泄露&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;单例模式在Android开发中会经常用到，但是如果使用不当就会导致内存泄露。因为单例的静态特性使得它的生命周期同应用的生命周期一样长，如果一个对象已经没有用处了，但是单例还持有它的引用，那么在整个应用程序的生命周期它都不能正常被回收，从而导致内存泄露。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class AppSettings {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    private static volatile AppSettings singleton;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    private Context mContext;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    private AppSettings(Context context) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        this.mContext = context;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public static AppSettings getInstance(Context context) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        if (singleton == null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            synchronized (AppSettings.class) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (singleton == null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    singleton = new AppSettings(context);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        return singleton;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;像上面代码中这样的单例，如果我们在调用getInstance(Context context)方法的时候传入的context参数是Activity、Service等上下文，就会导致内存泄露。以Activity为例，当我们启动一个Activity，并调用getInstance(Context context)方法去获取AppSettings的单例，传入Activity.this作为context，这样AppSettings类的单例sInstance就持有了Activity的引用，当我们退出Activity时，该Activity就没有用了，但是因为sIntance作为静态单例（在应用程序的整个生命周期中存在）会继续持有这个Activity的引用，导致这个Activity对象无法被回收释放，这就造成了内存泄露。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了避免这样单例导致内存泄露，我们可以将context参数改为全局的上下文：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;private AppSettings(Context context) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        this.mContext = context.getApplicationContext();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.静态变量导致内存泄漏&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;静态变量存储在方法区，它的生命周期从类加载开始，到整个进程结束。一旦静态变量初始化后，它所持有的引用只有等到进程结束才会释放。比如下面这样的情况，在Activity中为了避免重复的创建info，将sInfo作为静态变量：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class MainActivity2 extends AppCompatActivity {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public static Info sInfo;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    protected void onCreate(Bundle savedInstanceState) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        super.onCreate(savedInstanceState);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        sInfo = new Info(this);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    class Info {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        private Context mContext;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        public Info(Context context) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            this.mContext = context;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Info作为Activity的静态成员，并且持有Activity的引用，但是sInfo作为静态变量，生命周期肯定比Activity长。所以当Activity退出后，sInfo仍然引用了Activity，Activity不能被回收，这就导致了内存泄露。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Android开发中，静态持有很多时候都有可能因为其使用的生命周期不一致而导致内存泄露，所以我们在新建静态持有的变量的时候需要多考虑一下各个成员之间的引用关系，并且尽量少地使用静态持有的变量，以避免发生内存泄露。当然，我们也可以在适当的时候讲静态量重置为null，使其不再持有引用，这样也可以避免内存泄露。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.非静态内部类导致内存泄露&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;非静态内部类（包括匿名内部类）默认就会持有外部类的引用，当非静态内部类对象的生命周期比外部类对象的生命周期长时，就会导致内存泄露。非静态内部类导致的内存泄露在Android开发中有一种典型的场景就是使用Handler，很多开发者在使用Handler是这样写的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class MainActivity2 extends AppCompatActivity {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    protected void onCreate(Bundle savedInstanceState) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        super.onCreate(savedInstanceState);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        start();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    private void start() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Message message = Message.obtain();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        message.what = 1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mHandler.sendMessage(message);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    private Handler mHandler = new Handler() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        public void handleMessage(Message msg) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            super.handleMessage(msg);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            if (msg.what == 1) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                //doNothing&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    };&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也许有人会说，mHandler并未作为静态变量持有Activity引用，生命周期可能不会比Activity长，应该不一定会导致内存泄露呢，显然不是这样的！熟悉Handler消息机制的都知道，mHandler会作为成员变量保存在发送的消息msg中，即msg持有mHandler的引用，而mHandler是Activity的非静态内部类实例，即mHandler持有Activity的引用，那么我们就可以理解为msg间接持有Activity的引用。msg被发送后先放到消息队列MessageQueue中，然后等待Looper的轮询处理（MessageQueue和Looper都是与线程相关联的，MessageQueue是Looper引用的成员变量，而Looper是保存在ThreadLocal中的）。那么当Activity退出后，msg可能仍然存在于消息对列MessageQueue中未处理或者正在处理，那么这样就会导致Activity无法被回收，以致发生Activity的内存泄露。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通常在Android开发中如果要使用内部类，但又要规避内存泄露，一般都会采用静态内部类+弱引用的方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;MyHandler mHandler;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public static class MyHandler extends Handler {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        private WeakReference&amp;lt;Activity&amp;gt; mActivityWeakReference;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        public MyHandler(Activity activity) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mActivityWeakReference = new WeakReference&amp;lt;&amp;gt;(activity);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        public void handleMessage(Message msg) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            super.handleMessage(msg);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;mHandler通过弱引用的方式持有Activity，当GC执行垃圾回收时，遇到Activity就会回收并释放所占据的内存单元。这样就不会发生内存泄露了。上面的做法确实避免了Activity导致的内存泄露，发送的msg不再已经没有持有Activity的引用了，但是msg还是有可能存在消息队列MessageQueue中，所以更好的是在Activity销毁时就将mHandler的回调和发送的消息给移除掉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    protected void onDestroy() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        super.onDestroy();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mHandler.removeCallbacksAndMessages(null);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;非静态内部类造成内存泄露还有一种情况就是使用Thread或者AsyncTask。要避免内存泄露的话还是需要像上面Handler一样使用静态内部类+弱应用的方式（代码就不列了，参考上面Hanlder的正确写法）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.未取消注册或回调导致内存泄露&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如我们在Activity中注册广播，如果在Activity销毁后不取消注册，那么这个刚播会一直存在系统中，同上面所说的非静态内部类一样持有Activity引用，导致内存泄露。因此注册广播后在Activity销毁后一定要取消注册。在注册观察则模式的时候，如果不及时取消也会造成内存泄露。比如使用Retrofit+RxJava注册网络请求的观察者回调，同样作为匿名内部类持有外部引用，所以需要记得在不用或者销毁的时候取消注册。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.Timer和TimerTask导致内存泄露&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Timer和TimerTask在Android中通常会被用来做一些计时或循环任务，比如实现无限轮播的ViewPager：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;private void stopTimer(){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        if(mTimer!=null){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mTimer.cancel();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mTimer.purge();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mTimer = null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        if(mTimerTask!=null){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mTimerTask.cancel();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mTimerTask = null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    protected void onDestroy() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        super.onDestroy();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        stopTimer();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当我们Activity销毁的时，有可能Timer还在继续等待执行TimerTask，它持有Activity的引用不能被回收，因此当我们Activity销毁的时候要立即cancel掉Timer和TimerTask，以避免发生内存泄漏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;6.集合中的对象未清理造成内存泄露&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个比较好理解，如果一个对象放入到ArrayList、HashMap等集合中，这个集合就会持有该对象的引用。当我们不再需要这个对象时，也并没有将它从集合中移除，这样只要集合还在使用（而此对象已经无用了），这个对象就造成了内存泄露。并且如果集合被静态引用的话，集合里面那些没有用的对象更会造成内存泄露了。所以在使用集合时要及时将不用的对象从集合remove，或者clear集合，以避免内存泄漏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;7.资源未关闭或释放导致内存泄露&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在使用IO、File流或者Sqlite、Cursor等资源时要及时关闭。这些资源在进行读写操作时通常都使用了缓冲，如果不及时关闭，这些缓冲对象就会一直被占用而得不到释放，以致发生内存泄露。因此我们在不需要使用它们的时候就及时关闭，以便缓冲能及时得到释放，从而避免内存泄露。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;8.属性动画造成内存泄露&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;动画同样是一个耗时任务，比如在Activity中启动了属性动画（ObjectAnimator），但是在销毁的时候，没有调用cancle方法，虽然我们看不到动画了，但是这个动画依然会不断地播放下去，动画引用所在的控件，所在的控件引用Activity，这就造成Activity无法正常释放。因此同样要在Activity销毁的时候cancel掉属性动画，避免发生内存泄漏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;9.WebView造成内存泄露&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于WebView的内存泄露，因为WebView在加载网页后会长期占用内存而不能被释放，因此我们在Activity销毁后要调用它的destory()方法来销毁它以释放内存。另外在查阅WebView内存泄露相关资料时看到这种情况：Webview下面的Callback持有Activity引用，造成Webview内存无法释放，即使是调用了Webview.destory()等方法都无法解决问题（Android5.1之后）。最终的解决方案是：在销毁WebView之前需要先将WebView从父容器中移除，然后再销毁WebView。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对于生命周期比Activity长的对象（单例），要避免直接引用Activity的context，可以考虑使用ApplicationContext，静态变量不使用时及时置空；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Handler持有的引用最好使用弱引用，在Activity被释放的时候要记得清空Message，取消Handler对象的Runnable；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;非静态内部类、非静态匿名内部类会自动持有外部类的引用，为避免内存泄露，可以考虑把内部类声明为静态的；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;广播接收器、EventBus等的使用过程中，注册/反注册应该成对使用，但凡有注册的都应该有反注册；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不再使用的资源对象Cursor、File、Bitmap等要记住正确关闭；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;集合里面的东西有加入就应该对应有相应的删除。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;属性动画及时取消，注意webview内存泄漏问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>50e7d75f43dd95af48dc2ffd66d6ff45</guid>
<title>[译] DevSecOps：在多云环境中确保供应链安全的关键</title>
<link>https://toutiao.io/k/vtfe1gs</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/06ULcDvaIGkjXCD67kuZz9v54Q7iajwlIlyLBiayXjtQ36dxniaclCEfU7wVPQWichmC7Rm2XQb8heBwqibDMApChqA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;作&lt;/span&gt;&lt;span&gt;者：&lt;/span&gt;&lt;span&gt;Johnathan Hunt，译者：&lt;/span&gt;&lt;span&gt;马景贺（小马哥）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;本文译自 &lt;span&gt;DevSecOps: the Key to Securing Your Supply Chain in a Multi-Cloud Threatscape&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;Johnathan Hunt，&lt;span&gt;GitLab&lt;sup&gt;[2]&lt;/sup&gt;&lt;/span&gt;公司安全 VP，他在信息安全和网络安全领域工作了 20 多年，曾在多个垂直领域工作，包括 SaaS、金融、电信、医疗、政府等。他专注于在多家公司建立或成熟安全项目，包括两家财富 500 强公司和多家初创公司。Johnathan 特别热衷于漏洞赏金、供应链安全和 DevSecOps。他曾在多个会议、播客、访谈和博客系列中介绍过这些主题。他拥有许多安全认证，并拥有信息系统的硕士学位。&lt;/p&gt;&lt;h2&gt;主要收获&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;可以将最近的供应链攻击作为 DevSecOps 的一个试金石，我们可以看到在 DevOps 中确实需要一个改进的安全框架。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;随着网络安全的关注度的提升以及 IT 安全支持的激增，企业应该首先评估他们的 DevOps 做法。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;DevSecOps 是这样的：利用 CI/CD 平台和容器化，在 SDLC（软件开发生命周期）内增加测试和扫描，并且使用 AI/ML 来最大限度的减少手动安全措施。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;安全左移或许需要整个组织在多个业务部门之间进行组织架构改变，但整体安全态势将很快得到大幅改善。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;采用 DevSecOps 框架的企业不仅可以加强对漏洞的预防，还可以增加商业价值，因为他们可以提供更安全的产品和服务，更好地保护其业务和客户。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;DevSecOps 恰逢其时&lt;/h2&gt;&lt;p&gt;&lt;span&gt;随着近期的供应链和云攻击，企业现在正在寻求开发人员来增强企业安全&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;由于迅速转变为远程和混合工作模式，我们看到了所有部门在云计算应用和数字转型方面的爆炸式增长。这种转变本质上并不坏，但是企业需要记住的是——使用的服务越多，可以暴漏的&lt;span&gt;漏洞&lt;sup&gt;[3]&lt;/sup&gt;&lt;/span&gt;和风险也就越多。随着漏洞暴露数量的增多，企业正在寻求新的方法来增强安全。2021 年的 &lt;span&gt;Gartner 预测&lt;sup&gt;[4]&lt;/sup&gt;&lt;/span&gt;中，全世界花费在信息安全和风险管理技术和服务上的费用将增长 12.4%，达到了 $1504 亿。&lt;/p&gt;&lt;p&gt;你或许在想——但今天的企业已经有了一些安全流程以及供应商风险管理计划。你想的没有错，企业拥有几个项目和合作伙伴，旨在帮助企业和客户对公司的安全态势感到满意。直到现在，这也是企业安全的主要内容——走过场和打擦边球。这将永远不会真正确保一个公司的安全。事实上，供应商风险管理的缺失或不足可能是当今公司在供应链安全方面面临的最严重威胁。&lt;/p&gt;&lt;p&gt;随着 2021 年网络安全的盘点，出现了一种转变，也许是由于云计算的利害关系比以往任何时候都高。企业正感受到优先考虑和花费在更现代安全上的压力。Gartner 在&lt;span&gt;CIO in 2021&lt;sup&gt;[5]&lt;/sup&gt;&lt;/span&gt;中发现，网络安全是新支出的首要任务。&lt;/p&gt;&lt;p&gt;GitLab 最新的年度&lt;span&gt;DevSecOps 报告&lt;sup&gt;[6]&lt;/sup&gt;&lt;/span&gt;中指出，绝大多数的 IT 和安全从业人员会将他们的投资聚焦在云计算上，其次是 AI。在企业奔向供应商以确保自己和客户的安全之前，他们应该评估从 DevOps 开始，在内部可以采取哪些实际的、积极的措施。&lt;/p&gt;&lt;p&gt;曾几何时，开发人员和企业领导者很少考虑安全的问题——他们认为这是 CIO 和安全团队的事情。尽管我们已经被推到了一个多云环境中，但是云安全和合规问题依旧是事后才考虑的，参考 PwC 的&lt;span&gt;云业务安全&lt;sup&gt;[7]&lt;/sup&gt;&lt;/span&gt;。好消息是，在调查中发现，这些 C 开头的大佬们，不仅仅是 CIO，正在对云安全和整个组织的安全负责。&lt;/p&gt;&lt;p&gt;随着现代人对于进入市场的期待，今天的安全领导正在为快速开发踩刹车，并将开发人员纳入安全范畴。当开发人员通过 CI/CD Pipeline 匆忙写代码时，企业发现安全测试和检查往往是可以被绕过的，是不充分的，是可以妥协的。他们仍然在努力解决这个难题，寻找正确的答案。&lt;/p&gt;&lt;p&gt;进入 DevSecOps——这个框架不仅仅是一个流行词或者是一时的趋势。我认为 DevSecOps 正在成为 DevOps 的同义词。因为今天的开发者对安全的期望越来越高。在&lt;span&gt;Gitlab&lt;sup&gt;[8]&lt;/sup&gt;&lt;/span&gt;，我们将这些组件定义为 DevSecOps 端到端安全框架的关键：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;应用程序安全测试和修复&lt;/strong&gt;：采用大量的扫描，如 SAST、DAST 和安全检测&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;云原生应用保护&lt;/strong&gt;：使用 Kubernetes 和容器扫描来识别漏洞和保护应用程序&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;政策合规性和可审计性&lt;/strong&gt;：通过持续的文件和透明度，满足许可证合规标准&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;SDLC 平台安全&lt;/strong&gt;：在业界领先的 CI/CD 平台上创建代码，优先考虑并满足IT安全标准&lt;/span&gt;&lt;/p&gt;&lt;p&gt;企业的主要目的就是创建有价值和成功的产品或者服务，以期在市场占据主导地位，但是我们看到，在未来的企业中，安全将把好的和伟大的分开。为了避免重大泄漏，就像近期的 Kaseya，Colonial Pipeline，SolarWinds 和 JBS 供应链攻击，所有领导人都必须深入研究他们的安全程序，并成为安全倡议的积极参与者。领导人在安全的重要性上没有保持一致和统一，如果要改善整个工程和产品组织的安全，他们必须从这里开始。&lt;/p&gt;&lt;h2&gt;DevSecOps 现状&lt;/h2&gt;&lt;p&gt;&lt;span&gt;研究表明，安全人员正在采用安全第一的思维模式，但仍然需要更多安全和 IT 的协作，积极有效的框架以及增加对 AI/ML 工具的使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;GitLab 公司的年度 DevSecOps 报告发现，在使用 DevOps 的组织中，安全性显著提高。事实上，72% 的安全专家将他们自己组织的安全努力评为“良好”或“强大”。再者，DevOps 中运行安全扫描的也比以往多：超过一半的运行了 SAST，44% 的运行了 DAST 扫描，接近 50% 的扫描了容器和依赖。所有这些都表明，行业对 DevSecOps 方法的接受程度在不断提高。实际中，70% 的安全团队表明安全已经左移了。&lt;/p&gt;&lt;p&gt;然而，在将安全继承到 DevOps 时依旧有一些绊脚石。超过四分之三的安全团队受访者仍然认为开发人员发现的错误太少，而且在 SDLC 中发现的时间太晚。在 DevOps 团队中，42% 的受访者感觉到安全测试在流程中发生的太晚了，近 37% 的受访者表示追踪缺陷修复的状态非常具有挑战性。所有这些都表明在开发过程中对安全采取了一种被动的方法。开发人员和安全团队往往停留在他们各自的专业领域，然后在出现漏洞时做出反应。&lt;/p&gt;&lt;p&gt;为了减少手动测试和扫描，DevOps 从业者开始利用 AI/ML 工具和技术。GitLab 的 DevSecOps 调查报告发现，四分之一的受访者声称实现了全自动化测试，比 2020 年增长了 13%。调查进一步发现，使用 AI/ML 或者机器人来测试和评审代码的数量在急剧飙升。75% 的团队已经在用或者正在计划使用此技术，比 2020 年上升了 41%。CI/CD 平台正在加强其ML能力，以实现更顺畅、更安全的 DevOps 流程，这些工具的使用在未来几年只会越来越普遍。&lt;/p&gt;&lt;p&gt;自动 DevSecOps 成为主流以来，已经取得了一些进展，在企业开始以积极主动的心态对待安全问题之前，他们不会成功采用DevSecOps。由于安全和 IT 部门在一个单一的愿景上保持一致，成功地执行一个既定策略，并使他们的工作流程现代化和安全化，他们的被动将减少，主动将增加，同时更具协同性。&lt;/p&gt;&lt;h2&gt;客服困难，采用 DevSecOps 框架&lt;/h2&gt;&lt;p&gt;&lt;span&gt;随着公司持续向云迁移，越来越明显的是，他们应该将 DevSecOps 继承到云基础设施中。可能会产生一些痛点，但是持续时间不会太长而且回报率极高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;有效采用 DevSecOps 的一个最大的障碍就是人们认为它会与进入市场的速度相悖。现如今，企业的成功取决于快速部署和快速、迭代开发。最初，实施 DevSecOps 框架可能会感觉到在你的 CI/CD 管道中设置了减速带。新的安全流程有可能会给优先考虑安全问题的安全团队和专注于推进发布的 IT 团队带来挑战，但伴随着这种 “摩擦 “也会带来 DevSecOps 实施的最初结果——端到端的安全处于起步阶段。实施后不需要很长时间就能看到积极的结果。&lt;/p&gt;&lt;p&gt;最重要的就是在 DevSecOps 中，要让球转起来。组织必须从某个地方开始，他们不需要几个安全平台和工具。企业可以马上开始，当你开发出适合你的组织的 DevSecOps 框架时，你的安全实践将不得不与你的业务一起发展。&lt;/p&gt;&lt;p&gt;随着组织的演变，扩容是 DevSecOps 扩容的另外一个常见痛点。企业在扩大业务规模时，可能很难预测扩展 DevSecOps 的成本。除此以外，云工具链也变得越来越复杂，因此很难在一个工具中设置政策或工作流程，并知道它们在整个工具链中得到了遵守。然而，这些问题可以通过采用单一的、包括安全在内的端到端 DevOps 工具来解决。单一的 DevSecOps 平台有可能实现检测和缓解应用程序威胁的全新方法，同时比非集成平台更有效地做到这一点。&lt;/p&gt;&lt;p&gt;企业可以通过以下方式确保他们正在进行适当的安全调查，加强他们的供应链，并改进他们的 DevSecOps 方法。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;保持依赖的可视化，确保开发软件的每个人都熟知依赖&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;利用 CI/CD Pipeline 来将 SAST 和 DAST 测试自动集成到开发流程中&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;让开发人员在编写代码时完成漏洞和依赖性扫描，甚至在提交或合并之前就完成&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;实现自动化的 AI/ML 工具，减少人工安全，增加支持扫描、监控和审查&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;调研在多云环境中敏感信息管理的解决方案&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;加强漏洞预防和改善整体安全态势&lt;/h2&gt;&lt;p&gt;&lt;span&gt;长期以来，像供应链、勒索软件或云计算攻击等重大违规事件都是以反应性措施来处理的。通过在整个软件开发生命周期中优先考虑安全问题。团队可以抓住并解决许多这类攻击中所利用的漏洞，并大大降低漏洞的风险。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;通过安全左移，领导者可以优先进行安全测试，从而更快地修复漏洞，并允许开发人员更快地发布代码。&lt;/p&gt;&lt;p&gt;事实上，这种新的运作模式超越了左移，使安全成为各学科和组织部门的优先事项。DevSecOps 将改变潜在的企业文化，使其拥抱安全并考虑决策对于下游安全的影响。这种文化上的转变对安全来说似乎并不重要，但是，最近针对国家供应链的重大勒索软件攻击的增加表明，目前的学科划分在安全方面留下了缺口，导致了可利用的漏洞。&lt;/p&gt;&lt;p&gt;IT、安全和企业领导必须通力协作来确保他们的组织是一个成功的、被保护的整体。随着越来越多的部门承担起安全责任，企业可以发布从第一天起就考虑到安全的应用程序。&lt;/p&gt;&lt;p&gt;为了变成一个安全优先的组织并且构建出 DevSecOps 框架，这里有一些你的组织应该采取的具体的下一步措施：&lt;/p&gt;&lt;p&gt;1 定义你的 KPI：全面审视你的企业在哪些方面可以提高安全性——评估你的供应商风险、合规要求和安全漏洞。这一阶段的探索将确定你的流程、你的投资以及你认为可以改进的地方。&lt;/p&gt;&lt;p&gt;2 内部集会：在你的董事会和你的团队中，你需要一个组织性的安全优先级。表明企业的每一块都要发挥作用，而保护企业的最好办法就是一起行动。&lt;/p&gt;&lt;p&gt;3 流程一致性：在各业务部门之间划分安全职责的所有权，并准备好与组织内的新人进行合作。&lt;/p&gt;&lt;p&gt;4 确保提议的优先级：在开始的时候，你的安全计划可能会感觉更多的是被动的，并且关注眼前的需求。开始时，要立即修补明显的安全漏洞，然后努力建立一个更积极主动的长期模式。&lt;/p&gt;&lt;p&gt;5 执行策略：在你的团队中积极主动与协作，在整个组织中分享反馈和进展。&lt;/p&gt;&lt;p&gt;6 发展你的战略：你不能设置和忘记安全措施。你的协议和优先事项应该随着你业务的发展而发展。安全就像其他管道一样，它需要不断的迭代和改进。&lt;/p&gt;&lt;p&gt;向 DevSecOps 框架的过渡，一开始会感觉像其他组织转变一样，但接受这一转变的公司将迅速改善其整体安全状况。加强安全是一项商业决策，需要整个组织的支持，它影响着整体商业价值。成功地实施 DevSecOps 框架使企业能够：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;增加商业价值：你的企业将能够提供更安全的数据、更安全的产品和竞争优势，从而加强你的品牌和形象。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;增加客户价值：有了这个框架，你可以满足客户的安全要求，提高对客户数据的保护。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;保持合规：随着更多行业标准和政府标准合规要求的推出，你需要做好满足需求的准备。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;建立共同体：当你把安全放在首位时，你将与你的客户和合作伙伴建立信任和信心。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;结论&lt;/h2&gt;&lt;p&gt;以被动的方式来应对安全是有缺陷的。伴随着大面积的向云迁移，攻击面比以往更大了，组织需要在他们的开发中认真考虑安全所处的角色。企业越积极主动，他们及他们的用户就会得到更好的回报。&lt;/p&gt;&lt;p&gt;公有和私有部门在网络安全方面采取了比以往更强硬的立场。五月份，拜登政府宣布了&lt;span&gt;行政命令&lt;sup&gt;[9]&lt;/sup&gt;&lt;/span&gt;，旨在为整个私营和公共部门建立新的安全标准。随着网络安全标准和审查的增加，强制性报告和信息共享，企业将被期望，甚至更多，给予安全他们应有的注意。公司一直有自己的安全和客户的安全需要考虑，但在国家安全方面也要发挥越来越大的作用。企业不能等待。他们需要一个决定性的转变。他们需要一个 DevSecOps 框架。&lt;/p&gt;&lt;p&gt;这是一个 IT 和安全专业人士奋起直追的时刻。一个 DevSecOps 框架或一个更敏锐的风险管理流程可以为 Kaseya、Colonial Pipeline、SolarWinds 和 JBS 做什么。我们永远不会知道，我们所知道的是我们现在可以采取的实际行动。&lt;/p&gt;&lt;p&gt;虽然几年来业界一直在讨论向左转移的问题，现在是时候停止口头宣告并开始采取行动的时候了，风险是巨大的：成为网络攻击的受害者、失去竞争力或者失去客户的信任。雇员、用户和消费者应该得到果断的行动，以提供更安全的产品并使他们得到保护。&lt;/p&gt;&lt;h4&gt;引用链接&lt;/h4&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; DevSecOps: the Key to Securing Your Supply Chain in a Multi-Cloud Threatscape: &lt;em&gt;https://www.infoq.com/articles/devsecops-supply-chain/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[2]&lt;/code&gt; GitLab: &lt;em&gt;https://about.gitlab.com/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[3]&lt;/code&gt; 漏洞: &lt;em&gt;https://www.infoq.com/news/2021/05/aqua-security-report/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[4]&lt;/code&gt; Gartner 预测: &lt;em&gt;https://www.gartner.com/en/newsroom/press-releases/2021-05-17-gartner-forecasts-worldwide-security-and-risk-managem&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[5]&lt;/code&gt; CIO in 2021: &lt;em&gt;https://www.gartner.com/en/newsroom/press-releases/2020-10-20-gartner-survey-of-nearly-2000-cios-reveals-top-performing-enterprises-are-prioritizing-digital-innovation-during-the-pandemic&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[6]&lt;/code&gt; DevSecOps 报告: &lt;em&gt;https://about.gitlab.com/developer-survey/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[7]&lt;/code&gt; 云业务安全: &lt;em&gt;https://www.pwc.com/us/en/tech-effect/cloud/cloud-business-survey.html&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[8]&lt;/code&gt; Gitlab: &lt;em&gt;https://about.gitlab.com/solutions/dev-sec-ops/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[9]&lt;/code&gt; 行政命令: &lt;em&gt;https://www.whitehouse.gov/briefing-room/presidential-actions/2021/05/12/executive-order-on-improving-the-nations-cybersecurity&lt;/em&gt;&lt;/p&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3934837&quot; data-style-type=&quot;&quot;&gt;&lt;section data-v-09862f0b=&quot;&quot; data-tools=&quot;新媒体排版&quot;&gt;&lt;section data-id=&quot;90196&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3934821&quot; data-style-type=&quot;&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-xmtstyleindex=&quot;0&quot; data-xmt-x1=&quot;381.5&quot; data-xmt-y1=&quot;4647.640625&quot; data-xmt-x2=&quot;1058.5&quot; data-xmt-y2=&quot;5940.220625&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-style=&quot;margin-top: -10px; padding-right: 10px; padding-left: 10px; font-size: 16px; color: black; line-height: 1.6; letter-spacing: 0px; word-break: break-word; overflow-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &amp;quot;PingFang SC&amp;quot;, Cambria, Cochin, Georgia, Times, &amp;quot;Times New Roman&amp;quot;, serif;&quot; data-xmt-x1=&quot;381.5&quot; data-xmt-y1=&quot;4647.640625&quot; data-xmt-x2=&quot;1038.5&quot; data-xmt-y2=&quot;5940.220625&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot; data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot; data-style=&quot;max-width: 100%; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); font-family: 微软雅黑; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; data-xmt-x1=&quot;391.5&quot; data-xmt-y1=&quot;5894.640625&quot; data-xmt-x2=&quot;1048.5&quot; data-xmt-y2=&quot;5940.218725&quot;&gt;&lt;section data-role=&quot;paragraph&quot; data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot; data-xmt-x1=&quot;391.5&quot; data-xmt-y1=&quot;5894.640625&quot; data-xmt-x2=&quot;1048.5&quot; data-xmt-y2=&quot;5940.218725&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot; data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot; data-xmt-x1=&quot;391.5&quot; data-xmt-y1=&quot;5894.640625&quot; data-xmt-x2=&quot;1048.5&quot; data-xmt-y2=&quot;5940.218725&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94252&quot; data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot; data-xmt-x1=&quot;391.5&quot; data-xmt-y1=&quot;5894.640625&quot; data-xmt-x2=&quot;1048.5&quot; data-xmt-y2=&quot;5940.218725&quot;&gt;&lt;section data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot; data-xmt-x1=&quot;391.5&quot; data-xmt-y1=&quot;5894.640625&quot; data-xmt-x2=&quot;1048.5&quot; data-xmt-y2=&quot;5940.218725&quot;&gt;&lt;section data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/06ULcDvaIGkNtmfuZvBk1hjk0CD8S4rH2yZQJomXNKxOAcn3x9o7LdgszlTJ1LNjrS9hII3jzn9uAo5bjf8ibrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649385388&amp;amp;idx=1&amp;amp;sn=4c76729dfe58a73ca4ed30222a6021af&amp;amp;chksm=f224e3c3c5536ad5d01a6e81c7f744205192c86a28975567aca9b38ce2cd737506261fec398b&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Istio 大咖说第 6 期：Envoy 在线答疑问题收集&lt;/a&gt;&lt;/p&gt;&lt;h4&gt;关于云原生社区&lt;br/&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3934837&quot; data-style-type=&quot;&quot;&gt;&lt;section data-v-09862f0b=&quot;&quot; data-tools=&quot;新媒体排版&quot;&gt;&lt;section data-id=&quot;90196&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;云原生社区正式成立于 2020 年 5 月，是一个中立的云原生终端用户社区，致力于为开发者提供云原生领域的专业资讯，推动中国云原生产业发展，目标成为中国云原生领域最具影响力的开源社区。&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649383149&amp;amp;idx=3&amp;amp;sn=6012d51c80d0b8f84db58e514448ad11&amp;amp;chksm=f224ea82c553639460af375bb1f172ba94502c5599eb2a4e4df52287f98db29e3858ae09373d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;点击了解我们&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;点击了解我们&lt;/a&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;云原生社区基于成员兴趣创建了多个 SIG（特别兴趣小组），如 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649382008&amp;amp;idx=2&amp;amp;sn=8329de15872f67151e76e4dc2ece84eb&amp;amp;chksm=f224d617c5535f015e3d71a3d21c234bc333653792c85646c13b2a260a4ac2381e06fc0bf8f4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Kubernetes&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Kubernetes&lt;/a&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384221&amp;amp;idx=2&amp;amp;sn=04c5062a448e9696e9296a02e82837c3&amp;amp;chksm=f224ef72c553666444b33121ae42dbf4e7609574c29e4c55b84f9f6e2cb5bae88a037f2248d2&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Istio&lt;/a&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384308&amp;amp;idx=2&amp;amp;sn=6188dfb44c7a7313a252879a0044b406&amp;amp;chksm=f224ef1bc553660df3b77ff63bd969a4aec56fc5a64a5cf202fb56a507fa0b13588f56384b4e&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Envoy&lt;/a&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384308&amp;amp;idx=3&amp;amp;sn=c144874967206a7d0abe0b66e36cc03f&amp;amp;chksm=f224ef1bc553660d9f32e206c5a9e1424a60f49ced76b3d5925d0bffa09eacbe14b1da8b512a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Dapr&lt;/a&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384269&amp;amp;idx=2&amp;amp;sn=baaa3c95835c663c7141406b8ac1293b&amp;amp;chksm=f224ef22c553663436fcbeab26d97abe166f82b8880fc5531d2157ab89b760457ba8664a1d39&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;OAM&lt;/a&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384175&amp;amp;idx=1&amp;amp;sn=ea9058418afd668967e28a3ba211d649&amp;amp;chksm=f224ee80c5536796af57f48c8ee7e242a2b1478645ce823d711be263587576362744eac8121d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;边缘计算&lt;/a&gt;&lt;span&gt;、&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384137&amp;amp;idx=1&amp;amp;sn=d14055b1b5408a30db96d8e132a046ab&amp;amp;chksm=f224eea6c55367b0058a971ea579e9b1f7cb70e3d39eb4f36b64f9cab924a2b4c3fc845681f2&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;机器学习&lt;/a&gt;&lt;span&gt;、&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649383872&amp;amp;idx=1&amp;amp;sn=b6a3c43ce750ea923fed04592c5b7cfd&amp;amp;chksm=f224e9afc55360b912fd2e0d1a9ab4cc66a22deb81db8f07bc3a83146f370cb388ae53c44ef6&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;可观察性&lt;/a&gt;&lt;span&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384467&amp;amp;idx=3&amp;amp;sn=9a8fe5c24d9458d0113c59604b6ab5e8&amp;amp;chksm=f224ec7cc553656aa33f3304608cc24423d3aca7f0d64ae9e50da2850ce5c4df0d4ff9cc013f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;稳定性&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;稳定性&lt;/a&gt;等&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;请扫描下面的二维码，点击公众号后台的「加入我们」，填写问卷加入社区。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI1NTE2NDE2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/06ULcDvaIGmqt5TicIcR8qFEjicfezMe4YuBlNbN8vl8Mh1fePHOrPibvlqJseGaG4ctibamAhKHMP3xOEW3ByibOjw/0?wx_fmt=png&quot; data-nickname=&quot;Cloud Native Community&quot; data-alias=&quot;CloudNativeCN&quot; data-signature=&quot;云原生社区是国内最大的独立第三方云原生终端用户和泛开发者社区，由 CNCF 大使、开源意见领袖共同发起成立于 2020 年 5 月 12 日，提供云原生专业资讯，促进云原生产业发展。社区官网 https://cloudnative.to&quot; data-from=&quot;1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-v-09862f0b=&quot;&quot; data-tools=&quot;新媒体排版&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;点击下方“阅读原文”查看更多&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c4240bd3d6e2e08b8999d7899bfb7339</guid>
<title>[推荐] 选公司，就要去上升期的</title>
<link>https://toutiao.io/k/hd0xtfs</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;174&quot; data-backw=&quot;365&quot; data-ratio=&quot;0.4767123287671233&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/cvQbJDZsKLp6wejHtKTRbqqQyt0wMk9K1wNtuwRqQTJAPOJ1KiaqSeSRbIJRTicVicKpDKRndBodY2DBNN20tvWwA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;365&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原创：小姐姐味道（微信公众号ID：xjjdog），欢迎分享，转载请保留出处。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;人的发展，还是要看时机的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我不由想起了呆过的一家公司。2年时间，我们的团队，由刚开始的100多人，发展到最后的2000多人，经历了一次次的技术迭代升级。这是一笔宝贵的财富，我的技术水平，也得到了极大的提升。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常的感谢我们当时的技术总监。如果不是他亲自挂帅，带我们完成了一波波的技术升级，我不会了解到统一、正确的思路，能够节省多少时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一次，我将简单的回忆一下&lt;strong&gt;数据治理&lt;/strong&gt;方面的迭代，希望能从中找到一些共通的东西。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来一波重要的思路总结。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当年，入职第二天，领导给我的第一个任务，就是选一个长远的、能扩展、能维护的数据库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于历史的原因，公司的数据库选用了Oracle，但过了几年，噩梦开始了。Oracle极度复杂，在换了几个DBA后，没人敢动这台机器。领导萌生了换Oracle的念头，是因为一次事故。有一次，因为系统断电，Oracle死活启动不起来，给Oracle的技术支持打电话，结果来回推脱，到最后只能花了非常高的价钱，请一些代理机构来解决。大家得出的结论是：Oracle的技术支持并不可靠，还经常发生宰客行为。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;核心技术要掌握在自己手里。经过在&lt;code&gt;db-engines&lt;/code&gt;进行调研，综合国内的招聘情况，我们最终还是保守的选择了&lt;code&gt;MySQL&lt;/code&gt;，而不是性能更高功能更全的&lt;code&gt;Postgresql&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;曾经想过全部使用NoSQL，但被领导果断的被判定为&lt;code&gt;无知&lt;/code&gt;。虽然现在有各种各样的数据库，比如时序数据库、海量存储、各种NoSQL等，但目前使用最多的，还是RDBMS。在RDBMS方面，在互联网，Oracle的优势，已经完全比不上MySQL了。原因就在于MySQL的技术栈，工具全人才多，而且具有良好的扩展性。如果在一个&lt;code&gt;互联网公司&lt;/code&gt;，领导选择采购Oracle，那一般是判定他的脑子被驴踢了，或者采购的脑子被钱砸了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以前的领导，脑子肯定是被驴踢了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但选择了MySQL，就要承受MySQL所带来的技术投入。随着系统的变大，这种投入也逐渐膨胀，但总体看来还是好于&lt;code&gt;表面买放心&lt;/code&gt;的Oracle。在这期间，我经历了数据清洗、数据迁移、各种分层的数据库模型建设，是一笔非常宝贵的经验。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 重构填坑&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在接下来很长一段时间里，我们做的工作就是重构、填坑。我知道这很难，很多公司就死在这一环，因为它需要持续的投入。在此期间，如果同时要求功能性建设的话，这个战线就会拉的很长，很少有领导能够撑过这一环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幸运的是，我们的领导有魄力，能够向长远的目光去看，顶住了短期的&lt;code&gt;无业绩&lt;/code&gt;压力，之后的很多改造和扩展顺风顺水，节省了很多人力和财力。但这种未雨绸缪的领导毕竟是少数的，我后面遇到的大多数公司，都是被销售和产品牵着鼻子走，到最后系统越做越烂以至于无法维护。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那对于数据库来说，我都获取了哪些经验呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小的系统叠加代码，可能会陷入玩SQL的状态。加功能，堆代码，一行SQL走天下，使用的SQL函数，也是越来越偏门。这个非常有意思，你的sql玩的越6，那么给后人埋的坑，越多。你的一句魔幻SQL，会给后人带来十倍甚至几十倍的重构代价。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是为什么不使用Oracle这样一些数据库的原因，因为里面80%的附加功能，基本上是用不到的。即使是MySQL，按照公司的规范，一些官宣的特性，在公司内也是严格禁止的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为功能和扩展性，完全是相反的两回事。除非是访问量固定，或者是外包这样的一锤子买卖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着业务的发展，系统的性能也发生了瓶颈，报应也如期而至，以前的技巧变成了现在的累赘。很快，以前用Oracle时写的一些代码，开始显现出它的弊端。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;各种慢查询层出不穷，查询界面一直转圈&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;经常就发生全文扫描，DBA疲于奔命，最后撂挑子不干了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;想要加缓存，发现无从下手，牵一发动全身&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;想要分库分表，结果根本找不到能分的维度，只好在一次次的讨论会中灰溜溜的承认现实&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多老板搞不明白。我原本一个好好的系统，为什么用户量才翻了一倍，大部分代码就得重写呢？很多项目经理搞不明白。技术人员在那里优化了好几个月，为什么我的功能体验不升反降呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那是因为。你的团队，在相当长的一段时间里，在填坑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;凡是都有规范，都有定律。照顾了工期，质量就要打折，如果加上开发人员并没有长远意识的话，接下来很大的工作，就是填坑。坑填不完，接下来的工作就无法进行。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 数据表的类型&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首当其冲的，就是数据库表的重构。比如以什么ali规范为标准：一个超过3个表的联合查询业务，大概率是不合理的。这个虽然极端，但却是非常重要的指导意见。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;忘掉什么数据库范式，我们将存在两类表：小表和宽表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的改造过程，也是按照这种划分方式进行的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5936555891238671&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLrqXicmwZ2YNJiasvwQIZUlKgoDBrUAF37cARRc87oLAzauQsoMXrKy0RTOW9r3TquErPE52HOeoy7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;662&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小表提供了最基本的数据，可能一个简单的KV就完成了。一些联合查询，并不通过SQL进行JOIN查询，因为我们吃过这个东西的亏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式系统的特点，就是小耗时的多次查询，比机器hang在那里更加有生命力。换句话说，程序里循环1000次10毫秒的查询，比单次查询耗费6秒要强的多。松散的结果，不仅在业务上能支持天马行空的自由组合，在扩展性上也更胜一筹。唯一的一个弱点，就是编码的要求高了，代码量多了，不过这也是我们所希望的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这对一些运行系统来说，是天大的福音。但是问题又来了，统计性的工作又该怎么做？比如报表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是宽表的用途了。宽表通过冗余的方式，提供了某个重要功能常用的分析数据。这种表的字段一般都特别多，在写入时通过拼接获取冗余数据，一般用在读多写少的场景。所以到最后，我们的业务数据，根据查询的维度，写了很多份。不同的团队维护着不同维度的副本，也是团队成员开始爆炸、业务开始飞速发展的开始。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么要这么做？主要还是解耦。有时候，我们通过MQ等分发数据；有时候，我们通过Binlog分发数据。同一份数据，因为维度的不同，有着不同的用途，最主要的业务就减少了宕机的风险。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 分库分表&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理想很美好，但现实很骨感。在我们打算把大表小表方案落实的时候，一件更重要的事渐渐的浮上水面：我们的数据量已经到了一定级别，需要进行分库分表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也证明了领导的先见之明，如果采用的是Oracle数据库，我们的IT费用将会因为购入新的数据库实例急剧飙升。纵向扩展Oracle也能暂时的解决问题，但它总有爆发的一天。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分库分表分为纵向拆分和横向拆分。按照业务进行拆分这一块，我们本身就已经做的很好了，倒是单表的上限处理（比如十几亿的订单表），费了我们很大的功夫。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4857142857142857&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLrqXicmwZ2YNJiasvwQIZUlKgFpibZSopUHmgOUs6U2j7icrbryjqVzCp38Q69t2ibCIL62DwjxUC2R3wA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;805&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前行业内的分库分表方案，集中在以代理方式存在的MyCat，还有以驱动形式存在的ShardingJDBC。为了尽量的少引入额外的维护成本，加上它们的效果都差不多，我们最后的评估，采用的就是ShardingJDBC。当然它的弱点也是很明显的：以Java驱动形式存在，不支持异构系统，比如golang开发语言。幸运的是技术爆炸这一块研发部控制的很好，我们的多数系统是Java的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让人感叹技术统一的好处。永远不要为了尝鲜，引入一些与公司架构不一致的东西，会给所有人带来困扰。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;技术组件好选，但等到真正落实下来，却非常的痛。一句原本好好运行的语句，到了分库分表环境下，竟然就不能运行。归根揭底还是SQL写的太不规范了，用了一些不标准的东西，比如用了&lt;code&gt;distinct&lt;/code&gt;、&lt;code&gt;having&lt;/code&gt;、&lt;code&gt;union&lt;/code&gt;等。这些在单库表的情况下，运行的很好。但到了分库分表环境下，由于组件的限制，它们通常不能好好工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这部分是最耗时的折腾。有些SQL由于改不动了，我们最后几乎把业务重写了一遍，最终使用最简单的CRUD完成了所有的功能。如果想要我再来第二遍的话，我会毫不犹豫的说：No。我会在项目开始设计的时候，就避免这些问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 数据同步&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;终于完成了数据库的扩展性，只要硬件够，可以支持到天荒地老了。现在有时间有精力，来看一下数据同步的问题了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面我们说了，有一大堆小表和大表，用在不同的场景。这些分库分表的原始表，我们就可以把它当作小表，需要把它同步到其他地方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同业务通过共享数据库来共享数据不得不说是个非常蠢的主意。这个时候就需要一些数据同步工具。我们采用了两种同步方式。一种是消息，一种是binlog。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5950413223140496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLrqXicmwZ2YNJiasvwQIZUlKggibamjyyx8pc7dtiaXWibwcaElpn9jlBl9ib6cuPAiczdvrGSlNPrknJctQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;726&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一些有着明显业务属性的信息，我们是通过消息分享的。比如订单，在信息落地到DB后，我们会同时发送一条MQ消息。对订单信息感兴趣的业务方，只需要订阅对应的主题就可以了。当然这里有一个非常大的话题，就是分布式事务（关于这部分，我会在其他文章中分享），来保证消息能够发送成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一些有着共通特性的数据，因为技术原因需要扩展成宽表，或者转化为其他维度的查询数据的时候，就可以通过binlog，把数据共享出去。对于MySQL来说，国内的canal组件，能够非常容易的完成这个转变，我们选的就是这门技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那什么时候用MQ，什么时候用Binlog呢？MQ的信息流明显是比Binlog清晰的，但它的开发难度大，有更多要考虑的因素。如果非要找个边界的话。我觉得MQ主要用在跨业务方的数据交互上，而Binlog是用在自己业务组内的技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了不对主库造成影响，我们一般会拉出多个从库，甚至是从库的从库。一部分从库参与读写分离的业务，一部分从库，就专门为Canal提供数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我离开这家公司的时候，领导正在带领着兄弟们搞异地机房的数据同步。我知道很多公司可能永远用不上，但没有亲身经历这一块，还是有一点小遗憾的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 数据仓库&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据同步是个非常脏的活，经常因为异常，造成了同步终止，这时候依赖的业务方就会陷入抓狂状态中。更脏的活，还是ETL。非常的佩服做数据清洗的同事们，是他们让专注于业务开发的同学，用着清清爽爽的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是这样令人啼笑皆非，因为某些需求，我们需要把分库分表完的数据，重新给合起来。比如某些报表业务需要全量的数据。那就需要把所有的数据汇总到一个地方进行查询，比如ElasticSearch、MongoDB等。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.727027027027027&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLrqXicmwZ2YNJiasvwQIZUlKgtDyFiclfPUDfHyovCjpMhoG6gweiaQ8vZI4RIpRJiaqIBUDSUQdnY80Dw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;740&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据仓库有很多选择。如果数据量适中，就可以选择ElasticSearch，MongoDB等。如果数据量非常大，那就需要考虑Hbase，Druid等大数据产品。在我们这里，按照功能分了三个层次：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;RDBMS（MySQL）作为原始的数据存储，提供扁平快的数据通道&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ElasticSearch作为大型宽表，分布式的类RT的存储。用来存储一些中等规模的数据，并提供一些中延迟的搜索功能，比如商品搜索等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Hbase、Druid作为海量的存储系统，存储系统所有的历史记录，并提供离线分析功能&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在的风向，是使用一些分布式的数据库，比如PolarDB、TiDB等，由于它们在接入层采用的是MySQL协议，所以数据迁移起来、代码改起来是相对简单的。我们有部分非核心业务，已经迁入了这种分布式数据库，但是核心数据还是不敢动，需要更多的时间进行验证。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. 总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这几年走下来，我觉得最重要的收获，是对于技术的规划性，而不是&lt;code&gt;车到山前必有路&lt;/code&gt;的勇往直前。这种工作，需要有能量的人去做。我们的技术总监，对于技术如何迭代，思路是非常清晰的，加上他一直在力推这些事情，就节省了非常多的&lt;code&gt;论证&lt;/code&gt;时间和&lt;code&gt;扯皮&lt;/code&gt;时间。在后面的从业生涯中，我再也没见过这样的技术总监。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;作者简介：&lt;strong&gt;小姐姐味道&lt;/strong&gt;  (xjjdog)，一个不允许程序员走弯路的公众号。聚焦基础架构和Linux。十年架构，日百亿流量，与你探讨高并发世界，给你不一样的味道。我的个人微信xjjdog0，欢迎添加好友，进一步交流。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ef0e645f60ad31971d488a90639ac33f</guid>
<title>[推荐] 树莓派家用指北</title>
<link>https://toutiao.io/k/h2njn7z</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;前两天刚刚入职，最近几天忙着租房搬家，忙活了几天总算是住进了自己小屋里，作为一个软件工程师，怎么可以没有一台家用服务器呢？方案有很多种，上至几千元的 NAS，下至淘汰的老电脑，但是旧电脑响声大功耗高，NAS 动辄三四千的价格对我这个刚毕业的大学生来说着实有些困难，于是我将目光放到了另一个小玩意上——树莓派。&lt;/p&gt;&lt;p&gt;我选择树莓派的原因也很简单，第一便宜，第二可查阅的资料非常多，基本上你之后使用过程中的问题网络上都有解决方案了，因此本文不会介绍怎么使用树莓派，怎么烧录系统，这些东西有太多人写过了，我重复写也没什么意思，因此这块内容我就一笔带过了，本文是我自己的家用服务器方案，更多的是提供一个方向性的指导，如果你觉得我的文章对你有所帮助，欢迎点个关注支持一下哦～&lt;/p&gt;&lt;h2&gt;什么是树莓派？&lt;/h2&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTx7ehOiaRuJMA9FtXlibB7ibljibpn3sUAWiasLccmXIRaVfH9UxDmu6lZGw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;打开任何一个搜索引擎在里面输入&lt;strong&gt;「树莓派」&lt;/strong&gt;三个字都会出现很多内容，其实树莓派本质上就是一台小电脑，虽然外形只有信用卡大小，却具有电脑的所有基本功能。和我们平常用的电脑不一样的是，树莓派自身是没有屏幕、键盘、鼠标这些东西的，但是它提供了网口、USB 口以及视频输出口（其实意思就是让你自己配）。&lt;/p&gt;&lt;p&gt;当然了，树莓派和主流电脑一个很大的区别就是他的芯片，和主流的 x86 桌面级电脑不同的是，树莓派用的是低功耗的 ARM 芯片，因此在性能上和常规电脑还是有些差距的，不过随着近年来 ARM 芯片的不断发展，其性能已经和传统 x86 处理器不相伯仲，甚至在某些方面遥遥领先，例如苹果的 M1 芯片。这里推荐阅读我之前写的两篇文章 👉&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&amp;amp;mid=2247484658&amp;amp;idx=1&amp;amp;sn=58a2c7cde1ed027b26f1e2e41deb8bdb&amp;amp;scene=21#wechat_redirect&quot; title=&quot;《M1 暴打 Intel？——x86 与 ARM 的爱恨情仇》&quot; data-linktype=&quot;2&quot;&gt;《M1 暴打 Intel？——x86 与 ARM 的爱恨情仇》&lt;/a&gt;和&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&amp;amp;mid=2247484681&amp;amp;idx=1&amp;amp;sn=aa4ec453f111157205111ec3d6022c5c&amp;amp;chksm=ceb3d1bbf9c458ad33758e466664d1b0bcdc3e5a348f8ad47a6ac068c8102414cdfee6a1140d&amp;amp;scene=21&amp;amp;cur_album_id=1418449495750311936#wechat_redirect&quot; title=&quot;《M1 暴打 Intel？——这次的芯片有何不同》&quot; data-linktype=&quot;2&quot;&gt;《M1 暴打 Intel？——这次的芯片有何不同》&lt;/a&gt;&lt;/p&gt;&lt;p&gt;好在在学校的这些年，有一些闲置的键盘、鼠标和移动硬盘没来得及出手，于是我便果断的选择了树莓派作为我的家用服务器。&lt;/p&gt;&lt;h2&gt;树莓派的选择&lt;/h2&gt;&lt;p&gt;打开淘宝搜索树莓派，眼花缭乱的，那应该如何选择呢？&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7046979865771812&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTvJgOL4qMmulyZyrHhXsry9rHS0GZbQsiaGSP0cdECshnpDQEl1nGfFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1490&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;其实很简单，虽然树莓派的型号众多，但是细分下来也只有三类：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;Model B 系列：旗舰版，接口全，性能强&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;Model A 系列：青春版，外形小，性能一般，配置和接口略有阉割&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;Zero 系列：迷你版，拥有超小身材，性能较弱&lt;/span&gt;&lt;/p&gt;&lt;p&gt;目前，树莓派已经发展到了第四代了，如果资金不是非常紧张的，推荐购买树莓派 4B 版，官网对他的介绍如下：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4879194630872483&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicThVHIcc2Kkkn9X0E0otjPahP5F2ojRwh4PHlNxH8V7gsJ13CFtUMGzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1490&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;相较于前代，处理器性能大幅增强，并且最高支持 8G 内存，支持 4K 视频输出，同时使用 USB- C 供电，完全可以作为一个桌面级电脑使用了，用作家用服务器绰绰有余了。&lt;/p&gt;&lt;h2&gt;操作系统选择&lt;/h2&gt;&lt;p&gt;说完了树莓派的硬件，怎么可以离开软件呢？树莓派相较于传统电脑另一个好处就是可以自由选择烧录的操作系统，官方推荐的是 Raspberry Pi OS，系统的烧录网上的教程太多了，这里我推荐直接使用官方提供的烧录软件&lt;strong&gt;「Raspberry Pi Imager」&lt;/strong&gt;，从下面的图中也可以看出来是一个非常容易上手的软件了。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6588235294117647&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTKcrB20hDj7GAVX2ZiaYp2gsEp8MC3B63lXxM63dJN1ibfhxFunUZy92g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1360&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;SD 卡选择 16G 的即可，如果容量大一些也是可以的，读写速度自然也是越快越好了，这里我烧录的系统是官方推荐的 Raspberry Pi OS，针对树莓派进行了性能优化，由于是基于 Debian 开发的操作系统，经常使用 Ubuntu 的同学上手难度会稍微低一些。&lt;/p&gt;&lt;p&gt;当然了，你也可以选择烧录其他的操作系统，例如 Ubuntu、Manjaro、Android 等操作系统，甚至有人成功烧录了最近新出的 Windows11，链接在这里，有兴趣的小伙伴自行阅读 👉&lt;span&gt;How to Install Windows 11 on a Raspberry Pi 4&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.0615640599001663&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicT1jkQy4JIjMvAfGCWC2NzB3YsTQcfOcBviaup2p6gia2JRZdKTrHBgfjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1202&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h2&gt;家用树莓派方案指北&lt;/h2&gt;&lt;p&gt;说了树莓派软硬件的选择后，终于可以进入本文的正题了。&lt;/p&gt;&lt;p&gt;树莓派的玩法有很多，网上有很多控制机器人、外接灯泡控制开关等，说实话，这些玩法教育意义大于实用意义，毕竟家用也不会把灯泡接到树莓派上，直接买个小米的智能灯泡控制体验不比这个好吗？&lt;/p&gt;&lt;p&gt;之所以一开始就舍弃使用旧电脑作为家用服务器这一方案的一个原因就是功耗，网上有人对树莓派的功耗进行过测试，4B 的功耗：空闲时 2.7 W，负载时到 6.4 W。按照家里电费 0.7 元一度电的价格计算，一年 365 天每天 24 小时高负荷运行的电费也才&lt;strong&gt;6.4×24×365÷1000×0.7=39.2448 元&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4318181818181818&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicT7EIlMpGUIsHYLiaB12VcHTYb14mUFibcIcdSWLnMFDh9gongpAE2w3Yw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;968&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;因此树莓派适用于一些适合 24 小时在线的服务，我的服务有：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;离线下载（Aria2、qbittorrent）&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;米家、HomeKit 等智能家居中转控制（HomeAssistant）&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;局域网文件共享（Samba）&lt;/span&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;Linux Server（Docker）&lt;/span&gt;&lt;span&gt;&lt;span&gt;5.&lt;/span&gt;家庭 Dashboard 中控面板（Flutter Web）&lt;/span&gt;&lt;span&gt;&lt;span&gt;6.&lt;/span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;接下来我将会按照顺序逐一介绍。&lt;/p&gt;&lt;h3&gt;连接树莓派——连通性测试&lt;/h3&gt;&lt;p&gt;想要使用树莓派第一步肯定是连接上树莓派，连接树莓派的方式有很多种，直接接键盘、鼠标、显示器，或者通过 SSH/VNC/FTP，无论用何种方式只要能连接上网络即可。方便起见，建议先连接显示器，然后开启 SSH 和 VNC 服务。网络上的教程很多很详细，这里不再赘述。&lt;/p&gt;&lt;p&gt;本节主要来介绍一个很关键但是很多文章都忽略的内容，即树莓派与个人电脑间的&lt;strong&gt;网络连通性测试&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;如果要实现诸如上述局域网共享文件、离线下载等功能，一个很重要的特点是工作电脑与树莓派之间的&lt;strong&gt;传输速度要快&lt;/strong&gt;，不然我离线下载完文件后传到自己电脑上还要好久，那岂不是多此一举吗？&lt;/p&gt;&lt;p&gt;由于大多数教程中工作电脑与树莓派的连接都是通过 WI-FI 而非网线的方式，因此在一开始就有必要针对二者的网络传输速度做一个测试，这里我推荐使用&lt;strong&gt;「iPerf3」&lt;/strong&gt;，安装和使用都很简单。&lt;/p&gt;&lt;p&gt;我们需要在树莓派上使用 apt 安装 iPerf3，然后启动 iPerf3 的服务。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 安装 iPerf3&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sudo apt install iperf3&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 启动 iPerf3 服务&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;iperf3 -p 3005 -s&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;code&gt;-p&lt;/code&gt;设置监听的端口号，客户端需要使用该端口与服务端进行通信。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;code&gt;-s&lt;/code&gt;设置为服务模式运行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;然后在工作电脑上也安装上 iPerf3 即可，mac 电脑直接执行 &lt;code&gt;brew install iperf3&lt;/code&gt; 即可安装，然后我们只需执行下面的命令即可。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 测试 Mac 与树莓派之间的网速（我的树莓派内网 ip 为192.168.31.189）&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;iperf3 -c 192.168.31.189 -p 3005&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;我的测试结果如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6466165413533834&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTibITmOLGJkricBnYcc9YS7yKH1ib0eb7u1mPuqv9WaawysuQx2GxGngjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1330&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;换算一下，上传下载大约能有 7MB/s 的速度，虽然速度不是很快，但是基本可以用。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;PS：如果有小伙伴测试结束后发现连通速度有些慢，不妨检查下你的树莓派是否连接到 5GHz 的 Wi-Fi 上。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;确认连接速度可以正常使用后，我们便可以来安装使用一个非常重要的工具了——Docker。&lt;/p&gt;&lt;h3&gt;使用 Docker 为树莓派赋能&lt;/h3&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7486263736263736&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicT2Fr6cZjH9WACvSLh0dYO9fFZIEibCMOMWZotfhwkYK1Zu46gDuorF4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;728&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;Docker 的存在使得开发者可以快速搭建自己所需要的开发环境，只需指定好镜像后即可快速生成所需要的容器环境。并且由于树莓派使用的是 ARM 架构的芯片，很多常用软件如果想要正常安装使用需要自行编译，这对于性能不够强悍的树莓派来说无疑是一种负担，为了让我们的精力聚焦在在实际的开发中，而不是纠缠着应用运行环境的问题上，这次我们使用 Docker 搭建所需要的开发环境，为树莓派赋能。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;对 Docker 还不了解的小伙伴可以移步 👉https://yeasy.gitbook.io/docker_practice/&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在树莓派上安装 Docker、配置镜像加速在上面的链接中都已给出，值得一提的是，Docker 的定位在于将容器内的环境搭建起来，但如果我们想将多个容器的运行方式和配置固定下来，应用于容器编排，则需要使用 Docker Compose。&lt;/p&gt;&lt;p&gt;举个例子，我们有一个应用容器，需要 mysql 存储数据， nginx 作转发，消息队列作数据转化，那在每次启动前，需要将每个前置容器先启动，再把应用容器跑起来，这本身就是一个重复的动作。而且在启动时，还需要针对每个容器进行不同的配置，所以为了&lt;strong&gt;实现对多个容器的组合管理&lt;/strong&gt;，例如规定容器启动顺序，规定好配置内容等行为，Docker Compose 便应运而生了。&lt;/p&gt;&lt;p&gt;Docker Compose 的安装方式有很多种，但由于 ARM 架构的限制，树莓派上的 Docker Compose 建议使用 pip 安装。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sudo pip3 install -U docker-compose&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;！！！一定是 Python3 版本的 pip，所以建议直接使用 pip3&lt;/strong&gt;&lt;/p&gt;&lt;h3&gt;监管你的 Docker——Portainer&lt;/h3&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5233333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTD9wIsaZOzkA31AuYvX5IzGcuW6mrjLLZeuHQomW5Gr1iajwpvXKoD5w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;Portainer 是 Docker 的轻量级，跨平台和开源管理 UI。你可以通过 WebUI 管理你的 docker 容器，镜像，网络和卷。他的安装也很简单，直接执行以下命令即可。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;安装完成后如下图所示 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.41005291005291006&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTpD94aK3Lky6cAdpGibBtEpkTwytqAcsLJguV7ib3liaVXsnXRSKxpBcoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1512&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;监控面板——Pi Dashboard&lt;/h3&gt;&lt;p&gt;有了 Docker 之后，我们便可以方便快速的进行各种软件的安装了。为了方便监控我们的树莓派情况，首当其冲的便是 Pi Dashboard。&lt;/p&gt;&lt;p&gt;安装很简单，只需执行下面一行命令 👇&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sudo docker run -d --name docker-pi-dashboard -e &#x27;LISTEN=1024&#x27; --net=host ecat/docker-pi-dashboard&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;启动完毕后可以通过&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sudo docker ps | grep docker-pi-dashboard&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;来确认我们的容器是否启动成功，如果启动成功，在浏览器中输入&lt;code&gt;&amp;lt;你的IP地址&amp;gt;:1024&lt;/code&gt;即可访问到 pi dashboard 了。如下图所示 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6252676659528907&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTOCVPxErLfCYfmw2fO5kJAwX9bibyoqmmUOicfxPCLUXWl1F1NPXOBVvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;934&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;智能家居——HomeAssistant&lt;/h3&gt;&lt;p&gt;智能家居是眼下最火的领域之一，小米、苹果、华为等都在布局该领域，旗下的米家、HomeKit 等都已经提供了非常完善的服务，那么我们为什么要在树莓派上搭建一套智能家居系统呢？&lt;/p&gt;&lt;p&gt;其实原因很简单，虽然目前智能家居产品众多，但是尚未有一种智能家居解决方案同时满足设备种类多、交互体验好、成本低廉的特性，为此很多情况我们都会选择某一家的某一些产品，这就有可能会造成整个家里出现小米的台灯、华为的传感器、苹果的音箱等多种混乱的局面，然后你还要安装多个 App，这种体验无疑是非常差的。&lt;/p&gt;&lt;p&gt;在计算机领域有一句名言——&lt;strong&gt;所有兼容问题都可以通过加一层抽象解决，所有性能问题都可以通过去掉一层抽象解决。&lt;/strong&gt;既然这样，何不在这些智能家居平台基础上再抽出一层，提供一个统一的控制入口？&lt;/p&gt;&lt;p&gt;答案自然是可以的，并且已经有人将方案开源出来了，这就是本节要介绍的 HomeAssistant。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.45717344753747324&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTXkKkHVKzL0Yncs1I7KQIjaZJMwQfMKbelBzQ2bv24KY8ODf4aJsD1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;934&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;无论是米家还是 HomeKit 都只能在各自的生态中使用，米家只有移动端 App，HomeKit 虽然覆盖了平板、手机、电脑、手表等，但也仅限苹果生态。（互联网发展了这么多年，却忘记了他最开始的形态，真不知道这是一种进步还是一种悲哀）&lt;/p&gt;&lt;p&gt;扯了这么远，回到正题，HomeAssistant 的安装使用非常简单，官网已经写的非常详细了 👉https://www.home-assistant.io/installation/raspberrypi#docker-compose&lt;/p&gt;&lt;p&gt;推荐使用 Docker Compose 安装。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;yaml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;version: &quot;3&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;services:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  homeassistant:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    container_name: homeassistant&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    image: &quot;ghcr.io/home-assistant/raspberrypi4-homeassistant:stable&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    volumes:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      - /PATH_TO_YOUR_CONFIG:/config&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      - /etc/localtime:/etc/localtime:ro&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    restart: unless-stopped&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    privileged: true&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    network_mode: host&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;指定好 volumes 的路径后执行&lt;code&gt;docker-compose up -d&lt;/code&gt;指令即可。&lt;/p&gt;&lt;h3&gt;米家的接入&lt;/h3&gt;&lt;p&gt;安装好之后你的家庭应该是空的，如果想要绑定米家设备，可以接入米家的 MIoT 插件，文档 👉https://github.com/al-one/hass-xiaomi-miot/blob/master/README_zh.md&lt;/p&gt;&lt;p&gt;填写好自己的小米账号和密码后，即可利用网页在 HomeAssistant 中查看使用自己的米家设备，以此达到跨平台的目的。下图是我自己配置的控制页面 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3484848484848485&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTsR1YcHs9vBAibtibTwU5zdHvibbxlCCuLyZS8LdUhJMQ6YBxIZ1vn26lA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1914&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;开放能力——REST API&lt;/h3&gt;&lt;p&gt;如果只是提供了一个网页用于控制，那么本质上也就是在交互体验上进行了优化，并不值得单独开一小节。HomeAssistant 作为一个开源产品，最大的优势在于提供了开放的能力，使每个用户按照自己的想法去进行更改设置，我们完全可以根据 HA 提供的 REST API 针对自己的需求定制化。（例如制作一个属于你自己的家庭枢纽，后面会提到）&lt;/p&gt;&lt;p&gt;HomeAssistant 默认是不会开放 REST API 功能，你需要在&lt;code&gt;configuration.yaml&lt;/code&gt;文件中配置一下&lt;code&gt;api&lt;/code&gt;选项，如下图所示 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.39290586630286495&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTHfG7yg2o5nCMjVsWoXXYpwx2IElEsrm71gUeibH9EicPOWsQicecp8QQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;733&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;关于 HomeAssistant 可配置的选项还有很多，具体的可以参考文档 👉https://developers.home-assistant.io/&lt;/p&gt;&lt;h3&gt;离线下载——Aria2&lt;/h3&gt;&lt;p&gt;有些资源下载时间较长，不适合电脑长期挂机下载的，这时就可以将我们的树莓派变成一个离线下载的服务器。提到下载，不可不提的一个神器便是 Aria2。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.2391713747645951&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTUXus5gHY0Q8YibCGOhBU1epNMlme8PEVP8ibE4htSbckTJw0wreZ3xkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;531&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;Aria2 是一款自由、跨平台&lt;strong&gt;命令行界面&lt;/strong&gt;的下载管理器，和 wget 这类下载器不同的是，Aria2 不仅支持 BitTorrent，还能够从各种来源多路检索所请求的文件。包括 HTTP，HTTPS，FTP 和 BitTorrent 协议。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;对种子下载原理感兴趣的同学可以阅读我的这篇文章 👉&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&amp;amp;mid=2247484780&amp;amp;idx=1&amp;amp;sn=f4c12708e159821f700811b1dc1be35c&amp;amp;scene=21#wechat_redirect&quot; title=&quot;《人人都是 LSP？—— 种子与文件下载的相爱相杀》&quot; data-linktype=&quot;2&quot;&gt;《人人都是 LSP？—— 种子与文件下载的相爱相杀》&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;而且 Raspbain 系统默认已经安装了 Aria2，运行 apt-cache show aria2 即可查看安装信息，因此我们要做的就是为 Aria2 找一个图形化界面即可，使用 Docker 的一大好处就是可以直接去找别人已经打包好的镜像文件，让安装使用变得十分易用。&lt;/p&gt;&lt;p&gt;只需执行下述命令即可启动一个 Aira2 的图形化界面了 👇&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;docker run -d --name aria2-ui-pi -p 8888:80 -p 6800:6800 -v /data:/data --restart=always huangzulin/aria2-ui-pi&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;p&gt;默认下载路径是在容器内的 /data 文件夹，为了方便使用最好指定一个 volume 映射&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;局域网文件共享——Samba&lt;/h3&gt;&lt;p&gt;现在，手机是 Android/iOS，电脑是 Win/Mac，除去苹果生态，设备与设备之间的文件传输直至今日仍然是一个大问题。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.42875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTXa1WnX0lGtFUcY4WpuByyFDrQ89H8M8L5F7Ytu1CVR8MTScyZaIr8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;Samba 是在 Linux 和 UNIX 系统上实现 SMB 协议的一个免费软件，SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。通过该协议，你可以快速方便的在 Win 与 Linux/Unix 之间分享文件，而不是通过 QQ 在线传文件。&lt;/p&gt;&lt;p&gt;安装过程也十分简单，你可以选择 apt 安装也可以选择 docker 直接安装，网上的教程非常多，详情可参考 👉&lt;span&gt;在树莓派上配置 Samba 服务教程&lt;sup&gt;[2]&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;打造属于你自己的家庭枢纽&lt;/h3&gt;&lt;p&gt;无论是 HomeAssistant 还是 Aria2，这些都是别人写好的东西，如果你想让树莓派更加定制化，你可以按照自己的想法去边写一些小程序（这也就是为什么之前要提一下开放 HomeAssistant 的 REST API）。&lt;/p&gt;&lt;p&gt;如果想要让自己的程序运行在树莓派上，大致有以下几条路可以走 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5580568720379147&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicT6ZX8icIuZPtCNtvIHdJ6Ply072d2icJjr1icTgPPAs3mZefHpw4RC4wAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;844&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;为了打造一个属于自己的家庭枢纽，我的想法是在一块&lt;strong&gt;可以触摸的屏幕&lt;/strong&gt;上控制自己家的智能家居设备（借助 HomeAssistant），直观地查看天气（和风天气），追踪快递行程（爬虫）、时钟、纪念日/倒数日/照片墙等，因此这是一个完整的网页，我选择的技术栈是 SpringBoot + Flutter Web + Nginx，然后使用 Docker 打包成一个镜像启动整个服务。&lt;/p&gt;&lt;p&gt;部分页面如下 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4071573261309926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTQODBvtibq3uNmOM6nHcfU9ckyDenX7jMALXWp1ygakePmAicDDN1WW8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1481&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;我在做的就是 Java 相关的工作，后端选择 SpringBoot 无可厚非，之所以选择 Flutter Web 而不是传统的 Vue 或者 React，一方面是因为 Flutter 的声明式 UI 写起来确实比传统 Web 页面编写更舒服，效率更高，另一方面是因为用 Flutter 写的网页可以无缝转换成在 Android/iOS/PC/Linux/macOS 这些平台上的原生 App，有助于后期针对多个平台的覆盖（当然更多还是因为我已经把 Vue 和 React 忘的差不多了)。&lt;/p&gt;&lt;p&gt;目前这个网页比较简陋，还有很多我想做的功能没来得及做上去，但后续我准备持续更新这个代码，后续如果在家里运行效果还不错的话，甚至有想开源出去的想法，不过这就是后话了。&lt;/p&gt;&lt;h3&gt;随时随地访问——内网穿透&lt;/h3&gt;&lt;p&gt;玩了这么多东西，有没有发现一个最大的问题？&lt;/p&gt;&lt;p&gt;没错，就是这些所有的东西必须要求你的电脑和树莓派处在同一个网络里，即局域网环境里。虽然我一开始的使用场景就是在家里使用，但如果我在公司突然想看一部美剧了，但是用公司电脑下载视频显然是不现实的，如果这时候我可以在外网直接访问家里树莓派的离线下载服务，那么下班回家后岂不就可以看到自己想看的电影了吗？&lt;/p&gt;&lt;p&gt;所以，最好的方式就是联系你的宽带运营商，并申请一个公网 IP，这样你就可以通过这个公网 IP 访问到你的树莓派了。&lt;/p&gt;&lt;p&gt;据我所知，目前只有电信的部分地区会给公网 IP，大多数运营商是不会提供公网 IP 的，而且申请流程很麻烦，所以为了可以随时随地的从外网访问家里服务器的文件或其他服务，我们可以为树莓派做一个&lt;strong&gt;「内网穿透」&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.32531824611032534&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTLLziazMtXZicKqhIu94GufrehGj2OZPvDRlqxI7FNybPLx5HBZfjRxuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;707&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;「计算机领域的大多数问题都可以通过增加一层来解决」，所谓内网穿透，无非是在内部网络和互联网之间增加一个中转服务器，这个中转服务器负责接收你的请求并转发到内部服务器，也即&lt;strong&gt;「代理」&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;当然了，内网穿透的原理肯定不会这么简单，这里只是通俗的解释一下，如果之后有机会来详细说下。所以为了实现内网穿透，我们需要有一台可以公网访问的服务器作为中转桥梁，这时我突然想到我毕业前买的学生机还没到期呢，现在刚好在吃灰，拿它来做中转岂不是最好的？&lt;/p&gt;&lt;p&gt;内网穿透服务器的选择有很多，FRP 是用的最多的，但我这里选择的是 👉&lt;span&gt;nps&lt;sup&gt;[3]&lt;/sup&gt;&lt;/span&gt;，原因也很简单，页面好看，交互简单，性能够用。&lt;/p&gt;&lt;p&gt;nps 是一款轻量级、高性能、功能强大的内网穿透代理服务器。目前支持 tcp、udp 流量转发，可支持&lt;strong&gt;任何 tcp、udp 上层协议&lt;/strong&gt;（访问内网网站、本地支付接口调试、ssh 访问、远程桌面，内网 dns 解析等等……），此外还支持内网 http 代理、内网 socks5 代理、p2p 等，并带有功能强大的 web 管理端。&lt;/p&gt;&lt;p&gt;我们只需要在云主机上安装好服务端，并按照后台提示在树莓派上安装好客户端，简单设置自己要转发的端口即可实现内网穿透。&lt;/p&gt;&lt;p&gt;官方文档在 👉https://ehang-io.github.io/nps/#/?id=nps&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTLzqYLx5Eus5D03LDor9OCorJn6Licv6QtLg3NibpdpicEia3Zf4eZhPAeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h2&gt;最后&lt;/h2&gt;&lt;p&gt;拥有一台树莓派最大的好处就是可以充分发挥你的灵感与创意，如果你有想法、有能力、有时间，不妨让树莓派成为你实现想法的载体。&lt;/p&gt;&lt;p&gt;最后扯一点文章之外的，工作之后的时间果然少了很多，这篇文章从开始写到现在完成差不多花了一个星期，阿里的工作强度的确很大，每天下班到家多半也是 10 点之后的事情了，能留出来码字的时间实在有限，难得周末有空，把近期搬家捣鼓自己家的想法写下来，也算是自己新阶段的开始。这段时间阅读了很多内部的优秀文档，也希望自己未来的文章可以像内网的大神们一样更专业，新的征程加油！&lt;/p&gt;&lt;p&gt;以上就是本文的全部内容了，如果觉得还不错的话，不妨给我一个点赞关注支持一下哦 👍&lt;/p&gt;&lt;h3&gt;References&lt;/h3&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; How to Install Windows 11 on a Raspberry Pi 4: &lt;em&gt;https://www.tomshardware.com/how-to/install-windows-11-raspberry-pi#xenforo-comments-3710927&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[2]&lt;/code&gt; 在树莓派上配置 Samba 服务教程: &lt;em&gt;https://ee-fans.com/%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E9%85%8D%E7%BD%AEsamba%E6%9C%8D%E5%8A%A1%E6%95%99%E7%A8%8B/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[3]&lt;/code&gt; nps: &lt;em&gt;https://github.com/ehang-io/nps&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>