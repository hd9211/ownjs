<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>6a38b93c284cd16afd350401e6122dd0</guid>
<title>职场：3 天准备 5 天面试，跳槽完成</title>
<link>https://toutiao.io/k/1d2mnjh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote&gt;&lt;p&gt;为什么跳槽？大饼吃多了太撑，想出去走走。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;01&lt;/span&gt;&lt;/p&gt;&lt;p&gt;从想离职到提出离职，考虑了半个月，至于跳槽的原因，已经有知名互联网大佬给出过精辟解答，这里不重复说了；&lt;/p&gt;&lt;p&gt;离职手续办理好之后，休息了几天时间，然后准备简历和选择公司，在当前这个阶段和就业环境下，心里确实有点犯毛躁，&lt;strong&gt;不过选好的河就大胆的去趟，这就是生活该有的样子&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;下面聊聊整个跳槽过程和面试相关的问题，首先说下跳槽的整体情况，从离职到休息结束开始算起话，计划是两周内完成跳槽，当时的构想是这样：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.175&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBWqVadjyrus5icpvdaG4NWfuZVb3ujYP5zI552cHjlmr8ZDyjIlIVQ6RYLLY5W3Phib7uou5s1YtuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1040&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第一周&lt;/strong&gt;：休息的时候考虑好自己想去的公司，周三准备好简历，周四看看JDK必问试题，周五给意向公司投去简历，周末了解一下将要面试公司的基础业务；如果第二周意向公司面试失败，就海投准备再面一周；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二周&lt;/strong&gt;：本周面的都是意向公司，大概面了11家公司，收到了三份offer，也都是自己中意的公司，这样跳槽就结束，最后就选择一家公司继续搬砖的节奏，第三周的计划完全落空；&lt;/p&gt;&lt;p&gt;上面就是整个离职和跳槽的整体情况，然后来说说详细的面试过程，希望给准备跳槽的朋友一些参考。&lt;/p&gt;&lt;p&gt;&lt;span&gt;02&lt;/span&gt;&lt;/p&gt;&lt;p&gt;离职后的第一周，主要是休息和面试的准备时间，然后就是浏览自己想要跳槽的公司，准备好简历，在周四周五两天给想去的公司投简历或者发邮件。虽然这段时间是打算休息的，但是准备的事情还是很多。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.40703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBWqVadjyrus5icpvdaG4NWfwich59XyK7S5csj7JdlNCWJ0MYCQFp27KeIUCX9GW5NsNIjuqd6wjjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;寻找意向公司&lt;/strong&gt;：每个程序员都有自己中意的几家公司，可能是大公司或者一些崛起的小厂，找好自己想去的公司，并且熟悉相关业务和网上的风评，这样给面试的时候留个话题。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;准备简历&lt;/strong&gt;：简历是最关键的，用来介绍自己的相关学历信息，技能展示，以及工作经历和经验，最后&lt;strong&gt;做好PDF格式&lt;/strong&gt;的简历，避免不同电脑下的简历打不开或者格式混乱。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;面试题准备&lt;/strong&gt;：程序员跳槽的最大麻烦就是要准备面试题，这个没什么需要多说的，在工作4-5年这个阶段，基本不会被问框架的大问题，更侧重细节和难点问题的解决思路，所以这些不用过度准备，就看了JVM的执行周期和并发编程相关的内容，这两个方面问题说清楚基本不会再问JDK底层原理。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;审视自己&lt;/strong&gt;：这是个人认为最重要的一个过程，看清自己业务经验和编程技能，尤其是自己写的简历内容，要知道面试官的提问除了JDK底层原理，其他问题基本都是根据简历描述提问，所以换位思考一下，如果拿自己的简历提问，会问出哪方面的问题，然后自己再构思好如何回答，这样真到面试的时候不会出现紧张情绪，如果你对自己的认知足够清楚，不出意外的话自己构思的问题一定会被面试官问到。&lt;/p&gt;&lt;p&gt;出于对自己的工作经验的把握，当时根据自己的简历内容构思好如下几个方面问题的回答思路：1.分布式使用的难点和细节；2.微服务模式下事务组件和原理；3.异步流程的注意事项；4.海量数据的管理思路和不同业务场景存储选型；5.开发中遇到的难点问题解决思路；6.JDK底层的JVM虚拟机执行周期；从后来的面试过程看，不管是阿里快手等大厂，还是面试的几家小厂，技术问题基本都是问这几个，当时看自己的简历时，感觉也就问这几个问题合适了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;投递简历&lt;/strong&gt;：个人的计划是先面自己中意的公司，选择在第一周最后给这批公司投去简历，周末接到的第一个面试机会居然是支付宝，几轮面试下来简直是难尽一言。建议对于收到面试邀请的公司要快速熟悉一下对方的业务和简单的情况，这是多数HR和管理者喜欢问的内容，可以留个不错的印象。&lt;/p&gt;&lt;p&gt;&lt;span&gt;03&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;大致流程&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;休息和准备一周之后，就正式开始面试，每天至少面试3家，有家公司面试到晚上10点结束，那感觉简直是细品柠檬味酸透心，不用惊讶晚上面试的情况，真的是很常见的操作。现在阶段的面试，公司对入职者更加谨慎，所以基本不会直接发offer下来，选择是双向的，求职者拿多个offer要权衡一下，公司对多个面试者也需要斟酌一下再选择，基本都是面试结束后2-3天的考虑时间才会有最终结果。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBWqVadjyrus5icpvdaG4NWfmDn3n6SzJlMub4LobSCagycVcuL8zkhbzXBPsphkGTmpIqL6W6UpqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;没折腾完这个流程，很难收到最终的offer邮件，的确很闹心不过这就是职场，如果有其他公司卡offer时间节点，也可以提前和自己中意的公司沟通，加快面试的流程，这里完全没必要怂或者觉得尴尬。自己当时因为拿到offer，支付宝的面试流程还没走完，就直接电话和当时的面试官沟通，提前面了第三轮，但是难度过大，直接凉凉了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;技术面试&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;现场面的首轮非常重要，通常是由架构师或者服务端主管来面，主要还是技术问题居多，给第一位面试官留下足够好的印象，会让你接下来的面试难度降低。首轮技术面基本都是围绕简历内容：了解之前工作经验业务模式和相关技术选型，以及相关业务难点解决方案，这是一大块；另一块就是自己在简历上罗列的技术栈，结合项目的具体应用场景；最后就是JDK底层会有2-3个问题，无非就是容器，并发，JVM的内容；基本面到这里没有问题，就差不多结束了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.226215644820296&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBWqVadjyrus5icpvdaG4NWf85GSwZvibSicpnW8dasiaHd084VvEwEYnlaTjP2rZEQ4mmKcQicLicibPNWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;946&quot;/&gt;&lt;/p&gt;&lt;p&gt;有的公司直接给你二轮技术面的机会，有的公司可能会让你回去等通知，毕竟技术负责人的时间确实需要协调，不可能随时有空来面试，技术二面基本都是技术负责人来面：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.20618556701030927&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBWqVadjyrus5icpvdaG4NWfj4XsSks0lWEatib9k6BbClav8sxxe6FT33icRVz3MEDiczqUZYoxPvv5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;970&quot;/&gt;&lt;/p&gt;&lt;p&gt;如何猜测可能的提问，你需要判断该公司是技术型公司，还是业务型公司，不同的类型的业务其部门负责人的关注方向自然不一样，技术二面的问题通常不会很偏专业技术或者业务，问题回答的空间很大，需要思路清晰并且言之有理，这个真的需要自己理解，当然不排除遇到技术型负责人，例如上面说的支付宝三面，被问哑口无言，个人觉得二面一般考验人的思维和事物的认知水平，难度会比一面要简单一些。在二面中如果熟悉过该公司的业务，也可以提出来简单沟通一下作为加分项，薪水问题也会在这里做个初步交流，面试的最后可以问下该公司的技术栈选型，后续如果拿到offer，也可以提前熟悉一下，避免刚入职时手忙脚乱。&lt;/p&gt;&lt;p&gt;基本两轮技术面决定这家公司能给你开多少薪水，之后就会把技术面试的结果转到HR部门，由HR部门做消息同步，如果技术面试HR重点沟通薪水问题。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;人事部HR面&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;首先必须要说明一点，并不是前面两轮面试通过，就能拿到合适自己的薪水和offer邮件，和HR的面试对薪水的影响很大，HR面基本没有什么需要提前考虑的，基本就是有套路性的闲聊，熟悉一下性格三观等，所以放松且自信的有说有笑就好，也可以多问一些公司的情况，这是一个双向对话，不是单方面被提问。&lt;/p&gt;&lt;p&gt;最后HR会给到一个薪水线，然后通常给1-2天的考虑时间，如果对这个薪水不满意，这里也可以给出自己的薪水线，这取决你自己对整个面试过程的把握，如果面试过程顺利，该公司也对你表现出很大的好感，就自信大胆的沟通就好，不会因为薪水问题直接拒绝的，后续考虑两天才会有最终结果。&lt;/p&gt;&lt;p&gt;最后就是考虑后明确薪水的事，如果薪水没有问题，邮件offer也就基本当天就发了。&lt;/p&gt;&lt;p&gt;&lt;span&gt;04&lt;/span&gt;&lt;/p&gt;&lt;p&gt;对面试过程的问题做个简单总结，给大家一个参考，注意这里针对【4-5年】的工作经验，同时也受到工作经验的影响，不同阶段的面试问题肯定是不一样的：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.16984402079722705&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBWqVadjyrus5icpvdaG4NWf3Y1N3Ydm6hQJLaUpDEuNSpCrtMctP3lTSMialP3hNDzNCQtcBJOSKeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1154&quot;/&gt;&lt;/p&gt;&lt;p&gt;这是公司考察一个求职者的基本思路，从面试过程就能清楚的感觉到。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;业务能力&lt;/strong&gt;：通常是面试最开始的提问，难度不大，都是关于之前接触的业务和技术选型，业务难点的解决思路，再难度大点就是业务的演进过程和相关处理方案，尤其是数据体量膨胀和业务重构的问题，这种问题的范围取决简历上你自己是否做了描述，如果你描述过项目有这样的历程，自然很可能被提问到。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;技术栈应用&lt;/strong&gt;：这个就不用多说，简历上陈列的技术栈就是重点提问的内容，不过这里重点提一下现在阶段求职基本都很关注分布式体系，这算是基础的能力，尤其是微服务的技术组件，对于技术细节的考核不会过于深，重点是在业务中的应用细节处理，例如缓存，异步，高并发，服务状态，分布事务等问题，大的方向没必要多说，细节问题说好2-3个基本就能看出来是用过还是学过，或者是背过面试题。&lt;strong&gt;解决过业务问题的坑坑洼洼的事情吐槽它几件出来，很容易和面试官达成共识&lt;/strong&gt;，例如分布式事务组件或者中间件崩溃等常见问题。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;JDK底层&lt;/strong&gt;：一个开明的面试官通常不会过度为难你JDK底层原理，基本都会抛选择给你自己：聊聊你最熟悉的JDK模块，或者分析阅读过的JDK源码。工作4.5年不能一点JDK底层不了解吧，选最熟悉的两块内容就好，推荐并发和JVM两方面内容。JVM作为底层多少都要熟悉基本流程，并发作为开发中难度较高的模块也最体现Java水准线。这里可以从实际的底层原理去聊，也可以从实际场景去聊，例如处理JVM问题或者用并发解决什么场景的问题，这样应付JDK底层的问题都是可以的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;综合能力&lt;/strong&gt;：综合考察基本都是在部门负责人和HR的两次面试中，会通过各种自带套路的问题，例如：上次离职的原因，如何看待上家公司，对自己职场规划等。这些问题最重要的是&lt;strong&gt;思路清晰并且避免吐槽指错现象，任何事情都是相互的，认知要好，态度要坦然，职场上公司和员工都不容易&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;span&gt;05&lt;/span&gt;&lt;/p&gt;&lt;p&gt;整体上看现在的跳槽情况，面试机会确实比上两年少一些，可能也因为不在3月和9月，公司的选择也更加谨慎，求职周期拉长，让人觉得跳槽难度很大，另外薪水相比之前确实有下降，这是大环境导致的，技术需要日常多用心积累，业务能力也需要用心去思考，平时积累足够，跳槽之前理清做好计划，心态平和就好。&lt;/p&gt;&lt;p&gt;最后说一句个人对于工作理解就是：积累专业技能，提高认知能力，做事情三思而后行，预则立，不预则废。&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3783359497645212&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCjMheLZtcM2iaVMBOpIUKR4CDRCG9FLT5K6NmGXvG7exrW0TSuDjnTKJQ5PDq8j8Y7PHDd17Z3gicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>54a2e35b28d1e025c42e32db9ffd2531</guid>
<title>通知 &amp; 告警治理（降噪）的 7 种方法</title>
<link>https://toutiao.io/k/556xuh7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;情景&amp;amp;任务&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;很多团队的成员都被海量通知和告警所困扰：&lt;/section&gt;&lt;section&gt;工作日打开邮箱，几百几千封的邮件。虽然可以通过邮件过滤器将邮件分组，让自己快速找到自己最关心的内容。但是还是不可避免过个1年半载邮件过多，容量不足，其他人发邮件发不进来。或者真正出问题时，邮件过于频率，最需要的时候反而打不开邮件了。&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.432900432900433&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlic2Cic5EJabjnt1EdSfKJrzNIU6LGztVtYUb523pmAQ1DrDWIicOvibgoFlPtGw4DRlZKicnjk1OibQ0KQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;231&quot;/&gt;&lt;/p&gt;&lt;section&gt;周末正在旅行，手机告警短信一个接一个的。眼看手机快没电了，还等着下车刷手机上公交卡呢。一个告警短信来了嗒嗒嗒一声，手机没电了。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;对于短信和邮件等通知和告警形式，当消息量大于一定程度后，平均可用价值在降低（内容熵增）。容易引起下面问题：&lt;/section&gt;&lt;p&gt;l 故障期间，告警风暴，手机/邮箱会被海量告警淹没；&lt;/p&gt;&lt;p&gt;l 运维人员很难从海量告警中筛选出重要告警，容易忽略重要告警；&lt;/p&gt;&lt;p&gt;l 固定阈值控制，频繁误报、漏报告警；&lt;/p&gt;&lt;p&gt;l 告警没有发给真正需要处理问题的人；&lt;/p&gt;&lt;p&gt;l 目前有些线上告警一直无人处理，告警一直存在，没有真正发挥告警的意义；&lt;/p&gt;&lt;p&gt;l 告警和巡检没有做明确的分类区分；&lt;/p&gt;&lt;section&gt;为了快速应对故障，提高对告警的敏感性，需要对告警进行治理。&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;行动&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;严格来说：告警也是一种通知。但是告警和其他通知的思路有所不同。对于告警：&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3391167192429022&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlic2Cic5EJabjnt1EdSfKJrzNLd95E2NBIBEHBmphQDgoicYxgNwVsnXtEacNGqTu8rtiba2kF4F166fw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;634&quot;/&gt;&lt;/p&gt;&lt;section&gt;其他通知思路：&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.14478764478764478&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlic2Cic5EJabjnt1EdSfKJrzNDPT4lQs0CXhxuJpCicmibwyofRxd5RWiaKbSH9snrrFtNiczMOLAQqfgHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1036&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;（一）规范命名&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;告警和通知的共性问题是都需要熵减，就是让内容更有秩序，容易分辨。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;主题可采用：【级别+分类】+内容 的形式，例如：&lt;/section&gt;&lt;section&gt;&lt;span&gt;【P0系统告警】ping命令不可达&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;级别定义可根据需要处理的时效来规范，比如可设定P0级别为需要立即处理，P1级别为连续发生则需要立即处理，P2级别为保持关注。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;分类可大体上分为告警类和通知类。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;告警类又可分为系统告警和业务告警。通知类又可分为定时巡检通知和条件触发类通知。定时巡检通知和条件触发类通知都各有系统类和业务类。CPU、内存、磁盘剩余量等属性属于系统类。和具体业务相关的，比如做支付业务的，支付成功笔数、退款率都属于业务类。举个例子：&lt;/section&gt;&lt;section&gt;&lt;span&gt;【P2定时业务巡检】近1小时业务成功率99.9968%，TP99耗时260ms&lt;/span&gt;&lt;/section&gt;&lt;p&gt;收到这条通知，可能大多数同事平时就是了解下目前的系统状况是一直很稳定的。比如一个季度会专门思考分析下成功率和耗时是否满足要求，是质量提高了还是下降了。是否需要处理还是保持现状。&lt;/p&gt;&lt;section&gt;再举个条件触发类通知的例子：&lt;br/&gt;&lt;/section&gt;&lt;section&gt;比如某业务在高速增长，大家很关心增长速度。所以就配置了一个通知：业务每上升一个百分点就发一个通知：&lt;/section&gt;&lt;p&gt;&lt;span&gt;【P1条件触发通知】XXX业务近一周业务增长1%，目前日单量3000W&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;（二）阈值与等级和周期联动&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;对于同一类的通知和告警可根据程度设置不同的级别和发送周期。让紧急问题快速得到处理，不紧急的问题不频繁发送，达到&lt;strong&gt;&lt;span&gt;降噪&lt;/span&gt;&lt;/strong&gt;的目的。&lt;br/&gt;&lt;/section&gt;&lt;p&gt;举个例子：&lt;/p&gt;&lt;p&gt;&lt;span&gt;【P0业务告警】5分钟XX业务失败1000笔，成功率0%&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;【P1业务告警】5分钟XX业务失败100笔，成功率97%&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;【P2业务告警】过去1小时XX业务失败10笔，成功率99.9%&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;（三）减少巡检类通知，建立系统以查代推，用异常报警代替部分巡检通知&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;信息的接收有推和拉两种方式。通知属于推动信息。自己主动查询属于拉取信息。在上面告警和通知的思路图中，我们主要希望推送的信息是变化的信息，像巡检类中，各个指标没有什么变化，更好的一种方式是自己主动去查询。查询的时候不仅要看数值，还希望看到一段时间的变化趋势或者成为态势。如果指标发生了变化，可以采用主动推动的方式，便于及时处理。&lt;/section&gt;&lt;section&gt;例如：系统巡检CPU、内存、磁盘都正常的话，可以以日报或者周报、月报的形式推动。而小时级的巡检数据正常情况下落库到系统中。需要了解的人员可以去系统中查询。异常情况，比如CPU超过阈值则以告警的形式推送。这样，系统运行正常的话，通知和报警都很少。&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibRjxUKVp62DibZ18iaU0bVkpHlDWO56dVo2jdPchGIDzdhJhPibJ8OuSA2eueeod6RaXWBTXbKWLT2w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.36666666666666664&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;（四）聚合压缩&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;同类报警需要聚合压缩，这方面业界相关的资料就很多了。为了找到同类信息，算法、人工智能都可以用上。&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;（五）告警闭环&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;告警触发--&amp;gt;告警确认---&amp;gt;告警处理--&amp;gt;恢复信息&lt;/p&gt;&lt;section&gt;看到一些公司在初期设计的告警就是有问题的时候把报警发出来。其他事情都是手工来做。更好的一种做法举例是这样：&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;span&gt;【P0业务告警】5分钟XX业务失败1000笔，成功率0%&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;对应的监控大盘链接为：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485527&amp;amp;idx=1&amp;amp;sn=21413445605b9b2b9f883ba7b446c64c&amp;amp;chksm=fafde2f9cd8a6bef39582ee0075fcb846bf5c320dbddb0b4f0363a88f42d760109acf8ae198f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;链接名&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;链接名&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;对于监控链接为：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484492&amp;amp;idx=1&amp;amp;sn=28bd807db3880ad116b022d2e13db4b1&amp;amp;chksm=fafdeee2cd8a67f4e3703e6c0789b5e21aefcdbcb0aee3a4b20f35ad33c344f6d107db3898eb&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;链接名&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;链接名&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484014&amp;amp;idx=1&amp;amp;sn=f7d86fd284ea13f0ab21de023e95ca1a&amp;amp;chksm=fafde8c0cd8a61d65528020765fca70a5e01198b3e0d3a8621b9d72cea531d518f5188ba643a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;点我确认接受到告警&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;点我确认接收到告警&lt;/a&gt;      &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247483932&amp;amp;idx=1&amp;amp;sn=e06714e218f6746d99c2afd2044799b4&amp;amp;chksm=fafde8b2cd8a61a492956788ea05b594a9069e702f6a9e1d0ba94df426447f2a4e5032bc1314&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;点我确认你在处理告警&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;点我确认你在处理告警&lt;/a&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247483932&amp;amp;idx=1&amp;amp;sn=e06714e218f6746d99c2afd2044799b4&amp;amp;chksm=fafde8b2cd8a61a492956788ea05b594a9069e702f6a9e1d0ba94df426447f2a4e5032bc1314&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;点我确认你在处理告警&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;这样，有人点击了：确认接收到告警，其他人就知道可以快速联系到谁，节省系统恢复的时间。有人点击了：点我确认你在处理告警，则可以暂停此告警的发送，避免告警风暴。&lt;/p&gt;&lt;section&gt;告警恢复后要有恢复通知：&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;【P0业务告警恢复】5分钟XX业务失败1000笔，成功率0% -- 已恢复，目前&lt;span&gt;5分钟XX业务失败1笔，成功率99.99%&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;（六）告警控制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;告警控制的手段有自动或手动关闭报警、未处理告警频率递减等。例如：系统如果在发布时由于机器数量降低有1%的CPU使用率上升，则可以在发布时手动或者发布操作关联降级CPU使用率报警。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;再比如：在确实出现故障的时候，故障一直没有恢复，本来5分钟报警一次，已经报警了三次了。再连续的报警已经意义不大，可降级成1个小时1次。&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;（七）明确责任人，以治降噪&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;告警降噪最好的办法是有问题就处理，问题解决了，告警就消失了。可实际上大家经常面临的问题是：报警大家都收到了，谁也不去解决。所以需要在告警中就明确处理人员：比如当日值班人员或者模块负责人。&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8354037267080745&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlic2Cic5EJabjnt1EdSfKJrzNEP8YEGhntlv2dic8RNaqFT1dmKLFaWqq1mcZY4emIBMX5lo1mIB7jIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;322&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;相关阅读&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9af2526f605dd73dde22aef28f6de3cf</guid>
<title>Spring 如何创建 bean 对象？</title>
<link>https://toutiao.io/k/1a67fbw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前情回顾&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前文「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4NzYyMDE4MQ==&amp;amp;mid=2247484821&amp;amp;idx=1&amp;amp;sn=5d2ed50262d5a0019805fa55e9e368fc&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Spring 如何从 IoC 容器中获取对象？&lt;/a&gt;」从整体上分析了如何从 Spring IoC 容器获取一个 bean 对象。该逻辑由 AbstractBeanFactory#doGetBean 方法实现，主要流程如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;2.3684210526315788&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ophTb90oYCSp0zx3yp8picvvaak9kOtrQQ8Lct1dqdaQlz5P1gG4EEf1pK3wgPfsYrZWcCvP3WlU5opyNFJ4kWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;684&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文进一步深入细节，主要分析如何创建 singleton（单例）类型的对象。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何创建单例对象？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从流程图可以看出，当获取一个 bean 对象时，Spring 会首先尝试从缓存中获取单例对象。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;值得注意是的：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;只有对象是单例的场景，即 scope 为 singleton 时才会缓存对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这里其实涉及到了所谓的「三级缓存」，为了更容易理解三级缓存，本文先研究这个 bean 对象是什么时候放入缓存的，后面再研究三级缓存。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然能取，必然有地方把 bean 对象存入了缓存，那缓存中的数据是从哪里来的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面主要分析单例对象是如何创建、并放入缓存中的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该逻辑在 AbstractBeanFactory#doGetBean 方法中，主要代码如下（保留了创建单例 bean 对象的代码，其他部分暂时忽略）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractBeanFactory&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;FactoryBeanRegistrySupport&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ConfigurableBeanFactory&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;T &lt;span&gt;doGetBean&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;            String name, @Nullable Class&amp;lt;T&amp;gt; requiredType, @Nullable Object[] args, &lt;span&gt;boolean&lt;/span&gt; typeCheckOnly)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        String beanName = transformedBeanName(name);&lt;br/&gt;        Object bean;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 从缓存中获取单例 bean 对象&lt;/span&gt;&lt;br/&gt;        Object sharedInstance = getSingleton(beanName);&lt;br/&gt;        &lt;br/&gt;        &lt;span&gt;// 缓存中不存在 bean 对象&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;// 获取 BeanDefinition&lt;/span&gt;&lt;br/&gt;                RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;// 获取依赖的 bean 对象&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 若创建一个 bean 对象时依赖其他对象，则先创建被依赖对象&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;// 创建 scope 为 singleton（单例）的对象&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (mbd.isSingleton()) {&lt;br/&gt;                    sharedInstance = getSingleton(beanName, () -&amp;gt; {&lt;br/&gt;                        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                            &lt;span&gt;return&lt;/span&gt; createBean(beanName, mbd, args);&lt;br/&gt;                        }&lt;br/&gt;                        &lt;span&gt;catch&lt;/span&gt; (BeansException ex) {&lt;br/&gt;                            &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;                        }&lt;br/&gt;                    });&lt;br/&gt;                    &lt;span&gt;// 处理 FactoryBean 的场景&lt;/span&gt;&lt;br/&gt;                    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;// 创建 scope 为 prototype 的对象&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (mbd.isPrototype()) {&lt;br/&gt;                    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;// 创建其他类型对象&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;catch&lt;/span&gt; (BeansException ex) {&lt;br/&gt;                &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 类型检查&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (T) bean;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实就是这个 DefaultSingletonBeanRegistry#getSingleton 方法，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DefaultSingletonBeanRegistry&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;SimpleAliasRegistry&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;SingletonBeanRegistry&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 单例 bean 对象缓存（beanName, bean）&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; singletonObjects = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;(&lt;span&gt;256&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;getSingleton&lt;/span&gt;&lt;span&gt;(String beanName, ObjectFactory&amp;lt;?&amp;gt; singletonFactory)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Assert.notNull(beanName, &lt;span&gt;&quot;Bean name must not be null&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.singletonObjects) {&lt;br/&gt;            &lt;span&gt;// 先从缓存中获取 bean 对象&lt;/span&gt;&lt;br/&gt;            Object singletonObject = &lt;span&gt;this&lt;/span&gt;.singletonObjects.get(beanName);&lt;br/&gt;            &lt;span&gt;// 缓存中不存在时再去创建&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (singletonObject == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 创建单例对象前&lt;/span&gt;&lt;br/&gt;                beforeSingletonCreation(beanName);&lt;br/&gt;                &lt;span&gt;boolean&lt;/span&gt; newSingleton = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;boolean&lt;/span&gt; recordSuppressedExceptions = (&lt;span&gt;this&lt;/span&gt;.suppressedExceptions == &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (recordSuppressedExceptions) {&lt;br/&gt;                    &lt;span&gt;this&lt;/span&gt;.suppressedExceptions = &lt;span&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;&amp;gt;();&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;// 创建单例对象&lt;/span&gt;&lt;br/&gt;                    singletonObject = singletonFactory.getObject();&lt;br/&gt;                    newSingleton = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;// catch ...&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (recordSuppressedExceptions) {&lt;br/&gt;                        &lt;span&gt;this&lt;/span&gt;.suppressedExceptions = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;                    }&lt;br/&gt;                    &lt;span&gt;// 创建单例对象后&lt;/span&gt;&lt;br/&gt;                    afterSingletonCreation(beanName);&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (newSingleton) {&lt;br/&gt;                    &lt;span&gt;// 将对象添加到缓存&lt;/span&gt;&lt;br/&gt;                    addSingleton(beanName, singletonObject);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;// 缓存中有的话直接返回&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; singletonObject;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;getSingleton 方法会先从缓存 singletonObjects（其实就是一个 Map）中获取 bean 对象，如果缓存有就直接返回，否则再去创建。创建成功后，会把该对象存入缓存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建的逻辑在哪呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看代码是通过 ObjectFactory#getObject 方法来创建的，ObjectFactory 是一个函数式接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@FunctionalInterface&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ObjectFactory&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;T &lt;span&gt;getObject&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法的实现是什么呢？退回上一层，即 getBean 方法，看这里：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sharedInstance = getSingleton(beanName, () -&amp;gt; {&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 创建 bean 对象&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; createBean(beanName, mbd, args);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;catch&lt;/span&gt; (BeansException ex) {&lt;br/&gt;        &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里用到了 Lambda 表达式，将如下表达式作为参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;() -&amp;gt; {&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 创建 bean 对象&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; createBean(beanName, mbd, args);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;catch&lt;/span&gt; (BeansException ex) {&lt;br/&gt;        &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建 bean 对象的逻辑就在这个 createBean 方法中，它在 AbstractAutowireCapableBeanFactory 类中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractAutowireCapableBeanFactory&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractBeanFactory&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;AutowireCapableBeanFactory&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; Object &lt;span&gt;createBean&lt;/span&gt;&lt;span&gt;(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;throws&lt;/span&gt; BeanCreationException &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        RootBeanDefinition mbdToUse = mbd;&lt;br/&gt;&lt;br/&gt;        Class&amp;lt;?&amp;gt; resolvedClass = resolveBeanClass(mbd, beanName);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (resolvedClass != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !mbd.hasBeanClass() &amp;amp;&amp;amp; mbd.getBeanClassName() != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            mbdToUse = &lt;span&gt;new&lt;/span&gt; RootBeanDefinition(mbd);&lt;br/&gt;            mbdToUse.setBeanClass(resolvedClass);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// Prepare method overrides.&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            mbdToUse.prepareMethodOverrides();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// catch ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// 这里可能返回代理对象&lt;/span&gt;&lt;br/&gt;            Object bean = resolveBeforeInstantiation(beanName, mbdToUse);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (bean != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; bean;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// catch ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// 创建 bean 对象&lt;/span&gt;&lt;br/&gt;            Object beanInstance = doCreateBean(beanName, mbdToUse, args);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (logger.isTraceEnabled()) {&lt;br/&gt;                logger.trace(&lt;span&gt;&quot;Finished creating instance of bean &#x27;&quot;&lt;/span&gt; + beanName + &lt;span&gt;&quot;&#x27;&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; beanInstance;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// catch ...&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;值得注意的是，resolveBeforeInstantiation 方法其实是跟 AOP 实现相关的，可能在这里生成代理对象就返回了。由于现在主要分析 IoC 的流程，因此这里暂时略过，有兴趣的朋友们可以自行研究。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里继续沿着主线逻辑走。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建 bean 对象是在 doCreateBean 方法中实现的，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractAutowireCapableBeanFactory&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractBeanFactory&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;AutowireCapableBeanFactory&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; Object &lt;span&gt;doCreateBean&lt;/span&gt;&lt;span&gt;(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;throws&lt;/span&gt; BeanCreationException &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// Instantiate the bean.&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 1. 实例化 bean&lt;/span&gt;&lt;br/&gt;        BeanWrapper instanceWrapper = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (mbd.isSingleton()) {&lt;br/&gt;            instanceWrapper = &lt;span&gt;this&lt;/span&gt;.factoryBeanInstanceCache.remove(beanName);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (instanceWrapper == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            instanceWrapper = createBeanInstance(beanName, mbd, args);&lt;br/&gt;        }&lt;br/&gt;        Object bean = instanceWrapper.getWrappedInstance();&lt;br/&gt;        Class&amp;lt;?&amp;gt; beanType = instanceWrapper.getWrappedClass();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (beanType != NullBean&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;            mbd.resolvedTargetType = beanType;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// Allow post-processors to modify the merged bean definition.&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (mbd.postProcessingLock) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (!mbd.postProcessed) {&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;// catch ...&lt;/span&gt;&lt;br/&gt;                mbd.postProcessed = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; earlySingletonExposure = (mbd.isSingleton() &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.allowCircularReferences &amp;amp;&amp;amp;&lt;br/&gt;                isSingletonCurrentlyInCreation(beanName));&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (earlySingletonExposure) {&lt;br/&gt;            addSingletonFactory(beanName, () -&amp;gt; getEarlyBeanReference(beanName, mbd, bean));&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// Initialize the bean instance.&lt;/span&gt;&lt;br/&gt;        Object exposedObject = bean;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// 2. 填充属性&lt;/span&gt;&lt;br/&gt;            populateBean(beanName, mbd, instanceWrapper);&lt;br/&gt;            &lt;span&gt;// 3. 初始化&lt;/span&gt;&lt;br/&gt;            exposedObject = initializeBean(beanName, exposedObject, mbd);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// catch ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (earlySingletonExposure) {&lt;br/&gt;            Object earlySingletonReference = getSingleton(beanName, &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (earlySingletonReference != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (exposedObject == bean) {&lt;br/&gt;                    exposedObject = earlySingletonReference;&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.allowRawInjectionDespiteWrapping &amp;amp;&amp;amp; hasDependentBean(beanName)) {&lt;br/&gt;                    String[] dependentBeans = getDependentBeans(beanName);&lt;br/&gt;                    Set&amp;lt;String&amp;gt; actualDependentBeans = &lt;span&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;&amp;gt;(dependentBeans.length);&lt;br/&gt;                    &lt;span&gt;for&lt;/span&gt; (String dependentBean : dependentBeans) {&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {&lt;br/&gt;                            actualDependentBeans.add(dependentBean);&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// Register bean as disposable.&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            registerDisposableBeanIfNecessary(beanName, bean, mbd);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// catch ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; exposedObject;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：Instantiate 和 Initialize 虽然看起来有点像，但它俩不是一回事，前者是“实例化”，后者是“初始化”。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法看起来有点长，但最主要的事情只有三件：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;创建 bean 对象：createBeanInstance 方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;填充属性：populateBean 方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;初始化 bean：initializeBean 方法&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这几个方法内部其实都有一大堆堆堆堆堆……的代码，再对照一下前面给出的整体流程图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.421011673151751&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ophTb90oYCSQXV27XgPhoHD5xMXWZokcuf6gmFZnXo2KoBFdTInuLm5wJDFSFrSN9CT1m81RUTfGobTiaQ1em0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2570&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是这样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文在前文整体分析的基础上又进一步细化，先到这里吧，后面再继续分析~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何从 Spring IoC 容器中获取 bean 对象？前文对此进行了整体流程的分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文在前文的基础上又进一步细化，主要从整体上探讨了 Spring 如何创建单例的 bean 对象，整体上分为三个步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;创建 bean 对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;填充 bean 属性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;初始化 bean 对象&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于这三个步骤具体又做了什么，且听下回分解。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;有点「自顶向下」的感觉了，这就是「金字塔原理」？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4NzYyMDE4MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/sz_mmbiz_png/ophTb90oYCQ3hdcibbKDTtUib9yUnFAicJ4RoeJPVgwzjRejhoNbVYcCzyHtcW6vn9EbxP3PpErEIRkibrms8KEYDQ/0?wx_fmt=png&quot; data-nickname=&quot;WriteOnRead&quot; data-alias=&quot;WriteOnRead&quot; data-signature=&quot;Java学习与分享。知易行难，坚持更难。加油！&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1792a13918556ab0afd409b1e05b4240</guid>
<title>聊聊 IT 技术人的知识体系</title>
<link>https://toutiao.io/k/vmimc5g</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;161&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.2777777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/fCpd1cf8iacboUWicibrqngI6axlkiaEZKSOWSicUSdsk4LbBIQhzV9NJQ79BDSNLm4KRFkDFHcdb3hN0cpR9iaKwRxw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【个人成长&lt;strong&gt;&lt;span&gt;】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;| &lt;/span&gt;&lt;strong&gt;&lt;span&gt;作者&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;/Edison Zhou&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;我在我的2020年终总结中提到技术人需要建立自己的知识体系，那么怎么建立自己的知识体系呢？技术人的知识体系又是什么样的呢？今天，和你一一分享。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文视频版：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4NzQzNTg4Ng==&amp;amp;mid=2651734689&amp;amp;idx=1&amp;amp;sn=774b0c51d53c06f81fb765c7173aaaa1&amp;amp;chksm=8bc39da0bcb414b6904df41999cecd8e58908b0d30c7dc3ed5a640c5d6af05cfa9d321dec82c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;聊聊IT技术人的知识体系&quot; data-itemshowtype=&quot;5&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;聊聊IT技术人的知识体系&lt;/a&gt;，本文为该视频的文字稿。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1&lt;/span&gt;关于我的12字方针&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;我在我的《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4NzQzNTg4Ng==&amp;amp;mid=2651734149&amp;amp;idx=1&amp;amp;sn=75f3bfceff058042c764efd094cbf158&amp;amp;chksm=8bc39f84bcb41692500a44c5a4a69e6c867cd7c600bf4e0bfe2ece1988a3688b5b5fc3a0a73f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2020年终回顾&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;2020年终回顾&lt;/a&gt;》一文中提到了一个12字方针，以应对IT技术人的中年危机，它是“&lt;strong&gt;抓主线、建体系、有侧重、多复盘&lt;/strong&gt;”。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;139&quot; data-backw=&quot;258&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;258&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;86&quot; data-ratio=&quot;0.5376827896512936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fCpd1cf8iacYVFJUtUdwrENd5no68ft7sibx9aHnOCq33ouIvY2GZ01GH2XjBAojQJRjQJBf3YWqajzofx0FJibSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;889&quot;/&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中，“建体系”三个字最为重要。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，是建什么体系呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;答曰：建立我们IT技术人的知识体系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来，我们就来聊聊如何建立我们自己的知识体系。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;2&lt;/span&gt;刻意构筑 点-线-面&lt;/section&gt;&lt;p&gt;&lt;span&gt;我们可以借助 &lt;strong&gt;点-线-面&lt;/strong&gt; 的方法论来构筑知识体系，即我们在工作中用到的往往是一个知识面的某条主线的某个点，只有当你用了多个点之后才会将它们升维到某条主线，最终多条主线再次升维形成一个知识面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里我们以Redis为例来说说如何构筑Redis的点-线-面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;248&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;514&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;83&quot; data-ratio=&quot;0.33407572383073497&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fCpd1cf8iacaCD0zs9aP5DWSsWHia1icNSowVLb5lpVoibwYUoBDg7aFTVxPKDqA6YBtE0oZIbf9WhfUibBiaENvFoVw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;898&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis应该是我们做后端开发的技术人大概率都会用到的一个中间件，不管你用到了哪种程度，只要你是做后端开发，那么你的知识体系中必然有它的位置。&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;这里我们借助某位老师总结的一个Redis的知识结构图来聊聊，如下图所示：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;248&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;258&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;86&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fCpd1cf8iacYVFJUtUdwrENd5no68ft7s5etIstD2micpkibmYnSLeu55scxUok6sgkia3ErpT6wkjUPOAckia3dWpw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;我们可以从上图中看到，该老师将Redis这个知识面分为了两大维度 和 三大主线，两大维度分别是 应用维度 和 系统维度，三大主线分别是 高性能主线、高可靠主线 和 高可扩展主线。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;作为一个对自己有追求 又 渴望成长 的IT技术人来说，往往都是在工作中在了解和实践Redis的一个又一个零散的知识点，却很少将它们整理和归纳，使这些点能够串联起一条主线脉络在心中。比如，我们常常使用Redis做缓存，用了很多相关的get/set接口，也用了k/v、string、set等数据结构，有的还使用到了新增的SET接口实现了分布式锁去应对秒杀抢购的业务场景，但却很少将它们归纳分类提升维度，进而构筑知识体系，因此在面试中的回答往往不够完整（这也是我的经历，错失一些offer的感悟）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如果我们都能有这样的整理和归纳，对每个知识面都有像上图一样的脉络在心中，是不是也会增加我们的自信程度，减少不必要的中年焦虑？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;画外音：骚年，平日里多多归纳总结，刻意练习，必有收获。技术如此，业务知识也如此，心中有一条公司整体业务的主线 以及 自己项目团队所负责的业务线的详细脉络，就是一个合格的IT技术人，因为技术是为业务服务的，没有交付业务价值的技术也是不合格的。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;那么，跳出Redis这个知识面，我们后端技术人的知识体系的全貌又是怎么样的？这里我整理了一棵树，它列出重要的知识面 和 主线，仅供参考。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;416&quot; data-backw=&quot;451&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;451&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;254&quot; data-ratio=&quot;0.9217252396166135&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fCpd1cf8iacYVFJUtUdwrENd5no68ft7setykTsvZaC36kvZC5lBHwJSs2CXhKtoxIl1wFbibukMenib3SQpKwdPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1252&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;当然，这还只是一棵较为粗糙的树，我会持续对它进行完善，因为我的技术认知和业务认知也在不断地更新，乐观接受新认知，勇于放弃旧认知，只要自己不断地在进步，就是值得高兴的事。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;此外，金三银四已经到来，Edison也在整理一棵开发面试的知识体系，目前整理到了v0.5版本，关注EdisonTalk的童鞋可以回复“面试知识树”获取。这个pdf的全貌如下图所示：&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;341&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;518&quot; data-ratio=&quot;0.6055900621118012&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fCpd1cf8iacYVFJUtUdwrENd5no68ft7sdooN6VhaPuedt4zmZebArKknn8yp7fY6QHPXyZsw1kNqVB1XwVbQMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1288&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在EdisonTalk交流群里（欢迎加群交流），很多童鞋都表达了自己的焦虑，认为自己多年所学的知识可能会在今后的日子越来越得不到市场。我承认，在国内的互联网和IT大环境市场下，面向职位和工资编程，.NET在互联网大厂的平均使用份额的确不高，但是也需要承认.NET在数字化转型、工业制造、3D游戏（Unity）、BIM设计、医疗信息化等行业领域还是占有一席之地。此外，作为一个程序员，掌握两门及以上的开发语言也不是什么坏事儿，如果我们将自己的知识体系进行一个抽象和升维，你会发现.NET技术栈在你的知识体系中只是其中的一个面，其他的很多面其实都是后端开发通用的技术能力，你不必担心这些通用的技术能力在其他企业用不上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;画外音：讲到这里，细心的读者应该可以发现，抽象归纳和顶层设计的能力对于程序员来说，是个需要逐步练习的技能，可以帮助我们看到全局，而只有看到全局，你才能做到胸有全局脉络，又能聚焦局部重点。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;3&lt;/span&gt;其他想说的&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;关于硬技能和软技能&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在职场中，硬技能是我们安身立命的基础，它是硬核的，即我们所掌握的开发语言、框架、中间件 和 项目经验。软技能是我们扩展边界的条件，它是加分项，可以在我们达到开发角色边界的时候帮助我们跨上一个新台阶，比如Team Leader或Project Manager等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;341&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;340&quot; data-ratio=&quot;0.3318534961154273&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fCpd1cf8iacYVFJUtUdwrENd5no68ft7sE2fPPctdiaTNuIssQNPyWw6DPqP8H8Y4XKMjKxicjfxbbm26tddRZnhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;901&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;技术人职场打怪升级路线&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在职场中，我们首先是做事，通过硬核技能写好代码做好服务，等到一定时机，我们有机会管事（比如Team Leader），再管人（比如Manager），最后管心（比如Director或CIO/CTO）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;185&quot; data-backw=&quot;328&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;328&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;109&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fCpd1cf8iacZnibZG0ra87V5DHSibFtJmeeXibAcTjqPDFSveLpBl0lSfvy6u8H6xicV8icRDX1CgI44tfS8tibaznvmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么技术人越成长晋升，关注点都会慢慢聚焦到人和人心上面？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为&lt;strong&gt;人心比系统复杂&lt;/strong&gt;，架构师处理的是多个系统之间的连接关系，而管理者处理的其实是多个人心之间的连接关系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;我的一点成长经验&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我在职场中也没有做到什么高级管理者的位置，但我现在逐步养成了拔高自己的视角去看待一些问题，我也有了一些自己的成长经验，我觉得以下几点对初入职场和初中级开发工程师都是有用的（如果你也认可）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;185&quot; data-backw=&quot;328&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;317&quot; data-ratio=&quot;0.6188340807174888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fCpd1cf8iacYVFJUtUdwrENd5no68ft7suTqKX2yXeCXIfTc2hPvVkjiboGesTUL54erdujnTTCLLINLDp0d4OBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一点，&lt;strong&gt;积极主动做事&lt;/strong&gt;。职场中积极主动做事的人，运气都不会太差，机会一定都是会留给积极做事有准备的人。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二点，&lt;strong&gt;努力扩展边界&lt;/strong&gt;。任何成长阶段都有自己的边界，而渴望成长的人总是希望在几年或多年的时间里上一个新台阶。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第三点，&lt;strong&gt;及时总结复盘&lt;/strong&gt;。当你努力踏上一个新的台阶时，你总是不习惯或者不适应的，你会踩很多很多的坑，这时你需要及时对踩过的坑进行总结复盘，避免下次再犯。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这三点其实是有一个顺序关系的，你只有积极主动做事，才会在大概率的情况下得到拓展边界（踏上新的成长台阶）的机会，而当你踏上新台阶时，一定会碰到各种各样的问题（因为要处理问题的复杂度提升了）进而踩很多坑，这时你就需要及时总结复盘，避免多次犯同样的错误。如此，这就是一轮成长的闭环，而技术人的职场进阶路线就是一个又一个这样的闭环。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;4&lt;/span&gt;小结&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;本文介绍了IT技术人的知识体系的概念，如何通过 点-线-面 理论来构建自己的知识体系，最后给出了一个后端技术人知识体系的示例，你可以根据自己的需求进行完善。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，你有没有开始计划去整理你的知识体系呢？欢迎留言，一起交流！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;配套视频&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section/&gt;&lt;p&gt;&lt;span&gt;后台回复：&lt;strong&gt;面试知识树&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;即可获得.NET开发面试知识体系pdf&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;__bg_gif&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_gif/r0Yeg3pq20kXBcStvMoDUdhY0LlibllkRC7l9RV1ROKHxIuCfQfTy09WLHTwN8l72OX2JV3z0lQXfsdQWCZ5BiaA/640?wx_fmt=gif&quot; data-ratio=&quot;0.125&quot; data-type=&quot;gif&quot; data-w=&quot;720&quot; data-width=&quot;80%&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/r0Yeg3pq20kXBcStvMoDUdhY0LlibllkRC7l9RV1ROKHxIuCfQfTy09WLHTwN8l72OX2JV3z0lQXfsdQWCZ5BiaA/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;年终总结：&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4NzQzNTg4Ng==&amp;amp;mid=2651734149&amp;amp;idx=1&amp;amp;sn=75f3bfceff058042c764efd094cbf158&amp;amp;chksm=8bc39f84bcb41692500a44c5a4a69e6c867cd7c600bf4e0bfe2ece1988a3688b5b5fc3a0a73f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Edison的2020年终总结&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;Edison的2020年终总结&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数字化转型：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4NzQzNTg4Ng==&amp;amp;mid=2651732970&amp;amp;idx=1&amp;amp;sn=c0f217fced5d68ef81246c9b0e7528c8&amp;amp;chksm=8bc3e4ebbcb46dfd58b37b7d6d49095887e943b9eb288dc114a314d1449c4d1938e0d0ca8cc5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;我在传统企业做数字化转型&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Edison在传统企业做数字化转型&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;技术管理：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4NzQzNTg4Ng==&amp;amp;mid=2651733864&amp;amp;idx=1&amp;amp;sn=f06e2b737419b3e04ac313f62176c978&amp;amp;chksm=8bc3e069bcb4697f27e7f92a746780629e46ee95949f3e1dc22a141621dbb38bc22e862a5b67&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;IT技术人的技术管理学习进阶&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;IT技术人的技术管理学习进阶&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;商业知识：&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4NzQzNTg4Ng==&amp;amp;mid=2651734202&amp;amp;idx=1&amp;amp;sn=3bbca266c43e43a0bfe3cd98b7bf54c6&amp;amp;chksm=8bc39fbbbcb416adba16fb085660eba6ae57f7675790237fce41761ba6c928e138626b588d8a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;技术人的底层商业知识系列文章目录&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;IT技术人的底层商业知识兵器库&lt;/a&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;.NET大会：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4NzQzNTg4Ng==&amp;amp;mid=2651734305&amp;amp;idx=1&amp;amp;sn=475e554e2da5f39d1d4ee004bc8f476b&amp;amp;chksm=8bc39e20bcb41736cd4d4b64acd7d7c2715d7c3ec52df6c5b2f4ed31bca78e65ce7ae6674773&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2020年中国.NET开发者大会PDF资料&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;2020年中国.NET开发者大会PDF资料&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;👇扫码关注EdisonTalk&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA4NzQzNTg4Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/fCpd1cf8iacbJedmiaPXbPDa7ZPs4ianVyxeKwdNgZib1h5xktrFemhPvXA9sZ7lEn2CQesXavQzX16doZicUwfpQag/0?wx_fmt=png&quot; data-nickname=&quot;EdisonTalk&quot; data-alias=&quot;edc-talk&quot; data-signature=&quot;勤于学习 • 善于总结 • 乐于分享&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-type=&quot;gif&quot; data-ratio=&quot;0.2778649921507064&quot; data-w=&quot;637&quot; class=&quot;__bg_gif&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/ANsQAmJ8oxXiac1myuYZopO7E8a8nT2Fb4QS0ZNkicxPRZfU9rMEQCySgCkZ2eXbvCCtQRLDu1NUmoMancYFxSfQ/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>eba48463752fd8f324bbca430a08684f</guid>
<title>架构设计笔记（八）：详细方案设计</title>
<link>https://toutiao.io/k/pbf0cqj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3SkyOMFuaN3dAIxTqzOGiazewxYDEIZL30o7cjpB1egceSXfhWfctGiajN9lMbELciaHrQ3hNArEib7R39s9H4f8uw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;2021年 中国南海&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上篇说了，我们整个系统的复杂度在于高性能高可用的读和写。读达到了八万多，写达到了两万多，这个要求在一般的软件系统里面还是比较高的。先说一下我们的技术栈是Java，后端存储使用关系型数据库Mysql，前后端分离，有PC端，APP都是原生开发，15个人的研发力量。所谓详细设计其实就是需要确定细节，架构层面将诸多架构细节确定下来，按照确定好的细节在进行逐步推进。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们从三个层面进行讨论。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;单体应用层面&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于单机服务来说，单应用内部需要结合缓存、数据量连接池、代码优化等方式来提高单体应用的性能，同时服务器硬件性能能提高的就提高。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;缓存使用Redis，保证缓存数据可以落地，并且支持缓存集群&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据库连接池使用HikariCP，不再使用Druid&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;统一编码规范，如字符串拼接不能使用String直接进行，多用Threadlocal，禁用For循环查询数据库&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;JVM的优化&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;SQL的优化，查看执行过程耗时，特别是多表的级联查询问题&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;架构层面&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;宏观上保证系统高性能和高可用，从成熟的解决方案中进行筛选，适用系统场景。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;单个服务都是无状态服务，保证服务可以水平扩展，同时满足了高性能和高可用&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;集中管理session数据，Redis集群存储&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;搭建负载均衡服务，分配请求到各个无状态服务，算法使用负载最低优选原则，通过zookeeper来获取服务的负载状态&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;单个数据库连接有限，数据库采用一主两备方式提供服务，主数据库提供写操作，2个备份服务器提供读操作&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;主备同步机制使用Mysql主从同步机制即可，读取不是强时效性，所以可以存在延迟&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;主数据库暂时不进行分库，根据目前资源，需要从业务层面在降低大量写库的压力&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不做微服务架构，由于系统目前业务比较简单，服务治理和服务边界划分等会增加大量的工作量&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;业务层面&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从高性能和高可用为出发点，有些性能问题可以通过业务逻辑进行规避。&lt;/p&gt;&lt;p&gt;先分析一下写的场景，上篇文章中提到的写主要是发生在你每次跑步完成之后上传一条跑步记录，同时会生成一条动态。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;那么跑步记录上传这个逻辑和发动态这两个逻辑，是不是要在一个事务中完成？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;跑步记录上传这个动作是不是要实时的？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当你的网络环境不好的时候，跑步记录不一定说跑完了就马上就上传，其实可以在APP的后台保存记录后，选择适当网络通讯好的时候再上传。这样就避免了高峰期时大批量的跑步记录上传给系统带来的压力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另外一个场景是动态的发布。想想看动态发布是谁在读，那肯定是他的关注的好友在读取这个动态，那么这个信息其实并不是需要即时性的，它可以多刷几次也能读到。这里就可以完全用异步方式去&lt;span&gt;生成动态，扩展一下，异步方式也可以解决跑步记录生成消息通知，总里程计算等其他业务逻辑。&lt;/span&gt;&lt;span&gt;因为写消息队列肯定是比写数据库快多了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;以上，我们从架构宏观到单体应用层面，再到业务场景设计了整个架构的规范细节，当然不能面面俱到，但是大的原则是不会变的，同时需要考虑到研发力量技术栈和周期等外部因素，遵循简单原则和演化原则进行总体架构设计。&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>