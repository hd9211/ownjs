<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>cbb9ac1dc92411698f9c08d5b64336b4</guid>
<title>周末别闲着，快来吧！</title>
<link>https://toutiao.io/k/sat069j</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c20f5dcd0130dd9b24afd980f787b8d7</guid>
<title>AIX 中的 timeout 脚本</title>
<link>https://toutiao.io/k/947t07k</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post&quot;&gt;
&lt;h1 class=&quot;title&quot;&gt;AIX中的timeout脚本&lt;/h1&gt;
&lt;p&gt;
AIX 下没有现成的 &lt;code&gt;timeout&lt;/code&gt; 命令来限时运行命令，于是就想着自己实现一个类似的脚本。本来以为挺简单的一件事情，结果埋者一堆坑。
&lt;/p&gt;

&lt;p&gt;
最后的结果如下：
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-shell&quot;&gt;&lt;span class=&quot;org-keyword&quot;&gt;ksh&lt;/span&gt;
&lt;span class=&quot;org-variable-name&quot;&gt;waitfor&lt;/span&gt;=$&lt;span class=&quot;org-variable-name&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;org-builtin&quot;&gt;shift&lt;/span&gt;
&lt;span class=&quot;org-variable-name&quot;&gt;command&lt;/span&gt;=$&lt;span class=&quot;org-variable-name&quot;&gt;*&lt;/span&gt;
$&lt;span class=&quot;org-variable-name&quot;&gt;command&lt;/span&gt; &amp;amp;
&lt;span class=&quot;org-variable-name&quot;&gt;commandpid&lt;/span&gt;=$&lt;span class=&quot;org-variable-name&quot;&gt;!&lt;/span&gt;
(sleep $&lt;span class=&quot;org-variable-name&quot;&gt;waitfor&lt;/span&gt;;&lt;span class=&quot;org-builtin&quot;&gt;kill&lt;/span&gt; $&lt;span class=&quot;org-variable-name&quot;&gt;commandpid&lt;/span&gt;) &amp;amp; 
&lt;span class=&quot;org-variable-name&quot;&gt;watchdogpid&lt;/span&gt;=$&lt;span class=&quot;org-variable-name&quot;&gt;!&lt;/span&gt;
&lt;span class=&quot;org-builtin&quot;&gt;wait&lt;/span&gt; $&lt;span class=&quot;org-variable-name&quot;&gt;commandpid&lt;/span&gt;
&lt;span class=&quot;org-builtin&quot;&gt;kill&lt;/span&gt; $&lt;span class=&quot;org-variable-name&quot;&gt;watchdogpid&lt;/span&gt;               
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
这里有两个需要关注的地方：
&lt;/p&gt;
&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;&lt;code&gt;(sleep $waitof;kill $commandpid) &amp;amp;&lt;/code&gt; 在超时杀掉工作命令后就退出了，工作命令被杀掉之后 &lt;code&gt;wait $commandpid&lt;/code&gt; 执行完成，主进程继续执行 &lt;code&gt;kill $watchdogpid&lt;/code&gt;.
然而由于监控进程早已退出，在忙碌的系统中，可能出现 &lt;code&gt;$watchdogpid&lt;/code&gt; 被其他进程重复使用，导致误杀其他进程的风险。
要解决这一风险，可以让监控进程在杀掉工作进程后再等待一段时间，以便让主进程杀掉监控进程。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kill $watchdogpid&lt;/code&gt; 在 &lt;code&gt;ksh&lt;/code&gt; 中并不会把子进程一起杀掉，也就是说 &lt;code&gt;sleep $waitfor&lt;/code&gt; 这个进程依然在运行，只不过父进程从 &lt;code&gt;$watchdogpid&lt;/code&gt; 变成了 &lt;code&gt;1&lt;/code&gt;.
不仅如此 &lt;code&gt;AIX&lt;/code&gt; 上的 &lt;code&gt;kill&lt;/code&gt; 居然不支持 &lt;code&gt;PID&lt;/code&gt; 为负数的情况，这使得妄想通过 &lt;code&gt;kill -$watchdogpid&lt;/code&gt; 杀掉整个进程组变得不可能。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;
最后经过尝试，发现在ksh交互模式下，用 &lt;code&gt;kill %jobID&lt;/code&gt; 的方式是能够将整个 &lt;code&gt;JOB&lt;/code&gt; 杀干净的，因此最后的结果如下：
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-shell&quot;&gt;&lt;span class=&quot;org-keyword&quot;&gt;ksh&lt;/span&gt;
&lt;span class=&quot;org-variable-name&quot;&gt;waitfor&lt;/span&gt;=$&lt;span class=&quot;org-variable-name&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;org-builtin&quot;&gt;shift&lt;/span&gt;
&lt;span class=&quot;org-variable-name&quot;&gt;command&lt;/span&gt;=$&lt;span class=&quot;org-variable-name&quot;&gt;*&lt;/span&gt;
$&lt;span class=&quot;org-variable-name&quot;&gt;command&lt;/span&gt; &amp;amp;
&lt;span class=&quot;org-variable-name&quot;&gt;commandpid&lt;/span&gt;=$&lt;span class=&quot;org-variable-name&quot;&gt;!&lt;/span&gt;
(sleep $&lt;span class=&quot;org-variable-name&quot;&gt;waitfor&lt;/span&gt;;&lt;span class=&quot;org-builtin&quot;&gt;kill&lt;/span&gt; $&lt;span class=&quot;org-variable-name&quot;&gt;commandpid&lt;/span&gt;;sleep 1) &amp;amp;
&lt;span class=&quot;org-builtin&quot;&gt;wait&lt;/span&gt; $&lt;span class=&quot;org-variable-name&quot;&gt;commandpid&lt;/span&gt;
&lt;span class=&quot;org-builtin&quot;&gt;kill&lt;/span&gt; %2 &amp;gt;/dev/null 2&amp;gt;&amp;amp;1
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
不过这种实现有个比较大的缺点就是由于整个实现实在交互式ksh环境中执行的，因此会污染 ksh 的 history 命令历史。
&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dc496d31ad79cd3abfed0fdc5486ba8b</guid>
<title>手把手教你实现 Android 编译期注解</title>
<link>https://toutiao.io/k/ds5jwrd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;类似下面这种写法，当View一多得不停的findViewById 写很多行，手写起来很麻烦，我们首先尝试用运行期注解来解决这个问题，看看能不能自动处理这些findViewById的操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.20390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6RgrtwPGnjRCypOQgicFPym5WH3Qrhf9QnTcKsVNVzl8y9JmcOMf0JAq9qoRRJUtXpP1goTD4sHLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先是工程结构，肯定要定义一个lib module。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2625250501002004&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6RgrtwPGnjRCypOQgicFPymuuFfpR3mDDydxlBbPCsMHKOmvTIbV7tQoFjKKQic75eNT35reezwnVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;998&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其次定义我们的注解类：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4666666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6RgrtwPGnjRCypOQgicFPymkqL3eFrUjCvzhJdsWdretsj1PZUT05rW59RqUBgN1icJHf9LAQAy4Ng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1170&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有了这个注解的类，我们就可以在我们的MainAcitivity先用起来，虽然此时这个注解还并未起到什么作用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6RgrtwPGnjRCypOQgicFPymibT6H1XtA2Dt7r8FtoT7ic6zHBFJy6HZdX4AmVQYlMTVMY2GmgYUKnUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;到这里要稍微想一下，此时我们要做的是 &lt;strong&gt;通过注解来将R.id.xx 赋值给对应的field&lt;/strong&gt;，也就是你定义的那些view对象(例如红框中的tv)，对于我们的lib工程来说，因为是MainActivity 要依赖lib，自然你lib不可以依赖Main所属的app工程了，这里有2个原因：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以这个问题就变成了，lib工程 只能拿到Acitivty，拿不到宿主的MainActivity , 既然拿不到宿主的MainActivity，那我怎么知道这个activity有多少个field？这里就要用到反射了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;BindingView&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;init&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;Activity activity&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Field[] fields = activity.getClass().getDeclaredFields();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (Field field : fields) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            BindView annotation = field.getAnnotation(BindView.class);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (annotation != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; viewId = annotation.&lt;span class=&quot;code-snippet__keyword&quot;&gt;value&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                field.setAccessible(&lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    field.&lt;span class=&quot;code-snippet__keyword&quot;&gt;set&lt;/span&gt;(activity, activity.findViewById(viewId));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (IllegalAccessException e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    e.printStackTrace();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最后我们在宿主的MainActivity中调用一下这个方法 即可：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.68515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6RgrtwPGnjRCypOQgicFPymUqkCraGxDYewIrCLP8jAxyDy83wpQiboU8xPHA9VtPZ8icoewuORXS9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;到这里其实有人就要问了，这个运行时注解看起来也不难啊，为啥好像用的人不是很多？问题就出在刚才反射的那堆方法里，反射大家都知道 会对Android运行时带来一些性能损耗，而这里的代码是一段循环， 也就是说这里的代码会随着你使用lib的Activity的界面复杂程度的提高 而变得越来越慢，这是一个会&lt;strong&gt;随着你界面复杂度提高而逐步劣化&lt;/strong&gt;的过程， 单次反射对于今天的手机来说几乎已经不存在什么性能消耗了，但是这种for循环中使用反射还是尽量少用。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;为了解决这个问题，就要使用编译期注解。现在我们来尝试用编译期注解来解决上述的问题。前面我们说过，运行期注解可以用反射来拿到宿主的field 从而完成需求，为了解决反射的性能问题，我们其实想要的代码是这样的：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们可以在app 的module 中新建一个&lt;span&gt;MainActivityViewBinding&lt;/span&gt;的类：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.188911704312115&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6RgrtwPGnjRCypOQgicFPymemPqwichv2Sm8U49K0NwADrjfSfl9ib5OHBgVYc74BKfwLAGmh9hPv4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;974&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;然后在我们的BindingView(注意我们的BindingView是在lib module下的)中来调用这个方法不就解决这个反射的问题了吗？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6RgrtwPGnjRCypOQgicFPymt28ROu1963WPicLGib7UM8w4XNwNUl25g6Gj3J6g13bIfog2c8oy11OA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是这里会有个问题 就是你既然是一个lib 你不能依赖宿主 ，所以在lib Module 中你其实拿不到 MainActivityViewBinding 这个类的，还是得利用反射。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;141&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.24375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6RgrtwPGnjRCypOQgicFPym6UPrSqR3jXeY3D8g4ia7R5R2Lj5ZpFkgialre9zXTqtmFTxibDpYfgEVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;可以看一下上面注释掉的代码，为啥不直接字符串写死？因为你是lib库你当然得是动态的，不然怎么给别人用？其实就是获取宿主的class名称然后加上一个固定的后缀ViewBinding 即可。这个时候 我们就拿到这个Binding的class了，对吧，剩下就是调用构造方法即可。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; BindingView {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; init(Activity activity) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Class bindingClass = Class.forName(activity.getClass().getCanonicalName() + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;ViewBinding&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Constructor &lt;span class=&quot;code-snippet__keyword&quot;&gt;constructor&lt;/span&gt; = bindingClass.getDeclaredConstructor(&lt;span class=&quot;code-snippet__params&quot;&gt;activity.getClass()&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;constructor&lt;/span&gt;.newInstance(&lt;span class=&quot;code-snippet__params&quot;&gt;activity&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } catch (&lt;span class=&quot;code-snippet__params&quot;&gt;ClassNotFoundException | NoSuchMethodException e&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            e.printStackTrace(&lt;span class=&quot;code-snippet__params&quot;/&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } catch (&lt;span class=&quot;code-snippet__params&quot;&gt;IllegalAccessException e&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            e.printStackTrace();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (InstantiationException e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            e.printStackTrace();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (InvocationTargetException e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            e.printStackTrace();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;看下此时的代码结构：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_png/4g5IMGibSxt6RgrtwPGnjRCypOQgicFPymFbglomibnmrYCZm47fUGbUmVGRU5BIicsFxOJXVbh21zpc4yu8ebb8Mg/0?wx_fmt=png&quot; data-cropx1=&quot;-0.8754325259515571&quot; data-cropx2=&quot;837.7889273356401&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;677.584775086505&quot; data-ratio=&quot;0.8100358422939068&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt6RgrtwPGnjRCypOQgicFPymkxOryRI2SRELIPIOkTicqs6nb7YeyD5lib31teBicjE6L4n8PZSdXr0MA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;837&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有人这里要问，这里你不还是用了反射么，对! 这里虽然用了反射，但是我这里的反射只会调用一次，不管你的activity有都少field，在我这里反射方法都只会执行一次。所以性能肯定是比之前的方案要快很多倍的。接着看，虽然此刻代码可以正常运行，但是还有一个问题， 虽然我可以在lib中调用到我们app宿主的类的构造方法，但是，&lt;span&gt;&lt;strong&gt;宿主的这个类依旧是我们手写的啊&lt;/strong&gt;？&lt;/span&gt;那你这个lib库 还是没有起到任何可以让我们少写代码的作用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个时候就需要我们的apt 出场了，也就是编译期注解的核心部分了。我们创建一个&lt;span&gt;&lt;strong&gt;J&lt;/strong&gt;&lt;strong&gt;ava Library&lt;/strong&gt;&lt;/span&gt;，注意是Java lib不是android lib，然后在app module中引入他。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;注意 引入的方式 不是imp了，是annotation processor ；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_png/4g5IMGibSxt6RgrtwPGnjRCypOQgicFPymnZ7P2Zia4mWgBmT30x8VAxyBqoOicm6JEyoQWw3DLLF5pYND99QZicxmw/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1065&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;350.08650519031147&quot; data-ratio=&quot;0.3286384976525822&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt6RgrtwPGnjRCypOQgicFPym7zaAsIyia8JORsKDbEoakk2ibrcHBgyCy7CQbhTU1094AuIm1jcpycCg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1065&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;然后我们来修改一下lib_processor,首先创建一个 注解处理类：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;117&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.20177562550443906&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6RgrtwPGnjRCypOQgicFPymI9MLmxH8ibbKCzco3UPFRxJ4aVWgZYrDdoarD4fiahCU34ia32VDbqxyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1239&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;再创建文件&lt;span&gt;resources/META-&lt;/span&gt;&lt;span&gt;INF&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;services/javax.annotation.processing.Processor&lt;/span&gt; ,这里要注意 文件夹创建不要写错了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5511811023622047&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6RgrtwPGnjRCypOQgicFPymiaBgbaVu0icylttfxMMQtfbDTq9eQxyWPr1icUdfZ9bAGdTEMBwbVaKGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1016&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;然后再这个Processor指定 一下我们的注解处理器即可：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;168&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.28984375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6RgrtwPGnjRCypOQgicFPymmtoTynnTogib9RvlF6TCHcwsyEgFEcJRzUfibmgtJAyfvBw0MicLdEf3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;到这里还没完，我们得告诉这个注解处理器 只处理我们的BindView注解即可，否则这个注解处理器默认处理全部注解 速度就太慢了，但是此时 我们的BindView这个注解类还在lib仓里面，显然我们要调整一下我们的工程结构：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7684630738522954&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6RgrtwPGnjRCypOQgicFPym6QOWoibDpL7VptLPocGYwxCwCop4fOM2uoDG22bbRNRdaWIf72lCbJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1002&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们&lt;span&gt;&lt;strong&gt;再新建一个Javalib，只放BindView即可&lt;/strong&gt;&lt;/span&gt;，然后让我们的lib_processor和app 都依赖这个lib_interface即可。再稍微修改一下代码，此时我们是编译期处理，所Policy不用是runtime了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Retention&lt;/span&gt;(RetentionPolicy.SOURCE)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Target&lt;/span&gt;(ElementType.FIELD)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__meta&quot;&gt;@interface&lt;/span&gt; BindView {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;BindingProcessor&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;AbstractProcessor&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Messager messager;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ProcessingEnvironment processingEnvironment)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        messager = processingEnvironment.getMessager();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        messager.printMessage(Diagnostic.Kind.NOTE, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot; BindingProcessor init&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;super&lt;/span&gt;.init(processingEnvironment);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Set&amp;lt;? extends TypeElement&amp;gt; set, RoundEnvironment roundEnvironment)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; Set&amp;lt;String&amp;gt; &lt;span class=&quot;code-snippet__title&quot;&gt;getSupportedAnnotationTypes&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; Collections.singleton(BindView.class.getCanonicalName());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;到此我们的大部分工作就处理完毕了。再看一下代码结构（这里的代码结构一定要理解清楚为什么这样设计，否则你是学不会编译期注解的）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.0059055118110236&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6RgrtwPGnjRCypOQgicFPymDZETict5NzRBMaHHmvFl2KqcQo9xY1IBticXPUgAhlgOIZ5Bm3X0KRqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1016&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们现在已经能够做到 通过 lib 这个sdk 调用到&lt;span&gt;MainActivityViewBinding&lt;/span&gt;这个里面的方法，但是他 还在app仓是我们手写的，不太智能，还没办法用。我们需要在注解处理器里面 ，动态的生成这个类，只要能完成这个步骤，那我们的SDK也就基本完成了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里要提一下，很多人注解始终学不会就是卡在这里，因为太多的文章或者教程上来就是Javapoet 那一套代码，压根学不会，或者只能复制粘贴别人的东西，稍微变动一下就不会了，其实这里最佳的学习方式是先用StringBuffer 字符串拼接的方式 拼出我们想要的代码就可以了，通过这个字符串拼接的过程 来理解对应的api以及生成java代码的思路，然后最后再用JavaPoet来优化代码即可。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们可以先思考一下， 如果用字符串拼接的方式来做这个生成类的操作要完成哪些步骤。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;首先要获取哪些类使用了我们的BindView注解；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;获取这些类中使用了BindView注解的field以及他们对应的值；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;拿到这些类的类名称以便我们生成诸如MainActivityViewBinding这样的类名；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;拿到这些类的包名，因为我们生成的类要和注解所属的类属于同一个package 才不会出现field 访问权限的问题；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;上述条件都具备以后 就用字符串拼接的方式 拼接出我们想要的java代码 即可。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里就直接上代码了，重要部分 直接看注释即可，有了上面的步骤分析再看代码注释应该不难理解。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; BindingProcessor &lt;span class=&quot;code-snippet__keyword&quot;&gt;extends&lt;/span&gt; AbstractProcessor {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Messager messager;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Filer filer;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Elements elementUtils;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; synchronized &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; init(ProcessingEnvironment processingEnvironment) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        messager = processingEnvironment.getMessager();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        filer = processingEnvironment.getFiler();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        elementUtils = processingEnvironment.getElementUtils();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        messager.printMessage(Diagnostic.Kind.NOTE, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot; BindingProcessor init&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;super&lt;/span&gt;.init(processingEnvironment);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; generateCodeByStringBuffer(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; className, List&amp;lt;Element&amp;gt; elements) throws IOException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; packageName = elementUtils.getPackageOf(elements.get(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;)).getQualifiedName().toString();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        StringBuffer sb = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; StringBuffer();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        sb.append(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;package &quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        sb.append(packageName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        sb.append(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;;\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        final &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; classDefine = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;public class &quot;&lt;/span&gt; + className + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;ViewBinding { \n&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        sb.append(classDefine);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; constructorName = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;public &quot;&lt;/span&gt; + className + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;ViewBinding(&quot;&lt;/span&gt; + className + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot; activity){ \n&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        sb.append(constructorName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (Element e : elements) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            sb.append(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;activity.&quot;&lt;/span&gt; + e.getSimpleName() + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;=activity.findViewById(&quot;&lt;/span&gt; + e.getAnnotation(BindView.class).value() + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;);\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        sb.append(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;\n}&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        sb.append(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;\n }&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        JavaFileObject sourceFile = filer.createSourceFile(className + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;ViewBinding&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Writer writer = sourceFile.openWriter();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        writer.write(sb.toString());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        writer.close();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;boolean&lt;/span&gt; process(Set&amp;lt;? &lt;span class=&quot;code-snippet__keyword&quot;&gt;extends&lt;/span&gt; TypeElement&amp;gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;set&lt;/span&gt;, RoundEnvironment roundEnvironment) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Map&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;, List&amp;lt;Element&amp;gt;&amp;gt; fieldMap = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (Element element : roundEnvironment.getElementsAnnotatedWith(BindView.class)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; className = element.getEnclosingElement().getSimpleName().toString();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (fieldMap.get(className) != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                List&amp;lt;Element&amp;gt; elementList = fieldMap.get(className);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                elementList.add(element);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                List&amp;lt;Element&amp;gt; elements = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                elements.add(element);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                fieldMap.put(className, elements);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (Map.Entry&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;, List&amp;lt;Element&amp;gt;&amp;gt; entry : fieldMap.entrySet()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                generateCodeByStringBuffer(entry.getKey(), entry.getValue());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (IOException e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                e.printStackTrace();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; Set&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;&amp;gt; getSupportedAnnotationTypes() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; Collections.singleton(BindView.class.getCanonicalName());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最后看下效果：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;156&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.2703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6RgrtwPGnjRCypOQgicFPyml9qejETB6uP4hcs2SBE5x9j4MGF1fOe06PPljQyprH4VtXc5uY2Dsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;虽然生成的代码格式不太好看，但是运行起来是ok的。这里要注意一下Element 这个接口，实际上使用编译期注解的时候 如果能够理解了Element，那后续的工作就简单不少。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;317&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5492700729927007&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6RgrtwPGnjRCypOQgicFPymbvv9zUicmCr9DYWsVbEXYMMc3RTqDqjEN78RVFwI4I9oQBDBFYNsBmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1096&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;主要关注Element的这5个子类即可，举个例子：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;package&lt;/span&gt; com.smart.annotationlib_2;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;VivoTest&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; a;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;VivoTest&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; b )&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.a = b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b3a92d8232df7d7884d3ca23054b7e1c</guid>
<title>[推荐] 将你的 Windows，快速打造成 Docker 工作站</title>
<link>https://toutiao.io/k/138vl3z</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;174&quot; data-backw=&quot;365&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4767123287671233&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/cvQbJDZsKLp6wejHtKTRbqqQyt0wMk9K1wNtuwRqQTJAPOJ1KiaqSeSRbIJRTicVicKpDKRndBodY2DBNN20tvWwA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;365&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原创：小姐姐味道（微信公众号ID：xjjdog），欢迎分享，转载请保留出处。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;手里的macbook因为键盘问题返厂维修了，只好抱起了久违的Windows。首先面临的，就是Docker问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;docker好用，但安装麻烦，用起来也命令繁多。一个小白，如何打造舒适的docker环境，是一个非常有挑战的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文将手把手的教你怎么把docker方便的搞到windows上，打造一个好用的开发环境，并安装好用的管理工具。所以本文包含以下内容：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;安装Windows10&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;安装WSL2环境&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;安装Ubuntu操作系统&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;安装Docker&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;安装portainer&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用方法&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;篇幅较长，所以本文暂时杜绝废话。力求一气呵成，半小时内手握白富美。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 安装WSL2&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 安装Windows Terminal&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在远程连接其他Linux的时候，我通常使用&lt;code&gt;Xshell&lt;/code&gt;，就因为它长得比较漂亮耐看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Windows上，就可以安装&lt;code&gt;Windows Terminal&lt;/code&gt;。有点类似于MacOS上的&lt;code&gt;iTerm&lt;/code&gt;，可以说是Windows下最舒适的终端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装&lt;code&gt;Windows Terminal&lt;/code&gt;需要从应用商店去获取，就是下面这个按钮。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/cvQbJDZsKLpMicibT8xBYNRorRibpKeicqJUH11yHD5dQxzKPJ6iaNRvbNwBH806nbx3icbHme4wXR8l22VQRhKnuEEw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在搜索框里搜索&lt;code&gt;Windows Terminal&lt;/code&gt;，即可找到这个软件。比较人性化的一点是，它不像Mac的应用商店一样，需要你先准备一个账号。WT不需要登录即可获取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的页面一直打转也不要紧，关闭重新打开几次就好了。由于众所周知的原因，国外网站就没有几个不转圈的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.593929450369155&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/cvQbJDZsKLpMicibT8xBYNRorRibpKeicqJUicu7hk5XaFZfLbTsUyCRYicMyz6N3iaMJ594eyyiaSibk79g5I7o0xE0LzA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1219&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 开启WSL2&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图，在控制面板，找到程序选项，点击 “启用或关闭Windows功能”。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4383318544809228&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/cvQbJDZsKLpMicibT8xBYNRorRibpKeicqJURtJgZoTvQuTB6IaCaosYRmoauA9dcTVGF9RW1YqJlx3ZKfkIXCUTwQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1127&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从弹出的对话框里，划到最下边，然后给“适用于Linux的Windows子系统“，打勾，完事！&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5883376849434291&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/cvQbJDZsKLpMicibT8xBYNRorRibpKeicqJUw7CBzHYhJCWqP8c3rlSibsKFpWFIruBTgNBP2F2XsdNIFd70HWx8Jibw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1149&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要启用WSL2，必须要把Windows10升级到最新版本才可以。在Powershell中，执行下面命令，切换成WSL2版本。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;wsl --set-default-version 2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2 安装Ubuntu子系统&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从应用商店安装Ubuntu系统，这个系统将会以软件的形式存在。我这里选择的是LTS版本，可以看到给它打分的人并不多，可能大多数都是像我一样没有微软账号的游客。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5669421487603306&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/cvQbJDZsKLpMicibT8xBYNRorRibpKeicqJURUMQOLmANSxt3j70n0ia1LRXTTCW6fThOuLoJ0LQ2j9yXw01ia0epJyA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1210&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，神奇的事情发生了。在我们的&lt;code&gt;Windows Terminal&lt;/code&gt;右上角，有一个向下的箭头，点击它，就可以看到刚刚安装的Ubuntu。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Windows上离着Linux，只差一次点击而已。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5221987315010571&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/cvQbJDZsKLpMicibT8xBYNRorRibpKeicqJUEibDhRLFeia99uRsBg0E3J9MS3qswdKA3ELwUH34Syicia663jCNrpzvSw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;946&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进入Linux系统之后，我们就可以像配置一个普通Linux一样配置这台机器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先把ubuntu的软件源给换掉。编辑&lt;code&gt;/etc/apt/sources.list&lt;/code&gt;文件，把它的内容换成下面的源。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse&lt;br/&gt;deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse&lt;br/&gt;deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse&lt;br/&gt;deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse&lt;br/&gt;deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse&lt;br/&gt;deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse&lt;br/&gt;deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse&lt;br/&gt;deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse&lt;br/&gt;deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse&lt;br/&gt;deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，安装最好用的&lt;code&gt;oh-my-zsh&lt;/code&gt;。先用&lt;code&gt;sudo apt install zsh&lt;/code&gt;安装shell终端，然后运行下面的命令。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sh -c &lt;span&gt;&quot;&lt;span&gt;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&lt;/span&gt;&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;等待一小段时间，我们的终端颜值就更上一层楼了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 安装Docker&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装Docker，直接从官方下载最新的Windows版本就可以了，不要下载一些其他平台的阿猫阿狗。地址在这里&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;https://www.docker.com/products/docker-desktop&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一路next即可安装。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLpMicibT8xBYNRorRibpKeicqJUrSSETkCvCcylIXkHEQq6P9lbsvPVia7y7TE6LpEUVSTyXn1f28XKS0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动之后，点击设置，然后更改镜像仓库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为一些不可明说的原因，docker官方的镜像仓库无法访问。你可以从下面这些挑选一个，或者直接全部写上 。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;[&lt;span&gt;&quot;https://registry.docker-cn.com&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;https://dockerhub.azk8s.cn&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;https://reg-mirror.qiniu.com&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;http://hub-mirror.c.163.com&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;https://docker.mirrors.ustc.edu.cn&quot;&lt;/span&gt;&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完事之后，不要忘了 &lt;code&gt;apply &amp;amp; restart&lt;/code&gt; 重启生效一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时在右下角，就出现了Docker的小图标，非常的赏心悦目。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 安装 portainer&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有很多Docker的管理工具，但我独爱portainer，原因就是它好用，而且是基于web的。它不仅能管理单机上的docker，还能够管理局域网中的集群，只要你使用&lt;code&gt;-H 0.0.0.0:2375&lt;/code&gt;把它监听在网络上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看它的一张图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLpMicibT8xBYNRorRibpKeicqJUQ3C9ics60BemqQiceUUjQm26p90tWtiakyhpWecwILMYPHxqZkGg9uoqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以说，docker命令能搞的事情，在这个web应用上，都能搞。但首先我们得把它安装上去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打开我们的wsl2的Ubuntu系统，此时你会发现，已经有了docker命令。我们在终端输入以下命令行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;docker volume create portainer_data&lt;br/&gt;docker run -d -p 9000:9000 -p 8000:8000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;稍等片刻，portainer就启动成功了。这得益于我们把镜像仓库切换到国内的原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;访问 http://localhost:9000 端口，将出现portainer的设置界面。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.471875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLpMicibT8xBYNRorRibpKeicqJU5JpCOlwM11FwbAltTOSqqicGXC9RsqBA5Jd3icuctwcfNhwBPS57OcYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在模板页面，有很多常见的软件应用，直接点击部署，就可以将软件安装在系统上。如果你是作为开发机使用，那么推荐使用docker的host模式，相当于使用主机的网络，和安装一个平常的软件没什么区别。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我想要一个MySQL数据库，就不需要再跑到MySQL官方下载一个，然后进入繁杂的安装程序中。直接在Docker上搞一个就可以了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.601081081081081&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLpMicibT8xBYNRorRibpKeicqJUrXPrh1zwNovXKNEkWtJno5Gwz2FDibFIaPJFMJwJzro7FAZtngqYk3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;925&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击小箭头，可以直接在web上进入Docker虚拟环境的命令行终端，非常的方便。如果你平常要调研的额软件和中间件非常的多，想要快速体验它的功能效果，这不得不说是个非常好用的功能。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6153005464480874&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLpMicibT8xBYNRorRibpKeicqJUF7elwEZSddhJamFylvs3CM86GQjgHnezZvkWkib5WAs2YLiaf2ibXSRhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;915&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;End&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到此为止，我们的Docker开发环境就搭建完毕了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你是一个命令行控，可以直接使用WSL终端提供的docker命令进行操作。但如果你对docker并不是非常熟悉，那么就可以使用portainer实现对Docker的管理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;人生苦短，如果把时间都花费在安装软件上，那是多么一件悲哀的事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;搞定Docker，以后安装软件，只需要在google搜一下软件docker启动的命令就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;省时省力，不易出错。即使你的公司没有虚拟化环境，docker作为一个开发工具，依然有它的价值。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;作者简介：&lt;strong&gt;小姐姐味道&lt;/strong&gt;  (xjjdog)，一个不允许程序员走弯路的公众号。聚焦基础架构和Linux。十年架构，日百亿流量，与你探讨高并发世界，给你不一样的味道。我的个人微信xjjdog0，欢迎添加好友，进一步交流。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA4MTc4NTUxNQ==&amp;amp;action=getalbum&amp;amp;album_id=1551616798431690754#wechat_redirect&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;1. 玩转Linux&lt;/a&gt;&lt;br/&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA4MTc4NTUxNQ==&amp;amp;action=getalbum&amp;amp;album_id=1339444055490592770#wechat_redirect&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;2. 什么味道专辑&lt;/a&gt;&lt;/p&gt;&lt;p&gt;3. &lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;amp;mid=2650521059&amp;amp;idx=1&amp;amp;sn=d6742140c684f16cb4435508bdb5a418&amp;amp;scene=21#wechat_redirect&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;蓝牙如梦&lt;/a&gt;&lt;br/&gt;4. &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;amp;mid=2650520865&amp;amp;idx=1&amp;amp;sn=ff7a751a092000a9aec8e47df35ab25a&amp;amp;chksm=8780bae5b0f733f3bd75575ef9c14e548bd833bf2ba1289b6f77fd0bbcc5fbc264c19c8cb04a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;杀机！&lt;/a&gt;&lt;br/&gt;5. &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;amp;mid=2650521617&amp;amp;idx=1&amp;amp;sn=86e4bee100fa78ccc94e24bb27f0e71a&amp;amp;chksm=8780c7d5b0f74ec36bd0a06167f5b84777ecb2d48b57f3d96e3ce3c4575e6b777dda0188376f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;架构师BUG，非比&lt;/a&gt;寻常&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA4MTc4NTUxNQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLrpoDEiau93r55W4t2fdn7HtIUQLGrD0Tnt3SlucZhSN9fIxBic1NB349KKIiaHvCZ0UgGsTjibWehicmA/0?wx_fmt=png&quot; data-nickname=&quot;小姐姐味道&quot; data-alias=&quot;xjjdog&quot; data-signature=&quot;不羡鸳鸯不羡仙，一行代码调半天&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ef0e645f60ad31971d488a90639ac33f</guid>
<title>[推荐] 树莓派家用指北</title>
<link>https://toutiao.io/k/h2njn7z</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;前两天刚刚入职，最近几天忙着租房搬家，忙活了几天总算是住进了自己小屋里，作为一个软件工程师，怎么可以没有一台家用服务器呢？方案有很多种，上至几千元的 NAS，下至淘汰的老电脑，但是旧电脑响声大功耗高，NAS 动辄三四千的价格对我这个刚毕业的大学生来说着实有些困难，于是我将目光放到了另一个小玩意上——树莓派。&lt;/p&gt;&lt;p&gt;我选择树莓派的原因也很简单，第一便宜，第二可查阅的资料非常多，基本上你之后使用过程中的问题网络上都有解决方案了，因此本文不会介绍怎么使用树莓派，怎么烧录系统，这些东西有太多人写过了，我重复写也没什么意思，因此这块内容我就一笔带过了，本文是我自己的家用服务器方案，更多的是提供一个方向性的指导，如果你觉得我的文章对你有所帮助，欢迎点个关注支持一下哦～&lt;/p&gt;&lt;h2&gt;什么是树莓派？&lt;/h2&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTx7ehOiaRuJMA9FtXlibB7ibljibpn3sUAWiasLccmXIRaVfH9UxDmu6lZGw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;打开任何一个搜索引擎在里面输入&lt;strong&gt;「树莓派」&lt;/strong&gt;三个字都会出现很多内容，其实树莓派本质上就是一台小电脑，虽然外形只有信用卡大小，却具有电脑的所有基本功能。和我们平常用的电脑不一样的是，树莓派自身是没有屏幕、键盘、鼠标这些东西的，但是它提供了网口、USB 口以及视频输出口（其实意思就是让你自己配）。&lt;/p&gt;&lt;p&gt;当然了，树莓派和主流电脑一个很大的区别就是他的芯片，和主流的 x86 桌面级电脑不同的是，树莓派用的是低功耗的 ARM 芯片，因此在性能上和常规电脑还是有些差距的，不过随着近年来 ARM 芯片的不断发展，其性能已经和传统 x86 处理器不相伯仲，甚至在某些方面遥遥领先，例如苹果的 M1 芯片。这里推荐阅读我之前写的两篇文章 👉&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&amp;amp;mid=2247484658&amp;amp;idx=1&amp;amp;sn=58a2c7cde1ed027b26f1e2e41deb8bdb&amp;amp;scene=21#wechat_redirect&quot; title=&quot;《M1 暴打 Intel？——x86 与 ARM 的爱恨情仇》&quot; data-linktype=&quot;2&quot;&gt;《M1 暴打 Intel？——x86 与 ARM 的爱恨情仇》&lt;/a&gt;和&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&amp;amp;mid=2247484681&amp;amp;idx=1&amp;amp;sn=aa4ec453f111157205111ec3d6022c5c&amp;amp;chksm=ceb3d1bbf9c458ad33758e466664d1b0bcdc3e5a348f8ad47a6ac068c8102414cdfee6a1140d&amp;amp;scene=21&amp;amp;cur_album_id=1418449495750311936#wechat_redirect&quot; title=&quot;《M1 暴打 Intel？——这次的芯片有何不同》&quot; data-linktype=&quot;2&quot;&gt;《M1 暴打 Intel？——这次的芯片有何不同》&lt;/a&gt;&lt;/p&gt;&lt;p&gt;好在在学校的这些年，有一些闲置的键盘、鼠标和移动硬盘没来得及出手，于是我便果断的选择了树莓派作为我的家用服务器。&lt;/p&gt;&lt;h2&gt;树莓派的选择&lt;/h2&gt;&lt;p&gt;打开淘宝搜索树莓派，眼花缭乱的，那应该如何选择呢？&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7046979865771812&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTvJgOL4qMmulyZyrHhXsry9rHS0GZbQsiaGSP0cdECshnpDQEl1nGfFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1490&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;其实很简单，虽然树莓派的型号众多，但是细分下来也只有三类：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;Model B 系列：旗舰版，接口全，性能强&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;Model A 系列：青春版，外形小，性能一般，配置和接口略有阉割&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;Zero 系列：迷你版，拥有超小身材，性能较弱&lt;/span&gt;&lt;/p&gt;&lt;p&gt;目前，树莓派已经发展到了第四代了，如果资金不是非常紧张的，推荐购买树莓派 4B 版，官网对他的介绍如下：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4879194630872483&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicThVHIcc2Kkkn9X0E0otjPahP5F2ojRwh4PHlNxH8V7gsJ13CFtUMGzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1490&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;相较于前代，处理器性能大幅增强，并且最高支持 8G 内存，支持 4K 视频输出，同时使用 USB- C 供电，完全可以作为一个桌面级电脑使用了，用作家用服务器绰绰有余了。&lt;/p&gt;&lt;h2&gt;操作系统选择&lt;/h2&gt;&lt;p&gt;说完了树莓派的硬件，怎么可以离开软件呢？树莓派相较于传统电脑另一个好处就是可以自由选择烧录的操作系统，官方推荐的是 Raspberry Pi OS，系统的烧录网上的教程太多了，这里我推荐直接使用官方提供的烧录软件&lt;strong&gt;「Raspberry Pi Imager」&lt;/strong&gt;，从下面的图中也可以看出来是一个非常容易上手的软件了。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6588235294117647&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTKcrB20hDj7GAVX2ZiaYp2gsEp8MC3B63lXxM63dJN1ibfhxFunUZy92g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1360&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;SD 卡选择 16G 的即可，如果容量大一些也是可以的，读写速度自然也是越快越好了，这里我烧录的系统是官方推荐的 Raspberry Pi OS，针对树莓派进行了性能优化，由于是基于 Debian 开发的操作系统，经常使用 Ubuntu 的同学上手难度会稍微低一些。&lt;/p&gt;&lt;p&gt;当然了，你也可以选择烧录其他的操作系统，例如 Ubuntu、Manjaro、Android 等操作系统，甚至有人成功烧录了最近新出的 Windows11，链接在这里，有兴趣的小伙伴自行阅读 👉&lt;span&gt;How to Install Windows 11 on a Raspberry Pi 4&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.0615640599001663&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicT1jkQy4JIjMvAfGCWC2NzB3YsTQcfOcBviaup2p6gia2JRZdKTrHBgfjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1202&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h2&gt;家用树莓派方案指北&lt;/h2&gt;&lt;p&gt;说了树莓派软硬件的选择后，终于可以进入本文的正题了。&lt;/p&gt;&lt;p&gt;树莓派的玩法有很多，网上有很多控制机器人、外接灯泡控制开关等，说实话，这些玩法教育意义大于实用意义，毕竟家用也不会把灯泡接到树莓派上，直接买个小米的智能灯泡控制体验不比这个好吗？&lt;/p&gt;&lt;p&gt;之所以一开始就舍弃使用旧电脑作为家用服务器这一方案的一个原因就是功耗，网上有人对树莓派的功耗进行过测试，4B 的功耗：空闲时 2.7 W，负载时到 6.4 W。按照家里电费 0.7 元一度电的价格计算，一年 365 天每天 24 小时高负荷运行的电费也才&lt;strong&gt;6.4×24×365÷1000×0.7=39.2448 元&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4318181818181818&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicT7EIlMpGUIsHYLiaB12VcHTYb14mUFibcIcdSWLnMFDh9gongpAE2w3Yw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;968&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;因此树莓派适用于一些适合 24 小时在线的服务，我的服务有：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;离线下载（Aria2、qbittorrent）&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;米家、HomeKit 等智能家居中转控制（HomeAssistant）&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;局域网文件共享（Samba）&lt;/span&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;Linux Server（Docker）&lt;/span&gt;&lt;span&gt;&lt;span&gt;5.&lt;/span&gt;家庭 Dashboard 中控面板（Flutter Web）&lt;/span&gt;&lt;span&gt;&lt;span&gt;6.&lt;/span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;接下来我将会按照顺序逐一介绍。&lt;/p&gt;&lt;h3&gt;连接树莓派——连通性测试&lt;/h3&gt;&lt;p&gt;想要使用树莓派第一步肯定是连接上树莓派，连接树莓派的方式有很多种，直接接键盘、鼠标、显示器，或者通过 SSH/VNC/FTP，无论用何种方式只要能连接上网络即可。方便起见，建议先连接显示器，然后开启 SSH 和 VNC 服务。网络上的教程很多很详细，这里不再赘述。&lt;/p&gt;&lt;p&gt;本节主要来介绍一个很关键但是很多文章都忽略的内容，即树莓派与个人电脑间的&lt;strong&gt;网络连通性测试&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;如果要实现诸如上述局域网共享文件、离线下载等功能，一个很重要的特点是工作电脑与树莓派之间的&lt;strong&gt;传输速度要快&lt;/strong&gt;，不然我离线下载完文件后传到自己电脑上还要好久，那岂不是多此一举吗？&lt;/p&gt;&lt;p&gt;由于大多数教程中工作电脑与树莓派的连接都是通过 WI-FI 而非网线的方式，因此在一开始就有必要针对二者的网络传输速度做一个测试，这里我推荐使用&lt;strong&gt;「iPerf3」&lt;/strong&gt;，安装和使用都很简单。&lt;/p&gt;&lt;p&gt;我们需要在树莓派上使用 apt 安装 iPerf3，然后启动 iPerf3 的服务。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 安装 iPerf3&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sudo apt install iperf3&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 启动 iPerf3 服务&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;iperf3 -p 3005 -s&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;code&gt;-p&lt;/code&gt;设置监听的端口号，客户端需要使用该端口与服务端进行通信。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;code&gt;-s&lt;/code&gt;设置为服务模式运行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;然后在工作电脑上也安装上 iPerf3 即可，mac 电脑直接执行 &lt;code&gt;brew install iperf3&lt;/code&gt; 即可安装，然后我们只需执行下面的命令即可。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 测试 Mac 与树莓派之间的网速（我的树莓派内网 ip 为192.168.31.189）&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;iperf3 -c 192.168.31.189 -p 3005&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;我的测试结果如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6466165413533834&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTibITmOLGJkricBnYcc9YS7yKH1ib0eb7u1mPuqv9WaawysuQx2GxGngjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1330&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;换算一下，上传下载大约能有 7MB/s 的速度，虽然速度不是很快，但是基本可以用。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;PS：如果有小伙伴测试结束后发现连通速度有些慢，不妨检查下你的树莓派是否连接到 5GHz 的 Wi-Fi 上。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;确认连接速度可以正常使用后，我们便可以来安装使用一个非常重要的工具了——Docker。&lt;/p&gt;&lt;h3&gt;使用 Docker 为树莓派赋能&lt;/h3&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7486263736263736&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicT2Fr6cZjH9WACvSLh0dYO9fFZIEibCMOMWZotfhwkYK1Zu46gDuorF4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;728&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;Docker 的存在使得开发者可以快速搭建自己所需要的开发环境，只需指定好镜像后即可快速生成所需要的容器环境。并且由于树莓派使用的是 ARM 架构的芯片，很多常用软件如果想要正常安装使用需要自行编译，这对于性能不够强悍的树莓派来说无疑是一种负担，为了让我们的精力聚焦在在实际的开发中，而不是纠缠着应用运行环境的问题上，这次我们使用 Docker 搭建所需要的开发环境，为树莓派赋能。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;对 Docker 还不了解的小伙伴可以移步 👉https://yeasy.gitbook.io/docker_practice/&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在树莓派上安装 Docker、配置镜像加速在上面的链接中都已给出，值得一提的是，Docker 的定位在于将容器内的环境搭建起来，但如果我们想将多个容器的运行方式和配置固定下来，应用于容器编排，则需要使用 Docker Compose。&lt;/p&gt;&lt;p&gt;举个例子，我们有一个应用容器，需要 mysql 存储数据， nginx 作转发，消息队列作数据转化，那在每次启动前，需要将每个前置容器先启动，再把应用容器跑起来，这本身就是一个重复的动作。而且在启动时，还需要针对每个容器进行不同的配置，所以为了&lt;strong&gt;实现对多个容器的组合管理&lt;/strong&gt;，例如规定容器启动顺序，规定好配置内容等行为，Docker Compose 便应运而生了。&lt;/p&gt;&lt;p&gt;Docker Compose 的安装方式有很多种，但由于 ARM 架构的限制，树莓派上的 Docker Compose 建议使用 pip 安装。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sudo pip3 install -U docker-compose&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;！！！一定是 Python3 版本的 pip，所以建议直接使用 pip3&lt;/strong&gt;&lt;/p&gt;&lt;h3&gt;监管你的 Docker——Portainer&lt;/h3&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5233333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTD9wIsaZOzkA31AuYvX5IzGcuW6mrjLLZeuHQomW5Gr1iajwpvXKoD5w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;Portainer 是 Docker 的轻量级，跨平台和开源管理 UI。你可以通过 WebUI 管理你的 docker 容器，镜像，网络和卷。他的安装也很简单，直接执行以下命令即可。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;安装完成后如下图所示 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.41005291005291006&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTpD94aK3Lky6cAdpGibBtEpkTwytqAcsLJguV7ib3liaVXsnXRSKxpBcoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1512&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;监控面板——Pi Dashboard&lt;/h3&gt;&lt;p&gt;有了 Docker 之后，我们便可以方便快速的进行各种软件的安装了。为了方便监控我们的树莓派情况，首当其冲的便是 Pi Dashboard。&lt;/p&gt;&lt;p&gt;安装很简单，只需执行下面一行命令 👇&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sudo docker run -d --name docker-pi-dashboard -e &#x27;LISTEN=1024&#x27; --net=host ecat/docker-pi-dashboard&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;启动完毕后可以通过&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sudo docker ps | grep docker-pi-dashboard&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;来确认我们的容器是否启动成功，如果启动成功，在浏览器中输入&lt;code&gt;&amp;lt;你的IP地址&amp;gt;:1024&lt;/code&gt;即可访问到 pi dashboard 了。如下图所示 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6252676659528907&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTOCVPxErLfCYfmw2fO5kJAwX9bibyoqmmUOicfxPCLUXWl1F1NPXOBVvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;934&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;智能家居——HomeAssistant&lt;/h3&gt;&lt;p&gt;智能家居是眼下最火的领域之一，小米、苹果、华为等都在布局该领域，旗下的米家、HomeKit 等都已经提供了非常完善的服务，那么我们为什么要在树莓派上搭建一套智能家居系统呢？&lt;/p&gt;&lt;p&gt;其实原因很简单，虽然目前智能家居产品众多，但是尚未有一种智能家居解决方案同时满足设备种类多、交互体验好、成本低廉的特性，为此很多情况我们都会选择某一家的某一些产品，这就有可能会造成整个家里出现小米的台灯、华为的传感器、苹果的音箱等多种混乱的局面，然后你还要安装多个 App，这种体验无疑是非常差的。&lt;/p&gt;&lt;p&gt;在计算机领域有一句名言——&lt;strong&gt;所有兼容问题都可以通过加一层抽象解决，所有性能问题都可以通过去掉一层抽象解决。&lt;/strong&gt;既然这样，何不在这些智能家居平台基础上再抽出一层，提供一个统一的控制入口？&lt;/p&gt;&lt;p&gt;答案自然是可以的，并且已经有人将方案开源出来了，这就是本节要介绍的 HomeAssistant。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.45717344753747324&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTXkKkHVKzL0Yncs1I7KQIjaZJMwQfMKbelBzQ2bv24KY8ODf4aJsD1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;934&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;无论是米家还是 HomeKit 都只能在各自的生态中使用，米家只有移动端 App，HomeKit 虽然覆盖了平板、手机、电脑、手表等，但也仅限苹果生态。（互联网发展了这么多年，却忘记了他最开始的形态，真不知道这是一种进步还是一种悲哀）&lt;/p&gt;&lt;p&gt;扯了这么远，回到正题，HomeAssistant 的安装使用非常简单，官网已经写的非常详细了 👉https://www.home-assistant.io/installation/raspberrypi#docker-compose&lt;/p&gt;&lt;p&gt;推荐使用 Docker Compose 安装。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;yaml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;version: &quot;3&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;services:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  homeassistant:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    container_name: homeassistant&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    image: &quot;ghcr.io/home-assistant/raspberrypi4-homeassistant:stable&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    volumes:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      - /PATH_TO_YOUR_CONFIG:/config&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      - /etc/localtime:/etc/localtime:ro&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    restart: unless-stopped&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    privileged: true&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    network_mode: host&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;指定好 volumes 的路径后执行&lt;code&gt;docker-compose up -d&lt;/code&gt;指令即可。&lt;/p&gt;&lt;h3&gt;米家的接入&lt;/h3&gt;&lt;p&gt;安装好之后你的家庭应该是空的，如果想要绑定米家设备，可以接入米家的 MIoT 插件，文档 👉https://github.com/al-one/hass-xiaomi-miot/blob/master/README_zh.md&lt;/p&gt;&lt;p&gt;填写好自己的小米账号和密码后，即可利用网页在 HomeAssistant 中查看使用自己的米家设备，以此达到跨平台的目的。下图是我自己配置的控制页面 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3484848484848485&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTsR1YcHs9vBAibtibTwU5zdHvibbxlCCuLyZS8LdUhJMQ6YBxIZ1vn26lA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1914&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;开放能力——REST API&lt;/h3&gt;&lt;p&gt;如果只是提供了一个网页用于控制，那么本质上也就是在交互体验上进行了优化，并不值得单独开一小节。HomeAssistant 作为一个开源产品，最大的优势在于提供了开放的能力，使每个用户按照自己的想法去进行更改设置，我们完全可以根据 HA 提供的 REST API 针对自己的需求定制化。（例如制作一个属于你自己的家庭枢纽，后面会提到）&lt;/p&gt;&lt;p&gt;HomeAssistant 默认是不会开放 REST API 功能，你需要在&lt;code&gt;configuration.yaml&lt;/code&gt;文件中配置一下&lt;code&gt;api&lt;/code&gt;选项，如下图所示 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.39290586630286495&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTHfG7yg2o5nCMjVsWoXXYpwx2IElEsrm71gUeibH9EicPOWsQicecp8QQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;733&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;关于 HomeAssistant 可配置的选项还有很多，具体的可以参考文档 👉https://developers.home-assistant.io/&lt;/p&gt;&lt;h3&gt;离线下载——Aria2&lt;/h3&gt;&lt;p&gt;有些资源下载时间较长，不适合电脑长期挂机下载的，这时就可以将我们的树莓派变成一个离线下载的服务器。提到下载，不可不提的一个神器便是 Aria2。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.2391713747645951&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTUXus5gHY0Q8YibCGOhBU1epNMlme8PEVP8ibE4htSbckTJw0wreZ3xkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;531&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;Aria2 是一款自由、跨平台&lt;strong&gt;命令行界面&lt;/strong&gt;的下载管理器，和 wget 这类下载器不同的是，Aria2 不仅支持 BitTorrent，还能够从各种来源多路检索所请求的文件。包括 HTTP，HTTPS，FTP 和 BitTorrent 协议。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;对种子下载原理感兴趣的同学可以阅读我的这篇文章 👉&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&amp;amp;mid=2247484780&amp;amp;idx=1&amp;amp;sn=f4c12708e159821f700811b1dc1be35c&amp;amp;scene=21#wechat_redirect&quot; title=&quot;《人人都是 LSP？—— 种子与文件下载的相爱相杀》&quot; data-linktype=&quot;2&quot;&gt;《人人都是 LSP？—— 种子与文件下载的相爱相杀》&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;而且 Raspbain 系统默认已经安装了 Aria2，运行 apt-cache show aria2 即可查看安装信息，因此我们要做的就是为 Aria2 找一个图形化界面即可，使用 Docker 的一大好处就是可以直接去找别人已经打包好的镜像文件，让安装使用变得十分易用。&lt;/p&gt;&lt;p&gt;只需执行下述命令即可启动一个 Aira2 的图形化界面了 👇&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;docker run -d --name aria2-ui-pi -p 8888:80 -p 6800:6800 -v /data:/data --restart=always huangzulin/aria2-ui-pi&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;p&gt;默认下载路径是在容器内的 /data 文件夹，为了方便使用最好指定一个 volume 映射&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;局域网文件共享——Samba&lt;/h3&gt;&lt;p&gt;现在，手机是 Android/iOS，电脑是 Win/Mac，除去苹果生态，设备与设备之间的文件传输直至今日仍然是一个大问题。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.42875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTXa1WnX0lGtFUcY4WpuByyFDrQ89H8M8L5F7Ytu1CVR8MTScyZaIr8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;Samba 是在 Linux 和 UNIX 系统上实现 SMB 协议的一个免费软件，SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。通过该协议，你可以快速方便的在 Win 与 Linux/Unix 之间分享文件，而不是通过 QQ 在线传文件。&lt;/p&gt;&lt;p&gt;安装过程也十分简单，你可以选择 apt 安装也可以选择 docker 直接安装，网上的教程非常多，详情可参考 👉&lt;span&gt;在树莓派上配置 Samba 服务教程&lt;sup&gt;[2]&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;打造属于你自己的家庭枢纽&lt;/h3&gt;&lt;p&gt;无论是 HomeAssistant 还是 Aria2，这些都是别人写好的东西，如果你想让树莓派更加定制化，你可以按照自己的想法去边写一些小程序（这也就是为什么之前要提一下开放 HomeAssistant 的 REST API）。&lt;/p&gt;&lt;p&gt;如果想要让自己的程序运行在树莓派上，大致有以下几条路可以走 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5580568720379147&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicT6ZX8icIuZPtCNtvIHdJ6Ply072d2icJjr1icTgPPAs3mZefHpw4RC4wAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;844&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;为了打造一个属于自己的家庭枢纽，我的想法是在一块&lt;strong&gt;可以触摸的屏幕&lt;/strong&gt;上控制自己家的智能家居设备（借助 HomeAssistant），直观地查看天气（和风天气），追踪快递行程（爬虫）、时钟、纪念日/倒数日/照片墙等，因此这是一个完整的网页，我选择的技术栈是 SpringBoot + Flutter Web + Nginx，然后使用 Docker 打包成一个镜像启动整个服务。&lt;/p&gt;&lt;p&gt;部分页面如下 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4071573261309926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTQODBvtibq3uNmOM6nHcfU9ckyDenX7jMALXWp1ygakePmAicDDN1WW8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1481&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;我在做的就是 Java 相关的工作，后端选择 SpringBoot 无可厚非，之所以选择 Flutter Web 而不是传统的 Vue 或者 React，一方面是因为 Flutter 的声明式 UI 写起来确实比传统 Web 页面编写更舒服，效率更高，另一方面是因为用 Flutter 写的网页可以无缝转换成在 Android/iOS/PC/Linux/macOS 这些平台上的原生 App，有助于后期针对多个平台的覆盖（当然更多还是因为我已经把 Vue 和 React 忘的差不多了)。&lt;/p&gt;&lt;p&gt;目前这个网页比较简陋，还有很多我想做的功能没来得及做上去，但后续我准备持续更新这个代码，后续如果在家里运行效果还不错的话，甚至有想开源出去的想法，不过这就是后话了。&lt;/p&gt;&lt;h3&gt;随时随地访问——内网穿透&lt;/h3&gt;&lt;p&gt;玩了这么多东西，有没有发现一个最大的问题？&lt;/p&gt;&lt;p&gt;没错，就是这些所有的东西必须要求你的电脑和树莓派处在同一个网络里，即局域网环境里。虽然我一开始的使用场景就是在家里使用，但如果我在公司突然想看一部美剧了，但是用公司电脑下载视频显然是不现实的，如果这时候我可以在外网直接访问家里树莓派的离线下载服务，那么下班回家后岂不就可以看到自己想看的电影了吗？&lt;/p&gt;&lt;p&gt;所以，最好的方式就是联系你的宽带运营商，并申请一个公网 IP，这样你就可以通过这个公网 IP 访问到你的树莓派了。&lt;/p&gt;&lt;p&gt;据我所知，目前只有电信的部分地区会给公网 IP，大多数运营商是不会提供公网 IP 的，而且申请流程很麻烦，所以为了可以随时随地的从外网访问家里服务器的文件或其他服务，我们可以为树莓派做一个&lt;strong&gt;「内网穿透」&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.32531824611032534&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTLLziazMtXZicKqhIu94GufrehGj2OZPvDRlqxI7FNybPLx5HBZfjRxuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;707&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;「计算机领域的大多数问题都可以通过增加一层来解决」，所谓内网穿透，无非是在内部网络和互联网之间增加一个中转服务器，这个中转服务器负责接收你的请求并转发到内部服务器，也即&lt;strong&gt;「代理」&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;当然了，内网穿透的原理肯定不会这么简单，这里只是通俗的解释一下，如果之后有机会来详细说下。所以为了实现内网穿透，我们需要有一台可以公网访问的服务器作为中转桥梁，这时我突然想到我毕业前买的学生机还没到期呢，现在刚好在吃灰，拿它来做中转岂不是最好的？&lt;/p&gt;&lt;p&gt;内网穿透服务器的选择有很多，FRP 是用的最多的，但我这里选择的是 👉&lt;span&gt;nps&lt;sup&gt;[3]&lt;/sup&gt;&lt;/span&gt;，原因也很简单，页面好看，交互简单，性能够用。&lt;/p&gt;&lt;p&gt;nps 是一款轻量级、高性能、功能强大的内网穿透代理服务器。目前支持 tcp、udp 流量转发，可支持&lt;strong&gt;任何 tcp、udp 上层协议&lt;/strong&gt;（访问内网网站、本地支付接口调试、ssh 访问、远程桌面，内网 dns 解析等等……），此外还支持内网 http 代理、内网 socks5 代理、p2p 等，并带有功能强大的 web 管理端。&lt;/p&gt;&lt;p&gt;我们只需要在云主机上安装好服务端，并按照后台提示在树莓派上安装好客户端，简单设置自己要转发的端口即可实现内网穿透。&lt;/p&gt;&lt;p&gt;官方文档在 👉https://ehang-io.github.io/nps/#/?id=nps&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTLzqYLx5Eus5D03LDor9OCorJn6Licv6QtLg3NibpdpicEia3Zf4eZhPAeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h2&gt;最后&lt;/h2&gt;&lt;p&gt;拥有一台树莓派最大的好处就是可以充分发挥你的灵感与创意，如果你有想法、有能力、有时间，不妨让树莓派成为你实现想法的载体。&lt;/p&gt;&lt;p&gt;最后扯一点文章之外的，工作之后的时间果然少了很多，这篇文章从开始写到现在完成差不多花了一个星期，阿里的工作强度的确很大，每天下班到家多半也是 10 点之后的事情了，能留出来码字的时间实在有限，难得周末有空，把近期搬家捣鼓自己家的想法写下来，也算是自己新阶段的开始。这段时间阅读了很多内部的优秀文档，也希望自己未来的文章可以像内网的大神们一样更专业，新的征程加油！&lt;/p&gt;&lt;p&gt;以上就是本文的全部内容了，如果觉得还不错的话，不妨给我一个点赞关注支持一下哦 👍&lt;/p&gt;&lt;h3&gt;References&lt;/h3&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; How to Install Windows 11 on a Raspberry Pi 4: &lt;em&gt;https://www.tomshardware.com/how-to/install-windows-11-raspberry-pi#xenforo-comments-3710927&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[2]&lt;/code&gt; 在树莓派上配置 Samba 服务教程: &lt;em&gt;https://ee-fans.com/%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E9%85%8D%E7%BD%AEsamba%E6%9C%8D%E5%8A%A1%E6%95%99%E7%A8%8B/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[3]&lt;/code&gt; nps: &lt;em&gt;https://github.com/ehang-io/nps&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>