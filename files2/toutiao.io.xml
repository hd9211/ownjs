<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>20d2063eb68002b4a7c446e718c944b5</guid>
<title>如何写好一份 30K Offer 的简历？</title>
<link>https://toutiao.io/k/jghtnwm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;279&quot; data-ratio=&quot;0.5953846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mALMxRtWV1fIXmVo5kqFkByTF5M1QqzQefhS9EYKY6BzY1Dmib2jiabopE4CdId9eYgX7TEHHeVt9lsFDn0RS7Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;650&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哈喽，大家好，我是瓜哥，致力于分享互联网各领域干货。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近很多大学生都在进行期末考试，马上就放假了，是时候轻松一下了，但是作为即将进入大四的童鞋们，面临的就是&lt;code&gt;秋季招聘&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为过来人，给大家的建议就是利用好 &lt;code&gt;7、8&lt;/code&gt; 月的黄金时间，准备好一份简历，并针对性进行巩固技术知识，在秋招中斩获 &lt;code&gt;N&lt;/code&gt; 个 &lt;code&gt;Offer&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这篇文章就和大家简单聊聊，如何写好一份简历？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;俗话说的好，&lt;code&gt;学历是块敲门砖，正所谓师傅领进门，修行靠个人&lt;/code&gt;。简历也一样是找工作的敲门砖，简历不是简单的记一份流水账，而是让面试官了解你的重要途径。校招更是如此，因为初出茅庐的应届毕业生并没有实际的工作经验，所以简历的第一印象很重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写好一份技术简历，首先需要知道简历中一般包括什么内容。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;简历基本要素&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;基本信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;求职意向&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;专业技能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;工作经历、项目经验（重点）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;教育及培训背景&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自我评价&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其他&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;基本信息又包含哪些内容呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;姓名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;性别&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;年龄/出生年月&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;民族&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;政治面貌&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;学历&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;专业（考虑是否对应聘职位有帮助）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;工作年限&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;联系方式（手机、电子邮箱）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;婚否&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于基本信息这里面需要注意的地方是，如果是中专毕业，建议别写，如果是大专，建议写本科，最好自己提前完成自考成人本科。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在工作经验方面，如果是应届生，建议写半年实习，一般情况下，学校也会安排实习，如果已经有相关编程经验，按照实际写即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于联系方式，建议留当地的号码，邮箱建议注册姓名拼音的邮箱。案例如下：zhangsan@163.com/zs@163.com）&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;求职意向&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多应届生，反馈求职意向和招聘不符，这块需要注意的地方是建议上面的求职意向需要根据招聘情况，及时调整，&lt;code&gt;招聘需求中都会有写&lt;/code&gt;。比如，Web 前端工程师、小程序工程师、C++ 开发工程师、嵌入式软件工程师等等。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;简历书写建议&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;不要将自己的爱好兴趣写进去；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;简历页数不超过 2 页；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;不写与招聘要求无关的技术；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;不给自己挖坑，斟酌了解、熟悉、精通用词；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;简历中不要出现错误的单词拼写，注意技术名词的大小写；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;作为理工科的程序员，也要将简历中的语言表达通顺；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;切记不要写与招聘岗位无关的工作经验；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;简历不要造假，随时可能被 Pass；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;项目经历中是否担任过一些重要的职位，如小组长、负责人；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;突出个人亮点、做过什么大型项目、修改过公司什么难度的 Bug 、给公司带来多大的效益；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;英语四六级、软件工程师的证书写进简历；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在校连续几年拿过国家奖学金或国家励志奖学金写进简历；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;实习经历或导师带领做过的技术项目写进简历；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;重点院校毕业要放在简历耀眼的位置；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如 GitHub 2k Star 或博客内容丰富写进简历；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;建议使用 PDF 版简历，偏于携带和传播；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;确保简历中的技术内容都能说出什么，证书与项目经历要真实。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;专业技能如何写？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于专业技能方向，这里提供一个通用的模板写法。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;综合自己掌握的知识点与大量企业的网络招聘需求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;了解、掌握、精通根据自身能力来写&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不要全写精通，你不是神&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;专业名词大小写不要写错、不懂的提前网上查询&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;针对不同企业对技术的要求进行简历微调&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;自我评价&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后聊聊自我评价，看到很多应届生的简历，自我评价过多且过分夸张，十分不建议，自我评价需要做到的是前后一致，个人特长需要与工作岗位相关的内容，并不是打篮球、画画之类的，很多应届生都这么干过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;瓜哥给大家一个示例：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;具有良好的编码风格 工作细致&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;具有较强的抗压和适应能力&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;喜欢参加公司 OR 线下技术交流会&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，瓜哥最近也在整理，前端、后端的相关简历模板，需要&lt;code&gt;简历模板&lt;/code&gt;或者&lt;code&gt;简历指导&lt;/code&gt;的小伙伴们记得&lt;code&gt;一键三连&lt;/code&gt;支持瓜哥，&lt;code&gt;在看&lt;/code&gt;越多，瓜哥整理的进度也会越快。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;码字不易，在线求个三连支持。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，关注瓜哥不迷路，带你编程上高速，下一个技术大佬就是你。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击下方卡片，回复 &lt;code&gt;书籍&lt;/code&gt; 免费获取 2 本保姆级电子书&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwNDM2ODIxOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/mALMxRtWV1fxCl58rlJ2wanda3pGIZZ5ZZsaDDicsfibicL5Kzj1rBcTFibGta06QdFbzUh4JyAfd2RDa8QEV6Iamw/0?wx_fmt=png&quot; data-nickname=&quot;代码情缘&quot; data-alias=&quot;&quot; data-signature=&quot;林中有两条路，我选择了人迹更少的那条，一切来自于此。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>61dd90db12909325eea31b296e6657fc</guid>
<title>MySQL 中存储时间的最佳实践</title>
<link>https://toutiao.io/k/ohwsofq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;平时开发中经常需要记录时间，比如用于记录某条记录的创建时间以及修改时间。在数据库中存储时间的方式有很多种，比如 MySQL 本身就提供了日期类型，比如 DATETIME，TIMESTAMEP 等，我们也可以直接存储时间戳为 INT 类型，也有人直接将时间存储为字符串类型。&lt;/p&gt;&lt;p&gt;那么到底哪种存储时间的方式更好呢？&lt;/p&gt;&lt;h2&gt;不要使用字符串存储时间类型&lt;/h2&gt;&lt;p&gt;这是初学者很容易犯的错误，容易直接将字段设置为 VARCHAR 类型，存储&quot;2021-01-01 00:00:00&quot;这样的字符串。当然这样做的优点是比较简单，上手快。&lt;/p&gt;&lt;p&gt;但是极力不推荐这样做，因为这样做有两个比较大的问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;字符串占用的空间大&lt;/li&gt;&lt;li&gt;这样存储的字段比较效率太低，只能逐个字符比较，无法使用 MySQL 提供的日期API&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;MySQL 中的日期类型&lt;/h2&gt;&lt;p&gt;MySQL 数据库中常见的日期类型有 YEAR、DATE、TIME、DATETIME、TIMESTAMEP。因为一般都需要将日期精确到秒，其中比较合适的有DATETIME，TIMESTAMEP。&lt;/p&gt;&lt;p&gt;&lt;b&gt;DATETIME&lt;/b&gt;&lt;/p&gt;&lt;p&gt;DATETIME 在数据库中存储的形式为：YYYY-MM-DD HH:MM:SS，固定占用 8 个字节。&lt;/p&gt;&lt;p&gt;从 MySQL 5.6 版本开始，DATETIME 类型支持毫秒，DATETIME(N) 中的 N 表示毫秒的精度。例如，DATETIME(6) 表示可以存储 6 位的毫秒值。&lt;/p&gt;&lt;p&gt;&lt;b&gt;TIMESTAMEP&lt;/b&gt;&lt;/p&gt;&lt;p&gt;TIMESTAMP 实际存储的内容为‘1970-01-01 00:00:00’到现在的毫秒数。在 MySQL 中，由于类型 TIMESTAMP 占用 4 个字节，因此其存储的时间上限只能到‘2038-01-19 03:14:07’。&lt;/p&gt;&lt;p&gt;从 MySQL 5.6 版本开始，类型 TIMESTAMP 也能支持毫秒。与 DATETIME 不同的是，若带有毫秒时，类型 TIMESTAMP 占用 7 个字节，而 DATETIME 无论是否存储毫秒信息，都占用 8 个字节。&lt;/p&gt;&lt;p&gt;类型 TIMESTAMP 最大的优点是可以带有时区属性，因为它本质上是从毫秒转化而来。如果你的业务需要对应不同的国家时区，那么类型 TIMESTAMP 是一种不错的选择。比如新闻类的业务，通常用户想知道这篇新闻发布时对应的自己国家时间，那么 TIMESTAMP 是一种选择。Timestamp 类型字段的值会随着服务器时区的变化而变化，自动换算成相应的时间，说简单点就是在不同时区，查询到同一个条记录此字段的值会不一样。&lt;/p&gt;&lt;p&gt;&lt;b&gt;TIMESTAMP 的性能问题&lt;/b&gt;&lt;/p&gt;&lt;p&gt;TIMESTAMP 还存在潜在的性能问题。&lt;/p&gt;&lt;p&gt;虽然从毫秒数转换到类型 TIMESTAMP 本身需要的 CPU 指令并不多，这并不会带来直接的性能问题。但是如果使用默认的操作系统时区，则每次通过时区计算时间时，要调用操作系统底层系统函数 __tz_convert()，而这个函数需要额外的加锁操作，以确保这时操作系统时区没有修改。所以，当大规模并发访问时，由于热点资源竞争，会产生两个问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;性能不如 DATETIME：DATETIME 不存在时区转化问题。&lt;/li&gt;&lt;li&gt;性能抖动：海量并发时，存在性能抖动问题。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;为了优化 TIMESTAMP 的使用，建议使用显式的时区，而不是操作系统时区。比如在配置文件中显示地设置时区，而不要使用系统时区：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;1 [mysqld]
2
3 time_zone = &quot;+08:00&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;简单总结一下这两种数据类型的优缺点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;DATETIME 没有存储的时间上限，而TIMESTAMP存储的时间上限只能到‘2038-01-19 03:14:07’&lt;/li&gt;&lt;li&gt;DATETIME 不带时区属性，需要前端或者服务端处理，但是仅从数据库保存数据和读取数据而言，性能更好&lt;/li&gt;&lt;li&gt;TIMESTAMP 带有时区属性，但是每次需要通过时区计算时间，并发访问时会有性能问题&lt;/li&gt;&lt;li&gt;存储 DATETIME 比 TIMESTAMEP 多占用一部分空间&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;数值型时间戳（INT）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;很多时候，我们也会使用 int 或者 bigint 类型的数值也就是时间戳来表示时间。&lt;/p&gt;&lt;p&gt;这种存储方式的具有 Timestamp 类型的所具有一些优点，并且使用它的进行日期排序以及对比等操作的效率会更高，跨系统也很方便，毕竟只是存放的数值。缺点也很明显，就是数据的可读性太差了，你无法直观的看到具体时间。&lt;/p&gt;&lt;p&gt;如果需要查看某个时间段内的数据&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;1 select * from t where created_at &amp;gt; UNIX_TIMESTAMP(&#x27;2021-01-01 00:00:00&#x27;);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;DATETIME vs TIMESTAMP vs INT，怎么选？&lt;/h2&gt;&lt;p&gt;每种方式都有各自的优势，下面再对这三种方式做一个简单的对比：&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;日期类型&lt;/th&gt;&lt;th&gt;占用空间&lt;/th&gt;&lt;th&gt;日期格式&lt;/th&gt;&lt;th&gt;日期范围&lt;/th&gt;&lt;th&gt;是否存在时区问题&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;DATETIME&lt;/td&gt;&lt;td&gt;8 字节&lt;/td&gt;&lt;td&gt;YYYY-MM-DD HH:MM:SS&lt;/td&gt;&lt;td&gt;1000-01-01 00:00:00 ～9999-12-31 23:59:59&lt;/td&gt;&lt;td&gt;是&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TIMESTAMP&lt;/td&gt;&lt;td&gt;4 字节&lt;/td&gt;&lt;td&gt;YYYY-MM-DD HH:MM:SS&lt;/td&gt;&lt;td&gt;1970-01-01 00:00:00 ～2038-01-19 03:14:07&lt;/td&gt;&lt;td&gt;否&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;INT&lt;/td&gt;&lt;td&gt;4 字节&lt;/td&gt;&lt;td&gt;全数字时间戳&lt;/td&gt;&lt;td&gt;1000-01-01 00:00:01 之后的时间&lt;/td&gt;&lt;td&gt;否&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;TIMESTAMP 与 INT 本质一样，但是相比而言虽然 INT 对开发友好，但是对 DBA 以及数据分析人员不友好，可读性差。所以《高性能 MySQL 》的作者推荐  TIMESTAMP 的原因就是它的数值表示时间更加直观。下面是原文：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-fccc7d7920390551efff8a5eff13414f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;414&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-fccc7d7920390551efff8a5eff13414f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;414&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-fccc7d7920390551efff8a5eff13414f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-fccc7d7920390551efff8a5eff13414f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;至于时区问题，可以由前端或者服务这里做一次转化，不一定非要在数据库中解决。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;本文比较了几种最常使用的存储时间的方式，我最推荐的还是 DATETIME。理由如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;TIMESTAMP 比数值型时间戳可读性更好&lt;/li&gt;&lt;li&gt;DATETIME 的存储上限为 9999-12-31 23:59:59，如果使用 TIMESTAMP，则 2038 年需要考虑解决方案&lt;/li&gt;&lt;li&gt;DATETIME 由于不需要时区转换，所以性能比 TIMESTAMP 好&lt;/li&gt;&lt;li&gt;如果需要将时间存储到毫秒，TIMESTAMP 要 7 个字节，和 DATETIME 8 字节差不太多 &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;推荐阅读：&lt;/b&gt;&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/650/%25E7%25A7%2581%25E6%259C%2589%25E5%258C%2596%25E4%25BB%2593%25E5%25BA%2593%25E7%259A%2584%2520GO%2520%25E6%25A8%25A1%25E5%259D%2597%25E4%25BD%25BF%25E7%2594%25A8%25E5%25AE%259E%25E8%25B7%25B5.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic4.zhimg.com/v2-2b8c596b85073408346e12f2225395d7_180x120.jpg&quot; data-image-width=&quot;922&quot; data-image-height=&quot;273&quot; class=&quot;LinkCard old LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;私有化仓库的 GO 模块使用实践&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.upyun.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic4.zhimg.com/v2-2b8c596b85073408346e12f2225395d7_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/640/%25E5%25AE%259E%25E6%2593%258D%25E7%25AC%2594%25E8%25AE%25B0%25EF%25BC%259A%25E4%25B8%25BA%2520NSQ%2520%25E9%2585%258D%25E7%25BD%25AE%25E7%259B%2591%25E6%258E%25A7%25E6%259C%258D%25E5%258A%25A1%25E7%259A%2584%25E5%25BF%2583%25E8%25B7%25AF%25E5%258E%2586%25E7%25A8%258B.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic4.zhimg.com/v2-f18a6f76571f135e62db962fa4b73587_180x120.jpg&quot; data-image-width=&quot;1011&quot; data-image-height=&quot;593&quot; class=&quot;LinkCard old LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;实操笔记：为 NSQ 配置监控服务的心路历程&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.upyun.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic4.zhimg.com/v2-f18a6f76571f135e62db962fa4b73587_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c4460f42b01547c0cfe888f0c0086718</guid>
<title>一文带你了解 Windows 性能监控系统的使用</title>
<link>https://toutiao.io/k/npyseo6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-inner&quot;&gt;
                                                    
&lt;p&gt;我们现实工作中很多时候想知道当前服务器的各项性能指标，比如说CPU的使用率是多少，还有多少内存，各个磁盘的IO是什么样的情况等等。假如我们使用的是windows操作系统，那么它其实已经内置了一个很强的性能监控系统，本文就来介绍一下我们如何使用这个性能监控系统。&lt;/p&gt;



&lt;h2&gt;Windows Performance counter系统介绍&lt;/h2&gt;



&lt;p&gt;总得来说Windows performance counter系统是由这几个方面组成的：Consumer，provider，countersets，counters，instances以及counter value组成。&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;所谓的Consumer其实就是使用performance数据的模块，我们下面介绍的GUI和代码都属于这部分。&lt;/li&gt;&lt;li&gt;Provider是指产生和publish性能数据的部分。它可以把数据publish给不同的countersets。&lt;/li&gt;&lt;li&gt;Counterset就是一个group，它可以包含一个或多个counters，它会返回多个instance。&lt;/li&gt;&lt;li&gt;Counter就是一个性能的定义，它有一个名字和类型。比如磁盘每秒写IO。&lt;/li&gt;&lt;li&gt;Instance是性能数据的entity，可以包含一个或多个counter值。我们可以这样理解，假设我们是看磁盘的信息，磁盘的每秒的写IO就是一个counter，然后每个磁盘就是一个instance，它可以包含每秒写IO的counter，也可以包含每秒读IO的counter。&lt;/li&gt;&lt;li&gt;Counter value就比较直观了，就是counter的值。&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;一般来说，Consumer会定期从provider的counterset中收集并记录数据。下面是一个简单的性能API架构图&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image.png&quot; alt=&quot;&quot; class=&quot;wp-image-773&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image.png 624w, https://donggeitnote.com/wp-content/uploads/2021/07/image-300x196.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;总得来说V1的架构已经要废弃了，大家尽量还是用V2的架构。&lt;/p&gt;



&lt;h2&gt;Performance Monitor GUI&lt;/h2&gt;



&lt;p&gt;我们可以在开始菜单打开Performance Monitor界面，如下图所示，我们可以看到在右边其实有一个系统的总体情况的信息，它包括内存使用的情况，网络的传输状况，磁盘的一些简单信息和各个process的整体信息。这是一个实时的显示。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-1.png&quot; alt=&quot;&quot; class=&quot;wp-image-774&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-1.png 624w, https://donggeitnote.com/wp-content/uploads/2021/07/image-1-300x174.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;那么我们如何来真正使用这个工具呢？我们可以在左边Data Collector Sets中点击User Defined，然后创建你关心的Countset，&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-2.png&quot; alt=&quot;&quot; class=&quot;wp-image-775&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-2.png 494w, https://donggeitnote.com/wp-content/uploads/2021/07/image-2-300x166.png 300w&quot; sizes=&quot;(max-width: 494px) 100vw, 494px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;这里我们使用Create Manually来创建我们关心的Data Collector Set&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-3.png&quot; alt=&quot;&quot; class=&quot;wp-image-776&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-3.png 537w, https://donggeitnote.com/wp-content/uploads/2021/07/image-3-300x221.png 300w&quot; sizes=&quot;(max-width: 537px) 100vw, 537px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;这里选择Performance Counter&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-4.png&quot; alt=&quot;&quot; class=&quot;wp-image-777&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-4.png 535w, https://donggeitnote.com/wp-content/uploads/2021/07/image-4-300x159.png 300w&quot; sizes=&quot;(max-width: 535px) 100vw, 535px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;然后点击Add加入我们关心的performance Count，我们这里加入一个Process的%Process Time以及Memory中的Available Mbytes两个performance Count&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-5.png&quot; alt=&quot;&quot; class=&quot;wp-image-778&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-5.png 624w, https://donggeitnote.com/wp-content/uploads/2021/07/image-5-300x140.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;并且把Sample Interval设为1 second，这个地方你可以根据你的监测时间来进行设置，一般来说，在现实的prod环境中，我们可能设置5分钟的间隔就足够我们分析出问题的时候系统总体状况了。下面设置一下你想把log保存的目录。这个目录一般我们会有一个script来及时把它上传到对应的log系统中以供我们分析。&lt;/p&gt;



&lt;p&gt;然后右击我们刚刚创建的Data collector set就可以start了，start之后可以看到具体的目录位置，这里我们可以右击属性，然后修改log的format到不同的格式，默认是binary，我们这里修改成comma separate：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-6.png&quot; alt=&quot;&quot; class=&quot;wp-image-779&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-6.png 397w, https://donggeitnote.com/wp-content/uploads/2021/07/image-6-300x108.png 300w&quot; sizes=&quot;(max-width: 397px) 100vw, 397px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;这样一来相关的数据就被记录到对应的文件中了，有了这些原始数据，你想做任何的性能分析都是小菜一碟了。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-7.png&quot; alt=&quot;&quot; class=&quot;wp-image-780&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-7.png 624w, https://donggeitnote.com/wp-content/uploads/2021/07/image-7-300x130.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;h2&gt;使用Performance Counter class进行.NET的编程&lt;/h2&gt;



&lt;p&gt;上面我们介绍了系统提供的各种Performance Counter，假如我们想要监控一个自定义的Performance Count怎么办呢，这里就来详细介绍一下如何在.NET的情况下创建一个自定义的performance Count。当然你也可以用代码来记录上面提到的predefine的performance count，只是不需要再进行创建即可。&lt;/p&gt;



&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;首先来创建对应的data collection，首先是创建performance count的分类，这里我们取名为PerformanceCountExample，同时在其中创建两个count，分别是AverageCount和AverageCountBase。相关的代码如下：&lt;/li&gt;&lt;/ol&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;csharp&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;private static bool SetupCategory()
        {
            if (!PerformanceCounterCategory.Exists(&quot;PerformanceCountExample&quot;))
            {
                CounterCreationDataCollection counterDataCollection = new CounterCreationDataCollection();

                // Add the counter.
                CounterCreationData averageCount64 = new CounterCreationData();
                averageCount64.CounterType = PerformanceCounterType.AverageCount64;
                averageCount64.CounterName = &quot;AverageCount&quot;;
                counterDataCollection.Add(averageCount64);

                // Add the base counter.
                CounterCreationData averageCount64Base = new CounterCreationData();
                averageCount64Base.CounterType = PerformanceCounterType.AverageBase;
                averageCount64Base.CounterName = &quot;AverageCountBase&quot;;
                counterDataCollection.Add(averageCount64Base);

                // Create the category.
                PerformanceCounterCategory.Create(&quot;PerformanceCountExample&quot;,
                    &quot;Demonstrates usage of the performance counter type.&quot;,
                    PerformanceCounterCategoryType.SingleInstance, counterDataCollection);

                return (true);
            }
            else
            {
                Console.WriteLine(&quot;Category exists - PerformanceCountExample&quot;);
                return (false);
            }
        }
&lt;/pre&gt;



&lt;p&gt;创建对应的PerformanceCounter，这里我们分别创建了avgCounter和avgCounterBase，具体的代码如下所示：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;csharp&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;        private static void CreateCounters()
        {
            // Create the counters.

            avgCounter = new PerformanceCounter(&quot;AverageCounter64SampleCategory&quot;,
                &quot;AverageCounter64Sample&quot;,
                false);


            avgCounterBase = new PerformanceCounter(&quot;AverageCounter64SampleCategory&quot;,
                &quot;AverageCounter64SampleBase&quot;,
                false);

            avgCounter.RawValue = 0;
            avgCounterBase.RawValue = 0;
        }
&lt;/pre&gt;



&lt;p&gt;下面我们来模拟一些代码用来修改这些performance count&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;csharp&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;        private static void CollectSamples(ArrayList samplesList)
        {

            Random r = new Random(DateTime.Now.Millisecond);

            // Loop for the samples.
            for (int j = 0; j &amp;lt; 100; j++)
            {

                int value = r.Next(1, 10);
                Console.Write(j + &quot; = &quot; + value);

                avgCounter.IncrementBy(value);

                avgCounterBase.Increment();

                if ((j % 10) == 9)
                {
                    OutputSample(avgCounterBase.NextSample());
                    samplesList.Add(avgCounter.NextSample());
                }
                else
                {
                    Console.WriteLine();
                }

                System.Threading.Thread.Sleep(50);
            }
        }

        private static void OutputSample(CounterSample s)
        {
            Console.WriteLine(&quot;\r\n+++++++++++&quot;);
            Console.WriteLine(&quot;Sample values - \r\n&quot;);
            Console.WriteLine(&quot;   BaseValue        = &quot; + s.BaseValue);
            Console.WriteLine(&quot;   CounterFrequency = &quot; + s.CounterFrequency);
            Console.WriteLine(&quot;   CounterTimeStamp = &quot; + s.CounterTimeStamp);
            Console.WriteLine(&quot;   CounterType      = &quot; + s.CounterType);
            Console.WriteLine(&quot;   RawValue         = &quot; + s.RawValue);
            Console.WriteLine(&quot;   SystemFrequency  = &quot; + s.SystemFrequency);
            Console.WriteLine(&quot;   TimeStamp        = &quot; + s.TimeStamp);
            Console.WriteLine(&quot;   TimeStamp100nSec = &quot; + s.TimeStamp100nSec);
            Console.WriteLine(&quot;++++++++++++++++++++++&quot;);
        }
&lt;/pre&gt;



&lt;p&gt;最后我们可以在main函数中进行调用了：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;csharp&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;            if (SetupCategory())
                return;
            CreateCounters();
            CollectSamples(samplesList);
&lt;/pre&gt;



&lt;p&gt;这个时候我们运行相应代码之后就可以看到对应的perfcount信息了，需要注意的是代码需要在Admin的情况下运行：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-8.png&quot; alt=&quot;&quot; class=&quot;wp-image-781&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/07/image-8.png 345w, https://donggeitnote.com/wp-content/uploads/2021/07/image-8-300x173.png 300w&quot; sizes=&quot;(max-width: 345px) 100vw, 345px&quot;/&gt;&lt;/figure&gt;



&lt;h2&gt;总结&lt;/h2&gt;



&lt;p&gt;本文简单全面总结了Windows中performance counter的使用方法，从理论，GUI以及代码实例三个方面详细介绍了相关内容，希望对大家有所帮助。&lt;/p&gt;
                                                    &lt;nav class=&quot;pagination group&quot;&gt;
                      &lt;/nav&gt;
        &lt;/div&gt;

        
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3ed78c9d395816ced64f21e7b08a4f2c</guid>
<title>微服务的灾难：拆的很爽，但服务太小</title>
<link>https://toutiao.io/k/lsz4d8v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是煎鱼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我有一个好朋友小咸鱼，他们组织早期是业务萌芽的初期，在快速发展阶段，面临着软件开发周期的挑战。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.312&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4iaqCwOBeImibWbrxAMKFDsHgh05w4h8niabZtgubYH3L9hC2ib1rhicoFoqLPBdOzSFmiaBu6uKWa9OrnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;过去的巨石应用&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这 “强大又厚实” 的巨石应用是他们应用架构上的一个早期策略：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7507836990595611&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4iaqCwOBeImibWbrxAMKFDsHgPM5ABJw216QRwDwobqEBzvpcYSKey6iamCllJiaeickpUhXqX3UlibPVEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;638&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但随着业务的持续发展，巨石应用的痛点也非常明确。像是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;难以部署和维护。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;频繁部署的障碍。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不相关的功能之间的依赖性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;难以尝试新的技术/框架。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些痛点也正给他们公司带来各种各样的组织问题，而当代微服务的横空出世，对软件工程师很有吸引力，他们也就转型了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;现代的微服务架构&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正式迈向了微服务转型之路，一切先从拆分开始：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7507836990595611&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4iaqCwOBeImibWbrxAMKFDsHgM2vqUuLsbVQ6XvhFPMGibuOlJbevk8RpsfVjxEibV8N89FkFnRepjOuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;638&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以往的大单体中，我们会将其 Cache、DB 等混合在一起。但在做微服务后，我们会选用拆成多个服务的方式，最终演变成：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7507836990595611&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4iaqCwOBeImibWbrxAMKFDsHgE4ZPlYo8jKY9sDlVNESNXyW9JaLNoO392rVywMokVJujq8dCEBNW4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;638&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微服务拆分有以下几种粗的基准：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;UI、静态内容组件化，解耦出来成为可独立部署的客户端应用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;定义边界，服务要有较为明确清洗的边界。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单一职责，服务的能力要单一，数据库等第三方依赖存储要独立。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;绞杀者模式&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在完成微服务改造的基准的定义后，绝大部分公司都是采取业界中比较著名的 “绞杀者” 模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.30241187384044527&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4iaqCwOBeImibWbrxAMKFDsHgw2Gyszqufib5HdH7qgmhPq8GcpmOMPXTGPEU8jrwnEBUQFt2VkoP7dA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;539&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于会考虑微服务的组织，大多都是有成熟业务的盈利组织了，业务发展太迅猛，才发现技术架构跟不上业务要求的迭代速度和周期，不大可能停下业务硬重构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此业内基本采取边迁移，边改造为微服务的渐进式重构的方式，实现 “绞杀者”，把技术债务给偿还了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务太小&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在微服务逐步的演进过程中，我们就会发现一个新的问题。虽然在微服务做规划时，都会很认真的对服务的拆分进行深入研讨，但还是&lt;strong&gt;出现了服务拆的很爽，但后面实战的时候发现服务太小了&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;N 人维护数倍服务&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出现了 “&lt;strong&gt;10 名工程师组成了维护 60 项服务的小组&lt;/strong&gt;。一人负责一个服务还不够用” 的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正当以为这不是常见问题时，最近看到我的好朋友 HHF（@HHFCodeRv）提到有人向他咨询架构相关的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是咨询他的公司的 Java 架构师落地的方案。如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5935162094763092&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4iaqCwOBeImibWbrxAMKFDsHgaqRchubib49pKI32AUSZs17mJeto3qicb4nhRiamsPF8QXQUhHXd2LiaKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;401&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;亮点是这 2 个后端开发，其中一个还是架构师。结合实际情况，可能只有 1 个后端在干活。这堪称 1:17 的人和服务的配比量，每天光切 IDE 找服务可能就得好几东...&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，应用还没上线，就拆成数倍的服务。形成 &lt;strong&gt;N 个人维护其自身数量的数倍服务&lt;/strong&gt;，不大合理。这也是业内很多互联网公司需要思考和解决的问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;新功能归属谁&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际的业务场景中，出现了 “&lt;strong&gt;有人要求我把一个新功能同时部署到两个不同服务之中&lt;/strong&gt;” 的诉求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为这个新功能同时是 ServiceA 和 ServiceB 这两个服务的职责划分的所有者或者部分所有者，所以新功能理应同时在这两个服务都要有所提供。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候需要考虑以下问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个新功能是什么，具体的业务领域划分？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么这两个服务会存储共享这一个新功能的可能？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这两个服务，是否应该继续拆开，要不要合并？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于新功能的出现，是不是应该拆出第三个服务？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在真实的项目场景中，我们会按照事前定的 “契约” 进行设计和开发。也就是在设计时，就要针对服务的上下文边界确立好，做好约束和规范。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出现上面这些问题，我们要想想：&lt;strong&gt;是不是服务的职责不清晰还是拆分有偏差，又或是业务领域改变了？&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们要尽快对整体的服务做一个再规划，&lt;strong&gt;界定新的上下文&lt;/strong&gt;。否则，以后会越来越乱，有好受的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在今天的文章中，我们介绍了巨石应用和微服务架构的一些基本特性。同时也给大家展示了，最常见的切换方式：绞杀者模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后和大家探讨了所有微服务演讲中，都必然会碰到的一个大问题：服务太小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务太小又分为两种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;起步上来就一顿拆，应用还没上线就拆出来 60，70 个服务，拆的很开心。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发展时发现有新业务领域，又或是用的时候不对劲。频繁一块功能，好几个服务左右反复横跳，感觉应该在一块。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况下，我们需要&lt;strong&gt;分清楚，这是人，还是设计上的问题&lt;/strong&gt;（这很重要）。&lt;span&gt;及时重新界定新的领域，面向服务&lt;strong&gt;做好新的上下文界定&lt;/strong&gt;，能够适当的解决部分问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务是在持续发展的，若要做好，要长期的阶段性复盘。但若是人的问题，那就需要好好思考了，毕竟康威定律。&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxMDI4MDc1NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4iac2xQZIq5icSiaTepuae8zLIUMiaxibbUM8ic735ewo6e89GRtjGbUBlgNYibwCjAicglQcvz6dCQ6yTKOw/0?wx_fmt=png&quot; data-nickname=&quot;脑子进煎鱼了&quot; data-alias=&quot;eddycjy&quot; data-signature=&quot;分享计算机基础、Go 语言、微服务架构和系统设计；著有图书《Go 语言编程之旅》。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;关注煎鱼，吸取他的知识 👆&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.07106598984771574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/486RHs1WbcgGib6o96dHbvGUGGwPicd8wusUGH1cXR29tM4bO0lNzialzkQhvU6m5ZUdaKibmcF2OQayjMe9Bia6iaXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;394&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你好，我是煎鱼。高一折腾过前端，参加过国赛拿了奖，大学搞过 PHP。现在整 Go，在公司负责微服务架构等相关工作推进和研发。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;从大学开始靠自己赚生活费和学费，到出版 Go 畅销书《Go 语言编程之旅》，再到获得 GOP（Go 领域最有观点专家）荣誉，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;amp;mid=2247483854&amp;amp;idx=1&amp;amp;sn=ec422fbf4d846975f2930ddeb5e81373&amp;amp;chksm=f9041493ce739d85a4b987eece14da627206cdad798f645cc770868312e4a22b6df24804f186&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;点击蓝字查看我的出书之路&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;点击蓝字查看我的出书之路&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;日常分享高质量文章，输出 Go 面试、工作经验、架构设计，&lt;span&gt;加微信拉读者交流群，记得点赞！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>434403b1e867c95736552b278ed35627</guid>
<title>由浅入深 C A S，小白也能与 BAT 面试官对线</title>
<link>https://toutiao.io/k/kl90dzl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前言&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java并发编程系列番外篇&lt;code&gt;C A S（Compare and swap）&lt;/code&gt;，文章风格依然是图文并茂，通俗易懂，让读者们也能与面试官疯狂对线。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;C A S&lt;/code&gt;作为并发编程必不可少的基础知识，面试时&lt;code&gt;C A S&lt;/code&gt;也是个高频考点，所以说&lt;code&gt;C A S&lt;/code&gt;是必知必会，本文将带读者们深入理解&lt;code&gt;C A S&lt;/code&gt;。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;大纲&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6713395638629284&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8ny1VNcSscicjAax5qNibFxqiaba0Vib3GTSllkErmDuJk4DomJKhhb28icN01EWXASN46mP6dZ87ZBqj5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;642&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;C A S基本概念&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;C A S（compareAndSwap）&lt;/code&gt;也叫比较交换，是一种无锁原子算法，映射到操作系统就是一条&lt;code&gt;cmpxchg&lt;/code&gt;硬件汇编指令（&lt;strong&gt;保证原子性&lt;/strong&gt;），其作用是让&lt;code&gt;C P U&lt;/code&gt;将内存值更新为新值，但是有个条件，内存值必须与期望值相同，并且&lt;code&gt;C A S&lt;/code&gt;操作无需用户态与内核态切换，直接在用户态对内存进行读写操作（&lt;strong&gt;意味着不会阻塞/线程上下文切换&lt;/strong&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它包含&lt;code&gt;3&lt;/code&gt;个参数&lt;code&gt;C A S（V，E，N）&lt;/code&gt;，&lt;code&gt;V&lt;/code&gt;表示待更新的内存值，&lt;code&gt;E&lt;/code&gt;表示预期值，&lt;code&gt;N&lt;/code&gt;表示新值，当 &lt;code&gt;V&lt;/code&gt;值等于&lt;code&gt;E&lt;/code&gt;值时，才会将&lt;code&gt;V&lt;/code&gt;值更新成&lt;code&gt;N&lt;/code&gt;值，如果&lt;code&gt;V&lt;/code&gt;值和&lt;code&gt;E&lt;/code&gt;值不等，不做更新，这就是一次&lt;code&gt;C A S&lt;/code&gt;的操作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.95&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8ny1VNcSscicjAax5qNibFxqiabHujbJoOdS8SRxegxFTHuoKHLwjkVahNbPibZP6rhYkYtuX8RQkK2Cbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;740&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单说，&lt;code&gt;C A S&lt;/code&gt;需要你额外给出一个期望值，也就是你认为这个变量现在应该是什么样子的，如果变量不是你想象的那样，说明它已经被别人修改过了，你只需要重新读取，设置新期望值，再次尝试修改就好了。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;C A S如何保证原子性&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原子性是指一个或者多个操作在&lt;code&gt;C P U&lt;/code&gt;执行的过程中不被中断的特性，要么执行，要不执行，不能执行到一半（&lt;strong&gt;不可被中断的一个或一系列操作&lt;/strong&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了保证&lt;code&gt;C A S&lt;/code&gt;的原子性，&lt;code&gt;C P U&lt;/code&gt;提供了下面两种方式&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;总线锁定&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总线（&lt;code&gt;B U S&lt;/code&gt;）是计算机组件间的传输数据方式，也就是说&lt;code&gt;C P U&lt;/code&gt;与其他组件连接传输数据，就是靠总线完成的，比如&lt;code&gt;C P U&lt;/code&gt;对内存的读写。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3482475764354959&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8ny1VNcSscicjAax5qNibFxqiab1UEcNV0VfpBkR7icdiazr27wBlcCa8QaMvdHoDWuZTe3HqaLHAiaB3cXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1341&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;总线锁定&lt;/strong&gt;是指&lt;code&gt;C P U&lt;/code&gt;使用了总线锁，所谓总线锁就是使用&lt;code&gt;C P U&lt;/code&gt;提供的&lt;code&gt;LOCK#&lt;/code&gt;信号，当&lt;code&gt;C P U&lt;/code&gt;在总线上输出&lt;code&gt;LOCK#&lt;/code&gt;信号时，其他&lt;code&gt;C P U&lt;/code&gt;的总线请求将被阻塞。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1978021978021978&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8ny1VNcSscicjAax5qNibFxqiab183RLQ5wiaWzgiaiblQpR7JQP0HHdZxzHlXJgcrhB5VZXSFqBnYNblfsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;637&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;缓存锁定&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总线锁定方式虽然保证了原子性，但是在锁定期间，会导致大量阻塞，增加系统的性能开销，所以现代&lt;code&gt;C P U&lt;/code&gt;为了提升性能，通过锁定范围缩小的思想设计出了缓存行锁定（&lt;strong&gt;缓存行是&lt;code&gt;C P U&lt;/code&gt;高速缓存存储的最小单位&lt;/strong&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓&lt;strong&gt;缓存锁定&lt;/strong&gt;是指&lt;code&gt;C P U&lt;/code&gt;对&lt;strong&gt;缓存行&lt;/strong&gt;进行锁定，当缓存行中的共享变量回写到内存时，其他&lt;code&gt;C P U&lt;/code&gt;会通过总线嗅探机制感知该共享变量是否发生变化，如果发生变化，让自己对应的共享变量缓存行失效，重新从内存读取最新的数据，缓存锁定是基于缓存一致性机制来实现的，因为缓存一致性机制会阻止两个以上&lt;code&gt;C P U&lt;/code&gt;同时修改同一个共享变量（&lt;strong&gt;现代&lt;code&gt;C P U&lt;/code&gt;基本都支持和使用缓存锁定机制&lt;/strong&gt;）。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;C A S的问题&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;C A S&lt;/code&gt;和锁都解决了原子性问题，和锁相比没有阻塞、线程上下文你切换、死锁，所以&lt;code&gt;C A S&lt;/code&gt;要比锁拥有更优越的性能，但是&lt;code&gt;C A S&lt;/code&gt;同样存在缺点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;C A S&lt;/code&gt;的问题如下&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;只能保证一个共享变量的原子操作&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;自旋时间太长（建立在自旋锁的基础上）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;ABA&lt;/code&gt;问题&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;只能保证一个共享变量原子操作&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;C A S&lt;/code&gt;只能针对一个共享变量使用，如果多个共享变量就只能使用锁了，当然如果你有办法把多个变量整成一个变量，利用&lt;code&gt;C A S&lt;/code&gt;也不错，例如读写锁中&lt;code&gt;state&lt;/code&gt;的高低位。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;自旋时间太长&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个线程获取锁时失败，不进行阻塞挂起，而是间隔一段时间再次尝试获取，直到成功为止，这种循环获取的机制被称为自旋锁(&lt;strong&gt;&lt;code&gt;spinlock&lt;/code&gt;&lt;/strong&gt;)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自旋锁好处是，持有锁的线程在短时间内释放锁，那些等待竞争锁的线程就不需进入阻塞状态（&lt;strong&gt;无需线程上下文切换/无需用户态与内核态切换&lt;/strong&gt;），它们只需要等一等（&lt;strong&gt;自旋&lt;/strong&gt;），等到持有锁的线程释放锁之后即可获取，这样就避免了用户态和内核态的切换消耗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自旋锁坏处显而易见，线程在长时间内持有锁，等待竞争锁的线程一直自旋，即CPU一直空转，资源浪费在毫无意义的地方，所以一般会限制自旋次数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后来说自旋锁的实现，实现自旋锁可以基于&lt;code&gt;C A S&lt;/code&gt;实现，先定义&lt;code&gt;lockValue&lt;/code&gt;对象默认值&lt;code&gt;1&lt;/code&gt;，&lt;code&gt;1&lt;/code&gt;代表锁资源空闲，&lt;code&gt;0&lt;/code&gt;代表锁资源被占用，代码如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SpinLock&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;//lockValue 默认值1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; AtomicInteger lockValue = &lt;span&gt;new&lt;/span&gt; AtomicInteger(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;//自旋获取锁&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 循环检测尝试获取锁&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (!tryLock()){&lt;br/&gt;            &lt;span&gt;// 空转&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;//获取锁&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;tryLock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 期望值1，更新值0，更新成功返回true，更新失败返回false&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; lockValue.compareAndSet(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;//释放锁&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;unLock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(!lockValue.compareAndSet(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;)){&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&lt;span&gt;&quot;释放锁失败&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面定义了&lt;code&gt;AtomicInteger&lt;/code&gt;类型的&lt;code&gt;lockValue&lt;/code&gt;变量，&lt;code&gt;AtomicInteger&lt;/code&gt;是&lt;code&gt;Java&lt;/code&gt;基于&lt;code&gt;C A S&lt;/code&gt;实现的&lt;code&gt;Integer&lt;/code&gt;原子操作类，还定义了3个函数&lt;code&gt;lock、tryLock、unLock&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;tryLock函数-获取锁&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;期望值1，更新值0&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;C A S&lt;/code&gt;更新&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;如果期望值与&lt;code&gt;lockValue&lt;/code&gt;值相等，则&lt;code&gt;lockValue&lt;/code&gt;值更新为&lt;code&gt;0&lt;/code&gt;，返回&lt;code&gt;true&lt;/code&gt;，否则执行下面逻辑&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;如果期望值与&lt;code&gt;lockValue&lt;/code&gt;值不相等，不做任何更新，返回&lt;code&gt;false&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;unLock函数-释放锁&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;期望值&lt;code&gt;0&lt;/code&gt;，更新值&lt;code&gt;1&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;C A S&lt;/code&gt;更新&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;如果期望值与&lt;code&gt;lockValue&lt;/code&gt;值相等，则&lt;code&gt;lockValue&lt;/code&gt;值更新为&lt;code&gt;1&lt;/code&gt;，返回&lt;code&gt;true&lt;/code&gt;，否则执行下面逻辑&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;如果期望值与&lt;code&gt;lockValue&lt;/code&gt;值不相等，不做任何更新，返回&lt;code&gt;false&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;lock函数-自旋获取锁&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;执行&lt;code&gt;tryLock&lt;/code&gt;函数，返回&lt;code&gt;true&lt;/code&gt;停止，否则一直循环&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.6184834123222749&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8ny1VNcSscicjAax5qNibFxqiabQHKscYW1MI87ic7kFeJjDqKWIqRl72I4nPTwJ8OBaUBz7L0sN4FFBqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;422&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图可以看出，只有&lt;code&gt;tryLock&lt;/code&gt;成功的线程（&lt;strong&gt;把&lt;code&gt;lockValue&lt;/code&gt;更新为&lt;code&gt;0&lt;/code&gt;&lt;/strong&gt;），才会执行代码块，其他线程个&lt;code&gt;tryLock&lt;/code&gt;自旋等待&lt;code&gt;lockValue&lt;/code&gt;被更新成&lt;code&gt;1&lt;/code&gt;，&lt;code&gt;tryLock&lt;/code&gt;成功的线程执行&lt;code&gt;unLock&lt;/code&gt;（&lt;strong&gt;把&lt;code&gt;lockValue&lt;/code&gt;更新为&lt;code&gt;1&lt;/code&gt;&lt;/strong&gt;），自旋的线程才会&lt;code&gt;tryLock&lt;/code&gt;成功。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;ABA问题&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;C A S&lt;/code&gt;需要检查待更新的内存值有没有被修改，如果没有则更新，但是存在这样一种情况，如果一个值原来是&lt;code&gt;A&lt;/code&gt;，变成了&lt;code&gt;B&lt;/code&gt;，然后又变成了&lt;code&gt;A&lt;/code&gt;，在&lt;code&gt;C A S&lt;/code&gt;检查的时候会发现没有被修改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设有两个线程，线程&lt;code&gt;1&lt;/code&gt;读取到内存值&lt;code&gt;A&lt;/code&gt;，线程&lt;code&gt;1&lt;/code&gt;时间片用完，切换到线程&lt;code&gt;2&lt;/code&gt;，线程&lt;code&gt;2&lt;/code&gt;也读取到了内存值&lt;code&gt;A&lt;/code&gt;，并把它修改为&lt;code&gt;B&lt;/code&gt;值，然后再把&lt;code&gt;B&lt;/code&gt;值还原到&lt;code&gt;A&lt;/code&gt;值，简单说，修改次序是&lt;code&gt;A-&amp;gt;B-&amp;gt;A&lt;/code&gt;，接着线程&lt;code&gt;1&lt;/code&gt;恢复运行，它发现内存值还是&lt;code&gt;A&lt;/code&gt;，然后执行&lt;code&gt;C A S&lt;/code&gt;操作，这就是著名的&lt;code&gt;ABA&lt;/code&gt;问题，但是好像又看不出什么问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只是简单的数据结构，确实不会有什么问题，如果是复杂的数据结构可能就会有问题了（&lt;strong&gt;使用&lt;code&gt;AtomicReference&lt;/code&gt;可以把&lt;code&gt;C A S&lt;/code&gt;使用在对象上&lt;/strong&gt;），以链表数据结构为例，两个线程通过&lt;code&gt;C A S&lt;/code&gt;去删除头节点，假设现在链表有&lt;code&gt;A-&amp;gt;B&lt;/code&gt;节点&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.794392523364486&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8ny1VNcSscicjAax5qNibFxqiabJLQZYt6OMXoBHbMIlLoNjgVt85LZlT0FGAoWB09ScvI5KITMSr9qxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1177&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程&lt;code&gt;1&lt;/code&gt;删除&lt;code&gt;A&lt;/code&gt;节点，&lt;code&gt;B&lt;/code&gt;节点成为头节点，正要执行&lt;code&gt;C A S(A,A,B)&lt;/code&gt;时，时间片用完，切换到线程&lt;code&gt;2&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程&lt;code&gt;2&lt;/code&gt;删除&lt;code&gt;A、B&lt;/code&gt;节点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程&lt;code&gt;2&lt;/code&gt;加入&lt;code&gt;C、A&lt;/code&gt;节点，链表节点变成&lt;code&gt;A-&amp;gt;C&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程&lt;code&gt;1&lt;/code&gt;重新获取时间片，执行&lt;code&gt;C A S(A,A,B)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;丢失&lt;code&gt;C&lt;/code&gt;节点&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要解决&lt;code&gt;A B A&lt;/code&gt;问题也非常简单，只要追加版本号即可，每次改变时加&lt;code&gt;1&lt;/code&gt;，即&lt;code&gt;A —&amp;gt; B —&amp;gt; A&lt;/code&gt;，变成&lt;code&gt;1A —&amp;gt; 2B —&amp;gt; 3A&lt;/code&gt;，在&lt;code&gt;Java&lt;/code&gt;中提供了&lt;code&gt;AtomicStampedRdference&lt;/code&gt;可以实现这个方案（&lt;strong&gt;面试只要问了&lt;code&gt;C A S&lt;/code&gt;，就一定会问&lt;code&gt;ABA&lt;/code&gt;，这块一定要搞明白&lt;/strong&gt;）。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;唠嗑唠嗑&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;C A S&lt;/code&gt;到这里就结束啦，当然了，后续会有&lt;code&gt;Atomic&lt;/code&gt;系列的文章，有了&lt;code&gt;C A S&lt;/code&gt;铺垫，后面的&lt;code&gt;Atomic&lt;/code&gt;也是十分简单的，另外这里有个福利想告知下给各位读者，阿星公众号明天有个&lt;strong&gt;回馈读者，送酷炫显示器一台的抽奖活动&lt;/strong&gt;，还没关注的朋友们，可以提前关注啦，欢迎大家参与，万一中了呢~&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;历史好文推荐&lt;/h1&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;关于我&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是阿星，一个热爱技术的Java程序猿，公众号  &lt;strong&gt;&lt;span&gt;「程序猿阿星」&lt;/span&gt;&lt;/strong&gt; 里将会定期分享操作系统、计算机网络、Java、分布式、数据库等精品原创文章，2021，与您在 Be Better 的路上共同成长！。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5763888888888888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/23OQmC1ia8ny1VNcSscicjAax5qNibFxqiabN9INTg5p0btl41sHbrWImwuUcvkNTB8otfP11SRo4zMibnJI47muKlQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;288&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常感谢各位小哥哥小姐姐们能看到这里，原创不易，文章有帮助可以关注、点个赞、分享与评论，都是支持（莫要白嫖）！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;愿你我都能奔赴在各自想去的路上，我们下篇文章见&lt;/p&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>