<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ca49fa8ac7c5851a0b435b9f84a28571</guid>
<title>这大概是最差的2022年Fla</title>
<link>https://toutiao.io/k/6o7qitt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single js_wx_tap_highlight wx_tap_card&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left js_a11y_comma js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUzNjAxODg4MQ==&amp;amp;action=getalbum&amp;amp;album_id=2093362651824209920#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;2093362651824209920&quot; data-tag_source=&quot;1&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#工程师&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;5个&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;h1&gt;新年答谢用户福利:除夕夜发红包，要入群的亲们赶紧啦。&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2700296735905046&quot; data-type=&quot;jpeg&quot; data-w=&quot;674&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlib9s4YRCefQopMmSOqAx9aunSzJvdzevtQUggImbDBM6v7yicctUzN3mKjSBodUr5Xmcu70DjYq4Tw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;新年flag：&lt;/p&gt;&lt;p&gt;1&amp;gt;千万不要想着去深造&lt;/p&gt;&lt;p&gt;2&amp;gt;不要再关心用户数&lt;/p&gt;&lt;p&gt;3&amp;gt;晚上的重保和往年一样一切顺利&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在公众号写这篇文章，就像我之前在文章评论里提过的：我是自己的最大黑粉。但是这些都是真实的经历和思考，觉得还是能让大家少走一些弯路吧。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;千万不要想着去深造&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我有个梦想，希望有机会去大学里讲课。不是全职的，偶尔讲讲课也好。但是学历不够，只有一个同等学力的研究生文凭。还是一个半吊子心理学的。听说现在大学的讲师都是博士起步。所以想去讲课要重新上研究生还要上博士。如果为了这个梦想放下一切，从现在开始也要7年的时间。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;梦想是一定要有的，万一实现了呢。但是，现在千万不要去想这件事，先专心把工作做好。立这个Flag出于两点：&lt;/p&gt;&lt;p&gt;第一是根据自身特点。&lt;/p&gt;&lt;p&gt;第二是时间的管理方法要求。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;根据自身特点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;自己觉得哈，自己和其他人有那么一丁点不一样。我要是想做什么，会非常投入的去做，从而会忽略一些其他的事情。对我现在而言，工作是最重要的，不应该分散精力做其他的事情，否则什么也做不好。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;澄清一点哈，我觉得能够非常投入的做事情不一定是好事。大家看到我总是周末和节假日发文章不要有压力，我其实是很羡慕周末放松的朋友的。我现在的情况完全是因为……脑子坏掉了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我是认真的。小时候我觉得自己还是挺正常的，记忆力不错。那时候看电影电视剧，看一遍整个台词包括里面出现的诗句都能背下来。但是平时精力比较涣散。上课不听讲。老师提问我上去做题，我没听老师讲课所以刚上去的时候是不会的，但是看一眼旁边同学立即学会了，然后做对了走下讲台。做作业的时候，嘴里唱着歌，脑子里做着电视回放，左手转着笔，右手答着题。这种精力不集中的情况下，每次做不了全对，但是能有个八九十分。总体成绩还不错。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;初三的时候，出了一次车祸，撞到了“颅底”，说是大脑非常关键的部位，大出血休克差点挂掉。从此，上课发现老师讲课听不懂了，说话开始词不达意了。而且再也不能左手画圆右手画方了，一次只能干一件事。说也奇怪，我是山东人。中考压力也蛮大的，我们是一个重点初中，前四名有希望考重点高中。之前我成绩十名左右的样子，出车祸后就上升到了前四名，顺利考上了重点高中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;凡事都有代价，成绩上来的代价是从此想做好什么都要非常努力去做。往往做一件事的时候忽略了很多其他的事情。比如我到现在都打理不好自己的头发。这个……认识我的朋友是知道的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上帝为我关上了一扇门却同时打开了一扇窗。如果我能自己选，我仍要原来的门---要走出去容易很多。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;时间的管理方法要求&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8574074074074074&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlib4b8hIIMeFf4AKsDJWsLGGicoSta9Z7Pt0tRx9TTsrPvUybicuJosozjR1GN6GRvt3AK8ySj5lBaicQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;事有轻重缓急，伟人说过：如果要做的事情超过4件，就需要把多出来的全都放弃，不要再想着去做它。而结合我自身的特点，目前的情况最理想情况是把本职工作这一件事做好。坦白说，现在的年轻人后生可畏，人又聪明。我做梦都想着工作都未必事事比人家做的好。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;不要再关心用户数&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;大家知道我一般是周末写文周末发，而且没有固定的时间点。周三周四发文效果好；有固定时间点效果好。这些我知不知道呢，既然能写出来肯定是知道的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我的决策方式很简单，我想写什么，写了发了，而且周末发文基本也没有什么用户增长，没什么可激动的。事情做完了，精力就释放出来了。单核CPU单线程运行，任务唤醒成本太高。这本质也是一个时间管理的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其实文章周末写了，定到任务提醒中，周二睡觉前定时发送也是可以的。这是件有规律的事情，比随性要难一些，但是做到了也是一个提升。以后平时要这样做。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另外，我关注的重点在用户增长，这个是不对的。重点应该放到单篇文章的阅读量上，因为这个指标才是体现文章质量的直接指标，并且有效衡量的周期更短，对改进帮助更大。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;晚上的重保和往年一样一切顺利&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个和工作有关啦，这次终于可以现场重保，很激动。不要问我是什么公司，什么重保，个人公众号无权透漏公司信息。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;合法合规是立身之本。记得在之前公司，我曾经给相关部门的同事上报有一年总共在公众号挣了2块多钱的广告费，问要不要申报。估计那个收到的同事还以为我在恶作剧呢。我是真心问合不合规，要不要申报。还专门查了相关法律条文赞赏和这些广告费要不要交税，虽然我的文章只有底部广告，而且长度都在几千字，底部广告根本没有人点。一年也没有十几块钱的收入。但是我是终于找到的条文说不用交税才放心。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这次除夕我初步打算发200元80个红包。虽然不多，相信我，我的总体收入是负数，所以对大家的一片赤诚之心还是能体现的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;128&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlib4b8hIIMeFf4AKsDJWsLGGib0PiagtXy6EZQ589nMdUBSmn5Iib6rv8YhKuPdyNuH5QWGM7q62ZtBzQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3d72e318487d132076cd450672afbf2b</guid>
<title>2022春节贺岁档电影开分，水门桥不理想，四海崩了！用Python一探究竟</title>
<link>https://toutiao.io/k/877cd6d</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管受到疫情影响，部分地区被迫关闭了电影院，但从大年初一中国影史第二单日总票房的数据来看，2022 年春节期间大家的观影热情还是十分高涨的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大年初一上映当天，从票房数据来看，《长津湖之水门桥》一马当先，《四海》《这个杀手不太冷静》《奇迹·笨小孩》你追我赶，动画片《熊出没》表现强势，《狙击手》令人遗憾。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.902687673772011&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2ozNacoHjicGBv5GWSAUWzUcDsPcwLNdFhJf9YOU3VTBib67xh8fYb9qHQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1079&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前，几部真人电影豆瓣已经开分了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32421875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2opOvlOiabnvTV7V4pFT65gBINUefyz5co2fLwp7mtMs8eDtqosJHTHrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们用 Python 爬取这几部豆瓣开分的电影评论，爬取的具体分析过程这里就不说了，不了解的可以参考一下：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU3Mzk1ODA5OQ==&amp;amp;mid=2247484101&amp;amp;idx=1&amp;amp;sn=2367e5f51ca00e35717d8ab7340c5aad&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;豆瓣影评爬取参考&lt;/a&gt;，主要实现代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;spider&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    url = &lt;span&gt;&#x27;https://accounts.douban.com/j/mobile/login/basic&#x27;&lt;/span&gt;&lt;br/&gt;    headers = {&lt;span&gt;&quot;User-Agent&quot;&lt;/span&gt;: &lt;span&gt;&#x27;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)&#x27;&lt;/span&gt;}&lt;br/&gt;    &lt;span&gt;# 龙岭迷窟网址，为了动态翻页，start 后加了格式化数字，短评页面有 20 条数据，每页增加 20 条&lt;/span&gt;&lt;br/&gt;    url_comment = &lt;span&gt;&#x27;https://movie.douban.com/subject/35215390/comments?start=%d&amp;amp;limit=20&amp;amp;sort=new_score&amp;amp;status=P&#x27;&lt;/span&gt;&lt;br/&gt;    data = {&lt;br/&gt;        &lt;span&gt;&#x27;ck&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;用户名&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&#x27;password&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;密码&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&#x27;remember&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;false&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&#x27;ticket&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    session = requests.session()&lt;br/&gt;    session.post(url=url, headers=headers, data=data)&lt;br/&gt;    &lt;span&gt;# 初始化 4 个 list 分别存用户名、评星、时间、评论文字&lt;/span&gt;&lt;br/&gt;    users = []&lt;br/&gt;    stars = []&lt;br/&gt;    times = []&lt;br/&gt;    content = []&lt;br/&gt;    &lt;span&gt;# 抓取 500 条，每页 20 条，这也是豆瓣给的上限&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;500&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;):&lt;br/&gt;        &lt;span&gt;# 获取 HTML&lt;/span&gt;&lt;br/&gt;        data = session.get(url_comment % i, headers=headers)&lt;br/&gt;        &lt;span&gt;# 状态码 200 表是成功&lt;/span&gt;&lt;br/&gt;        print(&lt;span&gt;&#x27;第&#x27;&lt;/span&gt;, i, &lt;span&gt;&#x27;页&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;状态码：&#x27;&lt;/span&gt;,data.status_code)&lt;br/&gt;        &lt;span&gt;# 暂停 0-1 秒时间，防止IP被封&lt;/span&gt;&lt;br/&gt;        time.sleep(random.random())&lt;br/&gt;        &lt;span&gt;# 解析 HTML&lt;/span&gt;&lt;br/&gt;        selector = etree.HTML(data.text)&lt;br/&gt;        &lt;span&gt;# 用 xpath 获取单页所有评论&lt;/span&gt;&lt;br/&gt;        comments = selector.xpath(&lt;span&gt;&#x27;//div[@class=&quot;comment&quot;]&#x27;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;# 遍历所有评论，获取详细信息&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; comment &lt;span&gt;in&lt;/span&gt; comments:&lt;br/&gt;            &lt;span&gt;# 获取用户名&lt;/span&gt;&lt;br/&gt;            user = comment.xpath(&lt;span&gt;&#x27;.//h3/span[2]/a/text()&#x27;&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;            &lt;span&gt;# 获取评星&lt;/span&gt;&lt;br/&gt;            star = comment.xpath(&lt;span&gt;&#x27;.//h3/span[2]/span[2]/@class&#x27;&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;7&lt;/span&gt;:&lt;span&gt;8&lt;/span&gt;]&lt;br/&gt;            &lt;span&gt;# 获取时间&lt;/span&gt;&lt;br/&gt;            date_time = comment.xpath(&lt;span&gt;&#x27;.//h3/span[2]/span[3]/@title&#x27;&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;# 有的时间为空，需要判断下&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; len(date_time) != &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;                date_time = date_time[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;                date_time = date_time[:&lt;span&gt;10&lt;/span&gt;]&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;                date_time = &lt;span&gt;None&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;# 获取评论文字&lt;/span&gt;&lt;br/&gt;            comment_text = comment.xpath(&lt;span&gt;&#x27;.//p/span/text()&#x27;&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;].strip()&lt;br/&gt;            &lt;span&gt;# 添加所有信息到列表&lt;/span&gt;&lt;br/&gt;            users.append(user)&lt;br/&gt;            stars.append(star)&lt;br/&gt;            times.append(date_time)&lt;br/&gt;            content.append(comment_text)&lt;br/&gt;    &lt;span&gt;# 用字典包装&lt;/span&gt;&lt;br/&gt;    comment_dic = {&lt;span&gt;&#x27;user&#x27;&lt;/span&gt;: users, &lt;span&gt;&#x27;star&#x27;&lt;/span&gt;: stars, &lt;span&gt;&#x27;time&#x27;&lt;/span&gt;: times, &lt;span&gt;&#x27;comments&#x27;&lt;/span&gt;: content}&lt;br/&gt;    &lt;span&gt;# 转换成 DataFrame 格式&lt;/span&gt;&lt;br/&gt;    comment_df = pd.DataFrame(comment_dic)&lt;br/&gt;    &lt;span&gt;# 保存数据&lt;/span&gt;&lt;br/&gt;    comment_df.to_csv(&lt;span&gt;&#x27;data.csv&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了评论数据，我们再通过词云直观的感受一下，主要代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;df = pd.read_csv(&lt;span&gt;&quot;comment.csv&quot;&lt;/span&gt;, index_col = &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;cts_list = df[&lt;span&gt;&#x27;comments&#x27;&lt;/span&gt;].values.tolist()&lt;br/&gt;cts_str =&lt;span&gt;&quot;&quot;&lt;/span&gt;.join([str(i).replace(&lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;&#x27;&lt;/span&gt;).replace(&lt;span&gt;&#x27; &#x27;&lt;/span&gt;, &lt;span&gt;&#x27;&#x27;&lt;/span&gt;) &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; cts_list])&lt;br/&gt;stop_words = []&lt;br/&gt;&lt;span&gt;with&lt;/span&gt; open(&lt;span&gt;&#x27;stop_words.txt&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;r&#x27;&lt;/span&gt;, encoding=&lt;span&gt;&#x27;utf-8&#x27;&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; f:&lt;br/&gt;    lines = f.readlines()&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; lines:&lt;br/&gt;        stop_words.append(line.strip())&lt;br/&gt;&lt;span&gt;# jieba 分词&lt;/span&gt;&lt;br/&gt;word_list = jieba.cut(cts_str)&lt;br/&gt;words = []&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; word &lt;span&gt;in&lt;/span&gt; word_list:&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; word &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; stop_words:&lt;br/&gt;        words.append(word)&lt;br/&gt;cts_str = &lt;span&gt;&#x27;，&#x27;&lt;/span&gt;.join(words)&lt;br/&gt;print(cts_str)&lt;br/&gt;stylecloud.gen_stylecloud(text=cts_str, max_words=&lt;span&gt;300&lt;/span&gt;,&lt;br/&gt;                          collocations=&lt;span&gt;False&lt;/span&gt;,&lt;br/&gt;                          font_path=&lt;span&gt;&quot;SIMLI.TTF&quot;&lt;/span&gt;,&lt;br/&gt;                          icon_name=&lt;span&gt;&quot;fas fa-arrow-circle-right&quot;&lt;/span&gt;,&lt;br/&gt;                          size=&lt;span&gt;800&lt;/span&gt;,&lt;br/&gt;                          output_name=&lt;span&gt;&quot;comment.png&quot;&lt;/span&gt;)&lt;br/&gt;Image(filename=&lt;span&gt;&quot;comment.png&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们来看《四海》，《四海》的口碑为什么没有纵横四海？看看观众怎么说的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2oakEHR4kNg4GhTmaNibeNj1myqrop4wor1HgjWHAQMylrjWhRxFCpFaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着看《这个杀手不太冷静》，作为一部喜剧片，豆瓣这个评分还算可以，看看观众怎么说的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2oJhxrv81ibiapiaGNd9vw8Z7LHJZNow1BRoJb56TotK16Pw38G9OqrRHDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再接着看《长津湖之水门桥》，目前评分是低于第一部的，看看观众怎么说的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2oicHZecIeGxqlTd7KYaOylx4297QdeLJonpTpdufHO6EablaZGZ1rMeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再接着看《奇迹·笨小孩》，评分和票房都算是中规中矩，看看观众怎么说的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2oc2zJS8V2YoDfCUaP3pkBibFSEkgkOLUcRz8OeMN9oKLBpNtN3mTDY6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再接着看《狙击手》，国师父女指导，票房不佳，评分暂列第一，看看观众怎么说的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2ok6LupiaY4Svw5VY3zET2Q2w8J3UJ4cUOnstKLrmCiczicTYd5tzGI3RpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码已经打包整理好了，有需要的小伙伴可以在公众号&lt;strong&gt;Python数据分析之美&lt;/strong&gt;后台回复&lt;strong&gt;m2022&lt;/strong&gt;直接获取~&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b796d9b52880f42c972215177fad7684</guid>
<title>网易云音乐广告CTR预估模型演进过程</title>
<link>https://toutiao.io/k/ajdmqsp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&amp;quot;shifu_c_008&amp;quot;)&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;导读：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文先介绍了效果广告的基本原理，然后以云音乐广告系统从浅层模型到深度模型的演进为主线，介绍了广告算法团队在算法优化过程中遇到的问题、思考和解决的过程。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;广告是云音乐的重要收入来源之一，最近两年云音乐广告平台在深度（机器）学习技术上做了很大的投入，期间也遇到了许多问题，也取得了一些不错的成果。本文将以模型演进为主线，重点介绍遇到的问题、思考和解决问题的过程，希望能为其他同学在类似的算法场景下提供一些参考。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;广告系统最典型的机器学习应用场景是广告点击率（CTR）预估，另外在广告主需要考核成本的时候还会用到转化率（CVR）预估，其中也有大量的深度学习实践，考虑到篇幅，本文聚焦在CTR预估，以后再单独介绍CVR的相关实践。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;1&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p hm_fix=&quot;360:461&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;云音乐广告系统的特点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;广告作为互联网的主要商业模式之一，是各大互联网公司的重要业务。云音乐广告平台是国内第一个专注于基于音频流量变现的广告平台，有一些自己的特点，比如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些基本特点决定了算法模型的选择、优化等基本面，后续会穿插着提到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;2&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p hm_fix=&quot;360:461&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;广告系统为什么需要CTR预估&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 广告主和媒体的博弈问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我前面提到广告点击率（CTR）预估是典型的机器学习应用场景，但为什么需要CTR预估呢，为了解释清楚这个问题，需要先了解效果广告的机制。效果广告要的是直接转化率，这一点跟品牌广告不同，品牌广告主要打品牌知名度，比如汽车广告，房产广告等，广告主不指望用户看完这个广告之后立刻去买一辆车子或者房子，而是先让用户熟悉这个品牌。而效果广告则希望用户看完广告之后立刻去成交，例如淘宝上的商品搜索广告，百度搜索广告等，都以转化为目的。效果广告的主要博弈方是广告主和媒体方，扩展一下也包含了广告平台、用户等参与方，但为了简化问题我们只考虑最主要的部分，双方的利益如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5308464849354376&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmdjGiazJ8nRH7oc0GJEvQE5Gp2ZtxmPaz7nsbOGsxb2c1qCV1raxibEtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;697&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;广告主最关注ROI，希望用最低的成本拿到自己的目标用户，底线是不能长期做亏本生意。媒体方则希望提高点击率（按点击率计费时，点击越多收入越多）、通过竞争提升单次点击价格，关注的是流量变现价值的最大化。这两方的诉求目标是矛盾的，解决办法是引入经济学的拍卖机制，然后用计算机程序来实现自动竞价，把经济学和计算机科学结合起来解决这个博弈问题，下面详细介绍一下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. GFP vs GSP&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大家应该在电视里面看过拍卖的场景，比如拍卖某个古董时，从低价开始喊，然后不断加价，直到没人再加为止，这时候锤子一敲就成交了，这个模式叫做英式拍卖，这种公开叫价的形式叫明拍。还有一种叫暗拍，情况类似于每个竞买人把自己的价格写好，等全部交上去后按价格的高低排序，价格最高者得。如果是第一价格模式则按第一价格支付，按第二价格模式则出价最高的人按照第二名的价格支付。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8515901060070671&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmAmA1pVhdQgicYIibj2dUftsLYLHYIIjEZ4har8Gq2w3D76c8YCZGNrQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;283&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;GFP（Generalized First Price）广义第一价格模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;早期的互联网产品，比如Yahoo和MSN采用的是GFP，广告主针对某个关键词出价，价高者得且按自己的出价支付。早期百度的竞价排名也是类似的规则。但这种模式最大的问题是系统收入非常不稳定，竞买人需要频繁修改出价以拿到流量或者希望以更低的价格拿到流量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;GSP（Generalized Second Price）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2002年Google在Adwords业务中采用了GSP机制，即出价最高者按照第二名的出价来支付。GSP模式由于看不到其他人的出价，可以鼓励广告主按照自己认为的真实价值来出价，鼓励“讲真话”。并且排序时还引入了质量得分，通常是pCTR，即预估的广告点击率，然后按照Price * pCTR排序，这样可以惩罚广告质量差的广告。用Bid来表示出价，则按eCPM排序的规则为：eCPM = Bid * pCTR * 1000 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于在竞拍的过程中，不可能所有参与竞买的广告都能得到曝光，并且不同的人对于不同的广告点击率也不一样，所以CTR不能使用历史统计值，而且即使有历史统计值也解决不了新广告的问题，因此CTR只能预估，但如何预估呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 经济学+机器学习&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;机器学习为CTR预估找到了一个解决方案：利用机器学习的回归技术来预测点击概率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以用一个公式来表示，点击概率 p = f(user features, context features, ad features)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样一来，就比较完美地平衡了广告主和媒体方的利益：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;精准投放保障广告主的ROI；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;拍卖机制保障媒体方流量价值的最大化；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在这过程中，CTR预估扮演着非常关键的桥梁作用。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmkPOsa6w3fAA3wmcImJIPkmAvJ5vKSuicWTNW01jPObH5V76ThNT7JuA/640?wx_fmt=jpeg&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1034&quot; data-cropy1=&quot;57.245674740484425&quot; data-cropy2=&quot;441.86505190311414&quot; data-ratio=&quot;0.3723404255319149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sYBGQlzfEOWQvvKU1Uicm15ERq0qqwTFD4WZWX2suEpzLbicav7RhBNGtkKjib7OvRauYs4pXyhDbXPqAMz8BbWjQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1034&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;3&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p hm_fix=&quot;360:461&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;浅层学习CTR预估模型优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业界早期阶段，在2012年以前，几乎主流公司都使用LR模型来预估CTR。LR有很多优点，比如简单、易于并行化、可解释性强。比较适合处理广告场景高维、稀疏的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6869565217391305&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmuORuRmM9Y8YmoPfpqNJzIPmVNgiaY1XpwyswVeIibrcmD4E0NCntOQnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;345&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（利用sigmoid函数映射点击概率）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;云音乐广告系统最初采用的是LR模型，至今也还作为基线在跑着。后来尝试了FM，以及LR+GBDT，FM+GBDT，如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmrejoJ6aaRYQhZWj3CVVUIbmkFkk8TiaiajJKhZHYr5xPXiaPs2oCR2RGA/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;572&quot; data-cropy1=&quot;37&quot; data-cropy2=&quot;502&quot; data-ratio=&quot;0.8111888111888111&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sYBGQlzfEOWQvvKU1Uicm15ERq0qqwTFDpO5mibLkbAvdNPjvuRibWkpaJibCzficxQIia1h63CRHyWibibh4Mw7OViaPQw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;572&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;LR模型阶段打下了很多基础，做了很多数据和特征工程的事情，避免Garbage in, garbage out，争取达到效果的上限。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 数据采样&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;（1）样本正确选取问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最开始，各个广告位的历史数据是放在一起训练的，最终训练出一个模型。启动画也包含其中，并且数据量占了很大比例，但启动画有一个很大的问题，就是误点率很高，误点数据基本上是随机分布，没办法体现出用户的真实意图，很多数据都是噪声，严重影响模型的准确性。因此需要去除不能真实反应用户意图的场景数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，最初的版本iOS和Android双端数据也是放在一起训练的，但通过一段时间的运行发现，双端的广告主数据几乎完全不一样，基本上可以看做是两个数据集，并且在同样的广告位，其CTR和CVR的表现也有显著差异。所以需要拆分不同的数据分布。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，对于训练样本的选择来说，我们把开机画数据拆了出去，同时iOS和Android分端训练，这样一来，模型效果得到了大幅提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;AB实验中，iOS端eCPM提升了11.12%，Android端eCPM提升了10.50%，全流量后效果表现一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;（2）样本不平衡问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在我们的CTR场景，尤其是CVR场景，正负样本比例相差非常大。CTR正负样本比例大约从1:1000至1:100，CVR从曝光到转化则是1:10000，甚至更低。在模型的训练过程中，正样本变成了小概率事件，很容易被模型当作噪声而忽略了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们在CTR模型中，把正样本上采样了10倍，效果上Android端AUC提升1.02%，iOS端AUC提升0.75% 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对CVR模型（深度模型）的训练数据，我们对负样本降采样10倍，AUC提升了1.06%，线上效果也表现显著。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;（3）其它的样本问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过优化，离线AUC提高了1.4%， eCPM相对基线提高了3.73% 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 特征组合&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们有一个CASE分析工具，可以分析不同权重对结果的影响程度。我们发现模型并没有学出用户侧与广告侧的匹配关系，主要依靠单特征在影响pCTR打分。尽管做了一些人工特征组合，比如广告主+年龄，但由于太稀疏没有学出来。很自然我们想用FM模型来尝试一下自动特征组合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;（1）尝试FM&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;FM引入了隐向量，为每一个特征学习一个隐权重向量。在做特征交叉时，使用两个特征隐向量的内积作为交叉特征的权重。与直接特征组合（用POLY2模型的方式）需要该组合的所有特征同时存在才更新参数不同，对训练数据中没有出现的组合FM也能够学到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.1788793103448276&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmUf265CiaDCua9CwFXJmqcfWIKibQdE4UxQmvE97WvW0Gibo1KicrFuzorQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;464&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;举例来说：用直接特征组合时，只有当广告主为“潭州教育”且“用户年龄为20岁”时才会更新该组合特征的参数（否则其中一个为0，则相乘后也为0），但这种组合太稀疏，基本上训练不充分。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;FM由于使用两个特征向量的内积来表示权重，比如广告主（潭州教育）的特征向量为v_i，年龄为20岁的特征向量为v_j，权重w=向量积&amp;lt;v_i,v_j&amp;gt;，只要出现了广告主（潭州教育）或年龄为20岁的样本，都可以共享更新相应的特征向量。解决了稀疏特征组合的问题。FM的不足是只有二阶特征组合，非线性表达能力依然不足。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;效果：线下AUC提升0.75%，但线上效果不稳定，因此只做了小流量上线，不符合全流量的标准。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们推断了效果不理想的原因：一是我们的特征中，连续特征很多，将其离散化取决于经验，因此即使做了二阶交叉，解决的可能不是关键问题；第二，云音乐的广告推荐场景属于弱个性化推荐场景。相对来说云音乐的歌曲推荐属于强个性化推荐，淘宝的商品推荐也属于强个性化推荐，不仅拥有足够的样本数据做训练，每个人的偏好也相对更明显。而个人对广告的喜爱与否并不是那么明显（有时候说喜欢广告，不如说不那么讨厌的广告）。在这种场景下，二阶特征组合的记忆力并不算太好，基于这种推断，我们自然开始尝试GBDT。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;（2）尝试GBDT&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;GBDT的引入带来了如下优点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7710144927536232&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmbZGaCY194NJezduD7Q16G93VtMtdnu7LA4unk6D1oOhmcsqQmWPicoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;345&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;LR+GBDT模型相比基线LR模型，AUC绝对值提升1.03%，相对提升1.71%，效果非常显著。线上CTR和eCPM提升稳定，符合全流量标准。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;之后我们又尝试了FM+GBDT，但效果不如LR+GBDT。浅层学习阶段，最终LR+GBDT胜出，成为了效果最好的模型。我们的推测原因是：弱个性化场景下需要有深度记忆功能。LR处理了稀疏特征记忆能力，GBDT处理好了深度组合特征以及连续特征的记忆能力，这正是我们音频流量广告场景（结合我们的广告主特点）所适合的。我们这个思路会持续到深度学习阶段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如喜欢听儿童歌曲的用户，年龄可能在25岁以上，并且可能喜欢购买化妆品，可能是年轻的妈妈们。喜欢听英文歌曲的用户，也许是爱好英文歌曲，也许正在锻炼自己的听力，喜欢点击英语培训广告，需要多种特征组合起来才能更精确。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;4&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p hm_fix=&quot;360:461&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;人类行为可预测的认知 – 个人理论总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;人类行为有93%是可预测的，这是美国东北大学科学家的一项研究结论。我认为这一基本原则是很多优化工作的指导基础。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 个体人格相对稳定，才能用历史预测未来&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;人类行为可预测是因为人格的相对稳定性，人格包含性格、气质、能力、兴趣、爱好等成分，是由先天的遗传和后天的环境因素共同决定的。招聘面试也是采用了这个原理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 人类具有共同的行为模式，可以用群体预测个体&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由此原理引出了协同过滤算法，即利用某种共同兴趣或共同经历的群体行为来预测个体的行为。比如大多数读过笑傲江湖和神雕侠侣的人，都读过倚天屠龙记，假如有某个人读了笑傲江湖和神雕侠侣，我们可以推断他很大概率会喜欢倚天屠龙记。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;做算法上的任何优化，都应该遵循这两个基本原则。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;5&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p hm_fix=&quot;360:461&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;深度模型演进和优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;深度模型的引入，一方面是由于业界已经有很多公司成功把深度学习应用到了CTR预估，并取得了效果；其实更重要的原因是延续LR+GBDT的优化思路，需要持续做，上面提到了用LR处理稀疏特征记忆，用GBDT处理深度组合特征和连续特征记忆，自然会想到Wide&amp;amp;Deep模型，即使用Wide的记忆能力，以及Deep的泛化能力。我们从Wide&amp;amp;Deep切入深度学习，并且做了很多尝试。如图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVm1gITTTcDCe376bXJicSiaibmgOEMx1gjUk584kEKPrvL0OAFnnHW4ut6A/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;306&quot; data-cropy1=&quot;41&quot; data-cropy2=&quot;784&quot; data-ratio=&quot;2.4248366013071894&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sYBGQlzfEOWQvvKU1Uicm15ERq0qqwTFDpV2Ek9hT9BvlPbibTibCqCF4toLVk2aEAdwhIJGqlIS7fjsfAGOlLSKQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;306&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Wide&amp;amp;Deep、DeepFM、DCN都没有全流量，第一个全流量的深度模型是DCN+Wide，目前（2020年10月）正在跑的是DICN+Wide。下面介绍一下这些模型的特点和问题，以及做的优化工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. Wide&amp;amp;Deep&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在讲Wide&amp;amp;Deep之前，我先讲一下业界早期尝试将深度学习应用于广告CTR预估的情况。业界早期的时候，使用的是纯DNN模型（MLP），但无论怎么优化都很难超越LR+GBDT，主要原因是广告场景有大量的长尾稀疏数据，DNN采用Embedding的方式训练不出来，后来尝试了很多方法把DNN和LR以及其它浅层模型融合起来，融合之后的效果才超过了LR，比如采用LR训练后的权重参数，或者进一步将FM的隐向量作为Embedding输入等。Wide&amp;amp;Deep就是在这种情况下作为一种融合方案之一，由Google在2016年发布出来的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVms5ZGbomY20FTqEicr49Hbu4CicnoPZ9e8u6cOLsKQLKltZnxicvmHrnNw/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;522&quot; data-cropy1=&quot;42&quot; data-cropy2=&quot;350&quot; data-ratio=&quot;0.5919540229885057&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sYBGQlzfEOWQvvKU1Uicm15ERq0qqwTFDvHKp5ynOxk8zIUHnxE1jFn26RRTS20r8QVTuDDozkXAGTaA0uIgYZA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;522&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;W&amp;amp;D通过将浅层模型和深层模型联合训练，融合了浅层模型的记忆能力和深层模型的泛化能力。通过Wide侧较好地解决了长尾数据的拟合，弥补了纯DNN的不足。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过理论归理论，有没有效果还要看实际场景，我们最开始W&amp;amp;D的效果始终没有赶上LR，后来做了一些特征优化，比如连续特征同时做离散化处理，用全连接代替Wide和Deep融合时直接相加，最后的效果只是与LR模型打平。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们根据浅层学习时的经验，认为是Deep侧对特征交叉训练不够，纯DNN模型只是隐性交叉，并且是稀疏的场景，隐性交叉需要足够的样本和足够多的训练时间。因此后续的思路是需要在Deep侧做特征交叉方面的尝试。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于是第一个深度模型，也让我们体会到了，并不是所有深度模型的效果都会优于浅层模型，尤其是做过良好特征工程的LR模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. DeepFM&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本来顺着上面的思路应该优化Deep侧，但由于根据以往的经验，DeepFM模型的效果可能还不错，我们还尝试了DeepFM模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.49550898203592814&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmiaiapPMlgGQHISttlcfgxiaJtIWStCS5uu259tejwQPTZSZ2ia7JpzokDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;668&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;优化了特征、正则项、模型层数和embedding size等调优，最终效果与基线LR的AUC相差千分位，依然不好，与浅层模型时单独尝试FM的效果表现一致，这坚定了我们往优化Deep侧的方向去尝试。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. DCN&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DCN的引入主要是为了解决纯DNN没有特征显式交叉的问题，它在Wide&amp;amp;Deep的基础上，把Wide侧改成了Cross Network，示意如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.978343949044586&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVm4DmfiabLhnCNwPLQQKLicoyCoyHy2zia5UhEgzA0QeSUaQ6JIoTic1NInQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;785&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该模型的核心是Cross Network，设计用来高效地进行特征交叉，公式如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.11826086956521739&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmib2TE4CJocfhiaUGAmQiaTcHZJHrickaZIVF1K6nQBMQY1b954xbhr0icFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;575&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;xl表示第l层的cross layer输出，wl是参数，bl是偏置，都是列向量。其实是应用了残差网络的思想，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3806646525679758&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmLhvgWD6A25VuicpIf1lV1NabvicoV4bU1A5o0r9FALrgJhIbHmQDeg3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;662&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样模型就能够高效地学习到高阶的非线性特征组合了。DCN的效果：离线AUC比LR高0.69%，线上eCPM提升幅度稳定达到3%，达到了上线标准。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们观察到的现象是当特征显性高阶交叉时效果就会更好，与LR采用GBDT组合特征时效果会更好的表现是一致的。应该是挖掘出了音乐场景下深层次的关系。后来我们还在DCN上面引入了Attention机制，也取得了一定的效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4. DCIN+Wide&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;顺着前面的优化思路，DCN已经解决了特征深度交叉，以及泛化的功能，DIN解决了用户短期兴趣问题，这些解决的都是头部数据的问题，这些数据有一定的量来训练，而广告场景的长尾数据问题依然没有解决。因此我们很自然地把Wide侧增加了进去，模型示意图如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8576388888888888&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmGfqHZDLh89946DHKibQqM26LHTWiaaLECluIHpxD78IfqSM7t0vZq1YQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;864&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Wide的加入，使得长尾数据的记忆能力得到了一定的加强，线下AUC和线上效果都有一定的提升，虽然提升量不算太大，但为人工特征工程提供了可能。这是我们现在的线上模型（2020年10月）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面介绍一些我们对深度模型做的优化点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5. 激活函数的优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在优化DeepFM的过程中，最初Deep模型的隐藏层激活函数用的是ReLU，但我们发现Deep侧不起作用，进一步发现隐藏层的很多输出为0。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.24742268041237114&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmAZuarfAXfoLf0srUcicmVutvIOhWicEDupPkKWsYqc9VZHmtkZXlxicYw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;388&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从ReLU函数的定义可以知道，负梯度时该ReLU单元会被置为0，这是它单侧抑制的能力。但由于我们的数据特点，ReLU的这个特点变成了局限，在训练过程中导致大量神经元不可逆死亡，进而使大量参数无法更新，从而训练过程失败。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;后来我们把激活函数换成了PReLU，公式如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.23834196891191708&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmZHR6U20T2RsBnqlf8x40QrrTSoXzA2fzJURvhLIqZVKzxXnVgwaSNg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;386&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当x小于0时，用了一个很小的正数a实现一个斜率为a的线性函数ax，这样既实现了单侧抑制功能，又不至于导致大量神经元不可逆死亡。a可以作为网络中的参数通过训练更新。当a=0时，PReLU退化成ReLU；如果a是一个固定值，则PReLU退化成Leaky ReLU（LReLU）。BP更新a时，采用的是带动量的更新方式：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.294478527607362&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmd2koSXia6cIkyoiaSO8SyicxyysZ85sDT6gO6cxljOGUhPHhEqoDibrn5w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;326&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ReLU和PreLU的函数曲线图对比如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4236111111111111&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmkKw3KYc7M5jUiaVfFUwAMU0iaAhFwSEvyKrkr3Tk28gpvCZWOYibicAiaibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;864&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;采用PReLU作为激活函数之后，解决了神经元死亡的问题，AUC提升了千分之五。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;6. 递减学习率和Batch size的优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们使用adam优化器，学习率初始值设置为 a，之后每n步降低0.96，AUC提升了千分之二。我们的Batch size设置为10000，比起很多公司的CTR场景设置来说偏大，主要是由于我们很多场景的CTR是千分位，需要考虑每个batch里有一定数据的正样本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8775894538606404&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmP0rGNSOzZ0lHib3A44JThfN2qUD34j6s6qjWZLq8kYU3Ik7lvZRiazgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;531&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上图看到，太高的学习率会导致不收敛或者震荡，太低的学习率则收敛速度太慢，递降的学习率一开始比较大可以让模型快速收敛，后面逐步减少则可以精确收敛。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;7. 缺失值处理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于我们的数据稀疏，很多属性和特征的覆盖率不高，经常会存在样本中域缺失的情况。我们给缺失的域一个单独的Embedding向量，使缺失值不对该域其他的Embedding向量产生影响。处理流程如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; x1缺失:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  x’= w1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  x’= w2 * x1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;x’作为Embedding向量输入模型。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8. 深度模型时代，特征工程依然重要&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;深度模型时代并非不需要特征工程了，尽量理论上说DNN能够拟合任意函数，但那只是理论上的，前提是有稠密的数据、充足的样本、足够长的训练时间。而现实中上述条件可能一项都不具备，因此在如何让模型更有效率训练这个问题上，需要考虑不同数据的特点，比如图像处理需要用CNN，时序处理用RNN，广告及推荐场景可能用DeepFM，DCN，DIN等，都是在采用更适合的模型来做“特征工程”，找到适合自己数据特征的交叉方式来提升训练的有效性。另外在对长尾数据的处理方面，依然把浅层模型融合进来，把之前有效的人工组合特征工程继续用上。深层浅层学习结合起来提升效果，目前看起来还比较有效。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;6&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p hm_fix=&quot;360:461&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;优化建议&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们在算法改进的过程中遇到了非常多的问题，上面只是列了其中的一部分。我认为最重要的是做事方法，正确的方法可以少走弯路，对此我有三点建议：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;抓住本源。采用的数据要能真实反应用户的意图，并且数据一定要正确，这是所有后续工作的基础。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;围绕解决业务问题去思考和创新。别人的方法只能参考，每个业务的特点不同，数据分布肯定也不一样，必须要针对自己的业务和数据特点做优化。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;看细节。从细节中去找问题和找改进点，CASE分析很重要，否则容易高来高去不接地气。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;网易有数为云音乐广告变现业务提供一站式机器学习平台服务，欢迎点击“阅读原文”了解产品。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101582&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;作者简介&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p hm_fix=&quot;322:369&quot;&gt;&lt;span&gt;Neil，网易云音乐营收技术负责人，曾任百度国际移动广告平台技术负责人，十多年互联网行业经验，专注于广告算法和后端系统架构。获北京大学学士学位，马里兰大学硕士学位。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIwNTUxNTI1Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOV4Bfic2e5zqTMCl0XxmMuVq1XpDOBrbXicVB4KmrEXglsWcnMREoQXfX24sscdvQIR74ic3SiciaLoMFA/0?wx_fmt=png&quot; data-nickname=&quot;网易有数&quot; data-alias=&quot;Youdata_Netease&quot; data-signature=&quot;网易有数是网易数帆旗下大数据技术与服务品牌，以“数据价值”为导向，聚焦于企业 “看数”、“管数”、“用数”等业务场景，提供全链路大数据技术及产品服务，致力于盘活企业数据生产力，加速实现数字化转型。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;__bg_gif rich_pages wxw-img&quot; data-fileid=&quot;100003451&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/sYBGQlzfEOXECeWKgyIia3c7bom7Ir4rh4qI4XdxuRW4lyHudFyglytmLrOM4yYOWs3XNqqj0XlXTEw8icZ2Eb1Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;317:401&quot;&gt;分享，点赞，在看，安排一下？&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4a2ecfd101c9a8b157a7eded7768cf07</guid>
<title>腾讯课堂 H5 直播间点赞动效实现</title>
<link>https://toutiao.io/k/s9wmei7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section class=&quot;mp_profile_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU2Mzk1NzkwOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibpVQtdHw0UaW5glBQ3RRqy8rYolxkF0tOaAqTUGW9MXPIGvLUGAJ7jB2JicLxJd6xvvWicThNSWFgg/0?wx_fmt=png&quot; data-nickname=&quot;趣谈前端&quot; data-alias=&quot;beautifulFront&quot; data-signature=&quot;徐小夕【知乎专栏作家】掘金签约作者，定期分享前端工程化，可视化，企业实战项目知识，深度复盘企业中经常遇到的500+技术问题解决方案。【关注趣谈前端，前端路上不迷茫】&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;职业规划&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;高级前端&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;可视化低代码&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;点击上方 &lt;strong&gt;趣谈前端&lt;/strong&gt;&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;，关注公众号&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回复&lt;/span&gt;&lt;span&gt;&lt;span&gt;进群&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，加入前端交流群&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;1. 前言&lt;/strong&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;以前在看微信视频号直播的时候，经常点击右下角的点赞按钮。看着它的数字慢慢从一位数变成五位数，还是挺有氛围感的。特别是长按的时候，有个手机震动的反馈，很带感。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.14375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnZAVNKXV6pohRgZHxYe68hicnejt0jqiaJQ4Dr9FLdJFJicb199s9RcOrQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;320&quot;/&gt;&lt;/p&gt;&lt;p&gt;虽然之前很好奇这些飘动的点赞动效是怎么实现的，但没有特别去钻研。直到前阵子投入腾讯课堂 H5 直播间的需求，需要自己去实现一个这样的效果时，才开始摸索。&lt;/p&gt;&lt;p&gt;先看看最后的效果：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.7890625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnNYSbDhHmnWxASR45B7zGmFbnRjsiaolyCEXj9trb2XI35UzMNlibbZpg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;256&quot;/&gt;&lt;/p&gt;&lt;p&gt;相比视频号的点赞动效，轨迹复杂了很多。可以看到课堂直播间的这一段点赞动效，大概分为这么三个阶段：&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;从无到有，在上升过程中&lt;strong&gt;放大&lt;/strong&gt;成正常大小&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;上升过程中&lt;strong&gt;左右摇曳&lt;/strong&gt;，且&lt;strong&gt;摇曳的幅度随机&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;左右摇曳上升的过程中，&lt;strong&gt;渐隐并缩小&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;p&gt;在动手之前，我先想到了使用 &lt;strong&gt;CSS animation&lt;/strong&gt; 去实现这种运动轨迹。在完成之后，又用 &lt;strong&gt;Canvas&lt;/strong&gt; 重构了一版，优化了性能。&lt;/p&gt;&lt;p&gt;接下来我们分别来看看这两种实现方式。&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;2. CSS 实现点赞动效&lt;/strong&gt;&lt;/h2&gt;&lt;h3&gt;&lt;strong&gt;2.1 轨迹分析&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;由于点赞动画是在一个二维平面上的，我们可以将它的运动轨迹拆分为 &lt;strong&gt;x 轴&lt;/strong&gt; 和 &lt;strong&gt;y 轴&lt;/strong&gt; 上的两段。&lt;/p&gt;&lt;p&gt;在 &lt;strong&gt;y 轴&lt;/strong&gt; 上非常简单，我们的点赞图标会做一段&lt;span&gt;垂直上升的&lt;/span&gt;匀速运动，从容器底部上升到容器顶部。&lt;/p&gt;&lt;p&gt;而 &lt;strong&gt;x 轴&lt;/strong&gt; 上是左右摇曳的，用数学的角度说，是一段简谐运动。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5864485981308412&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3Cn2ZYgnv2KkzoW2WoNHFD5PSDsaAiabyfxA6qK8MwRfyWWL1U0Ab8M0Ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;428&quot;/&gt;&lt;/p&gt;&lt;p&gt;但用 css 实现的时候，其实不用这么精细。为了简化计算，我们可以用几个关键帧来串联这段运动轨迹，例如：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;@keyframes&lt;/strong&gt;&lt;/span&gt; bubble_swing {&lt;br/&gt;  &lt;span&gt;0%&lt;/span&gt; {&lt;br/&gt;    中间&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;25%&lt;/span&gt; {&lt;br/&gt;    最左&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;75%&lt;/span&gt; {&lt;br/&gt;    最右&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;100%&lt;/span&gt; {&lt;br/&gt;    中间&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;2.2 轨迹设计&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;根据上面的分析，我们可以设计一段相同的上升轨迹，以及几段不同的左右摇曳轨迹。&lt;/p&gt;&lt;p&gt;上升轨迹很简单，&lt;span&gt;同时&lt;/span&gt;我们还可以加上透明度（opacity）、大小（transform）的变化，如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;@keyframes&lt;/strong&gt;&lt;/span&gt; bubble_y {&lt;br/&gt;  &lt;span&gt;0%&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;transform&lt;/span&gt;: &lt;span&gt;scale&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;margin-bottom&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;5%&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;transform&lt;/span&gt;: &lt;span&gt;scale&lt;/span&gt;(&lt;span&gt;1.5&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;80%&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;transform&lt;/span&gt;: &lt;span&gt;scale&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;100%&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;margin-bottom&lt;/span&gt;: &lt;span&gt;var&lt;/span&gt;(--cntHeight);&lt;br/&gt;    &lt;span&gt;transform&lt;/span&gt;: &lt;span&gt;scale&lt;/span&gt;(&lt;span&gt;0.8&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中，--cntHeight 指的是容器的高度。也就是说，我们通过让 margin-bottom 不断增大，来控制点赞图标从容器底部上升到容器顶部。&lt;/p&gt;&lt;p&gt;而对于横向运动的轨迹，为了增加运动轨迹的多样性，我们&lt;span&gt;可&lt;/span&gt;&lt;span&gt;以设计多段&lt;/span&gt;左右摇曳的轨迹，比如说一段 “中间 -&amp;gt; 最左 -&amp;gt; 中间 -&amp;gt; 最右” 的轨迹：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;@keyframes&lt;/strong&gt;&lt;/span&gt; bubble_swing_1 {&lt;br/&gt;  &lt;span&gt;0%&lt;/span&gt; {&lt;br/&gt;    // 中间&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;25%&lt;/span&gt; {&lt;br/&gt;    // 最左&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: -&lt;span&gt;12px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;75%&lt;/span&gt; {&lt;br/&gt;    // 最右&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;12px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;100%&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里同样使用 margin 来控制图标的左右移动。类似的，我们还可以设计几段别的轨迹：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 任意轨迹&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;@keyframes&lt;/strong&gt;&lt;/span&gt; bubble_swing_2 {&lt;br/&gt;  0% {&lt;br/&gt;    &lt;span&gt;// 中间&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  33% {&lt;br/&gt;    &lt;span&gt;// 最左&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: -&lt;span&gt;12px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  100% {&lt;br/&gt;    &lt;span&gt;// 随机位置&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;6px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 简谐反向&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;@keyframes&lt;/strong&gt;&lt;/span&gt; bubble_swing_3 {&lt;br/&gt;  0% {&lt;br/&gt;    &lt;span&gt;// 中间&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  25% {&lt;br/&gt;    &lt;span&gt;// 最右&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;12px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  75% {&lt;br/&gt;    &lt;span&gt;// 最左&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: -&lt;span&gt;12px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  100% {&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来我们把 &lt;strong&gt;x 轴&lt;/strong&gt; 和 &lt;strong&gt;y 轴&lt;/strong&gt; 的轨迹（@keyframes）结合起来，并设置一个随机的动画时间，比如说：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;@for&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;$i&lt;/span&gt; from &lt;span&gt;1&lt;/span&gt; through &lt;span&gt;3&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;@for&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;$j&lt;/span&gt; from &lt;span&gt;1&lt;/span&gt; through &lt;span&gt;2&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;.bl_&lt;/span&gt;#{&lt;span&gt;$i&lt;/span&gt;}_#{&lt;span&gt;$j&lt;/span&gt;} {&lt;br/&gt;      &lt;span&gt;animation&lt;/span&gt;: bubble_y calc(&lt;span&gt;1.5s&lt;/span&gt; + &lt;span&gt;$j&lt;/span&gt; * &lt;span&gt;0.5s&lt;/span&gt;) linear &lt;span&gt;1&lt;/span&gt; forwards,&lt;br/&gt;        bubble_swing_#{&lt;span&gt;$i&lt;/span&gt;} calc(&lt;span&gt;1.5s&lt;/span&gt; + &lt;span&gt;$j&lt;/span&gt; * &lt;span&gt;0.5s&lt;/span&gt;) linear &lt;span&gt;1&lt;/span&gt; forwards;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里生成了 3 * 2 = 6 种不同的轨迹。针对这类重复的选择器，用 SCSS 中的循环语法，可以少写很多代码。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;2.3 随机选择图片（雪碧图）&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;我们每次点赞会出现不同的图标，于是这里设计了一系列选择器给不同的图标，让它们呈现不同的图片。首先我们要准备一张雪碧图，保持所有图标的大小一致，然后同样使用 SCSS 的循环语法：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;@for&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;$i&lt;/span&gt; from &lt;span&gt;0&lt;/span&gt; through &lt;span&gt;7&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;.b&lt;/span&gt;#{&lt;span&gt;$i&lt;/span&gt;} {&lt;br/&gt;    &lt;span&gt;background&lt;/span&gt;: url(&lt;span&gt;&#x27;../../images/like_sprites.png&#x27;&lt;/span&gt;) calc(#{&lt;span&gt;$i&lt;/span&gt;} * -&lt;span&gt;24px&lt;/span&gt;) &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;像上面生成了 8 个选择器，我们在程序执行时就可以随机给图标赋予一个选择器。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;2.4 生成一个点赞图标&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;CSS 的部分差不多了，我们现在来看 JS 是怎么执行的。我们需要有一个容器 div，让它来装载要生成的点赞图标。以及一个按钮来绑定点击事件：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;const cacheRef = useRef&amp;lt;LikeCache&amp;gt;({&lt;br/&gt;    bubbleCnt: &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;    likeIcon: &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;    bubbleIndex: &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;    timer: &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;useEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    cacheRef.current.bubbleCnt = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;like-bubble-cnt&#x27;&lt;/span&gt;);&lt;br/&gt;    cacheRef.current.likeIcon = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;like-icon&#x27;&lt;/span&gt;);&lt;br/&gt;}, []);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在点击事件中，生成一个新的 div 元素，并为它设置 className。接着将它 append 到容器下，最后在一段时间后销毁这个点赞图标元素。如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 添加 bubble&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; addBubble = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; { bubbleCnt } = cacheRef.current;&lt;br/&gt;&lt;br/&gt;  cacheRef.current.bubbleIndex %= maxBubble;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; d = &lt;span&gt;document&lt;/span&gt;.createElement(&lt;span&gt;&#x27;div&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 图片类 b0 - b7&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 随机动画类 bl_1_1 - bl_3_2&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; swing = &lt;span&gt;Math&lt;/span&gt;.floor(&lt;span&gt;Math&lt;/span&gt;.random() * &lt;span&gt;3&lt;/span&gt;) + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; speed = &lt;span&gt;Math&lt;/span&gt;.floor(&lt;span&gt;Math&lt;/span&gt;.random() * &lt;span&gt;2&lt;/span&gt;) + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  d.className = &lt;span&gt;`like-bubble b&lt;span&gt;${cacheRef.current.bubbleIndex}&lt;/span&gt; bl_&lt;span&gt;${swing}&lt;/span&gt;_&lt;span&gt;${speed}&lt;/span&gt;`&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  bubbleCnt?.appendChild(d);&lt;br/&gt;  cacheRef.current.bubbleIndex++;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 动画结束后销毁元素&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;setTimeout&lt;/span&gt;(&lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    bubbleCnt?.removeChild(d);&lt;br/&gt;  }, &lt;span&gt;2600&lt;/span&gt;);&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;到这里，我们就实现得差不多了。不过，我们还可以给点击的图标加点动画，让它有一个被按压后弹起的效果：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 点击“喜欢”&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; onClick = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; { timer, likeIcon } = cacheRef.current;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (!likeIcon) {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (timer) {&lt;br/&gt;    &lt;span&gt;clearTimeout&lt;/span&gt;(timer);&lt;br/&gt;    cacheRef.current.timer = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  likeIcon.classList.remove(&lt;span&gt;&#x27;bounce-click&#x27;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;// 删除并重新添加类，需要延迟添加&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;setTimeout&lt;/span&gt;(&lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    likeIcon.classList.add(&lt;span&gt;&#x27;bounce-click&#x27;&lt;/span&gt;);&lt;br/&gt;  }, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;  cacheRef.current.timer = &lt;span&gt;window&lt;/span&gt;.setTimeout(&lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    likeIcon.classList.remove(&lt;span&gt;&#x27;bounce-click&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;clearTimeout&lt;/span&gt;(timer!);&lt;br/&gt;    cacheRef.current.timer = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  }, &lt;span&gt;300&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  addBubble();&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;2.5 最终效果&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;最后来看看效果吧！&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.3728813559322033&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnKMM9EDicGnPXbFbLpMNpr4JMGcT53f2hbKZjW68KbtSACvXxibu3gI3g/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;177&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;3. Canvas 实现点赞动效&lt;/strong&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;我们都知道 Canvas 的绘制更流畅一些，能够带来更好的体验。但苦于编码比较复杂，也有一定的学习成本，实现起来要比 CSS 复杂不少。&lt;/p&gt;&lt;p&gt;接下来我们看看基于 &lt;span&gt;C&lt;/span&gt;&lt;span&gt;anvas&lt;/span&gt; 的点赞动效实现。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;3.1 画布创建&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;首先我们读取一个 &lt;span&gt;C&lt;/span&gt;&lt;span&gt;anvas&lt;/span&gt; 元素的 id，并通过 getContext 获取它的上下文。除此之外，还传入了一个 canvasScale，指的是画布放大的比例，这个在之后会用到：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;constructor&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;canvasId: string, canvasScale: number&lt;/span&gt;)&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; canvas = &lt;span&gt;document&lt;/span&gt;.getElementById(canvasId) &lt;span&gt;&lt;strong&gt;as&lt;/strong&gt;&lt;/span&gt; HTMLCanvasElement;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.context = canvas.getContext(&lt;span&gt;&#x27;2d&#x27;&lt;/span&gt;)!;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.width = canvas.width;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.height = canvas.height;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.canvasScale = canvasScale;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.img = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.loadImages();&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.2 预加载图片（雪碧图）&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;在 constructor 这里，我们还通过 loadImages 这个函数，预加载了雪碧图：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;import&lt;/strong&gt;&lt;/span&gt; likeSprites &lt;span&gt;&lt;strong&gt;from&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&#x27;../../images/like_sprites.png&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 预加载图片&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;loadImages = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; p = &lt;span&gt;&lt;strong&gt;new&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve: (image: HTMLImageElement) =&amp;gt; &lt;span&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; img = &lt;span&gt;&lt;strong&gt;new&lt;/strong&gt;&lt;/span&gt; Image();&lt;br/&gt;    img.onerror = &lt;span&gt;() =&amp;gt;&lt;/span&gt; resolve(img);&lt;br/&gt;    img.onload = &lt;span&gt;() =&amp;gt;&lt;/span&gt; resolve(img);&lt;br/&gt;    img.src = likeSprites;&lt;br/&gt;  });&lt;br/&gt;  p.then(&lt;span&gt;(&lt;span&gt;img&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (img &amp;amp;&amp;amp; img.width &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.img = img;&lt;br/&gt;    } &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// error(&#x27;[live-connect]预加载喜欢动效图片失败&#x27;);&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  });&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.3 轨迹拆解&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;同样的，我们需要从 Canvas 的视角来拆解点赞图标的运动轨迹。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;y 轴&lt;/strong&gt; 的运动和 CSS 一样，我们知道起始位置和终止位置就可以得出。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;x 轴&lt;/strong&gt; 的运动可以好好推敲。由于 Canvas 是逐帧绘制的，我们可以模拟出一个比较逼真的简谐运动。这里要来讲一讲大家耳熟能详的初中数学了，下面是我们要使用的一条正弦函数的公式：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;y = A sin(Bx + C) + D&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参数说明：&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;振幅是 &lt;strong&gt;A&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;周期是 &lt;strong&gt;2π/B&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;相移是 &lt;strong&gt;−C/B&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;垂直移位是 &lt;strong&gt;D&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;套入点赞动效：&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;赋予图标元素随机的振幅 A。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;赋予图标元素随机的周期，即 B 是随机的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;取 C = 0，即相移为 0。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;取 D = 0，即不需要垂直移位。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;y = A sinBx。&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.4 横竖位移计算&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;确定位移轨迹之后，我们先定义一些常量，如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/** 图片显示宽高 */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; IMAGE_WIDTH = &lt;span&gt;30&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/** 图片原始宽高 */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; SOURCE_IMAGE_WIDTH = &lt;span&gt;144&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/** 图片数量 */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; IMG_NUM = &lt;span&gt;8&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/** 放大阶段（百分比）*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; ENLARGE_STAGE = &lt;span&gt;0.1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/** 收缩渐隐阶段（百分比）*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; FADE_OUT_STAGE = &lt;span&gt;0.8&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先我们可以设计 &lt;strong&gt;x 轴&lt;/strong&gt; 和 &lt;strong&gt;y 轴&lt;/strong&gt; 两个方向上的位移计算函数，函数参数 progress 是 0 到 1 之间的数值，表示一个过程量（0 -&amp;gt; 1）。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 起始位置&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; basicX = &lt;span&gt;this&lt;/span&gt;.width / &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 正弦频率&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; frequency = random(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 正弦振幅&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; amplitude = random(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;) * (random(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) ? &lt;span&gt;1&lt;/span&gt; : -&lt;span&gt;1&lt;/span&gt;) * &lt;span&gt;this&lt;/span&gt;.canvasScale;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 获取横向位移（x轴）&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; getTranslateX = &lt;span&gt;(&lt;span&gt;progress: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (progress &amp;lt; ENLARGE_STAGE) {&lt;br/&gt;    &lt;span&gt;// 放大期间，不进行摇摆位移&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; basicX;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; basicX + amplitude * &lt;span&gt;Math&lt;/span&gt;.sin(frequency * (progress - ENLARGE_STAGE));&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 获取竖向位移（y轴）&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; getTranslateY = &lt;span&gt;(&lt;span&gt;progress: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; IMAGE_WIDTH / &lt;span&gt;2&lt;/span&gt; + (&lt;span&gt;this&lt;/span&gt;.height - IMAGE_WIDTH / &lt;span&gt;2&lt;/span&gt;) * (&lt;span&gt;1&lt;/span&gt; - progress);&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.5 大小和透明度计算&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;要绘制的图标大小怎么控制呢？在 Canvas 中，其实就是计算一个 scale，表示放缩的比例。&lt;/p&gt;&lt;p&gt;我们根据放大/收缩阶段的过程常量和 progress 变量来调节它的大小。起始阶段先线性放大至 1，最后阶段再线性缩小至 0。&lt;/p&gt;&lt;p&gt;透明度同理，在消失之前都是返回 1，其余时刻线性缩小。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 获取放缩比例&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; getScale = &lt;span&gt;(&lt;span&gt;progress: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;let&lt;/strong&gt;&lt;/span&gt; r = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (progress &amp;lt; ENLARGE_STAGE) {&lt;br/&gt;    &lt;span&gt;// 放大&lt;/span&gt;&lt;br/&gt;    r = progress / ENLARGE_STAGE;&lt;br/&gt;  } &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (progress &amp;gt; FADE_OUT_STAGE) {&lt;br/&gt;    &lt;span&gt;// 缩小&lt;/span&gt;&lt;br/&gt;    r = (&lt;span&gt;1&lt;/span&gt; - progress) / (&lt;span&gt;1&lt;/span&gt; - FADE_OUT_STAGE);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; r;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 获取透明度&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; getAlpha = &lt;span&gt;(&lt;span&gt;progress: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (progress &amp;lt; FADE_OUT_STAGE) {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;return &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; - (progress - FADE_OUT_STAGE) / (&lt;span&gt;1&lt;/span&gt; - FADE_OUT_STAGE);&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.6 Canvas 绘制&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;绘制时，我们先挑选一张图片。如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 按顺序读取图片&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; { curImgIndex } = &lt;span&gt;&lt;strong&gt;this&lt;/strong&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 更新顺序&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;this&lt;/strong&gt;&lt;/span&gt;.curImgIndex = ++&lt;span&gt;&lt;strong&gt;this&lt;/strong&gt;&lt;/span&gt;.curImgIndex % IMG_NUM;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;strong&gt;3.6.1 画布元素清晰度&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;接下来需要用到我们之前提到的 canvasScale 了：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; newWidth = IMAGE_WIDTH * &lt;span&gt;this&lt;/span&gt;.canvasScale;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为什么这里要乘以一个 canvasScale 呢？因为 Canvas 是&lt;strong&gt;位图模式&lt;/strong&gt;的，它会根据设备的 &lt;strong&gt;dpi&lt;/strong&gt; 来渲染图片。&lt;/p&gt;&lt;p&gt;首先先介绍一下高分屏的概念：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;高分屏：在同样大小的屏幕面积上显示更多的像素点，也就是更多的可视信息。常见的就是 SXGA（1400 * 1050），UXGA（1600 * 1200）。1024 * 768 分辨率的屏幕叫普通屏，也就是 XGA 的屏幕，这个分辨率以上的屏幕叫高分屏。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在高分屏上，每平方英寸会有更多的像素。原来在普通屏上绘制的 1 个像素，为了适应高分屏，被迫放大，变成了 4 个像素或者更多。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;可以想象成，一张清晰度正常的普通图片为了布满整个背景被强行放大 n 倍，所以看起来模糊了&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7434869739478958&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnbPNrjWlfSpuw7eSdysHUzPsroUKbjBBCf0f6Ik4MAkF99lOAqf1gRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;499&quot;/&gt;&lt;/p&gt;&lt;p&gt;为了解决这个问题，就需要我们将绘制的图片放大。同时还要控制 Canvas 画布在 CSS 中的宽高。做到绘制内容变大的同时，画布依然呈现原来的大小。这样一来，图片就会因为绘制了更多的内容，而在高分屏上变得清晰且细腻。&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;3.6.2 绘制元素&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;绘制我们用到了 drawImage。在调用它之前，我们需要&lt;span&gt;根据计算出的 translateX 和 translateY，&lt;/span&gt;&lt;span&gt;调&lt;/span&gt;&lt;span&gt;整绘制的起&lt;/span&gt;&lt;span&gt;点&lt;/span&gt;。并且调整放缩比例和透明度，即 &lt;code&gt;context.scale()&lt;/code&gt; 和 &lt;code&gt;context.globalAlpha&lt;/code&gt;。如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;(&lt;span&gt;progress: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 动画过程 0 -&amp;gt; 1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (progress &amp;gt;= &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;&lt;strong&gt;return &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  context.save();&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; scale = getScale(progress);&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; translateX = getTranslateX(progress);&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; translateY = getTranslateY(progress);&lt;br/&gt;  context.translate(translateX, translateY);&lt;br/&gt;  context.scale(scale, scale);&lt;br/&gt;  context.globalAlpha = getAlpha(progress);&lt;br/&gt;  context.drawImage(&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.img!,&lt;br/&gt;    SOURCE_IMAGE_WIDTH * curImgIndex,&lt;br/&gt;    &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;    SOURCE_IMAGE_WIDTH,&lt;br/&gt;    SOURCE_IMAGE_WIDTH,&lt;br/&gt;    -newWidth / &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt;    -newWidth / &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt;    newWidth,&lt;br/&gt;    newWidth,&lt;br/&gt;  );&lt;br/&gt;  context.restore();&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;strong&gt;3.6.3 创建绘制实例&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;我们用一个 start 函数来生成点赞动画，每当调用它时，都会创建一个 render 方法，并塞入一个 renderList。renderList 中存放的就是当前所有点赞图标的绘制任务。如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;start = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; render = &lt;span&gt;this&lt;/span&gt;.createRender();&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; duration = random(&lt;span&gt;2100&lt;/span&gt;, &lt;span&gt;2600&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (!render) {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.renderList.push({&lt;br/&gt;    render,&lt;br/&gt;    duration,&lt;br/&gt;    &lt;span&gt;timestamp&lt;/span&gt;: &lt;span&gt;Date&lt;/span&gt;.now(),&lt;br/&gt;  });&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.scanning) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.scanning = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    requestAnimationFrame(&lt;span&gt;this&lt;/span&gt;.scan);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;strong&gt;3.6.4 实时绘制&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;知道了需要绘制哪些对象之后，就需要通过下面的 scan 方法，让 Canvas 在每一帧都去绘制内容。&lt;/p&gt;&lt;p&gt;每次绘制分为这么几个过程：&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;清空画布为透明。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;从绘制列表中取出一个点赞图标的 render 方法，并调用它。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;假如它返回了 true，代表点赞图标已经完整经历了整个动效的过程，需要将它从绘制列表中剔除出去。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;重复 2、3 过程，直至列表中没有任务需要执行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;requestAnimationFrame&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 调用 scan 方法自身，等待下一帧重新调用 scan 绘制内容。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;scan = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.context.clearRect(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.width, &lt;span&gt;this&lt;/span&gt;.height);&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;let&lt;/strong&gt;&lt;/span&gt; index = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;let&lt;/strong&gt;&lt;/span&gt; { length } = &lt;span&gt;this&lt;/span&gt;.renderList;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (length &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    requestAnimationFrame(&lt;span&gt;this&lt;/span&gt;.scan);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.scanning = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  } &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.scanning = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;while&lt;/strong&gt;&lt;/span&gt; (index &amp;lt; length) {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; child = &lt;span&gt;this&lt;/span&gt;.renderList[index];&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (!child || !child.render || child.render.call(&lt;span&gt;null&lt;/span&gt;, (&lt;span&gt;Date&lt;/span&gt;.now() - child.timestamp) / child.duration)) {&lt;br/&gt;      &lt;span&gt;// 结束了，删除该动画&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.renderList.splice(index, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;      length--;&lt;br/&gt;    } &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;/span&gt; {&lt;br/&gt;      index++;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.7 调用&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;接下来我们只需要在点击的时候，调用一下 &lt;code&gt;start&lt;/code&gt; 方法即可。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 点击“喜欢”&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; onClick = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  cacheRef.current.LikeAni?.start?.();&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; (&lt;br/&gt;  &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;{cn(&lt;/span&gt;&#x27;&lt;span&gt;like-wrap&lt;/span&gt;&#x27;, &lt;span&gt;className&lt;/span&gt;)}&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;canvas&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;{CANVAS_ID}&lt;/span&gt; &lt;span&gt;width&lt;/span&gt;=&lt;span&gt;{CANVAS_WIDTH}&lt;/span&gt; &lt;span&gt;height&lt;/span&gt;=&lt;span&gt;{CANVAS_HEIGHT}&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;like-bubble-cnt&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;{cn(&lt;/span&gt;&#x27;&lt;span&gt;like-icon-cnt&lt;/span&gt;&#x27;, &lt;span&gt;className&lt;/span&gt;)} &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{onClick}&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;i&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;like-icon&quot;&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;like-icon&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在直播场景下，还有很多不同的触发方式。除了自己点击，我们还可以接受来自其他用户的反馈（网络请求）来触发&lt;span&gt; &lt;/span&gt;&lt;code&gt;start&lt;/code&gt;&lt;span&gt; 方法&lt;/span&gt;。或者根据在线人数，多次调用 &lt;code&gt;start&lt;/code&gt; 方法来生成一定数量的点赞图标。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;3.8 最终效果&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.3728813559322033&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnYP7LBJLR62gxgcnGSICWb4VWTXCy1PFJEvticiaLXO5TWh19eA5M2xZQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;177&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;4. 性能比较&lt;/strong&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;以下内容是在 MacBook Pro 16 的屏幕上测试的。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;4.1 Frame Rendering Stats&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;在 chrome devtools 中，有两个小功能可以来观察我们绘制的性能情况：&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;这两个功能，可以在 chrome devtools 中使用快捷键 Command + Shift + P，呼起命令搜索的 Panel 来搜索到。&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;CSS 性能&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;我们可以看到高亮区域在频繁闪动，以及 GPU 内存的使用比率较高，这是因为 CSS 的实现方式是不断生成新的元素（并在随后销毁），会消耗更多的内存。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0235690235690236&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3Cn61PuKHuVcJY64I0ciaw5Yib7aKR0QeczWS6w7Vov2EtcKhruOHEXIuAw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;297&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Canvas 性能&lt;/strong&gt;&lt;br/&gt;&lt;/h4&gt;&lt;p&gt;相反，Canvas 是集中在画布上绘制并输出的，不会反复创建和销毁元素。会比 CSS 的实现更加流畅，性能更好一点。&lt;/p&gt;&lt;p&gt;除了流畅以外，Canvas 还能够放大画布和画布元素，这也是一个非常重要的优势。这意味着 Canvas 能够绘制出更清晰的内容，生成出来的点赞图标更加细腻。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0235690235690236&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CneXgmLZDgbvcd17KZ2etPibicNN9GTMoSaib6cFxiaHuCRAlrB4tkvuibrLw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;297&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;4.2 Performance&lt;/strong&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;在 chrome devtools 中切换到 Performance 面板，还可以观察动画绘制过程中，页面的一些性能指标。&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;CSS 性能&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;CSS 的实现之所以看起比较卡顿，主要是因为绘制任务太频繁。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1705790297339593&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnUB3NiciafG8nmTuKibbRQ4OKZVeJicHbvMxclwKsmicZ6k6jQwumiaFCb9Wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1278&quot;/&gt;&lt;/p&gt;&lt;p&gt;具体到每一帧，我们可以观察到 LayoutShift 的警告。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.50431654676259&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3Cnh2hVHf4azOrrBKM4A1mHibNyeGI0x6ad3ze5OtdPuPBZuBQ5ogzfYaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1390&quot;/&gt;&lt;/p&gt;&lt;p&gt;每次可视元素在两次渲染帧中的起始位置不同时，就说是发生了 LS（Layout Shift）。&lt;strong&gt;改变了起始位置的元素被认为是不稳定元素&lt;/strong&gt;。&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Canvas 性能&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;Canvas 实现的性能情况看起来就比较正常，即使绘制清晰一些的图片也不在话下。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0332409972299168&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnKibqyoXGwzYP3IPzDj3bfosticSBNhal4Nr1rrz5HjibvRDqsJ1kHT5iag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1444&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;5. 相关&lt;/strong&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;实现参考：&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fgithub.com%2Fantiter%2Fpraise-animation&amp;amp;title=&quot; href=&quot;&quot;&gt;https://github.com/antiter/praise-animation&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;更多推荐&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;点个在看 你最好看&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.8&quot; data-type=&quot;png&quot; data-w=&quot;50&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ImtD1PjRzRibmwqBpXL6icIKqbwdwwR26NfB89hJ09AJCorfLHxNdGlIIKr02IiajJ3O6t3qzXFXcJZ1lUxUnibTIA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>19dcd8ae993693bacdf8747e2c342638</guid>
<title>新年特辑1-Gwen为你读：《No Matter What 》</title>
<link>https://toutiao.io/k/qnbk10r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;No Matter What&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;不管怎么样你都会爱我么？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Small was feeling grim and dark.&lt;/p&gt;&lt;p&gt;狐狸小小的心情，郁闷又糟糕。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Playing toss and fling and squash, yell and scream and bang and crash, break and snap and bash and battle.&lt;/p&gt;&lt;p&gt;他故意扔东西，还把它们压扁，然后大吼大叫，把东西弄得乒乒乓乓响。到处敲敲打打，大搞破坏。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;“Good grief!” said Large, “What is the matter?”&lt;/p&gt;&lt;p&gt;“哎呀！”狐狸妈妈说， “这是怎么了呢？”&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Small said, “I&#x27;m a grim and grumpy little Small and nobody loves me at all.”&lt;/p&gt;&lt;p&gt;小小说：“我是一只讨人厌又坏脾气的小狐狸，没有人爱我。”&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;“Oh Small,” said Large. “Grumpy or not, I&#x27;ll always love you no matter what.”&lt;/p&gt;&lt;p&gt;“噢，小小，”妈妈说，“不管你是不是坏脾气，我都会永远爱着你。”&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Small said, “If I was a grizzly bear, would you love me? Would you care?”&lt;/p&gt;&lt;p&gt;小小说：“那如果我是一只大棕熊，你还会爱我，一直关心我么？”&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;“Oh, of course,” said Large, “Bear or not, I&#x27;ll always love you, no matter what.”&lt;/p&gt;&lt;p&gt;“当然了”妈妈说，“就算你变成一只大棕熊，不管怎么样，我都会永远爱着你。”&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Small said, “But if I turned into a bug. Would you still love me and give me a hug?”&lt;/p&gt;&lt;p&gt;小小说：“可是，如果我变成一只虫虫，你还会爱我，抱抱我么？”&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;“Of course I would.” said Large, “Bug or not, I&#x27;ll always love you no matter what.&lt;/p&gt;&lt;p&gt;“当然会啊，”妈妈说，“就算你变成一只虫虫，不管怎么样，我都会永远爱着你。”&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;“No matter what?” said Small and smiled. &quot;What if I was a crocodile?”&lt;/p&gt;&lt;p&gt;“不管怎么样么？”小小微笑着问。“那如果我变成一只鳄鱼呢？”&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Large said, “ I&#x27;d hug you close and tight, and tuck you up in bed each night.”&lt;/p&gt;&lt;p&gt;妈妈说，“我会紧紧抱抱你，而且每晚都帮你盖好被子。”&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;“Does love wear out?” said Small, “Does it break or bend? Can you fix it, stick it? Does it mend?”&lt;/p&gt;&lt;p&gt;“那爱会不会有用完的一天呢？”小小又接着问，“它会不会坏掉或弯曲变形呢？你可以修好、黏好它么？它能修补得好么？”&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;“Oh help.” said Large,” I&#x27;m not that clever. I just know I&#x27;ll love you forever.”&lt;/p&gt;&lt;p&gt;“噢，天呀。”妈妈说，“我没有那么聪明，我只知道我会永远永远爱着你。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>