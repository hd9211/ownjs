<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>9bc91747953240610887972a7b42ebff</guid>
<title>万级并发：电商库存扣减如何设计？不超卖</title>
<link>https://toutiao.io/k/1nwsx5k</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着中国消费认知的不断升级，网购走近千家万户，越来越被人们所接受。淘宝、唯品会、考拉、京东、拼多多等逐渐成为我们生活的重要组成部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7577777777777778&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3Ohm6WHibeXKSo8vYe9AHPO3t2uiaGuvWbrn3BjzQHYAj1lml7Tz3InyHlSXQ7pcuMHtlcTR4jzCG7qMJLENrhRQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了常规的购物下单外，这些电商平台还经常搞一些双十一活动，秒杀、大促、限时购，各种营销玩法，层出不穷。&lt;strong&gt;今天就来跟大家聊一聊电商技术里的库存扣减&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.409375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3Ohm6WHibeXKSo8vYe9AHPO3t2uiaGuvWbrHv71rRVNQrVYjYHaejJY7rfURwkdLwsyvDReCra4RmibUGdGq5yrkA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当有很多人同时在买一件商品时（假设库存充足），每个人几乎同时下单成功，给人一种并行的感觉。但真实情况，&lt;strong&gt;库存只是一个数值，无论是存在mysql数据库还是redis缓存，减值时都要控制顺序，只能串行来扣减，当然为了保证安全性，会设计一些锁控制操作。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;🌴 库存扣减关键技术点&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;同一个SKU，库存数量是共享&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;剩余库存要大于等于本次扣减的数量，否则会出现&lt;code&gt;超卖&lt;/code&gt;现象，引发资损&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对同一个数量多用户并发扣减时，要注意并发安全，保证数据的一致性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类似于秒杀这样高QPS的扣减场景，要保证性能与高可用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于购物车下单场景，多个商品库存批量扣减，要保证事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果有&lt;code&gt;交易退款&lt;/code&gt;，保证库存扣减可以返还&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;返还的数据总量不能大于扣减的总量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返还要保证幂等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以分多次返还&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;🌴 数据库扣减方案&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要是依赖数据库特性来保证扣减的一致性，逻辑简单，开发部署成本很低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;依赖的数据库特性：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;依赖数据库的乐观锁（比如：版本号或者库存数量）保证数据并发扣减的强一致性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;借助事务特性，针对购物车下单批量扣减时，部分扣减失败，数据回滚&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.0289532293986636&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3Ohm6WHibeXKSo8vYe9AHPO3t2uiaGuvWbX08QmmqKul5D2Hws0s1OZWFgicUKViaDhiadWePQjdzloesSupH4gHVUg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;898&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;最上面会查询当前的剩余库存（可能不准确，但没关系，这里只是第一步粗略校验），前置校验，如果已经没有库存，前置拦截生效，减少对数据库的写操作。毕竟读操作不涉及加锁，并发性能高。数据库包含两张表：库存表、流水表。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1、库存表&lt;/strong&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;sku_id&lt;/td&gt;&lt;td&gt;商品规格id&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;leaved_amount&lt;/td&gt;&lt;td&gt;剩余可购买数量&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当用户进行取消订单、申请退货退款，需要把数量加回来&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果商家补过库存，需要在此基础上额外加上增量库存&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2、 流水表&lt;/strong&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;id&lt;/td&gt;&lt;td&gt;主键id&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sku_id&lt;/td&gt;&lt;td&gt;商品规格id&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;order_detail_id&lt;/td&gt;&lt;td&gt;订单明细id&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;quantity_trade&lt;/td&gt;&lt;td&gt;本次购买扣减的数量&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用于查看明细、对账、盘货、排查问题等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在扣减后，某些场景下需要返还也依赖流水&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;单条商品的扣减SQL大致如下：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;update inventory &lt;br/&gt;&lt;span&gt;set&lt;/span&gt; leaved_amount = leaved_amount - &lt;span&gt;#{count} &lt;/span&gt;&lt;br/&gt;&lt;span&gt;where&lt;/span&gt; sku_id=&lt;span&gt;&#x27;123&#x27;&lt;/span&gt; and leaved_amount &amp;gt;= &lt;span&gt;#{count}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;此 SQL 采用 类似乐观锁的方式实现了原子性，在 where 条件里判断此次购买的数量小于等于剩余的数量。在扣减服务的代码里，判断此 SQL 的返回值，如果值为 1 ，表示扣减成功。否则，返回 0 ，表示库存不足，需要回滚。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;扣减成功后，需要记录扣减流水，并与订单明细记录做关联。&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当用户归还数量时，需要带回此编号，用来标识此次返还属于历史上的具体哪次扣减。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;进行幂等性控制。当用户调用扣减接口出现超时时，因为用户不知道是否成功，用此编号进行重试或反查。在重试时，使用此编号进行标识防重。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;🌴 【数据库扣减方案】第一次升级&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个极端的例子：最新款iPhone秒杀，库存只有5件，活动期间峰值QPS预估在10W，活动结束后，上面的流水表最终只会插入5条记录，但是查询的QPS却接近 &lt;code&gt;10W QPS&lt;/code&gt;，读的压力非常大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，数据库扣减方案第一次升级主要是针对&lt;code&gt;库存前置校验&lt;/code&gt;模块的优化，作为前置拦截器，承载的流量很大，如果将流量全部压到主库上，很容易把数据压垮。我们考虑把数据库架构升级。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.825&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3Ohm6WHibeXKSo8vYe9AHPO3t2uiaGuvWbNjhEgFx6wtpQWbC4M6DdkDVA7IccaSFziaeIffiaJFn1VzEQibcbic5icwA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1120&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采用了&lt;code&gt;读写分离&lt;/code&gt;方式，新增加了一套从库，借助mysql自带的数据同步能力。&lt;code&gt;库存校验&lt;/code&gt;时读取从数据库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，数据同步有一定的时间延迟，从库的数据新鲜度有一定的滞后性，所以这个&lt;code&gt;库存校验&lt;/code&gt;结果并不一定准确，但却能拦截大部分的&lt;code&gt;无效流量&lt;/code&gt;。最终能不能成功购买，由主库的&lt;code&gt;乐观扣减SQL&lt;/code&gt;来控制，并不会影响最终扣减的准确性。大大减轻主库的查询压力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;🌴 【&lt;/strong&gt;&lt;strong&gt;数据库扣减方&lt;/strong&gt;&lt;strong&gt;案】第二次升级&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入了从库，确实能分摊主库很大一部分压力，但是面对秒杀这种万级QPS流量，mysql的&lt;code&gt;千级TPS&lt;/code&gt;根本支撑不了，需要进一步升级读取的性能。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8719298245614036&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3Ohm6WHibeXKSo8vYe9AHPO3t2uiaGuvWbavZWeotuZgMsJ6DzzLufKiaGO4GA4SS0IGP7aR25VPWNicibDb2SLlicibQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1140&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;此时引入缓存中间件（如Redis），将mysql的数据定时同步到缓存中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;库存校验&lt;/code&gt;模块，从redis中查询剩余的库存数据。由于缓存基于内存操作，性能比数据库高出几个数量级，单台redis实例可以达到10W QPS的读性能&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方案升级后，基本上解决了在前置&lt;code&gt;库存校验&lt;/code&gt;环节及&lt;code&gt;获取库存数量接口&lt;/code&gt;的性能问题，提高了系统整体性能，提供较好的用户体验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;补充说明：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果并发量还是很高的话，可以考虑引入&lt;code&gt;缓存集群&lt;/code&gt;，将不同的&lt;code&gt;秒杀商品sku&lt;/code&gt;尽量均匀分布在多个redis节点中，从而分摊掉整体的峰值QPS压力。（参考缓存热点的解决方案）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据库方案的优点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;借助数据库的&lt;code&gt;ACID&lt;/code&gt;特性，业务上不会出现&lt;code&gt;超卖&lt;/code&gt;、&lt;code&gt;少买&lt;/code&gt;现象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实现简单，如果项目工期紧张，或者开发资源不足情况下非常适用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据库方案的不足：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果参与秒杀的SKU非常多，最后的写操作都是基于&lt;code&gt;库存主库&lt;/code&gt;，性能压力会比较大。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;🌴 纯缓存扣减方案&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis采用单线程的事件模型，具有&lt;code&gt;原子性&lt;/code&gt;的特性。当有多个客户端给Redis发送命令时，Redis会按照接收到的顺序&lt;code&gt;串行化&lt;/code&gt;执行。对于还未被调度的命令，则放在队列里&lt;code&gt;排队等待&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;库存扣减为了保证数据并发安全，要求原子性，而&lt;code&gt;Redis&lt;/code&gt;正好满足扣减类的特殊性要求，是个不错的技术选型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面，我们简单来看看基于&lt;code&gt;Redis&lt;/code&gt;如何来设计库存扣减？&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.1947483588621444&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3Ohm6WHibeXKSo8vYe9AHPO3t2uiaGuvWbmQvibxIVqVWas4bpf9D3oEb3dc9yoALMU2EOdDGfKJlXjwS2bficr1TQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;914&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;首先，设计Redis的数据模型：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;剩余库存（k-v结构）：&lt;br/&gt;key：sku_leaved_amount_{sku_id}&lt;br/&gt;value：剩余的库存数值&lt;br/&gt;&lt;br/&gt;流水（&lt;span&gt;hash&lt;/span&gt;结构）：&lt;br/&gt;key：inventory_flow_{sku_id}&lt;br/&gt;&lt;span&gt;hash&lt;/span&gt;—key：订单明细id（不同业务场景的全局性id，用来做幂等控制）&lt;br/&gt;&lt;span&gt;hash&lt;/span&gt;—value：本次购买的数量&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于购物车下单，多个sku批量扣减，我们需要按单个sku循环发起Redis调用。但是多个Redis命令无法保证原子性。我们可以采用&lt;code&gt;lua脚本&lt;/code&gt;形式，将这些命令打包到一个脚本中，作为一个命令发送给Redis执行，从而保证了原子性。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;lua 是一个类似 JavaScript、Shell 等的解释性语言，它可以完成 Redis 已有命令不支持的功能。用户在编写完 lua 脚本之后，将此脚本上传至 Redis 服务端，服务端会返回一个标识码代表此脚本。在实际执行具体请求时，将数据和此标识码发送至 Redis 即可。Redis 会和执行普通命令一样，采用单线程执行此 lua 脚本和对应数据。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Lua 脚本执行流程：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;批量扣减是对单个扣减的循环调用，所以这里介绍的流程只讲单次扣减的处理步骤。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先根据&lt;code&gt;订单明细id&lt;/code&gt;查询扣减流水，是否已经操作过，做幂等性校验&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后查询sku的剩余库存，并根据&lt;code&gt;下单购买数&lt;/code&gt;做校验，只要有一个sku 数量不足，则返回失败&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修改所有sku的缓存中的剩余库存数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缓存中插入扣减流水记录&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当Redis扣减成功后，应用程序再将此次扣减&lt;code&gt;异步化&lt;/code&gt;保存到数据库中，持久化存储，毕竟Redis只是临时性存储，有宕机风险，会丢失数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缓存方案利弊分析：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Redis&lt;/code&gt;缓存方案，借助了缓存的&lt;code&gt;高性能&lt;/code&gt;，承载更高的并发。但是没有数据库的&lt;code&gt;ACID&lt;/code&gt;特性，极端情况下，可能出现&lt;code&gt;少卖&lt;/code&gt;情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为了避免&lt;code&gt;少卖&lt;/code&gt;情况发生，&lt;code&gt;纯缓存方案&lt;/code&gt;需要做大量的对账、异常处理的设计，系统复杂度增加很多。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;纯缓存方案&lt;/code&gt;适合一些高并发、大流量场景，但对数据准确度要求不是特别苛刻的业务场景。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;风险：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述&lt;code&gt;Lua脚本&lt;/code&gt;把多条命令打包在一起，虽然保证了原子性，但不具备&lt;code&gt;事务回滚&lt;/code&gt;特性。比如，库存扣减成功了，此时&lt;code&gt;Redis宕机&lt;/code&gt;，扣减流水并没有插入成功，应用程序认为本次&lt;code&gt;Redis调用&lt;/code&gt;是&lt;code&gt;失败&lt;/code&gt;的，前台给用户反馈错误提示，但是已经扣减的数量不会回滚。当Redis故障修复后，再次启动，此时恢复的数据已经存在不一致了。需要结合&lt;code&gt;Redis&lt;/code&gt;和&lt;code&gt;数据库&lt;/code&gt;做数据核对check，并结合扣减服务的日志，做数据的增量修复。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;🌴 基于分库分表的扣减方案&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面提到的数据库方式是基于&lt;code&gt;单库单表&lt;/code&gt;玩法，虽然借助&lt;code&gt;ACID&lt;/code&gt;特性能保证数据的一致性，但是单台mysql的并发能力有限，如何提升性能？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了&lt;code&gt;纯缓存&lt;/code&gt;化方案外，我们还可以考虑将&lt;code&gt;库存表&lt;/code&gt;进行&lt;code&gt;水平拆分&lt;/code&gt;，分摊洪峰压力。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7298850574712644&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3Ohm6WHibeXKSo8vYe9AHPO3t2uiaGuvWbeDDmJZ0q7jdJmYhzZpPqrvXaoOmv7cW0BLvqTQLz5WvdL0Sl86iaktQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1044&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如库存表的QPS要求是1.6万，经过拆分成16张表后，如果数据分布均匀，每个物理表预计处理 1000 QPS，完全处于mysql单实例的承载范围之内。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外拆分后，单表的数据量也会相应减少很多，假如分表前有一个亿数据，分表后每张表不到1千万，索引查询性能也会快很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;同一次扣减业务，库存扣减和插入流水要放在同一个分库中，通过事务保证一致性，满足同时成功或同时失败。如果数据分布和业务请求足够均匀，理论上经过分库分表设计后，整个系统的吞吐量将会是线性的增长，主要取决于分表实例的数量。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;🌴 其他扣减方案&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有其他的一些解决方案，这里只是提供一些思路，方案细节就不展开了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、如果某个sku_id的库存扣减过热，单台实例支撑不了（&lt;strong&gt;mysql官方测评：一般单行更新的QPS在500以内&lt;/strong&gt;），可以考虑将一个sku的大库存拆分成N份，放在不同的库中（也就是说所有子库的库存数总和才是一件sku的真实库存），由于前台的访问流量非常大，按照&lt;code&gt;均分原则&lt;/code&gt;，每个子库分到的流量应该差不多。上层路由时只需要在&lt;code&gt;sku_id&lt;/code&gt;后面拼接&lt;code&gt;一个范围内的随机数&lt;/code&gt;，即可找到对应的子库，有效减轻系统压力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、单条sku库存记录更新过热，也可以采用批量提交方式，将多次扣减累计计数，集中成一次扣减，&lt;strong&gt;从而实现了将串行处理变成了批处理&lt;/strong&gt;，也可以大大减轻数据库压力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、引入&lt;code&gt;RocketMQ&lt;/code&gt;消息队列，经过前置校验后，如果有剩余库存，则把创建订单的操作封装成消息发送给MQ，订单系统从RocketMQ中以特定的频率消费，创建订单，该方案有一定的延迟性。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;关于我：计算机专业出&lt;/span&gt;&lt;span&gt;身，前阿里架构师，出&lt;/span&gt;&lt;span&gt;过专利，竞赛拿过奖，CSDN博客专家，&lt;/span&gt;&lt;span&gt;负责过电商交易、社区、营销、金融等业务，&lt;/span&gt;&lt;span&gt;多年团队管理经验，爱思考，喜欢结交朋友&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;欢迎大家扫描 &lt;/span&gt;&lt;span&gt;↓↓↓ 二维码，加个&lt;/span&gt;&lt;span&gt;微&lt;/span&gt;&lt;span&gt;信好友，多多交流&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9575757575757575&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3Ohm6WHibeXK4p76DKrThTwVIln4eQGGvEDFSmuTU13NOAz4QvnmDQ4mmcZyicNWfkGmNKLF30uWWic6rTLmHiaVng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;330&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5NDAwMzM0MA==&amp;amp;mid=2247485101&amp;amp;idx=1&amp;amp;sn=40ecbfba914173c99bba7acedba6478a&amp;amp;chksm=ec68314edb1fb8581b3389a8e47407cccf44b958f9411d1d2e7ca9610e6e2bba2ac0aebfe4b0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;淘宝双11千亿交易额的系统架构演变&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5NDAwMzM0MA==&amp;amp;mid=2247484438&amp;amp;idx=1&amp;amp;sn=686afd68b34579d0c38b7de67ce2b64b&amp;amp;chksm=ec6833f5db1fbae3897f2261e270e745182996f95b2fe7c3d4d57e2000607e6bf2c6ead2b446&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;淘宝订单自动确认收货的N种实现，秒杀面试官&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5NDAwMzM0MA==&amp;amp;mid=2247484307&amp;amp;idx=1&amp;amp;sn=37351d4934ee92c05f6f1beb76462cf4&amp;amp;chksm=ec683470db1fbd6625e46acc6d1e6813b072c8358dc1d7a98cc6bedd7636a182c2b09d0e8ef8&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;如何设计一个高性能的秒杀系统&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;码字不易，请不要白嫖。如果对您的工作有帮助，请转发分享，点个 “赞”&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d5cace4954fc1f382548870c234e388b</guid>
<title>Redis 破障之路（三）：Redis 单线程架构</title>
<link>https://toutiao.io/k/mx661vn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODE5ODM0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeFt08hV3N1706WTzfhoTNoXm5LXRV0XibppmeNR4zSNMa3QOJJ7ib4O21P5yohibwuD26Tp9ETWZAqA/0?wx_fmt=png&quot; data-nickname=&quot;三分恶&quot; data-alias=&quot;Fighter3FullStack&quot; data-signature=&quot;一个全栈开发。分享Java后端、Web前端、计算机基础知识。&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，Redis是一个单线程架构的NoSQL数据库，但是是单线程模型的Redis为什么性能如此之高?这就是我们接下来要探究学习的内容。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、Redis的单线程架构&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.1、Redis单线程简介&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先要明白，&lt;code&gt;Redis的单线程指的是执行命令时的单线程&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis客户端与服务端的模型可以简化成下图，每次客户端调用都经历了发送命令、执行命令、返回结果三个过程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.37181663837011886&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWclHjFzib2lr6leR5lSQKrNyu8cswG80gEdPm8IYibIP5icV7LfGwUniaL0ticdnSEyPuVmTudMaf8RKuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;589&quot;/&gt;&lt;figcaption&gt;Redis客户端请求与服务端响应&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们说的单线程就是在第二步&lt;code&gt;执行命令&lt;/code&gt;，一条命令从从客户端达到服务端不会立刻被执行，而是会进入一个队列中等待，每次只会有一条指令被选中执行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.44285714285714284&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWclHjFzib2lr6leR5lSQKrNyOyRvbwe2mWrsRAU2trUbVWM98NZndX6TWYeE2XA64QibqviaWy7uJklw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;630&quot;/&gt;&lt;figcaption&gt;Redis单线程执行命令&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发送命令、返回结果、命令排队这些就不是那么简单了，例如Redis使用了I/O多路复用技术来解决I/O的问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.2、Redis为什么要使用单线程&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是官方的解释：https://redis.io/topics/faq&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3741648106904232&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWclHjFzib2lr6leR5lSQKrNyDibu4pVOibDmCepribtj5YlhWdE5EH6ZIQL7HSEubYbZBRm5icdLgGxqug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;898&quot;/&gt;&lt;figcaption&gt;Redis单线程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方FAQ表示，因为Redis是基于内存的操作，CPU成为Redis的瓶颈的情况很少见，Redis的瓶颈最有可能是内存的大小或者网络限制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想要最大程度利用CPU，可以在一台机器上启动多个Redis实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得一提的，网络上存在这样的观点：吐槽官方的解释有些敷衍，其实就是历史原因，开发者嫌多线程麻烦，后来这个CPU的利用问题就被抛给了使用者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时FAQ里还提到了， Redis 4.0 之后开始变成多线程，除了主线程外，它也有后台线程在处理一些较为缓慢的操作，例如清理脏数据、无用连接的释放、大 Key 的删除等等。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.3、为什么单线程还能这么快&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常来讲，单线程处理能力要比多线程差，那么为什么Redis使用单线程模型会达到每秒万级别的处理能力呢？可以将其归结为三点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;第一：&lt;/strong&gt;纯内存访问，Redis将所有数据放在内存中，内存的响应时长大约为100纳秒，这是Redis达到每秒万级别访问的最重要的基础。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;第二：&lt;/strong&gt;非阻塞I/O，Redis使用epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5948827292110874&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWclHjFzib2lr6leR5lSQKrNyEaqmIJic3EqFYaUVQP4j202vHqJJ9hScLBFtTyKgp3qE1fptdoINobw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;469&quot;/&gt;&lt;figcaption&gt;Redis使用IO多路复用和自身事件模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「这里再扩展一下I/O多路复用：」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引用知乎上一个高赞的回答来解释什么是I/O多路复用。假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;第一种选择：按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡主，全班都会被耽误。这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;第二种选择：你创建30个分身，每个分身检查一个学生的答案是否正确。这种类似于为每一个用户创建一个进程或者线程处理连接。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一种就是阻塞IO模型，第三种就是I/O复用模型，Linux下的select、poll和epoll就是干这个的。将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的socket应该采用&lt;code&gt;非阻塞模式&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是&lt;code&gt;事件驱动&lt;/code&gt;，所谓的reactor模式。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.4407894736842106&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWclHjFzib2lr6leR5lSQKrNyxj8bpteOsAVw4soiad8qibHKZbic8hunTKeLCC7wUNFddkA5UIgZBbAAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;760&quot;/&gt;&lt;figcaption&gt;多路复用模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们继续来看Redis单线程却很快的最后一条原因，在多线程开发中，存在线程的切换和竞争，这样一来，是有时间的消耗的。对于需要磁盘I/O的程序来讲，磁盘I/O是一个比较耗时的操作，所以对于需要进行磁盘I/O的程序，我们可以使用多线程，在某个线程进行I/O时，CPU切换到当前程序的其他线程执行，以此减少CPU的等待时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了。Redis的数据存放在内存中，将内存中的数据读入CPU时，CPU不是依然需要等待吗，为什么不能在等待数据从内存读入CPU期间执行其他线程，以此提高CPU的使用率呢？这个问题的答案很简单，内存的读些速度虽然比CPU慢很多，但是也是非常快的。CPU切换线程需要花费一定的时间，而多次切换线程所花费的时间，可能比直接使用单线程执行相同的任务，花费的时间要更多，这是非常不划算的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;单线程也会有一个问题&lt;/code&gt;：对于每个命令的执行时间是有要求的。如果某个命令执行过长，会造成其他命令的阻塞，对于Redis这种高性能的服务来说是致命的，所以Redis是面向快速执行场景的数据库。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、支持多线程的Redis6.0&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;“Redis不是单线程吗？怎么又支持多线程了？”&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信学到了这里，这已经不是一个问题了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis6.0引入了多线程的特性，这个多线程是在哪里呢？——&lt;strong&gt;「是对处理网络请求过程采用了多线程」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 6.0采用多个IO线程来处理网络请求，网络请求的解析可以由其他线程完成，然后把解析后的请求交由主线程进行实际的内存读写。提升网络请求处理的并行度，进而提升整体性能。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5191666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWclHjFzib2lr6leR5lSQKrNyQ0OCibeoZSa4QuvADNbeXQw1fOiaWRGNKy9PpAmQyI1fN8iasicSMnK0qg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么多并发的线程安全问题存在吗？——当然不存在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「Redis 的多 IO 线程只是用来处理网络请求的，对于命令的执行，Redis 仍然使用单线程来处理。」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「参考：」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;【1】：《Redis开发与运维》&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;【2】：[支持多线程的Redis6.0来了](https://www.cnblogs.com/mr-wuxiansheng/p/12884356.html)&lt;br/&gt;&lt;br/&gt;【3】：[为什么 Redis 选择单线程模型](https://draveness.me/whys-the-design-redis-single-thread/)&lt;br/&gt;&lt;br/&gt;【4】：[Redis 和 I/O 多路复用](https://draveness.me/redis-io-multiplexing/)&lt;br/&gt;&lt;br/&gt;【5】：[I/O多路复用技术（multiplexing）是什么？](https://www.zhihu.com/question/28594409)&lt;br/&gt;&lt;br/&gt;【6】：[一文搞懂I/O多路复用及其技术](https://www.cnblogs.com/yrxing/p/14143644.html)&lt;br/&gt;&lt;br/&gt;【7】:[Redis为什么是单线程的](https://www.debugger.wiki/article/html/1588496434080602)&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;系列目录：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247485766&amp;amp;idx=1&amp;amp;sn=1bafe8a665d4fdc73c0597b7ec92f0e0&amp;amp;chksm=c0cce1e3f7bb68f57c1cc0ce33e1e1bcc96b16a70b9b6c9b37fa90359507d443421f7ba6da26&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;【Redis破障之路】一：强大的Redis&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247485872&amp;amp;idx=1&amp;amp;sn=75c3ea75cacaf8c32f9d571d04c2c6aa&amp;amp;chksm=c0cce115f7bb6803b04156d0545b163a98e94621182e2183ce45c18c70b3389465b7194ec5e8&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;【Redis破障之路】二：Redis安装和基本数据结构&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODE5ODM0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeFt08hV3N1706WTzfhoTNoXm5LXRV0XibppmeNR4zSNMa3QOJJ7ib4O21P5yohibwuD26Tp9ETWZAqA/0?wx_fmt=png&quot; data-nickname=&quot;三分恶&quot; data-alias=&quot;Fighter3FullStack&quot; data-signature=&quot;一个全栈开发。分享Java后端、Web前端、计算机基础知识。&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;204&quot; data-backw=&quot;558&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBLml8yqRnW8SzBIzu9h5RZaLdMfqqUt3mXMbX3bO0nu0FyfqotEfYm56F1xTqoqsmrQn3icGJ6Dw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>97d6f250407e77f210e330590abb10ed</guid>
<title>系统高可用之健康检查和健康度量那些事</title>
<link>https://toutiao.io/k/9qrsvdn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;vivo互联网技术&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;微信号&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;vivoVMIC&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;功能介绍&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>399ccfb4835ec57abdb2f752130aff25</guid>
<title>如何更好使用多线程</title>
<link>https://toutiao.io/k/my7c6ad</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;        说到线程相信很多开发人员都会认为只要使用了多线程技术服务性能就会提高很多，但涉及过渡使用问题就很少人去了解。在使用上更多是了解是创建，使用，销毁或使用线程池之类的。但这些资料更多是如何使用线程，但对于应用怎样针对性规划线程让应用发挥出更好的性能则很难有更详细的资料来讲述。&lt;/p&gt;&lt;p&gt;        在硬件层面相信大家应该知道一个CPU核心只能运行一个线程，对于一个8逻辑核心的CPU同时工作线程是8个。但在软件服务应用中很多时候进程都开启远超过CPU核心数工作线程，这主要原因是在应用中往往涉及到IO这样低效率工作，为了确保CPU可以更好地继续其他的工作，系统会把等待IO完成线程加入到调度环节等待，然后由其它需要的任务线程补上。所以为了满足服务应用需要系统的逻辑线程远高于工作线程数。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;线程工作饱和度&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;        线程工作饱和度相信很少人去了解它，只知道多线程可以更多地使用CPU资源，达到一个更高效的处理。在进程中线程有创建时间和CPU工作时间，不同的代码对线程使用的CPU时间也有所不同； 在服务应用中最常见的代码可以划分两种：一种是高速的内存运算，别一种则是IO操作(数据库，文件或其他网络服务等)。两种代码引起线程的工作饱和度都有着很大的差别，接下来通过简单的代码来看一下不同代码引起的线程工作量问题。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Memory&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.Threading.Interlocked.Increment(&lt;span class=&quot;code-snippet__keyword&quot;&gt;ref&lt;/span&gt; mCount);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;以上是一个简单内存累加方法，由于没有IO操作所以类似于CPU自悬状态，这一操作会一个占用比较多的CPU资源 &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08084163898117387&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7WiafGUNVvx4u0GkDyficBJbXLECS8hpHNeIgwEaaJ5ibXI9fRIaoaRRgeQIOyaLHJ8o7YymqkwPol81ibVGjHCleg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;903&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;IO&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Console.WriteLine(mCount);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.Threading.Interlocked.Increment(&lt;span class=&quot;code-snippet__keyword&quot;&gt;ref&lt;/span&gt; mCount);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;同样一个代码增加了一个控制台输出，由于Console存在输出IO操作这类操作比内存操作要慢，所以该操作会占用比较少的CPU&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.03229398663697105&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7WiafGUNVvx4u0GkDyficBJbXLECS8hpHN5Fuw2fkaO4EnE3ibhftP4kuCZuIhkdzcQzN01VvSAUxKibj60QjI440w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;898&quot;/&gt;&lt;/p&gt;&lt;p&gt;接下来两个代码使用4和8个线程运行情况又怎样呢？&lt;/p&gt;&lt;p&gt;Memory(4线程)&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.04776119402985075&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7WiafGUNVvx4u0GkDyficBJbXLECS8hpHNSMiaaicV74ElWkS19YFV4OZhOlibr7GxXenIBkhJ4Fsu5zibzIYSyIyicTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1005&quot;/&gt;&lt;/p&gt;&lt;p&gt;Memory(8线程)&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.027916251246261216&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7WiafGUNVvx4u0GkDyficBJbXLECS8hpHN6HiaOcjssKqjX4umGuMFOpItRmZqbM1fzPwQcDFjx5qelbbw2TEpicZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1003&quot;/&gt;&lt;/p&gt;&lt;p&gt;IO(4线程）&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.030753968253968252&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7WiafGUNVvx4u0GkDyficBJbXLECS8hpHNticM3p9WJ9XaNkqa86EuzLPzlG7EI195z8pp4AI7oF2Oy6qPjoMiaOmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1008&quot;/&gt;&lt;/p&gt;&lt;p&gt;IO(8线程）&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.029791459781529295&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7WiafGUNVvx4u0GkDyficBJbXLECS8hpHNmegBI8l5Oq7sJlRRUe2L9JaqvBKQ9ltOAkqsSicrP9TPtIRKuqibpOSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1007&quot;/&gt;&lt;/p&gt;&lt;p&gt;测试可以发现纯内存操作随着线程的增加CPU使用率也成正比增加，而涉及到IO的操作的测试中4线程已经达到的IO操作的饱和量了，在往上加线程也无法达到更高的操作。所以当在创建多线程的时候，要确保创建的线程是否过量。就拿Memory函数来说，当CPU是8逻辑核的情况，再往上压到10线程已经没有提交效率的意义了，反而增加了线程调度的损耗。同样在IO操作也是，受IO限制开启再多的线程也无法提高IO操作效率(所以这种操作一般异步配合线程池回调来更好利用线程资源)。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;规划准则&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;        从上面的测试可以反映出普遍使用线程场景的需求，当存在大量内存运算的时候总线程数尽量不要超过CPU的逻辑核数；而针对IO场景的应用规划线程数据超过IO负载能力。CPU有自己的处理想极限，不同IO也同样有处理极限；当到达相关资源极限的时候创建再多的线程意义不大，不但不能增加处理的效率，反而会引起线程过多影响性能的情况出现。在规划中要以线程最大饱和度作为规划的依据，最少线程资源最大化的目标让使用到的线程都得到最大化运行饱和度。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;高效使用多线程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;        提高性能不应该以线程多少来进行规划使用，首要目标是提升线程的工作饱和度。提高线程工作饱和度最主要方式就是线程复用，而线程池正是达到这种方式的最佳途径。但系统任务多样性，一个全局的线程池是无法达到更的分配，所以想在多线程上更用得更灵活，需要针对不同的业务场和资源来制定任务队列来控制线程的开销。&lt;/p&gt;&lt;p&gt;        以下是aspcore针对socket io封装的任务处理队列，在execute方法实现可以看到尽可以让线程处于工作状态，不要轻易回到收到全局的线程池中。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.Internal&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;internal&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;IOQueue&lt;/span&gt; : &lt;span class=&quot;code-snippet__title&quot;&gt;PipeScheduler&lt;/span&gt;, &lt;span class=&quot;code-snippet__title&quot;&gt;IThreadPoolWorkItem&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;readonly&lt;/span&gt; ConcurrentQueue&amp;lt;Work&amp;gt; _workItems = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ConcurrentQueue&amp;lt;Work&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; _doingWork;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Schedule&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;Action&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;object&lt;/span&gt;?&amp;gt; action, &lt;span class=&quot;code-snippet__keyword&quot;&gt;object&lt;/span&gt;? state&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            _workItems.Enqueue(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Work(action, state));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (Interlocked.CompareExchange(&lt;span class=&quot;code-snippet__keyword&quot;&gt;ref&lt;/span&gt; _doingWork, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                System.Threading.ThreadPool.UnsafeQueueUserWorkItem(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;, preferLocal: &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; IThreadPoolWorkItem.Execute()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (_workItems.TryDequeue(&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt; Work item))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    item.Callback(item.State);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                _doingWork = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                Thread.MemoryBarrier();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (_workItems.IsEmpty)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (Interlocked.Exchange(&lt;span class=&quot;code-snippet__keyword&quot;&gt;ref&lt;/span&gt; _doingWork, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;) == &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; Work&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;readonly&lt;/span&gt; Action&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;object&lt;/span&gt;?&amp;gt; Callback;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;object&lt;/span&gt;? State;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Work&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;Action&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;object&lt;/span&gt;?&amp;gt; callback, &lt;span class=&quot;code-snippet__keyword&quot;&gt;object&lt;/span&gt;? state&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                Callback = callback;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                State = state;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;以上是aspcore Kestrel模块的网络接收任务队列实现，在techempower的plaintext测试中配置了8个任务队列来完成相关操作，性能达到这项测试的最高。测试硬件资源是40线程，而aspcore Kestrel使用了8个线程来处理这一块达到最高的性能状态。&lt;/p&gt;&lt;p&gt;        同样BeetleX也实现类似的任务队列，只是为了使用方便通过队列组的方式进行定义和处理。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;DispatchCenter&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__type&quot;&gt;T&lt;/span&gt;&amp;gt; : &lt;span class=&quot;code-snippet__type&quot;&gt;IDisposable&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        List&amp;lt;SingleThreadDispatcher&amp;lt;T&amp;gt;&amp;gt; mDispatchers = new List&amp;lt;SingleThreadDispatcher&amp;lt;T&amp;gt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        long mIndex = &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; DispatchCenter(Action&amp;lt;T&amp;gt; process) : &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;(process, Math.Min(Environment.ProcessorCount, &lt;span class=&quot;code-snippet__number&quot;&gt;16&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; DispatchCenter(Action&amp;lt;T&amp;gt; process, int count)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (int i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; count; i++)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                mDispatchers.Add(new SingleThreadDispatcher&amp;lt;T&amp;gt;(process));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; void SetErrorHaneler(Action&amp;lt;T, Exception&amp;gt; handler)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (handler != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                foreach (&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; item &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; mDispatchers)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    item.ProcessError = handler;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; void Enqueue(T &lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;, int waitLength = &lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (waitLength &amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                Next().Enqueue(&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (int i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; mDispatchers.Count; i++)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; item = mDispatchers[i];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (item.Count &amp;lt; waitLength)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        item.Enqueue(&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                Next().Enqueue(&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; int Count&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                int count = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                foreach (&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; item &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; mDispatchers)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    count += item.Count;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; count;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; SingleThreadDispatcher&amp;lt;T&amp;gt; Get(&lt;span class=&quot;code-snippet__keyword&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            int id = Math.Abs(&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;.GetHashCode());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; mDispatchers[id % mDispatchers.Count];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; SingleThreadDispatcher&amp;lt;T&amp;gt; Next()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; mDispatchers[(int)(System.Threading.Interlocked.Increment(ref mIndex) % mDispatchers.Count)];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; void Dispose()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            foreach (SingleThreadDispatcher&amp;lt;T&amp;gt; item &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; mDispatchers)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                item.Dispose();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mDispatchers.Clear();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;        其实针对多线程的使用并不能简单地创建线程即可，实际应用中需要考虑代码占用的CPU资源情况和具体CPU资源做一个规则调整才能更好的发挥出更高效的作用。所以在设计应用时一般都依据不同业务定义不同的任务队列，并定义相关配置参数，确保服务应用在不同硬件环境配置出更优化的处理性能状态。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;BeetleX&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;开源跨平台通讯框架(支持TLS)&lt;br/&gt;提供高性能服务和大数据处理解决方案&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/7WiafGUNVvx5wTglothR7zH3eKkaNOEDT8s5SECkGYrwibVCulGpoXAahuVDsdWAsn5zibUCd4QkMQzfGZdqyyn0Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;https://beetlex.io&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fe50c7ffdbb2b0425b25d13791becbd2</guid>
<title>并发编程：内存模型</title>
<link>https://toutiao.io/k/7e5tpja</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h1&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI0NjA1MTU5Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/9637P74IBOELE4a67W59PvEHNfF5smZrVwsjic7qZT9wum9eZa3MqFx8MfXddXZiatAVcvQVsV45cTjQLRXQdzag/0?wx_fmt=png&quot; data-nickname=&quot;coredump&quot; data-alias=&quot;cpp-coredump&quot; data-signature=&quot;分布式、数据库、C++、算法等&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;内存模型&lt;br/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C++ 在 C++11 标准中终于引入了内存模型（Memory Model）的概念。从此，C++ 才有了跨平台（跨操作系统、跨硬件平台）的并发编程标准。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;内存模型描述了多线程通过共享内存变量进行交互的一些规定和限制。其中，最重要的一点是规定了内存顺序（Memory Ordering）。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现代编译器和 CPU 都可能对指令进行重排，并且现代 CPU 拥有多级 cache，这些都有可能导致多个线程观察到的变量修改顺序不一致。比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;初始化：&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; A = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; B = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;线程 &lt;span&gt;1&lt;/span&gt;：&lt;br/&gt;A = &lt;span&gt;42&lt;/span&gt;;&lt;br/&gt;B = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;线程 &lt;span&gt;2&lt;/span&gt;：&lt;br/&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (B == &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; A &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程 2 输出的值是多少？答案是：&lt;strong&gt;0 或 42 都有可能&lt;/strong&gt;。如何保证上面的代码一定输出 42 呢？我们可以利用原子操作和内存顺序的能力。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;原子操作和内存顺序&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原子操作（atomic operation）其实有两层含义：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;原子操作是不可分的。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;原子操作是多个线程之间的一个同步点。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一层含义很好理解，从名字就可以看出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二层含义是本文的重点。同步点的意思是，执行原子操作的时候，会对这个原子操作前后的内存操作进行一些必要的同步，从而影响这些操作在不同线程之间的可见情况。至于哪些操作会在多线程之间同步，这个由内存顺序来规定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C++ 的内存模型规定了 6 种内存顺序，每种内存顺序要求同步的操作都不一样（当然，对性能的影响也不一样），并且有些内存顺序是可以（需要）配合使用的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面介绍一下各种内存顺序的特点。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;memory_order_relaxed&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只保证操作的原子性，不影响这个同步点前后的其它内存操作。这是原子操作中最宽松的内存顺序，无法解决上述例子的同步问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;memory_order_acquire 和 memory_order_release&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Acquire 和 release 这两个往往放在相关的上下文配合使用。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;memory_order_acquire 提供 read acquire 的语意，适用于 atomic load 操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从执行 read acquire 的线程来看，read acquire 语意会阻止原子操作之后的所有读和写被重排到原子操作之前。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7261904761904762&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9637P74IBOETkMWuwxYdTibWQeIYzUrG2kJlscjibjXicJDle3EMPnZibSVbIVJuLRYHH6Xf20CXroFDbibl4HYiaPag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;84&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;A.load(&lt;span&gt;std&lt;/span&gt;::memory_order_acquire);&lt;br/&gt;B = &lt;span&gt;42&lt;/span&gt;;  &lt;span&gt;// 不可能被重排到 A.load(std::memory_order_acquire); 之前&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;memory_order_release 提供 write release 语意，适用于 atomic store 操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从执行 write release 的线程来看，write release 语意会阻止原子操作之前的所有读和写被重排到原子操作之后。&lt;img data-ratio=&quot;0.7619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9637P74IBOETkMWuwxYdTibWQeIYzUrG2dDKU5hcgyEa4aibmgTKV8gichLxGt5RUCU2zwLlYO2oO4EgfzicPR9uPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;84&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;B = &lt;span&gt;42&lt;/span&gt;; &lt;span&gt;// 不可能被乱序到 A.store(1, std::memory_order_release); 之后&lt;/span&gt;&lt;br/&gt;A.store(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;std&lt;/span&gt;::memory_order_release);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，release-acquire 是一对会相互影响的内存顺序语意。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面说了，原子操作是一个多线程的同步点。memory order 决定了在这个同步点前后的其它内存操作对其它线程的可见性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于同一个变量 B：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程 1 对进行 release store：&lt;code&gt;B.store(1, std::memory_order_release);&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程 2 对进行 acquire load：&lt;code&gt;B.load(std::memory_order_acquire);&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;则在线程 2 完成 aquire load 之后，保证线程 A 在 release store 之前的所有内存写操作都对线程 2 可见。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是前面那个例子，使用 release-acquire 语意可以保证在线程 2 观察到 B 变成 1 之后，能观察到 A 变成 42。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;线程 &lt;span&gt;1&lt;/span&gt;：&lt;br/&gt;A = &lt;span&gt;42&lt;/span&gt;;&lt;br/&gt;B.store(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;std&lt;/span&gt;::memory_order_release);&lt;br/&gt;&lt;br/&gt;线程 &lt;span&gt;2&lt;/span&gt;：&lt;br/&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (B.load(&lt;span&gt;std&lt;/span&gt;::memory_order_acquire) == &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; A &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;  &lt;span&gt;// always output 42&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;memory_order_consume&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样作用于 atomic load 操作，memory_order_consume 是一种比 memory_order_acquire 弱一些的语意。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从执行 read consume 的线程来看，read consume 语意会阻止原子操作之后&lt;strong&gt;有依赖关系&lt;/strong&gt;的读写操作被重排到原子操作之前。（Read acquire 是阻止原子操作之后&lt;strong&gt;所有&lt;/strong&gt;的读写操作被重排到原子操作之前。）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据 cppreference 的文档说明：不鼓励使用 memory_order_consume 这个内存顺序。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;The specification of release-consume ordering is being revised, and the use of memory_order_consume is temporarily discouraged.(since C++17)&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;memory_order_acq_rel&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对一个 load-modify-store 的原子操作施加 read acquire 和 write release 的内存顺序限制。比如 &lt;code&gt;A.fetch_add(1, std::memory_order_acq_rel)&lt;/code&gt;。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;memory_order_seq_cst&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;memory_order_seq_cst 是最严格的内存顺序：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对于 atomic load，它会执行 acquire 语意。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于 atomic store，它会执行 release 语意。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于 load-modify-store，它会执行 acquire-release 语意。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;除此之外，它还保证，所有线程观察到的所有原子变量的修改顺序是一致的。&lt;/strong&gt; 举个例子：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;std&lt;/span&gt;::atomic&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; x{&lt;span&gt;0&lt;/span&gt;};&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::atomic&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; y{&lt;span&gt;0&lt;/span&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 线程 1&lt;/span&gt;&lt;br/&gt;x.store(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;std&lt;/span&gt;::memory_order_release);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 线程 2&lt;/span&gt;&lt;br/&gt;y.store(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;std&lt;/span&gt;::memory_order_release);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 线程 3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; a = x.load(&lt;span&gt;std&lt;/span&gt;::memory_order_acquire);&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; b = y.load(&lt;span&gt;std&lt;/span&gt;::memory_order_acquire);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 线程 4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; c = y.load(&lt;span&gt;std&lt;/span&gt;::memory_order_acquire);&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; d = x.load(&lt;span&gt;std&lt;/span&gt;::memory_order_acuqire);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面这个例子中，x 和 y 其实是完全无关的。所以完全可能出现：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程 3 观察到：a == 1 且 b == 0。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程 4 观察到：c == 1 且 d == 0。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果将所有的 memory order 改成 memory_order_seq_cst：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果线程 3 看到的是 a == 1 且 b == 0 =&amp;gt; 这意味着 x.store(1, ...) 发生在 y.store(1, ...) 之前。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;那么线程 4 就不可能看到 c == 1 且 d == 0 的情况了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小结&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存模型、内存顺序、原子操作这些都是 lock-free 并发编程的基础知识。最开始学习这几个概念的时候，感觉头都要秃了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Intel 的处理器的内存顺序比较严格，一般情况下，不会重排指令。一些并发的坑，只有在内存顺序比较宽松的处理器上（比如 ARM）才能测试出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;身边没有 ARM 的 Linux 机器，所以本文的例子都没有做过实验。（本来想在 iPhone 上试试看，但是没搞过客户端的环境，折腾过一次，太麻烦，放弃了。。）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于这几个内存顺序的使用原则：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果确定只需要保证操作是原子的，请使用 memory_order_relaxed。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果不知道该用什么内存顺序，请使用 memory_order_seq_cst。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果你知道 acquire-release 是什么意思，请使用 memory_order_acquire 和 memory_order_release。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后，不建议使用 memory_order_consume。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;参考文档&lt;/h1&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;原子操作 vs 非原子操作 - https://preshing.com/20130618/atomic-vs-non-atomic-operations/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;编译器指令重排 - http://preshing.com/20120625/memory-ordering-at-compile-time&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CPU 指令重排 - http://preshing.com/20120710/memory-barriers-are-like-source-control-operations&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cppreference: memory order - https://en.cppreference.com/w/cpp/atomic/memory_order)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Acquire and Release Semantics - https://preshing.com/20120913/acquire-and-release-semantics/&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>