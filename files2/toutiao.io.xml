<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>867ec2981b98efd8c8f445ddff87dabd</guid>
<title>第 062 期「码农周刊 VIP 会员专属邮件周报」今晚发送，请查收！</title>
<link>https://toutiao.io/k/s01gzxl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a6166e508ae15e06b7507458494158d7</guid>
<title>恐惧和自我偏见：成长的最大障碍</title>
<link>https://toutiao.io/k/45ae6zg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote data-type=&quot;blockquote&quot;&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;em data-type=&quot;italic&quot;&gt;我们每个人都有一些害怕的事情，成长就是克服恐惧，做到原来不敢做的事情。如果自己都不相信自己能做到，还有谁会相信我们呢？只有克服内心的恐惧和自我偏见，才能收获成长。原文链接：[&lt;/em&gt;Fears and Limiting Beliefs](https://www.patreon.com/posts/20851818)&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;通常来说，我们每个人在生活中都或多或少面临懒惰、拖延症以及缺乏决心的困扰，本质上这都是我们内心中的恐惧和自我偏见的反映，大概率我们并不真的懒惰&lt;span data-type=&quot;sup&quot;&gt;[1]&lt;/span&gt;。&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;实现梦想的最大障碍并不是懒惰、意志力不足或没有时间，最大的障碍是我们内心的恐惧和自我偏见。&lt;/p&gt;&lt;h5 data-id=&quot;heading0&quot; data-type=&quot;heading&quot; top=&quot;424&quot;&gt;信念 Beliefs&lt;/h5&gt;&lt;p data-type=&quot;paragraph&quot;&gt;我们的信念似乎会影响很多事情：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-type=&quot;paragraph&quot;&gt;信念影响动机&lt;span data-type=&quot;sup&quot;&gt;[2]&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-type=&quot;paragraph&quot;&gt;信念影响压力&lt;span data-type=&quot;sup&quot;&gt;[3]&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-type=&quot;paragraph&quot;&gt;信念影响我们的自控能力&lt;span data-type=&quot;sup&quot;&gt;[4]&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-type=&quot;paragraph&quot;&gt;信念影响我们学习、改变的潜力&lt;span data-type=&quot;sup&quot;&gt;[5]&lt;/span&gt;（成长心态）。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;自我限制信念（self-limiting belief）&lt;span data-type=&quot;sup&quot;&gt;[6]&lt;/span&gt;是指那些你自认为是正确的、但却限制了你进步的信念。它可以表现为消极的自我暗示或对世界的悲观看法。例如：“我赚不到更多钱了，因为这已经是我们行业的玻璃天花板”，“像我这样的人不可能成为企业家”，“别人总是说我数学不好，所以我是一个糟糕的程序员”。&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;大多数信念都是我们自认为的事实，然而并没有得到任何积极的验证。&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;好消息是，信念是可以改变的。马丁·塞格利曼在《活出最乐观的自己》(Learned Optimism)&lt;span data-type=&quot;sup&quot;&gt;[7]&lt;/span&gt;中很好的解释了如何通过重塑信念来改变生活态度。还有一本书叫《伯恩斯新情绪疗法》(Feeling Good: The New Mood Therapy)&lt;span data-type=&quot;sup&quot;&gt;[8]&lt;/span&gt;，是开始了解认知行为疗法&lt;span data-type=&quot;sup&quot;&gt;[9]&lt;/span&gt;的最好的入门书籍。&lt;/p&gt;&lt;h5 data-id=&quot;heading1&quot; data-type=&quot;heading&quot; top=&quot;936&quot;&gt;恐惧 Fears&lt;/h5&gt;&lt;p data-type=&quot;paragraph&quot;&gt;内心的恐惧也会产生类似的效果：阻止我们做自己想做的事情。恐惧的问题在于它们会撒谎、会逃避。&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;恐惧是非常微妙的，它会导致一些看似无关的行为——你会沉迷于追剧，而不是写一篇思考了一整天的文章。为什么会这样？因为你害怕这篇文章不够完美，人们会不喜欢。这篇文章还不够好，甚至文章还没有写出来，但已经不够好了！&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;我们的大脑在估计可能性和概率的时候表现非常糟糕，尤其是当事情可能出错的时候。&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;恐惧让我们厌恶风险，让我们错过完全可以把握的机会。&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;解决恐惧问题不仅能帮助我们自己，还能帮助到我们的团队&lt;span data-type=&quot;sup&quot;&gt;[10]&lt;/span&gt;。&lt;/p&gt;&lt;h5 data-id=&quot;heading2&quot; data-type=&quot;heading&quot; top=&quot;1298&quot;&gt;我们能做什么？&lt;/h5&gt;&lt;p data-type=&quot;paragraph&quot;&gt;首先，有一个很重要但颇有争议的观点：不要只相信真实的东西，而要相信有用的东西，甚至迷信也有帮助&lt;span data-type=&quot;sup&quot;&gt;[11]&lt;/span&gt;。&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;其次，谨慎地采取小的、不完美的步骤&lt;span data-type=&quot;sup&quot;&gt;[12]&lt;/span&gt;，而不是一下子制定一个巨大的、雄心勃勃的计划。变化不会在一瞬间发生，也不会立即看到显著的变化。事实可能恰恰相反：为改变付出的努力越多，阻力就越大&lt;span data-type=&quot;sup&quot;&gt;[13]&lt;/span&gt;。&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;最后，走出舒适区，直面我们的恐惧。例如，如果我们害怕拒绝，那就挑战一下”拒绝“，看看它是什么感觉。&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;总之，开始通过实验来验证我们的信念。&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;关于在生活中运用信念和自我认知的知识，阅读马克·曼森（Mark Manson）的&lt;em data-type=&quot;italic&quot;&gt;&lt;span data-type=&quot;strong&quot;&gt;自我认知指南&lt;/span&gt;&lt;/em&gt;&lt;span data-type=&quot;sup&quot;&gt;[14]&lt;/span&gt;是一个很好的起点。&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote data-type=&quot;blockquote&quot;&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span data-type=&quot;strong&quot;&gt;Reference:&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;[1] https://medium.com/personal-growth/youre-not-lazy-7e357516c007&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;[2] https://www.stanforddaily.com/2010/10/25/willpower-can-be-an-unlimited-resource-study-says/&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;[3] https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3374921/&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;[4] https://medicalxpress.com/news/2015-04-dont-self-control-believing.html&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;[5] https://sharpbrains.com/blog/2018/08/13/meta-analysis-finds-value-in-teaching-the-science-of-neuroplasticity-especially-for-math-achievement-among-at-risk-students/&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;[6] http://www.stevepavlina.com/blog/2012/07/dissolving-limiting-beliefs/&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;[7] https://book.douban.com/subject/4934590/&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;[8] https://book.douban.com/subject/5980113/&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;[9] http://cbtsanfrancisco.com/cbt-is-for-hackers/&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;[10] https://blog.liberationist.org/this-idea-will-get-you-fired-928d816f8f64&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;[11] http://journals.sagepub.com/doi/abs/10.1177/0956797610372631&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;[12] https://practicingruby.com/articles/low-cost-approach-to-side-projects&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;[13] https://www.goodreads.com/book/show/10645233-do-the-work&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;[14] https://markmanson.net/downloads/self-knowledge&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;封面题图来自https://unsplash.com/@jasmin_sessler&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>92f19a75952364b042e3d20774d521b5</guid>
<title>Vue 刷新页面有哪几种方式</title>
<link>https://toutiao.io/k/pha8yz4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entryContent&quot;&gt;&amp;#13;
        &lt;p&gt;在Vue项目中，刷新当前页除了 &lt;code&gt;window.reload()&lt;/code&gt;，你还能想到什么办法？而且这种办法会重新加载资源出现短暂的空白页面。体验不是很好。&lt;/p&gt;
&lt;p&gt;在某个详情页面的时候，我们经常需要通过路由中的详情 &lt;code&gt;id&lt;/code&gt; 去获取内容，当我们在不同的详情页来回切换的时候，打开的页面是同一个，只是需要通过监听路由中的参数 &lt;code&gt;id&lt;/code&gt; 的变化去重新请求详情接口。&lt;/p&gt;
&lt;p&gt;如果这个详情页只需要一个接口还好，只需要通过 &lt;code&gt;watch&lt;/code&gt; 去监听，里面做数据请求就好。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot; language-csharp&quot;&gt;watch&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&amp;#13;
    $route&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&amp;#13;
      immediate&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&amp;#13;
      &lt;span class=&quot;token function&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;to&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&amp;#13;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;to&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#x27;Detail&#x27;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&amp;#13;
          &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; id &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; to&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;id&amp;#13;
           &lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;&amp;#13;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&amp;#13;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&amp;#13;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&amp;#13;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&amp;#13;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那一旦这个页面有很多的接口，数据逻辑依赖很复杂的时候，这个时候再写一推的监听就很容易出现屎山代码。而且不好维护。&lt;/p&gt;
&lt;p&gt;此时我们最希望的是进入每个详情页都刷新页面，也就是重新加载一遍组件。怎么去维护好一个全局刷新页面的方法去更新路由组件？&lt;/p&gt;
&lt;p&gt;我们可以通过在 &lt;code&gt;App.vue&lt;/code&gt; 里定义一个 &lt;code&gt;reload&lt;/code&gt; 方法，通过&lt;code&gt;provide&lt;/code&gt; 和 &lt;code&gt;inject&lt;/code&gt; 来抛出和注入到其它页面使用。&lt;/p&gt;
&lt;p&gt;而最终的重担落在这个 &lt;code&gt;reload&lt;/code&gt; 方法身上，其实也简单，这个方法主要的做的事是控制一个变量的值来控制整个页面的路由组件移除和显示。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot; language-xml&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;template&lt;span class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&amp;#13;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div &lt;span class=&quot;token attr-name&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;app&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&amp;#13;
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;router-view &lt;span class=&quot;token attr-name&quot;&gt;v-if&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;isRouterAlive&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&amp;#13;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;span class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&amp;#13;
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;template&lt;span class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&amp;#13;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;js language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&amp;#13;
  name&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#x27;App&#x27;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&amp;#13;
  &lt;span class=&quot;token function&quot;&gt;provide&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&amp;#13;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&amp;#13;
      reload&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;reload&amp;#13;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&amp;#13;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&amp;#13;
  &lt;span class=&quot;token function&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&amp;#13;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&amp;#13;
      isRouterAlive&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&amp;#13;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&amp;#13;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&amp;#13;
  methods&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&amp;#13;
    &lt;span class=&quot;token function&quot;&gt;reload&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&amp;#13;
      &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;isRouterAlive &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&amp;#13;
      &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;$nextTick&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&amp;#13;
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;isRouterAlive &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&amp;#13;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&amp;#13;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&amp;#13;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&amp;#13;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&amp;#13;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在其它页面注入该方法直接调用即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&amp;#13;
  inject&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#x27;reload&#x27;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&amp;#13;
  &lt;span class=&quot;token function&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&amp;#13;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&amp;#13;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&amp;#13;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&amp;#13;
&amp;#13;
  methods&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&amp;#13;
    &lt;span class=&quot;token function&quot;&gt;refresh&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&amp;#13;
      &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;reload&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&amp;#13;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&amp;#13;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&amp;#13;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际项目中经常有各种曲线救国的思路可以帮我们解决很多问题。遇到问题一定要发散下思维，这个时候搞懂原理，再结合各种特性才能想到解决办法。&lt;/p&gt;
&lt;p&gt;实践告诉我们文档中的方法很正，但是并不能解决所有的问题。往往需要根据文档中的多个特性相结合找到思路。&lt;/p&gt;
    &lt;/div&gt;&amp;#13;
&amp;#13;
    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3a57e06551916ed125c83696a426cb40</guid>
<title>面试官：小松子来聊一聊内存逃逸</title>
<link>https://toutiao.io/k/lszkuxv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;欢迎大家点击上方文字「Golang梦工厂」关注公众号，设为星标，第一时间接收推送文章。&lt;/code&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;哈喽，大家好，我是&lt;code&gt;asong&lt;/code&gt;。最近无聊看了一下&lt;code&gt;Go&lt;/code&gt;语言的面试八股文，发现面试官都喜欢问内存逃逸这个话题，这个激起了我的兴趣，我对内存逃逸的了解很浅，所以找了很多文章精读了一下，在这里做一个总结，方便日后查阅、学习。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是内存逃逸&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初次看到这个话题，我是懵逼的，怎么还有内存逃逸，内存逃逸到底是干什么的？接下来我们一起来看看什么是内存逃逸。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道一般情况下程序存放在&lt;code&gt;rom&lt;/code&gt;或者&lt;code&gt;Flash&lt;/code&gt;中，运行时需要拷贝到内存中执行，内存会分别存储不同的信息，内存空间包含两个最重要的区域：堆区(Heap)和栈区(Stack)，对于我这种&lt;code&gt;C&lt;/code&gt;语言出身的人，对堆内存和栈内存的了解还是挺深的。在&lt;code&gt;C&lt;/code&gt;语言中，栈区域会专门存放函数的参数、局部变量等，栈的地址从内存高地址往低地址增长，而堆内存正好相反，堆地址从内存低地址往高地址增长，但是如果我们想在堆区域分配内存需要我们手动调用&lt;code&gt;malloc&lt;/code&gt;函数去堆区域申请内存分配，然后我使用完了还需要自己手动释放，如果没有释放就会导致内存泄漏。写过&lt;code&gt;C&lt;/code&gt;语言的朋友应该都知道&lt;code&gt;C&lt;/code&gt;语言函数是不能返回局部变量地址(特指存放于栈区的局部变量地址)，除非是局部静态变量地址，字符串常量地址、动态分配地址。其原因是一般局部变量的作用域只在函数内，其存储位置在栈区中，当程序调用完函数后，局部变量会随此函数一起被释放。其地址指向的内容不明（原先的数值可能不变，也可能改变）。而局部静态变量地址和字符串常量地址存放在数据区，动态分配地址存放在堆区，函数运行结束后只会释放栈区的内容，而不会改变数据区和堆区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在&lt;code&gt;C&lt;/code&gt;语言中我们想在一个函数中返回局部变量地址时，有三个正确的方式：返回静态局部变量地址、返回字符串常量地址，返回动态分配在堆上的地址，因为他们都不在栈区，即使释放函数，其内容也不会受影响，我们以在返回堆上内存地址为例看一段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&quot;stdio.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&quot;stdlib.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//返回动态分配的地址 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt;* &lt;span&gt;f1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;9&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; *pa = (&lt;span&gt;int&lt;/span&gt;*) &lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;8&lt;/span&gt;);&lt;br/&gt;    *pa = a;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; pa;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; *pb;&lt;br/&gt;    pb = f1();&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;after : *pb = %d\tpb = %p\n&quot;&lt;/span&gt;,*pb, pb);&lt;br/&gt;    &lt;span&gt;free&lt;/span&gt;(pb);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的例子我们知道在&lt;code&gt;C&lt;/code&gt;语言中动态内存的分配与释放完全交与程序员的手中，这样就会导致我们在写程序时如履薄冰，好处是我们可以完全掌控内存，缺点是我们一不小心就会导致内存泄漏，所以很多现代语言都有&lt;code&gt;GC&lt;/code&gt;机制，&lt;code&gt;Go&lt;/code&gt;就是一门带垃圾回收的语言，真正解放了我们程序员的双手，我们不需要在像写&lt;code&gt;C&lt;/code&gt;语言那样考虑是否能返回局部变量地址了，内存管理交与给编译器，编译器会经过逃逸分析把变量合理的分配到&quot;正确&quot;的地方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到这里，可以简单总结一下什么是内存逃逸了：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在一段程序中，每一个函数都会有自己的内存区域存放自己的局部变量、返回地址等，这些内存会由编译器在栈中进行分配，每一个函数都会分配一个栈桢，在函数运行结束后进行销毁，但是有些变量我们想在函数运行结束后仍然使用它，那么就需要把这个变量在堆上分配，这种从&quot;栈&quot;上逃逸到&quot;堆&quot;上的现象就成为内存逃逸。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是逃逸分析&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面我们知道了什么是内存逃逸，下面我们就来看一看什么是逃逸分析？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文我们说到&lt;code&gt;C&lt;/code&gt;语言使用&lt;code&gt;malloc&lt;/code&gt;在堆上动态分配内存后，还需要手动调用&lt;code&gt;free&lt;/code&gt;释放内存，如果不释放就会造成内存泄漏的风险。在&lt;code&gt;Go&lt;/code&gt;语言中堆内存的分配与释放完全不需要我们去管了，&lt;code&gt;Go&lt;/code&gt;语言引入了&lt;code&gt;GC&lt;/code&gt;机制，&lt;code&gt;GC&lt;/code&gt;机制会对位于堆上的对象进行自动管理，当某个对象不可达时(即没有其对象引用它时)，他将会被回收并被重用。虽然引入&lt;code&gt;GC&lt;/code&gt;可以让开发人员降低对内存管理的心智负担，但是&lt;code&gt;GC&lt;/code&gt;也会给程序带来性能损耗，当堆内存中有大量待扫描的堆内存对象时，将会给&lt;code&gt;GC&lt;/code&gt;带来过大的压力，虽然&lt;code&gt;Go&lt;/code&gt;语言使用的是标记清除算法，并且在此基础上使用了三色标记法和写屏障技术，提高了效率，但是如果我们的程序仍在堆上分配了大量内存，依赖会对&lt;code&gt;GC&lt;/code&gt;造成不可忽视的压力。因此为了减少&lt;code&gt;GC&lt;/code&gt;造成的压力，&lt;code&gt;Go&lt;/code&gt;语言引入了逃逸分析，也就是想法设法尽量减少在堆上的内存分配，可以在栈中分配的变量尽量留在栈中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小结逃逸分析：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;逃逸分析就是指程序在编译阶段根据代码中的数据流，对代码中哪些变量需要在栈中分配，哪些变量需要在堆上分配进行静态分析的方法。堆和栈相比，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。栈内存分配则会非常快。栈分配内存只需要两个CPU指令：“PUSH”和“RELEASE”，分配和释放；而堆分配内存首先需要去找到一块大小合适的内存块，之后要通过垃圾回收才能释放。所以逃逸分析更做到更好内存分配，提高程序的运行速度。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;Go&lt;/code&gt;语言中的逃逸分析&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Go&lt;/code&gt;语言的逃逸分析总共实现了两个版本：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;粗略看了一下逃逸分析的代码，大概有&lt;code&gt;1500+&lt;/code&gt;行（go1.15.7）。代码我倒是没仔细看，注释我倒是仔细看了一遍，注释写的还是很详细的，代码路径：src/cmd/compile/internal/gc/escape.go，大家可以自己看一遍注释，其逃逸分析原理如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;pointers to stack objects cannot be stored in the heap&lt;/code&gt;：指向栈对象的指针不能存储在堆中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;pointers to a stack object cannot outlive that object&lt;/code&gt;：指向栈对象的指针不能超过该对象的存活期，也就说指针不能在栈对象被销毁后依旧存活。（例子：声明的函数返回并销毁了对象的栈帧，或者它在循环迭代中被重复用于逻辑上不同的变量）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们大概知道它的分析准则是什么就好了，具体逃逸分析是怎么做的，感兴趣的同学可以根据源码自行研究。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然逃逸分析是在编译阶段进行的，那我们就可以通过&lt;code&gt;go build -gcflags &#x27;-m -m -l&#x27;&lt;/code&gt;命令查看到逃逸分析的结果，我们之前在分析内联优化时使用的&lt;code&gt;-gcflags &#x27;-m -m&#x27;&lt;/code&gt;，能看到所有的编译器优化，这里使用&lt;code&gt;-l&lt;/code&gt;禁用掉内联优化，只关注逃逸优化就好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们也知道了逃逸分析，接下来我们就看几个逃逸分析的例子。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;几个逃逸分析的例子&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 函数返回局部指针变量&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Add&lt;/span&gt;&lt;span&gt;(x,y &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; *&lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; res := &lt;span&gt;0&lt;/span&gt;&lt;br/&gt; res = x + y&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &amp;amp;res&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; Add(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看逃逸分析结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; build -gcflags=&lt;span&gt;&quot;-m -m -l&quot;&lt;/span&gt; ./test1.&lt;span&gt;go&lt;/span&gt;&lt;br/&gt;# command-line-arguments&lt;br/&gt;./test1.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;6&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;: &amp;amp;res escapes to heap&lt;br/&gt;./test1.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;6&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:         from ~r2 (&lt;span&gt;return&lt;/span&gt;) at ./test1.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;6&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;./test1.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;: moved to heap: res&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析结果很明了，函数返回的局部变量是一个指针变量，当函数&lt;code&gt;Add&lt;/code&gt;执行结束后，对应的栈桢就会被销毁，但是引用已经返回到函数之外，如果我们在外部解引用地址，就会导致程序访问非法内存，就像上面的&lt;code&gt;C&lt;/code&gt;语言的例子一样，所以编译器经过逃逸分析后将其在堆上分配内存。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. interface类型逃逸&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看一个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; str := &lt;span&gt;&quot;asong太帅了吧&quot;&lt;/span&gt;&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;%v&quot;&lt;/span&gt;,str)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看逃逸分析结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; build -gcflags=&lt;span&gt;&quot;-m -m -l&quot;&lt;/span&gt; ./test2.&lt;span&gt;go&lt;/span&gt; &lt;br/&gt;# command-line-arguments&lt;br/&gt;./test2.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;: str escapes to heap&lt;br/&gt;./test2.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;:        from ... argument (arg to ...) at ./test2.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;&lt;br/&gt;./test2.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;:        from *(... argument) (indirection) at ./test2.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;&lt;br/&gt;./test2.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;:        from ... argument (passed to call[argument content escapes]) at ./test2.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;&lt;br/&gt;./test2.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;: main ... argument does not escape&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;str&lt;/code&gt;是&lt;code&gt;main&lt;/code&gt;函数中的一个局部变量，传递给&lt;code&gt;fmt.Println()&lt;/code&gt;函数后发生了逃逸，这是因为&lt;code&gt;fmt.Println()&lt;/code&gt;函数的入参是一个&lt;code&gt;interface{}&lt;/code&gt;类型，如果函数参数为&lt;code&gt;interface{}&lt;/code&gt;，那么在编译期间就很难确定其参数的具体类型，也会发送逃逸。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;观察这个分析结果，我们可以看到没有&lt;code&gt;moved to heap: str&lt;/code&gt;，这也就是说明&lt;code&gt;str&lt;/code&gt;变量并没有在堆上进行分配，只是它存储的值逃逸到堆上了，也就说任何被&lt;code&gt;str&lt;/code&gt;引用的对象必须分配在堆上。如果我们把代码改成这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; str := &lt;span&gt;&quot;asong太帅了吧&quot;&lt;/span&gt;&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;%p&quot;&lt;/span&gt;,&amp;amp;str)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看逃逸分析结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; build -gcflags=&lt;span&gt;&quot;-m -m -l&quot;&lt;/span&gt; ./test2.&lt;span&gt;go&lt;/span&gt;&lt;br/&gt;# command-line-arguments&lt;br/&gt;./test2.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: &amp;amp;str escapes to heap&lt;br/&gt;./test2.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;:        from ... argument (arg to ...) at ./test2.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;12&lt;/span&gt;&lt;br/&gt;./test2.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;:        from *(... argument) (indirection) at ./test2.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;12&lt;/span&gt;&lt;br/&gt;./test2.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;:        from ... argument (passed to call[argument content escapes]) at ./test2.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;12&lt;/span&gt;&lt;br/&gt;./test2.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: &amp;amp;str escapes to heap&lt;br/&gt;./test2.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;:        from &amp;amp;str (&lt;span&gt;interface&lt;/span&gt;-converted) at ./test2.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;&lt;br/&gt;./test2.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;:        from ... argument (arg to ...) at ./test2.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;12&lt;/span&gt;&lt;br/&gt;./test2.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;:        from *(... argument) (indirection) at ./test2.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;12&lt;/span&gt;&lt;br/&gt;./test2.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;:        from ... argument (passed to call[argument content escapes]) at ./test2.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;12&lt;/span&gt;&lt;br/&gt;./test2.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;8&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;: moved to heap: str&lt;br/&gt;./test2.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;12&lt;/span&gt;: main ... argument does not escape&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这回&lt;code&gt;str&lt;/code&gt;也逃逸到了堆上，在堆上进行内存分配，这是因为我们访问&lt;code&gt;str&lt;/code&gt;的地址，因为入参是&lt;code&gt;interface&lt;/code&gt;类型，所以变量&lt;code&gt;str&lt;/code&gt;的地址以实参的形式传入&lt;code&gt;fmt.Printf&lt;/code&gt;后被装箱到一个&lt;code&gt;interface{}&lt;/code&gt;形参变量中，装箱的形参变量的值要在堆上分配，但是还要存储一个栈上的地址，也就是&lt;code&gt;str&lt;/code&gt;的地址，堆上的对象不能存储一个栈上的地址，所以&lt;code&gt;str&lt;/code&gt;也逃逸到堆上，在堆上分配内存。（&lt;strong&gt;这里注意一个知识点：Go语言的参数传递只有值传递&lt;/strong&gt;）&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 闭包产生的逃逸&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Increase&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; n := &lt;span&gt;0&lt;/span&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  n++&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; n&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; in := Increase()&lt;br/&gt; fmt.Println(in()) &lt;span&gt;// 1&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看逃逸分析结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; build -gcflags=&lt;span&gt;&quot;-m -m -l&quot;&lt;/span&gt; ./test3.&lt;span&gt;go&lt;/span&gt;&lt;br/&gt;# command-line-arguments&lt;br/&gt;./test3.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;: Increase.func1 capturing by ref: n (addr=&lt;span&gt;true&lt;/span&gt; assign=&lt;span&gt;true&lt;/span&gt; width=&lt;span&gt;8&lt;/span&gt;)&lt;br/&gt;./test3.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;: &lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;literal&lt;/span&gt; &lt;span&gt;escapes&lt;/span&gt; &lt;span&gt;to&lt;/span&gt; &lt;span&gt;heap&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;./test3.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:         from ~r0 (assigned) at ./test3.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;7&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt;&lt;br/&gt;./test3.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;: &lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;literal&lt;/span&gt; &lt;span&gt;escapes&lt;/span&gt; &lt;span&gt;to&lt;/span&gt; &lt;span&gt;heap&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;./test3.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:         from &amp;amp;(&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;literal&lt;/span&gt;) &lt;span&gt;(address-of)&lt;/span&gt; &lt;span&gt;at&lt;/span&gt; ./&lt;span&gt;test3&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:9:9&lt;/span&gt;&lt;br/&gt;./test3.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;:         from ~r0 (assigned) at ./test3.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;7&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt;&lt;br/&gt;./test3.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;: &amp;amp;n escapes to heap&lt;br/&gt;./test3.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;:        from &lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;literal&lt;/span&gt; &lt;span&gt;(captured by a closure)&lt;/span&gt; &lt;span&gt;at&lt;/span&gt; ./&lt;span&gt;test3&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:9:9&lt;/span&gt;&lt;br/&gt;./test3.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;:        from &amp;amp;(&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;literal&lt;/span&gt;) &lt;span&gt;(address-of)&lt;/span&gt; &lt;span&gt;at&lt;/span&gt; ./&lt;span&gt;test3&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:9:9&lt;/span&gt;&lt;br/&gt;./test3.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;:        from ~r0 (assigned) at ./test3.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;7&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt;&lt;br/&gt;./test3.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;8&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;: moved to heap: n&lt;br/&gt;./test3.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt;: in() escapes to heap&lt;br/&gt;./test3.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt;:       from ... argument (arg to ...) at ./test3.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;&lt;br/&gt;./test3.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt;:       from *(... argument) (indirection) at ./test3.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;&lt;br/&gt;./test3.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt;:       from ... argument (passed to call[argument content escapes]) at ./test3.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;&lt;br/&gt;./test3.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;: main ... argument does not escape&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为函数也是一个指针类型，所以匿名函数当作返回值时也发生了逃逸，在匿名函数中使用外部变量&lt;code&gt;n&lt;/code&gt;，这个变量&lt;code&gt;n&lt;/code&gt;会一直存在直到&lt;code&gt;in&lt;/code&gt;被销毁，所以&lt;code&gt;n&lt;/code&gt;变量逃逸到了堆上。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 变量大小不确定及栈空间不足引发逃逸&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先使用&lt;code&gt;ulimit -a&lt;/code&gt;查看操作系统的栈空间：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ulimit -a&lt;br/&gt;-t: cpu time (seconds)              unlimited&lt;br/&gt;-f: file size (blocks)              unlimited&lt;br/&gt;-d: data seg size (kbytes)          unlimited&lt;br/&gt;-s: stack size (kbytes)             &lt;span&gt;8192&lt;/span&gt;&lt;br/&gt;-c: core file size (blocks)         &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;-v: address space (kbytes)          unlimited&lt;br/&gt;-l: locked-in-memory size (kbytes)  unlimited&lt;br/&gt;-u: processes                       &lt;span&gt;2784&lt;/span&gt;&lt;br/&gt;-n: file descriptors                &lt;span&gt;256&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的电脑的栈空间大小是&lt;code&gt;8192&lt;/code&gt;，所以根据这个我们写一个测试用例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;math/rand&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;LessThan8192&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; nums := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;) &lt;span&gt;// = 64KB&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;len&lt;/span&gt;(nums); i++ {&lt;br/&gt;  nums[i] = rand.Int()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;MoreThan8192&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt; nums := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;1000000&lt;/span&gt;) &lt;span&gt;// = 64KB&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;len&lt;/span&gt;(nums); i++ {&lt;br/&gt;  nums[i] = rand.Int()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NonConstant&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; number := &lt;span&gt;10&lt;/span&gt;&lt;br/&gt; s := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, number)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;len&lt;/span&gt;(s); i++ {&lt;br/&gt;  s[i] = i&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; NonConstant()&lt;br/&gt; MoreThan8192()&lt;br/&gt; LessThan8192()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看逃逸分析结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; build -gcflags=&lt;span&gt;&quot;-m -m -l&quot;&lt;/span&gt; ./test4.&lt;span&gt;go&lt;/span&gt;&lt;br/&gt;# command-line-arguments&lt;br/&gt;./test4.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;8&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt;: LessThan8192 &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;) does not escape&lt;br/&gt;./test4.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt;: &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;1000000&lt;/span&gt;) escapes to heap&lt;br/&gt;./test4.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt;:       from &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;1000000&lt;/span&gt;) (non-constant size) at ./test4.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt;&lt;br/&gt;./test4.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;:&lt;span&gt;11&lt;/span&gt;: &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, number) escapes to heap&lt;br/&gt;./test4.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;:&lt;span&gt;11&lt;/span&gt;:       from &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, number) (non-constant size) at ./test4.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;:&lt;span&gt;11&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到，当栈空间足够时，不会发生逃逸，但是当变量过大时，已经完全超过栈空间的大小时，将会发生逃逸到堆上分配内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样当我们初始化切片时，没有直接指定大小，而是填入的变量，这种情况为了保证内存的安全，编译器也会触发逃逸，在堆上进行分配内存。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考文章（建议大家阅读一遍）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;https://driverzhang.github.io/post/golang%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://segmentfault.com/a/1190000039843497&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://tonybai.com/2021/05/24/understand-go-escape-analysis-by-example/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://cloud.tencent.com/developer/article/1732263&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://geektutu.com/post/hpg-escape-analysis.html&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文到这里结束了，这篇文章我们一起分析了什么是内存逃逸以及&lt;code&gt;Go&lt;/code&gt;语言中的逃逸分析，上面只列举了几个例子，因为发生的逃逸的情况是列举不全的，我们只需要了解什么是逃逸分析，了解逃逸的策略就可以了，后面在实战中可以根据具体代码具体分析，写出更优质的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后对逃逸做一个总结：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;逃逸分析在编译阶段确定哪些变量可以分配在栈中，哪些变量分配在堆上&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;逃逸分析减轻了&lt;code&gt;GC&lt;/code&gt;压力，提高程序的运行速度&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;栈上内存使用完毕不需要&lt;code&gt;GC&lt;/code&gt;处理，堆上内存使用完毕会交给&lt;code&gt;GC&lt;/code&gt;处理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;函数传参时对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据代码具体分析，尽量减少逃逸代码，减轻&lt;code&gt;GC&lt;/code&gt;压力，提高性能&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！我是&lt;code&gt;asong&lt;/code&gt;，我们下期见。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：关注公众号获取。更多学习资料请到公众号领取。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.31875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CqB2u93NwB8rxL8DUy5BbjNyggRGwIWE7Y2icLH12dMCLvlJ3AG8PR7qVOBWj2mVrxbJdYibAILPRGVo32XlnXJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐往期文章：&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5fae7fe93f491454b0093732e081464c</guid>
<title>了解这些软件设计思想，你的思维至少上升一个段位</title>
<link>https://toutiao.io/k/mjj6g4o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;一、介绍&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念，四位作者合称 GOF（全拼 Gang of Four），简称四人帮！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;书中共说到 23 种设计模式，这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，随着软件的快速发展，还出现另一类我们所熟知的设计模式：&lt;strong&gt;J2EE 设计模式&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先要跟大家说明的是，&lt;strong&gt;设计模式其实不是一项新技术&lt;/strong&gt;，而是众多软件开发人员经过相当长的一段时间的试用和试错总结出来的一套软件设计开发实践方案，学习这些知识有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也不BB了，下面我们就一起来深入了解一下大神们总结的这套方法论！&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;二、方法论&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1、单一职责原则&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单一职责原则，顾名思义，一个类负责一个功能的处理，比如我们在代码中经常会涉及到调用第三方的接口，通常我们往往会将一个接口请求方法封装成一个&lt;code&gt;http&lt;/code&gt;请求的工具类，这样其他的调用方能非常方便的进行调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单一职责原则，主要的目的是将一个功能划分到合适的粒度，让这些各自执行单一职责的类，各司其职。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有我们常常说的mvc模式，将数据操作与业务逻辑处理进行分离，也是属于单一职责原则的一种。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2、开闭原则&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开闭原则，指的是：&lt;strong&gt;对扩展开放，对修改关闭&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的意思是在增加新功能的时候，&lt;strong&gt;能不改代码就尽量不要改，如果只增加代码就完成了新功能，那是最好的&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我举个简单的例子，大家可能就懂了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际的项目开发过程中，尤其是与第三方公司进行接口对接的时候，例如 a 公司，他的接口协议要求采用&lt;code&gt;rsa&lt;/code&gt;加密；b 公司，他的接口协议采用&lt;code&gt;aes&lt;/code&gt;加密，c公司，他的接口协议要求采用&lt;code&gt;md5&lt;/code&gt;就可以了...&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在一开始的时候，可能你没有想那么多，设想所有其他公司跟你对接的时候，全部采用&lt;code&gt;rsa&lt;/code&gt;加密，那么当第二家公司来了时候，要求采用&lt;code&gt;aes&lt;/code&gt;，这个时候，你必须得改代码才能支持这种功能，假如又来了其他公司呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这种情况下，我们可以采用面向接口编程的思想，定义一个抽象的方法，然后针对不同的加密算法，编写不同的实现类，当新来了一家公司要求采用不同的加密算法时，我们只需要扩展一个新的实现类，在逻辑处理层进行路由即可快速完成开发和对接！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现开闭原则的主要步骤就是将业务方法里面的逻辑进行抽象化，从而实现逻辑层面代码的解耦。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3、里氏代换原则&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;里氏替换原则，通俗的说就是：子类可以扩展父类的功能，但不能改变父类原有的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说：&lt;strong&gt;子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当子类在重写父类的方法时，如果使用不当，很可能会改变父类方法中的逻辑语义，进而造成逻辑处理混乱。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际的业务开发中，尤其是大家在使用类继承操作时，应当谨慎重新父类方法，方法定义的时候，名称也尽量不要发生重名。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时，应该注意类过多的继承，例如 A 类继承自 B 类，B 类 继承自 C 类，C 类继承 D 类，这种场景下，第一：逻辑很可能非常复杂，代码可读性可能很差，第二种可能会出现方法名或者属性名冲突。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我曾经修改一个老项目 bug 的时候，就出现过这种情况，一个实体类出现三层关系的继承，当我把子类进行序列化成&lt;code&gt;json&lt;/code&gt;的时候，突然报错，原因就是因为里面有个属性，在基类里面也定义了，但是类型却不一样，也就是说在这个子类里面有两个相同的属性，只是字段类型不同而已，从而导致这个序列化报错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，大家在使用类继承操作时，一定要谨慎处理，最好的情况下是一层关系继承，这样即使出现问题了，也好排查，范围可控；继承关系多了，反而代码变的非常复杂，每个方法逻辑都需要一一梳理清楚，你才敢去下手，这种情况下，反而为难了自己！&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4、依赖倒转原则&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;依赖倒转原则，简单的说就是&lt;strong&gt;面向接口编程，依赖于抽象而不依赖于具体&lt;/strong&gt;，他是实现&lt;strong&gt;开闭原则&lt;/strong&gt;的一个途径。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;依赖倒转原则主要有以下几点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;高层的模块不应该依赖于低层的模块，这两者都应该依赖于其抽象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;抽象不应该依赖细节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;细节应该依赖抽象&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换句话说，就是将具体类里面的方法进行逻辑抽象化，提升到接口或者抽象类里面，由具体的实现类去实现具体的业务逻辑，抽象层不关注细节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是我们俗称的，不管遇到啥事情，先看大局，在看小点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，例如我们常常使用的&lt;code&gt;MVC&lt;/code&gt;框架，在&lt;code&gt;Service&lt;/code&gt;层通常会&lt;strong&gt;先编写接口类，然后在编写服务实现类，这就是典型的面向接口编程&lt;/strong&gt;，这种方案有哪些好处呢？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可以减少研发人员并行开发引起的风险&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以显著提高代码的可读性和可维护性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以降低类间的耦合性&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个大项目开发的时候，试想一下，如果2个以上研发人员在编写同一个类的同一个方法，没有定义接口的情况下，随着时间的流逝，这个类大概率会非常混乱，同时，里面的方法估计阅读起来也很困难，一眼望去基本上不知道这个方法是干嘛的，尤其是重载方法很多的时候，尤其困难。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们引入接口之后，将所有的核心方法全部抽象定义，当我们对其进行二次开发的时，也会能快速定位到以前的和谐方法，然后进行快速定位和维护。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面向接口编程，还有一个很大的好处，就是可以降低类之间的耦合度。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5、接口隔离原则&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口隔离原则的意思是：&lt;strong&gt;尽量将一个接口拆的更细，使用多个隔离的接口，比使用单个接口要好&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个原则基本上是从大型软件架构出发、便于升级和维护的思想诞生出来的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，一个第三方保险服务系统里面，如果是小项目，你可以在一个接口里面定义&lt;code&gt;投保方法&lt;/code&gt;、&lt;code&gt;取消方法&lt;/code&gt;、 &lt;code&gt;退保方法&lt;/code&gt;、 &lt;code&gt;理赔方法&lt;/code&gt;、 &lt;code&gt;保单方法&lt;/code&gt;这5种方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你只跟一家保险公司合作的时候，这套接口定义是没问题的，但是假如现在公司的业务发展的非常快，已经引入10几家保险公司了，你会发现这个接口基本上顶不住了，在此有两种方法可以解决这种技术难题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;1、针对不同的保险公司，又重新定义一个接口，然后还是里面的5种方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2、针对不同的操作行为，比如&lt;code&gt;投保&lt;/code&gt;，单独定义一套接口，然后针对不同的保险公司编写不同的实现类&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两种其实本质都是将一个接口，拆成多个颗粒度更细的接口，然后从行为上，让各种的实现类更加独立，进而降低类之间的耦合度，开发起来层次清晰，有利于系统的稳定！&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.6、组合/聚合复用原则&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;合成复用原则的意思就是：&lt;strong&gt;尽量使用组合/聚合的方式，而不是使用继承&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓&lt;strong&gt;组合/聚合的方式&lt;/strong&gt;，其实就是我们在&lt;code&gt;springMVC&lt;/code&gt;里面使用的&lt;code&gt;ioc&lt;/code&gt;依赖注入方式，&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt; &lt;span&gt;/**&lt;br/&gt;     * ioc依赖注入&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; BService bService;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//业务代码...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;AService&lt;/code&gt;类调用&lt;code&gt;BService&lt;/code&gt;类，有两种方式可以实现，第一种就是通过继承方式，可以直接调用；第二种方式就是通过&lt;code&gt;ioc&lt;/code&gt;依赖注入的方式，在类里面进行组合操作，然后进行调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;很明显，第二种方式，我们使用的爱不释手&lt;/strong&gt;！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式有个好处就是，代码层次清晰，编写优雅，用上之后容易上瘾，推荐使用！&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.7、迪米特法则&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;迪米特法则，又称最少知道原则，意思就是说：&lt;strong&gt;一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类似单一原则的思想，例如我们编写实体类的时候，基本上就是属性名称，加&lt;code&gt;get/set&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt; &lt;span&gt;/**&lt;br/&gt;     * 用户id&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Long userId;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;/**&lt;br/&gt;     * 用户姓名&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt; &lt;span&gt;private&lt;/span&gt; String userName;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Long &lt;span&gt;getUserId&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.userId;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setUserId&lt;/span&gt;&lt;span&gt;(Long userId)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.userId = userId;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getUserName&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.userName;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setUserName&lt;/span&gt;&lt;span&gt;(String userName)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.userName = userName;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个实体里面出现跟自己没太大关系的代码时，例如数据运算逻辑处理，这个时候应当将这部分代码全部清理出去，交由业务处理层来出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从实体类的定义来说，它主要的功能就是承担数据展示，当多个业务处理层在使用这个实体类的时候，如果你们嵌套了很多的数据运算逻辑，可能在返回的时候，客户端得到的实体类的属性值，并不是正确的结果！&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;三、小结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面一共介绍了 7 种设计原则，基本上都是大神们经过很多次血的教训，总结出来的一套方法论。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些设计原则，可以给同行在实际的软件设计过程中，提供一些思路，具体的应用，还需要结合实际的业务场景进一步思考，怎么让系统变的更加可靠，开发更佳迅速，代码阅读起来更佳轻松，关键在于灵活运用！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>