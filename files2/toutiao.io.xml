<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3d4cdd790e6c304087fa9274d0494f85</guid>
<title>必知必会的大厂面试计算机基础和概念</title>
<link>https://toutiao.io/k/xvy1us5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近在翻阅文章时，看到全成大佬推荐的《程序员的自我修养》，这是一本讲链接、装载与库的计算机图书，看了下目录后觉得挺有意思。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此决定每读一章就将其读书笔记整理记录下来，分享给大家。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目录：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;462&quot; data-ratio=&quot;0.8281938325991189&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4gzsvHTSrewSAlLNRaEJSMRg29ibPbrKTvciaKoPyp55riadzBqDU6AicA7C164Q4eMjv1naQAWE2W7icQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;908&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;不要让 CPU 打盹&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在计算机发展早期，CPU 资源十分昂贵。如果一个 CPU 只能运行一个程序，那么当程序在读写磁盘（进行 I/O 操作）时，CPU 就空闲下来了。这在当时简直就是巨大的浪费。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4gzsvHTSrewSAlLNRaEJSMRkQTyMohvPfZFj4icuicBfKDMbBVgibYicj56BUEzBPicIzeZmVvg14GzBxA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;198&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;CPU 只能和一个程序A “聊天“，其他来再多的程序BCD，都没有任何操作的空间。就像早年的手机，打电话和上网（语音/数据）只能二选一，作为 CPU 的你，并不能多线程操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此机智的人们很快就编写了一些监控程序，希望来解决这个问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;多道程序（Multiprogramming）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多道程序起，操作系统正式具有同时运行多个程序的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其是让 CPU 一次读取多个程序放入内存中。当某个程序暂时无须使用 CPU 时，监控程序就把另外的正在等待 CPU 资源的程序启动，以此使得 CPU 能够充分地利用起来。这种策略的确大大的提高了 CPU 资源的利用率。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;真实场景&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你在 Windows 上点击鼠标 10 分钟以后系统才有反应，那是多么无奈的事情。因为没有优先级区分，自然一路排下来也就不知道要等到什么时候了，相当于半饿死。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;存在的问题&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;核心问题在于程序之间的调度策略太粗糙。对于多道程序来删，程序之间部分轻重缓急，也就是说不存在优先级的区分。因此如果有些程序急需使用 CPU 来完成一些任务，那么很有可能会很长时间后才有机会被分配到 CPU，才得以继续往下运行。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;分时系统（Time-Sharing System）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序运行模式改为协作的模式，在原有的多道程序继续升级改造，即每个程序运行一段时间以后都主动让出 CPU 给其他程序，使得一段时间内每个程序都有机会运行一小段。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;真实场景&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如你点击一下鼠标或按下一个键盘按键后，他会相较前者能够更快的得到响应，因为他好歹是存在切换的可能性。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;存在问题&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候的监控程序已经比原有多道程序的模式已经复杂了不少，完整的操作系统雏形已经基本形成，很早期的 Windows（Windows 95 和 Windows NT 之前），MacOS X 之前的 MacOS 版本都是采用这种分时系统的方式来进行程序调度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其仍然存在问题，核心在于若一个程序一直在进行一个耗时计算，便会一直霸占着 CPU 不放，那么操作系统也没有不放，就会导致其他程序都只能无限等待，相当于就是系统假死了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;多任务系统（Multi-tasking）&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;背景&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分时系统中，一个程序死循环就会导致系统假死，并且其运行效率并不高，只能解决当时的交互式环境。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;放在现在来讲，已经完全没法很好的运行。因此当时业界也在研究更为先进的操作系统模式，也就是现在最为流行也是最熟悉的多任务系统。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解决方案&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在多任务系统中，所有的应用程序都以进行（Process）的方式运行，其有以下特点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;每个进程都有自己独立的地址空间，因此各进程之间相互隔离。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个 CPU 都由操作系统统一进行分配。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个进程根据其优先级的高低都有机会得到 CPU。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但需要注意的是，若是进程运行超出了指定的时间，操作系统就会暂停该进程，将 CPU 资源分配给其他等待运行的进程。这种 CPU 的分配方式一般称作抢占式（Preemptive）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这种方式，操作系统就可以强制剥夺 CPU 资源并且分配给它认为目前最需要资源的进程，如果分配给每个进程的时间都很短，即 CPU 在多个进程间快速切换，就可以造成多个进程同时在运行的假象。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;内存不够用怎么办&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在早期的计算机中，程序是直接运行在物理内存上的，访问的内存地址都是物理地址。假设只是一个进程在跑，可能内存资源还够用，但实际上为了更有效地利用硬件资源，我们必须运行多个程序，CPU 的利用率才会比较高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候就会遇到一个严重的问题，那就是如何将计算机上有限的物理内存分配给多个程序使用？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.45870206489675514&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4gzsvHTSrewSAlLNRaEJSMRpf7R3N6icDdibw83ZQp1bQY8JQ8g34ssESZaRMaap9IPHBtHrEoaWR5g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1356&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就像上图，每个程序他都想申请 1GB 的内容，而计算机本身只有 1GB 的物理内存，根本没有办法真正的执行。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;真实场景和问题&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能会有小伙伴想，煎鱼你举的例子太极端了，我们举个 ”正常“ 点的例子。假设计算机有 128MB 内存，程序 A 运行需要 10MB，程序 B 需要 100MB，程序 C 需要 20 MB。假设该几个程序运行时，我们按照其想要的一分配，不就好了吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但现实并不是这样，这种简单的内存分配策略存在许多的问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;地址空间不隔离：所有程序都直接访问物理地址，各程序所使用的内存空间并不是相互独立，很容易改写到其他程序的内存地址。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;内存使用效率低：没有有效的内存管理机制，一会运行程序 A，一会运行程序 B，就需要经常要将大量数据换出换入，效率十分低下。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;程序运行的地址不确定：每次程序运行时，都需要从内存中给其分配一块足够大的空闲区域，但这些内存区域位置是不确定的，给程序编写造成了一定的麻烦。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解决方法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决上述问题的解决思路，就是万能的法宝：增加中间层，即使用一种间接的地址访问方法。把程序给出的地址看作是一种虚拟地址（Virtual Address），然后通过某些映射的方法，将这个虚拟地址最终转换成实际的物理地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述提到了两个非常重要的内存概念：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;物理地址空间：是实实在在存在的，存在于计算机中，且对每一台计算机来说只有唯一的一个，你可以将其想象为物理内存。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;虚拟地址空间：是指虚拟的、人们想象出来的地址空间。其实它并不存在，每个进程都有自己的独立虚拟空间，且每个进程只能访问自己的地址空间。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如此一来，操作系统只需要控制虚拟地址到物理地址的映射过程，就可以保证任意一个程序锁你访问的物理内存区域和另外一个程序不重叠，以达到地址空间隔离的效果。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5060532687651331&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4gzsvHTSrewSAlLNRaEJSMReFXgwwXib7NdY7P4cxSpvdDtOtUSymaRFibQfS8FxIY41uGcnxyuG0Sw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1652&quot;/&gt;&lt;figcaption&gt;进程虚拟空间、物理空间和磁盘之间的页映射关系&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外需要清楚虚拟存储的实现需要依靠硬件的支持，对于不同的 CPU 来说不同。但大多采用 MMU（Memory Management Unit）的部件来进行页映射：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3128491620111732&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4gzsvHTSrewSAlLNRaEJSMR1cuVVv8pbPajx1vWqE8s8RaNeBtAzicvkLa6KV9jMhchQG1649KmIsQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1432&quot;/&gt;&lt;figcaption&gt;虚拟地址到物理地址的转变&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU 发出的是虚拟地址（Virtual Address），也就是日常程序中所看到的是虚拟地址。经过 MMU 转换后就会变成物理地址（Physical Address）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前常见的 MMU 均已集成在 CPU 内部了，不会再以独立部件存在。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;线程的那些事&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程（Thread），有时候被称为轻量级进程，是程序执行流程的最小单元。一个标准的线程由线程 ID、当前指令指针（PC）、寄存器集合和堆栈组成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）及一些进程级的资源（如打开文件和信号）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7105263157894737&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4gzsvHTSrewSAlLNRaEJSMRcbDZiaI4dz8cqu2bicS8GEQ4V1cEpYYmOoHWE8VPyztm5z6nuibjQvKCg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1216&quot;/&gt;&lt;figcaption&gt;线程组成&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么需要多线程&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;某个操作可能会陷入长时间等待，等待的线程会进入睡眠状态，无法继续执行。多线程执行可以有效利用等待的时间。典型的例子是等待网络响应，这时候就可以切换了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;某个操作会消耗大量的时间，如果只有一个线程，程序和用户之间的交互会中断。多线程的情况下，可以让一个线程负责交互，另外一个线程负责计算。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;程序逻辑本身就要求并发操作，例如一个多端下载软件。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;多 CPU 或多核计算机，其本身就具备同时执行多个线程的能力。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;相对于多进程应用，多线程在数据共享方面效率会高很多。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;线程的访问权限&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程可以访问进程内存里的所有数据，甚至在知道堆栈地址的情况下，可以访问其他线程里的堆栈信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其私有存储空间主要分为：栈、线程局部存储（Thread Local Storage，TLS）、寄存器（包括 PC 寄存器）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;线程调度和时间片&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在单处理器对应多线程的情况下，并发是一种模拟处理的状态。操作系统会让这些多线程程序轮流执行，每次仅执行一小段时间（通常是几十到几百毫秒），这样子线程就 “看起来” 在同时执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不断在处理器上切换不同的线程行为称之为线程调度（Thread Schedule），通常拥有至少三种状态，分别是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;运行（Running）：此时线程正在执行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;就绪（Ready）：此时线程可以立刻运行，但 CPU 已经被占用，暂时无法分配。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;等待（Waiting）：此时线程正在等待某一事件（例如：I/O 事件）发生，无法执行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;处于运行状态中的线程都会拥有一段可以执行的时间，这段时间段称为时间片（Time Slice）。其基本流转：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当时间片用尽的时候，进程进入就绪状态。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当时间片用尽之前，进程若开始等待某个事件，那么它将进入等待状态。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每当一个线程离开运行状态时，调度系统就会选择一个当前是就绪状态的线程继续执行。而一个处于等待状态的线程在完成所等待的事件后，就会进入就绪状态。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7421731123388582&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4gzsvHTSrewSAlLNRaEJSMRwdgLslTUMuSk4icovwYyHzOGMASTZFjGIEjlCdIoJjDJoAkerLacxCA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1086&quot;/&gt;&lt;figcaption&gt;线程状态流转&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;线程优先级&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Windows 和 Linux 中，线程的优先级可以通过用户手动设置，系统也会根据线程的表现自动调整优先级，以使得调度更有效率。常见的一般有两类线程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;IO 密集型线程（IO Bound Thread）：频繁等待，像是网络调用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CPU 密集型线程（CPU Bound Thread）：很少等待，主要是计算为主。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的线程调度方式如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;轮转法：让各个线程轮流执行一小段时间，这也决定了线程之间存在交错执行的特点。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;优先级调度：在具有优先级调度的系统中，线程都拥有各自的线程优先级，具有高优先级的线程会更早的执行，低优先级的线程常常要等待到系统中已经没有高优先级的可执行线程时才可以执行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IO 密集型线程总是会比 CPU 密集型线程容易得到优先级的提升。但在优先级调度下，存在一种线程饿死的现象。一个线程被饿死，是说它的优先级比较低，在它执行之前，总是有较高优先级的线程要执行。因此低优先级线程始终无法执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了避免饿死现象，调度系统会逐步提升那些等待了过长时间的得不到执行的线程优先级。这样的方式，一个线程只要等待足够长的时间，其优先级最终一定会提高到足够让他执行的程度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程优先级改变一般有三种方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用户指定优先级。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据进入等待状态的频繁程度提升或降低优先级。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;长时间得不到执行而被提升优先级。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;可抢占线程和不可抢占线程&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程在用尽时间片之后会被强制剥夺继续执行的权利，而进入就绪状态，这个过程叫做抢占（Preemption），即之后执行的别的线程抢占了当前线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前以可抢占式线程居多，非抢占式线程在今日已经十分少见。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;三种线程模型&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日常在程序中使用的线程其实并不是内核线程，而是存在于用户态的用户线程。用户态并不一定在操作系统内核中对应同等数量的内核线程。接下来将介绍三种常见的用户态多线程库的实现方式。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;一对一模型&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一对一模型指的是一个用户使用的线程就唯一对应一个内核使用的线程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4885844748858447&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4gzsvHTSrewSAlLNRaEJSMRN0DBTDPvOARXdRH5atG6UxudhTF0SNlC2BCLNZrTIWib9YDR8VEnA0Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1314&quot;/&gt;&lt;figcaption&gt;一对一线程模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;线程之间的并发是真正的并发。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;线程阻塞时，其他线程执行不会受到影响。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;操作系统限制了内核线程的数量，因此一对一线程会让用户的线程数受限。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;内核线程调度时，上下文切换的开销较大，导致用户线程的执行效率下降。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;多对一模型&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多对一模型指的是多个用户线程映射到一个内核线程上，线程之间的切换由用户态的代码来进行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4885844748858447&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4gzsvHTSrewSAlLNRaEJSMRho1Q5eice2WH46mWkDkRKicNu1wCZbSUQgYOwYwbibyCZAtgnIzCn8z6A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1314&quot;/&gt;&lt;figcaption&gt;多对一模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果一个用户线程阻塞，那么所有的线程都将无法执行，因为内核线程也被阻塞住了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;多对多模型&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多对多模型指的是将多个用户线程映射到少数但不止一个内核线程上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5220700152207002&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4gzsvHTSrewSAlLNRaEJSMRibiamvjfktCGeXkVZqGWcyq3Ots0fyg7tN0xM8V5CiaEMkjWwX9ibLkZEA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1314&quot;/&gt;&lt;figcaption&gt;多对多模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要涉及到 CPU、内存、线程。我们能够从其的一些关注点知道为什么 CPU 调度会这样子发展，又经历了什么东西。内存为什么会出现虚拟内存，物理内存，其之间又是如何相互转换的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外还了解到线程的基本分类和常见调度方式等，这些都是计算机基本的软硬件知识，非常值得大家仔细思考。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>704fcb9bf62e5b06b4bb481d88915111</guid>
<title>《我想进大厂》之 JVM 夺命连环 10 问</title>
<link>https://toutiao.io/k/swi8lo6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;（给&lt;/span&gt;&lt;span&gt;ImportNew&lt;/span&gt;&lt;span&gt;加星标，提高Java技能）&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;作者： 科技缪缪（本文来自作者投稿）&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 说说 JVM 的内存布局？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.37890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlaX1kzmfeFkqNiaDiar0WVkM9WqfBbh6BW3EmEgTCVCW4XbhYQGBzhSXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Java 虚拟机主要包含几个区域：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;堆&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：堆是 Java 虚拟机中最大的一块内存，是线程共享的内存区域，基本上所有的对象实例数组都是在堆上分配空间。堆区细分为 Young&lt;/span&gt;&lt;span&gt; 区年轻代和 Old 区老年代，其中年轻代又分为 Eden、S0、S1 3个部分，他们默认的比例是 8:1:1 的大小。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;栈&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：栈是线程私有的内存区域，每个方法执行的时候都会在栈创建一个栈帧，方法的调用过程就对应着栈的入栈和出栈的过程。每个栈帧的结构又包含局部变量表、操作数栈、动态连接、方法返回地址。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;局部变量表用于存储方法参数和局部变量。当第一个方法被调用的时候，它的参数会被传递至从0开始的连续的局部变量表中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;操作数栈用于一些字节码指令从局部变量表中传递至操作数栈，也用来准备方法调用的参数以及接收方法返回结果。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;动态连接用于将符号引用表示的方法转换为实际方法的直接引用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;元数据&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：在 Java1.7 之前，包含方法区的概念，常量池就存在于方法区（永久代）中，而方法区本身是一个逻辑上的概念，在1.7之后则是把常量池移到了堆内，1.8之后移出了永久代的概念(方法区的概念仍然保留)，实现方式则是现在的元数据。它包含类的元信息和运行时常量池。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;class 文件就是类和接口的定义信息。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;运行时常量池就是类和接口的常量池运行时的表现形式。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;本地方法栈&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：主要用于执行本地 native 方法的区域。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;程序计数器&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：也是线程私有的区域，用于记录当前线程下虚拟机正在执行的字节码的指令地址。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 知道 new 一个对象的过程吗？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.40390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlOvda0KYHkCicWv9Libm8FpZgRKScK30oQxYPNIOsfMgjEvMmq8Isb6Rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当虚拟机遇见 &lt;strong&gt;new &lt;/strong&gt;关键字时候，实现判断当前类是否已经加载。如果类没有加载，首先执行类的加载机制，加载完成后再为对象分配空间、初始化等。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;首先&lt;strong&gt;校验当前类是否被加载&lt;/strong&gt;，如果没有加载，执行类加载机制；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;加载&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：就是从字节码加载成二进制流的过程；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;验证&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：当然加载完成之后，当然需要校验 class 文件是否符合虚拟机规范，跟我们接口请求一样，第一件事情当然是先做个参数校验了；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;准备&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：为静态变量、常量赋默认值；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;解析&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：把常量池中符号引用(以符号描述引用的目标)替换为直接引用(指向目标的指针或者句柄等)的过程；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;初始化&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：执行 static 代码块 (cinit) 进行初始化，如果存在父类，先对父类进行初始化。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;注意&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：静态代码块是绝对线程安全的，只能隐式被 Java 虚拟机在类加载过程中初始化调用！(此处该有问题：&lt;strong&gt;static 代码块线程安全吗？&lt;/strong&gt;)&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当类加载完成之后，紧接着就是对象分配内存空间和初始化的过程：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;首先为对象分配合适大小的内存空间；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;接着为实例变量赋默认值；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;设置对象的头信息，对象 hashcode、GC 分代年龄、元数据信息等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;执行构造函数 (init) 初始化。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 知道双亲委派模型吗？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;类加载器自顶向下分为：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Bootstrap ClassLoader&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;（启动类加载器）：默认会去加载 JAVA_HOME/lib 目录下的 jar；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Extention ClassLoader&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;（扩展类加载器）：默认去加载 JAVA_HOME/lib/ext 目录下的 jar；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Application ClassLoader&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;（应用程序类加载器）：比如我们的 Web 应用，会加载 Web 程序中 ClassPath 下的类；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;User ClassLoader&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;（用户自定义类加载器）：由用户自己定义。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当我们在加载类的时候，首先都会向上询问自己的父加载器是否已经加载。如果没有则依次向上询问；如果没有加载，则从上到下依次尝试是否能加载当前类，直到加载成功。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.64609375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlZKccYiccqpOGYdIUwltUNPmmyib6Gz2W6IWH6FCIIxojeQpyjXpw6T5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;4. 说说有哪些垃圾回收算法？&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;标记-清除&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;统一标记出需要回收的对象，标记完成之后统一回收所有被标记的对象。而由于标记的过程需要遍历所有的 GC ROOT，清除的过程也要遍历堆中所有的对象，所以标记-清除算法的效率低下，同时也带来了内存碎片的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;复制算法&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了解决性能的问题，复制算法应运而生。它将内存分为大小相等的两块区域，每次使用其中的一块。当一块内存使用完之后，将还存活的对象拷贝到另外一块内存区域中，然后把当前内存清空。这样性能和内存碎片的问题得以解决。但是同时带来了另外一个问题，可使用的内存空间缩小了一半！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此，诞生了我们现在的常见的&lt;strong&gt;年轻代+老年代&lt;/strong&gt;的内存结构：Eden+S0+S1 组成。因为根据 IBM 的研究显示，98%的对象都是朝生夕死，所以实际上存活的对象并不是很多，完全不需要用到一半内存浪费，所以默认的比例是 8:1:1。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样，在使用的时候只使用 Eden 区和 S0、S1 中的一个，每次都把存活的对象拷贝另外一个未使用的 Survivor 区，同时清空 Eden 和使用的 Survivor，这样下来内存的浪费就只有10%了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果最后未使用的 Survivor 放不下存活的对象，这些对象就进入 Old 老年代了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;注意&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：所以有一些初级点的问题会问你，为什么要分为 Eden 区和2个 Survior 区？有什么作用？就是为了节省内存和解决内存碎片的问题。这些算法都是为了解决问题而产生的，如果理解原因你就不需要死记硬背了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;标记-整理&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;针对老年代再用复制算法显然不合适，因为进入老年代的对象都存活率比较高了，这时候再频繁的复制对性能影响就比较大，而且也不会再有另外的空间进行兜底。所以针对老年代的特点，通过&lt;strong&gt;标记-整理&lt;/strong&gt;算法，标记出所有的存活对象，让所有存活的对象都向一端移动，然后清理掉边界以外的内存空间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;5. 什么是 GC ROOT？有哪些 GC ROOT？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面提到的标记的算法，怎么标记一个对象是否存活？简单的通过引用计数法，给对象设置一个引用计数器，每当有一个地方引用他，就给计数器+1，反之则计数器-1，但是这个简单的算法&lt;strong&gt;无法解决循环引用的问题&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Java 通过可达性分析算法来达到标记存活对象的目的，定义一系列的 GC ROOT 为起点。从起点开始向下开始搜索，搜索走过的路径称为引用链。当一个对象到 GC ROOT没有任何引用链相连的话，则对象可以判定是可以被回收的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而可以作为 GC ROOT 的对象包括：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;栈中引用的对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;静态变量、常量引用的对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;本地方法栈 native 方法引用的对象。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;6. 垃圾回收器了解吗？年轻代和老年代都有哪些垃圾回收器？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.41953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlS2swjribk4EibNmDPwGf1o5gqeRbkSdEKic67pibPqMEDGPf857pP2G1YA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;年轻代的垃圾收集器包含有 Serial、ParNew、Parallell。老年代则包括 Serial Old 老年代版本、CMS、Parallel Old 老年代版本和 JDK11 中全新的 G1 收集器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Serial&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：单线程版本收集器，进行垃圾回收的时候会 STW（Stop The World），也就是进行垃圾回收的时候其他的工作线程都必须暂停。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;ParNew&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Serial 的多线程版本，用于和 CMS 配合使用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Parallel Scavenge&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：可以并行收集的多线程垃圾收集器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Serial Old&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Serial 的老年代版本，也是单线程。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Parallel Old&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Parallel Scavenge 的老年代版本。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;CMS（Concurrent Mark Sweep）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：CMS 收集器是以获取最短停顿时间为目标的收集器。相对于其他的收集器 STW 的时间更短暂，可以并行收集是它的特点，同时它基于&lt;strong&gt;标记-清除&lt;/strong&gt;算法。整个 GC 过程分为4步：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;初始标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：标记 GC ROOT 能关联到的对象，需要 STW；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;并发标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：从 GCRoots 的直接关联对象开始遍历整个对象图的过程，不需要 STW；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;重新标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：为了修正并发标记期间，因用户程序继续运作而导致标记产生改变的标记，需要 STW；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;并发清除&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：清理删除掉标记阶段判断的已经死亡的对象，不需要 STW。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从整个过程来看，并发标记和并发清除的耗时最长，但是不需要停止用户线程。而初始标记和重新标记的耗时较短，但是需要停止用户线程。总体而言，整个过程造成的停顿时间较短，大部分时候是可以和用户线程一起工作的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;G1（Garbage First）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：G1 收集器是 JDK9 的默认垃圾收集器，不再区分年轻代和老年代进行回收。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;7. G1的原理了解吗？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.54453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlclwUSgRl1TKmdLvuBoicahRpa48GWyMADXRrVQhAiaryF7LPkLCC1TeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;G1 作为 JDK9 之后的服务端默认收集器，不再区分年轻代和老年代进行垃圾回收。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;把内存划分为多个 Region，每个 Region 的大小可以通过 &lt;strong&gt;-XX：G1HeapRegionSize&lt;/strong&gt; 设置，大小为1~32M。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于大对象的存储则衍生出 &lt;strong&gt;Humongous &lt;/strong&gt;的概念。超过 Region 大小一半的对象会被认为是大对象，而超过整个 Region 大小的对象被认为是超级大对象，将会被存储在连续的 N 个 Humongous Region 中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;G1 在进行回收的时候会在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间优先回收收益最大的 Region。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;G1 的回收过程分为以下四个步骤：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;初始标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：标记 GC ROOT 能关联到的对象，需要 STW；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;并发标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：从 GCRoots 的直接关联对象开始遍历整个对象图的过程，扫描完成后还会重新处理并发标记过程中产生变动的对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;最终标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：短暂暂停用户线程，再处理一次，需要 STW；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;筛选回收&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：更新 Region 的统计数据，对每个 Region 的回收价值和成本排序，根据用户设置的停顿时间制定回收计划。再把需要回收的 Region 中存活对象复制到空的 Region，同时清理旧的 Region。需要 STW。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总的来说除了并发标记之外，其他几个过程也还是需要短暂的 STW。G1 的目标是在停顿和延迟可控的情况下尽可能提高吞吐量。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;8. 什么时候会触发 YGC 和 FGC？对象什么时候会进入老年代？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当一个新的对象来申请内存空间的时候，如果 Eden 区无法满足内存分配需求，则触发 YGC。使用中的 Survivor 区和 Eden 区存活对象送到未使用的 Survivor 区。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果 YGC 之后还是没有足够空间，则直接进入老年代分配。如果老年代也无法分配空间，触发 FGC，FGC 之后还是放不下则报出 OOM 异常。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.03125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlDlicFGn9Z2ic9ABVnrxWE9qzl4p4QOrbWyeZ1nEYqxGibianVicET1BqnLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;YGC 之后，存活的对象将会被复制到未使用的 Survivor 区。如果 S 区放不下，则直接晋升至老年代。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而对于那些一直在 Survivor 区来回复制的对象，通过 &lt;strong&gt;-XX：MaxTenuringThreshold&lt;/strong&gt; 配置交换阈值，默认15次。如果超过次数同样进入老年代。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此外，还有一种动态年龄的判断机制，不需要等到 MaxTenuringThreshold 就能晋升老年代。如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;9. 频繁 FullGC 怎么排查？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种问题最好的办法就是结合有具体的例子举例分析，如果没有就说一般的分析步骤。发生 FGC 有可能是内存分配不合理，比如 Eden 区太小，导致对象频繁进入老年代，这时候通过启动参数配置就能看出来，另外有可能就是存在内存泄露，可以通过以下的步骤进行排查：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;1. &lt;strong&gt;jstat -gcutil&lt;/strong&gt; 或者查看 gc.log 日志，查看内存回收情况。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.35078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlNzhFQZlnLpOEIWkoPIgE4pPQYFcZ8OVdAu4ibOBtawqVJOaLficd7icXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;S0、S1 分别代表两个 Survivor 区占比；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;E 代表 Eden 区占比，图中可以看到使用了78%；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;O 代表老年代，M 代表元空间，YGC 发生54次，YGCT 代表 YGC 累计耗时，GCT 代表 GC 累计耗时。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.196875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSllkLHHPvwzafVdDDsvk6lPxdJPUQ5M2uV0Cch5HD8LfnjWrjBGPJj0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;[GC&lt;/span&gt;&lt;span&gt; 或 &lt;/span&gt;&lt;span&gt;[FGC&lt;/span&gt;&lt;span&gt; 开头代表垃圾回收的类型；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;PSYoungGen: 6130K-&amp;gt;6130K(9216K)] 12274K-&amp;gt;14330K(19456K), 0.0034895 secs&lt;/span&gt;&lt;span&gt; 代表 YGC 前后内存使用情况；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Times: user=0.02 sys=0.00, real=0.00 secs&lt;/span&gt;&lt;span&gt;：user 表示用户态消耗的 CPU 时间，sys 表示内核态消耗的 CPU 时间，real 表示各种墙时钟的等待时间；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这两张图只是举例并没有关联关系。比如你从图里面看能到是否进行 FGC、FGC 的时间花费多长；GC 后老年代，年轻代内存是否有减少；得到一些初步的情况来做出判断。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. dump 出内存文件在具体分析。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如通过 jmap 命令 &lt;strong&gt;jmap -dump:format=b,file=dumpfile pid&lt;/strong&gt;。&lt;/span&gt;&lt;span&gt;导出之后再&lt;/span&gt;&lt;span&gt;通过 &lt;/span&gt;&lt;span&gt;Eclipse Memory Analyze&lt;/span&gt;&lt;span&gt;r &lt;/span&gt;&lt;span&gt;等工具进行分析，定位到代码、&lt;/span&gt;&lt;span&gt;修复。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里还会可能存在一个提问的点，比如 &lt;strong&gt;CPU 飙高，同时 FGC 怎么办&lt;/strong&gt;？办法比较类似：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;找到当前进程的 pid，&lt;strong&gt;top -p pid -H&lt;/strong&gt; 查看资源占用，找到问题线程；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;printf “%x\n” pid&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，把线程 pid 转为16进制，比如 0x32d；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;jstack pid|grep -A 10 0x32d &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;查看线程的堆栈日志，还找不到问题继续下一步；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;dump 出内存文件用 MAT 等工具进行分析，定位到代码、修复。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;10. JVM调优有什么经验吗？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;要明白一点，所有的调优的目的都是为了用更小的硬件成本达到更高的吞吐，JVM 的调优也是一样。通过对垃圾收集器和内存分配的调优达到性能的最佳。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;简单的参数含义&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，需要知道几个主要的参数含义。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlLWMnkcBxCTMcdsOu97iaiaSbOv87f3heq6PbIWTnZOtQIaEy96HZxj8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-Xms&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 设置初始堆的大小，&lt;strong&gt;-Xmx &lt;/strong&gt;设置最大堆的大小；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:NewSize&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 年轻代大小，&lt;strong&gt;-XX:MaxNewSize&lt;/strong&gt; 年轻代最大值，&lt;strong&gt;-Xmn&lt;/strong&gt; 则是相当于同时配置 -XX:NewSize 和 -XX:MaxNewSize 为一样的值；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:NewRatio&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 设置年轻代和年老代的比值。如果为3，表示年轻代与老年代比值为 1:3，默认值为2；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:SurvivorRatio&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 年轻代和两个 Survivor 的比值。默认值为8，代表比值为 8:1:1；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:PretenureSizeThreshold&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 当创建的对象超过指定大小时，直接把对象分配在老年代；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:MaxTenuringThreshold&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 设定对象在 Survivor 复制的最大年龄阈值，超过阈值转移到老年代；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:MaxDirectMemorySize&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 当 Direct ByteBuffer 分配的堆外内存到达指定大小后，即触发 Full GC。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;调优&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;为了打印日志方便排查问题最好开启GC日志。开启GC日志对性能影响微乎其微，但是能帮助我们快速排查定位问题。&lt;strong&gt;-XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:gc.log&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;一般设置 &lt;strong&gt;-Xms=-Xmx&lt;/strong&gt;。这样可以获得固定大小的堆内存，减少 GC 次数和耗时，可以使得堆相对稳定；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 让 JVM 在发生内存溢出的时候自动生成内存快照，方便排查问题；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;-Xmn&lt;/strong&gt; 设置新生代的大小。太小会增加 YGC，太大会减小老年代大小，一般设置为&lt;strong&gt;整个堆的1/4到1/3&lt;/strong&gt;；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;设置 &lt;strong&gt;-XX:+DisableExplicitGC &lt;/strong&gt;禁止系统 System.gc()。防止手动误触发 FGC 造成问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651482823&amp;amp;idx=1&amp;amp;sn=cd623fbfa900f1217b34d34f980b2e82&amp;amp;chksm=bd2506b88a528faea643840bb2613ae67252085c24faaba2359006cc37335dc4fe042f1ca66d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;关于 JVM 内存的 N 个问题&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651488039&amp;amp;idx=1&amp;amp;sn=b812f2bd8b3e0e7edfdb2bb6c050894e&amp;amp;chksm=bd2513588a529a4e02c41f59fa78adc2c064b48b112a5120d53687b8ee84aff87524acecb479&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;JVM 史上最最最完整深入解析&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651486318&amp;amp;idx=1&amp;amp;sn=a0bf7b6896cc30cff1581243193200fc&amp;amp;chksm=bd2514118a529d0769979c50eaac2c8b5fef25cb8fdf550d9e24534d211700d0bd6befae2b64&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Spring Boot项目优化和JVM调优&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;好文章，我&lt;/span&gt;&lt;span&gt;在看&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a71bbbcd3cc40b56f9a74c76fb5890eb</guid>
<title>资料 | 德勤 2020 技术趋势报告.pdf</title>
<link>https://toutiao.io/k/rpq9ju7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;大家好，我是周刊菌。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;「码农周刊 VIP 会员」推出 27 周啦！感谢亲们的大力支持！第 027 期「码农周刊 VIP 会员专属邮件周报」已发送完毕，请注意查收。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;告诉大家一个好消息&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：已有数位上市公司 CTO 低调订阅了我们的「码农周刊 VIP 会员专属邮件周报」，感谢肯定！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;255&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;255&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ7PeUupLzwuuAibicnrRNxKcfCY7fIva78efKsUzANlCCAeuSQEGkGm34rKkzNRpzy6IiaiaHmBNA6DcA/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1376&quot; data-ratio=&quot;1.464&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNav8ibRlj1geJpJpDuHReKErd27rYF2J1yDshJg9GTfTJTWoFmZEpH49OwwCFvRpSibv30kjnCiaQn4cOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;「码农周刊 VIP 会员」是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;简介版&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;码农周刊 VIP 会员 = 全年 52 期「VIP 会员专属邮件周报」 + 只限 VIP 会员加入的交流圈子 + 大厂「内推机会」 + N 多福利&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;详细版&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击「阅读原文」即可查看详细介绍&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;加入「码农周刊 VIP 会员」，与上市公司 CTO 一起成长！&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全年 52 期「VIP 会员专属邮件周报」 + 只限 VIP 会员加入的交流圈子 + 大厂「内推机会」 + N 多福利，你值得拥有！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;原价 365 元/年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;，现价仅需 108 元！&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;260&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;350&quot; data-ratio=&quot;1.3478260869565217&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ55lkiaIfFtAvQ7oklJLhfYEwMXeZORosBgxxRzEaXjYiapBSev2CQfYfl7kTiaFqsoiaicGyvcKIHzcSg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cd153723d43b8882b99246b5d652a572</guid>
<title>iOS 推送手机消息背后的技术</title>
<link>https://toutiao.io/k/qugr2s1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：allenzzhao，腾讯  IEG运营开发工程师&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;消息推送我们几乎每天都会用到，但你知道iOS中的消息推送是如何实现的吗？本文将从推送权限申请，到本地和远程消息推送，再到App对推送消息的处理等多个步骤，详细介绍iOS中消息推送的工作流程。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、概述&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息推送是一种App向用户传递信息的重要方式，无论App是否正在运行，只要用户打开了通知权限就能够收到推送消息。开发者通过调用iOS系统方法就可以发起本地消息推送，例如我们最常见的闹钟应用，App能够根据本地存储的闹钟信息直接发起本地通知，因此即使没有网络也能收到闹钟提醒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;远程消息推送则是由业务方服务器将消息内容按照固定格式发送到Apple Push Notitfication service（简称APNs），然后再经由苹果的APNs服务器推送到用户设备上，例如腾讯新闻可以向用户推送时事热点新闻，QQ邮箱可以为用户推送收到新邮件的提醒，游戏App可以通过这种方式通知玩家有新的游戏福利，既能够及时地通知用户重要信息，也能够促使用户通过推送消息打开或唤醒App，提高App的使用率。除了标题、内容、提示音和角标数字等固定推送参数以外，开发者还可以在推送消息中增加自定义参数，让用户在点击推送消息时能够直达相关新闻、邮件或福利页面，提供更好的用户体验和页面的曝光率。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5039761431411531&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavG0DSxsc5FX0j5x4DiaedflLFzncLjJKQWs7gW07mqep02wwLgxQEskexJmYGQa0sDPSHmVFQvWQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1006&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、XCode配置&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用消息推送相关功能之前，我们首先需要准备支持推送功能的证书，个人开发者可以参考&lt;a href=&quot;https://cloud.tencent.com/document/product/548/36664#.E6.AD.A5.E9.AA.A43.EF.BC.9A.E4.B8.8A.E4.BC.A0.E8.AF.81.E4.B9.A6.E5.88.B0-tpns-.E6.8E.A7.E5.88.B6.E5.8F.B0&quot; data-linktype=&quot;2&quot;&gt;腾讯云的TPNS文档&lt;/a&gt;，在苹果开发者中心中配置和导出推送证书。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，还需要在XCode的工程配置Signing &amp;amp; Capabilities配置中增加消息推送权限，在操作完成后Xcode会自动生成或更新工程的entitlements文件，增加如图所示的APS Environment字段。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7283406754772394&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavG0DSxsc5FX0j5x4Diaedfl15CEuEF0SQY8ib9IicdAJt6AfzGOxo7pQZKKKA1BrW16YWibICRTYib5Xg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;681&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.10337078651685393&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavG0DSxsc5FX0j5x4Diaedfl5p0BJdMLbUkx0BBeMuunn1MZAL4I7bBmOJ9icIUgibzENsV7uEGEsEvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1335&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3、申请消息推送权限&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6930147058823529&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavG0DSxsc5FX0j5x4DiaedflpglRcd7mU4lA7LfHoqopwPtkVRvml2LzTGag86p1d1FJw51zLUHeIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1088&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是本地推送还是远程推送，在推送前都必须要先向用户申请推送权限，只有用户授权后才能够收到推送消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;苹果在iOS10中引入了UserNotifications框架，将推送相关功能进行了封装和升级，除了以前UIApplication可以做到的一些基本的本地和远程消息推送功能外，还增加了撤回或修改推送消息、自定义通知UI、推送消息前台显示等功能。在iOS10及以上的版本中，苹果推荐开发者使用requestAuthorizationWithOptions:completionHandler:方法向用户申请消息推送权限，该方法需要指定一个用于描述推送权限的UNAuthorizationOptions类型参数，包括alert（消息的标题、文字等内容）、sound（消息提示音）、badge（App右上角显示的角标）；还可以在该方法的completionHandler回调方法中通过granted参数来判断用户是否允许了授权。相关代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#import &lt;span&gt;&amp;lt;UserNotifications/UserNotifications.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;……&lt;br/&gt;[[UNUserNotificationCenter currentNotificationCenter]&lt;br/&gt;requestAuthorizationWithOptions:UNAuthorizationOptionSound|UNAuthorizationOptionAlert|UNAuthorizationOptionBadge&lt;br/&gt;completionHandler:^(&lt;span&gt;BOOL&lt;/span&gt; granted, &lt;span&gt;NSError&lt;/span&gt; * _Nullable error) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(granted){&lt;br/&gt;        &lt;span&gt;//用户允许了推送权限申请&lt;/span&gt;&lt;br/&gt;    }&lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//用户拒绝了推送权限申请&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在iOS9中，直接使用UIApplication的registerUserNotificationSettings方法即可，该方法同样需要通过配置sound、alert、badge等参数，但是没有提供用于判断用户点击了授权还是拒绝的回调方法。相关代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[[&lt;span&gt;UIApplication&lt;/span&gt; sharedApplication] registerUserNotificationSettings:&lt;br/&gt; [&lt;span&gt;UIUserNotificationSettings&lt;/span&gt; settingsForTypes:&lt;br/&gt;  (&lt;span&gt;UIUserNotificationTypeSound&lt;/span&gt; | &lt;span&gt;UIUserNotificationTypeAlert&lt;/span&gt; | &lt;span&gt;UIUserNotificationTypeBadge&lt;/span&gt;)&lt;br/&gt;                                   categories:&lt;span&gt;nil&lt;/span&gt;]];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要注意无论是UserNotifications还是UIApplication的申请推送权限的方法，上文中的申请用户授权的系统弹窗都只会显示一次，iOS会记录用户对于该App的授权状态，不会向用户重复申请授权。消息推送是App的一项重要功能，同时也是很好的运营手段，因此很多App在启动后会检查消息推送的授权状态，如果用户拒绝了消息推送权限，仍然会以一定的频率弹窗提醒用户，在iOS的设置中心中再去打开App的推送权限。相关代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;(@available(iOS &lt;span&gt;10.0&lt;/span&gt;,*)){&lt;br/&gt;    [[UNUserNotificationCenter currentNotificationCenter] getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (UNAuthorizationStatusDenied == settings.authorizationStatus) {&lt;br/&gt;            &lt;span&gt;//用户拒绝消息推送，弹窗提示引导用户去系统设置中进行授权&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;UIAlertController&lt;/span&gt;* alert = [&lt;span&gt;UIAlertController&lt;/span&gt; alertControllerWithTitle:&lt;span&gt;@&quot;未打开推送功能&quot;&lt;/span&gt; message:&lt;span&gt;@&quot;请在设备的\&quot;设置-App-通知\&quot;选项中，允许通知&quot;&lt;/span&gt; preferredStyle:&lt;span&gt;UIAlertControllerStyleAlert&lt;/span&gt;];&lt;br/&gt;            &lt;span&gt;UIAlertAction&lt;/span&gt;* cancel = [&lt;span&gt;UIAlertAction&lt;/span&gt; actionWithTitle:&lt;span&gt;@&quot;取消&quot;&lt;/span&gt; style:&lt;span&gt;UIAlertActionStyleCancel&lt;/span&gt; handler:^(&lt;span&gt;UIAlertAction&lt;/span&gt;* action){&lt;br/&gt;                [alert dismissViewControllerAnimated: &lt;span&gt;YES&lt;/span&gt; completion: &lt;span&gt;nil&lt;/span&gt;];&lt;br/&gt;            }];&lt;br/&gt;            &lt;span&gt;UIAlertAction&lt;/span&gt;* ok = [&lt;span&gt;UIAlertAction&lt;/span&gt; actionWithTitle:&lt;span&gt;@&quot;去设置&quot;&lt;/span&gt; style:&lt;span&gt;UIAlertActionStyleDefault&lt;/span&gt; handler:^(&lt;span&gt;UIAlertAction&lt;/span&gt;* action){&lt;br/&gt;                [alert dismissViewControllerAnimated: &lt;span&gt;YES&lt;/span&gt; completion: &lt;span&gt;nil&lt;/span&gt;];&lt;br/&gt;                &lt;span&gt;NSURL&lt;/span&gt; * url = [&lt;span&gt;NSURL&lt;/span&gt; URLWithString:&lt;span&gt;UIApplicationOpenSettingsURLString&lt;/span&gt;];&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt;([[&lt;span&gt;UIApplication&lt;/span&gt; sharedApplication] canOpenURL:url])&lt;br/&gt;                {&lt;br/&gt;                    &lt;span&gt;NSURL&lt;/span&gt;*url =[&lt;span&gt;NSURL&lt;/span&gt; URLWithString:&lt;span&gt;UIApplicationOpenSettingsURLString&lt;/span&gt;];&lt;br/&gt;                    [[&lt;span&gt;UIApplication&lt;/span&gt; sharedApplication] openURL:url];&lt;br/&gt;                }&lt;br/&gt;            }];&lt;br/&gt;            [alert addAction: cancel];&lt;br/&gt;            [alert addAction: ok];&lt;br/&gt;            [[&lt;span&gt;UIApplication&lt;/span&gt; sharedApplication].keyWindow.rootViewController presentViewController:alert animated: &lt;span&gt;YES&lt;/span&gt; completion: &lt;span&gt;nil&lt;/span&gt;];&lt;br/&gt;        }&lt;br/&gt;    }];&lt;br/&gt;}&lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;UIUserNotificationSettings&lt;/span&gt; *setting = [[&lt;span&gt;UIApplication&lt;/span&gt; sharedApplication] currentUserNotificationSettings];&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;UIUserNotificationTypeNone&lt;/span&gt; == setting.types) {&lt;br/&gt;        &lt;span&gt;//用户拒绝消息推送，处理方式同上&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4、本地推送&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9419588875453446&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavG0DSxsc5FX0j5x4DiaedflKTHLBPIBbNP4lZ2I66v0ibCU1wrA8K6brNib4BCzQXIIFuWjbd2YXP3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;827&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在iOS10中，UserNotifications框架为我们提供了UNMutableNotificationContent对象描述消息推送的标题、内容、提示音、角表等内容，UNNotificationTrigger对象描述消息推送的推送时间策略，UNNotificationRequest对象整合推送内容和时间。每个Request对象都需要配置一个id来标识该条推送内容，UNUserNotificationCenter通过该id来管理（包括增加、删除、查询和修改）所有的Request。UNNotificationTrigger有四个子类，分别是UNTimeIntervalNotificationTrigger用于通过时间间隔控制消息推送，UNCalendarNotificationTrigger通过日期控制消息推送，UNLocationNotificationTrigger通过地理位置控制消息推送，UNPushNotificationTrigger远程消息推送对象。相关代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//推送内容&lt;/span&gt;&lt;br/&gt;UNMutableNotificationContent* content = [[UNMutableNotificationContent alloc] init];&lt;br/&gt;content.title = &lt;span&gt;@&quot;推送标题&quot;&lt;/span&gt;;&lt;br/&gt;content.body = &lt;span&gt;@&quot;推送内容&quot;&lt;/span&gt;;&lt;br/&gt;content.sound = [UNNotificationSound defaultSound];&lt;span&gt;//默认提示音&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//日期推送，今日15:53:00推送本地消息&lt;/span&gt;&lt;br/&gt;&lt;span&gt;NSDateComponents&lt;/span&gt;* date = [[&lt;span&gt;NSDateComponents&lt;/span&gt; alloc] init];&lt;br/&gt;date.hour = &lt;span&gt;15&lt;/span&gt;;&lt;br/&gt;date.minute = &lt;span&gt;53&lt;/span&gt;;&lt;br/&gt;UNCalendarNotificationTrigger* calendarTrigger = [UNCalendarNotificationTrigger&lt;br/&gt;       triggerWithDateMatchingComponents:date repeats:&lt;span&gt;NO&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;//倒计时推送，2s后推送本地消息&lt;/span&gt;&lt;br/&gt;UNTimeIntervalNotificationTrigger *intervalTrigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:&lt;span&gt;2&lt;/span&gt; repeats:&lt;span&gt;NO&lt;/span&gt;];&lt;br/&gt;UNNotificationRequest* request = [UNNotificationRequest&lt;br/&gt;       requestWithIdentifier:&lt;span&gt;@&quot;testId&quot;&lt;/span&gt; content:content trigger:calendarTrigger];&lt;br/&gt;&lt;span&gt;//将推送请求添加到管理中心才会生效&lt;/span&gt;&lt;br/&gt;UNUserNotificationCenter* center = [UNUserNotificationCenter currentNotificationCenter];&lt;br/&gt;[center addNotificationRequest:request withCompletionHandler:^(&lt;span&gt;NSError&lt;/span&gt; * _Nullable error) {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (error != &lt;span&gt;nil&lt;/span&gt;) {&lt;br/&gt;       &lt;span&gt;NSLog&lt;/span&gt;(&lt;span&gt;@&quot;%@&quot;&lt;/span&gt;, error.localizedDescription);&lt;br/&gt;   }&lt;br/&gt;}];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在iOS9中，UIApplication提供了presentLocalNotificationNow和scheduleLocalNotification两个本地消息推送的方法，分别表示立即推送和按照固定日期推送，UILocalNotification同时描述了消息内容和推送的时机。示例代码是一个2s后推送的本地消息，soundName属性用于描述消息的提示音，用户可以自定义提示音（需要将音频文件打包到安装包中）或者使用默认提示音乐，repeatInterval和repeatCalendar属性分别用于根据时间差和日期进行重复提示的操作。相关代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;UILocalNotification&lt;/span&gt; *notification = [[&lt;span&gt;UILocalNotification&lt;/span&gt; alloc] init];&lt;br/&gt;notification.fireDate = [&lt;span&gt;NSDate&lt;/span&gt; dateWithTimeIntervalSinceNow:&lt;span&gt;2&lt;/span&gt;];&lt;br/&gt;notification.alertTitle = &lt;span&gt;@&quot;推送标题&quot;&lt;/span&gt;;&lt;br/&gt;notification.alertBody = &lt;span&gt;@&quot;推送内容&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//notification.soundName = UILocalNotificationDefaultSoundName;&lt;/span&gt;&lt;br/&gt;notification.soundName = &lt;span&gt;@&quot;mysound.wav&quot;&lt;/span&gt;;&lt;br/&gt;[[&lt;span&gt;UIApplication&lt;/span&gt; sharedApplication] scheduleLocalNotification:notification];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5、远程推送&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9770531400966184&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavG0DSxsc5FX0j5x4DiaedflosIfpBZgh26icWOTUM8xenSzuCTmzc93wsaE1rEea8Jle61kC9ibZWTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同于本地消息推送不依赖网络请求，可以直接调用iOS系统方法，远程消息推送的实现涉及到用户设备、我们自己的业务方服务器和苹果的APNs服务的交互。不同于Android系统中远程消息推送的实现，需要App自身通过后台服务与业务服务器维持长链接通信，iOS中的消息推送是操作系统与苹果的APNs服务器直接交互实现的，App自身并不需要维持与服务器的连接。只要用户开启了推送权限，我们的业务服务器就可以随时通过调用APNs服务向用户推送通知，这样既能够为开发者和用户提供安全稳定的推送服务，也够节省系统资源消耗，提高系统流畅度和电池续航能力。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.527831094049904&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavG0DSxsc5FX0j5x4Diaedfl7wJdk5CPK0cTbm1vvWW3BhMEDMMhyyhQhD9vibz9rIc99wMSYznSXOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2084&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;iOS客户端远程消息推送的实现可以分为以下几个流程：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户的iphone通过iOS的系统方法调用与苹果的APNs服务器通信，获取设备的deviceToken，它是由APNs服务分配的用于唯一标识不同设备上的不同App，可以认为是由deviceID、bundleId和安装时的相关信息生成的，App的升级操作deviceToken不变，卸载重装App、恢复和重装操作系统后的deviceToken会发生变化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;苹果的APNs服务是基于deviceToken实现的，因此需要将设备的deviceToken发送到我们的业务服务器中，用于后续的消息推送。一个设备可能登录过多个用户，一个用户也可能在多个设备中登录过，当我们需要给不同用户推送不同的消息时，除了deviceToken之外，我们还需要保存用户的openid与deviceToken的映射关系。我们可以在用户登录成功后的时机更新openid和deviceToken的映射关系，用户退出后取消映射关系，只保存用户最后登录设备的deviceToken，避免一个设备收到多个重复通知和一个用户在不同设备收到多个通知等情况。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在新闻类App出现事实热点新闻时，后台服务就可以携带消息内容和deviceToken等内容，向苹果的APNs服务发起消息推送请求，推送消息的实现是异步的，只要请求格式和deviceToken检查通过APNs服务就不会报错，但是用户还是可能因为网络异常或者关闭了推送权限等原因收不到推送消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;APNs服务向用户设备推送消息这一步也是异步的，在用户关机或网络异常收不到推送的情况下，APNs会为每个deviceToken保留最后一条推送消息，待网络恢复后再次推送。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.1、获取设备deviceToken&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在App启动时，我们可以通过UIApplication的registerForRemoteNotifications方法向苹果的APNS服务器请求deviceToken，如果请求成功则didRegisterForRemoteNotificationsWithDeviceToken回调方法会被执行，为了便于业务服务器的调用，我们一般会将二进制的deviceToken转换为16进制的字符串后再进行存储；如果请求失败则didFailToRegisterForRemoteNotificationsWithError方法也会被调用，并附带具体的错误信息。相关代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//调用系统方法请求deviceToken&lt;/span&gt;&lt;br/&gt;- (&lt;span&gt;BOOL&lt;/span&gt;)application:(&lt;span&gt;UIApplication&lt;/span&gt; *)application didFinishLaunchingWithOptions:(&lt;span&gt;NSDictionary&lt;/span&gt; *)launchOptions {&lt;br/&gt;    [[&lt;span&gt;UIApplication&lt;/span&gt; sharedApplication] registerForRemoteNotifications];&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//deviceToken获取成功的回调&lt;/span&gt;&lt;br/&gt;- (&lt;span&gt;void&lt;/span&gt;)application:(&lt;span&gt;UIApplication&lt;/span&gt; *)application didRegisterForRemoteNotificationsWithDeviceToken:(&lt;span&gt;NSData&lt;/span&gt; *)deviceToken{&lt;br/&gt;    &lt;span&gt;NSString&lt;/span&gt; *deviceTokenStr;&lt;br/&gt;    &lt;span&gt;NSUInteger&lt;/span&gt; length = deviceToken.length;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (![deviceToken isKindOfClass:[&lt;span&gt;NSData&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;]] || length == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *bytes = (&lt;span&gt;const&lt;/span&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *)deviceToken.bytes;&lt;br/&gt;    &lt;span&gt;NSMutableString&lt;/span&gt; *hex = [&lt;span&gt;NSMutableString&lt;/span&gt; new];&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;NSInteger&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; deviceToken.length; i++) {&lt;br/&gt;        [hex appendFormat:&lt;span&gt;@&quot;%02x&quot;&lt;/span&gt;, bytes[i]];&lt;br/&gt;    }&lt;br/&gt;    deviceTokenStr = [hex &lt;span&gt;copy&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;NSLog&lt;/span&gt;(&lt;span&gt;@&quot;%@&quot;&lt;/span&gt;, deviceTokenStr);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//deviceToken获取失败的回调&lt;/span&gt;&lt;br/&gt;- (&lt;span&gt;void&lt;/span&gt;)application:(&lt;span&gt;UIApplication&lt;/span&gt; *)application didFailToRegisterForRemoteNotificationsWithError:(&lt;span&gt;NSError&lt;/span&gt; *)error{&lt;br/&gt;    &lt;span&gt;NSLog&lt;/span&gt;(&lt;span&gt;@&quot;error,%@&quot;&lt;/span&gt;,error);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.2、后台调用APNs推送&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务方服务器调用APNs服务时首先要建立安全连接，进行开发者身份的认证，分为基于证书（Certificate-Based）和基于Token（Token-Based）的认证两种方式，比较常用的是基于证书的认证方式。推送证书分为开发环境和生产环境的证书，分别对应不同的APNs推送接口，我们从苹果开发者平台或者第三方平台导出的推送证书一般有p12和pem两种格式的文件，为了便于接口调用我们可以通过以下命令将p12格式的文件转换为pem证书。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;openssl pkcs12 -&lt;span&gt;in&lt;/span&gt; push_dev.p12 -&lt;span&gt;out&lt;/span&gt; push_dev.pem -nodes&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于证书建立TLS连接的流程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6738402678144428&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavG0DSxsc5FX0j5x4DiaedflibBy1x6TW3d8z2dibuSJU6fIAY6WV4zcKORTjLeLOBwVrdWLErXZScOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2091&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;业务方服务器（Provider）向APNs服务器发起建立TLS连接的请求。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;APNs服务器返回的它的证书，供业务方服务器校验。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务方服务器提供自己的推送证书，供APNs服务器校验。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;APNs服务器验证业务方服务器提供的推送证书无误后，TLS连接就已经建立完成，之后业务方服务器就可以直接向APNs发送消息推送请求了。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务方与APNs建立请求的简易实现的PHP代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$deviceToken= &lt;span&gt;&#x27;22124c450762170ca2ddb32a50381dd2c3026dbdb020f6dddcabefdca724fdd6&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//dev params&lt;/span&gt;&lt;br/&gt;$devUrl = &lt;span&gt;&#x27;ssl://gateway.sandbox.push.apple.com:2195&#x27;&lt;/span&gt;;&lt;br/&gt;$devCertificate = &lt;span&gt;&#x27;push_dev.pem&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//product params&lt;/span&gt;&lt;br/&gt;$proUrl = &lt;span&gt;&#x27;ssl://gateway.push.apple.com:2195&#x27;&lt;/span&gt;;&lt;br/&gt;$proCertificate = &lt;span&gt;&#x27;push_pro.pem&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;// Change 2 : If any&lt;/span&gt;&lt;br/&gt;$title = &lt;span&gt;&#x27;标题&#x27;&lt;/span&gt;;&lt;span&gt;//消息标题&lt;/span&gt;&lt;br/&gt;$content = &lt;span&gt;&#x27;消息内容&#x27;&lt;/span&gt;;&lt;span&gt;//内容&lt;/span&gt;&lt;br/&gt;$ctx = stream_context_create();&lt;br/&gt;&lt;span&gt;// Change 3 : APNS Cert File name and location.&lt;/span&gt;&lt;br/&gt;stream_context_set_option($ctx, &lt;span&gt;&#x27;ssl&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;local_cert&#x27;&lt;/span&gt;, $devCertificate);&lt;br/&gt;&lt;span&gt;// Open a connection to the APNS server&lt;/span&gt;&lt;br/&gt;$fp = stream_socket_client($devUrl, $err, $errstr, &lt;span&gt;60&lt;/span&gt;, STREAM_CLIENT_CONNECT|STREAM_CLIENT_PERSISTENT, $ctx);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (!$fp)&lt;br/&gt;    &lt;span&gt;exit&lt;/span&gt;(&lt;span&gt;&quot;Failed to connect: $err $errstr&quot;&lt;/span&gt; . PHP_EOL);&lt;br/&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&#x27;Connected to APNS&#x27;&lt;/span&gt; . PHP_EOL;&lt;br/&gt;&lt;span&gt;// Create the payload body&lt;/span&gt;&lt;br/&gt;$body[&lt;span&gt;&#x27;aps&#x27;&lt;/span&gt;] = &lt;span&gt;array&lt;/span&gt;(&lt;br/&gt;    &lt;span&gt;&#x27;alert&#x27;&lt;/span&gt; =&amp;gt;&lt;span&gt;array&lt;/span&gt;(&lt;br/&gt;        &lt;span&gt;&#x27;title&#x27;&lt;/span&gt;=&amp;gt;$title,&lt;br/&gt;        &lt;span&gt;&#x27;body&#x27;&lt;/span&gt;=&amp;gt;$content&lt;br/&gt;    ),&lt;br/&gt;    &lt;span&gt;&#x27;sound&#x27;&lt;/span&gt; =&amp;gt; &lt;span&gt;&#x27;default&#x27;&lt;/span&gt;&lt;br/&gt;    );&lt;br/&gt;&lt;span&gt;//自定义内容&lt;/span&gt;&lt;br/&gt;$body[&lt;span&gt;&#x27;userInfo&#x27;&lt;/span&gt;] = &lt;span&gt;array&lt;/span&gt;(&lt;br/&gt;    &lt;span&gt;&#x27;url&#x27;&lt;/span&gt; =&amp;gt; &lt;span&gt;&#x27;https://www.qq.com&#x27;&lt;/span&gt;,&lt;br/&gt;);&lt;br/&gt;&lt;span&gt;// Encode the payload as JSON&lt;/span&gt;&lt;br/&gt;$payload = json_encode($body);&lt;br/&gt;&lt;span&gt;// Build the binary notification&lt;/span&gt;&lt;br/&gt;$msg = chr(&lt;span&gt;0&lt;/span&gt;) . pack(&lt;span&gt;&#x27;n&#x27;&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;) . pack(&lt;span&gt;&#x27;H*&#x27;&lt;/span&gt;, $deviceToken) . pack(&lt;span&gt;&#x27;n&#x27;&lt;/span&gt;, strlen($payload)) . $payload;&lt;br/&gt;&lt;span&gt;// Send it to the server&lt;/span&gt;&lt;br/&gt;$result = fwrite($fp, $msg, strlen($msg));&lt;br/&gt;&lt;span&gt;//发送多个就调用多次fwrite&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//$result = fwrite($fp, $msg, strlen($msg));&lt;/span&gt;&lt;br/&gt;&lt;span&gt;echo&lt;/span&gt; $msg;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (!$result)&lt;br/&gt;    &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&#x27;Message not delivered&#x27;&lt;/span&gt; . PHP_EOL;&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&#x27;Message successfully delivered&#x27;&lt;/span&gt; . PHP_EOL;&lt;br/&gt;&lt;span&gt;// Close the connection to the server&lt;/span&gt;&lt;br/&gt;fclose($fp);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务方服务器通过证书与APNs建立安全连接后可以进行连续多次的消息推送操作，每次消息推送都要指定deviceToken和Payload参数。Payload是一个json对象，用于配置iOS在收到远程消息推送时的展现形式，aps参数包含了苹果预设的alert、sound、badge等参数，其中alert参数可以是字符串，或者包含title、body等参数的字典类型；badge参数使用整形设置App图标右上角显示的数字，badge设置为0时角标不会显示；sound参数用于设置推送的声音，不传该参数或者传递空字符串则推送不会发出提示音，设置为default时使用系统默认提示音，也可以设置为具体的音频文件名，需要提前音频文件放到项目的bundle目录，且时长不能超过30s。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了预设参数以外，我们还可以在aps的同级自定义一些参数，这些参数也可以是字典类型，再嵌套其他参数，例如示例代码中我们自定义的userInfo对象，但是一般推送消息的payload不宜过大，应控制在4K以内，建议只透传一些id和url等关键参数，具体的内容由客户端在收到推送时再去通过网络请求获取。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;    &lt;span&gt;&quot;aps&quot;&lt;/span&gt; : {&lt;br/&gt;        &lt;span&gt;&quot;alert&quot;&lt;/span&gt; : {&lt;br/&gt;            &lt;span&gt;&quot;title&quot;&lt;/span&gt; : &lt;span&gt;&quot;Game Request&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;subtitle&quot;&lt;/span&gt; : &lt;span&gt;&quot;Five Card Draw&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;body&quot;&lt;/span&gt; : &lt;span&gt;&quot;Bob wants to play poker&quot;&lt;/span&gt;,&lt;br/&gt;        },&lt;br/&gt;        &lt;span&gt;&quot;badge&quot;&lt;/span&gt; : &lt;span&gt;9&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;sound&quot;&lt;/span&gt; : &lt;span&gt;&quot;gameMusic.wav&quot;&lt;/span&gt;,&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;&quot;gameID&quot;&lt;/span&gt; : &lt;span&gt;&quot;12345678&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述payload包含了常见的推送消息的标题、副标题、内容、消息提示音、App的角标数字等预设参数，以及一个开发者自定义的gameID参数。用户点击推送消息后会自动启动或从后台唤醒App，我们可以在系统的回调方法中获取到自定义参数，并根据gameID自动为用户打开该游戏页面。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.3、消息推送调试工具&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在进行APNs接口调试时，我们可以利用一些优秀的推送调试工具帮助我们验证payload或证书等内容的合法性。本文介绍两款比较流行的开源软件，分别是国外的Knuff和国内开发者维护的smartPush。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9854327335047129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavG0DSxsc5FX0j5x4Diaedfl4wMsXehKLMMzMiaM40bDvdqw6OlUNcEJwSDJydyk74iaaKHjzO6lYDlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1167&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Knuff：https://github.com/KnuffApp/Knuff&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SmartPush：https://github.com/shaojiankui/SmartPush&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6、App推送消息的处理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在iOS10中，UserNotifications框架为开发者提供了UNUserNotificationCenterDelegate协议，开发者可以通过实现协议中的方法，在App接收到推送消息和用户点击推送消息时进行一些业务逻辑的处理。无论是本地推送还是远程推送的消息，App的运行状态都可能处于以下三种状态：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;App正在前台运行，此时用户正在使用App，收到推送消息时默认不会弹出消息提示框，willPresentNotification回调方法会被调用，开发者可以从UNNotification对象中获取该推送消息的payload内容，进而获取自定义参数，然后显示一个自定义弹窗提示用户收到了新的消息；也可以在willPresentNotification方法中通过completionHandler函数的调用让推送消息直接在前台显示，用户点击前台显示的推送消息时，didReceiveNotificationResponse回调方法也会被执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;App在后台运行，此时用户点击推送消息会将App从后台唤醒，didReceiveNotificationResponse回调方法会被执行，开发者可以在该方法中获得payload，解析自定义参数并自动打开对应的页面。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;App尚未启动，此时用户点击推送消息会打开App，开发者可以从launchOptions中获取本地或远程推送消息中的自定义参数，待页面初始化完成后进行相关页面的跳转。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#import &lt;span&gt;&amp;lt;UserNotifications/UserNotifications.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;@interface&lt;/span&gt; &lt;span&gt;AppDelegate&lt;/span&gt; ()&amp;lt;&lt;span&gt;UNUserNotificationCenterDelegate&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@end&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;@implementation&lt;/span&gt; &lt;span&gt;AppDelegate&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//在App启动后就将AppDelegate对象配置为NotificationCenter的delegate&lt;/span&gt;&lt;br/&gt;- (&lt;span&gt;BOOL&lt;/span&gt;)application:(&lt;span&gt;UIApplication&lt;/span&gt; *)application didFinishLaunchingWithOptions:(&lt;span&gt;NSDictionary&lt;/span&gt; *)launchOptions {&lt;br/&gt;    [UNUserNotificationCenter currentNotificationCenter].delegate = &lt;span&gt;self&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;// NSDictionary *localNotification = [launchOptions valueForKey:UIApplicationLaunchOptionsLocalNotificationKey];&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;NSDictionary&lt;/span&gt; *remoteNotification = [launchOptions valueForKey:&lt;span&gt;UIApplicationLaunchOptionsRemoteNotificationKey&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(remoteNotification){&lt;br/&gt;        &lt;span&gt;//app已退出，点击拉起了app&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;NSDictionary&lt;/span&gt; *params = userInfo[&lt;span&gt;@&quot;userInfo&quot;&lt;/span&gt;];&lt;br/&gt;        &lt;span&gt;//此时NavigationController还未初始化，可以先暂存参数，稍后跳转&lt;/span&gt;&lt;br/&gt;        [PageSwitch handlePushSwitch:params];&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//用户点击推送消息的回调&lt;/span&gt;&lt;br/&gt;- (&lt;span&gt;void&lt;/span&gt;)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(&lt;span&gt;void&lt;/span&gt; (^)(&lt;span&gt;void&lt;/span&gt;))completionHandler API_AVAILABLE(ios(&lt;span&gt;10.0&lt;/span&gt;)){&lt;br/&gt;    UNNotification *noti = ((UNNotificationResponse *)response).notification;&lt;br/&gt;    &lt;span&gt;NSDictionary&lt;/span&gt; *userInfo = noti.request.content.userInfo;&lt;br/&gt;    &lt;span&gt;NSDictionary&lt;/span&gt; *params = userInfo[&lt;span&gt;@&quot;userInfo&quot;&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;//根据消息推送中的参数，在用户点击推送时自动进行跳转&lt;/span&gt;&lt;br/&gt;    [PageSwitch handlePushSwitch:params];&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//App在前台运行时收到推送消息的回调&lt;/span&gt;&lt;br/&gt;- (&lt;span&gt;void&lt;/span&gt;)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(&lt;span&gt;nonnull&lt;/span&gt; UNNotification *)notification withCompletionHandler:(&lt;span&gt;nonnull&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; (^)(UNNotificationPresentationOptions))completionHandler API_AVAILABLE(ios(&lt;span&gt;10.0&lt;/span&gt;)){&lt;br/&gt;    &lt;span&gt;//可以让App在前台运行时也能收到推送消息&lt;/span&gt;&lt;br/&gt;    completionHandler(UNNotificationPresentationOptionBadge|UNNotificationPresentationOptionAlert);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在iOS9中，UIApplication提供了下面三个消息推送的处理方法，分别是远程消息推送、远程静默推送和本地消息推送的回调处理方法。前两个回调方法都能够用于App远程消息推送的处理，同时使用时只有远程静默推送方法会被调用，当payload包含参数content-available=1时，该推送就是静默推送，静默推送不会显示任何推送消息，当App在后台挂起时，静默推送的回调方法会被执行，开发者有30s的时间内在该回调方法中处理一些业务逻辑，并在处理完成后调用fetchCompletionHandler。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//远程消息推送回调方法，ios(3.0, 10.0)&lt;/span&gt;&lt;br/&gt;- (&lt;span&gt;void&lt;/span&gt;)application:(&lt;span&gt;UIApplication&lt;/span&gt; *)application didReceiveRemoteNotification:(&lt;span&gt;NSDictionary&lt;/span&gt; *)userInfo;&lt;br/&gt;&lt;span&gt;//远程静默推送回调方法，ios(7.0, *)&lt;/span&gt;&lt;br/&gt;- (&lt;span&gt;void&lt;/span&gt;)application:(&lt;span&gt;UIApplication&lt;/span&gt; *)application didReceiveRemoteNotification:(&lt;span&gt;NSDictionary&lt;/span&gt; *)userInfo &lt;br/&gt;    fetchCompletionHandler:(&lt;span&gt;void&lt;/span&gt; (^)(&lt;span&gt;UIBackgroundFetchResult&lt;/span&gt; result))completionHandler API_AVAILABLE(ios(&lt;span&gt;7.0&lt;/span&gt;));&lt;br/&gt;&lt;span&gt;//本地消息推送回调方法，ios(4.0, 10.0)&lt;/span&gt;&lt;br/&gt;-(&lt;span&gt;void&lt;/span&gt;)application:(&lt;span&gt;UIApplication&lt;/span&gt; *)application didReceiveLocalNotification:(&lt;span&gt;UILocalNotification&lt;/span&gt; *)notification;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;UIApplication中的这三个方法在：①App在前台运行时收到通知，②App在后台运行时用户点击推送消息拉起App，这两种场景下都会被调用，区别是前两种方法对应远程消息推送的接收和点击触发响应，didReceiveLocalNotification用于本地消息推送。我们可以通过UIApplication的applicationState属性来判断App是否在前台运行，然后分别实现：①用户点击消息唤起后台App并打开对应页面，②用户前台使用App时显示自定义弹窗。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;- (&lt;span&gt;void&lt;/span&gt;)application:(&lt;span&gt;UIApplication&lt;/span&gt; *)application didReceiveRemoteNotification:(&lt;span&gt;NSDictionary&lt;/span&gt; *)userInfo{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;([&lt;span&gt;UIApplication&lt;/span&gt; sharedApplication].applicationState == &lt;span&gt;UIApplicationStateActive&lt;/span&gt;){&lt;br/&gt;        &lt;span&gt;NSLog&lt;/span&gt;(&lt;span&gt;@&quot;在前台,%@&quot;&lt;/span&gt;,userInfo);&lt;br/&gt;    }&lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;NSLog&lt;/span&gt;(&lt;span&gt;@&quot;从后台进入前台，%@&quot;&lt;/span&gt;,userInfo);&lt;br/&gt;        &lt;span&gt;NSDictionary&lt;/span&gt; *params = userInfo[&lt;span&gt;@&quot;userInfo&quot;&lt;/span&gt;];&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;([Tools isValidString:params[&lt;span&gt;@&quot;url&quot;&lt;/span&gt;]]){&lt;br/&gt;            &lt;span&gt;NSString&lt;/span&gt; *routeUrl = params[&lt;span&gt;@&quot;url&quot;&lt;/span&gt;];&lt;br/&gt;            [PageSwitch handlePushSwitch:params];&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7、总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文首先介绍了消息推送相关的工程配置和推送权限的申请，然后分别介绍了本地和远程消息推送的不同使用场景和实现方法，最后介绍了App在收到推送消息后的相关回调方法和处理逻辑。在实际的项目开发中，我们往往会选择腾讯云推送或极光推送等更加成熟的第三方消息推送平台，这些平台都提供了相对完善的推送和数据统计服务，通过接口和SDK屏蔽了底层逻辑的实现，通过对iOS消息推送的实现过程的了解也能够帮助我们更好的使用这些平台。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于时间的关系，自己的研究并不深入，如有疏漏和错误，欢迎留言指正交流～&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8、扩展阅读&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;苹果官方技术文档，&lt;/span&gt;&lt;a href=&quot;https://developer.apple.com/documentation/usernotifications?language=objc&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;https://developer.apple.com/documentation/usernotifications&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;史上最全iOS Push技术详解，https://cloud.tencent.com/developer/article/1198303&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;iOS远程推送-APNs详解，https://juejin.im/post/6844903893592178696&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;iOS静默推送进阶知识，https://www.jianshu.com/p/c211bd295d58&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;iOS10自定义通知UI，https://www.jianshu.com/p/85ac47bdf387&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;信鸽文档-推送服务介绍，https://xg.qq.com/docs/ios_access/ios_push_introduction.html&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;浅谈iOS和Android后台实时消息推送的原理和区别，https://cloud.tencent.com/developer/article/1150967&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;浅谈基于HTTP2推送消息到APNs，http://www.linkedkeeper.com/167.html&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;PHP基于socket的ios 推送的实现，https://www.fzb.me/2015-9-7-sockect-implement-for-apns.html&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如何构建一套高可用的移动消息推送平台？，https://www.infoq.cn/article/HA-mobile-message-push-platform&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.729264475743349&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvatricjRxhpM1x45aB6doaVg7WMhINPwOiaqpskia1kH7hgibO0dicW2HLcW8HRGMzESQwehIcyckLXtwsA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;639&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ae142a618bf7aaefa787793932950838</guid>
<title>内存泄露的原因找到了，罪魁祸首居然是 Java TheadLocal</title>
<link>https://toutiao.io/k/bu7zyjd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ThreadLocal使用不规范，师傅两行泪&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;组内来了一个实习生，看这小伙子春光满面、精神抖擞、头发微少，我心头一喜：绝对是个潜力股。于是我找经理申请亲自来带他，为了帮助小伙子快速成长，我给他分了一个需求，这不需求刚上线几天就出网上问题了😭后台监控服务发现内存一直在缓慢上升，初步怀疑是内存泄露。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把实习生的PR都找出来仔细review，果然发现问题了。由于公司内部代码是保密的，这里简单写一个demo还原场景（忽略代码风格问题）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadPoolDemo&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadPoolExecutor poolExecutor = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, TimeUnit.MINUTES, &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&amp;gt;());&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; ++i) {&lt;br/&gt;            poolExecutor.execute(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;                &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                    ThreadLocal&amp;lt;BigObject&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;                    threadLocal.set(&lt;span&gt;new&lt;/span&gt; BigObject());&lt;br/&gt;                    &lt;span&gt;// 其他业务代码&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;            });&lt;br/&gt;            Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BigObject&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 100M&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;100&lt;/span&gt; * &lt;span&gt;1024&lt;/span&gt; * &lt;span&gt;1024&lt;/span&gt;];&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码分析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;创建一个核心线程数和最大线程数都为10的线程池，保证线程池里一直会有10个线程在运行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用for循环向线程池中提交了100个任务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;定义了一个ThreadLocal类型的变量，Value类型是大对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个任务会向threadLocal变量里塞一个大对象，然后执行其他业务逻辑。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于没有调用线程池的shutdown方法，线程池里的线程还是会在运行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;乍一看这代码好像没有什么问题，那为什么会导致服务GC后内存还高居不下呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码中给threadLocal赋值了一个大的对象，但是执行完业务逻辑后没有调用remove方法，最后导致线程池中10个线程的threadLocals变量中包含的大对象没有被释放掉，出现了内存泄露。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家说说这样的实习生还能留不？&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ThreadLocal的value值存在哪里？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实习生说他以为线程任务结束了threadLocal赋值的对象会被JVM垃圾回收，很疑惑为什么会出现内存泄露。作为师傅我肯定要给他把原理讲透呀。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal类提供set/get方法存储和获取value值，但实际上ThreadLocal类并不存储value值，真正存储是靠ThreadLocalMap这个类，ThreadLocalMap是ThreadLocal的一个静态内部类，它的key是ThreadLocal实例对象，value是任意Object对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocalMap类的定义&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalMap&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 定义一个table数组，存储多个threadLocal对象及其value值&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Entry[] table;&lt;br/&gt;    ThreadLocalMap(ThreadLocal&amp;lt;?&amp;gt; firstKey, Object firstValue) {&lt;br/&gt;        table = &lt;span&gt;new&lt;/span&gt; Entry[INITIAL_CAPACITY];&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; i = firstKey.threadLocalHashCode &amp;amp; (INITIAL_CAPACITY - &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        table[i] = &lt;span&gt;new&lt;/span&gt; Entry(firstKey, firstValue);&lt;br/&gt;        size = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        setThreshold(INITIAL_CAPACITY);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 定义一个Entry类，key是一个弱引用的ThreadLocal对象&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// value是任意对象&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Entry&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;WeakReference&lt;/span&gt;&amp;lt;&lt;span&gt;ThreadLocal&lt;/span&gt;&amp;lt;?&amp;gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;/** The value associated with this ThreadLocal. */&lt;/span&gt;&lt;br/&gt;        Object value;&lt;br/&gt;        Entry(ThreadLocal&amp;lt;?&amp;gt; k, Object v) {&lt;br/&gt;            &lt;span&gt;super&lt;/span&gt;(k);&lt;br/&gt;            value = v;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 省略其他&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进一步分析ThreadLocal类的代码，看set和get方法如何与ThreadLocalMap静态内部类关联上。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ThreadLocal类set方法&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocal&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(T value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Thread t = Thread.currentThread();&lt;br/&gt;        ThreadLocalMap map = getMap(t);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (map != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            map.set(&lt;span&gt;this&lt;/span&gt;, value);&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;            createMap(t, value);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;ThreadLocalMap &lt;span&gt;getMap&lt;/span&gt;&lt;span&gt;(Thread t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; t.threadLocals;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;createMap&lt;/span&gt;&lt;span&gt;(Thread t, T firstValue)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        t.threadLocals = &lt;span&gt;new&lt;/span&gt; ThreadLocalMap(&lt;span&gt;this&lt;/span&gt;, firstValue);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 省略其他方法&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;set的逻辑比较简单，就是获取当前线程的ThreadLocalMap，然后往map里添加KV，K是当前ThreadLocal实例，V是我们传入的value。这里需要注意一下，map的获取是需要从Thread类对象里面取，看一下Thread类的定义。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ThreadLocal.ThreadLocalMap threadLocals = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;//省略其他&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Thread类维护了一个ThreadLocalMap的变量引用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ThreadLocal类get方法&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;get获取当前线程的对应的私有变量，是之前set或者通过initialValue的值，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocal&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Thread t = Thread.currentThread();&lt;br/&gt;        ThreadLocalMap map = getMap(t);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (map != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            ThreadLocalMap.Entry e = map.getEntry(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; (T)e.value;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; setInitialValue();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码逻辑分析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取当前线程的ThreadLocalMap实例；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果不为空，以当前ThreadLocal实例为key获取value；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果ThreadLocalMap为空或者根据当前ThreadLocal实例获取的value为空，则执行setInitialValue()；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ThreadLocal相关类的关系总结&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看了上面的分析是不是对Thread，ThreadLocal，ThreadLocalMap，Entry这几个类之间的关系有点晕了，没关系我专门画了一个UML类图来总结（忽略UML标准语法）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.4955489614243322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3Eqvp3YicFWMibu1U3OU2e8vtJZ7eD1Cv4rVQ9DztBCE3BTl9ibqo0BgBicibUfzNgRcEJYHgBFIicWwj3kw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;674&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;ThreadLocal&lt;/span&gt;&lt;span&gt;相关类的关系&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;每个线程是一个Thread实例，其内部维护一个threadLocals的实例成员，其类型是ThreadLocal.ThreadLocalMap。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过实例化ThreadLocal实例，我们可以对当前运行的线程设置一些线程私有的变量，通过调用ThreadLocal的set和get方法存取。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ThreadLocal本身并不是一个容器，我们存取的value实际上存储在ThreadLocalMap中，ThreadLocal只是作为TheadLocalMap的key。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个线程实例都对应一个TheadLocalMap实例，我们可以在同一个线程里实例化很多个ThreadLocal来存储很多种类型的值，这些ThreadLocal实例分别作为key，对应各自的value，最终存储在Entry table数组中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当调用ThreadLocal的set/get进行赋值/取值操作时，首先获取当前线程的ThreadLocalMap实例，然后就像操作一个普通的map一样，进行put和get。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ThreadLocal内存模型原理&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过上面的分析我们对ThreadLocal相关的类设计已经非常清楚了，下面通过一张图更加深入理解一下ThreadLocal的内存存储。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5263157894736842&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3Eqvp3YicFWMibu1U3OU2e8vtJhlaIhkIiahgKGmWqJhBCx9cHq1LSJ72u8umj8755KVVuTcTaJ7vqzCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1254&quot;/&gt;&lt;figcaption&gt;ThreadLocal内存模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图中左边是栈，右边是堆。线程的一些局部变量和引用使用的内存属于Stack（栈）区，而普通的对象是存储在Heap（堆）区。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程运行时，我们定义的TheadLocal对象被初始化，存储在Heap，同时线程运行的栈区保存了指向该实例的引用，也就是图中的ThreadLocalRef。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当ThreadLocal的set/get被调用时，虚拟机会根据当前线程的引用也就是CurrentThreadRef找到其对应在堆区的实例，然后查看其对用的TheadLocalMap实例是否被创建，如果没有，则创建并初始化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Map实例化之后，也就拿到了该ThreadLocalMap的句柄，那么就可以将当前ThreadLocal对象作为key，进行存取操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;图中的虚线，表示key对应ThreadLocal实例的引用是个弱引用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;强引用弱引用的概念&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocalMap的key是一个弱引用类型，源代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalMap&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 定义一个Entry类，key是一个弱引用的ThreadLocal对象&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// value是任意对象&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Entry&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;WeakReference&lt;/span&gt;&amp;lt;&lt;span&gt;ThreadLocal&lt;/span&gt;&amp;lt;?&amp;gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;/** The value associated with this ThreadLocal. */&lt;/span&gt;&lt;br/&gt;        Object value;&lt;br/&gt;        Entry(ThreadLocal&amp;lt;?&amp;gt; k, Object v) {&lt;br/&gt;            &lt;span&gt;super&lt;/span&gt;(k);&lt;br/&gt;            value = v;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 省略其他&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面解释一下常见的几种引用概念。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;强引用&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;一直活着&lt;/strong&gt;：类似“Object obj=new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象实例。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;弱引用&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;回收就会死亡&lt;/strong&gt;：被弱引用关联的对象实例只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象实例。在JDK 1.2之后，提供了WeakReference类来实现弱引用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;软引用&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;有一次活的机会&lt;/strong&gt;：软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象实例列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;虚引用&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;也称为幽灵引用或者幻影引用&lt;/strong&gt;，它是最弱的一种引用关系。一个对象实例是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象实例被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;内存泄露是不是弱引用的锅？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从表面上看内存泄漏的根源在于使用了弱引用，但是另一个问题也同样值得思考：为什么ThreadLocalMap使用弱引用而不是强引用？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;翻看官网文档的说法：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys. &lt;/p&gt;&lt;p&gt;为了处理非常大和长期的用途，哈希表条目使用weakreference作为键。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分两种情况讨论：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）key 使用强引用&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引用ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）key 使用弱引&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引用ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set、get、remove的时候会被清除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal被清理后key为null，对应的value在下一次ThreadLocalMap调用set、get、remove的时候可能会被清除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ThreadLocal最佳实践&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过前面几小节我们分析了ThreadLocal的类设计以及内存模型，同时也重点分析了发生内存泄露的条件和特定场景。最后结合项目中的经验给出建议使用ThreadLocal的场景：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当需要存储线程私有变量的时候。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当需要实现线程安全的变量时。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当需要减少线程资源竞争的时候。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综合上面的分析，我们可以理解ThreadLocal内存泄漏的前因后果，那么怎么避免内存泄漏呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案就是：每次使用完ThreadLocal，建议调用它的remove()方法，清除数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外需要强调的是并不是所有使用ThreadLocal的地方，都要在最后remove（），因为他们的生命周期可能是需要和项目的生存周期一样长的，所以要进行恰当的选择，以免出现业务逻辑错误！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>