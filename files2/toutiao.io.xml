<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>d9cdbd1757227d485b5314f963f0b9de</guid>
<title>时间轮在 Kafka 的实践</title>
<link>https://toutiao.io/k/441cqn5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;562&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;562&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBG8fiaH5DpcXl4gX9dSJhFzF6ARFqaicYjickTxiaPM701eKEspL7tj7A4xonqVVkpDfA12KVmDDPE8icg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-darkmode-bgcolor-15906711670635=&quot;rgb(52, 52, 52)&quot; data-darkmode-original-bgcolor-15906711670635=&quot;rgb(239, 239, 239)&quot; data-style=&quot;padding: 10px; display: inline-block; width: 558px; border-width: 1px; border-style: solid; border-color: transparent; background-color: rgb(239, 239, 239); border-radius: 0px;&quot; class=&quot;js_darkmode__0&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; data-darkmode-bgcolor-15906711670635=&quot;rgb(52, 52, 52)&quot; data-darkmode-original-bgcolor-15906711670635=&quot;rgb(239, 239, 239)&quot;&gt;&lt;section data-darkmode-bgcolor-15906711670635=&quot;rgb(52, 52, 52)&quot; data-darkmode-original-bgcolor-15906711670635=&quot;rgb(239, 239, 239)&quot;&gt;&lt;p data-darkmode-bgcolor-15906711670635=&quot;rgb(52, 52, 52)&quot; data-darkmode-original-bgcolor-15906711670635=&quot;rgb(239, 239, 239)&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;桔妹导读：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;时间轮是一个应用场景很广的组件，在很多高性能中间件中都有它的身影，如Netty、Quartz、Akka，当然也包括Kafka，本文主要介绍时间轮在kafka的应用和实战，从核心源码和设计的角度对时间轮进行深入的讲解 。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;1. &lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引子&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.0734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jE5bOw22iaBtFvdK9icOj3ibAXa8W3tqZ2lQDEaA5XcCDJ5cVIic2221PzXcw0oo69kvia8ojgPZnEV4jPxZURBln4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;562&quot; data-backh=&quot;41&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从2个面试题说起，第一个问题：&lt;strong&gt;如果一台机器上有10w个定时任务，如何做到高效触发？&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具体场景是：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有一个APP实时消息通道系统，对每个用户会维护一个APP到服务器的TCP连接，用来实时收发消息，对这个TCP连接，有这样一个需求：“如果连续30s没有请求包（例如登录，消息，keepalive包），服务端就要将这个用户的状态置为离线”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; 其中，单机TCP同时在线量约在10w级别，keepalive请求包较分散大概30s一次，吞吐量约在3000qps。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;怎么做？&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;常用方案使用time定时任务，每秒扫描一次所有连接的集合Map&amp;lt;uid, last_packet_time&amp;gt;，把连接时间（每次有新的请求更新对应连接的连接时间）比当前时间的差值大30s的连接找出来处理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另一种方案，使用环形队列法：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;382&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6606498194945848&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBG8fiaH5DpcXl4gX9dSJhFzFyHiaiaWIPMkRLgqmsN5VzQsHuYdCHiadPl2dunDHicSlewT7ma4pWBNJBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1108&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;三个重要的数据结构：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;30s超时，就创建一个index从0到30的环形队列（本质是个数组）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;环上每一个slot是一个Set&amp;lt;uid&amp;gt;，任务集合&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;同时还有一个Map&amp;lt;uid, index&amp;gt;，记录uid落在环上的哪个slot里&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这样当有某用户uid有请求包到达时：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从Map结构中，查找出这个uid存储在哪一个slot里&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从这个slot的Set结构中，删除这个uid&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将uid重新加入到新的slot中，具体是哪一个slot呢 =&amp;gt; Current Index指针所指向的&lt;/span&gt;&lt;span&gt;上一个&lt;/span&gt;&lt;span&gt;slot，因为这个slot，会被timer在30s之后扫描到&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;更新Map，这个uid对应slot的index值&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;哪些元素会被超时掉呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Current Index每秒种移动一个slot，这个slot对应的Set&amp;lt;uid&amp;gt;中所有uid都应该被集体超时！如果最近30s有请求包来到，一定被放到Current Index的前一个slot了，Current Index所在的slot对应Set中所有元素，都是最近30s没有请求包来到的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，当没有超时时，Current Index扫到的每一个slot的Set中应该都没有元素。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;两种方案对比：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;方案一每次都要轮询所有数据，而方案二使用环形队列只需要轮询这一刻需要过期的数据，如果没有数据过期则没有数据要处理，并且是批量超时，并且由于是环形结构更加节约空间，这很适合高性能场景。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第二个问题：&lt;strong&gt;在开发过程中有延迟一定时间的任务要执行，怎么做？&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果不重复造轮子的话，我们的选择当然是延迟队列或者Timer。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;延迟队列和在Timer中增 加延时任务采用数组表示的最小堆的数据结构实现，每次放入新元素和移除队首元素时间复杂度为O(nlog(n))。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;2. &lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;时间轮&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.0734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jE5bOw22iaBtFvdK9icOj3ibAXa8W3tqZ2lQDEaA5XcCDJ5cVIic2221PzXcw0oo69kvia8ojgPZnEV4jPxZURBln4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;562&quot; data-backh=&quot;41&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;方案二所采用的环形队列，就是时间轮的底层数据结构，它能够让需要处理的数据（任务的抽象）集中，在Kafka中存在大量的延迟操作，比如延迟生产、延迟拉取以及延迟删除等。Kafka并没有使用JDK自带的Timer或者DelayQueue来实现延迟的功能，而是基于时间轮自定义了一个用于实现延迟功能的定时器（SystemTimer）。JDK的Timer和DelayQueue插入和删除操作的平均时间复杂度为O(nlog(n))，并不能满足Kafka的高性能要求，而基于时间轮可以将插入和删除操作的时间复杂度都降为O(1)。时间轮的应用并非Kafka独有，其应用场景还有很多，在Netty、Akka、Quartz、Zookeeper等组件中都存在时间轮的踪影。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;▍&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;2.1 时间轮的数据结构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;参考下图，Kafka中的时间轮（TimingWheel）是一个存储定时任务的环形队列，底层采用数组实现，数组中的每个元素可以存放一个定时任务列表（TimerTaskList）。TimerTaskList是一个环形的双向链表，链表中的每一项表示的都是定时任务项（TimerTaskEntry），其中封装了真正的定时任务TimerTask。在Kafka源码中对这个TimeTaskList是用一个名称为buckets的数组表示的，所以后面介绍中可能TimerTaskList也会被称为bucket。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;312&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.54&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBG8fiaH5DpcXl4gX9dSJhFzFpdDDKO9Iib8RQIRQ3JMaZoqNfC7VDYJZTtUy2UOaXVFtDicNGsC0Btqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;span&gt;图二&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;针对上图的几个名词简单解释下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;tickMs：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;时间轮由多个时间格组成，每个时间格就是tickMs，它代表当前时间轮的基本时间跨度。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;wheelSize：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;代表每一层时间轮的格数&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;interval：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;当前时间轮的总体时间跨度，interval=tickMs × wheelSize&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;startMs：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;构造当层时间轮时候的当前时间，第一层的时间轮的startMs是TimeUnit.NANOSECONDS.toMillis(nanoseconds()),上层时间轮的startMs为下层时间轮的currentTime。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;currentTime：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;表示时间轮当前所处的时间，currentTime是tickMs的整数倍（通过currentTime=startMs - (startMs % tickMs来保正currentTime一定是tickMs的整数倍），这个运算类比钟表中分钟里65秒分钟指针指向的还是1分钟）。currentTime可以将整个时间轮划分为到期部分和未到期部分，currentTime当前指向的时间格也属于到期部分，表示刚好到期，需要处理此时间格所对应的TimerTaskList的所有任务。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;▍&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;2.2 时间轮中的任务存放&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;若时间轮的tickMs=1ms，wheelSize=20，那么可以计算得出interval为20ms。初始情况下表盘指针currentTime指向时间格0，此时有一个定时为2ms的任务插入进来会存放到时间格为2的TimerTaskList中。随着时间的不断推移，指针currentTime不断向前推进，过了2ms之后，当到达时间格2时，就需要将时间格2所对应的TimeTaskList中的任务做相应的到期操作。此时若又有一个定时为8ms的任务插入进来，则会存放到时间格10中，currentTime再过8ms后会指向时间格10。如果同时有一个定时为19ms的任务插入进来怎么办？新来的TimerTaskEntry会复用原来的TimerTaskList，所以它会插入到原本已经到期的时间格1中。总之，整个时间轮的总体跨度是不变的，随着指针currentTime的不断推进，当前时间轮所能处理的时间段也在不断后移，总体时间范围在currentTime和currentTime+interval之间。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;▍&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;2.3 时间轮的升降级&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果此时有个定时为350ms的任务该如何处理？直接扩充wheelSize的大小么？Kafka中不乏几万甚至几十万毫秒的定时任务，这个wheelSize的扩充没有底线，就算将所有的定时任务的到期时间都设定一个上限，比如100万毫秒，那么这个wheelSize为100万毫秒的时间轮不仅占用很大的内存空间，而且效率也会拉低。Kafka为此引入了层级时间轮的概念，当任务的到期时间超过了当前时间轮所表示的时间范围时，就会尝试添加到上层时间轮中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;513&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.9129332206255283&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBG8fiaH5DpcXl4gX9dSJhFzFXzdeg3QUgdoJ26RtYQpibFsFK0IXhico9xicPsZDvRnYcicqul57P0tP0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1183&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;图三&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;参考上图，复用之前的案例，第一层的时间轮tickMs=1ms, wheelSize=20, interval=20ms。第二层的时间轮的tickMs为第一层时间轮的interval，即为20ms。每一层时间轮的wheelSize是固定的，都是20，那么第二层的时间轮的总体时间跨度interval为400ms。以此类推，这个400ms也是第三层的tickMs的大小，第三层的时间轮的总体时间跨度为8000ms。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;刚才提到的350ms的任务，不会插入到第一层时间轮，会插入到interval=20*20的第二层时间轮中，具体插入到时间轮的哪个bucket呢？先用350/tickMs(20)=virtualId(17)，然后virtualId(17) %wheelSize (20) = 17，所以350会放在第17个bucket。如果此时有一个450ms后执行的任务，那么会放在第三层时间轮中，按照刚才的计算公式，会放在第0个bucket。第0个bucket里会包含&lt;/span&gt;&lt;span&gt;[400,800)ms&lt;/span&gt;&lt;span&gt;的任务。&lt;/span&gt;&lt;span&gt;随着时间流逝，当时间过去了400ms，那么450ms后就要执行的任务还剩下50ms的时间才能执行，此时有一个时间轮降级的操作，将50ms任务重新提交到层级时间轮中，那么此时50ms的任务根据公式会放入第二个时间轮的第2个bucket中，此bucket的时间范围为[40,60)ms，然后再经过40ms，这个50ms的任务又会被监控到，此时距离任务执行还有10ms，同样将10ms的任务提交到层级时间轮，此时会加入到第一层时间轮的第10个bucket，所以再经过10ms后，此任务到期，最终执行。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;整个时间轮的升级降级操作是不是很类似于我们的时钟？ 第一层时间轮tickMs=1s, wheelSize=60，interval=1min，此为秒钟；第二层tickMs=1min，wheelSize=60，interval=1hour，此为分钟；第三层tickMs=1hour，wheelSize为12，interval为12hours，此为时钟。而钟表的指针就对应程序中的currentTime，这个后面分析代码时候会讲到（对这个的理解也是时间轮理解的重点和难点）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;2.4 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;任务添加和驱动时间轮滚动核心流程图&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;322&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;409&quot; data-ratio=&quot;0.5736994219653179&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBG8fiaH5DpcXl4gX9dSJhFzFeEWic4vjFkWp5Sng55EQSXoSZIIA9yIlKezQgWkiaT7bRuAHrNWq1J6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1384&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图四&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;2.5 重点代码介绍&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这是往SystenTimer中添加一个任务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; def &lt;span class=&quot;code-snippet__title&quot;&gt;addTimerTaskEntry&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;timerTaskEntry: TimerTaskEntry&lt;/span&gt;): Unit&lt;/span&gt; = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!timingWheel.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(timerTaskEntry)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!timerTaskEntry.cancelled)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      taskExecutor.submit(timerTaskEntry.timerTask)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;timingWheel添加任务，递归添加直到添加该任务进合适的时间轮的bucket中&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;def &lt;span class=&quot;code-snippet__title&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;timerTaskEntry: TimerTaskEntry&lt;/span&gt;): Boolean&lt;/span&gt; = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  val expiration = timerTaskEntry.expirationMs&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timerTaskEntry.cancelled) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (expiration &amp;lt; currentTime + tickMs) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (expiration &amp;lt; currentTime + interval) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    val virtualId = expiration / tickMs&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    val bucket = buckets((virtualId % wheelSize.toLong).toInt)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    bucket.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(timerTaskEntry)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (bucket.setExpiration(virtualId * tickMs)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      queue.offer(bucket)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (overflowWheel == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) addOverflowWheel()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    overflowWheel.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(timerTaskEntry)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在本层级时间轮里添加上一层时间轮里的过程，注意的是在下一层时间轮的interval为上一层时间轮的tickMs。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt;[&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;] &lt;span class=&quot;code-snippet__function&quot;&gt;def &lt;span class=&quot;code-snippet__title&quot;&gt;addOverflowWheel&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;synchronized&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (overflowWheel == &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      overflowWheel = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; TimingWheel(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        tickMs = interval,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        wheelSize = wheelSize,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        startMs = currentTime,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        taskCounter = taskCounter,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        queue&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;驱动时间轮滚动过程：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;注意这里会存在一个递归，一直驱动时间轮的指针滚动直到时间不足于驱动上层的时间轮滚动。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;def advanceClock(timeMs: &lt;span class=&quot;code-snippet__built_in&quot;&gt;Long&lt;/span&gt;): &lt;span class=&quot;code-snippet__built_in&quot;&gt;Unit&lt;/span&gt; = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timeMs &amp;gt;= currentTime + tickMs) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    currentTime = timeMs - (timeMs % tickMs)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (overflowWheel != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) overflowWheel.advanceClock(currentTime)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;驱动源：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt;[&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;] &lt;span class=&quot;code-snippet__keyword&quot;&gt;val&lt;/span&gt; reinsert = (timerTaskEntry: TimerTaskEntry) =&amp;gt; addTimerTaskEntry(timerTaskEntry)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;def advanceClock(timeoutMs: &lt;span class=&quot;code-snippet__built_in&quot;&gt;Long&lt;/span&gt;): &lt;span class=&quot;code-snippet__built_in&quot;&gt;Boolean&lt;/span&gt; = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; bucket = delayQueue.poll(timeoutMs, TimeUnit.MILLISECONDS)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (bucket != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    writeLock.lock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (bucket != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        timingWheel.advanceClock(bucket.getExpiration())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        bucket.flush(reinsert)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        bucket = delayQueue.poll()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      writeLock.unlock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;3. &lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.0734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jE5bOw22iaBtFvdK9icOj3ibAXa8W3tqZ2lQDEaA5XcCDJ5cVIic2221PzXcw0oo69kvia8ojgPZnEV4jPxZURBln4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;562&quot; data-backh=&quot;41&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span data-shimo-docs=&quot;[[20,&amp;quot;通过以上工作，滴滴Presto逐渐接入公司各大数据平台，并成为了公司首选Ad-Hoc查询引擎及Hive SQL加速引擎，下图可以看到某产品接入后的性能提升：\n&amp;quot;]]&quot;&gt;&lt;span data-shimo-docs=&quot;[[20,&amp;quot;但是如果看最近一个月的CPU使用率会发现，平均CPU使用率比较低，且波峰在白天10~18点，晚上基本上没有查询，CPU使用率不到5%。如下图所示：&amp;quot;,&amp;quot;0:\&amp;quot;%23333333\&amp;quot;&amp;quot;]]&quot;&gt;kafka的延迟队列使用时间轮实现，能够支持大量任务的高效触发，但是在kafka延迟队列实现方案里还是看到了delayQueue的影子，使用delayQueue是对时间轮里面的bucket放入延迟队列，以此来推动时间轮滚动，但是基于将插入和删除操作则放入时间轮中，将这些操作的时间复杂度都降为O(1)，提升效率。Kafka对性能的极致追求让它把最合适的组件放在最适合的位置。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;本文作者&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;h3&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;▬&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/h3&gt;&lt;h3&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;106&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;106&quot; data-ratio=&quot;0.18946188340807174&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBG8fiaH5DpcXl4gX9dSJhFzFSfRy6bcPNkSCjLkT4a5KRa0Rh1n8icXoTBmxqDdEibibXiaK5vI6zfCliag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span data-shimo-docs=&quot;[[20,&amp;quot;通过以上工作，滴滴Presto逐渐接入公司各大数据平台，并成为了公司首选Ad-Hoc查询引擎及Hive SQL加速引擎，下图可以看到某产品接入后的性能提升：\n&amp;quot;]]&quot;&gt;&lt;span data-shimo-docs=&quot;[[20,&amp;quot;但是如果看最近一个月的CPU使用率会发现，平均CPU使用率比较低，且波峰在白天10~18点，晚上基本上没有查询，CPU使用率不到5%。如下图所示：&amp;quot;,&amp;quot;0:\&amp;quot;%23333333\&amp;quot;&amp;quot;]]&quot;&gt;&lt;span data-shimo-docs=&quot;[[20,&amp;quot;所以，解决晚上资源浪费问题是我们今后需要解决的难题。&amp;quot;,&amp;quot;0:\&amp;quot;%23333333\&amp;quot;&amp;quot;],[20,&amp;quot;\n同时，为了不与开源社区脱节，我们打算升级PrestoDB 0.215到PrestoSQL 340版本，届时会把我们的Presto on Druid代码开源出来，回馈社区。&amp;quot;]]&quot;&gt;滴滴车险团队架构师，负责车险核心系统的架构和设计，十年互联网研发架构经验，其中五年中间件与基础架构经验，对高并发，高可用以及分布式应用的架构设计有丰富的实战经验，尤其对分布式消息队列，分布式流程编排引擎、分布式数据库中间件有较深入的研究，热爱技术，崇尚开源，是Kafka、RocketMQ、Conductor等多个知名开源项目的源码贡献者。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h3&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;团队招聘&lt;/strong&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;▬&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span data-shimo-docs=&quot;[[20,&amp;quot;对于低重要度的特征，最终做了删除，从而降低模型大小。例如我们发现方位角的重要度在实际模型训练中不如角变量。推测方位角本身的不连续性（0 = 2pi）可能对模型训练是一种干扰。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;对于异常值，做了基本的数据清洗，如无效的速度值，无效的方位角；对于不足的GPS序列长度，用0进行填充（但需要额外注意起点属性）等。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;3. 模型选择、训练与效果&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;DNN&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;：只需要相对简单的算法实现，引入较小的模型库。然而GPS轨迹数据具有典型的时间序列特征，在4万样本下，应用利用DNN模型调参优化后，训练结果准确率最高达到91%。Bad case中存在大量时间不敏感的情形，最典型的情形就是——轨迹由差转优时，判定结果未能及时转变为高质量。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;CNN&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;：这里可以尝试两种实现方式，一种是通过生成bitmap进行识别，然而GPS跨度不确定性较高，方向性不易表达，在实现上具有一定困难。第二种将序列化数据转化为二维数组，C模型能够识别出前后时间戳之间的变化特征，但并不能保留更长的时间的变化特征。最终训练出的准确率在93%左右。另外，CNN模型应用在移动端有一个明显的缺点，即模型尺寸一般较大。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;LSTM（&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;长短期记忆网络&amp;quot;],[20,&amp;quot;）&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;：一种特殊的RNN模型，相比前述模型对轨迹质量序列判定有明显优势。在轨迹质量由好转差，或由差转好的识别上具有非常高的灵敏度，使用128个unit能够达到97%的准确率。缺点是LSTM模型训练速度相对较慢，算法库实现相对复杂。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;最终我们选择了使用LSTM模型。使用LSTM的训练结果，准确率大幅提升。在剩余3%的错误样例中，很多轨迹在形态上表现出较高的真实性，但却无法同路网进行匹配。理论上通过引入路网属性能够上带来准确率的进一步提升，然而这种数据的耦合脱离了轨迹质量判定的初衷——服务于偏航引擎专家系统，而非直接用于偏航判定。对此我们将会在最后进行更详细的介绍。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3&amp;quot;],[20,&amp;quot;4. 移动端性能优化&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;模型推算性能对于移动端尤为重要。偏航场景下，GPS更新频繁，选择在必要的时候进行模型推算能够避免不必要的计算开销。通常我们会计算当前GPS点与规划路线的偏离度，只有偏离度大于阈值时才会进行轨迹质量判定。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;基于深度学习的专家系统探索&amp;quot;,&amp;quot;27:\&amp;quot;14\&amp;quot;|8:1&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:2&amp;quot;],[20,&amp;quot;轨迹质量模型作为偏航判定的重要依据，能够以较小的代价移植到移动端。如果不考虑前端性能及数据限制，我们完全可以定义整个偏航判定问题，训练相应的偏航模型。然而偏航场景种类繁多，过于复杂，训练出一套通用的偏航模型需要大量的数据，充足的路网信息，和较大的模型存储，这对于移动端而言不太现实。  &amp;quot;]]&quot;&gt;&lt;span&gt;滴滴车险团队基于滴滴近百万辆车和海量数据，通过线上化、科技化、数据化的手段，达到车险的降赔付、降发生，降保费，为乘客、司机、以及车队、合作伙伴提供方便快捷高效的车险金融服务。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span data-shimo-docs=&quot;[[20,&amp;quot;对于低重要度的特征，最终做了删除，从而降低模型大小。例如我们发现方位角的重要度在实际模型训练中不如角变量。推测方位角本身的不连续性（0 = 2pi）可能对模型训练是一种干扰。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;对于异常值，做了基本的数据清洗，如无效的速度值，无效的方位角；对于不足的GPS序列长度，用0进行填充（但需要额外注意起点属性）等。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;3. 模型选择、训练与效果&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;DNN&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;：只需要相对简单的算法实现，引入较小的模型库。然而GPS轨迹数据具有典型的时间序列特征，在4万样本下，应用利用DNN模型调参优化后，训练结果准确率最高达到91%。Bad case中存在大量时间不敏感的情形，最典型的情形就是——轨迹由差转优时，判定结果未能及时转变为高质量。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;CNN&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;：这里可以尝试两种实现方式，一种是通过生成bitmap进行识别，然而GPS跨度不确定性较高，方向性不易表达，在实现上具有一定困难。第二种将序列化数据转化为二维数组，C模型能够识别出前后时间戳之间的变化特征，但并不能保留更长的时间的变化特征。最终训练出的准确率在93%左右。另外，CNN模型应用在移动端有一个明显的缺点，即模型尺寸一般较大。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;LSTM（&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;长短期记忆网络&amp;quot;],[20,&amp;quot;）&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;：一种特殊的RNN模型，相比前述模型对轨迹质量序列判定有明显优势。在轨迹质量由好转差，或由差转好的识别上具有非常高的灵敏度，使用128个unit能够达到97%的准确率。缺点是LSTM模型训练速度相对较慢，算法库实现相对复杂。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;最终我们选择了使用LSTM模型。使用LSTM的训练结果，准确率大幅提升。在剩余3%的错误样例中，很多轨迹在形态上表现出较高的真实性，但却无法同路网进行匹配。理论上通过引入路网属性能够上带来准确率的进一步提升，然而这种数据的耦合脱离了轨迹质量判定的初衷——服务于偏航引擎专家系统，而非直接用于偏航判定。对此我们将会在最后进行更详细的介绍。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3&amp;quot;],[20,&amp;quot;4. 移动端性能优化&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;模型推算性能对于移动端尤为重要。偏航场景下，GPS更新频繁，选择在必要的时候进行模型推算能够避免不必要的计算开销。通常我们会计算当前GPS点与规划路线的偏离度，只有偏离度大于阈值时才会进行轨迹质量判定。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;基于深度学习的专家系统探索&amp;quot;,&amp;quot;27:\&amp;quot;14\&amp;quot;|8:1&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:2&amp;quot;],[20,&amp;quot;轨迹质量模型作为偏航判定的重要依据，能够以较小的代价移植到移动端。如果不考虑前端性能及数据限制，我们完全可以定义整个偏航判定问题，训练相应的偏航模型。然而偏航场景种类繁多，过于复杂，训练出一套通用的偏航模型需要大量的数据，充足的路网信息，和较大的模型存储，这对于移动端而言不太现实。  &amp;quot;]]&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;团队长期招聘&lt;span&gt;java高级工程师和技术专家，&lt;/span&gt;欢迎有兴趣的小伙伴加入，可投递简历至 diditech@didiglobal.com，邮件请邮件主题请命名为「姓名-应聘部门-应聘方向」。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;135&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;135&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBFBFcH3cDkw5qRpibVy97GUiaCUicPhRyTg6LpWp2CFHhKZSYuQnmhyZzBnnRxJ4EuWwvI3HTgqibQ7Mw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;256&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;扫码了解更多岗位&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;延伸阅读&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;▬&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1ODEzNjI2NA==&amp;amp;mid=2247512436&amp;amp;idx=1&amp;amp;sn=1fea750185b0ec4a5c5e000db7e773e1&amp;amp;chksm=fc29dfd3cb5e56c5e8d07d13a755a3434cfd61af38a161bfde4be7eaf28b56fda65644da6971&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;112&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.2&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBG8fiaH5DpcXl4gX9dSJhFzFUvNyoeeVzZpUV1iao6ZywZNm1lvQfoWJiaYJF1rICaHKIACfRhLLoIeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1ODEzNjI2NA==&amp;amp;mid=2247507588&amp;amp;idx=1&amp;amp;sn=a4cc88ed4a14007f5d39da9e7c0e6d02&amp;amp;chksm=fc29b023cb5e393522bc096473e6ff4a5b2045bb591dd62609a6cbae7a2727991c6d82d628e3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;112&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.2&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBHraEAV6GKpIj4dQOQNs9ggIppJ4Jhjb2ic2K75ZnPYjTCBicrmiaEgQtH17Ks8E8uk0QeojUDD9whibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1ODEzNjI2NA==&amp;amp;mid=2247493821&amp;amp;idx=1&amp;amp;sn=c3fa1e6733cf9f2b173793adeb0139b3&amp;amp;chksm=fc29861acb5e0f0c5bb5bf02d4e0cafc68cd19232643be1cb798a05bd4a60e65d8705281a0ac&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; hasload=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBFPvfKQEIHKT8V3yZSGBZQtHgjI7CoApEqXV3uRhYFH383kdxwNSsfOUib2NViciaJeYHtJk1CvZdVGA/640?wx_fmt=png&quot; data-backw=&quot;562&quot; data-backh=&quot;112&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;内容编辑&lt;span&gt; | Charlotte&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;联系我们 | DiDiTech@didiglobal.com&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;pre ng-bind-html=&quot;message.MMActualContent&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;162&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.28888888888888886&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBHCquJeOibVaFwqqC4iadSqFxSJRyP1G2V6ZB0tXzfDbHQmq5LXdiawGrVAfTs5INmjsvxOnH4dU8how/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e7583dd9be89f5f5fba1fc84d1163778</guid>
<title>虚拟机系列：JVM 执行引擎和垃圾回收</title>
<link>https://toutiao.io/k/hvkhrg3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1&gt;&lt;span&gt;一、执行引擎&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;应用程序经过编译，转换为字节码文件，字节码加载到内存空间并不能直接在操作系统上执行，执行引擎作为Java虚拟机核心的组成部分，作用就是将字节码指令解释/编译为对应系统平台上的本地机器指令。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5483091787439613&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvArrrqwmibM8HOXIoQDsTfkF0HEywSdsRSgvDxV4diavy7YbsJQia0icz5zdKVn5gk8ABZz50g1DK9BWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;解释器&lt;/strong&gt;：虚拟机启动时会根据预定义对字节码采用逐行解释的方式执行，将每条字节码文件中的内容解释为对应系统平台的本地机器指令执行；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;JIT编译器&lt;/strong&gt;：虚拟机将源代码编译成本地机器平台相关的机器语言，并且寻找热点高频执行的代码将其放入元空间中，即元空间中存放的JIT缓存代码；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;垃圾回收&lt;/strong&gt;：对于没有任何引用的对象标记为垃圾，会被回收释放内存空间。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、垃圾对象标记&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、引用计数法&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;每个对象保存一个整型引用计数器，用来记录对象被引用的次数，当该对象被一个对象引用时，计数器加1，当失去一个引用时，计数器减1；引用计数算法就是通过判断对象的引用数量来决定对象是否可以被当做垃圾对象回收掉。&lt;/p&gt;&lt;p&gt;虽然引用计数法效率高，但是当两个对象互相引用时会导致这两个对象一直不会被回收，这是一个致命的缺陷。所以JVM并没有采用该标记算法。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、可达性分析算法&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;可达性分析算法是基于对象到根对象的引用链是否可达来判断对象是否可以被回收；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5601503759398496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvArrrqwmibM8HOXIoQDsTfkFoM8fjGPeOZlPOxKjaYVcGOr2Uey3NUmWfAicD5aWRn8B0rvjsib7vOSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1064&quot;/&gt;&lt;/p&gt;&lt;p&gt;运行程序把所有的引用关系链看作一张图，通过GC-Roots根对象对象集合作为起始点，从每个根节点向下不断搜索被根对象集合所连接的对象是否可达，搜索路径称为引用链（Reference-Chain），如果对象到GC-Roots没有任何引用链存在，则说明此对象是不可用的，&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;虚拟机栈中引用的对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;元空间中类静态属性引用的对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;元空间中常量引用的对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;本地方法栈中Native方法引用的对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;相对于引用计数法算法，可达性分析算法则避免了循环引用导致的问题，同样具备执行高效的特点，也是JVM采用的标记算法。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、垃圾回收机制&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、标记清除算法&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;标记-清除算法分为标记和清除两个阶段：&lt;/p&gt;&lt;p&gt;标记阶段：从根对象集合进行扫描，对存活的对象对象标记；清除阶段：再次扫描发现未被标记的对象并进行回收；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6045548654244306&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvArrrqwmibM8HOXIoQDsTfkFFpW6FtSSehTaneZfhZpzGw06aibXRkLft1D81v9yibDYf9sic5oZZNDQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;966&quot;/&gt;&lt;/p&gt;&lt;p&gt;该算法效率不高，进行垃圾回收需要暂停应用程序，同时会产生大量内存碎片，后续程序运行过程中分配内存占用较大的对象时，会有连续内存不够情况，容易触发再一次垃圾收集动作。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、标记整理算法&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;标记整理算法的标记过程类似标记清除算法，第一阶段：标记出垃圾对象；第二阶段：让所有存活的对象都向内存区一端移动；第三阶段：直接清理掉边界端以外的内存，类似于磁盘整理的过程；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6024844720496895&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvArrrqwmibM8HOXIoQDsTfkFNDibrfWCXKSibSXq25VRUhGeOG3KJeynygI8AiaRn7vJZn7qfZnh8bZVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;966&quot;/&gt;&lt;/p&gt;&lt;p&gt;该垃圾回收算法效率不高，对象移动过程需要暂停应用程序，适用于对象存活率高的场景（老年代）。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、复制算法&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;复制算法将内存按容量划分为大小相等的两块，每次只使用其中的一块，当使用的这块的内存用完，就将还存活着的对象复制到另外一块空闲内存上，然后使用过的内存空间一次清理。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5762195121951219&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvArrrqwmibM8HOXIoQDsTfkFOSUplgql9BJicPM6eER4DpdcPB0UV5ZcAYSf7H3gdhHbhxEDlw0XkgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;656&quot;/&gt;&lt;/p&gt;&lt;p&gt;该算法实现简单，运行效率高，但是内存空间严重浪费，适用于对象存活率低的场景，比如新生代。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;4、分代收集算法&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;当前市场上几乎所有的虚拟机都采用该回收算法，分代收集算法根据年轻代和老年代的各自特点采用不同的算法机制，不同内存区域中对象生命周期也不同，因此对堆内存不同区域采用不同的回收策略可以提高垃圾回收执行效率。通常情况新生代对象存活率低，回收频繁，就采用复制算法；老年代存对象生命周期长，活率高，就用标记清除算法或者标记整理算法。&lt;/p&gt;&lt;p&gt;Java堆内存一般可以分为新生代、老年代和永久代三个模块，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5061728395061729&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvArrrqwmibM8HOXIoQDsTfkFDEOIGxVhjiccicDhYKEomRazWMb0KKkjynpPCW3ImzB3pBNx53dTUoeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;972&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;新生代&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通常情况下，新创建的对象实例首先都是放在新生代空间中，所以追求快速的回收掉垃圾对象，一般情况下，新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0，survivor1)区，对象实例大部分在Eden区中生成；&lt;/p&gt;&lt;p&gt;垃圾回收时先把eden区存活对象复制到S0区，然后清空eden区，当S0区也满时，再将eden区和S0区存活对象复制到S1区，然后清空eden和S0区，之后交换S0区和S1区的角色，当S1区无法存放eden区和S0区的存活对象时，就将存活对象直接存移到老年代区，当老年代区也满了，触发一次FullGC，即新生代、老年代都进行回收。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;老年代&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;老年代区存放一些生命周期较长的对象，对象实例在新生代中经历了多次垃圾回收仍然存活的对象，会被移动到老年代区中。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、源代码地址&lt;/span&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;GitHub·地址&lt;br/&gt;https:&lt;span&gt;//github.com/cicadasmile/java-base-parent&lt;/span&gt;&lt;br/&gt;GitEE·地址&lt;br/&gt;https:&lt;span&gt;//gitee.com/cicadasmile/java-base-parent&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3783359497645212&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCjMheLZtcM2iaVMBOpIUKR4CDRCG9FLT5K6NmGXvG7exrW0TSuDjnTKJQ5PDq8j8Y7PHDd17Z3gicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9e29096b02ce4d9b40752328c0cb35b6</guid>
<title>如何制作 Sketch 插件</title>
<link>https://toutiao.io/k/xjsgd30</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;cont&quot;&gt;&lt;p&gt;&lt;img src=&quot;https://p2.ssl.qhimgs4.com/t011270038e64a675be.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Sketch 是近些年比较流行的 UI 设计软件，它比起之前常用的 Illustrator 或者 Photoshop 比较好的地方在于小巧功能简单但足够，同时对 Mac 的触摸板支持更加友好。另外它的插件系统也要比 Adobe 更加友好，大量的插件帮助我们解决协同和效率上的问题。&lt;/p&gt;
&lt;p&gt;Sketch 插件最大的好处在于可以直接使用 JavaScript 进行开发，并提供了许多配套的开发工具。下面我就以帮助设计师同学快速插入占位图的插件 Placeholder 为例，带大家一步一步的了解如何进行 Sketch 插件开发。&lt;/p&gt;
&lt;p&gt;在进行插件开发之前，我们需要了解一些基础的知识。Sketch 是一套原生 Objective-C 开发的软件，它之所以能支持使用 JS 开发，是因为它使用 &lt;a href=&quot;https://github.com/ccgus/CocoaScript&quot;&gt;CocoaScript&lt;/a&gt; 作为插件的开发语言。它就像是一座桥（Bridge），能让我们在插件中写 OC 和 JS，然后 Sketch 将基础方法进行了封装，实现了一套 &lt;a href=&quot;https://developer.sketch.com/plugins/javascript-api&quot;&gt;JavaScript API&lt;/a&gt;，这样我们就能使用 JS 开发 Sketch 插件了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 关于如何开发插件，官方提供了一份入门教程&lt;a href=&quot;https://developer.sketch.com/plugins/create-a-plugin&quot;&gt;《Create a plugin》&lt;/a&gt;，在阅读下文之前，也可以花 2~3min 先看看这篇官方教程，内容比较简短。&lt;/p&gt;
&lt;/blockquote&gt;


&lt;h2&gt;&lt;a id=&quot;toc-7ae&quot; class=&quot;anchor&quot; href=&quot;#toc-7ae&quot;/&gt;需求整理&lt;/h2&gt;
&lt;p&gt;在进行插件开发之前，我们捋一捋我们需要实现的功能。&lt;a href=&quot;http://placeimg.com/&quot;&gt;http://placeimg.com/&lt;/a&gt; 是一个专门用来生成占位图的网站，我们将利用该网站提供的服务制作一个生成指定大小的占位图并插入到 Sketch 画板中的功能。插件会提供一个面板，可以让使用者输入尺寸、分类等可选项，同时提供插入按钮，点击后会在画板插入一张图片图层。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;toc-fea&quot; class=&quot;anchor&quot; href=&quot;#toc-fea&quot;/&gt;使用 skpm 初始化项目&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;skpm&lt;/code&gt; 是 Sketch 官方提供的插件管理工具，类比于 Node.js 中的 &lt;code&gt;npm&lt;/code&gt;。它集插件的创建、开发、构建、发布等多项功能于一体，我们在很多场景都需要使用它。安装的话比较简单，直接使用 &lt;code&gt;npm&lt;/code&gt; 全局安装即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs lang-cmake&quot;&gt;npm &lt;span class=&quot;hljs-keyword&quot;&gt;install&lt;/span&gt; -g skpm&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;按照官方教程，安装完毕之后我们就可以使用 &lt;code&gt;skpm create&lt;/code&gt; 命令来初始化项目目录了。当然 &lt;code&gt;skpm&lt;/code&gt; 是支持基于模板初始化的，官方仓库也列举了一些&lt;a href=&quot;https://github.com/skpm/skpm#create-a-new-plugin&quot;&gt;模板&lt;/a&gt;，我们可以使用 &lt;code&gt;--temlate&lt;/code&gt; 来指定模板进行初始化。不过处于教学的目的，我这里就还是使用官方默认的模板创建了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;➜  ~ skpm create sketch-placeimg
✔ Done!


To get started, cd into the new directory:
  cd sketch-placeimg

To start a development live-reload build:
  npm run start

To build the plugin:
  npm run build

To publish the plugin:
  skpm publish&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;skpm&lt;/code&gt; 内部会使用 &lt;code&gt;webpack&lt;/code&gt; 进行打包编译，运行 &lt;code&gt;npm run build&lt;/code&gt; 会生成 &lt;code&gt;sketch-placeimg.sketchplugin&lt;/code&gt; 目录，该目录就是最终的插件目录。双击该目录，或者将该目录拖拽到 Sketch 界面上就成功安装插件了。和 &lt;code&gt;webpack --watch&lt;/code&gt; 类似，运行 &lt;code&gt;npm run watch&lt;/code&gt; 的话对监听文件变化实时编译，在开发中非常有帮助。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 不要使用 &lt;code&gt;npm start&lt;/code&gt; 进行开发，它携带的 &lt;code&gt;--run&lt;/code&gt; 命令会使得&lt;a href=&quot;https://github.com/skpm/skpm/issues/266&quot;&gt;构建速度特别慢&lt;/a&gt;。虽然它带 Live Reload 功能会很方便，但在官方未修复该问题前还是不建议大家使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a id=&quot;toc-be7&quot; class=&quot;anchor&quot; href=&quot;#toc-be7&quot;/&gt;项目结构入门&lt;/h2&gt;
&lt;p&gt;创建好的模板目录结构如下，为了帮助大家理解，我们来简单的介绍下这些目录和文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs lang-css&quot;&gt;.
├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;README&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.md&lt;/span&gt;
├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;assets&lt;/span&gt;
│   └── &lt;span class=&quot;hljs-selector-tag&quot;&gt;icon&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.png&lt;/span&gt;
├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;sketch-assets&lt;/span&gt;
│   └── &lt;span class=&quot;hljs-selector-tag&quot;&gt;icon&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.sketch&lt;/span&gt;
├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;sketch-placeimg&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.sketchplugin&lt;/span&gt;
│   └── &lt;span class=&quot;hljs-selector-tag&quot;&gt;Contents&lt;/span&gt;
│       ├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;Resources&lt;/span&gt;
│       │   └── &lt;span class=&quot;hljs-selector-tag&quot;&gt;icon&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.png&lt;/span&gt;
│       └── &lt;span class=&quot;hljs-selector-tag&quot;&gt;Sketch&lt;/span&gt;
│           ├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;manifest&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.json&lt;/span&gt;
│           ├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;my-command&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.js&lt;/span&gt;
│           └── &lt;span class=&quot;hljs-selector-tag&quot;&gt;my-command&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.js&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.map&lt;/span&gt;
├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;node_modules&lt;/span&gt;
├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;package&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.json&lt;/span&gt;
└── &lt;span class=&quot;hljs-selector-tag&quot;&gt;src&lt;/span&gt;
    ├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;manifest&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.json&lt;/span&gt;
    └── &lt;span class=&quot;hljs-selector-tag&quot;&gt;my-command&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.js&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a id=&quot;toc-b9c&quot; class=&quot;anchor&quot; href=&quot;#toc-b9c&quot;/&gt;package.json&lt;/h3&gt;
&lt;p&gt;和大多数 JS 项目一样，&lt;code&gt;skpm&lt;/code&gt; 创建的项目中也会有 &lt;code&gt;package.json&lt;/code&gt; 文件。该文件除了像之前一样记录了项目的依赖和快捷命令之外，还增加了 &lt;code&gt;skpm&lt;/code&gt; 字段用来对 &lt;code&gt;skpm&lt;/code&gt; 进行配置，默认的值如下。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  ...
  &quot;skpm&quot;: {
    &quot;name&quot;: &quot;sketch-placeimg&quot;,
    &quot;manifest&quot;: &quot;src/manifest.json&quot;,
    &quot;main&quot;: &quot;sketch-placeimg.sketchplugin&quot;,
    &quot;assets&quot;: [
      &quot;assets/**/*&quot;
    ],
    &quot;sketch-assets-file&quot;: &quot;sketch-assets/icons.sketch&quot;
  },
  ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里指定了该插件的名称为 &lt;code&gt;sketch-placeimg&lt;/code&gt;，插件的 &lt;code&gt;manifest&lt;/code&gt; 文件为 &lt;code&gt;src/manifest.json&lt;/code&gt;。&lt;code&gt;main&lt;/code&gt; 表示的是最终生成的插件目录名称。&lt;code&gt;assets&lt;/code&gt; 则表示的插件依赖的图片等相关素材，在编译的时候会将命中该配置的文件拷贝到 &lt;code&gt;&amp;lt;main&amp;gt;/Contents/Resources&lt;/code&gt; 目录下。&lt;/p&gt;
&lt;h3&gt;&lt;a id=&quot;toc-4b1&quot; class=&quot;anchor&quot; href=&quot;#toc-4b1&quot;/&gt;manifest.json&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;manifest.json&lt;/code&gt; 这个文件大家可以理解为是 Sketch 插件的 &lt;code&gt;package.json&lt;/code&gt; 文件。我们来看看默认生成的 &lt;code&gt;manifest.json&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;$schema&quot;: &quot;https://raw.githubusercontent.com/sketch-hq/SketchAPI/develop/docs/sketch-plugin-manifest-schema.json&quot;,
  &quot;icon&quot;: &quot;icon.png&quot;,
  &quot;commands&quot;: [
    {
      &quot;name&quot;: &quot;my-command&quot;,
      &quot;identifier&quot;: &quot;sketch-placeimg.my-command-identifier&quot;,
      &quot;script&quot;: &quot;./my-command.js&quot;
    }
  ],
  &quot;menu&quot;: {
    &quot;title&quot;: &quot;sketch-placeimg&quot;,
    &quot;items&quot;: [
      &quot;sketch-placeimg.my-command-identifier&quot;
    ]
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看到 &lt;code&gt;$schema&lt;/code&gt; 就有 JSON Schema 那味了，它对应的 JSON 文件地址告诉我们可以在里面配置那些字段。其实最重要的其实就是上面列出来的 &lt;code&gt;commands&lt;/code&gt; 和 &lt;code&gt;menu&lt;/code&gt; 两个字段。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;commands&lt;/code&gt; 标记了插件有哪些命令，这里只有一个命令，命令的名称（name）是 &lt;code&gt;my-command&lt;/code&gt;，该命令的 ID（identifier）为 &lt;code&gt;sketch-placeimg.my-command-identifier&lt;/code&gt;，对应的执行脚本为 &lt;code&gt;./my-command.js&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;menu&lt;/code&gt; 则标记了该插件的导航菜单配置，比如示例这里它指定了该插件在插件菜单中的名称（title）为 &lt;code&gt;sketch-placeimg&lt;/code&gt;，并拥有一个子菜单，对应的是 ID 为&lt;code&gt;sketch-placeimg.my-command-identifier&lt;/code&gt;的命令。通过这个 ID，菜单的行为就和执行脚本关联起来了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p2.ssl.qhimgs4.com/t01d7d195029cdc4203.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a id=&quot;toc-1f1&quot; class=&quot;anchor&quot; href=&quot;#toc-1f1&quot;/&gt;appcast.xml&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;manifest.json&lt;/code&gt; 默认的示例中有两个比较重要的字段没有配置，那就是 &lt;code&gt;version&lt;/code&gt; 和 &lt;code&gt;appcast&lt;/code&gt;。&lt;code&gt;version&lt;/code&gt; 很明显就是用来表示当前插件的版本的。而 &lt;code&gt;appcast&lt;/code&gt; 它的值是一个 XML 的 URL 地址，该 XML 里面包含了该插件所有的版本以及该版本对应的下载地址。Sketch 会将 &lt;code&gt;version&lt;/code&gt; 对应的版本和 &lt;code&gt;appcast&lt;/code&gt; 对应的 XML 进行对比，如果发现有新的版本了，会使用该版本对应的下载地址下载插件，执行在线更新插件。一个 &lt;code&gt;appcast.xml&lt;/code&gt; 文件大概是这样的格式。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs lang-xml&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;rss&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;xmlns:sparkle&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.andymatuschak.org/xml-namespaces/sparkle&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;xmlns:dc&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://purl.org/dc/elements/1.1/&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;version&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;2.0&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;channel&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;item&lt;/span&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;enclosure&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;url&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;https://github.com/lizheming/sketch-placeimg/releases/download/v0.1.1/sketch-placeimg.sketchplugin.zip&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;sparkle:version&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;0.1.1&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;item&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;item&lt;/span&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;enclosure&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;url&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;https://github.com/lizheming/sketch-placeimg/releases/download/v0.1.0/sketch-placeimg.sketchplugin.zip&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;sparkle:version&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;0.1.0&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;item&lt;/span&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;channel&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;rss&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果是通过 &lt;code&gt;skpm publish&lt;/code&gt; 命令去发布插件的话，会自动在根目录生成一个 &lt;code&gt;.appcast.xml&lt;/code&gt; 文件。当然按照官方文档 &lt;a href=&quot;https://developer.sketch.com/plugins/update-a-plugin&quot;&gt;《Update a plugin》&lt;/a&gt; 所说，你也可以手动生成。&lt;/p&gt;
&lt;h3&gt;&lt;a id=&quot;resource&quot; class=&quot;anchor&quot; href=&quot;#resource&quot;/&gt;resource&lt;/h3&gt;
&lt;p&gt;从上面的内容我们可以知道，&lt;code&gt;skpm&lt;/code&gt; 会通过 &lt;code&gt;package.json&lt;/code&gt; 中指定的 &lt;code&gt;manifest&lt;/code&gt; 文件读取所有 &lt;code&gt;commands&lt;/code&gt; 对应的 &lt;code&gt;script&lt;/code&gt; 文件作为编译入口文件，将这些文档编译打包输出到 &lt;code&gt;&amp;lt;main&amp;gt;/Contents/Sketch&lt;/code&gt; 目录。所有的 &lt;code&gt;assets&lt;/code&gt; 配置对应的文件会拷贝到  &lt;code&gt;&amp;lt;main&amp;gt;/Contents/Resources&lt;/code&gt; 目录中。最终完成插件的生成。&lt;/p&gt;
&lt;p&gt;换句话来说只想要走 &lt;code&gt;webpack&lt;/code&gt; 打包编译的话就必须是插件的命令才行。如果有一些依赖的非插件类资源，比如插件嵌入的 HTML 页面依赖的 JS 文件想要走编译的话，就需要使用 &lt;code&gt;resource&lt;/code&gt; 这个配置了。&lt;code&gt;resource&lt;/code&gt; 配置中配置的文件会走 &lt;code&gt;webpack&lt;/code&gt; 的编译打包，并输出到 &lt;code&gt;&amp;lt;main&amp;gt;/Contents/Resources&lt;/code&gt; 目录中。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;toc-0e6&quot; class=&quot;anchor&quot; href=&quot;#toc-0e6&quot;/&gt;插件开发&lt;/h2&gt;
&lt;p&gt;一些基本原理了解清楚之后我们就可以进行插件的开发了。首先我们需要用户点击插件菜单之后打开一个面板，该面板可以配置尺寸、分类等基础信息。&lt;/p&gt;
&lt;p&gt;Sketch 插件中我们可以使用原生写法进行面板的开发，但是这样写起 UI 来说比较麻烦，而且对前端同学来说入门比较高。所以一般大家都会采用 WebView 加载网页的形式进行开发。原理基本上等同于移动端采用 WebView 加载网页一样，客户端调用 WebView 方法加载网页，通过实例的 &lt;code&gt;webContents.executeJavaScript()&lt;/code&gt;方法进行插件到网页的通信，而网页中则使用被重定义的 &lt;code&gt;window.postMessage&lt;/code&gt; 与插件进行通信。&lt;/p&gt;
&lt;h3&gt;&lt;a id=&quot;sketch-module-web-view&quot; class=&quot;anchor&quot; href=&quot;#sketch-module-web-view&quot;/&gt;sketch-module-web-view&lt;/h3&gt;
&lt;p&gt;想要在插件中加载网页，需要安装 Sketch 封装好的 &lt;code&gt;sketch-module-web-view&lt;/code&gt; 插件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs lang-sql&quot;&gt;npm &lt;span class=&quot;hljs-keyword&quot;&gt;install&lt;/span&gt; sketch-&lt;span class=&quot;hljs-keyword&quot;&gt;module&lt;/span&gt;-web-&lt;span class=&quot;hljs-keyword&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;--save-dev&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// src/my-command.js
import BrowserWindow from &#x27;sketch-module-web-view&#x27;;
export default function() {
  const browserWindow = new BrowserWindow({
    width: 510,
    height: 270,
    resizable: false,
    movable: false,
    alwaysOnTop: true,
    maximizable: false,
    minimizable: false
  });
  browserWindow.loadURL(require(&#x27;../resources/webview.html&#x27;))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当你做完这些你会发现点击插件菜单后什么都没有发生，这是因为还需要更改一下配置。大家可以看到我们最后是使用了 &lt;code&gt;require()&lt;/code&gt; 引入了一个 HTML 文件，而官方默认的模板是没有提供 HTML 引入的支持的，所以我们需要为 HTML 文件增加对应的 webpack loader。&lt;/p&gt;
&lt;p&gt;我们这里需要的是 &lt;code&gt;html-loader&lt;/code&gt; 和 &lt;code&gt;@skpm/extract-loader&lt;/code&gt; 两款 Loader。前者是用来解析处理 HTML 中存在的包括 &lt;code&gt;&amp;lt;link /&amp;gt;&lt;/code&gt; 或者 &lt;code&gt;&amp;lt;img /&amp;gt;&lt;/code&gt; 之类的 HTML 代码中可能存在的资源关联情况。而后者则是用来将 HTML 文件拷贝到 &lt;code&gt;&amp;lt;main&amp;gt;/Contents/Resources&lt;/code&gt; 目录并返回对应的 &lt;code&gt;file:///&lt;/code&gt; 格式的文件路径 URL，用来在插件中进行关联。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs lang-sql&quot;&gt;npm &lt;span class=&quot;hljs-keyword&quot;&gt;install&lt;/span&gt; html-loader @skpm/&lt;span class=&quot;hljs-keyword&quot;&gt;extract&lt;/span&gt;-loader &lt;span class=&quot;hljs-comment&quot;&gt;--save-dev&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Sketch 插件官方为我们自定义 webpack 配置也预留好了入口，在项目根目录中创建 &lt;code&gt;webpack.skpm.config.js&lt;/code&gt; 文件，它导出的方法接收的参数中第一个则是插件最终的 webpack 配置，我们直接在这基础上进行修改即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// webpack.skpm.config.js
module.exports = function (config, entry) {
  config.module.rules.push({
    test: /\.html$/,
    use: [
      { loader: &quot;@skpm/extract-loader&quot; },
      {
        loader: &quot;html-loader&quot;,
        options: {
          attributes: {
            list: [
              { tag: &#x27;img&#x27;, attribute: &#x27;src&#x27;, type: &#x27;src&#x27; },
              { tag: &#x27;link&#x27;, attribute: &#x27;href&#x27;, type: &#x27;src&#x27; }
            ]
          }
        }
      }
    ]
  });
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; &lt;code&gt;html-loader&lt;/code&gt; 插件在新版里对配置格式做了一些修改，所以之前很多老的教程中的配置都会报错。当然如果你有更多的插件需求也可以按照这个流程往配置对象中添加。之后我们再执行 &lt;code&gt;npm run watch&lt;/code&gt;，点击菜单就可以看到我们预期的页面了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p2.ssl.qhimgs4.com/t018d066fdf4976461a.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 官方是提供了一套带有 &lt;code&gt;sketch-module-web-view&lt;/code&gt; 模块的模板的，这里只是为了能更清楚的给大家解释清楚插件的原理和流程所以和他家一步一步的进行说明。真实的开发场景中建议大家直接使用以下命令进行快速初始化。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;skpm create &amp;lt;plugin-name&amp;gt; --template=skpm/with-webview&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;a id=&quot;toc-cdc&quot; class=&quot;anchor&quot; href=&quot;#toc-cdc&quot;/&gt;React 的集成&lt;/h3&gt;
&lt;p&gt;面板这块我准备使用 React 进行开发，主要是有 &lt;a href=&quot;http://reactdesktop.js.org/&quot;&gt;React Desktoop&lt;/a&gt; 这个 React 组件，能够很好的在 Web 中模拟 Mac OSX 的 UI 风格（虽然也就几个表单没什么好模拟的就是了）。&lt;/p&gt;
&lt;p&gt;令人开心的是 &lt;code&gt;skpm&lt;/code&gt; 默认的 webpack 配置已经增加了 React 的支持，所以我们不需要额外的增加 webpack 的配置，只需要把 React 相关的依赖安装好就可以进行开发了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm install react react-dom react-desktop --save-dev&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;增加 &lt;code&gt;webview.js&lt;/code&gt; 入口文件。由于该文件需要走 webpack 编译，但是又不是插件命令的执行文件，所以我们需要像上文说的，将入口文件加入到 &lt;code&gt;package.json&lt;/code&gt; 的 &lt;code&gt;skpm.resources&lt;/code&gt; 配置中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs lang-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// package.json&lt;/span&gt;
{
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;skpm&quot;&lt;/span&gt;: {
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;resources&quot;&lt;/span&gt;: [
      &lt;span class=&quot;hljs-string&quot;&gt;&quot;resources/webview.js&quot;&lt;/span&gt;
    ]
  }
}

&lt;span class=&quot;hljs-comment&quot;&gt;// resources/webview.js&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; React &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#x27;react&#x27;&lt;/span&gt;;
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; ReactDOM &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#x27;react-dom&#x27;&lt;/span&gt;;

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;App&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;/&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;Hello World!&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;hr&lt;/span&gt; /&amp;gt;&lt;/span&gt;
    via: &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;em&lt;/span&gt;&amp;gt;&lt;/span&gt;@lizheming&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;em&lt;/span&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;)
}

ReactDOM.render(&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;App&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;hljs-built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;hljs-string&quot;&gt;&#x27;app&#x27;&lt;/span&gt;));&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;webview.html&lt;/code&gt; 也需要改造一下，引入 JS 入口文件。这里需要注意一下 &lt;code&gt;../resource_webview.js&lt;/code&gt; 这个引用文件地址，这是 JS 入口文件编译后最终的文件地址。主要是因为 HTML 文件最终会生成到 &lt;code&gt;&amp;lt;name&amp;gt;.sketchplugin/Resources/_webpack_resources&lt;/code&gt; 目录下，而 JS 入口文件会将 &lt;code&gt;/&lt;/code&gt; 分隔符替换成 &lt;code&gt;_&lt;/code&gt; 分隔符，生成在 &lt;code&gt;&amp;lt;name&amp;gt;.sketchplugin/Resources&lt;/code&gt; 目录下。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;zh-CN&quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot; /&amp;gt;
    &amp;lt;title&amp;gt;PlaceIMG&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id=&quot;app&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;script src=&quot;../resources_webview.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/skpm/skpm/blob/master/packages/builder/src/utils/resourceLoader.js#L7-L21&quot;&gt;HTML 文件生成到 &lt;code&gt;_webpack_resources&lt;/code&gt; 配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/skpm/skpm/blob/master/packages/builder/src/utils/webpackConfig.js#L163-L169&quot;&gt;JS 入口文件生成到 &lt;code&gt;Resource&lt;/code&gt; 目录配置&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;a id=&quot;toc-416&quot; class=&quot;anchor&quot; href=&quot;#toc-416&quot;/&gt;面板开发&lt;/h3&gt;
&lt;p&gt;流程打通了之后接下来我们可以专心进行面板的开发了。面板开发这块就不多描述了，无非就是前段页面的编写而已，最后插件面板大概是长这样子的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p2.ssl.qhimgs4.com/t01d9753783666f4713.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;-_-||嗯，其实我就是想和大家讲下流程硬上 React 的…&lt;/p&gt;
&lt;p&gt;选择完毕点击插入后，调用 &lt;code&gt;postMessage()&lt;/code&gt; 方法将最终的配置传递给插件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;//resources/webview.js
import React, {useReducer} from &#x27;react&#x27;;

function App() {
  const [{width, height, category, filter}, dispatch] = useReducer(
    (state, {type, ...payload}) =&amp;gt; ({...state, ...payload}),
    {width: undefind, height: undefined, category: &#x27;any&#x27;, filter: &#x27;none&#x27;}
  );
  const onInsert = _ =&amp;gt; postMessage(&#x27;insert&#x27;, width, height, category, filter);
  return (
    &amp;lt;button onClick={onInsert}&amp;gt;插入&amp;lt;/button&amp;gt;
  );
}&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; Web 原生的 &lt;code&gt;postMessage()&lt;/code&gt; 方法的语法为 &lt;code&gt;postMessage(message, targetOrigin, [transfer])&lt;/code&gt;。事件名称和事件参数都应该序列化之后通过 &lt;code&gt;message&lt;/code&gt; 参数传入。&lt;/p&gt;
&lt;p&gt;Sketch 插件中的 &lt;code&gt;postMessage()&lt;/code&gt; 方法是注入方法，它对原生的方法进行了复写，所以参数格式上会与原生的不一样。注入方法的实现可参见 &lt;a href=&quot;https://github.com/skpm/sketch-module-web-view/blob/master/lib/inject-client-messaging.js&quot;&gt;&lt;code&gt;sketch-module-web-view&lt;/code&gt; 代码&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在插件中，我们监听 &lt;code&gt;insert&lt;/code&gt; 事件，获取到用户选择的配置之后给生成图片图层插入到画板中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;//src/my-command.js
import sketch, { Image, Rectangle } from &#x27;sketch/dom&#x27;;
import BrowserWindow from &#x27;sketch-module-web-view&#x27;;

export default function() {
  const browserWindow = new BrowserWindow({...});
  browserWindow.webContents.on(&#x27;insert&#x27;, function(width, height, category, filter) {
    const url = &#x27;https://placeimg.com/&#x27; + [width, height, category, filter].join(&#x27;/&#x27;);
    new Image({
      image:  NSURL.URLWithString(url),
      parent: getSelectedArtboard(),
      frame: new Rectangle(0, 0, width, height),
    });
    return browserWindow.close();
  });
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a id=&quot;toc-a30&quot; class=&quot;anchor&quot; href=&quot;#toc-a30&quot;/&gt;插件发布&lt;/h2&gt;
&lt;p&gt;最终我们的插件的主体功能就开发完毕了。下面我们就可以进行插件的发布了。我们可以直接使用 &lt;code&gt;skpm publish&lt;/code&gt; 进行发布，它需要你通过 &lt;code&gt;skpm publish --repo-url&lt;/code&gt; 或者是 &lt;code&gt;package.json&lt;/code&gt; 中的 &lt;code&gt;repository&lt;/code&gt; 字段为插件指定 Github 仓库地址。&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&quot;https://github.com/settings/tokens&quot;&gt;Personal Access Token&lt;/a&gt; 页面为 skpm 申请新的 Token，记得勾选上 &lt;code&gt;repo&lt;/code&gt; 操作的权限。使用 &lt;code&gt;skpm login &amp;lt;token&amp;gt;&lt;/code&gt; 进行登录之后，skpm 就获得了操作项目的权限。&lt;/p&gt;
&lt;p&gt;最后通过 &lt;code&gt;skpm publish &amp;lt;version&amp;gt;&lt;/code&gt; 就可以成功发布了。如前文所说，发布后会在项目目录创建 &lt;code&gt;.appcast.xml&lt;/code&gt; 文件，同时会发布一条对应版本的 Release 记录，提供插件的 zip 包下载地址。执行完 publish 操作后，如果发现你的插件还没有在&lt;a href=&quot;https://github.com/sketchplugins/plugin-directory&quot;&gt;插件中心仓库&lt;/a&gt;中列出来，还会询问你是否提交个 PR 把自己的插件增加上。&lt;/p&gt;
&lt;p&gt;当然如果你的插件不方便发布到 Github 上，也可以使用前文所说的手工发布，执行 &lt;code&gt;skpm build&lt;/code&gt; 后对生成的 &lt;code&gt;&amp;lt;name&amp;gt;.sketchplugin&lt;/code&gt; 目录进行打包即可。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;toc-688&quot; class=&quot;anchor&quot; href=&quot;#toc-688&quot;/&gt;插件调试&lt;/h2&gt;
&lt;p&gt;上文的示例插件比较简单，所以没有使用特别多的调试手段。在官方教程&lt;a href=&quot;https://developer.sketch.com/plugins/debugging&quot;&gt;《Debug a plugin》&lt;/a&gt;中描述了多种可以进行调试的方式。用的比较多的还是日志调试方式，可以使用系统的 &lt;code&gt;Console.app&lt;/code&gt; 查看日志，也可以使用 &lt;code&gt;skpm log -f&lt;/code&gt; 插件日志。&lt;/p&gt;
&lt;p&gt;文档里说的大部分是插件的调试，WebView 内的前端代码调试会更简单一点。WebView 窗体右键审查元素即可使用 Safari 的开发者工具进行调试了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 插件本身的代码本质是客户端代码，WebView 本质是前端代码，所以两者的调试和日志输出位置都是有区别的，这里要注意区分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a id=&quot;toc-7a0&quot; class=&quot;anchor&quot; href=&quot;#toc-7a0&quot;/&gt;后记&lt;/h2&gt;
&lt;p&gt;以上就是开发 Sketch 的一些基础知识和简单流程，其它的就是多去看一下 &lt;a href=&quot;https://developer.sketch.com/reference/api/&quot;&gt;Sketch API&lt;/a&gt; 文档了。不过在实际的使用中 Sketch 的这套 JavaScript API 并不是非常完美，部分功能可能还暂时需要使用原生 API 区别。这时候可以多 Google 一下，能找到很多前人的实现，节省自己的工作量。&lt;/p&gt;
&lt;p&gt;本文主要是介绍了一套 JavaScript API + WebView 的偏前端的开发方式，代码我都已经放到 Github 上 &lt;a href=&quot;https://github.com/lizheming/sketch-placeimg&quot;&gt;https://github.com/lizheming/sketch-placeimg&lt;/a&gt;，大家可以自行查阅和下载。除了这种方式之外，我们也可以使用 OC + WebView 甚至是纯 OC 客户端的方式去开发插件。使用纯客户端开发的话性能会比 JavaScript API 的形式好一点，但是对于不了解 OC 开发的前端同学来说上手难度还是比较高的。&lt;/p&gt;
&lt;p&gt;除了 Sketch 之外，Figma 也是一款非常棒的 UI 设计软件。它基于 Web 开发，天生跨平台，更提供了更加易用的协作模式，解决 UI 开发中的多人协作问题。感兴趣的同学也可以去了解一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28325423&quot;&gt;《Sketch插件开发总结》&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3ee3a901966fe023e7699dda06f92296</guid>
<title>如何一步步 get 大厂前端 offer，或许你可以参考这份成长经历</title>
<link>https://toutiao.io/k/ekbitqq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;之前在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&amp;amp;mid=2247484495&amp;amp;idx=1&amp;amp;sn=3039d0ddfe1c93e945b2ee1f63516053&amp;amp;scene=21#wechat_redirect&quot; title=&quot;《前端菜鸟的阿里实习百日之旅》&quot; data-linktype=&quot;2&quot;&gt;《前端菜鸟的阿里实习百日之旅》&lt;/a&gt;一文中，我的好友「承和」分享了一些作为前端开发实习生的感悟，文章发出后，很多人在后台询问能不能谈谈前端的学习路径，以及作为一个萌新如何拿到大厂的前端 offer。的确，秋招已过去大半，下一波待就业的应届生们也可以开始考虑实习和春招了，为此，本文以 Q&amp;amp;A 形式邀请了他来讲述他是如何一步步 get 大厂的前端 offer，希望他的成长经历可以为正在准备的人带来一些启发。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzUgfoTYVhuOGlhzvGrmSwljH29T5mBzM4zCItp8VItFBDq4zyibJ617GGF6FI6TM4MJaGgVOAiauicA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1440&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;Q：初来乍到，先做个简单的自我介绍吧&lt;/h3&gt;&lt;p&gt;「01 二进制」的读者，你们好，我是承和，目前是一名计算机专业的研三学生，就读于杭州电子科技大学，本科就读于马爸爸的母校，也就是杭州师范大学。在此次秋招中，很幸运的拿到了阿里，字节，拼多多等公司的 Offer，希望我的成长经历能对你们有所启发。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzUgfoTYVhuOGlhzvGrmSwl4Nc3avnKHah39Dqia2ician2SPh5XiapN4xCqUCVuibQOsmAwQ7y6qOUibgA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;320&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;Q：能不能简单说说你这些年的前端学习经历呢？&lt;/h3&gt;&lt;p&gt;说起前端，其实我最早接触的是 iOS 客户端开发。在我大二的时候，苹果发布了最新的开发语言 Swift，恰巧在当时，我在编程上的启蒙老师所在的实验室正在招新，听说加入还会分配 MacBook，于是我马上联系了他。就这样我顺理成章的白嫖到了一台 MacBook Air 笔记本，而当时分配到的任务是开发一款 App，也正是从这个任务开始，我走上了软件开发这条不归路。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6648648648648648&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzUgfoTYVhuOGlhzvGrmSwlYx297k6fTEpJhACmno3mlmHc5JRJJJwWKschVMiayhua6ic55Cssb0Lg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;555&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;后来实验室为了减少开发和维护的成本，导师让我学习有关跨平台应用开发技术，也正是从那时起，我逐渐接触到前端开发。在学习过程中，我发现，相对于客户端，前端开发有更广的发展空间，再加上当时客户端的就业形势是&lt;strong&gt;&quot;49 年入国军&quot;&lt;/strong&gt;，因此，毅然决然地选择了前端开发。&lt;/p&gt;&lt;p&gt;再后来，读研期间，学习了点深度学习的相关知识，发现这玩意儿极其烧脑，加上国内学术圈又相当浮躁，多数研究生基本都是为了发论文而发论文，很少有能实际落地应用到工程之中的。加之现在算法岗 hc 非常少，大厂的算法岗几乎是神仙打架，想着肯定是没办法靠算法吃饭了，所以又重新投入到了前端的怀抱中，从 0 开始学起，好好沉淀自己的前端技术。&lt;/p&gt;&lt;h3&gt;Q：你这也算是有了几年开发经验的老鸟了，要不简单谈谈你是如何学习前端技术的？&lt;/h3&gt;&lt;p&gt;我个人认为，学习编程就和练武一样，学习任何一门技术都是&lt;strong&gt;修炼内功&lt;/strong&gt;和&lt;strong&gt;学习招式&lt;/strong&gt;的过程。内功指的就是基础，就前端领域而言，也就是我们常说的前端三板斧：&lt;strong&gt;HTML、CSS 和 JS&lt;/strong&gt;。我们可以根据网上较流行的知识图谱或者一个面试宝典，进行初步的学习。若想要深刻了解的话，便要通过阅读大量相关的专业书籍来加强理解（后面我也会推荐一些，此处没有广告，可放心食用）。&lt;/p&gt;&lt;p&gt;招式指的便是各种&lt;strong&gt;前端框架&lt;/strong&gt;，这些框架帮助我们封装了底层对于 dom 的操作等，使我们能够专注于业务代码的编写。现如今国内 Vue 和 React 大行其道，但是作为 JS 革命性的框架之一，jQuery 我们自然不能忘记，该框架非常适合前端入门者进行学习。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6646153846153846&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzUgfoTYVhuOGlhzvGrmSwlJlqX4oIO3kLNTbZq1UyYrziaGfeAEwB9LYHRdxCr4RVPaGibecu7MVXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1625&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;对于框架的学习大致可以分为以下 3 个步骤 👇：&lt;/p&gt;&lt;p&gt;第一步，学会&lt;strong&gt;招式的使用，&lt;/strong&gt;你要学会怎么用它，知道这个框架究竟解决了哪些问题，这些资料最好的获取方式便是官网，例如 React 官网，便清楚的说明了 React 的用途，在开发中大多数遇到的问题也能在 React 官网上找到解决方法。&lt;/p&gt;&lt;p&gt;第二步便是用框架做一个项目，在编写项目的过程中，你会遇到很多&quot;稀奇古怪&quot;的问题，通过解决这些问题，可以加深你对框架的理解。&lt;/p&gt;&lt;p&gt;第三步要做到知其然知其所以然，在熟练掌握框架的使用后，去学习它的源码，去看一些源码解析或者大佬的直播课，最好是自己手动实现一个类似于 React 的 diff 算法。&lt;/p&gt;&lt;h3&gt;Q：在学习的过程中，有什么需要注意的呢？&lt;/h3&gt;&lt;p&gt;在学习过程中你会接触到非常多的知识点，难免会产生焦虑，这时候要做的就是定义一个边界，做到对另一个知识点的探索&lt;strong&gt;适可而止&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;例如，在利用 React 脚手架的开发过程当中，我们会接触到 Webpack，我们可以先用脚手架中 Webpack 默认配置来进行项目开发，去了解 Webpack 的功能和大致打包流程，来做到对 Webpack 的整体认识，在后续进行项目优化时，可以尝试对默认配置进行修改，通过熟读 Webpack 官网，了解针对 Webpack，我们有哪些优化手段，并且付诸于实践，在工程当中加深自己对于框架和工具的理解。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzUgfoTYVhuOGlhzvGrmSwlz41kjQtatIKVdNvIJh7XxzF92l6hFkUe9CXW1ksR0A7GwiclT5uRjbA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1620&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;上述是如何学习一个前端框架的简单例子。我们有时候会感叹，这么多的知识点，我们如何来进行学习，这也是国内技术面试的现状：&lt;strong&gt;面试造火箭，工作拧螺丝&lt;/strong&gt;。在准备面试的过程当中，我们可以通过一个面试宝典或知识点的总结来系统的学习前端，随后其余教程和专业书籍加深你对知识点的理解，根据人类的遗忘周期，大概会在第二至第三天会忘掉大部分第一天学习的知识，因此，通过反复学习，反复理解，&lt;strong&gt;达到内功和招式的相互影响，最终修炼成功！&lt;/strong&gt;&lt;/p&gt;&lt;h3&gt;Q：作为一个 Offer 收割机，关于前端面试你有什么想说的呢？&lt;/h3&gt;&lt;p&gt;正如上文提到的，国内现在的技术面试基本是“面试造火箭，工作拧螺丝“，在准备面试过程当中，要求我们既有较广的知识面，又需要在一个领域有比较深入地研究。比如面试官会非常感兴趣问 React 源码相关的一些问题，这可能在我们的工作过程当中基本接触不到，因为一般的大厂都有自己的组件库和针对自己的业务，会对市面上较流行的脚手架工具都做一层封装，大部分的开发人员都属于”搬砖“的角色，也就是完成特定的任务即可。所以，这时候就会用人问了，明明是工作中不常用的知识点，为什么面试官就喜欢问呢？&lt;/p&gt;&lt;p&gt;个人看来，问源码能考察一位同学对该项技术是否有思考和热情，因为框架的使用基本每一个人都会，然而对于源码的阅读和理解，有助于更深层次的去理解框架，在开发中遇到一些问题时，也能够更加快速的去定位问题，有相应的方法去解决。将来在做业务的技术选型时，因为你知道各个框架的利弊，所以能够更加快速的做出决策和进行开发。这也就是面试官喜欢考察源码的原因，在原有的广度基础上，来查看我们的知识点深度究竟在哪里。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6670784434836319&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzUgfoTYVhuOGlhzvGrmSwlvuBlQnawyxUz3FkCVX1eeEy81lGrib53ottb2JiaNGFPJFg8DKpBLh7w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1619&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;Q：简单分享一下你的面经吧&lt;/h3&gt;&lt;p&gt;面试一般分为三个部分，自我介绍，面试官提问，和同学提问。其中第一部分和第三部分我们需要进行详细的准备，自我介绍准备一分钟左右时长即可，对于应届生来说，可能没有太多的项目经验，我们可以介绍下自己学习前端的过程和相对比较擅长的技术栈，有目的性的来引导面试官问对应的问题。面试官基本也会挑你简历上写的知识点来问，这时候就要求我们对简历上的每一个知识点都要做到胸有成竹，在写该知识点的时候，可以模拟下面试官可能会问些什么问题，对知识点进行总结和有逻辑性的表达，在回答过程当中也可以合理的“埋坑”，引导面试官往自己擅长的知识点上问。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6642066420664207&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzUgfoTYVhuOGlhzvGrmSwlVjO3dW89pRrEx39C49WVCWuf5E6pJtU3aLTm7xZiaiaY38sQf7aicZfnA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1626&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;举一个较简单的例子，浏览器中输入 URL 究竟发生了什么，你回答了相关步骤中有一步为浏览器根据返回的状态码进行判断再进行后续操作。那么接下来面试官可能会问你你了解到的状态码有哪些。你经过准备也知道这个知识点，便能自信的回答。在最后一个环节反向提问的过程中，可以针对职位相对应的技术栈和相关的业务，或者此次面试过程中有什么不足点，有什么建议进行提问，有时高质量的提问也能提升面试官的印象分。在面试后我们要进行及时的复盘和总结，例如每一个提问知识点的及时记录，对于在此次面试过程中发挥不好的地方，及时想出对应的方法总结，有利于在下次面试中更充分的发挥自己的实力。&lt;/p&gt;&lt;h3&gt;Q：要不推荐一些资料呗？&lt;/h3&gt;&lt;p&gt;下面是我个人推荐的较好的学习资料，既有书籍也有博客等。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;HTML：基本概念和常用标签的掌握，h5 新标签和新特性。html 语义化等。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;CSS：《CSS 世界》(从流的概念来讲解) ,flex 布局(阮一峰教程)。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;JS:《JavaScript 高级程序设计第 4 版》(红宝书反复看) 《你不知道的 JS》《javascript 语言精髓与编程实践》&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;ES6:菜鸟教程 ES6(大致浏览新特性) 《阮一峰 ES6 标准入门》(api 细节查看)&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Typescript:ts 官网，&lt;span&gt;一文学会 TypeScript 的 82% 常用知识点（上）&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Vuejs:vue 官网(建议花 2-3 天完完整整的看下来)， 《剖析 vuejs 运行机制》(染陌大佬编写) &lt;span&gt;逐行分析 vue 源码&lt;sup&gt;[2]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;React:react 官网，《深入浅出 react 技术栈》，&lt;span&gt;React 技术揭秘&lt;sup&gt;[3]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Webpack:webpack 官网，《深入浅出 webpack》&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Node:nodejs 菜鸟教程(快速上手),《深入浅出 nodejs》(掌握 node 的事件循环和垃圾回收算法，有精力可以研究 v8 源码)。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;计算机网络：《图解 HTTP》(反复看)，《计算机网络》(谢希仁著)&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;数据结构：《算法》(书名就叫算法，虽然是 java 写的，但也能看得懂)。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;设计模式：《javascript 设计模式与开发实践》&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;知识点总结和面试宝典：&lt;span&gt;个人秋招经验总结(前端方向)&lt;sup&gt;[4]&lt;/sup&gt;&lt;/span&gt; &lt;span&gt;前端面试与进阶指南&lt;sup&gt;[5]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;子弈大佬的面经: &lt;span&gt;个人前端资源汇集（持续更新）&lt;sup&gt;[6]&lt;/sup&gt;&lt;/span&gt; &lt;span&gt;面试分享：两年工作经验成功面试阿里 P6 总结&lt;sup&gt;[7]&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.3326226012793176&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzUgfoTYVhuOGlhzvGrmSwllTZObIf1Pic0biaqNDjmDzaAh6bwuzJkE9zKiclGYscK8p2WkEX4gyLqg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;469&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;最后&lt;/h3&gt;&lt;p&gt;这便是简单的一些前端学习和面试经验的分享，希望对你的前端学习和面试都有一定的帮助。欢迎各位读者留言讨论，也欢迎添加我的微信，进一步的交流和分享前端经验，预祝小伙伴们都有自己满意的 offer！&lt;/p&gt;&lt;section&gt;&lt;mp-qa class=&quot;js_uneditable custom_select_card qa_iframe&quot; data-pluginname=&quot;insertquestion&quot; data-id=&quot;1558506325456781314&quot; data-bizuin=&quot;Mzg2ODAyNTgyMQ==&quot; data-title=&quot;对于前端学习，你有什么想说的想问的吗？&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.3371104815864023&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzUgfoTYVhuOGlhzvGrmSwlZaiaicmBYDtPNzTbRUFb2kgRQkd55SqeGZJg0gmjdJHSWh0xOJgrMTyw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;353&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;References&lt;/h3&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; 一文学会 TypeScript 的 82% 常用知识点（上）: &lt;em&gt;https://www.cnblogs.com/sexintercourse/p/11961086.html&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[2]&lt;/code&gt; 逐行分析 vue 源码: &lt;em&gt;https://www.bbsmax.com/A/lk5aPaE4J1/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[3]&lt;/code&gt; React 技术揭秘: &lt;em&gt;https://react.iamkasong.com/#%E7%AB%A0%E8%8A%82%E8%AF%B4%E6%98%8E&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[4]&lt;/code&gt; 个人秋招经验总结(前端方向): &lt;em&gt;https://www.nowcoder.com/discuss/258810?type=post&amp;amp;order=time&amp;amp;pos=&amp;amp;page=3&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[5]&lt;/code&gt; 前端面试与进阶指南: &lt;em&gt;https://www.cxymsg.com/guide/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[6]&lt;/code&gt; 个人前端资源汇集（持续更新）: &lt;em&gt;https://juejin.im/post/6844904116590739469&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[7]&lt;/code&gt; 面试分享：两年工作经验成功面试阿里 P6 总结: &lt;em&gt;https://juejin.im/post/6844903928442667015&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f5b6343016d4488fbb09cb98c1146989</guid>
<title>图文结合，白话 Go 的垃圾回收原理</title>
<link>https://toutiao.io/k/51hfsz6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面两篇文章介绍了Go语言的&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247485736&amp;amp;idx=1&amp;amp;sn=921a9dfe3d638074b68a4fd072ea3cb9&amp;amp;chksm=fa80d8bfcdf751a948ea49ee620ca9d88ff0a62b4ad4e3a53321fee6813b8f90098fd72f7b11&amp;amp;token=940952510&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;内存分配策略&lt;/a&gt;以及&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247485886&amp;amp;idx=1&amp;amp;sn=f29fe2ce95a485e2c2ef1c4cd33b5085&amp;amp;chksm=fa80d829cdf7513fdf45b16be023809d9725b150803b6482643c3dd84aa3c0090c2cb9efd3aa&amp;amp;token=940952510&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Go协程动态扩充和收缩栈内存的原理&lt;/a&gt;，今天这篇文章我们主要来聊一下内存管理的另外一大块内容：垃圾回收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面首先我们会聊一下什么是GC (垃圾回收)，GC的作用是什么，然后再结合图示用每个人都能听懂的大白话解释Go的GC原理。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是GC？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现代高级编程语言管理内存的方式分为两种：自动和手动，像C、C++ 等编程语言使用手动管理内存的方式，工程师编写代码过程中需要主动申请或者释放内存；而 PHP、Java 和 Go 等语言使用自动的内存管理系统，有内存分配器和垃圾收集器来代为分配和回收内存，其中垃圾收集器就是我们常说的GC。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;GC回收的是什么？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在应用程序中会使用到两种内存，分别为堆（Heap）和栈（Stack），GC负责回收堆内存，而不负责回收栈中的内存。那么这是为什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要原因是栈是一块专用内存，专门为了函数执行而准备的，存储着函数中的局部变量以及调用栈。除此以外，栈中的数据都有一个特点——简单。比如局部变量不能被函数外访问，所以这块内存用完就可以直接释放。正是因为这个特点，栈中的数据可以通过简单的编译器指令自动清理，并不需要通过 GC 来回收。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;GC算法的种类&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主流的垃圾回收算法有两大类，分别是追踪式垃圾回收算法和引用计数法（ Reference counting ）。而Go语言现在用的三色标记法就属于追踪式垃圾回收算法的一种。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;追踪式算法的核心思想是判断一个对象是否可达，一旦这个对象不可达就可以在垃圾回收的控制循环里被 GC 回收了。那么我们怎么判断一个对象是否可达呢？很简单，第一步找出所有的全局变量和当前函数栈里的变量，标记为可达。第二步，从已经标记的数据开始，进一步标记它们可访问的变量，以此类推。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go的垃圾回收算法&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go的垃圾收集器从一开始到现在一直在演进，在v1.5版本开始三色标记法作为垃圾回收算法前使用&lt;strong&gt;Mark-And-Sweep&lt;/strong&gt;（标记清除）算法。从v1.5版本Go实现了基于&lt;strong&gt;三色标记清除的并发&lt;/strong&gt;垃圾收集器，大幅度降低垃圾收集的延迟从几百 ms 降低至 10ms 以下。在v1.8又使用&lt;strong&gt;混合写屏障&lt;/strong&gt;将垃圾收集的时间缩短至 0.5ms 以内。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;标记清除算法的缺点&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Mark-And-Sweep&lt;/strong&gt;，这个算法就是严格按照追踪式算法的思路来实现的。这个垃圾回收算法的执行流程可以用下面这张图来表示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;2.031613976705491&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/z4pQ0O5h0f4Wt7WE18DVyFiaPG2C5Uyib3vZ40yEAiaviasqGLxEW1MwP6HwnZTSqeCibDZXL0pH527xtnEh9xOhujA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;601&quot;/&gt;&lt;figcaption&gt;垃圾回收--标记清除&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此算法主要有两个步骤：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;暂停应用程序的执行, 从根对象出发标记出可达对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;清除未标记的对象，恢复应用程序的执行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个算法最大的问题是 GC 执行期间需要把整个程序完全暂停，不能异步地进行垃圾回收，对实时性要求高的系统来说，这种需要长时间挂起的标记清扫法是不可接受的。所以就需要一个算法来解决 GC 运行时程序长时间挂起的问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;三色标记清除法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从v1.5版本Go实现了基于&lt;strong&gt;三色标记清除的并发&lt;/strong&gt;垃圾收集器，注意&lt;strong&gt;三色标记&lt;/strong&gt;这个算法不是Go的垃圾收集器独有的。这个算法背后的核心思想是由Edsger W. Dijkstra，Leslie Lamport，A.J.Martin，C.S.Scholten和E.F.M.Steffens提出的，算法首先于1978年发表在论文&lt;span&gt;*On-the-fly Garbage Collection：An Exercise in Cooperation*&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;上面。三色标记清除算法背后的首要原则就是它把堆中的对象根据它们的颜色分到不同集合里面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三色标记算法将程序中的对象分成白色、黑色和灰色三类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;白色对象 — 潜在的垃圾，其内存可能会被垃圾收集器回收；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;黑色对象 — 活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象，垃圾回收器不会扫描这些对象的子对象；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;灰色对象 — 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文字解释起来不太好理解，我用下面几张图演示一下三色标记清除的整个过程：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第一步：在进入GC的三色标记阶段的一开始，所有对象都是白色的。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5910878112712975&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4Wt7WE18DVyFiaPG2C5Uyib3Nzw2JVKp2Yb0ic2TiaqGBzicxhEYIGndsIYlvlCiakQFibTIMwckKy7FibVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1526&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第二步, 遍历根节点集合里的所有根对象，把根对象引用的对象标记为灰色，从白色集合放入灰色集合。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5947712418300654&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4Wt7WE18DVyFiaPG2C5Uyib3dA0l02vibL9iau9ibUzibN2LxKfL75PF4neicrGvzzfE3CXR4xHxxqVbiakQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1530&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第三步, 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合&lt;/strong&gt;&lt;img data-ratio=&quot;0.5973856209150327&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4Wt7WE18DVyFiaPG2C5Uyib3V0Nh0p9q4rTqic66muZfnVb0bVbYaiasU5qgovyK4x59F5aFjJOcKd2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1530&quot;/&gt;&lt;strong&gt;第四步：重复第三步, 直到灰色集合中无任何对象。&lt;/strong&gt;&lt;img data-ratio=&quot;0.609375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4Wt7WE18DVyFiaPG2C5Uyib3icre2fEw3yVtOiaX1fo1foqeOg1e7QRXMia5tcAY7GJWu9fnu4Fq1Jhww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1536&quot;/&gt;&lt;strong&gt;第五步：回收白色集合里的所有对象，本次垃圾回收结束。&lt;/strong&gt;&lt;img data-ratio=&quot;0.594488188976378&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4Wt7WE18DVyFiaPG2C5Uyib3CeBkJth5gYBK4YWWG3wrickbVQpHV1nwXqiadZqBL5uibk3bY8YqaubVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1524&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里所说的根节点集合里的根对象就是栈上的对象或者堆上的全局变量。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;写屏障&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Go&lt;/code&gt; 在GC阶段执行三色标记前，还需要先做一个准备工作——打开写屏障(Write Barrier)。那么写屏障是什么呢？我们知道三色标记法是一种可以并发执行的算法。所以在GC运行过程中程序的函数栈内可能会有新分配的对象，那么这些对象该怎么通知到 GC，怎么给他们着色呢？如果还是按照之前新建的对象标记为白色就有可能出现下图中的问题：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5846774193548387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4Wt7WE18DVyFiaPG2C5Uyib3DvWGYAkN0xonqzEpthFIo0HkqLCDpR1zb7XEOjwttcUogAu4icoia9xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1488&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在GC进行的过程中，应用程序新建了对象&lt;code&gt;I&lt;/code&gt;，此时如果已经标记成黑的对象&lt;code&gt;F&lt;/code&gt;引用了对象&lt;code&gt;I&lt;/code&gt;，那么在本次GC执行过程中因为黑色对象不会再次扫描，所以如果&lt;code&gt;I&lt;/code&gt;着色成白色的话，会被回收掉，这显然是不允许的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候就需要我们的&lt;strong&gt;写屏障&lt;/strong&gt;出马了。&lt;strong&gt;写屏障&lt;/strong&gt;主要做一件事情，修改原先的写逻辑，然后在对象新增的同时给它着色，并且着色为灰色。因此打开了写屏障可以保证了三色标记法在并发下安全正确地运行。&lt;span&gt;那么有人就会问这些写屏障标记成灰色的对象什么时候回收呢？&lt;/span&gt;&lt;span&gt;答案是后&lt;/span&gt;&lt;span&gt;续的GC过程中回收，在新的GC过程中所有已存对象就又从白色开始逐步被标记啦。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;三色不变性&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的任意一种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;屏障技术&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垃圾收集中的屏障技术更像是一个钩子方法，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以将它们分成读屏障（Read barrier）和写屏障（Write barrier）两种，因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以编程语言往往都会采用写屏障保证三色不变性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Go的混合写屏障&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;Go&lt;/code&gt; 语言 v1.7 版本之前，使用的是&lt;code&gt;Dijkstra&lt;/code&gt;插入写屏障保证强三色不变性，但是运行时并没有在所有的垃圾收集根对象上开启插入写屏障。因为 Go 语言的应用程序可能包含成百上千的 goroutine，而垃圾收集的根对象一般包括全局变量和栈对象，如果运行时需要在几百个 goroutine 的栈上都开启写屏障，会带来巨大的额外开销，所以 Go 团队在实现上选择了在标记阶段完成时&lt;strong&gt;暂停程序、将所有栈对象标记为灰色并重新扫描&lt;/strong&gt;，在活跃 goroutine 非常多的程序中，重新扫描的过程需要占用 10 ~ 100ms 的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言在 v1.8 组合 Dijkstra 插入写屏障和 Yuasa 删除写屏障构成了如下所示的混合写屏障，该写屏障会&lt;strong&gt;将被覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色&lt;/strong&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;writePointer(slot, ptr):&lt;br/&gt;    shade(*slot)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; current stack is grey:&lt;br/&gt;        shade(ptr)&lt;br/&gt;    *slot = ptr&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了移除栈的重扫描过程，除了引入混合写屏障之外，在垃圾收集的标记阶段，我们还需要&lt;strong&gt;将创建的所有新对象都标记成黑色&lt;/strong&gt;，防止新分配的栈内存和堆内存中的对象被错误地回收，因为栈内存在标记阶段最终都会变为黑色，所以不再需要重新扫描栈空间。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一次完整的GC过程&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go的垃圾回收器在使用了三色标记清除算法和混合写屏障后大大减少了暂停程序（STW）的时间，主要是在开启写屏障前和移除写屏障前暂停应用程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go的垃圾收集的整个过程可以分成标记准备、标记、标记终止和清除四个不同阶段，每个阶段完成的工作如下：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;标记准备阶段&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;暂停程序&lt;/strong&gt;，所有的处理器在这时会进入安全点（Safe point）；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;标记阶段&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将状态切换至 &lt;code&gt;_GCmark&lt;/code&gt;、开启写屏障、用户程序协助（Mutator Assiste）并将根对象入队；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;恢复执行程序，&lt;strong&gt;标记进程和用于协助的用户程序会开始并发标记内存中的对象&lt;/strong&gt;，标记用的算法就是上面介绍的三色标记清除法。&lt;strong&gt;写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新创建的对象都会被直接标记成黑色&lt;/strong&gt;；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;开始扫描根对象，包括所有 goroutine 的栈、全局对象以及不在堆中的运行时数据结构，扫描 goroutine 栈期间会暂停当前处理器；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用分布式的终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在标记开始的时候，收集器会默认抢占 25% 的 CPU 性能，剩下的75%会分配给程序执行。但是一旦收集器认为来不及进行标记任务了，就会改变这个 25% 的性能分配。这个时候收集器会抢占程序额外的 CPU，这部分被抢占 goroutine 有个名字叫 Mark Assist。而且因为抢占 CPU的目的主要是 GC 来不及标记新增的内存，那么抢占正在分配内存的 goroutine 效果会更加好，所以分配内存速度越快的 goroutine 就会被抢占越多的资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此以外 GC 还有一个额外的优化，一旦某次 GC 中用到了 Mark Assist，下次 GC 就会提前开始，目的是尽量减少 Mark Assist 的使用，从而避免影响正常的程序执行。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;标记终止阶段&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;暂停程序&lt;/strong&gt;、将状态切换至 &lt;code&gt;_GCmarktermination&lt;/code&gt; 并关闭辅助标记的用户程序；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;清理处理器上的线程缓存；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;清理阶段&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将状态切换至 &lt;code&gt;_GCoff&lt;/code&gt; 开始清理阶段，初始化清理状态并关闭写屏障；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;恢复用户程序，所有新创建的对象会标记成白色；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;后台并发清理所有的内存管理单元，当 goroutine 申请新的内存管理单元时就会触发清理；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;清理这个过程是并发进行的。清扫的开销会增加到分配堆内存的过程中，所以这个时间也是无感知的，不会与垃圾回收的延迟相关联。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go语言的垃圾收集的实现非常复杂，难懂的技术概念和原理也比较多，这篇文章意在用每个人都能看懂的白话文字结合图示把Go的垃圾回收原理解释清楚，让读者能对垃圾回收的大体流程有个概念。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面用一句话总结概况Go的垃圾回收原理：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Go的GC最早期使用的回收算法是&lt;strong&gt;标记-清除&lt;/strong&gt;算法，该算法需要在执行期间需要暂停应用程序(STW)，无法满足并发程序的实时性。后面Go的GC转为使用三色标记清除算法，并通过混合写屏障技术保证了Go并发执行GC时内存中对象的三色一致性（&lt;strong&gt;这里的并发指的是GC和应用程序的goroutine能同时执行&lt;/strong&gt;）。&lt;/p&gt;&lt;p&gt;一次完整的垃圾回收会分为四个阶段，分别是标记准备、标记、结束标记以及清理。在标记准备和标记结束阶段会需要 STW，标记阶段会减少程序的性能，而清理阶段是不会对程序有影响的。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这句话有点长，哈哈哈。看了今天的文章你对Go的垃圾回收有大体的理解了吗？能用自己的话总结一下吗？欢迎把自己的总结发在留言里，也欢迎把文章分享给朋友阅读。关注公众号「网管叨bi叨」，获取我整理的所有关于Go语言的技术文章。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;垃圾收集器&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Go 垃圾回收——三色标记法&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;&lt;span&gt;On-the-fly Garbage Collection：An Exercise in Cooperation&lt;/span&gt;: &lt;span&gt;https://www.microsoft.com/en-us/research/publication/fly-garbage-collection-exercise-cooperation/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;垃圾收集器: &lt;span&gt;https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;Go 垃圾回收——三色标记法: &lt;span&gt;https://zhuanlan.zhihu.com/p/105495961&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>