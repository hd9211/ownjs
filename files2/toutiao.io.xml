<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>d665d48e9d5c945f3d07dd7f26628633</guid>
<title>百亿规模 API 网关服务 Shepherd 的设计与实现</title>
<link>https://toutiao.io/k/18gz8ap</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一、背景介绍&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1.1 API网关是什么？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1.2 为什么要做Shepherd API网关？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1.3 使用Shepherd带来的收益是什么？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;二、技术设计与实现&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2.1 整体架构&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2.2 高可用设计&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2.3 易用性设计&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2.4 可扩展性设计&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;三、未来规划&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.1 云原生架构演进&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.2 静态网站托管&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.3 组件市场&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;作者简介&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;招聘信息&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一、背景&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.1 API网关是什么？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;API网关是随着微服务（&lt;/span&gt;&lt;span&gt;Microservice&lt;/span&gt;&lt;span&gt;）概念兴起的一种架构模式。原本一个庞大的单体应用（&lt;/span&gt;&lt;span&gt;All in one&lt;/span&gt;&lt;span&gt;）业务系统被拆分成许多微服务（&lt;/span&gt;&lt;span&gt;Microservice&lt;/span&gt;&lt;span&gt;）系统进行独立的维护和部署，服务拆分带来的变化是API的规模成倍增长，API的管理难度也在日益增加，使用API网关发布和管理API逐渐成为一种趋势。一般来说，API网关是运行于外部请求与内部服务之间的一个流量入口，实现对外部请求的协议转换、鉴权、流控、参数校验、监控等通用功能。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.2 为什么要做Shepherd API网关？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在没有Shepherd API网关之前，美团业务研发人员如果要将内部服务输出为对外的HTTP API接口。通常要搭建一个Web应用，用于完成基础的鉴权、限流、监控日志、参数校验、协议转换等工作，同时需要维护代码逻辑、基础组件的升级，研发效率相对比较低。此外，每个Web应用都需要维护机器、配置、数据库等，资源利用率也非常差。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;美团内部一些业务线苦于没有现成的解决方案，根据自身业务特点，研发了业务相关的API网关。放眼业界，亚马逊、阿里巴巴、腾讯等公司也都有成熟的API网关解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此，Shepherd API网关项目正式立项，我们目标是为美团提供高性能、高可用、可扩展的统一API网关解决方案，让业务研发人员通过配置的方式即可对外开放功能和数据。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;189&quot; data-ratio=&quot;0.3665644171779141&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVX5dJ5jd3oibevDVRzTmPJ8XHKicjLqF8uzzJ24AndzNDOaIemuib6K5Yo4zRibjswQ8R9nDfica2sViaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2608&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 1&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.3 使用Shepherd带来的收益是什么？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从业务研发人员的角度来看，接入Shepherd API网关，能带来哪些收益呢？简而言之包括三个方面。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;提升研发效率&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;业务研发人员只需要通过配置的方式即可快速开放服务接口。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Shepherd统一提供鉴权、限流、熔断等非业务基础能力。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Shepherd支持业务研发人员通过开发自定义组件的方式扩展API网关能力。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;降低沟通成本&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;业务研发人员配置好API，可以自动生成API的前后端交互文档和客户端SDK，方便前后端开发人员进行交互、联调。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;提升资源利用率&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;基于Serverless的架构思想，实现API全托管，业务研发人员无需关心机器资源问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二、技术设计与实现&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1 整体架构&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们先来看看Shepherd API网关的整体架构，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5350043215211755&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUB4fj2kUHfpVIVicZQ6yOoJUjNOicrhHfP75I78MwX6JvIRwS8ricpY17th9HvMQcibYmFSJluNIqYBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2314&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 2&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Shepherd API网关的&lt;strong&gt;控制面&lt;/strong&gt;由Shepherd管理平台和Shepherd监控中心组成。管理平台主要完成API的全生命周期管理以及配置下发的工作，监控中心完成API请求监控数据的收集和业务告警功能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Shepherd API网关的&lt;strong&gt;配置中心&lt;/strong&gt;主要完成控制面与数据面的信息交互，通过美团统一配置服务Lion来实现。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Shepherd API网关的&lt;strong&gt;数据面&lt;/strong&gt;也就是Shepherd 服务端。一次完整的API请求，可能是从移动应用、Web应用，合作伙伴或内部系统发起，经过Nginx负载均衡系统后，到达服务端。服务端集成了一系列的基础功能组件和业务自定义组件，通过泛化调用请求后端RPC服务、HTTP服务、函数服务或服务编排服务，最后返回响应结果。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面我们将针对这三个主要模块做详细的介绍。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1.1 控制面&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用API网关的控制面，业务研发人员可以轻松的完成API的全生命周期管理，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6137931034482759&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUB4fj2kUHfpVIVicZQ6yOoJUgwjh9GI7YEYHS0lDbmicNtxXJS4lUkscVhcjwEbYCeXojdwj3Qricpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1160&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 3&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;业务研发人员从创建API开始，完成参数录入、DSL脚本生成；接着可以通过文档和MOCK功能进行API测试；API测试完成后，为了保证上线稳定性，Shepherd管理平台提供了发布审批、灰度上线、版本回滚等一系列安全保证措施；API运行期间会监控API的调用失败情况、记录请求日志，一旦发现异常及时发出告警；最后，对于不再使用的API进行下线操作后，会回收API所占用的各类资源并等待重新启用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;整个生命周期，全部通过配置化、流程化的方式，由业务研发人员全自助管理，上手时间基本在10分钟以内，极大地提升了研发效率。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1.2 配置中心&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;API网关的配置中心存放API的相关配置信息——使用自定义的DSL（&lt;/span&gt;&lt;span&gt;Domain-Specific Language，领域专用语言&lt;/span&gt;&lt;span&gt;）来描述，用于向API网关的数据面下发API的路由、规则、组件等配置变更。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;配置中心的设计上使用统一配置管理服务Lion和本地缓存结合的方式，实现动态配置，不停机发布。API的配置如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5774783445620789&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUB4fj2kUHfpVIVicZQ6yOoJ5iaSMjMQPTBH3BIJCZeGEerHnnNsK2lQuibRaraMIW58gW7dKt2vj1ww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1039&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 4&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;API配置的详细说明：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Name、Group&lt;/strong&gt;：名字、所属分组。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Request&lt;/strong&gt;：请求的域名、路径、参数等信息。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Response&lt;/strong&gt;：响应的结果组装、异常处理、Header、Cookies信息。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Filters、FilterConfigs&lt;/strong&gt;：API使用到的功能组件和配置信息。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Invokers&lt;/strong&gt;：后端服务（&lt;/span&gt;&lt;span&gt;RPC/HTTP/Function&lt;/span&gt;&lt;span&gt;）的请求规则和编排信息。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1.3 数据面&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;API路由&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;API网关的数据面在感知到API配置后，会在内存中建立请求路径与API配置的路由信息。通常HTTP请求路径上，会包含一些路径变量，考虑到性能问题，Shepherd没有采用正则匹配的方式，而是设计了两种数据结构来存储。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;399&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;322&quot; data-ratio=&quot;0.8521256931608133&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVX5dJ5jd3oibevDVRzTmPJ8Ak2g3Uyy5wr2ZFbY9ksYKQ1g7uWTPEXmEXRoQ4HVBhbPvXvnVFPYzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2164&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 5&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一种是不包含路径变量的直接映射的MAP结构。其中，Key就是完整的域名和路径信息，Value是具体的API配置。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;另外一种是包含路径变量的前缀树数据结构。通过前缀匹配的方式，先进行叶子节点精确查找，并将查找节点入栈处理，如果匹配不上，则将栈顶节点出栈，再将同级的变量节点入栈，如果仍然找不到，则继续回溯，直到找到（&lt;/span&gt;&lt;span&gt;或没找到&lt;/span&gt;&lt;span&gt;）路径节点并退出。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;功能组件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当请求流量命中API请求路径进入服务端，具体处理逻辑由DSL中配置的一系列功能组件完成。网关提供了丰富的功能组件集成，包括链路追踪、实时监控、访问日志、参数校验、鉴权、限流、熔断降级、灰度分流等，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.37597503900156004&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUB4fj2kUHfpVIVicZQ6yOoJgsw4jM1bnMu4u9FPFuib3BJm03XnhWKjAzuMw6Ene6dPNstLeeD4jiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2564&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 6&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;协议转换&amp;amp;服务调用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;API调用的最后一步，就是协议转换以及服务调用了。网关需要完成的工作包括：获取HTTP请求参数、Context本地参数，拼装后端服务参数，完成HTTP协议到后端服务的协议转换，调用后端服务获取响应结果并转换为HTTP响应结果。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.25542570951585974&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUB4fj2kUHfpVIVicZQ6yOoJEreHb823VtA7FsxTMEootTZdOiaVdEQmwO0JrJoMHibKMGJQQfNqREMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2396&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 7&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上图以调用后端RPC服务为例，通过JsonPath表达式获取HTTP请求不同部位的参数值，替换RPC请求参数相应部位的Value，生成服务参数DSL，最后借助RPC泛化调用完成本次服务调用。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2 高可用设计&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Shepherd API网关作为接入层的基础组件，高可用性一直是业务研发人员非常关心的部分。接下来，我们就来探索一下Shepherd在高可用设计方面的实践。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2.1 排除性能隐患&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个高可用的系统，预防故障的发生，首先要排除性能隐患，保证高性能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Shepherd对API请求做了全异步化处理，请求通过Jetty IO线程异步提交到业务处理线程池，调用后端服务使用RPC或HTTP框架的异步方式，释放了由于网络等待引起的线程占用，使线程数不再成为网关的瓶颈。下图是使用Jetty容器时，服务端的请求线程处理逻辑：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;114&quot; data-ratio=&quot;0.22573363431151242&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVX5dJ5jd3oibevDVRzTmPJ8RiaQOUzbgtttfFeSU8eHia7iaiaskuYyh2CicZYoV7bXnE7fciaqyQn3o5xg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2658&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 8&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们通过域名压测网关单机的端到端QPS，发现QPS在超过2000时，会出现很多超时错误，而网关的服务端负载与性能却非常富余。调研发现，公司内其他的Web应用都存在这个问题，与Oceanus团队进行联合排查后，发现是Nginx与Web应用之间的长连接功能没有打开，且无法配置。Oceanus团队经过紧急排期，研发并上线长连接功能后，Shepherd端到端的QPS成功提升到了10000以上。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;另外，我们对Shepherd服务端进行了API请求预热的优化，使得网关启动时能立刻达到最佳性能，减少毛刺的发生。然后，通过压测时的CPU热点排查，将性能瓶颈找出，减少主链路上的本地日志打印，对请求日志进行异步化、远程化改造。Shepherd端到端的QPS再次提升30%以上。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在Shepherd服务上线稳定运行一年以后，我们再次对性能进行优化，并且做了一次网络框架升级，将Jetty容器全面替换为Netty网络框架，性能提升10%以上，Shepherd端到端的QPS成功提升到15000以上。下图是使用Netty框架时，服务端的请求线程处理逻辑：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;112&quot; data-ratio=&quot;0.22556390977443608&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVX5dJ5jd3oibevDVRzTmPJ8gMibRcBtibVVmuNnduuARrAof4aSv22wq9xWWz4fIjgJnZDIOF1NVjpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2660&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 9&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2.2 服务隔离&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;集群隔离&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;借鉴公司缓存、任务调度等成熟组件的经验，Shepherd在设计之初，就考虑了按业务线维度进行集群隔离，也支持重要业务独立部署。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;300&quot; data-ratio=&quot;0.5856651939126166&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVX5dJ5jd3oibevDVRzTmPJ8rtL5aOsYp8nGticUa2vbgIXLvZj6IedGplIRibjX7NbUKVPg4dS47KLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2037&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图10&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;请求隔离&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;服务节点维度，Shepherd支持请求的快慢线程池隔离。快慢线程池隔离主要用于一些使用了同步阻塞组件的API，例如SSO鉴权、自定义鉴权等，可能导致长时间阻塞共享业务线程池。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;快慢隔离的原理是统计API请求的处理时间，将请求处理耗时较长，超过容忍阈值的API请求隔离到慢线程池，避免影响其他正常API的调用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;除此之外，Shepherd也支持业务研发人员配置自定义线程池进行隔离。具体的线程隔离模型如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;348&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;240&quot; data-ratio=&quot;0.7070707070707071&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVX5dJ5jd3oibevDVRzTmPJ8oYqqcu0icpLicoYiaMdeMic6pLKnKyuibJhadsmsSXibUT09VcHGtvsFo4tg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;792&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 11&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2.3 稳定性保障&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Shepherd提供了一些常规的稳定性保障手段，来保证自身和后端服务的可用性。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;153&quot; data-ratio=&quot;0.2908805031446541&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVX5dJ5jd3oibevDVRzTmPJ8oib3DnaZia2oTsq03KbBh2BZPAmEBwA3pyiaNvojfLWG5N1hjUDxm6aFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2544&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图12&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;流量管控&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：从用户自定义UUID限流、App限流、IP限流、集群限流等多个维度提供流量保护。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;请求缓存&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：对于一些幂等的、查询频繁的、数据及时性不敏感的请求，业务研发人员可开启请求缓存功能。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;超时管理&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：每个API都设置了处理超时时间，对于超时的请求，进行快速失败的处理，避免资源占用。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;熔断降级&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：支持熔断降级功能，实时监控请求的统计信息，达到配置的失败阈值后，自动熔断，返回默认值。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2.4 请求安全&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;请求安全是API网关非常重要的能力，Shepherd集成了丰富的安全相关的系统组件，包括有基础的请求签名、SSO单点登录、基于SSO鉴权的UAC/UPM访问控制、用户鉴权Passport、商家鉴权EPassport、商家权益鉴权、反爬等等。业务研发人员只需要简单配置，即可使用。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2.5 可灰度&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;API网关作为请求入口，往往肩负着请求流量灰度验证的重任。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;灰度场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Shepherd在灰度能力上，支持灰度API自身逻辑，也支持灰度下游服务，也可以同时灰度API自身逻辑和下游服务。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.707250341997264&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUB4fj2kUHfpVIVicZQ6yOoJJktvb4v4ucg9VWrDRXPmTZ0vkiaSfBRqzpM2f9ib6Qdas81kNiajDSTlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2924&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 13&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;灰度API自身逻辑时，通过将流量分流到不同的API版本实现灰度能力；灰度下游服务时，通过给流量打标，分流到指定的下游灰度单元中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;灰度策略&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Shepherd支持丰富的灰度策略，可以按照比例数灰度，也可以按照特定条件灰度。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2.6 监控告警&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;立体化监控&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Shepherd提供360度的立体化监控，从业务指标、机器指标、JVM指标提供7x24小时的专业守护，如下表：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5433436532507739&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVX5dJ5jd3oibevDVRzTmPJ80hs1Na52McX40YUPVSy5KARISuEKmOUyjUBpaXiaBgeMmOXv2DUrveA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1292&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;多维度告警&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有了全面的监控体系，自然少不了配套的告警机制，主要的告警能力包括：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.42746913580246915&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUB4fj2kUHfpVIVicZQ6yOoJWZA3YBpheo0UHv0EFAYmPY3L1RVtYialNEvQBH9GibF9rTOHXSm67hpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1296&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2.7 故障自愈&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Shepherd服务端接入了弹性伸缩模块，可根据CPU等指标进行快速扩容、缩容。除此之外，还支持快速摘除问题节点，以及更细粒度的问题组件摘除。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;202&quot; data-ratio=&quot;0.3915929203539823&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVX5dJ5jd3oibevDVRzTmPJ8LMZQMe2dib9mVr351MPnuyck4C601EoeZSmmKib27haZ2jicaFGcod4zg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1808&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 14&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2.8 可迁移&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于一些已经在对外提供API的Web服务，业务研发人员为了减少运维成本和后续的研发提效，考虑将其迁移到Shepherd API网关。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于一些非核心API，可以考虑使用Oceanus的灰度发布功能直接迁移。但是对于一些核心API，上面的灰度发布功能是机器级别的，粒度较大，不够灵活，不能很好的支持灰度验证过程。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Shepherd为业务研发人员提供了一个灰度SDK，接入SDK的Web服务，可在识别灰度流量后转发到Shepherd API网关进行验证。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;灰度哪些API、灰度百分比可以在Shepherd管理端动态调节，实时生效，业务研发人员还可以通过SPI的方式自定义灰度策略。灰度验证通过后，再把API迁移到Shepherd API网关，保障迁移过程的稳定性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;灰度过程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;灰度前：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在Shepherd管理平台创建API分组，域名配置为目前使用的域名。在Oceanus上，原域名规则不变。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3944353518821604&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUB4fj2kUHfpVIVicZQ6yOoJgFSlQL0KMlKeC5oqWtvsoMFhFTbj3X6eshuD2uSd7vYmfRaibcz45tA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2444&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 15&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;灰度中：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在Shepherd管理平台开启灰度功能，灰度SDK将灰度流量转发到网关服务，进行验证。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3944353518821604&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUB4fj2kUHfpVIVicZQ6yOoJicwXjo9LMxLkcbCaafEB3MjS8IVpY7ibIJib8Zw6UMicJaSQCICoMxbqUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2444&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 16&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;灰度后：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;通过灰度流量验证Shepherd上的API配置符合预期后再迁移。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3944353518821604&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUB4fj2kUHfpVIVicZQ6yOoJI2w6PQCViaHdQDUVOibibPQbtpHVnNyAp1N2Oric4Kfpic6HmGicMbfVT2uA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2444&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 17&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.3 易用性设计&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Shepherd API网关的功能强大且复杂，易用性对业务研发人员来说至关重要。我们着重来看下自动生成DSL、API操作提效的解决方案。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.3.1 自动生成DSL&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;业务研发人员在实际使用网关管理平台时，我们尽量通过图形化的页面配置来减轻DSL的编写负担。但服务参数转换的DSL配置，仍然需要业务研发人员手工编写。一般来说，生成服务参数DSL的流程是：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;引入服务的接口包依赖。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;拿到服务参数类定义。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;编写Testcase生成JSON模板。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;填写参数映射规则。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;最后手工录入管理平台，发布API。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;整个过程非常繁琐，且容易出错。如果需要录入的API多达几十上百个，全部由业务研发人员手工录入的效率是非常低下的。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么能不能将服务参数DSL的生成过程给自动化呢？答案是可以的，业务RD只需在网关录入API文档信息，然后录入服务的Appkey、服务名、方法名信息，Shepherd管理端会从最新发布的服务框架控制台获取到服务参数的JSON Schema信息，JSON Schema定义了服务参数的类型和结构信息，管理端可根据这些信息，自动生成服务参数的JSON Mock数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;结合API文档的信息，自动替换参数名相同的Value值。这套DSL自动生成方案，使用过程中对业务透明、标准化，业务方只需升级最新版本服务框架即可使用，极大提升研发效率，目前受到业务研发人员的广泛好评。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5161290322580645&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUB4fj2kUHfpVIVicZQ6yOoJjugx3fI3wFibkJrI6kutDKlg7YJQOcBmjajqiaywmZOV4OYyoHvObe3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2666&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 18&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.3.2 API操作提效&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;快速创建API&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;API网关的核心能力是建立在API配置的基础上的，但提供强大功能的同时带来了较高的复杂性，不少业务研发人员吐槽API配置太繁琐，学习成本高。快速创建API的功能应运而生，业务研发人员只需要提供少量的信息就可以创建API。快速创建API的功能当前分为4种类型（&lt;/span&gt;&lt;span&gt;后端RPC服务API、后端HTTP服务API、SSO CallBack API、Nest API&lt;/span&gt;&lt;span&gt;），未来会根据业务应用场景的不同，提供更多的快速创建API类型。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;批量操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;业务研发人员在API网关上，需要管理非常多的业务分组，每个业务分组，最多可以有200个API配置，多个API可能有很多相同的配置，如组件配置，错误码配置和跨域配置的。每个API对于相同的配置都要配置一遍，操作重复度很高。因此Shepherd支持批量操作多个API：勾选多个API后，通过【批量操作】功能可一次性完成多个API配置更新，降低业务重复配置的操作成本。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;API导入导出&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Shepherd提供在不同研发环境相互导入导出API的能力，业务研发人员在线下测试完成后，只需要使用API导入导出功能，即可将配置导出到线上生产环境，避免重复配置。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.4 可扩展性设计&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个设计良好的基础组件，除了能提供强大的基础能力，还需要有良好的扩展能力。Shepherd的可扩展性主要体现在：支持自定义组件、服务编排的能力。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.4.1 自定义组件&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Shepherd提供了丰富的系统组件完成鉴权、限流、监控能力，能够满足大部分的业务需求。但仍有一些特殊的业务需求，如自定义验签、自定义结果处理等。Shepherd通过提供加载自定义组件能力，支持业务完成一些自定义逻辑的扩展。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下图是自定义组件实现的一个实例。getName中填写自定义组件申请时的名称，invoke方法中实现自定义组件的业务逻辑，如继续执行、进行页面跳转、直接返回结果、抛出异常等。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7204502814258912&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUB4fj2kUHfpVIVicZQ6yOoJibr2FknKruPKPrNggLdqeBQ6y0icYxuwqic1r0gAEJYeY0M2ZONzek46A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1066&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 19&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;目前Shepherd通过自定义组件已经成功支持了美团优选、外卖、餐饮、打车等重要业务，接入的自定义组件数量有200多个。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.4.2 服务编排&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一般情况下，网关上配置的一个API对应后端一个RPC或者HTTP服务。如果调用端有聚合和编排后端服务的需求，那么有多少后端服务，就必须发起多少次HTTP的请求调用。由此就会带来一些问题，调用端的HTTP请求次数过多，效率低，在调用端聚合服务的逻辑过重。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;服务编排的需求应运而生，服务编排是对既有服务进行编排调用，同时对获取的数据进行处理。主要应用在数据聚合场景：一次HTTP请求返回的数据需要调用多个或多次服务（&lt;/span&gt;&lt;span&gt;RPC或HTTP&lt;/span&gt;&lt;span&gt;）才能获取到完整的结果。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;经过前期调研，公司已经有一套成熟的服务编排框架，由客服团队开发的海盗组件（&lt;/span&gt;&lt;span&gt;参见《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651748475&amp;amp;idx=3&amp;amp;sn=23b517c9c5173a6585ddc7bfd23a878a&amp;amp;chksm=bd12a1368a65282071cec8ce73f16f86de546b2e22eae0af46cd8b6b88521b2ed14e32fb32e9&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;海盗中间件：美团服务体验平台对接业务数据的最佳实践&lt;/a&gt;》一文&lt;/span&gt;&lt;span&gt;）也是美团公司内部的公共服务。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此我们与海盗团队合作，设计了Shepherd的服务编排支持方案。海盗通过独立部署的方式提供服务编排能力，Shepherd与海盗之间通过RPC进行调用。这样可以解耦Shepherd与海盗，避免因服务编排能力影响集群上的其他服务，同时多一次RPC调用并不会有明显耗时增加。使用上对业务研发人员也是透明的，非常方便，业务研发人员在管理端配置好服务编排的API，通过配置中心同时下发到Shepherd服务端和海盗服务上，即可开始使用服务编排能力。整体的交互架构图如下：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6705882352941176&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUB4fj2kUHfpVIVicZQ6yOoJEOVc0KxIynxMEf5lKyPTetQLe5GZBKTpAP4htia5EkL3vmDsDmZrt9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1020&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 20&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;三、未来规划&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;目前接入Shepherd API网关的API数量超过18000多个，线上运行的集群数量90多个，日均总调用次数在百亿以上。随着Shepherd API网关业务规模的不断增长，对我们的可用性、易用性、可扩展性必将提出更高的要求。未来一年，Shepherd的规划重点包括有云原生架构演进、静态网站托管、组件市场等。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1 云原生架构演进&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Shepherd API网关的云原生架构演进有三个目标：简化接入网关步骤，提升业务研发人员的研发效率；减小服务端War包大小，提升安全性和稳定性；接入Serverless弹性，降低成本，提高资源利用率。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了实现这个三个目标，我们计划整体迁移网关服务到公司的Serverless服务Nest（&lt;/span&gt;&lt;span&gt;参见《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651761865&amp;amp;idx=1&amp;amp;sn=cf91e657b46b4550dd5e32489093b2c3&amp;amp;chksm=bd1275848a65fc92fd112ba9a87e5744212ba8ef4a834440609e08ccee9595d8011224fd525d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;美团Serverless平台Nest的探索与实践&lt;/a&gt;》一文&lt;/span&gt;&lt;span&gt;）上，同时通过抽取Shepherd核心功能到SDK的方式集成到业务的网关集群，业务研发人员可以只选择自己需要使用的自定义组件，从而大幅减小服务端的War包大小。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7751824817518248&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUB4fj2kUHfpVIVicZQ6yOoJrvicDiaVkygw25NKOIfkjAd2GumY9rhkiaLAptLxicib27grSkChPxAkOOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2740&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 21&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2 静态网站托管&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;依托Shepherd API网关实现静态网站托管的目标是：&lt;strong&gt;建设通用的静态网站托管解决方案，为开发者提供便捷、稳定、高扩展性的静态网站托管服务&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;静态网站托管解决方案能为业务研发人员提供的主要功能包括：托管静态网站资源，包括存储及访问；管理应用生命周期，包括自定义域配置以及身份验证和授权；CI/CD集成等。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3713768115942029&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUB4fj2kUHfpVIVicZQ6yOoJ7Nv6oHSVaCzJa62iaibcicPbrFh5GuqE1CKib1agAmofPGsSEaUdWn0hVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1656&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 22&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3 组件市场&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Shepherd API网关组件市场的目标是：&lt;strong&gt;合作共赢，形成开发生态，业务研发人员可将开发的自定义组件提供给其他有需要的业务研发团队使用&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们希望让业务研发人员参与到自定义组件的开发，完善使用文档后设置为公共组件，开放给所有使用Shepherd的业务研发人员使用，避免重复造轮子。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;作者简介&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;充泽、志洋、李敏等，均来自美团基础技术部-基础架构团队。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e610b265672a18f648393b0c8b999689</guid>
<title>Golang 内存管理分析</title>
<link>https://toutiao.io/k/5za3e5u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;大纲&lt;/h1&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;1. 目录&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2. 由一个问题展开&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3. 名字说明&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4. 内存怎么采样？&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;4.1 编译期间逃逸分析&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4.2 采样的简单实现&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4.3 内存采样的时机&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4.4 内存采样的入口&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4.5 内存采样的信息&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4.6 golang的类型反射&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;5. 内存分配&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;5.1 C语言你分配和释放内存怎么做？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;5.2 内存分配设计考虑的几个问题&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;5.3 golang的内存分配&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;6. 内存回收&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;6.1 golang协程抢占执行&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.2 STW是怎么回事？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.3 垃圾回收要求&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.4 golang版本迭代历史&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.5 GC触发条件&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.6 三色定义&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.7 GC流程&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.8 写屏障&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.9 内存可见性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.10 注意问题&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 目录&lt;strong/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 由一个问题展开&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang从语言级别，就提供了完整的采样和分析的机制。大家经常使用 pprof 分析内存占用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5359477124183006&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DIlBNOZ88iaCnvgTgGLTF9HbeHX7WCJS22BYiajN5aXVWj6qzGLuf2EXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1530&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是不清楚怎么实现？不清楚怎么看指标？不清楚 flat，cum的区别？我们就从这个问题展开。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 名字说明&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;内存分析的时候，有四个输入选项：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;alloc_objects : 历史总分配的累计&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;alloc_space ：历史总分配累计&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;inuse_objects：当前正在使用的对象数&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;堆上分配出来，业务正在使用的，也包括业务没有使用但是还没有垃圾回收掉的对象。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;inuse_space：当前正在使用的内存&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;两个输出选项：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;flat：平坦分配，非累加&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cum：累加&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;思考几个问题：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;上面说的对象是什么概念？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;经常使用内存分析，这个内存分析是否是精确的？性能消耗大不大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为啥显示的是堆栈？不是说分配的对象吗？为啥不直接显示分配的对象结构名？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 内存怎么采样？&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 编译期间逃逸分析&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说明下，golang pprof是分析从堆上分配的内存。golang的内存在堆上，还是在栈上？这个不是我们决定的，就算你调用new这个关键字，也不一定是在堆上分配。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.29850746268656714&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DwtPSLRiaQhRoe92zpicanF5zAKlECXHeME4ZKqAwfOHSZicz1zJu5cfvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;402&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.21794871794871795&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DwB356SekRQGzKxIMD16Kropp3P1q4TH9picsL6VPF3UwSM1NY3yn7eQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1014&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;逃逸分析是golang的一个非常重要的一个点。&lt;/span&gt;&lt;span&gt;对于内存分配，垃圾回收的设计都有非常重要的影响。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 采样的简单实现&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采样的实现非常简单。简单描述流程：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用一个公共变量用来记录&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分配内存的时候，加alloc size，加alloc对象数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;释放内存的时候，加free size，加free对象数&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;累计分配：就是alloc
当前在用 inuse：就是 &lt;code&gt;alloc-free&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8091603053435115&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DjOF71fW6Fln0WUH6ulvHYPkYGomUPHPOUicXY7dutDSQn8opHbVfTdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;655&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.3 内存采样的时机&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;采样的时机说3个点：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;分配堆上内存的时候，累计分配&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;回收器释放堆上内存的时候，累计释放&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每512KB打点采样&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是注意一点：并不是每一次分配内存都会被采样。也就是说这里其实是有个权衡的。现在是每满512KB才会采样一次。这里的考虑是性能和采样效果的权衡。因为采样是要耗费性能的，是要取堆栈的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;怎么理解？举个例子&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理想情况下（不考虑其他任何影响）：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4197247706422018&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4Dv7xia7VVEaaxR0V7ZASiagO7tuibSQTI8TwD3JeXqdFUQOXITx6qbr9ibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1744&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么有人会想，这样岂不是会漏掉了很多内存？统计还能用来排查问题吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是性能和效果的一个考虑，一般来讲，我们是用pprof分析内存占用的时候，在整个golang程序跑起来后，时时刻刻都在分配释放内存，每累计分配512KB，打点一次。虽然会漏掉一些内存分配释放，但是对每个结构都是公平的。如果有一个内存泄露分配行为，那么累计下来一定会被抓住的，并且是非常容易被抓住。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.4 内存采样的入口&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存采样的入口，这个非常简单理解。肯定是一个在分配内存的函数位置，一个是释放内存的位置。这里要特意提下上下文环境。因为golang是垃圾回收类型的语言，内存分配是完全交由golang自己管理，自己不能管理内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;两个入口函数：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;mProf_Malloc&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mProf_Free&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个是配套使用的采样打点函数。而且一定是配套的。简单说：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;mProf_Malloc 是由业务程序行为（赋值器）触发的，分配内存嘛。比如你new了一个对象，这个对象在堆上，那么会调用 &lt;code&gt;mallocgc&lt;/code&gt; 分配内存，如果到了采样点，那么会调用 &lt;code&gt;mProf_Malloc&lt;/code&gt; 采样。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mProf_Free 是回收器在确定并且将要回收内存的时候调用的。是垃圾回收过程的一环。并且还要注意一点，只有打过点的（mProf_Malloc计数过的对象，会有一个特殊处理），才会配套使用mProf_Free。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不是说，任意给一个内存地址给你。你都知道这个是业务类型。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.5 内存采样的信息&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里问你的是，golang采样是采样啥？类型信息？这里也说过一点，内存这里和类型系统是没啥关系的。这里采样的是分配栈，也就是分配路径。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.5.1 flat，cum 分别是怎么来的？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看个例子：&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9725490196078431&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DfG9con5dbDHuPsyiaUFqnA9qEMNoNfPWuus2C0e6DEtq2KcibB9nKUmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;510&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家可以先猜下，我们看alloc_space。这个内存会是怎么累计到的。实际统计如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3450087565674256&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DiapKxudCtticZGcDvZy4vFrYO4RB8yeQSak92CgqdiaSOf9gvacMcicqbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;571&quot;/&gt;&lt;/p&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和大家猜的一样吗？这些是怎么看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;首先说几个结论：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;flat统计到的，就是这个函数实际分配的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cum是累计的，包含自己分配的，也包含路过的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;cum和flat不相同的时候，代表这个函数除了自己分配内存，自己内部调用的别的函数也在分配内存。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;重点提示：这个要理解这个，首先要知道，内存采样的是什么，内存采样的是分配栈。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解释说明&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（图中140M我们当150M看哈，这里采样少了第一次，细节原因可以看代码，这里提一下，不做阐述。）：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;main函数里，A函数调用了5次，B函数 5次，C函数5次。其中B会调用A，C会调用B。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用一次A会分配10M内存，调用一次B会分配20M，调用一次C会分配30M。总累计分配内存是300M&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;A函数实际调用次数是 15次；这个和flat的值是一致的：150M&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;(A) * 5&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;(B -&amp;gt; A) * 5&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;(C -&amp;gt; B -&amp;gt; A) * 5&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;B函数函数实际调用10次；这个和flat的值也是一致的：100M&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;B * 5&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;(C -&amp;gt; B) * 5&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;C函数5次：这个和flat的值是一致的：50M&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;C * 5&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;main函数300M，也是一致的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;图示&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8029925187032418&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DfIOOpsV7U94sIWrGM8vhXBQMq9SgljYRHPwx5PKZicaqMDEahawGeqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记住一句话：采样是记录分配堆栈，而不是类型信息。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.6 golang的类型反射&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;思考几个问题：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;任意给一个内存地址给你，能知道这个对象类型吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;golang的反射到底是怎么回事？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先说结论：golang里面，内存块是没有携带对象类型信息的，这个跟C是一样的。但是golang又有反射，golang的反射一定要基于interface使用。这个要仔细理解下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为，golang里面interface的结构变量，是会记录type类型的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;反射定律一：&lt;/strong&gt;反射一定是基于接口的。是从接口到反射类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;反射定律二：&lt;/strong&gt;反射一定是基于接口的。是从反射类型到接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是那句话，golang的反射一定是依赖接口类型的，一定是经过接口倒腾过的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.44385026737967914&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DR1Tyicnbtesda7qV9SViavDJ0siaWEe1AtzTb5a3tRWnJqdlvzwQTAmAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;374&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为当前接口这个类型对应了两个内部结构：&lt;code&gt;struct iface&lt;/code&gt;，&lt;code&gt;struct eface&lt;/code&gt;，这两个结构都是会存储type类型。以后的一切都是基于这个类型的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 内存分配&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1 C语言你分配和释放内存怎么做？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思考一个问题，在C语言里，我们分配内存：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分配内存的时候，传入大小，拿到一个指针。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ptr = malloc(1024);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;释放内存的时候，直接传入ptr，没有任何其他参数：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;free (ptr);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;释放的时候，怎么确定释放哪些位置？如果要你自己实现，有很多简单的思路，说一个最简单的：分配的时候，不止分配1024字节，还分配了其他的信息，带head了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.3878048780487804&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DpWk8icmdLTf4ddR3pOjLzymKAEC6icv2V9NtG32IAicz0ic9qUH9K8Z1BA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;410&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种分配方式有什么问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;开销大，在通用的内存分配器中，很多场景下，有可能meta信息比自身还要大。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 内存分配设计考虑的几个问题&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;性能&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;局部性&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;碎片率&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;内部碎片率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;外部碎片率&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3 golang的内存分配&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang大方向的考虑就是基于局部性和碎片率来考虑的。使用的是和tcmalloc一致的设计。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.1 整体设计&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，内存块是不带类型信息的。像我们在C语言里面，有时候实现的简单的内存池，在不考虑一些开销的时候，会把业务类型放到meta信息里，为的是排查问题方便。golang内存管理作为一个通用模块，不会这么搞。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.1.1 地址空间设计&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，你查golang的资料，会看到这张图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.16575449569976544&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4Deia6DHht4QwS4kE9VUW6yHlvY6Iwl2bnYf4iaK6p35KdicwL6ejnnmQmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1279&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这张图有几个信息比较重要&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为什么spans区域是512M，bitmap区是16G，arena是512G？先不要纠结值，我们先说这个比例关系：&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;spans区域，一个指针大小（8Byte）对应arena的一个page（8KB），倍数是1024&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;bitmap区域，一个字节（8bit）对应arena的32Bytes，倍数是32倍&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;我们给用户分配的内存就是arena区域的内存，spans区，bitmap区均为其他用途的元数据信息。&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;bitmap这个实现我们这次不谈，不同通过这个你得知道一点：并不是所有的内存空间都会扫描一把，是有挑选判断的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;spans区域是一般用来根据一个内存地址查询mspan结构的。调用函数：spanOf。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;bitmap是用来辅助垃圾回收用的区域。有这个bitmap信息可以提高回收效率和精度。注意一点，这个不是标识object是否分配的位图，标识是否分配object的问题是&lt;code&gt;mspan.allocBits&lt;/code&gt;结构。这个可以理解为提高垃圾回收效率的实现。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意几个点：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;很多文章都提到golang内存512GB这个事情。512GB说的是内存虚拟地址空间的限制，是最大能力，是最大的规划利用。golang之前最大可以使用的内存地址空间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;golang1.11 之后已经没有512GB的限制了。基本上和系统的虚拟地址空间一致&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个比例还是一样的，1：1024，1：32&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;就算golang1.11之前，也不是说golang的程序上来就向系统申请这么大块虚拟地址。也是每64M的申请，管理对象单元是heapArea结构。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;三个区域看着连续结在一起，但是其实不是连续的地址。&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实际的实现中都是以64M（heapArena）的小单位进行的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.2 抽象对象概念&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4629981024667932&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4D6IqsF5vpIumCKMxwOhDB4A4dQeakqdwOZRt95gicXbqVY09K56bYiaJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1054&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;物理偏向概念&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;heapArena：堆上物理空间管理的一个小单元，64M一个。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;page：物理内存最小单位，8KB一个。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;逻辑偏向概念&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;span：span为内存分配的一个管理单元。span内按照固定大小size划分，相同的size划分为同一类。一个span管理一个连续的page。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;object：内存分配的最小单元。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;管理结构层次概念&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mcache：每个M上的，管理内存用的。我们都知道GMP架构，每个M都有自己的内存cache管理，这样是为了局部性。只是一个cache管理。mcentral：mheap结构所有，也只是一个cache管理，但是是为所有人服务的。mheap：是真正负责分配和释放物理内存的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.3 局部性的设计&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个思路很简单，就是设计成局部性的一个层次设计。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.3.1 mcache&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mcache由于只归属自己的M，span一旦在这个结构管理下，其他人是不可见，不会去操作的。只有这个m会操作。所以自然就不需要加锁。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.3.2 mcentral&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mcentral是所有人可见的。所以操作自然要互斥，这个的作用也是一个cache的统一管理。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.3.3 mheap&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是负责真实内存分配和释放的的一个结构。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.4 针对碎片率的设计&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang的内存设计目标：碎片率平均12.5%左右。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7231726283048211&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DRE53brYCleJl6622uSwAsh9QFwu9GBhezQMxT19GDEibhB4OibnrKQNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;643&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;tail wast实际是浪费的外部碎片&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;比如说，第一种size，8字节。一个page 8KB，8字节刚好对齐。外部碎片为0.&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;max waste说的是最大的内部碎片率&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;怎么算的？每一个放进该span的对象大小都是最小值的情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;比如说，第一种size，8字节。最小的对象是1字节，浪费7字节，最大碎片率为 1-1/8 = 87.5%&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么的出来的这些值？经验值吧，可能。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. 内存回收&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.1 golang协程抢占执行&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，golang没有真正的抢占。golang调度单位为协程，所谓抢占，也就是强行剥夺执行权。但是有一点，golang本质上是非抢占的，不像操作系统那样，有时钟中断和时间片的概念。golang虽然里面是有一个抢占的概念，但是注意了，这个抢占是建议性质的抢占，也就是说，如果有协程不听话，那是没有办法的，实现抢占的效果是要对方协程自己配合的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一句话：系统想让某个goroutine自己放弃执行权，会给这个协程设置一个魔数，协程在切调度，或者其他时机检查到了的时候，会感知到这一个行为。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;当前的抢占实现是：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;给这个协程设置一个的魔数(stackguard)。每个函数的入口会比较当前栈寄存器值和stackguard值来决定是否触发morestack函数。（这是一个抢占调度点）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;协程调用函数的时候，会检查是否需要栈扩容。如果被设置了抢占标示，那么就会首先调用到&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用newstack，在newstack里面判断是否是特殊值，这种特殊值，目的不在于扩容，而在于让出调度。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，在golang里面，只要有函数调用，就会有感知抢占的时机。stw就是基于这个实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;思考一个问题：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有一个猥琐的函数：非常耗时，一直在做cpu操作，并且完全没有函数调用。这种情况下，golang是没有一点办法的。那么这种情况会影响到整个程序的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我们平时写函数，一定要短小精悍，功能拆分合理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.2 STW是怎么回事？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;STW：stop the world，也就是说暂停说由协程的调度和执行。stw是怎么实现？stw的基础就是上面提到的抢占实现。stw调用的目的是为了让整个程序（赋值器停止），那么就需要剥夺每一个协程的执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;stw在垃圾回收的几个关键操作里是需要的，比如开启垃圾回收，需要stw，做好准备工作。如果stw的时候，出现了猥琐的函数，那么会导致整个系统的能力降低。因为大家都在等你一个人。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.3 垃圾回收要求&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;正确性：绝对不能回收正在使用的的内存对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;存活性：一轮回收过程一定是有边界，可结束的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.4 golang版本迭代历史&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;go 1.3 以前，使用是标记-清扫的方式，整个过程需要stw&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;go 1.3 版本分离了标记和清扫操作，标记过程stw，清扫过程并发执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;go 1.5 版本在标记过程中，使用三色标记法。回收过程分为四个阶段，其中，标记和清扫都并发执行的，但标记阶段的前后需要stw一定时间来做gc的准备工作和栈的re-scan。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;go 1.8 版本引入了混合写屏障机制，避免了对栈的re-scan，极大的减少了stw的时间。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.5 GC触发条件&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;gcTriggerHeap 当分配的内存达到一定值就触发GC&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gcTriggerTime 当一定时间没有执行过GC就触发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gcTriggerCycle 要求启动新一轮的GC，一启动则跳过，手动触发GC的runtime.GC( )会使用这个条件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.6 三色定义&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.6.1 强三色&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;黑色对象不允许指向白色对象。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.6.2 弱三色&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;黑色对象可以指向白色对象，但是前提是，该白色对象一定是处于灰色保护链中。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.7 GC流程&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里不详细阐述了。贴一张go1.8之前的图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DzW1eHrJBFC877UblYFvicerpibx33hDrxmbKq41EQEwSmaYlmGAJOiaZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当下GC大概分为四个阶段：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;GC准备阶段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;标记阶段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;标记结束阶段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;清理阶段&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.8 写屏障&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果标记和回收不用和应用程序并发，在标记和回收整个过程直接stw，那么就简单了。golang为了提供低时延，就必须让赋值器和回收器并发起来。但是在并发的过程中，赋值器和回收器对于引用树的理解就会出现不一致，这里就一定要配合写屏障技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写屏障技术，是动态捕捉写操作，维持回收正确性的技术。写屏障就是一段 hook 代码，编译期间生成，运行期间跟进情况会调用到 hook 的代码段，也就是写屏障的代码；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面系统整体的讨论下写屏障的技术。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.8.1 插入写屏障&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（Dijkstra &#x27;78）&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;writePointer ( slot, ptr ):&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 无脑保护插入的新值&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    shade ( ptr )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    *slot = ptr&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是另外一个通用的屏障技术。这个维护的是强三色不变式来保证正确性，保证黑色对象一定不能指向白色对象。golang使用的是这个屏障，插入屏障。按照道理，是几乎完全不需要stw的。但是golang有一个处理，由于栈上面使用屏障会导致处理非常复杂，并且开销会非常大。所以当前golang只针对堆上的写操作做了屏障。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么就会带来一个问题：所以当一轮扫描完了之后，在标记结束的阶段，还需要重新扫描一遍goroutine栈，并且栈引用到的所有对象也要扫描。因为goroutine有可能直接指向了白色对象。在扫描goroutine栈过程中，需要stw。这个也是go1.8以前的一个非常大的延迟来源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（开始的时候，stw扫描栈，得到灰色对象）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;图表演示&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆上路径赋值：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step1：堆上对象赋值的时候，插入写屏障，保护强三色不变式&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.36728395061728397&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DF11J33eLfia9xy4ayicqjFhKiaUlolbJiaeSBEggF7OkOHa0HvHUyHehGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;972&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step2：删除的时候，没啥问题&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.36699239956568946&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DHmRyWF8d4hV8kyIj0nc9lwcNiawRWBOVuBhPwYvXKTbr1hhwQFHyueg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;921&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;栈上对象赋值：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step3：栈上对象赋值的时候，没有写屏障。白色对象直接被黑色对象引用。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3575240128068303&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DUfO37E2nVSWzicziaqGdTkrxencx5GPpEDUjBwg5UGGLZO1Mc1q4s7Dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;937&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step4：删除灰色保护路径。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.393018018018018&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DpgtnqHS2v5Hq1qG9RAI8CicMpJicZz4EluZJJA6EiaibOfGj3LnauQQO4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;888&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以才需要在mark terminato阶段，重新扫描栈。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.8.2 删除写屏障&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（Yuasa &#x27;90）&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;writePointer ( slot, ptr ):&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     // 删除之前，保护原先白色或者灰色指向的数据块&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if ( isGery ( slot )  || isWhite ( slot ) )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        shade ( *slot )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    *slot = ptr&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是通用的一种写屏障技术。golang并没有实现，而是实现了插入写屏障。原因就在于：这个在垃圾回收之前，必须做一个快照扫描，这个就会对用户时延有比较严重的影响。下面详述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;主要流程：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在标记之前，需要打一个引用关系的快照。所以，这个对于栈内存很大的时候，影响越大。&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不需要完整的快照，只需要在扫描堆对象之前，确保所有的栈对象是黑色的。引用都是灰色的，这样就保证了一个前提：所有可达的对象都处于灰色保护状态中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对栈快照扫描需要stw，去扫描栈对象。这个时候，是需要暂停所有的用户程序。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;扫描堆对象的时候，可以和应用程序并发的。此后根一直保持黑色（黑色赋值器），不用再扫描栈。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对象被删除的时候，删除写屏障会捕捉到。置灰。&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;上面的伪代码显示有条件，其实第一版的时候是没有条件的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这里加上条件是为了回收精度：当上游之前是白色或者灰色才需要把这个置灰色。如果是黑？那么一定是处于灰色保护状态，因为这个是前提（理解这个非常重要）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（开始的时候，stw扫描栈，得到灰色对象）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;图表演示&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始扫描快照后：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.37760702524698136&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DLicOrYWuDIic3rNQPtJNmbCx5iaevmMaKcic3DUeuW0iapotAibnGhUx2kWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;911&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step1: 赋值。这里赋值是允许的，虽然是破坏了强三色不变式。但是还是符合弱三色不变式。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.324&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DAVAO12ru4MZXSHGTcNgNxFOJuSf4EbrS36FKict4EUW6fKDoqicd6ZcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step2：删除。这里就拦截了，必须置灰色。保证弱三色不变式。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3452502553626149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DGHKQZBgNYAQtHye4aA4F385MLcBPqrylWt0SQr03fEzF38hatbAgJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;979&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;回收精度：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;删除写屏障的精度比插入写屏障的精度更低。删除的即使是最后一个指针，也会保留到下一轮，属于一个浮动垃圾。这个比插入屏障精度还低。因为，对于插入屏障所保留的对象，回收器至少可以确定曾在其中执行了某些回收相关的操作（获取或写入对象的引用），但删除屏障所保留的对象却不一定被赋值器操作过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么需要打快照？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;删除写屏障，又叫快照屏障增量技术（或者说，一定要配合这个来做）。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先，是需要stw，针对扫描整个栈根打做一遍扫描。相当于一个快照。这个过程扫描之后，就能保证当前（时刻）所有可达的对象都处于灰色保护状态，满足弱三色不变式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后，赋值器和回收器就可以并发。但是并发有可能会破坏导致弱三色不变式。这个时候，就需要删除写屏障来时刻保护白色对象。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;golang为啥没有用这个？&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个是精度问题，这个精度要比插入写屏障低；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;考虑goroutine可能非常多，不适合上来就stw，扫描所有的内存栈。这个适合小内存的场景。&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;思考一个问题：这个和混合写屏障有没有区别？还是有区别的，这里是要锁整个栈，混合写屏障是并发的，每次只需要锁单个栈。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.8.3 混合写屏障&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;混合屏障是结合插入屏障和删除屏障。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;伪代码：&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;writePointer (slot, ptr) :&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 保护原来的（被删除的）&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    shade ( *slot )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if current stack is grey:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 如果对象为灰色，则还需要保护新指向的对象&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        shade ( ptr )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    *slot = ptr&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（开始的时候，stw扫描栈，得到黑色对象）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;golang实际情况：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;伪代码如上。但是这里提出来一点，golang根本不是和伪代码说的这样。没有做条件判断，所以现在的回收精度很低。这个算是一个TodoList。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.0122591943957968&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DVkeCnpYkTS4rfhJmYmicZyYMbNKtGj55dWLSzwWU2LcNiaLO0clJRsJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;571&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：使用了混合屏障，还是针对堆上的，栈上对象写入还是没有barrier。golang之前只使用插入屏障，关键在于栈对象没有，导致栈上黑对象可能指向白对象。所以要rescan。因为如果不rescan，而且又破坏了弱三色不变式（没有处于灰色保护链中），那么就丢数据了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;混合屏障，就是结合删除屏障，保护这一个前提，代价就是进一步降低回收精度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;图表示例：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;混合屏障就是要解决：&lt;strong&gt;栈指向白色对象，stw重新扫描栈的问题。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step1：赋值白对象到黑对象引用，这个不会阻止这个，也不会有写屏障。就是一个正常的赋值。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个时候黑色指向了白色对象。破坏了强三色不变式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;但是这个白色对象还处于灰色状态保护下。符合弱三色不变式。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.35441527446300713&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DiaujllHfur23qsTtVYRv3WHS75iaic25pzYkVf6Y3RC0dCdz7eqIcyANg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1676&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step2：删除指针的时候，意图破坏弱三色不变式的时候，写屏障就会把这个对象置灰色。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.36830102622576966&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DjkltfZP8Er69jfV4hLtmMUwCtPusQvgfqCvyZzar1xzvezSxm3icfXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1754&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;问题一：如果有个还会想？由于栈上没有写屏障，这个删除的对象式根指向的呢？如果存在以下场景?&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step1：堆上的白色对象引用赋值给黑色栈对象。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3645955451348183&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DMmViaDZLmjTrlLcRAv9W2daNtHXMX8ic6rXMH0PGGe5ysALjgD4Kib28g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1706&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step2：如果删除指针，岂不是连弱三色不变式也破坏了？&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.36874236874236876&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DhOuzeeiacib7etGBg8pQib4xSmycRjsA8UEhHAFWUTF6xiazYyOZbz3yFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1638&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这个怎么办呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是：其实根本就不可能出现这个场景的引用图。第一个图就不会出现。因为虽然没有stw，但是扫描某个g的时候，这个g是暂停的。相当于这个g栈是一个快照状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;混合写屏障的栈，要么全黑，要么全白（单个栈）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这个暂停g这个是怎么做到的？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;扫描的时候，会设置一个 _Gscan 状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;casgstatus的时候，保证循环等待这个状态完成。之前是直接吃cpu的，后面做了一个优化，加了一个yield，5us的间隔。&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;关于这段代码的改动&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.39296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DOvKRyxEOkc0JLVLU9v2sp4bJyXcia4nkxbJmB8H1taXYdSZ0ibYhmFwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;问题二：如果是多个栈呢，那么就不是原子的快照了。比如下图？那么就可能导致这种情况。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8549528301886793&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DLQ3JtedhgaOYWEnicYmxlvFQ4k79eXIJVl1z4icMicGN5icx2YcN28aGPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;848&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果说A和前面的黑色对象不属于同一个g栈。那么是否可能会导致这种场景出现？分析下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个场景是有这么一个白色对象，先只被G2栈根引用到。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当前G1已经被扫描完，G2还没有扫描。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;把这个白色对象赋值给G1栈的黑色对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这个时候把G2对白色对象的引用删掉，这样岂不是会出现黑色白色对象，且为唯一指针？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是：这里的关键在于第三步。G1的栈对象接受赋值，这个并不是凭空来的。那么一定是G1自己找来的，可达的对象。这个是一个前提。所以，如果能接受这样的赋值，那么这个白色对象一定是处于G1栈的灰色保护下，因为G1一定是可访问这个对象的。否则，根本就不能完成这个赋值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;混合写屏障的场景，白色对象处于灰色保护下，但是只由堆上的灰色对象保护。注意理解这点；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;屏障生成示例：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4738562091503268&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4Dcziamq5dlDp6dHsPIkOjDJ0Dh0kSGsQl5QCOmSdu1D4tB2icgZfqUicIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;918&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;写堆上内容，才会在编译期间生成写屏障&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;栈上的写，不会有写屏障。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;runtime.gcWriteBarrier :&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5614457831325301&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DqC3Km4voNU8PgnVaDYvicLfrKgGzpiavSBrp9HNZSPMw7icAic9DRsq5ag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;830&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;计算出wbBuf的next位置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;record ptr&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ptr指针放到wbBuf队列中。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;把 &lt;code&gt;*(slot)&lt;/code&gt; 存到wbBuf队列中 ( 置灰色，flush了就是灰色 )&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;shade( *slot )&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;如果队列没有满&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;那么就赋值写（&lt;code&gt;*(slot) = ptr&lt;/code&gt;）; 则返回&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;如果队列满了，那么跳到flush&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;wbBufFlush就是把wbBufFlush里的元属flush到灰色队列中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用完了 runtime.wbBufFlush 处理之后，返回赋值ret（&lt;code&gt;*(slot) = ptr&lt;/code&gt;）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么看起来，就不存在 判断stack是否为灰色的条件？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.8.4 其他屏障&lt;span/&gt;&lt;/h4&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;writePointer(slot, ptr):&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    shade(*slot)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    shade(ptr)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    *slot = ptr&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这种无条件的屏障更加容易理解，直接把目标和源都置灰色保护&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;heap上没有黑色到白色的指针&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;唯一有可能出现黑色到白色的引用 只可能出现在 被扫描了的stack&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一旦 stack 被扫描过了，只有一种办法能得到白色对象指针（white pointer）：通过transfer一个可达（reachable）对象&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;删除屏障和混合写屏障，保护了&lt;code&gt;shade(*slot)&lt;/code&gt;这个指针，就保护了一条路径：这个来路一定是灰色的，下游的白色都会收到保护。并且，我们知道，栈上得到的白色指针一定是可达的，那么一定是有堆上灰色对象保护的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;任何一个白色对象（被黑色栈对象指向的）一定是被堆上灰色对象保护可达的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种屏障会导致比较多的屏障，两倍。所以针对这个考虑权衡，会加一个stack条件判断，就是我们看到的混合屏障的样子。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.9 内存可见性&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提一下golang的内存可见性。在c里面，如果是在多线程环境，并发操作一些变量，需要考虑一些可见性的问题。比如赋值一个变量，这个线程还有可能在寄存器里没有刷下去，或者编译器帮你优化到寄存器中，不去内存读。所以有一个volatile关键字，强制去内存读。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang是否有这个内存可见性的问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一句话，golang里面，只要你保证顺序性，那么内存一致性就没有问题。具体可以搜索happen-before的机制。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.10 注意问题&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.10.1 千万不要尝试绕过golang的类型系统&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;千万不要尝试绕过golang的类型系统。golang官方在提到uintptr类型的时候，都说不要产生uintptr的临时变量，因为很有可能会导致gc的错误回收（这个做过一个简单的验证，1.13本的uintptr类型是不作为指针标记的）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举一个极端的例子，如果你new了一个对象，然后把这个对象的地址保存在8个不连续的byte类型里，那就等着coredump吧。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.10.2 在golang里按照c的思路实现一个内存池很容易踩到巨坑。&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如现在你分配一个大内存出来（1G的[ ]byte类型空间）。这是一个大内存块。并且golang没有任何标识这个地方标识指针。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;golang&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// 分配一个大内存数组（1GB），数组元素是byte。那么自然每个元素都是不含指针的。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;begin := make([]byte, 1024*1024*1024)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.14094650205761317&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DTv0cf8PLNFgtWxhvpiaEY2voibYpX6iaA4r9ibwNibL5A0qtygnhjqO5oGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;972&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么扫描是不会扫描这个内部的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存池分配器接口：&lt;code&gt;func (ac *Allocator) Alloc (size int) unsafe.Pointer&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用来分配对象，使用可能会导致莫名其妙的内存错误。假设用来分配对象T：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;golang&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type T struct {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    s *S&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;t := (*T) (ac.Alloc(sizeT))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;t.s = &amp;amp;S{}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;T对象是从一个大数组里划出来的，垃圾回收其实并不知道T这个对象。不过只要1G内存池本身不被回收，T对象还是安全的。但是T里面的S，是golang走类型系统分配出来的，就会有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设发生垃圾回收了，GC会认为这个内存空间是一个Byte数组，而不会扫描，那么t.s指向的对象认为未被任何对象引用到，它会被清理掉。最后t.s就成了一个悬挂指针。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;golang里面实现内存分配器，适用处理两种情况：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一种是用于分配对象里面不包含其他引用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;另一种，包含的引用对象也在这个分配器里&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，没必要自己搞通用内存池。一旦绕过了golang的类型系统，就会出现坑。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dbdacf39b0ded68ac69bfe9432320066</guid>
<title>FastAPI 的 swagger ui 界面崩溃修复记</title>
<link>https://toutiao.io/k/d1elomi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;最近在用python维护一些接口，一直用FastAPI挺清爽的，特别是自动生成Swagger文档并提供UI可以直接操作测试API这点太方便了。 悲剧居然在520这天降临，界面突然崩了，就像下面这样子：&lt;/p&gt;

&lt;p&gt;corrupt_swagger_ui&lt;/p&gt;

&lt;p&gt;而正常的界面一般长这样&lt;/p&gt;

&lt;p&gt;normal_swagger_ui&lt;/p&gt;

&lt;p&gt;在重启治百病的今天，重启了浏览器乃至重启了系统，换了几台电脑都不行的情况下，难道要加班？虽然孩子都可以打酱油了，520还是要过的啊。&lt;/p&gt;

&lt;p&gt;焦躁地审视一下页面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/swagger-ui-dist@3/swagger-ui.css&quot;&amp;gt;
&amp;lt;link rel=&quot;shortcut icon&quot; href=&quot;https://fastapi.tiangolo.com/img/favicon.png&quot;&amp;gt;
&amp;lt;title&amp;gt;FastAPI - Swagger UI&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&quot;swagger-ui&quot;&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/swagger-ui-dist@3/swagger-ui-bundle.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;!-- `SwaggerUIBundle` is now available on the page --&amp;gt;
&amp;lt;script&amp;gt;
const ui = SwaggerUIBundle({
    url: &#x27;/openapi.json&#x27;,
oauth2RedirectUrl: window.location.origin + &#x27;/docs/oauth2-redirect&#x27;,
    dom_id: &#x27;#swagger-ui&#x27;,
    presets: [
    SwaggerUIBundle.presets.apis,
    SwaggerUIBundle.SwaggerUIStandalonePreset
    ],
    layout: &quot;BaseLayout&quot;,
    deepLinking: true,
    showExtensions: true,
    showCommonExtensions: true
})
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;css和js都是cdn分发下来的，会不会是我连不上cdn呢，不，如果连不上那应该啥都看不到，只有一种可能是内容被改了，于是跑到分发页面swagger-ui-dist - npm[1]去看一下，准备下载一个下来比对：&lt;/p&gt;

&lt;p&gt;swagger_ui_homepage&lt;/p&gt;

&lt;p&gt;10小时之前有更新，看来是官方有bug，不是别人干的了。&lt;/p&gt;

&lt;p&gt;不死心的再去github上Releases · swagger-api/swagger-ui · GitHub[2]确认一下，确实发了新版。&lt;/p&gt;

&lt;p&gt;swagger_ui_github_release_page&lt;/p&gt;

&lt;p&gt;既然是新版有问题，那么我们就调整到老版本3.48.0看看。&lt;/p&gt;

&lt;p&gt;定位到构建app的python代码位置&lt;/p&gt;

&lt;p&gt;app = FastAPI()
把文档地址设为空，就不会注册相关的路由了，等下我们就可以插入自己的路由了。&lt;/p&gt;

&lt;p&gt;app = FastAPI(docs_url=None)
把做的相关修改独立到单独的文件里，不然各种引用一堆看不清楚&lt;/p&gt;

&lt;p&gt;from hotfixes import fix_swagger_ui
fix_swagger_ui(app)
这就是那个单独的文件hotfixes.py，主要操作就是调用get_swagger_ui_html时多添加了swagger_js_url和swagger_css_url两个参数，都替换成具体的上一版本3.48.0。&lt;/p&gt;

&lt;p&gt;from starlette.requests import Request
from fastapi import FastAPI&lt;/p&gt;

&lt;p&gt;from starlette.responses import HTMLResponse
from fastapi.openapi.docs import (
    get_swagger_ui_html,
)&lt;/p&gt;

&lt;p&gt;def patch_swagger_ui(app: FastAPI):
    app.docs_url = &quot;/docs&quot;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;async def swagger_ui_html(req: Request) -&amp;gt; HTMLResponse:
    root_path = req.scope.get(&quot;root_path&quot;, &quot;&quot;).rstrip(&quot;/&quot;)
    openapi_url = root_path + app.openapi_url
    oauth2_redirect_url = app.swagger_ui_oauth2_redirect_url
    if oauth2_redirect_url:
        oauth2_redirect_url = root_path + oauth2_redirect_url
    return get_swagger_ui_html(
        openapi_url=openapi_url,
        title=app.title + &quot; - Swagger UI&quot;,
        oauth2_redirect_url=oauth2_redirect_url,
        init_oauth=app.swagger_ui_init_oauth,
        swagger_js_url=&quot;https://cdn.jsdelivr.net/npm/swagger-ui-dist@3.48.0/swagger-ui-bundle.js&quot;,
        swagger_css_url=&quot;https://cdn.jsdelivr.net/npm/swagger-ui-dist@3.48.0/swagger-ui.css&quot;,
    )

app.add_route(app.docs_url, swagger_ui_html, include_in_schema=False)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启服务，有看到了熟悉的界面，又可以愉快的在界面上直接调用api了。爽，看时间还早，就记录一下大家看个热闹，晚上就可以安安心心的过520了。&lt;/p&gt;

&lt;p&gt;其实这里我好像做的太硬核了，一言不合就改代码。须知不是所有界面和代码我们都能改的，最好还是去路由器或者代理上做个重定向。这些也没权限咋办？浏览器上还可以装插件来重定向，如果长时间还没更新的话，我其他几个api也统统改一遍？不想，到时候再说吧。&lt;/p&gt;

&lt;p&gt;在520这个特殊的日子里,愿每一个程序版本都经过了完整地测试，佛祖保佑无bug，开发和测试互称520,世界大同...&lt;/p&gt;

&lt;p&gt;References
[1] swagger-ui-dist - npm: &lt;a href=&quot;https://www.npmjs.com/package/swagger-ui-dist&quot;&gt;https://www.npmjs.com/package/swagger-ui-dist&lt;/a&gt;
[2] Releases · swagger-api/swagger-ui · GitHub: &lt;a href=&quot;https://github.com/swagger-api/swagger-ui/releases&quot;&gt;https://github.com/swagger-api/swagger-ui/releases&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>696ade89874af4fe5daf90b1bad8e435</guid>
<title>逛到底层看 NIO 的零拷贝</title>
<link>https://toutiao.io/k/25bbheg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;mpsearch class=&quot;js_mpsearch appmsg_search_iframe js_uneditable custom_select_card&quot; data-keywords=&quot;%5B%7B%22label%22%3A%22spring%22%7D%2C%7B%22label%22%3A%22%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%22%7D%2C%7B%22label%22%3A%22%E6%9E%B6%E6%9E%84%E5%B8%88%E6%88%90%E9%95%BF%22%7D%2C%7B%22label%22%3A%22Netty%22%7D%5D&quot; data-parentclass=&quot;appmsg_search_iframe_wrp&quot; data-ratio=&quot;1.5664335664335665&quot; data-w=&quot;286&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本章还是关于NIO的概念铺底，有关NIO相关的代码，我还是希望大家闲余时间取网上找一下有关使用&lt;strong&gt;JDK NIO&lt;/strong&gt;开发服务端、客户端的代码，我会取写这些，但是具体的代码我不会很详细的取介绍，下一章的话可能就要上代码了，具体的规划如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;讲一下NIO基础API的使用、分析Netty的核心思想，使用Reactor模式仿写一个多线程版的Nio程序、再然后就是关于Netty的源码分析了！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回归正题，NIO的高性能除了体现在Epoll模型之外，还有很重要的一点，就是零拷贝！首先大家要先明白一点，所谓的&lt;strong&gt;0拷贝&lt;/strong&gt;，并不是一次拷贝都没有，而是数据由内核空间向用户空间的相互拷贝被取消了，所以称之为零拷贝！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;系统如何操作底层数据文件&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在了解整个IO的读写的过程中，我们需要知道我们的应用程序是如何操作一些内存、磁盘数据的！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在开发中，假设要向硬盘中写入一段文本数据，我们并不需要操作太多的细节，而是只需要简单的将数据转为字节然后在告诉程序，我们要写入的位置以及名称就可以了，为什么这么简单呢？因为操作系统全部帮我们开发好了，我们只需要调用就可以了，但是我们想一下，如果我们的操作系统的全部权限，包括内存都可以让用户随意操作那是一个很危险的事情，例如某些病毒可以随意篡改内存中的数据，以达到某些不轨的目的，那就很难受了！所以，我们的操作系统就必须对这些底层的API进行一些限制和保护！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是如何保护呢？一方面，我们希望外部系统能够调用我的系统API，另一方面我又不想外部随意访问我的API怎么办呢? 此时，我们就要引申出来一个组件叫做kernel,你可以把它理解为一段程序，他在机器启动的时候被加载进来，被用于管理系统底层的一些设备，例如硬盘、内存、网卡等硬件设备！当我们又了kernel之后，会发生什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是以写出文件为例，当我们调用了一个write api的时候，他会将write的方法名以及参数加载到CPU的寄存器中，同时执行一个指令叫做  &lt;strong&gt;int 0x80&lt;/strong&gt;的指令，int 0x80是 &lt;strong&gt;interrupt 128（0x80的10进制）&lt;strong&gt;的缩写，我们一般叫&lt;/strong&gt;80中断&lt;/strong&gt;，当调用了这个指令之后，CUP会停止当前的调度，保存当前的执行中的线程的状态，然后在中断向量表中寻找 128代表的回调函数，将之前写到寄存器中的数据（write /参数）当作参数，传递到这个回调函数中，由这个回调函数去寻找对应的系统函数write进行写出操作！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家回想一下，当系统发起一个调用后不再是用户程序直接调用系统API的而是切换成内核调用这些API，所以内核是以这种方式来保护系统的而且这也就是 &lt;strong&gt;用户态切换到内核态&lt;/strong&gt;！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;传统的I/O读写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;场景：读取一个图片通过socket传输到客户端展示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.26237905520774046&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yYet2uXPiclAHcA9ZkyQW6o5vVdQysTyWO5MKur8ZgowdicwiblVXN3Mic1XAcwkibZws1GamvSjjCNicicTI0xtdU5cw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1757&quot;/&gt;&lt;figcaption&gt;image-20210314222351485&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;程序发起read请求，调用系统read api由用户态切换至内核态！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CPU通过DMA引擎将磁盘数据加载到内核缓冲区，触发中止指令，CPU将内核缓冲区的数据拷贝到用户空间！由内核态切换至用户态！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;程序 发起write调用，调用系统API，由用户态切换只内核态，CPU将用户空间的数据拷贝到Socket缓冲区！再由内核态切换至用户态！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DMA引擎异步将Socket缓冲区拷贝到网卡通过底层协议栈发送至对端！&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以了解一下，这当中发生了4次上下文的切换和4次数据拷贝！我们大致分析一下，那些数据拷贝是多余的：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;磁盘文件拷贝到内核缓冲区是必须的不能省略，因为这个数据总归要读取出来的！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;内核空间拷贝到用户空间，如果我们不准备对数据做修改的话，好像没有必要呀，直接拷贝到Socket缓冲区不就可以了&lt;/strong&gt;！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Socket到网卡，好像也有点多余，为什么这么说呢？因为我们直接从内核空间里面直接怼到网卡里面，中间不就少了很多的拷贝和上下文的切换看吗？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;sendfile&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过Centos &lt;strong&gt;man page&lt;/strong&gt;指令查看该函数的定义！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以通过该链接下载:sendfile()函数介绍&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;基本介绍：&lt;/p&gt;&lt;p&gt;sendfile——在文件描述符之间传输数据&lt;/p&gt;&lt;p&gt;描述&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;ssize_t&lt;/span&gt; &lt;span&gt;sendfile&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; out_fd, &lt;span&gt;int&lt;/span&gt; in_fd, &lt;span&gt;off_t&lt;/span&gt; *offset, &lt;span&gt;size_t&lt;/span&gt; count)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;sendfile()在一个文件描述符和另一个文件描述符之间复制数据。因为这种复制是在内核中完成的，所以sendfile()比read(2)和write(2)的组合更高效，后者需要在用户空间之间来回传输数据。&lt;/p&gt;&lt;p&gt;in_fd应该是打开用于读取的文件描述符，而out_fd应该是打开用于写入的文件描述符。&lt;/p&gt;&lt;p&gt;如果offset不为NULL，则它指向一个保存文件偏移量的变量，sendfile()将从这个变量开始从in_fd读取数据。当sendfile()返回时，这个变量将被设置为最后一个被读取字节后面的字节的偏移量。如果offset不为NULL，则sendfile()不会修改当前值&lt;/p&gt;&lt;p&gt;租用文件偏移in_fd;否则，将调整当前文件偏移量以反映从in_fd读取的字节数。&lt;/p&gt;&lt;p&gt;如果offset为NULL，则从当前文件偏移量开始从in_fd读取数据，并通过调用更新文件偏移量。&lt;/p&gt;&lt;p&gt;count是要在文件描述符之间复制的字节数。&lt;/p&gt;&lt;p&gt;in_fd参数必须对应于支持类似mmap(2)的操作的文件(也就是说，它不能是套接字)。&lt;/p&gt;&lt;p&gt;在2.6.33之前的Linux内核中，out_fd必须引用一个套接字。从Linux 2.6.33开始，它可以是任何文件。如果是一个常规文件，则sendfile()适当地更改文件偏移量。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来说，sendfile函数可以将两个文件描述符里面的数据来回复制，再Linux中万物皆文件！内核空间和Socket也是一个个的对应的文件，sendfile函数可以将两个文件里面的数据来回传输，这也造就了，我们后面的零拷贝优化！&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;sendfile - linux2.4之前&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5802845528455285&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yYet2uXPiclAHcA9ZkyQW6o5vVdQysTyW3vWJXQVY29GE9JicEhQw93BKJMEsyeB90pMfBPzoHTwwyExC2SZRdYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;984&quot;/&gt;&lt;figcaption&gt;image-20210314230009773&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户程序发起read请求，程序由用户态切换至内核态！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DMA引擎将数据从磁盘拷贝出来到内核空间！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用sendfile函数将内核空间的数据直接拷贝到Socket缓冲区！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;上下文从内核态切换至用户态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Socket缓冲区通过DMA引擎，将数据拷贝到网卡，通过底层协议栈发送到对端！&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个优化不可谓不狠，上下文切换次数变为两次，数据拷贝变为两次，这基本符合了我们上面的优化要求，但是我们还是会发现，从内核空间到Socket缓冲区，然后从内核缓冲区到网卡似乎也有点鸡肋，所以，Linux2.4之后再次进行了优化！&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;sendfile - linux2.4之后&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5581874356333677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yYet2uXPiclAHcA9ZkyQW6o5vVdQysTyW4gNNPZ0hdaFCAM33DX1eiccRFF7AtVCp6FKha1Wwq6EYTfUeW66Hz3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;971&quot;/&gt;&lt;figcaption&gt;image-20210314231519642&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户程序发起read请求，程序由用户态切换至内核态！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DMA引擎将数据从磁盘拷贝出来到内核空间！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用sendfile函数将内核空间的数据再内存中的起始位置和偏移量写入Socket缓冲区！然后内核态切换至用户态！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DMA引擎读取Socket缓冲区的内存信息，直接由内核空间拷贝至网卡！&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的优化是原本将内核空间的数据拷贝至Socket缓冲区的步骤，变成了只记录文件的起始位置和偏移量！然后程序直接返回，由DMA引擎异步的将数据从内核空间拷贝到网卡！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么不是直接拷贝，而是多了一步记录文件信息的步骤呢？因为相比于内核空间，网卡的读取速率实在是太慢了，这一步如果由CPU来操作的话，会严重拉低CPU的运行速度，所以要交给DMA来做，但是因为是异步的，DMA引擎又不知道为这个Socket到底发送多少数据，所以要在Socket上记录文件起始量和数据长度，再由DMA引擎读取这些文件信息，将文件发送只网卡数据！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;mmap&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过Centos &lt;strong&gt;man page&lt;/strong&gt;指令查看该函数的定义！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mmap()函数介绍&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;名字&lt;/p&gt;&lt;p&gt;mmap, munmap -将文件或设备映射到内存中&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;mmap&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt; *addr, &lt;span&gt;size_t&lt;/span&gt; length, &lt;span&gt;int&lt;/span&gt; prot, &lt;span&gt;int&lt;/span&gt; flags,&lt;br/&gt;       &lt;span&gt;int&lt;/span&gt; fd, &lt;span&gt;off_t&lt;/span&gt; offset)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;munmap&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt; *addr, &lt;span&gt;size_t&lt;/span&gt; length)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;描述:&lt;/p&gt;&lt;p&gt;mmap()在调用进程的虚拟地址空间中创建一个新的映射。新映射的起始地址在addr中指定。length参数指定映射的长度,如果addr为空，则内核选择创建映射的地址;这是创建新映射的最可移植的方法。如果addr不为空，则内核将其作为提示!关于在哪里放置映射;在Linux上，映射将在附近的页面边界创建。新映射的地址作为调用的结果返回。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mmap()系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再调用read()，write（）等操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么叫区域共享，这个不能被理解为我们的应用程序就可以直接到内核空间读取数据了，而是我们在用户空间里面再开辟一个空间，将内核空间的数据的起始以及偏移量映射到用户空间！简单点说 **也就是用户空间的内存，持有对内核空间这一段内存区域的引用！**这样用户空间在操作读取到的数据的时候，就可以像直接操作自己空间下的数据一样操作内核空间的数据！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.27109826589595376&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yYet2uXPiclAHcA9ZkyQW6o5vVdQysTyWx4SrESdCc1via8767eolxM0ia36PIrEvO9TeFzPCLsCkpZ8KGXvia0KiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1730&quot;/&gt;&lt;figcaption&gt;image-20210315092915111&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户程序发起read请求，然后上下文由用户态切换至内核态！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cpu通知DMA，由DMA引擎异步将数据读取至内核区域，同时在用户空间建立地址映射！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;上下文由内核态切换至用户态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发起write请求，上下文由用户态切换至内核态！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CPU通知DMA引擎将数据拷贝至Socket缓存！程序切换至用户态！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DMA引擎异步将数据拷贝至网卡！&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很明白的发现mmap函数在read数据的时候，少了异步由内核空间到用户空间的数据复制，&lt;strong&gt;而是直接建立一个映射关系，操作的时候，直接操作映射数据，但是上下文的切换没有变！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mmap所建立的虚拟空间，空间量事实上可以远大于物理内存空间，假设我们想虚拟内存空间中写入数据的时候，超过物理内存时，操作系统会进行页置换，根据淘汰算法，将需要淘汰的页置换成所需的新页，所以mmap对应的内存是可以被淘汰的（若内存页是&quot;脏&quot;的，则操作系统会先将数据回写磁盘再淘汰）。这样，就算mmap的数据远大于物理内存，操作系统也能很好地处理，不会产生功能上的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;sendfile: 只经历两次上线文的切换和两次数据拷贝，但是缺点也显而易见，你无法对数据进行修改操作！适合大文件的数据传输！而且是没有没有修改数据的需求！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;mmap: 经历4次上下文的切换、三次数据拷贝，但是用户操作读取来的数据，异常简单！适合小文件的读写和传输！&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;nio的堆外内存&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆外内存的实现类是&lt;code&gt;DirectByteBuffer&lt;/code&gt;, 我们查看SocketChannel再向通道写入数据的时候的代码：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.35300546448087433&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yYet2uXPiclAHcA9ZkyQW6o5vVdQysTyWkHqiawcEibjic9Aeicwqj80m4g4q8u8SvMES7B2XSoKZhdhq3UpgicHHibqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;915&quot;/&gt;&lt;figcaption&gt;image-20210315121518393&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码是当你调用SocketChannel.write的时候的源代码，我们从代码中可以得知，无论你是否使用的是不是堆外内存，在内部NIO都会将其转换为堆外内存，然后在进行后续操作，那么堆外内存究竟有何种魔力呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;何为堆外内存，要知道我们的JAVA代码运行在了JVM容器里面，我们又叫做&lt;strong&gt;Java虚拟机&lt;/strong&gt;，java开发者为了方便内存管理和内存分配，将JVM的空间与操作系统的空间隔离了起来，市面上所有的VM程序都是这样做的，VM程序的空间结构和操作系统的空间结构是不一样的，所以java程序无法直接的将数据写出去，必须先将数据拷贝到C的堆内存上也就是常说的堆外内存，然后在进行后续的读写，在NIO中直接使用堆外内存可以省去JVM内部数据向本次内存空间拷贝的步骤，加快处理速度！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且NIO中每次写入写出不在是以一个一个的字节写出，而是用了一个Buffer内存块的方式写出，也就是说只需要告诉CPU 我这个数据块的数据开始的索引以及数据偏移量就可以直接读取，但是JVM通过垃圾回收的时候，通过会做垃圾拷贝整理，这个时候会移动内存，这个时候如果内存地址改变，就势必会出现问题，所以我们要想一个办法，让JVM垃圾回收不影响这个数据块！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结来说：&lt;strong&gt;它可以使用Native 函数库直接分配堆外内存，然后通过一个存储在Java 堆里面的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java 堆和Native 堆中来回复制数据。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;能够避免JVM垃圾回收过程中做内存整理，所产生的的问题，当数据产生在JVM内部的时候，JVM的垃圾回收就无法影响这部分数据了，而且能够变相的减轻JVM垃圾回收的压力！因为不用再管理这一部分数据了！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他的内存结构看起来像这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6909569798068481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yYet2uXPiclAHcA9ZkyQW6o5vVdQysTyWly1KVrs3CjKQSX1RyDkibnP3moboxN4HzbIftdV718CjrfddZsyIFiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1139&quot;/&gt;&lt;figcaption&gt;image-20210315125336866&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么&lt;code&gt;DirectByteBuffer&lt;/code&gt;就能够直接操作JVM外的内存呢？我们看下他的源码实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;DirectByteBuffer(&lt;span&gt;int&lt;/span&gt; cap) { &lt;br/&gt;  .....忽略....&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//分配内存&lt;/span&gt;&lt;br/&gt;            base = unsafe.allocateMemory(size);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (OutOfMemoryError x) {&lt;br/&gt;            ....忽略....&lt;br/&gt;        }&lt;br/&gt;        ....忽略....&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (pa &amp;amp;&amp;amp; (base % ps != &lt;span&gt;0&lt;/span&gt;)) {&lt;br/&gt;            &lt;span&gt;//对齐page 计算地址并保存&lt;/span&gt;&lt;br/&gt;            address = base + ps - (base &amp;amp; (ps - &lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//计算地址并保存&lt;/span&gt;&lt;br/&gt;            address = base;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//释放内存的回调&lt;/span&gt;&lt;br/&gt;        cleaner = Cleaner.create(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Deallocator(base, size, cap));&lt;br/&gt;        ....忽略..&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们主要关注：&lt;code&gt;unsafe.allocateMemory(size);&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;allocateMemory&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; var1)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到他调用的是 native方法，这种方法通常由C++实现，是直接操作内存空间的，这个是被jdk进行安全保护的操作，也就是说你通过&lt;code&gt;Unsafe.getUnsafe()&lt;/code&gt;是获取不到的，必须通过反射，具体的实现，自行翻阅浏览器！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如此NIO就可以通过本地方法去操作JVM外的内存，但是大家有没有发现一点问题，我们现在是能够让操作系统直接读取数据了，而且也能够避免垃圾回收所带来的影响了还能减轻垃圾回收的压力，可谓是一举三得，但是大家有没有考虑过一个问题，这部分空间不经过垃JVM管理了，他该什么时候释放呢？JVM都管理不了了，那么堆外内存势必会导致OOM的出现，所以，我们必须要去手动的释放这个内存，但是手动释放对于编程复杂度难度太大，所以，JVM对堆外内存的管理也做了一部分优化，首先我们先看一下上述&lt;strong&gt;DirectByteBuffer&lt;/strong&gt;中的&lt;code&gt;cleaner = Cleaner.create(this, new Deallocator(base, size, cap));&lt;/code&gt;,这个对象，他主要用于堆外内存空间的释放；&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Cleaner&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;PhantomReference&lt;/span&gt;&amp;lt;&lt;span&gt;Object&lt;/span&gt;&amp;gt; &lt;/span&gt;{....}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;虚引用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Cleaner继承了一个PhantomReference，这代表着Cleaner是一个虚引用，有关强软弱虚引用的使用，请大家自行百度，Netty更新完成之后，我会写一篇文章做单独的介绍，这里就不一一介绍了，这里直接说&lt;strong&gt;PhantomReference&lt;/strong&gt;虚引用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PhantomReference&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Reference&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;PhantomReference&lt;/span&gt;&lt;span&gt;(T referent, ReferenceQueue&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt; q)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(referent, q);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虚引用的构造函数中要求必须传递的两个参数，被引用对象、引用队列！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个参数的用意是什么呢，看个图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.622568093385214&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yYet2uXPiclAHcA9ZkyQW6o5vVdQysTyWG5vl1VLF5e1Pvku69ybAnTkZpver5ScnX7QEROicnNK5gn0xq6BRTmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;771&quot;/&gt;&lt;figcaption&gt;image-20210315131401311&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM中判断一个对象是否需要回收，一般都是使用&lt;strong&gt;可达性分析算法&lt;/strong&gt;，什么是可达性分析呢？就是从所谓的方法区、栈空间中找到被标记为root的节点，然后沿着&lt;strong&gt;root节点向下找&lt;/strong&gt;，被找到的都任务是存活对象，当所有的root节点&lt;strong&gt;寻找完毕后&lt;/strong&gt;，剩余的节点也就被认为是&lt;strong&gt;垃圾对象&lt;/strong&gt;；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;依据上图，我们明显发现栈空间中持有对direct的引用，我们将该对象传递给弱引用和，弱引用也持有该对象，现在相当于direct引用和ref引用同时引用堆空间中的一块数据，当direct使用完毕后，该引用断开：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6106666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yYet2uXPiclAHcA9ZkyQW6o5vVdQysTyWT4iaZqLcTlpUl0NDJkx6yZQqxImtUD2HRZGDiccedtoh3f7O2qtEEMrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;figcaption&gt;image-20210315131857691&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM通过可待性分析算法，发现除了 ref引用之外，其余的没有人引用他，因为ref是虚引用，所以本次垃圾回收一定会回收它，回收的时候，做了一件什么事呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在创建这个虚引用的时候传入了一个队列，在这个对象被回收的时候，被引用的对象会进入到这个回调！&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyPhantomReference&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; ReferenceQueue&amp;lt;Object&amp;gt; queue = &lt;span&gt;new&lt;/span&gt; ReferenceQueue&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;10&lt;/span&gt; * &lt;span&gt;1024&lt;/span&gt;];&lt;br/&gt;        &lt;span&gt;//将该对象被虚引用引用&lt;/span&gt;&lt;br/&gt;        PhantomReference&amp;lt;Object&amp;gt; objectPhantomReference = &lt;span&gt;new&lt;/span&gt; PhantomReference&amp;lt;Object&amp;gt;(bytes,queue);&lt;br/&gt;        &lt;span&gt;//这个一定返回null  因为实在接口定义中写死的&lt;/span&gt;&lt;br/&gt;        System.out.println(objectPhantomReference.get());&lt;br/&gt;        &lt;span&gt;//此时jvm并没有进行对象的回收，该队列返回为空&lt;/span&gt;&lt;br/&gt;        System.out.println(queue.poll());&lt;br/&gt;        &lt;span&gt;//手动释放该引用，将该引用置为无效引用&lt;/span&gt;&lt;br/&gt;        bytes = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;//触发gc&lt;/span&gt;&lt;br/&gt;        System.gc();&lt;br/&gt;        &lt;span&gt;//这里返回的还是null  接口定义中写死的&lt;/span&gt;&lt;br/&gt;        System.out.println(objectPhantomReference.get());&lt;br/&gt;        &lt;span&gt;//垃圾回收后，被回收对象进入到引用队列&lt;/span&gt;&lt;br/&gt;        System.out.println(queue.poll());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本了解了虚引用之后，我们再来看&lt;code&gt;DirectByteBuffer&lt;/code&gt;对象，他在构造函数创建的时候引用看一个虚引用&lt;code&gt;Cleaner&lt;/code&gt;！当这个DirectByteBuffer使用完毕后，DirectByteBuffer被JVM回收，触发Cleaner虚引用！JVM垃圾线程会将这个对象绑定到&lt;code&gt;Reference&lt;/code&gt;对象中的&lt;code&gt;pending&lt;/code&gt;属性中，程序启动后引用类&lt;code&gt;Reference&lt;/code&gt;类会创建一条守护线程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; {&lt;br/&gt;        ThreadGroup tg = Thread.currentThread().getThreadGroup();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (ThreadGroup tgn = tg;&lt;br/&gt;             tgn != &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;             tg = tgn, tgn = tg.getParent());&lt;br/&gt;        Thread handler = &lt;span&gt;new&lt;/span&gt; ReferenceHandler(tg, &lt;span&gt;&quot;Reference Handler&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//设置优先级为系统最高优先级&lt;/span&gt;&lt;br/&gt;        handler.setPriority(Thread.MAX_PRIORITY);&lt;br/&gt;        handler.setDaemon(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;        handler.start();&lt;br/&gt;  &lt;span&gt;//.......................&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看一下该线程的定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;tryHandlePending&lt;/span&gt;&lt;span&gt;(&lt;span&gt;boolean&lt;/span&gt; waitForNotify)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Reference&amp;lt;Object&amp;gt; r;&lt;br/&gt;        Cleaner c;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;synchronized&lt;/span&gt; (lock) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (pending != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                   &lt;span&gt;//......忽略&lt;/span&gt;&lt;br/&gt;                    c = r &lt;span&gt;instanceof&lt;/span&gt; Cleaner ? (Cleaner) r : &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;                    pending = r.discovered;&lt;br/&gt;                    r.discovered = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;                } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;//队列中没有数据结阻塞  RefQueue入队逻辑中有NF操作，感兴趣可以自己去看下&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (waitForNotify) {&lt;br/&gt;                        lock.wait();&lt;br/&gt;                    }&lt;br/&gt;                    &lt;span&gt;// retry if waited&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; waitForNotify;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (OutOfMemoryError x) {&lt;br/&gt;            &lt;span&gt;//发生OOM之后就让出线程的使用权，看能不能内部消化这个OOM&lt;/span&gt;&lt;br/&gt;            Thread.yield();&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException x) {&lt;br/&gt;            &lt;span&gt;// 线程中断的话就直接返回&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 这里是关键，如果虚引用是一个 cleaner对象，就直接进行清空操作，不在入队&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (c != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;//TODO 重点关注&lt;/span&gt;&lt;br/&gt;            c.clean();&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;  &lt;span&gt;//如果不是 cleaner对象，就将该引用入队&lt;/span&gt;&lt;br/&gt;        ReferenceQueue&amp;lt;? &lt;span&gt;super&lt;/span&gt; Object&amp;gt; q = r.queue;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (q != ReferenceQueue.NULL) q.enqueue(r);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那我们此时就应该重点关注**c.clean();**方法了！&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;this&lt;/span&gt;.thunk.run();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重点关注这个，thunk是一个什么对象？我们需要重新回到 DirectByteBuffer创建的时候，看看他传递的是什么。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; cleaner = Cleaner.create(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Deallocator(base, size, cap));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到，传入的是一个 &lt;code&gt;Deallocator&lt;/code&gt;对象，那么他所调用的run方法，我们看下逻辑:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (address == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;// Paranoia&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//释放内存&lt;/span&gt;&lt;br/&gt;    unsafe.freeMemory(address);&lt;br/&gt;    address = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    Bits.unreserveMemory(size, capacity);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重点关注**unsafe.freeMemory(address);**这个就是释放内存的！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，我们知道了JVM是如何管理堆外内存的了！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6054481546572935&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yYet2uXPiclAHcA9ZkyQW6o5vVdQysTyWJGRTMzWnllaMf0oja29St2NqrNz49g5aWAqRC5YxM2AwYZXib6HC5gQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1138&quot;/&gt;&lt;figcaption&gt;image-20210315143654610&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>66af45769d211df66854ae369ced17f8</guid>
<title>DuckDB：开篇</title>
<link>https://toutiao.io/k/g6gcl8g</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.773972602739726&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9637P74IBOH4hsRQYibBVGPSdDsXhoILAeqFHcAyic08mBE915l4ZT6ZL74713sZ5hoenknE7jCzW27UE63lQnCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;146&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;DuckDB 简介&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近发现了一个适合深入学习的开源分析型数据库——&lt;span&gt;DuckDB&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;。简单说，DuckDB 是一个 &lt;span&gt;OLAP&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;（列存）版本的 &lt;span&gt;SQLite&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为了一个学习样例，DuckDB 具有以下优点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;DuckDB 没有外部依赖，所以编译、链接、运行都可以一气呵成，非常简单。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码不算多，除去测试代码，大概 13~14w 行，并且代码质量不错。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;麻雀虽小，五脏俱全。并且 DuckDB 遵循教科书上的经典模块设计，相对容易看懂。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DuckDB 集成了 OLAP 领域的各种知识，它的各种设计、实现都可以找到参考论文，方便学习。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;对比 LevelDB&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前也写过&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;amp;album_id=1342947967103352833&amp;amp;__biz=MzI0NjA1MTU5Ng==#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;一系列 LevelDB 源码解析的文章&lt;/a&gt;。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI0NjA1MTU5Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/9637P74IBOELE4a67W59PvEHNfF5smZrVwsjic7qZT9wum9eZa3MqFx8MfXddXZiatAVcvQVsV45cTjQLRXQdzag/0?wx_fmt=png&quot; data-nickname=&quot;coredump&quot; data-alias=&quot;cpp-coredump&quot; data-signature=&quot;分布式、数据库、C++、算法等&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码量上，LevelDB 大概也就 2w 行，比 DuckDB 少很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;功能上，LevelDB 只是一个简单的 key-value 存储。而 DuckDB 则是一个完成的数据库——SQL Parser、Optimizer、Execution Engine、Transaction、Storage 一个不少。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;DuckDB 的模块介绍&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;SQL Parser&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DuckDB 的 &lt;span&gt;SQL parser&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt; 是从 Postgres 的 &lt;span&gt;libpg_query &lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;精简而来的。由于 Postgres 是 C 语言写的，通过这个 SQL parser，我们会得到一个 C 语言结构体表示的 parse tree。DuckDB 会将其转换成自己内部的 C++ 对象。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Logical Planner&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Logical planner&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt; 由 binder 和 plan generator 两部分组成。Binder 将 parse tree 与 schema 的信息（列名、类型等）绑定起来。Schema 信息保存在 &lt;span&gt;catalog&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;。Plan generator 将 parse tree 转换成一颗逻辑查询操作符（scan, filter, project 等）树。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Optimizer&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DuckDB 实现了基于规则（rule-based）和基于代价（cost-based）的优化器。&lt;span&gt;Optimizer&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt; 的主要任务是优化 SQL，它将前面 logical planner 生成的 logical plan 转换成一个&lt;strong&gt;等价但执行代价更小&lt;/strong&gt;的 logical plan。常见的优化方式有谓词下推（predicate pushdown）、表达式重写（expression rewriting）、调整 join 顺序（join ordering）等。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Physical Planner 和 Execution Engine&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Physical planner 和 execution engine 的代码都在 &lt;span&gt;execution &lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;目录下。Physical planner 将 Logical plan 转换成 physical plan。Physical plan 是一个真正可以执行的物理计划。DuckDB 实现了一个向量化（vectorized）的解释型执行引擎。向量化可以利用 CPU 提供的 SIMD 指令加速计算。DuckDB 采用 SQL 的解释执行，而没有采用 SQL 的编译执行，原因是编译执行需要依赖编译组件，比如 LLVM，这会导致 DuckDB 的体积膨胀不少。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Transaction and Concurrency Control&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DuckDB 支持 Serializable 的事务隔离。事务相关的代码在 &lt;span&gt;transaction &lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt;目录下。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Storage&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Storage &lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt;是 DuckDB 的列式存储引擎，处于整个 DuckDB 架构的最底层，负责提供数据的高效读写。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;编译运行&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DuckDB 的下载和编译很简单：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;git &lt;span&gt;clone&lt;/span&gt; https://github.com/duckdb/duckdb&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; duckdb&lt;br/&gt;BUILD_BENCHMARK=1 BUILD_TPCH=1 make&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译完成后，我们可以得到一个 DuckDB 的二进制库+头文件。另外，我们得到一个 benchmark 程序，可以用来测试 DuckDB 的性能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# 列出所支持的 benchmark &lt;/span&gt;&lt;br/&gt;build/release/benchmark/benchmark_runner --list&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 运行指定的一个 benchmark&lt;/span&gt;&lt;br/&gt;build/release/benchmark/benchmark_runner benchmark/tpch/sf1/q01.benchmark&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 运行某个目录下的 benchmark&lt;/span&gt;&lt;br/&gt;build/release/benchmark/benchmark_runner &lt;span&gt;&#x27;benchmark/tpch/sf1/.*&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 运行所有 benchmark&lt;/span&gt;&lt;br/&gt;build/release/benchmark/benchmark_runner&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于 benchmark_runner 的更多功能，可以参考&lt;span&gt;官方文档&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;DuckDB: &lt;em&gt;https://duckdb.org/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;OLAP: &lt;em&gt;https://en.wikipedia.org/wiki/Online_analytical_processing&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;SQLite: &lt;em&gt;https://www.sqlite.org/index.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;SQL parser: &lt;em&gt;https://github.com/duckdb/duckdb/tree/v0.2.6/src/parser&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;libpg_query : &lt;em&gt;https://github.com/lfittl/libpg_query&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;Logical planner: &lt;em&gt;https://github.com/duckdb/duckdb/tree/v0.2.6/src/planner&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;catalog: &lt;em&gt;https://github.com/duckdb/duckdb/tree/v0.2.6/src/catalog&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;Optimizer: &lt;em&gt;https://github.com/duckdb/duckdb/tree/v0.2.6/src/optimizer&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;execution : &lt;em&gt;https://github.com/duckdb/duckdb/tree/v0.2.6/src/execution&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10]&lt;/span&gt;&lt;p&gt;transaction : &lt;em&gt;https://github.com/duckdb/duckdb/tree/v0.2.6/src/transaction&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11]&lt;/span&gt;&lt;p&gt;Storage : &lt;em&gt;https://github.com/duckdb/duckdb/tree/v0.2.6/src/storage&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12]&lt;/span&gt;&lt;p&gt;官方文档: &lt;em&gt;https://github.com/duckdb/duckdb/blob/v0.2.6/benchmark/README.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>