<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>4a225e2d07d887526ac95e9ada8924b5</guid>
<title>面试过 200 人的经验，都在这里了 | 码农周刊第 325 期</title>
<link>https://toutiao.io/k/xvysg5s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;面试过 200 人的经验，都在这里了 | 码农周刊第 325 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第325期（2020-11-25）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=325&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3250&quot; target=&quot;_blank&quot;&gt;薪资翻番如何实现？程序员的涨薪秘诀&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=325&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3250&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_321.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=325&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;相比 cocos2d 引擎有着更低的入门门槛和维护成本，为复杂动画的实现提供了一种全新的方式，新的复杂动画开发将会变得更加简单高效。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;让您享受极简编程体验，快速访问支付宝开放平台开放的各项核心能力。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;一个不错的 Python 学习教程，30 天循序渐进地教你学会 Python。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;白皮书从技术、市场、趋势、挑战等多维度，对我国开源产业生态进行了全面、深度的剖析，指出了我国开源产业发展的几大重要趋势。&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        
        &lt;p&gt;经验总结&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;一步步教你&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        
        &lt;p&gt;供参考&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;收藏吧&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;实用&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;使用方便&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;一步步教你&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;良心教程&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;你怎么看？&lt;/p&gt;
        
        &lt;p&gt;深入研究&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;技术总结，经验分享&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 451179 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 429587 即可&lt;/p&gt;
        
        &lt;p&gt;分享计算机视觉与机器学习技术的最前沿&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 359575 即可&lt;/p&gt;
        
        &lt;p&gt;聚焦基础架构和Linux。十年架构，日百亿流量，与你探讨高并发世界，给你不一样的味道。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 351247 即可&lt;/p&gt;
        
        &lt;p&gt;学习就是不停的积累&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 24912 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;本手册以开发工程师为中心视角，划分为单元测试、安全规约、MySQL 数据库、工程结构等七个维度，相应的扩展解释和说明、正例和反例，全面、立体、形象地帮助开发工程师成长。欢迎到&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;兑换阅读。&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;个人经历&lt;/p&gt;
        
        &lt;p&gt;一直被追赶，从未被超越&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>deb9c783024cc3046c250bf0c90456a8</guid>
<title>编码风格：Mvc 模式下 SSM 环境，代码分层管理</title>
<link>https://toutiao.io/k/dr3u1om</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1&gt;&lt;span&gt;一、分层策略&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;MVC模式与代码分层策略，MVC全名是ModelViewController即模型－视图－控制器，作为一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑，这是一种开发模式，但并不是实际开发中代码的分层模式，通常SSM框架的后端代码分层如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7587006960556845&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDMX1ZqiaQLKPukndEhjpicD1TH4QxYQ2s3iaf61M2NNW0edLHaG73jhZicA6GkhPFcxWIyT8GicQSzluw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;862&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;controller控制层：定义服务端接口，入参出参，和一些入参校验；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;service业务服务层：组装业务逻辑，业务校验，构建控制层需要的参数模型；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;dao数据交互层：提供服务层需要的数据查询方法，处理数据交互条件相关的逻辑；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;mapper持久层：基于mybatis框架需要的原生支持，目前很常用的持久层组件；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;&lt;span&gt;二、控制层&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、Rest接口风格&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;基于资源访问和处理的逻辑，使用不同风格的注解。例如资源新增，更新，查询，删除。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 新增&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@PostMapping&lt;/span&gt;(&lt;span&gt;&quot;/insert&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; Integer &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;(@RequestBody BaseInfo baseInfo)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; baseInfoService.insert(baseInfo);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 更新&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@PutMapping&lt;/span&gt;(&lt;span&gt;&quot;/update/{id}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;update&lt;/span&gt;&lt;span&gt;(@PathVariable(value = &lt;span&gt;&quot;id&quot;&lt;/span&gt;)&lt;/span&gt; Integer id,&lt;br/&gt;                     @RequestBody BaseInfo baseInfo) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (id&amp;lt;&lt;span&gt;1&lt;/span&gt;){&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;error&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    baseInfo.setId(id);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;update=&quot;&lt;/span&gt;+baseInfoService.update(baseInfo);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 主键查询&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/detail/{id}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; InfoModel &lt;span&gt;detail&lt;/span&gt;&lt;span&gt;(@PathVariable(value = &lt;span&gt;&quot;id&quot;&lt;/span&gt;)&lt;/span&gt; Integer id) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; baseInfoService.detail(id) ;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 主键删除&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@DeleteMapping&lt;/span&gt;(&lt;span&gt;&quot;/delete/{id}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;delete&lt;/span&gt;&lt;span&gt;(@PathVariable(value = &lt;span&gt;&quot;id&quot;&lt;/span&gt;)&lt;/span&gt; Integer id) &lt;/span&gt;{&lt;br/&gt;    baseInfoService.delete(id) ;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;SUS&quot;&lt;/span&gt; ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;2、接口复用度&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;不建议接口高度复用，例如增删改查都各自对接接口即可，基本原则，不同的客户端端操作，对于独立的接口。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 列表加载&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/list&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;BaseInfo&amp;gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; baseInfoService.list(&lt;span&gt;new&lt;/span&gt; BaseInfoExample()) ;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 列表搜索&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@PostMapping&lt;/span&gt;(&lt;span&gt;&quot;/search&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;BaseInfo&amp;gt; &lt;span&gt;search&lt;/span&gt; &lt;span&gt;(@RequestParam(&lt;span&gt;&quot;userName&quot;&lt;/span&gt;)&lt;/span&gt; String userName,&lt;br/&gt;                              @&lt;span&gt;RequestParam&lt;/span&gt;&lt;span&gt;(&lt;span&gt;&quot;phone&quot;&lt;/span&gt;)&lt;/span&gt; String phone) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; baseInfoService.search(userName,phone) ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如常见的list接口，list通常都有会按条件加载的search机制，而且搜索的判断条件很复杂，建议分为两个接口，从实际考虑，大部分场景下都是只使用list接口，很少使用search搜索。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3、入参出参&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;校验客户端必须条件，例如某某条件必填必选等，如果有问题，快速阻断请求链路，做到程序入口控制层拦截返回。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@PutMapping&lt;/span&gt;(&lt;span&gt;&quot;/update/{id}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;update&lt;/span&gt;&lt;span&gt;(@PathVariable(value = &lt;span&gt;&quot;id&quot;&lt;/span&gt;)&lt;/span&gt; Integer id,&lt;br/&gt;                     @RequestBody BaseInfo baseInfo) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (id&amp;lt;&lt;span&gt;1&lt;/span&gt;){&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;error&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    baseInfo.setId(id);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;update=&quot;&lt;/span&gt;+baseInfoService.update(baseInfo);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参数在三个以下，可以直接陈列入参，参数在三个或三个以上可以使用实体类统一封装。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@PostMapping&lt;/span&gt;(&lt;span&gt;&quot;/search&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;BaseInfo&amp;gt; &lt;span&gt;search&lt;/span&gt; &lt;span&gt;(@RequestParam(&lt;span&gt;&quot;userName&quot;&lt;/span&gt;)&lt;/span&gt; String userName,&lt;br/&gt;                              @&lt;span&gt;RequestParam&lt;/span&gt;&lt;span&gt;(&lt;span&gt;&quot;phone&quot;&lt;/span&gt;)&lt;/span&gt; String phone) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; baseInfoService.search(userName,phone) ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;4、参数处理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;出参格式处理度基本原则，服务器作为公共资源，避免非必要操作，例如客户端可自行判断返回值是否为空，null等，或者一些常见格式处理，利用客户端适当分担服务器压力。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、业务服务层&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、业务校验&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;例如传入订单号，经过数据库层查询，没有订单数据，这里称为业务性质的异常，代码本身没有问题，但是业务逻辑无法正常执行。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; InfoModel &lt;span&gt;detail&lt;/span&gt;&lt;span&gt;(Integer id)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    BaseInfo baseInfo = baseInfoDao.selectByPrimaryKey(id) ;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (baseInfo != &lt;span&gt;null&lt;/span&gt;){&lt;br/&gt;        DetailInfoEntity detailInfoEntity = detailInfoDao.getById(id);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (detailInfoEntity == &lt;span&gt;null&lt;/span&gt;){&lt;br/&gt;            LOG.info(&lt;span&gt;&quot;id=&quot;&lt;/span&gt;+id+&lt;span&gt;&quot;数据缺失 DetailInfo&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; buildModel(baseInfo,detailInfoEntity) ;&lt;br/&gt;    }&lt;br/&gt;    LOG.info(&lt;span&gt;&quot;id=&quot;&lt;/span&gt;+id+&lt;span&gt;&quot;数据完全缺失&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;2、组装业务逻辑&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通常情况下服务层作为逻辑做复杂的一块，用来拼接业务核心步骤，可以通过业务逻辑判定，一步一步执行程序，避免在程序入口做大量可能用到的对象创建和需求数据查询。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;(BaseInfo record)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    record.setCreateTime(&lt;span&gt;new&lt;/span&gt; Date());&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; insertFlag = baseInfoDao.insert(record);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (insertFlag &amp;gt; &lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;        DetailInfoEntity detailInfoEntity = &lt;span&gt;new&lt;/span&gt; DetailInfoEntity();&lt;br/&gt;        detailInfoEntity.setUserId(record.getId());&lt;br/&gt;        detailInfoEntity.setCreateTime(record.getCreateTime());&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(detailInfoDao.save(detailInfoEntity)){&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; insertFlag ;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; insertFlag;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;3、数据模型构建&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通常情况业务层是偏复杂的，如果想快速理解业务层，可以对复杂的业务方法，在提供一个返参构建的方法，用来处理服务层要向控制层回传的参数，这样可以让重度的服务层方法变的清晰。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; InfoModel &lt;span&gt;buildModel&lt;/span&gt; &lt;span&gt;(BaseInfo baseInfo,DetailInfoEntity detailInfo)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    InfoModel infoModel = &lt;span&gt;new&lt;/span&gt; InfoModel() ;&lt;br/&gt;    infoModel.setBaseInfo(baseInfo);&lt;br/&gt;    infoModel.setDetailInfoEntity(detailInfo);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; infoModel ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;&lt;span&gt;四、数据交互层&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、逆向工程&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;这里以使用mybatis框架或者mybatis-plus框架作为参考。如果是mybatis框架，建议逆向工程的模板代码不做自定义的修改，如果需要自定义方法，在mapper和xml层面再自定义一个扩展文件，用来存放自定义的方法和SQL逻辑，这样避免表结构变动大引发的强烈不适。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6972477064220184&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDMX1ZqiaQLKPukndEhjpicD17qnGMRIUsriaibhwibbIvR44L8r3bz2uaEZNNB3CBhf6LLZMaia8zwtMVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;872&quot;/&gt;&lt;/p&gt;&lt;p&gt;当然现在大部分都会mybatis-plus作为持久层组件，可以避免上述问题。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、数据交互&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;针对业务层的需要，提供相应的数据查询方法，只处理与数据库交互的逻辑，避免出现业务逻辑，尤其在分布式架构下，不同服务的数据查询和组装，不应该出现在该层。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;BaseInfoDao&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt;&lt;span&gt;(BaseInfo record)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;List&amp;lt;BaseInfo&amp;gt; &lt;span&gt;selectByExample&lt;/span&gt;&lt;span&gt;(BaseInfoExample example)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;updateByPrimaryKey&lt;/span&gt;&lt;span&gt;(BaseInfo record)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;BaseInfo &lt;span&gt;selectByPrimaryKey&lt;/span&gt;&lt;span&gt;(Integer id)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;deleteByPrimaryKey&lt;/span&gt;&lt;span&gt;(Integer id)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;BaseInfo &lt;span&gt;getById&lt;/span&gt; &lt;span&gt;(Integer id)&lt;/span&gt; &lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;&lt;span&gt;五、源代码地址&lt;/span&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;GitHub·地址&lt;br/&gt;https:&lt;span&gt;//github.com/cicadasmile/data-manage-parent&lt;/span&gt;&lt;br/&gt;GitEE·地址&lt;br/&gt;https:&lt;span&gt;//gitee.com/cicadasmile/data-manage-parent&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3783359497645212&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCjMheLZtcM2iaVMBOpIUKR4CDRCG9FLT5K6NmGXvG7exrW0TSuDjnTKJQ5PDq8j8Y7PHDd17Z3gicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d79dbef21efd42ba4008b1d9b39155a4</guid>
<title>Grails Oauth2 插件适配非标准 SSO 接口</title>
<link>https://toutiao.io/k/nzhai4f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-header&quot;&gt;
&lt;h1 class=&quot;title&quot;&gt;Grails Oauth2 插件适配非标准 SSO 接口&lt;/h1&gt;
&lt;p class=&quot;meta&quot;&gt;冯宇 Posted at — Nov 26, 2020
&lt;span class=&quot;meta&quot; id=&quot;busuanzi_container_page_pv&quot;&gt;阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;/&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;markdown&quot;&gt;

&lt;p&gt;最近遇到一个项目，需要跟某大厂的单点登录接口对接。然而该厂使用的并非行业通用的 OAuth2 接口，经过一番魔改之后，成功搞定了单点登录的对接。&lt;/p&gt;
&lt;h2 id=&quot;该厂单点登录的流程&quot;&gt;该厂单点登录的流程&lt;/h2&gt;
&lt;p&gt;该厂单点登录的流程大致如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;请求登录页面：&lt;code&gt;{ssoUrl}?returnUrl=http://localhost:8080/&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登录成功会给&lt;code&gt;returnUrl&lt;/code&gt;带回一个&lt;code&gt;token=xxYYzz&lt;/code&gt;的参数跳转回来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用这个&lt;code&gt;token&lt;/code&gt;参数配合&lt;code&gt;username:password&lt;/code&gt;(经过 base64 编码)认证请求用户信息接口获取用户信息:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;POST /{ssoUrl}/getUser?token=xxYYzz
Authorization Basic {secret}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然不是标准的单点登录流程(如 Oauth2 协议跳转回来的参数是&lt;code&gt;code&lt;/code&gt;而不是&lt;code&gt;token&lt;/code&gt;，需要用&lt;code&gt;code&lt;/code&gt;换取&lt;code&gt;access token&lt;/code&gt;，然后用&lt;code&gt;access token&lt;/code&gt;登录 SSO 系统获取用户信息)，但大体流程上还是大同小异的。因此可以通过稍加改造 Grails Oauth2 插件来对接到我们已经支持的 OAuth2 登录。&lt;/p&gt;
&lt;h2 id=&quot;实现非标准-oauth2-适配&quot;&gt;实现非标准 Oauth2 适配&lt;/h2&gt;
&lt;p&gt;Grails 的&lt;a href=&quot;http://pledbrook.github.io/grails-shiro-oauth/guide/introduction.html&quot;&gt;grails-shiro-oauth&lt;/a&gt;插件使用上还是比较简单的，插件已经实现了一个&lt;code&gt;OauthController&lt;/code&gt;，并且实现了&lt;code&gt;callback&lt;/code&gt;和&lt;code&gt;authenticate&lt;/code&gt;两个 action，默认注册了&lt;code&gt;/oauth/callback/$provider&lt;/code&gt;这个 URL 帮助自动处理 OAuth2 的回调，我们只需要实现目标 SSO 服务端的 API 以及成功的响应&lt;code&gt;onSuccess&lt;/code&gt; action 就可以了。&lt;/p&gt;
&lt;p&gt;大致的主要部分逻辑如下:&lt;/p&gt;
&lt;p&gt;Api 实现部分：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyApi&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;DefaultApi20&lt;/span&gt; {

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;ConfigObject&lt;/span&gt; &lt;span&gt;configObject&lt;/span&gt; = &lt;span&gt;Holders&lt;/span&gt;.&lt;span&gt;grailsApplication&lt;/span&gt;.&lt;span&gt;config&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;ssoUrl&lt;/span&gt; = &lt;span&gt;configObject&lt;/span&gt;.&lt;span&gt;oauth&lt;/span&gt;.&lt;span&gt;providers&lt;/span&gt;.&lt;span&gt;myApi&lt;/span&gt;.&lt;span&gt;ssoUrl&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;resourceUrl&lt;/span&gt; = &lt;span&gt;configObject&lt;/span&gt;.&lt;span&gt;oauth&lt;/span&gt;.&lt;span&gt;providers&lt;/span&gt;.&lt;span&gt;myApi&lt;/span&gt;.&lt;span&gt;resourceUrl&lt;/span&gt;

    &lt;span&gt;@Override&lt;/span&gt;
    &lt;span&gt;Verb&lt;/span&gt; &lt;span&gt;getAccessTokenVerb&lt;/span&gt;() {
        &lt;span&gt;Verb&lt;/span&gt;.&lt;span&gt;POST&lt;/span&gt;
    }

    &lt;span&gt;@Override&lt;/span&gt;
    &lt;span&gt;AccessTokenExtractor&lt;/span&gt; &lt;span&gt;getAccessTokenExtractor&lt;/span&gt;() {
        &lt;span&gt;new&lt;/span&gt; &lt;span&gt;JsonTokenExtractor&lt;/span&gt;()
    }

    &lt;span&gt;@Override&lt;/span&gt;
    &lt;span&gt;String&lt;/span&gt; &lt;span&gt;getAccessTokenEndpoint&lt;/span&gt;() {
        &lt;span&gt;resourceUrl&lt;/span&gt;
    }

    &lt;span&gt;@Override&lt;/span&gt;
    &lt;span&gt;String&lt;/span&gt; &lt;span&gt;getAuthorizationUrl&lt;/span&gt;(&lt;span&gt;OAuthConfig&lt;/span&gt; &lt;span&gt;config&lt;/span&gt;) {
        &lt;span&gt;Preconditions&lt;/span&gt;.&lt;span&gt;checkValidUrl&lt;/span&gt;(&lt;span&gt;config&lt;/span&gt;.&lt;span&gt;callback&lt;/span&gt;, &lt;span&gt;&quot;Must provide a valid url as callback. RootCloud does not support OOB&quot;&lt;/span&gt;)
        &lt;span&gt;String&lt;/span&gt;.&lt;span&gt;format&lt;/span&gt;(&lt;span&gt;ssoUrl&lt;/span&gt;, &lt;span&gt;OAuthEncoder&lt;/span&gt;.&lt;span&gt;encode&lt;/span&gt;(&lt;span&gt;config&lt;/span&gt;.&lt;span&gt;callback&lt;/span&gt;))
    }

    &lt;span&gt;@Override&lt;/span&gt;
    &lt;span&gt;OAuthService&lt;/span&gt; &lt;span&gt;createService&lt;/span&gt;(&lt;span&gt;OAuthConfig&lt;/span&gt; &lt;span&gt;config&lt;/span&gt;) {
        &lt;span&gt;new&lt;/span&gt; &lt;span&gt;MyApiOAuthService&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;config&lt;/span&gt;);
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;OAuthService 实现部分:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyApiOAuthService&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;OAuth20ServiceImpl&lt;/span&gt; {

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;DefaultApi20&lt;/span&gt; &lt;span&gt;api&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;OAuthConfig&lt;/span&gt; &lt;span&gt;config&lt;/span&gt;

    &lt;span&gt;MyApiOAuthService&lt;/span&gt;(&lt;span&gt;DefaultApi20&lt;/span&gt; &lt;span&gt;api&lt;/span&gt;, &lt;span&gt;OAuthConfig&lt;/span&gt; &lt;span&gt;config&lt;/span&gt;) {
        &lt;span&gt;super&lt;/span&gt;(&lt;span&gt;api&lt;/span&gt;, &lt;span&gt;config&lt;/span&gt;)
        &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;api&lt;/span&gt; = &lt;span&gt;api&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;config&lt;/span&gt; = &lt;span&gt;config&lt;/span&gt;
    }

    &lt;span&gt;@Override&lt;/span&gt;
    &lt;span&gt;Token&lt;/span&gt; &lt;span&gt;getAccessToken&lt;/span&gt;(&lt;span&gt;Token&lt;/span&gt; &lt;span&gt;requestToken&lt;/span&gt;, &lt;span&gt;Verifier&lt;/span&gt; &lt;span&gt;verifier&lt;/span&gt;) {
        &lt;span&gt;String&lt;/span&gt; &lt;span&gt;url&lt;/span&gt; = &lt;span&gt;api&lt;/span&gt;.&lt;span&gt;accessTokenEndpoint&lt;/span&gt; + &lt;span&gt;&quot;?token=${requestToken.token}&quot;&lt;/span&gt;
        &lt;span&gt;OAuthRequest&lt;/span&gt; &lt;span&gt;request&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;OAuthRequest&lt;/span&gt;(&lt;span&gt;api&lt;/span&gt;.&lt;span&gt;getAccessTokenVerb&lt;/span&gt;(), &lt;span&gt;url&lt;/span&gt;)
        &lt;span&gt;request&lt;/span&gt;.&lt;span&gt;addHeader&lt;/span&gt;(&lt;span&gt;&#x27;Authorization&#x27;&lt;/span&gt;, &lt;span&gt;&quot;Basic ${config.apiSecret}&quot;&lt;/span&gt;)
        &lt;span&gt;Response&lt;/span&gt; &lt;span&gt;response&lt;/span&gt; = &lt;span&gt;request&lt;/span&gt;.&lt;span&gt;send&lt;/span&gt;()
        &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Token&lt;/span&gt;(&lt;span&gt;response&lt;/span&gt;.&lt;span&gt;body&lt;/span&gt;, &lt;span&gt;config&lt;/span&gt;.&lt;span&gt;apiSecret&lt;/span&gt;)
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里有一些 hack 的部分，&lt;code&gt;getAccessToken&lt;/code&gt;按照 OAuth2 的流程应该是使用&lt;code&gt;code&lt;/code&gt;换取&lt;code&gt;access token&lt;/code&gt;的过程，但是被我们调整成了直接用&lt;code&gt;token&lt;/code&gt;请求用户信息，将响应封装进入了&lt;code&gt;Token&lt;/code&gt;类，交由&lt;code&gt;onSuccess&lt;/code&gt; action 进行解析。&lt;/p&gt;
&lt;p&gt;由于 grails shiro oauth 插件只认&lt;code&gt;code&lt;/code&gt;参数，不认非标准的&lt;code&gt;token&lt;/code&gt;参数，因此我们需要在 filter 中做一下参数转换，以便对接插件。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;OauthCallbackFilters&lt;/span&gt; {

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;filters&lt;/span&gt; = {
        &lt;span&gt;fillInCodeParam&lt;/span&gt;(&lt;span&gt;controller:&lt;/span&gt; &lt;span&gt;&#x27;oauth&#x27;&lt;/span&gt;, &lt;span&gt;action:&lt;/span&gt; &lt;span&gt;&#x27;callback&#x27;&lt;/span&gt;) {
            &lt;span&gt;before&lt;/span&gt; = {
                &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;params&lt;/span&gt;.&lt;span&gt;token&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;params&lt;/span&gt;.&lt;span&gt;code&lt;/span&gt;) {
                    &lt;span&gt;params&lt;/span&gt;.&lt;span&gt;put&lt;/span&gt;(&lt;span&gt;&#x27;code&#x27;&lt;/span&gt;, &lt;span&gt;params&lt;/span&gt;.&lt;span&gt;token&lt;/span&gt;)
                }
            }
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后在 onSuccess action 的逻辑中变通一下，直接按照 JSON 格式解析&lt;code&gt;Token&lt;/code&gt;就完事了:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ShiroOAuthController&lt;/span&gt; {

    &lt;span&gt;GrailsApplication&lt;/span&gt; &lt;span&gt;grailsApplication&lt;/span&gt;
    &lt;span&gt;OauthService&lt;/span&gt; &lt;span&gt;oauthService&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;onSuccess&lt;/span&gt;() {
        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;params&lt;/span&gt;.&lt;span&gt;provider&lt;/span&gt;) {
            &lt;span&gt;renderError&lt;/span&gt; &lt;span&gt;400&lt;/span&gt;, &lt;span&gt;&quot;The Shiro OAuth callback URL must include the &#x27;provider&#x27; URL parameter.&quot;&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;
        }
        &lt;span&gt;Map&lt;/span&gt; &lt;span&gt;providerConfig&lt;/span&gt; = &lt;span&gt;grailsApplication&lt;/span&gt;.&lt;span&gt;config&lt;/span&gt;.&lt;span&gt;oauth&lt;/span&gt;.&lt;span&gt;providers&lt;/span&gt;[&lt;span&gt;params&lt;/span&gt;.&lt;span&gt;provider&lt;/span&gt;]
        &lt;span&gt;String&lt;/span&gt; &lt;span&gt;sessionKey&lt;/span&gt; = &lt;span&gt;oauthService&lt;/span&gt;.&lt;span&gt;findSessionKeyForAccessToken&lt;/span&gt;(&lt;span&gt;params&lt;/span&gt;.&lt;span&gt;provider&lt;/span&gt;)
        &lt;span&gt;Token&lt;/span&gt; &lt;span&gt;accessToken&lt;/span&gt; = &lt;span&gt;session&lt;/span&gt;[&lt;span&gt;sessionKey&lt;/span&gt;]
        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;accessToken&lt;/span&gt;) {
            &lt;span&gt;renderError&lt;/span&gt; &lt;span&gt;500&lt;/span&gt;, &lt;span&gt;&quot;No OAuth token in the session for provider &#x27;${params.provider}&#x27;!&quot;&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;
        }

        &lt;span&gt;// Create the relevant authentication token and attempt to log in.
&lt;/span&gt;&lt;span/&gt;        &lt;span&gt;def&lt;/span&gt; &lt;span&gt;oauthUserInfo&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;params&lt;/span&gt;.&lt;span&gt;provider&lt;/span&gt; == &lt;span&gt;&#x27;myapi&#x27;&lt;/span&gt;) {
            &lt;span&gt;oauthUserInfo&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;JSONObject&lt;/span&gt;(&lt;span&gt;accessToken&lt;/span&gt;.&lt;span&gt;token&lt;/span&gt;)
        } &lt;span&gt;else&lt;/span&gt; {
            &lt;span&gt;Response&lt;/span&gt; &lt;span&gt;response&lt;/span&gt; = &lt;span&gt;oauthService&lt;/span&gt;.&lt;span&gt;&quot;get${params.provider}Resource&quot;&lt;/span&gt;(&lt;span&gt;accessToken&lt;/span&gt;, &lt;span&gt;providerConfig&lt;/span&gt;.&lt;span&gt;resourceUrl&lt;/span&gt;)
            &lt;span&gt;log&lt;/span&gt;.&lt;span&gt;debug&lt;/span&gt;(&lt;span&gt;&quot;OAuth resource response for ${params.provider}: ${response.body}&quot;&lt;/span&gt;)
            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;response&lt;/span&gt;.&lt;span&gt;body&lt;/span&gt; =~ &lt;span&gt;/\{.*}/&lt;/span&gt;) {
                &lt;span&gt;oauthUserInfo&lt;/span&gt; = &lt;span&gt;JSON&lt;/span&gt;.&lt;span&gt;parse&lt;/span&gt;(&lt;span&gt;response&lt;/span&gt;.&lt;span&gt;body&lt;/span&gt;)
            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;response&lt;/span&gt;.&lt;span&gt;body&lt;/span&gt; =~ &lt;span&gt;/&amp;lt;.*&amp;gt;/&lt;/span&gt;) {
                &lt;span&gt;oauthUserInfo&lt;/span&gt; = &lt;span&gt;XML&lt;/span&gt;.&lt;span&gt;parse&lt;/span&gt;(&lt;span&gt;response&lt;/span&gt;.&lt;span&gt;body&lt;/span&gt;)
            } &lt;span&gt;else&lt;/span&gt; {
                &lt;span&gt;oauthUserInfo&lt;/span&gt; = &lt;span&gt;request&lt;/span&gt;.&lt;span&gt;getParameterMap&lt;/span&gt;()
            }
        }
        &lt;span&gt;//...
&lt;/span&gt;&lt;span/&gt;    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样通过小幅度变通就可以适配非标准的 OAuth2 流程了。&lt;/p&gt;


&lt;/div&gt;

&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e630986e4b005575c5f2d0b2631f7e64</guid>
<title>做架构也得讲武德</title>
<link>https://toutiao.io/k/otq0aqr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;这里是Z哥的个人公众号&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;每周五11：45 按时送达&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;当然了，也会时不时加个餐～&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;我的第「169」篇原创敬上&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;大家好，我是Z哥。今天分享一篇对「架构」这件事的随想。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我想，做「架构」是每个热爱技术的技术人在不断追求想进入的领域。但是很多人可能工作了很多年也没能真正参与到做架构这件事上。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，很多人对做架构这件事的感知停留在网上很多大牛分享的文章里。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是，如果你只是看网上的文章其实对架构的理解会非常容易跑偏的，主要原因有两点。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第一点，世界是在不断发展和迭代的。技术也是人类文明的一部分，所以自然也会随着时间的推移不断进化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而很多讲架构的文章喜欢和新技术挂上钩，一个没用到新技术的“架构”，会让很多人觉得有点out，缺乏吸引力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是新技术的推出，要么是用来解决过去无法解决的问题，要么是可以提高当前解决问题的效率。正如当前的你在20年前做程序员，基于当时的编程环境，开发效率肯定不如现在，这是毋庸置疑的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;也正因为如此，每一项新技术的出现，背后必然对应着一个典型的问题场景。能最大化发挥这项新技术价值的地方也应该是这个场景。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果我们仅仅停留在这项新技术本身去考虑它有什么用，那么就很容易就会陷入到“拿着锤子找钉子”的情况里。特别是出于对「架构」的崇拜，“我怎么才能用上这个技术”会成为脑海中第一重要的目标。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第二点，不管是创造新技术的人还是分享新技术使用经验的人，对他们来说肯定得对外展示新技术好的一面。如果写不好的一面，这不是拆自己台么，或者担心表现出自己不会用、丢脸么。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你有心的话，当你在网上搜某个技术的相关资料的时候其实很容易观察到这个现象，讲优点的文章比讲缺点、讲遇到什么坑的文章多得多。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这会造成的影响就是过度拉高“旁观者”对新技术的预期，认为它是很牛逼的，能解决很多问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么正确对待「架构」的态度应该是什么呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我根据我自己做架构5年踩坑的经验总结了以下3点。希望能帮助你少踩甚至是避开我踩过的坑。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;/01  回到现实的问题中/&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;任何技术应该都只是解决问题的可选项之一，并没有所谓的唯一选择。只有你回到的现实中，从实际的问题出发去考虑，你才能规避掉你对某项技术所带的偏见。（当然，提前是你还得对每项技术有基本的了解）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如，之前我团队里有个小伙伴觉得Saga模式非常酷，他认为用它来实现数据的写操作又快又准，还能大大降低资源竞争问题，是所有项目应该考虑的第一选择。于是，他在一个新项目中用上了。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是，最终系统上线后，页面操作的响应的确挺快，但是由于数据的滞后产生了一系列问题，让系统使用者苦不堪言。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;/02  大多数时候，「减」都比「加」好/&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我问你两个词语，你知道「简单」和「容易」的区别吗？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在我看来它们有很大的区别，我的理解是，「简单」是形容事物的，「容易」是描述做一件事的过程。所以，我们做架构这件事，要追求的是「简单」而不是「容易」。虽然很多时候「容易」会让你用的时候觉得很「简单」，但那不是真的简单，最多算得上是局部的“简单”。（这段话有点绕，细品一下应该还是很容易理解的）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，想要架构变得「简单」，自然是做减法比做加法好。但是现实中，往往相反，更多人乐忠于增加什么新技术，引入什么新技术。毕竟做加法有可能不用考虑“历史问题”，而要做减法不得不考虑“历史问题”，很明显前者更「容易」。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;/03  时刻保持风险意识/&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;大多数情况下，后续暴露出风险的地方大多数是一些非功能性的点。比如，数据经常出错，访问量一大数据同步就延迟的厉害，甚至宕机。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这些点说起来简单，但是需要考虑的细节非常多。类似于「木桶原理」，只要你的整体架构中有一块短板拖了后腿，大大小小的问题就会接踵而来。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;更加麻烦的是，这些问题还不容易解决，甚至需要做大量的推倒重新设计才能解决。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;虽然说，不管怎么样依旧无法100%规避风险，但是时刻带着风险意识问自己：“这里这样设计可能会有什么问题？”必然会大大降低风险系数。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外，对待已经察觉到的潜在风险绝对不能草率，认为未来不一定会发生，先将就着。规模越大的系统，越符合墨菲定律所提到规律——“凡是可能出错的事有很大几率会出错”，而且时间会大大提前。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;暂时就想到这么多，这个话题其实很大，后续有新的思考再分享给大家一起讨论。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;好了，总结一下。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这篇呢，Z哥和你分享了我对架构这件事的随想。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先，对待一个陌生的技术，预期不能过于乐观。因为以下两点会潜移默化地让你产生偏见。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对自己不了解的技术的崇拜感。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;你能查到的对外分享讲优点的远大于讲缺点和坑的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对待架构这件事我给出的3个建议是：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;回到现实的问题中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;大多数时候，「减」都比「加」好。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;时刻保持风险意识。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;希望对你有所启发。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;架构是“平衡”的艺术，祝你早日找到你的“平衡感”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;推荐阅读：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原创不易，如果你觉得这篇文章还不错，就「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」或者「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;分享&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」一下吧。鼓励我的创作 ：）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.4428822495606327&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/oB5bd6W6hI1Xrkr3iaFRP5fErfmjHqlBw160icnia8yicWBlicnPEfqGE80alzGl9FLj6FxyuibIuliceoH9zicibj95loQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1138&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你有关于软件架构、分布式系统、产品、运营的困惑&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以试试点击「&lt;strong&gt;阅读原文&lt;/strong&gt;」&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a807ad856a67c676205386c355a03345</guid>
<title>Java 字符串 String 那些事</title>
<link>https://toutiao.io/k/nslm9x5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;引言&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知在java里面除了&lt;code&gt;8&lt;/code&gt;种基本数据类型的话，还有一种特殊的类型String，这个类型是我们每天搬砖都基本上要使用它。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;String 类型可能是 Java 中应用最频繁的引用类型，但它的性能问题却常常被忽略。高效的使用字符串，可以提升系统的整体性能。当然，要做到高效使用字符串，需要深入了解其特性。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;String类&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看下String类的源码:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;String&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;.&lt;span&gt;io&lt;/span&gt;.&lt;span&gt;Serializable&lt;/span&gt;, &lt;span&gt;Comparable&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt;, &lt;span&gt;CharSequence&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/** The value is used for character storage. */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; value[];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从源码上我们是不是可以发现&lt;code&gt;String&lt;/code&gt;类是被&lt;code&gt;final&lt;/code&gt;关键字所修饰的，&lt;code&gt;String&lt;/code&gt;类的数据是通过&lt;code&gt;char[]&lt;/code&gt; 数组来存储的。数组也是被&lt;code&gt;final&lt;/code&gt;修饰的所以&lt;code&gt;String&lt;/code&gt; 对象是不可被更改的。接下来我们再看看String的一些方法：像concat、replace、substring等都是返回了一个新的&lt;code&gt;new String&lt;/code&gt;感兴趣的可以去看看String的一些常见方法。当我们执行这些方法之后最原始的字符串是没有改变的，都是返回新的字符串。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String str = &lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;java金融&quot;&lt;/span&gt;);&lt;br/&gt;        String str1 = str.substring(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;);&lt;br/&gt;        String str2 = str.concat(&lt;span&gt;&quot;公众号&quot;&lt;/span&gt;);&lt;br/&gt;        String str3 = str.replace(&lt;span&gt;&quot;java金融&quot;&lt;/span&gt;, &lt;span&gt;&quot;关注:【java金融】&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 还有其他的方法&lt;/span&gt;&lt;br/&gt;        System.out.println(str1);&lt;br/&gt;        System.out.println(str2);&lt;br/&gt;        System.out.println(str3);&lt;br/&gt;        System.out.println(str);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java&lt;br/&gt;java金融公众号&lt;br/&gt;关注:【java金融】&lt;br/&gt;java金融&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们只要记住一点：“&lt;code&gt;String&lt;/code&gt;对象一旦被创建就是固定不变的了，
对&lt;code&gt;String&lt;/code&gt;对象的任何改变都不影响到原对象，相关的任何&lt;code&gt;change&lt;/code&gt;操作都会生成新的对象”。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;字符串常量池&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;JVM&lt;/code&gt;中，为了减少字符串对象的重复创建，维护了一块特殊的内存空间，这块内存就被称为全局字符串常量池（&lt;code&gt;string pool&lt;/code&gt;也有叫做&lt;code&gt;string literal pool&lt;/code&gt;）。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;字符串常量池的位置&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字符串常量池所在的位置也是跟不同的&lt;code&gt;jdk&lt;/code&gt;版本有关系的。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在&lt;code&gt;JDK6&lt;/code&gt;及之前字符串常量池存放在方法区, 此时&lt;code&gt;hotspot&lt;/code&gt;虚拟机对方法区的实现为永久代。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在&lt;code&gt;JDK7&lt;/code&gt;字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是&lt;code&gt;hotspot&lt;/code&gt;中的永久代。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在&lt;code&gt;JDK8 hotspot&lt;/code&gt;移除了永久代用元空间(&lt;code&gt;Metaspace&lt;/code&gt;)取而代之, 这时候字符串常量池还在堆里只不过把方法区的实现从永久代变成了元空间(&lt;code&gt;Metaspace&lt;/code&gt;) 。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;String# intern&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;String::intern()是一个本地方法，它的作用是如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象的引用；否则，会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述定义出自《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》我们知道了这个 &lt;code&gt;String::intern()&lt;/code&gt;这个方法的作用下面来看几道并没有什么用的题目看看你是否都能够回答对？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;        String str2 = &lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;java&quot;&lt;/span&gt;) + &lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;金融&quot;&lt;/span&gt;); &lt;span&gt;// 1&lt;/span&gt;&lt;br/&gt;         str2.intern(); &lt;span&gt;// 2&lt;/span&gt;&lt;br/&gt;         String str1 = &lt;span&gt;&quot;java金融&quot;&lt;/span&gt;; &lt;span&gt;// 3&lt;/span&gt;&lt;br/&gt;         System.out.println(str2 == str1);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个代码在&lt;code&gt;JDK6&lt;/code&gt;中输出结果是&lt;code&gt;false&lt;/code&gt;，在&lt;code&gt;jdk7&lt;/code&gt;输出是&lt;code&gt;true&lt;/code&gt;。为何会因为不同的&lt;code&gt;jdk&lt;/code&gt;版本输出结果不一样，因为不同版本字符串常量池的位置发生了变化。下面来分析下为何会产生这种差异。字符串虽然不属于基本数据类型但是它也可以想基本类型一样，直接通过字面量来赋值，同时也是可以通过&lt;code&gt;new&lt;/code&gt; 来生成字符串对象。通过字面量赋值的方式和&lt;code&gt;new&lt;/code&gt; 的方式 生成字符串还是有区别的。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;字面量赋值：通过字面量赋值（使用双引号声明出来的&lt;code&gt;String&lt;/code&gt;）会先去常量池中查找是否已经有相同的字符串，如果已经存在栈中的引用直接指向该字符串，如果不存在就在常量中生成一个字符串再将栈中的引用指向该字符串。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;new&lt;/code&gt; 的方式创建：而通过&lt;code&gt;new&lt;/code&gt;的方式创建字符串时，就直接在堆中生成一个字符串的对象栈中的引用指向该对象。对于堆中的字符串对象，可以通过 &lt;code&gt;intern&lt;/code&gt;() 方法来将字符串添加的常量池中，并返回指向该常量的引用。&lt;code&gt;jdk6&lt;/code&gt; 结果是&lt;code&gt;false&lt;/code&gt;，是因为常量池是在永久代的Perm区和java堆是两个区域。所以两个区域的对象地址比较是不同的。&lt;code&gt;JDK7&lt;/code&gt;结果是&lt;code&gt;true&lt;/code&gt;， 这个原因主要是从&lt;code&gt;JDK 7&lt;/code&gt;及以后，&lt;code&gt;HotSpot&lt;/code&gt; 将常量池从永久代移到了堆，正因为如此，&lt;code&gt;JDK7&lt;/code&gt; 及以后的&lt;code&gt;intern&lt;/code&gt;方法在实现上发生了比较大的改变，&lt;code&gt;JDK7及以&lt;/code&gt;后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于如果在常量池找不到对应的字符串则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。所以为什么返回true 是因为执行完标号为1的时候常量池中没有&quot;&lt;strong&gt;「java金融」&lt;/strong&gt;&quot;对象的，接下来标号为2的时候 会在常量池生成一个“&lt;strong&gt;「java金融」&lt;/strong&gt;”的对象会直接存一个对堆中“&lt;strong&gt;「java金融」&lt;/strong&gt;”的引用，标号为3：进行字面量赋值的时候常量池已经存在了所以直接返回该引用。所以都是指向堆中的字符串返回true&lt;code&gt;。&lt;/code&gt;&lt;strong&gt;「如果把3行代码放到第一行上面结果又不一样了，感兴趣的可以动手试一试并且分析下原因哦。」&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;string 常见性能优化&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;使用+号拼接字符串&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字符串拼接是我们平时在代码中使用最频繁的了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;   String str = &lt;span&gt;&quot;关注&quot;&lt;/span&gt;+&lt;span&gt;&quot;公众号:&quot;&lt;/span&gt;+&lt;span&gt;&quot;java金融&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过反编译查看下上述代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(java.lang.String[])&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    descriptor: ([Ljava/lang/String;)V&lt;br/&gt;    flags: ACC_PUBLIC, ACC_STATIC&lt;br/&gt;    Code:&lt;br/&gt;      stack=&lt;span&gt;1&lt;/span&gt;, locals=&lt;span&gt;2&lt;/span&gt;, args_size=&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;0&lt;/span&gt;: ldc           #&lt;span&gt;2&lt;/span&gt;                  &lt;span&gt;// String 关注公众号:java金融&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;2&lt;/span&gt;: astore_1&lt;br/&gt;         &lt;span&gt;3&lt;/span&gt;: &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;      LineNumberTable:&lt;br/&gt;        line &lt;span&gt;11&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;        line &lt;span&gt;12&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以发现编译器直接帮我们优化了，直接生成了一个字符串“关注公众号:java金融” 并没有生成中间变量的&lt;code&gt;String&lt;/code&gt;实例。如果我们上述代码稍微变化下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String str =&lt;span&gt;&quot;关注&quot;&lt;/span&gt;;&lt;br/&gt;        String str1 = str + &lt;span&gt;&quot;公众号:java金融&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt; stack=&lt;span&gt;2&lt;/span&gt;, locals=&lt;span&gt;3&lt;/span&gt;, args_size=&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;0&lt;/span&gt;: ldc           #&lt;span&gt;2&lt;/span&gt;                  &lt;span&gt;// String 关注&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;2&lt;/span&gt;: astore_1&lt;br/&gt;         &lt;span&gt;3&lt;/span&gt;: &lt;span&gt;new&lt;/span&gt;           #&lt;span&gt;3&lt;/span&gt;                  &lt;span&gt;// class java/lang/StringBuilder&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;6&lt;/span&gt;: dup&lt;br/&gt;         &lt;span&gt;7&lt;/span&gt;: invokespecial #&lt;span&gt;4&lt;/span&gt;                  &lt;span&gt;// Method java/lang/StringBuilder.&quot;&amp;lt;init&amp;gt;&quot;:()V&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;10&lt;/span&gt;: aload_1&lt;br/&gt;        &lt;span&gt;11&lt;/span&gt;: invokevirtual #&lt;span&gt;5&lt;/span&gt;                  &lt;span&gt;// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;14&lt;/span&gt;: ldc           #&lt;span&gt;6&lt;/span&gt;                  &lt;span&gt;// String 公众号:java金融&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;16&lt;/span&gt;: invokevirtual #&lt;span&gt;5&lt;/span&gt;                  &lt;span&gt;// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;19&lt;/span&gt;: invokevirtual #&lt;span&gt;7&lt;/span&gt;                  &lt;span&gt;// Method java/lang/StringBuilder.toString:()Ljava/lang/String;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;22&lt;/span&gt;: astore_2&lt;br/&gt;        &lt;span&gt;23&lt;/span&gt;: &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;      LineNumberTable:&lt;br/&gt;        line &lt;span&gt;11&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;        line &lt;span&gt;12&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;        line &lt;span&gt;13&lt;/span&gt;: &lt;span&gt;23&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从反编译代码中我们会发现生成了&lt;code&gt;StringBuilder&lt;/code&gt;对象来进行追加。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;所以&lt;code&gt;String&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; 拼接变量的时候底层是通过&lt;code&gt;StringBuilder&lt;/code&gt;来实现的，我们循环操作拼接字符串的时候也应当使用&lt;code&gt;StringBuilder&lt;/code&gt;替代+，否则的话每一次循环都会创建
一个&lt;code&gt;StringBuilder&lt;/code&gt; 对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于静态字符串的拼接操作，Java在编译时会进行彻底的优化，会把多个拼接字符串在编译时合成一个单独的长字符串。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;常见字符串经典面试题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于字符串最常见的面试题，面试宝典常见的题目。&lt;strong&gt;「String s = new String(&quot;xyz&quot;)」&lt;/strong&gt; 创建了多少个实例？一般的回答都会是2个，(一个是“xyz”,一个是指向“xyz”的引用对象s)
答案并没有那么简单哦，可以看看大佬的回答还是非常精彩的。连接地址https://www.iteye.com/blog/rednaxelafx-774673（文末第一个参考地址）&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;结束&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;由于自己才疏学浅，难免会有纰漏，假如你发现了错误的地方，还望留言给我指出来,我会对其加以修正。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果你觉得文章还不错，你的转发、分享、赞赏、点赞、留言就是对我最大的鼓励。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;感谢您的阅读,十分欢迎并感谢您的关注。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3649122807017544&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qu3ItokgsApW7AbPSO6cAke5IVGZ6EvYkK0avyt5adIUDqpXledxY5ibRuIwSicmeuSSInQp9k2cySdukILWPomg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1710&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://www.iteye.com/blog/rednaxelafx-774673
https://www.zhihu.com/question/36908414/answer/69724311
https://www.cnblogs.com/paddix/p/5326863.html
https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>