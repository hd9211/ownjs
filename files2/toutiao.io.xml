<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>2ee39ce857145be62bcf3fc62091d2bf</guid>
<title>乒乓球自练网红神器，缓解程序员视力疲劳，全家都适用！</title>
<link>https://toutiao.io/k/six5ocz</link>
<content:encoded>&lt;div&gt;&lt;body id=&quot;readabilityBody&quot;&gt;


&lt;/body&gt;
&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9c6f3d43542a47c7d26aee5cff94c5e0</guid>
<title>[推荐] 偷天换日，用 JavaAgent 欺骗你的 JVM</title>
<link>https://toutiao.io/k/cah22k5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Java Agent 出现在 JDK1.5 版本以后，它允许程序员利用 &lt;span&gt;Agent &lt;/span&gt;技术构建一个独立于应用程序的代理程序。用途也非常广泛，可以协助监测、运行、甚至替换其他 JVM 上的程序。先从下面这张图直观的看一下它都被应用在哪些场景：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5509433962264151&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9MCsN27dESvlrlywMqh18mzu7AiaQ2jjyF1TlyibbqgK9rW2mcSUBFjPlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;530&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;看到这里你是不是也很好奇，究竟是什么神仙技术，能够应用在这么多场景下，那今天我们就来挖掘一下，看看神奇的 Java Agent 是如何工作在底层，默默支撑了这么多优秀的应用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;回到文章开头的类比，我们还是用和 AOP 比较的方式，来先对Java Agent 有一个大致的了解：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;作用级别&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;span&gt;AO&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt; &lt;/span&gt;运行于应用程序内的方法级别，而 &lt;span&gt;Agent &lt;/span&gt;能够作用于虚拟机级别&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;组成部分&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;span&gt;AO&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt; &lt;/span&gt;的实现需要目标方法和逻辑增强部分的方法，而 Java Agent 要生效需要两个工程，一个是 &lt;span&gt;Agent &lt;/span&gt;代理，另一个是需要被代理的主程序；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;执行场合&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;span&gt;AO&lt;/span&gt;&lt;span&gt;P &lt;/span&gt;可以运行在切面的前后或环绕等场合，而 Java Agent 的执行只有两种方式，JDK1.5 提供的 preMain 模式在主程序运行前执行，&lt;span&gt;JDK&lt;/span&gt;&lt;span&gt;1.6 &lt;/span&gt;提供的 agentMain 在主程序运行后执行。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面我们就分别看一下在两种模式下，如何动手实现一个 &lt;span&gt;Agent &lt;/span&gt;代理程序。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Premain 模式&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Premain 模式允许在主程序执行前执行一个 &lt;span&gt;Agent &lt;/span&gt;代理，实现起来非常简单，下面我们分别实现两个组成部分。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;Agent&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;先写一个简单的功能，在主程序执行前打印一句话，并打印传递给代理的参数：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MyPreMainAgent&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;premain&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String agentArgs, Instrumentation inst&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;premain start&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;args:&quot;&lt;/span&gt;+agentArgs);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在写完了 &lt;span&gt;Agent &lt;/span&gt;的逻辑后，需要把它打包成 jar 文件。这里我们直接使用 maven 插件打包的方式，在打包前进行一些配置。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;maven-jar-plugin&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;3.1.0&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;archive&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;manifest&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;addClasspath&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;addClasspath&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;manifest&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;manifestEntries&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;Premain-Class&lt;/span&gt;&amp;gt;&lt;/span&gt;com.cn.agent.MyPreMainAgent&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;Premain-Class&lt;/span&gt;&amp;gt;&lt;/span&gt;                            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;Can-Redefine-Classes&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;Can-Redefine-Classes&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;Can-Retransform-Classes&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;Can-Retransform-Classes&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;Can-Set-Native-Method-Prefix&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;Can-Set-Native-Method-Prefix&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;manifestEntries&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;archive&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;配置的打包参数中，通过 manifestEntries 的方式添加属性到 MANIFEST.MF 文件中，解释一下里面的几个参数：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Premain-Class&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：包含 premain 方法的类，需要配置为类的全路径；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Can-Redefine-Classes&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：为 true 时表示能够重新定义 class；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Can-Retransform-Classes&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：为 true 时表示能够重新转换 class，实现字节码替换；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Can-Set-Native-Method-Prefix&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：为 true 时表示能够设置 native 方法的前缀。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其中 Premain-Class 为必须配置，其余几项是非必须选项，默认情况下都为 false。通常也建议加入，这几个功能我们会在后面具体介绍。在配置完成后，使用 mvn 命令打包：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;mvn clean &lt;span class=&quot;code-snippet__keyword&quot;&gt;package&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;打包完成后生成 myAgent-1.0.jar 文件，我们可以解压 jar 文件，看一下生成的 MANIFEST.MF 文件：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4099009900990099&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9Mla3YlKFBFBSnplLPv5iaNkht3j9cPH1oYgpYGI95fd1gpqFZIVJicI6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;505&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以看到，添加的属性已经被加入到了文件中。到这里，&lt;span&gt;Agent &lt;/span&gt;代理部分就完成了，因为代理不能够直接运行，需要附着于其他程序，所以下面新建一个工程来实现主程序。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;主程序&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在主程序的工程中，只需要一个能够执行的 main 方法的入口就可以了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;AgentTest&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String[] args&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;main project start&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在主程序完成后，要考虑的就是应该如何将主程序与 &lt;span&gt;Agent &lt;/span&gt;工程连接起来。这里可以通过 -javaagent 参数来指定运行的代理，命令格式如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;java&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-javaagent&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:myAgent.jar&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-jar&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;AgentTest&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.jar&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;并且，可以指定的代理数量是没有限制的。会根据指定的顺序先后依次执行各个代理，如果要同时运行两个代理，就可以按照下面的命令执行：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;java&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-javaagent&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:myAgent1.jar&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-javaagent&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:myAgent2.jar&lt;/span&gt;  &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-jar&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;AgentTest&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.jar&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以我们在 IDEA 中执行程序为例，在 VM options 中加入添加启动参数：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;diff&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__deletion&quot;&gt;-javaagent:F:\Workspace\MyAgent\target\myAgent-1.0.jar=Hydra&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__deletion&quot;&gt;-javaagent:F:\Workspace\MyAgent\target\myAgent-1.0.jar=Trunks&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;执行 main 方法，查看输出结果：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42237061769616024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9MLiaCzLZPe73l3jYtXt8nnmYgQ5gcic1Nx02XCEWicm89iaM9Rd9nBtCZvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;599&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;根据执行结果的打印语句可以看出，在执行主程序前，依次执行了两次我们的 &lt;span&gt;Agent &lt;/span&gt;代理。可以通过下面的图来表示执行代理与主程序的执行顺序。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6906354515050167&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9MmeEibAx9Zk3hiaYWfZMBvOgb84Lc8ItWgRf5goFc8H6NSdfZzXZeEEzA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;598&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;缺陷&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在提供便利的同时，premain 模式也有一些缺陷，例如如果 &lt;span&gt;Agent&lt;/span&gt; 在运行过程中出现异常，那么也会导致主程序的启动失败。我们对上面例子中 &lt;span&gt;Agent &lt;/span&gt;的代码进行一下改造，手动抛出一个异常。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;premain&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String agentArgs, Instrumentation inst&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;premain start&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;args:&quot;&lt;/span&gt;+agentArgs);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;error&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;再次运行主程序：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3743743743743744&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9M3ookJCtnkTeN8vjcE4vsickPW8BHofCicy2ulZ9ygQWfnfF0o8xuvXVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;999&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以看到，在 &lt;span&gt;Agent &lt;/span&gt;抛出异常后主程序也没有启动。针对 premain 模式的一些缺陷，在 JDK1.6 之后引入了 agentmain 模式。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Agentmain 模式&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;agentmain 模式可以说是 premain 的升级版本，它允许代理的目标主程序的 JVM 先行启动，再通过 attach 机制连接两个 JVM，下面我们分三个部分实现。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;agent&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;agent 部分和上面一样，实现简单的打印功能：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MyAgentMain&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;agentmain&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String agentArgs, Instrumentation instrumentation&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;agent main start&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;args:&quot;&lt;/span&gt;+agentArgs);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;修改 maven 插件配置，指定 Agent-Class：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;maven-jar-plugin&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;3.1.0&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;archive&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;manifest&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;addClasspath&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;addClasspath&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;manifest&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;manifestEntries&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;Agent-Class&lt;/span&gt;&amp;gt;&lt;/span&gt;com.cn.agent.MyAgentMain&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;Agent-Class&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;Can-Redefine-Classes&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;Can-Redefine-Classes&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;Can-Retransform-Classes&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;Can-Retransform-Classes&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;manifestEntries&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;archive&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;主程序&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里我们直接启动主程序等待代理被载入，在主程序中使用了 System.in 进行阻塞，防止主进程提前结束。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;AgentmainTest&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String[] args&lt;/span&gt;) throws IOException&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt;.read();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;attach 机制&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;和 premain 模式不同，我们不能再通过添加启动参数的方式来连接 &lt;span&gt;Agent&lt;/span&gt; 和主程序了，这里需要借助 com.sun.tools.attach 包下的 VirtualMachine 工具类。需要注意该类不是 JVM 标准规范，是由 Sun 公司自己实现的，使用前需要引入依赖：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.sun&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;tools&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;system&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;systemPath&lt;/span&gt;&amp;gt;&lt;/span&gt;${JAVA_HOME}\lib\tools.jar&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;systemPath&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;VirtualMachine 代表了一个要被附着的 Java 虚拟机，也就是程序中需要监控的目标虚拟机。外部进程可以使用 VirtualMachine 的实例将 agent 加载到目标虚拟机中。先看一下它的静态方法 attach：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; VirtualMachine &lt;span class=&quot;code-snippet__title&quot;&gt;attach&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String var0&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过 attach 方法可以获取一个 JVM 的对象实例，这里传入的参数是目标虚拟机运行时的进程号 pid。也就是说，我们在使用 attach 前，需要先获取刚才启动的主程序的 pid，使用 jps 命令查看线程 pid：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;11140&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;16372&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;RemoteMavenServer36&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;16392&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;AgentmainTest&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;20204&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;Jps&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;2460&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;Launcher&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;获取到主程序 AgentmainTest 运行时 pid 是 16392，将它应用于虚拟机的连接。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;AttachTest&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String[] args&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            VirtualMachine  vm= VirtualMachine.attach(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;16392&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            vm.loadAgent(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;F:\\Workspace\\MyAgent\\target\\myAgent-1.0.jar&quot;&lt;/span&gt;,&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;param&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            e.printStackTrace();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在获取到 VirtualMachine 实例后，就可以通过 loadAgent 方法可以实现注入 agent 代理类的操作，方法的第一个参数是代理的本地路径，第二个参数是传给代理的参数。执行 AttachTest，再回到主程序 AgentmainTest 的控制台，可以看到执行了了 &lt;span&gt;Agent&lt;/span&gt; 中的代码：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2754777070063694&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9MdHRPc00Ww9TVUf3wqNfa2uAra0OqldYhicsaAe1jndcBHACpymPFpwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;628&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样，一个简单的 agentMain 模式代理就实现完成了，可以通过下面这张图再梳理一下三个模块之间的关系。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2588699080157687&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9MXM1iahCcAaIY4mUXS6UqbXq2FK33GwxvXKTVek8Eic9ricWWVShFdlyaw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;761&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;应用&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;到这里，我们就已经简单地了解了两种模式的实现方法，但是作为高质量程序员，我们肯定不能满足于只用代理单纯地打印语句，下面我们再来看看能怎么利用 Java Agent 搞点实用的东西。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在上面的两种模式中，agent 部分的逻辑分别是在 premain 方法和 agentmain 方法中实现的。并且，这两个方法在签名上对参数有严格的要求，premain 方法允许以下面两种方式定义：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; premain(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; agentArgs)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; premain(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; agentArgs, Instrumentation inst)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;agentmain 方法允许以下面两种方式定义：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; agentmain(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; agentArgs)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; agentmain(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; agentArgs, Instrumentation inst)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果在 agent 中同时存在两种签名的方法，带有 Instrumentation 参数的方法优先级更高，会被 jvm 优先加载，它的实例 inst 会由 JVM 自动注入，下面我们就看看能通过 Instrumentation 实现什么功能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Instrumentation&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;先大体介绍一下 Instrumentation 接口。其中的方法允许在运行时操作 Java 程序，提供了诸如改变字节码、新增 jar 包、替换 class 等功能。而通过这些功能使 Java 具有了更强的动态控制和解释能力。在我们编写 &lt;span&gt;Agent&lt;/span&gt; 代理的过程中，Instrumentation 中下面 3 个方法比较重要和常用，我们来着重看一下。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;addTransformer&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;addTransformer 方法允许我们在类加载之前，重新定义 Class，先看一下方法的定义：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;addTransformer&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;ClassFileTransformer transformer&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ClassFileTransformer 是一个接口，只有一个 transform 方法，它在主程序的 main 方法执行前，装载的每个类都要经过 transform 执行一次，可以将它称为转换器。我们可以实现这个方法来重新定义 Class，下面就通过一个例子看看具体如何使用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，在主程序工程创建一个 Fruit 类：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Fruit&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;getFruit&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;banana&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;编译完成后复制一份 class 文件，并将其重命名为 Fruit2.class，再修改 Fruit 中的方法为：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;getFruit&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;apple&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;创建主程序，在主程序中创建了一个 Fruit 对象并调用了其 getFruit 方法：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;TransformMain&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String[] args&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Fruit().getFruit();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这时执行结果会打印 apple，接下来开始实现 premain 代理部分。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在代理的 premain 方法中，使用 Instrumentation 的 addTransformer 方法拦截类的加载：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;TransformAgent&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;premain&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String agentArgs, Instrumentation inst&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        inst.addTransformer(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; FruitTransformer());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;FruitTransforme r类实现了 ClassFileTransformer 接口，转换 class 部分的逻辑都在 transform 方法中：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;FruitTransformer&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ClassFileTransformer&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @&lt;span class=&quot;code-snippet__function&quot;&gt;Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;[] &lt;span class=&quot;code-snippet__title&quot;&gt;transform&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;ClassLoader loader, String className, Class&amp;lt;?&amp;gt; classBeingRedefined,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            ProtectionDomain protectionDomain, &lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;[] classfileBuffer&lt;/span&gt;){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!className.&lt;span class=&quot;code-snippet__keyword&quot;&gt;equals&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;com/cn/hydra/test/Fruit&quot;&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; classfileBuffer;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        String fileName=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;F:\\Workspace\\agent-test\\target\\classes\\com\\cn\\hydra\\test\\Fruit2.class&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; getClassBytes(fileName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;[] &lt;span class=&quot;code-snippet__title&quot;&gt;getClassBytes&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String fileName&lt;/span&gt;)&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        File file = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; File(fileName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt;(InputStream &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; FileInputStream(file);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            ByteArrayOutputStream bs = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ByteArrayOutputStream()){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; length = file.length();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;[] bytes = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;[(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;) length];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; n;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; ((n = &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt;.read(bytes)) != &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                bs.write(bytes, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, n);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; bytes;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            e.printStackTrace();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 transform 方法中，主要做了两件事：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;因为 addTransformer 方法不能指明需要转换的类，所以需要通过 className 判断当前加载的 class 是否我们要拦截的目标 class，对于非目标 class 直接返回原字节数组，注意 className 的格式，需要将类全限定名中的 &#x27;.&#x27; 替换为 &#x27;/&#x27;；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;读取我们之前复制出来的 class 文件，读入二进制字符流，替换原有 classfileBuffer 字节数组并返回，完成 class 定义的替换。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;将 &lt;span&gt;Agent&lt;/span&gt; 部分打包完成后，在主程序添加启动参数：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-javaagent&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:F&lt;/span&gt;:\&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Workspace&lt;/span&gt;\&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;MyAgent&lt;/span&gt;\&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;target&lt;/span&gt;\&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;transformAgent-1&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.jar&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;再次执行主程序，结果打印：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;banana&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样，就实现了在 main 方法执行前 class 的替换。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;redefineClasses&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们可以直观地从方法的名字上来理解它的作用，重定义 class，通俗点来讲的话就是实现指定类的替换。方法定义如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;redefineClasses&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ClassDefinition... definitions)&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt;  ClassNotFoundException, UnmodifiableClassException&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它的参数是可变长的 ClassDefinition 数组，再看一下 ClassDefinition 的构造方法：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ClassDefinition&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;Class&amp;lt;?&amp;gt; theClass,&lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;[] theClassFile&lt;/span&gt;)&lt;/span&gt; {...}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ClassDefinition 中指定了的 Class 对象和修改后的字节码数组。简单来说，就是使用提供的类文件字节，替换了原有的类。并且，在 redefineClasses 方法重定义的过程中，传入的是 ClassDefinition 的数组，它会按照这个数组顺序进行加载，以便满足在类之间相互依赖的情况下进行更改。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面通过一个例子来看一下它的生效过程，premain 代理部分：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;RedefineAgent&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;premain&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String agentArgs, Instrumentation inst)&lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; UnmodifiableClassException, ClassNotFoundException &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        String fileName=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;F:\\Workspace\\agent-test\\target\\classes\\com\\cn\\hydra\\test\\Fruit2.class&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ClassDefinition def=&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ClassDefinition(Fruit.class,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                FruitTransformer.getClassBytes(fileName));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        inst.redefineClasses(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ClassDefinition[]{def});&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主程序可以直接复用上面的，执行后打印：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;banana&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以看到，用我们指定的 class 文件的字节替换了原有类，即实现了指定类的替换。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;retransformClasses&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;retransformClasses 应用于 agentmain 模式，可以在类加载之后重新定义 Class，即触发类的重新加载。首先看一下该方法的定义：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;retransformClasses&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Class&amp;lt;?&amp;gt;... classes)&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; UnmodifiableClassException&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它的参数 classes 是需要转换的类数组，可变长参数也说明了它和 redefineClasses 方法一样，也可以批量转换类的定义。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面，我们通过例子来看看如何使用 retransformClasses 方法，&lt;span&gt;Agent &lt;/span&gt;代理部分代码如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;RetransformAgent&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;agentmain&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String agentArgs, Instrumentation inst&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            throws UnmodifiableClassException&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        inst.addTransformer(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; FruitTransformer(),&lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        inst.retransformClasses(Fruit.class);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;retransform success&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;看一下这里调用的 addTransformer 方法的定义，与上面略有不同：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;addTransformer&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ClassFileTransformer transformer, &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; canRetransform)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ClassFileTransformer 转换器依旧复用了上面的 FruitTransformer。重点看一下新加的第二个参数，当 canRetransform 为 true 时，表示允许重新定义 class。这时，相当于调用了转换器 ClassFileTransformer 中的 transform 方法，会将转换后 class 的字节作为新类定义进行加载。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主程序部分代码，我们在死循环中不断的执行打印语句，来监控类是否发生了改变：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;RetransformMain&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;true&lt;/span&gt;){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Fruit().getFruit();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            TimeUnit.SECONDS.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后，使用 attach API 注入 &lt;span&gt;Agent&lt;/span&gt; 代理到主程序中：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;AttachRetransform&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        VirtualMachine vm = VirtualMachine.attach(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;6380&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        vm.loadAgent(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;F:\\Workspace\\MyAgent\\target\\retransformAgent-1.0.jar&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;回到主程序控制台，查看运行结果：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46634615384615385&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9M4Yfgzj40BEWQ6meuOyS9nsgvgtARdTdzl2t8Xc4ia7z2Bw0pTa5XS7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;624&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以看到在注入代理后，打印语句发生变化，说明类的定义已经被改变并进行了重新加载。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;其他&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;除了这几个主要的方法外，Instrumentation 中还有一些其他方法，这里仅简单列举一下常用方法的功能：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;removeTransformer&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：删除一个 ClassFileTransformer 类转换器；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;getAllLoadedClasses&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：获取当前已经被加载的 Class；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;getInitiatedClasses&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：获取由指定的 ClassLoader 加载的 Class；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;getObjectSize&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：获取一个对象占用空间的大小；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;appendToBootstrapClassLoaderSearch&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：添加 jar 包到启动类加载器；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;appendToSystemClassLoaderSearch&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：添加 jar 包到系统类加载器；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;isNativeMethodPrefixSupported&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：判断是否能给 native 方法添加前缀，即是否能够拦截 native 方法；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;setNativeMethodPrefix&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：设置 native 方法的前缀。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Javassist&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在上面的几个例子中，我们都是直接读取的 class 文件中的字节来进行 class 的重定义或转换。但是在实际的工作环境中，可能更多的是去动态的修改 class 文件的字节码，这时候就可以借助 javassist 来更简单的修改字节码文件。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;简单来说，javassist 是一个分析、编辑和创建 Java 字节码的类库。在使用时我们可以直接调用它提供的 API，以编码的形式动态改变或生成 class 的结构。相对于 ASM 等其他要求了解底层虚拟机指令的字节码框架，javassist 真的是非常简单和快捷。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面，我们就通过一个简单的例子，看看如何将 Java agent 和 Javassist 结合在一起使用。首前先引入 javassist 的依赖：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.javassist&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;javassist&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;3.20.0-GA&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们要实现的功能是通过代理，来计算方法执行的时间。premain 代理部分和之前基本一致，先添加一个转换器：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Agent&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;premain&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String agentArgs, Instrumentation inst)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        inst.addTransformer(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; LogTransformer());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;LogTransformer&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ClassFileTransformer&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;[] transform(ClassLoader loader, String className, Class&amp;lt;?&amp;gt; classBeingRedefined, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                ProtectionDomain protectionDomain, &lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;[] classfileBuffer) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; IllegalClassFormatException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!className.equals(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;com/cn/hydra/test/Fruit&quot;&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; calculate();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                e.printStackTrace();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 calculate 方法中，使用 javassist 动态的改变了方法的定义：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;static &lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;[] calculate() throws Exception {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ClassPool pool = ClassPool.getDefault();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    CtClass ctClass = pool.get(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;com.cn.hydra.test.Fruit&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    CtMethod ctMethod = ctClass.getDeclaredMethod(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;getFruit&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    CtMethod copyMethod = CtNewMethod.&lt;span class=&quot;code-snippet__built_in&quot;&gt;copy&lt;/span&gt;(ctMethod, ctClass, &lt;span class=&quot;code-snippet__built_in&quot;&gt;new&lt;/span&gt; ClassMap());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ctMethod.setName(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;getFruit$agent&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    StringBuffer body = &lt;span class=&quot;code-snippet__built_in&quot;&gt;new&lt;/span&gt; StringBuffer(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;{\n&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            .&lt;span class=&quot;code-snippet__built_in&quot;&gt;append&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;long begin = System.nanoTime();\n&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            .&lt;span class=&quot;code-snippet__built_in&quot;&gt;append&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;getFruit$agent($$);\n&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            .&lt;span class=&quot;code-snippet__built_in&quot;&gt;append&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;System.out.println(\&quot;use \&quot;+(System.nanoTime() - begin) +\&quot; ns\&quot;);\n&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            .&lt;span class=&quot;code-snippet__built_in&quot;&gt;append&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;}&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    copyMethod.setBody(body.toString());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ctClass.addMethod(copyMethod);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; ctClass.toBytecode();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在上面的代码中，主要实现了这些功能：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;利用全限定名获取类 CtClass；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;根据方法名获取方法 CtMethod，并通过 CtNewMethod.copy 方法复制一个新的方法；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;修改旧方法的方法名为 getFruit$agent；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过 setBody 方法修改复制出来方法的内容，在新方法中进行了逻辑增强并调用了旧方法，最后将新方法添加到类中。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主程序仍然复用之前的代码，执行查看结果，完成了代理中的执行时间统计功能：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2981878088962109&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9Mic7DYGxlweUWn2pX1n9vRDffTd9ibVPzkiaulcSRMyHIUBdmTiaHB0Yc5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;607&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这时候我们可以再通过反射看一下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (Method method : Fruit.class.getDeclaredMethods()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(method.getName());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    method.invoke(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Fruit());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;-------&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;查看结果，可以看到类中确实已经新增了一个方法：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47796610169491527&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9MHMCAoIKB0FR0urfTstXQfiarQOD1JmwaCvKVGLcSauT1kKeh0vB6law/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;590&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;除此之外，javassist 还有很多其他的功能，例如新建 Class、设置父类、读取和写入字节码等等，大家可以在具体的场景中学习它的用法。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;虽然我们在平常的工作中，直接用到 Java Agent 的场景可能并不是很多，但是在热部署、监控、性能分析等工具中，它们可能隐藏在业务系统的角落里，一直在默默发挥着巨大的作用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文从 Java Agent 的两种模式入手，手动实现并简要分析了它们的工作流程。虽然在这里只利用它们完成了一些简单的功能，但是不得不说，正是 Java Agent 的出现，让程序的运行不再循规蹈矩，也为我们的代码提供了无限的可能性。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d5fbd1e0352f4c6e4f93efa17720d94e</guid>
<title>[推荐] 浅谈缓存最终一致性的解决方案</title>
<link>https://toutiao.io/k/mgym1lv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：clareguo，腾讯 CSIG 后台开发工程师&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;46&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;到底是更新缓存还是删除缓存? 到底是先更新数据库，再删除缓存，还是先删除缓存，再更新数据库?&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1 引言&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于互联网业务来说，传统的直接访问数据库方式，主要通过数据分片、一主多从等方式来扛住读写流量，但随着数据量的积累和流量的激增，仅依赖数据库来承接所有流量，不仅成本高、效率低、而且还伴随着稳定性降低的风险。鉴于大部分业务通常是读多写少（读取频率远远高于更新频率），甚至存在读操作数量高出写操作多个数量级的情况。因此，在架构设计中，常采用增加缓存层来提高系统的响应能力，提升数据读写性能、减少数据库访问压力，从而提升业务的稳定性和访问体验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据 CAP 原理，分布式系统在可用性、一致性和分区容错性上无法兼得，通常由于分区容错无法避免，所以一致性和可用性难以同时成立。对于缓存系统来说，如何保证其数据一致性是一个在应用缓存的同时不得不解决的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要明确的是，缓存系统的数据一致性通常包括持久化层和缓存层的一致性、以及多级缓存之间的一致性，这里我们仅讨论前者。持久化层和缓存层的一致性问题也通常被称为双写一致性问题，“双写”意为数据既在数据库中保存一份，也在缓存中保存一份。对于一致性来说，包含强一致性和弱一致性，强一致性保证写入后立即可以读取，弱一致性则不保证立即可以读取写入后的值，而是尽可能的保证在经过一定时间后可以读取到，在弱一致性中应用最为广泛的模型则是最终一致性模型，即保证在一定时间之后写入和读取达到一致的状态。对于应用缓存的大部分场景来说，追求的则是最终一致性，少部分对数据一致性要求极高的场景则会追求强一致性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2 保证最终一致性的策略（ Cache Policy ）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了达到最终一致性，针对不同的场景，业界逐步形成了下面这几种应用缓存的策略。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 Cache-Aside&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Cache-Aside 意为旁路缓存模式，是应用最为广泛的一种缓存策略。下面的图示展示了它的读写流程，来看看它是如何保证最终一致性的。在读请求中，首先请求缓存，若缓存命中（ cache hit ），则直接返回缓存中的数据；若缓存未命中（ cache miss ），则查询数据库并将查询结果更新至缓存，然后返回查询出的数据（ demand-filled look-aside ）。在写请求中，先更新数据库，再删除缓存（write-invalidate）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5924050632911393&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEy8knbFcMB7NoiajEYjxo04ww5kmKIOyicbnpbMD0kz3N57EzT4H46xkQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1580&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.1 为什么删除缓存，而不是更新缓存？&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Cache-Aside 中，对于读请求的处理比较容易理解，但在写请求中，可能会有读者提出疑问，为什么要删除缓存，而不是更新缓存？站在符合直觉的角度来看，更新缓存是一个容易被理解的方案，但站在性能和安全的角度，更新缓存则可能会导致一些不好的后果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先是性能，当该缓存对应的结果需要消耗大量的计算过程才能得到时，比如需要访问多张数据库表并联合计算，那么在写操作中更新缓存的动作将会是一笔不小的开销。同时，当写操作较多时，可能也会存在刚更新的缓存还没有被读取到，又再次被更新的情况（这常被称为缓存扰动），显然，这样的更新是白白消耗机器性能的，会导致缓存利用率不高。而等到读请求未命中缓存时再去更新，也符合懒加载的思路，需要时再进行计算。删除缓存的操作不仅是幂等的，可以在发生异常时重试，而且写-删除和读-更新在语义上更加对称。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次是安全，在并发场景下，在写请求中更新缓存可能会引发数据的不一致问题。参考下面的图示，若存在两个来自不同线程的写请求，首先来自线程 1 的写请求更新了数据库（ step 1 ），接着来自线程 2 的写请求再次更新了数据库（ step 3 ），但由于网络延迟等原因，线程 1 可能会晚于线程 2 更新缓存（ step 4 晚于 step 3 ），那么这样便会导致最终写入数据库的结果是来自线程 2 的新值，写入缓存的结果是来自线程 1 的旧值，即缓存落后于数据库，此时再有读请求命中缓存（ step 5 ），读取到的便是旧值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5852130325814536&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwErd8vgtqGLMcj2zkhqt4sO4mwic32ZU0wrlRP2reBh4K48X5jEVBooEA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1596&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.2 为什么先更新数据库，而不是先删除缓存？&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，有读者也会对更新数据库和删除缓存的时序产生疑问，那么为什么不先删除缓存，再更新数据库呢？在单线程下，这种方案看似具有一定合理性，这种合理性体现在删除缓存成功，但更新数据库失败的场景下，尽管缓存被删除了，下次读操作时，仍能将正确的数据写回缓存，相对于 Cache-Aside 中更新数据库成功，删除缓存失败的场景来说，先删除缓存的方案似乎更合理一些。那么，先删除缓存有什么问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题仍然出现在并发场景下，首先来自线程 1 的写请求删除了缓存（ step 1 ），接着来自线程 2 的读请求由于缓存的删除导致缓存未命中，根据 Cache-Aside 模式，线程 2 继而查询数据库（ step 2 ），但由于写请求通常慢于读请求，线程 1 更新数据库的操作可能会晚于线程 2 查询数据库后更新缓存的操作（ step 4 晚于 step 3 ），那么这样便会导致最终写入缓存的结果是来自线程 2 中查询到的旧值，而写入数据库的结果是来自线程 1 的新值，即缓存落后于数据库，此时再有读请求命中缓存（ step 5 ），读取到的便是旧值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3954659949622166&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEgctQjMRGQglE3wyEmDWxGefpPfdZmcsgz1El5qL5icCdroGYcSTrI5Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1588&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，先删除缓存，由于缓存中数据缺失，加剧数据库的请求压力，可能会增大缓存穿透出现的概率。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.3 如果选择先删除缓存，再更新数据库，那如何解决一致性问题呢？&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了避免“先删除缓存，再更新数据库”这一方案在读写并发时可能带来的缓存脏数据，业界又提出了延时双删的策略，即在更新数据库之后，延迟一段时间再次删除缓存，为了保证第二次删除缓存的时间点在读请求更新缓存之后，这个延迟时间的经验值通常应稍大于业务中读请求的耗时。延迟的实现可以在代码中 &lt;code&gt;sleep&lt;/code&gt; 或采用延迟队列。显而易见的是，无论这个值如何预估，都很难和读请求的完成时间点准确衔接，这也是延时双删被诟病的主要原因。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5082382762991128&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEtpFBnmv9rhKJULmmAIrGjcqnnXSInT1UMTntXVntpZWPuf8Oaicfb4w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1578&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.4 那么 Cache-Aside 存在数据不一致的可能吗？&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Cache-Aside 中，也存在数据不一致的可能性。在下面的读写并发场景下，首先来自线程 1 的读请求在未命中缓存的情况下查询数据库（ step 1 ），接着来自线程 2 的写请求更新数据库（ step 2 ），但由于一些极端原因，线程 1 中读请求的更新缓存操作晚于线程 2 中写请求的删除缓存的操作（ step 4 晚于 step 3 ），那么这样便会导致最终写入缓存中的是来自线程 1 的旧值，而写入数据库中的是来自线程 2 的新值，即缓存落后于数据库，此时再有读请求命中缓存（ step 5 ），读取到的便是旧值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种场景的出现，不仅需要缓存失效且读写并发执行，而且还需要读请求查询数据库的执行早于写请求更新数据库，同时读请求的执行完成晚于写请求。足以见得，这种不一致场景产生的条件非常严格，在实际的生产中出现的可能性较小。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4068010075566751&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEy1XuQ2xxVFFdNZgibhhSJUnR0sViasGl6xzLgNMcP3wxC1bJJ59CZ0icQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1588&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，在并发环境下，Cache-Aside 中也存在读请求命中缓存的时间点在写请求更新数据库之后，删除缓存之前，这样也会导致读请求查询到的缓存落后于数据库的情况。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38944723618090454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEuKSPArRcuQPbIob0MBaBWgKYyrZBZuNUvBR7DYNeNm67EmAbOwsuKA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1592&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然在下一次读请求中，缓存会被更新，但如果业务层面对这种情况的容忍度较低，那么可以采用加锁在写请求中保证“更新数据库&amp;amp;删除缓存”的串行执行为原子性操作（同理也可对读请求中缓存的更新加锁）。加锁势必会导致吞吐量的下降，故采取加锁的方案应该对性能的损耗有所预期。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4292929292929293&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwExt0GUt5zySf0MYCib3Wbg3jibkIwvQNicERf8PKC2wFTJfAtLBjiaODpxg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1584&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6914212548015365&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEicojwkV1Uh0nDTWGFTd3ncLQbibB2eZiccTnm4BOjILRvawDvx4qqhsMw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1562&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 补偿机制&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在上面提到了，在 Cache-Aside 中可能存在更新数据库成功，但删除缓存失败的场景，如果发生这种情况，那么便会导致缓存中的数据落后于数据库，产生数据的不一致的问题。其实，不仅 Cache-Aside 存在这样的问题，在延时双删等策略中也存在这样的问题。针对可能出现的删除失败问题，目前业界主要有以下几种补偿机制。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2.1 删除重试机制&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于同步重试删除在性能上会影响吞吐量，所以常通过引入消息队列，将删除失败的缓存对应的 &lt;code&gt;key&lt;/code&gt; 放入消息队列中，在对应的消费者中获取删除失败的 &lt;code&gt;key&lt;/code&gt; ，异步重试删除。这种方法在实现上相对简单，但由于删除失败后的逻辑需要基于业务代码的 trigger 来触发 ，对业务代码具有一定入侵性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45132743362831856&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEkNJlDa9w1r2icXT7YGQtpuZq66BIDuFaCe79Whl5gDeOu1EyqEibB03A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1582&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2.2 基于数据库日志（ MySQL binlog ）增量解析、订阅和消费&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;鉴于上述方案对业务代码具有一定入侵性，所以需要一种更加优雅的解决方案，让缓存删除失败的补偿机制运行在背后，尽量少的耦合于业务代码。一个简单的思路是通过后台任务使用更新时间戳或者版本作为对比获取数据库的增量数据更新至缓存中，这种方式在小规模数据的场景可以起到一定作用，但其扩展性、稳定性都有所欠缺。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个相对成熟的方案是基于 MySQL 数据库增量日志进行解析和消费，这里较为流行的是阿里巴巴开源的作为 MySQL binlog 增量获取和解析的组件 canal （类似的开源组件还有 Maxwell、Databus 等）。canal sever 模拟 MySQL slave 的交互协议，伪装为 MySQL slave ，向 MySQL master 发送 dump 协议，MySQL master 收到 dump 请求，开始推送 binary log 给 slave （即 canal sever ），canal sever 解析 binary log 对象（原始为 byte 流），可由 canal client 拉取进行消费，同时 canal server 也默认支持将变更记录投递到 MQ 系统中，主动推送给其他系统进行消费。在 ack 机制的加持下，不管是推送还是拉取，都可以有效的保证数据按照预期被消费。当前版本的 canal 支持的 MQ 有 kafka 或者 RocketMQ 。另外， canal 依赖 zookeeper 作为分布式协调组件来实现 HA ，canal 的 HA 分为两个部分：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为了减少对 MySQL dump 的请求压力，不同 canal server 上的 instance 要求同一时间只能有一个处于运行状态，其他的 instance 处于 standby 状态；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为了保证有序性，对于一个 instance 在同一时间只能由一个 canal client 进行 get/ack 等动作；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6923076923076923&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEByTHKnOZ2yJDa8ciamnK6GsqkWm8CMcViaPHXdvhtSPV2wunkXcnrP0A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1560&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，针对缓存的删除操作便可以在 canal client 或 consumer 中编写相关业务代码来完成。这样，结合数据库日志增量解析消费的方案以及 Cache-Aside 模型，在读请求中未命中缓存时更新缓存（通常这里会涉及到复杂的业务逻辑），在写请求更新数据库后删除缓存，并基于日志增量解析来补偿数据库更新时可能的缓存删除失败问题，在绝大多数场景下，可以有效的保证缓存的最终一致性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外需要注意的是，还应该隔离事务与缓存，确保数据库入库后再进行缓存的删除操作。比如考虑到数据库的主从架构，主从同步及读从写主的场景下，可能会造成读取到从库的旧数据后便更新了缓存，导致缓存落后于数据库的问题，这就要求对缓存的删除应该确保在数据库操作完成之后。所以，基于 binlog 增量日志进行数据同步的方案，可以通过选择解析从节点的 binlog，来避免主从同步下删除缓存过早的问题。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2.3 数据传输服务 DTS&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据传输服务（ Data Transmission Service，简称 DTS）是云服务商提供的一种支持 RDBMS（关系型数据库）、NoSQL、OLAP 等多种数据源之间进行数据交互的数据流服务。DTS 提供了包括数据迁移、数据订阅、数据同步等在内的多种数据传输能力，常用于不停服数据迁移、数据异地灾备、异地多活(单元化)、跨境数据同步、实时数据仓库、查询报表分流、缓存更新、异步消息通知等多种业务应用场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对于上述基于 canal 等开源组件自建系统，DTS 的优势体现在对多种数据源的支持、对多种数据传输方式的支持，避免了部署维护的人力成本。目前，各家云服务商的 DTS 服务已 针对云数据库，云缓存等产品进行了适配，解决了 Binlog 日志回收，主备切换等场景下的订阅高可用问题。在大规模的缓存数据一致性场景下，优先推荐使用 DTS 服务。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 Read-Through&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Read-Through 意为读穿透模式，它的流程和 Cache-Aside 类似，不同点在于 Read-Through 中多了一个访问控制层，读请求只和该访问控制层进行交互，而背后缓存命中与否的逻辑则由访问控制层与数据源进行交互，业务层的实现会更加简洁，并且对于缓存层及持久化层交互的封装程度更高，更易于移植。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7479224376731302&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEMibwZEPeCZE1icibze89CLf9h8aPkgcJ0NUWlvJjd0IcMa6Yib4ziamibic1w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1444&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 Write-Through&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Write-Through 意为直写模式，对于 Write-Through 直写模式来说，它也增加了访问控制层来提供更高程度的封装。不同于 Cache-Aside 的是，Write-Through 直写模式在写请求更新数据库之后，并不会删除缓存，而是更新缓存。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49111675126903553&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEbcBG5HIc4pohTLg9sMgRNDlAR3xPmYHS2HlMbz3Gv57bTeRJsmicKAA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1576&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式的优势在于读请求过程简单，不需要查询数据库更新缓存等操作。但其劣势也非常明显，除了上面我们提到的更新数据库再更新缓存的弊端之外，这种方案还会造成更新效率低，并且两个写操作任何一次写失败都会造成数据不一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要使用这种方案，最好可以将这两个操作作为事务处理，可以同时失败或者同时成功，支持回滚，并且防止并发环境下的不一致。另外，为了防止缓存扰动的频发，也可以给缓存增加 TTL 来缓解。站在可行性的角度，不管是 Write-Through 模式还是 Cache-Aside 模式，理想状况下都可以通过分布式事务保证缓存层数据与持久化层数据的一致性，但在实际项目中，大多都对一致性的要求存在一些宽容度，所以在方案上往往有所折衷。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Write-Through 直写模式适合写操作较多，并且对一致性要求较高的场景，在应用 Write-Through 模式时，也需要通过一定的补偿机制来解决它的问题。首先，在并发环境下，我们前面提到了先更新数据库，再更新缓存会导致缓存和数据库的不一致，那么先更新缓存，再更新数据库呢？这样的操作时序仍然会导致下面这样线程 1 先更新缓存，最后更新数据库的情况，即由于线程 1 和 线程 2 的执行不确定性导致数据库和缓存的不一致。这种由于线程竞争导致的缓存不一致，可以通过分布式锁解决，保证对缓存和数据库的操作仅能由同一个线程完成。对于没有拿到锁的线程，一是通过锁的 &lt;code&gt;timeout&lt;/code&gt; 时间进行控制，二是将请求暂存在消息队列中顺序消费。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.410941475826972&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEB0ibpwSfY0CJJgyibXEVJ6xCKUjvZ72PI39SQWDEUz3bjCYUGrJQhkUg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1572&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在下面这种并发执行场景下，来自线程 1 的写请求更新了数据库，接着来自线程 2 的读请求命中缓存，接着线程 1 才更新缓存，这样便会导致线程 2 读取到的缓存落后于数据库。同理，先更新缓存后更新数据库在写请求和读请求并发时，也会出现类似的问题。面对这种场景，我们也可以加锁解决。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3883984867591425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEXvn8hXIzibTmpt4R8LEuwMUN0aLDJug0kGtXicPmTgfnNSic7XLbIn5Eg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1586&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另在，在 Write-Through 模式下，不管是先更新缓存还是先更新数据库，都存在更新缓存或者更新数据库失败的情况，上面提到的重试机制和补偿机制在这里也是奏效的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5 Write-Behind&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Write behind 意为异步回写模式，它也具有类似 Read-Through/Write-Through 的访问控制层，不同的是，Write behind 在处理写请求时，只更新缓存而不更新数据库，对于数据库的更新，则是通过批量异步更新的方式进行的，批量写入的时间点可以选在数据库负载较低的时间进行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48984771573604063&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEfl7FaXmIwmgNPoUOwib2tSWykFoZicIpiaxbHPIpLC51VKyFazLkKEaeQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1576&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Write-Behind 模式下，写请求延迟较低，减轻了数据库的压力，具有较好的吞吐性。但数据库和缓存的一致性较弱，比如当更新的数据还未被写入数据库时，直接从数据库中查询数据是落后于缓存的。同时，缓存的负载较大，如果缓存宕机会导致数据丢失，所以需要做好缓存的高可用。显然，Write behind 模式下适合大量写操作的场景，常用于电商秒杀场景中库存的扣减。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.6 Write-Around&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一些非核心业务，对一致性的要求较弱，可以选择在 cache aside 读模式下增加一个缓存过期时间，在写请求中仅仅更新数据库，不做任何删除或更新缓存的操作，这样，缓存仅能通过过期时间失效。这种方案实现简单，但缓存中的数据和数据库数据一致性较差，往往会造成用户的体验较差，应慎重选择。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在解决缓存一致性的过程中，有多种途径可以保证缓存的最终一致性，应该根据场景来设计合适的方案，读多写少的场景下，可以选择采用“ Cache-Aside 结合消费数据库日志做补偿”的方案，写多的场景下，可以选择采用“ Write-Through 结合分布式锁”的方案 ，写多的极端场景下，可以选择采用“ Write-Behind ” 的方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;最近其他好文：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649766734&amp;amp;idx=1&amp;amp;sn=b23d539c9daedbf8a6ab8993505e3641&amp;amp;chksm=becca83589bb2123c21a187be11e064ba5e5154ceded1eef0b95d3ba3e4f9e8140adadfff0de&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;最近大火的 NFT 数字藏品是什么？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;最近大火的 NFT 数字藏品是什么？&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649766668&amp;amp;idx=1&amp;amp;sn=bc8d55f637fe8b00ce5404cfcfb8b7fc&amp;amp;chksm=becca87789bb216125125fdb6f5d883048a6346937f0c6707ea527df429040b508a759362de9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2021 腾讯技术十大热门文章&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;2021 腾讯技术十大热门文章&lt;/a&gt;&lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649766668&amp;amp;idx=1&amp;amp;sn=bc8d55f637fe8b00ce5404cfcfb8b7fc&amp;amp;chksm=becca87789bb216125125fdb6f5d883048a6346937f0c6707ea527df429040b508a759362de9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2021 腾讯技术十大热门文章&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649766638&amp;amp;idx=1&amp;amp;sn=031eaf1fdd40222568eb40a9b6a399fb&amp;amp;chksm=becca99589bb2083ae4a361707339fc343bfe2d604c7cbcb6de582e878bc275849e52d0b9f68&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;服务器开发设计之算法宝典&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;服务器开发设计之算法宝典&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;3.72125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvatkTw3ahJGNlXdrVzdl0yxFvsAzUia48cP7KRgP46ZoZHANttHd1ZXKgWia8wm4TdWcNsrib1oSwaiaMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.587962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvatPyBdU42Pibe0fLSj0H232CGFzpFGdr8BenFo7oRWoAaecicibla1KEFW6KPrRStATLSwQ1hGJOUeEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_live_iframe&quot; data-pluginname=&quot;videosnap&quot; data-headimgurl=&quot;https://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;将在01月12日 19:30 直播&quot; data-intro=&quot;对谈CoDesign程序媛，听听“文艺女青年”的前端旅行&quot; data-noticeid=&quot;finderlivenotice-v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder-1641525666664055-1293066808&quot; data-type=&quot;live&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5ODYwMjI2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasvpPfMrktl2xvC9A325p8Qa9dFeEzxZmZ2O1XuFGsVXyQhG9Dia8J8nTXVtzNcHozr0umH3R4iboXg/0?wx_fmt=png&quot; data-nickname=&quot;腾讯技术工程&quot; data-alias=&quot;Tencent_TEG&quot; data-signature=&quot;腾讯技术官方号。腾讯技术创新、前沿领域发布解读平台。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c6958515e606acc952427f125467dc6a</guid>
<title>[推荐] JVM调优的几种场景（建议收藏）</title>
<link>https://toutiao.io/k/0mfx2nd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;大家好，我是冰河~~&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近很多小伙伴跟我说，自己学了不少JVM的调优知识，但是在实际工作中却不知道何时对JVM进行调优。今天，冰河就为大家介绍几种JVM调优的场景。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg4MjU0OTM1OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/2hHcUic5FEwGzljlbsOzVRib0A41LgChOaWdo7OSYAl43icUjIdMIicibjljZNvVGSZ7s7E95lAQf6k1q5AvGMZFoJQ/0?wx_fmt=png&quot; data-nickname=&quot;冰河技术&quot; data-alias=&quot;hacker-binghe&quot; data-signature=&quot;分享各种编程语言、开发技术、分布式与微服务架构、分布式数据库、分布式事务、云原生、大数据与云计算技术和渗透技术。另外，还会分享各种面试题和面试技巧。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;点击上方卡片关注我&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在阅读本文时，冰河假定大家已经了解了运行时的数据区域和常用的垃圾回收算法，也了解了Hotspot支持的垃圾回收器。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;cpu占用过高&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;cpu占用过高要分情况讨论，是不是业务上在搞活动，突然有大批的流量进来，而且活动结束后cpu占用率就下降了，如果是这种情况其实可以不用太关心，因为请求越多，需要处理的线程数越多，这是正常的现象。话说回来，如果你的服务器配置本身就差，cpu也只有一个核心，这种情况，稍微多一点流量就真的能够把你的cpu资源耗尽，这时应该考虑先把配置提升吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二种情况，cpu占用率&lt;strong&gt;长期过高&lt;/strong&gt;，这种情况下可能是你的程序有那种循环次数超级多的代码，甚至是出现死循环了。排查步骤如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）用top命令查看cpu占用情况&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2616580310880829&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2hHcUic5FEwHbzcdlXpjOX5mgMoHdSnWooq05hR8mqwpicaEl0HrteUDMfE7AWnBPRNzrtK5wYeTiaGp8J5Micn8CQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1158&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就可以定位出cpu过高的进程。在linux下，top命令获得的进程号和jps工具获得的vmid是相同的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.075809199318569&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2hHcUic5FEwHbzcdlXpjOX5mgMoHdSnWornbuib9ANC4kPwxibWCmKWxD14z3CplafMLFxkX8icsUzaz8RPSq9wL2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1174&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）用top -Hp命令查看线程的情况&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6779359430604982&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2hHcUic5FEwHbzcdlXpjOX5mgMoHdSnWoCIoucEaHuJJst2XCl9y0cTkCGM4IzSeswBBwzRjXbW6oCID2ibAAr2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1124&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到是线程id为7287这个线程一直在占用cpu&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（3）把线程号转换为16进制&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[root@localhost ~]# printf &quot;%x&quot; 7287&lt;br/&gt;1c77&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记下这个16进制的数字，下面我们要用&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（4）用jstack工具查看线程栈情况&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[root@localhost ~]# jstack 7268 | grep 1c77 -A 10&lt;br/&gt;&quot;http-nio-8080-exec-2&quot; #16 daemon prio=5 os_prio=0 tid=0x00007fb66ce81000 nid=0x1c77 runnable [0x00007fb639ab9000]&lt;br/&gt;   java.lang.Thread.State: RUNNABLE&lt;br/&gt; at com.spareyaya.jvm.service.EndlessLoopService.service(EndlessLoopService.java:19)&lt;br/&gt; at com.spareyaya.jvm.controller.JVMController.endlessLoop(JVMController.java:30)&lt;br/&gt; at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt; at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)&lt;br/&gt; at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)&lt;br/&gt; at java.lang.reflect.Method.invoke(Method.java:498)&lt;br/&gt; at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)&lt;br/&gt; at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)&lt;br/&gt; at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过jstack工具输出现在的线程栈，再通过grep命令结合上一步拿到的线程16进制的id定位到这个线程的运行情况，其中jstack后面的7268是第（1）步定位到的进程号，grep后面的是（2）、（3）步定位到的线程号。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从输出结果可以看到这个线程处于运行状态，在执行&lt;code&gt;com.spareyaya.jvm.service.EndlessLoopService.service&lt;/code&gt;这个方法，代码行号是19行，这样就可以去到代码的19行，找到其所在的代码块，看看是不是处于循环中，这样就定位到了问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;死锁&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;死锁并没有第一种场景那么明显，web应用肯定是多线程的程序，它服务于多个请求，程序发生死锁后，死锁的线程处于等待状态（WAITING或TIMED_WAITING），等待状态的线程不占用cpu，消耗的内存也很有限，而表现上可能是请求没法进行，最后超时了。在死锁情况不多的时候，这种情况不容易被发现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用jstack工具来查看&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）jps查看java进程&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[root@localhost ~]# jps -l&lt;br/&gt;8737 sun.tools.jps.Jps&lt;br/&gt;8682 jvm-0.0.1-SNAPSHOT.jar&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）jstack查看死锁问题&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于web应用往往会有很多工作线程，特别是在高并发的情况下线程数更多，于是这个命令的输出内容会十分多。jstack最大的好处就是会把产生死锁的信息（包含是什么线程产生的）输出到最后，所以我们只需要看最后的内容就行了&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Java stack information for the threads listed above:&lt;br/&gt;===================================================&lt;br/&gt;&quot;Thread-4&quot;:&lt;br/&gt; at com.spareyaya.jvm.service.DeadLockService.service2(DeadLockService.java:35)&lt;br/&gt; - waiting to lock &amp;lt;0x00000000f5035ae0&amp;gt; (a java.lang.Object)&lt;br/&gt; - locked &amp;lt;0x00000000f5035af0&amp;gt; (a java.lang.Object)&lt;br/&gt; at com.spareyaya.jvm.controller.JVMController.lambda$deadLock$1(JVMController.java:41)&lt;br/&gt; at com.spareyaya.jvm.controller.JVMController$$Lambda$457/1776922136.run(Unknown Source)&lt;br/&gt; at java.lang.Thread.run(Thread.java:748)&lt;br/&gt;&quot;Thread-3&quot;:&lt;br/&gt; at com.spareyaya.jvm.service.DeadLockService.service1(DeadLockService.java:27)&lt;br/&gt; - waiting to lock &amp;lt;0x00000000f5035af0&amp;gt; (a java.lang.Object)&lt;br/&gt; - locked &amp;lt;0x00000000f5035ae0&amp;gt; (a java.lang.Object)&lt;br/&gt; at com.spareyaya.jvm.controller.JVMController.lambda$deadLock$0(JVMController.java:37)&lt;br/&gt; at com.spareyaya.jvm.controller.JVMController$$Lambda$456/474286897.run(Unknown Source)&lt;br/&gt; at java.lang.Thread.run(Thread.java:748)&lt;br/&gt;&lt;br/&gt;Found 1 deadlock.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发现了一个死锁，原因也一目了然。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;内存泄漏&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，java和c++的最大区别是前者会自动收回不再使用的内存，后者需要程序员手动释放。在c++中，如果我们忘记释放内存就会发生内存泄漏。但是，不要以为jvm帮我们回收了内存就不会出现内存泄漏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序发生内存泄漏后，进程的可用内存会慢慢变少，最后的结果就是抛出OOM错误。发生OOM错误后可能会想到是内存不够大，于是把-Xmx参数调大，然后重启应用。这么做的结果就是，过了一段时间后，OOM依然会出现。最后无法再调大最大堆内存了，结果就是只能每隔一段时间重启一下应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存泄漏的另一个可能的表现是请求的响应时间变长了。这是因为频繁发生的GC会暂停其它所有线程（Stop The World）造成的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了模拟这个场景，使用了以下的程序&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.ExecutorService;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.Executors;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Main&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Main main = &lt;span&gt;new&lt;/span&gt; Main();&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;            main.run();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ExecutorService executorService = Executors.newCachedThreadPool();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++) {&lt;br/&gt;            executorService.execute(() -&amp;gt; {&lt;br/&gt;                &lt;span&gt;// do something...&lt;/span&gt;&lt;br/&gt;            });&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行参数是&lt;code&gt;-Xms20m -Xmx20m -XX:+PrintGC&lt;/code&gt;，把可用内存调小一点，并且在发生gc时输出信息，运行结果如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;[GC (Allocation Failure)  12776K-&amp;gt;10840K(18432K), 0.0309510 secs]&lt;br/&gt;[GC (Allocation Failure)  13400K-&amp;gt;11520K(18432K), 0.0333385 secs]&lt;br/&gt;[GC (Allocation Failure)  14080K-&amp;gt;12168K(18432K), 0.0332409 secs]&lt;br/&gt;[GC (Allocation Failure)  14728K-&amp;gt;12832K(18432K), 0.0370435 secs]&lt;br/&gt;[Full GC (Ergonomics)  12832K-&amp;gt;12363K(18432K), 0.1942141 secs]&lt;br/&gt;[Full GC (Ergonomics)  14923K-&amp;gt;12951K(18432K), 0.1607221 secs]&lt;br/&gt;[Full GC (Ergonomics)  15511K-&amp;gt;13542K(18432K), 0.1956311 secs]&lt;br/&gt;...&lt;br/&gt;[Full GC (Ergonomics)  16382K-&amp;gt;16381K(18432K), 0.1734902 secs]&lt;br/&gt;[Full GC (Ergonomics)  16383K-&amp;gt;16383K(18432K), 0.1922607 secs]&lt;br/&gt;[Full GC (Ergonomics)  16383K-&amp;gt;16383K(18432K), 0.1824278 secs]&lt;br/&gt;[Full GC (Allocation Failure)  16383K-&amp;gt;16383K(18432K), 0.1710382 secs]&lt;br/&gt;[Full GC (Ergonomics)  16383K-&amp;gt;16382K(18432K), 0.1829138 secs]&lt;br/&gt;[Full GC (Ergonomics) Exception in thread &quot;main&quot;  16383K-&amp;gt;16382K(18432K), 0.1406222 secs]&lt;br/&gt;[Full GC (Allocation Failure)  16382K-&amp;gt;16382K(18432K), 0.1392928 secs]&lt;br/&gt;[Full GC (Ergonomics)  16383K-&amp;gt;16382K(18432K), 0.1546243 secs]&lt;br/&gt;[Full GC (Ergonomics)  16383K-&amp;gt;16382K(18432K), 0.1755271 secs]&lt;br/&gt;[Full GC (Ergonomics)  16383K-&amp;gt;16382K(18432K), 0.1699080 secs]&lt;br/&gt;[Full GC (Allocation Failure)  16382K-&amp;gt;16382K(18432K), 0.1697982 secs]&lt;br/&gt;[Full GC (Ergonomics)  16383K-&amp;gt;16382K(18432K), 0.1851136 secs]&lt;br/&gt;[Full GC (Allocation Failure)  16382K-&amp;gt;16382K(18432K), 0.1655088 secs]&lt;br/&gt;java.lang.OutOfMemoryError: Java heap space&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到虽然一直在gc，占用的内存却越来越多，说明程序有的对象无法被回收。但是上面的程序对象都是定义在方法内的，属于局部变量，局部变量在方法运行结果后，所引用的对象在gc时应该被回收啊，但是这里明显没有。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了找出到底是哪些对象没能被回收，我们加上运行参数-XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=heap.bin，意思是发生OOM时把堆内存信息dump出来。运行程序直至异常，于是得到heap.dump文件，然后我们借助eclipse的MAT插件来分析，如果没有安装需要先安装。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后File-&amp;gt;Open Heap Dump... ，然后选择刚才dump出来的文件，选择Leak Suspects&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5155367231638418&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2hHcUic5FEwHbzcdlXpjOX5mgMoHdSnWoR33SJF7kQD6fTIVRiaicBzicAuibHzoUQ30SWYaZalKiaxibUbRevktuzscQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1416&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MAT会列出所有可能发生内存泄漏的对象&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4652482269503546&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2hHcUic5FEwHbzcdlXpjOX5mgMoHdSnWo9pO3JhOZchmHylpvPwX0vG78hpoSrku9Xb1QdLDejfVkEolwmsFzQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1410&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到居然有21260个Thread对象，3386个ThreadPoolExecutor对象，如果你去看一下&lt;code&gt;java.util.concurrent.ThreadPoolExecutor&lt;/code&gt;的源码，可以发现线程池为了复用线程，会不断地等待新的任务，线程也不会回收，需要调用其shutdown方法才能让线程池执行完任务后停止。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实线程池定义成局部变量，好的做法是设置成单例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;上面只是其中一种处理方法&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在线上的应用，内存往往会设置得很大，这样发生OOM再把内存快照dump出来的文件就会很大，可能大到在本地的电脑中已经无法分析了（因为内存不足够打开这个dump文件）。这里介绍另一种处理办法：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）用jps定位到进程号&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;C:\Users\spareyaya\IdeaProjects\maven-project\target\classes\org\example\net&amp;gt;jps -l&lt;br/&gt;24836 org.example.net.Main&lt;br/&gt;62520 org.jetbrains.jps.cmdline.Launcher&lt;br/&gt;129980 sun.tools.jps.Jps&lt;br/&gt;136028 org.jetbrains.jps.cmdline.Launcher&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为已经知道了是哪个应用发生了OOM，这样可以直接用jps找到进程号135988&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）用jstat分析gc活动情况&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jstat是一个统计java进程内存使用情况和gc活动的工具，参数可以有很多，可以通过jstat -help查看所有参数以及含义&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;C:\Users\spareyaya\IdeaProjects\maven-project\target\classes\org\example\net&amp;gt;jstat -gcutil -t -h8 24836 1000&lt;br/&gt;Timestamp         S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT&lt;br/&gt;           29.1  32.81   0.00  23.48  85.92  92.84  84.13     14    0.339     0    0.000    0.339&lt;br/&gt;           30.1  32.81   0.00  78.12  85.92  92.84  84.13     14    0.339     0    0.000    0.339&lt;br/&gt;           31.1   0.00   0.00  22.70  91.74  92.72  83.71     15    0.389     1    0.233    0.622&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面是命令意思是输出gc的情况，输出时间，每8行输出一个行头信息，统计的进程号是24836，每1000毫秒输出一次信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出信息是Timestamp是距离jvm启动的时间，S0、S1、E是新生代的两个Survivor和Eden，O是老年代区，M是Metaspace，CCS使用压缩比例，YGC和YGCT分别是新生代gc的次数和时间，FGC和FGCT分别是老年代gc的次数和时间，GCT是gc的总时间。虽然发生了gc，但是老年代内存占用率根本没下降，说明有的对象没法被回收（当然也不排除这些对象真的是有用）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（3）用jmap工具dump出内存快照&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jmap可以把指定java进程的内存快照dump出来，效果和第一种处理办法一样，不同的是它不用等OOM就可以做到，而且dump出来的快照也会小很多。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;jmap -dump:live,format=b,file=heap.bin 24836&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时会得到heap.bin的内存快照文件，然后就可以用eclipse来分析了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上三种严格地说还算不上jvm的调优，只是用了jvm工具把代码中存在的问题找了出来。我们进行jvm的主要目的是尽量减少停顿时间，提高系统的吞吐量。但是如果我们没有对系统进行分析就盲目去设置其中的参数，可能会得到更坏的结果，jvm发展到今天，各种默认的参数可能是实验室的人经过多次的测试来做平衡的，适用大多数的应用场景。如果你认为你的jvm确实有调优的必要，也务必要取样分析，最后还得慢慢多次调节，才有可能得到更优的效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;好了，今天就到这儿吧，我是冰河，我们下期见~~&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9281a42de0566df0d10cc3a0cdc1dded</guid>
<title>[推荐] 从零打造 Instagram</title>
<link>https://toutiao.io/k/hufqvji</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;article&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;Instagram是全球最大的照片、视频分享社区，如果让我们自己设计一个Instagram这样的服务，应该怎么做呢？这篇文章解析了Instagram的功能和架构，从中我们可以看到设计一个内容分享服务所需要关注的部分。原文：Instagram System Architecture&lt;span&gt;[1]&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkYgmP5bxr4BnkLICz0NUnl4VBFperNf5840Gib4iclwqJlZpJXRvNRhfw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;625&quot;/&gt;&lt;/p&gt;&lt;p&gt;Instagram是一个免费的照片和视频分享社交网络，有很多人每天在上面分享故事，记录生活中的点点滴滴。&lt;/p&gt;&lt;h4&gt;功能性需求&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;用户可以上传照片和视频&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户可以查看照片和视频&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户可以根据照片标题进行搜索&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户可以关注/取消关注其他用户&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户可以通过搜索栏搜索用户id&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;为关注的每个用户创建信息流&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可以把照片存档&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可以通过聊天窗口分享故事&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可以拉黑/限制其他用户&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可以在其他用户的帖子下面点赞和评论&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户可以发帖&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3376436781609196&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkxPNuKGbw5bc0hnkw1WX5oOCR00X71lOO90RjicEDX8hkZnwv6p8P1Rg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;696&quot;/&gt;&lt;/p&gt;&lt;h4&gt;非功能性需求&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;高可扩展性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;高一致性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;高可用性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;高可靠性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户数据应该是持久化的（任何上传的照片都不应该丢失）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;生成信息流的最大延迟是150毫秒&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;接下来我们做一下&lt;span&gt;系统容量估算&lt;/span&gt;。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;假设注册用户 = 5亿&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;30%的活跃用户 = 1.5亿&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;注册名人人数 = 10k&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;读请求数 = 100 *上传(写)请求数&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;高峰时刻，假设平均流量 = X，目标处理上限是6X&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;活跃用户：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;每周发帖3次，每个帖子包含1 MB的图片和文本&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每个帖子至少收到10个赞和2-3条评论&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;关注100个用户，有50个粉丝&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每天刷新2次信息流&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;名人：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;每周发帖2次，每个帖子包含大于500K的图片和文本&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每个帖子至少收到50K个赞和至少1K条评论&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;拥有500万粉丝&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每天刷新2次信息流&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;每秒请求数（QPS）：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;发帖&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;点赞&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;评论&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;4&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;关注信息流&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;5&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;数据量&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;64base([‘a-z’,‘A-Z’,‘0–9’,‘-’,‘_’])编码的user_id，需要5 bits ~ 1Byte&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;500 Million + 10K * 5 bits ~ 1 Byte = 1G user&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;容量估计：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;每天上传的活跃用户 = 100万&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每天上传的照片 = 500万张&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每天每秒上传的照片 = 57张照片&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;平均照片大小 = 150 KB&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每天存储开销 = 500万* 150KB = 716GB&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据保存10年，所需存储容量为716 GB * 365 * 10年 = 2553 TB ≈ 2.6 PB&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;日活跃用户查看 = 1000万&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每小时的信息流产生量为1000万，即2800 RPS(每秒请求数)。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果用户每天搜索一次，那就是每天1000万次搜索，也就是115个RPS。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;hr/&gt;&lt;h4&gt;系统组件设计&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5037878787878788&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkRqLeUR9ibkSsicLALrdzWxPibBEwFZpoO3To17RyL8M7xLScsF6z8wYHg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;528&quot;/&gt;&lt;/p&gt;&lt;p&gt;因此，更好的方法是用2个数据库分别处理读写操作。此外，分离照片的读写请求可以帮助我们独立的扩展和优化每个过程。下图显示了读写的过程。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44567219152854515&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkFZicQrFia4cTpvm6ZdicUPOxBKZoiatFVFLZd8NMpPibUroo4BGaAtyeRicQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;543&quot;/&gt;&lt;/p&gt;&lt;h5&gt;1. 信息流生成服务（News Feed Generation services）&lt;/h5&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;为用户更新所关注的用户的最新帖子&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每个用户的信息流都是独一无二的，组合非常复杂&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;为了生成新的信息流，系统必须获取这些照片的元数据(喜欢、评论、时间、位置等)，并将其传递给排名算法，以决定哪些照片应该根据元数据安排在信息流中&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;后端需要同时查询大量的表，然后使用预定义的参数对它们进行排序，这种方法将导致更高的延迟，需要大量的时间来生成新的信息流&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;因此，可以采用预生成的信息流。创建专门用于生成每个用户独有信息流的服务器，并将其结果存储在单独的信息流表中。当用户点击更新时，直接从数据库中读取信息流并显示给用户。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5&gt;2. 提供信息流（Serving the News Feed）&lt;/h5&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;推模式（Push）&lt;/span&gt; — 当用户上传了新的照片/视频，他/她的所有粉丝都会获得更新。如果用户关注了很多人或名人，服务器就必须非常频繁的向用户推送更新。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;拉模式（Pull）&lt;/span&gt; — 用户主动刷新他们的信息流(向服务器发出一个拉取请求)。在用户刷新之前，新帖子是不可见的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;混合模式（Hybrid Approach）&lt;/span&gt; — 对拥有大量粉丝的名人用户应用拉模式，普通用户采用推模式。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5&gt;3. 负载均衡（Load Balancing）&lt;/h5&gt;&lt;hr/&gt;&lt;h4&gt;数据架构&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4835294117647059&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkicf91n5kVWlM88ia8S5o3a8UMHtlns0h4Bzl1hicJ1E5kns3GSiaatkAZA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;850&quot;/&gt;&lt;/p&gt;&lt;h5&gt;数据库设计&lt;/h5&gt;&lt;p&gt;&lt;span&gt;1. 用户相关数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 照片相关数据（AWS S3）&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;photo id&lt;/span&gt;（主键）：10字节长度的唯一照片id，用于标识每一张照片&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;UserId&lt;/span&gt;：上传照片的用户id&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Path&lt;/span&gt;：存放照片的对象存储路径/URL&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Latitude &amp;amp; Longitude（纬度和经度）&lt;/span&gt;：存储这些信息来找到照片的位置&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Date &amp;amp; time（日期和时间）&lt;/span&gt;：照片上传的日期和时间戳&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49335548172757476&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkze1bEqtBwAlOkML5cB0ff043F7sNy6x5HeILZZe1XyEFf6sLhKmuKA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;602&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. 用户关注和粉丝相关数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5905882352941176&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkoyXKHeAqXXNK804hsXVGNPBxqiclo1TCS8FJVRkOeL68TMpETSBy6ibw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;425&quot;/&gt;&lt;/p&gt;&lt;p&gt;因此，我们需要两种不同的数据库：&lt;br/&gt;1）关系型数据库（MySQL）&lt;br/&gt;2）NoSQL数据库（Cassandra）&lt;/p&gt;&lt;h5&gt;数据模型&lt;/h5&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24142857142857144&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkDhicUtj3Myl2Lycy0TvLJpVZpanv2ZzcfLGEEwxRicvibqPA6aJsmPhLw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1742857142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkmZgdic3I84RsRnL0gQTbYdAkUlyoaks1whI3K9icb1ME9kzR9zeWr71A/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.82&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkMcVTo5uDlwpPDZIhyj7s8zBHrdyLjKVoqQW2dtmmGKxMuqaziaB2N4Q/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7171428571428572&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkU0pbsqT36wocwcICLeic6miaSmlOExBjcfGTKPHkcMpDicibgIKqvoLyJA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;典型查询&lt;/span&gt;：&lt;/p&gt;&lt;hr/&gt;&lt;h4&gt;接口/API&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;create_post(user_id, image, text, timestamp) -&amp;gt; success/failure&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;comment_post(user_id, post_id, comment, timestamp) -&amp;gt; success/failure&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;like_post(user_id, post_id, timestamp) -&amp;gt; success/failure&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;get_follow_feed(user_id, timestamp) -&amp;gt; list of newest posts from user follow list, ordered by time, limit 20&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;get_profile_feed(user_id, user2_id, timestamp) -&amp;gt; list of newest posts from user2, ordered by time, limit 20&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;hr/&gt;&lt;h4&gt;系统架构&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3514285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkTLTERrvjwxBC5eSCMu0XCRo7D3J5FiccFWJ3Kian8b2qdIUCdXlWVZKA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7114285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkiaXgIodH7DiaYyjntqn5Q6bWoho6jJ1KjRs0AltnJ75wR28flm4URWGw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;发帖&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5571428571428572&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkBBSUSLfHG9ZhBA9icRM2AH0G5jCmnHpzK9iblo0jUHZuIzL4kydt9IYw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;信息流&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3585714285714286&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkJCnpgt4242jCVAyIVCJr6RPV9Y0zfQrTQrSKW982lP9iaN1ZiaWqMVxw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;进一步细化&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;发帖&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6928571428571428&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkCXZXTTIBtUfVCpbAqdljDZd0HHIp5YVD9K9LLxQjRoRDCl7al1ysMg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;信息流&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4514285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkOx9dpib3C2kFZXqCeRV9DcoQLc9Fq4ZtDRb2ib3hG9roHDpbNr9zw6hg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8485714285714285&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkp3ic6DbUU4PE5sBfPGYnRzkdEmma1pQgjAm2WBBsrenU8OwHBTbKQ2g/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6728571428571428&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnkuKnTFebwY06gicf4z7GcfO117v7LqHVtYJc3yh9ulPPcjOf2nia1ib2HQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9557142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0U6eonmbHcwT7VzJsrv7rnk1slyVp0NO6ZOwa0yTkU6ibl2EnxYxp41G4TchpKHxA7baDJ02GetxJg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;hr/&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;延伸阅读：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Instagram Engineering: https://medium.com/@InstagramEng&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Instagram System Design: https://youtu.be/da7mdMz0g0g&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Designing Instagram: https://www.educative.io/courses/grokking-the-system-design-interview/m2yDVZnQ8lG&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Design Photo Sharing Platform - Instagram: https://techtakshila.com/system-design-interview/chapter-4/&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Designing Instagram: https://www.codercrunch.com/design/634265/designing-instagram&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Designing Instagram Architecture: https://nlogn.in/designing-instagram-architecture-system-design/&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;System Design Analysis of Instagram: https://towardsdatascience.com/system-design-analysis-of-instagram-51cd25093971&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;References:&lt;/span&gt;&lt;br/&gt;[1] Instagram System Architecture: https://medium.com/interviewnoodle/instagram-system-architecture-fdbec22e48ee&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。&lt;br/&gt;微信公众号：DeepNoMind&lt;/p&gt;&lt;/blockquote&gt;&lt;/article&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>