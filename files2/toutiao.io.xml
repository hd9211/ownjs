<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>52700d0932c1be83fc86d3a0335cfff4</guid>
<title>浅谈 Java 中的 AutoCloseable 接口</title>
<link>https://toutiao.io/k/znohjci</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Closes this resource, relinquishing any underlying resources. This method is invoked automatically on objects managed by the try-with-resources statement.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;While this interface method is declared to throw Exception, implementers are strongly encouraged to declare concrete implementations of the close method to throw more specific exceptions, or to throw no exception at all if the close operation cannot fail.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Cases where the close operation may fail require careful attention by implementers. It is strongly advised to relinquish the underlying resources and to internally mark the resource as closed, prior to throwing the exception. The close method is unlikely to be invoked more than once and so this ensures that the resources are released in a timely manner. Furthermore it reduces problems that could arise when the resource wraps, or is wrapped, by another resource.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Implementers of this interface are also strongly advised to not have the close method throw InterruptedException.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;This exception interacts with a thread&#x27;s interrupted status, and runtime misbehavior is likely to occur if an InterruptedException is suppressed.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;More generally, if it would cause problems for an exception to be suppressed, the AutoCloseable.close method should not throw it.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Note that unlike the java.io.Closeable#close close method of java.io.Closeable, this close method is not required to be idempotent. In other words, calling this close method more than once may have some visible side effect, unlike Closeable.close which is required to have no effect if called more than once.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;However, implementers of this interface are strongly encouraged to make their close methods idempotent.&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a13fc38fcf5d9f04e0e4337893d09f5e</guid>
<title>[推荐] [译] 何时使用 Rust 和何时使用 Golang？</title>
<link>https://toutiao.io/k/z6p6anw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6671232876712329&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UWba2ryLMqm2lSGu3l8woJasfoSWefXzWUb2qTiaX8WcYsNsx4F7qza5oHcHhXsgQhIp1ht8Ih1ldzkgaKuUeTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;730&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Golang 和 Rust 之间有明显的区别。Golang 更加注重构建可以无限扩展的 Web API 和小型服务，尤其是在 goroutine 的强大支持下。Rust 也可以用于小型服务，但是从开发人员的经验来看，事情要困难得多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Rust 非常适合处理大量数据和其他 CPU 密集型操作，例如执行算法。这是 Rust 超过 Golang 的最大优势。要求高性能的项目通常更适合 Rust。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本教程中，我们将就 Golang 和 Rust 进行比较和对比，评估这两种编程语言的性能，并发性，内存管理和整体开发人员体验。我们还将概述这些元素，以帮助您一目了然地为项目选择正确的语言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您刚开始使用 Rust，那么在继续阅读之前，最好先阅读一下&lt;span&gt;初学者指南&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您全都都准备好了，那就让我们开始吧！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;性能&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Golang 最初是由 Google 的工程师设计的，于 2009 年向公众推出。它的创建是为 C++提供替代方案，该替代方案易于学习和编码，并且经过优化可在多核 CPU 上运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从那时起，Golang 对于希望利用该语言提供的并发性的开发人员来说非常有用。该语言提供了 goroutine，使您可以将函数作为 goroutine 运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Golang 的一大优势是您可以轻松使用 goroutines。只需将&lt;code&gt;go&lt;/code&gt;添加到函数前即可使其作为 goroutine 运行。Golang 的并发模型允许您跨多个 CPU 内核部署工作负载，从而使其成为一种非常有效的语言。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(from &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;3&lt;/span&gt;; i++ {&lt;br/&gt;        fmt.Println(from, &lt;span&gt;&quot;:&quot;&lt;/span&gt;, i)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;    f(&lt;span&gt;&quot;direct&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;go&lt;/span&gt; f(&lt;span&gt;&quot;goroutine&quot;&lt;/span&gt;)&lt;br/&gt;    time.Sleep(time.Second)&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;done&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管有多核 CPU 支持，Rust 仍然跑赢 Golang。Rust 在执行算法和资源密集型操作方面效率更高。该&lt;span&gt;基准测试游戏&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;比较了 rust 和 golang 的不同算法，如二叉树。对于所有经过测试的算法，Rust 至少快 30％；在二叉树计算的情况下，最高可达 1,000％。&lt;span&gt;Bitbucket 的&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;一项研究表明，Rust 与 C++的性能相似。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6680555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UWba2ryLMqm2lSGu3l8woJasfoSWefXz3Z8x7jFeiaHleFQBURFps0bFfArzvohAtf5AmK6uibNxyfK3tLhHl5Wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;（来源：&lt;span&gt;基准测试游戏&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;）&lt;/em&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;并发&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上所述，Golang 支持并发。例如，假设您正在运行一个处理 API 请求的 Web 服务器。您可以使用 Golang 的 goroutine 程序将每个请求作为 goroutine 运行，通过将任务分发到所有可用的 CPU 内核来最大程度地提高效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Goroutines 是 Golang 内置功能的一部分，而 Rust 仅支持本地 async/await 语法来支持并发。因此，在并发方面，Golang 的开发人员有经验优势。但是，Rust 在保证内存安全方面要好得多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是 Rust 的简化线程的示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;use&lt;/span&gt; std::thread;&lt;br/&gt;&lt;span&gt;use&lt;/span&gt; std::time::Duration;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;   &lt;span&gt;// 1. create a new thread&lt;/span&gt;&lt;br/&gt;   thread::spawn(|| {&lt;br/&gt;      &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;..&lt;span&gt;10&lt;/span&gt; {&lt;br/&gt;         &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;thread: number {}!&quot;&lt;/span&gt;, i);&lt;br/&gt;         thread::sleep(Duration::from_millis(&lt;span&gt;100&lt;/span&gt;));&lt;br/&gt;      }&lt;br/&gt;   });&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;hi from the main thread!&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发一直是开发人员的棘手问题。在不影响开发人员体验的情况下保证内存安全的并发性并不是一项容易的任务。但是，这种极端的安全重点导致创建了&lt;span&gt;可证明正确的并发&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;。Rust 尝试使用所有权概念来防止未经请求的资源访问，以防止出现内存安全错误。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Rust 提供了四种不同的并发范例，以帮助您避免常见的内存安全陷阱。我们将仔细研究两个常见的范例：channel 和锁。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Channel&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;channel&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt; 有助于从一个线程传送消息到另一个。虽然 Golang 也存在此概念，但 Rust 允许您将&lt;span&gt;指针&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;从一个线程转移到另一个线程，以避免争用资源。通过传递指针，Rust 可以对 channel 强制执行线程隔离。同样，Rust 在并发模型方面表现出对内存安全的痴迷。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;锁&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仅当持有&lt;span&gt;锁&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;时才能访问数据。Rust 依赖于锁定数据而不是 cod 的原理，而 cod 经常在诸如 Java 之类的编程语言中找到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有关所有权和所有并发范例的更多详细信息，请查看“&lt;span&gt;使用 Rust 进行无所畏惧的并发&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;”。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;内存安全&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;较早的所有权概念是 Rust 的主要卖点之一。Rust 将&lt;span&gt;类型安全&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt;提升到了新的水平，这对于实现内存安全的并发性也很重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据&lt;span&gt;Bitbucket 博客&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt;，“ Rust 非常严格和繁琐的编译器会检查您使用的每个变量以及您引用的每个内存地址。它避免了可能发生的数据争用情况，并通知您未定义的行为。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这意味着由于 Rust 对内存安全性的极度痴迷，您最终不会出现缓冲区溢出或争用情况。但是，这也有其缺点。例如，您在编写代码时必须非常了解内存分配原则。始终保持您的内存安全防护并不容易。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;开发人员体验&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，让我们看一下每种语言的学习曲线。Golang 在设计时考虑了简单性。开发人员经常将其称为“无聊”语言，也就是说，其有限的内置功能集使 Golang 易于学习、使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，Golang 提供了比 C++更简单的替代方案，隐藏了诸如内存安全性和内存分配等方面的内容。Rust 采用了另一种方法，迫使您考虑诸如内存安全性的概念。所有权的概念和传递指针的能力使 Rust 失去了学习的吸引力。当您不断考虑内存安全性时，您的工作效率就会降低，并且您的代码注定会变得更加复杂。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与 Golang 相比，Rust 的学习曲线非常陡峭。值得一提的是，与 Python 和 JavaScript 等动态语言相比，Golang 的学习曲线较为陡峭。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;何时使用 Golang&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 在各种用例中都能很好地工作，使其成为创建 Web API 的 Node.js 的绝佳替代品。正如&lt;span&gt;Loris Cro&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt;指出的那样，“ Go 的并发模型非常适合必须处理多个独立请求的服务器端应用程序”。这正是 Golang 提供 goroutines 的原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，Golang 内置了对 HTTP Web 协议的支持。您可以使用内置的 HTTP 支持快速设计一个小型 API，并将其作为微服务运行。因此，Golang 非常适合微服务架构并满足 API 开发人员的需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简而言之，如果您重视开发速度并且更喜欢语法简单而不是性能，那么 Golang 是一个很好的选择。最重要的是，Golang 提供了更好的代码可读性，这对于大型开发团队而言是一个重要标准。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以下情况下选择 Golang：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;您关心简单性和可读性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;您需要一种简单的语法来快速编写代码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;您想使用支持 Web 开发的更灵活的语言&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;何时使用 Rust&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当性能很重要时，例如在处理大量数据时，Rust 是一个不错的选择。此外，Rust 为您提供了对线程行为以及线程之间资源共享方式的细粒度控制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一方面，Rust 具有陡峭的学习曲线，并且由于内存安全性的额外复杂性而减慢了开发速度。这并不一定是不利的。Rust 还保证当编译器检查每个数据指针时，您不会遇到内存安全性错误。对于复杂的系统，此保证会派上用场。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以下情况下选择 Rust：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;您关心性能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;您想要对线程进行细粒度的控制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;您重视内存安全而不是简单性&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go vs. Rust：我的大实话&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们从突出相似之处开始。Go 和 Rust 都是开源的，旨在支持微服务架构和并行计算环境。两者都通过并发优化了可用 CPU 内核的利用率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但归根结底，哪种语言是最好的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有很多方法可以解决这个问题。我建议考虑要构建哪种类型的应用程序。Golang 可很好地用于创建 Web 应用程序和 API，这些应用程序和 API 利用其内置的并发功能，同时支持微服务体系结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;您还可以使用 Rust 来开发 Web API，但并不是在设计时考虑到此用例。Rust 对内存安全性的关注增加了复杂性和开发时间，尤其是对于相当简单的 Web API。但是，对代码的大量控制使您可以编写更优化，内存效率更高且性能更高的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简而言之，Golang 与 Rust 的争论实际上是一个简单与安全的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有关更多观点，请查看“&lt;span&gt;在 Go 和 Rust 之间选择&lt;/span&gt;&lt;sup&gt;[13]&lt;/sup&gt;”。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;LogRocket：全面了解线上 Rust 应用程序&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调试 Rust 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪 Rust 应用程序的性能，自动显示错误以及跟踪缓慢的网络请求和加载时间感兴趣，请&lt;span&gt;尝试 LogRocket&lt;/span&gt;&lt;sup&gt;[14]&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5641666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UWba2ryLMqm2lSGu3l8woJasfoSWefXzicMmuvXWfZBD6vwrFFqvVWQBhs8NY0G1DCqbicVkYrrBWviaY3uFMnx9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LogRocket&lt;/span&gt;&lt;sup&gt;[15]&lt;/sup&gt;就像 Web 应用程序的 DVR，实际上记录了 Rust 应用程序中发生的所有事情。您可以汇总并报告问题发生时应用程序所处的状态，而不用猜测为什么会发生问题。LogRocket 还监视您的应用程序的性能，报告诸如客户端 CPU 负载，客户端内存使用情况等指标。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原文链接：https://blog.logrocket.com/when-to-use-rust-and-when-to-use-golang/&lt;/p&gt;&lt;p&gt;原文作者：Michiel Mulders&lt;/p&gt;&lt;p&gt;译者：polarisxu&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;初学者指南: &lt;em&gt;https://blog.logrocket.com/getting-up-to-speed-with-rust/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;基准测试游戏: &lt;em&gt;https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust-go.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;Bitbucket 的: &lt;em&gt;https://bitbucket.org/blog/why-rust&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;基准测试游戏: &lt;em&gt;https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust-go.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;可证明正确的并发: &lt;em&gt;https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;channel: &lt;em&gt;https://doc.rust-lang.org/stable/rust-by-example/std_misc/channels.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;指针: &lt;em&gt;https://doc.rust-lang.org/std/primitive.pointer.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;锁: &lt;em&gt;https://doc.rust-lang.org/std/sync/struct.Mutex.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;使用 Rust 进行无所畏惧的并发: &lt;em&gt;https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10]&lt;/span&gt;&lt;p&gt;类型安全: &lt;em&gt;https://en.wikipedia.org/wiki/Type_safety&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11]&lt;/span&gt;&lt;p&gt;Bitbucket 博客: &lt;em&gt;https://bitbucket.org/blog/why-rust&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12]&lt;/span&gt;&lt;p&gt;Loris Cro: &lt;em&gt;https://kristoff.it/blog/why-go-and-not-rust/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[13]&lt;/span&gt;&lt;p&gt;在 Go 和 Rust 之间选择: &lt;em&gt;https://sdtimes.com/softwaredev/the-developers-dilemma-choosing-between-go-and-rust/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[14]&lt;/span&gt;&lt;p&gt;尝试 LogRocket: &lt;em&gt;https://logrocket.com/signup&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[15]&lt;/span&gt;&lt;p&gt;LogRocket: &lt;em&gt;https://logrocket.com/signup&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b578e03898ef697e2d6c67eb2b27ab6c</guid>
<title>[推荐] 万亿级数据应该怎么迁移？</title>
<link>https://toutiao.io/k/qk70u1x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;blockquote&gt;&lt;p&gt;之前写过一篇文章:&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA5Mjg2MDQ5NQ==&amp;amp;mid=2452509718&amp;amp;idx=1&amp;amp;sn=139b17d40b8afd6291537c12883476b1&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;binlog还能这么用之Canal篇&lt;/a&gt;，在里面介绍了一些增量数据迁移的一些方法，但是对于整体的数据的迁移介绍得不是很深，这里想对迁移数据整体做一个介绍，希望能帮助到大家。&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;&lt;span&gt;背景&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h1&gt;&lt;p&gt;在星爷的《大话西游》中有一句非常出名的台词：“曾经有一份真挚的感情摆在我的面前我没有珍惜，等我失去的时候才追悔莫及，人间最痛苦的事莫过于此，如果上天能给我一次再来一次的机会，我会对哪个女孩说三个字：我爱你，如果非要在这份爱上加一个期限，我希望是一万年！”在我们开发人员的眼中，这个感情就和我们数据库中的数据一样，我们多希望他一万年都不改变，但是往往事与愿违，随着公司的不断发展，业务的不断变更，我们对数据的要求也在不断的变化，大概有下面的几种情况：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;分库分表&lt;/strong&gt;：业务发展越来越快，导致单机数据库承受的压力越来越大，数据量也越来越多，这个时候通常会使用分库的方法去解决这个问题，将数据库的流量均分到不同的机器上。从单机数据库到分库这个过程，我们就需要完整的迁移我们的数据，我们才能成功的分库的方式上使用我们的数据。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;更换存储介质&lt;/strong&gt;：上面介绍的分库，一般来说我们迁移完之后，存储介质依然是同样的，比如说之前使用的是单机Mysql，分库之后就变成了多台机器的Mysql，我们的数据库表的字段都没有发生变化,迁移来说相对比较简单。有时候我们分库分表并不能解决所有的问题，如果我们需要很多复杂的查询，这个时候使用Mysql可能就不是一个靠谱的方案，那么我们就需要替换查询的存储介质，比如使用elasticsearch，这种的迁移就会稍微要复杂一些，涉及到不同存储介质的数据转换。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;切换新系统&lt;/strong&gt;：一般公司在高速发展中，一定会出现很多为了速度快然后重复建设的项目，当公司再一定时间段的时候，往往这部分项目会被合并，变成一个平台或者中台，比如我们一些会员系统，电商系统等等。这个时候往往就会面临一个问题，将老的系统中的数据需要迁移到新的系统中，这个时候就更加复杂了，有可能不仅是存储介质有变动，有可能项目语言也不同，从更上层的角度来看，部门有可能也不同，所以这种数据迁移的难度是比较高，风险也更加的大。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在实际业务开发中，我们会根据不同的情况来做出不同的迁移方案，接下来我们来讨论一下到底应该怎么迁移数据。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;数据迁移&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h1&gt;&lt;p&gt;数据迁移其实不是一蹴而就的，每一次数据迁移都需要一段漫长的时间，有可能是一周，有可能是几个月，通常来说我们迁移数据的过程基本都和下图差不多：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5148861646234676&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/WLIGprPy3z796G2KhBiafFU2uR8Nyqgahq7gXVzzmjUic2uZDN1mvjgPJsc3uwaQ6H3nugC7rL2O7qYzvh2QnoOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;571&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;首先我们需要将我们数据库已经存在的数据进行批量的迁移，然后需要处理新增的这部分数据，需要实时的把这部分数据在写完原本的数据库之后然后写到我们的新的存储，在这一过程中我们需要不断的进行数据校验。当我们校验基本问题不大的时候，然后进行切流操作，直到完全切流之后，我们就可以不用再进行数据校验和增量数据迁移。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;存量数据迁移&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;首先我们来说一下存量数据迁移应该怎么做，存量数据迁移在开源社区中搜索了一圈发现没有太好用的工具，目前来说阿里云的DTS提供了存量数据迁移，DTS支持同构和异构不同数据源之间的迁移，基本支持业界常见的数据库比如Mysql,Orcale,SQL Server等等。DTS比较适合我们之前说的前两个场景，一个是分库的场景，如果使用的是阿里云的DRDS那么就可以直接将数据通过DTS迁移到DRDS,另外一个是数据异构的场景，无论是Redis还是ES，DTS都支持直接进行迁移。&lt;/p&gt;&lt;p&gt;那么DTS的存量迁移怎么做的呢？其实比较简单大概就是下面几个步骤：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当存量迁移任务启动的时候，我们获取当前需要迁移的最大的id和最小id&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;设置一个分段，比如1万，从最小id开始每次查询1万的数据给DTS服务器，交给DTS处理。sql如下：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; table_name &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &amp;gt; curId &lt;span&gt;and&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &amp;lt; curId + &lt;span&gt;10000&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.当id大于maxId之后，存量数据迁移任务结束&lt;/p&gt;&lt;p&gt;当然我们在实际的迁移过程中可能不会去使用阿里云，或者说在我们的第三个场景下，我们的数据库字段之间需要做很多转换，DTS不支持，那么我们就可以模仿DTS的做法，通过分段批量读取数据的方式来迁移数据，这里需要注意的是我们批量迁移数据的时候需要控制分段的大小，以及频率，防止影响我们线上的正常运行。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;增量数据迁移&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;存量数据的迁移方案比较有限，但是增量的数据迁移方法就是百花齐放了，一般来说我们有下面的几种方法：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DTS: 阿里云的DTS算是一条龙服务了，在提供存量数据迁移的同时也提供了增量数据迁移，只不过需要按量收费。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;服务双写：比较适合于系统没有切换的迁移，也就是只换了存储但是系统还是同一个，比如说分库分表，redis数据同步等，这个的做法比较简单直接在代码里面同步的去写入需要迁移的数据，但是由于不是同一个数据库就不能保证事务，有可能导致迁移数据的时候会出现数据丢失，这个过程通过后续的数据校验会进行解决。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;MQ异步写入：这个可以适用于所有的场景，当有数据修改的时候发送一个MQ消息，消费者收到这个消息之后再进行数据更新。这个和上面的双写有点类似，但是他把数据库的操作变成了MQ异步了出问题的概率就会小很多&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;监听binlog: 我们可以使用之前说过的canal或者其他的一些开源的如databus去进行binlog监听，监听binlog的方式 就和上面的消息MQ方式一样，只是发送消息的这一步被我们省略了。这个方式的一个开发量来说基本是最小的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这么多种方式我们应该使用哪种呢？我个人来说是比较推荐监听binlog的做法的，监听binlog减少开发成本，我们只需要实现consumer逻辑即可，数据能保证一致性，因为是监听的binlog这里不需要担心之前双写的时候不是一个事务的问题。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;数据校验&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;前面所说的所有方案，虽然有很多是成熟的云服务(dts)或者中间件(canal)，但是他们都有可能出现一些数据丢失，出现数据丢失的情况整体来说还是比较少，但是非常难排查，有可能是dts或者canal不小心抖了一下，又或者是接收数据的时候不小心导致的丢失。既然我们没有办法避免我们的数据在迁移的过程中丢失，那么我们应该通过其他手段来进行校正。&lt;/p&gt;&lt;p&gt;通常来说我们迁移数据的时候都会有数据校验这一个步骤，但是在不同团队可能会选取不同的数据校验方案：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;之前在美团的时候，我们会做一个双读，也就是我们所有的读取都会从新的里面读取一份，但是返回的还是老的，这个时候我们需要做这部分数据的校验，如果有问题可以发出报警人工修复或者自动修复。通过这种方式，我们常用的数据就能很快的进行一个修复，当然也会不定时的去跑一个全量的数据check，只是这种check出来修复数据的时间就比较滞后。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;现在在猿辅导之后，我们没有采用之前的那种方式，因为双读check虽然能很快发现数据的不对，但是我们并没有对这部分数据有那么高的一个实时性校验并且双读的一个代码开发量还是稍微比较大的，但是又不能依靠不定时全量check去保证，这样就会导致我们的数据校验时间会非常的延长。我们采取了一个折中的方法，我们借鉴了对账里面的T+1的一个思路，我们每天凌晨获取老数据库中昨天更新的数据，然后和我们新数据库中的数据做一一比对，如果有数据不一样或者数据缺失，我们都可以立马进行一个修复。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;当然在实际开发过程中我们也需要注意下面几点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据校验任务的一个正确性如何保证，校验任务本来就是去校正其他数据的，但是如果他自身出现了问题，就失去了校验的意义，这里目前来说只能靠review代码这种方式去保证校验任务的正确性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;校验任务的时候需要注意日志的打印，有时候出现问题可能是直接所有数据出现问题，那么校验任务就有可能会打出大量的错误日志，然后进行报警，有可能会将系统打挂，或者说影响其他人的服务。这里如果要简单一点搞，可以将一些非人工处理的报警搞成warn，复杂一点搞得话，可以封装一个工具，某个error打印再某个时间段超过一定量然后就不用再打印了。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;校验任务注意不要影响线上运行的服务，通常校验任务会写很多批查询的语句，会出现批量扫表的情况，如果代码没有写好很容易导致数据库挂掉。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;切流&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;当我们数据校验基本没有报错了之后，说明我们的迁移程序是比较稳定的了，那么我们就可以直接使用我们新的数据了吗？当然是不可以的，如果我们一把切换了，顺利的话当然是很好的，如果出现问题了，那么就会影响所有的用户。&lt;/p&gt;&lt;p&gt;所以我们接下来就需要进行灰度，也就是切流。对于不同的业务切流的的维度会不一样，对于用户维度的切流，我们通常会以userId的取模的方式去进行切流，对于租户或者商家维度的业务，就需要按照租户id取模的方式去切流。这个切流需要制定好一个切流计划，在什么时间段，放出多少的流量，并且切流的时候一定要选择流量比较少的时候进行切流，每一次切流都需要对日志做详细的观察，出现问题尽早修复，流量的一个放出过程是一个由慢到快的过程，比如最开始是以1%的量去不断叠加的，到后面的时候我们直接以10%，20%的量去快速放量。因为如果出现问题的话往往在小流量的时候就会发现，如果小流量没有问题那么后续就可以快速放量。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;注意主键ID&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;在迁移数据的过程中特别要注意的是主键ID，在上面双写的方案中也提到过主键ID需要双写的时候手动的去指定，防止ID生成顺序错误。&lt;/p&gt;&lt;p&gt;如果我们是因为分库分表而进行迁移，就需要考虑我们以后的主键Id就不能是自增id,需要使用分布式id，这里比较推荐的是美团开源的leaf，他支持两种模式一种是雪花算法趋势递增，但是所有的id都是Long型，适合于一些支持Long为id的应用。还有一种是号段模式，这种会根据你设置的一个基础id，从这个上面不断的增加。并且基本都走的是内存生成，性能也是非常的快。&lt;/p&gt;&lt;p&gt;当然我们还有种情况是我们需要迁移系统，之前系统的主键id在新系统中已经有了，那么我们的id就需要做一些映射。如果我们在迁移系统的时候已经知道未来大概有哪些系统会迁移进来，我们就可以采用预留的方式，比如A系统现在的数据是1到1亿，B系统的数据也是1到1亿，我们现在需要将A,B两个系统合并成新系统，那么我们可以稍微预估一些Buffer,比如给A系统留1到1.5亿，这样A就不需要进行映射，B系统是1.5亿到3亿，那么我们转换成老系统Id的时候就需要减去1.5亿，最后我们新系统的新的Id就从3亿开始递增。&lt;br/&gt;但是如果系统中没有做规划的预留段怎么办呢？可以通过下面两种方式：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;需要新增一个表，将老系统的id和新系统的id做一个映射记录，这个工作量还是比较大的，因为我们一般迁移都会涉及几十上百张表，记录的成本还是非常的高。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果id是Long型的话，我们可以好好利用long是64位这个因素，我们可以制定一个规则，我们新系统的id都是从一个比较大的数开始，比如从大于Int的数开始，将小Int的那部分数都可以留给我们的老系统做Id迁移，比如我们上面的1.5亿的数据量，其实只用了28位，我们的Int是32位，那么还有4位可以使用，这个4位可以代表16个系统做迁移，当然如果规划中有更多的系统做迁移，可以将新系统的id起始点设置得更大一点。如下图所示：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4451476793248945&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/WLIGprPy3z796G2KhBiafFU2uR8NyqgahK8ZazUiaScHIpWMnWYNJkXA3u5QUibCoicDg3WEqdcntEo4RyeySYV8mQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;474&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h1&gt;&lt;p&gt;最后简单来总结下这个套路，其实就是四个步骤，一个注意：存量，增量，校验，切流，最后再注意一下id。不管是多大量级的数据，基本上按照这个套路来迁移就不会出现大的问题。希望能在大家的后续迁移数据工作中，这篇文章能帮助到你。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6f8d185fd5a0627344cdc836c03f3721</guid>
<title>[推荐] 爱了！一个现代化的 Git CLI 客户端，一堆命令不用记了</title>
<link>https://toutiao.io/k/s3pgs9r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;span&gt;关注公众号 “&lt;/span&gt;&lt;span&gt;&lt;span&gt;转角遇到GitHub&lt;/span&gt;&lt;/span&gt;&lt;span&gt;” ，每天推荐给你优秀开源项目&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是欧盆索思（opensource），每天为你带来优秀的开源项目！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看一张动图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.290625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/lkYNiaZsfpqbfTtJ24frNJpobbiczdSTj9oD67Zl7o7Jk1yKia0KoosN5fe77camiatzBGX10WR5lR4IMErePVoWtQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天推荐的这个工具是：bit，它是构建在 git 之上的实验性现代化 git CLI，可提供令人满意的默认值和其他优点。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;命令和 flag 建议，以帮助你浏览 git 为您提供的众多选项；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;bit add、bit checkout 能自动完成分支名和文件名；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自动获取（fetch）和分支快速转发（fast-forwarding），减少合并冲突的可能性；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;建议与 git 别名一起使用；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一些新命令，如 bit sync 等，能极大地简化了工作流程；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;来自 git-extras 的命令，例如 bit release &amp;amp; bit info；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;与 git 完全兼容，允许您在需要时回退到 git。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目地址：https://github.com/chriswalz/bit，Star 数：2.7k+。这是一个 Go 项目。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;安装&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）最简单的安装方式&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ curl -sf https://gobinaries.com/chriswalz/bit | sh; curl -sf https://gobinaries.com/chriswalz/bit/bitcomplete | sh &amp;amp;&amp;amp; &lt;span&gt;echo&lt;/span&gt; y | COMP_INSTALL=1 bitcomplete&lt;br/&gt;$ bit&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）也可以直接从这里下载&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/chriswalz/bit/releases&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3）如果安装了 Go，则可以从源码编译&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;确保使用了 go module。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ go get github.com/chriswalz/bit&lt;br/&gt;$ bit&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，bit 依赖 git。所以你本地需要安装 git。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前支持如下平台：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;iTerm2 (macOS)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Terminal.app (macOS)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Command Prompt (Windows)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;WSL/Windows Subsystem for Linux (Windows)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gnome-terminal (Ubuntu)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;bit 特有的命令&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、bit save [commit message]&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个新的提交。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、bit sync&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同步对 origin 分支的更改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大部分时候，bit sync 相当于 &lt;code&gt;bit commit -m &quot;I can still use git commands&quot;&lt;/code&gt;, &lt;code&gt;bit pull -r origin master&lt;/code&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;bit 常见工作流&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过例子演示 bit 常见工作流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、切换分支&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ bit&lt;br/&gt;&amp;gt; bit switch example-branch&lt;br/&gt;? Branch does not exist. Do you want to create it? Yes&lt;br/&gt;Switched to a new branch &lt;span&gt;&#x27;example-branch&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、做一些改动&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ bit add *&lt;br/&gt;$ bit save &lt;span&gt;&quot;add important feature&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、做其他改动&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ bit save&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、push 改变到 origin&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ bit sync&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5、一段时间后，可以再同步别人的修改&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ bit sync&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般都直接输入 bit，然后回车。接着输入会自动提示，如开始的动图。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;文末&lt;strong&gt;「阅读原文」&lt;/strong&gt;可直达项目首页。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;今天的项目大家觉得怎么样吗？如果你喜欢，请在文章底部留言、点赞或关注转发，你的支持就是我持续更新的最大动力！&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;转角遇到GitHub - 送给爱开源的你&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;258&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;258&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lkYNiaZsfpqYm0bG0MRgJIZRoicricTQsNEEbzuja1veleica9PFicSiayqmibQZzSRZBNufMjJIq2tKXpb4VK0DjbibZQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;344&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Git · GitHub · GitLab · Gitee&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7207b9ab5a64afbda98591815971f720</guid>
<title>[推荐] 图解常见的九种设计模式</title>
<link>https://toutiao.io/k/pjsjgsi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在软件工程中，设计模式（Design Pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。根据模式的目的来划分的话，GoF（Gang of Four）设计模式可以分为以下 3 种类型：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYORsOE5icFY5emqIg38W1BFcLLHCtQy8reE1enw9uibroWMVxZlQUqw9g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.33055555555555555&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、创建型模式：用来描述 “如何创建对象”，它的主要特点是 “将对象的创建和使用分离”。包括单例、原型、工厂方法、抽象工厂和建造者 5 种模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、结构型模式：用来描述如何将类或对象按照某种布局组成更大的结构。包括代理、适配器、桥接、装饰、外观、享元和组合 7 种模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、行为型模式：用来识别对象之间的常用交流模式以及如何分配职责。包括模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录和解释器 11 种模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来阿宝哥将结合一些生活中的场景并通过精美的配图，来向大家介绍 9 种常用的设计模式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;一、建造者模式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建造者模式（Builder Pattern）将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一辆小汽车 🚗 通常由 &lt;strong&gt;发动机、底盘、车身和电气设备&lt;/strong&gt; 四大部分组成。汽车电气设备的内部构造很复杂，简单起见，我们只考虑三个部分：引擎、底盘和车身。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYYVUo8Masic9yq0JzwWjiaUtXcd8csBBBK3ysEJXLVH6qoVZbnlElSC6w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.24814814814814815&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在现实生活中，小汽车也是由不同的零部件组装而成，比如上图中我们把小汽车分成引擎、底盘和车身三大部分。下面我们来看一下如何使用建造者模式来造车子。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; Car {&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; engine: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; chassis: &lt;span&gt;string&lt;/span&gt;, &lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; body: &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;  &lt;/span&gt;) {}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; CarBuilder {&lt;br/&gt;  engine!: &lt;span&gt;string&lt;/span&gt;; &lt;span&gt;// 引擎&lt;/span&gt;&lt;br/&gt;  chassis!: &lt;span&gt;string&lt;/span&gt;; &lt;span&gt;// 底盘&lt;/span&gt;&lt;br/&gt;  body!: &lt;span&gt;string&lt;/span&gt;; &lt;span&gt;// 车身&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  addChassis(chassis: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.chassis = chassis;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  addEngine(engine: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.engine = engine;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  addBody(body: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.body = body;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  build() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Car(&lt;span&gt;this&lt;/span&gt;.engine, &lt;span&gt;this&lt;/span&gt;.chassis, &lt;span&gt;this&lt;/span&gt;.body);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以上代码中，我们定义一个 &lt;code&gt;CarBuilder&lt;/code&gt; 类，并提供了 &lt;code&gt;addChassis&lt;/code&gt;、&lt;code&gt;addEngine&lt;/code&gt; 和 &lt;code&gt;addBody&lt;/code&gt; 3 个方法用于组装车子的不同部位，当车子的 3 个部分都组装完成后，调用 &lt;code&gt;build&lt;/code&gt; 方法就可以开始造车。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; car = &lt;span&gt;new&lt;/span&gt; CarBuilder()&lt;br/&gt;  .addEngine(&lt;span&gt;&#x27;v12&#x27;&lt;/span&gt;)&lt;br/&gt;  .addBody(&lt;span&gt;&#x27;镁合金&#x27;&lt;/span&gt;)&lt;br/&gt;  .addChassis(&lt;span&gt;&#x27;复合材料&#x27;&lt;/span&gt;)&lt;br/&gt;  .build();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3 应用场景及案例&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要生成的产品对象的属性相互依赖，需要指定其生成顺序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Github - node-sql-query：https://github.com/dresende/node-sql-query&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;二、工厂模式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在现实生活中，工厂是负责生产产品的，比如牛奶、面包或礼物等，这些产品满足了我们日常的生理需求。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYYozbev3whOjKiciaF6TnbB1nHA5U8oT5pmPebv7XtWas0V0s8kXWQibcQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.35648148148148145&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在众多设计模式当中，有一种被称为工厂模式的设计模式，它提供了创建对象的最佳方式。工厂模式可以分为：&lt;strong&gt;简单工厂模式、工厂方法模式和抽象工厂模式&lt;/strong&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 简单工厂&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单工厂模式又叫 &lt;strong&gt;静态方法模式&lt;/strong&gt;，因为工厂类中定义了一个静态方法用于创建对象。简单工厂让使用者不用知道具体的参数就可以创建出所需的 ”产品“ 类，即使用者可以直接消费产品而不需要知道产品的具体生产细节。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYUWltia1zbFdvpxcrGHC0CEjTT0iacxdXxW3AVicYb2J4TYCsTNsicR7SEw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.4861111111111111&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，阿宝哥模拟了用户购车的流程，小王和小秦分别向 BMW 工厂订购了 BMW730 和 BMW840 型号的车型，接着工厂会先判断用户选择的车型，然后按照对应的模型进行生产并在生产完成后交付给用户。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看一下如何使用简单工厂来描述 BMW 工厂生产指定型号车子的过程。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BMW {&lt;br/&gt;  &lt;span&gt;abstract&lt;/span&gt; run(): &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; BMW730 &lt;span&gt;extends&lt;/span&gt; BMW {&lt;br/&gt;  run(): &lt;span&gt;void&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;BMW730 发动咯&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; BMW840 &lt;span&gt;extends&lt;/span&gt; BMW {&lt;br/&gt;  run(): &lt;span&gt;void&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;BMW840 发动咯&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; BMWFactory {&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; produceBMW(model: &lt;span&gt;&quot;730&quot;&lt;/span&gt; | &lt;span&gt;&quot;840&quot;&lt;/span&gt;): BMW {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (model === &lt;span&gt;&quot;730&quot;&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BMW730();&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BMW840();&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以上代码中，我们定义一个 &lt;code&gt;BMWFactory&lt;/code&gt; 类，该类提供了一个静态的 &lt;code&gt;produceBMW()&lt;/code&gt; 方法，用于根据不同的模型参数来创建不同型号的车子。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; bmw730 = BMWFactory.produceBMW(&lt;span&gt;&quot;730&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; bmw840 = BMWFactory.produceBMW(&lt;span&gt;&quot;840&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;bmw730.run();&lt;br/&gt;bmw840.run();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.3 应用场景&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;工厂类负责创建的对象比较少：由于创建的对象比较少，不会造成工厂方法中业务逻辑过于复杂。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端只需知道传入工厂类静态方法的参数，而不需要关心创建对象的细节。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 工厂方法&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工厂方法模式（Factory Method Pattern）又称为工厂模式，也叫多态工厂（Polymorphic Factory）模式，它属于类创建型模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象， &lt;strong&gt;这样做的目的是将产品类的实例化操作延迟到工厂子类中完成&lt;/strong&gt;，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYKUYSgZ69oEMWbx3nEAUw2Weg0iacMyKMfyiaCjiciaFyU18qskQvchSicUQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.4824074074074074&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，阿宝哥模拟了用户购车的流程，小王和小秦分别向 BMW 730 和 BMW 840 工厂订购了 BMW730 和 BMW840 型号的车子，接着工厂按照对应的模型进行生产并在生产完成后交付给用户。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，我们来看一下如何使用工厂方法来描述 BMW 工厂生产指定型号车子的过程。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BMWFactory {&lt;br/&gt;  &lt;span&gt;abstract&lt;/span&gt; produceBMW(): BMW;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; BMW730Factory &lt;span&gt;extends&lt;/span&gt; BMWFactory {&lt;br/&gt;  produceBMW(): BMW {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BMW730();&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; BMW840Factory &lt;span&gt;extends&lt;/span&gt; BMWFactory {&lt;br/&gt;  produceBMW(): BMW {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BMW840();&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以上代码中，我们分别创建了 &lt;code&gt;BMW730Factory&lt;/code&gt; 和 &lt;code&gt;BMW840Factory&lt;/code&gt; 两个工厂类，然后使用这两个类的实例来生产不同型号的车子。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; bmw730Factory = &lt;span&gt;new&lt;/span&gt; BMW730Factory();&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; bmw840Factory = &lt;span&gt;new&lt;/span&gt; BMW840Factory();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; bmw730 = bmw730Factory.produceBMW();&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; bmw840 = bmw840Factory.produceBMW();&lt;br/&gt;&lt;br/&gt;bmw730.run();&lt;br/&gt;bmw840.run();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.3 应用场景&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 抽象工厂&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;抽象工厂模式（Abstract Factory Pattern），提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。&lt;strong&gt;但是有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYH3bye09dUCBvakibGmEJd8XJKG22mqwlFGibnAtW3OzsN9YWGiaIGQiaew/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.4898148148148148&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，阿宝哥模拟了用户购车的流程，小王向 BMW 工厂订购了 BMW730，工厂按照 730 对应的模型进行生产并在生产完成后交付给小王。而小秦向同一个 BMW 工厂订购了 BMW840，工厂按照 840 对应的模型进行生产并在生产完成后交付给小秦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看一下如何使用抽象工厂来描述上述的购车过程。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BMWFactory {&lt;br/&gt;  &lt;span&gt;abstract&lt;/span&gt; produce730BMW(): BMW730;&lt;br/&gt;  &lt;span&gt;abstract&lt;/span&gt; produce840BMW(): BMW840;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; ConcreteBMWFactory &lt;span&gt;extends&lt;/span&gt; BMWFactory {&lt;br/&gt;  produce730BMW(): BMW730 {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BMW730();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  produce840BMW(): BMW840 {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BMW840();&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; bmwFactory = &lt;span&gt;new&lt;/span&gt; ConcreteBMWFactory();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; bmw730 = bmwFactory.produce730BMW();&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; bmw840 = bmwFactory.produce840BMW();&lt;br/&gt;&lt;br/&gt;bmw730.run();&lt;br/&gt;bmw840.run();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3.3 应用场景&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统中有多于一个的产品族，而每次只使用其中某一产品族。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;三、单例模式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单例模式（Singleton Pattern）是一种常用的模式，有一些对象我们往往只需要一个，比如全局缓存、浏览器中的 window 对象等。单例模式用于保证一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYCwmXHgibyIcuia9UpgZTBEUL1HBdHfdfNayicOJRwbqRZYMOIMH8fK7TQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.39537037037037037&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，阿宝哥模拟了借车的流程，小王临时有急事找阿宝哥借车子，阿宝哥家的车子刚好没用，就借给小王了。当天，小秦也需要用车子，也找阿宝哥借车，因为阿宝哥家里只有一辆车子，所以就没有车可借了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于车子来说，它虽然给生活带来了很大的便利，但养车也需要一笔不小的费用（车位费、油费和保养费等），所以阿宝哥家里只有一辆车子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开发软件系统时，如果遇到创建对象时耗时过多或耗资源过多，但又经常用到的对象，我们就可以考虑使用单例模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看一下如何使用 TypeScript 来实现单例模式。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; Singleton {&lt;br/&gt;  &lt;span&gt;// 定义私有的静态属性，来保存对象实例&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; singleton: Singleton;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;constructor&lt;/span&gt;(&lt;span/&gt;) {}&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 提供一个静态的方法来获取对象实例&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; getInstance(): Singleton {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!Singleton.singleton) {&lt;br/&gt;      Singleton.singleton = &lt;span&gt;new&lt;/span&gt; Singleton();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Singleton.singleton;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; instance1 = Singleton.getInstance();&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; instance2 = Singleton.getInstance();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(instance1 === instance2); &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 应用场景&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;需要频繁实例化然后销毁的对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建对象时耗时过多或耗资源过多，但又经常用到的对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;四、适配器模式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际生活中，也存在适配器的使用场景，比如：港式插头转换器、电源适配器和 USB 转接口。&lt;strong&gt;而在软件工程中，适配器模式的作用是解决两个软件实体间的接口不兼容的问题&lt;/strong&gt;&lt;strong&gt;。&lt;/strong&gt;使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体就可以一起工作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicY87zR7joPTDTaflpOc37uVYctCgwjzVyPry3AVUW2ubVNUdp0X7ib0Ug/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.4527777777777778&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Logger {&lt;br/&gt;  info(message: &lt;span&gt;string&lt;/span&gt;): &lt;span&gt;Promise&lt;/span&gt;&amp;lt;&lt;span&gt;void&lt;/span&gt;&amp;gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; CloudLogger {&lt;br/&gt;  sendToServer(message: &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;string&lt;/span&gt;): &lt;span&gt;Promise&lt;/span&gt;&amp;lt;&lt;span&gt;void&lt;/span&gt;&amp;gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; AliLogger &lt;span&gt;implements&lt;/span&gt; CloudLogger {&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; sendToServer(message: &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;string&lt;/span&gt;): &lt;span&gt;Promise&lt;/span&gt;&amp;lt;&lt;span&gt;void&lt;/span&gt;&amp;gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.info(message);&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.info(&lt;span&gt;&#x27;This Message was saved with AliLogger&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; CloudLoggerAdapter &lt;span&gt;implements&lt;/span&gt; Logger {&lt;br/&gt;  &lt;span&gt;protected&lt;/span&gt; cloudLogger: CloudLogger;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt; (&lt;span&gt;cloudLogger: CloudLogger&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.cloudLogger = cloudLogger;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; info(message: &lt;span&gt;string&lt;/span&gt;): &lt;span&gt;Promise&lt;/span&gt;&amp;lt;&lt;span&gt;void&lt;/span&gt;&amp;gt; {&lt;br/&gt;    &lt;span&gt;await&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.cloudLogger.sendToServer(message, &lt;span&gt;&#x27;info&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; NotificationService {&lt;br/&gt;  &lt;span&gt;protected&lt;/span&gt; logger: Logger;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt; (&lt;span&gt;logger: Logger&lt;/span&gt;) {    &lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.logger = logger;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; send(message: &lt;span&gt;string&lt;/span&gt;): &lt;span&gt;Promise&lt;/span&gt;&amp;lt;&lt;span&gt;void&lt;/span&gt;&amp;gt; {&lt;br/&gt;    &lt;span&gt;await&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.logger.info(&lt;span&gt;`Notification sended: &lt;span&gt;${message}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以上代码中，因为 &lt;code&gt;Logger&lt;/code&gt; 和 &lt;code&gt;CloudLogger&lt;/code&gt; 这两个接口不匹配，所以我们引入了 &lt;code&gt;CloudLoggerAdapter&lt;/code&gt; 适配器来解决兼容性问题。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;(&lt;span&gt;async&lt;/span&gt; () =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; aliLogger = &lt;span&gt;new&lt;/span&gt; AliLogger();&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; cloudLoggerAdapter = &lt;span&gt;new&lt;/span&gt; CloudLoggerAdapter(aliLogger);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; notificationService = &lt;span&gt;new&lt;/span&gt; NotificationService(cloudLoggerAdapter);&lt;br/&gt;  &lt;span&gt;await&lt;/span&gt; notificationService.send(&lt;span&gt;&#x27;Hello semlinker, To Cloud&#x27;&lt;/span&gt;);&lt;br/&gt;})();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.3 应用场景及案例&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Github - axios-mock-adapter：https://github.com/ctimmerm/axios-mock-adapter&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;五、观察者模式 &amp;amp; 发布订阅模式&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1 观察者模式&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;观察者模式，它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在观察者模式中有两个主要角色：Subject（主题）和 Observer（观察者）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYicKmbjTUWZYRg7bzOP6ZPlhC8dAhEwia3pqtReHMnCZF6R3TTeWnJOkA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.531062124248497&quot; data-w=&quot;998&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，Subject（主题）就是阿宝哥的 TS 专题文章，而观察者就是小秦和小王。由于观察者模式支持简单的广播通信，当消息更新时，会自动通知所有的观察者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看一下如何使用 TypeScript 来实现观察者模式。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Observer {&lt;br/&gt;  notify: &lt;span&gt;Function&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; ConcreteObserver &lt;span&gt;implements&lt;/span&gt; Observer{&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;&lt;span&gt;private&lt;/span&gt; name: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) {}&lt;br/&gt;&lt;br/&gt;  notify() {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`&lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.name}&lt;/span&gt; has been notified.`&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; Subject { &lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; observers: Observer[] = [];&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; addObserver(observer: Observer): &lt;span&gt;void&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(observer, &lt;span&gt;&quot;is pushed!&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.observers.push(observer);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; deleteObserver(observer: Observer): &lt;span&gt;void&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;remove&quot;&lt;/span&gt;, observer);&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; n: &lt;span&gt;number&lt;/span&gt; = &lt;span&gt;this&lt;/span&gt;.observers.indexOf(observer);&lt;br/&gt;    n != &lt;span&gt;-1&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.observers.splice(n, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; notifyObservers(): &lt;span&gt;void&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;notify all the observers&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.observers);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.observers.forEach(&lt;span&gt;&lt;span&gt;observer&lt;/span&gt; =&amp;gt;&lt;/span&gt; observer.notify());&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; subject: Subject = &lt;span&gt;new&lt;/span&gt; Subject();&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; xiaoQin = &lt;span&gt;new&lt;/span&gt; ConcreteObserver(&lt;span&gt;&quot;小秦&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; xiaoWang = &lt;span&gt;new&lt;/span&gt; ConcreteObserver(&lt;span&gt;&quot;小王&quot;&lt;/span&gt;);&lt;br/&gt;subject.addObserver(xiaoQin);&lt;br/&gt;subject.addObserver(xiaoWang);&lt;br/&gt;subject.notifyObservers();&lt;br/&gt;&lt;br/&gt;subject.deleteObserver(xiaoQin);&lt;br/&gt;subject.notifyObservers();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1.3 应用场景及案例&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个对象的行为依赖于另一个对象的状态。或者换一种说法，当被观察对象（目标对象）的状态发生改变时 ，会直接影响到观察对象的行为。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RxJS Subject：https://github.com/ReactiveX/rxjs/blob/master/src/internal/Subject.ts&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RxJS Subject 文档：https://rxjs.dev/guide/subject&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 发布订阅模式&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在软件架构中，发布/订阅是一种消息范式，&lt;strong&gt;消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，然后分别发送给不同的订阅者。&lt;/strong&gt; 同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在发布订阅模式中有三个主要角色：Publisher（发布者）、 Channels（通道）和 Subscriber（订阅者）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYsZibrw2DBibCXudiabAmSCg3nNZectclZZCib795MH2z8lt14YMKsKtuFQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.40185185185185185&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，Publisher（发布者）是阿宝哥，Channels（通道）中 Topic A 和 Topic B 分别对应于 TS 专题和 Deno 专题，而 Subscriber（订阅者）就是小秦、小王和小池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看一下如何使用 TypeScript 来实现发布订阅模式。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; EventHandler = &lt;span&gt;(&lt;span&gt;...args: &lt;span&gt;any&lt;/span&gt;[]&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;any&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; EventEmitter {&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; c = &lt;span&gt;new&lt;/span&gt; Map&amp;lt;&lt;span&gt;string&lt;/span&gt;, EventHandler[]&amp;gt;();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 订阅指定的主题&lt;/span&gt;&lt;br/&gt;  subscribe(topic: &lt;span&gt;string&lt;/span&gt;, ...handlers: EventHandler[]) {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; topics = &lt;span&gt;this&lt;/span&gt;.c.get(topic);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!topics) {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.c.set(topic, topics = []);&lt;br/&gt;    }&lt;br/&gt;    topics.push(...handlers);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 取消订阅指定的主题&lt;/span&gt;&lt;br/&gt;  unsubscribe(topic: &lt;span&gt;string&lt;/span&gt;, handler?: EventHandler): &lt;span&gt;boolean&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!handler) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.c.delete(topic);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; topics = &lt;span&gt;this&lt;/span&gt;.c.get(topic);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!topics) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; index = topics.indexOf(handler);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (index &amp;lt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    topics.splice(index, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (topics.length === &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.c.delete(topic);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 为指定的主题发布消息&lt;/span&gt;&lt;br/&gt;  publish(topic: &lt;span&gt;string&lt;/span&gt;, ...args: &lt;span&gt;any&lt;/span&gt;[]): &lt;span&gt;any&lt;/span&gt;[] | &lt;span&gt;null&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; topics = &lt;span&gt;this&lt;/span&gt;.c.get(topic);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!topics) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; topics.map(&lt;span&gt;&lt;span&gt;handler&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; handler(...args);&lt;br/&gt;      } &lt;span&gt;catch&lt;/span&gt; (e) {&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.error(e);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;    });&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; eventEmitter = &lt;span&gt;new&lt;/span&gt; EventEmitter();&lt;br/&gt;eventEmitter.subscribe(&lt;span&gt;&quot;ts&quot;&lt;/span&gt;, &lt;span&gt;(&lt;span&gt;msg&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`收到订阅的消息：&lt;span&gt;${msg}&lt;/span&gt;`&lt;/span&gt;) );&lt;br/&gt;&lt;br/&gt;eventEmitter.publish(&lt;span&gt;&quot;ts&quot;&lt;/span&gt;, &lt;span&gt;&quot;TypeScript发布订阅模式&quot;&lt;/span&gt;);&lt;br/&gt;eventEmitter.unsubscribe(&lt;span&gt;&quot;ts&quot;&lt;/span&gt;);&lt;br/&gt;eventEmitter.publish(&lt;span&gt;&quot;ts&quot;&lt;/span&gt;, &lt;span&gt;&quot;TypeScript发布订阅模式&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2.3 应用场景&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;作为事件总线，来实现不同组件间或模块间的通信。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;BetterScroll - EventEmitter：https://github.com/ustbhuangyi/better-scroll/blob/dev/packages/shared-utils/src/events.ts&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;amp;mid=2247486413&amp;amp;idx=1&amp;amp;sn=f9a2d3a0f7f89817ce0f5abb4a2698ed&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;EventEmitter 在插件化架构的应用&lt;/a&gt;：https://mp.weixin.qq.com/s/N4iw3bi0bxJ57J8EAp5ctQ&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;六、策略模式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;策略模式（Strategy Pattern）定义了一系列的算法，把它们一个个封装起来，并且使它们可以互相替换。策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活、可维护、可扩展。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYJbJ6yQpSoG7PMzibnyoAia1NvIeWVVIauojkxNu9o2Qa7GN0T2nmliaHQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.512962962962963&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前在一些主流的 Web 站点中，都提供了多种不同的登录方式。比如账号密码登录、手机验证码登录和第三方登录。为了方便维护不同的登录方式，我们可以把不同的登录方式封装成不同的登录策略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看一下如何使用策略模式来封装不同的登录方式。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更好地理解以下代码，我们先来看一下对应的 UML 类图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYl5SX5hwrg3Tj5LPGQwh4eVsNKuEcXo8MX1mbgUPcAq5C8PNIxm3KMg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.38981481481481484&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Strategy {&lt;br/&gt;  authenticate(...args: &lt;span&gt;any&lt;/span&gt;): &lt;span&gt;any&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; Authenticator {&lt;br/&gt;  strategy: &lt;span&gt;any&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span/&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.strategy = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  setStrategy(strategy: &lt;span&gt;any&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.strategy = strategy;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  authenticate(...args: &lt;span&gt;any&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.strategy) {&lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;尚未设置认证策略&#x27;&lt;/span&gt;);&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.strategy.authenticate(...args);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; WechatStrategy &lt;span&gt;implements&lt;/span&gt; Strategy {&lt;br/&gt;  authenticate(wechatToken: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (wechatToken !== &lt;span&gt;&#x27;123&#x27;&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;无效的微信用户&#x27;&lt;/span&gt;);&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;微信认证成功&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; LocalStrategy &lt;span&gt;implements&lt;/span&gt; Strategy {&lt;br/&gt;  authenticate(username: &lt;span&gt;string&lt;/span&gt;, password: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (username !== &lt;span&gt;&#x27;abao&#x27;&lt;/span&gt; &amp;amp;&amp;amp; password !== &lt;span&gt;&#x27;123&#x27;&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;账号或密码错误&#x27;&lt;/span&gt;);&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;账号和密码认证成功&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; auth = &lt;span&gt;new&lt;/span&gt; Authenticator();&lt;br/&gt;&lt;br/&gt;auth.setStrategy(&lt;span&gt;new&lt;/span&gt; WechatStrategy());&lt;br/&gt;auth.authenticate(&lt;span&gt;&#x27;123456&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;auth.setStrategy(&lt;span&gt;new&lt;/span&gt; LocalStrategy());&lt;br/&gt;auth.authenticate(&lt;span&gt;&#x27;abao&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;123&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.3 应用场景及案例&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Github - passport-local：https://github.com/jaredhanson/passport-local&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Github - passport-oauth2：https://github.com/jaredhanson/passport-oauth2&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Github - zod：https://github.com/vriad/zod/blob/master/src/types/string.ts&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;七、职责链模式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;职责链模式是使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。在职责链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYK5Ro2JicfYmoq4dRHeibldSgicBR1tfHmmjf1GFX43B3Ijn8jHv855dWg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.4305555555555556&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在公司中不同的岗位拥有不同的职责与权限。以上述的请假流程为例，当阿宝哥请 1 天假时，只要组长审批就可以了，不需要流转到主管和总监。如果职责链上的某个环节无法处理当前的请求，若含有下个环节，则会把请求转交给下个环节来处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在日常的软件开发过程中，对于职责链来说，一种常见的应用场景是中间件，下面我们来看一下如何利用职责链来处理请求。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更好地理解以下代码，我们先来看一下对应的 UML 类图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYz2cnpExp89LOgLVLq0HgyDqUSFqVXgiaAKs5VX0vicYnd1CC4Sq51ulg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.5805555555555556&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; IHandler {&lt;br/&gt;  addMiddleware(h: IHandler): IHandler;&lt;br/&gt;  &lt;span&gt;get&lt;/span&gt;(url: &lt;span&gt;string&lt;/span&gt;, callback: &lt;span&gt;(&lt;span&gt;data: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;): &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AbstractHandler &lt;span&gt;implements&lt;/span&gt; IHandler {&lt;br/&gt;  next!: IHandler;&lt;br/&gt;  addMiddleware(h: IHandler) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.next = h;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.next;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;get&lt;/span&gt;(url: &lt;span&gt;string&lt;/span&gt;, callback: &lt;span&gt;(&lt;span&gt;data: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.next) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.next.get(url, callback);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 定义Auth中间件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; Auth &lt;span&gt;extends&lt;/span&gt; AbstractHandler {&lt;br/&gt;  isAuthenticated: &lt;span&gt;boolean&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;username: &lt;span&gt;string&lt;/span&gt;, password: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.isAuthenticated = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (username === &lt;span&gt;&#x27;abao&#x27;&lt;/span&gt; &amp;amp;&amp;amp; password === &lt;span&gt;&#x27;123&#x27;&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.isAuthenticated = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;get&lt;/span&gt;(url: &lt;span&gt;string&lt;/span&gt;, callback: &lt;span&gt;(&lt;span&gt;data: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.isAuthenticated) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;.get(url, callback);&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;&#x27;Not Authorized&#x27;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 定义Logger中间件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; Logger &lt;span&gt;extends&lt;/span&gt; AbstractHandler {&lt;br/&gt;  &lt;span&gt;get&lt;/span&gt;(url: &lt;span&gt;string&lt;/span&gt;, callback: &lt;span&gt;(&lt;span&gt;data: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;/GET Request to: &#x27;&lt;/span&gt;, url);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;.get(url, callback);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; Route &lt;span&gt;extends&lt;/span&gt; AbstractHandler {&lt;br/&gt;  URLMaps: {[key: &lt;span&gt;string&lt;/span&gt;]: &lt;span&gt;any&lt;/span&gt;};&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span/&gt;) {&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.URLMaps = {&lt;br/&gt;      &lt;span&gt;&#x27;/api/todos&#x27;&lt;/span&gt;: [{ title: &lt;span&gt;&#x27;learn ts&#x27;&lt;/span&gt; }, { title: &lt;span&gt;&#x27;learn react&#x27;&lt;/span&gt; }],&lt;br/&gt;      &lt;span&gt;&#x27;/api/random&#x27;&lt;/span&gt;: &lt;span&gt;Math&lt;/span&gt;.random(),&lt;br/&gt;    };&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;get&lt;/span&gt;(url: &lt;span&gt;string&lt;/span&gt;, callback: &lt;span&gt;(&lt;span&gt;data: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;.get(url, callback);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.URLMaps.hasOwnProperty(url)) {&lt;br/&gt;      callback(&lt;span&gt;this&lt;/span&gt;.URLMaps[url]);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; route = &lt;span&gt;new&lt;/span&gt; Route();&lt;br/&gt;route.addMiddleware(&lt;span&gt;new&lt;/span&gt; Auth(&lt;span&gt;&#x27;abao&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;123&#x27;&lt;/span&gt;)).addMiddleware(&lt;span&gt;new&lt;/span&gt; Logger());&lt;br/&gt;&lt;br/&gt;route.get(&lt;span&gt;&#x27;/api/todos&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;data&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;JSON&lt;/span&gt;.stringify({ data }, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;));&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;route.get(&lt;span&gt;&#x27;/api/random&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;data&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(data);&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.3 应用场景&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可处理一个请求的对象集合应被动态指定。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有多个对象可以处理一个请求，哪个对象处理该请求运行时自动确定，客户端只需要把请求提交到链上即可。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;八、模板方法模式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;模板方法模式由两部分结构组成：抽象父类和具体的实现子类。&lt;strong&gt;通常在抽象父类中封装了子类的算法框架，也包括实现一些公共方法以及封装子类中所有方法的执行顺序&lt;/strong&gt;。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYNOdjfUEPciaNfMYZpJCCXRHjOoPAAC7wc8qLibIKIyWzcbUshQyW6QuQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.34629629629629627&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，阿宝哥通过使用不同的解析器来分别解析 CSV 和 Markup 文件。虽然解析的是不同的类型的文件，但文件的处理流程是一样的。这里主要包含读取文件、解析文件和打印数据三个步骤。针对这个场景，我们就可以引入模板方法来封装以上三个步骤的处理顺序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看一下如何使用模板方法来实现上述的解析流程。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更好地理解以下代码，我们先来看一下对应的 UML 类图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYLXjUAXclQXQ508iabWJhUgAfSR8aD4icKD2JbRjSK0klfVXnowCP1UsA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.524&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; fs &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;fs&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DataParser {&lt;br/&gt;  data: &lt;span&gt;string&lt;/span&gt; = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;  out: &lt;span&gt;any&lt;/span&gt; = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 这就是所谓的模板方法&lt;/span&gt;&lt;br/&gt;  parse(pathUrl: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.readFile(pathUrl);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.doParsing();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.printData();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  readFile(pathUrl: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.data = fs.readFileSync(pathUrl, &lt;span&gt;&#x27;utf8&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;abstract&lt;/span&gt; doParsing(): &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;  &lt;br/&gt;  printData() {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;this&lt;/span&gt;.out);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; CSVParser &lt;span&gt;extends&lt;/span&gt; DataParser {&lt;br/&gt;  doParsing() {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.out = &lt;span&gt;this&lt;/span&gt;.data.split(&lt;span&gt;&#x27;,&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; MarkupParser &lt;span&gt;extends&lt;/span&gt; DataParser {&lt;br/&gt;  doParsing() {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.out = &lt;span&gt;this&lt;/span&gt;.data.match(&lt;span&gt;/&amp;lt;\w+&amp;gt;.*&amp;lt;\/\w+&amp;gt;/gim&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; csvPath = &lt;span&gt;&#x27;./data.csv&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; mdPath = &lt;span&gt;&#x27;./design-pattern.md&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;new&lt;/span&gt; CSVParser().parse(csvPath);&lt;br/&gt;&lt;span&gt;new&lt;/span&gt; MarkupParser().parse(mdPath);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.3 应用场景&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;九、参考资源&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;维基百科 - 设计模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Java设计模式：23种设计模式全面解析&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Design Patterns Everyday&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>