<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>6b636b9eaebb464527414216810bf75c</guid>
<title>春联专用喷胶，点击领券现价只需4.6元！</title>
<link>https://toutiao.io/k/1i9uqmb</link>
<content:encoded>&lt;div&gt;&lt;body data-spm=&quot;10720394/n&quot; id=&quot;readabilityBody&quot;&gt;
    
    
    
    
    
    
      
      
    
    
    
    
    
  &lt;/body&gt;
&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9c6f3d43542a47c7d26aee5cff94c5e0</guid>
<title>[推荐] 偷天换日，用 JavaAgent 欺骗你的 JVM</title>
<link>https://toutiao.io/k/cah22k5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Java Agent 出现在 JDK1.5 版本以后，它允许程序员利用 &lt;span&gt;Agent &lt;/span&gt;技术构建一个独立于应用程序的代理程序。用途也非常广泛，可以协助监测、运行、甚至替换其他 JVM 上的程序。先从下面这张图直观的看一下它都被应用在哪些场景：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5509433962264151&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9MCsN27dESvlrlywMqh18mzu7AiaQ2jjyF1TlyibbqgK9rW2mcSUBFjPlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;530&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;看到这里你是不是也很好奇，究竟是什么神仙技术，能够应用在这么多场景下，那今天我们就来挖掘一下，看看神奇的 Java Agent 是如何工作在底层，默默支撑了这么多优秀的应用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;回到文章开头的类比，我们还是用和 AOP 比较的方式，来先对Java Agent 有一个大致的了解：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;作用级别&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;span&gt;AO&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt; &lt;/span&gt;运行于应用程序内的方法级别，而 &lt;span&gt;Agent &lt;/span&gt;能够作用于虚拟机级别&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;组成部分&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;span&gt;AO&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt; &lt;/span&gt;的实现需要目标方法和逻辑增强部分的方法，而 Java Agent 要生效需要两个工程，一个是 &lt;span&gt;Agent &lt;/span&gt;代理，另一个是需要被代理的主程序；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;执行场合&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;span&gt;AO&lt;/span&gt;&lt;span&gt;P &lt;/span&gt;可以运行在切面的前后或环绕等场合，而 Java Agent 的执行只有两种方式，JDK1.5 提供的 preMain 模式在主程序运行前执行，&lt;span&gt;JDK&lt;/span&gt;&lt;span&gt;1.6 &lt;/span&gt;提供的 agentMain 在主程序运行后执行。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面我们就分别看一下在两种模式下，如何动手实现一个 &lt;span&gt;Agent &lt;/span&gt;代理程序。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Premain 模式&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Premain 模式允许在主程序执行前执行一个 &lt;span&gt;Agent &lt;/span&gt;代理，实现起来非常简单，下面我们分别实现两个组成部分。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;Agent&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;先写一个简单的功能，在主程序执行前打印一句话，并打印传递给代理的参数：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MyPreMainAgent&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;premain&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String agentArgs, Instrumentation inst&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;premain start&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;args:&quot;&lt;/span&gt;+agentArgs);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在写完了 &lt;span&gt;Agent &lt;/span&gt;的逻辑后，需要把它打包成 jar 文件。这里我们直接使用 maven 插件打包的方式，在打包前进行一些配置。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;maven-jar-plugin&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;3.1.0&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;archive&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;manifest&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;addClasspath&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;addClasspath&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;manifest&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;manifestEntries&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;Premain-Class&lt;/span&gt;&amp;gt;&lt;/span&gt;com.cn.agent.MyPreMainAgent&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;Premain-Class&lt;/span&gt;&amp;gt;&lt;/span&gt;                            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;Can-Redefine-Classes&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;Can-Redefine-Classes&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;Can-Retransform-Classes&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;Can-Retransform-Classes&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;Can-Set-Native-Method-Prefix&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;Can-Set-Native-Method-Prefix&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;manifestEntries&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;archive&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;配置的打包参数中，通过 manifestEntries 的方式添加属性到 MANIFEST.MF 文件中，解释一下里面的几个参数：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Premain-Class&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：包含 premain 方法的类，需要配置为类的全路径；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Can-Redefine-Classes&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：为 true 时表示能够重新定义 class；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Can-Retransform-Classes&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：为 true 时表示能够重新转换 class，实现字节码替换；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Can-Set-Native-Method-Prefix&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：为 true 时表示能够设置 native 方法的前缀。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其中 Premain-Class 为必须配置，其余几项是非必须选项，默认情况下都为 false。通常也建议加入，这几个功能我们会在后面具体介绍。在配置完成后，使用 mvn 命令打包：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;mvn clean &lt;span class=&quot;code-snippet__keyword&quot;&gt;package&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;打包完成后生成 myAgent-1.0.jar 文件，我们可以解压 jar 文件，看一下生成的 MANIFEST.MF 文件：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4099009900990099&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9Mla3YlKFBFBSnplLPv5iaNkht3j9cPH1oYgpYGI95fd1gpqFZIVJicI6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;505&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以看到，添加的属性已经被加入到了文件中。到这里，&lt;span&gt;Agent &lt;/span&gt;代理部分就完成了，因为代理不能够直接运行，需要附着于其他程序，所以下面新建一个工程来实现主程序。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;主程序&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在主程序的工程中，只需要一个能够执行的 main 方法的入口就可以了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;AgentTest&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String[] args&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;main project start&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在主程序完成后，要考虑的就是应该如何将主程序与 &lt;span&gt;Agent &lt;/span&gt;工程连接起来。这里可以通过 -javaagent 参数来指定运行的代理，命令格式如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;java&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-javaagent&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:myAgent.jar&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-jar&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;AgentTest&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.jar&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;并且，可以指定的代理数量是没有限制的。会根据指定的顺序先后依次执行各个代理，如果要同时运行两个代理，就可以按照下面的命令执行：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;java&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-javaagent&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:myAgent1.jar&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-javaagent&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:myAgent2.jar&lt;/span&gt;  &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-jar&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;AgentTest&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.jar&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以我们在 IDEA 中执行程序为例，在 VM options 中加入添加启动参数：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;diff&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__deletion&quot;&gt;-javaagent:F:\Workspace\MyAgent\target\myAgent-1.0.jar=Hydra&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__deletion&quot;&gt;-javaagent:F:\Workspace\MyAgent\target\myAgent-1.0.jar=Trunks&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;执行 main 方法，查看输出结果：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42237061769616024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9MLiaCzLZPe73l3jYtXt8nnmYgQ5gcic1Nx02XCEWicm89iaM9Rd9nBtCZvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;599&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;根据执行结果的打印语句可以看出，在执行主程序前，依次执行了两次我们的 &lt;span&gt;Agent &lt;/span&gt;代理。可以通过下面的图来表示执行代理与主程序的执行顺序。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6906354515050167&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9MmeEibAx9Zk3hiaYWfZMBvOgb84Lc8ItWgRf5goFc8H6NSdfZzXZeEEzA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;598&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;缺陷&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在提供便利的同时，premain 模式也有一些缺陷，例如如果 &lt;span&gt;Agent&lt;/span&gt; 在运行过程中出现异常，那么也会导致主程序的启动失败。我们对上面例子中 &lt;span&gt;Agent &lt;/span&gt;的代码进行一下改造，手动抛出一个异常。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;premain&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String agentArgs, Instrumentation inst&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;premain start&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;args:&quot;&lt;/span&gt;+agentArgs);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;error&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;再次运行主程序：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3743743743743744&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9M3ookJCtnkTeN8vjcE4vsickPW8BHofCicy2ulZ9ygQWfnfF0o8xuvXVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;999&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以看到，在 &lt;span&gt;Agent &lt;/span&gt;抛出异常后主程序也没有启动。针对 premain 模式的一些缺陷，在 JDK1.6 之后引入了 agentmain 模式。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Agentmain 模式&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;agentmain 模式可以说是 premain 的升级版本，它允许代理的目标主程序的 JVM 先行启动，再通过 attach 机制连接两个 JVM，下面我们分三个部分实现。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;agent&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;agent 部分和上面一样，实现简单的打印功能：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MyAgentMain&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;agentmain&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String agentArgs, Instrumentation instrumentation&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;agent main start&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;args:&quot;&lt;/span&gt;+agentArgs);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;修改 maven 插件配置，指定 Agent-Class：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;maven-jar-plugin&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;3.1.0&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;archive&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;manifest&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;addClasspath&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;addClasspath&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;manifest&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;manifestEntries&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;Agent-Class&lt;/span&gt;&amp;gt;&lt;/span&gt;com.cn.agent.MyAgentMain&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;Agent-Class&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;Can-Redefine-Classes&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;Can-Redefine-Classes&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;Can-Retransform-Classes&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;Can-Retransform-Classes&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;manifestEntries&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;archive&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;主程序&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里我们直接启动主程序等待代理被载入，在主程序中使用了 System.in 进行阻塞，防止主进程提前结束。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;AgentmainTest&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String[] args&lt;/span&gt;) throws IOException&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt;.read();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;attach 机制&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;和 premain 模式不同，我们不能再通过添加启动参数的方式来连接 &lt;span&gt;Agent&lt;/span&gt; 和主程序了，这里需要借助 com.sun.tools.attach 包下的 VirtualMachine 工具类。需要注意该类不是 JVM 标准规范，是由 Sun 公司自己实现的，使用前需要引入依赖：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.sun&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;tools&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;system&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;systemPath&lt;/span&gt;&amp;gt;&lt;/span&gt;${JAVA_HOME}\lib\tools.jar&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;systemPath&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;VirtualMachine 代表了一个要被附着的 Java 虚拟机，也就是程序中需要监控的目标虚拟机。外部进程可以使用 VirtualMachine 的实例将 agent 加载到目标虚拟机中。先看一下它的静态方法 attach：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; VirtualMachine &lt;span class=&quot;code-snippet__title&quot;&gt;attach&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String var0&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过 attach 方法可以获取一个 JVM 的对象实例，这里传入的参数是目标虚拟机运行时的进程号 pid。也就是说，我们在使用 attach 前，需要先获取刚才启动的主程序的 pid，使用 jps 命令查看线程 pid：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;11140&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;16372&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;RemoteMavenServer36&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;16392&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;AgentmainTest&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;20204&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;Jps&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;2460&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;Launcher&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;获取到主程序 AgentmainTest 运行时 pid 是 16392，将它应用于虚拟机的连接。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;AttachTest&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String[] args&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            VirtualMachine  vm= VirtualMachine.attach(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;16392&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            vm.loadAgent(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;F:\\Workspace\\MyAgent\\target\\myAgent-1.0.jar&quot;&lt;/span&gt;,&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;param&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            e.printStackTrace();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在获取到 VirtualMachine 实例后，就可以通过 loadAgent 方法可以实现注入 agent 代理类的操作，方法的第一个参数是代理的本地路径，第二个参数是传给代理的参数。执行 AttachTest，再回到主程序 AgentmainTest 的控制台，可以看到执行了了 &lt;span&gt;Agent&lt;/span&gt; 中的代码：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2754777070063694&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9MdHRPc00Ww9TVUf3wqNfa2uAra0OqldYhicsaAe1jndcBHACpymPFpwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;628&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样，一个简单的 agentMain 模式代理就实现完成了，可以通过下面这张图再梳理一下三个模块之间的关系。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2588699080157687&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9MXM1iahCcAaIY4mUXS6UqbXq2FK33GwxvXKTVek8Eic9ricWWVShFdlyaw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;761&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;应用&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;到这里，我们就已经简单地了解了两种模式的实现方法，但是作为高质量程序员，我们肯定不能满足于只用代理单纯地打印语句，下面我们再来看看能怎么利用 Java Agent 搞点实用的东西。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在上面的两种模式中，agent 部分的逻辑分别是在 premain 方法和 agentmain 方法中实现的。并且，这两个方法在签名上对参数有严格的要求，premain 方法允许以下面两种方式定义：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; premain(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; agentArgs)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; premain(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; agentArgs, Instrumentation inst)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;agentmain 方法允许以下面两种方式定义：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; agentmain(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; agentArgs)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; agentmain(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; agentArgs, Instrumentation inst)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果在 agent 中同时存在两种签名的方法，带有 Instrumentation 参数的方法优先级更高，会被 jvm 优先加载，它的实例 inst 会由 JVM 自动注入，下面我们就看看能通过 Instrumentation 实现什么功能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Instrumentation&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;先大体介绍一下 Instrumentation 接口。其中的方法允许在运行时操作 Java 程序，提供了诸如改变字节码、新增 jar 包、替换 class 等功能。而通过这些功能使 Java 具有了更强的动态控制和解释能力。在我们编写 &lt;span&gt;Agent&lt;/span&gt; 代理的过程中，Instrumentation 中下面 3 个方法比较重要和常用，我们来着重看一下。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;addTransformer&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;addTransformer 方法允许我们在类加载之前，重新定义 Class，先看一下方法的定义：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;addTransformer&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;ClassFileTransformer transformer&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ClassFileTransformer 是一个接口，只有一个 transform 方法，它在主程序的 main 方法执行前，装载的每个类都要经过 transform 执行一次，可以将它称为转换器。我们可以实现这个方法来重新定义 Class，下面就通过一个例子看看具体如何使用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，在主程序工程创建一个 Fruit 类：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Fruit&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;getFruit&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;banana&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;编译完成后复制一份 class 文件，并将其重命名为 Fruit2.class，再修改 Fruit 中的方法为：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;getFruit&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;apple&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;创建主程序，在主程序中创建了一个 Fruit 对象并调用了其 getFruit 方法：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;TransformMain&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String[] args&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Fruit().getFruit();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这时执行结果会打印 apple，接下来开始实现 premain 代理部分。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在代理的 premain 方法中，使用 Instrumentation 的 addTransformer 方法拦截类的加载：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;TransformAgent&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;premain&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String agentArgs, Instrumentation inst&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        inst.addTransformer(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; FruitTransformer());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;FruitTransforme r类实现了 ClassFileTransformer 接口，转换 class 部分的逻辑都在 transform 方法中：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;FruitTransformer&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ClassFileTransformer&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @&lt;span class=&quot;code-snippet__function&quot;&gt;Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;[] &lt;span class=&quot;code-snippet__title&quot;&gt;transform&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;ClassLoader loader, String className, Class&amp;lt;?&amp;gt; classBeingRedefined,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            ProtectionDomain protectionDomain, &lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;[] classfileBuffer&lt;/span&gt;){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!className.&lt;span class=&quot;code-snippet__keyword&quot;&gt;equals&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;com/cn/hydra/test/Fruit&quot;&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; classfileBuffer;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        String fileName=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;F:\\Workspace\\agent-test\\target\\classes\\com\\cn\\hydra\\test\\Fruit2.class&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; getClassBytes(fileName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;[] &lt;span class=&quot;code-snippet__title&quot;&gt;getClassBytes&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String fileName&lt;/span&gt;)&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        File file = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; File(fileName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt;(InputStream &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; FileInputStream(file);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            ByteArrayOutputStream bs = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ByteArrayOutputStream()){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; length = file.length();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;[] bytes = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;[(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;) length];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; n;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; ((n = &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt;.read(bytes)) != &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                bs.write(bytes, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, n);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; bytes;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            e.printStackTrace();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 transform 方法中，主要做了两件事：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;因为 addTransformer 方法不能指明需要转换的类，所以需要通过 className 判断当前加载的 class 是否我们要拦截的目标 class，对于非目标 class 直接返回原字节数组，注意 className 的格式，需要将类全限定名中的 &#x27;.&#x27; 替换为 &#x27;/&#x27;；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;读取我们之前复制出来的 class 文件，读入二进制字符流，替换原有 classfileBuffer 字节数组并返回，完成 class 定义的替换。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;将 &lt;span&gt;Agent&lt;/span&gt; 部分打包完成后，在主程序添加启动参数：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-javaagent&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:F&lt;/span&gt;:\&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Workspace&lt;/span&gt;\&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;MyAgent&lt;/span&gt;\&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;target&lt;/span&gt;\&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;transformAgent-1&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.jar&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;再次执行主程序，结果打印：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;banana&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样，就实现了在 main 方法执行前 class 的替换。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;redefineClasses&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们可以直观地从方法的名字上来理解它的作用，重定义 class，通俗点来讲的话就是实现指定类的替换。方法定义如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;redefineClasses&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ClassDefinition... definitions)&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt;  ClassNotFoundException, UnmodifiableClassException&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它的参数是可变长的 ClassDefinition 数组，再看一下 ClassDefinition 的构造方法：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ClassDefinition&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;Class&amp;lt;?&amp;gt; theClass,&lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;[] theClassFile&lt;/span&gt;)&lt;/span&gt; {...}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ClassDefinition 中指定了的 Class 对象和修改后的字节码数组。简单来说，就是使用提供的类文件字节，替换了原有的类。并且，在 redefineClasses 方法重定义的过程中，传入的是 ClassDefinition 的数组，它会按照这个数组顺序进行加载，以便满足在类之间相互依赖的情况下进行更改。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面通过一个例子来看一下它的生效过程，premain 代理部分：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;RedefineAgent&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;premain&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String agentArgs, Instrumentation inst)&lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; UnmodifiableClassException, ClassNotFoundException &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        String fileName=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;F:\\Workspace\\agent-test\\target\\classes\\com\\cn\\hydra\\test\\Fruit2.class&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ClassDefinition def=&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ClassDefinition(Fruit.class,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                FruitTransformer.getClassBytes(fileName));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        inst.redefineClasses(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ClassDefinition[]{def});&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主程序可以直接复用上面的，执行后打印：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;banana&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以看到，用我们指定的 class 文件的字节替换了原有类，即实现了指定类的替换。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;retransformClasses&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;retransformClasses 应用于 agentmain 模式，可以在类加载之后重新定义 Class，即触发类的重新加载。首先看一下该方法的定义：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;retransformClasses&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Class&amp;lt;?&amp;gt;... classes)&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; UnmodifiableClassException&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它的参数 classes 是需要转换的类数组，可变长参数也说明了它和 redefineClasses 方法一样，也可以批量转换类的定义。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面，我们通过例子来看看如何使用 retransformClasses 方法，&lt;span&gt;Agent &lt;/span&gt;代理部分代码如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;RetransformAgent&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;agentmain&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String agentArgs, Instrumentation inst&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            throws UnmodifiableClassException&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        inst.addTransformer(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; FruitTransformer(),&lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        inst.retransformClasses(Fruit.class);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;retransform success&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;看一下这里调用的 addTransformer 方法的定义，与上面略有不同：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;addTransformer&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ClassFileTransformer transformer, &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; canRetransform)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ClassFileTransformer 转换器依旧复用了上面的 FruitTransformer。重点看一下新加的第二个参数，当 canRetransform 为 true 时，表示允许重新定义 class。这时，相当于调用了转换器 ClassFileTransformer 中的 transform 方法，会将转换后 class 的字节作为新类定义进行加载。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主程序部分代码，我们在死循环中不断的执行打印语句，来监控类是否发生了改变：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;RetransformMain&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;true&lt;/span&gt;){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Fruit().getFruit();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            TimeUnit.SECONDS.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后，使用 attach API 注入 &lt;span&gt;Agent&lt;/span&gt; 代理到主程序中：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;AttachRetransform&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        VirtualMachine vm = VirtualMachine.attach(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;6380&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        vm.loadAgent(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;F:\\Workspace\\MyAgent\\target\\retransformAgent-1.0.jar&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;回到主程序控制台，查看运行结果：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46634615384615385&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9M4Yfgzj40BEWQ6meuOyS9nsgvgtARdTdzl2t8Xc4ia7z2Bw0pTa5XS7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;624&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以看到在注入代理后，打印语句发生变化，说明类的定义已经被改变并进行了重新加载。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;其他&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;除了这几个主要的方法外，Instrumentation 中还有一些其他方法，这里仅简单列举一下常用方法的功能：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;removeTransformer&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：删除一个 ClassFileTransformer 类转换器；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;getAllLoadedClasses&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：获取当前已经被加载的 Class；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;getInitiatedClasses&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：获取由指定的 ClassLoader 加载的 Class；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;getObjectSize&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：获取一个对象占用空间的大小；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;appendToBootstrapClassLoaderSearch&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：添加 jar 包到启动类加载器；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;appendToSystemClassLoaderSearch&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：添加 jar 包到系统类加载器；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;isNativeMethodPrefixSupported&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：判断是否能给 native 方法添加前缀，即是否能够拦截 native 方法；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;setNativeMethodPrefix&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：设置 native 方法的前缀。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Javassist&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在上面的几个例子中，我们都是直接读取的 class 文件中的字节来进行 class 的重定义或转换。但是在实际的工作环境中，可能更多的是去动态的修改 class 文件的字节码，这时候就可以借助 javassist 来更简单的修改字节码文件。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;简单来说，javassist 是一个分析、编辑和创建 Java 字节码的类库。在使用时我们可以直接调用它提供的 API，以编码的形式动态改变或生成 class 的结构。相对于 ASM 等其他要求了解底层虚拟机指令的字节码框架，javassist 真的是非常简单和快捷。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面，我们就通过一个简单的例子，看看如何将 Java agent 和 Javassist 结合在一起使用。首前先引入 javassist 的依赖：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.javassist&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;javassist&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;3.20.0-GA&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们要实现的功能是通过代理，来计算方法执行的时间。premain 代理部分和之前基本一致，先添加一个转换器：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Agent&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;premain&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String agentArgs, Instrumentation inst)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        inst.addTransformer(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; LogTransformer());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;LogTransformer&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ClassFileTransformer&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;[] transform(ClassLoader loader, String className, Class&amp;lt;?&amp;gt; classBeingRedefined, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                ProtectionDomain protectionDomain, &lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;[] classfileBuffer) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; IllegalClassFormatException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!className.equals(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;com/cn/hydra/test/Fruit&quot;&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; calculate();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                e.printStackTrace();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 calculate 方法中，使用 javassist 动态的改变了方法的定义：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;static &lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;[] calculate() throws Exception {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ClassPool pool = ClassPool.getDefault();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    CtClass ctClass = pool.get(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;com.cn.hydra.test.Fruit&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    CtMethod ctMethod = ctClass.getDeclaredMethod(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;getFruit&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    CtMethod copyMethod = CtNewMethod.&lt;span class=&quot;code-snippet__built_in&quot;&gt;copy&lt;/span&gt;(ctMethod, ctClass, &lt;span class=&quot;code-snippet__built_in&quot;&gt;new&lt;/span&gt; ClassMap());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ctMethod.setName(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;getFruit$agent&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    StringBuffer body = &lt;span class=&quot;code-snippet__built_in&quot;&gt;new&lt;/span&gt; StringBuffer(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;{\n&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            .&lt;span class=&quot;code-snippet__built_in&quot;&gt;append&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;long begin = System.nanoTime();\n&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            .&lt;span class=&quot;code-snippet__built_in&quot;&gt;append&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;getFruit$agent($$);\n&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            .&lt;span class=&quot;code-snippet__built_in&quot;&gt;append&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;System.out.println(\&quot;use \&quot;+(System.nanoTime() - begin) +\&quot; ns\&quot;);\n&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            .&lt;span class=&quot;code-snippet__built_in&quot;&gt;append&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;}&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    copyMethod.setBody(body.toString());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ctClass.addMethod(copyMethod);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; ctClass.toBytecode();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在上面的代码中，主要实现了这些功能：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;利用全限定名获取类 CtClass；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;根据方法名获取方法 CtMethod，并通过 CtNewMethod.copy 方法复制一个新的方法；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;修改旧方法的方法名为 getFruit$agent；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过 setBody 方法修改复制出来方法的内容，在新方法中进行了逻辑增强并调用了旧方法，最后将新方法添加到类中。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主程序仍然复用之前的代码，执行查看结果，完成了代理中的执行时间统计功能：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2981878088962109&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9Mic7DYGxlweUWn2pX1n9vRDffTd9ibVPzkiaulcSRMyHIUBdmTiaHB0Yc5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;607&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这时候我们可以再通过反射看一下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (Method method : Fruit.class.getDeclaredMethods()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(method.getName());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    method.invoke(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Fruit());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;-------&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;查看结果，可以看到类中确实已经新增了一个方法：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47796610169491527&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9MHMCAoIKB0FR0urfTstXQfiarQOD1JmwaCvKVGLcSauT1kKeh0vB6law/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;590&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;除此之外，javassist 还有很多其他的功能，例如新建 Class、设置父类、读取和写入字节码等等，大家可以在具体的场景中学习它的用法。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;虽然我们在平常的工作中，直接用到 Java Agent 的场景可能并不是很多，但是在热部署、监控、性能分析等工具中，它们可能隐藏在业务系统的角落里，一直在默默发挥着巨大的作用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文从 Java Agent 的两种模式入手，手动实现并简要分析了它们的工作流程。虽然在这里只利用它们完成了一些简单的功能，但是不得不说，正是 Java Agent 的出现，让程序的运行不再循规蹈矩，也为我们的代码提供了无限的可能性。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1650abb6796a707f506e2cb5cbe17f98</guid>
<title>[推荐] 面渣逆袭：JVM经典五十问，这下面试稳了！</title>
<link>https://toutiao.io/k/wideaab</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是老三，“&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzkwODE5ODM0Ng==&amp;amp;action=getalbum&amp;amp;album_id=2041709347461709827&amp;amp;scene=173&amp;amp;from_msgid=2247488709&amp;amp;from_itemidx=1&amp;amp;count=3&amp;amp;nolastread=1#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;面渣逆袭&lt;/a&gt;“系列继续，这节我们来搞定JVM。说真的，JVM调优什么的一个程序员可能整个职业生涯都碰不到两次，但是，一旦用到的时候，那就是救命了，而且最重要的是——面试必问，所以，还能怎么办？整！&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;引言&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.什么是JVM?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM——Java虚拟机，它是Java实现平台无关性的基石。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java程序运行的时候，编译器将Java文件编译成平台无关的Java字节码文件（.class）,接下来对应平台JVM对字节码文件进行解释，翻译成对应平台匹配的机器指令并运行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT6sCpCRPEkDmXia2Af3mnSXiaDAdXlxP4crT1Ph9RZGg5rVyGzK4d3P4A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Java语言编译运行&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时JVM也是一个跨语言的平台，和语言无关，只和class的文件格式关联，任何语言，只要能翻译成符合规范的字节码文件，都能被JVM运行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTNhiae9Zu0KoxXUE44fxKLMQTNwAdAfn4Ih4o16MUpPEGRdxk1MyXm6A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;JVM跨语言&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;内存管理&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.能说一下JVM的内存区域吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM内存区域最粗略的划分可以分为&lt;code&gt;堆&lt;/code&gt;和&lt;code&gt;栈&lt;/code&gt;，当然，按照虚拟机规范，可以划分为以下几个区域：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTrefbiarN08NsiabzYjseLpa5ib4rlxRWl3icjNQGZ6f6pcAmfZKiaOLTGbw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Java虚拟机运行时数据区&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM内存分为线程私有区和线程共享区，其中&lt;code&gt;方法区&lt;/code&gt;和&lt;code&gt;堆&lt;/code&gt;是线程共享区，&lt;code&gt;虚拟机栈&lt;/code&gt;、&lt;code&gt;本地方法栈&lt;/code&gt;和&lt;code&gt;程序计数器&lt;/code&gt;是线程隔离的数据区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1、程序计数器&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序计数器（Program Counter Register）也被称为PC寄存器，是一块较小的内存空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它可以看作是当前线程所执行的字节码的行号指示器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2、Java虚拟机栈&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java虚拟机栈描述的是Java方法执行的线程内存模型：方法执行时，JVM会同步创建一个栈帧，用来存储局部变量表、操作数栈、动态连接等。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTN2lzU3fCTMeSzcuLs9N9CWxN7LGpHZ6B3v0iaAwPAzpickO70BCHiaplw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Java虚拟机栈&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3、本地方法栈&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 虚拟机规范允许本地方法栈被实现成固定大小的或者是根据计算动态扩展和收缩的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4、Java堆&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于Java应用程序来说，Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java里“&lt;strong&gt;几乎&lt;/strong&gt;”所有的对象实例都在这里分配内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”（Garbage Collected Heap，）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现&lt;code&gt;新生代&lt;/code&gt;、&lt;code&gt;老年代&lt;/code&gt;、&lt;code&gt;Eden空间&lt;/code&gt;、&lt;code&gt;From Survivor空间&lt;/code&gt;、&lt;code&gt;To Survivor空间&lt;/code&gt;等名词，需要注意的是这种划分只是根据垃圾回收机制来进行的划分，不是Java虚拟机规范本身制定的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT0V3y5wXvIu5EQdSuAibX23yicpNNFfQ99CTZkhhYRGicvQh0HegfqQpGw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Java 堆内存结构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;5.方法区&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法区是比较特别的一块区域，和堆类似，它也是各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它特别在Java虚拟机规范对它的约束非常宽松，所以方法区的具体实现历经了许多变迁，例如jdk1.7之前使用永久代作为方法区的实现。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.说一下JDK1.6、1.7、1.8内存区域的变化？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK1.6、1.7/1.8内存区域发生了变化，主要体现在方法区的实现：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTcbdiaps8YA1WTibKewfAIEf82Y0ickAh2wB2iaD6yEVED9Kib8iaqKzS6T8A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;JDK 1.6内存区域&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;JDK1.7时发生了一些变化，将字符串常量池、静态变量，存放在堆上&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTEsicg5FQqMuq51jv3hHfj6y0n3RXibicTZP8dDgQeiaXxflug804zicpuSw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;JDK 1.7内存区域&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在JDK1.8时彻底干掉了永久代，而在直接内存中划出一块区域作为&lt;strong&gt;元空间&lt;/strong&gt;，运行时常量池、类常量池都移动到元空间。&lt;/p&gt;&lt;figure&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTLm5dph6wcoQ7LsBzWeWd9LqJNpPIGXOTfwj6oXAYL9pv9GtNsUq0JQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;JDK 1.8内存区域&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.为什么使用元空间替代永久代作为方法区的实现？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java虚拟机规范规定的方法区只是换种方式实现。有客观和主观两个原因。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;客观上使用永久代来实现方法区的决定的设计导致了Java应用更容易遇到内存溢出的问题（永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会出问题），而且有极少数方法 （例如String::intern()）会因永久代的原因而导致不同虚拟机下有不同的表现。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;主观上当Oracle收购BEA获得了JRockit的所有权后，准备把JRockit中的优秀功能，譬如Java Mission Control管理工具，移植到HotSpot 虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。考虑到HotSpot未来的发展，在JDK 6的 时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了，到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Meta-space）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.对象创建的过程了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JVM中对象的创建，我们从一个new指令开始：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就先执行相应的类加载过程&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;类加载检查通过后，接下来虚拟机将为新生对象分配内存。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;内存分配完成之后，虚拟机将分配到的内存空间（但不包括对象头）都初始化为零值。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;接下来设置对象头，请求头里包含了对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个过程大概图示如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTI3SsibF3J171z2nX1QL460maVXOnL3GJTFicsO4y6iaIicFgMic4zsnSJyw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;对象创建过程&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6.什么是指针碰撞？什么是空闲列表？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存分配有两种方式，&lt;strong&gt;指针碰撞&lt;/strong&gt;（Bump The Pointer）、&lt;strong&gt;空闲列表&lt;/strong&gt;（Free List）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTqkW9BcnpksRB5NcMtyjpwlKviayTmu68j4MflCtpY8oEl7dXsQkOicrw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;指针碰撞和空闲列表&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;指针碰撞：假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;空闲列表：如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;两种方式的选择由Java堆是否规整决定，Java堆是否规整是由选择的垃圾收集器是否具有压缩整理能力决定的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7.JVM 里 new 对象时，堆会发生抢占吗？JVM是怎么设计来保证线程安全的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;会，假设JVM虚拟机上，每一次new 对象时，指针就会向右移动一个对象size的距离，一个线程正在给A对象分配内存，指针还没有来的及修改，另一个为B对象分配内存的线程，又引用了这个指针来分配内存，这就发生了抢占。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有两种可选方案来解决这个问题：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT76tQN7aZYXZhgc9v9pDxibzE4FoYWFSSHTZZwAV4PhjZgwmbceYAXAg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;堆抢占和解决方案&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;采用CAS分配重试的方式来保证更新操作的原子性&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;每个线程在Java堆中预先分配一小块内存，也就是本地线程分配缓冲（Thread Local Allocation&lt;/p&gt;&lt;p&gt;Buffer，TLAB），要分配内存的线程，先在本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8.能说一下对象的内存布局吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTY5FSkH1KVsMXcZnjc1ErBkakvpYmCr08wfb4BqEFzKVLqVBhMQQrOg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;对象的存储布局&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;对象头&lt;/strong&gt;主要由两部分组成：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一部分存储对象自身的运行时数据：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，官方称它为Mark Word，它是个动态的结构，随着对象状态变化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二部分是类型指针，指向对象的类元数据类型（即对象代表哪个类）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;此外，如果对象是一个Java数组，那还应该有一块用于记录数组长度的数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;实例数据&lt;/strong&gt;用来存储对象真正的有效信息，也就是我们在程序代码里所定义的各种类型的字段内容，无论是从父类继承的，还是自己定义的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;对齐填充&lt;/strong&gt;不是必须的，没有特别含义，仅仅起着占位符的作用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;9.对象怎么访问定位？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java程序会通过栈上的reference数据来操作堆上的具体对象。由于reference类型在《Java虚拟机规范》里面只规定了它是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置，所以对象访问方式也是由虚拟机实现而定的，主流的访问方式主要有使用句柄和直接指针两种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息，其结构如图所示：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTXFcy5QuefJhIRibTDBr80RIficQPJN5rk8glVNQ0nRj9XL72ppLZTJiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;通过句柄访问对象&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销，如图所示：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTYldac8BLjSK1jQblvnPz5XOdwHsbSH0VDYCntop74tav3UQxIDr1nA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;通过直接指针访问对象&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HotSpot虚拟机主要使用直接指针来进行对象访问。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;10.内存溢出和内存泄漏是什么意思？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存泄露就是申请的内存空间没有被正确释放，导致内存被白白占用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存溢出就是申请的内存超过了可用内存，内存不够了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两者关系：内存泄露可能会导致内存溢出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用一个有味道的比喻，内存溢出就是排队去蹲坑，发现没坑位了，内存泄漏，就是有人占着茅坑不拉屎，占着茅坑不拉屎的多了可能会导致坑位不够用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTbl6wa1yZSXBJhnQYdo4EmKL91w2U3b3k8uFNV5sY7OHVNnIPricuq2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;内存泄漏、内存溢出&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;11.能手写内存溢出的例子吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JVM的几个内存区域中，除了程序计数器外，其他几个运行时区域都有发生内存溢出（OOM）异常的可能，重点关注堆和栈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java堆用于储存对象实例，只要不断创建不可被回收的对象，比如静态对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常（OutOfMemoryError）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就相当于一个房子里，不断堆积不能被收走的杂物，那么房子很快就会被堆满了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * VM参数： -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HeapOOM&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;OOMObject&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;OOMObject&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;OOMObject&amp;gt;();&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            list.add(&lt;span&gt;new&lt;/span&gt; OOMObject());&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK使用的HotSpot虚拟机的栈内存大小是固定的，我们可以把栈的内存设大一点，然后不断地去创建线程，因为操作系统给每个进程分配的内存是有限的，所以到最后，也会发生OutOfMemoryError异常。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * vm参数：-Xss2M&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JavaVMStackOOM&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;dontStop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;stackLeakByThread&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;                &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                    dontStop();&lt;br/&gt;                }&lt;br/&gt;            });&lt;br/&gt;            thread.start();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{&lt;br/&gt;        JavaVMStackOOM oom = &lt;span&gt;new&lt;/span&gt; JavaVMStackOOM();&lt;br/&gt;        oom.stackLeakByThread();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;12.内存泄漏可能由哪些原因导致呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存泄漏可能的原因有很多种：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTj2R64dfqznKMQcFWzASAQNSl9gcuDxbc6icjeMpe6GiaeI9Cbyu3ficqw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;内存泄漏可能原因&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;静态集合类引起内存泄漏&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;静态集合的生命周期和 JVM 一致，所以静态集合引用的对象不能被释放。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;OOM&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;static&lt;/span&gt; List list = &lt;span&gt;new&lt;/span&gt; ArrayList();&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;oomTests&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;   Object obj = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;&lt;br/&gt;   list.add(obj);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;单例模式&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和上面的例子原理类似，单例对象在初始化后会以静态变量的方式在 JVM 的整个生命周期中存在。如果单例对象持有外部的引用，那么这个外部对象将不能被 GC 回收，导致内存泄漏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据连接、IO、Socket等连接&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建的连接不再使用时，需要调用 &lt;strong&gt;close&lt;/strong&gt; 方法关闭连接，只有连接被关闭后，GC 才会回收对应的对象（Connection，Statement，ResultSet，Session）。忘记关闭这些资源会导致持续占有内存，无法被 GC 回收。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            Connection conn = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;            Class.forName(&lt;span&gt;&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt;);&lt;br/&gt;            conn = DriverManager.getConnection(&lt;span&gt;&quot;url&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;);&lt;br/&gt;            Statement stmt = conn.createStatement();&lt;br/&gt;            ResultSet rs = stmt.executeQuery(&lt;span&gt;&quot;....&quot;&lt;/span&gt;);&lt;br/&gt;          } &lt;span&gt;catch&lt;/span&gt; (Exception e) { &lt;br/&gt;           &lt;br/&gt;          }&lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//不关闭连接&lt;/span&gt;&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;变量不合理的作用域&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个变量的定义作用域大于其使用范围，很可能存在内存泄漏；或不再使用对象没有及时将对象设置为 null，很可能导致内存泄漏的发生。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Simple&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Object object;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;method1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        object = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;        &lt;span&gt;//...其他代码&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//由于作用域原因，method1执行完成之后，object 对象所分配的内存不会马上释放&lt;/span&gt;&lt;br/&gt;        object = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;hash值发生变化&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对象Hash值改变，使用HashMap、HashSet等容器中时候，由于对象修改之后的Hah值和存储进容器时的Hash值不同，所以无法找到存入的对象，自然也无法单独删除了，这也会造成内存泄漏。说句题外话，这也是为什么String类型被设置成了不可变类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ThreadLocal使用不当&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal的弱引用导致内存泄漏也是个老生常谈的话题了，使用完ThreadLocal一定要记得使用remove方法来进行清除。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;13.如何判断对象仍然存活？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有两种方式，**引用计数算法（reference counting）**和可达性分析算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引用计数器的算法是这样的：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTZiaq73lOU6kKF1PmDdLnPnIDjFAfffCMTu5vP7BkKDopUiaDGvNx78HA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;引用计数算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前 Java 虚拟机的主流垃圾回收器采取的是可达性分析算法。这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集（Gc Root Set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTwXhzhPuC1NmAzWXmE5FmZXwcMRz8thEPVc3lKkF74gILtribxRJ0LUg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;14.Java中可作为GC Roots的对象有哪几种？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以作为GC Roots的主要有四种对象：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;虚拟机栈(栈帧中的本地变量表)中引用的对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方法区中类静态属性引用的对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方法区中常量引用的对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本地方法栈中JNI引用的对象&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;15.说一下对象有哪几种引用？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java中的引用有四种，分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;强引用是最传统的&lt;code&gt;引用&lt;/code&gt;的定义，是指在程序代码之中普遍存在的引用赋值，无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Object obj =&lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;        Object obj = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;        ReferenceQueue queue = &lt;span&gt;new&lt;/span&gt; ReferenceQueue();&lt;br/&gt;        SoftReference reference = &lt;span&gt;new&lt;/span&gt; SoftReference(obj, queue);&lt;br/&gt;        &lt;span&gt;//强引用对象滞空，保留软引用&lt;/span&gt;&lt;br/&gt;        obj = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;        Object obj = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;        ReferenceQueue queue = &lt;span&gt;new&lt;/span&gt; ReferenceQueue();&lt;br/&gt;        WeakReference reference = &lt;span&gt;new&lt;/span&gt; WeakReference(obj, queue);&lt;br/&gt;        &lt;span&gt;//强引用对象滞空，保留软引用&lt;/span&gt;&lt;br/&gt;        obj = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;        Object obj = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;        ReferenceQueue queue = &lt;span&gt;new&lt;/span&gt; ReferenceQueue();&lt;br/&gt;        PhantomReference reference = &lt;span&gt;new&lt;/span&gt; PhantomReference(obj, queue);&lt;br/&gt;        &lt;span&gt;//强引用对象滞空，保留软引用&lt;/span&gt;&lt;br/&gt;        obj = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTzEruV6Mu4mKfWqZdAyicj71dyWhU4j6Kedwic2W4nwmaAj8EzoVFcDGw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;四种引用总结&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;16.finalize()方法了解吗？有什么作用？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用一个不太贴切的比喻，垃圾回收就是古代的秋后问斩，finalize()就是刀下留人，在人犯被处决之前，还要做最后一次审计，青天大老爷看看有没有什么冤情，需不需要刀下留人。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT76PAiaQLAV8hQpg8Ezg36uVItzNkqzX5jP66L2zl21Km74Uqcicw5DFg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;刀下留人&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。如果对象在在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 （this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它就”逃过一劫“；但是如果没有抓住这个机会，那么对象就真的要被回收了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;17.Java堆的内存分区了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照垃圾收集，将Java堆划分为**新生代 （Young Generation）&lt;strong&gt;和&lt;/strong&gt;老年代（Old Generation）**两个区域，新生代存放存活时间短的对象，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而新生代又可以分为三个区域，eden、from、to，比例是8：1：1，而新生代的内存分区同样是从垃圾收集的角度来分配的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTILmlIV9ECMWEVibImt63ebRsXqP6exzE0lNLQ8eJAV2cXicnk8jwLs0A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Java堆内存划分&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;18.垃圾收集算法了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垃圾收集算法主要有三种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;标记-清除算法&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;见名知义，&lt;code&gt;标记-清除&lt;/code&gt;（Mark-Sweep）算法分为两个阶段：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;标记&lt;/strong&gt; : 标记出所有需要回收的对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;清除&lt;/strong&gt;：回收所有被标记的对象&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT03GOXRmjSQLq8Kp9AvtUFahuwI6ibIv4KzXt9whicxqDf2AJ0BRe3MiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;标记-清除算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记-清除算法比较基础，但是主要存在两个缺点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;标记-复制算法&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记-复制算法解决了标记-清除算法面对大量可回收对象时执行效率低的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过程也比较简单：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTu9U2nWFMGA4rWRXW0qHGPiaNYzMicoMSibP848Sxwg3rLFfcrsh9VvTRA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;标记-复制算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种算法存在一个明显的缺点：一部分空间没有使用，存在空间的浪费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新生代垃圾收集主要采用这种算法，因为新生代的存活对象比较少，每次复制的只是少量的存活对象。当然，实际新生代的收集不是按照这个比例。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;标记-整理算法&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了降低内存的消耗，引入一种针对性的算法：&lt;code&gt;标记-整理&lt;/code&gt;（Mark-Compact）算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTx2Iafn9HyDvr0UXP6fq41xVPvnAYQd0eJ7eP53XDEWR8j7F1FjZEag/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;标记-整理算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记-整理算法主要用于老年代，移动存活对象是个极为负重的操作，而且这种操作需要Stop The World才能进行，只是从整体的吞吐量来考量，老年代使用标记-整理算法更加合适。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;19.说一下新生代的区域划分？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新生代的垃圾收集主要采用标记-复制算法，因为新生代的存活对象比较少，每次复制少量的存活对象效率比较高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于这种算法，虚拟机将内存分为一块较大的Eden空间和两块较小的 Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。默认Eden和Survivor的大小比例是8∶1。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT4YHlwFclfhibRsibkPxqrp2eHSXY71WBAytV0CjrjdyoruE7s9rQeDRg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;新生代内存划分&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;20.Minor GC/Young GC、Major GC/Old GC、Mixed GC、Full GC都是什么意思？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;部分收集&lt;/strong&gt;（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前&lt;strong&gt;只有&lt;/strong&gt;CMS收集器会有单独收集老年代的行为。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;整堆收集&lt;/strong&gt;（Full GC）：收集整个Java堆和方法区的垃圾收集。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;21.Minor GC/Young GC什么时候触发？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新创建的对象优先在新生代Eden区进行分配，如果Eden区没有足够的空间时，就会触发Young GC来清理新生代。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;22.什么时候会触发Full GC？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个触发条件稍微有点多，往下看：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTia2jz8FrptJQ3N8DQRmYTzogpLO2jiaVZV0ZPyTZdomnoolVWPaKvTOg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Full GC触发条件&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Young GC之前检查老年代&lt;/strong&gt;：在要进行 Young GC 的时候，发现&lt;code&gt;老年代可用的连续内存空间&lt;/code&gt; &amp;lt; &lt;code&gt;新生代历次Young GC后升入老年代的对象总和的平均大小&lt;/code&gt;，说明本次Young GC后可能升入老年代的对象大小，可能超过了老年代当前可用内存空间,那就会触发 Full GC。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Young GC之后老年代空间不足&lt;/strong&gt;：执行Young GC之后有一批对象需要放入老年代，此时老年代就是没有足够的内存空间存放这些对象了，此时必须立即触发一次Full GC&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;老年代空间不足&lt;/strong&gt;，老年代内存使用率过高，达到一定比例，也会触发Full GC。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;空间分配担保失败&lt;/strong&gt;（ Promotion Failure），新生代的 To 区放不下从 Eden 和 From 拷贝过来对象，或者新生代对象 GC 年龄到达阈值需要晋升这两种情况，老年代如果放不下的话都会触发 Full GC。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;方法区内存空间不足&lt;/strong&gt;：如果方法区由永久代实现，永久代空间不足 Full GC。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;System.gc()等命令触发&lt;/strong&gt;：System.gc()、jmap -dump 等命令会触发 full gc。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;23.对象什么时候会进入老年代？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTkR19bP4X5X1dqDVckbYcB8M68a3Aq4swUxickib8HBJKe3yYribgZNhHw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;对象进入老年代&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;长期存活的对象将进入老年代&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在对象的对象头信息中存储着对象的迭代年龄,迭代年龄会在每次YoungGC之后对象的移区操作中增加,每一次移区年龄加一.当这个年龄达到15(默认)之后,这个对象将会被移入老年代。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过这个参数设置这个年龄值。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;- XX:MaxTenuringThreshold&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;大对象直接进入老年代&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一些占用大量连续内存空间的对象在被加载就会直接进入老年代.这样的大对象一般是一些数组,长字符串之类的对。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HotSpot虚拟机提供了这个参数来设置。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;-XX：PretenureSizeThreshold&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;动态对象年龄判定&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了能更好地适应不同程序的内存状况，HotSpot虚拟机并不是永远要求对象的年龄必须达到- XX：MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;空间分配担保&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如在Young GC之后，新生代仍然有大量对象存活，就需要老年代进行分配担保，把Survivor无法容纳的对象直接送入老年代。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;24.知道有哪些垃圾收集器吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要垃圾收集器如下，图中标出了它们的工作区域、垃圾收集算法，以及配合关系。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTH8Vib0FiayIHPwScYicjhJ4ibEiceMnOz4LXHMKRiaxbETf2p1xVEcCn9N4g/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;HotSpot虚拟机垃圾收集器&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些收集器里，面试的重点是两个——&lt;strong&gt;CMS&lt;/strong&gt;和&lt;strong&gt;G1&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Serial收集器是最基础、历史最悠久的收集器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如同它的名字（串行），它是一个单线程工作的收集器，使用一个处理器或一条收集线程去完成垃圾收集工作。并且进行垃圾收集时，必须暂停其他所有工作线程，直到垃圾收集结束——这就是所谓的“Stop The World”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Serial/Serial Old收集器的运行过程如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTrsAicwCPx0558QjDzvLYiagicoSdLdSdD6GXa6JKeV8R3AaPYPEnO3GoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Serial/Serial Old收集器运行示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ParNew收集器实质上是Serial收集器的多线程并行版本，使用多条线程进行垃圾收集。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ParNew/Serial Old收集器运行示意图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTx2taFoj9KkJk0gJOg0yn4kH3fADYzPuDqea5wKNIcgouf3I2QyYI4A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;ParNew/Serial Old收集器运行示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Parallel Scavenge收集器是一款新生代收集器，基于标记-复制算法实现，也能够并行收集。和ParNew有些类似，但Parallel Scavenge主要关注的是垃圾收集的吞吐量——所谓吞吐量，就是CPU用于运行用户代码的时间和总消耗时间的比值，比值越大，说明垃圾收集的占比越小。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT8eb1TJQZFLyvX1ZRYeiaG6tIzNicd9XOcxQLHRnKWzCUkr285AZhfaxg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;吞吐量&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTW7Fiab6ToYoS76g2YAulthtYZiafxct4L7eGQwlDgCFGdSLACZa1zWWA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Parallel Scavenge/Parallel Old收集器运行示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，同样是老年代的收集器，采用标记-清除算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Garbage First（简称G1）收集器是垃圾收集器的一个颠覆性的产物，它开创了局部收集的设计思路和基于Region的内存布局形式。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;25.什么是Stop The World ? 什么是 OopMap ？什么是安全点？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进行垃圾回收的过程中，会涉及对象的移动。为了保证对象引用更新的正确性，必须暂停所有的用户线程，像这样的停顿，虚拟机设计者形象描述为&lt;code&gt;Stop The World&lt;/code&gt;。也简称为STW。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在HotSpot中，有个数据结构（映射表）称为&lt;code&gt;OopMap&lt;/code&gt;。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，记录到OopMap。在即时编译过程中，也会在&lt;code&gt;特定的位置&lt;/code&gt;生成 OopMap，记录下栈上和寄存器里哪些位置是引用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些特定的位置主要在：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;1.循环的末尾（非 counted 循环）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;2.方法临返回前 / 调用方法的call指令后&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;3.可能抛异常的位置&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些位置就叫作&lt;strong&gt;安全点(safepoint)。&lt;/strong&gt; 用户程序执行时并非在代码指令流的任意位置都能够在停顿下来开始垃圾收集，而是必须是执行到安全点才能够暂停。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用通俗的比喻，假如老王去拉车，车上东西很重，老王累的汗流浃背，但是老王不能在上坡或者下坡休息，只能在平地上停下来擦擦汗，喝口水。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT8LZHjoVgNeiaVMsLeicGn7aHEyazxGy9GSVOPnEEwrjSuzkcalu8ARxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;老王拉车只能在平路休息&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;26.能详细说一下CMS收集器的垃圾收集过程吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CMS收集齐的垃圾收集分为四步：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;初始标记&lt;/strong&gt;（CMS initial mark）：单线程运行，需要Stop The World，标记GC Roots能直达的对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;并发标记&lt;/strong&gt;（（CMS concurrent mark）：无停顿，和用户线程同时运行，从GC Roots直达对象开始遍历整个对象图。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;重新标记&lt;/strong&gt;（CMS remark）：多线程运行，需要Stop The World，标记并发标记阶段产生对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;并发清除&lt;/strong&gt;（CMS concurrent sweep）：无停顿，和用户线程同时运行，清理掉标记阶段标记的死亡的对象。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Concurrent Mark Sweep收集器运行示意图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT2sTricwq5keYkNCoEW12KA7IeUNQq1Q4kXj8wqELUiac71VB00iaorgUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Concurrent Mark Sweep收集器运行示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;27.G1垃圾收集器了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Garbage First（简称G1）收集器是垃圾收集器的一个颠覆性的产物，它开创了局部收集的设计思路和基于Region的内存布局形式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异。以前的收集器分代是划分新生代、老年代、持久代等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;G1把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT6FqGp13gGUHUpD94omUYNSba7EF1E2C95F3bduicH6lYiasfaQhLZXibg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;G1 Heap Regions&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就避免了收集整个堆，而是按照若干个Region集进行收集，同时维护一个优先级列表，跟踪各个Region回收的“价值，优先收集价值高的Region。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;G1收集器的运行过程大致可划分为以下四个步骤：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;初始标记&lt;/strong&gt;（initial mark），标记了从GC Root开始直接关联可达的对象。STW（Stop the World）执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;并发标记&lt;/strong&gt;（concurrent marking），和用户线程并发执行，从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象、&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;最终标记&lt;/strong&gt;（Remark），STW，标记再并发标记过程中产生的垃圾。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;筛选回收&lt;/strong&gt;（Live Data Counting And Evacuation），制定回收计划，选择多个Region 构成回收集，把回收集中Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间。需要STW。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTnibUuMAwtqgTqNuGu7fHUK4XSLXCzR1G0WakjBicOcBjS1LgyZpS55Ig/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;G1收集器运行示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;28.有了CMS，为什么还要引入G1？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：CMS最主要的优点在名字上已经体现出来——并发收集、低停顿。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：CMS同样有三个明显的缺点。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Mark Sweep算法会导致内存碎片比较多&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CMS的并发能力比较依赖于CPU资源，并发回收时垃圾收集线程可能会抢占用户线程的资源，导致用户程序性能下降。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;并发清除阶段，用户线程依然在运行，会产生所谓的理“浮动垃圾”（Floating Garbage），本次垃圾收集无法处理浮动垃圾，必须到下一次垃圾收集才能处理。如果浮动垃圾太多，会触发新的垃圾回收，导致性能降低。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;G1主要解决了内存碎片过多的问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;29.你们线上用的什么垃圾收集器？为什么要用它？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么说呢，虽然调优说的震天响，但是我们一般都是用默认。管你Java怎么升，我用8，那么JDK1.8默认用的是什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;java -XX:+PrintCommandLineFlags -version&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到有这么一行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;-XX:+UseParallelGC&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;UseParallelGC&lt;/code&gt; = &lt;code&gt;Parallel Scavenge + Parallel Old&lt;/code&gt;，表示的是新生代用的&lt;code&gt;Parallel Scavenge&lt;/code&gt;收集器，老年代用的是&lt;code&gt;Parallel Old&lt;/code&gt; 收集器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那为什么要用这个呢？默认的呗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然面试肯定不能这么答。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Parallel Scavenge的特点是什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;高吞吐，我们可以回答：因为我们系统是业务相对复杂，但并发并不是非常高，所以希望尽可能的利用处理器资源，出于提高吞吐量的考虑采用&lt;code&gt;Parallel Scavenge + Parallel Old&lt;/code&gt;的组合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，这个默认虽然也有说法，但不太讨喜。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还可以说：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采用&lt;code&gt;Parallel New&lt;/code&gt;+&lt;code&gt;CMS&lt;/code&gt;的组合，我们比较关注服务的响应速度，所以采用了CMS来降低停顿时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者一步到位：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们线上采用了设计比较优秀的G1垃圾收集器，因为它不仅满足我们低停顿的要求，而且解决了CMS的浮动垃圾问题、内存碎片问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;30.垃圾收集器应该如何选择？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垃圾收集器的选择需要权衡的点还是比较多的——例如运行应用的基础设施如何？使用JDK的发行商是什么？等等……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里简单地列一下上面提到的一些收集器的适用场景：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Serial ：如果应用程序有一个很小的内存空间（大约100 MB）亦或它在没有停顿时间要求的单线程处理器上运行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Parallel：如果优先考虑应用程序的峰值性能，并且没有时间要求要求，或者可以接受1秒或更长的停顿时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CMS/G1：如果响应时间比吞吐量优先级高，或者垃圾收集暂停必须保持在大约1秒以内。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ZGC：如果响应时间是高优先级的，或者堆空间比较大。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;31.对象一定分配在堆中吗？有没有了解逃逸分析技术？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;对象一定分配在堆中吗？&lt;/strong&gt; 不一定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着JIT编译期的发展与逃逸分析技术逐渐成熟，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。其实，在编译期间，JIT会对代码做很多优化。其中有一部分优化的目的就是减少内存堆分配压力，其中一种重要的技术叫做逃逸分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;什么是逃逸分析？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;逃逸分析&lt;/strong&gt;是指分析指针动态范围的方法，它同编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他方法或者线程所引用，这种现象称作指针（或者引用）的逃逸(Escape)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通俗点讲，当一个对象被new出来之后，它可能被外部所调用，如果是作为参数传递到外部了，就称之为方法逃逸。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTynkkcDXF9sKPjYEbYzMD8SaIW4j1iawsVqy4xy2ukHuaItaPwUXNnfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;逃逸&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，如果对象还有可能被外部线程访问到，例如赋值给可以在其它线程中访问的实例变量，这种就被称为线程逃逸。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTTOX3vvAdwcByN7iaxpH1MiakOAnH9KgvR4sOgRH962y6tatVXFMKqFzg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;逃逸强度&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;逃逸分析的好处&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果确定一个对象不会逃逸到线程之外，那么久可以考虑将这个对象在栈上分配，对象占用的内存随着栈帧出栈而销毁，这样一来，垃圾收集的压力就降低很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争， 对这个变量实施的同步措施也就可以安全地消除掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个数据是基本数据类型，不可拆分，它就被称之为标量。把一个Java对象拆散，将其用到的成员变量恢复为原始类型来访问，这个过程就称为标量替换。假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么可以不创建对象，直接用创建若干个成员变量代替，可以让对象的成员变量在栈上分配和读写。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;JVM调优&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;32.有哪些常用的命令行性能监控和故障处理工具？&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;操作系统工具&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;top：显示系统整体资源使用情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;vmstat：监控内存和CPU&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;iostat：监控IO使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;netstat：监控网络使用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;JDK性能监控工具&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;jps：虚拟机进程查看&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jstat：虚拟机运行时信息查看&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jinfo：虚拟机配置查看&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jmap：内存映像（导出）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jhat：堆转储快照分析&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jstack：Java堆栈跟踪&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jcmd：实现上面除了jstat外所有命令的功能&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;33.了解哪些可视化的性能监控和故障处理工具？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是一些JDK自带的可视化性能监控和故障处理工具：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTibBKNxlQnYeOVuUaBEsuIJ3kXTqCkFKQ7vvtC7ibiab8Q2ryYiaMl6ibhlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;JConsole概览&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTd5Ks3dLxgcznsRWvAUjGYrnYibsTpIlnE1APYGg7EDFO6jm2lxnb5bQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;VisualVM安装插件&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTic6Bc6zaxFx6kEHCXhDWibd6vY5bb8iagBlmOrqpDia6ELCp1MiauNsRPAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;JMC主要界面&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，还有一些第三方的工具：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 堆内存分析工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GC 日志分析工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;GC&lt;/code&gt; 日志分析工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;商用的性能分析利器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阿里开源诊断工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 应用性能分析工具，开源、火焰图、跨平台。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;34.JVM的常见参数配置知道哪些？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一些常见的参数配置：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;堆配置：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;-Xms:初始堆大小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-Xms：最大堆大小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:NewSize=n:设置年轻代大小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:NewRatio=n:设置年轻代和年老代的比值。如：为3表示年轻代和年老代比值为1：3，年轻代占整个年轻代年老代和的1/4&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如3表示Eden：3 Survivor：2，一个Survivor区占整个年轻代的1/5&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:MaxPermSize=n:设置持久代大小&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;收集器设置：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;-XX:+UseSerialGC:设置串行收集器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+UseParallelGC:设置并行收集器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+UseParalledlOldGC:设置并行年老代收集器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+UseConcMarkSweepGC:设置并发收集器&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;并行收集器设置&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:MaxGCPauseMillis=n:设置并行收集最大的暂停时间（如果到这个时间了，垃圾回收器依然没有回收完，也会停止回收）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为：1/(1+n)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:ParallelGCThreads=n:设置并发收集器年轻代手机方式为并行收集时，使用的CPU数。并行收集线程数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;打印GC回收的过程日志信息&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;-XX:+PrintGC&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+PrintGCDetails&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+PrintGCTimeStamps&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-Xloggc:filename&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;35.有做过JVM调优吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM调优是一件很严肃的事情，不是拍脑门就开始调优的，需要有严密的分析和监控机制，大概的一个JVM调优流程图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT4jicGxb8ENuyvB7pwKLWylruUQbqR0xAgFyNNMHPWXRwickIMefjlWgA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;JVM调优大致流程图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上，JVM调优是不得已而为之，有那功夫，好好把烂代码重构一下不比瞎调JVM强。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，面试官非要问怎么办？可以从处理问题的角度来回答（对应图中事后），这是一个中规中矩的案例：电商公司的运营后台系统，偶发性的引发OOM异常，堆内存溢出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、因为是偶发性的，所以第一次简单的认为就是堆内存不足导致，单方面的加大了堆内存从4G调整到8G   -Xms8g。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、但是问题依然没有解决，只能从堆内存信息下手，通过开启了-XX:+HeapDumpOnOutOfMemoryError参数 获得堆内存的dump文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、用JProfiler 对  堆dump文件进行分析，通过JProfiler查看到占用内存最大的对象是String对象，本来想跟踪着String对象找到其引用的地方，但dump文件太大，跟踪进去的时候总是卡死，而String对象占用比较多也比较正常，最开始也没有认定就是这里的问题，于是就从线程信息里面找突破点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、通过线程进行分析，先找到了几个正在运行的业务线程，然后逐一跟进业务线程看了下代码，有个方法引起了我的注意，&lt;code&gt;导出订单信息&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5、因为订单信息导出这个方法可能会有几万的数据量，首先要从数据库里面查询出来订单信息，然后把订单信息生成excel，这个过程会产生大量的String对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6、为了验证自己的猜想，于是准备登录后台去测试下，结果在测试的过程中发现导出订单的按钮前端居然没有做点击后按钮置灰交互事件，后端也没有做防止重复提交，因为导出订单数据本来就非常慢，使用的人员可能发现点击后很久后页面都没反应，然后就一直点，结果就大量的请求进入到后台，堆内存产生了大量的订单对象和EXCEL对象，而且方法执行非常慢，导致这一段时间内这些对象都无法被回收，所以最终导致内存溢出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7、知道了问题就容易解决了，最终没有调整任何JVM参数，只是做了两个处理：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在前端的导出订单按钮上加上了置灰状态，等后端响应之后按钮才可以进行点击&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;后端代码加分布式锁，做防重处理&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样双管齐下，保证导出的请求不会一直打到服务端，问题解决！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;36.线上服务CPU占用过高怎么排查？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题分析：CPU高一定是某个程序长期占用了CPU资源。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTiaAoib9d8fhbGUaPsOZ121D3fLC7EUY0HtO8b5JY1g2Su7LhahcQaWzw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;CPU飙高&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、所以先需要找出那个进程占用CPU高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、然后根据找到对应进行里哪个线程占用CPU高。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;top -Hp 进程ID   列出对应进程里面的线程占用资源情况&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、找到对应线程ID后，再打印出对应线程的堆栈信息&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;printf &quot;%x\n&quot;  PID    把线程ID转换为16进制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jstack PID 打印出进程的所有线程信息，从打印出来的线程信息中找到上一步转换为16进制的线程ID对应的线程信息。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、最后根据线程的堆栈信息定位到具体业务方法,从代码逻辑中找到问题所在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看是否有线程长时间的watting 或blocked，如果线程长期处于watting状态下， 关注watting on xxxxxx，说明线程在等待这把锁，然后根据锁的地址找到持有锁的线程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;37.内存飙高问题怎么排查？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析：内存飚高如果是发生在java进程上，一般是因为创建了大量对象所导致，持续飚高说明垃圾回收跟不上对象创建的速度，或者内存泄露导致对象无法回收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、先观察垃圾回收的情况&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;jstat -gc PID 1000 查看GC次数，时间等信息，每隔一秒打印一次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jmap -histo PID | head -20   查看堆内存占用空间最大的前20个对象类型,可初步查看是哪个对象占用了内存。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果每次GC次数频繁，而且每次回收的内存空间也正常，那说明是因为对象创建速度快导致内存一直占用很高；如果每次回收的内存非常少，那么很可能是因为内存泄露导致内存一直无法被回收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、导出堆内存文件快照&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;jmap -dump:live,format=b,file=/home/myheapdump.hprof PID  dump堆内存信息到文件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、使用visualVM对dump文件进行离线分析，找到占用内存高的对象，再找到创建该对象的业务代码位置，从代码和业务场景中定位具体问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;38.频繁 minor gc 怎么办？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优化Minor GC频繁问题：通常情况下，由于新生代空间较小，Eden区很快被填满，就会导致频繁Minor  GC，因此可以通过增大新生代空间&lt;code&gt;-Xmn&lt;/code&gt;来降低Minor GC的频率。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;39.频繁Full GC怎么办？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Full GC的排查思路大概如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;清楚从程序角度，有哪些原因导致FGC？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;大对象&lt;/strong&gt;：系统一次性加载了过多数据到内存中（比如SQL查询未做分页），导致大对象进入了老年代。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;内存泄漏&lt;/strong&gt;：频繁创建了大量对象，但是无法被回收（比如IO对象使用完后未调用close方法释放资源），先引发FGC，最后导致OOM.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;程序频繁生成一些&lt;strong&gt;长生命周期的对象&lt;/strong&gt;，当这些对象的存活年龄超过分代年龄时便会进入老年代，最后引发FGC. （即本文中的案例）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;程序BUG&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码中&lt;strong&gt;显式调用了gc&lt;/strong&gt;方法，包括自己的代码甚至框架中的代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JVM参数设置问题：包括总内存大小、新生代和老年代的大小、Eden区和S区的大小、元空间大小、垃圾回收算法等等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;清楚排查问题时能使用哪些工具&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;公司的监控系统：大部分公司都会有，可全方位监控JVM的各项指标。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JDK的自带工具，包括jmap、jstat等常用命令：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看堆内存各区域的使用率以及GC情况&lt;/span&gt;&lt;br/&gt;jstat -gcutil -h20 pid 1000&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看堆内存中的存活对象，并按空间排序&lt;/span&gt;&lt;br/&gt;jmap -histo pid | head -n20&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; dump堆内存文件&lt;/span&gt;&lt;br/&gt;jmap -dump:format=b,file=heap pid&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可视化的堆内存分析工具：JVisualVM、MAT等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;排查指南&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;查看监控，以了解出现问题的时间点以及当前FGC的频率（可对比正常情况看频率是否正常）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;了解该时间点之前有没有程序上线、基础组件升级等情况。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;了解JVM的参数设置，包括：堆空间各个区域的大小设置，新生代和老年代分别采用了哪些垃圾收集器，然后分析JVM参数设置是否合理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再对步骤1中列出的可能原因做排除法，其中元空间被打满、内存泄漏、代码显式调用gc方法比较容易排查。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;针对大对象或者长生命周期对象导致的FGC，可通过 jmap -histo 命令并结合dump堆内存文件作进一步分析，需要先定位到可疑对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过可疑对象定位到具体代码再次分析，这时候要结合GC原理和JVM参数设置，弄清楚可疑对象是否满足了进入到老年代的条件才能下结论。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;40.有没有处理过内存泄漏问题？是如何定位的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存泄漏是内在病源，外在病症表现可能有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;应用程序长时间连续运行时性能严重下降&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CPU 使用率飙升，甚至到 100%&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;频繁 Full GC，各种报警，例如接口超时报警等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;应用程序抛出 &lt;code&gt;OutOfMemoryError&lt;/code&gt; 错误&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;应用程序偶尔会耗尽连接对象&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;严重&lt;strong&gt;内存泄漏&lt;/strong&gt;往往伴随频繁的 &lt;strong&gt;Full GC&lt;/strong&gt;，所以分析排查内存泄漏问题首先还得从查看 Full GC 入手。主要有以下操作步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用 &lt;code&gt;jps&lt;/code&gt; 查看运行的 Java 进程 ID&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用&lt;code&gt;top -p [pid]&lt;/code&gt; 查看进程使用 CPU 和 MEM 的情况&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用 &lt;code&gt;top -Hp [pid]&lt;/code&gt; 查看进程下的所有线程占 CPU 和 MEM 的情况&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将线程 ID 转换为 16 进制：&lt;code&gt;printf &quot;%x\n&quot; [pid]&lt;/code&gt;，输出的值就是线程栈信息中的 &lt;strong&gt;nid&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;例如：&lt;code&gt;printf &quot;%x\n&quot; 29471&lt;/code&gt;，换行输出 &lt;strong&gt;731f&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;抓取线程栈：&lt;code&gt;jstack 29452 &amp;gt; 29452.txt&lt;/code&gt;，可以多抓几次做个对比。&lt;/p&gt;&lt;p&gt;在线程栈信息中找到对应线程号的 16 进制值，如下是 &lt;strong&gt;731f&lt;/strong&gt; 线程的信息。线程栈分析可使用 Visualvm 插件 &lt;strong&gt;TDA&lt;/strong&gt;。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&quot;Service Thread&quot;&lt;/span&gt; #&lt;span&gt;7&lt;/span&gt; daemon prio=&lt;span&gt;9&lt;/span&gt; os_prio=&lt;span&gt;0&lt;/span&gt; tid=&lt;span&gt;0x00007fbe2c164000&lt;/span&gt; nid=&lt;span&gt;0x731f&lt;/span&gt; runnable [&lt;span&gt;0x0000000000000000&lt;/span&gt;]&lt;br/&gt;   java.lang.Thread.State: RUNNABLE&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用&lt;code&gt;jstat -gcutil [pid] 5000 10&lt;/code&gt; 每隔 5 秒输出 GC 信息，输出 10 次，查看 &lt;strong&gt;YGC&lt;/strong&gt; 和 &lt;strong&gt;Full GC&lt;/strong&gt; 次数。通常会出现 YGC 不增加或增加缓慢，而 Full GC 增加很快。&lt;/p&gt;&lt;p&gt;或使用 &lt;code&gt;jstat -gccause [pid] 5000&lt;/code&gt; ，同样是输出 GC 摘要信息。&lt;/p&gt;&lt;p&gt;或使用 &lt;code&gt;jmap -heap [pid]&lt;/code&gt; 查看堆的摘要信息，关注老年代内存使用是否达到阀值，若达到阀值就会执行 Full GC。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果发现 &lt;code&gt;Full GC&lt;/code&gt; 次数太多，就很大概率存在内存泄漏了&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用 &lt;code&gt;jmap -histo:live [pid]&lt;/code&gt; 输出每个类的对象数量，内存大小(字节单位)及全限定类名。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;生成 &lt;code&gt;dump&lt;/code&gt; 文件，借助工具分析哪 个对象非常多，基本就能定位到问题在那了&lt;/p&gt;&lt;p&gt;使用 jmap 生成 dump 文件：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# jmap -dump:live,format=b,file=&lt;span&gt;29471&lt;/span&gt;.dump &lt;span&gt;29471&lt;/span&gt;&lt;br/&gt;Dumping heap to /root/dump ...&lt;br/&gt;Heap dump file created&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以使用 &lt;strong&gt;jhat&lt;/strong&gt; 命令分析：&lt;code&gt;jhat -port 8000 29471.dump&lt;/code&gt;，浏览器访问 jhat 服务，端口是 8000。&lt;/p&gt;&lt;p&gt;通常使用图形化工具分析，如 JDK 自带的 &lt;strong&gt;jvisualvm&lt;/strong&gt;，从菜单 &amp;gt; 文件 &amp;gt; 装入 dump 文件。&lt;/p&gt;&lt;p&gt;或使用第三方式具分析的，如 &lt;strong&gt;JProfiler&lt;/strong&gt; 也是个图形化工具，&lt;strong&gt;GCViewer&lt;/strong&gt; 工具。Eclipse 或以使用 MAT 工具查看。或使用在线分析平台 &lt;strong&gt;GCEasy&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;注意：如果 dump 文件较大的话，分析会占比较大的内存。&lt;/p&gt;&lt;p&gt;基本上就可以定位到代码层的逻辑了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ol start=&quot;11&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在 dump 文析结果中查找存在大量的对象，再查对其的引用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;dump 文件分析&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;41.有没有处理过内存溢出问题？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存泄漏和内存溢出二者关系非常密切，内存溢出可能会有很多原因导致，内存泄漏最可能的罪魁祸首之一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;排查过程和排查内存泄漏过程类似。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;虚拟机执行&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;42.能说一下类的生命周期吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个类从被加载到虚拟机内存中开始，到从内存中卸载，整个生命周期需要经过七个阶段：加载 （Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）、使用（Using）和卸载（Unloading），其中验证、准备、解析三个部分统称为连接（Linking）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTQ4kgKmAgYMV4GYJSLgiaOZeyLX7ibpRenh6ebqiaQkiaBHaOx2kVFRBS4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;类的生命周期&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;43.类加载的过程知道吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加载是JVM加载的起点，具体什么时候开始加载，《Java虚拟机规范》中并没有进行强制约束，可以交给虚拟机的具体实现来自由把握。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在加载过程，JVM要做三件事情：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTpWvLTEpdH0icvwhcCqmUm78AOAdXWA9o8ZELScYBU5Yh2XZ7wgVx1Iw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;加载&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;1）通过一个类的全限定名来获取定义此类的二进制字节流。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区中的数据存储格式完全由虚拟机实现自行定义，《Java虚拟机规范》未规定此区域的具体数据结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象， 这个对象将作为程序访问方法区中的类型数据的外部接口。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;44.类加载器有哪些？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要有四种类加载器:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;启动类加载器&lt;/strong&gt;(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;扩展类加载器&lt;/strong&gt;(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;系统类加载器&lt;/strong&gt;（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;用户自定义类加载器&lt;/strong&gt; (user class loader)，用户通过继承 java.lang.ClassLoader类的方式自行实现的类加载器。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;45.什么是双亲委派机制？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTtcyiaOeuLwFYlzwvuNujp8nkcg12lY7C631yKNy9I3HibB3HsKpoeQkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;双亲委派模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;46.为什么要用双亲委派机制？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是为了保证应用程序的稳定有序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如类java.lang.Object，它存放在rt.jar之中，通过双亲委派机制，保证最终都是委派给处于模型最顶端的启动类加载器进行加载，保证Object的一致。反之，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为java.lang.Object的类，并放在程序的 ClassPath中，那系统中就会出现多个不同的Object类。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;47.如何破坏双亲委派机制？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不想打破双亲委派模型，就重写ClassLoader类中的fifindClass()方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。而如果想打破双亲委派模型则需要重写loadClass()方法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;48.历史上有哪几次双亲委派机制的破坏？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派机制在历史上主要有三次破坏：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTOicIJL9OMa5am46V4EpXLL2qoWSDyTeMOeJpgSxI4FBkNBb8SaPmqQw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;双亲委派模型的三次破坏&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;第一次破坏&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK 1.2面世以前的“远古”时代。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类  java.lang.ClassLoader则在Java的第一个版本中就已经存在，为了向下兼容旧代码，所以无法以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK 1.2之后的java.lang.ClassLoader中添加一个新的  protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在 loadClass()中编写代码。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;第二次破坏&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，如果有基础类型又要调用回用户的代码，那该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如我们比较熟悉的JDBC:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;各个厂商各有不同的JDBC的实现，Java在核心包&lt;code&gt;\lib&lt;/code&gt;里定义了对应的SPI，那么这个就毫无疑问由&lt;code&gt;启动类加载器&lt;/code&gt;加载器加载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是各个厂商的实现，是没办法放在核心包里的，只能放在&lt;code&gt;classpath&lt;/code&gt;里，只能被&lt;code&gt;应用类加载器&lt;/code&gt;加载。那么，问题来了，启动类加载器它就加载不到厂商提供的SPI服务代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，引入了一个不太优雅的设计：线程上下文类加载器 （Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;第三次破坏&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，例如代码热替换（Hot Swap）、模块热部署（Hot Deployment）等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OSGi实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为 Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;49.你觉得应该怎么实现一个热部署功能？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们已经知道了Java类的加载过程。一个Java类文件到虚拟机里的对象，要经过如下过程:首先通过Java编译器，将Java文件编译成class字节码，类加载器读取class字节码，再将类转化为实例，对实例newInstance就可以生成对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类加载器ClassLoader功能，也就是将class字节码转换到类的实例。在Java应用中，所有的实例都是由类加载器，加载而来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般在系统中，类的加载都是由系统自带的类加载器完成，而且对于同一个全限定名的java类（如com.csiar.soc.HelloWorld），只能被加载一次，而且无法被卸载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候问题就来了，如果我们希望将java类卸载，并且替换更新版本的java类，该怎么做呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然在类加载器中，Java类只能被加载一次，并且无法卸载。那么我们是不是可以直接把Java类加载器干掉呢？答案是可以的，我们可以自定义类加载器，并重写ClassLoader的findClass方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想要实现热部署可以分以下三个步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;销毁原来的自定义ClassLoader&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更新class类文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建新的ClassLoader去加载更新后的class类文件。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到此，一个热部署的功能就这样实现了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;50.Tomcat的类加载机制了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Tomcat是主流的Java Web服务器之一，为了实现一些特殊的功能需求，自定义了一些类加载器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Tomcat类加载器如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTMGYrkqKcRpLsXsiaicqrvSRhr9XaibAvk2beJwFCCcWjtcjoeueUSrQeg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Tomcat类加载器&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Tomcat实际上也是破坏了双亲委派模型的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Tomact是web容器，可能需要部署多个应用程序。不同的应用程序可能会依赖同一个第三方类库的不同版本，但是不同版本的类库中某一个类的全路径名可能是一样的。如多个应用都要依赖hollis.jar，但是A应用需要依赖1.0.0版本，但是B应用需要依赖1.0.1版本。这两个版本中都有一个类是com.hollis.Test.class。如果采用默认的双亲委派类加载机制，那么无法加载多个相同的类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，Tomcat破坏了&lt;strong&gt;双亲委派原则&lt;/strong&gt;，提供隔离的机制，为每个web容器单独提供一个WebAppClassLoader加载器。每一个WebAppClassLoader负责加载本身的目录下的class文件，加载不到时再交CommonClassLoader加载，这和双亲委派刚好相反。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;好了，本期的50道JVM面试题就分享到这了，下期继续分享Java并发相关面试题，&lt;big&gt;&lt;strong&gt;点赞&lt;/strong&gt;&lt;/big&gt;、&lt;big&gt;&lt;strong&gt;关注&lt;/strong&gt;&lt;/big&gt;  不迷路，咱们下期见！&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ed3d9fa7bba99675b1043635ce0d67d2</guid>
<title>[推荐] 网络编程怎么做才算是优雅？</title>
<link>https://toutiao.io/k/zylzzpi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;174&quot; data-backw=&quot;365&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4767123287671233&quot; data-type=&quot;gif&quot; data-w=&quot;365&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/cvQbJDZsKLp6wejHtKTRbqqQyt0wMk9K1wNtuwRqQTJAPOJ1KiaqSeSRbIJRTicVicKpDKRndBodY2DBNN20tvWwA/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原创：小姐姐味道（微信公众号ID：xjjdog），欢迎分享，转载请保留出处。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;据说，web2.0的魅力在于由静态资源变成交互性资源，web3.0的魅力在于其去中心化的资源，大家都可以参与其中得享时代的福利。但是，无论上层概念玩的再花哨，最下层的通信还是基于web1.0所形成的技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的终极目标，其实就是打着去中心化的名义，做实际上的中心化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当流量增加到一定程度，网络编程会发生各种怪异的场景。下面将以十几个实际的案例，来说明xjjdog平常在工作中遇到的与网络相关的高频问题，希望能够助你一臂之力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 大量客户端上线注意躲避&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论你的服务器能力多强，在大批量连接到来，进行业务服务的时候，都会产生瞬时的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，如果你的MQTT服务器连接了几十万台设备。当你的MQTT服务器宕机重启的时候，就要接受几十万的并发，这几乎没有任何服务能够受得了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在xjjdog以往的经验中，因为服务端重启问题而造成的阻塞事故，数不胜数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个场景，其实和缓存的击穿概念非常的相似。当缓存中的热点数据集中失效的时候，请求就会全部击穿到数据库层面，造成问题。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4798807749627422&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1342&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLr2VuKPZxnONlCFrhAIg0Agc6t3LlnbibUrKk6UCDUnCzAfqntNh0mz60QcMVpNHaDPMFfyDp0aj5A/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图，解决缓存击穿问题就是给每个key加个失效时间的随机值，让它们不要在同一时间失效。类似的，我们可以在客户端重连服务端的时候，加上一个随机的时间。随机数是个好东西，它能让我们的海量连接在随机时间窗口内保持类线性的增长。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 多网卡队列&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在类似openstack等虚拟平台上假设的虚拟机，往往因为网卡能力不强而造成流量在达到一定程度之后，服务发生卡顿。这是因为单个cpu在处理中断时，产生了瓶颈。通过dstat或者iftop命令，可以看到当前的网络流量。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4381551362683438&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;954&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLraeg3qV1NqYqicNYpXMukH2HSibZc6bRbZyvIKzHKsczuuwpRuviamELTCT78oUQaUkmZzLnvPXricYQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，Kafka新机器上线之后，会进行大规模的数据拷贝，这个时候如果你去ping相关的机器，会发现ping值变的非常大。同时，&lt;code&gt;Recv-Q&lt;/code&gt;和&lt;code&gt;Send-Q&lt;/code&gt;的值也会增大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候，就需要开启网卡多队列模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;ethtool&lt;/code&gt;可以看到网卡的队列信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ethtool -l eth0 | grep &lt;span&gt;&#x27;Combined&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;Combined: 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，通过下面的命令，可以增加网卡的队列。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ethtool -L eth0 combined 2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建议同时开启中断平衡服务。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;systemctl start irqbalance&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 不定时的切断一下长连接&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果客户端和服务端连接上了，并一直保持连接不关闭对方，那么它就是一条长连接。长连接可以避免频繁的连接创建所产生的开销。从HTTP1到HTTP2再到HTTP3，一直在向减少连接，复用连接方面去努力。通常情况下，长连接是第一选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但有一些特殊情况，我们希望长连接并不要一直在那里保持着，需要给它增加TTL。这种情况通常发生在负载均衡场景里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如LVS、HAProxy等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果后端有A、B、C三台机器，经过LVS负载之后，90条连接被分散到三台机器。但某个时刻，A宕机了，它所持有的30个连接就会被重新负载到B、C上，这时候它们都持有45条连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当A重启之后，它却再也拿不到新的连接。如果LVS运算一次再平衡的话，产生的影响也比较大。所以我们希望创建的长连接能够有一个生存时长的属性，在某个时间间隔内达到渐进式的再平衡。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. k8s端口范围&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了k8s和别的程序不起冲突，默认端口的范围是 30000-32767。如果你在使用k8s平台，配置了nodeport但是无法访问到，要注意是不是设置的端口号太小了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. TIME_WAIT&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TIME_WAIT是主动关闭连接的一方保持的状态，像nginx、爬虫服务器，经常发生大量处于time_wait状态的连接。TCP一般在主动关闭连接后，会等待2MS，然后彻底关闭连接。由于HTTP使用了TCP协议，所以在这些频繁开关连接的服务器上，就积压了非常多的TIME_WAIT状态连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;某些系统通过dmesg可以看到以下信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;__ratelimit: 2170 callbacks suppressed&lt;br/&gt;TCP: time &lt;span&gt;wait&lt;/span&gt; bucket table overflow&lt;br/&gt;TCP: time &lt;span&gt;wait&lt;/span&gt; bucket table overflow&lt;br/&gt;TCP: time &lt;span&gt;wait&lt;/span&gt; bucket table overflow&lt;br/&gt;TCP: time &lt;span&gt;wait&lt;/span&gt; bucket table overflow&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sysctl命令可以设置这些参数，如果想要重启生效的话，加入/etc/sysctl.conf文件中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# 修改阈值&lt;/span&gt;&lt;br/&gt;net.ipv4.tcp_max_tw_buckets = 50000 &lt;br/&gt;&lt;span&gt;# 表示开启TCP连接中TIME-WAIT sockets的快速回收&lt;/span&gt;&lt;br/&gt;net.ipv4.tcp_tw_reuse = 1&lt;br/&gt;&lt;span&gt;#启用timewait 快速回收。这个一定要开启，默认是关闭的。&lt;/span&gt;&lt;br/&gt;net.ipv4.tcp_tw_recycle= 1   &lt;br/&gt;&lt;span&gt;# 修改系統默认的TIMEOUT时间,默认是60s&lt;/span&gt;&lt;br/&gt;net.ipv4.tcp_fin_timeout = 10&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试参数的话，可以使用 sysctl -w net.ipv4.tcp_tw_reuse = 1 这样的命令。如果是写入进文件的，则使用sysctl -p生效。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. CLOSE_WAIT&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CLOSE_WAIT一般是由于对端主动关闭，而我方没有正确处理的原因引起的。说白了，就是程序写的有问题，属于危害比较大的一种。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家都知道TCP的连接是三次握手四次挥手，这是由于TCP连接允许单向关闭。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0374707259953162&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;427&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLraeg3qV1NqYqicNYpXMukH2Hic8Rj6p5VFicDO6n01u1CNMWO3db3SdCibKMqOz8u3yv9wOicoWyS5sPQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图，当一个连接发起主动关闭之后，它将进入fin_wait_1状态。同时，收到fin报文的被动关闭方，进入close_wait状态，然后回复ack后，主动关闭方进入fin_wait_2状态。这就是单向的关闭。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，如果被动关闭方因为某些原因，没有发送fin报文给主动关闭方，那么它就会一直处于close_wait状态。比如，收到了EOF但没有发起close操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然，这多数是一种编程bug，只能通过代码review来解决。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7. 一个进程能够打开的网络连接&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4233576642335766&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;685&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLraeg3qV1NqYqicNYpXMukH2hIibPMZfiaXutYUhHiaqpYdg2bKY24g6Nj96l0KpdV7JUC1041pEO0Aiag/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux即使放开一个端口，能够接受的连接也是海量的。这些连接的上限，受到单进程文件句柄数量和操作系统文件句柄数量的限制，也就是ulimit和file-max。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了能够将参数修改持久化，我们倾向于将改动写入到文件里。进程的文件句柄限制，可以放在&lt;code&gt;/etc/security/limits.conf&lt;/code&gt;中，它的上限受到&lt;code&gt;fs.nr_open&lt;/code&gt;的制约；操作系统的文件句柄限制，可以放到&lt;code&gt;/etc/sysctl.conf&lt;/code&gt;文件中。最后，别忘了在&lt;code&gt;/proc/$id/limits&lt;/code&gt;文件中，确认修改是否对进程生效了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;/etc/security/limits.conf配置案例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;root soft nofile 1000000&lt;br/&gt;root hard nofile 1000000&lt;br/&gt;* soft nofile 1000000&lt;br/&gt;* hard nofile 1000000&lt;br/&gt;es  -  nofile  65535&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8. SO_KEEPALIVE&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果将这个Socket选项打开，客户端Socket每隔段的时间（大约两个小时）就会利用空闲的连接向服务器发送一个数据包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个数据包并没有其它的作用，只是为了检测一下服务器是否仍处于活动状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果服务器未响应这个数据包，在大约11分钟后，客户端Socket再发送一个数据包，如果在12分钟内，服务器还没响应，那么客户端Socket将关闭。如果将Socket选项关闭，客户端Socket在服务器无效的情况下可能会长时间不会关闭。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9. SO_REUSEADDR是为了解决什么问题&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们在网络开发时，时常会碰到&lt;code&gt;address already in use&lt;/code&gt;的异常，这是由于关闭应用程序时，还有对应端口的网络连接处于&lt;code&gt;TIME_WAIT&lt;/code&gt;状态而造成的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TIME_WAIT状态通常会持续一段时间（2ML），设置SO_REUSEADDR可以支持快速端口复用，支持应用的快速重启。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;10. 健康检查采用应用心跳&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;tcp自身的keepalived机制非常的鸡肋，它静悄悄的在底层运行，无法产生应用层的语义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们的想象里，连接就应该是一条线。但其实，它只是2个点，而且每次走的路径都可能不一样。一个点，需要在发出心跳包然后收到回复之后，才能知道对方是否存活。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;tcp自带的心跳机制，仅仅能知道对方是否存活，对于服务是否可用，健康状况这些东西一概不知，而且超时配置常常与超时重传机制相冲突。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，有确切含义的应用层心跳是必要的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;11. SO_LINGER&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个Socket选项可以影响close方法的行为。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在默认情况下，当调用close方法后，将立即返回；如果这时仍然有未被送出的数据包，那么这些数据包将被丢弃。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果将linger参数设为一个正整数n时（n的值最大是65，535），在调用close方法后，将最多被阻塞n秒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这n秒内，系统将尽量将未送出的数据包发送出去；如果超过了n秒，如果还有未发送的数据包，这些数据包将全部被丢弃；而close方法会立即返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果将linger设为0，和关闭SO_LINGER选项的作用是一样的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;12. SO_TIMEOUT&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过这个选项来设置读取数据超时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当输入流的read方法被阻塞时，如果设置timeout（timeout的单位是毫秒），那么系统在等待了timeout毫秒后会抛出一个InterruptedIOException例外。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在抛出例外后，输入流并未关闭，你可以继续通过read方法读取数据。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;13. SO_SNDBUF，SO_RCVBUF&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在默认情况下，输出流的发送缓冲区是8096个字节（8K）。这个值是Java所建议的输出缓冲区的大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这个默认值不能满足要求，可以用setSendBufferSize方法来重新设置缓冲区的大小。但最好不要将输出缓冲区设得太小，否则会导致传输数据过于频繁，从而降低网络传输的效率。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;14. SO_OOBINLINE&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这个Socket选项打开，可以通过Socket类的sendUrgentData方法向服务器发送一个单字节的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个单字节数据并不经过输出缓冲区，而是立即发出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然在客户端并不是使用OutputStream向服务器发送数据，但在服务端程序中这个单字节的数据是和其它的普通数据混在一起的。因此，在服务端程序中并不知道由客户端发过来的数据是由OutputStream还是由sendUrgentData发过来的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;End&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我非常惊讶的发现，现在有些网络环境，依然还是千兆网卡，包括一些比较专业的测试环境。当在这些环境上进行实际的压测时，当流量突破了网卡的限制，应用响应将会变的异常缓慢。计算机系统是一个整体，CPU、内存、网络、IO，任何一环出现瓶颈，都会造成问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式系统中，网络是一个非常重要的因素。但由于它相对来说比较底层，所以大多数开发对其了解较少。加上现在各种云原生组件的流行，接触这些底层设施的机会就越来越少。但如果系统真的发生了问题，在排除掉其他最可能出问题的组件后，千万别忘了--&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有网络这一摊子等着你。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;作者简介：&lt;strong&gt;小姐姐味道&lt;/strong&gt;  (xjjdog)，一个不允许程序员走弯路的公众号。聚焦基础架构和Linux。十年架构，日百亿流量，与你探讨高并发世界，给你不一样的味道。我的个人微信xjjdog0，欢迎添加好友，进一步交流。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3a676082c2425e9d5ae55a5f471e09b6</guid>
<title>[推荐] 缓存一致性最佳实践</title>
<link>https://toutiao.io/k/ymscqc1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4382826&quot; data-w=&quot;559&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbbFu7n3GktsBgczeVd0RHngWc5I6Wvf01FzUtDwQibTQEpYeZSM64W8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;背景 &lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;最近团队里我们在密集的讨论Redis缓存一致性相关的问题，电商核心的域如商品、营销、库存、订单等实际上在缓存的选择上各有特色，那么在这些差异的业务背后，我们有没有一些最佳实践可供参考呢？&lt;/p&gt;&lt;p&gt;本文尝试着来讨论这个问题，并给出一些建议。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在讨论之前，有两个重点我们需要达成一致：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分布式场景下无法做到强一致&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不同于CPU硬件缓存体系采用的MESI协议以及硬件的强时钟控制，分布式场景下我们无法做到缓存与底层数据库的强一致，即把缓存和数据库的数据变更做成一个原子操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;硬件工程师设计了内存屏障（Memory Barrier）的概念，提供给软件开发者不同的一致性选项在性能与一致性上进行权衡。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;就算是达到最终一致性也很难&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;分布式场景下，要做到最终一致性，就要求缓存中存储的是最新版本的数据（或者缓存为空），而且是在数据库更新后很迅速的就要达到这个一致性的状态，要做到是极其困难的。&lt;/p&gt;&lt;p&gt;我们会面临硬件、软件、通信等等组件非常多的异常情况。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5409836&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbvSxeCUz3xV2YIUErVqjzgbHHKuhWXsU0JyWT3jfkpKJPI1Z14xiatxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;976&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;CPU的缓存结构&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;缓存的一致性问题&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;一般化来说，我们面临的是这样的一个问题，如下图所示，数据库的数据会有5次更新，产生6个版本，V1~V6，图中每个方框的长度代表这个版本持续的时间。&lt;/p&gt;&lt;p&gt;我们期望，在数据库中的数据变化后，缓存层需要尽快的感知到并作出反应，如下图所示，缓存层方框中的间隔代表这个时间段缓存数据不存在，V2、V3以及V5版本在缓存中不存在并不会破坏我们的最终一致性要求，只要数据库的最终版本和缓存的最终版本是相同的就可以了。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2796296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbpcFMVGBvhuLoH4m6rYIj8yhttcP7lbiaonk7s2MgEjNyQmj9zOCXE1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;缓存是如何写入的&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存写入的代码通常情况下都是和缓存使用的代码放在一起的，包含4个步骤，如下图所示：W1读取缓存，W2判断缓存是否存在，W3组装缓存数据（这通常需要向数据库进行查询），W4写入缓存。&lt;/p&gt;&lt;p&gt;每一个步骤间可能会停顿多久是没有办法控制的，尤其是W3、W4之间的停顿最为要命，它很可能让我们将旧版本的数据写入到缓存中。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;我们可能会想，W4步的写入，带上W2的假设，即使用WriteIfNotExists语义，会不会有所改善？&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3916667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTb20FjhyT48qhUfho2h4bwblJcIsFVibcSh0dgWLCqB0hicJ8EDgk8VUyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;考虑如下的情形，假设有3个缓存写入的并发执行，由于短时间数据库大量的更新，它们分别组装的是V1、V2、V3版本的数据。&lt;/p&gt;&lt;p&gt;使用WriteIfNotExists语义，其中必然有2个执行会失败，哪一个会成功根本无法保证。&lt;/p&gt;&lt;p&gt;我们无法简单的做决策，需要再次将缓存读取出来，然后判断是否我们即将写入的一样，如果一样那就很简单；如果不一样的话，我们有两种选择：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;将缓存删除，让后续别的请求来处理写入。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用缓存提供的原子操作，仅在我们的数据是较新版本时写入。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.27833&quot; data-w=&quot;1006&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbxFk3v9PuJ3VBXYmdBKGOcvrMXAyRjrqiaXlId1X7Q849lA9Gbon5dpg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;如何感知数据库的变化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;数据库的数据发生变化后，我们如何感知到并进行有效的缓存管理呢？&lt;/p&gt;&lt;p&gt;通常情况下有如下的3种做法：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用代码执行流&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通常我们会在数据库操作完成后，执行一些缓存操作的代码。&lt;/p&gt;&lt;p&gt;这种方式最大的问题是可靠性不高，应用重启、机器意外当机等情况都会导致后续的代码无法执行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用事务消息&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;作为使用代码执行流的改进，在数据库操作完成后发出事务消息，然后在消息的消费逻辑里执行缓存的管理操作。&lt;/p&gt;&lt;p&gt;可靠性的问题就解决了，只是业务侧要为此增加事务消息的逻辑，以及运行成本。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用数据变更日志&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;数据库产品通常都支持在数据变更后产生变更日志，比如MySQL的binlog。&lt;/p&gt;&lt;p&gt;可以让中间件团队写一款产品，在接收到变更后执行缓存的管理操作，比如阿里的精卫。&lt;/p&gt;&lt;p&gt;可靠性有保证，同时还可以进行某个时间段变更日志的回放，功能就比较强大了。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;最佳实践一：数据库变更后失效缓存&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这是最常用和简单的方式，应该被作为首选的方案，整体的执行逻辑如下图所示：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5731481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbuFnDYpEbhQKFJQVPGlOAZaJibTSPEQ0ag8mIn1J78yhhBfdYOlLhBibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;W4步使用最基本的put语义，这里的假设是写入较晚的请求往往也是携带的最新的数据，这在大多的情形下都是成立的。&lt;/p&gt;&lt;p&gt;D1步使用监听DB binlog的方式来删除缓存，即前述使用数据变更日志中介绍的方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;这个方案的缺点是&lt;/strong&gt;：在数据库数据存在高并发更新且缓存读取流量较大的情况下，会有小概率存在缓存中存储的是旧版本数据的情况。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通常的解法有四种：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;限制缓存有效时间&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;设定缓存的过期时间，比如15分钟。即表示我们最多接受缓存在15分钟的时间范围内是旧的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;小概率缓存重加载&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;根据流量比设定一定比例的缓存重加载，以保证大流量情况下的缓存数据的一致性。&lt;/p&gt;&lt;p&gt;比如1%的比例，这同时还可以帮助数据库得到充分的预热。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;结合业务特点&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;根据业务的特点做一些设计，比如：&lt;/p&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;针对营销的场景&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;在商品详情页/确认订单页的优惠计算时使用缓存，而在下单时不使用缓存。&lt;/p&gt;&lt;p&gt;这可以让极端情况发生时，不产生过大的业务损失。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;针对库存的场景&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;读取到旧版本的数据只是会在商品已售罄的情况下让多余的流量进入到下单而已，下单时的库存扣减是操作数据库的，所以不会有业务上的损失。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;两次删除&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;D1步删除缓存的操作执行两次，且中间有一定的间隔，比如30秒。&lt;/p&gt;&lt;p&gt;这两次动作的触发都是由“缓存管理组件”发起的，所以可以由它支持。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;最佳实践二：带版本写入&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;针对象商品信息缓存这种更新频率低、数据一致性要求较高且缓存读取流量很高的场景，通常会采用带版本更新的方式，整体的执行逻辑如下图如示：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6055556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTblN4aNHDMTub6GiboN4tIj5MlIj1sSpEiamGf0A9Pu2VBmPRF9fjxcayA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;和“数据库变更后失效缓存”方案最大的差异在W4步和D1步，需要缓存层提供带版本写入的API，即仅当写入数据版本较新时可以写入成功，否则写入失败。&lt;/p&gt;&lt;p&gt;这同时也要求我们在数据库增加数据版本的信息。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个方案的最终一致性效果比较好，仅在极端情况下（新版本写入后数据丢失了，后续旧版本的写入就会成功）存在缓存中存储的是旧版本数据的可能。&lt;/p&gt;&lt;p&gt;在D1步使用写入而不是使用删除可以极大程度的避免这个极端情况的出现，同时由于该方案适用于缓存读取流量很高的场景，还可以避免缓存被删除后W3步短时间大量请求穿透到DB。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;总结与展望&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对于缓存与数据库分离的场景，在结合了业界多家公司的实践经验以及ROI权衡之后，前述的两个最佳实践是被应用的最为广泛的，尤其是最佳实践一，应该作为我们日常应用的首选。&lt;/p&gt;&lt;p&gt;同时，为了最大限度的避免每个最佳实践背后可能发生的不一致性问题，我们还需要切合业务的特点，在关键的场景上做一些保障一致性的设计（比如前述的营销在下单时使用数据库读而不是缓存读），这也显得尤为重要（毕竟如“背景”中所述，并不存在完美的技术方案）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;除了缓存与数据库分离的方案，还有两个业界已经应用的方案也值得我们借鉴：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;阿里XKV&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;简单来讲就是在数据库上部署一个Memcache的Server，它直接绕过数据库层直接访问存储引擎层（如：InnoDB），同时使用KV client来进行数据的访问。&lt;/p&gt;&lt;p&gt;它的特点是数据实际上与数据库是强一致的，性能可以比使用SQL访问数据库提升5～10倍。&lt;/p&gt;&lt;p&gt;缺点也很明显，只能通过主键或者唯一键来访问数据（这只是相对SQL来说的，大多数缓存本来也就是KV访问协议）。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;腾讯DCache&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;不用自行维护缓存与数据库两套存储，给开发人员统一的一套数据视图，由DCache在缓存更新后自行持久化数据。&lt;/p&gt;&lt;p&gt;缺点是支持的数据结构有限（ key-value，k-k-row，list，set，zset ），未来也很难支持形如数据库表一样复杂的数据结构。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.004&quot; data-w=&quot;1000&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/n4p7ssmqwmGHOiaBs4TLdiacnZ6Ub3E6Oqia4cJNlwjuvAI6fuDuXvUGb9FX2wTNgvRtdpqlSf4V780atTia0eorag/640?wx_fmt=gif&quot; data-type=&quot;gif&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;*文/苏木&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkxNTE3ODU0NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74Diclic7XyegA4UmC0SqoT4jDEpdzibjkibmAvz8svbJwfsufiaBqOWx9sskIrickxzGfCwkjuMBiaNLDxNA/0?wx_fmt=png&quot; data-nickname=&quot;得物技术&quot; data-signature=&quot;技术知识分享交流平台，与你一同走向技术的云端。&quot;/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>