<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>698d304a3b5b0645a5ec213ba29f829e</guid>
<title>愿天下无难买的菜</title>
<link>https://toutiao.io/k/49wpgo7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MzA0ODkyMA==&amp;amp;mid=2655078486&amp;amp;idx=1&amp;amp;sn=74e73b3348bcbc7159fd93a0f6eb2231&amp;amp;chksm=bd2918618a5e917715c93457bd59a6578f81c1516593ac7cf3cee8b59210dfe7736932c2adf2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;‍‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavibCwko58zNzRWjqVRjfRpn0C8vAXoia3dRvhFictjrgdrUa3sHBiaibTvTkU8mcX9NJfMYiaABFPA7JKyA/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MzA0ODkyMA==&amp;amp;mid=2655078486&amp;amp;idx=1&amp;amp;sn=74e73b3348bcbc7159fd93a0f6eb2231&amp;amp;chksm=bd2918618a5e917715c93457bd59a6578f81c1516593ac7cf3cee8b59210dfe7736932c2adf2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;非常时期囤货手册，已开源，请收好！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;非常时期囤货手册，已开源，请收好！&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;疫情当前，推荐几款开源的「买菜」工具。&lt;br/&gt;愿疫情早日结束！愿天下无难买的菜！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;br/&gt;叮咚买菜插件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 插件比手动下单更慢，不推荐在高峰期使用，可以在高峰期过后尝试，但也无法保证100%下单成功。&lt;br/&gt;2. 插件不保证兼容所有机型与安卓版本，如果发现无法使用，请及时卸载。&lt;br/&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;https://github.com/Skykai521/DingDongHelper&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;dingdong-helper&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;叮咚自动下单，并发调用接口方式，多人实战反馈10秒以内成功，自动将购物车能买的商品全部下单，只需自行编辑购物车和最后支付即可。&lt;br/&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;https://github.com/JannsenYang/dingdong-helper&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;robFood&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于 autojs pro 实现的买菜辅助脚本&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://github.com/sean529/robFood&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;山姆买菜&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://github.com/azhan1998/sam_buy&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;美团/叮咚买菜&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;兼容Mac和Windows平台，抢成功后会播放声音提醒。&lt;br/&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;https://github.com/Sjj1024/QiangCai&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;程序员做饭指南&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;用更清晰精准的描述来整理常见菜的做法，以方便程序员在家做饭。&lt;br/&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;https://github.com/Anduin2017/HowToCook&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;加入「码农周刊VIP会员」，成为更好的开发者！&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicibroqCN98y5SNT9NbfA3oHYQiaicFScHFfppgek7ZGicJiaHK45qc2zoccBibfEzIvzTsI4AB2xO2IaOw/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bbb7dd02eaa7bb22e3ccca75bf8a5244</guid>
<title>CSI 工作原理与JuiceFS CSI Driver 的架构设计详解</title>
<link>https://toutiao.io/k/623k5p8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post_content markdown&quot;&gt;&lt;p&gt;容器存储接口（Container Storage Interface）简称 CSI，CSI 建立了行业标准接口的规范，借助 CSI 容器编排系统（CO）可以将任意存储系统暴露给自己的容器工作负载。JuiceFS CSI Driver 通过实现 CSI 接口使得 Kubernetes 上的应用可以通过 PVC（PersistentVolumeClaim）使用 JuiceFS。本文将详细介绍 CSI 的工作原理以及 JuiceFS CSI Driver 的架构设计。&lt;/p&gt;&lt;h2 id=&quot;csi-的基本组件&quot;&gt;CSI 的基本组件&lt;/h2&gt;&lt;p&gt;CSI 的 cloud providers 有两种类型，一种为 in-tree 类型，一种为 out-of-tree 类型。前者是指运行在 K8s 核心组件内部的存储插件；后者是指独立在 K8s 组件之外运行的存储插件。本文主要介绍 out-of-tree 类型的插件。&lt;/p&gt;&lt;p&gt;out-of-tree 类型的插件主要是通过 gRPC 接口跟 K8s 组件交互，并且 K8s 提供了大量的 SideCar 组件来配合 CSI 插件实现丰富的功能。对于 out-of-tree 类型的插件来说，所用到的组件分为 SideCar 组件和第三方需要实现的插件。&lt;/p&gt;&lt;h3 id=&quot;sidecar-组件&quot;&gt;SideCar 组件&lt;/h3&gt;&lt;h4 id=&quot;external-attacher&quot;&gt;external-attacher&lt;/h4&gt;&lt;p&gt;监听 VolumeAttachment 对象，并调用 CSI driver Controller 服务的 &lt;code&gt;ControllerPublishVolume&lt;/code&gt; 和 &lt;code&gt;ControllerUnpublishVolume&lt;/code&gt; 接口，用来将 volume 附着到 node 上，或从 node 上删除。&lt;/p&gt;&lt;p&gt;如果存储系统需要 attach/detach 这一步，就需要使用到这个组件，因为 K8s 内部的 Attach/Detach Controller 不会直接调用 CSI driver 的接口。&lt;/p&gt;&lt;h4 id=&quot;external-provisioner&quot;&gt;external-provisioner&lt;/h4&gt;&lt;p&gt;监听 PVC 对象，并调用 CSI driver Controller 服务的 &lt;code&gt;CreateVolume&lt;/code&gt; 和 &lt;code&gt;DeleteVolume&lt;/code&gt; 接口，用来提供一个新的 volume。前提是 PVC 中指定的 StorageClass 的 provisioner 字段和 CSI driver Identity 服务的 &lt;code&gt;GetPluginInfo&lt;/code&gt; 接口的返回值一样。一旦新的 volume 提供出来，K8s 就会创建对应的 PV。&lt;/p&gt;&lt;p&gt;而如果 PVC 绑定的 PV 的回收策略是 delete，那么 external-provisioner 组件监听到 PVC 的删除后，会调用 CSI driver Controller 服务的 &lt;code&gt;DeleteVolume&lt;/code&gt; 接口。一旦 volume 删除成功，该组件也会删除相应的 PV。&lt;/p&gt;&lt;p&gt;该组件还支持从快照创建数据源。如果在 PVC 中指定了 Snapshot CRD 的数据源，那么该组件会通过 &lt;code&gt;SnapshotContent&lt;/code&gt; 对象获取有关快照的信息，并将此内容在调用 &lt;code&gt;CreateVolume&lt;/code&gt; 接口的时候传给 CSI driver，CSI driver 需要根据数据源快照来创建 volume。&lt;/p&gt;&lt;h4 id=&quot;external-resizer&quot;&gt;external-resizer&lt;/h4&gt;&lt;p&gt;监听 PVC 对象，如果用户请求在 PVC 对象上请求更多存储，该组件会调用 CSI driver Controller 服务的 &lt;code&gt;NodeExpandVolume&lt;/code&gt; 接口，用来对 volume 进行扩容。&lt;/p&gt;&lt;h4 id=&quot;external-snapshotter&quot;&gt;external-snapshotter&lt;/h4&gt;&lt;p&gt;该组件需要与 Snapshot Controller 配合使用。Snapshot Controller 会根据集群中创建的 Snapshot 对象创建对应的 VolumeSnapshotContent，而 external-snapshotter 负责监听 VolumeSnapshotContent 对象。当监听到 VolumeSnapshotContent 时，将其对应参数通过 &lt;code&gt;CreateSnapshotRequest&lt;/code&gt; 传给 CSI driver Controller 服务，调用其 &lt;code&gt;CreateSnapshot&lt;/code&gt; 接口。该组件还负责调用 &lt;code&gt;DeleteSnapshot&lt;/code&gt;、&lt;code&gt;ListSnapshots&lt;/code&gt; 接口。&lt;/p&gt;&lt;h4 id=&quot;livenessprobe&quot;&gt;livenessprobe&lt;/h4&gt;&lt;p&gt;负责监测 CSI driver 的健康情况，并通过 Liveness Probe 机制汇报给 K8s，当监测到 CSI driver 有异常时负责重启 pod。&lt;/p&gt;&lt;h4 id=&quot;node-driver-registrar&quot;&gt;node-driver-registrar&lt;/h4&gt;&lt;p&gt;通过直接调用 CSI driver Node 服务的 &lt;code&gt;NodeGetInfo&lt;/code&gt; 接口，将 CSI driver 的信息通过 kubelet 的插件注册机制在对应节点的 kubelet 上进行注册。&lt;/p&gt;&lt;h4 id=&quot;external-health-monitor-controller&quot;&gt;external-health-monitor-controller&lt;/h4&gt;&lt;p&gt;通过调用 CSI driver Controller 服务的 &lt;code&gt;ListVolumes&lt;/code&gt; 或者 &lt;code&gt;ControllerGetVolume&lt;/code&gt; 接口，来检查 CSI volume 的健康情况，并上报在 PVC 的 event 中。&lt;/p&gt;&lt;h4 id=&quot;external-health-monitor-agent&quot;&gt;external-health-monitor-agent&lt;/h4&gt;&lt;p&gt;通过调用 CSI driver Node 服务的 &lt;code&gt;NodeGetVolumeStats&lt;/code&gt; 接口，来检查 CSI volume 的健康情况，并上报在 pod 的 event 中。&lt;/p&gt;&lt;h3 id=&quot;第三方插件&quot;&gt;第三方插件&lt;/h3&gt;&lt;p&gt;第三方存储提供方（即 SP，Storage Provider）需要实现 Controller 和 Node 两个插件，其中 Controller 负责 Volume 的管理，以 StatefulSet 形式部署；Node 负责将 Volume mount 到 pod 中，以 DaemonSet 形式部署在每个 node 中。&lt;/p&gt;&lt;p&gt;CSI 插件与 kubelet 以及 K8s 外部组件是通过 Unix Domani Socket gRPC 来进行交互调用的。CSI 定义了三套 RPC 接口，SP 需要实现这三组接口，以便与 K8s 外部组件进行通信。三组接口分别是：CSI Identity、CSI Controller 和 CSI Node，下面详细看看这些接口定义。&lt;/p&gt;&lt;h4 id=&quot;csi-identity&quot;&gt;CSI Identity&lt;/h4&gt;&lt;p&gt;用于提供 CSI driver 的身份信息，Controller 和 Node 都需要实现。接口如下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;service Identity {
  rpc GetPluginInfo(GetPluginInfoRequest)
    returns (GetPluginInfoResponse) {}

  rpc GetPluginCapabilities(GetPluginCapabilitiesRequest)
    returns (GetPluginCapabilitiesResponse) {}

  rpc Probe (ProbeRequest)
    returns (ProbeResponse) {}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;GetPluginInfo&lt;/code&gt; 是必须要实现的，node-driver-registrar 组件会调用这个接口将 CSI driver 注册到 kubelet；&lt;code&gt;GetPluginCapabilities&lt;/code&gt; 是用来表明该 CSI driver 主要提供了哪些功能。&lt;/p&gt;&lt;h4 id=&quot;csi-controller&quot;&gt;CSI Controller&lt;/h4&gt;&lt;p&gt;用于实现创建/删除 volume、attach/detach volume、volume 快照、volume 扩缩容等功能，Controller 插件需要实现这组接口。接口如下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;service Controller {
  rpc CreateVolume (CreateVolumeRequest)
    returns (CreateVolumeResponse) {}

  rpc DeleteVolume (DeleteVolumeRequest)
    returns (DeleteVolumeResponse) {}

  rpc ControllerPublishVolume (ControllerPublishVolumeRequest)
    returns (ControllerPublishVolumeResponse) {}

  rpc ControllerUnpublishVolume (ControllerUnpublishVolumeRequest)
    returns (ControllerUnpublishVolumeResponse) {}

  rpc ValidateVolumeCapabilities (ValidateVolumeCapabilitiesRequest)
    returns (ValidateVolumeCapabilitiesResponse) {}

  rpc ListVolumes (ListVolumesRequest)
    returns (ListVolumesResponse) {}

  rpc GetCapacity (GetCapacityRequest)
    returns (GetCapacityResponse) {}

  rpc ControllerGetCapabilities (ControllerGetCapabilitiesRequest)
    returns (ControllerGetCapabilitiesResponse) {}

  rpc CreateSnapshot (CreateSnapshotRequest)
    returns (CreateSnapshotResponse) {}

  rpc DeleteSnapshot (DeleteSnapshotRequest)
    returns (DeleteSnapshotResponse) {}

  rpc ListSnapshots (ListSnapshotsRequest)
    returns (ListSnapshotsResponse) {}

  rpc ControllerExpandVolume (ControllerExpandVolumeRequest)
    returns (ControllerExpandVolumeResponse) {}

  rpc ControllerGetVolume (ControllerGetVolumeRequest)
    returns (ControllerGetVolumeResponse) {
        option (alpha_method) = true;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在上面介绍 K8s 外部组件的时候已经提到，不同的接口分别提供给不同的组件调用，用于配合实现不同的功能。比如 &lt;code&gt;CreateVolume&lt;/code&gt;/&lt;code&gt;DeleteVolume&lt;/code&gt; 配合 external-provisioner 实现创建/删除 volume 的功能；&lt;code&gt;ControllerPublishVolume&lt;/code&gt;/&lt;code&gt;ControllerUnpublishVolume&lt;/code&gt; 配合 external-attacher 实现 volume 的 attach/detach 功能等。&lt;/p&gt;&lt;h4 id=&quot;csi-node&quot;&gt;CSI Node&lt;/h4&gt;&lt;p&gt;用于实现 mount/umount volume、检查 volume 状态等功能，Node 插件需要实现这组接口。接口如下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;service Node {
  rpc NodeStageVolume (NodeStageVolumeRequest)
    returns (NodeStageVolumeResponse) {}

  rpc NodeUnstageVolume (NodeUnstageVolumeRequest)
    returns (NodeUnstageVolumeResponse) {}

  rpc NodePublishVolume (NodePublishVolumeRequest)
    returns (NodePublishVolumeResponse) {}

  rpc NodeUnpublishVolume (NodeUnpublishVolumeRequest)
    returns (NodeUnpublishVolumeResponse) {}

  rpc NodeGetVolumeStats (NodeGetVolumeStatsRequest)
    returns (NodeGetVolumeStatsResponse) {}

  rpc NodeExpandVolume(NodeExpandVolumeRequest)
    returns (NodeExpandVolumeResponse) {}

  rpc NodeGetCapabilities (NodeGetCapabilitiesRequest)
    returns (NodeGetCapabilitiesResponse) {}

  rpc NodeGetInfo (NodeGetInfoRequest)
    returns (NodeGetInfoResponse) {}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;NodeStageVolume&lt;/code&gt; 用来实现多个 pod 共享一个 volume 的功能，支持先将 volume 挂载到一个临时目录，然后通过 &lt;code&gt;NodePublishVolume&lt;/code&gt; 将其挂载到 pod 中；&lt;code&gt;NodeUnstageVolume&lt;/code&gt; 为其反操作。&lt;/p&gt;&lt;h2 id=&quot;工作流程&quot;&gt;工作流程&lt;/h2&gt;&lt;p&gt;下面来看看 pod 挂载 volume 的整个工作流程。整个流程流程分别三个阶段：Provision/Delete、Attach/Detach、Mount/Unmount，不过不是每个存储方案都会经历这三个阶段，比如 NFS 就没有 Attach/Detach 阶段。&lt;/p&gt;&lt;p&gt;整个过程不仅仅涉及到上面介绍的组件的工作，还涉及 ControllerManager 的 AttachDetachController 组件和 PVController 组件以及 kubelet。下面分别详细分析一下 Provision、Attach、Mount 三个阶段。&lt;/p&gt;&lt;h3 id=&quot;provision&quot;&gt;Provision&lt;/h3&gt;&lt;p&gt;先来看 Provision 阶段，整个过程如上图所示。其中 extenal-provisioner 和 PVController 均 watch PVC 资源。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;当 PVController watch 到集群中有 PVC 创建时，会判断当前是否有 in-tree plugin 与之相符，如果没有则判断其存储类型为 out-of-tree 类型，于是给 PVC 打上注解 &lt;code&gt;volume.beta.kubernetes.io/storage-provisioner={csi driver name}&lt;/code&gt;；&lt;/li&gt;&lt;li&gt;当 extenal-provisioner watch 到 PVC 的注解 csi driver 与自己的 csi driver 一致时，调用 CSI Controller 的 &lt;code&gt;CreateVolume&lt;/code&gt; 接口；&lt;/li&gt;&lt;li&gt;当 CSI Controller 的 &lt;code&gt;CreateVolume&lt;/code&gt; 接口返回成功时，extenal-provisioner 会在集群中创建对应的 PV；&lt;/li&gt;&lt;li&gt;PVController watch 到集群中有 PV 创建时，将 PV 与 PVC 进行绑定。&lt;/li&gt;&lt;/ol&gt;&lt;h3 id=&quot;attach&quot;&gt;Attach&lt;/h3&gt;&lt;p&gt;Attach 阶段是指将 volume 附着到节点上，整个过程如上图所示。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;ADController 监听到 pod 被调度到某节点，并且使用的是 CSI 类型的 PV，会调用内部的 in-tree CSI 插件的接口，该接口会在集群中创建一个 VolumeAttachment 资源；&lt;/li&gt;&lt;li&gt;external-attacher 组件 watch 到有 VolumeAttachment 资源创建出来时，会调用 CSI Controller 的 &lt;code&gt;ControllerPublishVolume&lt;/code&gt; 接口；&lt;/li&gt;&lt;li&gt;当 CSI Controller 的 &lt;code&gt;ControllerPublishVolume&lt;/code&gt; 接口调用成功后，external-attacher 将对应的 VolumeAttachment 对象的 Attached 状态设为 true；&lt;/li&gt;&lt;li&gt;ADController watch 到 VolumeAttachment 对象的 Attached 状态为 true 时，更新 ADController 内部的状态 ActualStateOfWorld。&lt;/li&gt;&lt;/ol&gt;&lt;h3 id=&quot;mount&quot;&gt;Mount&lt;/h3&gt;&lt;p&gt;最后一步将 volume 挂载到 pod 里的过程涉及到 kubelet。整个流程简单地说是，对应节点上的 kubelet 在创建 pod 的过程中，会调用 CSI Node 插件，执行 mount 操作。下面再针对 kubelet 内部的组件细分进行分析。&lt;/p&gt;&lt;p&gt;首先 kubelet 创建 pod 的主函数 &lt;code&gt;syncPod&lt;/code&gt; 中，kubelet 会调用其子组件 volumeManager 的 &lt;code&gt;WaitForAttachAndMount&lt;/code&gt; 方法，等待 volume mount 完成：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (kl *Kubelet) syncPod(o syncPodOptions) error {
...
// Volume manager will not mount volumes for terminated pods
if !kl.podIsTerminated(pod) {
// Wait for volumes to attach/mount
if err := kl.volumeManager.WaitForAttachAndMount(pod); err != nil {
kl.recorder.Eventf(pod, v1.EventTypeWarning, events.FailedMountVolume, &quot;Unable to attach or mount volumes: %v&quot;, err)
klog.Errorf(&quot;Unable to attach or mount volumes for pod %q: %v; skipping pod&quot;, format.Pod(pod), err)
return err
}
}
...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;volumeManager 中包含两个组件：desiredStateOfWorldPopulator 和 reconciler。这两个组件相互配合就完成了 volume 在 pod 中的 mount 和 umount 过程。整个过程如下：&lt;/p&gt;&lt;p&gt;desiredStateOfWorldPopulator 和 reconciler 的协同模式是生产者和消费者的模式。volumeManager 中维护了两个队列（严格来讲是 interface，但这里充当了队列的作用），即 DesiredStateOfWorld 和 ActualStateOfWorld，前者维护的是当前节点中 volume 的期望状态；后者维护的是当前节点中 volume 的实际状态。&lt;/p&gt;&lt;p&gt;而 desiredStateOfWorldPopulator 在自己的循环中只做了两个事情，一个是从 kubelet 的 podManager 中获取当前节点新建的 Pod，将其需要挂载的 volume 信息记录到 DesiredStateOfWorld 中；另一件事是从 podManager 中获取当前节点中被删除的 pod，检查其 volume 是否在 ActualStateOfWorld 的记录中，如果没有，将其在 DesiredStateOfWorld 中也删除，从而保证 DesiredStateOfWorld 记录的是节点中所有 volume 的期望状态。相关代码如下（为了精简逻辑，删除了部分代码）：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// Iterate through all pods and add to desired state of world if they don&#x27;t
// exist but should
func (dswp *desiredStateOfWorldPopulator) findAndAddNewPods() {
// Map unique pod name to outer volume name to MountedVolume.
mountedVolumesForPod := make(map[volumetypes.UniquePodName]map[string]cache.MountedVolume)
...
processedVolumesForFSResize := sets.NewString()
for _, pod := range dswp.podManager.GetPods() {
dswp.processPodVolumes(pod, mountedVolumesForPod, processedVolumesForFSResize)
}
}

// processPodVolumes processes the volumes in the given pod and adds them to the
// desired state of the world.
func (dswp *desiredStateOfWorldPopulator) processPodVolumes(
pod *v1.Pod,
mountedVolumesForPod map[volumetypes.UniquePodName]map[string]cache.MountedVolume,
processedVolumesForFSResize sets.String) {
uniquePodName := util.GetUniquePodName(pod)
    ...
for _, podVolume := range pod.Spec.Volumes {
pvc, volumeSpec, volumeGidValue, err :=
dswp.createVolumeSpec(podVolume, pod, mounts, devices)

// Add volume to desired state of world
_, err = dswp.desiredStateOfWorld.AddPodToVolume(
uniquePodName, pod, volumeSpec, podVolume.Name, volumeGidValue)
dswp.actualStateOfWorld.MarkRemountRequired(uniquePodName)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而 reconciler 就是消费者，它主要做了三件事：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;unmountVolumes()&lt;/code&gt;：在 ActualStateOfWorld 中遍历 volume，判断其是否在 DesiredStateOfWorld 中，如果不在，则调用 CSI Node 的接口执行 unmount，并在 ActualStateOfWorld 中记录；&lt;/li&gt;&lt;li&gt;&lt;code&gt;mountAttachVolumes()&lt;/code&gt;：从 DesiredStateOfWorld 中获取需要被 mount 的 volume，调用 CSI Node 的接口执行 mount 或扩容，并在 ActualStateOfWorld 中做记录；&lt;/li&gt;&lt;li&gt;&lt;code&gt;unmountDetachDevices()&lt;/code&gt;： 在 ActualStateOfWorld 中遍历 volume，若其已经 attach，但没有使用的 pod，并在 DesiredStateOfWorld 也没有记录，则将其 unmount/detach 掉。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们以 &lt;code&gt;mountAttachVolumes()&lt;/code&gt; 为例，看看其如何调用 CSI Node 的接口。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (rc *reconciler) mountAttachVolumes() {
// Ensure volumes that should be attached/mounted are attached/mounted.
for _, volumeToMount := range rc.desiredStateOfWorld.GetVolumesToMount() {
volMounted, devicePath, err := rc.actualStateOfWorld.PodExistsInVolume(volumeToMount.PodName, volumeToMount.VolumeName)
volumeToMount.DevicePath = devicePath
if cache.IsVolumeNotAttachedError(err) {
...
} else if !volMounted || cache.IsRemountRequiredError(err) {
// Volume is not mounted, or is already mounted, but requires remounting
err := rc.operationExecutor.MountVolume(
rc.waitForAttachTimeout,
volumeToMount.VolumeToMount,
rc.actualStateOfWorld,
isRemount)
...
} else if cache.IsFSResizeRequiredError(err) {
err := rc.operationExecutor.ExpandInUseVolume(
volumeToMount.VolumeToMount,
rc.actualStateOfWorld)
...
}
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行 mount 的操作全在 &lt;code&gt;rc.operationExecutor&lt;/code&gt; 中完成，再看 operationExecutor 的代码：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (oe *operationExecutor) MountVolume(
waitForAttachTimeout time.Duration,
volumeToMount VolumeToMount,
actualStateOfWorld ActualStateOfWorldMounterUpdater,
isRemount bool) error {
...
var generatedOperations volumetypes.GeneratedOperations
generatedOperations = oe.operationGenerator.GenerateMountVolumeFunc(
waitForAttachTimeout, volumeToMount, actualStateOfWorld, isRemount)

// Avoid executing mount/map from multiple pods referencing the
// same volume in parallel
podName := nestedpendingoperations.EmptyUniquePodName

return oe.pendingOperations.Run(
volumeToMount.VolumeName, podName, &quot;&quot; /* nodeName */, generatedOperations)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该函数先构造执行函数，再执行，那么再看构造函数：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (og *operationGenerator) GenerateMountVolumeFunc(
waitForAttachTimeout time.Duration,
volumeToMount VolumeToMount,
actualStateOfWorld ActualStateOfWorldMounterUpdater,
isRemount bool) volumetypes.GeneratedOperations {

volumePlugin, err :=
og.volumePluginMgr.FindPluginBySpec(volumeToMount.VolumeSpec)

mountVolumeFunc := func() volumetypes.OperationContext {
// Get mounter plugin
volumePlugin, err := og.volumePluginMgr.FindPluginBySpec(volumeToMount.VolumeSpec)
volumeMounter, newMounterErr := volumePlugin.NewMounter(
volumeToMount.VolumeSpec,
volumeToMount.Pod,
volume.VolumeOptions{})
...
// Execute mount
mountErr := volumeMounter.SetUp(volume.MounterArgs{
FsUser:              util.FsUserFrom(volumeToMount.Pod),
FsGroup:             fsGroup,
DesiredSize:         volumeToMount.DesiredSizeLimit,
FSGroupChangePolicy: fsGroupChangePolicy,
})
// Update actual state of world
markOpts := MarkVolumeOpts{
PodName:             volumeToMount.PodName,
PodUID:              volumeToMount.Pod.UID,
VolumeName:          volumeToMount.VolumeName,
Mounter:             volumeMounter,
OuterVolumeSpecName: volumeToMount.OuterVolumeSpecName,
VolumeGidVolume:     volumeToMount.VolumeGidValue,
VolumeSpec:          volumeToMount.VolumeSpec,
VolumeMountState:    VolumeMounted,
}

markVolMountedErr := actualStateOfWorld.MarkVolumeAsMounted(markOpts)
...
return volumetypes.NewOperationContext(nil, nil, migrated)
}

return volumetypes.GeneratedOperations{
OperationName:     &quot;volume_mount&quot;,
OperationFunc:     mountVolumeFunc,
EventRecorderFunc: eventRecorderFunc,
CompleteFunc:      util.OperationCompleteHook(util.GetFullQualifiedPluginNameForVolume(volumePluginName, volumeToMount.VolumeSpec), &quot;volume_mount&quot;),
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里先去注册到 kubelet 的 CSI 的 plugin 列表中找到对应的插件，然后再执行 &lt;code&gt;volumeMounter.SetUp&lt;/code&gt;，最后更新 ActualStateOfWorld 的记录。这里负责执行 external CSI 插件的是 csiMountMgr，代码如下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (c *csiMountMgr) SetUp(mounterArgs volume.MounterArgs) error {
return c.SetUpAt(c.GetPath(), mounterArgs)
}

func (c *csiMountMgr) SetUpAt(dir string, mounterArgs volume.MounterArgs) error {
csi, err := c.csiClientGetter.Get()
...

err = csi.NodePublishVolume(
ctx,
volumeHandle,
readOnly,
deviceMountPath,
dir,
accessMode,
publishContext,
volAttribs,
nodePublishSecrets,
fsType,
mountOptions,
)
    ...
return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，在 kubelet 中调用 CSI Node &lt;code&gt;NodePublishVolume&lt;/code&gt;/&lt;code&gt;NodeUnPublishVolume&lt;/code&gt; 接口的是 volumeManager 的 csiMountMgr。至此，整个 Pod 的 volume 流程就已经梳理清楚了。&lt;/p&gt;&lt;h2 id=&quot;juicefs-csi-driver-工作原理&quot;&gt;JuiceFS CSI Driver 工作原理&lt;/h2&gt;&lt;p&gt;接下来再来看看 JuiceFS CSI Driver 的工作原理。架构图如下：&lt;/p&gt;&lt;p&gt;JuiceFS 在 CSI Node 接口 &lt;code&gt;NodePublishVolume&lt;/code&gt; 中创建 pod，用来执行 &lt;code&gt;juicefs mount xxx&lt;/code&gt;，从而保证 juicefs 客户端运行在 pod 里。如果有多个的业务 pod 共用一份存储，mount pod 会在 annotation 进行引用计数，确保不会重复创建。具体的代码如下（为了方便阅读，省去了日志等无关代码）：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (p *PodMount) JMount(jfsSetting *jfsConfig.JfsSetting) error {
if err := p.createOrAddRef(jfsSetting); err != nil {
return err
}
return p.waitUtilPodReady(GenerateNameByVolumeId(jfsSetting.VolumeId))
}

func (p *PodMount) createOrAddRef(jfsSetting *jfsConfig.JfsSetting) error {
...

for i := 0; i &amp;lt; 120; i++ {
// wait for old pod deleted
oldPod, err := p.K8sClient.GetPod(podName, jfsConfig.Namespace)
if err == nil &amp;amp;&amp;amp; oldPod.DeletionTimestamp != nil {
time.Sleep(time.Millisecond * 500)
continue
} else if err != nil {
if K8serrors.IsNotFound(err) {
newPod := r.NewMountPod(podName)
if newPod.Annotations == nil {
newPod.Annotations = make(map[string]string)
}
newPod.Annotations[key] = jfsSetting.TargetPath
po, err := p.K8sClient.CreatePod(newPod)
...
return err
}
return err
}
      ...
return p.AddRefOfMount(jfsSetting.TargetPath, podName)
}
return status.Errorf(codes.Internal, &quot;Mount %v failed: mount pod %s has been deleting for 1 min&quot;, jfsSetting.VolumeId, podName)
}

func (p *PodMount) waitUtilPodReady(podName string) error {
// Wait until the mount pod is ready
for i := 0; i &amp;lt; 60; i++ {
pod, err := p.K8sClient.GetPod(podName, jfsConfig.Namespace)
...
if util.IsPodReady(pod) {
return nil
}
time.Sleep(time.Millisecond * 500)
}
...
return status.Errorf(codes.Internal, &quot;waitUtilPodReady: mount pod %s isn&#x27;t ready in 30 seconds: %v&quot;, podName, log)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;每当有业务 pod 退出时，CSI Node 会在接口 &lt;code&gt;NodeUnpublishVolume&lt;/code&gt; 删除 mount pod annotation 中对应的计数，当最后一个记录被删除时，mount pod 才会被删除。具体代码如下（为了方便阅读，省去了日志等无关代码）：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (p *PodMount) JUmount(volumeId, target string) error {
   ...
err = retry.RetryOnConflict(retry.DefaultBackoff, func() error {
po, err := p.K8sClient.GetPod(pod.Name, pod.Namespace)
if err != nil {
return err
}
annotation := po.Annotations
...
delete(annotation, key)
po.Annotations = annotation
return p.K8sClient.UpdatePod(po)
})
...

deleteMountPod := func(podName, namespace string) error {
return retry.RetryOnConflict(retry.DefaultBackoff, func() error {
po, err := p.K8sClient.GetPod(podName, namespace)
...
shouldDelay, err = util.ShouldDelay(po, p.K8sClient)
if err != nil {
return err
}
if !shouldDelay {
// do not set delay delete, delete it now
if err := p.K8sClient.DeletePod(po); err != nil {
return err
}
}
return nil
})
}

newPod, err := p.K8sClient.GetPod(pod.Name, pod.Namespace)
...
if HasRef(newPod) {
return nil
}
return deleteMountPod(pod.Name, pod.Namespace)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;CSI Driver 与 juicefs 客户端解耦，做升级不会影响到业务容器；将客户端独立在 pod 中运行也就使其在 K8s 的管控内，可观测性更强；同时 pod 的好处我们也能享受到，比如隔离性更强，可以单独设置客户端的资源配额等。&lt;/p&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;&lt;p&gt;本文从 CSI 的组件、CSI 接口、volume 如何挂载到 pod 上，三个方面入手，分析了 CSI 整个体系工作的过程，并介绍了 JuiceFS CSI Driver 的工作原理。CSI 是整个容器生态的标准存储接口，CO 通过 gRPC 方式和 CSI 插件通信，而为了做到普适，K8s 设计了很多外部组件来配合 CSI 插件来实现不同的功能，从而保证了 K8s 内部逻辑的纯粹以及 CSI 插件的简单易用。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bcfd5c60a58c5954a1d891a4d60fa9ba</guid>
<title>腾讯网关 TGW 基础原理入门</title>
<link>https://toutiao.io/k/xaremeg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：厉辉，腾讯后台研发高级工程师，当前在腾讯游戏后台团队工作，熟悉四七层负载均衡以及 API 网关等技术领域，同时也是 CNCF Ambassador 以及 Apache APISIX PMC。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本文是在组内技术分享的发言稿，主要介绍 TGW 基本原理和架构，同时为了加深理解，会辅助对比 TGW 与 LVS（ipvs）的异同。本次分享是偏基础性的 TGW 介绍，不会特别深入技术细节，目的是帮助需要用到 TGW 的同事快速的了解 TGW。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;零、引言&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TGW，全称 Tencent Gateway，是一套实现多网统一接入，支持自动负载均衡的系统。TGW 具有可靠性高，扩展性强，性能高，抗流量攻击能力强等特点，其主要提供 IP 收敛、多线接入和负载均衡的功能。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5473897617840852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasTL3gd13IGTUdJkF6WFIiaUZVTIhAd57nPUNpZuXdtUknGhs2fjXp9U4IyicuuTPkB0N94H6Edcjhg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1973&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、概况介绍&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 诞生背景&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同运营商用户间无法互通。在十几年前，中国的网络运营商主要有电信和联通两大运营商，又戏称南电信北网通，电信和网通分别布设了光缆，同一个运营商内相互联通，但运营商与运营商间互通需要经过专门的网络通道，一个是带宽有限，另一个是互通通道主要布置在骨干网，所以，在南方地区用电信的客户去访问网通的网站或者游戏，访问路径会变长，带宽受限，访问延迟高，反之也一样。就比如 DNF 的区服就分为了电信服和网通服。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7980295566502463&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasTL3gd13IGTUdJkF6WFIiaUdRUSHknjHRcyqjc7wJ14VOuoQc5gcJW0uDzCkBuSXK3uxSgDtn2jZg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;812&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分服的方式可以让同一个运营商的玩家以较低的时延游玩游戏，但当一个南方电信玩家想跟北方网通玩家一起联机的时候，就会体验很差。后来，以游戏为代表的业务多线接入的需求越来越强烈，但是公司缺乏一种通用的解决方案。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;思考：站在业务或者产品侧角度，为什么要用双线/多线服？抛开其他因素，双线区的游玩体验更好，游戏收入比单独的电信区/网通区高。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公网 IPv4 地址不足。全球公网 IPV4 地址早在 2011 年就已经分配完毕，IP 地址不足制约着部分重点业务的发展。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2323049001814882&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasTL3gd13IGTUdJkF6WFIiaUphSmH1wGP5PRib4wF3uIEfxicHMT57KUBH81ruu4MTUTZJ9fJsicLicMiaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1102&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 多通接入&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传统的网络方案，机房和网络类型是绑定的，即一台普通的服务器只能单独接入电信或者联通网络。由于用户跨运营商访问的速度非常慢，通常，游戏业务会为每个运营商均部署一套服务，但这样的方式也有两个问题：一是不同网络的用户互动麻烦，二是网络环境复杂，运维部署困难。（当然还有多线服务器解决方案，但需要是专门的多线机房/多线服务器，服务器成本也高）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.382051282051282&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasTL3gd13IGTUdJkF6WFIiaUx8Jn1iccdYrjwZHcicKLkcS60sepIvCAC2o0iapessZ6OugENyiacme5Bg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2340&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 TGW 的多线接入方案后，电信/联通/移动的玩家可以分别就近访问电信/联通/移动的网络访问至腾讯与各个运营商的入口外网 IP，经过 TGW 转发后，通过腾讯自建的内网专线，快速的连接至游戏服务器中（类似于网络游戏加速器的机制），缩短了网络路径。该方案的主要优势是，业务可以透明接入，服务器部署也灵活方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公司内首先试用多通接入的游戏业务有轩辕传奇、御龙在天和斗战神。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本质：不同运营商的用户，通过就近接入（域名就近解析或者 IP 就近接入 anycast），访问较近的对应运营商的腾讯外网入口，再通过腾讯内网专线访问对应服务器。&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. IP 收敛&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 2011 年下半年开始，腾讯开放平台开始对外推广（腾讯 QQ 空间页游业务大爆发，比如 QQ 农场/抢车位等等），众多第三方应用开始接入腾讯开放平台。按照当时的网络架构，每个开发商需要几十个到上百个的外网 IP，而合作专区的外网 IP 资源有限，很快就用完了。开发商申请不到外网 IP，制约了腾讯开放平台的进一步发展。经过分析发现，开放平台以小长尾应用居多，其中 90%以上的应用是网页游戏，网页游戏又以分区分服为主，一个游戏少则几十个区，多则数百个区，例如游戏蜀山传奇开了将近 800 个区，意味着需要消耗 800 个外网 IP。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0173611111111112&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasTL3gd13IGTUdJkF6WFIiaUs9K9wQWZdklQwzx22YNHacpC6NqzQBqK9vbsCu4fAwG1RGAFqMYBuA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;864&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对于这个问题，解决方案是让网页游戏接入四七层负载均衡（也就是 TGW），不同的区服使用同一个 IP 加不同的端口，多个业务可以复用外网 IP，以节省外网 IP 资源。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5247813411078717&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasTL3gd13IGTUdJkF6WFIiaUPQt378cNtftZFNLpPrFrCY8lKZMYYPwhg22q2hBat7XZuusWXpmPHw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2058&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本质：不同的服务器，利用 TGW 端口转换功能，使用相同的外网 IP+不同的端口对外提供服务，复用外网 IP。&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 负载均衡&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，TGW 最主要的功能还是负载均衡，业务接入负载均衡后，便可以集群化，横向扩展，同时兼具一定的高可用和高性能。常用的四层负载均衡算法为带权重的最小连接数 WLC（Weighted Least Connection）和加权轮询（Weighted Round Robin）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5482233502538071&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasTL3gd13IGTUdJkF6WFIiaU5O3tAq1ia1ia7gsKBCaBichgcFXncTz7VG8aeJYaXQFlTxmGeC4EtGzfQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1970&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本质：负载均衡&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. TGW 与 IPVS/LVS 异同&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简要介绍完 TGW 的基本功能，这里再与业界常用的四层负载均衡器 LVS 进行对比&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7065368567454798&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasTL3gd13IGTUdJkF6WFIiaUKmoWaqnel93xkW8AkzF8yzcGZhqSSWod8iaibsWftwDQpzufnpd8nb4Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1438&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;基本功能：TGW 作为有专业团队维护的产品，其功能肯定远比 LVS 丰富，其中 TGW 还支持全局 IP 限速限流；其 RS 均支持获取客户端 IP&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;转发模式：TGW 主要是 IP 隧道模式，LVS 考虑到泛用性，支持四种转发模式；TGW 入流量出流量均经过 TGW 转发，而 LVS，入流量经过 LVS 到后端服务器 RS，出流量直接从 RS 发到客户端；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;性能：TGW 基于 DPDK，其性能可达亿级长连接，千万级 pps；而 LVS 基于内核模块，性能百万级连接，接近百万级 pps；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高可用：TGW 是集群高可用，LVS 是 HA 高可用；TGW 只同步长连接，LVS 则长短连接均同步；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其他：LVS 当前也是 kubernetes services ipvs 解决方案的核心转发组件，当前未来的趋势是使用 Cillium&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 提问：TGW 和 CLB 有什么区别？&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TGW，Tencent GateWay， 是负载均衡 （Load Balancer，LB）， 在公司内部习惯叫 TGW 了，其主要提供 4 层负载均衡、外网接入、多线接入等功能；若需要接入 HTTPS 或者七层负载均衡或者 QUIC/HTTP3 协议，则可以使用 STGW 替代接入（TGW+nginx+加解密）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CLB，负载均衡（Cloud Load Balancer，CLB），是腾讯云产品化的名称，CLB 4 层就对应自研的 TGW， CLB 7 层对应自研的 STGW&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8205574912891986&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasTL3gd13IGTUdJkF6WFIiaUrykEQ0ibIUFJH3NG1sj7lyEtRIcjl9vEMKqKjRiaZFLkhld8CvUauxDg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1148&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、架构原理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;0. TGW 相关技术总览&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我这里对 TGW 的技术进行了一个整体的梳理，整体如下图的思维导图。这里分别从业务特点以及技术难点要点角度来看&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5930635838150289&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasTL3gd13IGTUdJkF6WFIiaU0ibOtV2OMSmIRtCiak8YW6EIMbJK2ia36n8kP9b443IK0YSib7F6SJjIeQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1730&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先看 TGW 的业务特点。TGW 作为腾讯公网接入的桥头堡，它会有大量的用户访问，需要支持更高的连接数和报文转发能力（pps），会有大量公司内和公司外（腾讯云客户）的业务接入，故需要承载大量的业务规则、外网 VIP、路由。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;故 TGW 最关注性能和稳定性，即性能 + 稳定性 &amp;gt;&amp;gt; 功能丰富度；但随着平台的迭代演进，随着性能和可靠性的提升，如何在兼顾性能和可靠性的前提下，不断给 TGW 新增新的功能，保障其可扩展性和可维护性，也会有很多技术挑战。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本章节介绍 TGW 请求转发和负载均衡流程以及 TGW 如何实现高可用。（TGW 高性能的一些实践，由于本人这方面了解不深，故不作介绍）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下一步会介绍 TGW 的整体架构。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. TGW 整体架构&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5199063231850117&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasTL3gd13IGTUdJkF6WFIiaUyianIr1oZvGw8YWfz3icCTSnOcRdnUzYYNet3thvjBxI3r27aQt0fRnA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1708&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网络转发，一般会将整体架构其分为管控平面和转发平面。管控平面负责管理控制，转发平面就是转发数据报文。TGW 的管控平面中最重要的便是规则，比如路由规则、限流规则、黑白名单规则，那么管控平面的主要职责便是控制规则，包括创建查询删除修改规则，如何高性能的将规则下发至转发平面，如何保证规则的一致性，对规则进行监控、拨测和告警等等；TGW 的转发平面主要是与路由器和交换机打交道，控制收到的报文如何处理，比如转发、负载均衡、协议转换、限流、黑白名单等。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 基本转发原理&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;转发模式&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业界开源的 LVS 负载均衡器的转发模式有四种：NAT 模式（源地址替换）、IP 隧道模式（封装一层 IP 头，IPIP 协议或 GRE 协议）、DR 模式（替换 MAC 地址，负载均衡器 LD 和服务器 RS 均需在同一局域网内，通过 MAC 地址路由访问）、FULLNAT 模式（源/目标地址替换）。不同的转发模式各有优缺点，这里不作过多展开。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TGW 的转发模式是 IP 隧道模式（也是业界最常见的模式），其主要优势是不依赖底层网络结构（相较于 DR 和 NAT 模式），可以同一网络平面通信也可以跨 VPC 网络通信（依赖于 VPC Gateway），另一方面，后端服务器 RS 也可以获取到客户端原始 IP 信息（NAT 模式无法获取）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3085808580858086&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasTL3gd13IGTUdJkF6WFIiaUEaO0fLZWYX4KouSN9ibrN9NTeWRuK9ZDb5S0dmH1mYEcgdorPolPS3Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2424&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图是 TGW IP 隧道（IPIP 协议）的整体转发流程，其中 CIP:CPORT 是客户端发起访问的 IP 和端口，VIP:VPORT 是业务对外提供服务的外网 IP 和端口，RSIP:RSPORT 是后端服务的内网 IP 和端口，TGWIP 是 TGW 内网的 IP。客户端到 TGW 之间是普通的网络报文，TGW 到后端服务之间是隧道报文（IPIP 或者 GRE）&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消息处理流程&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5397301349325337&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasTL3gd13IGTUdJkF6WFIiaUicPcu5PPscibngRqXzLmgZgrCXopiaZIncpOCNicGByt323QqYuLg7F7Ww/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2001&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图是 TGW 的消息处理流程。具体如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;转发的核心对象和概念。TGW 负载均衡的核心对象是 VIP 规则，VIP+VPORT 便是路由规则的主键，后端可以挂载多个服务器 RS，用于负载均衡；TGW 中有两个关键的查询表，规则表用于保存 VIP 规则，通过控制台/接口进行配置下发，对转发平面来讲是静态配置，连接表保存负载均衡调度结果，是在新建连接时动态创建。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;整体报文转发流程如上图，当一个请求到达时，解析报文后，查询连接表，如果是首包（未命中连接表），则查询规则表，进行调度和创建连接表，并转发报文，如果命中路由表，则根据已有的连接表信息转发报文。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;抓包&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再通过抓包，直观理解报文处理流程，如下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5446247464503042&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasTL3gd13IGTUdJkF6WFIiaU0nqaGz0fIehrqo0uYUms8e8LiaOa1Nq5KJoicfqw4MaK1rTibLZsX7ohg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1972&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第一部分是 TCP 建链的首包 SYNC 和回包 ACK 包，第一和第四行对应客户端与 TGW 间的 SYNC 和 ACK 包，第二和第三行对应 TGW 与后端服务间的 GRE 的 SYNC 和 ACK 包。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二部分对应第一行的 SYNC 包，可以看到它的源 IP：源 Port 是 203.195.x.x：53101，目的 IP：目的 Port 是 45.40.x.x:80，即原始地址。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三部分对应第二行的 SYNC 包，可以看到这个是一个 GRE 包，内层与原包基本类似（目标 Port 被修改，映射成 RS 的服务端口），中间的 GRE 包头，外层 IP 地址则是 TGW 和后端服务所在的母机（因为是 GRE 包，RS 在 VPC 网络中，TGW 会将报文转发到 RS 的母机）内网地址（9.171.x.x 和 10.112.x.x）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TGW 将该请求转发到后端母机后，母机会将该 GRE 包头去掉，然后将内层报文转发到 RS。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;考虑到信息安全，将外网 IP 地址部分打码&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;负载均衡转发流图&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TGW 当前提供的负载均衡功能支持外网负载均衡、内网负载均衡、以及 VPC 内网负载均衡，下图是提供的三种负载均衡转发格式图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5613305613305614&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasTL3gd13IGTUdJkF6WFIiaUiaupygO1W4J06FbT1ib0C9lp14xaTloibBTtLgOQ4JJbJAVe8zZZBGibFQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1924&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如图所示，外网负载均衡，客户端与 TGW 之间是 IP 包，后端 RS 若是物理机（Underlay 网络），则使用 IPIP 包，后端 RS 若是虚拟机或容器（Overlay 网络），则使用 GRE 包，若业务服务需要申请外网 IP 对外提供服务，便是该场景；VPC 内网负载均衡，调用者/客户端与 TGW 之间是 GRE 报文，TGW 与后端 RS 是 GRE 报文，通常使用场景是云上的虚拟机/内网服务 A 通过云上内网负载均衡访问另一个内网服务 B，对应云上的内网负载均衡。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;访问后端是物理机，TGW 需要侵入式的在机器上配置 IPIP 解报文配置，对使用者来说，是侵入式的；如果后端是虚拟机，则是在母机中进行解包 GRE 报文操作，对于虚拟机/容器用户来讲是透明的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PS：内网负载均衡已经不建议使用，若需要内网负载均衡/内网集群化，建议选用服务发现方案，比如腾讯的北极星 Polaris，开源的 Zuul、Consul、Etcd 等&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. TGW 高可用&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;TGW 高可用整体方案&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家都知道，业务会通过四层七层负载均衡，让业务集群化提供高可用的服务，TGW 也是如此，TGW 是利用交换机的集群化功能，通过 OSPF 路由发布协议和 ECMP 功能，让 TGW 集群化的提供集群化的四层流量接入功能。其整体架构图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5476673427991886&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasTL3gd13IGTUdJkF6WFIiaU5VbLwIia5K2qgz7ocdO1oTvdISnjU7LqMu9RZLOvdkTEVFhbwNfJynw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1972&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TGW 的集群化架构纵览：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;核心路由器和接入交换机。两个核心交换机同时提供服务，两个接入交换机同时提供服务；核心路由器与接入交换机两两互联，核心路由器与其下联接入交换机相连，同时与对端核心和下联接入交换机相连；接入交换机与下联服务器（也就是 TGW LD）相连，与对端接入交换机相连；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TGW 集群。一个 TGW 集群由 4/8/16 台机器，每个 LD 均配置相同的 VIP、路由转发规则，同时提供服务；TGW LD 外、内网分别与外网接入交换机 TGW-W、内网接入交换机 TGW-L 相连&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;OSPF 路由发布和 ECMP 负载均衡。OSPF：开放最短路径优先协议，支持多路路由；TGW 内、外网上联交换机内、外网核心路由器在同一个 OSPF 域中，实现交换机、核心路由的流量负载均衡；TGW 内、外网上联交换机和 TGW LD 内、外网在同一个 OSPF 域中，实现交换机、TGW LD 的流量负载均衡。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;思考：多个节点怎么接入流量、且分配均匀？解决方案：交换机配置 ECMP
如果节点故障怎么让交换机知道？解决方案：OSPF 路由发布
如何探测和发现节点故障？解决方案：状态监控、自动剔除
如果节点故障上联交换机重新分配流量，怎么保证连接不中断？解决方案：连接同步&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5766150560597971&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasTL3gd13IGTUdJkF6WFIiaUyLP6LS5HCluSaWdl5lXNTKsucdTBL6NCGMTUe2PEpicshlHwuDicnbbw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1873&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;高可用分析&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;对网络层和 TGW 集群进行高可用分析：&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网络层容灾：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;两台外网核心路由器同时服务，容量冗余。在任意一台核心故障的情况下，余下一台核心路由器能完全接管所有流量。内网亦然。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;两台外网接入交换机同时提供服务，容量冗余。任意一台外网接入交换机故障的情况下，余下一台外网接入交换机能完全接管集群所有流量。内网亦然。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TGW 集群容灾：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;集群 50% LD 故障，剩余 LD 能够接管所有流量；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LD 故障时，OSPF 路由自动收敛，将故障 LD 剔除（如果是 LD 故障的话），上联交换机重新分配流量，分配到剩余的 LD，为确保连接不中断，需要进行连接同步。连接同步是以单播的方式进行同步。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;连接同步&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;连接同步怎么做？有什么问题？又如何解决？又有其他什么挑战？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开源负载均衡 LVS 的连接同步是长短连接均同步，但这样的做法会影响负载均衡处理新建连接的性能。让我们设想一下，一个 TGW 集群 N 个节点（LD），不做连接同步，新建能力是 X，如果 TGW 集群没新建一个连接就立即同步该连接的话，做了连接同步后，极端情况下，新建能力下降为 X/N。另一方面，由于 TGW 支持的连接数达千万亿级，当新建连接数过多时，不论是新建连接的同步还是存量连接的同步，需要同步的数据量都会非常大。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5343889163780307&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasTL3gd13IGTUdJkF6WFIiaUAT3b6FZVP5Dg7MlwjDoA6iaK3Or1LGrAAj6O9a0Lv1CibCqshUnkaRTA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2021&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对于这两个问题的解决方案：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;仅同步长连接。TCP 连接分为长连接和短连接，短连接生命周期很短，并不需要同步，故 TGW 仅对连接存在时间超过 3 秒进行同步，3 秒是一个经验值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;定期、长周期全量同步时间。第一次同步后，4 分钟同步一次，新加入节点先进入就绪状态只接收同步连接，等 5 分钟后，等待完整一个周期后（超过 4 分钟即可），确保所有连接均同步完成后，上线引流；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异步批量发送。连接同步不要求实时性，3 秒同步和 3.2 秒同步其实差异并不大，故可先放入队列缓存，合并成一个报文（MTU 大小）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时又有另一个问题，即 LD 间连接的一致性如何保障，但这里就不作过多展开，有兴趣的可以自行了解&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;（业务常用的一致性手段，2PC、3PC、Paxos、Raft）&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;防 SYNC DDos 攻击&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4579710144927536&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasTL3gd13IGTUdJkF6WFIiaUXdf8Yxket97dicP9n6MSF9oYzVCKdFyLmZ7HZ85xkeicKlsFdHuZOib9Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1380&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;LVS 如何处理超时连接？又有什么问题？TGW 是怎么做的？又有什么优势？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;较早版本的 LVS 连接处理流程如上图的第一张图，其收到新建连接的 SYNC 包后，会创建新的连接，然后交由 timer 处理过期连接，该方案并不能及时的释放无效半连接，故 LVS 并不具有有效防 SYNC DDOS 攻击的能力，当 SYNC 包一旦占满的连接表，便无法新建连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关键点：如何确保在连接满之前一定能申请到连接？如何高效的释放无效 SYNC 包？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TGW 的做法是基于原有 LVS 的方案进行改进，使用 LRU 替换原有半连接表：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;创建新连接时，若因为半连接表满，导致新建连接失败，由于最老的半连接几乎是不会进行后续建链（业务特点），故直接释放 LRU 链尾节点，使用这段内存用于新建连接；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;新建连接后，设置超时 timer，并将该连接加入 LRU 头&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方案的优势主要有两点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;淘汰无效 SYNC 连接的时间复杂度为 O(1)，直接删除 LRU 链尾节点即可&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;新连接在连接表满之前，总是能够申请到新建连接所需的内存&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;FAQ&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 为什么 RS 回包要经过 TGW？&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;RS 没有外网 IP（外网网卡 IP）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RS 回包有两种选择，经过 TGW 或者 NAT，本质上最少要经过一跳转发，直接回包并不能缩短网络路径；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TGW 网络路径转发性能好、带宽大、资源足；NAT（云下 NAT）转发能力和性能差，云上 NAT 则还需要额外占用外网 IP，若共用则可能出现端口冲突、TIME_WAIT 等问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 为什么是 IP 隧道模式，而不是 DR/NAT 等其他模式？&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;IP 隧道模式是通过给客户端报文加壳（IPIP 包头/GRE 包头）通用性强，不依赖底层网络结构，更适合当前虚拟化/多 VPC 网络环境&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DR 模式是通过修改报文的源 MAC 和目的 MAC 地址实现的报文转发和负载均衡，负载均衡器和 RS 需要在同一个广播域，同时 RS 需要能够访问外网（比如要有外网 IP 地址）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NAT 模式是通过修改报文的 IP 地址（又分为 SNAT 和 FULLNAT），会导致业务方无法获取到客户端真实 IP。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 高性能网络框架的变化&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;epoll 多路复用（比如 nginx），瓶颈，几十万级 pps 时，用户态和内核态上下文切换，其未来发展有三个方向&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方向一：LVS，基于 Netfilter/BPF（其他工具还有 iptables、tcpdump 等），转发逻辑在内核态，绕过用户态和内核态上下文切换；TGW DPDK 版本，基于 DPDK，直接从网卡取包，CPU 作转发逻辑，缩短报文处理路径；再进一步优化便是将报文处理逻辑下沉，比如智能网卡或者 P4；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方向二：eBPF，新的 VM 设计，比 cBPF/Netfilter 性能提升 20 倍以上，充分利用 CPU 寄存器，落地产品比如 Cillium；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方向三：epoll 的未来，io_uring。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. CAP 三网合一的 IP 原理是怎么样？其价格与普通的三网外网 ip 有什么异同呢？&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;背景：中小运营商宽带用户跨网访问体验差&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基本概念：腾讯 CAP（Content Accelerate Platform：内容加速平台），CAP IP 与中小运营商对等互联&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么贵？CAP IP 必须具备电信与联通的 BGP 路由与带宽；电信与联通的用户庞大，两大运营商网络覆盖在中国市场各具有一定的垄断性，BGP 带宽资源价格昂贵；最初引入的电信与联通 BGP 带宽仅用于解决极少错配用户的互通问题，不可非合理使用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. IPIP 协议和 GRE 协议基本概念和异同&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;IP 隧道技术：是路由器把一种网络层协议封装到另一个协议中以跨过网络传送到另一个路由器的处理过程。隧道技术是一种数据包封装技术，它是将原始 IP 包（其报头包含原始发送者和最终目的地）封装在另一个数据包（称为封装的 IP 包）的数据净荷中进行传输。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;IPIP 即 IP in IP，一种 IP 隧道（IP Tunnel）协定，将一个 IP 封包，封装进另一个 IP 封包中。为了封装 IP 封包，在来源 IP 上要再加上一个外部的标头，隧道的进入点，目的位置，以及隧道离开的位置。这个技术使用于虚拟私人网络（VPN）上，RFC 2003 说明了这个协定的内容。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;GRE 也类似，即 IP in GRE&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;名词介绍&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OSPF 协议：一种动态路由协议，当前主要用于 tgw 的容灾功能上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ECMP：等价多路由&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IP 隧道技术：是路由器把一种网络层协议封装到另一个协议中以跨过网络传送到另一个路由器的处理过程。隧道技术是一种数据包封装技术，它是将原始 IP 包（其报头包含原始发送者和最终目的地）封装在另一个数据包（称为封装的 IP 包）的数据净荷中进行传输。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IPIP：即 IP in IP，一种 IP 隧道（IP Tunnel）协定，将一个 IP 封包，封装进另一个 IP 封包中。为了封装 IP 封包，在来源 IP 上要再加上一个外部的标头，隧道的进入点，目的位置，以及隧道离开的位置。这个技术使用于虚拟私人网络（VPN）上，RFC 2003 说明了这个协定的内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;WC：IDC 机房的外网核心设备 WC&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;XGWW：连接 TGW 服务器和 NFV 服务器的 TOR，XGWL 为内网，XGWW 为外网&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DPDK：旁路网卡 IO，绕过内核直接在用户态收发包来解决内核的瓶颈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;pps：一种单位，表示每秒报文数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VIP：虚拟服务地址（virtual IP，VIP）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RS：后端服务器（Real Server，RS）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HA：High Available（高可用）; 或者指 HA 高可用，即多节点运行，仅有一台提供服务（相较于集群化高可用）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LD：Load Dispatcher，转发物理单元&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LVS：Linux Virtual Server/IPVS&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VPC：私有网络（Virtual Private Cloud，VPC）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SNAT：（Source Network Address Translation，源网络地址转换）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DNAT：（Destination Network Address Translation，目的网络地址转换）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TGW，全称 Tencent Gateway，是一个可实现多通（电信，联通，移动，CAP）统一接入的负载均衡解决方案。四层负载均衡-TGW&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CLB：腾讯云负载均衡（Cloud Load Balancer，CLB）提供安全快捷的流量分发服务，访问流量经由 CLB 可以自动分配到云中的多台云服务器上，扩展系统的服务能力并消除单点故障。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAP：Content Acceleration Platform ，内容加速平台；使用腾讯自有地址 ，内容加速平台；对等接入中小运营商 （如天威 、长宽移动 )，已逐渐融入 TIX。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;WRR：加权轮询调度（Weighted Round-Robin Scheduling）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;WLC：加权最小连接调度（Weighted Least-Connection Scheduling）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;厉辉，当前在腾讯游戏后台团队工作，熟悉四七层负载均衡以及 API 网关等技术领域，同时也是 CNCF Ambassador 以及 Apache APISIX PMC。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.776851851851852&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauhb1oxPGgqgl8H8U5tnU9n8DJibbXIibFTSq5iaW5DkiaPBn03Cic2bg5pFKKIn3LSqqdibNClnpwndDibw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_live_iframe&quot; data-pluginname=&quot;videosnap&quot; data-headimgurl=&quot;https://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;将在04月14日 19:30 直播&quot; data-intro=&quot; 腾讯工程师分享：Prometheus原理及最佳实践&quot; data-noticeid=&quot;finderlivenotice-v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder-1649657748424696-1673220147&quot; data-type=&quot;live&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAEYkG7TmZ_AAAAAstQy6ubaLX4KHWvLEZgBPErqN4RiBcOuSDzNPgMIuivB3IuShKvvPoB-YpH2bX&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7Ym3K77SEULgkia8aTNJBjM3brJS7Kia3gfV1xmTYFBdPCAZnlzt9Jiab4cicnliapPnNIrmbdbmqZdsWgzWutnGuKa1Nf15krljkvZYA&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SZ&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdURp2ibmx0VDicTOlabyByNbMpickxEIibLPrEF17ic9OF0GEPIRBxNkA6mNxG5XUAl0X6E&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;伊隆·马斯克的OpenAI公司，发布了一套全新AI系统：DALL·E 2&quot; data-nonceid=&quot;1032235092142604197&quot; data-type=&quot;video&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5ODYwMjI2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasvpPfMrktl2xvC9A325p8Qa9dFeEzxZmZ2O1XuFGsVXyQhG9Dia8J8nTXVtzNcHozr0umH3R4iboXg/0?wx_fmt=png&quot; data-nickname=&quot;腾讯技术工程&quot; data-alias=&quot;Tencent_TEG&quot; data-signature=&quot;腾讯技术官方号。腾讯技术创新、前沿领域发布解读平台。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3e7566c97bf8a34005dd7b5fc07721e2</guid>
<title>知识图谱可视化技术在美团的实践与探索</title>
<link>https://toutiao.io/k/f8oloj0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;美团技术团队&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;meituantech&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;10000+工程师，如何支撑中国领先的生活服务电子商务平台？数亿消费者、数百万商户、2000多个行业、几千亿交易额背后是哪些技术在支撑？这里是美团、大众点评、美团外卖、美团配送、美团优选等技术团队的对外窗口。&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ee3fae2528bc594c3f7a787567019fb1</guid>
<title>面试官：手写实现一个 useState</title>
<link>https://toutiao.io/k/f4j8i8m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;简单实现：只是数组&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过数组实现，初始化的时候，创建两个数组：&lt;code&gt;states&lt;/code&gt; 与 &lt;code&gt;setters&lt;/code&gt; ，设置光标 &lt;code&gt;cursor&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第一次调用 &lt;code&gt;useState&lt;/code&gt; 时，创建一个 &lt;code&gt;setter&lt;/code&gt; 函数放入  &lt;code&gt;setters&lt;/code&gt; 中，并初始化一个 &lt;code&gt;state&lt;/code&gt; 放入 &lt;code&gt;states&lt;/code&gt; 中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;之后每次重新渲染时，都会重置光标 &lt;code&gt;cursor&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; ，通过  &lt;code&gt;cursor&lt;/code&gt; 从&lt;code&gt;states&lt;/code&gt; 与 &lt;code&gt;setters&lt;/code&gt; 获取 &lt;code&gt;[state, setter]&lt;/code&gt; 返回&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次更新 &lt;code&gt;state&lt;/code&gt; 时，都是通过调用 &lt;code&gt;setter&lt;/code&gt; 函数修改对应的 &lt;code&gt;state&lt;/code&gt; 值，这种对应关系是通过 &lt;code&gt;cursor&lt;/code&gt; 闭包来实现的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;RenderFunctionComponent&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; [firstName, setFirstName] = useState(&lt;span&gt;&quot;Rudi&quot;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; [lastName, setLastName] = useState(&lt;span&gt;&quot;Yardley&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;Button&lt;/span&gt; &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{()&lt;/span&gt; =&amp;gt;&lt;/span&gt; setFirstName(&quot;Fred&quot;)}&amp;gt;Fred&lt;span&gt;&amp;lt;/&lt;span&gt;Button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;  );&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1、初始化&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始化的时候，会创建两个数组: state和setters，把光标的位置设为0.&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKlxhBGZ5uVvbXiaia3LLLkknIScv1WMeWtjbAJTxicc22NK6PT1npYm6DUUic69OY2K8kVOZfL2TgdD0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2、第一次渲染&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用useState时，第一次渲染，会将一个set函数放入setters数组中，并且把初始state放入到state数组中.&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.1428571428571428&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKlxhBGZ5uVvbXiaia3LLLkknIUUo7jjMhhJTxZ1HdkeJkzfw92waf3RibfI7vlCibH1n4CsgHOYhPNBag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;630&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;use2&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3、后续渲染&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每一次重新渲染，光标都会重新设为0，然后从对应的数组中读取状态和set函数&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.2567783094098883&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKlxhBGZ5uVvbXiaia3LLLkknIIrib4qO3a48FFicUvOxCeHnnL8OGINJ5e8z1RHlsNeuT3qD07JAiaJ8xQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;627&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;use3&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例来自：react hooks进阶与原理&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; states = []&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; setters = []&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; firstRun = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; cursor = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//  使用工厂模式生成一个 createSetter，通过 cursor 指定指向的是哪个 state&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;createSetter&lt;/span&gt;(&lt;span&gt;cursor&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;newVal&lt;/span&gt;) &lt;/span&gt;{ &lt;span&gt;// 闭包&lt;/span&gt;&lt;br/&gt;    states[cursor] = newVal&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;useState&lt;/span&gt;(&lt;span&gt;initVal&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 首次&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(firstRun) {&lt;br/&gt;    states.push(initVal)&lt;br/&gt;    setters.push(createSetter(cursor))&lt;br/&gt;    firstRun = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; state = states[cursor]&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; setter = setters[cursor]&lt;br/&gt;  &lt;span&gt;// 光标移动到下一个位置&lt;/span&gt;&lt;br/&gt;  cursor++&lt;br/&gt;  &lt;span&gt;// 返回&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; [state, setter]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;App&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 每次重置 cursor&lt;/span&gt;&lt;br/&gt;  cursor = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;span&gt;RenderFunctionComponent&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;RenderFunctionComponent&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; [firstName, setFirstName] = useState(&lt;span&gt;&quot;Rudi&quot;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; [lastName, setLastName] = useState(&lt;span&gt;&quot;Yardley&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;Button&lt;/span&gt; &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{()&lt;/span&gt; =&amp;gt;&lt;/span&gt; setFirstName(&quot;Fred&quot;)}&amp;gt;Fred&lt;span&gt;&amp;lt;/&lt;span&gt;Button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;  );&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;进阶版 useState&lt;/span&gt;&lt;/h2&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;简单实现：只是链表&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在真实的 React Hooks 中，这种关系其实是通过链表实现的，首先我们需要明确以下内容：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 React 中最多会同时存在两棵 &lt;code&gt;Fiber&lt;/code&gt; 树。当前屏幕上显示内容对应的 Fiber 树称为 &lt;code&gt;current Fiber&lt;/code&gt; 树，正在内存中构建的 &lt;code&gt;Fiber&lt;/code&gt; 树称为 &lt;code&gt;workInProgress Fiber&lt;/code&gt; 树。&lt;code&gt;current Fiber&lt;/code&gt; 树中的 &lt;code&gt;Fiber&lt;/code&gt; 节点被称为 &lt;code&gt;current fiber&lt;/code&gt; ，&lt;code&gt;workInProgress Fiber&lt;/code&gt; 树中的 &lt;code&gt;Fiber&lt;/code&gt; 节点被称为 &lt;code&gt;workInProgress fiber&lt;/code&gt; ，他们通过 &lt;code&gt;alternate&lt;/code&gt; 属性连接。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// workInProgressHook 指针，指向当前 hook 对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; workInProgressHook = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// workInProgressHook fiber，这里指的是 App 组件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; fiber = {&lt;br/&gt;  &lt;span&gt;stateNode&lt;/span&gt;: App, &lt;span&gt;// App 组件&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始化阶段，react hooks 做的事情，在一个函数组件第一次渲染执行上下文过程中，每个 react hooks执行，都会产生一个 hook 对象，并形成链表结构，绑定在 &lt;code&gt;workInProgress&lt;/code&gt; 的 &lt;code&gt;memoizedState&lt;/code&gt; 属性上&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// workInProgressHook 指针，指向当前 hook 对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; workInProgressHook = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// workInProgressHook fiber，这里指的是 App 组件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; fiber = {&lt;br/&gt;  &lt;span&gt;stateNode&lt;/span&gt;: App, &lt;span&gt;// App 组件&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;memoizedState&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt; &lt;span&gt;// hooks 链表，初始为 null&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 是否是首次渲染&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; isMount = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后 react hooks 上的状态，绑定在当前 &lt;code&gt;hooks&lt;/code&gt; 对象的 &lt;code&gt;memoizedState&lt;/code&gt; 属性上。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 每个 hook 对象，例如 state hook、memo hook、ref hook 等&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; hook = {&lt;br/&gt;  &lt;span&gt;memoizedState&lt;/span&gt;: initVal, &lt;span&gt;// 当前state的值，例如 useState(initVal)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;action&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;// update 函数&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;next&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt; &lt;span&gt;// 因为是采用链表的形式连接起来，next指向下一个 hook&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首次渲染时，生成 &lt;code&gt;hook&lt;/code&gt; 对象，形成链表结构，绑定在 &lt;code&gt;workInProgress&lt;/code&gt; 的 &lt;code&gt;memoizedState&lt;/code&gt; 属性上，代码实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;useState&lt;/span&gt;(&lt;span&gt;initVal&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; hook&lt;br/&gt;  &lt;span&gt;// 首次会生成 hook 对象，并形成链表结构，绑定在 workInProgress 的 memoizedState 属性上&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(isMount) {&lt;br/&gt;    &lt;span&gt;// 生成当前 hook 对象&lt;/span&gt;&lt;br/&gt;    hook = {&lt;br/&gt;      &lt;span&gt;memoizedState&lt;/span&gt;: initVal, &lt;span&gt;// 当前state的值，例如 useState(initVal)&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;action&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;// update 函数&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;next&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt; &lt;span&gt;// 因为是采用链表的形式连接起来，next指向下一个 hook&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 绑定在 workInProgress 的 memoizedState 属性上&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(!fiber.memoizedState) {&lt;br/&gt;      &lt;span&gt;// 如果是第一个 hook 对象&lt;/span&gt;&lt;br/&gt;      fiber.memoizedState = hook&lt;br/&gt;      &lt;span&gt;// 指针指向当前 hook&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// workInProgressHook = hook&lt;/span&gt;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// 如果不是, 将 hook 追加到链尾&lt;/span&gt;&lt;br/&gt;      workInProgressHook.next = hook&lt;br/&gt;      &lt;span&gt;// workInProgressHook 指向下一个，鸡 hook&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// workInProgressHook = workInProgressHook.next&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    workInProgressHook = hook&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6822742474916388&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKlxhBGZ5uVvbXiaia3LLLkknIiaNfPTy8hS7ESlWYuzQdXtONF28f0W2muk3iaRttvNVF17Acfo8ibZP7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1794&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一次函数组件更新，当再次执行 &lt;code&gt;hooks&lt;/code&gt; 函数的时候，比如 &lt;code&gt;useState(0)&lt;/code&gt; ，首先要从 &lt;code&gt;current&lt;/code&gt; 的 &lt;code&gt;hooks&lt;/code&gt; 中找到与当前 &lt;code&gt;workInProgressHook&lt;/code&gt; ，对应的 &lt;code&gt;current hook&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;useState&lt;/span&gt;(&lt;span&gt;initVal&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; hook&lt;br/&gt;  &lt;span&gt;// 首次会生成 hook 对象，并形成链表结构，绑定在 workInProgress 的 memoizedState 属性上&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(isMount) {&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 拿到当前的 hook&lt;/span&gt;&lt;br/&gt;    hook = workInProgressHook&lt;br/&gt;    &lt;span&gt;// workInProgressHook 指向链表的下一个 hook&lt;/span&gt;&lt;br/&gt;    workInProgressHook = workInProgressHook.next&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来 &lt;code&gt;hooks&lt;/code&gt; 函数执行的时候，把最新的状态更新到 &lt;code&gt;workInProgressHook&lt;/code&gt; ，保证 &lt;code&gt;hooks&lt;/code&gt; 状态不丢失&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;useState&lt;/span&gt;(&lt;span&gt;initVal&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; hook&lt;br/&gt;  &lt;span&gt;// 首次会生成 hook 对象，并形成链表结构，绑定在 workInProgress 的 memoizedState 属性上&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(isMount) {&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 状态更新，拿到 current hook，调用 action 函数，更新到最新 state&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; baseState = hook.memoizedState &lt;br/&gt;  &lt;span&gt;// 执行 update 函数&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(hook.action) {&lt;br/&gt;    &lt;span&gt;// 更新最新值&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; action = hook.action&lt;br/&gt;    &lt;span&gt;// 如果是 setNum(num=&amp;gt;num+1) 形式&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt; action === &lt;span&gt;&#x27;function&#x27;&lt;/span&gt;) {&lt;br/&gt;      baseState = action(baseState)&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      baseState = action&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 清空 action&lt;/span&gt;&lt;br/&gt;    hook.action = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 更新最新值&lt;/span&gt;&lt;br/&gt;  hook.memoizedState = baseState&lt;br/&gt;  &lt;span&gt;// 返回最新值 baseState、dispatchAction&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; [baseState, dispatchAction(hook)]&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// action 函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;dispatchAction&lt;/span&gt;(&lt;span&gt;hook&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;action&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    hook.action = action&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6268518518518519&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKlxhBGZ5uVvbXiaia3LLLkknIhicPdiatwaAYLibAYP7ajc3SZSRMYPzaZjtGTy4ANgyZhFHgribnycdAoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// workInProgressHook 指针，指向当前 hook 对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; workInProgressHook = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// workInProgressHook fiber，这里指的是 App 组件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; fiber = {&lt;br/&gt;  &lt;span&gt;stateNode&lt;/span&gt;: App, &lt;span&gt;// App 组件&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;memoizedState&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt; &lt;span&gt;// hooks 链表，初始为 null&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 是否是首次渲染&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; isMount = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;schedule&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  workInProgressHook = fiber.memoizedState&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; app = fiber.stateNode()&lt;br/&gt;  isMount = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; app&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;useState&lt;/span&gt;(&lt;span&gt;initVal&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; hook&lt;br/&gt;  &lt;span&gt;// 首次会生成 hook 对象，并形成链表结构，绑定在 workInProgress 的 memoizedState 属性上&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(isMount) {&lt;br/&gt;    &lt;span&gt;// 每个 hook 对象，例如 state hook、memo hook、ref hook 等&lt;/span&gt;&lt;br/&gt;    hook = {&lt;br/&gt;      &lt;span&gt;memoizedState&lt;/span&gt;: initVal, &lt;span&gt;// 当前state的值，例如 useState(initVal)&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;action&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;// update 函数&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;next&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt; &lt;span&gt;// 因为是采用链表的形式连接起来，next指向下一个 hook&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 绑定在 workInProgress 的 memoizedState 属性上&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(!fiber.memoizedState) {&lt;br/&gt;      &lt;span&gt;// 如果是第一个 hook 对象&lt;/span&gt;&lt;br/&gt;      fiber.memoizedState = hook&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// 如果不是, 将 hook 追加到链尾&lt;/span&gt;&lt;br/&gt;      workInProgressHook.next = hook&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 指针指向当前 hook，链表尾部，最新 hook&lt;/span&gt;&lt;br/&gt;    workInProgressHook = hook&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 拿到当前的 hook&lt;/span&gt;&lt;br/&gt;    hook = workInProgressHook&lt;br/&gt;    &lt;span&gt;// workInProgressHook 指向链表的下一个 hook&lt;/span&gt;&lt;br/&gt;    workInProgressHook = workInProgressHook.next&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 状态更新，拿到 current hook，调用 action 函数，更新到最新 state&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; baseState = hook.memoizedState&lt;br/&gt;  &lt;span&gt;// 执行 update&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(hook.action) {&lt;br/&gt;    &lt;span&gt;// 更新最新值&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; action = hook.action&lt;br/&gt;    &lt;span&gt;// 如果是 setNum(num=&amp;gt;num+1) 形式&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt; action === &lt;span&gt;&#x27;function&#x27;&lt;/span&gt;) {&lt;br/&gt;      baseState = action(baseState)&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      baseState = action&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 清空 action&lt;/span&gt;&lt;br/&gt;    hook.action = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;  } &lt;br/&gt;  &lt;span&gt;// 更新最新值&lt;/span&gt;&lt;br/&gt;  hook.memoizedState = baseState&lt;br/&gt;  &lt;span&gt;// 返回最新值 baseState、dispatchAction&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; [baseState, dispatchAction(hook)]&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// action 函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;dispatchAction&lt;/span&gt;(&lt;span&gt;hook&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;action&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    hook.action = action&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 调度函数，模拟 react scheduler&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;schedule&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  workInProgressHook = fiber.memoizedState&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; app = fiber.stateNode()&lt;br/&gt;  isMount = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; app&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;App&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; [num, setNum] = useState(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    onClick() {&lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;num: &#x27;&lt;/span&gt;, num)&lt;br/&gt;      setNum(num+&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 测试结果&lt;/span&gt;&lt;br/&gt;schedule().onClick(); &lt;span&gt;// &#x27;num: &#x27; 0&lt;/span&gt;&lt;br/&gt;schedule().onClick(); &lt;span&gt;// &#x27;num: &#x27; 1&lt;/span&gt;&lt;br/&gt;schedule().onClick(); &lt;span&gt;// &#x27;num: &#x27; 2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;优化版：useState 是如何更新的&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;更近一步，其实 &lt;code&gt;useState&lt;/code&gt; 有两个阶段，负责初始化的 &lt;code&gt;mountState&lt;/code&gt; 与负责更新的 &lt;code&gt;updateState&lt;/code&gt;，在 &lt;code&gt;mountState&lt;/code&gt; 阶段会创建一个 &lt;code&gt;state&lt;/code&gt; &lt;code&gt;hook.queue&lt;/code&gt; 对象，保存负责更新的信息（包含 &lt;code&gt;pending&lt;/code&gt;，待更新队列），以及一个负责更新的函数 &lt;code&gt;dispatchAction&lt;/code&gt; （就是 &lt;code&gt;setNum&lt;/code&gt; ，第三个参数就是 &lt;code&gt;queue&lt;/code&gt;）&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 因此，实际的 hook 是这样的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 每个 hook 对象，例如 state hook、memo hook、ref hook 等&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; hook = {&lt;br/&gt;  &lt;span&gt;memoizedState&lt;/span&gt;: initVal, &lt;span&gt;// 当前state的值，例如 useState(initVal)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;queue&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;pending&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;  }, &lt;span&gt;// update 待更新队列, 链表的形式存储&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;next&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt; &lt;span&gt;// 因为是采用链表的形式连接起来，next指向下一个 hook&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 调用updateNum实际上调用这个,queue就是当前hooks对应的queue。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;dispatchAction&lt;/span&gt;(&lt;span&gt;queue, action&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;// 每一个任务对应一个update&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; update = {&lt;br/&gt;    &lt;span&gt;// 更新执行的函数&lt;/span&gt;&lt;br/&gt;    action,&lt;br/&gt;    &lt;span&gt;// 与同一个Hook的其他更新形成链表&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;next&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;  };&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;每次更新的时候（&lt;code&gt;updateState&lt;/code&gt;）都会创建一个 &lt;code&gt;update&lt;/code&gt; 对象，里面记录了此次更新的信息，然后将此&lt;code&gt;update&lt;/code&gt; 放入待更新的 &lt;code&gt;pending&lt;/code&gt; 队列中，最后，&lt;code&gt;dispatchAction&lt;/code&gt; 判断当前 &lt;code&gt;fiber&lt;/code&gt; 没有处于更新阶段&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果处于渲染阶段，那么不需要我们在更新当前函数组件，只需要更新一下当前 &lt;code&gt;update&lt;/code&gt; 的&lt;code&gt;expirationTime&lt;/code&gt; 即可&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;没有处于更新阶段，获取最新的 &lt;code&gt;state&lt;/code&gt; ,和上一次的 &lt;code&gt;currentState&lt;/code&gt; ，进行浅比较&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果相等，那么就退出&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不相等，那么调用 &lt;code&gt;scheduleUpdateOnFiber&lt;/code&gt; 调度渲染当前 &lt;code&gt;fiber&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现代码就不写了，感兴趣的可以实现一下，欢迎补充&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;参考&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;react hooks进阶与原理&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;「react进阶」一文吃透react-hooks原理&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;80行代码实现一个简易版useState&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;极简Hooks实现&lt;br/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>