<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>bdc81914f6ad6fbce52a0e855bc799bd</guid>
<title>工具 | 一套轻量级 Go 微服务框架</title>
<link>https://toutiao.io/k/1e2xzb9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;大家好，我是周刊菌。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzA4Njk2NDAzMA==&amp;amp;mid=2660215266&amp;amp;idx=2&amp;amp;sn=54400f6300be9d601500e59d737997e2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;牛年行牛运！加入「码农周刊VIP会员」，一起牛起来！&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;牛年行牛运！加入「码农周刊VIP会员」，一起牛起来！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;774&quot; data-ratio=&quot;1.8053333333333332&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNav8leEiaJdw64iaLEcYh6ljOt0HdicCyicjR6pic5WXCS2VwKaBAkkXmmpP3Pibic6e1Vv0Qsibcy2CpIUrtyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;322&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;350&quot; data-ratio=&quot;1.318840579710145&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav8pVYfXHFZnJw6GmED4PucZvQd6m3AP8fUG1IKJyBgicmJ3P5ygQjO5r6Bib2x190MFOlb6PwExNQuA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>83ea36460ed6ec41598dcb1ae06fe652</guid>
<title>​程序员划水指南</title>
<link>https://toutiao.io/k/gheevc3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;快过年了，跟我可爱的小侄子通了个电话，上来就说，&quot;叔叔你头发怎么变少了&quot;，我很痛心，我的小侄子，年纪轻轻的，眼神已经这么不好使了。但转念一想，这也是他对我的一种关心，作为叔叔，也该回应一把，今年过年给他带一本《少儿编程》回去当礼物吧。&lt;/p&gt;&lt;p&gt;但转念又一想，也许我真的头发变少了呢，我强壮的体魄不再足以支撑我肮脏的灵魂了呢，或许真的应了那句古语，&lt;strong&gt;程序员固有一死，要么骚死，要么猝死？&lt;/strong&gt; 我好残忍，我竟然想让我的小侄走上这么一条不归路。&lt;/p&gt;&lt;p&gt;可是我这一身编程本领好想传授予人，我还想不想那么快一&quot;猝&quot;而就。我还想看着小侄子长大成人，然后在面试他的时候偷偷放水，再把他招进部门结对编程，我一定要活久一点。我想一定还有跟我一样有未了心愿的程序员，于是今天我将祭出所有防猝死技能，&lt;strong&gt;希望赠与有缘人&lt;/strong&gt;。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;换行业&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;这是最直接的解决方案，那么问题来了，应该去哪个行业呢？程序员下岗后一般再就业的岗位不是送外卖就是送快递，这两个工作从工作强度和工作时长来说，丝毫不比程序员轻松。这就片面了。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.0018587360594795&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicmm7iaMouITfYqrY8uwKgQHDGIw3jTuL6XbhicqBe43ck0pEDfAHOaCcfA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1076&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;有时间送快递和外卖的话，那不如老老实实考个公务员吧。程序员怎么成为公务员？这里正好有一个github项目，就教你如何成为一个公务员。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;https:&lt;span&gt;//github.com/coder2gwy/coder2gwy&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;连怎么安排学习时间，怎么请假都安排得明明白白，贼吉尔细心。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6261040235525025&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicmQNO4T7I6kmUcPyueAmzROHjslh1T74z5xQleBNibhSzQnmmARibqwBhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2038&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4456824512534819&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicm0DVeTA8CgAY8ia0pB84PGeML7jsHfjwhB75Y0rnXIpCrcnS49hRsqdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2154&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;&lt;span&gt;跳槽到965的公司&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;从程序员跳槽到公务员或者是教师这条路子比较艰难，虽然我相信大部分程序员在考试上面都比常人要更擅长些。&lt;/p&gt;&lt;p&gt;一旦选择考公务员，等于放弃自己学习多年的技能，什么&lt;code&gt;mysql&lt;/code&gt;，&lt;code&gt;redis&lt;/code&gt;，&lt;code&gt;java&lt;/code&gt;，&lt;code&gt;设计模式&lt;/code&gt;这些，都将成为过眼云烟，选择成本巨大。就算成了，也可能会后悔，或许会在某个四下无人的下午三点，用当年的程序员杯子装着这周xx办主任送的茶叶泡的茶，写着 &lt;strong&gt;《下班总结》&lt;/strong&gt;，感叹这个世界少了一个出色的程序员。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.998&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicmYsBGINEWdlhCklolcbDMdJ0sAOPPp4oPK8UlZG13NmnulfMGPibdiabQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;500&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么跳槽到一个965的公司，可能可以帮助你远离猝死。那么问题来了，怎么样找到995的公司？&lt;/p&gt;&lt;p&gt;还记得n年前的那个996icu吗？&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;https:&lt;span&gt;//github.com/996icu/996.ICU&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4294478527607362&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicmuDdq7tJO63hqnwZh1wicCRDr6789JGRp7u7iaxaF3Iib6rr6t518UkFjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1630&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;br/&gt;里面贴心地给出了一份996的公司名单，如果你坚决拒绝996，那么从拒绝这份名单里的公司offer开始。&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;https:&lt;span&gt;//github.com/996icu/996.ICU/tree/master/blacklist&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6169811320754717&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicmLynMYMb6OMYFMmMegnsTG44zgiaeySyax5ax0SemELm1c6ByvWrpbqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2120&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;br/&gt;同时给出了这些公司996的证据，真正做到&quot;拒绝张嘴就来&quot;和有理有据，非常符合程序员讲事实摆道理的性格。&lt;p&gt;建议大家根据钱包厚度和身体承受能力进行选择，996下班不可怕，可怕的是，半夜一个报警就可以爬起来愉快网上冲浪了。以前高中的时候还要翻墙出去网吧通宵，现在在家里就能做到！&lt;/p&gt;&lt;p&gt;同时也给出了一份965的公司名单。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;https:&lt;span&gt;//github.com/996icu/996.ICU/tree/master/whitelist&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是值得一提，这些公司都比较少，同时不排除哪一天不会变成996。毕竟制度是人定的，公司也是要盈利的，哪天换了个领导冲kpi，大家也只能一起冲冲冲了。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5968342644320298&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicmn9xzM74ocnID1wwYW5KMcVObfBH755kd9Wbhyn61V2wYWrL4iamkv3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2148&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;结论上来说，996的公司比965的公司&lt;strong&gt;多太多&lt;/strong&gt;，大部分有志青年都在996的公司里，&lt;strong&gt;既然无法避免，那就要学会怎么在工作中防猝死&lt;/strong&gt;。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;学会划水&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;如果你已经在996的公司里，同时你的钱包需要你通过这种方式出卖劳动，那么显然换行业，跳槽，都不太适合，毕竟轻松意味着钱少。那么怎么在996公司里防猝死呢？&lt;br/&gt;划水成为唯一答案，划水其实也是一种技术，是分等级的，下面分享几个实用的划水技巧。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;初级划水技能&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;初级划水技能是属于每个程序员都要学会的基础技能。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;不要让自己看起来很闲&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;不管是因为你是真的很闲，还是因为你效率高很快把活干完了。如果你看起来很闲，老板就容易会认为你工作不饱和，从而不断加活，直到你看起来一直在忙为止。既然如此，如果你一直看起来很忙，那么这样的问题可以被很好的避免。而vscode是程序员最常用的编辑器，我们可以在此基础上找到很多划水神器。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9840909090909091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicmqdmOPNhHRrVianTbunkrdQ0qjnzlzUm0p2wxwGNUAIJHrYbflCT0Hmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;440&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h5&gt;&lt;span&gt;模拟写代码&lt;/span&gt;&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;https:&lt;span&gt;//github.com/zy445566/vscode-plugin-swimming&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码写的快，提早完工被压榨怎么办？你需要一个模拟写代码工具，让VSCode模拟写代码，划水、摸鱼神器，让代码自己重写一遍。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6749116607773852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicmqS7FP8Ur2rBeDpfiaabcVSxianVueahfp48icLUOWDQwp6MYQTolSJorQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1132&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h5&gt;&lt;span&gt;看小说工具&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;上学那会偷偷摸摸看小说时会在小说本上套上一层课本封面，以此来掩盖上课划水的行为。同样的道理，下面这个插件感觉跟上课看小说的经历有点像，他让开发者可以在 VSCode 上边写代码边看小说。&lt;/p&gt;&lt;p&gt;下次等产品经理路过你身旁的时候，以为你写了一堆密密麻麻的的代码，都不好意思再给你加需求。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6391402714932126&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicmlufEN7KxgzIcz1ibaJMLO5T2X4TGU98XyYHA22F1p5EnkhMzibjwWKLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1768&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;https://github.com/zrk1993/&lt;span&gt;read&lt;/span&gt;-vscode&lt;span&gt;-e&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;span&gt;听音乐插件&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;做事做全套，还要在vscode装上听音乐的插件。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicmibneajL8NAjcXE2r1LZZceEjtakicKrKf65bjich0NVqFlEpk6w9zGMoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;https:&lt;span&gt;//github.com/nondanee/vsc-netease-music&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;span&gt;炒股&lt;/span&gt;&lt;/h5&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7212449255751014&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicmuIVGCaXWEY70nhFgyic7mW9BMXhG0Eic5JdbxSicPWr2DVUOVfjoRibu6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1478&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;https:&lt;span&gt;//github.com/roblourens/vscode-stocks&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;中级划水技能&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;项目时间预估&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;每次需求迭代，产品都会让开发给出一个开发时间。&lt;/p&gt;&lt;p&gt;我接触过的百分之90的程序员都是老实的小伙子，是多少就报多少，有些为了方便产品快速看效果，还会压缩自己的时间，这种情况在新人程序员里尤为明显。&lt;/p&gt;&lt;p&gt;但有些不讲武德的产品，会动不动做一点 &lt;strong&gt;小小的改动&lt;/strong&gt;，同时因为改动&lt;strong&gt;较小&lt;/strong&gt;，之前提到的时间一般不会更改。&lt;/p&gt;&lt;p&gt;如果你所在的项目中产品不止一个人，就可能出现多个产品给你提需求的情况，改动不大，但挺急。&lt;/p&gt;&lt;p&gt;一个程序员越老实，就越不会表达，选择闷头苦干，有些甚至牺牲节假日时间在家干活。&lt;/p&gt;&lt;p&gt;因此为了更好的应对这些非常常见的情况，建议再估计工时的时候，都多预估至少20~50%的时间当做buffer。&lt;/p&gt;&lt;p&gt;如果你提前做好需求，&lt;strong&gt;请务必不要提前给产品看，这只会方便他在看到实物后做出更多的变更&lt;/strong&gt;。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.990909090909091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicmtpPLa28OdaHTOHNO2FbCXia3dFCicq4yPomxQIKG5UkblofHUyoL0D0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;440&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;如何巧妙的推掉需求&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;很多产品在做每一期迭代开发需求的时候，会有无穷无尽的想法，而且恨不得都全部实现，最好今天就能给到。&lt;/p&gt;&lt;p&gt;大部分老实的程序员，会选择尽可能满足这些可爱的需求。这些永远没办法做完的需求，才是耗尽程序员心力的重要因素。&lt;/p&gt;&lt;p&gt;你需要给每个需求和变更排期，给需求留足buffer，确保线上出问题的时候你还有时间去处理。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;让产品给这些需求排优先级&lt;/strong&gt;，从高到低，算好每个需求的人日，做不了一定要提出来，剩下的让不同产品去pk优先级，确保你不过劳。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9138576779026217&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicmJhPS55cW3JqGox0QgkSqI75DxGGx7Uu6G2Co58EOD96jtKKL0E4mFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;267&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;减少不必要的沟通&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;很多不明真相的产品、运营、其他部门的开发会通过各种途径找到你，大部分时候他们找你都是为了向你询问一些无关痛痒的问题。&lt;/p&gt;&lt;p&gt;有些时候当他们询问的问题触及技术细节的时候，新人程序员都会想要试图产生程序实现原理细节。&lt;/p&gt;&lt;p&gt;请记住一句话，&lt;strong&gt;千万不要跟不是搞技术的人聊实现细节，如果可以，最好别跟任何人聊技术实现细节&lt;/strong&gt;，不仅会把他们的思路带跑偏，还会越解释越迷糊。&lt;/p&gt;&lt;p&gt;另外还有一些人遇到一些疑问，会用企业微信或钉钉找到你，如果这个人说的事情不是紧急的事情，同时没有直接找到你面前，&lt;strong&gt;尽量选择过半小时后再处理&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;你要相信他们自己解决问题的能力，大部分不重要或跟你关系不大的问题，会因为你的延缓处理&lt;strong&gt;自动消失&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;大部分真正需要你解决的问题，&lt;strong&gt;半小时后还会再找你一次&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;另外，哪怕不听音乐，&lt;strong&gt;带上耳机，可以减少10%的无效沟通&lt;/strong&gt;，懂的自然懂。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9921875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicmoauKbWJSJqEMC3PRLEIWvUIJnEvHoicYcfVXuVKLhtL4dc60uXPiaNpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;256&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;提升办事效率&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;提升办事效率是为了减少自己无用时间的支出，从而不至于让自己没有时间在工作之余锻炼休闲。&lt;/p&gt;&lt;p&gt;提升效率这个事情其实比较简单。&lt;/p&gt;&lt;p&gt;选择适合自己的办公软件。比如印象笔记或有道云笔记来记录工作要点和备忘，用番茄学习时间来强迫自己专心写代码，同时还能装个眼睛护士定时提醒自己要放松一下眼睛。&lt;/p&gt;&lt;p&gt;另外我个人强烈建议大家&lt;strong&gt;多喝水&lt;/strong&gt;。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.42371134020618556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicmzmZprpoiaUKEGZRp2yKFmBuMwJyTgicL0qdLOpf6dTyNvnPVDoq98NXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;970&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;另外推荐几个 VSCode 效率插件&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;https:&lt;span&gt;//www.infoq.cn/article/c4wbmkc7sslz28gyazll&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;mac 效率神器&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;https:&lt;span&gt;//github.com/Louiszhai/tool&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;高级划水技能&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;防猝死的最高技巧是提升技术水平，可以减少排查问题的时间，提升工作效率，更好的预估时间（意味着可以更精确地给自己多估两天排期）。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.43004418262150224&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicm7e50gM6PJYjrsZxO5YUIa0Ij6RqoGVWichpv8yb7fbX0tSgia1IdRagQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;679&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9393939393939394&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicmQymSceqDUORyCgxe0PcONiay6AibhJUjg953zdYNMmAbPCrG1VEyS18A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;198&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.24676445211389128&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicmVgwsGQhQicUKqXgmNPK5p00XWILNwKv2NFDYRqOmbDvibJm6tzMQgGcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1159&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicmD825riaGk6ibMEHezPQQMXRDldNxx9Xh4XuC05HuXSZ9WjURJljDhlsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;380&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;只有提升自身硬实力，才能打破这个死循环。&lt;/p&gt;&lt;p&gt;下面介绍一个golang程序员学习提升的项目,里面有&lt;strong&gt;超全的golang面试问题和学习路线整理&lt;/strong&gt;，用问题驱动去学习，&lt;strong&gt;点击文章最底部【阅读原文】立刻体验在知识的海洋里呛水的感觉。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;同时还有一张完整的入门进阶知识图谱，值得star一个啊。关于其他编程语言的学习路线，欢迎各位私信我学习地址。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;https:&lt;span&gt;//github.com/xiaobaiTech/golangFamily&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure&gt;&lt;img data-ratio=&quot;2.8077571669477233&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicmhqr5kR5fMNPP6y2bC4P1xwibCeIHt7PbLMJEaBTKo92pn4gmziaq94VA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1186&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;学会管理自己的时间&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;要学习时间管理，就要像这个领域里最顶尖的大师学习。&lt;/p&gt;&lt;p&gt;而这个领域里我只认罗老师，罗老师去年荣获时间管理大师称号。在业务能力上罗老师绝对是个优秀的好歌手好演员，各领域开花，忙是不可避免的，工作强度不会比程序员弱。&lt;/p&gt;&lt;p&gt;在此基础上，还能做到宛如影分身之术一般时间管理能力，除了熬出两个黑眼圈外，身体却十分硬朗。仔细一想，罗老师是在承受着身体和心理都在长时间承受高强度的压力，但却不影响他身心健康。&lt;/p&gt;&lt;p&gt;我们可以好好分析一下，罗老师为什么能在防猝死这件事情上做的如此出类拔萃。个人拙见，有三点&lt;/p&gt;&lt;h3&gt;&lt;span&gt;热爱自己的事业&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;我们可以看下，罗老师的日程表。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7661290322580645&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicmuKdDRfDcAdnWTwkiaFrLZml1Nam2icq5oVYvrPex4I9cuumDvFOLLyTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;这工作强度映射到程序员身上，也差不多跟连续开会写代码997差不多了吧，然而他却硬朗得很。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;他到底是怎么做到的呢？一言以蔽之，&lt;strong&gt;热爱&lt;/strong&gt;。解bug的过程可能是难受压抑紧张的，但是解bug成功带来的成就感真的很爽。&lt;/p&gt;&lt;p&gt;如果不热爱这份工作，那么成就感没了，只剩下难受和压抑了，不快乐的人，说不定哪天&lt;strong&gt;说没就没了&lt;/strong&gt;。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicmhBkL00guIbAJNjSFbr8cdluYxMHX0RyP6aeNzpHxwwicqia0ksLIYgSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;180&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;锻炼身体&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;他热爱跳舞，被称为“亚洲舞王”。虽然这个称呼有点夸张，但是他不是天赋型选手，跳舞能力是花时间练出来的。&lt;/p&gt;&lt;p&gt;而跳舞这件事情，和健身类似，让身体动起来了，出汗了，你自然就爽了。&lt;/p&gt;&lt;p&gt;大家应该都有一种感觉，运动，会让你出汗，会让身体巨酸巨累，但是这个过程中，会让心情变得畅快不压抑，还能让你&lt;strong&gt;因为敲代码而变得瘦弱的肱二头肌变得粗壮一些&lt;/strong&gt;。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicm1hiaxH3sQGdHYzb8gkm7HpnEwMIgZ5Etnj5dyRgaN8XppuSpWCjEx2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;200&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;事业之外还有自己的爱好&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;这个世界上只有一种真正的英雄主义，就是在认清生活的真相之后，还能热爱生活。&lt;/p&gt;&lt;p&gt;很多程序员在大学刚毕业的时候，都想着自己以后能做一个牛逼哄哄的软件，然后跟乔布斯一样改变这个世界，但是往往又在几年后选择成为一条咸鱼，每天疲惫于跟产品经理斗智斗勇，只要能砍掉哪怕一个需求，那也是一次重大胜利。&lt;/p&gt;&lt;p&gt;我们都只是普通人，产品经理没错，程序猿也没错，当一条咸鱼也挺香的，但是在工作中当咸鱼可以，唯唯诺诺可以，但下了班，你必须重拳出击。&lt;/p&gt;&lt;p&gt;你得有自己的爱好，可以是爬山旅游，篮球游泳。如果这些都太索然无味，你还可以去酒吧&lt;strong&gt;跟各种臭妹妹坏弟弟喝上一杯&lt;/strong&gt;。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.956&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicm6lNOBiapXSZoJACvHGHaM6TdRib7mn2XPqJc8eicmNT4aYbFWiaDniaaogQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;250&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;要&lt;strong&gt;每天看一遍猝死的新闻&lt;/strong&gt;，坚定自己划水的信念。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9315068493150684&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicmLkYayiaCJ4038SrzzISBVCTefoxkEFSVZX0Z2yibibf2neJnXdibsCd4tA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1314&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;鲁迅曾经说过，&lt;strong&gt;划水最好的时候两个时间，一个是十年前，一个是现在&lt;/strong&gt;。你懂我意思吧？&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicm7hU4ouc6ukTbXe7YY5s3OUbgN6Onicj8yJy2icOm5wCSWnKTGowL5Ribg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;255&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;没懂? &lt;strong&gt;点个在看，你的每一次扩散都可能拯救一个在猝死边缘的程序猿！&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8574561403508771&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicmq73gZ1Hbpm9YfjvA8nByPib4O8Tg8eYmkp6Bkiat0ddgsolxLEWt1IEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;912&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/FmVWPHrDdnkeTvagibkdxicXBoYaqwXuicmZAHNaMptpG1RuAGbeqKpU7aEFRJmBicITysibicOxYlQmSP1rr2YY6Giag/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;900&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>54758877254642c98637ff6890c32e19</guid>
<title>系统性能提升之缓存</title>
<link>https://toutiao.io/k/kui38g4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;_2rhmJa&quot;&gt;&lt;p&gt;&lt;strong&gt;缓存&lt;/strong&gt;是解决互联网大流量常用的性能提升方式之一，也是最常被问到的问题。缓存又多种多样，像Java的内存缓存就有Guava Cache、Ehcache、Caffeine等等；像远程存储缓存（需要独立部署）常用的有Memcached、Redis等等。&lt;/p&gt;
&lt;p&gt;已知&lt;strong&gt;缓存&lt;/strong&gt;可以提升系统性能，那么适合什么场景？&lt;/p&gt;

&lt;p&gt;不同的场景都有各自的缓存策略，最最常见的就是先查询缓存，如果缓存未命中，再查询数据库，最后将数据库的数据添加到缓存中，以Redis缓存为例，代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;@Autowired
RedisTemplate&amp;lt;Long,String&amp;gt; redisTemplate;

public String getName(Long id){
  String name = redisTemplate.opsForValue().get(id);
  if(name == null){
    name = dao.getNameById(id);
    redisTemplate.opsForValue().setIfAbsent(id,name,30, TimeUnit.SECONDS);
  }
  return name;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相信大家这样的代码都不陌生，向大家推荐一个极其简单、好用的缓存组件&lt;strong&gt;AutoCache&lt;/strong&gt;组件，只需要这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;@AutoCache(remoteTTL = 30)
public String getName(Long id){
  return dao.getNameById(id);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为应对更多场景，还&lt;strong&gt;支持二级缓存&lt;/strong&gt;，也非常简单。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;@AutoCache(localTTL = 5, remoteTTL = 30)
public String getName(Long id) {
  return dao.getNameById(id);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置添加&lt;code&gt;Maven&lt;/code&gt;即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.github.haozi2015&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;autocache-spring-boot-starter&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.0.4&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更多功能，请关注作者&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fhaozi2015&quot; target=&quot;_blank&quot;&gt;haozi2015&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;源码：&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fhaozi2015%2FautoCache&quot; target=&quot;_blank&quot;&gt;https://github.com/haozi2015/autoCache&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gitee同步更新：&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fgitee.com%2Fopenhaozi2015%2FautoCache&quot; target=&quot;_blank&quot;&gt;https://gitee.com/openhaozi2015/autoCache&lt;/a&gt;&lt;/p&gt;
&lt;/article&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b323392bd69a38323b8a6dbf9dda0b62</guid>
<title>Java 高并发编程基础之 AQS</title>
<link>https://toutiao.io/k/6s1vey3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;引言&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;曾经有一道比较比较经典的面试题“你能够说说&lt;code&gt;java&lt;/code&gt;的并发包下面有哪些常见的类？”大多数人应该都可以说出
CountDownLatch、CyclicBarrier、Sempahore多线程并发三大利器。这三大利器都是通过&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;抽象类(下面简写AQS)来实现的，所以学习三大利器之前我们有必要先来学习下&lt;code&gt;AQS&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;★&lt;/span&gt;&lt;p&gt;AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;AQS结构&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到同步我们如何来保证同步？大家第一印象肯定是加锁了，说到锁的话大家肯定首先会想到的是Synchronized。Synchronized大家应该基本上都会使用，加锁和释放锁都是jvm 来帮我们实现的，我们只需要简单的加个 Synchronized关键字就可以了。用起来超级方便。但是有没有一种情况我们设置一个锁的超时时间Synchronized就有点实现不了，这时候我们就可以用ReentrantLock来实现,ReentrantLock是通过aqs来实现的，今天我们就通过ReentrantLock来学习一下aqs。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;CAS &amp;amp;&amp;amp; 公平锁和非公平锁&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AQS里面用到了大量的CAS学习AQS之前我们还是有必要简单的先了解下&lt;code&gt;CAS&lt;/code&gt;、公平锁和非公平锁。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;CAS&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;CAS&lt;/strong&gt; 全称是 compare and swap，是一种用于在多线程环境下实现同步功能的机制。&lt;code&gt;CAS&lt;/code&gt; 操作包含三个操作数 ：内存位置、预期数值和新值。&lt;code&gt;CAS&lt;/code&gt; 的实现逻辑是将内存位置处的数值与预期数值相比较，若相等，则将内存位置处的值替换为新值。若不相等，则不做任何操作,这个操作是个原子性操作，java里面的&lt;code&gt;AtomicInteger&lt;/code&gt;等类都是通过cas来实现的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;公平锁和非公平锁&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，队列中第一个才能获得到锁。优点：等待锁的线程不会饿死，每个线程都可以获取到锁。缺点：整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必唤醒所有线程，会减少唤起线程的数量。缺点：处于等待队列中的线程可能会饿死，或者等很久才会获得锁。文字有点拗口，我们来个实际的例子说明下。比如我们去食堂就餐的时候都要排队，大家都按照先来后到的顺序排队打饭，这就是公平锁。如果等到你准备拿盘子打饭的时候
直接蹦出了一个五大三粗的胖子插队到你前面，你看打不赢他只能忍气吞声让他插队，等胖子打完饭了又来个小个子也来插你队，这时候你没法忍了，直接大吼一声让他滚，这个
小个子只能屁颠屁颠到队尾去排队了这就是非公平锁。我们先来看看AQS有哪些属性&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 头节点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; Node head;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; Node tail;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; state;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// if (currentThread == getExclusiveOwnerThread()) {state++}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; Thread exclusiveOwnerThread; &lt;span&gt;//继承自AbstractOwnableSynchronizer&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来写一个demo分析下lock 加锁和释放锁的过程&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;   &lt;span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;// 上来先试试直接把状态置位1，如果此时没人获取锁就直接&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (compareAndSetState(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;))&lt;br/&gt;                 &lt;span&gt;// 争抢成功则修改获得锁状态的线程&lt;/span&gt;&lt;br/&gt;                setExclusiveOwnerThread(Thread.currentThread());&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;                acquire(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;cas&lt;/code&gt;尝试失败，说明已经有人再持有锁，所以进入acquire方法&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;acquire&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!tryAcquire(arg) &amp;amp;&amp;amp;&lt;br/&gt;            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))&lt;br/&gt;            selfInterrupt();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;tryAcquire&lt;/code&gt;方法，看名字大概能猜出什么意思，就是试一试。tryAcquire实际上是调用了父类Sync的&lt;code&gt;nonfairTryAcquire&lt;/code&gt;方法&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;nonfairTryAcquire&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; acquires)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; Thread current = Thread.currentThread();&lt;br/&gt;             &lt;span&gt;// 获取下当前锁的状态&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; c = getState();&lt;br/&gt;            &lt;span&gt;// 这个if 逻辑跟前面一进来就获取锁的逻辑一样都是通过cas尝试获取下锁&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (c == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (compareAndSetState(&lt;span&gt;0&lt;/span&gt;, acquires)) {&lt;br/&gt;                    setExclusiveOwnerThread(current);&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;// 进入这个判断说明 锁重入了 状态需要进行+1&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (current == getExclusiveOwnerThread()) {&lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; nextc = c + acquires;&lt;br/&gt;                 &lt;span&gt;// 如果锁的重入次数大于int的最大值，直接就抛出异常了，正常情况应该不存在这种情况，不过jdk还是严谨的&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (nextc &amp;lt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;// overflow&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error(&lt;span&gt;&quot;Maximum lock count exceeded&quot;&lt;/span&gt;);&lt;br/&gt;                setState(nextc);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;// 返回false 说明尝试获取锁失败了，失败了就要进行acquireQueued方法了&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;tryAcquire&lt;/code&gt;方法如果获取锁失败了,那么肯定就要排队等待获取锁。排队的线程需要待在哪里等待获取锁？这个就跟我们线程池执行任务一样，线程池把任务都封装成一个work，然后当线程处理任务不过来的时候，就把任务放到队列里面。AQS同样也是类似的，把排队等待获取锁的线程封装成一个NODE。然后再把NODE放入到一个队列里面。队列如下所示，不过需要注意一点head是不存NODE的。&lt;img data-ratio=&quot;0.3125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qu3ItokgsAribV9N3OiakAlkoCaXptm2AkJtW7icagn8LOTGjRTaA145YLvhUEq9HzQdpPpPoxXJzZIT7xsviauGjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1408&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们继续分析源码，看下获取锁失败是如何被加入队列的。就要执行acquireQueued方法，执行acquireQueued方法之前需要先执行addWaiter方法&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; Node &lt;span&gt;addWaiter&lt;/span&gt;&lt;span&gt;(Node mode)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Node node = &lt;span&gt;new&lt;/span&gt; Node(Thread.currentThread(), mode);&lt;br/&gt;        &lt;span&gt;// Try the fast path of enq; backup to full enq on failure&lt;/span&gt;&lt;br/&gt;        Node pred = tail;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (pred != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            node.prev = pred;&lt;br/&gt;            &lt;span&gt;// cas 加入队列队尾&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (compareAndSetTail(pred, node)) {&lt;br/&gt;                pred.next = node;&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; node;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 尾结点不为空 || cas 加入尾结点失败&lt;/span&gt;&lt;br/&gt;        enq(node);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; node;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;enq&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来再看看enq方法&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 通过自旋和CAS一定要当前node加入队尾&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; Node &lt;span&gt;enq&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; Node node)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;            Node t = tail;&lt;br/&gt;            &lt;span&gt;// 尾结点为空说明队列还是空的，还没有被初始化，所以初始化头结点，可以看到头结点的node 是没有绑定线程的也就是不存数据的&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (t == &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;// Must initialize&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (compareAndSetHead(&lt;span&gt;new&lt;/span&gt; Node()))&lt;br/&gt;                    tail = head;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                node.prev = t;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (compareAndSetTail(t, node)) {&lt;br/&gt;                    t.next = node;&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; t;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过addWaiter方法已经把获取锁的线程通过封装成一个NODE加入对列。上述方法的一个执行流程图如下：&lt;img data-ratio=&quot;0.7497219132369299&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qu3ItokgsAribV9N3OiakAlkoCaXptm2AksU1ic1nEp3v4OzYUxlB0wZXVrqk55x6ibibickjfLtXlOQffWutmfOXBow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;899&quot;/&gt;，接下来就是继续执行acquireQueued方法&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;acquireQueued&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;acquireQueued&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; Node node, &lt;span&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; failed = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;boolean&lt;/span&gt; interrupted = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;                 &lt;span&gt;// 通过自旋去获取锁 前驱节点==head的时候去尝试获取锁，这个方法在前面已经分析过了。&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;final&lt;/span&gt; Node p = node.predecessor();&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {&lt;br/&gt;                    setHead(node);&lt;br/&gt;                    p.next = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;// help GC&lt;/span&gt;&lt;br/&gt;                    failed = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; interrupted;&lt;br/&gt;                }&lt;br/&gt;               &lt;span&gt;// 进入这个if说明node的前驱节点不等于head 或者尝试获取锁失败了&lt;/span&gt;&lt;br/&gt;               &lt;span&gt;// 判断是否需要挂起当前线程&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;&lt;br/&gt;                    parkAndCheckInterrupt())&lt;br/&gt;                    interrupted = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;               &lt;span&gt;// 异常情况进入cancelAcquire，在jdk11的时候这个源码直接是catch (Throwable e){ cancelAcquire(node);} 简单明了&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (failed)&lt;br/&gt;                cancelAcquire(node);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;setHead&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法每当有一个node获取到锁了，就把当前&lt;code&gt;node&lt;/code&gt;节点设置为头节点，可以简单的看做当前节点获取到锁了就把当前节点”移除“（变为头结点）队列。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;shouldParkAfterFailedAcquire&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到这个方法我们就要先看下NODE可能会有哪些状态在源码里面我们可以看到总共会有四种状态&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;CANCELLED&lt;/strong&gt;：值为1，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node的结点，其结点的waitStatus为CANCELLED，即结束状态，进入该状态后的结点将不会再变化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;SIGNAL&lt;/strong&gt;：值为-1，被标识为该等待唤醒状态的后继结点，当其前继结点的线程释放了同步锁或被取消，将会通知该后继结点的线程执行。说白了，就是处于唤醒状态，只要前继结点释放锁，就会通知标识为SIGNAL状态的后继结点的线程执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;CONDITION&lt;/strong&gt;：值为-2，与Condition相关，该标识的结点处于等待队列中，结点的线程等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;PROPAGATE&lt;/strong&gt;：值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;shouldParkAfterFailedAcquire&lt;/span&gt;&lt;span&gt;(Node pred, Node node)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; ws = pred.waitStatus;&lt;br/&gt;        &lt;span&gt;// 前驱节点状态 如果这个状态为-1 则返回true，把当前线程挂起&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (ws == Node.SIGNAL)&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;// 大于0，说明状态为CANCELLED &lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (ws &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;               &lt;span&gt;// 删除被取消的node（让被取消的node成为一个没有引用的node等着下次GC被回收）&lt;/span&gt;&lt;br/&gt;                node.prev = pred = pred.prev;&lt;br/&gt;            } &lt;span&gt;while&lt;/span&gt; (pred.waitStatus &amp;gt; &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;            pred.next = node;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// 进入这里只能是 0，-2，-3。NODE节点初始化的时候waitStatus默认值是0，所以只有这里才有修改waitStatus的地方&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// 通过cas 把前驱节点的状态设置为-1，然后返回false ，外面调用这个方法的是个循环，又会调用一次这个方法&lt;/span&gt;&lt;br/&gt;            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;parkAndCheckInterrupt&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;挂起当前线程，并且阻塞&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;parkAndCheckInterrupt&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    LockSupport.park(&lt;span&gt;this&lt;/span&gt;); &lt;span&gt;// 挂起当前线程，阻塞&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Thread.interrupted();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.3282122905027933&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qu3ItokgsAribV9N3OiakAlkoCaXptm2AkicuDhTLSMU3WH9cxxT9oUAw8fVXlxNYqD6ricKKvyiawwwicJlr4J9cypA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;716&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解锁&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加锁成功了，那锁用完了就应该释放锁了，释放锁重点看下unparkSuccessor这个方法就好了&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;unparkSuccessor&lt;/span&gt;&lt;span&gt;(Node node)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;          &lt;span&gt;// 头结点状态&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; ws = node.waitStatus;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (ws &amp;lt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;            compareAndSetWaitStatus(node, ws, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        Node s = node.next;&lt;br/&gt;        &lt;span&gt;// s==null head的successor节点获取锁成功后，执行了head.next=null的操作后，解锁线程读取了head.next，因此s==null&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// head的successor节点被取消（cancelAcquire）时，执行了如下操作：successor.waitStatus=1 ; successor.next = successor;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (s == &lt;span&gt;null&lt;/span&gt; || s.waitStatus &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            s = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;// 从尾节点开始往前找，找到最前面的非取消的节点 这里没有break 哦&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (Node t = tail; t != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; t != node; t = t.prev)&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (t.waitStatus &amp;lt;= &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;                    s = t;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (s != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;             &lt;span&gt;// 唤醒线程 ，唤醒的线程会从acquireQueued去获取锁&lt;/span&gt;&lt;br/&gt;            LockSupport.unpark(s.thread);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;释放锁代码比较简单，基本都写在代码注释里面了，流程如下：&lt;img data-ratio=&quot;1.0345285524568393&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qu3ItokgsAribV9N3OiakAlkoCaXptm2Aks1vK9UvA7ncZw6vICwgaTZtaiakLY9EcZA1zNcHUk3eBjJPL0iaQumLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;753&quot;/&gt;这段代码里面有一个比较经典的面试题：如果头结点的下一个节点为空或者头结点的下一个节点的状态为取消的时候为什么要从后往前找，找到最前面非取消的节点？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;node.prev = pred; compareAndSetTail(pred, node) 这两个地方可以看作Tail入队的原子操作，但是此时pred.next = node;还没执行，如果这个时候执行了unparkSuccessor方法，就没办法从前往后找了，所以需要从后往前找。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在产生CANCELLED状态节点的时候，先断开的是Next指针，Prev指针并未断开，因此也是必须要从后往前遍历才能够遍历完全部的Node&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;reentrantLock的获取锁和释放锁基本就讲完了，里面还涉及多比较多的细节，感兴趣的同学可以对着源码一行一行去debug试试。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;适当的了解aqs才能更好的学习CountDownLatch、CyclicBarrier、Sempahore，因为这三个利器都是基于aqs来实现的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;结束&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;由于自己才疏学浅，难免会有纰漏，假如你发现了错误的地方，还望留言给我指出来,我会对其加以修正。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果你觉得文章还不错，你的转发、分享、赞赏、点赞、留言就是对我最大的鼓励。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;感谢您的阅读,十分欢迎并感谢您的关注。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIyMjQwMTgyNA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/qu3ItokgsApF99T8iaeM8zcTTMB6stsfYOGjWJ9MkQlr5zJ2gDIOFInycWpDDZjNk0mft0UNxytqBsE3qQicrlVw/0?wx_fmt=png&quot; data-nickname=&quot;java金融&quot; data-alias=&quot;java4299&quot; data-signature=&quot;关注【java金融】后台回复「666」 领取一份面试资料《Java面试BATJ通关手册》，覆盖了Java核心技术、JVM、Java并发、SSM、微服务、数据库、数据结构简历等等。&quot;/&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;站在巨人的肩膀上摘苹果:&lt;/section&gt;&lt;section&gt;https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html
https://javadoop.com/post/AbstractQueuedSynchronizer
https://www.cnblogs.com/yanlong300/p/10953185.html&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>644c00761274b04b1c89e19859c2dc0e</guid>
<title>什么是大端序和小端序，为什么要有字节序</title>
<link>https://toutiao.io/k/8sgffjn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;什么是字节序&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUzNTY5MzU2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4pGhLz2xEbRFHnAQon2QLYgbBibCJo1ibJHesLWshPJeRibateRtAqkaf6BgjlbhYiaxHLq6Zu07CRPw/0?wx_fmt=png&quot; data-nickname=&quot;网管叨bi叨&quot; data-alias=&quot;kevin_tech&quot; data-signature=&quot;每周分享技术类原创文章&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;字节序&lt;/strong&gt;，又称&lt;strong&gt;端序&lt;/strong&gt;或&lt;strong&gt;尾序&lt;/strong&gt;（英语中用单词：&lt;strong&gt;Endianness&lt;/strong&gt; 表示），在计算机领域中，指电脑内存中或在数字通信链路中，占用多个字节的数据的字节排列顺序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在几乎所有的平台上，多字节对象都被存储为连续的字节序列。例如在 Go 语言中，一个类型为&lt;code&gt;int&lt;/code&gt;的变量&lt;code&gt;x&lt;/code&gt;地址为&lt;code&gt;0x100&lt;/code&gt;，那么其指针&lt;code&gt;&amp;amp;x&lt;/code&gt;的值为&lt;code&gt;0x100&lt;/code&gt;。且&lt;code&gt;x&lt;/code&gt;的四个字节将被存储在内存的&lt;code&gt;0x100, 0x101, 0x102, 0x103&lt;/code&gt;位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字节的排列方式有两个通用规则:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;大端序（Big-Endian）将数据的低位字节存放在内存的高位地址，高位字节存放在低位地址。这种排列方式与数据用字节表示时的书写顺序一致，符合人类的阅读习惯。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;小端序（Little-Endian），将一个多位数的低位放在较小的地址处，高位放在较大的地址处，则称&lt;strong&gt;小端序&lt;/strong&gt;。小端序与人类的阅读习惯相反，但更符合计算机读取内存的方式，因为CPU读取内存中的数据时，是从低地址向高地址方向进行读取的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的文字描述有点抽象，我们拿一个例子来解释一下字节排列时的大端序和小端序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在内存中存放整型数值&lt;code&gt;168496141&lt;/code&gt; 需要4个字节，这个数值的对应的16进制表示是&lt;code&gt;0X0A0B0C0D&lt;/code&gt;，这个数值在用大端序和小端序排列时的在内存中的示意图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6789536266349584&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/z4pQ0O5h0f57PdQApCiar2T7k6Rd35YE3ic8t5ZgDto1gUtS0MhLv6hRIib5J1396Nfjd65vkgtWNalRTbeSbINicw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;841&quot;/&gt;&lt;figcaption&gt;大端序和小端序&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;为何要有字节序&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多人会问，为什么会有字节序，统一用大端序不行吗？答案是，计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，&lt;strong&gt;计算机的内部处理都是小端字节序。在计算机内部，小端序被广泛应用于现代 CPU 内部存储数据；而在其他场景，比如网络传输和文件存储则使用大端序&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Go语言对字节序的处理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言存储数据时的字节序依赖所在平台的 CPU，处理大小端序的代码位于 &lt;code&gt;encoding/binary&lt;/code&gt; ,包中的全局变量&lt;code&gt;BigEndian&lt;/code&gt;用于操作大端序数据，&lt;code&gt;LittleEndian&lt;/code&gt;用于操作小端序数据，这两个变量所对应的数据类型都实现了&lt;code&gt;ByteOrder&lt;/code&gt;接口。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;encoding/binary&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;unsafe&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; INT_SIZE = &lt;span&gt;int&lt;/span&gt;(unsafe.Sizeof(&lt;span&gt;0&lt;/span&gt;)) &lt;span&gt;//64位操作系统，8 bytes&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//判断我们系统中的字节序类型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;systemEdian&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0x01020304&lt;/span&gt;&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;&amp;amp;i:&quot;&lt;/span&gt;,&amp;amp;i)&lt;br/&gt; bs := (*[INT_SIZE]&lt;span&gt;byte&lt;/span&gt;)(unsafe.Pointer(&amp;amp;i))&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; bs[&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;0x04&lt;/span&gt; {&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;system edian is little endian&quot;&lt;/span&gt;)&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;system edian is big endian&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;temp: 0x%x,%v\n&quot;&lt;/span&gt;,bs[&lt;span&gt;0&lt;/span&gt;],&amp;amp;bs[&lt;span&gt;0&lt;/span&gt;])&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;temp: 0x%x,%v\n&quot;&lt;/span&gt;,bs[&lt;span&gt;1&lt;/span&gt;],&amp;amp;bs[&lt;span&gt;1&lt;/span&gt;])&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;temp: 0x%x,%v\n&quot;&lt;/span&gt;,bs[&lt;span&gt;2&lt;/span&gt;],&amp;amp;bs[&lt;span&gt;2&lt;/span&gt;])&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;temp: 0x%x,%v\n&quot;&lt;/span&gt;,bs[&lt;span&gt;3&lt;/span&gt;],&amp;amp;bs[&lt;span&gt;3&lt;/span&gt;])&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;testBigEndian&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; testInt &lt;span&gt;int32&lt;/span&gt; = &lt;span&gt;0x01020304&lt;/span&gt;&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;%d use big endian: \n&quot;&lt;/span&gt;, testInt)&lt;br/&gt; testBytes := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;)&lt;br/&gt; binary.BigEndian.PutUint32(testBytes, &lt;span&gt;uint32&lt;/span&gt;(testInt))&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;int32 to bytes:&quot;&lt;/span&gt;, testBytes)&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;int32 to bytes: %x \n&quot;&lt;/span&gt;, testBytes)&lt;br/&gt;&lt;br/&gt; convInt := binary.BigEndian.Uint32(testBytes)&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;bytes to int32: %d\n\n&quot;&lt;/span&gt;, convInt)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;testLittleEndian&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; testInt &lt;span&gt;int32&lt;/span&gt; = &lt;span&gt;0x01020304&lt;/span&gt;&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;%x use little endian: \n&quot;&lt;/span&gt;, testInt)&lt;br/&gt;  testBytes := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;)&lt;br/&gt; binary.LittleEndian.PutUint32(testBytes, &lt;span&gt;uint32&lt;/span&gt;(testInt))&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;int32 to bytes: %x \n&quot;&lt;/span&gt;, testBytes)&lt;br/&gt;&lt;br/&gt; convInt := binary.LittleEndian.Uint32(testBytes)&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;bytes to int32: %d\n\n&quot;&lt;/span&gt;, convInt)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; systemEdian()&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;&quot;&lt;/span&gt;)&lt;br/&gt; testBigEndian()&lt;br/&gt; testLittleEndian()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上面的程序会在终端里输出&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;amp;i: 0xc000084000&lt;br/&gt;system edian is little endian&lt;br/&gt;temp: 0x4,0xc000084000&lt;br/&gt;temp: 0x3,0xc000084001&lt;br/&gt;temp: 0x2,0xc000084002&lt;br/&gt;temp: 0x1,0xc000084003&lt;br/&gt;&lt;br/&gt;16909060 use big endian: &lt;br/&gt;int32 to bytes: [1 2 3 4]&lt;br/&gt;int32 to bytes: 01020304 &lt;br/&gt;bytes to int32: 16909060&lt;br/&gt;&lt;br/&gt;1020304 use little endian: &lt;br/&gt;int32 to bytes: 04030201 &lt;br/&gt;bytes to int32: 16909060&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合比如网络传输和文件储存，几乎都是用的大端字节序。正是因为这些原因才有了字节序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算机处理字节序的时候，如果是大端字节序，先读到的就是高位字节，后读到的就是低位字节。小端字节序则正好相反。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247487043&amp;amp;idx=1&amp;amp;sn=3896db731e63c516254f9a346b31006e&amp;amp;chksm=fa80dfd4cdf756c2d52d825f948119b66a09da6b0ba821b62ef6ef5ccb99bd80d0551d281de5&amp;amp;token=267822480&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Go指针的使用限制和unsafe.Pointer的突破之路&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>