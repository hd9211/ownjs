<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>092405b653c445f20274cb5dc8db7a62</guid>
<title>用 JavaScript 模拟事件循环</title>
<link>https://toutiao.io/k/t0u10ds</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;header class=&quot;post-header&quot;&gt;
        &lt;h1 class=&quot;post-title&quot; itemprop=&quot;name headline&quot;&gt;
          用JavaScript模拟事件循环
        &lt;/h1&gt;

        &lt;div class=&quot;post-meta-container&quot;&gt;
          &lt;p class=&quot;post-meta&quot;&gt;
    &lt;span class=&quot;post-meta-item&quot;&gt;
      &lt;span class=&quot;post-meta-item-icon&quot;&gt;
        &lt;i class=&quot;far fa-calendar&quot;/&gt;
      &lt;/span&gt;
      &lt;span class=&quot;post-meta-item-text&quot;&gt;发表于&lt;/span&gt;

      &lt;time title=&quot;创建时间：2021-06-09 00:00:00&quot; itemprop=&quot;dateCreated datePublished&quot; datetime=&quot;2021-06-09T00:00:00+08:00&quot;&gt;2021-06-09&lt;/time&gt;
    &lt;/span&gt;
      &lt;span class=&quot;post-meta-item&quot;&gt;
        &lt;span class=&quot;post-meta-item-icon&quot;&gt;
          &lt;i class=&quot;far fa-calendar-check&quot;/&gt;
        &lt;/span&gt;
        &lt;span class=&quot;post-meta-item-text&quot;&gt;更新于&lt;/span&gt;
        &lt;time title=&quot;修改时间：2021-07-05 10:29:19&quot; itemprop=&quot;dateModified&quot; datetime=&quot;2021-07-05T10:29:19+08:00&quot;&gt;2021-07-05&lt;/time&gt;
      &lt;/span&gt;

  
&lt;/p&gt;

        &lt;/div&gt;
      &lt;/header&gt;

    
    
    
    &lt;div class=&quot;post-body&quot; itemprop=&quot;articleBody&quot;&gt;
        &lt;p&gt;&lt;em&gt;本文属于原创文章，转载请注明–来自&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;//affecthing.com&quot;&gt;桃源小盼的博客&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;哇叽哇叽&quot;&gt;&lt;a href=&quot;#哇叽哇叽&quot; class=&quot;headerlink&quot; title=&quot;哇叽哇叽&quot;/&gt;哇叽哇叽&lt;/h2&gt;&lt;p&gt;对于很多概念性的原理，可能三两句话就能概括，但必然损失了很多细节。而实际的代码呢，无法忽略细节，最多是简化一些。&lt;/p&gt;
&lt;p&gt;那么就让我们一起来用伪代码来模拟事件循环机制吧。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Talk is cheap. Show me the code.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;说起来容易做起来难，历史上的马谡可能是最佳反面代表人物了。&lt;/p&gt;
&lt;span id=&quot;more&quot;/&gt;

&lt;h2 id=&quot;为什么是事件循环机制，而不是别的机制？&quot;&gt;&lt;a href=&quot;#为什么是事件循环机制，而不是别的机制？&quot; class=&quot;headerlink&quot; title=&quot;为什么是事件循环机制，而不是别的机制？&quot;/&gt;为什么是事件循环机制，而不是别的机制？&lt;/h2&gt;&lt;p&gt;js主线程要做各种类型的任务，例如：dom事件、布局计算、js任务、用户输入、动画、定时器。&lt;/p&gt;
&lt;h3 id=&quot;如何解决未来的新任务？&quot;&gt;&lt;a href=&quot;#如何解决未来的新任务？&quot; class=&quot;headerlink&quot; title=&quot;如何解决未来的新任务？&quot;/&gt;如何解决未来的新任务？&lt;/h3&gt;&lt;p&gt;各种事件不可能是同一时间执行，会在未来产生新的事件，所以就需要有一个机制像前台接待员一样，一直守在那里，时刻检测是否有新任务了，一有新任务就执行它，这就是事件循环机制。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  doSomething()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;如何解决积攒的新任务？&quot;&gt;&lt;a href=&quot;#如何解决积攒的新任务？&quot; class=&quot;headerlink&quot; title=&quot;如何解决积攒的新任务？&quot;/&gt;如何解决积攒的新任务？&lt;/h2&gt;&lt;p&gt;新任务太多了，前台接待员无法同时处理多个任务，只能让大家排队了，这就是任务队列机制。&lt;/p&gt;
&lt;p&gt;为什么无法同时处理多个任务？因为js(渲染进程的主线程)是单线程执行模式。&lt;/p&gt;
&lt;p&gt;队列是先进先出的数据结构，在js中可以理解为数组。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; queue = []&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; stop = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; task = queue.unshift()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  task()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 退出标志&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (stop) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;高优先级任务被阻塞了&quot;&gt;&lt;a href=&quot;#高优先级任务被阻塞了&quot; class=&quot;headerlink&quot; title=&quot;高优先级任务被阻塞了&quot;/&gt;高优先级任务被阻塞了&lt;/h2&gt;&lt;p&gt;如果只有一个消息队列，那么高优先级的任务一直在等待，可能会产生页面卡顿。&lt;br/&gt;所以按照任务的类型分了几种队列。优先级依次向下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户交互&lt;/li&gt;
&lt;li&gt;合成页面&lt;/li&gt;
&lt;li&gt;默认（资源加载、定时器等）&lt;/li&gt;
&lt;li&gt;空闲（垃圾回收等）&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Queue&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  handleQueue = []  &lt;span class=&quot;comment&quot;&gt;// 交互队列&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  composeQueue = [] &lt;span class=&quot;comment&quot;&gt;// 合成队列&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  baseQueue = []    &lt;span class=&quot;comment&quot;&gt;// 默认队列&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  freeQueue = []    &lt;span class=&quot;comment&quot;&gt;// 空闲队列&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 插入新任务&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;task, type&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (type === &lt;span class=&quot;string&quot;&gt;&#x27;handle&#x27;&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.handleQueue.push(task)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (type === &lt;span class=&quot;string&quot;&gt;&#x27;compose&#x27;&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.composeQueue.push(task)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (type === &lt;span class=&quot;string&quot;&gt;&#x27;base&#x27;&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.baseQueue.push(task)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (type === &lt;span class=&quot;string&quot;&gt;&#x27;free&#x27;&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.freeQueue.push(task)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 获取一个任务&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; queue = []&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (handleQueue.length &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;      queue = handleQueue&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (composeQueue.length &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;      queue = composeQueue&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (baseQueue.length &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;      queue = baseQueue&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (freeQueue.length &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;      queue = freeQueue&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; queue.unshift()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; queue = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Queue()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; stop = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; task = queue.get()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  task()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 退出标志&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (stop) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;页面在不同阶段，高优目标是不同的&quot;&gt;&lt;a href=&quot;#页面在不同阶段，高优目标是不同的&quot; class=&quot;headerlink&quot; title=&quot;页面在不同阶段，高优目标是不同的&quot;/&gt;页面在不同阶段，高优目标是不同的&lt;/h2&gt;&lt;p&gt;页面在加载阶段，第一目标是先把页面渲染出来。&lt;br/&gt;页面在交互阶段，第一目标是及时响应用户的操作。&lt;/p&gt;
&lt;p&gt;为了满足不同阶段的目标，需要调整不同阶段任务队列的优先级。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//blogcdn.affecthing.com/eventloop-1&quot; alt=&quot;natapp1&quot;/&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Queue&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  handleQueue = []&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  composeQueue = []&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  baseQueue = []&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  freeQueue = []&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  priority = []&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 设置优先级&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;setPriority&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;lifecycle&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (lifecycle === &lt;span class=&quot;string&quot;&gt;&#x27;pageload&#x27;&lt;/span&gt;) { &lt;span class=&quot;comment&quot;&gt;// 页面加载&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.priority = [&lt;span class=&quot;string&quot;&gt;&#x27;baseQueue&#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#x27;handleQueue&#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#x27;composeQueue&#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#x27;freeQueue&#x27;&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (lifecycle === &lt;span class=&quot;string&quot;&gt;&#x27;handle&#x27;&lt;/span&gt;) { &lt;span class=&quot;comment&quot;&gt;// 交互阶段&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.priority = [&lt;span class=&quot;string&quot;&gt;&#x27;handleQueue&#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#x27;composeQueue&#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#x27;baseQueue&#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#x27;freeQueue&#x27;&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (lifecycle === &lt;span class=&quot;string&quot;&gt;&#x27;free&#x27;&lt;/span&gt;) { &lt;span class=&quot;comment&quot;&gt;// 空闲阶段&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.priority = [&lt;span class=&quot;string&quot;&gt;&#x27;baseQueue&#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#x27;handleQueue&#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#x27;freeQueue&#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#x27;composeQueue&#x27;&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; curr = []&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 根据优先级顺序来获取任务&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.priority.forEach(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;priority&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; queue = &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;[priority]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (queue.length &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; queue.unshift()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;      }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    })&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 省略&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;task, type&lt;/span&gt;)&lt;/span&gt; {}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; queue = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Queue()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; stop = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;queue.setPriority(&lt;span class=&quot;string&quot;&gt;&#x27;pageload&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; task = queue.get()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  task()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 退出标志&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (stop) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;如何在渲染前做一些任务？&quot;&gt;&lt;a href=&quot;#如何在渲染前做一些任务？&quot; class=&quot;headerlink&quot; title=&quot;如何在渲染前做一些任务？&quot;/&gt;如何在渲染前做一些任务？&lt;/h2&gt;&lt;p&gt;有时候我们想在当前任务完成前再紧接着做一些任务，但是如果插入到队伍末尾，那么需要的时间可能长，可能短，这就无法稳定地按照预期来做了。&lt;/p&gt;
&lt;p&gt;所以增加了微任务队列，在当前任务即将完成时，再执行一些事情，不用等太久。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Task&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  microQueue = []&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 执行任务&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;do&lt;/span&gt;(&lt;span class=&quot;params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// start doSomething&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// doSomething&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// end doSomething&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 检查微任务队列&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (microQueue.length &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;      microQueue.forEach(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;microTask&lt;/span&gt; =&amp;gt;&lt;/span&gt; microTask())&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 添加微任务&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;addMicro&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;microTask&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.microQueue(microTask)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 省略，同上&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Queue&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;task, type&lt;/span&gt;)&lt;/span&gt; {}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;params&quot;/&gt;)&lt;/span&gt; {}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;setPriority&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;lifecycle&lt;/span&gt;)&lt;/span&gt; {}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; queue = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Queue()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;queue.add(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Task(), &lt;span class=&quot;string&quot;&gt;&#x27;base&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; task = queue.get()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  task.do()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 退出标志&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (stop) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;低级任务饿死现象&quot;&gt;&lt;a href=&quot;#低级任务饿死现象&quot; class=&quot;headerlink&quot; title=&quot;低级任务饿死现象&quot;/&gt;低级任务饿死现象&lt;/h2&gt;&lt;p&gt;一直在执行高优任务，低级任务就会出现饿死现象，所以连续执行一定数量的高优任务后，需要执行一次低级任务。&lt;/p&gt;
&lt;h2 id=&quot;异步回调&quot;&gt;&lt;a href=&quot;#异步回调&quot; class=&quot;headerlink&quot; title=&quot;异步回调&quot;/&gt;异步回调&lt;/h2&gt;&lt;p&gt;这里先说一个常识，js虽然是单线程执行，但是浏览器却是多进程的。&lt;/p&gt;
&lt;p&gt;一个异步任务，可能是由浏览器的其他进程或者线程去执行，然后再将执行结果利用 IPC 的方式通知渲染进程，之后渲染进程再将对应的消息添加到消息队列中。&lt;/p&gt;
&lt;h2 id=&quot;setTimeout实现机制有何不同之处？&quot;&gt;&lt;a href=&quot;#setTimeout实现机制有何不同之处？&quot; class=&quot;headerlink&quot; title=&quot;setTimeout实现机制有何不同之处？&quot;/&gt;setTimeout实现机制有何不同之处？&lt;/h2&gt;&lt;p&gt;由于存在时间的概念，并不能直接放入消息队列中。浏览器又增加了一个延迟队列，还有其他的一些延迟任务都在这里执行。每次执行完消息队列中的一个任务，就要检查一遍延迟队列。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; delayQueue = []&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 检查延迟队列中的任务，是否到时间了&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;checkDelayQueue&lt;/span&gt; (&lt;span class=&quot;params&quot;/&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  delayQueue.map(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;task&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&#x27;到期了&#x27;&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;      task()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  })&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 省略&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Queue&lt;/span&gt; &lt;/span&gt;{}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; queue = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Queue()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; task = queue.get()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  task.do()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  checkDelayQueue()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 退出标志&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (stop) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;


&lt;h2 id=&quot;结尾&quot;&gt;&lt;a href=&quot;#结尾&quot; class=&quot;headerlink&quot; title=&quot;结尾&quot;/&gt;结尾&lt;/h2&gt;&lt;p&gt;以上代码不是实际的浏览器实现，只是为了更好理解事件循环机制提供帮助。&lt;/p&gt;
&lt;p&gt;希望你也写出自己的实现版本。&lt;/p&gt;
&lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;/&gt;参考&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;《浏览器工作原理与实践》&lt;/li&gt;
&lt;li&gt;《JavaScript忍者秘籍》&lt;/li&gt;
&lt;/ol&gt;

    &lt;/div&gt;

    
    
    

    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7ec43d0a1ec680cd6f0ac370578364e8</guid>
<title>常见的软件设计原则</title>
<link>https://toutiao.io/k/424q2hi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;戳蓝字「TopCoder&lt;/span&gt;&lt;span&gt;」关注我们哦！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;290&quot; data-backw=&quot;504&quot; data-croporisrc=&quot;https://mp.weixin.qq.com/cgi-bin/photogalleryproxy?action=proxy&amp;amp;url=https%3A%2F%2Finews.gtimg.com%2Fnewsapp_bt%2F0%2F5002a6gmh3kqgk44%2F0%3Fappid%3D764c87a2b97faf28&amp;amp;supplier=5&amp;amp;from_public_pic=1&quot; data-cropx1=&quot;48.120209059233446&quot; data-cropx2=&quot;946.3641114982578&quot; data-cropy1=&quot;42.77351916376307&quot; data-cropy2=&quot;557.8379790940767&quot; data-ratio=&quot;0.5746102449888641&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jOD3PUUxTibMm6KwZyghlfMDzb9Ylt3NdEb5M9jWWlKpdE1kVVPGBtzWZ4IeibYV0SkYWU82rMYIm1sN6kGqPQVA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;898&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;设计模式就是软件设计中沉淀出的一些代码设计经验，设计模式主要是基于OOP角度来总结的。&lt;/p&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;软件设计原则的目的是 代码复用性、代码可扩展性、代码可维护性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;常见的软件设计原则分为：&lt;strong&gt;单一职责、开闭原则、接口隔离、里式替换、迪米特原则、依赖倒置原则&lt;/strong&gt;。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;单一职责&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;一个类或者方法只有一个职责，只有一个引起它变化的原因。&lt;/p&gt;&lt;p&gt;如果一个类有2个以上的职责，这些职责就耦合在一起了，会导致其中一个变化时，会影响到其他责任。多个职责耦合在一起，会影响代码复用性、对测试不友好。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;开闭原则&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;开闭原则就是说对扩展开放，对修改关闭。&lt;/p&gt;&lt;p&gt;在程序需要进行拓展的时候，尽量不去修改原有的代码，实现一个热插拔的效果。一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，通过实现类达到扩展需求。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;里氏代换原则&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;里氏代换原则(Liskov Substitution Principle LSP)是面向对象设计的基本原则之一。里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;依赖倒置原则&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;所谓依赖倒置原则（Dependence Inversion Principle）就是要&lt;strong&gt;依赖于抽象，不要依赖于具体实现&lt;/strong&gt;。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。&lt;/p&gt;&lt;p&gt;实现开闭原则的关键是抽象化，并且从抽象化导出具体化实现，如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要手段。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;接口隔离原则&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;接口隔离原则(Interface  Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;迪米特法则&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。也就是说一个软件实体应当尽可能少的与其他实体发生相互作用。这样，当一个模块修改时，就会尽量少的影响其他的模块，扩展会相对容易，这是对软件实体之间通信的限制，它要求限制软件实体之间通信的宽度和深度。&lt;/p&gt;&lt;p&gt;日常开发工作中，使用上述设计原则虽然不能保证写出完美的系统，但是可以保证系统实现不会差，基本的扩展性可维护性还是能够满足的。如果有些场景下，不能严格按照软件设计原则来实现，起码的隔离性要求还是要满足的，这样才能保证在后续修改时控制影响面，避免改动牵一发而动全身。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-style-type=&quot;2&quot; data-tools=&quot;新媒体排版&quot; data-id=&quot;8633&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt; 推荐阅读 &lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;figure&gt;&lt;span/&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4351cba9e1249ab71916435664803bdf</guid>
<title>[推荐] Nginx 最全操作总结</title>
<link>https://toutiao.io/k/0lvuhj9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：chrootliu，腾讯 QQ 音乐前端开发工程师&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本文将会从：安装 -&amp;gt; 全局配置 -&amp;gt; 常用的各种配置 来书写，其中常用配置写的炒鸡详细，需要的童鞋可以直接滑倒相应的位置查看。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;安装 nginx&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;下载 nginx 的压缩包文件到根目录，官网下载地址：nginx.org/download/nginx-x.xx.xx.tar.gz&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;yum update &lt;span&gt;#更新系统软件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; /&lt;br/&gt;wget nginx.org/download/nginx-1.17.2.tar.gz&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解压 tar.gz 压缩包文件，进去 nginx-1.17.2&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;tar -xzvf nginx-1.17.2.tar.gz&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; nginx-1.17.2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;进入文件夹后进行配置检查&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;./configure&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;通过安装前的配置检查，发现有报错。检查中发现一些依赖库没有找到，这时候需要先安装 nginx 的一些依赖库&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;yum -y install pcre* &lt;span&gt;#安装使nginx支持rewrite&lt;/span&gt;&lt;br/&gt;yum -y install gcc-c++&lt;br/&gt;yum -y install zlib*&lt;br/&gt;yum -y install openssl openssl-devel&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;再次进行检查操作 ./configure 没发现报错显示，接下来进行编译并安装的操作&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; // 检查模块支持&lt;br/&gt;  ./configure  --prefix=/usr/&lt;span&gt;local&lt;/span&gt;/nginx  --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_addition_module --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_auth_request_module --with-http_random_index_module --with-http_secure_link_module --with-http_degradation_module --with-http_slice_module --with-http_stub_status_module --with-mail --with-mail_ssl_module --with-stream --with-stream_ssl_module --with-stream_realip_module --with-stream_ssl_preread_module --with-threads --user=www --group=www&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里得特别注意下，你以后需要用到的功能模块是否存在，不然以后添加新的包会比较麻烦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;查看默认安装的模块支持&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命令 &lt;code&gt;ls nginx-1.17.2&lt;/code&gt; 查看 nginx 的文件列表，可以发现里面有一个 auto 的目录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个 auto 目录中有一个 options 文件，这个文件里面保存的就是 nginx 编译过程中的所有选项配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过命令：&lt;code&gt;cat nginx-1.17.2/auto/options | grep YES&lt;/code&gt;就可以查看&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://jingyan.baidu.com/article/454316ab354edcf7a7c03a81.html&quot; data-linktype=&quot;2&quot;&gt;nginx 编译安装时，怎么查看安装模块&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;编译并安装&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;make &amp;amp;&amp;amp; make install&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里需要注意，模块的支持跟后续的 nginx 配置有关，比如 SSL，gzip 压缩等等，编译安装前最好检查需要配置的模块存不存在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;查看 nginx 安装后在的目录，可以看到已经安装到 /usr/local/nginx 目录了&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;whereis nginx&lt;br/&gt;&lt;span&gt;$nginx&lt;/span&gt;: /usr/&lt;span&gt;local&lt;/span&gt;/nginx&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;启动 nginx 服务&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;cd&lt;/span&gt; /usr/&lt;span&gt;local&lt;/span&gt;/nginx/sbin/&lt;br/&gt;./nginx&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务启动的时候报错了：&lt;code&gt;nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)&lt;/code&gt; ，通过命令查看本机网络地址和端口等一些信息，找到被占用的 80 端口 &lt;code&gt;netstat -ntpl&lt;/code&gt; 的 tcp 连接，并杀死进程(kill 进程 pid)&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;netstat -ntpl&lt;br/&gt;&lt;span&gt;kill&lt;/span&gt; 进程PID&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续启动 nginx 服务，启动成功&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;./nginx&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在浏览器直接访问 ip 地址，页面出现 Welcome to Nginx! 则安装成功。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;nginx 配置&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基本结构&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;main        # 全局配置，对全局生效&lt;br/&gt;├── events  # 配置影响 nginx 服务器或与用户的网络连接&lt;br/&gt;├── http    # 配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置&lt;br/&gt;│   ├── upstream # 配置后端服务器具体地址，负载均衡配置不可或缺的部分&lt;br/&gt;│   ├── server   # 配置虚拟主机的相关参数，一个 http 块中可以有多个 server 块&lt;br/&gt;│   ├── server&lt;br/&gt;│   │   ├── location  # server 块可以包含多个 location 块，location 指令用于匹配 uri&lt;br/&gt;│   │   ├── location&lt;br/&gt;│   │   └── ...&lt;br/&gt;│   └── ...&lt;br/&gt;└── ...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;主要配置含义&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;main:nginx 的全局配置，对全局生效。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;events:配置影响 nginx 服务器或与用户的网络连接。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;http：可以嵌套多个 server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;server：配置虚拟主机的相关参数，一个 http 中可以有多个 server。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;location：配置请求的路由，以及各种页面的处理情况。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;upstream：配置后端服务器具体地址，负载均衡配置不可或缺的部分。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;nginx.conf 配置文件的语法规则&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;配置文件由指令与指令块构成&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每条指令以 “;” 分号结尾，指令与参数间以空格符号分隔&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;指令块以 {} 大括号将多条指令组织在一起&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;include 语句允许组合多个配置文件以提升可维护性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 # 符号添加注释，提高可读性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 $ 符号使用变量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;部分指令的参数支持正则表达式，例如常用的 location 指令&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;内置变量&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nginx 常用的内置全局变量，你可以在配置中随意使用：&lt;img data-ratio=&quot;0.6285362853628537&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauLdHRFreUAZ7U9Bz4XsHwXCXwgNAhHxPKRibPGxTxtaMqNjeOaot8jEqwDYjyGD5VojZLYIApEMEw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1626&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;常用命令&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里列举几个常用的命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;nginx -s reload  # 向主进程发送信号，重新加载配置文件，热重启&lt;br/&gt;nginx -s reopen  # 重启 Nginx&lt;br/&gt;nginx -s stop    # 快速关闭&lt;br/&gt;nginx -s quit    # 等待工作进程处理完成后关闭&lt;br/&gt;nginx -T         # 查看当前 Nginx 最终的配置&lt;br/&gt;nginx -t -c &amp;lt;配置路径&amp;gt;  # 检查配置是否有问题，如果已经在配置目录，则不需要 -c&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上命令通过 &lt;code&gt;nginx -h&lt;/code&gt; 就可以查看到，还有其它不常用这里未列出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 系统应用管理工具 systemd 关于 nginx 的常用命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;systemctl start nginx    # 启动 Nginx&lt;br/&gt;systemctl stop nginx     # 停止 Nginx&lt;br/&gt;systemctl restart nginx  # 重启 Nginx&lt;br/&gt;systemctl reload nginx   # 重新加载 Nginx，用于修改配置后&lt;br/&gt;systemctl enable nginx   # 设置开机启动 Nginx&lt;br/&gt;systemctl disable nginx  # 关闭开机启动 Nginx&lt;br/&gt;systemctl status nginx   # 查看 Nginx 运行状态&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;配置 nginx 开机自启&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;利用 systemctl 命令&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用 yum install 命令安装的 nginx，yum 命令会自动创建 nginx.service 文件，直接用命令:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;systemctl &lt;span&gt;enable&lt;/span&gt; nginx   &lt;span&gt;# 设置开机启动 Nginx&lt;/span&gt;&lt;br/&gt;systemctl &lt;span&gt;disable&lt;/span&gt; nginx  &lt;span&gt;# 关闭开机启动 Nginx&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就可以设置开机自启，否则需要在系统服务目录里创建 nginx.service 文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建并打开 nginx.service 文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;vi /lib/systemd/system/nginx.service&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内容如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[Unit]&lt;br/&gt;Description=nginx&lt;br/&gt;After=network.target&lt;br/&gt;&lt;br/&gt;[Service]&lt;br/&gt;Type=forking&lt;br/&gt;ExecStart=/usr/local/nginx/sbin/nginx&lt;br/&gt;ExecReload=/usr/local/nginx/sbin/nginx -s reload&lt;br/&gt;ExecStop=/usr/local/nginx/sbin/nginx -s quit&lt;br/&gt;PrivateTmp=true&lt;br/&gt;&lt;br/&gt;[Install]&lt;br/&gt;WantedBy=multi-user.target&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;:wq&lt;/code&gt; 保存退出，运行 &lt;code&gt;systemctl daemon-reload&lt;/code&gt; 使文件生效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样便可以通过以下命令操作 nginx 了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;systemctl start nginx.service # 启动nginx服务&lt;br/&gt;systemctl enable nginx.service # 设置开机启动&lt;br/&gt;systemctl disable nginx.service # 停止开机自启动&lt;br/&gt;systemctl status nginx.service # 查看服务当前状态&lt;br/&gt;systemctl restart nginx.service # 重新启动服务&lt;br/&gt;systemctl is-enabled nginx.service #查询服务是否开机启动&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;通过开机启动命令脚本实现开机自启&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建开机启动命令脚本文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;vi /etc/init.d/nginx&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个 nginx 文件中插入一下启动脚本代码，启动脚本代码来源网络复制，实测有效：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#! /bin/bash&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# chkconfig: - 85 15&lt;/span&gt;&lt;br/&gt;PATH=/usr/&lt;span&gt;local&lt;/span&gt;/nginx&lt;br/&gt;DESC=&lt;span&gt;&quot;nginx daemon&quot;&lt;/span&gt;&lt;br/&gt;NAME=nginx&lt;br/&gt;DAEMON=&lt;span&gt;$PATH&lt;/span&gt;/sbin/&lt;span&gt;$NAME&lt;/span&gt;&lt;br/&gt;CONFIGFILE=&lt;span&gt;$PATH&lt;/span&gt;/conf/&lt;span&gt;$NAME&lt;/span&gt;.conf&lt;br/&gt;PIDFILE=&lt;span&gt;$PATH&lt;/span&gt;/logs/&lt;span&gt;$NAME&lt;/span&gt;.pid&lt;br/&gt;scriptNAME=/etc/init.d/&lt;span&gt;$NAME&lt;/span&gt;&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; -e&lt;br/&gt;[ -x &lt;span&gt;&quot;&lt;span&gt;$DAEMON&lt;/span&gt;&quot;&lt;/span&gt; ] || &lt;span&gt;exit&lt;/span&gt; 0&lt;br/&gt;&lt;span&gt;&lt;span&gt;do_start&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;&lt;span&gt;$DAEMON&lt;/span&gt; -c &lt;span&gt;$CONFIGFILE&lt;/span&gt; || &lt;span&gt;echo&lt;/span&gt; -n &lt;span&gt;&quot;nginx already running&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;do_stop&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;&lt;span&gt;$DAEMON&lt;/span&gt; -s stop || &lt;span&gt;echo&lt;/span&gt; -n &lt;span&gt;&quot;nginx not running&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;do_reload&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;&lt;span&gt;$DAEMON&lt;/span&gt; -s reload || &lt;span&gt;echo&lt;/span&gt; -n &lt;span&gt;&quot;nginx can&#x27;t reload&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;span&gt;$1&lt;/span&gt;&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;br/&gt;start)&lt;br/&gt;&lt;span&gt;echo&lt;/span&gt; -n &lt;span&gt;&quot;Starting &lt;span&gt;$DESC&lt;/span&gt;: &lt;span&gt;$NAME&lt;/span&gt;&quot;&lt;/span&gt;&lt;br/&gt;do_start&lt;br/&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;.&quot;&lt;/span&gt;&lt;br/&gt;;;&lt;br/&gt;stop)&lt;br/&gt;&lt;span&gt;echo&lt;/span&gt; -n &lt;span&gt;&quot;Stopping &lt;span&gt;$DESC&lt;/span&gt;: &lt;span&gt;$NAME&lt;/span&gt;&quot;&lt;/span&gt;&lt;br/&gt;do_stop&lt;br/&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;.&quot;&lt;/span&gt;&lt;br/&gt;;;&lt;br/&gt;reload|graceful)&lt;br/&gt;&lt;span&gt;echo&lt;/span&gt; -n &lt;span&gt;&quot;Reloading &lt;span&gt;$DESC&lt;/span&gt; configuration...&quot;&lt;/span&gt;&lt;br/&gt;do_reload&lt;br/&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;.&quot;&lt;/span&gt;&lt;br/&gt;;;&lt;br/&gt;restart)&lt;br/&gt;&lt;span&gt;echo&lt;/span&gt; -n &lt;span&gt;&quot;Restarting &lt;span&gt;$DESC&lt;/span&gt;: &lt;span&gt;$NAME&lt;/span&gt;&quot;&lt;/span&gt;&lt;br/&gt;do_stop&lt;br/&gt;do_start&lt;br/&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;.&quot;&lt;/span&gt;&lt;br/&gt;;;&lt;br/&gt;*)&lt;br/&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;Usage: &lt;span&gt;$scriptNAME&lt;/span&gt; {start|stop|reload|restart}&quot;&lt;/span&gt; &amp;gt;&amp;amp;2&lt;br/&gt;&lt;span&gt;exit&lt;/span&gt; 3&lt;br/&gt;;;&lt;br/&gt;&lt;span&gt;esac&lt;/span&gt;&lt;br/&gt;&lt;span&gt;exit&lt;/span&gt; 0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置所有人都有对这个启动脚本 nginx 文件的执行权限：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;chmod a+x /etc/init.d/nginx&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把 nginx 加入系统服务中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;chkconfig --add nginx&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把服务设置为开机启动：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;chkconfig nginx on&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;reboot 重启系统生效，可以使用上面 systemctl 方法相同的命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;systemctl start nginx.service &lt;span&gt;# 启动nginx服务&lt;/span&gt;&lt;br/&gt;systemctl &lt;span&gt;enable&lt;/span&gt; nginx.service &lt;span&gt;# 设置开机启动&lt;/span&gt;&lt;br/&gt;systemctl &lt;span&gt;disable&lt;/span&gt; nginx.service &lt;span&gt;# 停止开机自启动&lt;/span&gt;&lt;br/&gt;systemctl status nginx.service &lt;span&gt;# 查看服务当前状态&lt;/span&gt;&lt;br/&gt;systemctl restart nginx.service &lt;span&gt;# 重新启动服务&lt;/span&gt;&lt;br/&gt;systemctl is-enabled nginx.service &lt;span&gt;#查询服务是否开机启动&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果服务启动的时候出现 &lt;code&gt;Restarting nginx daemon: nginxnginx: [error] open() &quot;/usr/local/nginx/logs/nginx.pid&quot; failed (2: No such file or directory) nginx not running&lt;/code&gt; 的错误，通过 nginx -c 参数指定配置文件即可解决&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/usr/&lt;span&gt;local&lt;/span&gt;/nginx/sbin/nginx -c /usr/&lt;span&gt;local&lt;/span&gt;/nginx/conf/nginx.conf&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果服务启动中出现 &lt;code&gt;nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)&lt;/code&gt; 的错误，可以先通过 &lt;code&gt;service nginx stop&lt;/code&gt; 停止服务，再启动就好。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;配置 nginx 全局可用&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你每次改了 &lt;code&gt;nginx.conf&lt;/code&gt; 配置文件的内容都需要重新到 nginx 启动目录去执行命令，或者通过 -p 参数指向特定目录，会不会感觉很麻烦？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：直接执行 &lt;code&gt;nginx -s reload&lt;/code&gt; 会报错 &lt;code&gt;-bash: nginx: command not found&lt;/code&gt;，需要到 &lt;code&gt;/usr/local/nginx/sbin&lt;/code&gt; 目录下面去执行，并且是执行 &lt;code&gt;./nginx -s reload&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有两种方式可以解决，一种是通过脚本对 nginx 命令包装，这里介绍另外一种比较简单：通过把 nginx 配置到环境变量里，用 nginx 执行指令即可。步骤如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、编辑 /etc/profile&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;vi /etc/profile&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、在最后一行添加配置，:wq 保存&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;export PATH=$PATH:/usr/local/nginx/sbin&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、使配置立即生效&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;source /etc/profile&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就可以愉快的直接在全局使用 nginx 命令了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;nginx 常用功能&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;反向代理&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们最常说的反向代理的是通过反向代理解决跨域问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实反向代理还可以用来控制缓存（代理缓存 proxy cache），进行访问控制等等，以及后面说的负载均衡其实都是通过反向代理来实现的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server {&lt;br/&gt;    listen    8080;&lt;br/&gt;        # 用户访问 ip:8080/test 下的所有路径代理到 github&lt;br/&gt;        location /test {&lt;br/&gt;         proxy_pass   https://github.com;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        # 所有 /api 下的接口访问都代理到本地的 8888 端口&lt;br/&gt;        # 例如你本地运行的 java 服务的端口是 8888，接口都是以 /api 开头&lt;br/&gt;        location /api {&lt;br/&gt;            proxy_pass   http://127.0.0.1:8888;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;访问控制&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server {&lt;br/&gt;   location ~ ^/index.html {&lt;br/&gt;       # 匹配 index.html 页面 除了 127.0.0.1 以外都可以访问&lt;br/&gt;       deny 192.168.1.1;&lt;br/&gt;       deny 192.168.1.2;&lt;br/&gt;       allow all;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的命令表示禁止 192.168.1.1 和 192.168.1.2 两个 ip 访问，其它全部允许。从上到下的顺序，匹配到了便跳出，可以按你的需求设置。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;负载均衡&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过负载均衡充利用服务器资源，nginx 目前支持自带 4 种负载均衡策略，还有 2 种常用的第三方策略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;轮询策略（默认）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个请求按时间顺序逐一分配到不同的后端服务器，如果有后端服务器挂掉，能自动剔除。但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;http {&lt;br/&gt;    upstream test.com {&lt;br/&gt;        server 192.168.1.12:8887;&lt;br/&gt;        server 192.168.1.13:8888;&lt;br/&gt;    }&lt;br/&gt;    server {&lt;br/&gt;        location /api {&lt;br/&gt;            proxy_pass  http://test.com;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;根据服务器权重&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如要配置：10 次请求中大概 1 次访问到 8888 端口，9 次访问到 8887 端口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;http {&lt;br/&gt;    upstream test.com {&lt;br/&gt;        server 192.168.1.12:8887 weight=9;&lt;br/&gt;        server 192.168.1.13:8888 weight=1;&lt;br/&gt;    }&lt;br/&gt;    server {&lt;br/&gt;        location /api {&lt;br/&gt;            proxy_pass  http://test.com;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;客户端 ip 绑定（ip_hash）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来自同一个 ip 的请求永远只分配一台服务器，有效解决了动态网页存在的 session 共享问题。例如：比如把登录信息保存到了 session 中，那么跳转到另外一台服务器的时候就需要重新登录了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以很多时候我们需要一个客户只访问一个服务器，那么就需要用 ip_hash 了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;http {&lt;br/&gt;    upstream test.com {&lt;br/&gt;     ip_hash;&lt;br/&gt;        server 192.168.1.12:8887;&lt;br/&gt;        server 192.168.1.13:8888;&lt;br/&gt;    }&lt;br/&gt;    server {&lt;br/&gt;        location /api {&lt;br/&gt;            proxy_pass  http://test.com;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最小连接数策略&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;http {&lt;br/&gt;    upstream test.com {&lt;br/&gt;     least_conn;&lt;br/&gt;        server 192.168.1.12:8887;&lt;br/&gt;        server 192.168.1.13:8888;&lt;br/&gt;    }&lt;br/&gt;    server {&lt;br/&gt;        location /api {&lt;br/&gt;            proxy_pass  http://test.com;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最快响应时间策略（依赖于第三方 NGINX Plus）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;依赖于 NGINX Plus，优先分配给响应时间最短的服务器。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;http {&lt;br/&gt;    upstream test.com {&lt;br/&gt;     fair;&lt;br/&gt;        server 192.168.1.12:8887;&lt;br/&gt;        server 192.168.1.13:8888;&lt;br/&gt;    }&lt;br/&gt;    server {&lt;br/&gt;        location /api {&lt;br/&gt;            proxy_pass  http://test.com;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;按访问 url 的 hash 结果（第三方）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按访问 url 的 hash 结果来分配请求，使每个 url 定向到同一个后端服务器，后端服务器为缓存时比较有效。在 upstream 中加入 hash 语句，server 语句中不能写入 weight 等其他的参数，hash_method 是使用的 hash 算法&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;http {&lt;br/&gt;    upstream test.com {&lt;br/&gt;     hash $request_uri;&lt;br/&gt;     hash_method crc32;&lt;br/&gt;     server 192.168.1.12:8887;&lt;br/&gt;     server 192.168.1.13:8888;&lt;br/&gt;    }&lt;br/&gt;    server {&lt;br/&gt;        location /api {&lt;br/&gt;            proxy_pass  http://test.com;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采用 HAproxy 的 loadbalance uri 或者 nginx 的 upstream_hash 模块，都可以做到针对 url 进行哈希算法式的负载均衡转发。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;gzip 压缩&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开启 gzip 压缩可以大幅减少 http 传输过程中文件的大小，可以极大的提高网站的访问速度，基本是必不可少的优化操作：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;gzip  on; # 开启gzip 压缩&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; gzip_types&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; gzip_static on;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; gzip_proxied expired no-cache no-store private auth;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; gzip_buffers 16 8k;&lt;/span&gt;&lt;br/&gt;gzip_min_length 1k;&lt;br/&gt;gzip_comp_level 4;&lt;br/&gt;gzip_http_version 1.0;&lt;br/&gt;gzip_vary off;&lt;br/&gt;gzip_disable &quot;MSIE [1-6]\.&quot;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解释一下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;gzip_types：要采用 gzip 压缩的 MIME 文件类型，其中 text/html 被系统强制启用；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gzip_static：默认 off，该模块启用后，Nginx 首先检查是否存在请求静态文件的 gz 结尾的文件，如果有则直接返回该 .gz 文件内容；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gzip_proxied：默认 off，nginx 做为反向代理时启用，用于设置启用或禁用从代理服务器上收到相应内容 gzip 压缩；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gzip_buffers：获取多少内存用于缓存压缩结果，16 8k 表示以 8k*16 为单位获得；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gzip_min_length：允许压缩的页面最小字节数，页面字节数从 header 头中的 Content-Length 中进行获取。默认值是 0，不管页面多大都压缩。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gzip_comp_level：gzip 压缩比，压缩级别是 1-9，1 压缩级别最低，9 最高，级别越高压缩率越大，压缩时间越长，建议 4-6；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gzip_http_version：默认 1.1，启用 gzip 所需的 HTTP 最低版本；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gzip_vary：用于在响应消息头中添加 Vary：Accept-Encoding，使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gzip_disable 指定哪些不需要 gzip 压缩的浏览器&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中第 2 点，普遍是结合前端打包的时候打包成 gzip 文件后部署到服务器上，这样服务器就可以直接使用 gzip 的文件了，并且可以把压缩比例提高，这样 nginx 就不用压缩，也就不会影响速度。一般不追求极致的情况下，前端不用做任何配置就可以使用啦~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;附前端 webpack 开启 gzip 压缩配置，在 vue-cli3 的 vue.config.js 配置文件中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; CompressionWebpackPlugin = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;compression-webpack-plugin&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;  &lt;span&gt;// gzip 配置&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;configureWebpack&lt;/span&gt;: &lt;span&gt;&lt;span&gt;config&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV === &lt;span&gt;&#x27;production&#x27;&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;// 生产环境&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;plugins&lt;/span&gt;: [&lt;span&gt;new&lt;/span&gt; CompressionWebpackPlugin({&lt;br/&gt;          &lt;span&gt;test&lt;/span&gt;: &lt;span&gt;/\.js$|\.html$|\.css/&lt;/span&gt;,    &lt;span&gt;// 匹配文件名&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;threshold&lt;/span&gt;: &lt;span&gt;1024&lt;/span&gt;,               &lt;span&gt;// 文件压缩阈值，对超过 1k 的进行压缩&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;deleteOriginalAssets&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;     &lt;span&gt;// 是否删除源文件&lt;/span&gt;&lt;br/&gt;        })]&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  },&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;HTTP 服务器&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nginx 本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用 nginx 来做服务器：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server {&lt;br/&gt;  listen       80;&lt;br/&gt;  server_name  localhost;&lt;br/&gt;&lt;br/&gt;  location / {&lt;br/&gt;      root   /usr/local/app;&lt;br/&gt;      index  index.html;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样如果访问 http://ip 就会默认访问到 /usr/local/app 目录下面的 index.html，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署，比如一个静态官网。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;动静分离&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是把动态和静态的请求分开。方式主要有两种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一种方法就是动态跟静态文件混合在一起发布， 通过 nginx 配置来分开&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 所有静态请求都由nginx处理，存放目录为 html&lt;/span&gt;&lt;br/&gt;location ~ \.(gif|jpg|jpeg|png|bmp|swf|css|js)$ {&lt;br/&gt;    root    /usr/&lt;span&gt;local&lt;/span&gt;/resource;&lt;br/&gt;    expires     10h; &lt;span&gt;# 设置过期时间为10小时&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 所有动态请求都转发给 tomcat 处理&lt;/span&gt;&lt;br/&gt;location ~ \.(jsp|&lt;span&gt;do&lt;/span&gt;)$ {&lt;br/&gt;    proxy_pass  127.0.0.1:8888;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意上面设置了 expires，当 nginx 设置了 expires 后，例如设置为：expires 10d; 那么，所在的 location 或 if 的内容，用户在 10 天内请求的时候，都只会访问浏览器中的缓存，而不会去请求 nginx 。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;请求限制&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于大流量恶意的访问，会造成带宽的浪费，给服务器增加压力。可以通过 nginx 对于同一 IP 的连接数以及并发数进行限制。合理的控制还可以用来防止 DDos 和 CC 攻击。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于请求限制主要使用 nginx 默认集成的 2 个模块：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;limit_conn_module 连接频率限制模块&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;limit_req_module 请求频率限制模块&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;涉及到的配置主要是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;limit_req_zone 限制请求数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;limit_conn_zone 限制并发连接数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;通过 limit_req_zone 限制请求数&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;http{&lt;br/&gt;    limit_conn_zone $binary_remote_addrzone=limit:10m; // 设置共享内存空间大&lt;br/&gt;    server{&lt;br/&gt;     location /{&lt;br/&gt;            limit_conn addr 5; # 同一用户地址同一时间只允许有5个连接。&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果共享内存空间被耗尽，服务器将会对后续所有的请求返回 503 (Service Temporarily Unavailable) 错误。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当多个 limit_conn_zone 指令被配置时，所有的连接数限制都会生效。比如，下面配置不仅会限制单一 IP 来源的连接数，同时也会限制单一虚拟服务器的总连接数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;limit_conn_zone $binary_remote_addr zone=perip:10m;&lt;br/&gt;limit_conn_zone $server_name zone=perserver:10m;&lt;br/&gt;server {&lt;br/&gt;    limit_conn perip 10; # 限制每个 ip 连接到服务器的数量&lt;br/&gt;    limit_conn perserver 2000; # 限制连接到服务器的总数&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;通过 limit_conn_zone 限制并发连接数&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;limit_req_zone $binary_remote_addr zone=creq:10 mrate=10r/s;&lt;br/&gt;server{&lt;br/&gt;    location /{&lt;br/&gt;        limit_req zone=creq burst=5;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;限制平均每秒不超过一个请求，同时允许超过频率限制的请求数不多于 5 个。如果不希望超过的请求被延迟，可以用 nodelay 参数,如：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;limit_req zone=creq burst=5 nodelay;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里只是简单讲讲，让大家有这个概念，配置的时候可以深入去找找资料。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;正向代理&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理，比如我们使用的 VPN 服务就是正向代理，直观区别：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0109409190371992&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauLdHRFreUAZ7U9Bz4XsHwXNDBe3m58FdgMKvWrqiaribzgPicia1GfpaB7q8D8p5jU7yOjT5t5Fx3Edw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;914&quot;/&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置正向代理：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;resolver 8.8.8.8 # 谷歌的域名解析地址&lt;br/&gt;server {&lt;br/&gt;    resolver_timeout 5s; // 设超时时间&lt;br/&gt;    location / {&lt;br/&gt;        # 当客户端请求我的时候，我会把请求转发给它&lt;br/&gt;        # $host 要访问的主机名 $request_uri 请求路径&lt;br/&gt;        proxy_pass http://$host$request_uri;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正向代理的对象是客户端，服务器端看不到真正的客户端。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;图片防盗链&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server {&lt;br/&gt;    listen       80;&lt;br/&gt;    server_name  *.test;&lt;br/&gt;&lt;br/&gt;    # 图片防盗链&lt;br/&gt;    location ~* \.(gif|jpg|jpeg|png|bmp|swf)$ {&lt;br/&gt;        valid_referers none blocked server_names ~\.google\. ~\.baidu\. *.qq.com;  # 只允许本机 IP 外链引用，将百度和谷歌也加入白名单有利于 SEO&lt;br/&gt;        if ($invalid_referer){&lt;br/&gt;            return 403;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上设置就能防止其它网站利用外链访问我们的图片，有利于节省流量&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;适配 PC 或移动设备&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据用户设备不同返回不同样式的站点，以前经常使用的是纯前端的自适应布局，但是复杂的网站并不适合响应式，无论是复杂性和易用性上面还是不如分开编写的好，比如我们常见的淘宝、京东。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据用户请求的 user-agent 来判断是返回 PC 还是 H5 站点：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server {&lt;br/&gt;    listen 80;&lt;br/&gt;    server_name test.com;&lt;br/&gt;&lt;br/&gt;    location / {&lt;br/&gt;     root  /usr/local/app/pc; # pc 的 html 路径&lt;br/&gt;        if ($http_user_agent ~* &#x27;(Android|webOS|iPhone|iPod|BlackBerry)&#x27;) {&lt;br/&gt;            root /usr/local/app/mobile; # mobile 的 html 路径&lt;br/&gt;        }&lt;br/&gt;        index index.html;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;设置二级域名&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新建一个 server 即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server {&lt;br/&gt;    listen 80;&lt;br/&gt;    server_name admin.test.com; // 二级域名&lt;br/&gt;&lt;br/&gt;    location / {&lt;br/&gt;        root  /usr/local/app/admin; # 二级域名的 html 路径&lt;br/&gt;        index index.html;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;配置 HTTPS&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我使用的是 certbot 免费证书，但申请一次有效期只有 3 个月（好像可以用 crontab 尝试配置自动续期，我暂时没试过）：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先安装 certbot&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;wget https://dl.eff.org/certbot-auto&lt;br/&gt;chmod a+x certbot-auto&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;申请证书（注意：需要把要申请证书的域名先解析到这台服务器上，才能申请）:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;sudo ./certbot-auto certonly --standalone --email admin@abc.com -d test.com -d www.test.com&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行上面指令，按提示操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Certbot 会启动一个临时服务器来完成验证（会占用 80 端口或 443 端口，因此需要暂时关闭 Web 服务器），然后 Certbot 会把证书以文件的形式保存，包括完整的证书链文件和私钥文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文件保存在 /etc/letsencrypt/live/ 下面的域名目录下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改 nginx 配置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server{&lt;br/&gt;    listen 443 ssl http2; // 这里还启用了 http/2.0&lt;br/&gt;&lt;br/&gt;    ssl_certificate /etc/letsencrypt/live/test.com/fullchain.pem; # 证书文件地址&lt;br/&gt;    ssl_certificate_key /etc/letsencrypt/live/test.com/privkey.pem; # 私钥文件地址&lt;br/&gt;&lt;br/&gt;    server_name test.com www.test.com; // 证书绑定的域名&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;配置 HTTP 转 HTTPS&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server {&lt;br/&gt;    listen      80;&lt;br/&gt;    server_name test.com www.test.com;&lt;br/&gt;&lt;br/&gt;    # 单域名重定向&lt;br/&gt;    if ($host = &#x27;www.sherlocked93.club&#x27;){&lt;br/&gt;        return 301 https://www.sherlocked93.club$request_uri;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    # 全局非 https 协议时重定向&lt;br/&gt;    if ($scheme != &#x27;https&#x27;) {&lt;br/&gt;        return 301 https://$server_name$request_uri;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    # 或者全部重定向&lt;br/&gt;    return 301 https://$server_name$request_uri;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上配置选择自己需要的一条即可，不用全部加。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;单页面项目 history 路由配置&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server {&lt;br/&gt;    listen       80;&lt;br/&gt;    server_name  fe.sherlocked93.club;&lt;br/&gt;&lt;br/&gt;    location / {&lt;br/&gt;        root       /usr/local/app/dist;  # vue 打包后的文件夹&lt;br/&gt;        index      index.html index.htm;&lt;br/&gt;        try_files  $uri $uri/ /index.html @rewrites; # 默认目录下的 index.html，如果都不存在则重定向&lt;br/&gt;&lt;br/&gt;        expires -1;                          # 首页一般没有强制缓存&lt;br/&gt;        add_header Cache-Control no-cache;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    location @rewrites { // 重定向设置&lt;br/&gt;        rewrite ^(.+)$ /index.html break;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90&quot; data-linktype=&quot;2&quot;&gt;vue-router&lt;/a&gt; 官网只有一句话 &lt;code&gt;try_files $uri $uri/ /index.html;&lt;/code&gt;，而上面做了一些重定向处理。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;配置高可用集群（双机热备）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当主 nginx 服务器宕机之后，切换到备份的 nginx 服务器&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先安装 keepalived:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;yum install keepalived -y&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后编辑 &lt;code&gt;/etc/keepalived/keepalived.conf&lt;/code&gt; 配置文件，并在配置文件中增加 &lt;code&gt;vrrp_script&lt;/code&gt; 定义一个外围检测机制，并在 &lt;code&gt;vrrp_instance&lt;/code&gt; 中通过定义 &lt;code&gt;track_script&lt;/code&gt; 来追踪脚本执行过程，实现节点转移：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;global_defs{&lt;br/&gt;   notification_email {&lt;br/&gt;        cchroot@gmail.com&lt;br/&gt;   }&lt;br/&gt;   notification_email_from test@firewall.loc&lt;br/&gt;   smtp_server 127.0.0.1&lt;br/&gt;   smtp_connect_timeout 30 // 上面都是邮件配置&lt;br/&gt;   router_id LVS_DEVEL     // 当前服务器名字，用 hostname 命令来查看&lt;br/&gt;}&lt;br/&gt;vrrp_script chk_maintainace { // 检测机制的脚本名称为chk_maintainace&lt;br/&gt;    script &quot;[[ -e/etc/keepalived/down ]] &amp;amp;&amp;amp; exit 1 || exit 0&quot; // 可以是脚本路径或脚本命令&lt;br/&gt;    // script &quot;/etc/keepalived/nginx_check.sh&quot;    // 比如这样的脚本路径&lt;br/&gt;    interval 2  // 每隔2秒检测一次&lt;br/&gt;    weight -20  // 当脚本执行成立，那么把当前服务器优先级改为-20&lt;br/&gt;}&lt;br/&gt;vrrp_instanceVI_1 {   // 每一个vrrp_instance就是定义一个虚拟路由器&lt;br/&gt;    state MASTER      // 主机为MASTER，备用机为BACKUP&lt;br/&gt;    interface eth0    // 网卡名字，可以从ifconfig中查找&lt;br/&gt;    virtual_router_id 51 // 虚拟路由的id号，一般小于255，主备机id需要一样&lt;br/&gt;    priority 100      // 优先级，master的优先级比backup的大&lt;br/&gt;    advert_int 1      // 默认心跳间隔&lt;br/&gt;    authentication {  // 认证机制&lt;br/&gt;        auth_type PASS&lt;br/&gt;        auth_pass 1111   // 密码&lt;br/&gt;    }&lt;br/&gt;    virtual_ipaddress {  // 虚拟地址vip&lt;br/&gt;       172.16.2.8&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中检测脚本 &lt;code&gt;nginx_check.sh&lt;/code&gt;，这里提供一个：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/bin/bash&lt;/span&gt;&lt;br/&gt;A=`ps -C nginx --no-header | wc -l`&lt;br/&gt;if [ $A -eq 0 ];then&lt;br/&gt;    /usr/sbin/nginx # 尝试重新启动nginx&lt;br/&gt;    sleep 2         # 睡眠2秒&lt;br/&gt;    if [ `ps -C nginx --no-header | wc -l` -eq 0 ];then&lt;br/&gt;        killall keepalived # 启动失败，将keepalived服务杀死。将vip漂移到其它备份节点&lt;br/&gt;    fi&lt;br/&gt;fi&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;复制一份到备份服务器，备份 nginx 的配置要将 &lt;code&gt;state&lt;/code&gt; 后改为 &lt;code&gt;BACKUP&lt;/code&gt;，&lt;code&gt;priority&lt;/code&gt; 改为比主机小。设置完毕后各自 &lt;code&gt;service keepalived start&lt;/code&gt; 启动，经过访问成功之后，可以把 Master 机的 keepalived 停掉，此时 Master 机就不再是主机了 &lt;code&gt;service keepalived stop&lt;/code&gt;，看访问虚拟 IP 时是否能够自动切换到备机 ip addr。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再次启动 Master 的 keepalived，此时 vip 又变到了主机上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置高可用集群的内容来源于：&lt;a href=&quot;https://juejin.im/post/6844904144235413512#heading-11&quot; data-linktype=&quot;2&quot;&gt;Nginx 从入门到实践，万字详解！&lt;/a&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;其它功能和技巧&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代理缓存&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nginx 的 http_proxy 模块，提供类似于 Squid 的缓存功能，使用 proxy_cache_path 来配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nginx 可以对访问过的内容在 nginx 服务器本地建立副本，这样在一段时间内再次访问该数据，就不需要通过 nginx 服务器再次向后端服务器发出请求，减小数据传输延迟，提高访问速度：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;proxy_cache_path usr/&lt;span&gt;local&lt;/span&gt;/cache levels=1:2 keys_zone=my_cache:10m;&lt;br/&gt;&lt;br/&gt;server {&lt;br/&gt;  listen       80;&lt;br/&gt;  server_name  test.com;&lt;br/&gt;&lt;br/&gt;  location / {&lt;br/&gt;      proxy_cache my_cache;&lt;br/&gt;      proxy_pass http://127.0.0.1:8888;&lt;br/&gt;      proxy_set_header Host &lt;span&gt;$host&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的配置表示：nginx 提供一块 10 M 的内存用于缓存，名字为 my_cache, levels 等级为 1:2，缓存存放的路径为 &lt;code&gt;usr/local/cache&lt;/code&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;访问日志&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;访问日志默认是注释的状态，需要可以打开和进行更详细的配置，一下是 nginx 的默认配置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;http {&lt;br/&gt;    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;&lt;br/&gt;                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;&lt;br/&gt;                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;&lt;br/&gt;&lt;br/&gt;    access_log  logs/access.log  main;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;错误日志&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;错误日志放在 main 全局区块中，童鞋们打开 nginx.conf 就可以看见在配置文件中和下面一样的代码了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;error_log  logs/error.log;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;error_log  logs/error.log  notice;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;error_log  logs/error.log  info;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nginx 错误日志默认配置为：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;error_log logs/error.log error;&lt;/code&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;静态资源服务器&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server {&lt;br/&gt;    listen       80;&lt;br/&gt;    server_name  static.bin;&lt;br/&gt;    charset utf-8;    &lt;span&gt;# 防止中文文件名乱码&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    location /download {&lt;br/&gt;        &lt;span&gt;alias&lt;/span&gt;           /usr/share/nginx/static;  &lt;span&gt;# 静态资源目录&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        autoindex               on;    &lt;span&gt;# 开启静态资源列目录，浏览目录权限&lt;/span&gt;&lt;br/&gt;        autoindex_exact_size    off;   &lt;span&gt;# on(默认)显示文件的确切大小，单位是byte；off显示文件大概大小，单位KB、MB、GB&lt;/span&gt;&lt;br/&gt;        autoindex_localtime     off;   &lt;span&gt;# off(默认)时显示的文件时间为GMT时间；on显示的文件时间为服务器时间&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;禁止指定 user_agent&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nginx 可以禁止指定的浏览器和爬虫框架访问：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; http_user_agent 为浏览器标识&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 禁止 user_agent 为baidu、360和sohu，~*表示不区分大小写匹配&lt;/span&gt;&lt;br/&gt;if ($http_user_agent ~* &#x27;baidu|360|sohu&#x27;) {&lt;br/&gt;    return 404;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt; 禁止 Scrapy 等工具的抓取&lt;/span&gt;&lt;br/&gt;if ($http_user_agent ~* (Scrapy|Curl|HttpClient)) {&lt;br/&gt;    return 403;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;请求过滤&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;根据请求类型过滤&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 非指定请求全返回 403&lt;/span&gt;&lt;br/&gt;if ( $request_method !~ ^(GET|POST|HEAD)$ ) {&lt;br/&gt;    return 403;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;根据状态码过滤&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;error_page 502 503 /50x.html;&lt;br/&gt;location = /50x.html {&lt;br/&gt;    root /usr/share/nginx/html;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样实际上是一个内部跳转，当访问出现 502、503 的时候就能返回 50x.html 中的内容，这里需要注意是否可以找到 50x.html 页面，所以加了个 location 保证找到你自定义的 50x 页面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;根据 URL 名称过滤&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;if ($host = zy.com&#x27; ) {&lt;br/&gt;     #其中 $1是取自regex部分()里的内容,匹配成功后跳转到的URL。&lt;br/&gt;     rewrite ^/(.*)$  http://www.zy.com/$1  permanent；&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;location /test {&lt;br/&gt;    // /test 全部重定向到首页&lt;br/&gt;    rewrite  ^(.*)$ /index.html  redirect;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ab 命令&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ab 命令全称为：Apache bench，是 Apache 自带的压力测试工具，也可以测试 Nginx、IIS 等其他 Web 服务器:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;-n 总共的请求数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-c 并发的请求数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-t 测试所进行的最大秒数，默认值 为 50000&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-p 包含了需要的 POST 的数据文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-T POST 数据所使用的 Content-type 头信息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ab -n 1000 -c 5000 http://127.0.0.1/ # 每次发送1000并发的请求数，请求数总数为5000。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试前需要安装 httpd-tools：&lt;code&gt;yum install httpd-tools&lt;/code&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;泛域名路径分离&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个非常实用的技能，经常有时候我们可能需要配置一些二级或者三级域名，希望通过 nginx 自动指向对应目录，比如：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;test1.doc.test.club 自动指向 /usr/local/html/doc/test1 服务器地址；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;test2.doc.test.club 自动指向 /usr/local/html/doc/test2 服务器地址；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server {&lt;br/&gt;    listen       80;&lt;br/&gt;    server_name  ~^([\w-]+)\.doc\.test\.club$;&lt;br/&gt;&lt;br/&gt;    root /usr/local/html/doc/$1;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;泛域名转发&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和之前的功能类似，有时候我们希望把二级或者三级域名链接重写到我们希望的路径，让后端就可以根据路由解析不同的规则：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;test1.serv.test.club/api?name=a 自动转发到 127.0.0.1:8080/test1/api?name=a&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;test2.serv.test.club/api?name=a 自动转发到 127.0.0.1:8080/test2/api?name=a&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server {&lt;br/&gt;    listen       80;&lt;br/&gt;    server_name ~^([\w-]+)\.serv\.test\.club$;&lt;br/&gt;&lt;br/&gt;    location / {&lt;br/&gt;        proxy_set_header        X-Real-IP $remote_addr;&lt;br/&gt;        proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;&lt;br/&gt;        proxy_set_header        Host $http_host;&lt;br/&gt;        proxy_set_header        X-NginX-Proxy true;&lt;br/&gt;        proxy_pass              http://127.0.0.1:8080/$1$request_uri;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;常见问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;nginx 中怎么设置变量&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或许你不知道，nginx 的配置文件使用的是一门微型的编程语言。既然是编程语言，一般也就少不了“变量”这种东西，但是在 nginx 配置中，变量只能存放一种类型的值，因为也只存在一种类型的值，那就是字符串。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如我们在 nginx.conf 中有这样一行配置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;set $name &quot;chroot&quot;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面使用了 set 配置指令对变量 &lt;code&gt;$name&lt;/code&gt;进行了赋值操作，把 &quot;chroot&quot; 赋值给了 &lt;code&gt;$name&lt;/code&gt;。nginx 变量名前面有一个 &lt;code&gt;$&lt;/code&gt; 符号，这是记法上的要求。所有的 Nginx 变量在 Nginx 配置文件中引用时都须带上 &lt;code&gt;$&lt;/code&gt; 前缀。这种表示方法和 Perl、PHP 这些语言是相似的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种表示方法的用处在哪里呢，那就是可以直接把变量嵌入到字符串常量中以构造出新的字符串，例如你需要进行一个字符串拼接：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server {&lt;br/&gt;  listen       80;&lt;br/&gt;  server_name  test.com;&lt;br/&gt;&lt;br/&gt;  location / {&lt;br/&gt;     set $temp hello;&lt;br/&gt;     return &quot;$temp world&quot;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上当匹配成功的时候就会返回字符串 &quot;hello world&quot; 了。需要注意的是，当引用的变量名之后紧跟着变量名的构成字符时（比如后跟字母、数字以及下划线），我们就需要使用特别的记法来消除歧义，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;server {&lt;br/&gt;  listen       80;&lt;br/&gt;  server_name  test.com;&lt;br/&gt;&lt;br/&gt;  location / {&lt;br/&gt;     set $temp &quot;hello &quot;;&lt;br/&gt;     return &quot;${temp}world&quot;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里，我们在配置指令的参数值中引用变量 &lt;code&gt;$temp&lt;/code&gt; 的时候，后面紧跟着 &lt;code&gt;world&lt;/code&gt; 这个单词，所以如果直接写作 &lt;code&gt;&quot;$tempworld&quot;&lt;/code&gt; 则 nginx 的计算引擎会将之识别为引用了变量 &lt;code&gt;$tempworld&lt;/code&gt;. 为了解决这个问题，nginx 的字符串支持使用花括号在 &lt;code&gt;$&lt;/code&gt; 之后把变量名围起来，比如这里的 &lt;code&gt;${temp}&lt;/code&gt;，所以 上面这个例子返回的还是 &quot;hello world&quot;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; curl &lt;span&gt;&#x27;http://test.com/&#x27;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    hello world&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还需要注意的是，若是想输出 &lt;code&gt;$&lt;/code&gt; 符号本身，可以这样做：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;geo $dollar {&lt;br/&gt;    default &quot;$&quot;;&lt;br/&gt;}&lt;br/&gt;server {&lt;br/&gt;    listen       80;&lt;br/&gt;    server_name  test.com;&lt;br/&gt;&lt;br/&gt;    location / {&lt;br/&gt;        set $temp &quot;hello &quot;;&lt;br/&gt;        return &quot;${temp}world: $dollar&quot;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面用到了标准模块 ngx_geo 提供的配置指令 geo 来为变量 &lt;code&gt;$dollar&lt;/code&gt; 赋予字符串 &lt;code&gt;&quot;$&quot;&lt;/code&gt; ，这样，这里的返回值就是 &quot;hello world: $&quot; 了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;附 nginx 内置预定义变量&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按字母顺序，变量名与对应定义：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$arg_PARAMETER&lt;/code&gt; #GET 请求中变量名 PARAMETER 参数的值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$args&lt;/code&gt; #这个变量等于 GET 请求中的参数，例如，foo=123&amp;amp;bar=blahblah;这个变量可以被修改&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$binary_remote_addr&lt;/code&gt; #二进制码形式的客户端地址&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$body_bytes_sent&lt;/code&gt; #传送页面的字节数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$content_length&lt;/code&gt; #请求头中的 Content-length 字段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$content_type&lt;/code&gt; #请求头中的 Content-Type 字段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$cookie_COOKIE&lt;/code&gt; #cookie COOKIE 的值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$document_root&lt;/code&gt; #当前请求在 root 指令中指定的值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$document_uri&lt;/code&gt; #与 $uri 相同&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$host&lt;/code&gt; #请求中的主机头(Host)字段，如果请求中的主机头不可用或者空，则为处理请求的 server 名称(处理请求的 server 的 server_name 指令的值)。值为小写，不包含端口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$hostname&lt;/code&gt; #机器名使用 gethostname 系统调用的值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$http_HEADER&lt;/code&gt; #HTTP 请求头中的内容，HEADER 为 HTTP 请求中的内容转为小写，-变为_(破折号变为下划线)，例如：&lt;code&gt;$http_user_agent&lt;/code&gt;(Uaer-Agent 的值)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$sent_http_HEADER&lt;/code&gt; #HTTP 响应头中的内容，HEADER 为 HTTP 响应中的内容转为小写，-变为_(破折号变为下划线)，例如：&lt;code&gt;$sent_http_cache_control&lt;/code&gt;、&lt;code&gt;$sent_http_content_type&lt;/code&gt;…&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$is_args&lt;/code&gt; #如果 $args 设置，值为&quot;?&quot;，否则为&quot;&quot;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$limit_rate&lt;/code&gt; #这个变量可以限制连接速率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$nginx_version&lt;/code&gt; #当前运行的 nginx 版本号&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$query_string&lt;/code&gt; #与 $args 相同&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$remote_addr&lt;/code&gt; #客户端的 IP 地址&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$remote_port&lt;/code&gt; #客户端的端口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$remote_port&lt;/code&gt; #已经经过 Auth Basic Module 验证的用户名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$request_filename&lt;/code&gt; #当前连接请求的文件路径，由 root 或 alias 指令与 URI 请求生成&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$request_body&lt;/code&gt; #这个变量（0.7.58+）包含请求的主要信息。在使用 proxy_pass 或 fastcgi_pass 指令的 location 中比较有意义&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$request_body_file&lt;/code&gt; #客户端请求主体信息的临时文件名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$request_completion&lt;/code&gt; #如果请求成功，设为&quot;OK&quot;；如果请求未完成或者不是一系列请求中最后一部分则设为空&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$request_method&lt;/code&gt; #这个变量是客户端请求的动作，通常为 GET 或 POST。包括 0.8.20 及之前的版本中，这个变量总为 main request 中的动作，如果当前请求是一个子请求，并不使用这个当前请求的动作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$request_uri&lt;/code&gt; #这个变量等于包含一些客户端请求参数的原始 URI，它无法修改，请查看 $uri 更改或重写 URI&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$scheme&lt;/code&gt; #所用的协议，例如 http 或者是 https，例如 &lt;code&gt;rewrite ^(.+)$$scheme://example.com$1 redirect&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$server_addr&lt;/code&gt; #服务器地址，在完成一次系统调用后可以确定这个值，如果要绕开系统调用，则必须在 listen 中指定地址并且使用 bind 参数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$server_name&lt;/code&gt; #服务器名称&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$server_port&lt;/code&gt; #请求到达服务器的端口号&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$server_protocol&lt;/code&gt; #请求使用的协议，通常是 HTTP/1.0、HTTP/1.1 或 HTTP/2&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$uri&lt;/code&gt; #请求中的当前 URI(不带请求参数，参数位于 args ) ， 不 同 于 浏 览 器 传 递 的 args)，不同于浏览器传递的 args)，不同于浏览器传递的 request_uri 的值，它可以通过内部重定向，或者使用 index 指令进行修改。不包括协议和主机名，例如 /foo/bar.html&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;附 nginx 模块&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;nginx 模块分类&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;核心模块：nginx 最基本最核心的服务，如进程管理、权限控制、日志记录；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;标准 HTTP 模块：nginx 服务器的标准 HTTP 功能；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可选 HTTP 模块：处理特殊的 HTTP 请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;邮件服务模块：邮件服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三方模块：作为扩展，完成特殊功能&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;模块清单&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;核心模块&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ngx_core&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_errlog&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_conf&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_events&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_event_core&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_epll&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_regex&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;标准 HTTP 模块&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ngx_http&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_core #配置端口，URI 分析，服务器相应错误处理，别名控制 (alias) 等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_log #自定义 access 日志&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_upstream #定义一组服务器，可以接受来自 proxy, Fastcgi,Memcache 的重定向；主要用作负载均衡&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_static&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_autoindex #自动生成目录列表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_index #处理以/结尾的请求，如果没有找到 index 页，则看是否开启了 random_index；如开启，则用之，否则用 autoindex&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_auth_basic #基于 http 的身份认证 (auth_basic)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_access #基于 IP 地址的访问控制 (deny,allow)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_limit_conn #限制来自客户端的连接的响应和处理速率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_limit_req #限制来自客户端的请求的响应和处理速率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_geo&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_map #创建任意的键值对变量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_split_clients&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_referer #过滤 HTTP 头中 Referer 为空的对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_rewrite #通过正则表达式重定向请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_proxy&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_fastcgi #支持 fastcgi&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_uwsgi&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_scgi&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_memcached&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_empty_gif #从内存创建一个 1×1 的透明 gif 图片，可以快速调用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_browser #解析 http 请求头部的 User-Agent 值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_charset #指定网页编码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_upstream_ip_hash&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_upstream_least_conn&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_upstream_keepalive&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_write_filter&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_header_filter&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_chunked_filter&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_range_header&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_gzip_filter&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_postpone_filter&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_ssi_filter&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_charset_filter&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_userid_filter&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_headers_filter #设置 http 响应头&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_copy_filter&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_range_body_filter&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_not_modified_filter&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;可选 HTTP 模块&lt;/strong&gt;:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ngx_http_addition #在响应请求的页面开始或者结尾添加文本信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_degradation #在低内存的情况下允许服务器返回 444 或者 204 错误&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_perl&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_flv #支持将 Flash 多媒体信息按照流文件传输，可以根据客户端指定的开始位置返回 Flash&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_geoip #支持解析基于 GeoIP 数据库的客户端请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_google_perftools&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_gzip #gzip 压缩请求的响应&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_gzip_static #搜索并使用预压缩的以.gz 为后缀的文件代替一般文件响应客户端请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_image_filter #支持改变 png，jpeg，gif 图片的尺寸和旋转方向&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_mp4 #支持.mp4,.m4v,.m4a 等多媒体信息按照流文件传输，常与 ngx_http_flv 一起使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_random_index #当收到 / 结尾的请求时，在指定目录下随机选择一个文件作为 index&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_secure_link #支持对请求链接的有效性检查&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_ssl #支持 https&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_stub_status&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_sub_module #使用指定的字符串替换响应中的信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_dav #支持 HTTP 和 WebDAV 协议中的 PUT/DELETE/MKCOL/COPY/MOVE 方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_http_xslt #将 XML 响应信息使用 XSLT 进行转换&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;邮件服务模块&lt;/strong&gt;:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ngx_mail_core&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_mail_pop3&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_mail_imap&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_mail_smtp&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_mail_auth_http&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_mail_proxy&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_mail_ssl&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第三方模块&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;echo-nginx-module #支持在 nginx 配置文件中使用 echo/sleep/time/exec 等类 Shell 命令&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;memc-nginx-module&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;rds-json-nginx-module #使 nginx 支持 json 数据的处理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;lua-nginx-module&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;视频号最新视频&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAJjUhrlvPsAAAAAstQy6ubaLX4KHWvLEZgBPEkKNMLl9VOfD-zNPgMIuzeC2qwTgrRf13Vpi4lJ-I&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=RBfjicXSHKCOONJnTbRmmlD8cOQPXE48ibtBXUEAKtRgl7BUBSYHUNaRHsOibNxVHntKHcVhdahYfW9FUWseOhdjS248icaWhleRjpcWeF4S0IdQrK5SHu1BMb9Trvyiag4jniaQLwJHgicIiaD1lZquAlCCeh83dgIFOAick6HZAT3OH09I&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=dc2dec1cd446892b76a52601807aa35e&amp;amp;token=cztXnd9GyrGhE2iaHGOXDiaIEWMBk1BY6bdAkbtbt3dRnIGnyp8bibIOhicHusCyVODD&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xEecUymmic8cw4v7Y2zbnVDuo/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;你很可能不知道的 10 个手机实用技巧，欢迎在评论区分享你的小技巧&amp;#10;#手机 #效率 #技巧 #iPhone&amp;#10;&quot; data-nonceid=&quot;10972294623550344267&quot; data-type=&quot;video&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;想了解腾讯人的故事，欢迎关注：腾讯技术&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg5OTE3MDMzOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/sz_mmbiz_png/YGYGFPll6xzwZBHwh7TgG3bjkhaTibXAC07CklcibMiateyQHO9oWOZBANkVvBichSQBRYf1H5D8PRRqDdWvyPicq1w/0?wx_fmt=png&quot; data-nickname=&quot;腾讯技术&quot; data-alias=&quot;&quot; data-signature=&quot;分享腾讯有料的技术，做有趣的技术人&quot; data-from=&quot;0&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6615b47a80cb0e28736c33e20d997597</guid>
<title>[推荐] 2021 年 5 月大厂面试总结</title>
<link>https://toutiao.io/k/jzi9mfx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;本文 9793 字，读完需要 30 分钟左右，适合在早高峰拥挤的地铁中阅读，你可能正在面试的路上，或者准备出去面试，无论怎样，本文都会给你带来不小的收获。我们也邀请了高飞来小道消息进行了分享，当天收听最高在线 1000 人+。欢迎大家&lt;strong&gt;扫码&lt;/strong&gt;收听回放。&lt;/p&gt;&lt;figure&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;506&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;596&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/EKs3bvt0w0JnIWSrhcUiavicHIjMpRDgaMq4IaXmoBfzYsAjnPy3rXlVfOTIl89MG20RVESibqSicCk5yp59QNrMGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;400&quot;/&gt;&lt;/figure&gt;&lt;span&gt;❞&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;沉寂了好一段日子，连我们公司自己人都问我为什么最近都不写文章了。那么当看到本篇的标题的时候，大家应该可以猜到这是为什么了。我最终还是决定要离开服务了 5 年多的公司。而这次跳槽历经 3 个月，前后聊了 10 家公司，进行了将近 40 场面试, 基本都是 4+1 的流程(技术面+HR 面)， 所以日程被排的很满。有一段时间每天都有 2 个面试邀约， 加上还有本职工作所以便没有精力再更新文章了。这次面试也算是个大活了， 经历了各式各样的面试场景。所以我想把这次跳槽的经验记录下来， 复盘一下自己的不足之处，同时也给大家提供一些素材，让大家以后出去面试能有个参照。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;素材介绍&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;面试 List&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我先介绍一下这一次面试的公司， 这一次我一心奔着大平台去的， 所以基本没有面试创业公司。以上市公司或者准上市公司为主。List 如下：BAT，快手，字节，贝壳，京东，美团，作业帮，神策数据。其中也调级加面过，也有由于职位不匹配换部门重新面过。所以虽然我没仔细计算过面试的场次，但是粗略估算差不多有 40 场这样一个数字吧。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;岗位介绍&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;职位上都是资深技术专家岗， 岗位需求上带的人较少，毕竟还是走技术路线，主要内容是在质量团队中做技术攻坚以及建设基础设施。业务方向上为容器，大数据，AI 这 3 个方向。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;面试结果&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5 家聊到最后，5 家由于岗位或方向不匹配主动放弃，1 家面试未通过（4 面交叉面的时候未通过）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上是这次面试的素材信息， 先介绍清楚， 避免跟我情况相差太多的同学有误解。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;算法方面&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;遇到算法考核的概率&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试考不考算法的问题我想大部分人都是很关心的， 毕竟平时工作用不上但面试就是喜欢考。我在面试之前其实也在群里询问是否要留足时间刷题，比较担心这么着急出去面试会不会因为准备不足而翻车。那么现在市面上对于算法的考核是什么样的呢？我直接说结果吧，不管大家是否认可在面试中把算法作为主要的考核手段。但是只要你有跳槽的心思， 就去刷题吧， 从我这次的面试经验来看，算法仍然是很主流的考核候选人的方式之一。但确实不是每一次都会考， 这个看公司风格，团队风格，面试官风格也看岗位的特点， 不是可以一概而论的。比如我在面试某家出了名的算法重灾区的时候，全程都没有考核算法。并且考核算法的这些公司里几乎也只有 1 面的时候才会考算法。所以综合我面试的所有数据来看， 遇到考算法和不考算法的团队是一半一半的概率。但是由于我这次面试的岗位的特点， 有时候一面面试官就是团队负责人的级别， 而到了这个级别的人一般是不喜欢问算法这种这么细节的东西的。所以我个人的结论是对于大部分测试开发人员来说，在面试的时候遇到算法考核的概率还是比较大的。PS：我也询问了几个同时期也在面试的朋友， 他们遇到考核算法的概率也不低。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;算法考核的范围和难度&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我这次遇到的题目几乎都是可以在 leetcode 上找到原题的，即便没有原题也是一个原题之上的变种， 所以大家刷题上还是以 leetcode 为主。难度上只遇见过 2 次中等难度， 其余的都是 easy 程度的题目，最多遇到的是链表和双指针相关的题目。可以看出来市场对于测试开发人员在算法上的考核要比研发序列轻松。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;算法考核占面试评价的比重&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我个人的感受是不会把算法作为硬性的标准一刀切的否定候选人。比如面试中有 2 次我是没有写出 bug free 的答案的，但是最后仍然通过了面试并且对方对我的评价依然不低。所以总结下来如果我们其他的方面足够优秀的话， 算法的影响并不是很大。但是如果面试官认为我们在其他方面并不优秀或者普普通通， 面试官就会很喜欢用算法来作为考核的最终手段了， 这时候没有答出来的话就是致命的了， 这一点我在接到某司 4 面挂通知的时候，就有所体会了。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;刷题是一定要刷的，不过 leetcode 上几千道题要刷完不太现实，成本太高。个人建议 easy 级别 top 系列可以刷一下。有精力的中等级别的刷一个高频系列，比如全排列，子集，子序列这些就可以了。再多的就不建议大部分人去刷了， 毕竟成本太高了。我们都是有工作和生活的，不可能整天都泡在算法上。否则会影响你正常的工作和学习的进度&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;做好心态建设，算法这个东西就跟高考似的， 刷过的题型是可以试试但是没刷过的可能连个思路都没有，leetcode 上那么多题型，你刷的再多也可能碰上没思路的题。这时候该认栽就认栽， 面试挂了也别气馁， 换一家继续面就可以了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;预留好足够的时间， 刷题是个长期的活，尤其我们都是有工作和生活的，做好长期战斗的准备。不要在已经开始投简历的阶段才开始刷题，临时抱佛脚不太管用。要在刚动了跳槽的心思的时候，就开始偷偷的刷起来。这一点我做的不好， 真的是简历已经发出去了，才开始刷。这就导致了我有几次没有写出正确的答案。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试频率方面&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的建议是有条件的话尽量的多面试几家，不要犯懒，即便这家公司你不想去， 也要去聊聊看。原因如下:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;面试讲究的是状态和心态，刚刚面试的时候一般是找不到一个良好的状态的， 很可能连自己的项目介绍的都磕磕巴巴的。而在心态上，刚出去面试不是过于乐观就是过于悲观，只有多面试几家公司才能树立一个比较合适的自信心。所以在去面试你特别想去的公司之前，最好先找 2 家公司练练手。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多面试也是为了找准自己的定位， 像我这种已经快 5 年半没有出去面试过的人，其实是很比较难能准确的评估自己的级别的。自己的定位找不准就容易出事， 比如本来你是 P8 能力的人，但是你觉得自己只有 p7 的水平，那么在跟 HR 谈薪的时候就会因为底气不足不敢要期望的薪资， 而如果你只有 P7 的水平却误认为自己是 P8 的级别，那也会因为自己有过高的期望而让谈判失败错失了好的工作机并会打击自己的信心。所以在面试初期的时候一定要快速的找准自己的职级定位&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面试是一个互相博弈的过程，尤其是跟 HR 谈薪资和定级的时候， 你需要手上至少有那么 2 个 offer 才能有底气与 HR 谈判。如果手上没 offer 就跟你心仪的公司谈， 很可能会被一压再压。要知道 HR 也是希望你过去的， 这也涉及到她的绩效。你手上有好的 offer 她就不敢压的太狠， 要不然你不来了她的损失也不小。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有些时候不聊一下，其实你都不知道这个岗位其实很适合你，没准聊着聊着就成了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试题方面&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先说明一下， 经过这次面试的总结，以及我跟几个同样在找工作的朋友沟通的情况看， 高级职位基本不会问基础方面的问题了， 因为这个级别开始就是走专家方向，要求的技术深度和广度是不一样的， 不会小打小闹的跟你扣基础技术。比如咱们社区里提到的一些常考题目一般都是看不到了。例如给你一个场景怎么设计测试用例，问 xpath 语法，问接口测试里怎么封装数据，问长连接和短连接的区别，问某个语言的语法， 类似这样的问题很少会碰到， 而我面试了 40 场是一个也没遇到。取而代之的会问一些成系统的问题来考核，希望候选人从更全局的角度来回答问题， 也希望候选人能更深入的分析一个方案的前因后果，成本收益，技术选型， 方案优势等等。当然面试官们还是以在简历中介绍的项目和技术点来挖掘问题为主， 不会天马行空的问不相干的问题。我把我还能记得的面试题分成几个类型列在下面。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;考核技术深度的类型&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一类问题是考核候选人硬实力的杀手锏，因为不像考核软性素质和项目管理类的这种偏务虚的问题， 务虚的问题是有话术的。而这类问题没有话术可言，只能靠自己的实力硬抗。下面我列一下我遇到的几个典型的问题。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;详细介绍一下容器网络的原理。这是我在面试一个做云的团队的一面面试题，后面又追问了 iptables 的原理， 因为现在的云产品都是要提供容器化服务的么，我简历中也写了很多 docker 和 k8s 的东西， 所以问这个问题也是对口。这个问题怎么说呢， 我觉得算是比较难的吧 ，大家用 docker 和 k8s 的时候一般都比较少关注底层原理。这涉及到 linux 底层的知识，包含了 namespace， 网桥，iptalbes 等知识， 具体的答案我曾经写过帖子，大家可以参考一下：https://testerhome.com/topics/9567&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在简历中描述的混沌工程项目中， 你是否调研过开源的故障注入工具比如 chaos-blade 和 chaos-mesh。你是否了解这两款工具，而当时你为什么没有选择开源工具而选择了自研， 你自研的东西对比这两款工具有什么区别？这个问题大概遇到了 3，4 次吧， 目前混沌工程比较火， 很多地方都希望我去做混沌工程相关的东西，所以碰见问这个问题的情况比较多。这个同样考察候选人的技术深度， 首先要解释清楚 chaos-blade 和 chaos-mesh 的原理，他们在故障注入方面是用什么样的机制去注入，各自的优缺点是什么。比如要解释 chaos-mesh 是直接从宿主机上通过切换名称空间来达到故障注入的目的，而我选择的是用 side car 模式直接注入故障容器的方式在 K8S 中注入故障。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;说几个你在运维 k8s 集群中出现的问题和解决思路，也有几个面试官直接问比较传统的介绍一下你印象最深刻的 bug。这个类型的问题回答思路一定要往高逼格上回答， 要体现技术身体和你处理问题的能力。我回答的是在维护 k8s 集群的时候遇到的 k8s 自己的 bug， 尤其是涉及到了 k8s 和 docker 的设计与 linux 内核冲突的 bug 方面上， 体现了自己研究 k8s 的技术深度。刚才也说了这是一个立 flag 的问题， 如果只是说一个很平常的 bug， 面试官会觉得你技术很一般， 没有解决过一些困难的问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;简述一下 spark 运行的原理/Flink 有几种窗口分别是做什么的。这是一道大数据相关的问题，是我面试一个大数据团队的时候遇到的。面试官估计就是想考核我 spark 的硬实力， 完全跟测试无关，这可能是很多小伙伴们不能理解的， 因为可能会觉得我要是会 spark 干嘛不去做大数据开发。但很遗憾， 很多的领域里面就是你不懂这个领域的研发技能的话，就是没办法做测试的。而大数据就是其中之一， 不懂大数据开发的人基本上很难能做大数据的测试。所以这道题从 RDD 讲起，数据切分，数据倾斜，shuffle 的原理，包括 shuffle 中的 shuffle write 和 shuffle read 的过程都是会考的。而 Flink 的题略简单， 时间窗口和数字窗口两个大类， 再详细讲一下时间窗口里的滚动窗口， 滑动窗口，session 窗口， global 窗口都说一遍也就过关了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果你自己维护一个 k8s 集群， 你通过什么手段保证集群的稳定性。这道题其实就是考察你懂不懂 k8s 的调度机制， 但是面试官没有直接问 node selector， pod selector，节点亲和性啊这些具体的知识点， 而是给我假设了这样一个场景看看我能不能灵活的运用这些知识点。所以我回答的思路就是围绕这些知识点的。比如第一点，流程规范上需要把 k8s 中运行的服务或任务分成不同的类别。类似算法中的分治思想。把集群中的节点也分成不同的类别， 比如有 SSD 硬盘的， 有 GPU 的， 有万兆网卡的，适合运行在线服务的，适合运行离线服务的， 适合运行业务服务的。这些节点分别按类别打上不同的 label， 然后把不同任务和服务使用 node selector 或者节点亲和性反亲和性调度到合适的节点上去。这样分而治之， 避免类似 IO 密集型的任务把业务服务给弄垮了的情况出现。所以流程规范上要规定每个团队按这种规范来启动容器。第二点，资源调度和规划上，每个任务和服务都要填写 request 和 limit 这两个字段明确的声明自己对于资源的需求， 禁止大量超卖导致资源失衡把机器搞垮， 同时节点的 kubelet 也需要在启动的时候限制好当前机器启动的 pod 数量的上限，避免 pod 过多， 也要通过参数给操作系统预留资源， 不能让 k8s 把资源都吃满，导致操作系统没有资源了整台机器崩溃。第三点，k8s 本身的服务要使用高可用模式， 并且所有启动了高可用模式的 pod， 需要使用 pod 反亲和性保证两个相同的服务不会启动到同一个节点上，同时每个 pod 必须配置好探针，对服务有完整的健康检查探活机制。第四点，要有完善的监控和自动化运维机制， 监控方面使用普罗米修斯监控所有节点和容器，并设置微信告警， 自动化运维方面编写自动化的程序， 比如自动清理存活时间太长的 pod， 节点压力过高时自动给该节点打 taint 以阻止任务继续调度到该节点上。第五点， 集群要有冗余， 多加几个节点防止某些节点崩溃的时候可以让服务迁移到其他健康节点上， 同时镜像要有规范，不能太大，免得迁移的时候 IO 太高，时间太长。这道题其实我理解对方就是在考我的 k8s 的调度机制，只是他没有直接问技术点， 而是考核我有没有一个成体系的技术能力解决问题。我发现这是好多大厂面试官的提问风格。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结一下这类问题是所有问题中最扣技术能力的了， 面试官会从简历中挑选他感兴趣的东西使劲往深了问， 考核的就是候选人在某样技术领域里到底走的多深。甚至直接就是问你研发技能， 这个是很多小伙伴们反感的。但这就是现实吧， 不仅仅是面试官， 我自己也比较认同只有在一定程度上了解了研发技术后，才能设计出更合适的测试场景。比如在大数据领域里你不知道 shuffle 这个东西的话， 那就真的不知道要去测试数据倾斜这个场景了。不知道 checkpoint 的话也就想不到在流计算里去测试数据一致性。所以有些时候你会面对一些研发技术的问题，我遇到一个比较极端的是面试官直接问我如何设计一个在线的实时排名系统， 就是客户端+kafka+flink 这套思路， 我理解面试官也不是说希望你能开发出这么一个系统出来， 他只是想知道你是否有相关的概念， 是不是深入的测过这样的系统， 因为如果你真的深入测试过一个系统， 那这个系统的架构你一定能说的出来。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;考核测试策略的类型&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一类问题主要出现在如果面试的岗位和当前公司的岗位很匹配的情况下， 或者面试官也是这一领域里面， 他会使劲的问测试策略。比如我是在 AI 领域中的， 我这一次找的工作也大多数是做 AI 的团队， 所以经常遇到如下问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果评估模型的效果？类似于问怎么做效果测试。这个问题在 AI 圈子里属于最常问的问题， 一般听说过的同学基本都知道采集数据灌入模型然后评估模型预测的正确率。但是如果这么简单的回答基本是会跪的。因为其实这个测试类型还蛮复杂的， 模型效果涉及到很多东西。比如线上模型和线下模型的效果一致性， 不同类型的模型的评估指标都有什么。整个模型的生命周期中分成哪些阶段， 每个阶段怎么测试来保证效果。做效果测试的时候数据如何采集等等。这类的问题肯定不是一两句话能说清楚的， 需要候选人更全面的分析每个场景和对应的测试方案。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在大数据产品里都做过哪些测试方案？同样是一个很大的问题， 我的答题思路是批处理和流计算要分别说， 批处理方面就涉及到了功能，性能，数据倾斜，异常场景， 数据及时性。流计算里功能，性能，数据一致性。同样共性的都要做监控，批处理的监控主要是写 spark 程序扫描数据， 而流计算主要是写一段 Flink 来对接消息中间件来扫描数据。白盒测试方面需要去研发的 repo 里以 UT 的形式去测试 UDF 和 UDAF， 还要去拆流，把大的流拆成若干个小流进行集成测试。同样不管批处理还是流计算在数据领域不管是功能还是性能测试都避免不了造数这个话题。需要分析一下需要造数进行测试的场景， 怎么造数， 甚至介绍一下自己的造数工具的思路。我自己的思路无非就是批处理用 spark， 流计算用消息中间件的客户端。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果测试产品的稳定性？这个问题容易理解为问你如何开展混沌工程。因为混沌工程的目的就是测试产品的高可用架构在生产环境下出现故障的时候是否有足够的容错能力保证产品继续的稳定提供服务。但混沌工程的这种故障注入进行测试只是一个思路， 所以我回答的时候也说明了在云原生架构下， 如何从服务调度方面，镜像规范方面， 容器编排规范方面来保证服务的稳定性。因为有些时候调度策略不对或者镜像太大或者没有设置合理的探针，资源规划都会导致服务的不稳定。而混沌工程方面也会展开来说在不同的场景下主要注意的地方， 比如在流计算场景里更注意的是故障在触发后会不会造成数据不一致的情况。所以验证点就不是业务正常的返回， 还要验证数据是否正确。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结一下这类问题跟上面说的技术深度不一样， 考核技术深度的时候是一条线的使劲往深了问， 而这种测试策略类型的问题我理解更看重的是候选人能否从整体的角度全面的介绍你的测试策略。毕竟这个级别不是大头兵了， 需要负责一个方向，不能是只在一个点上发力。个人理解这种问题会比较少扣技术细节， 更关注的是候选人对特定业务的测试方案的理解是否足够全面。我们在日常工作里很多人可能只是负责某一块东西， 很难能熟悉所有的测试方案， 比如从效果测试来说我们团队其实有人专门做在线效果测试， 有人专门做离线， 有人专门做一致性，有人专门做数据正确性测试， 并不是效果测试中所有的场景都交给一个人来测试。所以平时工作的时候除了自己负责的测试外， 还是建议大家都关注一下其他人做的测试类型， 给自己形成一个整体的测试思维和视角。这一点我自己也有所不足， 我更擅长的是机器学习场景， 而深度学习类比如 CV,NLP，OCR 我都不太熟，回答问题的这时候这部分有些缺失。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;考核管理能力/软性素质/测试理念/业务理解 等&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比较懒了我就把这些类型都汇总在一个标题里了， 回答这类问题有话术， 需要候选人口才好， 说话逻辑清晰， 并且对于问题有自己独到的见解， 我列一下我被问到的印象深刻的几个问题。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;你是如何理解工程效能的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你是如何理解 QA 这个职业的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果给你一个 40 人左右的团队， 你如何管理，如何展开招聘工作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果设计一个国内通用的可以评估自动化测试的效果的模型，你考虑一下这个模型要怎么设计， 要从哪些维度评估。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在推进工具/平台/流程 的时候遇到不配合的团队怎么处理？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;大概介绍一下产品的业务，盈利模式，公司对这个产品的策略&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何度量你的自动化测试方案/工程效能工具 的成本，收益&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你如何证明当前的产品的质量是 OK 的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你如何设计你所在产品的质量保障体系&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先这类问题大多数是没有正确答案的，每家公司的理念不一样， 仁者见仁智者见智。有些看运气， 就是看你回答的理念符不符合面试官的价值观， 不符合的话别想太多就认栽吧。然后回答这类问题的时候很看你的表达能力， 言语之间的逻辑性比较重要。个人觉得最关键的是对这类问题要事前有准备， 否则容易被打个措手不及。平时工作的时候也要多注重一些系统性思维的思考， 对以后都是有帮助的。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;剩下的有些问题我自己也记不清楚了， 就主要列上面那 3 个大类吧。整体看除了考核算法有固定的题库外， 其他的问题基本都是根据我简历里描述的项目来展开问的， 所以好好准备自己简历中描述的内容十分重要， 结合我自己做面试官的经验， 逻辑表达能力其实也是占了一个比较重要的位置。如果在回答上述这些问题的时候逻辑混乱， 磕磕巴巴，前言不搭后语, 那面试可能也是会挂的。所以事前准备真的很重要， 只要是简历里写的，都要自己过好几遍， 能预想到的问题都准备好答案背下来， 比如项目描述， 测试方案这些东西。并且整个技术方案的前因后果也要准备好， 因为有些面试官会比较喜欢问你为什么要推进这个技术方案， 是遇到什么问题导致的？还是你自己主动推进的？推进这个技术方案遇到了什么问题， 这个技术方案有什么优势， 后面的拿到了什么结果， 怎么度量你的结果。面试官会根据简历写的东西使劲扣， 所以事前准备好是非常重要的。自己简历里写的内容一定要经得起考验， 否则勾起面试官的兴趣后最后却比较失望，那就很影响面试结果了。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;谈一谈业务方向的选择&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次出来面试对于业务方向的选择也有一些感受， 我觉得有一句话也挺对的叫选择大于努力， 我自认为是比较努力的类型， 但也不得不承认当初也是选择了几个比较好的业务方向， 所以现在找工作比较容易， 竞争对手少，大厂都愿意要这几个方向的人才，而且价钱也都能聊的上去。这几个方向分别是：容器，大数据，AI。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先云目前比较火，尤其是云原生架构特别火， 不少公司都在转型云原生架构，线上线下环境都要上云。从我这次找工作的情况来看， 即便是顶级公司中也有不少项目是没有上云的， 而这些公司都不约而同的希望能将这些项目上云， 所以才会在面试的过程中非常关注我简历中描述的 docekr，k8s，混沌工程，环境治理等相关内容。看目前的趋势， 以后这类技术会成为行业内很普遍的技能，很多测试人员尤其是大厂测试人员都要或多或少的掌握一些这样的技能，而能在云原生架构下建设环境治理， CICD， 混沌工程以及各类测试平台与工具就成了目前比较稀缺的能力， 并且现在专业做云的公司也越来越多， 连字节都要搞自己的云了， 所以相关的测试岗位也变多了， 但是在测试行业里懂这些的人是比较少的， 毕竟容器技术才火了这么几年，而且被很多人当做是运维领域的技能，所以很少有 QA 会去研究。而这个领域的研究深了也会比较值钱。所以现在云领域我认为是一个比较好的方向。感兴趣的同学可以了解一下。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再说大数据， 我记得 15 年的时候，当时我们质量部这边有一个架构师就说过大数据是未来。当时我还不知道什么是大数据，好像那个时候大数据这个词还没有像现在这么普遍， 可能那个时候做大数据的人还是比较小众的。但是现在基本上成点规模的公司都会有自己的数据部门， 目前这部分业务的测试工作在很多公司仍然以研发自测为主，也没办法，懂大数据的 QA 比较少。这也导致了如果你在大数据上有一些沉淀的话， 就会比较抢手。我们团队之前有 2 个人拿了美团和快手的数据团队的 offer， 听说总包涨幅都不低。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后说说 AI， 前几年 AI 热潮造就了不少工作岗位， 虽然现在 AI 四小龙后劲不足，但市面上各个公司仍然都还在构建自己的 AI 能力。而跟上面 2 个领域一样的是 AI 领域的 QA 人才仍然很缺少， 做这部分测试需要懂机器学习，深度学习，大数据（因为目前机器学习都是构建在大量的数据下的）。我跟一些大厂的同行聊天的时候，大家都表达出了招人的乏力， 想在世面上招到符合要求的测试人员太困难， 大家都开启了内部培养的模式。所以在这样一个大环境下，懂 AI 业务和相关技术栈的 QA 会比较吃香。从我自己这次找工作来说， 在当前公司做机器学习平台的经历还是很加分的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以业务方向的选择是挺重要的， 除了我说的这 3 个方向以外一定也是有其他不错的方向， 只是我不熟悉的就不说了。我个人觉得选择一个技术类的业务方向是比较好的， 就比如我上面说的这 3 个方向， 全部是技术类的业务，也就是技术本身就占业务中很重要的部分。在这样的业务中工作就可以兼顾技术与业务两方面的发展。比如你在云产品中做测试人员， 云产品中很多时候玩的就是 docker，k8s，OpenStack，分布式存储这些东西，这样你测试的过程中就能练出一身技术了。选择走技术类的业务还有一个好处是业务足够复杂， 深度也足够深。可发展的空间比较大，越走到后面竞争对手就越少。当然做起来难度就越高，需要学习很多技术， 但也正因为难度大， 竞争对手才少， 机会才多。如果业务比较简单， 那很难做出亮点， 机会也少，门槛低，竞争对手就多。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;职业发展上个人感觉几个比较重要的事情&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;选择一个自己热爱的领域：这个怎么说呢， 努力的重要性是不言而喻的， 但是如果我不热爱这个领域的话， 实话实说我很这么多年来一直保持学习的状态。长期保持高强度的做一件自己不喜欢的事还能做的特别好， 这不是一般人能坚持下来的，起码我就不是。所以我个人觉得做自己喜欢的事挺重要的， 这很大程度决定了后面自己是不是能发展的好。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;选择一个有门槛的领域：门槛的重要性我之前专门写过文章表明我的观点， 上面也说过门槛高，挑战大，但是机会多，对手少，上限高。门槛低，容易做，但是机会少，对手多，上限低。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;心态上不要纠结于&lt;strong&gt;「QA」&lt;/strong&gt;的本职范围内：好些同学总会纠结一些事到底是不是 QA 的职责范围， 比如有人会觉得 docker 和 k8s 是运维才应该学的东西， 面试的时候面试官问几句心态就炸了，直言我又不是 研发/运维 我干嘛要学这个。这样是不行的， 还是那句话，高阶的测试开发人员一定要有技术追求。技术与业务的结合才是最优解。我在一场面试的时候，面试官问我混沌工程这个事情有些公司都是 SRE 部门做的， 你觉得 QA 做的优势是什么。我回答说 SRE 或运维可能在云原生相关能力上比我更优秀， 但是他们不懂用户，不懂业务，不懂产品。注入故障后他们并不能很好的评估故障带来的影响， 而 QA 可以。以我这几年做测开的经验， 很多有价值的事情都是需要一定的研发和运维能力才能去做。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;年龄是每个人都要面对的坎， 只有不停的提高自己的能力， 让能力的增长匹配的上年龄的增长才能让自己处于一个比较安全的位置。这一点在出来面试的时候就会感受的到。不希望自己面试的时候因为年龄问题被卡住，平时就不要趟平， 多锻炼自己的能力。我一个朋友在 43 岁的时候还能找到不错的工作， 而另一个人在 30 来岁的时候就早早的被迫转了行。这个行业， 逆水行舟， 不进则退， 大家努力吧。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自己的实力决定了周围人对待你的态度， 多年前我还是菜鸟的时候出来面试到处受白眼，遭嫌弃。而这次面试感觉全世界都变的友好了起来， 到处都洋溢着灿烂的笑脸， 婉拒对方的时候，他们还会各种挽留。而我在公司中推进事情的时候也是发现比以前容易很多，不再像以前那样不把自己当回事。所以想要受尊重， 想要工作开展的顺利， 还是要往上爬。这个世界就是这么现实，还是那句话， 逆水行舟不进则退。我们都是在水流中不停向前的人。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;跳槽的时候需要注意的几个事情&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;有些同学可能担心跳槽涨幅会不会卡 30%。普遍会有这个情况， 但优秀的人可以打破这个限制。想要超过 30% 一般要走特批， 或者业务方极力争取，所以面试中的任何一面的面评都是比较重要的，大家要认真对待每一次面试， 不要因为一面的时候觉得对方比你年轻或者能力没你好就态度轻慢。总之就是想要涨幅超过 30%， 就要证明自己有这个价值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;大厂背调一般比较严格， 大家注意千万别造假。简历中的工作信息最好对着自己的社保记录写一遍。第三方背调公司一般会要求提供 10 年内最近两家公司的信息， 要求提供同事， 直属上级和 HR 的联系方式。再强调一下别因为觉得自己跟领导或者 HR 关系不好，担心说自己坏话而填写其他人， 如果被查出来的话，也是可能会导致背调失败的。他们的评价并不会直接影响你的入职， 只要确定你没有造假就不会出事。如果上家公司找不到联系人了， 可能会要求提供社保记录， 离职证明（所以以前公司的离职证明最好留一个备份）。最后如果实在没办法证明自己在那家公司工作过的话， 背调公司一般会顺延， 调查 10 年内第三家公司的经历。在背调之前一定要跟 HR 再确认一遍他们手里的简历是不是你提供的最新的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;遇到不合拍的面试官的情况很正常，心里再不爽也别当时翻脸。没有当场翻脸就还有周旋的余地，很多面试官其实在你入职后都跟你没多少交集，没必要跟他置气。比如我 4 面挂的那一次就是美团技术委员会的交叉面， 完全是另一个部门的人。他是业务团队的人， 我面的是数据团队的岗位， 他不懂大数据， 我不懂客户端。被挂了也正常，因为两个人完全不在一个频道上。心态放平和， 面试后找主管沟通说明情况，看是否有周旋的余地。就算不成也没关系， 好好睡一觉准备下一家公司。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;尊重每一家公司，不要在 offer 之间反复横挑， 太败人品。如果决定不去这家公司了， 尽早说明， 不要拖着。圈子很小， 要小心维护自己的风评。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;尊重每一个面试官， 聊得开心的可以加个微信， 就算这次不成，以后也没准会有合作的机会。圈子真的很小， 没准走着走着就又聚到一起了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就写这么多吧，估计大家可借鉴的也不多， 毕竟每个人有每个人的情况。最后说一下大厂的面试流程都很长， 动辄 1 个多月，大家要合理安排时间。祝大家早日富可敌国！&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;742&quot; data-backw=&quot;558&quot; data-ratio=&quot;1.3293768545994065&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/EKs3bvt0w0JnIWSrhcUiavicHIjMpRDgaMzeNOVqiaALyLJ804RVrYpT1qACTD2lLYI6YlGW7wnNDr4DRpVd12HtQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1011&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3841886269070735&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_gif/EKs3bvt0w0IMIoKH5WoLTNicQz8R8EaYElJjicIvfJaicFoANUueBVfKKMm2MJNB4pPcKicOKpV6sPiaTAy3Dky0How/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;721&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>31cf7ca8b5107992439df9db65df70c3</guid>
<title>[推荐] 聊聊知乎订单系统迁移</title>
<link>https://toutiao.io/k/5rfvjrx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;本文主要介绍知乎订单系统后端语言栈的转型升级过程，包括其间踩过的一些坑和遇到的一些问题。一来是想通过本篇文章为其它应用服务转型提供借鉴经验，二来是总结对于订单系统的理解。鉴于文字功底不足，对于业务理解不充分的地方，欢迎留言交流。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;迁移背景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;随着知乎整体技术栈的变化，原有的 Python 技术栈逐渐被抛弃，新的 Go 和 Java 技术栈逐渐兴起。知乎交易系统的稳定性相比其它业务系统的稳定性重要很多，因为交易系统核心链路发生故障不仅会造成数据问题，还会造成严重的资损问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;随着公司业务的不断壮大发展，交易场景变得复杂，重构和优化难以避免，因为语言特性，Python 虽然开始撸代码很爽，但是后期的维护成本慢慢变高，不过 Python 在数据分析和人工智能方向上还是有很大优势的，只是在交易领域目前看起来不太合适。从技术生态上来说，用 Java 做交易系统会更有优势，所以接下来要说的知乎订单系统语言栈转型。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另外一个因素是 Python 的 GIL 锁导致它无法发挥多核的优势，性能上受到很大限制，在实际情况中遇到过多次主线程被 hang 住导致的可用性故障，所以坚定决心来迁移掉旧系统。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;前期准备&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;12&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;工欲善其事，必先利其器。&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;语言栈转型首先要明确转型的三个开发流程，即 MRO (Migration, Reconstruction, Optimization)&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;迁移 就是把原语言代码照着抄一遍到新语言项目上，按照新语言的工程实现风格来做就可以。其间最忌掺杂代码优化和 bug 修复，会容易引起新的问题，增加验证代码的难度。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;重构 目的是提高项目代码的可维护性和可迭代性，让代码更优雅和易读懂，可以放到迁移完成来做。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;优化 通过在模块依赖、调用关系、接口字段等方面的调整来降低项目的复杂性，提高合理性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于语言栈转型来说，迁移流程是肯定要做的，重构和优化如何选择，可以按模块划分功能拆成子任务来分别评估方案，参考依据为现有模块如果同时优化或重构带来的直接收益和间接收益有多少。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9692832764505119&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJeRB7mib9QnwbahcGlxZOn4aGCdD5IMTdTz9IsicvFM0chXicYnA3quByw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;293&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在风险可控的前提下，成本与收益要互相权衡，一般会有两种方案可供参考：第一种是锁定需求，堆人力开发上线，一步到位；第二种则是小步快走，迭代上线，分批交付。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.37910085054678005&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJojluRqC3gDpN9JrkfFzyAC7kFuZJhDrjJVlCQvSicA7gzzhhwWAoygw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;823&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;基于以上分析，在本次转型过程中，人力成本是一个更重要的因素，所以采用只迁移的方案，来压缩人力成本，降低 bug 引入风险的同时也具有很好的可测试性。并且为了不阻塞业务需求，采用小步快走的方式分批交付，以最长两周作为一个迭代周期进行交付。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;迁移方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;确定了交付方式，下面我们需要梳理当前系统中的功能模块，做好任务拆分和排期计划。知乎交易系统在迁移前的业务是针对虚拟商品的交易场景，交易路径比较短，用户从购买到消费内容的流程如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;在商品详情页浏览&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;生成订单进入收银台和用户支付&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;确认支付后订单交付&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户回到详情页消费内容&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;特定商品的七天无理由退款&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当时订单系统支持的功能还不多，业务模型和订单模型没有足够地抽象，梳理订单系统业务如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5767397521448999&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJqr55JS4IgVdytr0BVdsvw2vQrFuDyH57QoltcRWurwpicNVl2PNNoYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2098&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;完成了订单模块的拆分后，新老系统如何无缝切换？如何做到业务无感？如何保障交易系统稳定性？出现故障如何及时止损？基于上面讲述的原则，将整个系统的迁移划分成两个阶段，迁移前后的数据存储和模型都不变。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.34676434676434675&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJNlAr1glsqxTBvicTyec7PZrDZyO30QLson3ib65xic1XALMQZmCJhSDxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1638&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;接口验证&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不论是在迁移的哪个阶段，总需要调整订单接口，可以从订单操作角度分为读操作和写操作，需要针对读接口和写接口做不同的验证方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;写操作可以通过白名单测试以及灰度放量的方式进行验证上线，将接口未预期异常输出到 IM 工具以得到及时响应。主要的写操作相关接口有：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;订单的创建接口。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;订单绑定支付单的提交接口。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户支付后回调确认接口。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户发起退款接口。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下图展示的是 AB 平台的流量配置界面：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.45636363636363636&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJJPFMDkMeicbfRoTyXc5y4QZibM1OIysSVo0ib4CfIxjI9nGd2icITY548g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1650&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下图展示了部分交易预警通知消息：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0763116057233704&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJpM4yKbxkzbOPP8RcnGljJYyr9bvtbWj9K7sXzfPOnT2OTZbgzo1jVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1258&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;读操作往往伴随在写操作中。我们利用平台的录制回放功能进行接口的一致性检查，通过对比得出差异排查问题。主要的读操作接口有：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;获取支付方式列表接口&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;获取订单支付履约状态接口&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;获取充值列表接口&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;批量查询用户新客状态接口&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下图展示的是流量录制回放系统的数据大盘：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4238358326756117&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJsEo12l0ouVzZFUmRI7FoCUnzib9gz3ZziaT9HAcL9V0kiczJxLckABnNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1267&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;指标梳理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;监控是我们系统的『第三只眼』，可以及时反应系统的健康状况，及时发出告警信息，并帮助我们在出现故障时分析问题和快速缩小排查范围。硬件、数据库、中间件的监控已经在平台层得到支持，这里只需要梳理出应用的监控指标。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;日志监控：请求日志、服务端的错误日志。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;订单业务指标&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;下单量、成单量、掉单量&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;单量环比数据&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;首次履约异常量&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;补偿机制履约量&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;各通知事件 P95 耗时&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;成功履约 P95 耗时&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;履约准时率/成功率&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支付业务指标&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户购买完整耗时 P95。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;可用性保障&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在整个交付的过程中，转型前后对 SLA 要提供一致的可用性保障，可以看看下面的几个衡量标准：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.38011049723756907&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJ85icUvoVtb0AxtlKZAdaqGbGvgFOXV0yQVArf8pPkKYoMXXszuJc2hQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1810&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一般 3 个 9 的可用性全年宕机时间约为 8.76 小时，不同系统不同用户规模对于系统可用性的要求不一样，边缘业务的要求可能会低一些，但是对于核心链路场景 TPS 可能不高，但是必须要求保证高可用级别。如何保证或者提升服务的 SLA 是我们接下来要探讨的内容，一般有下面两个影响因素：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;也就是说我们要尽可能地降低故障频率，并确保出现故障后可以快速恢复。基于这两点我们在做系统平稳过渡时，要充分测试所有 case ，并且进行灰度方案和流量录制回放，发现异常立即回滚，定位问题解决后再重新灰度。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;MTTR 快速响应&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;持续监控&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;感知系统稳定性的第一步就是监控，通过监控来反映系统的健康状况以及辅助定位问题，监控有两个方向：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第一个方向是指标型监控，这里监控是在系统代码中安排各种实时打点，上报数据后通过配置报表呈现出来的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;基础设施提供的机器监控以及接口粒度的响应稳定性监控。&lt;/p&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;物理资源监控，如 CPU、硬盘、内存、网络 IO 等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;中间件监控，消息队列、缓存、Nginx 等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;服务接口，HTTP、RPC 接口等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据库监控，连接数、QPS、TPS、缓存命中率、主从延迟等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;业务数据层面的多维度监控，从客户端和服务端两个角度来划分。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;从客户端角度来监控服务端的接口成功率，支付成功率等维度。&lt;/p&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;从服务端角度从单量突变、环比变化、交易各阶段耗时等维度持续监控。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以上两点基于公司的 statsd 组件进行业务打点，通过配置 Grafana 监控大盘实时展示系统的健康状况。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6001540832049307&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJ7wlJ4GPuHPBq4qgicO76qYfKA8TeMzaoNIr1wPCOg1V0jjPzfRiaUKmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2596&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第二个方向是日志型监控，这主要依赖公司的 ELK 日志分析平台和 Sentry 异常捕获平台。通过 Sentry 平台可以及时发现系统告警日志和新发生的异常，便于快速定位异常代码的发生位置。ELK 平台则可以将关键的日志详细记录下来以便于分析产生的场景和复现问题，用来辅助修复问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;异常告警&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4759100642398287&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJxoZb3Qk58ibGuv8mflJ3iaDlVcSzOia8OBic1FhXvhviaQObSa4ISQwun4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3736&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;基于以上实时监控数据配置异常告警指标，能够提前预知故障风险，并及时发出告警信息。然而达到什么阈值需要告警？对应的故障等级是多少呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先我们要在交易的黄金链路上制定比较严格的告警指标，从下单、提单、确认支付到履约发货的每个环节做好配置，配置的严重程度依次递增分为 Info、Warning、Critical。按照人员类别和通知手段来举例说明告警渠道：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.34558823529411764&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJjRrgH3K2P6cpd6QBhYsnT8gWDdGdnXu6zktKeubjsoIiaV2V8TLjJQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1360&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;IM 中的预警消息截图如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.991701244813278&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJDrYJCGNJ0tW7GWStoaXib0IzArosWYOppt25hgjzk727CDquXyQtjsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1446&quot;/&gt;&lt;/p&gt;&lt;p&gt;订单主要预警点如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;核心接口异常&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;掉单率、成单率突变&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;交易各阶段耗时增加&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户支付后履约耗时增加&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;下单成功率过低&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;MTBF 降低故障率&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;系统监控告警以及日志系统可以帮我们快速的发现和定位问题，以及时止损。接下来说的质量提升则可以帮助我们降低故障发生率以避免损失，主要从两个方向来说明：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;规范化的验收方案&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.34227330779054915&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJ5KXgcWbGKpbIwAibqUWBH53QYbJGPR2jjSSh23CEfQlJQDY3brDkAhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1566&quot;/&gt;&lt;/p&gt;&lt;p&gt;① 开发完成包括逻辑功能和单元测试，优先保证单测行数覆盖率再去保证分支覆盖率。然后在联调测试环境中自测，通过后向 QA 同学提测。&lt;/p&gt;&lt;p&gt;② QA 同学可以在测试环境下同时进行功能验收和接口测试，测试通过后便部署到 Staging 环境。&lt;/p&gt;&lt;p&gt;③ 在 Staging 环境下进行功能验收并通过。&lt;/p&gt;&lt;p&gt;④ 灰度交付以及双读验证可以根据实际情况选择性使用。&lt;/p&gt;&lt;p&gt;⑤ 上线后需要最后进行回归测试。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;统一的编码规约以及多轮 CR 保障&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;代码上线前一般至少要经过两次代码评审，太小的 MR 直接拉一位同事在工位 CR 即可，超过百行的变更需要拉会研讨，两次评审的关注点也不同。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第一次评审应关注编码风格，这样可以避免一些因在写法上自由发挥而带来的坑，以此来沉淀出组内相对统一的编码规约，在编码的稳定性上建立基本的共识，提升代码质量。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第二次评审应关注代码逻辑，这里有个需要注意的点是，如果明确只做迁移，那么其间发现旧逻辑难理解的地方不要随便优化，因为在不了解背景的情况下很有可能会写一个 bug 带上线（这种事见过好几次）。另外这样也好去对比验证，验证通过上线后再去优化。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;只有通过明确目的和流程并且遵循这个流程做，才能更快更好地交付有质量的代码。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;一致性保障&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;每一个微服务都有自己的数据库，微服务内部的数据一致性由数据库事务来保障，Java 中采用 Spring 的 @Transtaction注解可以很方便地实现。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而跨微服务的分布式事务，像 支付、订单、会员三个微服务之间采用最终一致性，类似 TCC 模式的两阶段提交，订单通过全局发号器生成订单 ID，然后基于订单 ID 创建支付单，如果用户支付后订单会变更自身状态后通知会员微服务，履约成功则事务结束，履约失败则触发退款，如果用户未支付，那么订单系统将该订单以及支付单做关单处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对应一致性保障，我们对订单接口做了两个方面的处理：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;分布式锁&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于上游的支付消息监听、支付 HTTP 回调、订单主动查询支付结果三个同步机制分别基于订单 ID 加锁后再处理，保证同步机制不会被并发处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;接口幂等&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;加锁后对订单状态做了检查，处理过则响应成功，否则处理后响应成功，保证上游消息不会被重复处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;订单对于下游的履约，是通过订单 ID 作为幂等 key 来实现的，以保证同一个订单不会被重复履约，并且通过 ACK 机制保证履约后不会再重复调到下游。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4052346570397112&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJGVjmX0onY077uLq5FP4ibNMib2gibu9mVdemoBOQ1DrarmUpJhdqtmVBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1108&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其中分布式锁采用 etcd 锁，通过锁租约续期机制以及数据库唯一索引来进一步保障数据的一致性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;补偿模式&lt;/strong&gt;，虽然我们通过多种手段来保证了系统最终一致，但是分布式环境下会有诸多的因素，如网络抖动、磁盘 IO、数据库异常等都可能导致我们的处理中断。这时我们有两种补偿机制来恢复我们的处理：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;带惩罚机制的延时重试&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果通知中断，或者未收到下游的 ACK 响应，则可以将任务放到延迟队列进行有限次的重试，重试间隔逐次递增。最后一次处理失败报警人工处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;定时任务兜底&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了防止以上机制都失效，我们的兜底方案是定时扫描异常中断的订单再进行处理。如果处理依然失败则报警人工处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;事后总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;目标回顾&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;目标一：统一技术栈，降低项目维护成本。目标结果是下线旧订单系统。&lt;/p&gt;&lt;p&gt;目标二：简化下单流程，降低端接入成本。目标结果是后端统一接口，端上整合 SDK。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;执行计划&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;迁移的执行总共分成了三个大阶段：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第一阶段是迁移逻辑，即将客户端发起的 HTTP 请求转发到 RPC 接口，再由新系统执行。第一阶段做到所有的新功能需求都在新系统上开发，旧系统只需要日常维护。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第二阶段是通过和客户端同学合作，迁移并整合当前知乎所有下单场景，提供统一的下单购买接口，同时客户端也统一提供交易 SDK，新组件相对更加稳定和可监控，在经过灰度放量后于去年底完全上线。第二阶段做到了接口层的统一，更利于系统的维护和稳定，随着新版的发布，旧接口流量已经变得很低，大大降低了下阶段迁移的风险。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第三阶段是旧 HTTP 接口迁移，由新系统承载所有端的请求，提供相同规格的 HTTP 接口，最后通过修改 NGINX 配置完成接口迁移。第三阶段迁移完成后旧系统最终实现了下线。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;执行结果&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;截至此文撰写时间，语言栈已经 100% 迁移到新的系统上，旧系统已经完全下线，总计下线 12 个系统服务， 32 个对外 HTTP 接口，21 个 RPC 接口，15 个后台 HTTP 接口。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;根据 halo 指标，迁移前后接口 P95 耗时平均减少约 40%，硬件资源消耗减少约 20%。根据压测结果比较，迁移后支撑的业务容量增长约 10 倍。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;系统迁移完成只是取得了阶段性的胜利，接下来系统还需要经过一些小手术来消除病灶，主要是以下几点：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;不断细化监控粒度，优化告警配置，继续提高服务的稳定性。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对于 Python 的硬翻译还需要不断重构和优化，这里借鉴 DDD 设计思想。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;完善监控大盘，通过数据驱动来运营优化我们的流程。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;项目复盘总结以及业务普及宣讲，提升人员对于业务细节的认知。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题整理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;迁移总是不能一帆风顺的，其间遇到了很多奇奇怪怪的问题，为此头发是真没少掉。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;问题 1：迁移了一半新需求来了，又没有人力补上来怎么办？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;迁移后再做重构和优化过程，其实很大一部分考量是因为人力不足啊，而且现状也不允许锁定需求。那么只能写两遍了，优先支持需求，后面再迁移。如果人力充足可以选择一个小组维护新的系统一个小组维护旧的系统。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;问题 2：我明明请求了，可日志怎么就是不出来呢？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不要怀疑平台的问题，要先从自身找问题。总结两个原因吧，一个是新旧系统的迁移点太分散导致灰度不好控制，另一个是灰度开关忘记操作了，导致流量没有成功导到新系统上。这里要注意一个点就是在迁移过程中要尽可能的快速交付上线。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;问题 3：公司 Java 基础服务不够完善，很多基础平台没有支持怎么办?&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;于是自研了分布式延迟队列、分布式定时任务等组件，这里就不展开聊了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;问题 4：如何保证迁移过程中两个系统数据的一致性？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先我们前面讲到的是系统代码迁移，而数据存储不变，也就是说两个系统处理的数据会存在竞争，解决的办法是在处理时加上分布式锁，同时接口的处理也是要幂等的。这样即使在上下游系统做数据同步的时候也能避免竞争，保证数据的一致性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;就用户支付后支付结果同步到订单系统这一机制来说，采用推拉的机制。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;① 用户支付后订单主动轮询支付结果，则是在主动拉取数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;② 支付系统发出 MQ 消息被订单系统监听到，这是被动推送。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;③ 支付成功后触发的订单系统 HTTP 回调机制，这也是被动推送。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以上三种机制结合使用使得我们系统数据一致性有一个比较高的保障。我们要知道，一个系统绝非 100% 可靠，作为交易支付的核心链路，需要有多条机制保证数据的一致性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;问题 5：用户支付后没有收到会员权益是怎么回事？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在交易过程中，订单、支付、会员是三个独立的服务，如果订单丢失了支付的消息或者会员丢失了订单的消息都会导致用户收不到会员权益。上一个问题中已经讲到最终一致性同步机制，可能因为中间件或者网络故障导致消息无法同步，这时可以再增加一个补偿机制，通过定时任务扫描未完成的订单，主动检查支付状态后去会员业务履约，这是兜底策略，可保障数据的最终一致。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;业务沉淀&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从接收项目到现在也是对订单系统从懵懂到逐渐加深理解的一个过程，对于当前交易的业务和业务架构也有了一个理解。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;交易系统本身作为支付系统的上层系统，提供商品管理能力、交易收单能力、履约核销能力。外围业务子系统主要关注业务内容资源的管理。业务的收单履约管理接入交易系统即可，可减轻业务的开发复杂度。收单流程展示如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;业务定制商品详情页，然后通过详情页底栏调用端能力进入订单收银台。在这里客户端需要调用业务后端接口来获取商品详情，然后调用交易底栏的展示接口获取底部按钮的情况。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户通过底部按钮进入收银台后，在收银台可以选择支付方式和优惠券，点击确认支付调起微信或者支付宝付款。收银台展示以及获取支付参数的接口由交易系统提供。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;订单后台确认收款后会通知业务履约，用户端会回到详情页，用户在详情页进入内容播放页享受权益。履约核销流程是业务后端与交易系统后端的接口调用来完成的。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.693200663349917&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJrcfXyaZT7K80Q5wXsWMuegAADKfHOOQDicWU9etaXMoIMNhvdBqLyJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1206&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;现在知乎站内主要是虚拟商品的交易，一个通用的交易流程如下图：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7380281690140845&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJ9oyLRibzlAF9sWbbicMnSh3tkIE3w6oXrsUNtUicIGoEMoSzzdnZwKqyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1420&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;用户经历了从商品的浏览到进入收银台下单支付，再回到内容页消费内容。随着业务的发展，不同的交易场景和交易流程叠加，系统开始变得复杂，一个交易的业务架构慢慢呈现。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6779026217228464&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJ2VTxk3ibuJjQl8w1x0Nstdy8agrhcMCTibylLAO6epgiahsnIO0Fk1NTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2136&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;订单系统主要承载知乎站内站外的各种交易服务，提供稳定可靠的交易场景支撑。主要分为以下几个部分：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;首先产品服务层是面向用户能感受到的交互界面，提供对于这些页面的统一下单支付 API 网关。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;然后是订单服务层，由上层网关调用，提供着不同场景下的交易服务支撑。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;再往下是订单领域层，承载订单最核心逻辑代码，首先是用户购买需要的算价聚合，然后是管理订单模型的交易聚合，最后是买完商品后的履约处理的交付聚合。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;最底层是基础支撑服务层，主要是提供基本的服务支持以及交易依赖的一些服务。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;最后是运营服务，提供交易相关的后台功能支持。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;方法论实践&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;凡此以上，不论系统迁移方案还是架构理解都归结于参与人员的理解与认知，一个优秀的方案或合适的架构不是设计出来的，是迭代出来的。人的认知也是这样，需要不断的迭代升级，和很多的方法论一样，PDCA 循环为我们提炼了一个提升路径。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.985663082437276&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOO3NOzia3XAPaU46ThxHbBQJG5Qdab1H1Rdq44tUGSSiaL7H4GnofOgWNrz1Qp5jrAniccbfl7mIQkVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;279&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Plan 计划，明确我们迁移的目标，调研现状指定计划。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Do 执行，实现计划中的内容。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Check 检查，归纳总结，分析哪些做好了，还有什么问题。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Action 调整，总结经验教训，在下一个循环中解决。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;很多时候，也许你只做了前两步，但其实后两步对你的提升会有很大帮助。所以一个项目的复盘，一次 Code Review 很重要，有语言的交流和碰撞才更容易打破你的固有思维，做到业务认知的提升。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;参考文章&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://mp.weixin.qq.com/s/eKc8qoqNCgqrnont2nYNgA&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://zhuanlan.zhihu.com/p/138222300&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://blog.csdn.net/g6U8W7p06dCO99fQ3/article/details/103415254&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;招聘信息&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;知乎技术团队大量岗位持续招聘中，欢迎感兴趣的同学加入我们，可投简历至：&lt;span&gt;luohuijuan@zhihu.com&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;作者简介&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;42&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;张旭，知乎后端开发工程师，主要负责知乎商业基础相关系统研发，专注于电商交易营销领域。&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;参考阅读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;高可用架构欢迎技术架构领域原创文章，欢迎通过公众号菜单「联系我们」进行投稿。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.55546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8XkvNnTiapOMRvCRibd5Rxf4W9RY6pEILqJypJHyaNfBqIlzib26QKYtxgwGAeZcAhdFMYv3btF0DQwzD8Hh2a5gA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;2021年GIAC调整到7月30-31日在深圳举行，点击阅读原文了解更多详情。&lt;/span&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>