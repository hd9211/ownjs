<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>063d948a1c7e3b547fb05583d1e744b0</guid>
<title>CURD系统怎么做出技术含量惊艳面试官完善版</title>
<link>https://toutiao.io/k/2jsbhve</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引子&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;十几年前的一天，有段时间在读张爱玲的小说，同事看见了就说原来你爱看这种东西。我到现在都不知道他说的是哪种东西。那时候我只是单纯的觉得张爱玲写的东西有种特质，这种特质掌握了做什么事情都不会太差。后来我想明白了，这种特制叫做：善于运用技巧。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;举个例子，张爱玲有个神作《金锁记》，女主经历了不幸的一生心灵扭曲，害了儿女的一生。她女儿名字叫长安。女儿30岁了，终于有人上门提亲，她却说自己女儿怎么怎么不好，还抽大烟，最后吓跑了提亲的人。这时候是这么描写长安的：&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;55&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;长安悄悄的走下楼来,玄色花绣鞋与白丝袜停留在日色昏黄的楼梯上。停了一会,又上去了,一级一级,走进没有光的所在。&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;张爱玲施展她高超的绘画功力，手绘了一个电影中的分镜。不写长安的表情，不写她的心里，只给她的脚一个特写镜头。黑白的主体轮廓，昏黄的背景，画的尽头没有光，简直是野兽派画风的一幅画。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;镜头不动，只有人物的脚在动。整体包含三个画面：第一个画面是走下楼梯；第二个画面，停了一会儿，画外音：听到了提亲时的对话正好说到抽大烟的事；第三个画面是沉重的脚步走回了没有光的所在，那就是她的余生。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;此时无声胜有声，一切尽在不言中。&lt;/p&gt;&lt;p/&gt;&lt;h1&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485928&amp;amp;idx=1&amp;amp;sn=d60b63b554e5d1b054f273e898ed12c5&amp;amp;chksm=fafde346cd8a6a50fbf7d2d4b3eafc36ba356e161251504203465effcf187dc5368cff9f04b9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《CURD系统怎么做出技术含量--怎样引导面试》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;《CURD系统怎么做出技术含量--怎样引导面试》&lt;/a&gt;有朋友开玩笑说都用上了领域驱动了，就不叫CURD系统了吧。这里我解释一下，怕大家对DDD领域驱动设计有什么误解。&lt;/h1&gt;&lt;p&gt;DDD是为解决软件复杂性而生，但不仅仅可以被用于复杂的系统。它里面提到了很多技巧，其实&lt;span&gt;CURD就是其中一种技巧。这些技巧适用于任何系统，哪怕是非常小型的系统，比如&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485928&amp;amp;idx=1&amp;amp;sn=d60b63b554e5d1b054f273e898ed12c5&amp;amp;chksm=fafde346cd8a6a50fbf7d2d4b3eafc36ba356e161251504203465effcf187dc5368cff9f04b9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《CURD系统怎么做出技术含量--怎样引导面试》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span&gt;《CURD系统怎么做出技术含量--怎样引导面试》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;里提到的谦卑对象模型、充血模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;今天咱们再提高一下CURD系统的门槛，连DDD技巧，咱也不用。就用写咱们平时都在写的最简单的接口。能说明设计理念，也能惊艳到面试官：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;大纲&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;三种设计方法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;n+m返回值设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;概述&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;一个接口入参有n个值，需要的返回值是m个值。在返回值中可以把入参和返回值一起返回。&lt;/p&gt;&lt;p&gt;这种设计便于追踪和排查问题：&lt;/p&gt;&lt;p&gt;为了防止调用方没有日志追踪号、打印日志过多等原因造成不方便跟踪请求的问题，可以设计返回值将入参一起打印。这样调用方可以通过一条日志方便的获取到入参和返回值。线上排查问题会非常方便。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;建议使用场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;假设有个场景，调用方的系统设计不方便请求追踪，比如没有线程追踪号。在高并发量场景下可能日志是这样的：&lt;/p&gt;&lt;p&gt;1、thread-1|ClassName|参数1：11，参数2:11&lt;/p&gt;&lt;p&gt;2、thread-2|ClassName|参数1：22，参数2:22&lt;/p&gt;&lt;p&gt;3、thread-1|ClassName|参数1：33，参数2:33&lt;/p&gt;&lt;p&gt;4、thread-2|ClassName|返回值：44&lt;/p&gt;&lt;p&gt;5、thread-1|ClassName|返回值：55&lt;/p&gt;&lt;p&gt;6、thread-1|ClassName|返回值：66&lt;/p&gt;&lt;p&gt;你能决定55和66对应的谁是1，谁是3的返回值吗？&lt;/p&gt;&lt;p&gt;但是如果返回值包含了入参，就好办多了，举个返回值例子：&lt;/p&gt;&lt;p&gt;thread-1|ClassName|{参数1：11，参数2:11，返回值：55}&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这样就一目了然。有的时候可能是调用方本身的设计问题，但是如果被调用方能通过巧妙的设计帮助调用方。一旦遇到问题，调用方可以自己先进行排查，不用马上联系被调用方帮忙。即节约了自身的成本，又体现了专业性，何乐不为。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;不建议使用场景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;1、公司内有规范的、完善的、各个部门严格执行的全链路追踪标准&lt;/p&gt;&lt;p&gt;2、入参很大，不建议全量打印，可选取部分关键或者完全不用&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;终态设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484245&amp;amp;idx=1&amp;amp;sn=60bb5324704d43cfb0e72cb642ac4604&amp;amp;chksm=fafde9fbcd8a60edf8c96f162bfac9980c9623708bb03937969b25ef87eb4526d5a1f41aba26&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《实战并发-使用分布式缓存和有限状态机》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;《实战并发-使用分布式缓存和有限状态机》&lt;/a&gt;里我讲过有限状态自动机。有限状态机涉及状态流转。状态从分类上可以分成三种：初始状态、中间状态和终态。这段时间不是一直在讲TCP底层通信嘛，来一张TCP状态的流转图体会一下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1457905544147844&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;487&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9LBKNIvtzhGvak690hYJBokOn5mtWNNFSxAA3fS8p2n6Z1VBzuxic8r4vDNPtsY0nkHPokZ5LtkoA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;有限状态机的重点在于有限，要有起点和终点。也就是一定要有终态。在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484510&amp;amp;idx=1&amp;amp;sn=dbe4c622a7ef5d667f675420d5e4464c&amp;amp;chksm=fafdeef0cd8a67e64981d80c89c2c0a8fcb36177e5e19dcde180bc1e9718b577dce4d5d2d937&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《稳定性三十六计-超时处理》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《稳定性三十六计-超时处理》&lt;/a&gt;我讲过：&lt;/p&gt;&lt;p&gt;在传统的单机系统中，调用一个函数，要么返回成功，要么返回失败。这就是两态系统(2-state system)。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在分布式系统中，由于系统是分布在不同机器上的。还可能有一种状态叫：超时。成功、失败和超时是分布式系统调用的三态。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9903846153846154&quot; data-type=&quot;jpeg&quot; data-w=&quot;624&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicVYPeHOxevrQLEBUbDBBKiciaDnUCKK0N50iax8Y2X76Opom64icx9fJ01FGHpfACwXp46wDE51oU72w/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;超时不是终态，而是一种中间状态：最终有可能下游是成功了，也有可能是失败了。这时候我们需要在超时之后推定一种状态，推定成功或者失败。究竟是成功还是失败因功能而已。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;建议使用场景&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;比如付款操作，不知道是否成功就推定是成功的，那用户可能没有付款就拿到了商品或者享受了服务。商家就会资金损失。所以一般会推定失败。让用户再次支付。最终通过查询或者对账发现用户实际是支付成功的，可以再把钱给用户退回去，保证交易的公平性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;退款恰恰相反，需要推定成功。告诉用户，钱退给你了。最终通过查询或者对账发现实际是退款失败了，可以系统重新发起退款，直到真正退成功为止。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;后台管理系统也很需要这种终态设计。比如发布系统，发布了一个功能，发布系统如果出现了问题，这次发布没有结束。用户可能没有办法进行下一次发布。这时候可以设置超时自动结束，防止未结束的流程始终在那里，起码会干扰视线，增加判断成本。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;不建议使用场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这十几年的开发还没有遇到过什么场景不需要终态。但是有些终态是隐式的。举个例子：&lt;/p&gt;&lt;p&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485963&amp;amp;idx=1&amp;amp;sn=285f1bc91108e036bd4d4a1d5e1d244d&amp;amp;chksm=fafde0a5cd8a69b35572258dcd12f73218c3c72a7014e5c124b85078922bf5967605a4d867c4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《一个反直觉的sql》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《一个反直觉的sql》&lt;/a&gt;里提到的&lt;span&gt;&lt;strong&gt;事件溯源模式&lt;/strong&gt;&lt;/span&gt;，就是说比如在一张数据表中，只做数据记录用，只有插入操作没有更新操作。比如一个用户行为记录表，会记录用户什么时候登陆，因为用户是APP登陆的，所以2年都没有登出操作。是不是就没有终态呢？我们从这张表本身来看，因为是事件记录，所以落库的那一瞬间，状态就是“记录完成”，本身就是终态。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;两码一态&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;两码是指系统码和业务码，一态是说通过两码就可以确定最终的状态。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;很多情况下咱们是已经隐式的使用了两码一态，比如自己设计了一个单点登录接口给外部调用。一般是这样设计：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;实际上这个接口有个返回值，比如登录成功会返回用户信息或者直接返回&lt;span&gt;是否成功的布尔值&lt;/span&gt;。但是这个接口是给外部调用的，需要包装一层，最终就是返回&lt;span&gt;Re&lt;/span&gt;&lt;span&gt;sult&lt;/span&gt;&lt;span&gt;&amp;lt;User&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;或者Result&amp;lt;Boolean&amp;gt;。Result是怎么定义的呢？&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Data&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; Result&amp;lt;T&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;boolean&lt;/span&gt; isSuccess;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; errorCode;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; errorMessage;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; T data;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;有没有感觉和自己平时写的代码很像？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;分析一下：最外层isSuccess很多人都把它当成最终的状态来使用。比如在这个登录的场景下就代表了登录成功。但是如果isSuccess=true但是data==null？这就让人很迷惑，究竟是成功还是没有成功呢。成功了为啥我的数据没有吐给我？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;稍微合理一点的是&lt;span&gt;isSuccess&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;代表系统处理成功，就是没有抛出什么异常。究竟业务是否成功看data。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在更加规范的场合是这么定义的：&lt;/p&gt;&lt;pre&gt;&lt;br/&gt;&lt;span&gt;@Data&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public class &lt;/span&gt;Result&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; {&lt;br/&gt;    &lt;span&gt;private &lt;/span&gt;String &lt;span&gt;sysCode&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    private &lt;/span&gt;String &lt;span&gt;sysMessage&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    private &lt;/span&gt;String &lt;span&gt;bizCode&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    private &lt;/span&gt;String &lt;span&gt;bizMessage&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    private &lt;/span&gt;&lt;span&gt;T &lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;/pre&gt;&lt;p&gt;如果系统码sysCode为成功，是否业务成功需要看bizCode；如果sysCode失败，bizCode就不用看了，也很可能根本就没有拿到；如果sysCode为失败，看系统码是多少就可以定位问题范围，或者至少说这个问题开发人员应该查查；如果bizCode为失败，如果业务码也能定位问题范围，而这种问题一般不需要开发人员来处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;建议使用场景&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;比如后台管理系统中，可以定义：连接数据库异常、空指针异常等为系统失败，对两种异常分配不同的系统码，比如S001、S002；系统正常码可以分配S000；必填参数为空、参数校验失败为业务码，比如B001、B002；业务正常可以分配B000。最终状态由两个码共同决定。当系统码异常开发人员需要处理。当业务码异常可以联系运营人员培训一下怎么老填错或者不处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;比如我在之前的文章&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485988&amp;amp;idx=1&amp;amp;sn=efad5a030bc0a933ac5af2ee09f3c6c4&amp;amp;chksm=fafde08acd8a699c198d0d65c413273f05f2796cfd873160c2ba81ed3f33aebfaccb62234cb7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《一个http请求进来都经过了什么(2021版)》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《一个http请求进来都经过了什么(2021版)》&lt;/a&gt;中设立过一个场景&lt;/p&gt;&lt;p&gt;假设我在超市买了我喜爱的经典搭配：烤肠+酸奶。然后我就微信扫码付款了。付款时序图大体是这样的：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.734533183352081&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicwyMoVfkKaltdY7gIqsowo8keN6ic7ibzrHZZWVGq0eo5aNOxU5OXdFUNMMoqkq8g5Z2qol66SA9gg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;不用理解这个图，关系不大。我要说的是像支付这种场景后面会涉及多个环节，比如微信支付自身还要调用银行呢。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这时候的系统码和状态码中可以加一位，代表那个环节。比如系统码定义：&lt;/p&gt;&lt;p&gt;WS000、&lt;span&gt;W&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt;001……&lt;span&gt;BS&lt;/span&gt;&lt;span&gt;000&lt;/span&gt;&lt;span&gt;、B&lt;/span&gt;&lt;span&gt;S001&lt;/span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;S代表系统。W代表微信，比如下游请求银行，银行处理成功了，自身异常了，会设置这个码；B代表银行，比如银行自身异常了会设置这个码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同理，业务码&lt;span&gt;定义&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;WB&lt;/span&gt;&lt;span&gt;00&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;WB&lt;/span&gt;&lt;span&gt;001……&lt;span&gt;BB&lt;/span&gt;&lt;span&gt;000&lt;/span&gt;&lt;span&gt;、BB&lt;/span&gt;&lt;span&gt;001&lt;/span&gt;……&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;第二个B代表业务。W代表微信，比如自身校验没有通过，根本不会请求银行，会设置这个码；第一个B代表银行，比如银行最后发现用户余额不足会设置这个码。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;不建议使用场景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如果是给一个进程内部自身使用的，当然就没有必要定义这么复杂。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>03095fd1ea30d853a5feeb96e74f87ac</guid>
<title>​Golang 并发编程指南</title>
<link>https://toutiao.io/k/adoo89l</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：dcguo，腾讯 CSIG 电子签开放平台中心&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;分享 Golang 并发基础库，扩展以及三方库的一些常见问题、使用介绍和技巧，以及对一些并发库的选择和优化探讨。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;go 原生/扩展库&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;提倡的原则&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要通过共享内存进行通信;相反，通过通信来共享内存。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Goroutine&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;goroutine 并发模型&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;调度器主要结构&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要调度器结构是 M，P，G&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;M，内核级别线程，goroutine 基于 M 之上，代表执行者，底层线程，物理线程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;P，处理器，用来执行 goroutine，因此维护了一个 goroutine 队列，里面存储了所有要执行的 goroutine，将等待执行的 G 与 M 对接，它的数目也代表了真正的并发度( 即有多少个 goroutine 可以同时进行 )；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;G，goroutine 实现的核心结构，相当于轻量级线程，里面包含了 goroutine 需要的栈，程序计数器，以及所在 M 的信息&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;P 的数量由环境变量中的 GOMAXPROCS 决定，通常来说和核心数对应。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;映射关系&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户空间线程和内核空间线程映射关系有如下三种:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;N:1&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;1:1&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;M:N&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;调度图&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关系如图，灰色的 G 则是暂时还未运行的，处于就绪态，等待被调度，这个队列被 P 维护&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavYvtWT99MRVkXmGaGLiaAK2WL31ZM4xF0G7ux5yEiafmhF2sDl0bB5gp3IQJxjtoddJYW3a1RcI4HQ/640?wx_fmt=jpeg&quot; data-cropx1=&quot;12.24170616113744&quot; data-cropx2=&quot;738&quot; data-cropy1=&quot;13.990521327014218&quot; data-cropy2=&quot;641.8151658767772&quot; data-ratio=&quot;0.8663911845730028&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavYvtWT99MRVkXmGaGLiaAK2754ibbyib5MZzMC6W1UH3j4El7TUNV9oe8mvUibia9FYBMAicqcvYIemibibw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;726&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注:&lt;/strong&gt; 简单调度图如上，有关于 P 再多个 M 中切换，公共 goroutine 队列，M 从线程缓存中创建等步骤没有体现，复杂过程可以参考文章简单了解 &lt;a href=&quot;##%E5%8F%82%E8%80%83&quot;&gt;goroutine 如何实现&lt;/a&gt;。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;goroutine 使用&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;demo1&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; list.Sort()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;demo2&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Announce&lt;/span&gt;&lt;span&gt;(message &lt;span&gt;string&lt;/span&gt;, delay time.Duration)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        time.Sleep(delay)&lt;br/&gt;        fmt.&lt;span&gt;println&lt;/span&gt;(message)&lt;br/&gt;    }()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;channel&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;channel 特性&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;创建&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 创建 channel&lt;/span&gt;&lt;br/&gt;a := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;b := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;// 单向 channel&lt;/span&gt;&lt;br/&gt;c := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt;&amp;lt;- &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;d := &lt;span&gt;make&lt;/span&gt;(&amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;存入/读取/关闭&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20519159456118666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavYvtWT99MRVkXmGaGLiaAK2HaM8cicRPRy49N7yUIOV1HicDicd24f9NGJpAX61qMsbe4iaDichtdKecMA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1618&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;tip:&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;v, ok := &amp;lt;-a  &lt;span&gt;// 检查是否成功关闭(ok = false：已关闭)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;channel 使用/基础&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;use channel&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;ci := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;cj := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;cs := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; *os.File, &lt;span&gt;100&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;c := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    list.Sort()&lt;br/&gt;    c &amp;lt;- &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;}()&lt;br/&gt;doSomethingForValue&lt;br/&gt;&amp;lt;- c&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Server&lt;/span&gt;&lt;span&gt;(queue &lt;span&gt;chan&lt;/span&gt; *Request)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; req := &lt;span&gt;range&lt;/span&gt; queue {&lt;br/&gt;      sem &amp;lt;- &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;            process(req)&lt;br/&gt;            &amp;lt;- sem&lt;br/&gt;        }()&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Server&lt;/span&gt;&lt;span&gt;(queue &lt;span&gt;chan&lt;/span&gt; *Requet)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; req := &lt;span&gt;range&lt;/span&gt; queue {&lt;br/&gt;      sem &amp;lt;- &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(req *Request)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;          process(req)&lt;br/&gt;            &amp;lt;- sem&lt;br/&gt;        }(req)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Serve&lt;/span&gt;&lt;span&gt;(queue &lt;span&gt;chan&lt;/span&gt; *Request)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; req := &lt;span&gt;range&lt;/span&gt; queue {&lt;br/&gt;        req := req&lt;br/&gt;        sem &amp;lt;- &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;            process(req)&lt;br/&gt;          &amp;lt;-sem&lt;br/&gt;        }()&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;channel 使用/技巧&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;等待一个事件，也可以通过 close 一个 channel 就足够了。&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;c := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// close 的 channel 会读到一个零值&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;close&lt;/span&gt;(c)&lt;br/&gt;}()&lt;br/&gt;&amp;lt;-c&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;阻塞程序&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开源项目【是一个支持集群的 im 及实时推送服务】里面的基准测试的案例&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.648331830477908&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavYvtWT99MRVkXmGaGLiaAK2EDc9a69aslicKiaIZNe4T98LBPQmxam5jKJaQEtGDhS1tEg7HV93Gtwg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1109&quot;/&gt;&lt;/figure&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;取最快结果&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; ret := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;cap&lt;/span&gt;(ret); i++ {&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; call(ret)&lt;br/&gt; }&lt;br/&gt;    fmt.Println(&amp;lt;-ret)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;call&lt;/span&gt;&lt;span&gt;(ret &lt;span&gt;chan&lt;/span&gt;&amp;lt;- &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// do something&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt; ret &amp;lt;- &lt;span&gt;&quot;result&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;协同多个 goroutines&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注:&lt;/strong&gt; 协同多个 goroutines 方案很多，这里只展示 channel 的一种。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;limits := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{}, &lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 缓冲区满了就会阻塞在这&lt;/span&gt;&lt;br/&gt;  limits &amp;lt;- &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt;  do()&lt;br/&gt;  &amp;lt;-limits&lt;br/&gt; }()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;搭配 select 操作&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; a := &amp;lt;- testChanA:&lt;br/&gt;        &lt;span&gt;// todo a&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; b, ok := testChanB:&lt;br/&gt;        &lt;span&gt;// todo b, 通过 ok 判断 tesChanB 的关闭情况&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;// 默认分支&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;main go routinue 确认 worker goroutinue 真正退出的方式&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;worker&lt;/span&gt;&lt;span&gt;(testChan &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;     &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// todo some&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// case ...&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &amp;lt;- testChan:&lt;br/&gt;         testChan &amp;lt;- &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;     }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    testChan := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;go&lt;/span&gt; worker(testChan)&lt;br/&gt;    testChan &amp;lt;- &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;    &amp;lt;- testChan&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;关闭的 channel 不会被阻塞&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;testChan := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;close&lt;/span&gt;(testChan)&lt;br/&gt;&lt;br/&gt;zeroValue := &amp;lt;- testChan&lt;br/&gt;fmt.Println(zeroValue) &lt;span&gt;// false&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;testChan &amp;lt;- &lt;span&gt;true&lt;/span&gt; &lt;span&gt;// panic: send on closed channel&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注:&lt;/strong&gt; 如果是 &lt;code&gt;buffered channel&lt;/code&gt;, 即使被 close, 也可以读到之前存入的值，读取完毕后开始读零值，写入则会触发 panic&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;nil channel 读取和存入都不会阻塞，close 会 panic&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;略&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;range 遍历 channel&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;br/&gt;c := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt;  c &amp;lt;- i&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;close&lt;/span&gt;(c)&lt;br/&gt;}()&lt;br/&gt;&lt;span&gt;// 当 c 被关闭后，取完里面的元素就会跳出循环&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; x := &lt;span&gt;range&lt;/span&gt; c {&lt;br/&gt; fmt.Println(x)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;例: 唯一 id&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;newUniqueIdService&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; id := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; counter &lt;span&gt;int64&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;   id &amp;lt;- fmt.Sprintf(&lt;span&gt;&quot;%x&quot;&lt;/span&gt;, counter)&lt;br/&gt;   counter += &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt; }()&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; id&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;newUniqueIdServerMain&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; id := newUniqueIdService()&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt;  fmt.Println(&amp;lt;- id)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;带缓冲队列构造&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;略&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;超时 timeout 和心跳 heart beat&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;超时控制&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; done := do()&lt;br/&gt; &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &amp;lt;-done:&lt;br/&gt;  &lt;span&gt;// logic&lt;/span&gt;&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &amp;lt;-time.After(&lt;span&gt;3&lt;/span&gt; * time.Second):&lt;br/&gt;  &lt;span&gt;// timeout&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;demo&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;开源 im/goim 项目中的应用&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6190053285968028&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavYvtWT99MRVkXmGaGLiaAK2wq45RIub3diaRxlfY1WCqe2YLNAc5mqs1x6t185zTiaNtVRibXofzibSuQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1126&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;心跳&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;done := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;close&lt;/span&gt;(done)&lt;br/&gt; }()&lt;br/&gt; ticker := time.NewTicker(&lt;span&gt;10&lt;/span&gt; * time.Second)&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; &amp;lt;-done:&lt;br/&gt;    ticker.Stop()&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; &amp;lt;-ticker.C:&lt;br/&gt;    message.Touch()&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;多个 goroutine 同步响应&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; c := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{})&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;5&lt;/span&gt;; i++ {&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; do(c)&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;close&lt;/span&gt;(c)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;&lt;span&gt;(c &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 会阻塞直到收到 close&lt;/span&gt;&lt;br/&gt; &amp;lt;-c&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;hello&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;利用 channel 阻塞的特性和带缓冲的 channel 来实现控制并发数量&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;channel&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    count := &lt;span&gt;10&lt;/span&gt; &lt;span&gt;// 最大并发&lt;/span&gt;&lt;br/&gt; sum := &lt;span&gt;100&lt;/span&gt;  &lt;span&gt;// 总数&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    c := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{}, count)&lt;br/&gt;    sc := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{}, sum)&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(c)&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(sc)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i:=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;sum; i++ {&lt;br/&gt;        c &amp;lt;- &lt;span&gt;struct&lt;/span&gt;{}&lt;br/&gt;        &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(j &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;            fmt.Println(j)&lt;br/&gt;            &amp;lt;- c &lt;span&gt;// 执行完毕，释放资源&lt;/span&gt;&lt;br/&gt;            sc &amp;lt;- &lt;span&gt;struct&lt;/span&gt; {}{} &lt;span&gt;// 记录到执行总数&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i:=sum; i&amp;gt;&lt;span&gt;0&lt;/span&gt;; i++ {&lt;br/&gt;        &amp;lt;- sc&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;go 并发编程(基础库)&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这块东西为什么放到 channel 之后，因为这里包含了一些低级库，实际业务代码中除了 context 之外用到都较少(比如一些锁 mutex，或者一些原子库 atomic)，实际并发编程代码中可以用 channel 就用 channel，这也是 go 一直比较推崇得做法 &lt;code&gt;Share memory by communicating; don’t communicate by sharing memory&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Mutex/RWMutex&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;锁，使用简单，保护临界区数据&lt;/p&gt;&lt;p&gt;使用的时候注意锁粒度，每次加锁后都要记得解锁&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Mutex demo&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;sync&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; mutex sync.Mutex&lt;br/&gt; wait := sync.WaitGroup{}&lt;br/&gt;&lt;br/&gt; now := time.Now()&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= &lt;span&gt;3&lt;/span&gt;; i++ {&lt;br/&gt;  wait.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(i &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   mutex.Lock()&lt;br/&gt;   time.Sleep(time.Second)&lt;br/&gt;   mutex.Unlock()&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wait.Done()&lt;br/&gt;  }(i)&lt;br/&gt; }&lt;br/&gt; wait.Wait()&lt;br/&gt; duration := time.Since(now)&lt;br/&gt; fmt.Print(duration)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;结果:&lt;/strong&gt; 可以看到整个执行持续了 3 s 多，内部多个协程已经被 “锁” 住了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.26744186046511625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavYvtWT99MRVkXmGaGLiaAK2UylbnzCia52Dxz5Jq9gt4ao3VThTry9MsRTgDBbo7cN8hdZ6Ggo2f8Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;516&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;RWMutex demo&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意:&lt;/strong&gt; 这东西可以并发读，不可以并发读写/并发写写，不过现在即便场景是读多写少也很少用到这，一般集群环境都得分布式锁了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;sync&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; m *sync.RWMutex&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; m = &lt;span&gt;new&lt;/span&gt;(sync.RWMutex)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; read()&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; read()&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; write()&lt;br/&gt;&lt;br/&gt; time.Sleep(time.Second * &lt;span&gt;3&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; m.RLock()&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;startR&quot;&lt;/span&gt;)&lt;br/&gt; time.Sleep(time.Second)&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;endR&quot;&lt;/span&gt;)&lt;br/&gt; m.RUnlock()&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; m.Lock()&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;startW&quot;&lt;/span&gt;)&lt;br/&gt; time.Sleep(time.Second)&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;endW&quot;&lt;/span&gt;)&lt;br/&gt; m.Unlock()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;输出:&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.92578125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavYvtWT99MRVkXmGaGLiaAK2Kiakefr7R9AMD7j8FhYIeVbialQBYlAhzsG6UXVenIWR8G1AEC1vsASw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;256&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Atomic&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;可以对简单类型进行原子操作&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;int32&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;int64&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;uint32&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;uint64&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;uintptr&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;unsafe.Pointer&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;可以进行得原子操作如下&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;增/减&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;比较并且交换&lt;/p&gt;&lt;p&gt;假定被操作的值未曾被改变, 并一旦确定这个假设的真实性就立即进行值替换&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;载入&lt;/p&gt;&lt;p&gt;为了原子的读取某个值(防止写操作未完成就发生了一个读操作)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储&lt;/p&gt;&lt;p&gt;原子的值存储函数&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;交换&lt;/p&gt;&lt;p&gt;原子交换&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;demo:增&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;sync&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;sync/atomic&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; sum &lt;span&gt;uint64&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; wg sync.WaitGroup&lt;br/&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++ {&lt;br/&gt;  wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; c := &lt;span&gt;0&lt;/span&gt;; c &amp;lt; &lt;span&gt;100&lt;/span&gt;; c++ {&lt;br/&gt;    atomic.AddUint64(&amp;amp;sum, &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;  }()&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; wg.Wait()&lt;br/&gt; fmt.Println(sum)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;结果:&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3463203463203463&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavYvtWT99MRVkXmGaGLiaAK2fnRSzrvvvAficJDWfzZ2LJC7yhvBFFBV2KvQSxSSeiaJJ0Ih4qSnOZQA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;462&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;WaitGroup/ErrGroup&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;pre&gt;&lt;code&gt;waitGroup 是一个 waitGroup 对象可以等待一组 goroutinue 结束，但是他对错误传递，goroutinue 出错时不再等待其他 goroutinue(减少资源浪费) 都不能很好的解决，那么 errGroup 可以解决这部分问题&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;errGroup 中如果多个 goroutinue 错误，只会获取第一个出错的 goroutinue 的错误信息，后面的则不会被感知到；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;errGroup 里面没有做 panic 处理，代码要保持健壮&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;demo: errGroup&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;golang.org/x/sync/errgroup&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;net/http&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; g errgroup.Group&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; urls = []&lt;span&gt;string&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;&quot;https://github.com/&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;errUrl&quot;&lt;/span&gt;,&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, url := &lt;span&gt;range&lt;/span&gt; urls {&lt;br/&gt;  url := url&lt;br/&gt;  g.Go(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   resp, err := http.Get(url)&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    _ = resp.Body.Close()&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt; err := g.Wait()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  log.Fatal(&lt;span&gt;&quot;getErr&quot;&lt;/span&gt;, err)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;结果:&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1609702315325248&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavYvtWT99MRVkXmGaGLiaAK2gWGxzW19FhkgHMjUs16UuhVT1g7jpFveEx7FKCebxN1icdRhlV8myVQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;907&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;once&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;保证了传入的函数只会执行一次，这常用在单例模式，配置文件加载，初始化这些场景下。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;demo:&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;times := &lt;span&gt;10&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; (&lt;br/&gt;  o  sync.Once&lt;br/&gt;  wg sync.WaitGroup&lt;br/&gt; )&lt;br/&gt; wg.Add(times)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; times; i++ {&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(i &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;   o.Do(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    fmt.Println(i)&lt;br/&gt;   })&lt;br/&gt;  }(i)&lt;br/&gt; }&lt;br/&gt; wg.Wait()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;结果:&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24153498871331827&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavYvtWT99MRVkXmGaGLiaAK26gmEy40rwttKMzDXFWnHVlPScEwXUX9EEGaAb6Rkv0vPUX6qnmQAsg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;443&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Context&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;go 开发已经对他了解了太多&lt;/p&gt;&lt;p&gt;可以再多个 goroutinue 设置截止日期，同步信号，传递相关请求值&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对他的说明文章太多了，详细可以跳转看这篇 &lt;a href=&quot;https://km.woa.com/articles/show/426551?kmref=search&amp;amp;from_page=1&amp;amp;no=3&quot; data-linktype=&quot;2&quot;&gt;一文理解 golang context&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这边列一个遇到得问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;grpc 多服务调用，级联 cancel&lt;/p&gt;&lt;p&gt;A -&amp;gt; B -&amp;gt; C&lt;/p&gt;&lt;p&gt;A 调用 B，B 调用 C，当 A 不依赖 B 请求 C 得结果时，B 请求 C 之后直接返回 A，那么 A，B 间 context 被 cancel，而 C 得 context 也是继承于前面，C 请求直接挂掉，只需要重新搞个 context 向下传就好，记得带上 reqId, logId 等必要信息。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;并行&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;某些计算可以再 CPU 之间并行化，如果计算可以被划分为不同的可独立执行的部分，那么他就是可并行化的，任务可以通过一个 channel 发送结束信号。&lt;/p&gt;&lt;p&gt;假如我们可以再数组上进行一个比较耗时的操作，操作的值在每个数据上独立，如下:&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; vector []&lt;span&gt;float64&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(v vector)&lt;/span&gt; &lt;span&gt;DoSome&lt;/span&gt;&lt;span&gt;(i, n &lt;span&gt;int&lt;/span&gt;, u Vector, c &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; ; i &amp;lt; n; i ++ {&lt;br/&gt;        v[i] += u.Op(v[i])&lt;br/&gt;    }&lt;br/&gt;    c &amp;lt;- &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以再每个 CPU 上进行循环无关的迭代计算，我们仅需要创建完所有的 goroutine 后，从 channel 中读取结束信号进行计数即可。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;并发编程/工作流方案扩展&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这部分如需自己开发，内容其实可以分为两部分能力去做&lt;/p&gt;&lt;p&gt;需要去解决一些基础问题&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;并发编程:&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;启动 goroutine 时，增加防止程序 panic 能力&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;去封装一些更简单的错误处理方案，比如支持多个错误返回&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;限定任务的 goroutine 数量&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;工作流:&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在每个工作流执行到下一步前先去判断上一步的结果&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;工作流内嵌入一些拦截器&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;singlelFlight(go 官方扩展同步包)&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;一般系统重要的查询增加了缓存后，如果遇到缓存击穿，那么可以通过任务计划，加索等方式去解决这个问题，singleflight 这个库也可以很不错的应对这种问题。&lt;/p&gt;&lt;p&gt;它可以获取第一次请求得结果去返回给相同得请求
核心方法 &lt;code&gt;Do&lt;/code&gt; 执行和返回给定函数的值，确保某一个时间只有一个方法被执行。&lt;br/&gt;如果一个重复的请求进入，则重复的请求会等待前一个执行完毕并获取相同的数据，返回值 shared 标识返回值 v 是否是传递给重复的调用请求。&lt;/p&gt;&lt;p&gt;一句话形容他的功能，它可以用来归并请求，但是最好加上超时重试等机制，防止第一个 &lt;code&gt;执行&lt;/code&gt; 得请求出现超时等异常情况导致同时间大量请求不可用。&lt;/p&gt;&lt;p&gt;场景: 数据变化量小(key 变化不频繁，重复率高)，但是请求量大的场景&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;demo&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;golang.org/x/sync/singleflight&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;math/rand&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;sync&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; (&lt;br/&gt; g singleflight.Group&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; (&lt;br/&gt; funcKey = &lt;span&gt;&quot;key&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; times = &lt;span&gt;5&lt;/span&gt;&lt;br/&gt; randomNum = &lt;span&gt;100&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; rand.Seed(time.Now().UnixNano())&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; wg sync.WaitGroup&lt;br/&gt; wg.Add(times)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; times; i++ {&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;   num, err := run(funcKey)&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    log.Fatal(err)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   log.Println(num)&lt;br/&gt;  }()&lt;br/&gt; }&lt;br/&gt; wg.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(num &lt;span&gt;int&lt;/span&gt;, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; v, err, isShare := g.Do(key, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(&lt;span&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  time.Sleep(time.Second * &lt;span&gt;5&lt;/span&gt;)&lt;br/&gt;  num = rand.Intn(randomNum) &lt;span&gt;//[0,100)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; num, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; })&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  log.Fatal(err)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt; data := v.(&lt;span&gt;int&lt;/span&gt;)&lt;br/&gt; log.Println(isShare)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; data, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;连续执行 3 次，返回结果如下，全部取了共享得结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.8753180661577606&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavYvtWT99MRVkXmGaGLiaAK21oibsxqvxIwxBr8yMibwmFzUhQQKGHibzTaTsIPwJMcFAdAictFRZc4wPw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;393&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是注释掉 &lt;code&gt;time.Sleep(time.Second * 5)&lt;/code&gt; 再尝试一次看看。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8963730569948186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavYvtWT99MRVkXmGaGLiaAK2VzWKtCRoqOxxkBl5TCInGvjbvKSgFGibhR8CQywywNwtibRLpx5O9XKw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;386&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次全部取得真实值&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;实践:&lt;/strong&gt; 伙伴部门高峰期可以减少 20% 的 Redis 调用, 大大减少了 Redis 的负载&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实践&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;开发案例&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注:&lt;/strong&gt; 下面用到的方案因为开发时间较早，并不一定是以上多种方案中最优的，选择有很多种，使用那种方案只有有所考虑可以自圆其说即可。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;建议:&lt;/strong&gt; 项目中逐渐形成统一解决方案，从混乱到统一，逐渐小团队内对此类逻辑形成统一的一个解决标准，而不是大家对需求之外的控制代码写出各式各样的控制逻辑。&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;批量校验&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;场景&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;批量校验接口限频单账户最高 100qps/s，整个系统多个校验场景公用一个账户&lt;/p&gt;&lt;p&gt;限频需要限制批量校验最高为 50~80 qps/s(需要预留令牌供其他场景使用，否则频繁调用批量接口时候其他场景均会失败限频)。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;设计&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用 go routine 来并发进行三要素校验，因为 go routinue，所以每次开启 50 ~ 80 go routine 同时进行单次三要素校验；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;每轮校验耗时 1s，如果所有 routinue 校验后与校验开始时间间隔不满一秒，则需要主动程序睡眠至 1s，然后开始下轮校验；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;因为只是校验场景，如果某次校验失败，最容易的原因其实是校验方异常，或者被其他校验场景再当前 1s 内消耗过多令牌；&lt;/p&gt;&lt;p&gt;那么整个批量接口返回 err，运营同学重新发起就好。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;代码&lt;/p&gt;&lt;p&gt;代码需要进行的优化点：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;加锁(推荐使用，最多不到 100 的竞争者数目，使用锁性能影响微乎其微)；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;给每个传入 routine 的 element 数组包装，增加一个 key 属性，每个返回的 result 包含 key
通过 key 映射可以得到需要的一个顺序。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;sleep 1s 这个操作可以从调用前开始计时，调用完成后不满 1s 补充至 1s，而不是每次最长调用时间 elapsedTime + 1s；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通道中获取的三要素校验结果顺序和入参数据数组顺序不对应，这里通过两种方案：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;分组调用 getElementResponseConcurrent 方法时，传入切片可以省略部分计算，直接使用切片表达式。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3765527950310559&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavYvtWT99MRVkXmGaGLiaAK2eu5GOZe7IibcgyEltox1r5lOlibH7yj0G1RFtfbhSlOIuALcoibA33Zqg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1288&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;elementNum := &lt;span&gt;len&lt;/span&gt;(elements)&lt;br/&gt;m := elementNum / &lt;span&gt;80&lt;/span&gt;&lt;br/&gt;n := elementNum % &lt;span&gt;80&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; m &amp;lt; &lt;span&gt;1&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; results, err := getElementResponseConcurrent(ctx, elements, conn, caller); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                response.Results = results&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; response, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        results := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int64&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; n != &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;                m = m + &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; result []&lt;span&gt;int64&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= m; i++ {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; i == m {&lt;br/&gt;                        result, err = getElementResponseConcurrent(ctx, elements[(i&lt;span&gt;-1&lt;/span&gt;)*&lt;span&gt;80&lt;/span&gt;:(i&lt;span&gt;-1&lt;/span&gt;)*&lt;span&gt;80&lt;/span&gt;+n], conn, caller)&lt;br/&gt;                } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                        result, err = getElementResponseConcurrent(ctx, elements[(i&lt;span&gt;-1&lt;/span&gt;)*&lt;span&gt;80&lt;/span&gt;:i*&lt;span&gt;80&lt;/span&gt;], conn, caller)&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt;                }&lt;br/&gt;                results = &lt;span&gt;append&lt;/span&gt;(results, result...)&lt;br/&gt;        }&lt;br/&gt;        response.Results = results&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// getElementResponseConcurrent&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;getElementResponseConcurrent&lt;/span&gt;&lt;span&gt;(ctx context.Context, elements []*api.ThreeElements, conn *grpc.ClientConn,&lt;br/&gt;        caller *api.Caller)&lt;/span&gt; &lt;span&gt;([]&lt;span&gt;int64&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        results := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int64&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; chResult = &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt;)&lt;br/&gt;        chanErr := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; error)&lt;br/&gt;        &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(chanErr)&lt;br/&gt;        wg := sync.WaitGroup{}&lt;br/&gt;&lt;br/&gt;        faceIdClient := api.NewFaceIdClient(conn)&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; _, element := &lt;span&gt;range&lt;/span&gt; elements {&lt;br/&gt;                wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(element *api.ThreeElements)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;                        param := element.Param&lt;br/&gt;                        verificationRequest := &amp;amp;api.CheckMobileVerificationRequest{&lt;br/&gt;                                Caller:       caller,&lt;br/&gt;                                Param:        param,&lt;br/&gt;                        }&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; verification, err := faceIdClient.CheckMobileVerification(ctx, verificationRequest); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;                                chanErr &amp;lt;- err&lt;br/&gt;                                &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;                        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                                result := verification.Result&lt;br/&gt;                                chanErr &amp;lt;- &lt;span&gt;nil&lt;/span&gt; &lt;br/&gt;                                chResult &amp;lt;- result&lt;br/&gt;                        }&lt;br/&gt;                        &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;                }(element)&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;len&lt;/span&gt;(elements); i++ {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; err := &amp;lt;-chanErr; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;var&lt;/span&gt; result = &amp;lt;-chResult&lt;br/&gt;                results = &lt;span&gt;append&lt;/span&gt;(results, result)&lt;br/&gt;        }&lt;br/&gt;        wg.Wait()&lt;br/&gt;        time.Sleep(time.Second)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; results, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;历史数据批量标签&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;场景:&lt;/strong&gt; 产品上线一年，逐步开始做数据分析和统计需求提供给运营使用，接入 Tdw 之前是直接采用接口读历史表进行的数据分析，涉及全量用户的分析给用户记录打标签，数据效率较低，所以采用并发分组方法，考虑协程比较轻量，从开始上线时间节点截止当前时间分共 100 组，代码较为简单。&lt;/p&gt;&lt;p&gt;问题: 本次接口不是上线最终版，核心分析方法仅测试环境少量数据就会有 N 多条慢查询，所以这块还需要去对整体资源业务背景问题去考虑，防止线上数据量较大还有慢查询出现 cpu 打满。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5e250015b75462f4a9053b907b9acbfd</guid>
<title>分布式锁用Redis好？还是Zookeeper好？</title>
<link>https://toutiao.io/k/dliy2zu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过目前互联网项目越来越多的项目采用集群部署，也就是分布式情况，这两种锁就有些不够用了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来两张图举例说明下，本地锁的情况下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6891891891891891&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLn5KdSrodIRt9JZ61sjZSc1wYc9YoUAWNbEfiau0VzGGd3STmtHPMe1vQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;592&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式锁情况下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5166163141993958&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLnzia31jH6lMRCKkPwJBFQ6x3WvX3uiaRJ50tsRc4HobC4ZCJU7q2u771w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;662&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就其思想来说，就是一种“我全都要”的思想，所有服务都到一个统一的地方来取锁，只有取到锁的才能继续执行下去。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.539440203562341&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLnuDDxL5hD60aq2Z3R0mYJZgBQicIdha8cr704sOian7y1gopppAZqXapQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;393&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说完思想，下面来说一下具体的实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为实现分布式锁，在 Redis 中存在 &lt;code&gt;SETNX key value&lt;/code&gt; 命令，意为 &lt;code&gt;set if not exists&lt;/code&gt;（如果不存在该 key，才去 set 值），就比如说是张三去上厕所，看厕所门锁着，他就不进去了，厕所门开着他才去。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.22657952069716775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLngSF64JxibJlXgjHYmmGleA9TcQQbTdrdWDtn7fgeia9dfIseibr5uxHXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;459&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，第一次 set 返回了 1，表示成功，但是第二次返回 0，表示 set 失败，因为已经存在这个 key 了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然只靠 setnx 这个命令可以吗？当然是不行的，试想一种情况，张三在厕所里，但他在里面一直没有释放，一直在里面蹲着，那外面人想去厕所全部都去不了，都想锤死他了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 同理，假设已经进行了加锁，但是因为宕机或者出现异常未释放锁，就造成了所谓的“死锁”。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9063829787234042&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLnwM8cSicdKUa7R30GLDfkTAK2OUpa7EPdicKpVStgJJmKZIV5IIPF6b3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;235&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;聪明的你们肯定早都想到了，为它设置过期时间不就好了，可以 &lt;code&gt;SETEX key seconds value&lt;/code&gt; 命令，为指定 key 设置过期时间，单位为秒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这样又有另一个问题，我刚加锁成功，还没设置过期时间，Redis 宕机了不就又死锁了，所以说要保证原子性吖，要么一起成功，要么一起失败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然我们能想到的 Redis 肯定早都为你实现好了，在 Redis 2.8 的版本后，Redis 就为我们提供了一条组合命令 &lt;code&gt;SET key value ex seconds nx&lt;/code&gt;，加锁的同时设置过期时间。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2768670309653916&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLnZyXGRgcvmUPhpgMXcE96w55AiaBDMnPNV32ic6qV9pIaF2vAhoNvy9Nw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;549&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就好比是公司规定每人最多只能在厕所呆 2 分钟，不管释放没释放完都得出来，这样就解决了“死锁”问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这样就没有问题了吗？怎么可能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;试想又一种情况，厕所门肯定只能从里面开啊，张三上完厕所后张四进去锁上门，但是外面人以为还是张三在里面，而且已经过了 3 分钟了，就直接把门给撬开了，一看里面却是张四，这就很尴尬啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换成 Redis 就是说比如一个业务执行时间很长，锁已经自己过期了，别人已经设置了新的锁，但是当业务执行完之后直接释放锁，就有可能是删除了别人加的锁，这不是乱套了吗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在加锁时候，要设一个随机值，在删除锁时进行比对，如果是自己的锁，才删除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多说无益，烦人，直接上代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//基于jedis和lua脚本来实现&lt;/span&gt;&lt;br/&gt;privatestaticfinal String LOCK_SUCCESS = &lt;span&gt;&quot;OK&quot;&lt;/span&gt;;&lt;br/&gt;privatestaticfinal Long RELEASE_SUCCESS = &lt;span&gt;1L&lt;/span&gt;;&lt;br/&gt;privatestaticfinal String SET_IF_NOT_EXIST = &lt;span&gt;&quot;NX&quot;&lt;/span&gt;;&lt;br/&gt;privatestaticfinal String SET_WITH_EXPIRE_TIME = &lt;span&gt;&quot;PX&quot;&lt;/span&gt;;&lt;br/&gt; &lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;acquire&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 获取锁的超时时间，超过这个时间则放弃获取锁&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; end = System.currentTimeMillis() + acquireTimeout;&lt;br/&gt;        &lt;span&gt;// 随机生成一个 value&lt;/span&gt;&lt;br/&gt;        String requireToken = UUID.randomUUID().toString();&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (System.currentTimeMillis() &amp;lt; end) {&lt;br/&gt;            String result = jedis&lt;br/&gt;                .set(lockKey, requireToken, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (LOCK_SUCCESS.equals(result)) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; requireToken;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                Thread.currentThread().interrupt();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        log.error(&lt;span&gt;&quot;acquire lock due to error&quot;&lt;/span&gt;, e);&lt;br/&gt;    }&lt;br/&gt; &lt;br/&gt;    returnnull;&lt;br/&gt;}&lt;br/&gt; &lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;release&lt;/span&gt;&lt;span&gt;(String identify)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (identify == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        returnfalse;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//通过lua脚本进行比对删除操作，保证原子性&lt;/span&gt;&lt;br/&gt;    String script = &lt;span&gt;&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;&lt;/span&gt;;&lt;br/&gt;    Object result = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        result = jedis.eval(script, Collections.singletonList(lockKey),&lt;br/&gt;            Collections.singletonList(identify));&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (RELEASE_SUCCESS.equals(result)) {&lt;br/&gt;            log.info(&lt;span&gt;&quot;release lock success, requestToken:{}&quot;&lt;/span&gt;, identify);&lt;br/&gt;            returntrue;&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        log.error(&lt;span&gt;&quot;release lock due to error&quot;&lt;/span&gt;, e);&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (jedis != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            jedis.close();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt; &lt;br/&gt;    log.info(&lt;span&gt;&quot;release lock failed, requestToken:{}, result:{}&quot;&lt;/span&gt;, identify, result);&lt;br/&gt;    returnfalse;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;思考：加锁和释放锁的原子性可以用 lua 脚本来保证，那锁的自动续期改如何实现呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Redisson 实现&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redisson 顾名思义，Redis 的儿子，本质上还是 Redis 加锁，不过是对 Redis 做了很多封装，它不仅提供了一系列的分布式的 Java 常用对象，还提供了许多分布式服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在引入 Redisson 的依赖后，就可以直接进行调用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.redisson&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;redisson&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;3.13.4&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来一段 Redisson 的加锁代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//分布式锁名  锁的粒度越细，性能越好&lt;/span&gt;&lt;br/&gt;    RLock lock = redissonClient.getLock(&lt;span&gt;&quot;test_lock&quot;&lt;/span&gt;);&lt;br/&gt;    lock.lock();&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;//具体业务......&lt;/span&gt;&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        lock.unlock();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是这么简单，使用方法 jdk 的 ReentrantLock 差不多，并且也支持 ReadWriteLock（读写锁）、Reentrant Lock（可重入锁）、Fair Lock（公平锁）、RedLock（红锁）等各种锁，详细可以参照redisson官方文档来查看。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8220640569395018&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLnxzrsS3T54ic8vywwjvIWtwG4aObh1FrDnFTgic2jtdm0RjiarY4ibIcfVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;281&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么 Redisson 到底有哪些优势呢？锁的自动续期（默认都是 30 秒），如果业务超长，运行期间会自动给锁续上新的 30s，不用担心业务执行时间超长而锁被自动删掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加锁的业务只要运行完成，就不会给当前续期，即便不手动解锁，锁默认在 30s 后删除，不会造成死锁问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面也提到了锁的自动续期，我们来看看 Redisson 是如何来实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先说明一下，这里主要讲的是 Redisson 中的 RLock，也就是可重入锁，有两种实现方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 最常见的使用方法&lt;/span&gt;&lt;br/&gt;lock.lock();&lt;br/&gt; &lt;br/&gt;&lt;span&gt;// 加锁以后10秒钟自动解锁&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 无需调用unlock方法手动解锁&lt;/span&gt;&lt;br/&gt;lock.lock(&lt;span&gt;10&lt;/span&gt;, TimeUnit.SECONDS);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而只有无参的方法是提供锁的自动续期操作的，内部使用的是“看门狗”机制，我们来看一看源码。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9658536585365853&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLnAP5Eib55JI6vWhLtFfftvbzYfLFCB4ic8pwLlfniaOMDmlQPajPo0licGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;205&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9158415841584159&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLnFTHc1ibIaaG4kJKOrDicgHIuwJzeCwvoXVvV1plF1K6dyfgR7tK0TvIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;404&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管是空参还是带参方法，它们都调用的是同一个 lock 方法，未传参的话时间传了一个 -1，而带参的方法传过去的就是实际传入的时间。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6795048143053645&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLnsypK9ZKONpOSjV1bk0CkEzPEjC5ibBTyNqTGCOFHStrP24Fh7hB11rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;727&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续点进 scheduleExpirationRenewal 方法：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38394160583941606&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLnC5GYE6C26nY7JCDDIvoq6Wzx2oDu5EZLwT5BLoKzmPIq8DJGicEkEpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;685&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点进 renewExpiration 方法：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9939849624060151&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLnwTx0dPRMMWR1icmBLXJ0AwljSE4fEicJVqubACPlBHic1NROhpOmfUJicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;665&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结一下，就是当我们指定锁过期时间，那么锁到时间就会自动释放。如果没有指定锁过期时间，就使用看门狗的默认时间 30s，只要占锁成功，就会启动一个定时任务，每隔 10s 给锁设置新的过期时间，时间为看门狗的默认时间，直到锁释放。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;小结：虽然 lock() 有自动续锁机制，但是开发中还是推荐使用 &lt;code&gt;lock(time，timeUnit)&lt;/code&gt;，因为它省掉了整个续期带来的性能损，可以设置过期时间长一点，搭配 &lt;code&gt;unlock()&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若业务执行完成，会手动释放锁，若是业务执行超时，那一般我们服务也都会设置业务超时时间，就直接报错了，报错后就会通过设置的过期时间来释放锁。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    RLock lock = redissonClient.getLock(&lt;span&gt;&quot;test_lock&quot;&lt;/span&gt;);&lt;br/&gt;    lock.lock(&lt;span&gt;30&lt;/span&gt;, TimeUnit.SECONDS);&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;//.......具体业务&lt;/span&gt;&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;//手动释放锁&lt;/span&gt;&lt;br/&gt;        lock.unlock();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;推荐下自己做的 Spring Boot 的实战项目：&lt;/p&gt;&lt;p&gt;https://github.com/YunaiV/ruoyi-vue-pro&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多小伙伴都知道在分布式系统中，可以用 ZK 来做注册中心，但其实在除了做祖册中心以外，用 ZK 来做分布式锁也是很常见的一种方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来看一下 ZK 中是如何创建一个节点的？ZK 中存在 &lt;code&gt;create [-s] [-e] path [data]&lt;/code&gt; 命令，&lt;code&gt;-s&lt;/code&gt; 为创建有序节点，&lt;code&gt;-e&lt;/code&gt; 创建临时节点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.12410501193317422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLnpnCq8RKArGPxtDiaQib5b9snLdwzDl98tFkrrRqQCBicjHA9NoMLIgicbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;838&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就创建了一个父节点并为父节点创建了一个子节点，组合命令意为创建一个临时的有序节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 ZK 中分布式锁主要就是靠创建临时的顺序节点来实现的。至于为什么要用顺序节点和为什么用临时节点不用持久节点？先考虑一下，下文将作出说明。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时还有 ZK 中如何查看节点？ZK 中 &lt;code&gt;ls [-w] path&lt;/code&gt; 为查看节点命令，&lt;code&gt;-w&lt;/code&gt; 为添加一个 watch（监视器），&lt;code&gt;/&lt;/code&gt; 为查看根节点所有节点，可以看到我们刚才所创建的节点，同时如果是跟着指定节点名字的话为查看指定节点下的子节点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1815068493150685&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLn1icCA1xmYRuXbCCaLrn17WTOBZ6HMFfXSzJ6MRibictY1OQX5nboh3O7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;584&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面的 00000000 为 ZK 为顺序节点增加的顺序。注册监听器也是 ZK 实现分布式锁中比较重要的一个东西。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5086505190311419&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLnb156HMyHiaXDZCGXrBBJq96GJib7Twe7iagUrqMsJBAEtaUKJm0OxqD1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面来看一下 ZK 实现分布式锁的主要流程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当第一个线程进来时会去父节点上创建一个临时的顺序节点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二个线程进来发现锁已经被持有了，就会为当前持有锁的节点注册一个 watcher 监听器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三个线程进来发现锁已经被持有了，因为是顺序节点的缘故，就会为上一个节点去创建一个 watcher 监听器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当第一个线程释放锁后，删除节点，由它的下一个节点去占有锁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里，聪明的小伙伴们都已经看出来顺序节点的好处了。非顺序节点的话，每进来一个线程进来都会去持有锁的节点上注册一个监听器，容易引发“羊群效应”。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4533333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLnz7bD4b3MDaNVXUdd5CibG7wGSeGkm8x13Q4AIcbIBj2XWcJib5vUFGFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么大一群羊一起向你飞奔而来，不管你顶不顶得住，反正 ZK 服务器是会增大宕机的风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而顺序节点的话就不会，顺序节点当发现已经有线程持有锁后，会向它的上一个节点注册一个监听器，这样当持有锁的节点释放后，也只有持有锁的下一个节点可以抢到锁，相当于是排好队来执行的，降低服务器宕机风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于为什么使用临时节点，和 Redis 的过期时间一个道理，就算 ZK 服务器宕机，临时节点会随着服务器的宕机而消失，避免了死锁的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面来上一段代码的实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ZooKeeperDistributedLock&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Watcher&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ZooKeeper zk;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String locksRoot = &lt;span&gt;&quot;/locks&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String productId;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String waitNode;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String lockNode;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; CountDownLatch latch;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; CountDownLatch connectedLatch = &lt;span&gt;new&lt;/span&gt; CountDownLatch(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; sessionTimeout = &lt;span&gt;30000&lt;/span&gt;;&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ZooKeeperDistributedLock&lt;/span&gt;&lt;span&gt;(String productId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.productId = productId;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            String address = &lt;span&gt;&quot;192.168.189.131:2181,192.168.189.132:2181&quot;&lt;/span&gt;;&lt;br/&gt;            zk = &lt;span&gt;new&lt;/span&gt; ZooKeeper(address, sessionTimeout, &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;            connectedLatch.await();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LockException(e);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (KeeperException e) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LockException(e);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LockException(e);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;process&lt;/span&gt;&lt;span&gt;(WatchedEvent event)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (event.getState() == KeeperState.SyncConnected) {&lt;br/&gt;            connectedLatch.countDown();&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt; &lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.latch != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.latch.countDown();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;acquireDistributedLock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.tryLock()) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                waitForLock(waitNode, sessionTimeout);&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (KeeperException e) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LockException(e);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LockException(e);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//获取锁&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;tryLock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 传入进去的locksRoot + “/” + productId&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 假设productId代表了一个商品id，比如说1&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// locksRoot = locks&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// /locks/10000000000，/locks/10000000001，/locks/10000000002&lt;/span&gt;&lt;br/&gt;        lockNode = zk.create(locksRoot + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + productId, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);&lt;br/&gt; &lt;br/&gt;        &lt;span&gt;// 看看刚创建的节点是不是最小的节点&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// locks：10000000000，10000000001，10000000002&lt;/span&gt;&lt;br/&gt;        List&amp;lt;String&amp;gt; locks = zk.getChildren(locksRoot, &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;        Collections.sort(locks);&lt;br/&gt; &lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(lockNode.equals(locksRoot+&lt;span&gt;&quot;/&quot;&lt;/span&gt;+ locks.get(&lt;span&gt;0&lt;/span&gt;))){&lt;br/&gt;            &lt;span&gt;//如果是最小的节点,则表示取得锁&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt; &lt;br/&gt;        &lt;span&gt;//如果不是最小的节点，找到比自己小1的节点&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;int&lt;/span&gt; previousLockIndex = -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; locks.size(); i++) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(lockNode.equals(locksRoot + “/” + locks.get(i))) {&lt;br/&gt;                    previousLockIndex = i - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;       }&lt;br/&gt; &lt;br/&gt;       &lt;span&gt;this&lt;/span&gt;.waitNode = locks.get(previousLockIndex);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (KeeperException e) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LockException(e);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LockException(e);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;waitForLock&lt;/span&gt;&lt;span&gt;(String waitNode, &lt;span&gt;long&lt;/span&gt; waitTime)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException, KeeperException &lt;/span&gt;{&lt;br/&gt;        Stat stat = zk.exists(locksRoot + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + waitNode, &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (stat != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.latch = &lt;span&gt;new&lt;/span&gt; CountDownLatch(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.latch.await(waitTime, TimeUnit.MILLISECONDS);&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.latch = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;//释放锁&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;unlock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;unlock &quot;&lt;/span&gt; + lockNode);&lt;br/&gt;            zk.delete(lockNode, -&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;            lockNode = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;            zk.close();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (KeeperException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//异常&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LockException&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;RuntimeException&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = &lt;span&gt;1L&lt;/span&gt;;&lt;br/&gt; &lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;LockException&lt;/span&gt;&lt;span&gt;(String e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;super&lt;/span&gt;(e);&lt;br/&gt;        }&lt;br/&gt; &lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;LockException&lt;/span&gt;&lt;span&gt;(Exception e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;super&lt;/span&gt;(e);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;推荐下自己做的 Spring Cloud 的实战项目：&lt;/p&gt;&lt;p&gt;https://github.com/YunaiV/onemall&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然明白了 Redis 和 ZK 分别对分布式锁的实现，那么总该有所不同的吧。没错，我都帮大家整理好了：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实现方式的不同，Redis 实现为去插入一条占位数据，而 ZK 实现为去注册一个临时节点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;遇到宕机情况时，Redis 需要等到过期时间到了后自动释放锁，而 ZK 因为是临时节点，在宕机时候已经是删除了节点去释放锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis 在没抢占到锁的情况下一般会去自旋获取锁，比较浪费性能，而 ZK 是通过注册监听器的方式获取锁，性能而言优于 Redis。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过具体要采用哪种实现方式，还是需要具体情况具体分析，结合项目引用的技术栈来落地实现。&lt;/p&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>edbf99fc0e72a42a706aed0045af7249</guid>
<title>基于客观事实的 RFM 模型（Python 代码）</title>
<link>https://toutiao.io/k/sderuz9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NOM5HN2icXzxY50ppQNGcnW8CaOeRkY2X1pjfruGYKgIdZsbCicBNlgUaSEu5ib4iciae1NnuwsCeze5gmqQGCcABrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;CDA数据分析师 出品  &lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;h3&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;88402&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;88402&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107411&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot;&gt;1&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;316:225&quot;&gt;背景&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RFM（Recency Frequency Monetary）模型是衡量客户价值和客户创利能力的重要工具和手段。在众多的客户关系管理(CRM)的分析模式中，RFM模型是被广泛提到的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RFM模型是属于业务分析方法与模型中的部分。它的本质是用户分类。本文将用现代最流行的编程语言---Python语言来实践课堂上讲解的RFM模型，将用户进行分类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文采用Anaconda进行Python编译，主要涉及的Python模块：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;pandas&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;matplotlib&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;seaborn&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;datetime&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本章分为三部分讲解：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.RFM模型原理与步骤&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.Python分布实现RFM&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.总结&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107411&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;2&quot;&gt;2&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;RFM模型原理与步骤&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RFM模型的思路是：该模型是根据用户历史行为数据，结合业务理解选择划分维度，实现用户分类，助力用户精准营销。此外，还学习了构建RFM模型的步骤：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;获取R、F、M三个维度下的原始数据&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;定义R、F、M的评估模型与判断阈值&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;进行数据处理，获取R、F、M的值&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;参照评估模型与阈值，对用户进行分层&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;针对不同层级用户制定运营策略&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面步骤可以知道，我们需要有RFM三个维度，根据我们在业务分析方法课程中学到的，业务分析模型离不开指标，而指标是对度量的汇总。因此，在找出RFM三个维度后，需要对每个维度下度量实现不同汇总规则。下面讲述对R、F、M三个维度下的度量如何进行汇总。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.R代表最近一次消费，是计算最近一次消费时间点和当前时间点的时间差。因此，这里需要用到多维数据透视分析中的基本透视规则---最小值MIN求出最小的时间差。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.F代表消费频次，是在指定区间内统计用户的购买次数。因此，这里需要用到多维数据透视分析中的基本透视规则---技术类COUNT(技术类不去重指标)统计用户的购买次数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.M代表消费金额，是指在指定区间内统计用户的消费总金额，因此，这里需要用到求和类指标，也即基本透视规则中的合计规则---SUM。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在对得到RFM模型中的指标值后最重要的一步就是分层，根据我们在课堂上学到的内容，大部分的用户分层是根据经验来分层的，本文在追求数据的客观性下采取统计学中的等距分箱方法来进行分层，对R、F、M三个维度分成两类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;综上，我们大致了解了如何构建RFM模型，下面以Python实现RFM模型，并对每一步进行详细的讲解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107411&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;4&quot;&gt;3&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;Python实现RFM模型&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据准备&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文所需的数据是一家公司对2021年10月底至今的客户购买行为数据，（前十二行）如图下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4368932038834951&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/pxMrQvgWLULf1JbfH9M0KyibxGXq3JtglhedCibuSPHKADHAsqz6xX3wuMEmY8ACm0GgVibib0viacrP00nSMKzdsHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;858&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中，&lt;code&gt;uid&lt;/code&gt;代表客户的id，是存在重复情况的。&lt;code&gt;prince&lt;/code&gt;维度代表客户每发生一次交易行为所花费的金额。&lt;code&gt;time&lt;/code&gt;为客户发生交易行为的时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据读取与理解&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在得到一份数据之后，我们第一步就是要理解数据的业务意义，以及对数据表的EDA（探索性分析），这里通过如下代码，发现以下特征：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.10922330097087378&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/pxMrQvgWLULf1JbfH9M0KyibxGXq3JtglOibiaBjME3xe0EU4XrYe49RJDOWOe60mGpOPKNYTmLuvDmzydPDWS8cQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;778&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体代码（包含Python导入包部分）如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;python&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 导入相关包&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import pandas as pd&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import time&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import numpy as np&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import seaborn as sns&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import matplotlib.pyplot as plt&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;plt.rcParams[&#x27;font.sans-serif&#x27;] = [&quot;SimHei&quot;]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;plt.rcParams[&quot;axes.unicode_minus&quot;] = False&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sns.set(style=&quot;darkgrid&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 数据读取与查看&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;data = pd.read_excel(&#x27;data.xlsx&#x27;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;data.head()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;data.isnull().sum()  #查看缺失值&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;data.duplicated().sum()   #重复值，但是不删&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;data.dtypes  #查看数据类型&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;data.describe()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 创建dataframe，存放RFM各值&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;data_rfm = pd.DataFrame()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来进行R、F、M指标值构建。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;时间维度处理&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;从上文可以知道&lt;code&gt;time&lt;/code&gt;维度，即每笔交易行为发生的时间是字符串object的格式，而在Python中我们对时间作差需要的是&lt;code&gt;datetime&lt;/code&gt;格式，因此利用&lt;code&gt;pandas&lt;/code&gt;库中的&lt;code&gt;pd.to_datetime&lt;/code&gt;函数将时间格式进行转换，代码如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;data[&#x27;time&#x27;] = pd.to_datetime(data[&#x27;time&#x27;])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;得到的前五行数据如图下，可以看到数据类型变成了&lt;/span&gt;&lt;code&gt;datetime64[ns]&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5215827338129496&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/pxMrQvgWLULf1JbfH9M0KyibxGXq3JtglGv5tVic0Xvtf8OZk16iaSgng1IibKW4OaCPtCdAP35d6fH2nga9QpRvOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;556&quot;/&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;统计每笔订单产生时间与当前时间的差（这里的当前时间是2021年12月11日），得到的差是&lt;/span&gt;&lt;code&gt;&lt;span&gt;timedelta64[ns]&lt;/span&gt;&lt;/code&gt;&lt;span&gt;类型&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3275217932752179&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/pxMrQvgWLULf1JbfH9M0KyibxGXq3JtgllGBguhOfdibmu8xvyAjJantk2QO4WS0k4COufZOoUnlZBkicXIONIMHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;803&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到时间差中包含了day、时、分、秒4个维度，但是这里我们仅需要day维度，因此我们用&lt;/span&gt;&lt;code&gt;&lt;span&gt;astype()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;函数将类型转为仅含有day维度的&lt;/span&gt;&lt;code&gt;&lt;span&gt;timedelta64[D]&lt;/span&gt;&lt;/code&gt;&lt;span&gt;类型。具体代码如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 统计没条数据与当前日期的时间差&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;## 计算相差天数&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;data[&#x27;R&#x27;] = (pd.datetime.now() - data[&#x27;time&#x27;])&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;## 将时间差timedelta格式转化为需要的日格式&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;data[&#x27;R&#x27;] = data[&#x27;R&#x27;].astype(&#x27;timedelta64[D]&#x27;).astype(&#x27;int&#x27;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;（&lt;span md-inline=&quot;plain&quot;&gt;tips：这里可能会报警告：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;code&gt;FutureWarning: The pandas.datetime class is deprecated and will be removed from pandas in a future version. Import from datetime module instead.&lt;/code&gt;读者无需理会，这是由于我们所用的&lt;code&gt;pd.datetime.now()&lt;/code&gt;是一个比较旧的函数，以后将会废弃。&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;统计R值&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在上面我们已经创建了名为&lt;code&gt;data_rfm&lt;/code&gt;的表结构的数据框，因此，将下面统计的R值放入其中。R值得统计是找客户最近发生交易行为日期与当前日期的差。换一种思路就是找所有时间差中的最小值。因此利用&lt;code&gt;pandas&lt;/code&gt;中的&lt;code&gt;groupby&lt;/code&gt;函数对每个用户以上一步统计的R值作为分组依据进行分组，并求出最小值。具体代码如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;data_rfm = pd.merge(data_rfm,data.groupby(&#x27;uid&#x27;)[&#x27;R&#x27;].min(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         left_on = &#x27;user_id&#x27;,right_on=&#x27;uid&#x27;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;统计F值&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;F值得统计就是统计指定区间内的消费频次，而指定区间一般为人为设定，这里我们取全部数据，即2021年10月底至今作为指定区间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文利用&lt;code&gt;value_counts()&lt;/code&gt;函数对&lt;code&gt;uid&lt;/code&gt;进行统计即为每个用户得消费频次，同时将结果合并到&lt;code&gt;data_rfm&lt;/code&gt;数据框中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 统计指定区间内的消费频次&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;data_rfm[&#x27;user_id&#x27;] = data[&#x27;uid&#x27;].value_counts().index&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;data_rfm[&#x27;F&#x27;] = data[&#x27;uid&#x27;].value_counts().values&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;统计M值&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文以&lt;code&gt;uid&lt;/code&gt;作为分组依据对&lt;code&gt;price&lt;/code&gt;字段进行求和，得到求和类指标M值。此外，将结果合并到&lt;code&gt;data_rfm&lt;/code&gt;数据框中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;data_rfm = pd.merge(data_rfm,data.groupby(&#x27;uid&#x27;)[&#x27;price&#x27;].sum(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         left_on = &#x27;user_id&#x27;,right_on=&#x27;uid&#x27;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;data_rfm.rename(columns={&#x27;price&#x27;:&#x27;M&#x27;},inplace = True)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上述代码中出现了&lt;code&gt;pandas&lt;/code&gt;库中得合并语法&lt;code&gt;merge()&lt;/code&gt;，&lt;code&gt;merge()&lt;/code&gt;函数采取的是横向合并，不同于MYSQL，不需要指定左表还是右表为主表，只需要提供左表与右表的公共字段在各表中的名称即可。由于&lt;code&gt;data_rfm&lt;/code&gt;数据表中的&lt;code&gt;user_id&lt;/code&gt;是去重的，因此将其作为主键。而&lt;code&gt;data.groupby(&#x27;uid&#x27;)[&#x27;price&#x27;].sum()&lt;/code&gt;得到的表格也是去重的，因此我们可以采取多维数据模型中的连接对应关系---一对一对两表进行合并。公共字段为：左表的&lt;code&gt;uid&lt;/code&gt;，右表的&lt;code&gt;user_id&lt;/code&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终表格结果如下，展现前18行：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1949265687583444&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/pxMrQvgWLULf1JbfH9M0KyibxGXq3Jtgla37gTqqSuWjgPSWMHfZoicm9lHaiad6xIibDH9vDZ45hByyeYErzTJnpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;749&quot;/&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;数据分箱&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在得到R、F、M三个指标值后，我们需要对这三个指标进行分类，并将每个用户进行分层。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;本文不采取人为主观性的经验法则划分，而是采取等距分箱的方式划分，等距分箱的原理较简单，这里写出步骤：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;从最小值到最大值之间,均分为$N$等份（这里$N$取为2）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果 $A$,$B$ 为最小最大值, 则每个区间的长度为 $W=(B−A)/N$ ,.&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;则区间边界值为$A+W$,$A+2W$,….$A+(N−1)W$ 。这里只考虑边界，采用左闭右开的方式，即每个等份的实例数量不等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Python中可以利用&lt;code&gt;pandas&lt;/code&gt;库中的&lt;code&gt;cut()&lt;/code&gt;函数轻松实现上述等距分箱，同时将结果&lt;code&gt;R_label&lt;/code&gt;，&lt;code&gt;F_label&lt;/code&gt;，&lt;code&gt;M_label&lt;/code&gt;合并到&lt;code&gt;data_rfm&lt;/code&gt;数据框中具体代码如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 分箱 客观 左闭右开&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cut_R = pd.cut(data_rfm[&#x27;R&#x27;],bins = 2,right = False,labels = range(1,3)).astype(&#x27;int&#x27;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;data_rfm[&#x27;R_label&#x27;] = cut_R&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cut_F = pd.cut(data_rfm[&#x27;F&#x27;],bins = 2,right = False,labels = range(1,3)).astype(&#x27;int&#x27;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;data_rfm[&#x27;F_label&#x27;] = cut_F&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cut_M = pd.cut(data_rfm[&#x27;M&#x27;],bins = 2,right = False,labels = range(1,3)).astype(&#x27;int&#x27;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;data_rfm[&#x27;M_label&#x27;] = cut_M&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;由于利用&lt;/span&gt;&lt;code&gt;cut()&lt;/code&gt;&lt;span&gt;函数得到的是区间形式的值，因此需要赋予label值进行虚拟变量引用。label值使用1和2，对应的区间为从小到大。具体代表意思如下表：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.11621966794380588&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/pxMrQvgWLULf1JbfH9M0KyibxGXq3Jtgl7TibgvuKq8sfr9Um88iaJco0gorp1f8EmlenqbNhuFBbhwkwkbDdyouw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;783&quot;/&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;得到最终的表格形式如下：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7452123230641132&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/pxMrQvgWLULf1JbfH9M0KyibxGXq3JtglsM2wia19ZV1za3YIY6jDclficFSBmaow9OP3XL6W6meyaEsw6Sbz98BQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1201&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户分类&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在得到每个用户的R、F、M三个维度的label值后，最后就是需要对用户进行分类，分类的原则如图下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7712177121771218&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/pxMrQvgWLULf1JbfH9M0KyibxGXq3Jtgl2BOafktmpqmWay85Z6nyYNCkBVp9orH7akLBZeeABDpQnrUEpuxhoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;813&quot;/&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;利用pandas库中的·&lt;code&gt;terrows()&lt;/code&gt;函数循环遍历每个用户行为记录，将符合上述条件的划分对应的类，具体代码如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;python&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;for i,j in data_rfm.iterrows():&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if j[&#x27;R_label&#x27;] ==  2 and j[&#x27;F_label&#x27;] == 2 and j[&#x27;M_label&#x27;] == 2:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        data_rfm.loc[i,&#x27;用户类别&#x27;] = &#x27;重要价值用户&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if j[&#x27;R_label&#x27;] ==  2 and j[&#x27;F_label&#x27;] == 1 and j[&#x27;M_label&#x27;] == 2:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        data_rfm.loc[i,&#x27;用户类别&#x27;] = &#x27;重要发展用户&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if j[&#x27;R_label&#x27;] ==  1 and j[&#x27;F_label&#x27;] == 2 and j[&#x27;M_label&#x27;] == 2:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        data_rfm.loc[i,&#x27;用户类别&#x27;] = &#x27;重要保持用户&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if j[&#x27;R_label&#x27;] ==  1 and j[&#x27;F_label&#x27;] == 1 and j[&#x27;M_label&#x27;] == 2:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        data_rfm.loc[i,&#x27;用户类别&#x27;] = &#x27;重要挽留用户&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if j[&#x27;R_label&#x27;] ==  2 and j[&#x27;F_label&#x27;] == 2 and j[&#x27;M_label&#x27;] == 1:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        data_rfm.loc[i,&#x27;用户类别&#x27;] = &#x27;一般价值用户&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if j[&#x27;R_label&#x27;] ==  2 and j[&#x27;F_label&#x27;] == 1 and j[&#x27;M_label&#x27;] == 1:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        data_rfm.loc[i,&#x27;用户类别&#x27;] = &#x27;一般发展用户&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if j[&#x27;R_label&#x27;] ==  1 and j[&#x27;F_label&#x27;] == 2 and j[&#x27;M_label&#x27;] == 1:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        data_rfm.loc[i,&#x27;用户类别&#x27;] = &#x27;一般保持用户&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if j[&#x27;R_label&#x27;] ==  1 and j[&#x27;F_label&#x27;] == 1 and j[&#x27;M_label&#x27;] == 1:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        data_rfm.loc[i,&#x27;用户类别&#x27;] = &#x27;一般挽留用户&#x27;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;条形图可视化用户类别&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;利用&lt;code&gt;seaborn&lt;/code&gt;&lt;/span&gt;&lt;span&gt;画图库对已划分类别的用户进行技术统计与可视化，得到如下图表&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.660377358490566&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/pxMrQvgWLULf1JbfH9M0KyibxGXq3JtglULaIP28EOpZFKdcBdGm3cBT1F4yUA16XPIjpYkvpgxZxFlgbLv9Wzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;424&quot;/&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;可以看出，大部分的用户属于一般发展用户与一般挽留用户。而对于一般发展用户而言采取的策略为挖掘需求，后者则是放弃治疗。因此，可以看出该公司在10月底至今的时间段内，用户流失较多，但是可发展的用户同样是非常多的，想要提高收入，对一般发展用户入手是成本少，效率高的选择。&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107411&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;4&quot;&gt;4&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;总结&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RFM模型同时还利用了多维数据透视分析和业务分析方法两个模块的内容。所以说实践是检验和巩固学到的东西的最好方法。例如一级的常考题上，我们常碰到一个模拟题，包含RFM模型划分规则和一张帕累托图，问题是在公司有限成本下提高公司收入，需要针对哪种用户营销最好，答案是一般发展用户。相信大家一开始都很疑惑为什么选这个，这时候如果像本文一样对一份数据进行实践，这样你就会更加理解为什么是这个答案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUzODYwMDAzNA==&amp;amp;action=getalbum&amp;amp;album_id=1699019347278561282#wechat_redirect&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;&lt;em&gt;&lt;span&gt;1. &lt;/span&gt;&lt;/em&gt;pandas100个骚操作&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;2. &lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUzODYwMDAzNA==&amp;amp;action=getalbum&amp;amp;album_id=1838255778403581970#wechat_redirect&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;机器学习原创系列&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;3. &lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUzODYwMDAzNA==&amp;amp;action=getalbum&amp;amp;album_id=1816443218394218499#wechat_redirect&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;数据科学干货下载&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后给大家&lt;/span&gt;&lt;strong&gt;&lt;span&gt;分享《10本数据挖掘电子书》&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，包括数据分析、统计学、数据挖掘、机器学习。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在免费分享出来，有需要的读者可以下载学习，在下面的公众号「&lt;strong&gt;数据挖掘工程师&lt;/strong&gt;」里回复关键字：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;数据挖掘&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，就行。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4OTQ1MTA4OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Iefry9dPrYJ1LbaTxqd4VPOibfZ1tf0fXDUqFOLlPcRPvv4W4Cro4YnhRx2Xib5MId5rECtVMBkmvJk8nSNnsekw/0?wx_fmt=png&quot; data-nickname=&quot;数据挖掘工程师&quot; data-alias=&quot;DataMinings&quot; data-signature=&quot;数万名数据挖掘爱好者的聚集地，致力于前沿数据技术研究。公众号以数据为核心，分享大数据、数据分析、机器学习、深度学习等干货，想学数据我等你来。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dcff9315a5b0f48be32bdefe189ad06b</guid>
<title>119 python|第一部分：python核心（ 三）</title>
<link>https://toutiao.io/k/l7ftg3g</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前言：昨天进行了Python核心的第三个板块“语句&lt;strong&gt;&lt;span&gt;”&lt;/span&gt;&lt;/strong&gt;的学习，今天学习的内容是容器的引入部分。在介绍本节内容之前，首先要了解容器的概念，python的容器主要有列表、元祖、集合、字典四种类型，那什么是容器呢？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;188&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;容器：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;容器是一种把多个元素组织在一起的数据结构，容器中的元素可以逐个地迭代获取，可以用in, not in关键字判断元素是否包含在容器中。by LaoYuanPython&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;迭代：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;是通过重复执行的代码处理相似的数据集的过程，并且本次迭代的处理数据要依赖上一次的结果继续往下做，上一次产生的结果为下一次产生结果的初始状态，如果中途有任何停顿，都不能算是迭代。by LaoYuanPython&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;                        &lt;br mpa-from-tpl=&quot;t&quot; data-filtered=&quot;filtered&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;30&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZcWNHRSIjJGs9bvuzwV9GxaCvA4ic5qN3EhBUUSmSLdmc9YTk9M815IRRFboPVT3Klpyd0bCVEdIsgn7p6ue1Zg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;引入&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引入1：容器的通用操作&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.027777777777777776&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uyZsSl2gvXUO54LuJbh78tMMYyiav6tM98N9ouoQQTft4O3IWh4GbXmy4DLUYM3ECeaqyg9U36gDRH7rNrjqlvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）&lt;strong&gt;&lt;span&gt;数学运算符&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;name = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;小猪&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;name += &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;佩奇&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(name) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;name = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;猪小妹&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;name *= 2&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(name) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;佩奇&quot;&lt;/span&gt; &amp;gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;猪小妹&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2）成员运算符&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;（1）语法&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;数据 in 序列&lt;/p&gt;&lt;p&gt;数据 not in 序列&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（2）返回值&lt;/p&gt;&lt;p&gt;为bool类型&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;apache&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;#True&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;猪&quot;&lt;/span&gt; in &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;猪小妹&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;#False&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;猪妹&quot;&lt;/span&gt; in &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;猪小妹&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3）&lt;/span&gt;&lt;strong&gt;索引 index&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;（1）作用 ：定位&lt;strong&gt;单个&lt;/strong&gt;容器元素。&lt;/p&gt;&lt;p&gt;（2）语法 ：容器[整数] &lt;/p&gt;&lt;p&gt;（3）用法&lt;/p&gt;&lt;p&gt;正向索引从0开始，最后一项索引为len(s)-1；&lt;/p&gt;&lt;p&gt;反向索引从-1开始，第一项为-len(s)。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;statement&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;我是粉红猪佩奇，这是我的弟弟乔治&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(statement[&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;]) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(statement[-&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;]) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(len(statement)) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 注：索引不能越界&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(statement[&lt;span class=&quot;code-snippet__number&quot;&gt;90&lt;/span&gt;]) &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;4）&lt;/span&gt;切片 slice&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;（1）作用 ：定位&lt;strong&gt;多个&lt;/strong&gt;容器元素。&lt;/p&gt;&lt;p&gt;（2）语法 ：容器[开始索引: 结束索引: 步长] &lt;/p&gt;&lt;p&gt;（3）用法&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;statement&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;我肚子咕咕叫的声音是大自然最动听的声音之一&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(statement&lt;span class=&quot;code-snippet__section&quot;&gt;[3:5:1]&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(statement&lt;span class=&quot;code-snippet__section&quot;&gt;[:]&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(statement&lt;span class=&quot;code-snippet__section&quot;&gt;[-3:]&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(statement&lt;span class=&quot;code-snippet__section&quot;&gt;[2:2]&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(statement&lt;span class=&quot;code-snippet__section&quot;&gt;[::-1]&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;5）&lt;/span&gt;内建函数&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;（1）len(x) 返回序列的长度&lt;/p&gt;&lt;p&gt;（2）max(x) 返回序列的最大值元素&lt;/p&gt;&lt;p&gt;（3）min(x) 返回序列的最小值元素&lt;/p&gt;&lt;p&gt;（4）sum(x) 返回序列所有元素的和（元素必须是数值类型）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;30&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZcWNHRSIjJGs9bvuzwV9GxaCvA4ic5qN3EhBUUSmSLdmc9YTk9M815IRRFboPVT3Klpyd0bCVEdIsgn7p6ue1Zg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;04 容器类型　&lt;/span&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt; 4&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;.1 字符串&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.027777777777777776&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uyZsSl2gvXUO54LuJbh78tMMYyiav6tM9jn6yFFic11B0vQhibEicFyiariaZf5bK51KJpPAgasmPLgL01e3Ulr4ibTzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）定义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;由一系列字符组成的&lt;strong&gt;不可变序列容器&lt;/strong&gt;，存储的是字符的编码值。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.36964285714285716&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uyZsSl2gvXVmhpFKITckyFqFTRKHR78PEIfqPz4pNrM9uJZiaZry4Kmxj3obGibX7DcRTuoX9M5xXJffwY0Xmnhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1120&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（图源：无鸢^-^）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）编码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;（1）基础知识&lt;/p&gt;&lt;p&gt;&lt;strong&gt;字节：&lt;/strong&gt;计算机最小的存储单位，等于8位bit。&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;208&quot; data-source-title=&quot;Mr.peter&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;计算机存储单位一般用bit、B、KB、MB、GB、TB、PB、EB、ZB、YB、BB、NB、DB……来表示，它们之间的关系是：位 bit (比特)(Binary Digits)：存放一位二进制数，即 0 或 1，最小的存储单位。[英文缩写：b(固定小写)]
字节byte：8个二进制位为一个字节(B)，最常用的单位。1TB=1024GB 1GB=1024MB 1MB=1024KB 1KB=1024B 1B=8b&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;blockquote_info js_blockquote_source&quot; data-json=&quot;%7B%22type%22%3A%22out%22%2C%22source%22%3A%22url%22%2C%22digest%22%3A%22%3Cp%3E%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E4%B8%80%E8%88%AC%E7%94%A8bit%E3%80%81B%E3%80%81KB%E3%80%81MB%E3%80%81GB%E3%80%81TB%E3%80%81PB%E3%80%81EB%E3%80%81ZB%E3%80%81YB%E3%80%81BB%E3%80%81NB%E3%80%81DB%E2%80%A6%E2%80%A6%E6%9D%A5%E8%A1%A8%E7%A4%BA%EF%BC%8C%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%EF%BC%9A%5Cn%E4%BD%8D%26nbsp%3Bbit%26nbsp%3B(%E6%AF%94%E7%89%B9)(Binary%26nbsp%3BDigits)%EF%BC%9A%E5%AD%98%E6%94%BE%E4%B8%80%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%EF%BC%8C%E5%8D%B3%26nbsp%3B0%26nbsp%3B%E6%88%96%26nbsp%3B1%EF%BC%8C%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E3%80%82%5B%E8%8B%B1%E6%96%87%E7%BC%A9%E5%86%99%EF%BC%9Ab(%E5%9B%BA%E5%AE%9A%E5%B0%8F%E5%86%99)%5D%5Cn%E5%AD%97%E8%8A%82byte%EF%BC%9A8%E4%B8%AA%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82(B)%EF%BC%8C%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8D%95%E4%BD%8D%E3%80%82%5Cn1TB%3D1024GB%26nbsp%3B1GB%3D1024MB%26nbsp%3B1MB%3D1024KB%26nbsp%3B1KB%3D1024B%26nbsp%3B1B%3D8b%3C%2Fp%3E%22%2C%22digestLen%22%3A208%2C%22text%22%3A%22%22%2C%22article%22%3A%7B%7D%2C%22hasReportOverSize%22%3Afalse%2C%22editorReportData%22%3A%5B%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2276%22%2C%22len%22%3A1%7D%5D%2C%22from%22%3A%22Mr.peter%22%7D&quot;&gt;&lt;span class=&quot;blockquote_other&quot;&gt;Mr.peter&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;字符：&lt;/strong&gt;单个的数字、文字与符号。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;编码：&lt;/strong&gt;将字符转换成对应的二进制序列的过程。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;解码：&lt;/strong&gt;和编码相反。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;字符集(码表)：&lt;/strong&gt;存储字符与二进制序列的对应关系。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.706&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uyZsSl2gvXVmhpFKITckyFqFTRKHR78PfWHSkKjP8LzQn6m58nvZEmnaQg19UJibOvjia5ePJgKiaROEfn8yKhWFw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（2）编码方式&lt;/p&gt;&lt;p&gt;如ASCII编码（上图），包含英文、数字等字符，每个字符1个字节。除此之外，还有GBK编码， Unicode字符集， UTF-8编码。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（3）相关函数&lt;/p&gt;&lt;p&gt; &lt;strong&gt;ord(字符串)&lt;/strong&gt;&lt;strong&gt;: &lt;/strong&gt;返回该字符串的Unicode码。&lt;/p&gt;&lt;p&gt; &lt;strong&gt;chr(整数):&lt;/strong&gt;返回该整数对应的字符串。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;apache&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 文字--&amp;gt;数字&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;num&lt;/span&gt; = ord(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;猪&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;print&lt;/span&gt;(num)  # 29482&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 数字--&amp;gt;文字&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;num&lt;/span&gt; = chr(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;29482&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;print&lt;/span&gt;(num) #猪&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）字面值&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;a.单双引号&lt;/p&gt;&lt;p&gt;都可以用，更常用双引号&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;b.三引号&lt;/p&gt;&lt;p&gt;换行会自动转换为换行符\n；&lt;/p&gt;&lt;p&gt;所见即所得；&lt;/p&gt;&lt;p&gt;可以作为文档字符串&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;c.转义字符&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;\&#x27; \&quot;  &lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;\n  #换行   \\  #\&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;url &lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt; r&quot;C:\a\b\c&quot;  #r表示字符串中没有转义字符&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6905790838375108&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uyZsSl2gvXVmhpFKITckyFqFTRKHR78PfXbMChW6gMxJiawZrkaPqZKSnYEiatglofazXXDIXhLLh7Z7raYjAk5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1157&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;d.字符串格式化&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;作用：生成一定格式的字符串。&lt;/p&gt;&lt;p&gt;语法：字符串%(变量)&lt;/p&gt;&lt;p&gt;&lt;strong&gt;类型码：%s 字符串 %d整数 %f浮点数&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.32456140350877194&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uyZsSl2gvXVmhpFKITckyFqFTRKHR78PZAOTQUdicGLiaCo8ecH63ib5RGaDTNteWfWlVUYKKaMr6xxK2vmMsSJSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1254&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;晚安，朋友们！明天将进行容器列表和元组的学习~&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.12&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U9kKudHzsK3W5c0NRAdWnuRVSW6XQyGvg6OGgAx0tyceatfwtlSTTwQN8GvP155mZttbHucmWyonfEPlOiamy9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;350&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot; data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.0859375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JrRY60XUiczCB0aAKusfQXhclcbPLWbWc64icUBDfxMM47JVqSw3IOFHpry1wBXo1ryBDcXMIAWicGppjb6JJ3RCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;256&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;参考资料：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[1] Python基础概念之迭代、可迭代对象、迭代器&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://blog.csdn.net/LaoYuanPython/article/details/89609187&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[2] &lt;/span&gt;python容器--字符串string&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://blog.csdn.net/weixin_42712423/article/details/90111633&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[3] &lt;/span&gt;计算机存储单位的换算关系&lt;/p&gt;&lt;p&gt;https://www.cnblogs.com/peteremperor/p/7120945.html&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;花样早餐展位&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.3333333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uyZsSl2gvXVmhpFKITckyFqFTRKHR78PPdI8Hy96dibUoS6AVYdH5tZNv5YJgxGwt3N4sseG7d5a4ticEGibiaMibrQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>