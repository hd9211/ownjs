<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>2409a874b625213881f487873a5b15ba</guid>
<title>Rust 开源：24 个绝佳框架、项目及资料库</title>
<link>https://toutiao.io/k/b2sfp14</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;关注「&lt;/span&gt;&lt;span&gt;Rust编程指北&lt;/span&gt;&lt;span&gt;」，一起学习 Rust，给未来投资&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了方便阅读，本文采用中英文对照的方式，英文颜色浅一些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rust has a very lively and fast-paced open source ecosystem, with a ton of contributors working on a ton of awesome projects.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rust拥有一个无比活跃且快节奏的开源生态系统，海量贡献者在这个系统中开展海量优质项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;And if you are asking – what can I build in Rust? The answer is almost everything.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而如果你还感到困惑：我能借助Rust打造什么呢？答案是：它几乎无所不能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;This article will feature some of the open-source Rust libraries, frameworks, and repositories that could be useful to study or use for your own project.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文将对一些开源Rust资料库、框架及储存库进行介绍，它们值得研究，而且或许还能直接运用到你的项目中去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;For your convenience, I’ve split them into fields such as web development, game development, blockchain, and others. Let’s dig in!&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了方便起见，我将分领域进行介绍，分别涵盖网页开发、游戏开发、区块链和其他领域。咱们开动吧！&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;Web development frameworks for Rust&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;Rust网站开发框架&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Can you build a web app with Rust? Definitely!&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你能用Rust建设一个网站应用吗？当然能！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rust has multiple extremely fast web frameworks – Rocket, Actix Web, and Yew – and you can use the one that matches your needs and preferences.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rust拥有多个极其快速的web框架——Rocket、Actix Web以及Yew——你可以根据自己的需求和偏好自行选择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rocket&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Rocket&lt;/span&gt;&lt;span&gt; is the most accessible web framework in the Rust ecosystem for beginners. It is highly customizable and helps you kickstart a new application quickly. At the same time, it avoids a lot of unnecessary boilerplate. Rocket also has many features included, which means that you won’t need to go far from the framework to build everything you need.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Rocket是Rust生态系统中最适合初学者使用的web框架。它&lt;/span&gt;&lt;span&gt;的可定制程度很高&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;能够&lt;/span&gt;&lt;span&gt;帮助&lt;/span&gt;&lt;span&gt;你&lt;/span&gt;&lt;span&gt;快速启动一个新的应用程序。同时，它&lt;/span&gt;&lt;span&gt;也规避了&lt;/span&gt;&lt;span&gt;许多不必要的样板&lt;/span&gt;&lt;span&gt;文件&lt;/span&gt;&lt;span&gt;。Rocket还&lt;/span&gt;&lt;span&gt;有&lt;/span&gt;&lt;span&gt;许多功能，这意味着&lt;/span&gt;&lt;span&gt;，在构建你需要的一切的时候，你都无需&lt;/span&gt;&lt;span&gt;远离&lt;/span&gt;&lt;span&gt;这个&lt;/span&gt;&lt;span&gt;框架。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;In contrast to Actix Web, the framework runs on nightly Rust – the “experimental” version of the language.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;与Actix Web相比，该框架在&lt;/span&gt;&lt;span&gt;所谓的nightly &lt;/span&gt;&lt;span&gt;Rust上&lt;/span&gt;&lt;span&gt;运行&lt;/span&gt;&lt;span&gt;——&lt;/span&gt;&lt;span&gt;这是&lt;/span&gt;&lt;span&gt;该语言的“实验”版本。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Actix Web&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Actix Web&lt;/span&gt;&lt;span&gt; is usually thought to be more performant and stable than Rocket. Underneath, it works with the actor model used in &lt;/span&gt;&lt;span&gt;Erlang&lt;/span&gt;&lt;span&gt; and &lt;/span&gt;&lt;span&gt;Akka.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;人们通常认为&lt;/span&gt;&lt;span&gt;Actix Web比Rocket性能更好、更&lt;/span&gt;&lt;span&gt;加&lt;/span&gt;&lt;span&gt;稳定。&lt;/span&gt;&lt;span&gt;在底层&lt;/span&gt;&lt;span&gt;，它与Erlang和Akka中使用的actor模型一&lt;/span&gt;&lt;span&gt;同&lt;/span&gt;&lt;span&gt;工作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;In contrast to Rocket, it’s less “batteries included”, meaning that you will most likely need to use third-party libraries for extra functionality.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;与Rocket相比，它&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;“内置组件”更少，这意味着你很可能需要使用第三方&lt;/span&gt;&lt;span&gt;资料&lt;/span&gt;&lt;span&gt;库来实现额外的功能。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Yew&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Yew&lt;/span&gt;&lt;span&gt; is a Rust framework for creating web apps with WebAssembly. Among its main benefits, it lists a component-based framework like in React and Elm, outstanding performance because of the multi-thread support, and JavaScript interoperability.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Yew&lt;/span&gt;&lt;span&gt;&lt;span&gt; 是一个Rust框架&lt;/span&gt;&lt;span&gt;，用于通过&lt;/span&gt;&lt;span&gt;WebAssembly创建web应用。它的主要优点是，它列出了一个基于组件的框架——这和React&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;Elm&lt;/span&gt;&lt;span&gt;是一样的；&lt;/span&gt;&lt;span&gt;由于多线程支持&lt;/span&gt;&lt;span&gt;，它具&lt;/span&gt;&lt;span&gt;有出色的性能&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;span&gt;以及JavaScript的互操作性。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;As of now, it is not production-ready but should be an excellent choice for side projects and internal tooling, especially if you want to work with WASM.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;到目前为止，它还不能用于生产，但是对于&lt;/span&gt;&lt;span&gt;编外&lt;/span&gt;&lt;span&gt;项目和内部工具来说，它应该是一个很好的选择——特别是如果&lt;/span&gt;&lt;span&gt;你&lt;/span&gt;&lt;span&gt;想使用WASM&lt;/span&gt;&lt;span&gt;的话&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Zola&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;If you need something quick and simple to serve a static website, &lt;/span&gt;&lt;span&gt;Zola&lt;/span&gt;&lt;span&gt; is a fantastic tool to create fast and scalable web pages without any other dependencies or JS bloat.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如果你需要一&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt;快速和简单的&lt;/span&gt;&lt;span&gt;工具&lt;/span&gt;&lt;span&gt;服务&lt;/span&gt;&lt;span&gt;于&lt;/span&gt;&lt;span&gt;静态网站，&lt;/span&gt;&lt;span&gt;那么&lt;/span&gt;&lt;span&gt;Zola&lt;/span&gt;&lt;span&gt;就&lt;/span&gt;&lt;span&gt;是一个奇妙的工具，&lt;/span&gt;&lt;span&gt;它可以帮助&lt;/span&gt;&lt;span&gt;创建快速&lt;/span&gt;&lt;span&gt;、可扩展&lt;/span&gt;&lt;span&gt;网页，没有任何其他&lt;/span&gt;&lt;span&gt;依赖关系&lt;/span&gt;&lt;span&gt;或JS膨胀。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Warp&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Warp&lt;/span&gt;&lt;span&gt; is a web server framework written in Rust. In comparison to Rocket and Actix, it is rather slim for a web framework and will provide you only with basic functionality out of the box.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Warp是一个用Rust编写的web服务器框架。作为一个web框架，与Rocket和Actix相比，它显得相当精简，只提供基本的开箱即用功能。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;Game development&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;游戏开发&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;shape type=&quot;#_x0000_t75&quot; filled=&quot;f&quot;&gt;&lt;imagedata title=&quot;image1&quot;/&gt;&lt;/shape&gt;&lt;img data-ratio=&quot;0.35108153078202997&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmhrPEkIgHWliawq4e2aWibGNqCIvh08aUriaH6gpN9BKqhH3Iwj5XR5tXlln8NmS6kUtsfib751t15BRWWnj893Rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;601&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rust is exceptional for game development for the same reason that C++ is: it is predictably performant. Here are some of the engines you can use to build your own Rust game.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;与C++一样，Rust在游戏开发&lt;/span&gt;&lt;span&gt;领域也有上佳表现&lt;/span&gt;&lt;span&gt;:它&lt;/span&gt;&lt;span&gt;具备让人感到踏实的&lt;/span&gt;&lt;span&gt;性能&lt;/span&gt;&lt;span&gt;表现&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;以下介绍的是一些游戏引擎，借助它们，你可以创建自己的Rust游戏。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Bevy&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Two of the main Rust game engines are Bevy and Amethyst. Among them, &lt;/span&gt;&lt;span&gt;Bevy&lt;/span&gt;&lt;span&gt; is the newer and cooler one. It is a simple, data-driven engine and can essentially be called Amethyst 2.0 since it is heavily inspired by it.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Rust的两个主要&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;游戏引擎&lt;/span&gt;&lt;span&gt;分别&lt;/span&gt;&lt;span&gt;是Bevy和Amethyst。其中，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Bevy&lt;/span&gt;&lt;span&gt;&lt;span&gt; 更新&lt;/span&gt;&lt;span&gt;，也&lt;/span&gt;&lt;span&gt;更酷。&lt;/span&gt;&lt;span&gt;它&lt;/span&gt;&lt;span&gt;是一个简单的数据驱动的引擎，本质上可以被称为Amethyst 2.0，因为它&lt;/span&gt;&lt;span&gt;很大程度上&lt;/span&gt;&lt;span&gt;受到了&lt;/span&gt;&lt;span&gt;后者&lt;/span&gt;&lt;span&gt;的启发。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;For more info on Bevy, you can check out the &lt;/span&gt;&lt;span&gt;Bevy book.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;欲知&lt;/span&gt;&lt;span&gt;更多关于Bevy的信息，&lt;/span&gt;&lt;span&gt;你可以参看&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Bevy &lt;/span&gt;&lt;span&gt;手册&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Amethyst&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Amethyst&lt;/span&gt;&lt;span&gt; is the more mature one of the two and, because of that, has more features that you might need for a large-scale project and better integrations with 3rd party libraries. But, Bevy is catching up fast. If you are searching for an engine for your new project, I’d recommend looking at them both and seeing which one you like better.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;二者相比较的话，&lt;/span&gt;&lt;span&gt;Amethyst&lt;/span&gt;&lt;span&gt;更加成熟。&lt;/span&gt;&lt;span&gt;正因为如此，它拥有更多&lt;/span&gt;&lt;span&gt;你在大型项目中可能用得着&lt;/span&gt;&lt;span&gt;的特性，并&lt;/span&gt;&lt;span&gt;且&lt;/span&gt;&lt;span&gt;与第三方&lt;/span&gt;&lt;span&gt;资料&lt;/span&gt;&lt;span&gt;库&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;集成&lt;/span&gt;&lt;span&gt;度也更好&lt;/span&gt;&lt;span&gt;。但是，Bevy正在迎头赶上。如果你正在为你的新项目寻找引擎&lt;/span&gt;&lt;span&gt;的话&lt;/span&gt;&lt;span&gt;，我&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;建议&lt;/span&gt;&lt;span&gt;是你把这两个引擎都研究一下&lt;/span&gt;&lt;span&gt;，看看&lt;/span&gt;&lt;span&gt;自己&lt;/span&gt;&lt;span&gt;更喜欢哪一个。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;ggez&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;If you are searching for something simple to start off, &lt;/span&gt;&lt;span&gt;ggez&lt;/span&gt;&lt;span&gt; is a lightweight cross-platform game framework for making 2D games with minimal friction.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你找的是一个简单的工具用于起步阶段的话，ggez是一个轻量级的跨平台游戏框架，可以帮助你在阻力最小的情况下开发2D游戏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.0016611295681063123&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmhrPEkIgHWliawq4e2aWibGNqCIvh08aUeuxZUsdAnSDZJibibnb0IDPFicGgwHrdHAZkM5ibmQEA0p5yw0x1xh2TXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;602&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;If you want to read more on game development in Rust, check out &lt;/span&gt;&lt;span&gt;Are we game yet?&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如欲了解更多在Rust上开发游戏的内容，请参看&lt;/span&gt;&lt;span&gt;开始游戏了吗&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;Operating systems&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;操作系统&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.35108153078202997&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmhrPEkIgHWliawq4e2aWibGNqCIvh08aUtO0yIhI3qlyQV63HvicZdT0CgEBpqewI81xa52zY1kslR1X6uxibx6Jw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;601&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Rust is an excellent alternative to C in operating system development since it offers the same level of performance while taking care of memory safety. Actually, developers &lt;/span&gt;&lt;span&gt;are investigating&lt;/span&gt;&lt;span&gt; the possibility of adding Rust to the Linux kernel, and Microsoft &lt;/span&gt;&lt;span&gt;is experimenting with it&lt;/span&gt;&lt;span&gt; as well.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Rust在操作系统开发中是C语言的&lt;/span&gt;&lt;span&gt;绝佳&lt;/span&gt;&lt;span&gt;替代品，因为它在保证内存安全的同时提供了相同水&lt;/span&gt;&lt;span&gt;准&lt;/span&gt;&lt;span&gt;的性能。实际上，开发人员正在研究将Rust添加到Linux内核的可能性，微软也&lt;/span&gt;&lt;span&gt;正&lt;/span&gt;&lt;span&gt;在对此&lt;/span&gt;&lt;span&gt;展开&lt;/span&gt;&lt;span&gt;试验。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Here are some open-source operating systems that are written purely in Rust:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下是一些纯粹使用Rust语言编写的开源操作系统：&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Redox&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Redox&lt;/span&gt;&lt;span&gt; is an operating system written in Rust that uses Rust’s innovations to build a modern microkernel.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redox是一个用Rust编写的操作系统，借助Rust的创新来构建现代微核。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;intermezzOS&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;intermezzOS&lt;/span&gt;&lt;span&gt; is a teaching operating system, specifically focused on introducing systems programming concepts to experienced developers from other programming areas.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;intermezzOS是一&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt;教学操作系统，侧重于向来自其他编程领域的有经验的开发人员介绍系统编程概念。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Theseus&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Theseus&lt;/span&gt;&lt;span&gt; is a new OS written in Rust that presents a novel OS structure and claims to avoid the phenomenon of state spill, a thing that occurs when one entity’s state is permanently changed through interactions with another.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Theseus&lt;/span&gt;&lt;span&gt;&lt;span&gt; 是一个用Rust&lt;/span&gt;&lt;span&gt;编写&lt;/span&gt;&lt;span&gt;的新操作系统，它提出了一个新的操作系统结构，并声称可以避免状态溢出现象——即一个实体的状态通过与另一个实体的交互而永久改变。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;There’s quite a lot to read about – here’s a &lt;/span&gt;&lt;span&gt;paper&lt;/span&gt;&lt;span&gt; on the project.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;这方面还有很多东西可以读，详情请参看这篇&lt;/span&gt;&lt;span&gt;文章&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;GUI development&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;图形用户界面开发&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.35108153078202997&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmhrPEkIgHWliawq4e2aWibGNqCIvh08aUxSEWOUYhzDQicVS7lFA6nxIYYTibFsQay6MKor72se4IAvs0vf6vwlEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;601&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;While Rust isn’t well known for its capability for building captivating user interfaces, there’s still a lot of good libraries to build GUIs with.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;虽然Rust在构建吸引人的用户界面方面并不出名，但仍然有很多好的&lt;/span&gt;&lt;span&gt;资料&lt;/span&gt;&lt;span&gt;库可以用来构建&lt;/span&gt;&lt;span&gt;图形用户界面&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Druid&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Druid&lt;/span&gt;&lt;span&gt; is an experimental Rust-native UI toolkit with a focus on building simple, polished user experiences. It is data-oriented and inspired by modern frameworks such as Flutter, SwiftUI, and others.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Druid&lt;/span&gt;&lt;span&gt; 是一个实验性的Rust原生UI工具包，专注于构建简单、精致的用户体验。它是面向数据的，并受到了Flutter、SwiftUI等现代框架的启发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;To learn more about it, you can check out the &lt;/span&gt;&lt;span&gt;Druid book.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如欲了解更多，请参看&lt;/span&gt;&lt;span&gt;Druid &lt;/span&gt;&lt;span&gt;手册&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Iced&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Iced&lt;/span&gt;&lt;span&gt; is a cross-platform GUI library with a focus on simplicity and type safety. It’s heavily inspired by Elm. While it is still experimental right now, it is an excellent option for creating GUIs right in Rust for your side project.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Iced是一个关注&lt;/span&gt;&lt;span&gt;简洁&lt;/span&gt;&lt;span&gt;性和类型安全的跨平台&lt;/span&gt;&lt;span&gt;图形用户界面&lt;/span&gt;&lt;span&gt;库。它很大程度上&lt;/span&gt;&lt;span&gt;受到了Elm的启发&lt;/span&gt;&lt;span&gt;。虽然它现在还处于实验阶段，但它是在Rust中为项目创建&lt;/span&gt;&lt;span&gt;图形用户界面&lt;/span&gt;&lt;span&gt;的绝佳选择。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;The Orbital Widget Toolkit&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;轨道部件工具包&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;The Orbital Widget Toolkit&lt;/span&gt;&lt;span&gt; is a cross-platform toolkit for building scalable user interfaces with Rust. It’s focused on speed, ease of use, and cross-platform compatibility.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;轨道部件工具包&lt;/span&gt;&lt;span&gt;&lt;span&gt;是一个跨平台的工具包，用于&lt;/span&gt;&lt;span&gt;借助&lt;/span&gt;&lt;span&gt;Rust构建可&lt;/span&gt;&lt;span&gt;扩展&lt;/span&gt;&lt;span&gt;用户界面。它专注于速度、易用性和跨平台兼容性。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Tauri&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Tauri&lt;/span&gt;&lt;span&gt; is a framework for building desktop applications for Windows, Linux, and macOS. With it, you can use any front-end framework that compiles to HTML/CSS/JS for building UIs, and Rust as the backend.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Tauri&lt;/span&gt;&lt;span&gt;&lt;span&gt; 是用于为Windows、Linux和macOS构建桌面应用的框架。&lt;/span&gt;&lt;span&gt;有了&lt;/span&gt;&lt;span&gt;它，你&lt;/span&gt;&lt;span&gt;就&lt;/span&gt;&lt;span&gt;可以使用任何可以编译成HTML/CSS/JS来构建&lt;/span&gt;&lt;span&gt;用户界面&lt;/span&gt;&lt;span&gt;的前端框架，并将Rust作为后端。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmhrPEkIgHWliawq4e2aWibGNqCIvh08aUeuxZUsdAnSDZJibibnb0IDPFicGgwHrdHAZkM5ibmQEA0p5yw0x1xh2TXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.0016611295681063123&quot; data-w=&quot;602&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;If you want to learn more about GUI development possibilities in Rust, &lt;/span&gt;&lt;span&gt;here’s a big post&lt;/span&gt;&lt;span&gt; that covers most of the libraries.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如欲&lt;/span&gt;&lt;span&gt;了解更多关于&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;Rust中开发&lt;/span&gt;&lt;span&gt;图形用户界面&lt;/span&gt;&lt;span&gt;的可能性，&lt;/span&gt;&lt;span&gt;可以参看这篇&lt;/span&gt;&lt;span&gt;干货贴&lt;/span&gt;&lt;span&gt;，里面&lt;/span&gt;&lt;span&gt;涵盖了大部分&lt;/span&gt;&lt;span&gt;资料&lt;/span&gt;&lt;span&gt;库。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;Blockchain&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;区块链&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.35108153078202997&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmhrPEkIgHWliawq4e2aWibGNqCIvh08aU42oz47AjrsENMPblO3pG3qnYrIgtxHUp7l2qAtCHSG2Yb6H3xdGibyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;601&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;OpenEthereum&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;The main goal of &lt;/span&gt;&lt;span&gt;OpenEthereum&lt;/span&gt;&lt;span&gt; is to be the fastest, lightest, and most secure Ethereum client. It is developed with Rust and claims to provide core infrastructure that is essential for speedy and reliable services.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Open&lt;/span&gt;&lt;span&gt;以太坊&lt;/span&gt;&lt;span&gt;&lt;span&gt; 的主要目标是成为最快、最轻、最安全的以太坊客户端。它是&lt;/span&gt;&lt;span&gt;用&lt;/span&gt;&lt;span&gt;Rust开发的，并声称提供&lt;/span&gt;&lt;span&gt;了对快速可靠服务至关重要的&lt;/span&gt;&lt;span&gt;核心基础设施。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Lighthouse&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Lighthouse&lt;/span&gt;&lt;span&gt; is an open-source Ethereum 2.0 client, written in Rust and maintained by Sigma Prime.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Lighthouse&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;是一个开源以太坊2.0客户端，是用Rust编写的，由Sigma Prime维护。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Parity Technologies: Polkadot and Substrate&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;奇偶校验技术：Polkadot和Substrate&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;Parity Technologies works on building blockchain infrastructure for the decentralized web.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;奇偶校验技术&lt;/span&gt;&lt;span&gt;致力于为去中心化的网络构建区块链基础设施。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Among its projects are &lt;/span&gt;&lt;span&gt;Substrate&lt;/span&gt;&lt;span&gt;, a modular framework for blockchain development, and &lt;/span&gt;&lt;span&gt;Polkadot, a network of blockchains. Both of these projects heavily use Rust in their implementations.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;该公司的项目包括用于区块链开发的模块化框架Substrate和区块链网络Polkadot。这两个项目&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;实现&lt;/span&gt;&lt;span&gt;过程&lt;/span&gt;&lt;span&gt;都大量&lt;/span&gt;&lt;span&gt;借助&lt;/span&gt;&lt;span&gt;了Rust&lt;/span&gt;&lt;span&gt;语言&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;Other projects&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;其他项目&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.35108153078202997&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmhrPEkIgHWliawq4e2aWibGNqCIvh08aUT5iasUGVAl3JZUhzhehOGP8bvCibjiaicmeEvk27ccbw4VRCibLWFejkbcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;601&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Here are some of the projects that don’t fit into any given category. Hope you can find something awesome in this collection of “things”. :)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下项目不属于任何特定类别。愿你能在这些“东西”中找到一些很棒的东西。：）&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Servo&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Servo&lt;/span&gt;&lt;span&gt; is a web engine prototype written in Rust. It’s the result of Mozilla’s work on creating a new, open-source browser engine. In 2020, Servo moved on from Mozilla to being hosted by the Linux Foundation.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Servo&lt;/span&gt;&lt;span&gt;&lt;span&gt; 是一个用Rust编写的web引擎原型。Mozilla致力于创建一个新的开源浏览器引擎&lt;/span&gt;&lt;span&gt;，而Servo就是其努力&lt;/span&gt;&lt;span&gt;的成果。2020年，Servo从Mozilla转向Linux基金会托管。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Servo is supposed to be safer than the browsers written in C++ due to Rust’s memory safety guarantees that reduce the number of vulnerabilities.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Servo 被认为比用C++编写的浏览器更安全，因为Rust的内存安全保证&lt;/span&gt;&lt;span&gt;能够&lt;/span&gt;&lt;span&gt;减少漏洞数量。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;swc&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;swc&lt;/span&gt;&lt;span&gt; is a superfast JavaScript/TypeScript compiler. In comparison to Babel, it has been benchmarked to increase the compilation speed at least 18 times.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;swc&lt;/span&gt;&lt;span&gt; 是一个超快的JavaScript/TypeScript编译器。与Babel相比，它的编译速度至少提高了18倍。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Ruffle&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Want to run all the cool Flash games that Adobe has recently disabled support for? You can use &lt;/span&gt;&lt;span&gt;Ruffle, a Flash player emulator written in Rust.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;你&lt;/span&gt;&lt;span&gt;想运行Adobe最近禁用的所有&lt;/span&gt;&lt;span&gt;超酷的&lt;/span&gt;&lt;span&gt;Flash游戏吗?你可以使用&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Ruffle&lt;/span&gt;&lt;span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;它是&lt;/span&gt;&lt;span&gt;一个用Rust编写的Flash播放模拟器。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;You can try it out on &lt;/span&gt;&lt;span&gt;ruffle.rs.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击&lt;/span&gt;&lt;span&gt;ruffle.rs&lt;/span&gt;&lt;span&gt;试试吧。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Lunatic&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Lunatic&lt;/span&gt;&lt;span&gt; is an experimental platform that uses WASM instances as actors to structure execution. It is heavily inspired by &lt;/span&gt;&lt;span&gt;Erlang.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Lunatic&lt;/span&gt;&lt;span&gt;&lt;span&gt; 是一个实验平台，它使用WASM实例作为参与者来&lt;/span&gt;&lt;span&gt;构建&lt;/span&gt;&lt;span&gt;执行。它很大程度上受到了&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Erlang&lt;/span&gt;&lt;span&gt;的启发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;It is supposed to unite the good sides of WASM and Erlang, enabling you to build actor-based systems that are both fault-tolerant and blazingly fast.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;它&lt;/span&gt;&lt;span&gt;旨在&lt;/span&gt;&lt;span&gt;将WASM和Erlang的优点&lt;/span&gt;&lt;span&gt;整合&lt;/span&gt;&lt;span&gt;起来，使&lt;/span&gt;&lt;span&gt;你&lt;/span&gt;&lt;span&gt;能够构建既容错又快速的基于参与者的系统。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Starship&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Starship&lt;/span&gt;&lt;span&gt; is a fast, customizable, and intelligent prompt for those that want to make their shell cooler.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Starship&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;是一个快速的、可定制的智能提示符，适合那些希望自己的外壳更酷的人。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;MeiliSearch&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;MeiliSearch&lt;/span&gt;&lt;span&gt; is a powerful, fast, easy to use, and customizable search engine that’s also typo-tolerant. Now that’s a lot of adjectives! You can set it up for your own project instead of a custom and probably worse-performing solution.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MeiliSearch&lt;/span&gt;&lt;span&gt;&lt;span&gt; 是一个强大&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;快速&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;易于&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;可定制&lt;/span&gt;&lt;span&gt;、具有容错性&lt;/span&gt;&lt;span&gt;的搜索引擎。&lt;/span&gt;&lt;span&gt;这可真是一大堆&lt;/span&gt;&lt;span&gt;形容词啊!&lt;/span&gt;&lt;span&gt;你&lt;/span&gt;&lt;span&gt;可以&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;项目&lt;/span&gt;&lt;span&gt;里用它&lt;/span&gt;&lt;span&gt;，而不是&lt;/span&gt;&lt;span&gt;转投&lt;/span&gt;&lt;span&gt;定制的&lt;/span&gt;&lt;span&gt;，而且可能性能&lt;/span&gt;&lt;span&gt;更差的解决方案。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;Have anything to add?&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;还有什么要补充的吗？&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;As you can see, the ecosystem is vast, and there is a lot to explore. I certainly wasn’t able to cover everything. If you know of a project that deserves to be here, don’t be afraid to let us know on &lt;/span&gt;&lt;span&gt;Twitter!&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;正如你所看到的，&lt;/span&gt;&lt;span&gt;这个&lt;/span&gt;&lt;span&gt;生态系统&lt;/span&gt;&lt;span&gt;非常&lt;/span&gt;&lt;span&gt;巨大，有很多&lt;/span&gt;&lt;span&gt;内容&lt;/span&gt;&lt;span&gt;可以探索。当然，我&lt;/span&gt;&lt;span&gt;在这一无法一一详述&lt;/span&gt;&lt;span&gt;。如果你知道&lt;/span&gt;&lt;span&gt;什么&lt;/span&gt;&lt;span&gt;值得在这里&lt;/span&gt;&lt;span&gt;讨论&lt;/span&gt;&lt;span&gt;的项目，&lt;/span&gt;&lt;span&gt;请在&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Twitter&lt;/span&gt;&lt;span&gt;上告诉我们!&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;If you want to learn more about Rust, I suggest going to our blog’s &lt;/span&gt;&lt;span&gt;Rust section. Have fun!&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如欲了解更多关于Rust的内容，建议访问我们博客上的&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;专篇（https://serokell.io/blog/rust）&lt;/span&gt;&lt;span&gt;。祝你开心！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原文链接：https://serokell.io/blog/open-source-rust&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;觉得不错，点个赞吧&lt;/p&gt;&lt;p&gt;扫码关注「&lt;span&gt;Rust编程指北&lt;/span&gt;」&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kmhrPEkIgHUOxOIbBEsyACGOicYC9vRw0NtRrW7BsnWWmBjtwvOLEO75Yxib6ViagwACCA1z7p29eG6HCad48fXAA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>682a8772255876bcc2d08c5f74554ac4</guid>
<title>使用 Go defer 要小心这 2 个雷区</title>
<link>https://toutiao.io/k/ye8mh35</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是煎鱼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 语言中 defer 是一个非常有意思的关键字特性。例子如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; fmt.Println(&lt;span&gt;&quot;煎鱼了&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;脑子进&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;脑子进&lt;br/&gt;煎鱼了&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前几天我的读者群内有小伙伴讨论起了下面这个问题：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6857142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4j5DWNOwFianbpNnjqOghR07YfDzZ9rk5vclcUzSUJJoh1kY5KZORcNIOw9LFxRMicE4RdUYlbhBjwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1330&quot;/&gt;&lt;figcaption&gt;读者群的聊天截图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来讲，&lt;strong&gt;问题就是针对在 &lt;code&gt;for&lt;/code&gt; 循环里搞 defer 关键字，是否会造成什么性能影响&lt;/strong&gt;？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为在 Go 语言的底层数据结构设计上 defer 是链表的数据结构：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6497297297297298&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4j5DWNOwFianbpNnjqOghR07IeOiaSsWAhpwrtjcW6libeoAsnrVibjibQIrgfRy5c5fn2Cqib2Kq2bTxZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;925&quot;/&gt;&lt;figcaption&gt;defer 基本底层结构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家担心如果循环过大 defer 链表会巨长，不够 “精益求精”。又或是猜想会不会 Go defer 的设计和 Redis 数据结构设计类似，自己做了优化，其实没啥大影响？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天这篇文章，我们就来探索循环 Go defer，造成底层链表过长会不会带来什么问题，若有，具体有什么影响？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开始吸鱼之路。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;defer 性能优化 30%&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在早年 Go1.13 时曾经对 defer 进行了一轮性能优化，在大部分场景下 提高了 defer 30% 的性能：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4045734388742304&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4j5DWNOwFianbpNnjqOghR07DDPUAK32entwibdibwhHiahPoc5NGWfFY9zgBibe3OIcwbSXYW9xdw06Bw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2274&quot;/&gt;&lt;figcaption&gt;Go defer 1.13 优化记录&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来回顾一下 Go1.13 的变更，看看 Go defer 优化在了哪里，这是问题的关键点。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;以前和现在对比&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go1.12 及以前，调用 Go defer 时汇编代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    0x0070 00112 (main.go:6)    CALL    runtime.deferproc(SB)&lt;br/&gt;    0x0075 00117 (main.go:6)    TESTL    AX, AX&lt;br/&gt;    0x0077 00119 (main.go:6)    JNE    137&lt;br/&gt;    0x0079 00121 (main.go:7)    XCHGL    AX, AX&lt;br/&gt;    0x007a 00122 (main.go:7)    CALL    runtime.deferreturn(SB)&lt;br/&gt;    0x007f 00127 (main.go:7)    MOVQ    56(SP), BP&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go1.13 及以后，调用 Go defer 时汇编代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; 0x006e 00110 (main.go:4) MOVQ AX, (SP)&lt;br/&gt; 0x0072 00114 (main.go:4) CALL runtime.deferprocStack(SB)&lt;br/&gt; 0x0077 00119 (main.go:4) TESTL AX, AX&lt;br/&gt; 0x0079 00121 (main.go:4) JNE 139&lt;br/&gt; 0x007b 00123 (main.go:7) XCHGL AX, AX&lt;br/&gt; 0x007c 00124 (main.go:7) CALL runtime.deferreturn(SB)&lt;br/&gt; 0x0081 00129 (main.go:7) MOVQ 112(SP), BP&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从汇编的角度来看，像是原本调用 &lt;code&gt;runtime.deferproc&lt;/code&gt; 方法改成了调用 &lt;code&gt;runtime.deferprocStack&lt;/code&gt; 方法，难道是做了什么优化？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们&lt;strong&gt;抱着疑问&lt;/strong&gt;继续看下去。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;defer 最小单元：_defer&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相较于以前的版本，Go defer 的最小单元 &lt;code&gt;_defer&lt;/code&gt; 结构体主要是新增了 &lt;code&gt;heap&lt;/code&gt; 字段：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; _defer struct {&lt;br/&gt; siz     int32&lt;br/&gt; siz     int32 // includes both arguments and results&lt;br/&gt; started bool&lt;br/&gt; heap    bool&lt;br/&gt; sp      uintptr // sp at time of defer&lt;br/&gt; pc      uintptr&lt;br/&gt; fn      *funcval&lt;br/&gt; ...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该字段用于标识这个 &lt;code&gt;_defer&lt;/code&gt; 是在堆上，还是在栈上进行分配，其余字段并没有明确变更，那我们可以把聚焦点放在 &lt;code&gt;defer&lt;/code&gt; 的堆栈分配上了，看看是做了什么事。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;deferprocStack&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func deferprocStack(d *_defer) {&lt;br/&gt; gp := getg()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; gp.m.curg != gp {&lt;br/&gt;  throw(&lt;span&gt;&quot;defer on system stack&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt; &lt;br/&gt; d.started = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; d.heap = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; d.sp = getcallersp()&lt;br/&gt; d.pc = getcallerpc()&lt;br/&gt;&lt;br/&gt; *(*uintptr)(unsafe.Pointer(&amp;amp;d._panic)) = 0&lt;br/&gt; *(*uintptr)(unsafe.Pointer(&amp;amp;d.link)) = uintptr(unsafe.Pointer(gp._defer))&lt;br/&gt; *(*uintptr)(unsafe.Pointer(&amp;amp;gp._defer)) = uintptr(unsafe.Pointer(d))&lt;br/&gt;&lt;br/&gt; return0()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一块代码挺常规的，主要是获取调用 &lt;code&gt;defer&lt;/code&gt; 函数的函数栈指针、传入函数的参数具体地址以及PC（程序计数器），这块在前文 《深入理解 Go defer》 有详细介绍过，这里就不再赘述了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个 &lt;code&gt;deferprocStack&lt;/code&gt; 特殊在哪呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到它把 &lt;code&gt;d.heap&lt;/code&gt; 设置为了 &lt;code&gt;false&lt;/code&gt;，也就是代表 &lt;code&gt;deferprocStack&lt;/code&gt; 方法是针对将 &lt;code&gt;_defer&lt;/code&gt; 分配在栈上的应用场景的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;deferproc&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题来了，它又在哪里处理分配到堆上的应用场景呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func newdefer(siz int32) *_defer {&lt;br/&gt; ...&lt;br/&gt; d.heap = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; d.link = gp._defer&lt;br/&gt; gp._defer = d&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; d&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的 &lt;code&gt;newdefer&lt;/code&gt; 是在哪里调用的呢，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func deferproc(siz int32, fn *funcval) { // arguments of fn follow fn&lt;br/&gt; ...&lt;br/&gt; sp := getcallersp()&lt;br/&gt; argp := uintptr(unsafe.Pointer(&amp;amp;fn)) + unsafe.Sizeof(fn)&lt;br/&gt; callerpc := getcallerpc()&lt;br/&gt;&lt;br/&gt; d := newdefer(siz)&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常明确，先前的版本中调用的 &lt;code&gt;deferproc&lt;/code&gt; 方法，现在被用于对应分配到堆上的场景了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小结&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可以确定的是 &lt;code&gt;deferproc&lt;/code&gt; 并没有被去掉，而是流程被优化了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Go 编译器会根据应用场景去选择使用 &lt;code&gt;deferproc&lt;/code&gt; 还是 &lt;code&gt;deferprocStack&lt;/code&gt; 方法，他们分别是针对分配在堆上和栈上的使用场景。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;优化在哪儿&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要优化在于其 defer 对象的堆栈分配规则的改变，措施是：编译器对 &lt;code&gt;defer&lt;/code&gt; 的 &lt;code&gt;for-loop&lt;/code&gt; 迭代深度进行分析。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// src/cmd/compile/internal/gc/esc.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; ODEFER:&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; e.loopdepth == &lt;span&gt;1&lt;/span&gt; { &lt;span&gt;// top level&lt;/span&gt;&lt;br/&gt;  n.Esc = EscNever &lt;span&gt;// force stack allocation of defer record (see ssa.go)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;break&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 Go 编译器检测到循环深度（loopdepth）为 1，则设置逃逸分析的结果，将分配到栈上，否则分配到堆上。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// src/cmd/compile/internal/gc/ssa.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; ODEFER:&lt;br/&gt; d := callDefer&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; n.Esc == EscNever {&lt;br/&gt;  d = callDeferStack&lt;br/&gt; }&lt;br/&gt; s.call(n.Left, d)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以此免去了以前频繁调用 &lt;code&gt;systemstack&lt;/code&gt;、&lt;code&gt;mallocgc&lt;/code&gt; 等方法所带来的大量性能开销，来达到大部分场景提高性能的作用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;循环调用 defer&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到问题本身，知道了 defer 优化的原理后。那 “循环里搞 defer 关键字，是否会造成什么性能影响？”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最直接的影响就是这大约 30% 的性能优化直接全无，且由于姿势不正确，理论上 defer 既有的开销（链表变长）也变大，性能变差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此我们要避免以下两种场景的代码：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;显式循环：在调用 defer 关键字的外层有显式的循环调用，例如：&lt;code&gt;for-loop&lt;/code&gt; 语句等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;隐式循环：在调用 defer 关键字有类似循环嵌套的逻辑，例如：&lt;code&gt;goto&lt;/code&gt; 语句等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;显式循环&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个例子是直接在代码的 &lt;code&gt;for&lt;/code&gt; 循环中使用 defer 关键字：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt;= &lt;span&gt;99&lt;/span&gt;; i++ {&lt;br/&gt;  &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   fmt.Println(&lt;span&gt;&quot;脑子进煎鱼了&quot;&lt;/span&gt;)&lt;br/&gt;  }()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个也是最常见的模式，无论是写爬虫时，又或是 Goroutine 调用时，不少人都喜欢这么写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这属于显式的调用了循环。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;隐式循环&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个例子是在代码中使用类似 &lt;code&gt;goto&lt;/code&gt; 关键字：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; i := &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;food:&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {}()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; i == &lt;span&gt;1&lt;/span&gt; {&lt;br/&gt;  i -= &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;goto&lt;/span&gt; food&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种写法比较少见，因为 &lt;code&gt;goto&lt;/code&gt; 关键字有时候甚至会被列为代码规范不给使用，主要是会造成一些滥用，所以大多数就选择其实方式实现逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这属于隐式的调用，造成了类循环的作用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然，Defer 在设计上并没有说做的特别的奇妙。他主要是根据实际的一些应用场景进行了优化，达到了较好的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然本身 defer 会带一点点开销，但并没有想象中那么的不堪使用。除非你 defer 所在的代码是需要频繁执行的代码，才需要考虑去做优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;否则没有必要过度纠结，在实际上，猜测或遇到性能问题时，看看 PProf 的分析，看看 defer 是不是在相应的 hot path 之中，再进行合理优化就好。&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓的优化，可能也只是去掉 defer 而采用手动执行，并不复杂。在编码时避免踩到 defer 的显式和隐式循环这 2 个雷区就可以达到性能最大化了。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7bde04f4daf634219245239d724f1140</guid>
<title>面试官：两个 nil 比较结果是什么？</title>
<link>https://toutiao.io/k/otmhhst</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;背景&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;哈喽，大家好，我是&lt;code&gt;asong&lt;/code&gt;。前几天在一个交流群里看到了一道非常有意思的面试题，今天把它分享出来，我们先来看一下这个道题：&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;fmt.Println(&lt;span&gt;nil&lt;/span&gt;== &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两个&lt;code&gt;nil&lt;/code&gt;的比较结果是什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;true&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;、还是无法编译？大家先思考着，文中揭晓答案。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;写在开始：&lt;strong&gt;建议你们看一下这个视频：https://www.youtube.com/watch?v=ynoY2xz-F8s&lt;/strong&gt;  &lt;strong&gt;需要翻墙哈，看完这个你对&lt;code&gt;nil&lt;/code&gt;会有一个新的理解。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go中&lt;code&gt;nil&lt;/code&gt;的定义&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;Go&lt;/code&gt;官方文档中，对&lt;code&gt;nil&lt;/code&gt;的定义如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// nil is a predeclared identifier representing the zero value for a&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// pointer, channel, func, interface, map, or slice type.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; Type &lt;span&gt;// Type must be a pointer, channel, func, interface, map, or slice type&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;nil&lt;/code&gt;是一个预先声明的标识符，代表指针(&lt;code&gt;pointer&lt;/code&gt;)、通道(&lt;code&gt;channel&lt;/code&gt;)、函数(&lt;code&gt;func&lt;/code&gt;)、接口(&lt;code&gt;interface&lt;/code&gt;)、&lt;code&gt;map&lt;/code&gt;、切片(&lt;code&gt;slice&lt;/code&gt;)。也可以这么理解：指针、通道、函数、接口、map、切片的零值就是&lt;code&gt;nil&lt;/code&gt;，就像布尔类型的零值是&lt;code&gt;false&lt;/code&gt;、整型的零值是&lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;深入理解&lt;code&gt;nil&lt;/code&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;nil&lt;/code&gt;根本不是关键字&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看一段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;nil&lt;/span&gt; := &lt;span&gt;&quot;this is nil&quot;&lt;/span&gt;&lt;br/&gt; fmt.Println(&lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;this is &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那再改成这样呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;nil&lt;/span&gt; := &lt;span&gt;&quot;this is nil&quot;&lt;/span&gt;&lt;br/&gt; fmt.Println(&lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; slice []&lt;span&gt;string&lt;/span&gt; = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; fmt.Println(slice)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;# command-line-arguments&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;6&lt;/span&gt;: cannot use &lt;span&gt;nil&lt;/span&gt; (&lt;span&gt;type&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) as &lt;span&gt;type&lt;/span&gt; []&lt;span&gt;string&lt;/span&gt; in assignment&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译的时候直接报错了，因为这个&lt;code&gt;nil&lt;/code&gt;是一个&lt;code&gt;string&lt;/code&gt;类型，所以从这里确定&lt;code&gt;nil&lt;/code&gt;在&lt;code&gt;Go&lt;/code&gt;语言中并不是关键字，我们可以随意定义变量名为&lt;code&gt;nil&lt;/code&gt;（不过不建议这么用）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;nil&lt;/code&gt;的默认类型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般预声明标识符都会有一个默认类型，比如&lt;code&gt;Go&lt;/code&gt;语言中的&lt;code&gt;itoa&lt;/code&gt;默认类型就是&lt;code&gt;int&lt;/code&gt;，那么&lt;code&gt;nil&lt;/code&gt;的默认类型呢？我们写个例子来看一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;const&lt;/span&gt; val1 = &lt;span&gt;iota&lt;/span&gt;&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;%T\n&quot;&lt;/span&gt;,val1)&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; val2 = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;%T\n&quot;&lt;/span&gt;,val2)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;# command-line-arguments&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;6&lt;/span&gt;: use of untyped &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在编译时就已经报错，编译器告诉我们使用了无类型的&lt;code&gt;nil&lt;/code&gt;，所以我们可以得出结论：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;nil&lt;/code&gt;是没有默认类型的，它的类型具有不确定性，我们在使用它时必须要提供足够的信息能够让编译器推断&lt;code&gt;nil&lt;/code&gt;期望的类型。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;nil&lt;/code&gt;的比较&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;nil&lt;/code&gt;的比较我们可以分为以下两种情况：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看一下&lt;code&gt;nil&lt;/code&gt;标识符的比较，也就是我们开头那一道面试题，先看一下运行结果呢：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;# command-line-arguments&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;8&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: &lt;span&gt;nil&lt;/span&gt; == &lt;span&gt;nil&lt;/span&gt; (operator == not defined on &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过编译结果我们可以看出&lt;code&gt;==&lt;/code&gt;符号对于&lt;code&gt;nil&lt;/code&gt;来说是一种未定义的操作，所以是不可以比较两个&lt;code&gt;nil&lt;/code&gt;的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着我们来看一看&lt;code&gt;nil&lt;/code&gt;的值比较，因为&lt;code&gt;nil&lt;/code&gt;是没有类型的，是在编译期根据上下文确定的，所以要比较&lt;code&gt;nil&lt;/code&gt;的值也就是比较不同类型的&lt;code&gt;nil&lt;/code&gt;，这又分为同一个类型的&lt;code&gt;nil&lt;/code&gt;值比较和不同类型&lt;code&gt;nil&lt;/code&gt;值的比较，分这两种情况我们分别来验证一下。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;// 指针类型的nil比较&lt;/span&gt;&lt;br/&gt; fmt.Println((*&lt;span&gt;int64&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;) == (*&lt;span&gt;int64&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;))&lt;br/&gt; &lt;span&gt;// channel 类型的nil比较&lt;/span&gt;&lt;br/&gt; fmt.Println((&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;) == (&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;))&lt;br/&gt; &lt;span&gt;// func类型的nil比较&lt;/span&gt;&lt;br/&gt; fmt.Println((&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;)&lt;span&gt;(&lt;span&gt;nil&lt;/span&gt;)&lt;/span&gt; == &lt;span&gt;(&lt;span&gt;func&lt;/span&gt;()&lt;/span&gt;)&lt;span&gt;(&lt;span&gt;nil&lt;/span&gt;)&lt;/span&gt;) // &lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; 只能与&lt;span&gt;nil&lt;/span&gt;进行比较&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// interface类型的nil比较&lt;/span&gt;&lt;br/&gt; fmt.Println((&lt;span&gt;interface&lt;/span&gt;{})(&lt;span&gt;nil&lt;/span&gt;) == (&lt;span&gt;interface&lt;/span&gt;{})(&lt;span&gt;nil&lt;/span&gt;))&lt;br/&gt; &lt;span&gt;// map类型的nil比较&lt;/span&gt;&lt;br/&gt; fmt.Println((&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;) == (&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;)) &lt;span&gt;// map 只能与nil进行比较&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// slice类型的nil比较&lt;/span&gt;&lt;br/&gt; fmt.Println(([]&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;) == ([]&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;)) &lt;span&gt;// slice 只能与nil进行比较&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;# command-line-arguments&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;28&lt;/span&gt;: invalid operation: (&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;)&lt;span&gt;(&lt;span&gt;nil&lt;/span&gt;)&lt;/span&gt; == &lt;span&gt;(&lt;span&gt;func&lt;/span&gt;()&lt;/span&gt;)&lt;span&gt;(&lt;span&gt;nil&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;span&gt;func&lt;/span&gt; can only be compared to &lt;span&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt;:&lt;span&gt;36&lt;/span&gt;: invalid operation: (&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;) == (&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;) (&lt;span&gt;map&lt;/span&gt; can only be compared to &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt;:&lt;span&gt;27&lt;/span&gt;: invalid operation: ([]&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;) == ([]&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;) (slice can only be compared to &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从运行结果我们可以看出，指针类型&lt;code&gt;nil&lt;/code&gt;、&lt;code&gt;channel&lt;/code&gt;类型的&lt;code&gt;nil&lt;/code&gt;、&lt;code&gt;interface&lt;/code&gt;类型可以相互比较，而&lt;code&gt;func&lt;/code&gt;类型、&lt;code&gt;map&lt;/code&gt;类型、&lt;code&gt;slice&lt;/code&gt;类型只能与&lt;code&gt;nil&lt;/code&gt;标识符比较，两个类型相互比较是不合法的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; ptr *&lt;span&gt;int64&lt;/span&gt; = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; cha &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt; = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; fun &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; = &lt;span&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; inter &lt;span&gt;interface&lt;/span&gt;{} = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; ma &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt; = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; slice []&lt;span&gt;int64&lt;/span&gt; = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; fmt.Println(ptr == cha)&lt;br/&gt; fmt.Println(ptr == fun)&lt;br/&gt; fmt.Println(ptr == inter)&lt;br/&gt; fmt.Println(ptr == ma)&lt;br/&gt; fmt.Println(ptr == slice)&lt;br/&gt;&lt;br/&gt; fmt.Println(cha == fun)&lt;br/&gt; fmt.Println(cha == inter)&lt;br/&gt; fmt.Println(cha == ma)&lt;br/&gt; fmt.Println(cha == slice)&lt;br/&gt;&lt;br/&gt; fmt.Println(fun == inter)&lt;br/&gt; fmt.Println(fun == ma)&lt;br/&gt; fmt.Println(fun == slice)&lt;br/&gt;&lt;br/&gt; fmt.Println(inter == ma)&lt;br/&gt; fmt.Println(inter == slice)&lt;br/&gt;&lt;br/&gt; fmt.Println(ma == slice)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;# command-line-arguments&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: ptr == cha (mismatched types *&lt;span&gt;int64&lt;/span&gt; and &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt;)&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;15&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: ptr == fun (mismatched types *&lt;span&gt;int64&lt;/span&gt; and &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: ptr == ma (mismatched types *&lt;span&gt;int64&lt;/span&gt; and &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt;)&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: ptr == slice (mismatched types *&lt;span&gt;int64&lt;/span&gt; and []&lt;span&gt;int64&lt;/span&gt;)&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: cha == fun (mismatched types &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt; and &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;22&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: cha == ma (mismatched types &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt; and &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt;)&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;23&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: cha == slice (mismatched types &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt; and []&lt;span&gt;int64&lt;/span&gt;)&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: fun == inter (operator == not defined on &lt;span&gt;&lt;span&gt;func&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;26&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: fun == ma (mismatched types &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;27&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: fun == slice (mismatched types &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; []&lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;27&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: too many errors&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从运行结果我们可以得出，只有指针类型和channel类型与接口类型可以比较，其他类型的之间是不可以相互比较的。为什么指针类型、channel类型可以和接口类型进行比较呢？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这个答案，先空着，因为我也没有想明白，不是说/任何类型都实现了interface{}类型吗？这里没想明白，期待你们的解答。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;nil&lt;/code&gt;在不同类型中使用需要注意的问题&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;interface&lt;/code&gt;与&lt;code&gt;nil&lt;/code&gt;比较要注意的一个点&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看一个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; err := Todo()&lt;br/&gt; fmt.Println(err == &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Err &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; err &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Code &lt;span&gt;int64&lt;/span&gt;&lt;br/&gt; Msg &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Todo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;Err&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; res *err&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果是&lt;code&gt;false&lt;/code&gt;，在&lt;code&gt;Todo&lt;/code&gt;方法内我们声明了一个变量&lt;code&gt;res&lt;/code&gt;，这个变量是一个指针类型，零值是&lt;code&gt;nil&lt;/code&gt;，返回的是接口类型，按理说返回值接口类型也应是&lt;code&gt;nil&lt;/code&gt;才对，但是结果却不是这样。这是因为我们忽略了接口类型的一个概念，interface 不是单纯的值，而是分为类型和值。所以必须要类型和值同时都为 &lt;code&gt;nil&lt;/code&gt; 的情况下，&lt;code&gt;interface&lt;/code&gt; 的 &lt;code&gt;nil&lt;/code&gt; 判断才会为 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个新手很容易出现的问题，大家一定要注意这个问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一个&lt;code&gt;nil&lt;/code&gt;的&lt;code&gt;map&lt;/code&gt;读写数据是否会发生&lt;code&gt;panic&lt;/code&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于这种问题，我们直接写个例子测试一下就好：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; m &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt;&lt;br/&gt; fmt.Println(m[&lt;span&gt;&quot;asoong&quot;&lt;/span&gt;])&lt;br/&gt; m[&lt;span&gt;&quot;asong&quot;&lt;/span&gt;] = &lt;span&gt;&quot;Golang梦工厂&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;&lt;span&gt;panic&lt;/span&gt;: assignment to entry in &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;map&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;goroutine &lt;span&gt;1&lt;/span&gt; [running]:&lt;br/&gt;main.main()&lt;br/&gt;        &lt;span&gt;go&lt;/span&gt;/src/asong.cloud/Golang_Dream/code_demo/slice_demo/&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt; +&lt;span&gt;0xed&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据运行结果我们可以看出，一个&lt;code&gt;nil&lt;/code&gt;的&lt;code&gt;map&lt;/code&gt;可以读数据，但是不可以写入数据，否则会发生&lt;code&gt;panic&lt;/code&gt;，所以要使用&lt;code&gt;map&lt;/code&gt;一定要使用&lt;code&gt;make&lt;/code&gt;进行初始化。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;关闭&lt;code&gt;nil&lt;/code&gt;的&lt;code&gt;channel&lt;/code&gt;会引发&lt;code&gt;panic&lt;/code&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; cha &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; &lt;span&gt;close&lt;/span&gt;(cha)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;panic&lt;/span&gt;: &lt;span&gt;close&lt;/span&gt; of &lt;span&gt;nil&lt;/span&gt; channel&lt;br/&gt;&lt;br/&gt;goroutine &lt;span&gt;1&lt;/span&gt; [running]:&lt;br/&gt;main.main()&lt;br/&gt;       /&lt;span&gt;go&lt;/span&gt;/src/asong.cloud/Golang_Dream/code_demo/slice_demo/&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;5&lt;/span&gt; +&lt;span&gt;0x2a&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据运行结果我们可以得出关闭一个&lt;code&gt;nil&lt;/code&gt;的&lt;code&gt;channel&lt;/code&gt;会导致程序&lt;code&gt;panic&lt;/code&gt;，在使用上我们要注意这个问题，还有有一个需要注意的问题：&lt;strong&gt;一个&lt;code&gt;nil&lt;/code&gt;的&lt;code&gt;channel&lt;/code&gt;读写数据都会造成永远阻塞。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一个为&lt;code&gt;nil&lt;/code&gt;的&lt;code&gt;slice&lt;/code&gt;使用注意事项&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; slice []&lt;span&gt;int64&lt;/span&gt; = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; fmt.Println(&lt;span&gt;len&lt;/span&gt;(slice))&lt;br/&gt; fmt.Println(&lt;span&gt;cap&lt;/span&gt;(slice))&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;range&lt;/span&gt; slice{&lt;br/&gt;&lt;br/&gt; }&lt;br/&gt; fmt.Println(slice[&lt;span&gt;0&lt;/span&gt;])&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;panic&lt;/span&gt;: runtime error: index out of &lt;span&gt;range&lt;/span&gt; [&lt;span&gt;0&lt;/span&gt;] with length &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;goroutine &lt;span&gt;1&lt;/span&gt; [running]:&lt;br/&gt;main.main()&lt;br/&gt;        /&lt;span&gt;go&lt;/span&gt;/src/asong.cloud/Golang_Dream/code_demo/slice_demo/&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt; +&lt;span&gt;0xf2&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据这个例子，我们可以得出如下结论：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;一个为&lt;code&gt;nil&lt;/code&gt;的索引，不可以进行索引，否则会引发&lt;code&gt;panic&lt;/code&gt;，其他操作是可以。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;方法接收者为&lt;code&gt;nil&lt;/code&gt;时是否会引发&lt;code&gt;panic&lt;/code&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; m *man&lt;br/&gt; fmt.Println(m.GetName())&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; man &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m *man)&lt;/span&gt;&lt;span&gt;GetName&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;asong&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;asong&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据运行结果我们可以看出，方法接收者为&lt;code&gt;nil&lt;/code&gt;时，我们仍然可以访问对应的方法，但是要注意方法内的写法，否则也会引发&lt;code&gt;panic&lt;/code&gt;。上面的代码改成这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; m *man&lt;br/&gt; fmt.Println(m.GetName())&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; man &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Name &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m *man)&lt;/span&gt;&lt;span&gt;GetName&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; m.Name&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;&lt;span&gt;panic&lt;/span&gt;: runtime error: invalid memory address or &lt;span&gt;nil&lt;/span&gt; pointer dereference&lt;br/&gt;[signal SIGSEGV: segmentation violation code=&lt;span&gt;0x1&lt;/span&gt; addr=&lt;span&gt;0x0&lt;/span&gt; pc=&lt;span&gt;0x10a6ec3&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;goroutine &lt;span&gt;1&lt;/span&gt; [running]:&lt;br/&gt;main.(*man).GetName(...)&lt;br/&gt;        &lt;span&gt;go&lt;/span&gt;/src/asong.cloud/Golang_Dream/code_demo/slice_demo/&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;&lt;br/&gt;main.main()&lt;br/&gt;        &lt;span&gt;go&lt;/span&gt;/src/asong.cloud/Golang_Dream/code_demo/slice_demo/&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt; +&lt;span&gt;0x23&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就是直接引发&lt;code&gt;panic&lt;/code&gt;，所以为了程序健壮性我们要做一次指针判空处理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;空指针是一个没有任何值的指针&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; a = (*&lt;span&gt;int64&lt;/span&gt;)(unsafe.Pointer(&lt;span&gt;uintptr&lt;/span&gt;(&lt;span&gt;0x0&lt;/span&gt;)))&lt;br/&gt; fmt.Println(a == &lt;span&gt;nil&lt;/span&gt;)  &lt;span&gt;//true&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们用了&lt;code&gt;0x0&lt;/code&gt;做了一个小实验，正好证明了空指针就是一个没有指向任何值的指针。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章接近尾声啦，我们来揭晓一下文章开始的答案，用文中&lt;code&gt;nil&lt;/code&gt;比较的知识点正好可以解答这个问题，&lt;code&gt;nil&lt;/code&gt;标识符是没有类型的，所以&lt;code&gt;==&lt;/code&gt;对于&lt;code&gt;nil&lt;/code&gt;来说是一种未定义的操作，不可以进行比较，而这个在&lt;code&gt;python&lt;/code&gt;中是可以比较的，在 &lt;code&gt;python&lt;/code&gt; 中，两个&lt;code&gt;None&lt;/code&gt; 值永远相等，不要弄混了朋友们。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最后建议你们看一下这个视频：https://www.youtube.com/watch?v=ynoY2xz-F8s&lt;/strong&gt;  &lt;strong&gt;需要翻墙哈，看完这个你对&lt;code&gt;nil&lt;/code&gt;会有一个新的理解。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;好啦，这篇文章就到这里啦，素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：加我vx拉你入群，或者公众号获取入群二维码&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;翻译了一份Machinery中文文档，会定期进行维护，有需要的小伙伴们后台回复[machinery]即可获取。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我是asong，一名普普通通的程序猿，让我们一起慢慢变强吧。欢迎各位的关注，我们下期见~~~&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/k5430ljpYPNFVT6F1cSh4LJhic7wX9o3cmPicXrYcyvAxtKDVTg3PzTQicpw8wLIc59lVPs6c0UrWDwr1qnwq67UA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐往期文章：&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c2787fd151d25dc80c43be2159289d5b</guid>
<title>源码解析 GitHub 上 14.1k Star 的 RocketMQ</title>
<link>https://toutiao.io/k/0pi916j</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Ly9fQtHVgNmLTAOicuhahBE0jkfiajcTsV5yBW4eKI357LoU2xsQia7QDQLaKmbib9CdqrLVUDT5611PvbKFqOYfUg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;103160&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;前言&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p hm_fix=&quot;367:433&quot;&gt;&lt;span&gt;Apache RocketMQ 作为广为人知的开源消息中间件，诞生于阿里巴巴，于 2016 年捐赠给了 Apache。从 RocketMQ 4.0 到如今最新的 v4.7.1，不论是在阿里巴巴内部还是外部社区，都赢得了广泛的关注和好评。 &lt;/span&gt;&lt;/p&gt;&lt;p hm_fix=&quot;367:433&quot;&gt;&lt;/p&gt;&lt;p hm_fix=&quot;367:433&quot;&gt;&lt;span&gt;本文将站在发送方视角，通过阅读 RocketMQ Producer 源码，来分析在事务消息发送中 RocketMQ 是如何工作的。&lt;/span&gt;&lt;/p&gt;&lt;p hm_fix=&quot;367:433&quot;&gt;&lt;/p&gt;&lt;p hm_fix=&quot;367:433&quot;&gt;&lt;span&gt;需要说明的是，本文所贴代码，均来自 4.7.1 版本的 RocketMQ 源码。本文中所讨论的发送，仅指从 Producer 发送到 Broker 的过程，并不包含 Broker 将消息投递到 Consumer 的过程。 &lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;103158&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;宏观概览&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;RocketMQ 事务消息发送流程： &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img data-ratio=&quot;1.0369487485101312&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNmLTAOicuhahBE0jkfiajcTsVDl4ERgF5I6BfeDXn5oIKbgZqX5YY5wnSLO294bwolicdaYSuaoj0Ftg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;6712&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;结合源码来看，RocketMQ 的事务消息 TransactionMQProducer 的 sendMessageInTransaction 方法，实际调用了 DefaultMQProducerImpl 的 sendMessageInTransaction 方法。我们进入 sendMessageInTransaction 方法，整个事务消息的发送流程清晰可见。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先，做发送前检查，并填入必要参数，包括设 prepare 事务消息。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;源码清单-1&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public TransactionSendResult sendMessageInTransaction(final Message msg,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    final LocalTransactionExecuter localTransactionExecuter, final Object arg)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    throws MQClientException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    TransactionListener transactionListener = getCheckListener(); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        if (null == localTransactionExecuter &amp;amp;&amp;amp; null == transactionListener) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        throw new MQClientException(&quot;tranExecutor is null&quot;, null);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // ignore DelayTimeLevel parameter&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (msg.getDelayTimeLevel() != 0) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_DELAY_TIME_LEVEL);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Validators.checkMessage(msg, this.defaultMQProducer);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    SendResult sendResult = null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, &quot;true&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, this.defaultMQProducer.getProducerGroup());&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;进入发送处理流程： &lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;源码清单-2&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    try {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        sendResult = this.send(msg);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } catch (Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        throw new MQClientException(&quot;send message Exception&quot;, e);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;根据 broker 返回的处理结果决策本地事务是否执行，半消息发送成功则开始本地事务执行： &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;源码清单-3 &lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Throwable localException = null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    switch (sendResult.getSendStatus()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        case SEND_OK: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            try {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (sendResult.getTransactionId() != null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    msg.putUserProperty(&quot;__transactionId__&quot;, sendResult.getTransactionId());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                String transactionId = msg.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (null != transactionId &amp;amp;&amp;amp; !&quot;&quot;.equals(transactionId)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    msg.setTransactionId(transactionId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (null != localTransactionExecuter) { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    localTransactionState = localTransactionExecuter.executeLocalTransactionBranch(msg, arg);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                } else if (transactionListener != null) { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    log.debug(&quot;Used new transaction API&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    localTransactionState = transactionListener.executeLocalTransaction(msg, arg); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (null == localTransactionState) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    localTransactionState = LocalTransactionState.UNKNOW;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (localTransactionState != LocalTransactionState.COMMIT_MESSAGE) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    log.info(&quot;executeLocalTransactionBranch return {}&quot;, localTransactionState);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    log.info(msg.toString());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            } catch (Throwable e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                log.info(&quot;executeLocalTransactionBranch exception&quot;, e);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                log.info(msg.toString());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                localException = e;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        case FLUSH_DISK_TIMEOUT:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        case FLUSH_SLAVE_TIMEOUT:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        case SLAVE_NOT_AVAILABLE:  // 当备broker状态不可用时，半消息要回滚，不执行本地事务&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        default:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;本地事务执行结束，根据本地事务状态进行二阶段处理：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;源码清单-4&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    try {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        this.endTransaction(sendResult, localTransactionState, localException);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } catch (Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        log.warn(&quot;local transaction execute &quot; + localTransactionState + &quot;, but end broker transaction failed&quot;, e);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 组装发送结果&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    return transactionSendResult;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;接下来，我们深入每个阶段代码分析。 &lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;103158&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;深扒内幕&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;strong&gt;Ⅰ 阶段发送&lt;br/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;重点分析 send 方法。进入 send 方法后，我们发现，RocketMQ 的事务消息的一阶段，使用了 SYNC 同步模式：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;源码清单-5 &lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public SendResult send(Message msg,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    return this.sendDefaultImpl(msg, CommunicationMode.SYNC, null, timeout);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这一点很容易理解，毕竟事务消息是要根据一阶段发送结果来决定要不要执行本地事务的，所以一定要阻塞等待 broker 的 ack。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们进入 DefaultMQProducerImpl.java 中去看 sendDefaultImpl 方法的实现，通过读这个方法的代码，来尝试了解在事务消息的一阶段发送过程中 producer 的行为。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;值得注意的是，这个方法并非为事务消息定制，甚至不是为 SYNC 同步模式定制的，因此读懂了这段代码，基本可以对 RocketMQ 的消息发送机制有了一个较为全面的认识。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这段代码逻辑非常通畅，不忍切片。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了节省篇幅，将代码中较为繁杂但信息量不大的部分以注释代替，尽可能保留流程的完整性。个人认为较为重要或是容易被忽略的部分，以注释标出，后文还有部分细节的详细解读。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;源码清单-6&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;private SendResult sendDefaultImpl(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Message msg,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    final CommunicationMode communicationMode,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    final SendCallback sendCallback,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    final long timeout&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    this.makeSureStateOK();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 一、消息有效性校验。见后文&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Validators.checkMessage(msg, this.defaultMQProducer);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    final long invokeID = random.nextLong();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    long beginTimestampFirst = System.currentTimeMillis();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    long beginTimestampPrev = beginTimestampFirst;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    long endTimestamp = beginTimestampFirst;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 获取当前topic的发送路由信息，主要是要broker，如果没找到则从namesrv获取&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (topicPublishInfo != null &amp;amp;&amp;amp; topicPublishInfo.ok()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        boolean callTimeout = false;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        MessageQueue mq = null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Exception exception = null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        SendResult sendResult = null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 二、发送重试机制。见后文&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        int timesTotal = communicationMode == CommunicationMode.SYNC ? 1 + this.defaultMQProducer.getRetryTimesWhenSendFailed() : 1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        int times = 0;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        String[] brokersSent = new String[timesTotal];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        for (; times &amp;lt; timesTotal; times++) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            // 第一次发送是mq == null， 之后都是有broker信息的&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            String lastBrokerName = null == mq ? null : mq.getBrokerName();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            // 三、rocketmq发送消息时如何选择队列？——broker异常规避机制 &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            MessageQueue mqSelected = this.selectOneMessageQueue(topicPublishInfo, lastBrokerName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            if (mqSelected != null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                mq = mqSelected;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                brokersSent[times] = mq.getBrokerName();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                try {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    beginTimestampPrev = System.currentTimeMillis();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (times &amp;gt; 0) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        //Reset topic with namespace during resend.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        msg.setTopic(this.defaultMQProducer.withNamespace(msg.getTopic()));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    long costTime = beginTimestampPrev - beginTimestampFirst;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (timeout &amp;lt; costTime) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        callTimeout = true;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    // 发送核心代码&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    sendResult = this.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout - costTime);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    endTimestamp = System.currentTimeMillis();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    // rocketmq 选择 broker 时的规避机制，开启 sendLatencyFaultEnable == true 才生效&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    switch (communicationMode) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    // 四、RocketMQ的三种CommunicationMode。见后文&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        case ASYNC: // 异步模式&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            return null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        case ONEWAY: // 单向模式&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            return null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        case SYNC: // 同步模式&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            if (sendResult.getSendStatus() != SendStatus.SEND_OK) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                if (this.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                    continue;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            return sendResult;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        default:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                } catch (RemotingException e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    // ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    // 自动重试&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                } catch (MQClientException e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    // ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    // 自动重试&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                } catch (MQBrokerException e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                   // ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    // 仅返回码==NOT_IN_CURRENT_UNIT==205 时自动重试&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    // 其他情况不重试，抛异常&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                } catch (InterruptedException e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                   // ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    // 不重试，抛异常&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            } else {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        if (sendResult != null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            return sendResult;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 组装返回的info信息，最后以MQClientException抛出&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // ... ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 超时场景抛RemotingTooMuchRequestException&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        if (callTimeout) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            throw new RemotingTooMuchRequestException(&quot;sendDefaultImpl call timeout&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 填充MQClientException异常信息&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    validateNameServerSetting();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    throw new MQClientException(&quot;No route info of this topic: &quot; + msg.getTopic() + FAQUrl.suggestTodo(FAQUrl.NO_TOPIC_ROUTE_INFO),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        null).setResponseCode(ClientErrorCode.NOT_FOUND_TOPIC_EXCEPTION);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、消息有效性校验&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;源码清单-7&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; Validators.checkMessage(msg, this.defaultMQProducer);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在此方法中校验消息的有效性，包括对 topic 和消息体的校验。topic 的命名必须符合规范，且避免使用内置的系统消息 TOPIC。消息体长度 &amp;gt; 0 &amp;amp;&amp;amp; 消息体长度 &amp;lt;= 1024*1024*4 = 4M 。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;源码清单-8 &lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public static void checkMessage(Message msg, DefaultMQProducer defaultMQProducer)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    throws MQClientException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (null == msg) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        throw new MQClientException(ResponseCode.MESSAGE_ILLEGAL, &quot;the message is null&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // topic&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Validators.checkTopic(msg.getTopic());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Validators.isNotAllowedSendTopic(msg.getTopic());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // body&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (null == msg.getBody()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        throw new MQClientException(ResponseCode.MESSAGE_ILLEGAL, &quot;the message body is null&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (0 == msg.getBody().length) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        throw new MQClientException(ResponseCode.MESSAGE_ILLEGAL, &quot;the message body length is zero&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (msg.getBody().length &amp;gt; defaultMQProducer.getMaxMessageSize()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        throw new MQClientException(ResponseCode.MESSAGE_ILLEGAL,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &quot;the message body size over max value, MAX: &quot; + defaultMQProducer.getMaxMessageSize());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;二、发送重试机制&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Producer 在消息发送不成功时，会自动重试，最多发送次数 = retryTimesWhenSendFailed + 1 = 3 次 。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;值得注意的是，并非所有异常情况都会重试，从以上源码中可以提取到的信息告诉我们，在以下三种情况下，会自动重试：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1）发生 RemotingException，MQClientException 两种异常之一时&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2）发生 MQBrokerException 异常，且 ResponseCode 是 NOT_IN_CURRENT_UNIT = 205 时&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3）SYNC 模式下，未发生异常且发送结果状态非 SEND_OK &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在每次发送消息之前，会先检查是否在前面这两步就已经耗时超长（超时时长默认 3000ms），若是，则不再继续发送并且直接返回超时，不再重试。这里说明了 2 个问题：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1）producer 内部自动重试对业务应用而言是无感知的，应用看到的发送耗时是包含所有重试的耗时在内的；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2）一旦超时意味着本次消息发送已经以失败告终，原因是超时。这个信息最后会以 RemotingTooMuchRequestException 的形式抛出。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里需要指出的是，在 RocketMQ 官方文档中指出，发送超时时长是 10s，即 10000ms，网上许多人对 rocketMQ 的超时时间解读也认为是 10s。然而代码中却明明白白写着 3000ms，最终我 debug 之后确认，默认超时时间确实是 3000ms。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、broker 的异常规避机制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;源码清单-9&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;MessageQueue mqSelected = this.selectOneMessageQueue(topicPublishInfo, lastBrokerName);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这行代码是发送前选择 queue 的过程。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里涉及 RocketMQ 消息发送高可用的的一个核心机制，latencyFaultTolerance。这个机制是 Producer 负载均衡的一部分，通过 sendLatencyFaultEnable 的值来控制，默认是 false 关闭状态，不启动 broker 故障延迟机制，值为 true 时启用 broker 故障延迟机制，可由 Producer 主动打开。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;选择队列时，开启异常规避机制，则根据 broker 的工作状态避免选择当前状态不佳的 broker 代理，不健康的 broker 会在一段时间内被规避，不开启异常规避机制时，则按顺序选取下一个队列，但在重试场景下会尽量选择不同于上次发送 broker 的 queue。每次消息发送都会通过 updateFaultItem 方法来维护 broker 的状态信息。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;源码清单-10&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public void updateFaultItem(final String brokerName, final long currentLatency, boolean isolation) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (this.sendLatencyFaultEnable) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 计算延迟多久，isolation表示是否需要隔离该broker，若是，则从30s往前找第一个比30s小的延迟值，再按下标判断规避的周期，若30s，则是10min规避；&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 否则，按上一次发送耗时来决定规避时长；&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        long duration = computeNotAvailableDuration(isolation ? 30000 : currentLatency);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        this.latencyFaultTolerance.updateFaultItem(brokerName, currentLatency, duration);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;深入到 selectOneMessageQueue 方法内部一探究竟： &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;源码清单-11&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public MessageQueue selectOneMessageQueue(final TopicPublishInfo tpInfo, final String lastBrokerName) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (this.sendLatencyFaultEnable) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 开启异常规避&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        try {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            int index = tpInfo.getSendWhichQueue().getAndIncrement();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            for (int i = 0; i &amp;lt; tpInfo.getMessageQueueList().size(); i++) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                int pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (pos &amp;lt; 0)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    pos = 0;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                // 按顺序取下一个message queue作为发送的queue&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                MessageQueue mq = tpInfo.getMessageQueueList().get(pos);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                // 当前queue所在的broker可用，且与上一个queue的broker相同，&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                // 或者第一次发送，则使用这个queue&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (latencyFaultTolerance.isAvailable(mq.getBrokerName())) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (null == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        return mq;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            final String notBestBroker = latencyFaultTolerance.pickOneAtLeast();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            int writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            if (writeQueueNums &amp;gt; 0) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                final MessageQueue mq = tpInfo.selectOneMessageQueue();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (notBestBroker != null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    mq.setBrokerName(notBestBroker);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                return mq;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            } else {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                latencyFaultTolerance.remove(notBestBroker);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } catch (Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            log.error(&quot;Error occurred when selecting message queue&quot;, e);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        return tpInfo.selectOneMessageQueue();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 不开启异常规避，则随机自增选择Queue&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    return tpInfo.selectOneMessageQueue(lastBrokerName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;四、RocketMQ 的三种 CommunicationMode:&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;源码清单-12&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; public enum CommunicationMode {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    SYNC,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ASYNC,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ONEWAY,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;以上三种模式指的都是消息从发送方到达 broker 的阶段，不包含 broker 将消息投递给订阅方的过程。三种模式的发送方式的差异： &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span data-type=&quot;strong&quot;&gt;单向模式：&lt;/span&gt;ONEWAY。消息发送方只管发送，并不关心 broker 处理的结果如何。这种模式下，由于处理流程少，发送耗时非常小，吞吐量大，但不能保证消息可靠不丢，常用于流量巨大但不重要的消息场景，例如心跳发送等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span data-type=&quot;strong&quot;&gt;异步模式：&lt;/span&gt;ASYNC。消息发送方发送消息到 broker 后，无需等待 broker 处理，拿到的是 null 的返回值，而由一个异步的线程来做消息处理，处理完成后以回调的形式告诉发送方发送结果。异步处理时如有异常，返回发送方失败结果之前，会经过内部重试（默认 3 次，发送方不感知）。这种模式下，发送方等待时长较小，吞吐量较大，消息可靠，用于流量大但重要的消息场景。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span data-type=&quot;strong&quot;&gt;同步模式：&lt;/span&gt;SYNC。消息发送方需等待 broker 处理完成并明确返回成功或失败，在消息发送方拿到消息发送失败的结果之前，也会经历过内部重试（默认 3 次，发送方不感知）这种模式下，发送方会阻塞等待消息处理结果，等待时长较长，消息可靠，用于流量不大但重要的消息场景。需要强调的是，事务消息的一阶段半事务消息的处理是同步模式。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在 sendKernelImpl 方法中也可以看到具体的实现差异。ONEWAY 模式最为简单，不做任何处理。负责发送的 sendMessage 方法参数中，相比同步模式，异步模式多了回调方法、包含 topic 发送路由元信息的 topicPublishInfo、包含发送 broker 信息的 instance、包含发送队列信息的 producer、重试次数。另外，异步模式下，会对有压缩的消息先做 copy。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;源码清单-13&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    switch (communicationMode) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                case ASYNC:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    Message tmpMessage = msg;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    boolean messageCloned = false;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (msgBodyCompressed) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        //If msg body was compressed, msgbody should be reset using prevBody.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        //Clone new message using commpressed message body and recover origin massage.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        //Fix bug:https://github.com/apache/rocketmq-externals/issues/66&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        tmpMessage = MessageAccessor.cloneMessage(msg);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        messageCloned = true;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        msg.setBody(prevBody);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (topicWithNamespace) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        if (!messageCloned) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            tmpMessage = MessageAccessor.cloneMessage(msg);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            messageCloned = true;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), this.defaultMQProducer.getNamespace()));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    long costTimeAsync = System.currentTimeMillis() - beginStartTime;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (timeout &amp;lt; costTimeAsync) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        throw new RemotingTooMuchRequestException(&quot;sendKernelImpl call timeout&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        brokerAddr,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        mq.getBrokerName(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        tmpMessage,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        requestHeader,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        timeout - costTimeAsync,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        communicationMode,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        sendCallback,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        topicPublishInfo,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        this.mQClientFactory,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        this.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        context,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        this);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                case ONEWAY:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                case SYNC:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    long costTimeSync = System.currentTimeMillis() - beginStartTime;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (timeout &amp;lt; costTimeSync) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        throw new RemotingTooMuchRequestException(&quot;sendKernelImpl call timeout&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        brokerAddr,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        mq.getBrokerName(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        msg,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        requestHeader,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        timeout - costTimeSync,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        communicationMode,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        context,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        this);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                default:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    assert false;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;官方文档中有这样一张图，十分清晰的描述了异步通信的详细过程： &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7951612903225806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNmLTAOicuhahBE0jkfiajcTsV4AKcLrWhyF8miaO2ib338nYR6kH0Olz0fKAJj74RbKmeXX49C9s9YA0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;620&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-id=&quot;heading8&quot; data-type=&quot;heading&quot; top=&quot;10608&quot;&gt;&lt;strong&gt;Ⅱ 阶段发送&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;源码清单-3 体现了本地事务的执行，localTransactionState 将本地事务执行结果与事务消息二阶段的发送关联起来。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;值得注意的是，如果一阶段的发送结果是 SLAVE&lt;em data-type=&quot;italic&quot;&gt;NOT&lt;/em&gt;AVAILABLE，即便 broker 不可用时，也会将 localTransactionState 置为 Rollback，此时将不会执行本地事务。之后由 endTransaction 方法负责二阶段提交，见源码清单-4。具体到 endTransaction 的实现：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;源码清单-14&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public void endTransaction(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    final SendResult sendResult,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    final LocalTransactionState localTransactionState,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    final Throwable localException) throws RemotingException, MQBrokerException, InterruptedException, UnknownHostException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    final MessageId id;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (sendResult.getOffsetMsgId() != null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        id = MessageDecoder.decodeMessageId(sendResult.getOffsetMsgId());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } else {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        id = MessageDecoder.decodeMessageId(sendResult.getMsgId());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    String transactionId = sendResult.getTransactionId();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    final String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(sendResult.getMessageQueue().getBrokerName());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    EndTransactionRequestHeader requestHeader = new EndTransactionRequestHeader();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    requestHeader.setTransactionId(transactionId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    requestHeader.setCommitLogOffset(id.getOffset());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    switch (localTransactionState) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        case COMMIT_MESSAGE:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        case ROLLBACK_MESSAGE:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        case UNKNOW:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        default:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    requestHeader.setProducerGroup(this.defaultMQProducer.getProducerGroup());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    requestHeader.setTranStateTableOffset(sendResult.getQueueOffset());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    requestHeader.setMsgId(sendResult.getMsgId());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    String remark = localException != null ? (&quot;executeLocalTransactionBranch exception: &quot; + localException.toString()) : null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 采用oneway的方式发送二阶段消息&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, requestHeader, remark,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        this.defaultMQProducer.getSendMsgTimeout());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在二阶段发送时，之所以用 oneway 的方式发送，个人理解这正是因为事务消息有一个特殊的可靠机制——回查。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;103158&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;消息回查&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当 Broker 经过了一个特定的时间，发现依然没有得到事务消息的二阶段是否要提交或者回滚的确切信息，Broker 不知道 Producer 发生了什么情况（可能 producer 挂了，也可能 producer 发了 commit 但网络抖动丢了，也可能……于是主动发起回查。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;事务消息的回查机制，更多的是在 broker 端的体现。RocketMQ 的 broker 以 Half 消息、Op 消息、真实消息三个不同的 topic 来将不同发送阶段的事务消息进行了隔离，使得 Consumer 只能看到最终确认 commit 需要投递出去的消息。其中详细的实现逻辑在本文中暂不多赘述，后续可另开一篇专门来从 Broker 视角来解读。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;回到 Producer 的视角，当收到了 Broker 的回查请求，Producer 将根据消息检查本地事务状态，根据结果决定提交或回滚，这就要求 Producer 必须指定回查实现，以备不时之需。当然，正常情况下，并不推荐主动发送 UNKNOW 状态，这个状态毫无疑问会给 broker 带来额外回查开销，只在出现不可预知的异常情况时才启动回查机制，是一种比较合理的选择。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外，4.7.1 版本的事务回查并非无限回查，而是最多回查 15 次：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;源码清单-15&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@ImportantField&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; transactionCheckMax = &lt;span class=&quot;code-snippet__number&quot;&gt;15&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;103158&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;附录&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;官方给出 Producer 的默认参数如下（其中超时时长的参数，在前文中也已经提到，debug 的结果是默认 3000ms，并非 10000ms）: &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.2637920101458465&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNmLTAOicuhahBE0jkfiajcTsV7nBG45ZwiabY4T2gDBC7nGH2gjzzNjqSciaIZMic2BOiagUVFMd6uCT6ZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1577&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2198581560283688&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNmLTAOicuhahBE0jkfiajcTsV54PyJwR4hxTtibmGBmXccL0ibjLAfu3btKicibicVcCh3iaJTJcgLGYI0VPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1128&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;800&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNn8rstVfDv9pmtT4bLjphmE9ibjzMtp0CJxtiajyHY2FHl8hybIco0ic95eB1qEVRSawKUewKf8tJJmQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDk2MzUzMQ==&amp;amp;mid=2247486650&amp;amp;idx=1&amp;amp;sn=784145d54e857ce11868d4cbad3d0bda&amp;amp;chksm=f9e3181ece94910821d22af6a60146002d5146212e6ff9e27bbd2f3cb12870a8aecb68ac10e5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; hasload=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1578125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNlPfEPWbrSBV8RjAicxu6ib8nljInd37m3CNoh32xOuZwydrQbYKUNEcBjCIdsGssfGuroWVHp261Jw/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDk2MzUzMQ==&amp;amp;mid=2247486733&amp;amp;idx=1&amp;amp;sn=f6a91f5b14657a092af97e1e3542f023&amp;amp;chksm=f9e319a9ce9490bfdecd9534bdd95785ba8833f4023928de7776e49f82df91ba58ada2d95ab7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; hasload=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1578125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNlPfEPWbrSBV8RjAicxu6ib8nsF7Afp0llC6pt2IohPcGX2UufSQOOJcWiab87PqHncu605tQ9kuXWuw/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDk2MzUzMQ==&amp;amp;mid=2247486753&amp;amp;idx=1&amp;amp;sn=c87fb126e0c01521d467779ad4bfba18&amp;amp;chksm=f9e31985ce949093debaba15869d02e1f86246709d099d074bc7019a101cf6420882e8868543&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; hasload=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1578125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNlPfEPWbrSBV8RjAicxu6ib8nfia6TWiaJOibukYxQCeOVXLaLxjypNWQljBLCYATiaPUW0ibiaeHgnBQ2CaA/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;hr/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages __bg_gif&quot; data-ratio=&quot;0.3359173126614987&quot; data-s=&quot;300,640&quot; data-type=&quot;gif&quot; data-w=&quot;1548&quot; data-backw=&quot;357&quot; data-backh=&quot;120&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Ly9fQtHVgNkW5XM01qD7S0PrzSL4XF4j8aP07jS3gN59VyiaInelAh9R0icHicaYmTnc9ev8xM4PK8HltbeQTOleQ/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;79&quot; data-ratio=&quot;0.214900947459087&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNm5Jr4A4hmb8QKTl1n7uicZzqJ75oyzVLvGCkK9QhzGgc2Ux9GiaXicf7UUG4Ns1GMyr0YkTIU7fNeHQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;点击下方“&lt;/span&gt;&lt;span&gt;&lt;strong&gt;阅读原文&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;”，了解「mPaaS」更多资讯。&lt;/span&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>78375ed776eda1d00bacbb8877d80e2a</guid>
<title>广告行业中那些趣事系列 (32)：美团搜索 NER 技术实践学习笔记</title>
<link>https://toutiao.io/k/6nlq54b</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;blockquote&gt;导读：本文是“数据拾光者”专栏的第三十二篇文章，这个系列将介绍在广告行业中自然语言处理和推荐系统实践。本篇主要是学习美团技术团队分享的《美团搜索中NER技术的探索与实践》学习笔记，对于想了解美团搜索NER技术实践的小伙伴可能有所帮助。&lt;br/&gt;&lt;br/&gt;欢迎转载，转载请注明出处以及链接，更多关于自然语言处理、推荐系统优质内容请关注如下频道。&lt;br/&gt;&lt;br/&gt;知乎专栏：数据拾光者&lt;br/&gt;公众号：数据拾光者&lt;/blockquote&gt;&lt;p&gt;摘要：本篇主要是学习美团技术团队分享的《美团搜索中NER技术的探索与实践》学习笔记。首先介绍了背景，包括NER任务定义、美团搜索场景下的NER以及美团搜索NER任务面临的挑战；然后重点介绍了美团基于实体词典匹配+模型在线预测框架。通过实体词典匹配可以解决头部搜索NER匹配问题，而长尾复杂的搜索则通过模型在线预测解决。对于想了解美团搜索NER技术实践的小伙伴可能有所帮助。&lt;/p&gt;&lt;p&gt;郑重声明，本篇主要是学习美团技术团队发表的文章《美团搜索中NER技术的探索与实践》。因为上一篇&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzU1NjYyODQ4NA%3D%3D%26mid%3D2247484811%26idx%3D1%26sn%3D74f60c7bebadc95f138b6e622736082b%26chksm%3Dfbc36ae0ccb4e3f69c0c302f3c9a23c991654ceea4d6c35538381ce026159921dc466cc79b35%26scene%3D21%23wechat_redirect&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; class=&quot;LinkCard old LinkCard--noImage&quot;&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;《广告行业中那些趣事系列31：关键词提取技术攻略以及BERT实践》&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;mp.weixin.qq.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;p&gt;介绍了关键词提取技术以及BERT实践，关键词提取属于一种NER任务。美团的技术沉淀在业界是很有名的，通过学习美团NER技术实践对于我们线上实际业务的开展非常有帮助。这篇文章总体看了不下五遍，属于精读的文章。小伙伴们可以直接去拜读原文，非常精彩。这里更多的是根据自己的思考和理解将原文整理成更容易理解的方式进行表达(至少对于我是更容易理解的方式)，类似一种学习笔记的表现形式。很多小伙伴看到干货文章更多的是收藏+关注，然后就不了了之，成为“收藏党”。而我更推荐精读N遍，同时进行延伸查阅更多知识，最后以一种便于理解的方式整理出来，形成文章将知识固化。如果再能将固化的知识通过PPT等形式分享出来，那么理解的就更加深刻。&lt;/p&gt;&lt;p&gt;下面主要按照如下思维导图进行学习分享：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-56b0ebe02af8cf85523b0bfcd747787d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;357&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-56b0ebe02af8cf85523b0bfcd747787d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;357&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-56b0ebe02af8cf85523b0bfcd747787d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-56b0ebe02af8cf85523b0bfcd747787d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-16f0488e3736705f887413cdf5b136da_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;81&quot; data-rawheight=&quot;95&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;81&quot; data-rawheight=&quot;95&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-16f0488e3736705f887413cdf5b136da_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;1.1 NER任务定义&lt;/b&gt;&lt;/p&gt;&lt;p&gt;命名实体识别（Named Entity Recognition，简称NER）是指识别文本中具有特定意义的实体，主要包括人名、地名、机构名、专有名词等。作为NLP领域四大任务(&lt;b&gt;分类、生成、序列标注和句子对标注&lt;/b&gt;)之一，应用场景非常广泛，需要重点研究。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.2 美团搜索场景下的NER&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在美团搜索场景下，NER主要应用于&lt;b&gt;搜索召回&lt;/b&gt;、&lt;b&gt;用户意图识别&lt;/b&gt;、&lt;b&gt;实体链接&lt;/b&gt;等环节。本篇主要讲美团搜索召回任务中的NER技术实践。在O2O搜索中，&lt;b&gt;对商家POI的描述主要包括商家名称、地址、品类等相关性较弱的文本域&lt;/b&gt;。如果实际搜索中通过全部文本域命中的方式进行召回，那么可能产生大量的错误召回。下面通过举例说明：如果用户搜索了“海底捞”，如果采用全部文本域命中的方式，也就是说只要商家名称、地址或者品类等包含“海底捞”那么就会被召回。我们希望召回品类为“海底捞”的商家，但是实际情况是有些商家可能本身和海底捞没啥关系，但是在“地址”文本域中标记为“海底捞附近多少米”，作用是将海底捞作为一个参照物帮助用户更好的定位商家地址。这种情况下召回的商家并不是用户想要的。&lt;/p&gt;&lt;p&gt;针对这个问题美团提出了一种“&lt;b&gt;结构化召回&lt;/b&gt;”的策略，&lt;b&gt;让特定的查询只在特定的文本域做倒排检索&lt;/b&gt;，通过这种方式提升召回商家的相关性。当用户搜索“海底捞”时会基于NER先识别为商家，然后在商家的文本域内进行检索，这样就会过滤掉地址中包含“海底捞”但是本身没啥关系的商家，从而提升召回率。下面是基于NER结构化召回示例图：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-75471b170ec8e12dbd1832c1f0631f6f_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;193&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-75471b170ec8e12dbd1832c1f0631f6f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;193&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-75471b170ec8e12dbd1832c1f0631f6f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-75471b170ec8e12dbd1832c1f0631f6f_b.jpg&quot;/&gt;&lt;figcaption&gt;图1 基于NER结构化召回示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;1.3 美团搜索NER任务面临的挑战&lt;/b&gt;&lt;/p&gt;&lt;p&gt;实际业务场景中美团搜索NER任务会面临以下挑战：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;新增实体数量庞大且增速较快&lt;/b&gt;：美团本地生活服务领域发展迅速，出现很多新店、新商品、新服务品类等；&lt;/li&gt;&lt;li&gt;&lt;b&gt;用户搜索非标准化难以识别&lt;/b&gt;：用户query往往包括很多非标准表达、简称和热词，这使得NER任务完成高准确率和高覆盖率相对较难；&lt;/li&gt;&lt;li&gt;&lt;b&gt;领域相关性强&lt;/b&gt;：搜索中的实体识别与业务供给高度相关，仅通过通用语义无法准确识别，还需要加入业务相关知识进行辅助判断。比如之前有家有点黄的店名“叫X了X个X鸡”，仅从通用语义角度理解属于低俗内容，但是在美团业务中这是一个商家实体网红炸鸡品牌；&lt;/li&gt;&lt;li&gt;&lt;b&gt;性能要求高&lt;/b&gt;：线上搜索业务实时性要求非常高，否则会影响用户搜索体验。NER作为DQU的基础模块，&lt;b&gt;需要在毫秒级时间内完成&lt;/b&gt;。当前深度学习模型盛行，尤其像BERT这类模型效果很好，但是这类模型也存在预测耗时长的问题，如何优化模型性能，提升NER线上预测速度也是面临的重要挑战。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;总结下来就是美团搜索NER任务面临新增实体数量庞大并且增速快、用户搜索非标准化难以识别、领域相关性强以及性能要求高的挑战。下面会详细介绍美团搜索团队如何应对这些挑战。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2bfc7dd42d4f8801fbe1887484eb3a0e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;366&quot; data-rawheight=&quot;100&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;366&quot; data-rawheight=&quot;100&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-2bfc7dd42d4f8801fbe1887484eb3a0e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;针对美团搜索NER任务面临的挑战，美团主要构建了“&lt;b&gt;实体词典匹配+模型预测&lt;/b&gt;”技术框架。(这个架构其实和我们搜索召回任务的&lt;b&gt;行业词包+在线分类&lt;/b&gt;架构很相似，我们采用的是头部query构建行业词包，中长尾使用蒸馏模型构建线上分类)。至于为什么使用这种架构，下面通过三个问题进行详细说明：&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.1 为什么需要实体词典匹配&lt;/b&gt;&lt;/p&gt;&lt;p&gt;构建实体词典匹配主要有以下四个原因：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;一是搜索中用户查询的头部流量通常较短、表达形式简单，且集中在商户、品类、地址等三类实体搜索，通过实体词典匹配可以使得这部分搜索准确率达到90%以上；&lt;/li&gt;&lt;li&gt;二是&lt;b&gt;NER领域相关。&lt;/b&gt;离线通过挖掘业务数据资源获取业务实体词典，在线进行词典匹配时可以提升识别结果的领域相关性；&lt;/li&gt;&lt;li&gt;三是&lt;b&gt;新业务接入更加灵活&lt;/b&gt;，只需提供业务相关的实体词就可完成新业务场景下的实体识别；&lt;/li&gt;&lt;li&gt;四是实体词典匹配可以提升下游任务的响应速度，因为词典匹配速度很快，所以基本不存在性能问题。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;2.2 有了实体词典匹配为什么还要模型在线预测&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在实体词典匹配的基础上还需要模型在线预测主要有以下两方面的原因：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;一是随着搜索体量的不断增大，中长尾搜索流量更加复杂化，仅使用实体词典匹配很容易出现OOV&lt;b&gt; (Out Of Vocabulary)&lt;/b&gt;问题&lt;b&gt;，实体词典已经无法满足日益多样化的用户需求，而模型预测具备泛化能力，可作为词典匹配的有效补充&lt;/b&gt;。(这种做法有点类似我们行业词表+在线分类的方式，行业词表解决头部query-tag的匹配问题，在线分类解决中长尾query-tag的匹配问题)；&lt;/li&gt;&lt;li&gt;二是&lt;b&gt;实体词典匹配无法解决歧义问题&lt;/b&gt;，比如用户搜索“黄鹤楼美食”，“黄鹤楼”在实体词典中同时是武汉的景点、北京的商家、香烟产品，词典匹配不具备消歧能力，如果单纯通过实体词典匹配这三种类型都会输出，而模型预测可结合上下文，通过后面的”美食”会将实体词典匹配的香烟产品过滤掉，进一步提升匹配的准确率。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;2.3 实体词典匹配、模型预测两路结果是怎么合并输出的&lt;/b&gt;&lt;/p&gt;&lt;p&gt;美团搜索团队采用训练好的CRF权重网络作为打分器分别对实体词典匹配和模型预测两路输出的NER路径进行打分。&lt;b&gt;合并输出的规则是无法匹配词典或词典匹配打分明显低于模型预测时，采用模型预测的结果，其他情况仍然采用词典匹配结果&lt;/b&gt;。相当于是词典匹配为主+模型预测为辅的套路。后面会重点介绍实体词典匹配和模型预测的细节。下图是美团搜索NER实体词典匹配和模型在线预测合并流程：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-605f8c820afe2e8fab58b949fd77eaa6_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;402&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-605f8c820afe2e8fab58b949fd77eaa6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;402&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-605f8c820afe2e8fab58b949fd77eaa6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-605f8c820afe2e8fab58b949fd77eaa6_b.jpg&quot;/&gt;&lt;figcaption&gt;图2 实体词典匹配和模型在线预测合并流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e63854969354b606557d164d9ffb4a2c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;188&quot; data-rawheight=&quot;84&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;188&quot; data-rawheight=&quot;84&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-e63854969354b606557d164d9ffb4a2c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;3.1 实体词典匹配现状&lt;/b&gt;&lt;/p&gt;&lt;p&gt;传统的NER技术仅&lt;b&gt;能处理通用领域既定既有的实体&lt;/b&gt;，而无法应对垂直领域特有的实体类型。在美团搜索场景下，通过对商家POI结构化信息、商户评论数据、搜索日志等独有数据进行离线挖掘，&lt;b&gt;可以很好地解决领域实体识别问题&lt;/b&gt;。经过离线实体库不断的丰富完善累积后，在线使用轻量级的词库匹配实体识别方式简单、高效、可控，可以很好地覆盖头部和腰部流量。目前，&lt;b&gt;基于实体词典库的在线NER识别率可以达到92%&lt;/b&gt;。实体词典匹配主要分成离线挖掘和在线匹配两部分，下面会分别进行详细说明。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.2 离线挖掘实体词典&lt;/b&gt;&lt;/p&gt;&lt;p&gt;美团具有丰富多样的结构化数据，通过对领域内结构化数据的加工处理可以获得高精度的初始实体库。例如：从商户基础信息中可以获取商户名、类目、地址、售卖商品或服务等类型实体；从猫X眼X文X娱数据中，可以获取电影、电视剧、艺人等类型实体。上述结构化数据比较容易处理，比较复杂的是非结构化数据挖掘领域实体。用户搜索的实体名往往夹杂很多非标准化表达，与业务定义的标准实体名之间存在差异，&lt;b&gt;如何从非标准表达中挖掘领域实体变得尤为重要&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;现有的&lt;b&gt;新词挖掘技术&lt;/b&gt;主要分为&lt;b&gt;无监督学习、有监督学习和远程监督学习&lt;/b&gt;。无监督学习将高频序列作为候选集，并通过计算紧密度和自由度指标进行筛选&lt;b&gt;。&lt;/b&gt;这种方法虽然可以产生充分的候选集合，但是仅通过特征阈值过滤无法有效地平衡精确率与召回率，实际&lt;b&gt;应用中通常挑选较高的阈值保证精度而牺牲召回&lt;/b&gt;；有监督学习通常涉及复杂的语法分析模型或深度网络模型，且依赖领域专家设计复杂规则或大量的人工标记数据；远程监督学习通过开源知识库生成少量的标记数据，可以一定程度上缓解人力标注成本高的问题。然而小样本量的标记数据仅能学习简单的统计模型，无法训练具有高泛化能力的复杂模型。&lt;/p&gt;&lt;p&gt;美团搜索的离线实体挖掘是&lt;b&gt;多数据源多方法&lt;/b&gt;的。数据源主要包括结构化的商家信息库、百科词条，半结构化的搜索日志，以及非结构化的用户评论（UGC）等。使用的挖掘方法主要包括规则、传统机器学习模型、深度学习模型等。结构化数据以及半结构化数据的挖掘相对简单，比较复杂的是对非结构化的UGC数据进行挖掘。UGC作为一种非结构化文本，蕴含了大量非标准表达实体名。下图是针对UGC的垂直领域新词自动挖掘流程：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ade37229ef59912148843f95a0df09e5_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;262&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-ade37229ef59912148843f95a0df09e5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;262&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-ade37229ef59912148843f95a0df09e5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-ade37229ef59912148843f95a0df09e5_b.jpg&quot;/&gt;&lt;figcaption&gt;图3 UGC垂直领域新词自动挖掘流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;Step1：&lt;b&gt;候选序列挖掘&lt;/b&gt;。因为高频出现的序列一般是潜在新词的有效候选，所以将高频出现的序列作为初始候选数据集；&lt;/li&gt;&lt;li&gt;Step2：&lt;b&gt;基于远程监督词库优化候选集合。&lt;/b&gt;将领域累积的实体词典作为远程监督词库，把Step1中候选序列与实体词典的交集作为训练正样本。经过分析发现&lt;b&gt;上百万的高频序列中仅10%左右的候选是真正的新词&lt;/b&gt;。非交集的部分采用负采样的方式获得训练负样本。得到的训练集主要用于构建一个候选短语是否有效的二分类器，通过模型打分来评估候选短语的有效性。因为训练集中负样本混杂了少量正样本，所以为了降低负例对短语评估质量得分的影响，通过集成多个弱分类器减少误差。经过分类器预测后将得分超过一定阈值的集合作为正样本，其他作为负样本。至于候选短语是否可用主要从以下四个维度进行衡量：&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;频率&lt;/b&gt;：有意义的新词在语料中应当满足一定的频率，该指标由Step1计算得到。&lt;/li&gt;&lt;li&gt;&lt;b&gt;紧密度&lt;/b&gt;：主要用于&lt;b&gt;评估新短语中连续元素的共现强度&lt;/b&gt;，包括T分布检验、皮尔森卡方检验、逐点互信息、似然比等指标。&lt;/li&gt;&lt;li&gt;&lt;b&gt;信息度&lt;/b&gt;：新词应具有真实意义，指代某个新的实体或概念，该特征&lt;b&gt;主要考虑了词组在语料中的逆文档频率、词性分布以及停用词分布&lt;/b&gt;。&lt;/li&gt;&lt;li&gt;&lt;b&gt;完整性&lt;/b&gt;：新词应当在给定的上下文环境中作为整体解释存在，因此需要同时考虑词组的子集短语以及超集短语的紧密度，从而衡量词组的完整性。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;Step3: &lt;b&gt;基于深度语义网络的短语质量评估&lt;/b&gt;。经过Step2可以得到大量有标记的候选短语数据，接下来会&lt;b&gt;基于BERT深度语义网络来构建短语质量打分器&lt;/b&gt;。为了进一步提升训练数据的质量，利用搜索日志数据对Step2中生成的大规模正负例池数据进行远程指导，将有大量搜索记录的词条作为有意义的关键词。&lt;b&gt;将正例池与搜索日志重合的部分作为模型正样本&lt;/b&gt;，而将负例池减去搜索日志集合的部分作为模型负样本，进而提升训练数据的可靠性和多样性。此外，&lt;b&gt;采用Bootstrapping方式&lt;/b&gt;，初次得到短语质量分后，重新根据已有短语质量分以及远程语料搜索日志更新训练样本，迭代训练提升短语质量打分器效果，有效减少了伪正例和伪负例。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;3.3 词典在线匹配&lt;/b&gt;&lt;/p&gt;&lt;p&gt;3.3.1初始词典在线匹配方案以及存在的问题&lt;/p&gt;&lt;p&gt;初始词典在线匹配方法直接&lt;b&gt;针对Query做双向最大匹配&lt;/b&gt;获得成分识别候选集合，再基于实体搜索量PV筛选出最终结果。这种策略存在以下几个问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;当Query包含实体词库未覆盖实体时，基于字符的最大匹配算法易引起切分错误&lt;/b&gt;。这里先补充点业务知识，“海坨山”是北京市延庆区的一处景点，“海坨山谷”是张家口海坨房地产开发有限公司开发的一处山景地产，两者从字面上非常像，但实体意义完全不同。当用户搜索词“海坨山谷”，因为海坨山谷属于小众并且新增的实体词，所以在词库中是不存在的。词库仅能匹配到“海坨山”，因此出现“海坨山/谷”的错误切分；&lt;/li&gt;&lt;li&gt;&lt;b&gt;粒度不可控&lt;/b&gt;。例如对搜索词“星巴克咖啡”的切分结果取决于词库对“星巴克”、“咖啡”以及“星巴克咖啡”的覆盖；&lt;/li&gt;&lt;li&gt;&lt;b&gt;节点权重定义不合理&lt;/b&gt;。例如直接基于实体搜索量作为实体节点权重，当用户搜索“信阳菜馆”时，“信阳菜/馆”的得分可能大于“信阳/菜馆”，因为信阳菜的名气大于信阳菜馆，所以对应的搜索量也更大。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;3.3.2 两阶段修复策略&lt;/p&gt;&lt;p&gt;为了解决上述问题，实体词典在线匹配前引入CRF分词模型，针对垂直领域美团搜索制定分词准则，人工标注语料并训练CRF分词模型。针对模型分词错误问题，设计两阶段修复策略：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;结合模型分词Term和基于领域字典匹配Term，根据动态规划求解Term序列权重和的最优解；&lt;/li&gt;&lt;li&gt;基于Pattern正则表达式的强修复规则。最后，输出基于实体库匹配的成分识别结果。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;下面举例说明，在百度搜索输入“富春江浙西”，然后返回的搜索结果会匹配到“富春江浙西桐庐餐厅”。下面是搜索示例：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-8d0bd993baf40b735353de705b70237d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;284&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-8d0bd993baf40b735353de705b70237d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;284&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-8d0bd993baf40b735353de705b70237d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-8d0bd993baf40b735353de705b70237d_b.jpg&quot;/&gt;&lt;figcaption&gt;图4 百度搜索NER示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;对应到美团搜索NER任务中，通过两阶段修复策略可以根据“富春江浙西”输出实体库匹配的成分识别结果“富春江浙西桐庐餐厅”。下面是词典在线匹配两阶段修复流程：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-8658f0d4e50a266fa9324275fff41435_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;315&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-8658f0d4e50a266fa9324275fff41435_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;315&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-8658f0d4e50a266fa9324275fff41435_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-8658f0d4e50a266fa9324275fff41435_b.jpg&quot;/&gt;&lt;figcaption&gt;图5 词典在线匹配两阶段修复流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e9759a27fd75e629684752e93cc7f498_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;202&quot; data-rawheight=&quot;97&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;202&quot; data-rawheight=&quot;97&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-e9759a27fd75e629684752e93cc7f498_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;4.1 在线预测模型演进流程&lt;/b&gt;&lt;/p&gt;&lt;p&gt;前面也说了对于头部query来说主要使用实体词典匹配的方法就可以使在线NER识别率达到92%，对于那些长尾并且比较复杂的query主要使用模型在线预测。美团搜索NER在线预测模型演进流程如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c1dc20862776b7d33a60dc4da002a463_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;160&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-c1dc20862776b7d33a60dc4da002a463_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;160&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-c1dc20862776b7d33a60dc4da002a463_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-c1dc20862776b7d33a60dc4da002a463_b.jpg&quot;/&gt;&lt;figcaption&gt;图6 在线预测模型演进流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;从上图可以看出，2018年以前主要使用传统序列标注模型CRF，2018年使用业界主流方式构建LSTM+CRF模型，这个在上一篇文章&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzU1NjYyODQ4NA%3D%3D%26mid%3D2247484811%26idx%3D1%26sn%3D74f60c7bebadc95f138b6e622736082b%26chksm%3Dfbc36ae0ccb4e3f69c0c302f3c9a23c991654ceea4d6c35538381ce026159921dc466cc79b35%26scene%3D21%23wechat_redirect&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; class=&quot;LinkCard old LinkCard--noImage&quot;&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;《广告行业中那些趣事系列31：关键词提取技术攻略以及BERT实践》&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;mp.weixin.qq.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;p&gt;也说过LSTM+CRF模型天然适配序列标注任务，自从2015年LSTM+CRF出世因为模型本身和任务匹配度非常高基本成为主流；2019年随着BERT大火主要将BERT进行蒸馏构建在线预测模型；2020年完成BERT上线，这块主要解决了BERT性能问题；目前正在探索的模型是BERT+LR，利用知识增强以及弱监督BERT-NER。&lt;/p&gt;&lt;p&gt;&lt;b&gt;4.2 模型在线预测主要面临的问题&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在实践探索中模型在线预测主要遇到以下三个问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;性能要求高&lt;/b&gt;：NER作为基础模块，模型预测需要在毫秒级时间内完成，而目前基于深度学习的模型基本上都存在计算量大、预测时间较长的问题。NLP场景中目前主流模型是BERT这种预训练+微调两阶段模型，虽然效果不错，但是模型本身非常大，对于线上化非常不友好。&lt;/li&gt;&lt;li&gt;&lt;b&gt;领域强相关&lt;/b&gt;：搜索中的实体类型与业务供给高度相关，只考虑通用语义很难保证模型识别的准确性。&lt;/li&gt;&lt;li&gt;&lt;b&gt;标注数据缺乏&lt;/b&gt;：NER标注任务相对较难，需给出实体边界切分、实体类型信息，标注过程费时费力，大规模标注数据难以获取。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;针对&lt;b&gt;性能要求高的问题&lt;/b&gt;，我们的线上模型在&lt;b&gt;升级为BERT时进行了一系列的性能调优&lt;/b&gt;；针对&lt;b&gt;NER领域相关问题&lt;/b&gt;，我们提&lt;b&gt;出了融合搜索日志特征、实体词典信息的知识增强NER方法&lt;/b&gt;；针对&lt;b&gt;训练数据难以获取的问题&lt;/b&gt;，我们提出一种&lt;b&gt;弱监督的NER方法&lt;/b&gt;。下面我们详细介绍下这些技术点。&lt;/p&gt;&lt;p&gt;&lt;b&gt;4.3 在线预测模型性能优化&lt;/b&gt;&lt;/p&gt;&lt;p&gt;BERT是典型的预训练+微调两阶段模型，因为效果好和应用范围广所以是目前NLP领域最火的模型之一。美团搜索在线预测模型也是基于BERT构建，但是BERT这类预训练模型本身非常大，所以在线推理耗时较长，很难在毫秒级响应。关于BERT的详细讲解请小伙伴们参考我之前写过的一篇文章&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzU1NjYyODQ4NA%3D%3D%26mid%3D2247483819%26idx%3D1%26sn%3D398402a5211130833a5762ffd5332764%26chksm%3Dfbc36ec0ccb4e7d6f37804a810f6dd54deccbb57cded589cf259fd7b9073cf876c82592ddbd1%26scene%3D21%23wechat_redirect&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; class=&quot;LinkCard old LinkCard--noImage&quot;&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;《广告行业中那些趣事系列3：NLP中的巨星BERT》&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;mp.weixin.qq.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;p&gt;将BERT应用于在线预测主要面临&lt;b&gt;预测速度慢&lt;/b&gt;的问题。针对这个问题主要从&lt;b&gt;模型蒸馏&lt;/b&gt;、&lt;b&gt;预测加速&lt;/b&gt;两个方面进行了探索，&lt;b&gt;分阶段上线了BERT蒸馏模型、BERT+Softmax、BERT+CRF模型&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;4.3.1 模型蒸馏&lt;/p&gt;&lt;p&gt;美团技术团队尝试了对BERT模型进行&lt;b&gt;剪裁&lt;/b&gt;和&lt;b&gt;蒸馏&lt;/b&gt;两种方式，实验结果证明剪裁对于NER这种复杂NLP任务精度损失严重，而模型蒸馏是可行的。&lt;b&gt;模型蒸馏用简单的话来说就是用简单模型来学习复杂模型，使得这个简单模型的效果可以匹配复杂模型，并且模型上线时预测速度也很快。&lt;/b&gt;我们团队之前用模型蒸馏主要是让TextCNN去学习BERT模型做文本分类任务，取得了不错的线上效果。关于模型蒸馏的详细讲解小伙伴们可以参考我之前写过的一篇文章&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzU1NjYyODQ4NA%3D%3D%26mid%3D2247484578%26idx%3D1%26sn%3D6d025edea6134b16f9a2e706ae0dacc8%26chksm%3Dfbc36bc9ccb4e2df3b6975389eec39e659fabfe4abb018d1a4da79ad04408da1f2525fd7ec0f%26scene%3D21%23wechat_redirect&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-cb4bd80e75f4fbc7dfb7eda8bc927c01_180x120.jpg&quot; data-image-width=&quot;400&quot; data-image-height=&quot;170&quot; class=&quot;LinkCard old LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;广告行业中那些趣事系列21：从理论到实战BERT知识蒸馏&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;mp.weixin.qq.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic2.zhimg.com/v2-cb4bd80e75f4fbc7dfb7eda8bc927c01_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;p&gt;美团技术团队构建IDCNN-CRF作为简单模型去学习复杂模型BERT，&lt;b&gt;在没有明显精度损失的前提下，蒸馏模型的在线预测速度有数十倍的提升&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;4.3.2 预测加速&lt;/p&gt;&lt;p&gt;&lt;b&gt;BERT在线预测速度比较慢还有个原因是存在大量小算子以及Attention计算量的问题。&lt;/b&gt;针对这个问题主要使用以下三种方法加速模型预测：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;算子融合&lt;/b&gt;：通过降低Kernel  Launch次数和提高小算子访存效率来减少BERT中小算子的耗时开销。这里调研了Faster  Transformer的实现。平均时延上，有1.4x~2x左右加速比；TP999上，有2.1x~3x左右的加速比。该方法适合标准的BERT模型。开源版本的Faster  Transformer工程质量较低，易用性和稳定性上存在较多问题，无法直接应用，我们基于NV开源的Faster  Transformer进行了二次开发，主要在稳定性和易用性进行了改进。易用性方面，支持自动转换，支持Dynamic Batch，支持Auto  Tuning；稳定性方面，修复内存泄漏和线程安全问题；&lt;/li&gt;&lt;li&gt;&lt;b&gt;Batching&lt;/b&gt;：Batching的原理主要是&lt;b&gt;将多次请求合并到一个Batch进行推理&lt;/b&gt;，降低Kernel  Launch次数、充分利用多个GPU  SM，从而提高整体吞吐。在max_batch_size设置为4的情况下，原生BERT模型，可以在将平均Latency控制在6ms以内，最高吞吐可达1300  QPS。该方法十分适合美团搜索场景下的BERT模型优化，原因是&lt;b&gt;搜索有明显的高低峰期，可提升高峰期模型的吞吐量；&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;混合精度&lt;/b&gt;：混合精度指的是FP32和FP16混合的方式，&lt;b&gt;使用混合精度可以加速BERT训练和预测过程并且减少显存开销，同时兼顾FP32的稳定性和FP16的速度&lt;/b&gt;。在模型计算过程中使用FP16加速计算过程，模型训练过程中权重会存储成FP32格式，参数更新时采用FP32类型。利用FP32   Master-weights在FP32数据类型下进行参数更新，可有效避免溢出。混合精度在基本不影响效果的基础上，模型训练和预测速度都有一定的提升。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;除了上述模型蒸馏和预测加速提升在线模型预测性能之外，对于搜索日志中pv较高的query可以将预测结果以词典方式上传到缓存，进一步减少模型在线预测的QPS压力。&lt;/p&gt;&lt;p&gt;&lt;b&gt;4.4 基于知识增强NER解决领域相关问题&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如何&lt;b&gt;将特定领域的外部知识作为辅助信息嵌入到语言模型&lt;/b&gt;中，一直是近些年的研究热点。K-BERT、ERNIE等模型探索了知识图谱与BERT的结合方法，为我们提供了很好的借鉴。美团搜索中的NER是领域相关的，实体类型的判定与业务供给高度相关。因此，我们也探索了如何将供给POI信息、用户点击、领域实体词库等外部知识融入到NER模型中。&lt;/p&gt;&lt;p&gt;4.4.1 融合搜索日志特征的Lattice-LSTM&lt;/p&gt;&lt;p&gt;在O2O垂直搜索领域，大量的实体由商家自定义（如商家名、团单名等），实体信息隐藏在供给POI的属性中，单使用传统的语义方式识别效果差。&lt;b&gt;Lattice-LSTM针对中文实体识别，通过增加词向量的输入，丰富语义信息&lt;/b&gt;。借鉴这个思路，结合搜索用户行为，挖掘Query 中潜在短语，这些短语蕴含了POI属性信息，然后将这些隐藏的信息嵌入到模型中，&lt;b&gt;在一定程度上解决领域新词发现问题&lt;/b&gt;。与原始Lattice-LSTM方法对比，识别准确率千分位提升5个点。下面是融合搜索日志特征的模型训练和预测流程图：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-bcae573d3ba4854bdb41b197d4b99c02_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;511&quot; data-rawheight=&quot;227&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-bcae573d3ba4854bdb41b197d4b99c02_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;511&quot; data-rawheight=&quot;227&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-bcae573d3ba4854bdb41b197d4b99c02_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-bcae573d3ba4854bdb41b197d4b99c02_b.jpg&quot;/&gt;&lt;figcaption&gt;图7 融合搜索日志特征的模型训练和预测流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;4.4.2 融合实体词典的两阶段NER&lt;/p&gt;&lt;p&gt;我们考虑将领域词典知识融合到模型中，提出了&lt;b&gt;两阶段的NER识别方法&lt;/b&gt;。该方法是&lt;b&gt;将NER任务拆分成实体边界识别和实体标签识别两个子任务&lt;/b&gt;。相较于传统的端到端的NER方法，这种方法的优势是实体切分可以跨领域复用。另外，在实体标签识别阶段可以充分使用已积累的实体数据和实体链接等技术提高标签识别准确率，缺点是会存在错误传播的问题。&lt;/p&gt;&lt;p&gt;在第一阶段，让BERT模型专注于实体边界的确定，而第二阶段将实体词典带来的信息增益融入到实体分类模型中。第二阶段的实体分类可以单独对每个实体进行预测，但这种做法会丢失实体上下文信息，我们的处理方法是：将实体词典用作训练数据训练一个IDCNN分类模型，该模型对第一阶段输出的切分结果进行编码，并将编码信息加入到第二阶段的标签识别模型中，联合上下文词汇完成解码。基于Benchmark标注数据进行评估，该模型相比于BERT-NER在Query粒度的准确率上获得了1%的提升。这里我们使用IDCNN主要是考虑到模型性能问题，大家可视使用场景替换成BERT或其他分类模型。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-119ec63b47fdcd79dfa03f738686e7b1_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;447&quot; data-rawheight=&quot;303&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-119ec63b47fdcd79dfa03f738686e7b1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;447&quot; data-rawheight=&quot;303&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-119ec63b47fdcd79dfa03f738686e7b1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-119ec63b47fdcd79dfa03f738686e7b1_b.jpg&quot;/&gt;&lt;figcaption&gt;图8 融合实体词典的两阶段NER流程图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;4.5 基于弱监督NER解决训练数据难获取问题&lt;/b&gt;&lt;/p&gt;&lt;p&gt;针对标注数据难获取问题，我们提出了一种弱监督方案，该方案包含两个流程，分别是&lt;b&gt;弱监督标注数据生成&lt;/b&gt;、&lt;b&gt;模型训练&lt;/b&gt;。下面详细描述下这两个流程。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b5c684c0c5b7ffc7538fc961cf0b20c2_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;220&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-b5c684c0c5b7ffc7538fc961cf0b20c2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;220&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-b5c684c0c5b7ffc7538fc961cf0b20c2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b5c684c0c5b7ffc7538fc961cf0b20c2_b.jpg&quot;/&gt;&lt;figcaption&gt;图9 弱监督标注数据生成流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;Step1：弱监督标注样本生成&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;初版模型&lt;/b&gt;：利用已标注的小批量数据集训练实体识别模型，这里使用的是最新的BERT模型，得到初版模型ModelA。&lt;/li&gt;&lt;li&gt;&lt;b&gt;词典数据预测&lt;/b&gt;：实体识别模块目前沉淀下百万量级的高质量实体数据作为词典，数据格式为实体文本、实体类型、属性信息。用上一步得到的ModelA预测改词典数据输出实体识别结果。&lt;/li&gt;&lt;li&gt;&lt;b&gt;预测结果校正&lt;/b&gt;：实体词典中实体精度较高，理论上来讲模型预测的结果给出的实体类型至少有一个应该是实体词典中给出的该实体类型，否则说明模型对于这类输入的识别效果并不好，需要针对性地补充样本，我们对这类输入的模型结果进行校正后得到标注文本。校正方法我们尝试了两种，分别是&lt;b&gt;整体校正&lt;/b&gt;和&lt;b&gt;部分校正&lt;/b&gt;，整体校正是指整个输入校正为词典实体类型，部分校正是指对模型切分出的单个Term 进行类型校正。&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;        举个例子来说明，“兄弟烧烤个性diy”词典中给出的实体类型为商家，模型预测结果为修饰词+菜品+品类，没有Term属于商家类型，&lt;b&gt;模型预测结果和词典有差异&lt;/b&gt;，这时候我们需要对模型输出标签进行校正。校正候选就是三种，分别是“商家+菜品+品类”、“修饰词+商家+品类”、“修饰词+菜品+商家”。我们选择最接近于模型预测的一种，这样选择的理论意义在于模型已经收敛到预测分布最接近于真实分布，我们只需要在预测分布上进行微调，而不是大幅度改变这个分布。那从校正候选中如何选出最接近于模型预测的一种呢？我们使用的方法是计算校正候选在该模型下的概率得分，然后与模型当前预测结果（当前模型认为的最优结果）计算概率比，概率比计算公式如公式2所示，概率比最大的那个就是最终得到的校正候选，也就是最终得到的弱监督标注样本。在“兄弟烧烤个性diy”这个例子中，“商家+菜品+品类”这个校正候选与模型输出的“修饰词+菜品+品类”概率比最大，将得到“兄弟/商家  烧烤/菜品 个性diy/品类”标注数据。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f9536b0a20e98879925323ba16b90e45_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;505&quot; data-rawheight=&quot;148&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-f9536b0a20e98879925323ba16b90e45_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;505&quot; data-rawheight=&quot;148&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-f9536b0a20e98879925323ba16b90e45_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-f9536b0a20e98879925323ba16b90e45_b.jpg&quot;/&gt;&lt;figcaption&gt;图10 预测结果修正举例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;    弱监督模型训练方法包括两种：一是将生成的弱监督样本和标注样本进行混合不区分重新进行模型训练；二是在标注样本训练生成的ModelA基础上，用弱监督样本进行Fine-tuning训练。这两种方式我们都进行了尝试。从实验结果来看，Fine-tuning效果更好。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5eca3c3031291fc57b3e95f1f5fc5d31_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;140&quot; data-rawheight=&quot;81&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;140&quot; data-rawheight=&quot;81&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-5eca3c3031291fc57b3e95f1f5fc5d31_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;本篇主要是学习美团技术团队分享的《美团搜索中NER技术的探索与实践》学习笔记。首先介绍了背景，包括NER任务定义、美团搜索场景下的NER以及美团搜索NER任务面临的挑战；然后重点介绍了美团基于实体词典匹配+模型在线预测框架。通过实体词典匹配可以解决头部搜索NER匹配问题，而长尾复杂的搜索则通过模型在线预测解决。对于想了解美团搜索NER技术实践的小伙伴可能有所帮助。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-160b81850cde8d021d92f5722c62ce5d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;103&quot; data-rawheight=&quot;75&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;103&quot; data-rawheight=&quot;75&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-160b81850cde8d021d92f5722c62ce5d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;[1] 美团搜索中NER技术的探索与实践&lt;/p&gt;&lt;p&gt;最新最全的文章请关注我的微信公众号或者知乎专栏：数据拾光者。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/0igEHCfEQ3o8rWN-933A&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;weixin.qq.com/r/0igEHCf&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;EQ3o8rWN-933A&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt; (二维码自动识别)&lt;/p&gt;&lt;p&gt;码字不易，欢迎小伙伴们点赞和分享。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>