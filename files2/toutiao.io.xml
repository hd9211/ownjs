<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e733eec5f401db1a28aedc1a7c4ba462</guid>
<title>什么是好代码，Linux 大神来告诉你</title>
<link>https://toutiao.io/k/wo59ywm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-pm-slice=&quot;0 0 []&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;span&gt;‍&lt;/span&gt;‍&lt;/span&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.33184855233853006&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgRgzIV2YTLYP1C9K6m6ZesXIGMic8cBk5es1ZicMDfULrExGEw49a51icWhlYkA1pXmib62xNNUDrMgXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;898&quot;/&gt;&lt;span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;我是架构精进之路，点击上方“关注”，坚持每天为你分享技术干货，私信我回复“01”，送你一份程序员成长进阶大礼包。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.64453125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z2bVaFK6CgSYyADcSp1iavTiaJaNjgMtp8IS635j8outbDiardF9ojy2QPicXxSMkube0NJickrrVgmCyic0sya3P5AQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在工作中经常有同学在讨论，到底什么是好代码？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于好代码，相信每个人都有自己的理解，可能它是包括以下几个维度：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;关于代码结构本身；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;关于功能实现；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;关于学习成本；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;关于程序可读性...&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;但是全面清晰的将所有标准都一一列举出来又是非常困难。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;记得某一期的TED邀请了 Linus，里面讲到了他个人对生活的品味，以及为啥有 Linux 等等。其中Linus 提到了对 “好代码”的一些看法，一起整理分享给大家。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1 spellcheck=&quot;false&quot;&gt;&lt;span&gt;&lt;strong&gt;1. Linus Torvalds 介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img data-ratio=&quot;1.530612244897959&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z2bVaFK6CgSYyADcSp1iavTiaJaNjgMtp8PGvadY1Gc4ibgYTpPWJwPJsLtqtHTuSBfLRWMhI15nbYN0nzb5OPNrQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;196&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;Linus Torvalds 是Linux内核的缔造者，22岁他还在上大学的时候，就把Linux内核写出来了, 在他购买IBM PC的时候，第一想法是为这个PC写一个操作系统，而不是像普通人一样地去装这个系统装那个软件。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Linux 内核基本上全部是C语言实现的，底层的/boot由汇编实现，大量的移位运算，按位运算，定点移位运算，速度极快！特别在很多没有乘法指令的RISC结构CPU上，这样做是极其高效的，也是硬件容易接受编程方式。&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;注意: Operating System 可不是谁想写就能写的。尤其是OS内核部分，单会编程语言是远远不够的, 硬件知识的储备也是必不可少的。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;Linus Torvalds两次改变了技术，第一次是Linux内核，它帮助互联网的发展；第二次是Git，全球开发者使用的源代码管理系统。&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;Linus 本人同样是Git的缔造者， Git目前世界上最牛逼的分布式版本控制系统(没有之一)&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;h1 spellcheck=&quot;false&quot;&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1 spellcheck=&quot;false&quot;&gt;&lt;span&gt;&lt;strong&gt;2. 关于好代码&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Linus Torvalds说：&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“有时候你可以换个角度看问题，重写代码，排除特例，完美覆盖所有情况，这就是好的代码。同时也很简单，这是最基本的原则。细节非常重要。”&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在采访中，Linus Torvalds对比了以下2个函数：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 不怎么漂亮的代码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;img data-height=&quot;0&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z2bVaFK6CgSYyADcSp1iavTiaJaNjgMtp84pDbicw4xcdwO2bjmYGkZhfjs3znuRKShib2PSBn4nlKHbhavMIiba6tA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-width=&quot;0&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre language=&quot;javascript&quot; code_block=&quot;true&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;remove_list_entry(entry)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    prev = &lt;span class=&quot;code-snippet__keyword&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    walk = head;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (walk != entry)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        prev = walk;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        walk = walk-&amp;gt;next;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;(!prev)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        head = entry-&amp;gt;next;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        prev-&amp;gt;next = entry-&amp;gt;next;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;上面的代码，需要区分要移除的成员是否为链表的头一个成员。需要单独处理特例情况（要移除的成员为链表的头一个成员）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 好的代码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img data-height=&quot;0&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z2bVaFK6CgSYyADcSp1iavTiaJaNjgMtp8XmBZorViaAhCS3sJeHpeF4QGZicOibx7k7YM05UoQCA3dHKGMpZKiajYYQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-width=&quot;0&quot;/&gt;&lt;/section&gt;&lt;pre language=&quot;javascript&quot; code_block=&quot;true&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;remove_list_entry(entry)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;indirect&lt;/span&gt; = &amp;amp;head;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; ((*&lt;span class=&quot;code-snippet__keyword&quot;&gt;indirect&lt;/span&gt;) != entry))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;indirect&lt;/span&gt; = &amp;amp;(*&lt;span class=&quot;code-snippet__keyword&quot;&gt;indirect&lt;/span&gt;)-&amp;gt;next;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    *&lt;span class=&quot;code-snippet__keyword&quot;&gt;indirect&lt;/span&gt; = entry-&amp;gt;next;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这个代码完全不需要单独处理特例情况，程序整体更加整洁、优雅。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其实现原理为：指针变量indirect保存的是链表成员结构体中的next成员的地址（head指针也可这样看），如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-height=&quot;266&quot; data-ratio=&quot;0.26814516129032256&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z2bVaFK6CgSYyADcSp1iavTiaJaNjgMtp8T2bkq1LbiaEomCyIZj5f0TibUaRibibl2yBaCPjEtBurYoLg9JSdMNO87A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;992&quot; data-width=&quot;992&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以变量*indirect就相当于是前一个链表成员的next成员（相对于要移除的成员来说）。当找到要移除的成员后，进行如下操作即可：&lt;/span&gt;&lt;/section&gt;&lt;pre language=&quot;javascript&quot; code_block=&quot;true&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;*indirect = entry-&amp;gt;next;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h1 spellcheck=&quot;false&quot;&gt;&lt;span&gt;&lt;strong&gt;3. 访谈中的其他观点&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.1、关于工作方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在本次TED的采访中，&lt;span&gt;Torvalds&lt;/span&gt;以极其开放的态度讨论了他独特的工作方式和性格特点。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Linus Torvalds说：“我不是一个空想家，我是一名工程师，我非常乐意跟梦想家在一起，他们行走四方，仰望苍穹，看着满天星辰说，“我想到那儿去。”但我是低头看路的那种人，我只想填好眼前这个坑，不让自己掉进去，这就是我。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;3.2. 关于开源&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Linus Torvalds说道：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Linux并不是一个合作的产物，它是我一系列项目中的一个，纯粹出于自己当时的需要，部分原因是我需要得到结果，但更重要的原因是我享受编程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当年我只是想做一个完全属于自己的项目，我压根就没想过开源这件事。但在那之后，随着项目越来越大， 你会开始想让别人知道。感觉就像 “哇，快来看看我的成果！”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;成千上万的人想参与进来（Linux内核项目），但很多时候，我成为了那个断点，我无法让自己跨出那一步，同上千人合作。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因此Git是我的第二个大项目，它存在的意义就是维护我的第一个大项目。我编程是因为好玩，但我也想做一些有意义的事情，因此我设计每一个程序仅仅是因为我自己需要。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;而我喜欢开源软件的一点就是，它能让形形色色的人在一起合作。我们不必相互喜欢，有时候我们甚至互相讨厌&lt;/strong&gt;。是真的，我们经常吵得不可开交。&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;科学界的开源显然是一种回归，科学最初是开源的。&lt;/span&gt;&lt;span&gt;但之后变得越来越封闭，只存在那些昂贵的科学期刊上。&lt;/span&gt;&lt;span&gt;开源让科学&lt;/span&gt;&lt;span&gt;回归了，我们有了arXiv和开放期刊。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgSYyADcSp1iavTiaJaNjgMtp8f3UH6eg4Xn5b5sF3QRACAELXZXLic0bjEYS9c7GrQ3ZDTPCT26B6oNA/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;508.84615384615375&quot; data-ratio=&quot;0.47129629629629627&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z2bVaFK6CgSYyADcSp1iavTiaJaNjgMtp8ZMnX98RaJIleC5JTFNqKSpsraq2asLiaeM8stHZCCoU4XBS4fPLN9ibw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;附：&lt;/span&gt;&lt;span&gt;关于Linus Torvalds 本期 TED采访原视频，关注公众号回复关&lt;/span&gt;&lt;span&gt;键字“TED”即可获取&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p data-pm-slice=&quot;1 1 []&quot;&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;作者：架构精进之路，专注软件架构研究，技术学习与个人成长，关注并私信我回复“01”，送你一份程序员成长进阶大礼包。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;往期热文推荐：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98311&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;395&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;395&quot; data-ratio=&quot;0.36484375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgSxEpr7AzM5lGCicdEjfuE6jaiae9Rmj1CVCg85GJKaFKuico89ZlnhGicQiciciccOiaqVibE5cmKXwO1AOuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;87502&quot;&gt;&lt;p&gt;&lt;span&gt;「技术架构精进」专注架构研究，技术分享&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Thanks for reading!&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6741d350af3bda0d29555db200af2f5f</guid>
<title>58安居客二手房 API Gateway Sidecar 实践</title>
<link>https://toutiao.io/k/f4uurpl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.084375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2VY3NksPSaHql4LCOdAUeJwmvS72ibDvaMNiaLQkNZjTFquznHkHcccc2hnKS6nNAx0Y7bSUia0iaUZxQ5N5Zfxldw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;导读&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;58安居客二手房业务线的技术架构合并后，许多老页面需要逐步的重构成同一套技术体系，Web端采用NodeJs渲染，App后端API采用Java，再加上部分老的页面仍然使用的PHP。我们在对外接口这一层有很多通用的拦截功能，例如签名验证、用户票据验签、反爬虫拦截、公共参数处理、城市域名解析等。3套不同的技术栈意味着这些功能都要用不同的语言重复开发3遍，各端逻辑难以统一和维护，面临不少困难，因此亟需一个API网关能够统一的处理这些逻辑，降低维护成本。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;58安居客二手房业务线的技术架构合并后，许多老页面需要逐步的重构成同一套技术体系，Web端采用NodeJs渲染，App后端API采用Java，再加上部分老的页面仍然使用的PHP。我们在对外接口这一层有很多通用的拦截功能，例如签名验证、用户票据验签、反爬虫拦截、公共参数处理、城市域名解析等。3套不同的技术栈意味着这些功能都要用不同的语言重复开发3遍，各端逻辑难以统一和维护，面临不少困难，因此亟需一个API网关能够统一的处理这些逻辑，降低维护成本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;API Gateway 选型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;考虑到会有很多定制需求，加上二手房技术团队本身对Java比较熟悉，因此直接选择了Java技术栈下的解决方案。主要有3种：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;基于Netty定制&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Spring Cloud Zuul&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Spring Cloud Gateway&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;网关作为所有流量的入口，对于吞吐量、稳定性、请求延迟、资源占用都有着更高的要求。Zuul是基于Servlet的同步线程模型，不可避免的容易存在一些IO阻塞的场景导致线程频繁切换、线程阻塞等问题。而纯异步的线程和IO模型，能够减少线程开销、避免IO阻塞，因此在网关上Netty定制和Spring Cloud Gateway都是更好的选择&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而Netty定制需要比较多的开发资源投入，二手房技术团队重心还是在业务项目上，没有太大精力完全自研。最终我们选择了底层同样基于Netty的Spring Cloud Gateway&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Spring Cloud Gateway是Spring Cloud最新的网关组件，底层基于Project Reactor和Spring Webflux构建。Project Reactor提供了一套响应式编程风格的API以及底层基于Netty的异步网络请求模型，能够提供一套纯异步的编程和运行环境，在高并发的场景下能够比较好的利用CPU资源，避免出问题时大量线程阻塞的问题。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;什么是API Gateway Sidecar&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;传统的网关部署模式下，一般是外网流量进来以后直接进入到网关层，网关处理通用逻辑之后，再将流量转发给后端的业务服务器&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5813953&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaH15ewYmHialJD9xr4al1jDlVoicQC3VMbkgvzaJuhCArah9yRmc8H1he5qpSjqHwLun2dIicdibXA4ZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;172&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是58的运维架构如果要改成上述这种模式，成本风险都比较大，而且短期内只有房产二手房业务线一个团队有这样的需求。另外对接容器云平台的服务发现功能也比较复杂，短期内可行的架构如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.1337209&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaH15ewYmHialJD9xr4al1jDlAUic3vZbic8WljR36ibhw0uoX6eUD4jlK5xVdHEsDoIexJH3ciaMHS9Mqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;172&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是这种模式很快就被我们否定了，内网流量增加3倍，运维成本和系统稳定性都增加了很多不确定性。因此需要寻找一个既能满足我们的需求，又能适配当前58的运维和容器云平台架构的模式&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们将目光瞄向了Service Mesh架构中的Sidecar模式。Sidecar模式是在容器内部部署了一个Sidecar进程，流量先经过Sidecar代理，完成鉴权、日志、服务注册发现等功能。参考Sidecar模式，我们可以在容器内部署一个API Gateway进程，拦截进来的http流量，进行处理后再转发到原来的web进程。于是我们的部署结构如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.1130952&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaH15ewYmHialJD9xr4al1jDl7YhAsY549xYrkE4DZeSPSiadIJsE8pHaqkJUznBC1tCwbtg5nBcsZ2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;168&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这样在现有的运维和容器云架构下能够完美的实现我们需要的功能，流量和运维成本都没有太大的增加，我们只需要处理好Sidecar进程的监控即可&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;容器内Gateway进程部署&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;公司的云平台提供了启动脚本的钩子和自定义上传文件的功能，我们可以很轻松的实现网关安装包的安装和进程启动。不过Gateway进程的监控和容器关闭的钩子目前没有直接支持，已经和云平台的同学提需求后续考虑支持&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Java版本选择了JDK 11，对G1 GC延迟有比较大的优化，能够减少GC对网关的影响。Gateway进程内部本身没有太多的大内存使用，我们也希望资源能够占用尽量少一点，因此JVM堆大小选择了512MB&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后结合云平台提供的镜像商店，我们将这些功能都集成到一起放到一个基础镜像中。这样业务集群需要接入的时候直接继承Gateway的镜像即可。后续镜像的维护升级也可以由Gateway负责的同学统一安排&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;功能定制，模板化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在最初的版本上我们主要实现了4个功能&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;http跳转https&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;用户登陆票据验证&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;城市域名、路径解析&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;反爬虫服务接入&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;需要注意的是以上功能都需要同时支持58和安居客两个网站&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;功能开发上，由于二手房之前积累了不少CompletableFuture的使用经验，因此Reactor的Mono/Flux API上手起来还比较快。用户登陆的票据验证，由于云账号只提供了同步版本的SDK，因此我们暂时使用了线程池来兼容，后续云账号会提供支持异步版本的SDK供我们集成。反爬虫则基于SCF的异步调用来实现。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于不同域名(58.com/anjuke.com)、不同平台(web/app/小程序)城市解析还有反爬参数都不同，我们提供了模板化的预定义配置文件，业务方在接入时只需要根据当前集群支持的域名，直接引入模板配置即可快速上线&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;性能压测&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们使用ab对网关进行了压测，测试方式为网关在处理完上述4个功能的逻辑后直接返回200给请求方，流量不经过业务进程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;测试容器为4核4G的云平台容器：&lt;/span&gt;&lt;/section&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;并发数&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;P99&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;最慢请求&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;QPS&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;4&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;4&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;20ms&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;1500&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;8&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;7&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;30ms&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;2100&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;16&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;11&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;35ms&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;2200&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;4并发发的情况下，P99 4ms的性能开销完全满足我们的业务需求。&lt;/span&gt;&lt;span&gt;8并发时&lt;/span&gt;&lt;span&gt;也有不错的性能，而且4核单机2000 QPS至少能保证网关进程性能是远超过业务的Node/Java/PHP进程的&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;GC方面，Young GC基本维持在2~5ms，约1300次请求一次Young GC，对性能的影响目前来说没有太大问题。另外我们压测了大约近百万次请求都没有发生Mix GC，Old区的堆大小一直也比较稳定的维持在25%左右。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;上线实测&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;完成上述这些步骤后，我们开始在线上的集群实际的测试。我们先选取了一个流量很小的集群完成线上的初步验证后，开始在二手房业务mobile web最核心的二手房详情页进行应用。这个页面本身是使用NodeJs运行的&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;实际上线后，由于NodeJs中反爬、获取票据的逻辑都迁移到了Gateway中，整体的页面性能，平均速度提升了20%+，p95性能提升5~10%。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.3824074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaH15ewYmHialJD9xr4al1jDlZmNvd7T4Ao5ibjymiaD1JYaqP76AjTEumBdaib3ibsfMSiaq6MBb1ibcNTeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.3666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaH15ewYmHialJD9xr4al1jDlhD1BT9NmSnu3sOmZ1rocYVVBFDqpZ7pEBlGHFOUfSfCJ6t2xcx8icng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;更为重要的是，之前的NodeJs在高峰期或者遭到爬虫突然的大量请求时，响应时间的波动非常大。Gateway上线以后有效的平抑了这部分波动，减轻NodeJS进程的压力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.3703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaH15ewYmHialJD9xr4al1jDlA3Pbia6tTmKYXKMN1leBVTHWMDU9ELwYMCdhv4C682MicZfUUtibW4GZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;资源使用方面，CPU占用平均增加约5%，内存占用增加不到1G。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;监控方面，由于初期规模较小，目前只是依赖了Spring Boot Admin来进行简单的监控，后续这方面需要投入比较大的精力迭代。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结及后续优化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;目前这套Gateway已经在房产二手房业务线多个NodeJs和Java集群上线，给业务开发同学，特别是前端的同学减轻了不少维护成本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;后续的优化方向上主要是在性能、监控、通用化上进行优化&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;性能方面主要是优化日志的打印，进一步降低CPU开销以及GC频率的降低&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;监控上未来需要加强Gateway进程可用性的监控，避免假死；以及报警手段的加强&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通用化上，我们希望这个组件能够更加的可定制化和可扩展，方便其他业务线的团队有需求时能够快速的应用上线&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;作者简介：&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;董菲：房产事业群--二手房用户技术部 后端架构师&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;推荐阅读：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NDc5MzIxMw==&amp;amp;mid=2247491108&amp;amp;idx=1&amp;amp;sn=ed089c0fcc0a61f20021350624d27be1&amp;amp;chksm=ea3e9ab6dd4913a0dd66ef55c19dfbcc5449ce4b1afb33104662b6515a2a270d794353cb9cf4&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;营销自动化系统设计与实现&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NDc5MzIxMw==&amp;amp;mid=2247491058&amp;amp;idx=1&amp;amp;sn=3b1d7e68ff51df58046d1e0d0aee1039&amp;amp;chksm=ea3e9960dd491076573553ff0c74d1c41db04c1fd9be9a9d3d080cbe7e27955ac0ec151f5285&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;从Mach-O角度谈谈Swift和OC的存储差异&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NDc5MzIxMw==&amp;amp;mid=2247491090&amp;amp;idx=1&amp;amp;sn=5fd4e3eb17f7c5d8c9035e0f96c73084&amp;amp;chksm=ea3e9a80dd491396b0b937b4d70a16366b8241df24f67197256171a8193ffac21586a117ba82&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;文本预训练模型在信息安全场景的探索和实践&lt;/a&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;福利环节&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt; 为了鼓励优质内容传播，【58技术】公众号近期会持续推出不定期活动奖励。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;评论区参与话题讨论，#前后端交互的痛点#&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将抽取三个优质评论，送出定制版新年代码台历一本&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;活动时间：截至2021年1月24日&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.4481481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2VY3NksPSaH15ewYmHialJD9xr4al1jDlOElUklg3qIa5hibd9aUP0uhSRiamFR6mRziaejfyX6nUzSDqibPIwvVH7g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.35546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2VY3NksPSaHql4LCOdAUeJwmvS72ibDva6YTC5lzpo8tfzSSeQuxRfxPibP3ybyWlpt9d4VxXd8hO5GiaJdMhba5Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fcaac2b4c965037fdc1783334af8eb9a</guid>
<title>[译] 项目实战：使用 Go 构建 GraphQL API</title>
<link>https://toutiao.io/k/kw819ts</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7647058823529411&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UWba2ryLMql57M9Mgzo2dPJhrLdP13LYyawPzR90IIqJWQ1OianjSmjynEicZeZMbmR8e38mKTljJfCNq7w6iamZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;425&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;2020/5/16 更新：大家好，我刚刚更新了该项目以使用 Go module。不幸的是，&lt;span&gt;realize&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;很长时间没有更新并且无法正常工作。如果您想使用实时重新加载器，则还有其他选择，例如 &lt;span&gt;air&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;。否则，请随意忽略帖子中有关 realize 的任何内容，并按通常的方式运行项目。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本博文中将使用 &lt;strong&gt;Go&lt;/strong&gt;、&lt;strong&gt;GraphQL&lt;/strong&gt;、&lt;strong&gt;PostgreSQL&lt;/strong&gt; 创建一个 API。我已在项目结构上迭代几个版本，这是我最喜欢的一个。在大部分的时间，我创建 web APIs 都是通过 &lt;strong&gt;Node.js&lt;/strong&gt; 和 &lt;strong&gt;Ruby/Rails&lt;/strong&gt;。而第一次使用 &lt;strong&gt;Go&lt;/strong&gt; 设计 Web apis 时,需要费很大的劲儿。&lt;strong&gt;Ben Johnson&lt;/strong&gt; 的 &lt;span&gt;Structuring Applications in Go&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt; 文章对我有很大的帮助，本博文中的部分代码就得益于 &lt;strong&gt;Ben Johnson&lt;/strong&gt; 文章的指导，推荐阅读。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;配置&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，从项目的配置开始。在本篇博文中，我将在 macOS 中完成，但这并不重要。如果在你的 macOS 上还没有 &lt;strong&gt;Go&lt;/strong&gt; 和 &lt;strong&gt;PostGreSQL&lt;/strong&gt;，&lt;span&gt;bradford-hamilton/go-graphql-api&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt; 详细讲解了如何在 macOS 上配置 &lt;strong&gt;Go&lt;/strong&gt; 和 &lt;strong&gt;PostgreSQL&lt;/strong&gt;.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个新项目--&lt;strong&gt;go-graphal-api&lt;/strong&gt;，整体项目结构如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;├── gql&lt;br/&gt;│   ├── gql.go&lt;br/&gt;│   ├── queries.go&lt;br/&gt;│   ├── resolvers.go&lt;br/&gt;│   └── types.go&lt;br/&gt;├── main.go&lt;br/&gt;├── postgres&lt;br/&gt;│   └── postgres.go&lt;br/&gt;└── server&lt;br/&gt; └── server.go&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一些额外依赖需要安装。开发中热加载的 &lt;span&gt;realize&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;，go-chi 的轻量级路由 &lt;span&gt;chi&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt; 和管理 request/response 负载的 &lt;span&gt;render&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;，以及 &lt;span&gt;graphql-go/graphql&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;go get github.com/oxequa/realize&lt;br/&gt;go get github.com/go-chi/chi&lt;br/&gt;go get github.com/go-chi/render&lt;br/&gt;go get github.com/graphql-go/graphql&lt;br/&gt;go get github.com/lib/pq&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，创建一个数据库和一些测试使用的数据，在 Postgres 的命令行中输入 &lt;strong&gt;psql&lt;/strong&gt;，创建一个数据库：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;DATABASE&lt;/span&gt; go_graphql_db;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后连接上该库：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;\c go_graphql_db&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;连接上后，将以下 sql 语句粘贴到命令行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;users&lt;/span&gt; (&lt;br/&gt;  &lt;span&gt;id&lt;/span&gt; &lt;span&gt;serial&lt;/span&gt; PRIMARY &lt;span&gt;KEY&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;name&lt;/span&gt; &lt;span&gt;VARCHAR&lt;/span&gt; (&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;  age &lt;span&gt;INT&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;  profession &lt;span&gt;VARCHAR&lt;/span&gt; (&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;  friendly &lt;span&gt;BOOLEAN&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;br/&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;users&lt;/span&gt; &lt;span&gt;VALUES&lt;/span&gt;&lt;br/&gt;  (&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&#x27;kevin&#x27;&lt;/span&gt;, &lt;span&gt;35&lt;/span&gt;, &lt;span&gt;&#x27;waiter&#x27;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;),&lt;br/&gt;  (&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&#x27;angela&#x27;&lt;/span&gt;, &lt;span&gt;21&lt;/span&gt;, &lt;span&gt;&#x27;concierge&#x27;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;),&lt;br/&gt;  (&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;&#x27;alex&#x27;&lt;/span&gt;, &lt;span&gt;26&lt;/span&gt;, &lt;span&gt;&#x27;zoo keeper&#x27;&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;),&lt;br/&gt;  (&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;&#x27;becky&#x27;&lt;/span&gt;, &lt;span&gt;67&lt;/span&gt;, &lt;span&gt;&#x27;retired&#x27;&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;),&lt;br/&gt;  (&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;&#x27;kevin&#x27;&lt;/span&gt;, &lt;span&gt;15&lt;/span&gt;, &lt;span&gt;&#x27;in school&#x27;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;),&lt;br/&gt;  (&lt;span&gt;6&lt;/span&gt;, &lt;span&gt;&#x27;frankie&#x27;&lt;/span&gt;, &lt;span&gt;45&lt;/span&gt;, &lt;span&gt;&#x27;teller&#x27;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们创建了一个基础的用户表并新增了 6 条新用户数据，对本博文来说已经足够。接下来开始构建我们的 API。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这篇博文中，所有的代码片段都会包含一些注释，以帮助理解每一步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 &lt;strong&gt;main.go&lt;/strong&gt; 开始：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;net/http&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/bradford-hamilton/go-graphql-api/gql&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/bradford-hamilton/go-graphql-api/postgres&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/bradford-hamilton/go-graphql-api/server&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/go-chi/chi&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/go-chi/chi/middleware&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/go-chi/render&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/graphql-go/graphql&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// Initialize our API and return a pointer to our router for http.ListenAndServe&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// and a pointer to our db to defer its closing when main() is finished&lt;/span&gt;&lt;br/&gt; router, db := initializeAPI()&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; db.Close()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Listen on port 4000 and if there&#x27;s an error log it and exit&lt;/span&gt;&lt;br/&gt; log.Fatal(http.ListenAndServe(&lt;span&gt;&quot;:4000&quot;&lt;/span&gt;, router))&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;initializeAPI&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(*chi.Mux, *postgres.Db)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// Create a new router&lt;/span&gt;&lt;br/&gt; router := chi.NewRouter()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Create a new connection to our pg database&lt;/span&gt;&lt;br/&gt; db, err := postgres.New(&lt;br/&gt;  postgres.ConnString(&lt;span&gt;&quot;localhost&quot;&lt;/span&gt;, &lt;span&gt;5432&lt;/span&gt;, &lt;span&gt;&quot;bradford&quot;&lt;/span&gt;, &lt;span&gt;&quot;go_graphql_db&quot;&lt;/span&gt;),&lt;br/&gt; )&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  log.Fatal(err)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Create our root query for graphql&lt;/span&gt;&lt;br/&gt; rootQuery := gql.NewRoot(db)&lt;br/&gt; &lt;span&gt;// Create a new graphql schema, passing in the the root query&lt;/span&gt;&lt;br/&gt; sc, err := graphql.NewSchema(&lt;br/&gt;  graphql.SchemaConfig{Query: rootQuery.Query},&lt;br/&gt; )&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;Error creating schema: &quot;&lt;/span&gt;, err)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Create a server struct that holds a pointer to our database as well&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// as the address of our graphql schema&lt;/span&gt;&lt;br/&gt; s := server.Server{&lt;br/&gt;  GqlSchema: &amp;amp;sc,&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Add some middleware to our router&lt;/span&gt;&lt;br/&gt; router.Use(&lt;br/&gt;  render.SetContentType(render.ContentTypeJSON), &lt;span&gt;// set content-type headers as application/json&lt;/span&gt;&lt;br/&gt;  middleware.Logger,          &lt;span&gt;// log API request calls&lt;/span&gt;&lt;br/&gt;  middleware.DefaultCompress, &lt;span&gt;// compress results, mostly gzipping assets and json&lt;/span&gt;&lt;br/&gt;  middleware.StripSlashes,    &lt;span&gt;// match paths with a trailing slash, strip it, and continue routing through the mux&lt;/span&gt;&lt;br/&gt;  middleware.Recoverer,       &lt;span&gt;// recover from panics without crashing server&lt;/span&gt;&lt;br/&gt; )&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Create the graphql route with a Server method to handle it&lt;/span&gt;&lt;br/&gt; router.Post(&lt;span&gt;&quot;/graphql&quot;&lt;/span&gt;, s.GraphQL())&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; router, db&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面导入的 &lt;strong&gt;gql&lt;/strong&gt;、&lt;strong&gt;postgres&lt;/strong&gt; 和 &lt;strong&gt;server&lt;/strong&gt; 的路径应该是你本地的路径，以及 &lt;strong&gt;postgres.ConnString()&lt;/strong&gt; 中连接 PostgreSQL 的用户名也应该是你自己的，和我的不一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;initializeAPI()&lt;/strong&gt; 分为几大块主要的部分，接下来我们逐步构建每一块。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;strong&gt;chi.NewRouter()&lt;/strong&gt; 创建 router 并返回一个 mux，接下来是创建一个 PostgreSQL 数据库连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;strong&gt;postgres.ConnString()&lt;/strong&gt; 创建一个 &lt;strong&gt;string&lt;/strong&gt; 类型的连接配置，并封装到 &lt;strong&gt;postgres.New()&lt;/strong&gt; 函数中。这些逻辑在我们自己包中的 &lt;strong&gt;postgres.go&lt;/strong&gt; 文件中构建：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; postgres&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;database/sql&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// postgres driver&lt;/span&gt;&lt;br/&gt; _ &lt;span&gt;&quot;github.com/lib/pq&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Db is our database struct used for interacting with the database&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Db &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; *sql.DB&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// New makes a new database using the connection string and&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// returns it, otherwise returns the error&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;New&lt;/span&gt;&lt;span&gt;(connString &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(*Db, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; db, err := sql.Open(&lt;span&gt;&quot;postgres&quot;&lt;/span&gt;, connString)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Check that our connection is good&lt;/span&gt;&lt;br/&gt; err = db.Ping()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &amp;amp;Db{db}, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ConnString returns a connection string based on the parameters it&#x27;s given&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// This would normally also contain the password, however we&#x27;re not using one&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ConnString&lt;/span&gt;&lt;span&gt;(host &lt;span&gt;string&lt;/span&gt;, port &lt;span&gt;int&lt;/span&gt;, user &lt;span&gt;string&lt;/span&gt;, dbName &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; fmt.Sprintf(&lt;br/&gt;  &lt;span&gt;&quot;host=%s port=%d user=%s dbname=%s sslmode=disable&quot;&lt;/span&gt;,&lt;br/&gt;  host, port, user, dbName,&lt;br/&gt; )&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// User shape&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; User &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; ID         &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; Name       &lt;span&gt;string&lt;/span&gt;&lt;br/&gt; Age        &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; Profession &lt;span&gt;string&lt;/span&gt;&lt;br/&gt; Friendly   &lt;span&gt;bool&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// GetUsersByName is called within our user query for graphql&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(d *Db)&lt;/span&gt; &lt;span&gt;GetUsersByName&lt;/span&gt;&lt;span&gt;(name &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; []&lt;span&gt;User&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// Prepare query, takes a name argument, protects from sql injection&lt;/span&gt;&lt;br/&gt; stmt, err := d.Prepare(&lt;span&gt;&quot;SELECT * FROM users WHERE name=$1&quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;GetUserByName Preperation Err: &quot;&lt;/span&gt;, err)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Make query with our stmt, passing in name argument&lt;/span&gt;&lt;br/&gt; rows, err := stmt.Query(name)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;GetUserByName Query Err: &quot;&lt;/span&gt;, err)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Create User struct for holding each row&#x27;s data&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; r User&lt;br/&gt; &lt;span&gt;// Create slice of Users for our response&lt;/span&gt;&lt;br/&gt; users := []User{}&lt;br/&gt; &lt;span&gt;// Copy the columns from row into the values pointed at by r (User)&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; rows.Next() {&lt;br/&gt;  err = rows.Scan(&lt;br/&gt;   &amp;amp;r.ID,&lt;br/&gt;   &amp;amp;r.Name,&lt;br/&gt;   &amp;amp;r.Age,&lt;br/&gt;   &amp;amp;r.Profession,&lt;br/&gt;   &amp;amp;r.Friendly,&lt;br/&gt;  )&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   fmt.Println(&lt;span&gt;&quot;Error scanning rows: &quot;&lt;/span&gt;, err)&lt;br/&gt;  }&lt;br/&gt;  users = &lt;span&gt;append&lt;/span&gt;(users, r)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; users&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的思想是：创建数据库的连接并返回持有该连接的&lt;strong&gt;Db&lt;/strong&gt;对象。然后创建了一个 &lt;strong&gt;db&lt;/strong&gt; 的 &lt;strong&gt;GetUserByUsername()&lt;/strong&gt; 方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将关注点重新回到 &lt;strong&gt;main.go&lt;/strong&gt; 文件，在 40 行处创建了一个 root query 用于构建 GraphQL 的 schema。我们在 &lt;strong&gt;gql&lt;/strong&gt; 包下的 &lt;strong&gt;queries.go&lt;/strong&gt; 中创建：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; gql&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;github.com/bradford-hamilton/go-graphql-api/postgres&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/graphql-go/graphql&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Root holds a pointer to a graphql object&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Root &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Query *graphql.Object&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// NewRoot returns base query type. This is where we add all the base queries&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewRoot&lt;/span&gt;&lt;span&gt;(db *postgres.Db)&lt;/span&gt; *&lt;span&gt;Root&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// Create a resolver holding our databse. Resolver can be found in resolvers.go&lt;/span&gt;&lt;br/&gt; resolver := Resolver{db: db}&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Create a new Root that describes our base query set up. In this&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// example we have a user query that takes one argument called name&lt;/span&gt;&lt;br/&gt; root := Root{&lt;br/&gt;  Query: graphql.NewObject(&lt;br/&gt;   graphql.ObjectConfig{&lt;br/&gt;    Name: &lt;span&gt;&quot;Query&quot;&lt;/span&gt;,&lt;br/&gt;    Fields: graphql.Fields{&lt;br/&gt;     &lt;span&gt;&quot;users&quot;&lt;/span&gt;: &amp;amp;graphql.Field{&lt;br/&gt;      &lt;span&gt;// Slice of User type which can be found in types.go&lt;/span&gt;&lt;br/&gt;      Type: graphql.NewList(User),&lt;br/&gt;      Args: graphql.FieldConfigArgument{&lt;br/&gt;       &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &amp;amp;graphql.ArgumentConfig{&lt;br/&gt;        Type: graphql.String,&lt;br/&gt;       },&lt;br/&gt;      },&lt;br/&gt;      Resolve: resolver.UserResolver,&lt;br/&gt;     },&lt;br/&gt;    },&lt;br/&gt;   },&lt;br/&gt;  ),&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &amp;amp;root&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;strong&gt;NewRoot()&lt;/strong&gt; 方法中传入 &lt;strong&gt;db&lt;/strong&gt;，并使用该 db 创建一个 &lt;strong&gt;Resolver&lt;/strong&gt;。在&lt;strong&gt;Resolver&lt;/strong&gt;方法中对数据库进行操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后创建了一个 new root 用于用户的查询，需要&lt;strong&gt;name&lt;/strong&gt;作为查询参数。类型是 &lt;strong&gt;graphql.NewList&lt;/strong&gt; 的 &lt;strong&gt;User&lt;/strong&gt;（切片或者数组类型），在 &lt;strong&gt;gql&lt;/strong&gt; 包下的 &lt;strong&gt;type.go&lt;/strong&gt; 文件中定义。如果有其他类型的查询，就在这个 root 中增加。要把引入的 &lt;strong&gt;postgres&lt;/strong&gt; 包改成自己本地的包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来看一下 &lt;strong&gt;resolvers.go&lt;/strong&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; gql&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;github.com/bradford-hamilton/go-graphql-api/postgres&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/graphql-go/graphql&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Resolver struct holds a connection to our database&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Resolver &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; db *postgres.Db&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// UserResolver resolves our user query through a db call to GetUserByName&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(r *Resolver)&lt;/span&gt; &lt;span&gt;UserResolver&lt;/span&gt;&lt;span&gt;(p graphql.ResolveParams)&lt;/span&gt; &lt;span&gt;(&lt;span&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// Strip the name from arguments and assert that it&#x27;s a string&lt;/span&gt;&lt;br/&gt; name, ok := p.Args[&lt;span&gt;&quot;name&quot;&lt;/span&gt;].(&lt;span&gt;string&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; ok {&lt;br/&gt;  users := r.db.GetUsersByName(name)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; users, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里导入的 &lt;strong&gt;postgres&lt;/strong&gt; 包同样是你本地的。在这个地方还可以增加其他需要的解析器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来看 &lt;strong&gt;types.go&lt;/strong&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; gql&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;github.com/graphql-go/graphql&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// User describes a graphql object containing a User&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; User = graphql.NewObject(&lt;br/&gt; graphql.ObjectConfig{&lt;br/&gt;  Name: &lt;span&gt;&quot;User&quot;&lt;/span&gt;,&lt;br/&gt;  Fields: graphql.Fields{&lt;br/&gt;   &lt;span&gt;&quot;id&quot;&lt;/span&gt;: &amp;amp;graphql.Field{&lt;br/&gt;    Type: graphql.Int,&lt;br/&gt;   },&lt;br/&gt;   &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &amp;amp;graphql.Field{&lt;br/&gt;    Type: graphql.String,&lt;br/&gt;   },&lt;br/&gt;   &lt;span&gt;&quot;age&quot;&lt;/span&gt;: &amp;amp;graphql.Field{&lt;br/&gt;    Type: graphql.Int,&lt;br/&gt;   },&lt;br/&gt;   &lt;span&gt;&quot;profession&quot;&lt;/span&gt;: &amp;amp;graphql.Field{&lt;br/&gt;    Type: graphql.String,&lt;br/&gt;   },&lt;br/&gt;   &lt;span&gt;&quot;friendly&quot;&lt;/span&gt;: &amp;amp;graphql.Field{&lt;br/&gt;    Type: graphql.Boolean,&lt;br/&gt;   },&lt;br/&gt;  },&lt;br/&gt; },&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类似的，在这里添加我们不同的类型，每一个字段都指定了类型。在 &lt;strong&gt;main.go&lt;/strong&gt; 文件的 42 行使用 root query 创建了一个新的查询。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;差不多好了&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;strong&gt;main.go&lt;/strong&gt; 往下的 51 行处，创建一个新的 server，server 持有 GraphQL schema 的指针。下面是 &lt;strong&gt;server.go&lt;/strong&gt; 的内容：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; server&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;encoding/json&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;net/http&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/bradford-hamilton/go-graphql-api/gql&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/go-chi/render&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/graphql-go/graphql&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Server will hold connection to the db as well as handlers&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Server &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; GqlSchema *graphql.Schema&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; reqBody &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Query &lt;span&gt;string&lt;/span&gt; &lt;span&gt;`json:&quot;query&quot;`&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// GraphQL returns an http.HandlerFunc for our /graphql endpoint&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(s *Server)&lt;/span&gt; &lt;span&gt;GraphQL&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;http&lt;/span&gt;.&lt;span&gt;HandlerFunc&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(w http.ResponseWriter, r *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// Check to ensure query was provided in the request body&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; r.Body == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   http.Error(w, &lt;span&gt;&quot;Must provide graphql query in request body&quot;&lt;/span&gt;, &lt;span&gt;400&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; rBody reqBody&lt;br/&gt;  &lt;span&gt;// Decode the request body into rBody&lt;/span&gt;&lt;br/&gt;  err := json.NewDecoder(r.Body).Decode(&amp;amp;rBody)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   http.Error(w, &lt;span&gt;&quot;Error parsing JSON request body&quot;&lt;/span&gt;, &lt;span&gt;400&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Execute graphql query&lt;/span&gt;&lt;br/&gt;  result := gql.ExecuteQuery(rBody.Query, *s.GqlSchema)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// render.JSON comes from the chi/render package and handles&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// marshalling to json, automatically escaping HTML and setting&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// the Content-Type as application/json.&lt;/span&gt;&lt;br/&gt;  render.JSON(w, r, result)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 server 中有一个 &lt;strong&gt;GraphQL&lt;/strong&gt; 的方法，这个方法的主要作用就是处理 &lt;strong&gt;GraphQL&lt;/strong&gt; 的查询。记得将 &lt;strong&gt;gql&lt;/strong&gt; 的路径更新为你本地的路径。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来看最后一个文件 &lt;strong&gt;gql.go&lt;/strong&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; gql&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/graphql-go/graphql&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ExecuteQuery runs our graphql queries&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ExecuteQuery&lt;/span&gt;&lt;span&gt;(query &lt;span&gt;string&lt;/span&gt;, schema graphql.Schema)&lt;/span&gt; *&lt;span&gt;graphql&lt;/span&gt;.&lt;span&gt;Result&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; result := graphql.Do(graphql.Params{&lt;br/&gt;  Schema:        schema,&lt;br/&gt;  RequestString: query,&lt;br/&gt; })&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Error check&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(result.Errors) &amp;gt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  fmt.Printf(&lt;span&gt;&quot;Unexpected errors inside ExecuteQuery: %v&quot;&lt;/span&gt;, result.Errors)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里只有一个简单的 &lt;strong&gt;ExecuteQuery()&lt;/strong&gt; 函数用来执行 GraphQL 查询。在这里可能会有一个类似于 &lt;strong&gt;ExecuteMutation()&lt;/strong&gt; 函数用来处理 GraphQL 的 mutations。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;strong&gt;initializeAPI()&lt;/strong&gt; 的最后，在 router 中增加一些中间工具，以及增加处理 &lt;strong&gt;/graphql&lt;/strong&gt; POSTs 请求的 &lt;strong&gt;GraphQL&lt;/strong&gt; server 方法。并且在这个地方增加其他 RESTful 请求的路由，并在 server 中增加处理路由的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在项目的根目录运行 &lt;strong&gt;realize init&lt;/strong&gt;，会有两次提示信息并且两次都输入 &lt;strong&gt;n&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.1109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UWba2ryLMql57M9Mgzo2dPJhrLdP13LYcOsvpt7YxJWTpxxzoDzqVqOt98Eq29Zeibhia7fZr9MPSHvAc3PfPQdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是在你项目的根目录下创建的 &lt;strong&gt;.realize.yaml&lt;/strong&gt; 文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;settings:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;legacy:&lt;/span&gt;&lt;br/&gt; &lt;span&gt;force:&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; &lt;span&gt;interval:&lt;/span&gt; &lt;span&gt;0s&lt;/span&gt;&lt;br/&gt;&lt;span&gt;schema:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;go-graphql-api&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;path:&lt;/span&gt; &lt;span&gt;.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;commands:&lt;/span&gt;&lt;br/&gt; &lt;span&gt;run:&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;status:&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;watcher:&lt;/span&gt;&lt;br/&gt; &lt;span&gt;extensions:&lt;/span&gt;&lt;br/&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;go&lt;/span&gt;&lt;br/&gt; &lt;span&gt;paths:&lt;/span&gt;&lt;br/&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;/&lt;/span&gt;&lt;br/&gt; &lt;span&gt;ignored_paths:&lt;/span&gt;&lt;br/&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;.git&lt;/span&gt;&lt;br/&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;.realize&lt;/span&gt;&lt;br/&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;vendor&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段配置对于监控你项目里面的改变非常重要，如果检测到有改变，将自动重启 server 并重新运行 &lt;strong&gt;main.go&lt;/strong&gt; 文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一些开发 GraphQL API 非常好的工具，比如：&lt;strong&gt;&lt;span&gt;graphiql&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;span&gt;insomnia&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;span&gt;graphql-playground&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt;&lt;/strong&gt;，还可以发送一个 application/json 请求体的 POST 请求，比如:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;{&lt;br/&gt; &lt;span&gt;&quot;query&quot;&lt;/span&gt;: &lt;span&gt;&quot;{users(name:\&quot;kevin\&quot;){id, name, age}}&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;span&gt;Postman&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt; 里像下面这样：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.2548387096774194&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UWba2ryLMql57M9Mgzo2dPJhrLdP13LYicRD95c5AKJGgXDKcZcS3yPx3Qma0RGQYJ4Djr2BDdKpVMjguZDzBpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在查询中可以只请求一个属性或者多个属性的组合。在 GraphQL 的正式版中，可以只请求我们希望通过网络发送的信息。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;很成功&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大功告成！希望这篇博文对你在 Go 中编写 GraphQL API 有帮助。我尝试将功能分解到不同的包或文件中，使其更容易扩展，而且每一块也很容易测试。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;via: https://medium.com/@bradford_hamilton/building-an-api-with-graphql-and-go-9350df5c9356&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：&lt;span&gt;Bradford Lamson-Scribner&lt;/span&gt;&lt;sup&gt;[13]&lt;/sup&gt;译者：&lt;span&gt;HelloJavaWorld123&lt;/span&gt;&lt;sup&gt;[14]&lt;/sup&gt;校对：&lt;span&gt;polaris1119&lt;/span&gt;&lt;sup&gt;[15]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文由 &lt;span&gt;GCTT&lt;/span&gt;&lt;sup&gt;[16]&lt;/sup&gt; 原创编译，&lt;span&gt;Go 中文网&lt;/span&gt;&lt;sup&gt;[17]&lt;/sup&gt; 荣誉推出&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;realize: &lt;em&gt;https://github.com/oxequa/realize&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;air: &lt;em&gt;https://github.com/cosmtrek/air&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;Structuring Applications in Go: &lt;em&gt;https://medium.com/@benbjohnson/structuring-applications-in-go-3b04be4ff091&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;bradford-hamilton/go-graphql-api: &lt;em&gt;https://github.com/github.com/bradford-hamilton/go-graphql-api&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;realize: &lt;em&gt;https://github.com/oxequa/realize&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;chi: &lt;em&gt;https://github.com/go-chi/chi&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;render: &lt;em&gt;https://github.com/go-chi/render&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;graphql-go/graphql: &lt;em&gt;https://github.com/graphql-go/graphql&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;graphiql: &lt;em&gt;https://github.com/graphql/graphiql&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10]&lt;/span&gt;&lt;p&gt;insomnia: &lt;em&gt;https://insomnia.rest/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11]&lt;/span&gt;&lt;p&gt;graphql-playground: &lt;em&gt;https://github.com/prisma/graphql-playground&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12]&lt;/span&gt;&lt;p&gt;Postman: &lt;em&gt;https://www.getpostman.com/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[13]&lt;/span&gt;&lt;p&gt;Bradford Lamson-Scribner: &lt;em&gt;https://medium.com/@bradford_hamilton&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[14]&lt;/span&gt;&lt;p&gt;HelloJavaWorld123: &lt;em&gt;https://github.com/HelloJavaWorld123&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[15]&lt;/span&gt;&lt;p&gt;polaris1119: &lt;em&gt;https://github.com/polaris1119&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[16]&lt;/span&gt;&lt;p&gt;GCTT: &lt;em&gt;https://github.com/studygolang/GCTT&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[17]&lt;/span&gt;&lt;p&gt;Go 中文网: &lt;em&gt;https://studygolang.com/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>024ad25b0fa17f3f437f065f65d09f0c</guid>
<title>大白话彻底搞懂 HBase Rowkey 设计和实现</title>
<link>https://toutiao.io/k/87duh73</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这是云祁的第 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;55&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;篇文章&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;19&quot; data-cropselx2=&quot;331&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;234&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zWSuIP8rdu3kUk3Ng8l8W8tugDvnS68WrXyflgRaW5ntRaCDAT0d7icWI4Ko0aI6qFeibAib2E1oLZMZzzwIJkOzA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一、前言&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是云祁！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;周末面试了一位小伙伴，看他简历上写着&lt;span&gt;掌握HBase存储原理以及&lt;span&gt;RowKey&lt;/span&gt;设计&lt;/span&gt;，于是忍不住多问了几句 😂 谁让我最近在肝HBase......&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家都知道HBase由于它存储和读写的高性能，在OLAP即时分析中发挥着非常重要的作用，&lt;/span&gt;&lt;span&gt;而RowKey作为HBase的核心知识点，其设计势必会影响到数据在HBase中的分布，甚至会影响我们查询的效率，可以说&lt;/span&gt;&lt;span&gt;RowKey的设计质量关乎了HBase的质量。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;言归正传，对于关系型数据库，数据定位可以理解为“二维坐标”；但在HBase中，定位一条数据（即一个Cell）我们需要4个维度的限定：行键（RowKey）、列族（Column Family）、列限定符（Column Qualifier）、时间戳（Timestamp）。其中，RowKey是最容易出现问题的，所以除了根据业务和查询需求来设计之外，还有很多地方需要我们注意。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、RowKey概念&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HBase中RowKey可以唯一标识一行记录，在HBase查询的时候有以下几种方式：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过get方式，指定RowKey获取唯一一条记录&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过scan方式，设置startRow和stopRow参数进行范围匹配&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;全表扫描，即直接扫描整张表中所有行记录&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从字面意思来看，RowKey就是行键的意思，在曾删改查的过程中充当了主键的作用。它可以是 &lt;span&gt;任意字符串&lt;/span&gt;，在HBase内部RowKey保存为字节数组。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HBase中的数据是按照Rowkey的ASCII字典顺序进行全局排序的，有伙伴可能对ASCII字典序印象不够深刻，下面举例说明：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;假如有5个Rowkey：&quot;012&quot;, &quot;0&quot;, &quot;123&quot;, &quot;234&quot;, &quot;3&quot;，按ASCII字典排序后的结果为：&quot;0&quot;, &quot;012&quot;,
&quot;123&quot;, &quot;234&quot;, &quot;3&quot;。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此我们设计RowKey时，需要充分利用排序存储这个特性，将经常一起读取的行存储放到一起，要避免做全表扫描，因为效率特别低。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、什么是数据热点？&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 热点现象产生&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HBase中的行是按照Rowkey的字典顺序排序的，这种设计优化了scan操作，可以将相关的行以及会被一起读取的行存取在临近位置，便于scan。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而糟糕的Rowkey设计是热点的源头。热点发生在大量的client直接访问集群的一个或极少数个节点（访问可能是读，写或者其他操作）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大量访问会使热点region所在的单个机器超出自身承受能力，引起性能下降甚至region不可用，这也会影响同一个RegionServer上的其他region，由于主机无法服务其他region的请求，这样就造成 &lt;span&gt;数据热点现象&lt;/span&gt;（这一点其实和数据倾斜类似）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们在向HBase中插入数据的时候，应优化RowKey的设计，使数据被写入集群的多个&lt;span&gt;Region&lt;/span&gt;，而不是一个。尽量均衡地把记录分散到不同的Region中去，平衡每个Region的压力。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 避免数据热点的方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在日常使用中，主要有3个方法来避免热点现象，分别是反转，加盐和哈希，下面咱们逐个举例分析：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2.1 反转（Reversing）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一种咱们要分析的方法是反转，顾名思义它就是把固定长度或者数字格式的RowKey进行反转，反转分为一般数据反转和时间戳反转，其中以时间戳反转较常见。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;反转固定格式的数值&lt;/span&gt;以手机号为例，手机号的前缀变化比较少（如&lt;code&gt;152、185&lt;/code&gt;等），但后半部分变化很多。如果将它反转过来，可以有效地避免热点。不过其缺点就是失去了有序性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;反转时间&lt;/span&gt;这个操作严格来讲不算“打散”，但可以调整数据的时间排序。如果将时间按照字典序排列，最近产生的数据会排在旧数据后面。如果用一个大值减去时间（比如用&lt;code&gt;99999999&lt;/code&gt;减去&lt;code&gt;yyyyMMdd&lt;/code&gt;，或者&lt;code&gt;Long.MAX_VALUE&lt;/code&gt;减去时间戳），最新的数据就可以排在前面了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2.2 加盐（Salting）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的“加盐”与密码学中的“加盐”不是一回事。它是指在RowKey的前面增加一些前缀，加盐的前缀种类越多，RowKey就被打得越散。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是分配的随机前缀的种类数量应该和我们想把数据分散到的那些region的数量一致。只有这样，加盐之后的rowkey才会根据随机生成的前缀分散到各个region中，避免了热点现象。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2.3 哈希（Hashing）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实哈希和加盐的适用场景类似，但我们前缀不可以是随机的，因为必须要让客户端能够完整地重构RowKey。所以一般会拿原RowKey或其一部分计算Hash值，然后再对Hash值做运算作为前缀。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、RowKey的设计原则&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过前面的分析我们应该知道了HBase中RowKey设计的重要性了，为了帮助我们设计出完美的RowKey，HBase提出了RowKey的设计原则主要有以下四点：长度原则、唯一原则、排序原则、散列原则。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1 RowKey长度原则&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RowKey是一个二进制码流，可以是任意字符串，最大长度 64kb ，实际应用中一般为10-100bytes，以 byte[] 形式保存，一般设计成定长。建议越短越好，不要超过16个字节，原因如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在HBase的底层存储HFile中，RowKey是KeyValue结构中的一个域。假设RowKey长度100B，那么1000万条数据中，光RowKey就占用掉 &lt;code&gt;100*1000w=10亿个字节&lt;/code&gt; 将近1G空间，这样会极大影响HFile的存储效率。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.502865329512894&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zWSuIP8rdu29XHtb7nD1icr249698QyYoQHiclbzQEicASPB33okTWOJRDBVa1rjvSUKkNl0fBdpToL0aNzzPXMwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;698&quot;/&gt;&lt;figcaption&gt;HFile简单结构示意&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;HBase中设计有MemStore和BlockCache，分别对应列族/Store级别的写入缓存，和RegionServer级别的读取缓存。如果RowKey字段过长，内存的有效利用率就会降低，系统不能缓存更多的数据，这样会降低检索效率。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5422222222222223&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zWSuIP8rdu29XHtb7nD1icr249698QyYoa8ZxaOgib2t9oL8RuDV0orGicXDkKLZ72dKzKBgtPm2p5teseAbVJnow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;675&quot;/&gt;&lt;span&gt;另外，我们目前使用的服务器操作系统都是64位系统，内存是按照8B对齐的，因此设计RowKey时一般做成8B的整数倍，如16B或者24B，可以提高寻址效率。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样地，列族、列名的命名在保证可读的情况下也应尽量短。value永远和它的key一起传输的。当具体的值在系统间传输时，它的RowKey，列名，时间戳也会一起传输&lt;code&gt;（因此实际上列族命名几乎都用一个字母，比如‘c’或‘f’）&lt;/code&gt;。如果你的RowKey和列名和值相比较很大，那么你将会遇到一些有趣的问题。Hfile中的索引最终占据了HBase分配的大量内存。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2 唯一原则&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实唯一原则咱们可以结合HashMap的源码设计或者主键的概念来理解，由于RowKey用来唯一标识一行记录，所以必须在设计上保证RowKey的唯一性。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;&lt;span&gt;需要注意&lt;/span&gt;：由于HBase中数据存储的格式是Key-Value对格式，所以如果向HBase中同一张表插入相同RowKey的数据，则原先存在的数据会被新的数据给覆盖掉（和HashMap效果相同）。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.3 排序原则&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RowKey是按照字典顺序排序存储的，因此，设计RowKey的时候，要充分利用这个排序的特点，将经常读取的数据存储到一块，将最近可能会被访问的数据放到一块。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个常见的数据处理问题是快速获取数据的最近版本，使用反转的时间戳作为RowKey的一部分对这个问题十分有用，可以用 &lt;code&gt;Long.Max_Value-timestamp&lt;/code&gt;追加到&lt;code&gt;key&lt;/code&gt;的末尾。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如 &lt;code&gt;[key][reverse_timestamp],[key]&lt;/code&gt;的最新值可以通过&lt;code&gt;scan [key]&lt;/code&gt;获得[&lt;code&gt;key]&lt;/code&gt;的第一条记录，因为HBase中RowKey是有序的，第一条记录是最后录入的数据。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4 散列原则&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;散列原则用大白话来讲就是咱们设计出的RowKey需要能够均匀的分布到各个RegionServer上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如设计RowKey的时候，当Rowkey 是按时间戳的方式递增，就不要将时间放在二进制码的前面，可以将 Rowkey 的高位作为散列字段，由程序循环生成，可以在低位放时间字段，这样就可以提高数据均衡分布在每个Regionserver实现负载均衡的几率。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;&lt;span&gt;结合前面分析的热点现象的起因思考&lt;/span&gt;：如果没有散列字段，首字段只有时间信息，那就会出现所有新数据都在一个RegionServer上堆积的热点现象，这样在做数据检索的时候负载将会集中在个别RegionServer上，降低查询效率。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;五、举个栗子&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际业务中，有一部分是用户在日历上记录自己的行为。需要储存在RowKey中的维度有：用户ID（uuid，不会超过十亿）、日历上的日期（date，yyyyMMdd格式）、记录行为的类型（type，0~99之间）。记录的详细数据则存储在列f:data中。根据查询逻辑，我们可以设计的RowKey格式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;9&lt;/span&gt;~&lt;span&gt;79809782&lt;/span&gt;~&lt;span&gt;05&lt;/span&gt;~&lt;span&gt;0008839540&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;长度正好是24B。以字符&lt;code&gt;‘~’&lt;/code&gt;为分界（&lt;code&gt;‘~’&lt;/code&gt;的ASCII码是最大的，方便），各个部分的含义如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;uuid.toString().hashCode() % 10&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;99999999 - date&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;StringUtils.leftPad(type, 2, &quot;0&quot;)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;StringUtils.leftPad(uuid, 10, &quot;0&quot;)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;https://lidong.blog.csdn.net/article/details/80551851&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://blog.csdn.net/qq_35488412/article/details/78708493&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://www.jianshu.com/p/fefcad20feb7&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>72d921c03b236b3e3975aada0c6d8f6c</guid>
<title>金字塔思维，所有厉害的人都在用</title>
<link>https://toutiao.io/k/j22t4lx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;span&gt;成长&amp;amp;认知 &lt;/span&gt;丨 作者&lt;/span&gt;&lt;span&gt; / &lt;/span&gt;&lt;span&gt;袁吴范&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是&lt;/span&gt;&lt;span&gt;pointers公众号&lt;/span&gt;&lt;span&gt;的第43篇原创文章&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不知道大家有没有遇到过这样让人头疼的情况：&lt;/span&gt;&lt;span&gt;公司几个部门的人围在一起开会，各自从自己的角度出发，想要说服彼此，然而，两个小时过去了，问题的解决方案却没有任何进展，信息量很大，但是没法判断谁对谁错，同一个问题，似乎是“公说公有理，婆说婆有理”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实这种情况就是因为&lt;strong&gt;缺乏结构化思维&lt;/strong&gt;。&lt;/span&gt;&lt;span&gt;一般来说，解决问题的思维方式可以分为三种：&lt;/span&gt;&lt;span&gt;平面思维、单线思维和结构化思维。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用平面思维去解决问题，也可以称之为就事论事。&lt;/span&gt;&lt;span&gt;比如说“程序bug
多”的问题，为了解决这个问题，平面思维的解决方式一般都是“加强测试”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而单线思维则会从某个特定方向去思考问题，进一步寻找解决问题的方案。&lt;/span&gt;&lt;span&gt;比如单线思维者可能会觉得是代码设计和编码能力，然后去想法设法提升这方面能力。&lt;/span&gt;&lt;span&gt;提升编码质量，如果继续向上寻找原因，可能是需要“提升代码设计能力”，继续向上寻找，可能是“提升需求设计”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4XQ0RVoHjpyZKtGk4icAPtoTfC2KRSLcGrSRd2Vic28f0cth8h2x6IjfMnkRxHcwamImRicxNiamD49C2EjibYJwfCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;2.117505995203837&quot; data-w=&quot;417&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但在实际运用中我们会发现，平面思维和单线思维都有其片面性，都无法挖掘出事物的全貌，进而给出一个完善的解决方案。这两种思维方式多少都影响了我们对于问题的认知，并且可能会诱导我们提出一些错误的解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而当我们采用结构化的思考方式进行分析的时候，就可以把问题从内因、外因两方面来进行归类，层层剥茧，逐项分析，找出问题的原因，从而帮助我们更高效地解决问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而这种结构化的思维方式，被全球知名的咨询企业麦肯锡公司称为“金字塔原理”。我们日常用到的项目管理方法、问题分析方法、高效表达和沟通的方法，其实很多都脱胎于金字塔原理。有一本书推荐给大家，书名就叫《金字塔原理》。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个方法可以帮助我们更高效地建立问题和原因之间的逻辑联系，从而更有效地分析问题、解决问题。&lt;/span&gt;&lt;span&gt;那么，为什么金字塔思维更高效，我们又该如何运用好金字塔思维呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以一起看看2个例子吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大家追过女朋友吧，其实这也是有套路的。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4XQ0RVoHjpyZKtGk4icAPtoTfC2KRSLcG199LBPictbwZkLL3aTqUAb9cE88FvYbXpHJSlia9bzO4wTMQQibqQib8rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.0194444444444444&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再看一个我自己的例子。&lt;/span&gt;&lt;span&gt;由于本人已经带了一个团队，人数在30人+，&lt;span&gt;我们就能用上金字塔思维来帮我们理清思路，从而有条不紊的开展工作了。&lt;/span&gt;&lt;span&gt;带团队，对于技术人来说，主要做好三件中心事：&lt;/span&gt;&lt;strong&gt;业务，技术和管理。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4XQ0RVoHjpyZKtGk4icAPtoTfC2KRSLcG9JDVLLwyhqYxPcobcUx1mEWib1TSwfyAIXVcnRpGxWhql7gn8M4HoUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.25&quot; data-w=&quot;1080&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样，我们就可以初步构建出一个思维框架，用于指导实际的工作：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种思考方式是从目标出发进行倒推，《金字塔思维》中称之为自上而下的思考方式。&lt;/span&gt;&lt;span&gt;能帮我们快速有效地&lt;strong&gt;针对总体目标，制订方案，解决问题&lt;/strong&gt;。&lt;/span&gt;&lt;span&gt;能让我们在纷繁复杂的工作中迅速抓住重点，理清头绪。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从本质上讲，金字塔思维就是一个层层分解的结构化思考模式。这个思考模式一般是由塔尖、塔身和塔基构成。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;塔尖就是我们的中心思想或主题。&lt;/span&gt;&lt;span&gt;塔身就是构成中心思考或者主题的各个&lt;/span&gt;&lt;span&gt;分论点。&lt;/span&gt;&lt;span&gt;而塔基则是支撑各个分论点的要素或论据。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体来说，分为以下四个步骤：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、确定问题产生的背景&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如公司业务发生亏损、老板安排任务、预期目标没有实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、针对问题，提出核心目标&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如针对公司亏损这个问题，如何在三个月内实现盈利，就可以成为我们的核心目标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、将核心目标进行分解&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当我们找到合理的核心目标后，就需要对核心目标进行分解，从而寻求更具体的解决办法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、继续分解，直到能够把问题解释清楚&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;无论在职场中还是生活中，遇到难题的时候，结构化思考都能帮大家拆解问题，一步步实现自己的目标。如果你遇到了工作中或者生活中的难题，可以试试换个角度，或者把自己的思维提升到核心目标的高度去破局，说不定原先的问题就能迎刃而解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;金字塔思维之所以那么有效，是因为一个问题产生的原因往往是非常多样化的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如一家公司如何在市场竞争激烈的环境中活下去，其实受到很多因素的影响，可能跟市场环境有关，跟人们的需求变化有关，跟内部的管理有关，跟人才队伍的建设有关……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而这些原因，又可能分成更多细小的影响因素。&lt;/span&gt;&lt;span&gt;比如市场环境可以分成：&lt;/span&gt;&lt;span&gt;资本的青睐程度，市场上竞品的增加、替代产品的出现，经济大环境等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;公司的生存问题，并不像之前提到的“bug增多”的问题那样简单，因此我们很难通过简单的归因，找到问题的本质原因。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个时候，我们就可以利用神器：金字塔思维。进行理清逻辑，找到事物之间的联系，寻求一套更完善的解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;我是袁吴范，一个教你如何提升认知、快速晋升的90后技术总监&lt;span&gt;，&lt;/span&gt;公众号：”pointers“&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;你可以长按这个二维码加我微信，空位不多。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;记得备注“技术方向”，我会将你拉进一个高品质群，&lt;/span&gt;&lt;span&gt;&lt;span&gt;群里有开发、产品、技术经理、技术总监&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PVZcww4Su3icxqW28rtgt1ib4Iia7XUeWT9EdiapicwxdyHQCKDTRFDWqvErKb0FiaLWzZXQkPANFr00h9RRBC249MHQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>