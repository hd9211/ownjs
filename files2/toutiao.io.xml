<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>01adcab2dbf677f6b5b20faa75e94fb4</guid>
<title>怎么排查 CPU 飙升</title>
<link>https://toutiao.io/k/rq3wyhs</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1&gt;&lt;span&gt;怎么排查CPU飙升&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;线上有些系统，本来跑的好好的，突然有一天就会出现报警，CPU使用率飙升，然后重启之后就好了。例如，多线程操作一个线程不安全的list往往就会出现这种现象。那么怎么定位到具体的代码范围呢？今天笔者就教大家一个小技巧&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;&lt;span&gt;代码准备&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;这次，笔者准备了一个demo代码，大致线程模型是这样的:&lt;img data-ratio=&quot;0.44745222929936307&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7ICuYI5fFbIIaXAlQFQ9tVtn0k5kS3CUIY0mEMwqGaAI4CUEyl68pEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1256&quot;/&gt;&lt;/p&gt;&lt;p&gt;代码下所示:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;public class CpuHighExample {&lt;br/&gt;&lt;br/&gt;    public static void &lt;span&gt;&lt;span&gt;cpuHigh&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        final List&amp;lt;String&amp;gt; list = new LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;        Thread thread1 = new Thread(new &lt;span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;            @Override&lt;br/&gt;            public void &lt;span&gt;&lt;span&gt;run&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;                int count = 1;&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;                    // 构造thread1为消耗很高cpu的线程&lt;br/&gt;                    count = count + 1;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        thread1.setName(&lt;span&gt;&quot;thread1&quot;&lt;/span&gt;);&lt;br/&gt;        Thread thread2 = new Thread(new &lt;span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;            @Override&lt;br/&gt;            public void &lt;span&gt;&lt;span&gt;run&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;                    try {&lt;br/&gt;                        // 构造thread2为消耗很低cpu的线程&lt;br/&gt;                        Thread.sleep(1000);&lt;br/&gt;                    } catch (InterruptedException e) {&lt;br/&gt;                        e.printStackTrace();&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        thread2.setName(&lt;span&gt;&quot;thread2&quot;&lt;/span&gt;);&lt;br/&gt;        thread1.start();&lt;br/&gt;        thread2.start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span/&gt;&lt;span&gt;案例运行&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;这个案例一运行，就听见笔者的电脑风扇起飞了，呼呼作响。直接top一下&lt;img data-ratio=&quot;0.27223230490018147&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7FtpGMeoqxWeUe09Hiaupmk6AB12ux7T8RUsiclic762iaQV8zU1u3789rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1102&quot;/&gt;&lt;/p&gt;&lt;p&gt;果然是java进程，占用最高，CPU 100%了(占用了一个核),而其PID是2717，正是我们跑的例子。那么下一步，我们就需要定位到底是那一个线程在耗CPU&lt;/p&gt;&lt;pre&gt;&lt;code&gt;top -H&lt;br/&gt;Threads toggle&lt;br/&gt;            Starts top with the last remembered ’H’ state reversed.  When this&lt;br/&gt;            toggle  is  On,  all individual threads will be displayed.  Other-&lt;br/&gt;            wise, top displays a summation of all threads &lt;span&gt;in&lt;/span&gt; a process.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如man文档所描述,top -H可以打印出线程信息，我们就top -H一下。&lt;img data-ratio=&quot;0.3611111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7gVWF29FYqvsdgCp0SxRbAHsuYlcGib6Ow25t2iaqoZqSaoKFSNEuIQUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;图中可以看到，占用最高的线程PID是2727,同时线程名是thread1。&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;&lt;span&gt;继续jstack&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;我们知道jstack可以dump出jvm所有线程运行的快照，然后我们就可以通过刚才获取的PID去定位到jstack那个进程。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 注意，这边用top出来的进程号2717,而不是top -H出来的2727&lt;br/&gt;jstack 2717 &amp;gt; 1.txt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于jstack打印出的线程号是以16进制的形式表现的，所以我们对2727的线程号做一次转换,得到aa7。&lt;br/&gt;&lt;img data-ratio=&quot;0.3513203214695752&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7Z1MYNZ7AngNmNOmfdOia7SGcP0W6zPLy29iaibDJjZTX1tp2qTJRibCf1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1742&quot;/&gt;&lt;/p&gt;&lt;p&gt;然后我们在1.txt中搜索2727,这里用的是less然后进去后搜索，而不是用grep。因为这样比较直观的能看出之前和之后的信息。less下&lt;img data-ratio=&quot;0.06093189964157706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7k1icZP2z0uBTfeOhUUcV1YGL8dRA0XFNNqUaWTy4WrqN8dJJOK9Q2tg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1116&quot;/&gt;&lt;img data-ratio=&quot;0.27797202797202797&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7qGiaETjUfibeysR1DjicW6Hu1ib8Gbicy0IBD090xFA9eHoLjsd2OFM2UuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1144&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们找到aa7后，就直接能发现代码一直跑在CpuHighExample.java第19行上面。&lt;img data-ratio=&quot;0.35304990757855825&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7icibozct5NMOfl5X1b5Q9pEYfEF1VCKJfstRQLEEr3m4sum5ntxdeozg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1082&quot;/&gt;&lt;/p&gt;&lt;p&gt;当然了，我们需要多jstack几次，如果每次jstack出来都刚好在这段代码左右，那么基本可以证明，是这段代码导致CPU飙升了。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;CPU突然飙升这个问题，我们很容易通过top -H和jstack找到对应的代码范围，这无疑极大的缩小了我们的定位范围。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.359781121751026&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7x75CliawsSwbWnz6VZu2PrSTxAfA1Bl6MN5VdbWG06xzJzllCqZWPBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1462&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f79f835ec773c98b474e90f700fed766</guid>
<title>美团外卖实时数仓建设实践</title>
<link>https://toutiao.io/k/44pxclt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-bottom: 5px; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); text-align: center; box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;107&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;107&quot; data-ratio=&quot;0.18532818532818532&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgSqUNo1QscekFiaN8hrcem7WTpurZjSTib8whMJ9aeDSeOgY5jKNOLAx3ncZDibX6Iupcl9fzJeB6Zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2072&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;324&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;324&quot; data-ratio=&quot;0.5612094395280236&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY47goL4MxaoiaicUdpFy2JdcU0waQLKeuUu8QFft6Ba0UhplmfnfcTJ3ibRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1356&quot;/&gt;&lt;/p&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;font-variant-numeric: normal; font-variant-east-asian: normal; white-space: normal; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; line-height: 27.2px; widows: 1; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-bottom: -10px; margin-left: -8px; max-width: 100%; width: 18px; height: 18px; border-top: 8px solid rgb(54, 65, 173); border-left: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;br data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;/&gt;&lt;/section&gt;&lt;section data-bgopacity=&quot;50%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot; data-style=&quot;max-width: 100%; width: 543.333px; background: rgb(247, 247, 247); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot; data-darkmode-color-16008590572276=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16008590572276=&quot;rgb(0, 128, 255)&quot;&gt;文章作者：朱良 美团外卖 技术专家&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot; data-darkmode-color-16008590572276=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16008590572276=&quot;rgb(0, 128, 255)&quot;&gt;编辑整理：&lt;/span&gt;&lt;span data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot; data-darkmode-color-16008590572276=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16008590572276=&quot;rgb(0, 128, 255)&quot;&gt;Comn&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot; data-darkmode-color-16008590572276=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16008590572276=&quot;rgb(0, 128, 255)&quot;&gt;出品平台：DataFunTalk&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;max-width: 100%; width: 18px; height: 18px; border-bottom: 8px solid rgb(54, 65, 173); border-right: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;br data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-top: 25px; margin-bottom: 25px; white-space: normal; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; min-height: 1em; background-color: rgb(255, 255, 255); line-height: 2em; box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;strong data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;span data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16008590572276=&quot;rgb(136, 151, 171)&quot; data-darkmode-original-color-16008590572276=&quot;rgb(63, 74, 89)&quot; data-style=&quot;color: rgb(63, 74, 89); font-family: 微软雅黑; font-size: 11pt; letter-spacing: 0.4pt; text-align: left; text-indent: 0pt; visibility: visible;&quot;&gt;导读：&lt;/span&gt;&lt;/strong&gt;&lt;span data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16008590572276=&quot;rgb(136, 151, 171)&quot; data-darkmode-original-color-16008590572276=&quot;rgb(63, 74, 89)&quot; data-style=&quot;color: rgb(63, 74, 89); font-family: 微软雅黑; font-size: 11pt; letter-spacing: 0.4pt; text-align: left; text-indent: 0pt; visibility: visible;&quot;&gt;本文&lt;/span&gt;&lt;span&gt;主要介绍一种通用的实时数&lt;/span&gt;&lt;span&gt;仓&lt;/span&gt;&lt;span&gt;构建的方法与实践。&lt;/span&gt;&lt;span&gt;实时数仓以端&lt;/span&gt;&lt;span&gt;到端低延迟、&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;标准化、快速响应变化、数据统一&lt;/span&gt;&lt;span&gt;为目标&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;在实践中，我们总结的最佳实践是&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;一个通用&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;实时&lt;/span&gt;&lt;span&gt;生产平台&lt;/span&gt;&lt;span&gt; + 一个通用交互式&lt;/span&gt;&lt;span&gt;实时&lt;/span&gt;&lt;span&gt;分析引擎&lt;/span&gt;&lt;span&gt;相互配合同时满足实时和准实时业务场景&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;两者合理分工，互相补充，形成易于开发、易于维护、效率最高的流水线&lt;/span&gt;&lt;span&gt;，兼顾开发效率与生产成本，以较好的投入产出比满足业务多样需求。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;实时场景&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;shape type=&quot;#_x0000_t75&quot; filled=&quot;f&quot;&gt;&lt;imagedata title=&quot;image1&quot;/&gt;&lt;/shape&gt;&lt;img data-backh=&quot;311&quot; data-backw=&quot;553&quot; data-ratio=&quot;0.5615819209039548&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY47LdsFD9fB1A4ZicE6r6zib22VSkFN5jycEiaRiauCwyiaDzS1Rmxra9MokGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;885&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实时数据在美团外卖的场景是非常多的，主要有以下几点：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;运营层面：比如实时业务变化，实时营销效果，当日营业情况以及当日实时业务趋势分析等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;生产层面：比如实时系统是否可靠，系统是否稳定，实时监控系统的健康状况等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;C端用户：比如搜索推荐排序，需要实时了解用户的想法，行为、特点，给用户推荐更加关注的内容。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;风控侧：在外卖以及金融科技用的是非常多的，实时风险识别，反欺诈，异常交易等，都是大量应用实时数据的场景&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;实时技术及架构&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 实时计算技术选型&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;238&quot; data-backw=&quot;553&quot; data-ratio=&quot;0.43099273607748184&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY47wfso10tclGUNGS4vvbZH5shPEzCWXPHfJpjyHr7ibQoTeu8FBeiayyog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1239&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前开源的实时技术比较多，比较通用的是Storm、Spark Streaming以及Flink，具体要根据不同公司的业务情况进行选型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;美团外卖是依托美团整体的基础数据体系建设，从技术成熟度来讲，前几年用的是Storm，Storm当时在性能稳定性、可靠性以及扩展性上是无可替代的，随着Flink越来越成熟，从技术性能上以及框架设计优势上已经超越Storm，从趋势来讲就像Spark替代MR一样，Storm也会慢慢被Flink替代，当然从Storm迁移到Flink会有一个过程，我们目前有一些老的任务仍然在Storm上，也在不断推进任务迁移。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体Storm和Flink的对比可以参考上图表格。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 实时架构&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;① Lambda架构&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;286&quot; data-backw=&quot;553&quot; data-ratio=&quot;0.5167620605069502&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY47lyibAfzSI31vGZcrf1xyyruL5nVeXDkkS2pH3uSeN7d20aCQ7ZFkbtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1223&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Lambda架构是比较经典的架构，以前实时的场景不是很多，以离线为主，当附加了实时场景后，由于离线和实时的时效性不同，导致技术生态是不一样的。Lambda架构相当于附加了一条实时生产链路，在应用层面进行一个整合，双路生产，各自独立。这在业务应用中也是顺理成章采用的一种方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;双路生产会存在一些问题，比如加工逻辑double，开发运维也会double，资源同样会变成两个资源链路。因为存在以上问题，所以又演进了一个Kappa架构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;② Kappa架构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;276&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;280&quot; data-ratio=&quot;0.47641886490807356&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY47iae7rSgYhlME0XjZK1lTc285EMJZ1TibBiahjFzJTyiajk1tkfATnOb16w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1251&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kappa架构从架构设计来讲比较简单，生产统一，一套逻辑同时生产离线和实时。但是在实际应用场景有比较大的局限性，在业内直接用Kappa架构生产落地的案例不多见，且场景比较单一。这些问题在我们这边同样会遇到，我们也会有自己的一些思考，在后面会讲到。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;业务痛点&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-backh=&quot;215&quot; data-backw=&quot;553&quot; data-ratio=&quot;0.38794435857805254&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY47QulbL8dhO4QkNXb7rdwXFl08Qic3zqiciaMQZuZHSbDzAFhYwcRiaTMTyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1294&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在外卖业务上，我们也遇到了一些问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业务早期，为了满足业务需要，一般是拿到需求后case by case的先把需求完成，业务对于实时性要求是很高的，从时效性来说，没有进行中间层沉淀的机会，在这种场景下，一般是拿到业务逻辑直接嵌入，这是能想到的简单有效的方法，在业务发展初期这种开发模式比较常见。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上图所示，拿到数据源后，会经过数据清洗，扩维，通过Storm或Flink进行业务逻辑处理，最后直接进行业务输出。把这个环节拆开来看，数据源端会重复引用相同的数据源，后面进行清洗、过滤、扩维等操作，都要重复做一遍，唯一不同的是业务的代码逻辑是不一样的，如果业务较少，这种模式还可以接受，但当后续业务量上去后，会出现谁开发谁运维的情况，维护工作量会越来越大，作业无法形成统一管理。而且所有人都在申请资源，导致资源成本急速膨胀，资源不能集约有效利用，因此要思考如何从整体来进行实时数据的建设。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;04&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;数据特点与应用场景&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-backh=&quot;236&quot; data-backw=&quot;553&quot; data-ratio=&quot;0.4262948207171315&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY47yIWDicCmbsz6hSvSSiaVhr3qyqW0DXj4RLkXvXRPCXvWCYibPRB6T1LHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1255&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么如何来构建实时数仓呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先要进行拆解，有哪些数据，有哪些场景，这些场景有哪些共同特点，对于外卖场景来说一共有两大类，日志类和业务类。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;日志类：数据量特别大，半结构化，嵌套比较深。日志类的数据有个很大的特点，日志流一旦形成是不会变的，通过埋点的方式收集平台所有的日志，统一进行采集分发，就像一颗树，树根非常大，推到前端应用的时候，相当于从树根到树枝分叉的过程（从1到n的分解过程），如果所有的业务都从根上找数据，看起来路径最短，但包袱太重，数据检索效率低。日志类数据一般用于生产监控和用户行为分析，时效性要求比较高，时间窗口一般是5min或10min或截止到当前的一个状态，主要的应用是实时大屏和实时特征，例如用户每一次点击行为都能够立刻感知到等需求。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务类：主要是业务交易数据，业务系统一般是自成体系的，以Binlog日志的形式往下分发，业务系统都是事务型的，主要采用范式建模方式，特点是结构化的，主体非常清晰，但数据表较多，需要多表关联才能表达完整业务，因此是一个n到1的集成加工过程。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;业务类实时处理面临的几个难点：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务的多状态性：业务过程从开始到结束是不断变化的，比如从下单-&amp;gt;支付-&amp;gt;配送，业务库是在原始基础上进行变更的，binlog会产生很多变化的日志。而业务分析更加关注最终状态，由此产生数据回撤计算的问题，例如10点下单，13点取消，但希望在10点减掉取消单。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务集成：业务分析数据一般无法通过单一主体表达，往往是很多表进行关联，才能得到想要的信息，在实时流中进行数据的合流对齐，往往需要较大的缓存处理且复杂。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;分析是批量的，处理过程是流式的：对单一数据，无法形成分析，因此分析对象一定是批量的，而数据加工是逐条的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;日志类和业务类的场景一般是同时存在的，交织在一起，无论是Lambda架构还是Kappa架构，单一的应用都会有一些问题。因此针对场景来选择架构与实践才更有意义。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;05&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;实时数仓架构设计&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 实时架构：流批结合的探索&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;201&quot; data-backw=&quot;553&quot; data-ratio=&quot;0.364&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY47sczNJMdQ7XkMOyhE4UPIEoOGAYx0ia6eZ90sqC6pdib8icQc93lkxCs8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1250&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于以上问题，我们有自己的思考。通过流批结合的方式来应对不同的业务场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上图所示，数据从日志统一采集到消息队列，再到数据流的ETL过程，作为基础数据流的建设是统一的。之后对于日志类实时特征，实时大屏类应用走实时流计算。对于Binlog类业务分析走实时OLAP批处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;流式处理分析业务的痛点？对于范式业务，Storm和Flink都需要很大的外存，来实现数据流之间的业务对齐，需要大量的计算资源。且由于外存的限制，必须进行窗口的限定策略，最终可能放弃一些数据。计算之后，一般是存到Redis里做查询支撑，且KV存储在应对分析类查询场景中也有较多局限。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实时OLAP怎么实现？有没有一种自带存储的实时计算引擎，当实时数据来了之后，可以灵活的在一定范围内自由计算，并且有一定的数据承载能力，同时支持分析查询响应呢？随着技术的发展，目前MPP引擎发展非常迅速，性能也在飞快提升，所以在这种场景下就有了一种新的可能。这里我们使用的是Doris引擎。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种想法在业内也已经有实践，且成为一个重要探索方向。阿里基于ADB的实时OLAP方案等&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 实时数仓架构设计&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;257&quot; data-backw=&quot;553&quot; data-ratio=&quot;0.4654487688641779&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY47KibeyDudX692U6G9tPnYkuBYjTB5edzka04wttibRicDjBu8ic6lX1GOiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1259&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从整个实时数仓架构来看，首先考虑的是如何管理所有的实时数据，资源如何有效整合，数据如何进行建设。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从方法论来讲，实时和离线是非常相似的，离线数仓早期的时候也是case by case，当数据规模涨到一定量的时候才会考虑如何治理。分层是一种非常有效的数据治理方式，所以在实时数仓如何进行管理的问题上，首先考虑的也是分层的处理逻辑，具体如下：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据源：在数据源的层面，离线和实时在数据源是一致的，主要分为日志类和业务类，日志类又包括用户日志，DB日志以及服务器日志等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;实时明细层：在明细层，为了解决重复建设的问题，要进行统一构建，利用离线数仓的模式，建设统一的基础明细数据层，按照主题进行管理，明细层的目的是给下游提供直接可用的数据，因此要对基础层进行统一的加工，比如清洗、过滤、扩维等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;汇总层：汇总层通过Flink或Storm的简洁算子直接可以算出结果，并且形成汇总指标池，所有的指标都统一在汇总层加工，所有人按照统一的规范管理建设，形成可复用的汇总结果。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;总结起来，从整个实时数仓的建设角度来讲，首先数据建设的层次化要先建出来，先搭框架，然后定规范，每一层加工到什么程度，每一层用什么样的方式，当规范定义出来后，便于在生产上进行标准化的加工。由于要保证时效性，设计的时候，层次不能太多，对于实时性要求比较高的场景，基本可以走上图左侧的数据流，对于批量处理的需求，可以从实时明细层导入到实时olap引擎里，基于olap引擎自身的计算和查询能力进行快速的回撤计算，如上图右侧的数据流。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;06&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;实时平台化建设&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-backh=&quot;257&quot; data-backw=&quot;554&quot; data-ratio=&quot;0.46359223300970875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY47jXt5vT8Fa7KRhsILMX0wZSibicBH6Tibib1VEdYIcvIy7CCH8TZUrFWUhg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1236&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;架构确定之后，后面考虑的是如何进行平台化的建设，实时平台化建设完全附加于实时数仓管理之上进行的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先进行功能的抽象，把功能抽象成组件，这样就可以达到标准化的生产，系统化的保障就可以更深入的建设，对于基础加工层的清洗、过滤、合流、扩维、转换、加密、筛选等功能都可以抽象出来，基础层通过这种组件化的方式构建直接可用的数据结果流。这其中会有一个问题，用户的需求多样，满足了这个用户，如何兼容其他的用户，因此可能会出现冗余加工的情况，从存储来讲，实时数据不存历史，不会消耗过多的存储，这种冗余是可以接受的，通过冗余的方式可以提高生产效率，是一种空间换时间的思想应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过基础层的加工，数据全部沉淀到IDL层，同时写到olap引擎的基础层，再往上是实时汇总层计算，基于storm、flink或doris，生产多维度的汇总指标，形成统一的汇总层，进行统一的存储分发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当这些功能都有了以后，元数据管理，指标管理，数据安全性、SLA、数据质量等系统能力也会逐渐构建起来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 实时基础层功能&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;247&quot; data-backw=&quot;553&quot; data-ratio=&quot;0.44692737430167595&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY477SNC7QoQ7MBibmDxorSJ6d7DhLoeaiciaO4icvUVvg6mXZaVHqxyfnGtKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1253&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实时基础层的建设要解决一些问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先是一条流重复读的问题，一条Binlog打过来，是以DB包的形式存在的，用户可能只用其中一张表，如果大家都要用，可能存在所有人都要接这个流的问题。解决方案是可以按照不同的业务解构出来，还原到基础数据流层，根据业务的需要做成范式结构，按照数仓的建模方式进行集成化的主题建设。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次要进行组件的封装，比如基础层的清洗、过滤、扩维等功能，通过一个很简单的表达入口，让用户将逻辑写出来。trans环节是比较灵活的，比如从一个值转换成另外一个值，对于这种自定义逻辑表达，我们也开放了自定义组件，可以通过java或python开发自定义脚本，进行数据加工。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 实时特征生产功能&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;241&quot; data-backw=&quot;554&quot; data-ratio=&quot;0.43527508090614886&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY4730qXZl3NaPzKbfvhza1UuQYZRibDqYM3p6Hqib1TL6Wmia6GhVzHnu1eA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1236&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;特征生产可以通过sql语法进行逻辑表达，底层进行逻辑的适配，透传到计算引擎，屏蔽用户对计算引擎的依赖。就像对于离线场景，目前大公司很少通过代码的方式开发，除非一些特别的case，所以基本上可以通过sql化的方式表达。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在功能层面，把指标管理的思想融合进去，原子指标、派生指标，标准计算口径，维度选择，窗口设置等操作都可以通过配置化的方式，这样可以统一解析生产逻辑，进行统一封装。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还有一个问题，同一个源，写了很多sql，每一次提交都会起一个数据流，比较浪费资源，我们的解决方案是，通过同一条流实现动态指标的生产，在不停服务的情况下可以动态添加指标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以在实时平台建设过程中，更多考虑的是如何更有效的利用资源，在哪些环节更能节约化的使用资源，这是在工程方面更多考虑的事情。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. SLA建设&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;271&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;280&quot; data-ratio=&quot;0.4694178334561533&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY47Hf4D4s4nGoLC4MmvUuY7icqz6hPWsVh1ZoUqejia4Tka3K9LVyYDzUyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1357&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SLA主要解决两个问题，一个是端到端的SLA，一个是作业生产效率的SLA，我们采用埋点+上报的方式，由于实时流比较大，埋点要尽量简单，不能埋太多的东西，能表达业务即可，每个作业的输出统一上报到SLA监控平台，通过统一接口的形式，在每一个作业点上报所需要的信息，最后能够统计到端到端的SLA。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在实时生产中，由于链路非常长，无法控制所有链路，但是可以控制自己作业的效率，所以作业SLA也是必不可少的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4. 实时OLAP方案&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;269&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;290&quot; data-ratio=&quot;0.46534653465346537&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY47Je1v0UKMBnZ6uKGehEl8HLdPiaSvmoqc2nHkQyUrawBROSQgWbBa0YQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1212&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解决方案：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过带计算能力的olap引擎来解决，不需要把一个流进行逻辑化映射，只需要解决数据实时稳定的入库问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们这边采用的是doris作为高性能的olap引擎，由于业务数据产生的结果和结果之间还需要进行衍生计算，doris可以利用unique模型或聚合模型快速还原业务，还原业务的同时还可以进行汇总层的聚合，也是为了复用而设计。应用层可以是物理的，也可以是逻辑化视图。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种模式重在解决业务回撤计算，比如业务状态改变，需要在历史的某个点将值变更，这种场景用流计算的成本非常大，olap模式可以很好的解决这个问题。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;07&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;实时应用案例&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-backh=&quot;282&quot; data-backw=&quot;553&quot; data-ratio=&quot;0.5098712446351932&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY4730U1kTgqyglDkxKibr1TicWNpj6CLf092SdkBnusibiaBR9kttaGQSJlWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1165&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后通过一个案例说明，比如商家要根据用户历史下单数给用户优惠，商家需要看到历史下了多少单，历史T+1的数据要有，今天实时的数据也要有，这种场景是典型的Lambda架构，可以在doris里设计一个分区表，一个是历史分区，一个是今日分区，历史分区可以通过离线的方式生产，今日指标可以通过实时的方式计算，写到今日分区里，查询的时候进行一个简单的汇总。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种场景看起来比较简单，难点在于商家的量上来之后，很多简单的问题都会变的复杂，因此后面我们也会通过更多的业务输入，沉淀出更多的业务场景，抽象出来形成统一的生产方案和功能，以最小化的实时计算资源支撑多样化的业务需求，这也是未来需要达到的目的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16008590572276=&quot;rgb(136, 151, 171)&quot; data-darkmode-original-color-16008590572276=&quot;rgb(63, 74, 89)&quot; data-style=&quot;color: rgb(63, 74, 89); font-family: 微软雅黑; font-size: 11pt; letter-spacing: 0.4pt; text-align: left; text-indent: 0pt; visibility: visible;&quot;&gt;今天的分享就到这里，谢谢大家。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;在文末分享、点赞、在看，给个三连击呗~~&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;嘉宾介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;274&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;274&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY47j9w7euykic0EPa6l2ySODdthAIjgwgI56B2vMwCCq8nyeybbKGrMznA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;朱良&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;美团外卖 | 技术专家&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;朱良，5年以上传统行业数仓建设经验，6年互联网数仓经验，技术方向涉及离线，实时数仓治理，系统化能力建设，OLAP系统及引擎，大数据相关技术，重点跟进OLAP，实时技术前沿发展趋势。业务方向涉及即席查询，运营分析，策略报告产品，用户画像，人群推荐，实验评估等。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;会员推荐：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DataFun会员计划重磅发布！多重权益加持，为你筑就数据科学家之路！扫码了解更多：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;1606&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;246&quot; data-ratio=&quot;2.778498609823911&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zHbzQPKIBPjDxn4WzaBoRRHRHicz6Iz6BrVcCia7mbUMM8Uw9JMLYM3hEia0amw4iadLt5GIiaY4Ec5FgA0MzKlFVMw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1079&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;文章推荐：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&amp;amp;mid=2247508384&amp;amp;idx=1&amp;amp;sn=f4b9b2a8113daf5b73216258e66542e1&amp;amp;chksm=fbd713cccca09adafa33b72eb156fd7cd49a603b6ae266343e8310bb5f4eedcb25b679a7f879&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;美团外卖离线数仓建设实践&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关于我们：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;DataFunTalk &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;专注于大数据、人工智能技术应用的分享与交流。发起于2017年，在北京、上海、深圳、杭州等城市举办超过100场线下沙龙、论坛及峰会，已邀请近600位专家和学者参与分享。其公众号 DataFunTalk 累计生产原创文章300+，百万+阅读，8万+精准粉丝。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;160&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.27734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zHbzQPKIBPjDjicR2yOx02wNZLtRyVjaalkxbGB7NU2Paq7KM3MPhXtxKJy9M6Bs8EicpUtqCUe6fgfV4HSiaHs7Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;🧐&lt;strong&gt;分享、点赞、在看&lt;/strong&gt;，给个&lt;strong&gt;三连击&lt;/strong&gt;呗！&lt;strong&gt;👇 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e8d70511e6dee769862d6f21c77676fb</guid>
<title>Go 1.15 中值得关注的几个变化</title>
<link>https://toutiao.io/k/lipeqlg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-content&quot;&gt;&amp;#13;
&lt;p&gt;&lt;img src=&quot;https://tonybai.com/wp-content/uploads/go-1.15-1.png&quot; alt=&quot;img{512x368}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tip.golang.org/doc/go1.15&quot;&gt;Go 1.15版本&lt;/a&gt;在8月12日就正式发布了，给我的感觉就是发布的挺痛快^_^。这种感觉来自与之前版本发布时间的对比：&lt;a href=&quot;https://tonybai.com/2019/10/27/some-changes-in-go-1-13/&quot;&gt;Go 1.13版本&lt;/a&gt;发布于当年的9月4日，更早的&lt;a href=&quot;https://tonybai.com/2018/11/19/some-changes-in-go-1-11/&quot;&gt;Go 1.11版本&lt;/a&gt;发布于当年的8月25日。&lt;/p&gt;
&lt;p&gt;不过这个时间恰与我家&lt;a href=&quot;https://tonybai.com/2020/07/29/my-second-daughter-was-born/&quot;&gt;二宝出生&lt;/a&gt;和老婆月子时期有重叠，每天照顾孩子团团转的我实在抽不出时间研究Go 1.15的变化:(。如今，我逐渐从照顾二宝的工作中脱离出来^_^，于是“Go x.xx版本值得关注的几个变化”系列将继续下去。关注Go语言的演变对掌握和精通Go语言大有裨益，凡是致力于成为一名高级Gopher的读者都应该密切关注Go的演进。&lt;br/&gt;
截至写稿时，Go 1.15最新版是Go 1.15.2。Go 1.15一如既往的遵循&lt;a href=&quot;https://tip.golang.org/doc/go1compat.html&quot;&gt;Go1兼容性承诺&lt;/a&gt;。&lt;a href=&quot;https://tip.golang.org/ref/spec&quot;&gt;语言规范&lt;/a&gt;方面没有任何变化。可以说这是一个“面子”上变化较小的一个版本，但“里子”的变化还是不少的，在本文中我就和各位读者一起就重要变化逐一了解一下。&lt;/p&gt;
&lt;h3&gt;一. 平台移植性&lt;/h3&gt;
&lt;p&gt;Go 1.15版本不再对darwin/386和darwin/arm两个32位平台提供支持了。Go 1.15及以后版本仅对darwin/amd64和darwin/arm64版本提供支持。并且不再对macOS 10.12版本之前的版本提供支持。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tonybai.com/2020/03/08/some-changes-in-go-1-14/&quot;&gt;Go 1.14版本&lt;/a&gt;中，Go编译器在被传入-race和-msan的情况下，默认会执行&lt;strong&gt;-d=checkptr&lt;/strong&gt;，即对unsafe.Pointer的使用进行&lt;a href=&quot;https://github.com/golang/go/issues/34964&quot;&gt;合法性检查&lt;/a&gt;。&lt;strong&gt;-d=checkptr&lt;/strong&gt;主要检查两项内容：&lt;/p&gt;

&lt;p&gt;但在Go 1.14中，这个检查并不适用于Windows操作系统。Go 1.15中增加了对windows系统的支持。&lt;/p&gt;
&lt;p&gt;对于&lt;a href=&quot;https://riscv.org&quot;&gt;RISC-V&lt;/a&gt;架构，Go社区展现出十分积极的姿态，早在&lt;a href=&quot;https://tonybai.com/2018/11/19/some-changes-in-go-1-11/&quot;&gt;Go 1.11版本&lt;/a&gt;，Go就为RISC-V cpu架构预留了GOARCH值：riscv和riscv64。&lt;a href=&quot;https://tonybai.com/2020/03/08/some-changes-in-go-1-14/&quot;&gt;Go 1.14版本&lt;/a&gt;则为64bit RISC-V提供了在linux上的实验性支持(GOOS=linux, GOARCH=riscv64)。在Go 1.15版本中，Go在GOOS=linux, GOARCH=riscv64的环境下的稳定性和性能得到持续提升，并且已经可以支持goroutine异步抢占式调度了。&lt;/p&gt;
&lt;h3&gt;二. 工具链&lt;/h3&gt;
&lt;h4&gt;1. GOPROXY新增以管道符为分隔符的代理列表值&lt;/h4&gt;
&lt;p&gt;在&lt;a href=&quot;https://tonybai.com/2019/10/27/some-changes-in-go-1-13/&quot;&gt;Go 1.13版本&lt;/a&gt;中，&lt;a href=&quot;https://tonybai.com/2018/11/26/hello-go-module-proxy/&quot;&gt;GOPROXY&lt;/a&gt;支持设置为多个proxy的列表，多个proxy之间采用逗号分隔。Go工具链会按顺序尝试列表中的proxy以获取依赖包数据，但是当有proxy server服务不可达或者是返回的http状态码不是404也不是410时，go会终止数据获取。但是当列表中的proxy server返回其他错误时，Go命令不会向GOPROXY列表中的下一个值所代表的的proxy server发起请求，这种行为模式没能让所有gopher满意，&lt;strong&gt;很多Gopher认为Go工具链应该向后面的proxy server请求，直到所有proxy server都返回失败&lt;/strong&gt;。Go 1.15版本满足了Go社区的需求，新增以管道符“|”为分隔符的代理列表值。如果GOPROXY配置的proxy server列表值以管道符分隔，则无论某个proxy server返回什么错误码，Go命令都会向列表中的下一个proxy server发起新的尝试请求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：Go 1.15版本中GOPROXY环境变量的默认值依旧为&lt;strong&gt;https://proxy.golang.org,direct&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;2. module cache的存储路径可设置&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://tonybai.com/2019/06/03/the-practice-of-upgrading-major-version-under-go-module/&quot;&gt;Go module机制&lt;/a&gt;自打在&lt;a href=&quot;https://tonybai.com/2018/11/19/some-changes-in-go-1-11/&quot;&gt;Go 1.11版本&lt;/a&gt;中以试验特性的方式引入时就将module的本地缓存默认放在了&lt;strong&gt;\$GOPATH/pkg/mod&lt;/strong&gt;下（如果没有显式设置GOPATH，那么默认值将是&lt;strong&gt;~/go&lt;/strong&gt;；如果GOPATH下面配置了多个路径，那么选择第一个路径），一直到Go 1.14版本，这个位置都是无法配置的。&lt;/p&gt;
&lt;p&gt;Go module的引入为去除GOPATH提供了前提，于是module cache的位置也要尽量与GOPATH“脱钩”：Go 1.15提供了GOMODCACHE环境变量用于自定义module cache的存放位置。如果没有显式设置GOMODCACHE，那么module cache的默认存储路径依然是&lt;strong&gt;\$GOPATH/pkg/mod&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;三. 运行时、编译器和链接器&lt;/h3&gt;
&lt;h4&gt;1. panic展现形式变化&lt;/h4&gt;
&lt;p&gt;在Go 1.15之前，如果传给panic的值是bool, complex64, complex128, float32, float64, int, int8, int16, int32, int64, string, uint, uint8, uint16, uint32, uint64, uintptr等原生类型的值，那么panic在触发时会输出具体的值，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// go1.15-examples/runtime/panic.go

package main

func foo() {
    var i uint32 = 17
    panic(i)
}

func main() {
    foo()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用Go 1.14运行上述代码，得到如下结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$go run panic.go
panic: 17

goroutine 1 [running]:
main.foo(...)
    /Users/tonybai/go/src/github.com/bigwhite/experiments/go1.15-examples/runtime/panic.go:5
main.main()
    /Users/tonybai/go/src/github.com/bigwhite/experiments/go1.15-examples/runtime/panic.go:9 +0x39
exit status 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Go 1.15版本亦是如此。但是对于派生于上述原生类型的自定义类型而言，Go 1.14只是输出变量地址：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// go1.15-examples/runtime/panic.go

package main

type myint uint32

func bar() {
    var i myint = 27
    panic(i)
}

func main() {
    bar()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用Go 1.14运行上述代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$go run panic.go
panic: (main.myint) (0x105fca0,0xc00008e000)

goroutine 1 [running]:
main.bar(...)
    /Users/tonybai/go/src/github.com/bigwhite/experiments/go1.15-examples/runtime/panic.go:12
main.main()
    /Users/tonybai/go/src/github.com/bigwhite/experiments/go1.15-examples/runtime/panic.go:17 +0x39
exit status 2

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Go 1.15针对此情况作了展示优化，即便是派生于这些原生类型的自定义类型变量，panic也可以输出其值。使用Go 1.15运行上述代码的结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$go run panic.go
panic: main.myint(27)

goroutine 1 [running]:
main.bar(...)
    /Users/tonybai/go/src/github.com/bigwhite/experiments/go1.15-examples/runtime/panic.go:12
main.main()
    /Users/tonybai/go/src/github.com/bigwhite/experiments/go1.15-examples/runtime/panic.go:17 +0x39
exit status 2

&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;2. 将小整数([0,255])转换为interface类型值时将不会额外分配内存&lt;/h4&gt;
&lt;p&gt;Go 1.15在runtime/iface.go中做了一些优化改动：增加一个名为staticuint64s的数组，预先为[0,255]这256个数分配了内存。然后在convT16、convT32等运行时转换函数中判断要转换的整型值是否小于256(len(staticuint64s))，如果小于，则返回staticuint64s数组中对应的值的地址；否则调用mallocgc分配新内存。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$GOROOT/src/runtime/iface.go

// staticuint64s is used to avoid allocating in convTx for small integer values.
var staticuint64s = [...]uint64{
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
        0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
        0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
        0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,

        ... ...

        0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
        0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,

}

func convT16(val uint16) (x unsafe.Pointer) {
        if val &amp;lt; uint16(len(staticuint64s)) {
                x = unsafe.Pointer(&amp;amp;staticuint64s[val])
                if sys.BigEndian {
                        x = add(x, 6)
                }
        } else {
                x = mallocgc(2, uint16Type, false)
                *(*uint16)(x) = val
        }
        return
}

func convT32(val uint32) (x unsafe.Pointer) {
        if val &amp;lt; uint32(len(staticuint64s)) {
                x = unsafe.Pointer(&amp;amp;staticuint64s[val])
                if sys.BigEndian {
                        x = add(x, 4)
                }
        } else {
                x = mallocgc(4, uint32Type, false)
                *(*uint32)(x) = val
        }
        return
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以用下面例子来验证一下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// go1.15-examples/runtime/tinyint2interface.go

package main

import (
    &quot;math/rand&quot;
)

func convertSmallInteger() interface{} {
    i := rand.Intn(256)
    var j interface{} = i
    return j
}

func main() {
    for i := 0; i &amp;lt; 100000000; i++ {
        convertSmallInteger()
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们分别用go 1.14和go 1.15.2编译这个源文件（注意关闭内联等优化，否则很可能看不出效果）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// go 1.14

go build  -gcflags=&quot;-N -l&quot; -o tinyint2interface-go14 tinyint2interface.go

// go 1.15.2

go build  -gcflags=&quot;-N -l&quot; -o tinyint2interface-go15 tinyint2interface.go

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们使用下面命令输出程序执行时每次GC的信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$env GODEBUG=gctrace=1 ./tinyint2interface-go14
gc 1 @0.025s 0%: 0.009+0.18+0.021 ms clock, 0.079+0.079/0/0.20+0.17 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 8 P
gc 2 @0.047s 0%: 0.003+0.14+0.013 ms clock, 0.031+0.099/0.064/0.037+0.10 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 8 P
gc 3 @0.064s 0%: 0.008+0.20+0.016 ms clock, 0.071+0.071/0.018/0.081+0.13 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 8 P
gc 4 @0.081s 0%: 0.005+0.14+0.013 ms clock, 0.047+0.059/0.023/0.032+0.10 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 8 P
gc 5 @0.098s 0%: 0.005+0.10+0.017 ms clock, 0.042+0.073/0.027/0.080+0.13 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 8 P

... ...

gc 192 @3.264s 0%: 0.003+0.11+0.013 ms clock, 0.024+0.060/0.005/0.035+0.11 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 8 P
gc 193 @3.281s 0%: 0.005+0.13+0.032 ms clock, 0.042+0.075/0.041/0.050+0.25 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 8 P
gc 194 @3.298s 0%: 0.004+0.12+0.013 ms clock, 0.033+0.072/0.030/0.033+0.10 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 8 P
gc 195 @3.315s 0%: 0.003+0.17+0.023 ms clock, 0.029+0.062/0.055/0.024+0.18 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 8 P

$env GODEBUG=gctrace=1 ./tinyint2interface-go15
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们看到和go 1.14编译的程序不断分配内存，不断导致GC相比，go1.15.2没有输出GC信息，间接证实了小整数转interface变量值时不会触发内存分配。&lt;/p&gt;
&lt;h4&gt;3. 加入更现代化的链接器(linker)&lt;/h4&gt;
&lt;p&gt;一个新版的&lt;a href=&quot;https://golang.org/s/better-linker&quot;&gt;现代化linker&lt;/a&gt;正在逐渐加入到Go中，Go 1.15是新版linker的起点。后续若干版本，linker优化会逐步加入进来。在Go 1.15中，对于大型项目，新链接器的性能要提高20%，内存占用减少30%。&lt;/p&gt;
&lt;h4&gt;4. objdump支持输出GNU汇编语法&lt;/h4&gt;
&lt;p&gt;go 1.15为objdump工具增加了-gnu选项，&lt;strong&gt;以在Go汇编的后面，辅助输出GNU汇编，便于对照&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// go 1.14：

$go tool objdump -S tinyint2interface-go15|more
TEXT go.buildid(SB)

  0x1001000             ff20                    JMP 0(AX)
  0x1001002             476f                    OUTSD DS:0(SI), DX
  0x1001004             206275                  ANDB AH, 0x75(DX)
  0x1001007             696c642049443a20        IMULL $0x203a4449, 0x20(SP), BP
... ...

//go 1.15.2：

$go tool objdump  -S -gnu tinyint2interface-go15|more
TEXT go.buildid(SB)

  0x1001000             ff20                    JMP 0(AX)                            // jmpq *(%rax)           

  0x1001002             476f                    OUTSD DS:0(SI), DX                   // rex.RXB outsl %ds:(%rsi),(%dx)
  0x1001004             206275                  ANDB AH, 0x75(DX)                    // and %ah,0x75(%rdx)     

  0x1001007             696c642049443a20        IMULL $0x203a4449, 0x20(SP), BP      // imul $0x203a4449,0x20(%rsp,%riz,2),%ebp

... ...

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;四. 标准库&lt;/h3&gt;
&lt;p&gt;和以往发布的版本一样，标准库有大量小改动，这里挑出几个笔者感兴趣的和大家一起看一下。&lt;/p&gt;
&lt;h4&gt;1. 增加tzdata包&lt;/h4&gt;
&lt;p&gt;Go time包中很多方法依赖时区数据，但不是所有平台上都自带时区数据。Go time包会以下面顺序搜寻时区数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- ZONEINFO环境变量指示的路径中

- 在类Unix系统中一些常见的存放时区数据的路径（zoneinfo_unix.go中的zoneSources数组变量中存放这些常见路径）：

    &quot;/usr/share/zoneinfo/&quot;,
    &quot;/usr/share/lib/zoneinfo/&quot;,
    &quot;/usr/lib/locale/TZ/&quot;

- 如果平台没有，则尝试使用$GOROOT/lib/time/zoneinfo.zip这个随着go发布包一起发布的时区数据。但在应用部署的环境中，很大可能不会进行go安装。

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果go应用找不到时区数据，那么go应用运行将会受到影响，就如下面这个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// go1.15-examples/stdlib/tzdata.go

package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    loc, err := time.LoadLocation(&quot;America/New_York&quot;)
    if err != nil {
        fmt.Println(&quot;LoadLocation error:&quot;, err)
        return
    }
    fmt.Println(&quot;LoadLocation is:&quot;, loc)
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们移除系统的时区数据(比如将/usr/share/zoneinfo改名)和Go安装包自带的zoneinfo.zip(改个名)后，在Go 1.15.2下运行该示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go run tzdata.go
LoadLocation error: unknown time zone America/New_York

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为此，Go 1.15提供了一个将时区数据嵌入到Go应用二进制文件中的方法：&lt;strong&gt;导入time/tzdata包&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// go1.15-examples/stdlib/tzdata.go

package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
    _ &quot;time/tzdata&quot;
)

func main() {
    loc, err := time.LoadLocation(&quot;America/New_York&quot;)
    if err != nil {
        fmt.Println(&quot;LoadLocation error:&quot;, err)
        return
    }
    fmt.Println(&quot;LoadLocation is:&quot;, loc)
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们再用go 1.15.2运行一下上述导入tzdata包的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$go run testtimezone.go
LoadLocation is: America/New_York

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不过由于附带tzdata数据，应用二进制文件的size会增大大约800k，下面是在ubuntu下的实测值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-rwxr-xr-x 1 root root 2.0M Oct 11 02:42 tzdata-withouttzdata*
-rwxr-xr-x 1 root root 2.8M Oct 11 02:42 tzdata-withtzdata*

&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;2. 增加json解码限制&lt;/h4&gt;
&lt;p&gt;json包是日常使用最多的go标准库包之一，在Go 1.15中，go按照json规范的要求，为json的解码增加了一层限制：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// json规范要求

//https://tools.ietf.org/html/rfc7159#section-9

A JSON parser transforms a JSON text into another representation.  A
   JSON parser MUST accept all texts that conform to the JSON grammar.
   A JSON parser MAY accept non-JSON forms or extensions.

   An implementation may set limits on the size of texts that it
   accepts.  An implementation may set limits on the maximum depth of
   nesting.  An implementation may set limits on the range and precision
   of numbers.  An implementation may set limits on the length and
   character contents of strings.

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个限制就是增加了一个对json文本最大缩进深度值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// $GOROOT/src/encoding/json/scanner.go

// This limits the max nesting depth to prevent stack overflow.
// This is permitted by https://tools.ietf.org/html/rfc7159#section-9
const maxNestingDepth = 10000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果一旦传入的json文本数据缩进深度超过maxNestingDepth，那json包就会panic。当然，绝大多数情况下，我们是碰不到缩进10000层的超大json文本的。因此，该limit对于99.9999%的gopher都没啥影响。&lt;/p&gt;
&lt;h4&gt;3. reflect包&lt;/h4&gt;
&lt;p&gt;Go 1.15版本之前reflect包&lt;a href=&quot;https://github.com/golang/go/issues/38521&quot;&gt;存在一处行为不一致的问题&lt;/a&gt;，我们看下面例子(例子来源于https://play.golang.org/p/Jnga2_6Rmdf)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// go1.15-examples/stdlib/reflect.go

package main

import &quot;reflect&quot;

type u struct{}

func (u) M() { println(&quot;M&quot;) }

type t struct {
    u
    u2 u
}

func call(v reflect.Value) {
    defer func() {
        if err := recover(); err != nil {
            println(err.(string))
        }
    }()
    v.Method(0).Call(nil)
}

func main() {
    v := reflect.ValueOf(t{}) // v := t{}
    call(v)                   // v.M()
    call(v.Field(0))          // v.u.M()
    call(v.Field(1))          // v.u2.M()
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们使用Go 1.14版本运行该示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$go run reflect.go
M
M
reflect: reflect.flag.mustBeExported using value obtained using unexported field

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们看到同为类型t中的非导出字段(field)的u和u2(u是以嵌入类型方式称为类型t的字段的)，通过reflect包可以调用字段u的导出方法(如输出中的第二行的M)，却无法调用非导出字段u2的导出方法（如输出中的第三行的panic信息）。&lt;/p&gt;
&lt;p&gt;这种不一致在Go 1.15版本中被修复，我们使用Go 1.15.2运行上述示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$go run reflect.go
M
reflect: reflect.Value.Call using value obtained using unexported field
reflect: reflect.Value.Call using value obtained using unexported field

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们看到reflect无法调用非导出字段u和u2的导出方法了。但是reflect依然可以通过提升到类型t的方法来间接使用u的导出方法，正如运行结果中的第一行输出。&lt;br/&gt;
&lt;strong&gt;这一改动可能会影响到遗留代码中使用reflect调用以类型嵌入形式存在的非导出字段方法的代码&lt;/strong&gt;，如果你的代码中存在这样的问题，可以直接通过提升(promote)到包裹类型(如例子中的t)中的方法（如例子中的call(v)）来替代之前的方式。&lt;/p&gt;
&lt;h3&gt;五. 小结&lt;/h3&gt;
&lt;p&gt;由于Go 1.15删除了一些GC元数据和一些无用的类型元数据，Go 1.15编译出的二进制文件size会减少5%左右。我用一个中等规模的go项目实测了一下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-rwxr-xr-x   1 tonybai  staff    23M 10 10 16:54 yunxind*
-rwxr-xr-x   1 tonybai  staff    24M  9 30 11:20 yunxind-go14*

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;二进制文件size的确有变小，大约4%-5%。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你还没有升级到Go 1.15，那么现在正是时候&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;本文中涉及的代码可以在&lt;a href=&quot;https://github.com/bigwhite/experiments/tree/master/go1.15-examples&quot;&gt;这里&lt;/a&gt;下载。https://github.com/bigwhite/experiments/tree/master/go1.15-examples&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;我的Go技术专栏：“&lt;a href=&quot;https://www.imooc.com/read/87&quot;&gt;改善Go语⾔编程质量的50个有效实践&lt;/a&gt;”上线了，欢迎大家订阅学习！&lt;/p&gt;
&lt;p&gt;我的网课“&lt;a href=&quot;https://coding.imooc.com/class/284.html&quot;&gt;Kubernetes实战：高可用集群搭建、配置、运维与应用&lt;/a&gt;”在慕课网上线了，感谢小伙伴们学习支持！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://51smspush.com/&quot;&gt;我爱发短信&lt;/a&gt;：企业级短信平台定制开发专家 https://51smspush.com/&lt;br/&gt;
smspush : 可部署在企业内部的定制化短信平台，三网覆盖，不惧大并发接入，可定制扩展； 短信内容你来定，不再受约束, 接口丰富，支持长短信，签名可选。&lt;/p&gt;
&lt;p&gt;2020年4月8日，中国三大电信运营商联合发布《5G消息白皮书》，51短信平台也会全新升级到“51商用消息平台”，全面支持5G RCS消息。&lt;/p&gt;
&lt;p&gt;著名云主机服务厂商DigitalOcean发布最新的主机计划，入门级Droplet配置升级为：1 core CPU、1G内存、25G高速SSD，价格5$/月。有使用DigitalOcean需求的朋友，可以打开这个&lt;a href=&quot;https://m.do.co/c/bff6eed92687&quot;&gt;链接地址&lt;/a&gt;：https://m.do.co/c/bff6eed92687 开启你的DO主机之路。&lt;/p&gt;
&lt;p&gt;Gopher Daily(Gopher每日新闻)归档仓库 – https://github.com/bigwhite/gopherdaily&lt;/p&gt;
&lt;p&gt;我的联系方式：&lt;/p&gt;
&lt;p&gt;微博：https://weibo.com/bigwhite20xx&lt;br/&gt;
微信公众号：iamtonybai&lt;br/&gt;
博客：tonybai.com&lt;br/&gt;
github: https://github.com/bigwhite&lt;/p&gt;
&lt;p&gt;微信赞赏：&lt;br/&gt;
&lt;img src=&quot;https://tonybai.com/wp-content/uploads/wechat-zanshang-code-512x512.jpg&quot; alt=&quot;img{512x368}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;商务合作方式：撰稿、出书、培训、在线课程、合伙创业、咨询、广告合作。&lt;/p&gt;
&lt;p&gt;© 2020, &lt;a href=&quot;https://tonybai.com&quot;&gt;bigwhite&lt;/a&gt;. 版权所有. &lt;/p&gt;
&lt;p&gt;Related posts:&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://tonybai.com/2020/03/08/some-changes-in-go-1-14/&quot; rel=&quot;bookmark&quot; title=&quot;Go 1.14中值得关注的几个变化&quot;&gt;Go 1.14中值得关注的几个变化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tonybai.com/2016/02/21/some-changes-in-go-1-6/&quot; rel=&quot;bookmark&quot; title=&quot;Go 1.6中值得关注的几个变化&quot;&gt;Go 1.6中值得关注的几个变化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tonybai.com/2015/03/09/understanding-import-packages/&quot; rel=&quot;bookmark&quot; title=&quot;理解Golang包导入&quot;&gt;理解Golang包导入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tonybai.com/2018/11/26/hello-go-module-proxy/&quot; rel=&quot;bookmark&quot; title=&quot;Hello，Go module proxy&quot;&gt;Hello，Go module proxy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tonybai.com/2015/07/10/some-changes-in-go-1-5/&quot; rel=&quot;bookmark&quot; title=&quot;Go 1.5中值得关注的几个变化&quot;&gt;Go 1.5中值得关注的几个变化&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;&amp;#13;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>34e6e60802faa7ddfeb293dfba09af6c</guid>
<title>Go-Zero 如何应对海量定时/延迟任务</title>
<link>https://toutiao.io/k/g1xuphe</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;一个系统中存在着大量的调度任务，同时调度任务存在时间的滞后性，而大量的调度任务如果每一个都使用自己的调度器来管理任务的生命周期的话，浪费 cpu 的资源而且很低效。&lt;/p&gt;&lt;p&gt;本文来介绍 &lt;code&gt;go-zero&lt;/code&gt; 中 &lt;span&gt;延迟操作&lt;/span&gt;，它可能让开发者调度多个任务时，&lt;span&gt;只需关注具体的业务执行函数和执行时间「立即或者延迟」&lt;/span&gt;。而 &lt;span&gt;延迟操作&lt;/span&gt;，通常可以采用两个方案：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;Timer&lt;/code&gt;：定时器维护一个优先队列，到时间点执行，然后把需要执行的 task 存储在 map 中&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;collection&lt;/code&gt; 中的 &lt;code&gt;timingWheel&lt;/code&gt; ，维护一个存放任务组的数组，每一个槽都维护一个存储 task 的双向链表。开始执行时，计时器每隔指定时间执行一个槽里面的 tasks。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;方案 2 把维护 task 从 &lt;code&gt;优先队列 O(nlog(n))&lt;/code&gt; 降到 &lt;code&gt;双向链表 O(1)&lt;/code&gt;，而执行 task 也只要轮询一个时间点的 tasks &lt;code&gt;O(N)&lt;/code&gt;，不需要像优先队列，放入和删除元素 &lt;code&gt;O(nlog(n))&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;我们先看看 &lt;code&gt;go-zero&lt;/code&gt; 中自己对 &lt;code&gt;timingWheel&lt;/code&gt; 的使用 ：&lt;/p&gt;&lt;h2&gt;cache 中的 timingWheel&lt;/h2&gt;&lt;p&gt;首先我们先来在 &lt;code&gt;collection&lt;/code&gt; 的 &lt;code&gt;cache&lt;/code&gt; 中关于 &lt;code&gt;timingWheel&lt;/code&gt; 的使用：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;timingWheel&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;NewTimingWheel&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;time&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Second&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;slots&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;k&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;v&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{})&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;key&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;ok&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;k&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;cache&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Del&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;})&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;err&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;cache&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;timingWheel&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;timingWheel&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是 &lt;code&gt;cache&lt;/code&gt; 初始化中也同时初始化 &lt;code&gt;timingWheel&lt;/code&gt; 做 key 的过期处理，参数依次代表：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;interval&lt;/code&gt;：时间划分刻度&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;numSlots&lt;/code&gt;：时间槽&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;execute&lt;/code&gt;：时间点执行函数&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在 &lt;code&gt;cache&lt;/code&gt; 中执行函数则是 &lt;span&gt;删除过期 key&lt;/span&gt;，而这个过期则由 &lt;code&gt;timingWheel&lt;/code&gt; 来控制推进时间。&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来，就通过 &lt;code&gt;cache&lt;/code&gt; 对 &lt;code&gt;timingWheel&lt;/code&gt; 的使用来认识。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;初始化&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 真正做初始化&lt;/span&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;newTimingWheelWithClock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;interval&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Duration&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;numSlots&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;execute&lt;/span&gt; &lt;span&gt;Execute&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;ticker&lt;/span&gt; &lt;span&gt;timex&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Ticker&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;*&lt;/span&gt;&lt;span&gt;TimingWheel&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;tw&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;TimingWheel&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;interval&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;      &lt;span&gt;interval&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;                     &lt;span&gt;// 单个时间格时间间隔&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;ticker&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;        &lt;span&gt;ticker&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;                       &lt;span&gt;// 定时器，做时间推动，以interval为单位推进&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;slots&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;         &lt;span&gt;make&lt;/span&gt;&lt;span&gt;([]&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;List&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;numSlots&lt;/span&gt;&lt;span&gt;),&lt;/span&gt; &lt;span&gt;// 时间轮&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;timers&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;        &lt;span&gt;NewSafeMap&lt;/span&gt;&lt;span&gt;(),&lt;/span&gt;                 &lt;span&gt;// 存储task{key, value}的map [执行execute所需要的参数]&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;tickedPos&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;     &lt;span&gt;numSlots&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;                 &lt;span&gt;// at previous virtual circle&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;execute&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;       &lt;span&gt;execute&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;                      &lt;span&gt;// 执行函数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;numSlots&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;      &lt;span&gt;numSlots&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;                     &lt;span&gt;// 初始化 slots num&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;setChannel&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;    &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;timingEntry&lt;/span&gt;&lt;span&gt;),&lt;/span&gt;       &lt;span&gt;// 以下几个channel是做task传递的&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;moveChannel&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;   &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;baseEntry&lt;/span&gt;&lt;span&gt;),&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;removeChannel&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{}),&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;drainChannel&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;  &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;value&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{})),&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;stopChannel&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;   &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;lang&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;PlaceholderType&lt;/span&gt;&lt;span&gt;),&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 把 slot 中存储的 list 全部准备好&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;initSlots&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 开启异步协程，使用 channel 来做task通信和传递&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;go&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.44309647602541885&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbA2Zb6GjZc0zo2icBRxhOlfZ2W2kCZ7nRZHMbt30icn6zTNbW0fHUXXCElAPH2uAMZTXCysUMru7SCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1731&quot; title=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以上比较直观展示 &lt;code&gt;timingWheel&lt;/code&gt; 的 &lt;span&gt;“时间轮”&lt;/span&gt;，后面会围绕这张图解释其中推进的细节。&lt;/p&gt;&lt;p&gt;&lt;code&gt;go tw.run()&lt;/code&gt; 开一个协程做时间推动：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;TimingWheel&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;select&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// 定时器做时间推动 -&amp;gt; scanAndRunTasks()&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&amp;lt;-&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;ticker&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Chan&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;onTick&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// add task 会往 setChannel 输入task&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;task&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&amp;lt;-&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setChannel&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setTask&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;task&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;...&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看出，在初始化的时候就开始了 &lt;code&gt;timer&lt;/code&gt; 执行，并以&lt;code&gt;internal&lt;/code&gt;时间段转动，然后底层不停的获取来自 &lt;code&gt;slot&lt;/code&gt; 中的 &lt;code&gt;list&lt;/code&gt; 的 task，交给 &lt;code&gt;execute&lt;/code&gt; 执行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5576619273301737&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbA2Zb6GjZc0zo2icBRxhOlfZ7KHxknp0ykgrXOwEz7FLxrxIgAL0bxQw1JFULaLOickPl2MKdd39wcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1266&quot; title=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;Task Operation&lt;/h3&gt;&lt;p&gt;紧接着就是设置 &lt;code&gt;cache key&lt;/code&gt; ：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;c&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Cache&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;Set&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;key&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;value&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{})&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Lock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;_&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;ok&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;value&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;lruCache&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Unlock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;expiry&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;unstableExpiry&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;AroundDuration&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;expire&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;ok&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;timingWheel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;MoveTimer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;expiry&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;timingWheel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;SetTimer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;value&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;expiry&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;先看在 &lt;code&gt;data map&lt;/code&gt; 中有没有存在这个 key&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;存在，则更新 &lt;code&gt;expire&lt;/code&gt; -&amp;gt; &lt;code&gt;MoveTimer()&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第一次设置 key -&amp;gt; &lt;code&gt;SetTimer()&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;所以对于 &lt;code&gt;timingWheel&lt;/code&gt; 的使用上就清晰了，开发者根据需求可以 &lt;code&gt;add&lt;/code&gt; 或是 &lt;code&gt;update&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;同时我们跟源码进去会发现：&lt;code&gt;SetTimer() MoveTimer()&lt;/code&gt; 都是将 task 输送到 channel，由 &lt;code&gt;run()&lt;/code&gt; 中开启的协程不断取出 &lt;code&gt;channel&lt;/code&gt; 的 task 操作。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code&gt;SetTimer() -&amp;gt; setTask()&lt;/code&gt;：&lt;/p&gt;&lt;p&gt;&lt;code&gt;MoveTimer() -&amp;gt; moveTask()&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;由上面的调用链，有一个都会调用的函数：&lt;code&gt;moveTask()&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;TimingWheel&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;moveTask&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;task&lt;/span&gt; &lt;span&gt;baseEntry&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// timers: Map =&amp;gt; 通过key获取 [positionEntry「pos, task」]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;val&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;ok&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;timers&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;timer&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;val&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;positionEntry&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// {delay &amp;lt; interval} =&amp;gt; 延迟时间比一个时间格间隔还小，没有更小的刻度，说明任务应该立即执行&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;delay&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;interval&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;threading&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;GoSafe&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;})&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 如果 &amp;gt; interval，则通过 延迟时间delay 计算其出时间轮中的 new pos, circle&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;pos&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;circle&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getPositionAndCircle&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;delay&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;pos&lt;/span&gt; &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;pos&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;circle&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;circle&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 记录前后的移动offset。为了后面过程重新入队&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;diff&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;pos&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;pos&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;circle&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 转移到下一层，将 circle 转换为 diff 一部分&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;circle&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;circle&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;circle&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 因为是一个数组，要加上 numSlots [也就是相当于要走到下一层]&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;diff&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;numSlots&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;pos&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;pos&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 如果 offset 提前了，此时 task 也还在第一层&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 标记删除老的 task，并重新入队，等待被执行&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;removed&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;newItem&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;timingEntry&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;baseEntry&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;task&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;value&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;     &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;slots&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;pos&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;PushBack&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;newItem&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setTimerPosition&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;pos&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;newItem&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上过程有以下几种情况：&lt;/p&gt;&lt;h3&gt;Execute&lt;/h3&gt;&lt;p&gt;之前在初始化中，&lt;code&gt;run()&lt;/code&gt; 中定时器的不断推进，推进的过程主要就是把 list 中的 task 传给执行的 &lt;code&gt;execute func&lt;/code&gt;。我们从定时器的执行开始看：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 定时器 「每隔 internal 会执行一次」&lt;/span&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;TimingWheel&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;onTick&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 每次执行更新一下当前执行 tick 位置&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;tickedPos&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;tickedPos&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;%&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;numSlots&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 获取此时 tick位置 中的存储task的双向链表&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;l&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;slots&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;tickedPos&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;scanAndRunTasks&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;紧接着是如何去执行 &lt;code&gt;execute&lt;/code&gt;：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;TimingWheel&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;scanAndRunTasks&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;l&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;List&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 存储目前需要执行的task{key, value}  [execute所需要的参数，依次传递给execute执行]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; &lt;span&gt;tasks&lt;/span&gt; &lt;span&gt;[]&lt;/span&gt;&lt;span&gt;timingTask&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; &lt;span&gt;e&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;l&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Front&lt;/span&gt;&lt;span&gt;();&lt;/span&gt; &lt;span&gt;e&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;task&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;timingEntry&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 标记删除，在 scan 中做真正的删除 「删除map的data」&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;removed&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;next&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Next&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;l&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Remove&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;timers&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Del&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;e&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;next&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;circle&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// 当前执行点已经过期，但是同时不在第一层，所以当前层即然已经完成了，就会降到下一层&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;// 但是并没有修改 pos&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;circle&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;e&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Next&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;diff&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// 因为之前已经标注了diff，需要再进入队列&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;next&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Next&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;l&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Remove&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;pos&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;tickedPos&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;diff&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;%&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;numSlots&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;slots&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;pos&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;PushBack&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;task&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setTimerPosition&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;pos&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;task&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;diff&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;e&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;next&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 以上的情况都是不能执行的情况，能够执行的会被加入tasks中&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;tasks&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;tasks&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;timingTask&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;key&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;   &lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;value&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;})&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;next&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Next&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;l&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Remove&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;timers&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Del&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;e&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;next&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// for range tasks，然后把每个 task-&amp;gt;execute 执行即可&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;runTasks&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;tasks&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体的分支情况在注释中说明了，在看的时候可以和前面的 &lt;code&gt;moveTask()&lt;/code&gt; 结合起来，其中 &lt;code&gt;circle&lt;/code&gt; 下降，&lt;code&gt;diff&lt;/code&gt; 的计算是关联两个函数的重点。&lt;/p&gt;&lt;p&gt;至于 &lt;code&gt;diff&lt;/code&gt; 计算就涉及到 &lt;code&gt;pos, circle&lt;/code&gt; 的计算：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// interval: 4min, d: 60min, numSlots: 16, tickedPos = 15&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// step = 15, pos = 14, circle = 0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;TimingWheel&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;getPositionAndCircle&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;d&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Duration&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;pos&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;circle&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;steps&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;d&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;interval&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;pos&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;tickedPos&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;steps&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;%&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;numSlots&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;circle&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;steps&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;numSlots&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;上面的过程可以简化成下面：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;steps&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;d&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;interval&lt;/span&gt;&lt;br/&gt;&lt;span&gt;pos&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;step&lt;/span&gt; &lt;span&gt;%&lt;/span&gt; &lt;span&gt;numSlots&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;circle&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;step&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;numSlots&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;timingWheel&lt;/code&gt; 靠定时器推动，时间前进的同时会取出&lt;span&gt;当前时间格&lt;/span&gt;中 &lt;code&gt;list&lt;/code&gt;「双向链表」的 task，传递到 &lt;code&gt;execute&lt;/code&gt; 中执行。因为是是靠 &lt;code&gt;internal&lt;/code&gt; 固定时间刻度推进，可能就会出现：一个 60s 的 task，&lt;code&gt;internal = 1s&lt;/code&gt;，这样就会空跑 59 次 loop。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;而在扩展时间上，采取 &lt;code&gt;circle&lt;/code&gt; 分层，这样就可以不断复用原有的 &lt;code&gt;numSlots&lt;/code&gt; ，因为定时器在不断 &lt;code&gt;loop&lt;/code&gt;，而执行可以把上层的 &lt;code&gt;slot&lt;/code&gt; 下降到下层，在不断 &lt;code&gt;loop&lt;/code&gt; 中就可以执行到上层的 task。这样的设计可以在不创造额外的数据结构，突破长时间的限制。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;同时在 &lt;code&gt;go-zero&lt;/code&gt; 中还有很多实用的组件工具，用好工具对于提升服务性能和开发效率都有很大的帮助，希望本篇文章能给大家带来一些收获。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;同时欢迎大家使用 &lt;code&gt;go-zero&lt;/code&gt; 并加入我们，项目地址 https://github.com/tal-tech/go-zero&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9966442953020134&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbA2Zb6GjZc0zo2icBRxhOlfZ7h0WKmxYsOuibrQiaxZDz1RqTKufficj5HC11VUYGtwyML4ia4nerr3jMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;596&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ef81b18c0014dd5ec48bc05db1ae0406</guid>
<title>头条终面：写个消息中间件</title>
<link>https://toutiao.io/k/qjxr0pi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;每个时代，都不会亏待会学习的人。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是 yes。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种设计类问题想必大家都不陌生，面试时或多或少都能碰到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如如何写一个线程池？如何写一个 HashMap ？如何写一个 RPC 框架等等，当然这里的写不是真的叫你用代码写出来，只是说说设计理念，整体架构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个面试题来自于一个读者的字节面试经历，我会从面试技巧和消息中间件的设计两个方面阐述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我觉得重点在于面试技巧，因为它通用。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;两种极端的情况&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大多数同学遇到这种问题会出现两种极端的情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;第一种：一脸懵逼，两眼无神，不知从何说起，万般思绪，都化作一声叹息。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;第二种：夸夸其谈，像是口中架起了一把加特林，哒哒哒哒哒哒哒哒，还冒着蓝火。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6618257261410788&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8vRg6KcHicArndgScR8P2tM1EXUsfiboWR2xLnk41ibBkOVeicy6zGicfrEHwjb6UaC8yiafQT7B5aEyfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;482&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一种不用说了，好一点的面试官可能会引导你，会问一些提示性的问题，一步一步地带你渐入佳境，当然你要是胸中无点滴，那还是没救的，场面就异常地尴尬。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二种会把面试官整蒙了，或许你真的懂很多，很多细节也都清晰，但是你不能一股脑儿的都抛出来，这会显得你抓不住重点。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官也是人&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这点其实很关键，很多把面试官当成一个莫得感情的提问机器人，觉得他无所不能可以完全 get 到你的点，殊不知你引以为傲的细节回答，他可能觉得你在说蛇皮。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;是人就会有感情，就需要交流&lt;/span&gt;，好的面试官会把控整体进度，从拉家常开始，让场子热起来再一步一步的深挖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然也有一些面试官比较弱，这时候就需要你来&lt;span&gt;特意地流出一点空白，来让面试官涂鸦&lt;/span&gt;，让面试官感觉你这人就很舒服，你这波就稳了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然即使面对着把控全场的面试官你也得主动出击，每个人都有自己的擅长点，你需要引导面试官来询问你的长处。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;正确的回答姿势&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正确的回答姿势是 BFS（广度优先搜索） 而不是 DFS （深度优先搜索），什么意思呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是我们需要&lt;span&gt;先从大局上讲出需要设计的东西的重点，然后再等待面试官的继续提问，深挖&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要&lt;span&gt;揣摩面试官的心理&lt;/span&gt;，从他的提问可以看出他想要知道的重点是哪个方向的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如就拿 HashMap 来说，你&lt;span&gt;简单的&lt;/span&gt;把获取、写入、冲突处理、扩容啥的都说了，然后等待面试官接下来的提问，有可能会往线程安全方面深入，也有可能会往扩容方向再挖，比如引出 Redis 的 hash 扩容等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以说给面试官留提问的机会，抓住他的喜好或者说熟知的方向回答，这样如果你答得好，相互之间谈的来，面试官会对你高度认可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且在&lt;span&gt;说各设计要点的时候也要注意停顿，要留机会给面试官插话，让面试官充分参与你的设计&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是拿 HashMap 作为例子，比如你说了获取、写入、冲突之后稍作停顿，这时候大概率面试官还会问还有吗？让面试官有参与感，&lt;span&gt;让他感觉经过他的引导这个设计才逐步地完善&lt;/span&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8vRg6KcHicArndgScR8P2tM8VNMwtxvS6fX4cRvKgYLG1pElOGQMRNz4LibMNlIibJ8khibGA31twvcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然如果不问也没事，你停顿下继续说就行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;让面试成为一场技术交流，这是面试的最高境界&lt;/span&gt;，相信面试完了之后双方都会有意犹未尽的感觉，惺惺相惜就是这么来的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这种场景也不是这么容易碰到的，首先你和面试官得有相同方向的喜好，比如你对 JVM 有很深入的研究，而面试官对存储方面有很深入的研究，JVM 懂的不深，这样就碰不出火花了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以说会有很多人碰到这么个情况：我面这个公司一面挂，另一家公司面面超神，这都是很正常的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然你要是说你全能，那当我没说。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结一下面试技巧&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先要正确的看待面试官，你和面试官是同等的，不要一来就低声下气的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次回答问题需要抓住重点，不要一股脑儿的把你知道的都说了，要留白待面试官提问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要把控面试的节奏，往自己熟知的方向上引。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何写个消息中间件&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来咱们再看看如何写个消息中间件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们需要明确地提出消息中间件的几个重要角色，分别是生产者、消费者、Broker、注册中心。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简述下消息中间件数据流转过程，无非就是生产者生成消息，发送至 Broker，Broker 可以暂缓消息，然后消费者再从 Broker 获取消息，用于消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而注册中心用于服务的发现包括：Broker 的发现、生产者的发现、消费者的发现，当然还包括下线，可以说服务的高可用离不开注册中心。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后开始简述实现要点，可以同通信讲起：各模块的通信可以基于 Netty 然后自定义协议来实现，注册中心可以利用 zookeeper、consul、eureka、nacos 等等，也可以像 RocketMQ 自己实现简单的 namesrv （这一句话就都是关键词）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了考虑扩容和整体的性能，采用分布式的思想，像 Kafka 一样采取分区理念，一个 Topic 分为多个 partition，并且为保证数据可靠性，采取多副本存储，即 Leader 和 follower，根据性能和数据可靠的权衡提供异步和同步的刷盘存储。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且利用选举算法保证 Leader 挂了之后 follower 可以顶上，保证消息队列的高可用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也同样为了提高消息队列的可靠性利用本地文件系统来存储消息，并且采用顺序写的方式来提高性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可根据消息队列的特性利用内存映射、零拷贝进一步的提升性能，还可利用像 Kafka 这种批处理思想提高整体的吞吐。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;至此就差不多了，该说的要点说的都差不多了，面试官心里已经想，这人好像有点东西。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.925&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8vRg6KcHicArndgScR8P2tMiaMzrRQ9o5WGRZnZia5I5cNWbdcjaZUiarZWnZ5OaVialWzukMn0w3KVNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;440&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后可以深挖的点就很多了，比如提到的 Netty，各种注册中心就能问很多，比如各注册中心之间的选型对比等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你还提到了选举算法，所以可能会问 Bully 算法、Raft 算法、ZAB 算法等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你还提到了分区，可能会问这个分区和 RocketMQ 的队列有什么不同啊？具体分区要怎么实现？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后你提到顺序写，可能会问为什么要顺序写啊？你说的内存映射和零拷贝又是什么啊？那你知道 RocketMQ 和 Kafka 用了哪个吗?（这些我都分析过，可以看 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MjEyNTk1Ng==&amp;amp;mid=2247484278&amp;amp;idx=1&amp;amp;sn=952b97c166374ff271a14b4ab2e668e5&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;RocketMQ 和 Kafka 底层存储之那些你不知道的事&lt;/a&gt;）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然还有可能问各种细节，比如消息的写入如何存储、消息的索引如何生成等等，来深挖看你有没有看过消息中间件的源码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以问的还很多，这篇文章我也不可能每个点都延伸开说，&lt;span&gt;这些知识点还是得靠大家日积月累和平日的多加思考&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然日后的文章可以写一写今天提到的一些点，比如 Netty、选举算法啊，多种注册中心对比啊啥的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官想问的是什么&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再回到这个面试题，其实面试官想问的就是大方向上的设计，包括整体的架构、数据的流转和一些特性的把握，&lt;span&gt;所以对于这个问题他想听到的就是那些重点，而不是那些细节。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而继续的深挖取决于你回答这个问题时提出的各个关键词，对于面试官自身而言熟悉的词一抓到，他就已经知道下一步要问你什么了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以&lt;span&gt;在回答面试官的时候不仅要 get 到他的点，还得为之后的回答铺路&lt;/span&gt;，不会说的点不要提，擅长的点多提提。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前我已经提到了，这篇文章的重点其实不在于如何回答写一个消息中间件，而在于面试的技巧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为面试题千千万，而技巧掌握了那么千千万的面试题都适用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我还想提一下关于面试的一些个人看法，我个人是面试驱动学习型选手，我学习的动力就是面试，我享受面试官问我啥我都嘴角一翘微微一笑的那种不羁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是我不提倡那种纯粹背面试题的做法，学习是一个日积月累的过程，就像我每篇文末说的，从一点点到亿点点，又像我每篇开头都会提的，每个时代，都不会亏待会学习的人。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的面试驱动不仅仅是说为了面试而学习，还要以面试场景来学习，什么意思呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;学任何一种东西，都模拟一个面试官在你前面，让他从各种角度向你提问，驱动你全方位的理解一个知识点，这才是我说的面试驱动学习型选手。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以如果你看过我之前的文章会发现我经常会提出为什么呢，然后再作答。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一点要注意，&lt;span&gt;动手能力，这很关键。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Talk is cheap, show me the code。&lt;/p&gt;&lt;section&gt;&lt;mp-qa class=&quot;js_uneditable custom_select_card qa_iframe&quot; data-pluginname=&quot;insertquestion&quot; data-id=&quot;1558924558718599169&quot; data-bizuin=&quot;Mzg2MjEyNTk1Ng==&quot; data-title=&quot;兄弟萌，怎么说？&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>