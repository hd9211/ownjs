<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>bbc0e6f39437c3937e721bf0a579ab81</guid>
<title>2021 年仅剩 2 个月啦！抓紧啦！</title>
<link>https://toutiao.io/k/f430jea</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;34&quot; data-cropselx2=&quot;356&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;425&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav8Byw4xNoV6O2YGutfKmQLKuMZEIhBJF6MrQvoShfIAT6u3dXs6VZRzwSa2eT9jcekfaYuaOD6Hhw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>eb247f2c88e6d86fba625de7fedf1ece</guid>
<title>为视频会议开发实时、自动的手语检测</title>
<link>https://toutiao.io/k/gi028co</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;p&gt;每个人都应该可以使用视频会议，包括使用手语进行交流的用户。但是，由于大多数视频会议应用程序的过渡窗口都集中在大声说话的人身上，因此签名者很难“发言”，因此他们可以轻松有效地进行交流。在视频会议中启用实时手语检测具有挑战性，因为应用程序需要使用大量视频源作为输入来执行分类，这使得任务计算量很大。在某种程度上，由于这些挑战，手语检测的研究非常有限。&lt;/p&gt;&lt;p&gt;在“实时注册使用语言检测人体姿势估计”，在提出SLRTP2020和全世界展示ECCV2020，我们提出了一个实时手语检测模型，并证明它是如何被用来提供视频会议系统的机制来识别人以活动发言人的身份签名。&lt;/p&gt;&lt;p&gt;&lt;img data-fileid=&quot;100000437&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceHLMM8iamgcZsLwBBcAFIc7RlUCJaEibOYNx4AeufZcmYzDUNMJza99gQu2FQBlTNvIDCJZ1cRY6qHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;em&gt;我们的模型&lt;/em&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;为了为各种视频会议应用程序提供实时工作解决方案，我们需要设计一个轻量级的模型，该模型易于“即插即用”。之前在客户端集成视频会议应用程序模型的尝试证明了消耗更少 CPU 周期的轻量级模型的重要性，以最大限度地减少对通话质量的影响。为了降低输入维度，我们将模型所需的信息与视频隔离，以便对每一帧进行分类。&lt;/p&gt;&lt;p&gt;由于手语涉及用户的身体和手部，我们首先运行姿势估计模型PoseNet。这大大减少了从整个高清图像到用户身体上的一小部分地标的输入，包括眼睛、鼻子、肩膀、手等。我们使用这些地标来计算帧到帧的光流，从而量化供模型使用的用户动作，而不保留用户特定的信息。每个姿势都根据人的肩宽进行标准化，以确保模型在距离相机一定距离的范围内照顾到签名的人。然后，在传递给模型之前，光流通过视频的帧速率进行归一化。&lt;/p&gt;&lt;p&gt;为了测试这种方法，我们使用了德语手语语料库(DGS)，其中包含人们签名的长视频，并包含指示签名发生在哪些帧中的跨度注释。作为一个简单的基线，我们训练了一个线性回归模型来预测一个人何时使用光流数据进行签名。该基线达到了约 80% 的准确度，每帧仅使用约 3 微秒（0.000003 秒）的处理时间。通过将前 50 帧的光流作为线性模型的上下文，它能够达到 83.4%。&lt;/p&gt;&lt;p&gt;为了概括上下文的使用，我们使用了长短期记忆(LSTM) 架构，其中包含之前时间步长的记忆，但没有回溯。使用单层 LSTM，然后是线性层，该模型的准确率高达 91.5%，每帧处理时间为 3.5 毫秒（0.0035 秒）。&lt;/p&gt;&lt;p&gt;&lt;img data-fileid=&quot;100000436&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceHLMM8iamgcZsLwBBcAFIc7RNbzkbO4zpHIC7NBff3bYd9AYC0RookfzzXiapZGEicDf7Vvl7TsyNeAA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;em&gt;概念证明&lt;/em&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;一旦我们有了一个有效的手语检测模型，我们就需要设计一种方法来使用它来触发视频会议应用程序中的主动发言者功能。我们开发了一个轻量级、实时、手语检测网络演示，它连接到各种视频会议应用程序，并可以在用户签名时将其设置为“发言人”。此演示利用PoseNet快速人体姿态估计和使用tf.js在浏览器中运行的手语检测模型，使其能够实时可靠地工作。&lt;/p&gt;&lt;p&gt;当手语检测模型确定用户正在签名时，它会通过虚拟音频电缆传递超声波音频，任何视频会议应用程序都可以检测到，就好像签名用户在“说话”一样。音频以 20kHz 的频率传输，这通常超出人类的听觉范围。因为视频会议应用程序通常将音频“音量”检测为说话而不是仅检测语音，这使应用程序误认为用户正在说话。&lt;/p&gt;&lt;p&gt;&lt;img data-fileid=&quot;100000438&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceHLMM8iamgcZsLwBBcAFIc7R182QIdAJgibNUxQYeqHhZbX02a52BicvqNibhOT2ZGnfBrGoB8W6tAr6A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;p&gt;您可以立即试用我们的实验演示！默认情况下，该演示充当手语检测器。该训练码和模型，以及在网络演示 源代码可以在GitHub上。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;em&gt;演示&lt;/em&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;在下面的视频中，我们演示了如何使用模型。请注意左上角的黄色图表，它反映了模型在检测到该活动确实是手语方面的信心。当用户签名时，图表值上升到接近 100，当她停止签名时，它下降到零。这个过程是实时发生的，每秒 30 帧，这是所用相机的最大帧速率。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;em&gt;用户反馈&lt;/em&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;为了更好地了解演示在实践中的效果，我们进行了一项用户体验研究，参与者被要求在视频会议期间使用我们的实验演示，并像往常一样通过手语进行交流。他们还被要求互相签名，并在说话的参与者身上测试说话者的切换行为。参与者积极回应，手语被检测并被视为可听语音，演示成功识别了签名与会者并触发了会议系统的音频表图标以将焦点吸引到签名与会者。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;em&gt;结论&lt;/em&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;我们相信每个人都应该可以访问视频会议应用程序，并希望这项工作是朝着这个方向迈出的有意义的一步。我们已经展示了如何利用我们的模型使签名者能够更方便地使用视频会议。&lt;/p&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7366eaa130b0d59ff821f204eb2c7deb</guid>
<title>用状态机实现《394. 字符串解码》</title>
<link>https://toutiao.io/k/u7klht6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content&quot;&gt;

&lt;blockquote class=&quot;wp-block-quote&quot;&gt;&lt;p&gt;给定一个经过编码的字符串，返回它解码后的字符串。&lt;/p&gt;&lt;p&gt;编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。&lt;/p&gt;&lt;p&gt;你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。&lt;/p&gt;&lt;p&gt;此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br/&gt;输入：s = “3[a]2[bc]”&lt;br/&gt;输出：”aaabcbc”&lt;br/&gt;&lt;br/&gt;示例 2：&lt;br/&gt;输入：s = “3[a2[c]]”&lt;br/&gt;输出：”accaccacc”&lt;br/&gt;&lt;br/&gt;示例 3：&lt;br/&gt;输入：s = “2[abc]3[cd]ef”&lt;br/&gt;输出：”abcabccdcdcdef”&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;示例 4：&lt;br/&gt;输入：s = “abc3[cd]xyz”&lt;br/&gt;输出：”abccdcdcdxyz”&lt;/p&gt;&lt;cite&gt;394. 字符串解码 –&amp;gt; &lt;a href=&quot;https://leetcode-cn.com/problems/decode-string&quot; data-type=&quot;URL&quot; data-id=&quot;https://leetcode-cn.com/problems/decode-string&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;传送门&lt;/a&gt;&lt;/cite&gt;&lt;/blockquote&gt;



&lt;p&gt;今天做到这么一道题目，这个题目我一看，就想起了大学时候学习的编译原理，这个字符串解码，显然是“一个语言”，只不过这个语言的语法特别简单，只有字母，中括号和数字。我们要实现的就是，做一个这个“语言”的解释器，然后打印语句的结果。&lt;/p&gt;



&lt;p&gt;既然是语言，我们就按照语言的方式来解决。这个语言里，只有四种 TOKEN（这是个专有术语），数字，左中括号，右中括号，字母，很容易划分 TOKEN，因为每种 TOKEN 的边界都是不同的字符。&lt;/p&gt;



&lt;p&gt;语法非常简单，就是数字用于修饰一个字母串，中括号用于分割被修饰的字母串。只有唯一的操作，就是“打印”，有两种状态，“直接打印”，“重复打印”。于是我画了一个状态机：&lt;/p&gt;



&lt;div class=&quot;wp-block-image&quot;&gt;&lt;figure class=&quot;aligncenter size-full&quot;&gt;&lt;a href=&quot;https://sexywp.com/wp-content/uploads/2021/10/状态机.png&quot;&gt;&lt;img loading=&quot;lazy&quot; src=&quot;https://sexywp.com/wp-content/uploads/2021/10/状态机.png&quot; alt=&quot;&quot; class=&quot;wp-image-1099&quot; srcset=&quot;https://sexywp.com/wp-content/uploads/2021/10/状态机.png 529w, https://sexywp.com/wp-content/uploads/2021/10/状态机-300x180.png 300w&quot; sizes=&quot;(max-width: 529px) 100vw, 529px&quot;/&gt;&lt;/a&gt;&lt;figcaption&gt;状态机&lt;/figcaption&gt;&lt;/figure&gt;&lt;/div&gt;



&lt;p&gt;在初始状态下，遇到字母就直接打印，遇到数字，马上进入重复打印的流程，遇到右括号的时候，开始将遇到的模式重复打印。并退出重复打印的流程。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;python&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;def decodeString(self, s: str) -&amp;gt; str:
    res = &#x27;&#x27;
    count = 0
    p = &#x27;&#x27;
    state = &#x27;print&#x27;
    for c in s:
        if state == &#x27;print&#x27; and ord(&#x27;a&#x27;) &amp;lt;= ord(c) &amp;lt;= ord(&#x27;z&#x27;):
            res += c
        elif ord(&#x27;1&#x27;) &amp;lt;= ord(c) &amp;lt;= ord(&#x27;9&#x27;):
            count = count * 10 + int(c)
        elif c == &#x27;[&#x27;:
            state = &#x27;start&#x27;
        elif c == &#x27;]&#x27;:
            res += p * count
            count, p = 0, &#x27;&#x27;                
            state = &#x27;print&#x27;
        elif state == &#x27;start&#x27; and ord(&#x27;a&#x27;) &amp;lt;= ord(c) &amp;lt;= ord(&#x27;z&#x27;):
            p += c
    return res&lt;/pre&gt;



&lt;p&gt;写出来一测，我才发现，原来括号是可以嵌套的。上面的代码对于嵌套的括号是没法正确处理的。并且通过编写这个代码，发现我识别的两个状态似乎也有点错误，这个语言太简单了，状态的切换也有点多于。&lt;/p&gt;



&lt;p&gt;我发现，整个“语言”其实是一个递归的结构，可以表达成 “字母串 = 字母串 + 字母串 × 重复次数”，中括号其实就是字母串的分割边界。每遇到一个左括号，字母串的处理就深入一层，遇到一个右括号就跳出一层，只要用一个栈就可以轻松解决了。栈里要记录的东西，其实就是外层的前面一半字母串，以及内层需要重复的次数。这样，代码就改成了：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;python&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;def decodeString(self, s: str) -&amp;gt; str:
    res = &#x27;&#x27;
    count = 0
    stack = []
    for c in s:
        if ord(&#x27;a&#x27;) &amp;lt;= ord(c) &amp;lt;= ord(&#x27;z&#x27;):
            res += c
        elif ord(&#x27;0&#x27;) &amp;lt;= ord(c) &amp;lt;= ord(&#x27;9&#x27;):
            count = count * 10 + int(c)
        elif c == &#x27;[&#x27;:
            stack.append((res, count))
            res, count = &#x27;&#x27;, 0
        elif c == &#x27;]&#x27;:
            ctx_res, ctx_count = stack.pop()
            res = ctx_res + res * ctx_count
    return res&lt;/pre&gt;



&lt;p&gt;反倒更简洁了，我们需要求的是最外层的字母串，遇到左括号就压栈，遇到右括号，出栈的同时，做重复计算。栈里保留了当前字母串需要重复的次数。&lt;/p&gt;



&lt;p&gt;这个算法的时间复杂度是O(n)，空间复杂度也是O(n)。当然，到这里，想要写出这个算法的递归算法也是非常简单：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;python&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;def decodeString(self, s: str) -&amp;gt; str:
    def process() -&amp;gt; str:
        nonlocal i
        res = &#x27;&#x27;
        count = 0
        while i &amp;lt; len(s):
            c = s[i]
            i += 1
            if ord(&#x27;a&#x27;) &amp;lt;= ord(c) &amp;lt;= ord(&#x27;z&#x27;):
                res += c
            elif ord(&#x27;0&#x27;) &amp;lt;= ord(c) &amp;lt;= ord(&#x27;9&#x27;):
                count = count * 10 + int(c)
            elif c == &#x27;[&#x27;:
                res += process() * count
                count = 0
            elif c == &#x27;]&#x27;:
                return res
        return res
    i = 0
    return process()&lt;/pre&gt;



&lt;p&gt;— END —&lt;/p&gt;
&lt;h3&gt;相关阅读&lt;/h3&gt;&lt;/div&gt;


&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>009891959777731fe9abab76cf86f63f</guid>
<title>幂等设计详解</title>
<link>https://toutiao.io/k/qv6mpuj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;h1&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img data-fileid=&quot;100005159&quot; data-ratio=&quot;0.6506849315068494&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RQv8vncPm1UibHPAanTaZmNVW2yn5bYF7O5pGDH1QmUNa2XCUichFvjlOqV5sfnlHaKRALYlrlRCpZygon1I3PIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;146&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;Tech&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h1&gt;&lt;section data-mpa-template=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;strong&gt;导读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;img data-ratio=&quot;0.04938271604938271&quot; data-type=&quot;png&quot; data-w=&quot;162&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mflphQBJic3STjs5EXib7E8mUTyW8OOibkBv0A2RCNVdryhNX6icoDx1nzX2h4hcMVPMctYfUcqLiaquTwUnRqlJSbg/640?wx_fmt=png&quot; data-fileid=&quot;100005165&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p&gt;&lt;span&gt;本文主要从研发人员的角度，结合研发人员日常常见的各类业务场景，从经典系统框架的每一层入手分析幂等处理的时机。希望通过这篇文章的分析，让开发者在日常开发中对幂等的处理不再陌生。抓住导致请求、接口不幂等的本质，在工作中避免再陷入这个陷阱中。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;幂等、幂等性这词，作为一个研发人员是再熟悉不过的，那是否有深入思考过幂等产生的背景、为什么需要幂等，如何做才是幂等的？今天将结合业务场景及请求的过程来分析解决幂等（性）的方法。&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-id=&quot;98782&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;01&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;263:265&quot;&gt;&lt;strong&gt;概念&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;幂等这&lt;/span&gt;&lt;span&gt;个概念，是一个数学上的概念，即：&lt;/span&gt;&lt;span&gt;f……(f(f(x))) = f(x)。&lt;/span&gt;&lt;span&gt;用在计算机领域，指的是系统里的接口或方法对外的一种承诺，使用相同参数对同一资源重复调用某个接口或方法的结果与调用一次的结果相同。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-id=&quot;98782&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;02&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;263:265&quot;&gt;&lt;strong&gt;业务场景&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从业务场景上来说，如：现在互联网电商的下单服务，同一个用户在短时间内调用某一个下单服务，只能下单成功一次；银行账户之间的转账，A账户给B账户转账，无论系统出现什么问题或故障，也只能转账成功一次；&lt;strong&gt;前端页面对相同表单的内容多次向后端发起提交请求，后端只能给出一个相同的结果等都属于幂等的范畴。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;试想一下，如果提供的这些服务不是幂等的，客户在下单时由于网络不稳定或是连续点了几次下单按钮，实际客户只下了一单，结果系统里给客户生成了多单，那平台/商家将是无法承受的，如果被“羊毛党”盯上，损失是无可估量的；银行之间的转账，A账户本来实际给B账户只转了一百万，结果B账户收到了几百万，这在业务上是不可接受的。分析这些业务场景，开发者发现，无论是下单服务、转账服务还是表单提交都是一个个业务请求，提供这些业务服务的接口或方法都应该保证无论服务是超时、重试或有故障等异常情况，都要满足业务上的处理结果是正确的。&lt;/span&gt;&lt;strong&gt;业务上的一次或多次请求，最终的处理结果是一致的，即：在一定时间内，服务的幂等其实就是请求的幂等。&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-id=&quot;98782&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;03&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;323:264&quot;&gt;&lt;strong&gt;架构分析&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;从系统架构上进行分析，幂等该在哪一层去做，怎么做？&lt;/p&gt;&lt;p&gt;&lt;img data-fileid=&quot;100005161&quot; data-ratio=&quot;2.2857142857142856&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RQv8vncPm1VISeAdubuD3AesiaCOic8mtI8ka5UIklZFmqKX6Bu8Kwic6B3XAdGtcobbkat7E8KXOQWvZBO6v2Zqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;189&quot;/&gt;&lt;/p&gt;&lt;p&gt;图1  经典系统框架图&lt;/p&gt;&lt;p&gt;上图为一个最常见的经典系统框架图，Web端发起一个请求到后端，幂等该在哪一层来处理呢？不妨一层一层的分析。&lt;/p&gt;&lt;p&gt;Nginx是否需要做幂等，Nginx的主要功能是做Web服务器、反向代理、负载均衡等，把请求转发到后端的服务器上，本身不参与具体的业务，所以Nginx是不需要做幂等处理的；Gateway是负责权限校验、安全防御、认证鉴权、流量控制、协议转换、日志审计、监控等，本身也不含对任何业务的处理，所以其也不需要做幂等处理；Service层通常是对业务逻辑进行处理、编排，可能会改变数据，但对于数据的改变结果，最终也还是需要通过数据访问层，写入到数据库，所以Service层也不需要做数据幂等；DAO层主要是和数据库交互，把Service层的结果写入数据库，对Service层提供读取、写入数据库的功能。&lt;/p&gt;&lt;p&gt;在写入数据库的时候，针对每一次的写入，可能返回不同的结果，此时就需要按场景进行具体的分析对待；&lt;strong&gt;DataBase层，主要提供数据的存储，并不参与具体的业务逻辑计算。所以，通过对该架构的每一层的功能分析，得出对于请求的幂等处理，需要在DAO层做处理，以便保证多次请求和一次请求的结果是一致的。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;98782&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;301:353&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;04&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;数据库操作分析&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;通过上面的分析，得出幂等需要在DAO层来处理，再进一步分析，得出DAO层的操作主要就是CRUD。下面逐一对每一种操作分析是否需要做幂等，以及怎么做。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;R&lt;/strong&gt;&lt;strong&gt;（read）：&lt;/strong&gt;对应的操作SQL语句为select。只要查询条件不变，在一定的时间内，执行一次和执行多次返回的结果肯定是相同的，所以其本身是幂等的，不需要再做处理。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt; = &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;查询一次或多次结果是一致的，所以是幂等的。&lt;/span&gt;&lt;p&gt;&lt;strong&gt;C&lt;/strong&gt;&lt;strong&gt;（create）：&lt;/strong&gt;对应的操作SQL语句为insert。此时，需要分情况，如果用到的数据库主键为数据库自增，不考虑业务主键防重的情况下，每一次写入数据库就不是幂等的，所以为了保证幂等，需要在数据insert前做业务防重或是在数据库表上对业务主键加唯一索引。如果数据库主键不是自增，是由业务系统写入的，需要在业务系统里把数据库主键和业务主键做一对一映射，或是由独立服务提供数据库主键和业务主键的映射关系，保证多次请求获取到的数据库主键和业务主键是一致的，确保写入数据库操作是幂等的。综合来说，就是相同的数据多次写入数据库后，能否保证只有一条数据。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;user&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt;,age,sex,ts) &lt;span class=&quot;code-snippet__keyword&quot;&gt;values&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;,‘male’,&lt;span class=&quot;code-snippet__number&quot;&gt;2021&lt;/span&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;-07&lt;/span&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;-20&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;22&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;23&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;U&lt;/strong&gt;&lt;strong&gt;（update）：&lt;/strong&gt;对应的操作SQL语句为update。更新操作时，一定是要用绝对值进行更新操作，而不要用相对值进行更新，相对值更新可能导致更新操作不幂等。&lt;/p&gt;&lt;p&gt;幂等：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;update&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;set&lt;/span&gt; age = &lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt; = &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;非幂等：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;update&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;set&lt;/span&gt; age++ &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt; = &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;D&lt;/strong&gt;&lt;strong&gt;（delete）：&lt;/strong&gt;对应的操作SQL语句为delete。删除操作时，如果删除的是一个范围，生产上最好是禁止该类操作；比较推荐的做法是把按范围操作删除转换为先按范围查询，再按查询的主键进行删除。而且按范围删除的操作不是幂等的。&lt;/p&gt;&lt;p&gt;幂等：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt; = &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;非幂等：&lt;span&gt;该类操作要禁止。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; （&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;desc&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;98782&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;05&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;常见业务场景&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;保证幂等的实现方式有多种，此处例举几类常见的业务场景，在实际应用中，根据业务场景进行选用。&lt;/p&gt;&lt;p&gt;1. &lt;strong&gt;前端页面提交时，页面token机制。&lt;/strong&gt;进入页面时，从服务器获取token，在服务器端把token进行存储，提交时把token带到服务器端进行验证；常见的处理流程如下：&lt;/p&gt;&lt;p&gt;&lt;img data-fileid=&quot;100005162&quot; data-ratio=&quot;0.7021276595744681&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RQv8vncPm1XT1hWfSl2Gk8flusEIDldPdkaPj3ZP0yftqxN7P7hKDIlEwtZpC5Myw3NvMPM03atVicE8TNkSaNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;940&quot;/&gt;&lt;/p&gt;&lt;p&gt;图2  页面token机制处理流程&lt;/p&gt;&lt;ol start=&quot;2&quot; type=&quot;1&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;乐观锁机制&lt;/strong&gt;，使用数据库的版本号实现乐观锁，数据库更新时，判断版本号是否与查询时保持一致，一致更新成功，否则更新失败；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;select+insert&lt;/strong&gt;，数据写入前，先查询数据是否存在，存在直接返回，不存在则写入数据，保证写入数据库的数据正确性；常用于并发不高的一些后台系统或是防止任务的重复执行；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;悲观锁机制&lt;/strong&gt;，&lt;span&gt;一般id为主键或唯一索引，仅锁定当前记录；&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;1234&#x27;&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;update&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;去重表&lt;/strong&gt;，每一次写入或更新业务表时，先查询去重表是否已经存在记录，再操作业务表。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;数据库唯一索引&lt;/strong&gt;，为业务表建立唯一索引，避免业务数据多次写入；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;状态机&lt;/strong&gt;，业务状态在变更之前是有条件的，必须按设定的状态条件进行更新；&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;在实际开发中，保证提供的接口或服务的幂等（性），是一个最基本的技术要求，希望通过该分析，能对还未理解幂等（性）的研发人员有所帮助。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6772877728745c66a1a2edbce9a8eb29</guid>
<title>漫画图解 SSH</title>
<link>https://toutiao.io/k/2odttqb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-hnrfcf&quot; options=&quot;[object Object]&quot;&gt;&lt;p&gt;OpenSSL 本身是一个软件库，这个软件被广泛的应用在系统服务器当中，他的主要功能是在网络通信的过程中，保证数据的一致性以及数据传输过程中的安全性。软件本身是由C语言编写，这使得他具备了跨平台的特性，OpenSSL 主要包括如下三大功能:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;加解密：&lt;/b&gt;OpenSSL 具有丰富的加解密算法库，支持不同的加解密方式以及存储秘钥的方式，如对称加密，非对称加密，信息摘要等内容&lt;/li&gt;&lt;li&gt;&lt;b&gt;SSL 协议：&lt;/b&gt;OpenSSL 实现了 SSL 协议的的 SSLv2 和 SSLv3，支持了其中绝大部分算法协议&lt;/li&gt;&lt;li&gt;&lt;b&gt;证书操作&lt;/b&gt;：OpenSSL 自身提供了一种文本数据库，支持证书的管理功能，包括证书秘钥的产生、请求产生、证书签发、吊销和验证等功能。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;加解密的几种形式&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;加解密的形式通常分为以下几种：&lt;/p&gt;&lt;p&gt;下面我们挨个来看这些加密算法。&lt;/p&gt;&lt;p&gt;&lt;b&gt;对称算法&lt;/b&gt;&lt;/p&gt;&lt;p&gt;对称算法是指信息的发送方和接收方使用同一份秘钥去加解密数据。AES、DES 等都是常用的对称加密算法。&lt;/p&gt;&lt;p&gt;对称算法的优点是加解密的速度快，适合对于大数据量加密。缺点是因为只有一个秘钥，所以秘钥管理困难，只要暴露了，就很容易破解加密后的信息。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5b614d1b24564d7220e18fd000a27dc1_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1208&quot; data-rawheight=&quot;550&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-5b614d1b24564d7220e18fd000a27dc1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1208&quot; data-rawheight=&quot;550&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-5b614d1b24564d7220e18fd000a27dc1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-5b614d1b24564d7220e18fd000a27dc1_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;非对称算法&lt;/b&gt;&lt;/p&gt;&lt;p&gt;非对称算法是指信息的发送方和接收方分别持有一份秘钥。一份公开发布，称公钥；一份私有，称秘钥。秘钥可以导出对应的公钥。RSA、DSA 等是常用的非对称加密算法。&lt;/p&gt;&lt;p&gt;一般情况下，信息发送者用公开密钥去加密，而信息接收者则用私用密钥去解密。公钥机制灵活，但加密和解密速度却比对称密钥加密慢得多。不同的使用场景下，也会衍生出其他的使用方法，比如私钥加密，公钥解密。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-63aa3b8bb3a1cccc8ce974e95503cff5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1138&quot; data-rawheight=&quot;1056&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-63aa3b8bb3a1cccc8ce974e95503cff5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1138&quot; data-rawheight=&quot;1056&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-63aa3b8bb3a1cccc8ce974e95503cff5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-63aa3b8bb3a1cccc8ce974e95503cff5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;RSA 加解密算法&lt;/b&gt;&lt;/p&gt;&lt;p&gt;RSA 是一个流行的非对称加密算法， 生成公私钥内容如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;# 生成秘钥
OpenSSL genrsa -out test.key 1024
# 从秘钥中导出公钥
OpenSSL rsa -in test.key -pubout -out test_pub.key
# 公钥加密文件
echo &quot;test&quot; &amp;gt; hello
OpenSSL rsautl -encrypt -in hello -inkey test_pub.key -pubin -out hello.en
# 私钥解密文件
OpenSSL rsautl -decrypt -in hello.en -inkey test.key -out hello.de&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;不可逆加密算法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;不可逆加密算法主要用于校验文件的一致性，摘要算法就是其中一种。常用的摘要算法有 MD5。&lt;/p&gt;&lt;p&gt;&lt;b&gt;摘要算法&lt;/b&gt;&lt;/p&gt;&lt;p&gt;摘要算法用来把任何长度的明文以一定规则变成固定长度的一串字符。在做文件一致性校验的时候，我们通常都是先使用摘要算法，获得固定长度的一串字符，然后对这串字符进行签名。接收者接收到文件后，也会执行一遍摘要算法后再签名。前后数据一致，则表示文件在传输过程没有被窜改。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-99d8e2e7b4a06f49b43f1adf318c2e33_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;438&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-99d8e2e7b4a06f49b43f1adf318c2e33_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;438&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-99d8e2e7b4a06f49b43f1adf318c2e33_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-99d8e2e7b4a06f49b43f1adf318c2e33_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;base64&lt;/b&gt;&lt;/p&gt;&lt;p&gt;特别需要注意的是，&lt;b&gt;base64 不是加密算法，它是编码方式&lt;/b&gt;。它可以方便传输过程 ASCII 码和二进制码之间的转换。类似于图片或者一些文本协议，在传输过程中通常可以使用 base64 转换成二进制码进程传输。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;SSH 加密流程&lt;/b&gt;&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-51e9d5b45d53977bbe5f2d3ad5a08794_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1069&quot; data-rawheight=&quot;1266&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-51e9d5b45d53977bbe5f2d3ad5a08794_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1069&quot; data-rawheight=&quot;1266&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-51e9d5b45d53977bbe5f2d3ad5a08794_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-51e9d5b45d53977bbe5f2d3ad5a08794_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;客户端发送自己的密钥 ID 给服务器端&lt;/li&gt;&lt;li&gt;服务器在自己的 authorized_keys 文件中查找是否存在此 ID 的公钥&lt;/li&gt;&lt;li&gt;如果有，则服务器生成一个随机数，用当前 ID 的公钥加密&lt;/li&gt;&lt;li&gt;服务器将加密后的随机数发给客户端&lt;/li&gt;&lt;li&gt;客户端用私钥解密该随机数，然后在本地为随机数做 MD5 加密&lt;/li&gt;&lt;li&gt;客户端将该 MD5 哈希发给服务器端&lt;/li&gt;&lt;li&gt;服务器端为一开始自己生成的随机数也做一个 MD5 哈希，然后用通讯通道“公共的密钥”将该哈希加密，再跟客户端发来的内容进行对比。如果双方内容一致，则通过验证，开放访问权限给客户端&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;深入了解 OpenSSL 后，其对密码学技术的功能支持会让你激动不已，如果有兴趣可以更加深入地了解其中的内容以及试验不同加密方式在不同场景中的使用。&lt;/p&gt;&lt;p&gt;&lt;b&gt;推荐阅读：&lt;/b&gt;&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/604/%25E6%259C%258D%25E5%258A%25A1%25E5%2599%25A8%25E6%25A0%2587%25E9%2585%258D%2520SSH%2520%25E5%258D%258F%25E8%25AE%25AE%25EF%25BC%258C%25E4%25BD%25A0%25E4%25BA%2586%25E8%25A7%25A3%25E5%25A4%259A%25E5%25B0%2591%25EF%25BC%259F.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic1.zhimg.com/v2-c77779a3b76885f8efcd826f928efbb0_180x120.jpg&quot; data-image-width=&quot;1080&quot; data-image-height=&quot;567&quot; data-text=&quot;服务器标配 SSH 协议，你了解多少？&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/640/%25E5%25AE%259E%25E6%2593%258D%25E7%25AC%2594%25E8%25AE%25B0%25EF%25BC%259A%25E4%25B8%25BA%2520NSQ%2520%25E9%2585%258D%25E7%25BD%25AE%25E7%259B%2591%25E6%258E%25A7%25E6%259C%258D%25E5%258A%25A1%25E7%259A%2584%25E5%25BF%2583%25E8%25B7%25AF%25E5%258E%2586%25E7%25A8%258B.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic4.zhimg.com/v2-f18a6f76571f135e62db962fa4b73587_180x120.jpg&quot; data-image-width=&quot;1011&quot; data-image-height=&quot;593&quot; data-text=&quot;实操笔记：为 NSQ 配置监控服务的心路历程&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>