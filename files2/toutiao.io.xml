<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>d1f5af17095f5c420f20fc6b3b5ab0f1</guid>
<title>解码无代码/低代码创业圈子及其玩家</title>
<link>https://toutiao.io/k/dzgh03u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;10年前，互联网上的大多数网络和应用程序设计都依赖于开发人员，他们不得不夜以继日地工作来让代码能够跑起来。而今天，任何拥有电脑和互联网接入的人都可以使用极其强大的应用程序——无代码和低代码工具来构建网站、应用程序或内部工具。它不仅限于网站和应用程序，今天即使没有深厚IT功底的人也可以在网上经营整个公司，建立电子商务业务，甚至创办银行！例如，最近年经常性收入达到500万美元的Nuage Stays公司，就是使用Airtable、Zapier等&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.makerpad.co/stories/nadim-el-asmar-boostrapping-to-5m-with-no-code-tools&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;低代码工具构建&lt;/a&gt;&lt;/u&gt;的，用于管理预订、收集和存储数据、创建日历等。这个崇尚新技术的时代并未把它给落下， 已经有不少人记录了这个趋势， 并有越来越多的人在关注这个趋势： &lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b8dd5c7f482eba3dfe2f36fd37ea911e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1548&quot; data-rawheight=&quot;750&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-b8dd5c7f482eba3dfe2f36fd37ea911e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1548&quot; data-rawheight=&quot;750&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-b8dd5c7f482eba3dfe2f36fd37ea911e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b8dd5c7f482eba3dfe2f36fd37ea911e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;br/&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;无代码/低代码意味着什么？它是&lt;/b&gt;一种编程方法和运动，不一定涉及编写代码，而是与图形用户界面（GUI）一起，人们可以使用模板、拖放函数、会话界面和逻辑序列来实现任何数字产品。 &lt;/p&gt;&lt;p&gt;这一新兴类别是关于&lt;b&gt;软件开发的民主化&lt;/b&gt;，释放数字化给任何能够使用电脑、电话和互联网的人带来的潜力。 &lt;/p&gt;&lt;p&gt;让我们明确一点：无代码和低代码工具不是为了消除代码或工程师。它们是为了让程序员的生活更轻松，同时向每个人开放访问权限，让每个人都成为“公民开发者”。他们是为了抽象代码的复杂性，专注于设计和逻辑。这意味着不再需要做无聊、重复的以及和项目无关的任务。 &lt;/p&gt;&lt;p&gt;通过这些工具，世界任何地方的销售/营销/产品/运营团队和创始人都可以构建复杂的工作流程和应用程序，而不需要任何技术知识。 &lt;/p&gt;&lt;p&gt;&lt;b&gt;投资界似乎也注意到了这一趋势&lt;/b&gt;：仅在上个月 , 就宣布了多起非常大的融资： &lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.forbes.com/sites/alexkonrad/2021/03/08/zapier-bootstraps-to-5-billion-valuation/%3Fsh%3D34042ad71c8e&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt; Zapier 第二轮投资前估值为5&lt;/a&gt;0亿美元；&lt;/u&gt; &lt;/li&gt;&lt;li&gt;&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//techcrunch.com/2021/02/17/low-code-focused-outsystems-raises-150m-at-a-9-5b-valuation/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;OutSystems获得 1.5亿美元融资，估值达到95亿美元&lt;/a&gt;&lt;/u&gt; &lt;/li&gt;&lt;li&gt;&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//techcrunch.com/2021/02/22/creatio-raises-68m-as-the-low-code-space-keeps-attracting-huge-checks/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Creatio第一轮即获得6800万美元融资。 &lt;/a&gt;&lt;/u&gt; &lt;/li&gt;&lt;li&gt;&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//techcrunch.com/2021/02/22/rows-formerly-dashdash-raises-16m-to-build-and-populate-web-apps-using-only-spreadsheet-skills/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rows获得1600万B轮融资&lt;/a&gt;&lt;/u&gt;, &lt;/li&gt;&lt;li&gt;&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//venturebeat.com/2021/02/17/oribi-raises-15-5-million-to-challenge-google-analytics-with-no-code-marketing-insights/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Oribi 火的1550万美元B轮融资&lt;/a&gt;&lt;/u&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//venturebeat.com/2021/02/17/oribi-raises-15-5-million-to-challenge-google-analytics-with-no-code-marketing-insights/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;等等...势头如此强劲，以至于有些人认为这是一种&lt;/a&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//techcrunch.com/2020/07/21/tracking-the-growth-of-low-code-no-code-startups/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;热潮&lt;/a&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//venturebeat.com/2021/02/17/oribi-raises-15-5-million-to-challenge-google-analytics-with-no-code-marketing-insights/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;，与我们近年来看到的&lt;/a&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//venturebeat.com/2021/02/17/oribi-raises-15-5-million-to-challenge-google-analytics-with-no-code-marketing-insights/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;聊天机器人、ICOs-和大麻相关的&lt;/a&gt;&lt;/u&gt;爆炸相当... &lt;/p&gt;&lt;p&gt;在和使用它们的建造者和制造商一起使用了生态系统中的数百种工具，我们通常将这一类别分为： &lt;/p&gt;&lt;ol&gt;&lt;li&gt;无&lt;b&gt;代码&lt;/b&gt;：这包括 &lt;/li&gt;&lt;ol&gt;&lt;li&gt;字面上零代码的工具，提供给那些不知道也永远不想知道软件如何工作的人。他们只是想用它，且看起来不错就行。&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//onuniverse.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;（例如Universe，Gumroad&lt;/a&gt;等）。这些工具在设计上也不会太复杂。这个领域的公司感觉就像变魔法一样。你可以在15分钟内在手机上建立一个网站，或者在几分钟内以灵活的动态方式将Stripe计费带到你的产品中。它们通常易于使用，客户支持也很给力，大多数公司都有充满活力的非技术人员社区。 &lt;/li&gt;&lt;li&gt;工具和软件，面向那些善于系统思考并熟悉&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//technically.substack.com/p/whats-an-api&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;应用程序编程接口（API&lt;/a&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//technically.substack.com/p/whats-an-api&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;）&lt;/a&gt;的人（&lt;/b&gt;例如Airtable、Zapier、Webflow等）。这些工具确实有能力配置得更复杂，如果你想深入的话，还包括代码元素。这一细分市场不仅有趣，而且已经挤满了估值超过1亿美元的公司，它正迅速成为生态系统的滋生地。想想Atlassian作为一个完整的生态系统都做了什么，然后将其应用于&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.nocodelytics.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Webflow&lt;/a&gt;&lt;/u&gt; 或者 &lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//microsaasidea.substack.com/p/issue7-building-1k-10k-mrr-micro&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Airtable ecosystems&lt;/a&gt;&lt;/u&gt;. &lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;低代码：&lt;/b&gt;面向设计师、产品人员、创始人和工程师的工具和软件，他们希望找到更快、更好、更容易、更便宜的方法来构建和扩展，而不放弃代码带来的定制。（例如&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.8base.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;8base&lt;/a&gt;&lt;/u&gt;, &lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//retool.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Retool&lt;/a&gt;&lt;/u&gt;, &lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//internal.io/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Internal&lt;/a&gt;&lt;/u&gt;等）。这一领域的公司仍然需要一定程度的技术专长，但通常支持用户提高生产力，并在日常任务上节省大量时间。 &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;b&gt;深入挖掘，这些工具存在于哪些行业/垂直行业&lt;/b&gt;？我们花了几个月的时间试图回答这个问题，列出了145家独特的公司和12个需要我们关注的类别。 &lt;/p&gt;&lt;p&gt;&lt;b&gt;我们的计划是定期更新这篇文章&lt;/b&gt;，这样它就可以成为这个行业的热门文章。如果你正在建立一家你认为应该包括在内的公司，把它放在评论里或者在推特上联系我们！&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/W4ytOcrnIG6D9K5NNI9LzA&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;点击这里查看 145 个低代码产品及公司的分类分析&lt;/a&gt;。 &lt;/p&gt;&lt;p/&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e85200afd5799782b269294ae89ad896</guid>
<title>Kubebuilder 实战：CRUD</title>
<link>https://toutiao.io/k/9jssaxp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;markdown-body&quot;&gt;&lt;p&gt;在前两天的文章当中我们搭建好了本地的 K8s 开发环境，并且了解了 kubebuilder 的基本使用方法，今天就从我之前遇到的一个真实需求出发完整的写一个 Operator&lt;/p&gt;&lt;h2 id=&quot;需求分析&quot;&gt;&lt;a href=&quot;#需求分析&quot; class=&quot;headerlink&quot; title=&quot;需求分析&quot;/&gt;需求分析&lt;/h2&gt;&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;/&gt;背景&lt;/h3&gt;&lt;p&gt;在 K8s 运行的过程当中我们发现总是存在一些业务由于安全，可用性等各种各样的原因需要跑在一些独立的节点池上，这些节点池里面可能再划分一些小的节点池。&lt;/p&gt;&lt;p&gt;虽然我们可以使用 &lt;code&gt;Taint&lt;/code&gt;，&lt;code&gt;Label&lt;/code&gt;对节点进行划分，使用 &lt;code&gt;nodeSelector&lt;/code&gt; 和 &lt;code&gt;tolerations&lt;/code&gt;让 Pod 跑在指定的节点上，但是这样主要会有两个问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;一个是管理上不方便，在实际的使用过程中我们会发现存在错配漏配的情况&lt;br/&gt;虽然在 &lt;code&gt;v1.16&lt;/code&gt; 之后也可以使用 &lt;code&gt;RuntimeClass&lt;/code&gt;来简化 pod 的配置，但是 &lt;code&gt;RuntimClass&lt;/code&gt; 并不和节点进行关联&lt;sup id=&quot;fnref:1&quot; class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--rounded&quot; aria-label=&quot;容器运行时类(Runtime Class): https://kubernetes.io/zh/docs/concepts/containers/runtime-class/&amp;#10;&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;&lt;li&gt;另一个就是拓展需求不好实现，例如我们想要的某个节点属于网段或者当节点加入这个节点池自动开墙等&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;/&gt;需求&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;对应用来说我们可以在创建或者更新应用时便捷的选择的对应的节点池，默认情况下不需要进行选择&lt;/li&gt;&lt;li&gt;对于节点池来说&lt;ul&gt;&lt;li&gt;一个节点池可能有多个节点，并且一个节点也可能同时属于多个节点池&lt;/li&gt;&lt;li&gt;不同节点池的标签、污点信息可能不同&lt;/li&gt;&lt;li&gt;后续可以支持不同节点池的机型、安全组或者防火墙策略不同等&lt;/li&gt;&lt;li&gt;&lt;code&gt;MVP&lt;/code&gt; 版本支持标签、污点即可&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;方案设计&quot;&gt;&lt;a href=&quot;#方案设计&quot; class=&quot;headerlink&quot; title=&quot;方案设计&quot;/&gt;方案设计&lt;/h2&gt;&lt;p&gt;节点池资源如下&lt;/p&gt;&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs yaml&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;apiVersion:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;nodes.lailin.xyz/v1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;kind:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;NodePool&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;name:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;test&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;taints:&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;key:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;node-pool.lailin.xyz&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-attr&quot;&gt;value:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;test&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-attr&quot;&gt;effect:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;NoSchedule&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;labels:&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;node-pool.lailin.xyz/test:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;节点和节点池之间的映射如何建立？&lt;/p&gt;&lt;p&gt;Pod 和节点池之间的映射如何建立？&lt;/p&gt;&lt;ul&gt;&lt;li&gt;我们可以复用 &lt;code&gt;RuntimeClass&lt;/code&gt;对象，当创建一个 NodePool 对象的时候我们就创建一个对应的 &lt;code&gt;RuntimeClass&lt;/code&gt; 对象，然后在 &lt;code&gt;Pod&lt;/code&gt; 中只需要加上 &lt;code&gt;runtimeClassName: myclass&lt;/code&gt; 就可以了&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;注: 对于 MVP 版本来说其实我们不需要使用自定义资源，只需要通过标签和 RuntimeClass 结合就能满足需求，但是这里为了展示一个完整的流程，我们使用了自定义资源&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;开发&quot;&gt;&lt;a href=&quot;#开发&quot; class=&quot;headerlink&quot; title=&quot;开发&quot;/&gt;开发&lt;/h2&gt;&lt;h3 id=&quot;创建项目&quot;&gt;&lt;a href=&quot;#创建项目&quot; class=&quot;headerlink&quot; title=&quot;创建项目&quot;/&gt;创建项目&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# 初始化项目&lt;/span&gt;&lt;br/&gt;kubebuilder init --repo github.com/mohuishou/blog-code/k8s-operator/03-node-pool-operator --domain lailin.xyz --skip-go-version-check&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# 创建 api&lt;/span&gt;&lt;br/&gt;kubebuilder create api --group nodes --version v1 --kind NodePool&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&quot;定义对象&quot;&gt;&lt;a href=&quot;#定义对象&quot; class=&quot;headerlink&quot; title=&quot;定义对象&quot;/&gt;定义对象&lt;/h3&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// NodePoolSpec 节点池&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; NodePoolSpec &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Taints 污点&lt;/span&gt;&lt;br/&gt;Taints []v1.Taint &lt;span class=&quot;hljs-string&quot;&gt;`json:&quot;taints,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Labels 标签&lt;/span&gt;&lt;br/&gt;Labels &lt;span class=&quot;hljs-keyword&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;]&lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;`json:&quot;labels,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&quot;创建&quot;&gt;&lt;a href=&quot;#创建&quot; class=&quot;headerlink&quot; title=&quot;创建&quot;/&gt;创建&lt;/h3&gt;&lt;p&gt;我们实现 &lt;code&gt;Reconcile&lt;/code&gt; 函数，&lt;code&gt;req&lt;/code&gt;会返回当前变更的对象的 &lt;code&gt;Namespace&lt;/code&gt;和&lt;code&gt;Name&lt;/code&gt;信息，有这两个信息，我们就可以获取到这个对象了，所以我们的操作就是&lt;/p&gt;&lt;ul&gt;&lt;li&gt;获取 &lt;code&gt;NodePool&lt;/code&gt; 对象&lt;/li&gt;&lt;li&gt;通过 &lt;code&gt;NodePool&lt;/code&gt; 对象生成对应的 &lt;code&gt;Label&lt;/code&gt; 查找是否已经存在对应的 &lt;code&gt;Label&lt;/code&gt; 的 Node&lt;ul&gt;&lt;li&gt;如果存在，就给对应的 &lt;code&gt;Node&lt;/code&gt; 加上对应的 &lt;code&gt;Taint&lt;/code&gt; 和 &lt;code&gt;Label&lt;/code&gt;&lt;/li&gt;&lt;li&gt;如果不存在就跳过&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;通过 &lt;code&gt;NodePool&lt;/code&gt; 生成对应的 &lt;code&gt;RuntimeClass&lt;/code&gt; ，查找是否已经存在对应的 &lt;code&gt;RuntimeClass&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(r *NodePoolReconciler)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Reconcile&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ctx context.Context, req ctrl.Request)&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(ctrl.Result, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;_ = r.Log.WithValues(&lt;span class=&quot;hljs-string&quot;&gt;&quot;nodepool&quot;&lt;/span&gt;, req.NamespacedName)&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 获取对象&lt;/span&gt;&lt;br/&gt;pool := &amp;amp;nodesv1.NodePool{}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err := r.Get(ctx, req.NamespacedName, pool); err != &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ctrl.Result{}, err&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; nodes corev1.NodeList&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 查看是否存在对应的节点，如果存在那么就给这些节点加上数据&lt;/span&gt;&lt;br/&gt;err := r.List(ctx, &amp;amp;nodes, &amp;amp;client.ListOptions{LabelSelector: pool.NodeLabelSelector()})&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; client.IgnoreNotFound(err) != &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ctrl.Result{}, err&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;len&lt;/span&gt;(nodes.Items) &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; {&lt;br/&gt;r.Log.Info(&lt;span class=&quot;hljs-string&quot;&gt;&quot;find nodes, will merge data&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;nodes&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-built_in&quot;&gt;len&lt;/span&gt;(nodes.Items))&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; _, n := &lt;span class=&quot;hljs-keyword&quot;&gt;range&lt;/span&gt; nodes.Items {&lt;br/&gt;n := n&lt;br/&gt;err := r.Patch(ctx, pool.Spec.ApplyNode(n), client.Merge)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ctrl.Result{}, err&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; runtimeClass v1beta1.RuntimeClass&lt;br/&gt;err = r.Get(ctx, client.ObjectKeyFromObject(pool.RuntimeClass()), &amp;amp;runtimeClass)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; client.IgnoreNotFound(err) != &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ctrl.Result{}, err&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 如果不存在创建一个新的&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; runtimeClass.Name == &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt; {&lt;br/&gt;err = r.Create(ctx, pool.RuntimeClass())&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ctrl.Result{}, err&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ctrl.Result{}, &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&quot;更新&quot;&gt;&lt;a href=&quot;#更新&quot; class=&quot;headerlink&quot; title=&quot;更新&quot;/&gt;更新&lt;/h3&gt;&lt;p&gt;相信聪明的你已经发现上面的创建逻辑存在很多的问题&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如果 &lt;code&gt;NodePool&lt;/code&gt; 对象更新，&lt;code&gt;Node&lt;/code&gt; 是否更新对应的 &lt;code&gt;Taint&lt;/code&gt; 和&lt;code&gt;Label&lt;/code&gt;&lt;ul&gt;&lt;li&gt;如果 &lt;code&gt;NodePool&lt;/code&gt; 删除了一个 &lt;code&gt;Label&lt;/code&gt; 或&lt;code&gt;Taint&lt;/code&gt;对应 &lt;code&gt;Node&lt;/code&gt; 的&lt;code&gt;Label&lt;/code&gt;或&lt;code&gt;Taint&lt;/code&gt; 是否需要删除，怎么删除？&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;如果 &lt;code&gt;NodePool&lt;/code&gt; 对象更新，&lt;code&gt;RuntimeClass&lt;/code&gt;是否更新，如何更新&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们 &lt;code&gt;MVP&lt;/code&gt; 版本实现可以简单一些，我们约定，所有属于 &lt;code&gt;NodePool&lt;/code&gt; 的节点 &lt;code&gt;Tanit&lt;/code&gt; 和&lt;code&gt;Label&lt;/code&gt;信息都应该由 &lt;code&gt;NodePool&lt;/code&gt;管理，key 包含 kubernetes 标签污点除外&lt;/p&gt;&lt;figure class=&quot;highlight diff&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs diff&quot;&gt;func (r *NodePoolReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {&lt;br/&gt;  // ....&lt;br/&gt;  &lt;br/&gt;if len(nodes.Items) &amp;gt; 0 {&lt;br/&gt;r.Log.Info(&quot;find nodes, will merge data&quot;, &quot;nodes&quot;, len(nodes.Items))&lt;br/&gt;for _, n := range nodes.Items {&lt;br/&gt;n := n&lt;br/&gt;&lt;br/&gt;// 更新节点的标签和污点信息&lt;br/&gt;&lt;span class=&quot;hljs-addition&quot;&gt;+err := r.Update(ctx, pool.Spec.ApplyNode(n))&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-deletion&quot;&gt;-err := r.Patch(ctx, pool.Spec.ApplyNode(n), client.Merge)&lt;/span&gt;&lt;br/&gt;if err != nil {&lt;br/&gt;return ctrl.Result{}, err&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;//...&lt;br/&gt;&lt;br/&gt;// 如果存在则更新&lt;br/&gt;&lt;span class=&quot;hljs-addition&quot;&gt;+err = r.Client.Patch(ctx, pool.RuntimeClass(), client.Merge)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-addition&quot;&gt;+if err != nil {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-addition&quot;&gt;+return ctrl.Result{}, err&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-addition&quot;&gt;+}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;return ctrl.Result{}, err&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;code&gt;ApplyNode&lt;/code&gt; 方法如下所示，主要是修改节点的标签和污点信息&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// ApplyNode 生成 Node 结构，可以用于 Patch 数据&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(s *NodePoolSpec)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ApplyNode&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(node corev1.Node)&lt;/span&gt; *&lt;span class=&quot;hljs-title&quot;&gt;corev1&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;Node&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 除了节点池的标签之外，我们只保留 k8s 的相关标签&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 注意：这里的逻辑如果一个节点只能属于一个节点池&lt;/span&gt;&lt;br/&gt;nodeLabels := &lt;span class=&quot;hljs-keyword&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;]&lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;{}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; k, v := &lt;span class=&quot;hljs-keyword&quot;&gt;range&lt;/span&gt; node.Labels {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; strings.Contains(k, &lt;span class=&quot;hljs-string&quot;&gt;&quot;kubernetes&quot;&lt;/span&gt;) {&lt;br/&gt;nodeLabels[k] = v&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; k, v := &lt;span class=&quot;hljs-keyword&quot;&gt;range&lt;/span&gt; s.Labels {&lt;br/&gt;nodeLabels[k] = v&lt;br/&gt;}&lt;br/&gt;node.Labels = nodeLabels&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 污点同理&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; taints []corev1.Taint&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; _, taint := &lt;span class=&quot;hljs-keyword&quot;&gt;range&lt;/span&gt; node.Spec.Taints {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; strings.Contains(taint.Key, &lt;span class=&quot;hljs-string&quot;&gt;&quot;kubernetes&quot;&lt;/span&gt;) {&lt;br/&gt;taints = &lt;span class=&quot;hljs-built_in&quot;&gt;append&lt;/span&gt;(taints, taint)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;node.Spec.Taints = &lt;span class=&quot;hljs-built_in&quot;&gt;append&lt;/span&gt;(taints, s.Taints...)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &amp;amp;node&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;我们使用 &lt;code&gt;make run&lt;/code&gt;将服务跑起来测试一下&lt;/p&gt;&lt;p&gt;首先我们准备一份 NodePool 的 CRD，使用 &lt;code&gt;kubectl apply -f config/samples/&lt;/code&gt; 部署一下&lt;/p&gt;&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs yaml&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;apiVersion:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;nodes.lailin.xyz/v1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;kind:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;NodePool&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;name:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;master&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;taints:&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;key:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;node-pool.lailin.xyz&lt;/span&gt;&lt;br/&gt;      &lt;span class=&quot;hljs-attr&quot;&gt;value:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;master&lt;/span&gt;&lt;br/&gt;      &lt;span class=&quot;hljs-attr&quot;&gt;effect:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;NoSchedule&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;labels:&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-attr&quot;&gt;&quot;node-pool.lailin.xyz/master&quot;:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;8&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-attr&quot;&gt;&quot;node-pool.lailin.xyz/test&quot;:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;2&quot;&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;handler:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;runc&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;部署之后可以获取到节点的标签&lt;/p&gt;&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs yaml&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;labels:&lt;/span&gt;&lt;br/&gt;   &lt;span class=&quot;hljs-attr&quot;&gt;beta.kubernetes.io/arch:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;amd64&lt;/span&gt;&lt;br/&gt;   &lt;span class=&quot;hljs-attr&quot;&gt;beta.kubernetes.io/os:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;linux&lt;/span&gt;&lt;br/&gt;   &lt;span class=&quot;hljs-attr&quot;&gt;kubernetes.io/arch:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;amd64&lt;/span&gt;&lt;br/&gt;   &lt;span class=&quot;hljs-attr&quot;&gt;kubernetes.io/hostname:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;kind-control-plane&lt;/span&gt;&lt;br/&gt;   &lt;span class=&quot;hljs-attr&quot;&gt;kubernetes.io/os:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;linux&lt;/span&gt;&lt;br/&gt;   &lt;span class=&quot;hljs-attr&quot;&gt;node-pool.lailin.xyz/master:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;8&quot;&lt;/span&gt;&lt;br/&gt;   &lt;span class=&quot;hljs-attr&quot;&gt;node-pool.lailin.xyz/test:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;2&quot;&lt;/span&gt;&lt;br/&gt;   &lt;span class=&quot;hljs-attr&quot;&gt;node-role.kubernetes.io/control-plane:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;   &lt;span class=&quot;hljs-attr&quot;&gt;node-role.kubernetes.io/master:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;以及 &lt;code&gt;RuntimeClass&lt;/code&gt;&lt;/p&gt;&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs yaml&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;apiVersion:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;node.k8s.io/v1&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;handler:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;runc&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;kind:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;RuntimeClass&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;scheduling:&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-attr&quot;&gt;nodeSelector:&lt;/span&gt;&lt;br/&gt;      &lt;span class=&quot;hljs-attr&quot;&gt;node-pool.lailin.xyz/master:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;8&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span class=&quot;hljs-attr&quot;&gt;node-pool.lailin.xyz/test:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;2&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-attr&quot;&gt;tolerations:&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;effect:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;NoSchedule&lt;/span&gt;&lt;br/&gt;      &lt;span class=&quot;hljs-attr&quot;&gt;key:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;node-pool.lailin.xyz&lt;/span&gt;&lt;br/&gt;      &lt;span class=&quot;hljs-attr&quot;&gt;operator:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;Equal&lt;/span&gt;&lt;br/&gt;      &lt;span class=&quot;hljs-attr&quot;&gt;value:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;master&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;我们更新一下 NodePool&lt;/p&gt;&lt;figure class=&quot;highlight diff&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs diff&quot;&gt;apiVersion: nodes.lailin.xyz/v1&lt;br/&gt;kind: NodePool&lt;br/&gt;metadata:&lt;br/&gt;  name: master&lt;br/&gt;spec:&lt;br/&gt;  taints:&lt;br/&gt;    - key: node-pool.lailin.xyz&lt;br/&gt;      value: master&lt;br/&gt;      effect: NoSchedule&lt;br/&gt;  labels:&lt;br/&gt;&lt;span class=&quot;hljs-addition&quot;&gt;+    &quot;node-pool.lailin.xyz/master&quot;: &quot;10&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-deletion&quot;&gt;-    &quot;node-pool.lailin.xyz/master&quot;: &quot;8&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-deletion&quot;&gt;-    &quot;node-pool.lailin.xyz/test&quot;: &quot;2&quot;&lt;/span&gt;&lt;br/&gt;  handler: runc&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;可以看到 RuntimeClass&lt;/p&gt;&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs yaml&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;scheduling:&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;nodeSelector:&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-attr&quot;&gt;node-pool.lailin.xyz/master:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot;&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;tolerations:&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;effect:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;NoSchedule&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-attr&quot;&gt;key:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;node-pool.lailin.xyz&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-attr&quot;&gt;operator:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;Equal&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-attr&quot;&gt;value:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;master&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;和节点对应的标签信息都有了相应的变化&lt;/p&gt;&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs yaml&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;labels:&lt;/span&gt;&lt;br/&gt;   &lt;span class=&quot;hljs-attr&quot;&gt;beta.kubernetes.io/arch:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;amd64&lt;/span&gt;&lt;br/&gt;   &lt;span class=&quot;hljs-attr&quot;&gt;beta.kubernetes.io/os:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;linux&lt;/span&gt;&lt;br/&gt;   &lt;span class=&quot;hljs-attr&quot;&gt;kubernetes.io/arch:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;amd64&lt;/span&gt;&lt;br/&gt;   &lt;span class=&quot;hljs-attr&quot;&gt;kubernetes.io/hostname:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;kind-control-plane&lt;/span&gt;&lt;br/&gt;   &lt;span class=&quot;hljs-attr&quot;&gt;kubernetes.io/os:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;linux&lt;/span&gt;&lt;br/&gt;   &lt;span class=&quot;hljs-attr&quot;&gt;node-pool.lailin.xyz/master:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot;&lt;/span&gt;&lt;br/&gt;   &lt;span class=&quot;hljs-attr&quot;&gt;node-role.kubernetes.io/control-plane:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;   &lt;span class=&quot;hljs-attr&quot;&gt;node-role.kubernetes.io/master:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&quot;预删除-Finalizers&quot;&gt;&lt;a href=&quot;#预删除-Finalizers&quot; class=&quot;headerlink&quot; title=&quot;预删除: Finalizers&quot;/&gt;预删除: Finalizers&lt;/h3&gt;&lt;p&gt;我们可以直接使用 &lt;code&gt;kubectl delete NodePool name&lt;/code&gt;删除对应的对象，但是这样可以发现一个问题，就是 NodePool 创建的 RuntimeClass 以及其维护的 Node Taint Labels 等信息都没有被清理。&lt;/p&gt;&lt;p&gt;当我们想要再删除一个对象的时候，清理一写想要清理的信息时，我们就可以使用 &lt;code&gt;Finalizers&lt;/code&gt; 特性，执行预删除的操作。&lt;/p&gt;&lt;p&gt;k8s 的资源对象当中存在一个 &lt;code&gt;Finalizers&lt;/code&gt;字段，这个字段是一个字符串列表，当执行删除资源对象操作的时候，k8s 会先更新 &lt;code&gt;DeletionTimestamp&lt;/code&gt; 时间戳，然后会去检查 &lt;code&gt;Finalizers&lt;/code&gt; 是否为空，如果为空才会执行删除逻辑。所以我们就可以利用这个特性执行一些预删除的操作。&lt;em&gt;注意：预删除必须是幂等的&lt;/em&gt;&lt;/p&gt;&lt;figure class=&quot;highlight diff&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs diff&quot;&gt;func (r *NodePoolReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {&lt;br/&gt;_ = r.Log.WithValues(&quot;nodepool&quot;, req.NamespacedName)&lt;br/&gt;// ......&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-addition&quot;&gt;+// 进入预删除流程&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-addition&quot;&gt;+if !pool.DeletionTimestamp.IsZero() {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-addition&quot;&gt;+return ctrl.Result{}, r.nodeFinalizer(ctx, pool, nodes.Items)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-addition&quot;&gt;+}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-addition&quot;&gt;+// 如果删除时间戳为空说明现在不需要删除该数据，我们将 nodeFinalizer 加入到资源中&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-addition&quot;&gt;+if !containsString(pool.Finalizers, nodeFinalizer) {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-addition&quot;&gt;+pool.Finalizers = append(pool.Finalizers, nodeFinalizer)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-addition&quot;&gt;+if err := r.Client.Update(ctx, pool); err != nil {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-addition&quot;&gt;+return ctrl.Result{}, err&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-addition&quot;&gt;+}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-addition&quot;&gt;+}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;// ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;预删除的逻辑如下&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 节点预删除逻辑&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(r *NodePoolReconciler)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;nodeFinalizer&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ctx context.Context, pool *nodesv1.NodePool, nodes []corev1.Node)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 不为空就说明进入到预删除流程&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; _, n := &lt;span class=&quot;hljs-keyword&quot;&gt;range&lt;/span&gt; nodes {&lt;br/&gt;n := n&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 更新节点的标签和污点信息&lt;/span&gt;&lt;br/&gt;err := r.Update(ctx, pool.Spec.CleanNode(n))&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; err&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 预删除执行完毕，移除 nodeFinalizer&lt;/span&gt;&lt;br/&gt;pool.Finalizers = removeString(pool.Finalizers, nodeFinalizer)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; r.Client.Update(ctx, pool)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;我们执行 &lt;code&gt;kubectl delete NodePool master&lt;/code&gt; 然后再获取节点信息可以发现，除了 &lt;code&gt;kubernetes&lt;/code&gt; 的标签其他 NodePool 附加的标签都已经被删除掉了&lt;/p&gt;&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs yaml&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;labels:&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;beta.kubernetes.io/arch:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;amd64&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;beta.kubernetes.io/os:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;linux&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;kubernetes.io/arch:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;amd64&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;kubernetes.io/hostname:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;kind-control-plane&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;kubernetes.io/os:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;linux&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;node-role.kubernetes.io/control-plane:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;node-role.kubernetes.io/master:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&quot;OwnerReference&quot;&gt;&lt;a href=&quot;#OwnerReference&quot; class=&quot;headerlink&quot; title=&quot;OwnerReference&quot;/&gt;OwnerReference&lt;/h3&gt;&lt;p&gt;我们上面使用 &lt;code&gt;Finalizer&lt;/code&gt; 的时候只处理了 Node 的相关数据，没有处理 RuntimeClass，能不能用相同的方式进行处理呢？当然是可以的，但是不够优雅。&lt;/p&gt;&lt;p&gt;对于这种一一映射或者是附带创建出来的资源，更好的方式是在子资源的 OwnerReference 上加上对应的 id，这样我们删除对应的 NodePool 的时候所有 OwnerReference 是这个对象的对象都会被删除掉，就不用我们自己对这些逻辑进行处理了。&lt;/p&gt;&lt;figure class=&quot;highlight diff&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs diff&quot;&gt;func (r *NodePoolReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {&lt;br/&gt;//...&lt;br/&gt;&lt;br/&gt;// 如果不存在创建一个新的&lt;br/&gt;if runtimeClass.Name == &quot;&quot; {&lt;br/&gt;&lt;span class=&quot;hljs-addition&quot;&gt;+runtimeClass = pool.RuntimeClass()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-addition&quot;&gt;+err = ctrl.SetControllerReference(pool, runtimeClass, r.Scheme)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-addition&quot;&gt;+if err != nil {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-addition&quot;&gt;+return ctrl.Result{}, err&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-addition&quot;&gt;+}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-addition&quot;&gt;+err = r.Create(ctx, runtimeClass)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-deletion&quot;&gt;-err = r.Create(ctx, pool.RuntimeClass())&lt;/span&gt;&lt;br/&gt;return ctrl.Result{}, err&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;在创建的时候使用 &lt;code&gt;controllerutil.SetOwnerReference&lt;/code&gt; 设置一下 OwnerReference 即可，然后我们再试试删除就可以发现 RuntimeClass 也一并被删除了。&lt;/p&gt;&lt;p&gt;注意，RuntimeClass 是一个集群级别的资源，我们最开始创建的 NodePool 是 Namespace 级别的，直接运行会报错，因为 Cluster 级别的 OwnerReference 不允许是 Namespace 的资源。&lt;/p&gt;&lt;p&gt;这个需要在 &lt;code&gt;api/v1/nodepool_types.go&lt;/code&gt; 添加一行注释，指定为 Cluster 级别&lt;/p&gt;&lt;figure class=&quot;highlight diff&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs diff&quot;&gt;//+kubebuilder:object:root=true&lt;br/&gt;&lt;span class=&quot;hljs-addition&quot;&gt;+//+kubebuilder:resource:scope=Cluster&lt;/span&gt;&lt;br/&gt;//+kubebuilder:subresource:status&lt;br/&gt;&lt;br/&gt;// NodePool is the Schema for the nodepools API&lt;br/&gt;type NodePool struct {&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;修改之后我们需要先执行 &lt;code&gt;make uninstall&lt;/code&gt; 然后再执行 &lt;code&gt;make install&lt;/code&gt;&lt;/p&gt;&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;/&gt;总结&lt;/h2&gt;&lt;p&gt;回顾一下，这篇文章我们实现了一个 NodePool 的 Operator 用来控制节点以及对应的 RuntimeClass，除了基本的 CURD 之外我们还学习了预删除和 OwnerReference 的使用方式。之前在 kubectl delete 某个资源的时候有时候会卡住，这个其实是因为在执行预删除的操作，可能本来也比较慢，也有可能是预删除的时候返回了错误导致的。&lt;/p&gt;&lt;p&gt;下一篇我们一起来为我们的 Operator 加上 Event 和 Status。&lt;/p&gt;&lt;h2 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;/&gt;参考文献&lt;/h2&gt;&lt;section class=&quot;footnotes&quot;/&gt;&lt;h2 id=&quot;关注我获取更新&quot;&gt;&lt;a href=&quot;#关注我获取更新&quot; class=&quot;headerlink&quot; title=&quot;关注我获取更新&quot;/&gt;关注我获取更新&lt;a class=&quot;anchorjs-link&quot; aria-label=&quot;Anchor&quot; data-anchorjs-icon=&quot;&quot; href=&quot;#关注我获取更新&quot;/&gt;&lt;/h2&gt;&lt;h2 id=&quot;猜你喜欢&quot;&gt;猜你喜欢&lt;/h2&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1967e4669fe521dd62d3f526fc959289</guid>
<title>如果你也会手抖输错命令，那就必须给你推荐这个 Fuck 工具</title>
<link>https://toutiao.io/k/zv6r0sz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;【导语】：The Fuck 是一个命令输出校验工具，能自动校对输入命令并执行正确的指令。大概早在 2015 年就火了。&lt;/p&gt;
&lt;h3&gt;简介&lt;/h3&gt;
&lt;p&gt;The Fuck 是一款功能强大的应用程序，可以校对并纠正控制台中命令的错误。它的开发者透露，设计灵感来源于这条推特：&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6ccae5da2a27e851fbbf1c654d24babf_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;566&quot; data-rawheight=&quot;243&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-6ccae5da2a27e851fbbf1c654d24babf_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;566&quot; data-rawheight=&quot;243&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-6ccae5da2a27e851fbbf1c654d24babf_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-6ccae5da2a27e851fbbf1c654d24babf_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;简单的运行例子：  &lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-53361675b8cf86fc10002a22b3546ebc_b.gif&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;686&quot; data-rawheight=&quot;379&quot; data-thumbnail=&quot;https://pic1.zhimg.com/v2-53361675b8cf86fc10002a22b3546ebc_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-53361675b8cf86fc10002a22b3546ebc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;686&quot; data-rawheight=&quot;379&quot; data-thumbnail=&quot;https://pic1.zhimg.com/v2-53361675b8cf86fc10002a22b3546ebc_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-53361675b8cf86fc10002a22b3546ebc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-53361675b8cf86fc10002a22b3546ebc_b.gif&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;更多的例子：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;➜ apt-get install vim  
E: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)  
E: Unable to lock the administration directory (/var/lib/dpkg/), are you root?  

➜ fuck  
sudo apt-get install vim [enter/↑/↓/ctrl+c]  
[sudo] password for nvbn:  
Reading package lists... Done  
...  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;fatal: The current branch master has no upstream branch.  
To push the current branch and set the remote as upstream, use  

    git push --set-upstream origin master  


➜ fuck  
git push --set-upstream origin master [enter/↑/↓/ctrl+c]  
Counting objects: 9, done.  
...  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;➜ puthon  
No command &#x27;puthon&#x27; found, did you mean:  
 Command &#x27;python&#x27; from package &#x27;python-minimal&#x27; (main)  
 Command &#x27;python&#x27; from package &#x27;python3&#x27; (main)  
zsh: command not found: puthon  

➜ fuck  
python [enter/↑/↓/ctrl+c]  
Python 3.4.2 (default, Oct  8 2014, 13:08:17)  
...  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;项目地址是：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/nvbn/thefuck&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/nvbn/thefuck&lt;/span&gt;&lt;span class=&quot;invisible&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;下载安装&lt;/h3&gt;

&lt;ol&gt;&lt;li&gt;Ubuntu/Mint：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;sudo apt update  
sudo apt install python3-dev python3-pip python3-setuptools  
sudo pip3 install thefuck  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;&lt;li&gt;FreeBSD：&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;&lt;li&gt;ChromeOS:&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;&lt;li&gt;其他操作系统使用pip进行安装：&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;&lt;li&gt;升级：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;pip3 install thefuck --upgrade  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;作用机制&lt;/h3&gt;
&lt;p&gt;The Fuck 尝试将错误的命令与规则匹配，如果找到匹配项，则使用匹配的规则创建一个新命令并执行。规则很多没办法一一列举，简单罗列几个，各位有兴趣的话到官网上查找。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;adb_unknown_command：修复拼写错误的命令，例如adb logcta&lt;/li&gt;
&lt;li&gt;cat_dir：尝试cat目录时使用ls替换cat&lt;/li&gt;
&lt;li&gt;cd_parent：更改cd..为cd ..&lt;/li&gt;
&lt;li&gt;docker_not_command：修复了错误的docker命令，如docker tags&lt;/li&gt;
&lt;li&gt;git_branch_delete：更改 git branch -d 为 git branch -D&lt;/li&gt;
&lt;li&gt;go_unknown_command：修复错误的go命令，例如go bulid&lt;/li&gt;
&lt;li&gt;java：在运行Java程序时删除.java扩展名 与此同时，The Fuck也允许用户自定义匹配规则。&lt;/li&gt;
&lt;li&gt;在~/.config/thefuck/rules目录下创建一个文件名为your-rule-name.py的违建，规则文件必须包含两个函数：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;match(command: Command) -&amp;gt; bool  
get_new_command(command: Command) -&amp;gt; str | list[str]  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;side_effect(old_command: Command, fixed_command: str) -&amp;gt; None  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;开源前哨&lt;/code&gt; 日常分享热门、有趣和实用的开源项目。参与维护 10万+ Star 的开源技术资源库，包括：Python、Java、C/C++、Go、JS、CSS、Node.js、PHP、.NET 等。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5f26e2c7aa772d7841674afb249826e4</guid>
<title>从工业化到智能化，未来的 AB 实验是什么样子</title>
<link>https://toutiao.io/k/s4wvw9c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;前几天读到字节的一篇文章《9年70万次实验，字节跳动首次揭秘A/B测试》 ，文章内容暂且不论，主要想聊下这个标题。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span/&gt;&lt;span&gt;实验方面的权威著作《&lt;/span&gt;&lt;span&gt;Trustworthy Online Controlled Experiments》&lt;/span&gt;&lt;span&gt;将实验平台按成熟度分成了crawl, walk, run, fly四个阶段。&lt;/span&gt;&lt;span&gt;中国互联网公司中，字节与快手其实都早已进入了其中的最高阶段fly，即AB实验的大规模自动化，乃至事必AB。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;这之后，笔者认为AB实验的次数已不再是一个多么重要的数字，而平台应该向更高的阶段去发展，从工业时代进入到智能时代。而在新的时代里，实验的数量实际上不会上升，反而会下降。因为&lt;/span&gt;&lt;span&gt;平台将对海量的实验数据进行知识挖掘与发现，沉淀出更系统的业务知识体系，指导后续的策略迭代&lt;/span&gt;&lt;span&gt;（可类比智能驾驶的L2阶段）；并最终构&lt;/span&gt;&lt;span&gt;建出一套预测体系，在实验之前，便对大量实验评估出其正负向结果&lt;/span&gt;&lt;span&gt;（L4/L5阶段）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;本文将剖析工业时代实验平台存在的问题，并探讨未来智能时代对这些问题的解决路径。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.59296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5EpmeGExLQfic2KgOu7LJWmfGh0rungO4IUictf22P3PdZYTjaQK0SicK92h4V5icCUibQGBat2gcgudh4zqlRKVsvg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h2 dir=&quot;ltr&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 dir=&quot;ltr&quot;&gt;&lt;span&gt;一、工业时代的&lt;/span&gt;&lt;span&gt;A/B&lt;/span&gt;&lt;span&gt;实验：单点模式下的效率与认知两大难题&lt;/span&gt;&lt;/h2&gt;&lt;h3 dir=&quot;ltr&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 dir=&quot;ltr&quot;&gt;&lt;span&gt;1.1 工业时代实验平台的设计目标-单点模式&lt;/span&gt;&lt;/h3&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;工业时代实验平台的特征是大规模、自动化。平台通过一系列通用模块实现了各种实验低成本、大规模的并行测试，保障实验结果互不干扰（所谓“正交”），同时还给出详尽的实验数据分析及显著性检测以供决策。上述模式以单个实验作为其设计与操作的单位，每个策略单独开实验，单独看效果。更深层次地，笔者认为，&lt;/span&gt;&lt;span&gt;整个实验平台以低成本测试单个想法为其设计目标&lt;/span&gt;&lt;span&gt;。甚至AB这个名字，也侧面体现了低成本的目标。因为统计实验其实有很多方法，A/B只是其中最简单，理解成本也最低的一种实验，正因如此才最有利于大规模实现，而A/B也成了实验平台的代名词。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.2 单点模式下失控的成本：缺乏预判&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;但这个设计目标中的成本，考虑的仅是实验的实施成本，并没有考虑业务成本。遗憾的是，&lt;/span&gt;&lt;span&gt;业务成本才是总成本中的主体部分&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;一个产品feature进行实验的业务成本其实是相当高的，尤其是其中的时间成本。一个产品idea从创意到PRD、评审、到研发、封版、发版，要经历几周，然后用户更新版本，DA进行实验分析，业务决定是否推全。整个流程走下来，最快也要三周，经常需要一个月以上。&lt;/span&gt;&lt;span&gt;这样的速度，好像与我们平时说的快速迭代并不相符。&lt;/span&gt;&lt;span&gt;看起来，大厂的快速迭代可能更多是通过高并发来实现的，字节9年70万次实验，也就是平均每天200+实验，&lt;/span&gt;&lt;span&gt;我好像明白了什么。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;那么，如何才能降低业务成本呢？从实验策略各阶段所占的人天数来看，业务成本最主要是从研发阶段才开始增加的，所以降低成本，提升效率的关键问题在于预判，即&lt;/span&gt;&lt;span&gt;在决定研发前，预判该想法能够实验正向的概率&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 dir=&quot;ltr&quot;&gt;&lt;span&gt;1.3 单点模式下迭代的难题：难以归因&lt;/span&gt;&lt;/h3&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;上面的环节其实还没有说完。一个策略往往不是上了实验就能正向的。业内的基本事实是，大部分实验都是负向或不显著的，且随产品的不断完善与成熟，实验要正向变得愈加困难。而当前期已投入大量成本时，常会选择继续迭代。随着业务与实验的发展，负向迭代的需求也愈演愈烈，继续推高了成本，同时又带来了新的问题，如何确定实验迭代的方向？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;迭代方向探索这个问题，往往要基于DA对原实验负向的归因。从本质上来说，&lt;/span&gt;&lt;span&gt;实验归因问题，是要找到策略变量与结果变量之间缺失的因果链条&lt;/span&gt;&lt;span&gt;。即，我们通过实验已知实验策略A导致关键指标Y正向或负向的变化，希望知晓其影响路径，比如找到中间变量B或C，有A=&amp;gt;B, B=&amp;gt;C, C=&amp;gt;Y。&lt;/span&gt;&lt;span&gt;而负向实验迭代的问题，则是已知实验策略A导致关键指标Y负向，希望找到其变体A’，能使Y正向。&lt;/span&gt;&lt;span&gt;目前解这类问题的&lt;/span&gt;&lt;span&gt;一&lt;/span&gt;&lt;span&gt;种自然思路是先尝试归因，理解清楚可被更直接操控的中间变量B或C后，通过调整策略为A’，来影响B或C，最终使得Y正向。&lt;/span&gt;&lt;span&gt;于是，我们可以把归因视为迭代的基础。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;*对于统计不显著的实验，是否推全要case-by-case具体分析。但依据经验法则：如果该feature增加了产品复杂度，提高了用户认知成本，一般不建议推全（Occam&#x27;s Razor: 如无必要，勿增实体）。否则各种不显著实验推全，产品会变得越来越复杂。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;实验归因问题往往比较困难，有两个难点，都与实验分析的单点模式有关。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;首先，如上所述，&lt;/span&gt;&lt;span&gt;实验归因是个构造性问题，需要构造出中间变量&lt;/span&gt;&lt;span&gt;。那用什么方法来构造呢？目前DA侧在进行归因时，更多是通过维度下探来进行定位，但严格来说定位不是归因，未必能归结到原因。下探时也时常缺乏好的分析框架作为指导，采用诸如用户画像之类的常用维度，实际可能与问题关系不大，我把这种方法称之为旁(yuan)敲(mu)侧(qiu)击(yu)法。还有的采用遍历穷举法，将常用维度全都下探一遍，如果能找到相关的则是万幸，找不到那对于业务方也算有了交代，之后的迭代方向就交给业务自己去拍脑袋吧。实际上，要解决归因问题，需对业务机制有深入理解，本质上构造出整个因果关系链相当于建立了一个业务模型。这除了需要对业务具备基本认知，还需对相关实验进行研究与归纳，从中抽象出业务模型。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;其次，&lt;/span&gt;&lt;span&gt;实验归因常常是个欠定问题&lt;/span&gt;&lt;span&gt;。所谓欠定是说，实验结果之所以表现为这样，原因可能是B1，也可能是B2或C3。单个实验蕴含的信息可能不充分，不能唯一确定出是哪个原因。实际上，归因问题常常需要一个归纳-演绎的迭代过程（如下图），需要有新的数据输入才能更好判断。这可能需要设计新的实验，或通过更多相关实验的研究，才能有“唯一”指向性，更严谨地得到结论。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4392361111111111&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5EpmeGExLQfic2KgOu7LJWmfGh0rungO4HBP9mNkjHqA5OmOTwYXsfwINuhxS15hwR5wtIViaZs0fUo3HkSBHw6g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1152&quot;/&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;因此，归因问题不是仅靠逻辑推理就能解决的，而需要分析师经过大量实践，刻意练习与思考。而这首先需要我们有更中心化的知识沉淀与挖掘，摆脱单点模式，将大量实验的结果信息整合起来，才能有big picture，从中获得洞察，有更大的自信来判断究竟是怎么回事，并保障分析师解读的可靠性与一致性(consistency)。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;由此可见，工业时代，我们对于实验平台的理解，往往停留在工程系统上，更多将其理解为一个功能性与评估/验证性的工具，因此未能很好降低业务成本，从根本上提高业务发展的效率。&lt;/span&gt;&lt;span&gt;提效的关键问题在于预判与归因&lt;/span&gt;&lt;span&gt;。我们如何能在实验前就较好预判实验成功的概率，从一开始就排除掉一些大概率负向实验？同时，当负向发生时又如何更有效地找到迭代路径？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;这些问题，需要智能时代来解决。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 dir=&quot;ltr&quot;&gt;&lt;span&gt;二、智能时代的A/B实验：网络协同下预判与归因双重引擎&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 dir=&quot;ltr&quot;&gt;&lt;span&gt;2.1 智能时代实验平台的设计目标&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;智能时代的实验平台具有一个硬币的两面。一面是工程视角下的实验平台，即进行实验的基础设施，包括流量分配，数据评估等等，主要由工程团队来负责。另一面则是业务视角下的实验平台，是通过实验来最优化业务发展整体效率的工具，因此需要&lt;/span&gt;&lt;span&gt;配备预判与归因两大智能引擎，以及DA/DS的介入&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;那么预判与归因这两个问题又该如何解决呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;从强化学习的EE框架来看，工业时代实验平台上，每个实验都是单点实验，只有Explore(探索)，没有Exploit(利用)。&lt;/span&gt;&lt;span&gt;智能时代则将更多利用实验之间的网络协同来进行Exploit，我认为有两个&lt;/span&gt;&lt;span&gt;潜在的方向&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;表层是数据驱动的方法，目前阶段最主要是利用&lt;/span&gt;&lt;span&gt;实验策略的相似性进行迁移学习&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;span&gt;底层则从第一性原理出发，假设我们可以&lt;/span&gt;&lt;span&gt;抽象出一些普适的，有业务意义的关键概念&lt;/span&gt;&lt;span&gt;，如用户体验等心理变量，建立分析框架，同时结合实验数据等各类型数据，进行分析与度量，从而预判实验的正负向，并在同时解决归因问题。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;2.2 表层策略：迁移学习&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;迁移学习是机器学习的一个子领域，可以最大限度地利用有标注领域的知识，来辅助目标领域的知识获取和学习。比如，国际象棋和中国象棋比较相近，有部分棋子相同、走法相近，计算机学会了国际象棋，运用迁移学习的方法，只用观摩较少的棋局，就可以学会中国象棋。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;迁移学习的核心在于，&lt;/span&gt;&lt;span&gt;找到源领域和目标领域之间的相似性，并加以合理利用&lt;/span&gt;&lt;span&gt;。这里的源领域和目标领域，可以认为分别对应于我们已有的实验，和正准备进行的实验。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;例如短视频巨头快手，目前已有不少产品，国内有主App、极速版、概念版及各种孵化产品，海外也有多个产品。字节作为App工厂，产品就更数不胜数。另一方面，同一产品内的不同产品模块，也常有共性，比如短视频App的不同Feed间，这些都提供了相似性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;就使用场景的不同，这里的迁移学习又可分为两类：&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;一种是归纳式迁移学习(inductive transfer learning)。在这种学习方法中，两个实验对每个个体产生的效果可以不同（源Task与目标Task可以不同），因为不同，就要求在目标领域中必须有一些已标注的数据，才能进行学习。实践中，上面提到有一些新App用户量较小，做实验常有不置信的问题。这一问题历史上曾经尝试过一些方差缩减(variance reduction)方法，但实际对方差的降幅有限，不能根本上解决问题。更可行的思路应该是结合更大的数据集（核心App相似实验的数据），进行多任务学习。具体需结合实际场景，尝试基于实例的学习算法、基于超参数的学习算法等，这里不再赘述。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;另一种是转导式迁移学习（transductive transfer learning），在这种学习方法中，需假设两个实验对每个个体产生的效果相同。但在不少情况下，这个假设还是过于强了，比如动图实验在发现页与关注页的表现就不一样。实践中，我们需要研发一些方法来判断该假设是否合理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;由此可知，&lt;/span&gt;&lt;span&gt;迁移学习目前对于我们的场景仍有较大局限性&lt;/span&gt;&lt;span&gt;：首先该方法要求此前已有相似实验，才能进行迁移，适用场景相对小。其次，归纳式迁移学习需要当前实验已有样本，这可以解决小样本实验的置信问题，但不能事先进行预测。而转导式迁移学习在不少场景下假设过强，实践中，也需要研发方法来判断假设是否合理。最后，迁移不能解决归因问题，不能直接带来认知。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;因此，笔者认为&lt;/span&gt;&lt;span&gt;迁移学习可以在恰当场景下作为预测系统的重要补充&lt;/span&gt;&lt;span&gt;，在有相似实验的场景下，预测或能更准确。但我们还需要研发更好的方案，作为实验决策系统的主战场。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.3 &lt;/span&gt;&lt;span&gt;底层策略：&lt;/span&gt;&lt;span&gt;业务结构模型&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;在给出预判问题的解决方案前，让我们先回顾一下，产品经理是如何做类似决策的？以产品闻名的腾讯有一套&lt;/span&gt;&lt;span&gt;基于用户价值的产品方法论&lt;/span&gt;&lt;span&gt;，提倡一切以用户价值为归依，通过将自己带入普通用户，人同此心地去感受与体验产品，思考产品对于用户的价值。这种方法特别强调同理心，即“一秒变小白”的能力，产品经理快速将自己对产品的所有已知信息抹除，让自己和目标用户具有相同的视角，时刻审问自己：如果我是用户，会使用这个功能吗？一些名家的原话如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;马化腾&lt;/span&gt;&lt;span&gt;：任何产品的核心功能，其宗旨都是能对用户有所帮助，能够解决用户某一方面的需求，如节省时间、解决问题、提升效率等，而产品经理就是要将这种核心能力做到极致，通过技术实现差异化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;张小龙（在提到微信新上线的7.0版本时）：我在新旧版本切换使用2个月后，我就不愿意切换回旧版本了 ，所以我想想用户会喜欢这个版本，只是需要时间来适应。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;张小龙：个人对用户体验的目标是，做到“自然”。“自然”可能容易导致玄学，因此这里想强调的是，“自然”的思维方式一般是需要长期的非常理性的训练才能获得，而不是突然幻想自己获得了一种使用“自然原则”的能力。记得知乎上有个问题问“乔布斯为什么能凭直觉知道该怎么做”。我认为没有任何人有天生的可重复的直觉来立即成为一个领域的专业人员。比如，对于复杂事物，如何“抽象”为一个简单模型，是需要大量案例锻炼的。但是，如果经过一万小时的有意识的朝某个方向的训练（比如对“自然”的反复思考和实际工作练习），并且是极为理性的思维和实践训练，是可以获得一些直觉的。大量的理性训练有助于形成一种对同类事物的识别模式，这种模式形成直觉。比如大部分中国人其实是没有经受过“简单是美”的训练的，表现在现实中，很多人其实是很难接受一套极简主义的装修风格的居室的。只有当对“极简”有反复体验和思考，才能将“简单是美”变成骨子里的审美观，并体现在设计中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;俞军公式：产品的用户价值=(新体验-旧体验)-替换成本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;笔者自己高度认同上述方法论，但也认为这套方法用于实验预判时会存在一些问题。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span/&gt;&lt;span&gt;首先，实验正负向的问题，很需要定量思维，因为都是各种因素的权衡交互，一些定性的方法实践中往往不能给出直接的决策建议。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;其次，这套方法不太scalable，按张小龙与俞军的说法，要做好产品决策，需要经过反复思考，一万小时的刻意练习才能练就相应的直觉，构建心理表征。所以这套方法，对人的素质与经验要求有点高，且掌握之后，也无法高效地传递给他人。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;我们认为，从历史趋势来看，未来的决策方式会更分布式、更scable，在基本的理论框架下，新的实验不断创造新的数据，从而不断迭代、更新原有的决策模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;笔者在一开始接触产品分析时，直觉上便希望建立这样一套决策体系（虽然被告知很难、不可能），一年后因为一些际遇，始有心得，提出一套用户体验(UE)结构模型。之后近两年的时间里，有机会时便去预测各种实验的结果，验证该理论，看起来它多少经受住了时间的考验，虽然过程中需要技巧，并更完善的度量结果。幸运&lt;/span&gt;&lt;span&gt;的&lt;span&gt;是，笔者发现，这一模型恰巧也是解决许多实验归因问题的关键所在。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;归因问题需要我们建立一个合适的分析框架作为瞄准器，而不是常规性地拆分各种常用维度&lt;/span&gt;&lt;span&gt;，这个框架需要切近业务场景，而对于产品实验的归因，最直接的不就是产品交互，产品体验的角度嘛。所以，&lt;/span&gt;&lt;span&gt;UE结构模型，恰好提供了这样的工具，来帮助我们分解相关问题&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;更一般地，对于各种业务场景的实验，我们可尝试构建相应的业务结构模型。&lt;/span&gt;&lt;span&gt;这个模型包括两部分，一方面有一个合理的理论框架，连接了关键变量Y及其主要影响因素Bi。&lt;/span&gt;&lt;span&gt;然后我们考察实验策略A如何影响B，以及最终对Y的综合影响。&lt;/span&gt;&lt;span&gt;另一方面我们需要能定量刻画Bi，通过大量实证数据，来自AB、科学实验或是用研、用户反馈等。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;具体的业务结构模型不一而足，但不少重要的模型基于一定的心理变量，这些变量以前往往未被很好探究并赋予结构，当然我们需要这些变量有一定的信度与效度，从而是真正有意义与可测量的。这当中最通用的有用户体验结构模型，用户心智模型等。用户体验更适合解决当前产品的形态优化问题。用户需求与心智模型则更多应用于新产品的成败这样一个更复杂与困难的问题分析中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;在之后的一系列文章中，笔者将不揣浅陋，更详细地阐述一些业务结构模型，来初步实现实验的预判与归因。&lt;/span&gt;&lt;span&gt;预测体系的好处是可证伪，也欢迎大家给出各种case，来验证这种理论，更新我的认知。&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ff61e12ecc5543fbf8861c74d9a9ff03</guid>
<title>36 张图详解网络基础知识</title>
<link>https://toutiao.io/k/bjis3t4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;figure&gt;&lt;figcaption&gt;前言&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;网络协议&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;我们用手机连接上网的时候，会用到许多网络协议。从手机连接 WiFi 开始，使用的是 &lt;strong&gt;802.11&lt;/strong&gt; （即 WLAN ）协议，通过 WLAN 接入网络；手机自动获取网络配置，使用的是 &lt;strong&gt;DHCP&lt;/strong&gt; 协议，获取配置后手机才能正常通信。这时手机已经连入&lt;strong&gt;局域网&lt;/strong&gt;，可以访问局域网内的设备和资源，但还不能使用互联网应用，例如：微信、抖音等。想要访问&lt;strong&gt;互联网&lt;/strong&gt;，还需要在手机的上联网络设备上实现相关协议，即在无线路由器上配置 &lt;strong&gt;NAT&lt;/strong&gt;、 &lt;strong&gt;PPPOE&lt;/strong&gt; 等功能，再通过运营商提供的互联网线路把局域网接入到互联网中，手机就可以上网玩微信、刷抖音了。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.26864244741873805&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhAibTZMiajUGdG2HCNXoBJPMz4eJ0vkpPLBr0AkBco5tRpQRyuQRiad7Wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1046&quot; title=&quot;网络协议示意图&quot;/&gt;&lt;figcaption&gt;网络协议示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;局域网&lt;/strong&gt; ：小范围内的私有网络，一个家庭内的网络、一个公司内的网络、一个校园内的网络都属于局域网。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;广域网&lt;/strong&gt;：把不同地域的局域网互相连接起来的网络。运营商搭建广域网实现跨区域的网络互连。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;互联网&lt;/strong&gt;：互联全世界的网络。互联网是一个开放、互联的网络，不属于任何个人和任何机构，接入互联网后可以和互联网的任何一台主机进行通信。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;简单来说，就是手机、无线路由器等设备通过多种&lt;strong&gt;网络协议&lt;/strong&gt;实现通信。网络协议就是为了通信各方能够互相交流而定义的标准或规则，设备只要遵循相同的网络协议就能够实现通信。那网络协议又是谁规定的呢？ISO 制定了一个国际标准 &lt;strong&gt;OSI&lt;/strong&gt; ， 其中的 &lt;strong&gt;OSI 参考模型&lt;/strong&gt;常被用于网络协议的制定。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;2.3259668508287294&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibh6uQJNdNmR86rKBMFTbTXWhE2TZgktqBJo5zPKad8UuWR7QRnRxQw4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;181&quot; title=&quot;OSI 参考模型图&quot;/&gt;&lt;figcaption&gt;OSI 参考模型图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;OSI 参考模型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;OSI 参考模型将网络协议提供的服务分成 &lt;strong&gt;7&lt;/strong&gt; 层，并定义每一层的&lt;strong&gt;服务&lt;/strong&gt;内容，实现每一层服务的是&lt;strong&gt;协议&lt;/strong&gt;，协议的具体内容是&lt;strong&gt;规则&lt;/strong&gt;。上下层之间通过&lt;strong&gt;接口&lt;/strong&gt;进行交互，同一层之间通过&lt;strong&gt;协议&lt;/strong&gt;进行交互。OSI 参考模型只对各层的服务做了粗略的界定，并没有对协议进行详细的定义，但是许多协议都对应了 7 个分层的某一层。所以要了解网络，首先要了解 OSI 参考模型。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.2626970227670753&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibh4CH4VEic76p0gs0OxOvdqHF2XhTvC47ic65TnEFnqHicFZeP10HjJoZpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;571&quot; title=&quot;OSI 参考模型分层功能&quot;/&gt;&lt;figcaption&gt;OSI 参考模型分层功能&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;应用层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;OSI参考模型的第 &lt;strong&gt;7&lt;/strong&gt; 层（最高层）。应用程序和网络之间的接口，直接向用户提供服务。应用层协议有电子邮件、远程登录等协议。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8047808764940239&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhBHM0ID4PHB6gmciaiajNh6NKpj18AvyA0UpiaqzAibMOCo4Oic14QbTiavkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;502&quot; title=&quot;应用层示例图&quot;/&gt;&lt;figcaption&gt;应用层示例图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;表示层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;OSI参考模型的第 &lt;strong&gt;6&lt;/strong&gt; 层。负责数据格式的互相转换，如编码、数据格式转换和加密解密等。保证一个系统应用层发出的信息可被另一系统的应用层读出。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3237518910741301&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhbjeLdvrTPSibKXHcvPYNQ7vIxPm4xa6gXTT30UPibGOmsveBl0Ow9k1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;661&quot; title=&quot;表示层示例图&quot;/&gt;&lt;figcaption&gt;表示层示例图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;会话层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;OSI参考模型的第 &lt;strong&gt;5&lt;/strong&gt; 层。主要是管理和协调不同主机上各种进程之间的通信（对话），即负责建立、管理和终止应用程序之间的会话。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.1760797342192691&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhU62dNRZzibVgXiaUyJeWUNp9tQRQlKtIuGdCPhCaEUsIRtR8fAJv6ZicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;602&quot; title=&quot;会话层示例图&quot;/&gt;&lt;figcaption&gt;会话层示例图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;传输层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;OSI参考模型的第 &lt;strong&gt;4&lt;/strong&gt; 层。为上层协议提供通信主机间的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。只在通信主机上处理，不需要在路由器上处理。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2591362126245847&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhtPmon7ib0qicetLnGetZUBicwASfTuwDMrfhwulx8U1P3rwdicP8BAAmWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;602&quot; title=&quot;传输层示例图&quot;/&gt;&lt;figcaption&gt;传输层示例图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;网络层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;OSI参考模型的第 &lt;strong&gt;3&lt;/strong&gt; 层。在网络上将数据传输到目的地址，主要负责寻址和路由选择。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3687707641196013&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhMpuqNicFkyCSoRZplxmDWYQdkWDOqKUFzZx7y7tcDuJCzAoib3FFljpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;602&quot; title=&quot;网络层示例图&quot;/&gt;&lt;figcaption&gt;网络层示例图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;数据链路层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;OSI参考模型的第 2 层。负责物理层面上两个互连主机间的通信传输，将由 0 、 1 组成的比特流划分成数据帧传输给对端，即数据帧的生成与接收。通信传输实际上是通过物理的传输介质实现的。数据链路层的作用就是在这些通过传输介质互连的设备之间进行数据处理。&lt;/p&gt;&lt;p&gt;网络层与数据链路层都是基于目标地址将数据发送给接收端的，但是网络层负责将整个数据发送给最终目标地址， 而数据链路层则只负责发送一个分段内的数据。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.18635607321131448&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibh0FPR0aiaAtEK7jwHpiaCe2BWYbiaKBs1HibaCQRYSMicW9CqhxMBfxhcDMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;601&quot; title=&quot;数据链路层示例图&quot;/&gt;&lt;figcaption&gt;数据链路层示例图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;物理层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;OSI参考模型的第 &lt;strong&gt;1&lt;/strong&gt; 层（最底层）。负责逻辑信号（比特流）与物理信号（电信号、光信号）之间的互相转换，通过传输介质为数据链路层提供物理连接。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.23688663282571912&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhReb6DfDyDYXURlSpp35nqeVm1sPv3L15Vk1DGaqvna08QsoVqRIEPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;591&quot; title=&quot;物理层示例图&quot;/&gt;&lt;figcaption&gt;物理层示例图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;TCP/IP 参考模型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;由于 OSI 参考模型把服务划得过于琐碎，先定义参考模型再定义协议，有点理想化。TCP/IP 模型则正好相反，通过已有的协议归纳总结出来的模型，成为业界的实际网络协议标准。&lt;/p&gt;&lt;p&gt;TCP/IP 是有由 IETF 建议、推进其标准化的一种协议，是 IP 、 TCP 、 HTTP 等协议的集合。TCP/IP 是为使用互联网而开发制定的协议族，所以互联网的协议就是 TCP/IP 。&lt;/p&gt;&lt;p&gt;先介绍下 TCP/IP 与 OSI 分层之间的对应关系，以及 TCP/IP 每层的主要协议。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.554006968641115&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhCdAvJnMQiaiahhib7JLKzJNfiafoTy8ia11vgseBQ5led0hicgic7iauq7w71w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;861&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;网络接入层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;TCP/IP 是以 OSI 参考模型的物理层和数据链路层的功能是透明的为前提制定的，并未对这两层进行定义，所以可以把物理层和数据链路层合并称为&lt;strong&gt;网络接入层&lt;/strong&gt;。网络接入层是对网络介质的管理，定义如何使用网络来传送数据。但是在通信过程中这两层起到的作用不一样，所以也有把物理层和数据链路层分别称为&lt;strong&gt;硬件&lt;/strong&gt;、&lt;strong&gt;网络接口层&lt;/strong&gt;。TCP/IP 分为四层或者五层都可以，只要能理解其中的原理即可。&lt;/p&gt;&lt;p&gt;设备之间通过物理的传输介质互连， 而互连的设备之间使用 &lt;strong&gt;MAC 地址&lt;/strong&gt;实现数据传输。采用 MAC 地址，目的是为了识别连接到同一个传输介质上的设备。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;网络层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;相当于 OSI 模型中的第 3 层网络层，使用 &lt;strong&gt;IP 协议&lt;/strong&gt;。IP 协议基于 &lt;strong&gt;IP 地址&lt;/strong&gt;转发分包数据，作用是将数据包从源地址发送到目的地址。&lt;/p&gt;&lt;p&gt;TCP/IP 分层中的网络层与传输层的功能通常由&lt;strong&gt;操作系统&lt;/strong&gt;提供。 路由器就是通过网络层实现&lt;strong&gt;转发数据包&lt;/strong&gt;的功能。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.31893687707641194&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhgmia5jI0BhocAEYoZp4Yy0fkguHEsFOAUcJRiaw0wjtfq6z3r17tXyxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;602&quot; title=&quot;网络层&quot;/&gt;&lt;figcaption&gt;网络层&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;网络传输中，每个节点会根据数据的地址信息，来判断该报文应该由哪个网卡发送出去。各个地址会参考一个发出接口列表， MAC 寻址中所参考的这张表叫做 &lt;strong&gt;MAC 地址转发表&lt;/strong&gt;，而 IP 寻址中所参考的叫做&lt;strong&gt;路由控制表&lt;/strong&gt;。MAC 地址转发表根据自学自动生成。路由控制表则根据路由协议自动生成。MAC 地址转发表中所记录的是实际的 MAC 地址本身，而路由表中记录的 IP 地址则是集中了之后的网络号（即网络号与子网掩码）。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;IP&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;IP 是跨越网络传送数据包，使用 IP 地址作为主机的标识，使整个互联网都能收到数据的协议。IP 协议独立于底层介质，实现从源到目的的数据转发。IP 协议不具有重发机制，属于非可靠性传输协议。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;ICMP&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;用于在 IP 主机、路由器之间传递控制消息，用来诊断网络的健康状况。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;ARP&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从数据包的 IP 地址中解析出 MAC 地址的一种协议。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;传输层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;相当于 OSI 模型中的第 4 层传输层，主要功能就是让应用程序之间互相通信，通过&lt;strong&gt;端口号&lt;/strong&gt;识别应用程序，使用的协议有面向连接的 &lt;strong&gt;TCP&lt;/strong&gt; 协议和面向无连接的 &lt;strong&gt;UDP&lt;/strong&gt; 协议。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;面向连接&lt;/strong&gt;是在发送数据之前， 在收发主机之间连接一条逻辑通信链路。好比平常打电话，输入完对方电话号码拨出之后，只有对方接通电话才能真正通话，通话结束后将电话机扣上就如同切断电源。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;面向无连接&lt;/strong&gt;不要求建立和断开连接。发送端可于任何时候自由发送数据。如同去寄信，不需要确认收件人信息是否真实存在，也不需要确认收件人是否能收到信件，只要有个寄件地址就可以寄信了。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3768472906403941&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibh1FDAMrFcLpUrjPv5QwO1NIxdTdsaSxMYQRVd6SGx37kmLAjwlN8uTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;812&quot; title=&quot;传输层&quot;/&gt;&lt;figcaption&gt;传输层&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;应用层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;相当于 OSI 模型中的第 5 - 7 层的集合，不仅要实现 OSI 模型应用层的功能，还要实现会话层和表示层的功能。HTTP 、 POP3 、 TELNET 、 SSH 、 FTP 、 SNMP都是应用层协议。&lt;/p&gt;&lt;p&gt;TCP/IP 应用的架构绝大多数属于&lt;strong&gt;客户端/服务端&lt;/strong&gt;模型。提供服务的程序叫服务端， 接受服务的程序叫客户端。客户端可以随时发送请求给服务端。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3768472906403941&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhyKGe6YR44yJCG4CDH00V7a4gPZtxy7gPVpKAFEOFBQCDPiaRJstBTwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;812&quot; title=&quot;应用层&quot;/&gt;&lt;figcaption&gt;应用层&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;HTTP&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;是 WWW 浏览器和服务器之间的应用层通信协议，所传输数据的主要格式是 HTML 。HTTP 定义高级命令或者方法供浏览器用来与Web服务器通信。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;POP3&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;简单邮件传输协议，邮件客户端和邮件服务器使用。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;TELNET 和 SSH&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;远程终端协议，用于远程管理网络设备。TELNET 是明文传输， SSH 是加密传输。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;SNMP&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;简单网络管理协议，用于网管软件进行网络设备的监控和管理。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;封装与解封装&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;通常，为协议提供的信息为包&lt;strong&gt;头部&lt;/strong&gt;，所要发送的内容为&lt;strong&gt;数据&lt;/strong&gt;。每个分层中，都会对所发送的数据附加一个头部，在这个头部中包含了该层必要的信息， 如发送的目标地址以及协议相关信息。在下一层的角度看，从上一分层收到的包全部都被认为是本层的数据。&lt;/p&gt;&lt;p&gt;数据发送前，按照参考模型从上到下，在数据经过每一层时，添加协议报文头部信息，这个过程叫&lt;strong&gt;封装&lt;/strong&gt;。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2861378799110452&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhXtASosjXf7a0LethmCGpQMX5nriaOPCWyIvHMYiaHPECaUpAmaLicnggg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1349&quot; title=&quot;封装&quot;/&gt;&lt;figcaption&gt;封装&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;数据接收后，按照参考模型从下到上，在数据经过每一层时，去掉协议头部信息，这个过程叫&lt;strong&gt;解封装&lt;/strong&gt;。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2861378799110452&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhkVS7NZXRM4IYDAYFPvM2rKT9sNLfcg7Q9PLGvibevEjL5raXNibUicLPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1349&quot; title=&quot;解封装&quot;/&gt;&lt;figcaption&gt;解封装&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;经过传输层协议封装后的数据称为&lt;strong&gt;段&lt;/strong&gt;，经过网络层协议封装后的数据称为&lt;strong&gt;包&lt;/strong&gt;，经过数据链路层协议封装后的数据称为&lt;strong&gt;帧&lt;/strong&gt;，物理层传输的数据为&lt;strong&gt;比特&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;TCP/IP 通信中使用 MAC 地址、 IP 地址、端口号等信息作为&lt;strong&gt;地址标识&lt;/strong&gt;。甚至在应用层中，可以将电子邮件地址作为网络通信的地址。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;实际数据传输举例&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;实际生活中，互联网是使用的 TCP/IP 协议进行网络连接的。我们以&lt;strong&gt;访问网站&lt;/strong&gt;为例，看看网络是如何进行通信的。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4305750350631136&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibh4ortuHsDtNOO0wck96WUJX55pIDLJPhZAcFtbKprtVawgklvThCkcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1426&quot; title=&quot;数据传输举例&quot;/&gt;&lt;figcaption&gt;数据传输举例&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5&gt;&lt;span&gt;发送数据包&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;访问 HTTP 网站页面时，打开浏览器，输入网址，敲下回车键就开始进行 TCP/IP 通信了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;应用程序处理&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7429305912596401&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhLwc6n2P5M6fwW9obU0DWdXeoich6EHxLtohob84qjj4LE0NBxCMBLOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;778&quot; title=&quot;应用层&quot;/&gt;&lt;figcaption&gt;应用层&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;首先，应用程序中会进行 HTML 格式&lt;strong&gt;编码&lt;/strong&gt;处理，相当于 OSI 的表示层功能。编码转化后，不一定会马上发送出去，相当于会话层的功能。在请求发送的那一刻，建立 TCP 连接，然后在 TCP 连接上发送数据。接下来就是将数据发送给下一层的 TCP 进行处理。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;TCP 模块处理&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7429305912596401&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhOTXiaE6HEHCITq3X6icFDsdwUAv9UTrUichKVibSEBUtzt1IseM7GKlQww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;778&quot; title=&quot;传输层&quot;/&gt;&lt;figcaption&gt;传输层&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;TCP 会将应用层发来的数据顺利的发送至目的地。实现可靠传输的功能，需要给数据封装 TCP 头部信息。TCP 头部信息包括源端口号和目的端口号（识别主机上应用）、序号（确认哪部分是数据）以及校验和（判断数据是否被损坏）。随后&lt;strong&gt;封装&lt;/strong&gt;了 TCP 头部信息的段再发送给 IP 。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;IP  模块处理&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7429305912596401&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhKsAaleKcoqDgOHVfmQrPNmG0JypanWX6L4T9fUT1GrxxtCA2GRu95w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;778&quot; title=&quot;网络层&quot;/&gt;&lt;figcaption&gt;网络层&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;IP 将 TCP 传过来的数据段当做自己的数据，并封装 IP 头部信息。IP 头部信息中包含目的 IP 地址和源 IP 地址，以及上层协议类型信息。&lt;/p&gt;&lt;p&gt;IP 包生成后，根据主机&lt;strong&gt;路由表&lt;/strong&gt;进行数据发送。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;网络接口处理&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7419768934531451&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibh7fzBhQp6RyUz6tOPy9xomnB1jd4aThwQ5HS4N3hWn7jI3ic4TKXYYfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;779&quot; title=&quot;物理层&quot;/&gt;&lt;figcaption&gt;物理层&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;网络接口对传过来的 IP 包封装上以太网头部信息并进行发送处理。以太网头部信息包含目的 MAC 地址、源 MAC 地址，以及上层协议类型信息。然后将以太网数据&lt;strong&gt;帧&lt;/strong&gt;通过物理层传输给接收端。发送处理中的 FCS 由硬件计算， 添加到包的最后。设置 FCS 的目的是为了判断数据包是否由于噪声而被破坏。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;接收数据包&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;包的接收流程是发送流程的&lt;strong&gt;反向&lt;/strong&gt;过程。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;网络接口处理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;收到以太网包后，首先查看头部信息的目的 MAC 地址是否是发给自己的包。如果不是发送给自己的包就丢弃。如果是发送给自己的包，查看上层协议类型是 IP 包，以太网帧&lt;strong&gt;解封装&lt;/strong&gt;成 IP 包，传给 IP 模块进行处理。如果是无法识别的协议类型，则丢弃数据。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6457326892109501&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhZwvGQn8dLX5tvDwm5IevaicQJ93IkUnmMr2UFtEaBNxDRoPuib9dol6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;621&quot; title=&quot;网口处理流程&quot;/&gt;&lt;figcaption&gt;网口处理流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;IP  模块处理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;收到 IP 包后，进行类似处理。根据头部信息的目的 IP 地址判断是否是发送给自己包，如果是发送给自己的包，则查看上一层的协议类型。上一层协议是 TCP ，就把 IP 包解封装发送给 TCP 协议处理。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6457326892109501&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhQcwR7udwGoJ6pUWwGZ4nDcwMzkesJgpz6XC7l5R5FEsdqMrdpcf69Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;621&quot; title=&quot;IP模块处理流程&quot;/&gt;&lt;figcaption&gt;IP模块处理流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;假如有路由器，且接收端不是自己的地址，那么根据路由控制表转发数据。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3843594009983361&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhsBdTzwAicib1BGuUPk7DyKfWKeWIo1b5zdPibjkjZ55xWYg9iblkyfSjaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;601&quot; title=&quot;路由器处理流程&quot;/&gt;&lt;figcaption&gt;路由器处理流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;TCP 模块处理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;收到 TCP 段后，首先查看校验和，判断数据是否被破坏。然后检查是否按照序号接收数据。最后检查端口号，确定具体的应用程序。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.16542473919523099&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhUqvcpibJSeLPS8nqFxDAHwKibMlVvcRfKHhqnNSd7x8ZSHGQbZIiaH0vQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;671&quot; title=&quot;TCP模块处理流程&quot;/&gt;&lt;figcaption&gt;TCP模块处理流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;数据接收完毕后，发送一个 “ &lt;strong&gt;确认回执&lt;/strong&gt; ” 给发送端。如果这个回执信息未能达到发送端，那么发送端会认为接收端没有接收到数据而一直反复发送。&lt;/p&gt;&lt;p&gt;数据被完整接收后，会把 TCP 段解封装发送给由端口号识别的应用程序。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;应用程序处理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;应用程序收到数据后，通过解析数据内容获知发送端请求的网页内容，然后按照 HTTP 协议进行后续数据交互。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;网络构成&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7861507128309573&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhn9MmOLTT0pav1aX6MZ4UzlR1K7wNlgjPemvau0UbHprOViaxketCqyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;982&quot; title=&quot;网络构成要素&quot;/&gt;&lt;figcaption&gt;网络构成要素&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;搭建一套网络涉及各种线缆和网络设备。下面介绍一些常见的&lt;strong&gt;硬件设备&lt;/strong&gt;。硬件设备所说的层数是参照的 OSI 参考模型，而不是 TCP/IP 模型。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.446693657219973&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhypAKLNMIx5dndIiaIQokN7MbxEialnmh19eqSyQMv6n5x9xmy5r0CY1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;741&quot; title=&quot;主要设备及作用表&quot;/&gt;&lt;figcaption&gt;主要设备及作用表&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;通信介质与数据链路&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;设备之间通过线缆进行连接。有线线缆有双绞线、光纤、串口线等。根据数据链路不同选择对应的线缆。传输介质还可以被分为电波、微波等不同类型的电磁波。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;传输速率&lt;/strong&gt;：单位为 &lt;code&gt;bps&lt;/code&gt; ，是指单位时间内传输的数据量有多少。又称作带宽，带宽越大网络传输能力就越强。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;吞吐量&lt;/strong&gt;：单位为 &lt;code&gt;bps&lt;/code&gt; ，主机之间实际的传输速率。吞吐量这个词不仅衡量带宽， 同时也衡量主机的 CPU 处理能力、 网络的拥堵程度、 报文中数据字段的占有份额等信息。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;网卡&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;任一主机连接网络时，必须要使用网卡。可以是有线网卡，用来连接有线网络，也可以是无线网卡连接 WiFi 网络。每块网卡都有一个唯一的 &lt;strong&gt;MAC 地址&lt;/strong&gt;，也叫做硬件地址或物理地址。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.14342629482071714&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhsKiajcpoicn0WnkaLnktxBeUb0wLJeqvzwWicElHX0MTomfIrFV2EaXGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;502&quot; title=&quot;网卡&quot;/&gt;&lt;figcaption&gt;网卡&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;二层交换机&lt;/span&gt;&lt;/h4&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4560530679933665&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhGY3ImSAnriaBViaXTicFJmUrxOdGmZFnIFDtVpX5dYZkud9vXvgSaUAlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;603&quot; title=&quot;二层交换机&quot;/&gt;&lt;figcaption&gt;二层交换机&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;二层交换机位于 OSI 模型的第 2 层（数据链路层）。它能够识别数据链路层中的数据帧，并将帧转发给相连的另一个数据链路。&lt;/p&gt;&lt;p&gt;数据帧中有一个数据位叫做 &lt;strong&gt;FCS&lt;/strong&gt; ，用以校验数据是否正确送达目的地。二层交换机通过检查这个值，将损坏的数据丢弃。&lt;/p&gt;&lt;p&gt;二层交换机根据 MAC 地址&lt;strong&gt;自学机制&lt;/strong&gt;判断是否需要转发数据帧。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;路由器 / 三层交换机&lt;/span&gt;&lt;/h4&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2341897233201581&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhOsmuMplIHm41ne78tjlVT5Vk5rNuxacibkiazzZiazMBbySy4Wa6Hd4Xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1012&quot; title=&quot;路由器&quot;/&gt;&lt;figcaption&gt;路由器&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;路由器是在 OSI 模型的第 3 层（网络层）上连接两个网络、并对报文进行转发的设备。二层交换机是根据 MAC 地址进行处理，而路由器 / 三层交换机则是根据 &lt;strong&gt;IP 地址&lt;/strong&gt;进行处理的。因此 TCP/IP 中网络层的地址就成为了 IP 地址。&lt;/p&gt;&lt;p&gt;路由器可以连接不同的数据链路。比如连接两个以太网，或者连接一个以太网与一个无线网。家庭里面常见的无线路由器也是路由器的一种。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;四至七层交换机&lt;/span&gt;&lt;/h4&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.36585365853658536&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibheJZpf1ccQlLUFiavVb4eT7L7lyeduEHgkKTcF5kic5ia77dzcJjR3jTibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;902&quot; title=&quot;负载均衡设备&quot;/&gt;&lt;figcaption&gt;负载均衡设备&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;四至七层交换机负责处理 OSI 模型中从传输层至应用层的数据。以 TCP 等协议的传输层及其上面的应用层为基础，分析收发数据，并对其进行特定的处理。例如，视频网站的一台服务器不能满足访问需求，通过&lt;strong&gt;负载均衡设备&lt;/strong&gt;将访问分发到后台多个服务器上，就是四至七层交换机的一种。还有带宽控制、广域网加速器、防火墙等应用场景。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4147398843930636&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibh5tkzzM4hGNboia7uWSOpSOvG85R9xwlZSwg4f7mSHL0L0FuOh0w3DzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1384&quot; title=&quot;总结&quot;/&gt;&lt;figcaption&gt;总结&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;应用层设备有电脑、手机、服务器等。应用层设备&lt;strong&gt;不转发数据&lt;/strong&gt;，它们是&lt;strong&gt;数据的源或目的&lt;/strong&gt;，拥有应用层以下的各层功能。发送数据时，从上而下的顺序，逐层对数据进行封装，再通过以太网将数据发送出去。接收数据时，从下而上的顺序，逐层对数据进行解封装，最终恢复成原始数据。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9534883720930233&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhmPxTe3pbnXCo721tiaJVibU5ltqM173MoeanBtszdUibwDxlBBLq7xibuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;602&quot; title=&quot;应用层处理流程&quot;/&gt;&lt;figcaption&gt;应用层处理流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;数据链路层设备有二层交换机、网桥等。二层网络设备&lt;strong&gt;只转发数据&lt;/strong&gt;，通过识别数据的 &lt;strong&gt;MAC 地址&lt;/strong&gt;进行转发。二层交换机接收数据后，对数据最外层封装的以太网头部信息进行查看，看到数据的目的 MAC 地址后，把数据帧从对应端口发送出去。交换机并不会对数据帧进行解封装，只要知道 MAC 地址信息就可以正确地将数据转发出去。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3681592039800995&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibh25KFSbickc9wFSqMDO5auBdJRaK5DWCwzQRgvOv3YG0CkjKqebgNZCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;603&quot; title=&quot;数据链路层处理流程&quot;/&gt;&lt;figcaption&gt;数据链路层处理流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;网络层设备有路由器、三层交换机等。三层网络设备&lt;strong&gt;只转发数据&lt;/strong&gt;，通过识别数据的 &lt;strong&gt;IP 地址&lt;/strong&gt;进行转发。路由器接收数据后，首先查看最外层封装的以太网头部信息，当目的 MAC 地址是自己时，就会将以太网头部解封装，查看数据的 IP 地址。根据 IP 路由表做出转发决定时，路由器会把下一跳设备的 MAC 地址作为以太网头部的目的 MAC 地址，重新封装以太网头部并将数据转发出去。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5008291873963516&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhaiaoicM05qyZSlvlZfb2ibgdhyHibiaR3ZDLia13UibAzkJlLia1CzfbFhudicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;603&quot; title=&quot;网络层处理流程&quot;/&gt;&lt;figcaption&gt;网络层处理流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;转发数据的网络设备和应用层的数据，就像&lt;strong&gt;快递员&lt;/strong&gt;和&lt;strong&gt;包裹&lt;/strong&gt;一样。快递员根据目的地址运送包裹，不必了解包裹里的具体内容。&lt;/p&gt;&lt;p&gt;通过分层功能来区分网络设备已经不再适用，交换机集成三层路由功能就是三层交换机，无线AP集成路由器功能就是无线路由器。但是为了方便说明，通常是介绍单个设备的功能和原理。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.21212121212121213&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhmT3nzrMKm4ao3lvcr0do8j1VmDP3rC9ic757aboyF9GJ5qTNJpFnXow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;462&quot; title=&quot;无线路由器&quot;/&gt;&lt;figcaption&gt;无线路由器&lt;/figcaption&gt;&lt;/figure&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;图解TCP/IP - 竹下隆史&lt;/p&gt;&lt;p&gt;网络基础 - 田果&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>