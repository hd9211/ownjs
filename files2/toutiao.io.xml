<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>570576c0bf7854777c6a77574da6ff88</guid>
<title>资料 | 英语进阶指南</title>
<link>https://toutiao.io/k/4yqc5t5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f325e6d223643985b5499921cab9a604</guid>
<title>优质网站同好者周刊（第 5 期）</title>
<link>https://toutiao.io/k/ubsth9i</link>
<content:encoded>&lt;div&gt;&lt;html lang=&quot;zh-CN&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;/&gt;
  

    &lt;title&gt;优质网站同好者周刊（第 5 期）- 倾城之链 | 晚晴幽草轩&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,user-scalable=no&quot;/&gt;
    
    &lt;meta name=&quot;author&quot; content=&quot;晚晴幽草轩轩主&quot;/&gt;
    
    &lt;meta name=&quot;theme-color&quot; content=&quot;#fffffb&quot;/&gt;
    &lt;meta name=&quot;baidu-site-verification&quot; content=&quot;PKEtLPjO56&quot;/&gt;
    

    &lt;meta name=&quot;keywords&quot; content=&quot;倾城之链, 优质网站, 开放平台, 倾城&quot;/&gt;
    &lt;meta name=&quot;description&quot; content=&quot;倾城之链作为一个开放平台，旨在云集全球优秀网站，探索互联网中更广阔的世界。此周刊，将汇聚过去一周倾城所收录的内容，以飨同好；欢迎推荐或自荐（仅限有独立域名的网站，可以是二级域名）。您如果要了解收录要求，请参见关于倾城。&quot;/&gt;
&lt;meta property=&quot;og:type&quot; content=&quot;article&quot;/&gt;
&lt;meta property=&quot;og:title&quot; content=&quot;优质网站同好者周刊（第 5 期）- 倾城之链&quot;/&gt;
&lt;meta property=&quot;og:url&quot; content=&quot;https://www.jeffjade.com/2021/03/18/188-nicelinks-weekly-006/index.html&quot;/&gt;
&lt;meta property=&quot;og:site_name&quot; content=&quot;晚晴幽草轩&quot;/&gt;
&lt;meta property=&quot;og:description&quot; content=&quot;倾城之链作为一个开放平台，旨在云集全球优秀网站，探索互联网中更广阔的世界。此周刊，将汇聚过去一周倾城所收录的内容，以飨同好；欢迎推荐或自荐（仅限有独立域名的网站，可以是二级域名）。您如果要了解收录要求，请参见关于倾城。&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/forum.lovejade.cn.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/www.gitpod.io.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/defonic.com.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/rainbowhunt.com.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/mouto.org.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/coder.com.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/embed.so.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://image.nicelinks.site/%E5%80%BE%E5%9F%8E%E4%B9%8B%E9%93%BE-%E5%BE%AE%E4%BF%A1-mini.jpeg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://image.nicelinks.site/nicelinks-miniprogram-code.jpeg?imageView2/1/w/300/h/300/interlace/1/ignore-error/1&quot;/&gt;
&lt;meta property=&quot;og:updated_time&quot; content=&quot;2021-03-20T03:21:08.828Z&quot;/&gt;
&lt;meta name=&quot;twitter:card&quot; content=&quot;summary&quot;/&gt;
&lt;meta name=&quot;twitter:title&quot; content=&quot;优质网站同好者周刊（第 5 期）- 倾城之链&quot;/&gt;
&lt;meta name=&quot;twitter:description&quot; content=&quot;倾城之链作为一个开放平台，旨在云集全球优秀网站，探索互联网中更广阔的世界。此周刊，将汇聚过去一周倾城所收录的内容，以飨同好；欢迎推荐或自荐（仅限有独立域名的网站，可以是二级域名）。您如果要了解收录要求，请参见关于倾城。&quot;/&gt;
&lt;meta name=&quot;twitter:image&quot; content=&quot;https://oss.nicelinks.site/forum.lovejade.cn.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta name=&quot;twitter:creator&quot; content=&quot;@nicejadeyang&quot;/&gt;

    
    
    
    
    
    
    
    
    
    

    
    
    

    
    
    
    
    

    
    
    

    
    
    
    
    
    
&lt;/head&gt;&lt;/html&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>171742333c9d0f69e8dc4810f34d11a8</guid>
<title>写给开发人员的实用密码学：非对称加密算法</title>
<link>https://toutiao.io/k/ajk71ed</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面的文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3NTQyMzEzNQ==&amp;amp;mid=2247486210&amp;amp;idx=1&amp;amp;sn=a63107bab37b9406f19a2ca7e5a0ba2e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;写给开发人员的实用密码学 - 对称加密算法&lt;/a&gt;》中，介绍了现代密码学中非常重要的加密解密算法。从工程学的角度，选取密钥足够长的加密算法（比如AES 256、AES 512），是无法破解的。但在对称加密算法中，存在明显的薄弱环节，那就是密钥的存储与分发。因为算法是公开的，那么决定加密系统是否安全的因素就是密钥。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而在开放的互联网环境下，如何高效分发密钥成了一个难题。比如一个服务器，可能会服务千万级的用户，如果为每个用户分配不同的密钥，那密钥的维护是个大问题。密钥发放也是问题，如果是企业内部，还可以通过邮件发送密钥，但在开放的互联网上，这种方式行不通。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公开密钥算法（Public KeyCryptography），也称为非对称加密算法（Asymmetrical Cryptography），可以用于解决这一难题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顾名思义，非对称加密算法就是加密密钥和解密密钥不是同一个。算法的密钥是一对，分别是公钥（public key）和私钥（private key）。一般私钥由密钥对的生成方（比如服务器端）持有，避免泄露，而公钥任何人都可以持有，也不怕泄露。这里没有使用加密密钥和解密密钥，是因为公钥和私钥都可以用来加密，也可以用来解密。如果使用公钥加密，就要使用私钥解密，反之依然。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公开密钥算法不是一个算法而是一组算法，通常提供如下算法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;密钥对生成：生成随机对的私钥+对应的公钥。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加密/解密：通过公钥加密数据，并通过私钥解密数据（通常使用混合加密方案）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数字签名（消息认证）：通过私钥对消息签名，并通过公钥验证签名。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;密钥交换算法：通过不安全的通道在两方之间安全地交换加密密钥。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果公开密钥算法用于加密解密运算，习惯上称为非对称加密算法。非对称加密算法的加密解密过程如下图所示。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2885572139303483&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibQ4mtgHYXv6I2wbKslbeib7VTCdtGvpyrr2EL4yJL8XZVvITsV9ibAoeNwHNoZp42qwiavWZYDrdqtKtiaZAaHicT1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;402&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前非对称加密算法还无法取代对称加密算法，相比对称加密算法来说，公开密钥算法尤其是RSA算法运算非常缓慢，一般情况下，需要加密的明文数据都非常大，如果使用公开密钥算法进行加密，运算性能会惨不忍睹。公开密钥算法在密码学中一般进行密钥协商或者数字签名，因为这两者运算的数据相对较小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前，最重要和最常用的公钥密码系统是 RSA 和 椭圆曲线密码算法（ECC）。推荐使用 ECC，因为它具有较小的密钥，较短的签名和更好的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;国密 SM2 算法就是一种 ECC 算法，所以下面着重讲一讲 ECC。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ECC 算法&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ECC是比离散对数类算法（比如RSA和DH算法）更复杂的算法，非常难于理解，本身也是很复杂的一个结构体，在理解起来的时候有一定的难度。不理解ECC理论知识没有关系，但需要了解以下这张图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.695&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibQ4mtgHYXv6I2wbKslbeib7VTCdtGvpyrJNra3zLFMuzsjTr3Mxo7JLicGoaCkj7h4HHfVibfKyuWtkFfMaVEjRlw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ECC椭圆曲线由很多点组成，这些点由特定的方程式组成的，比如方程式可以是y^2 = x^3 + ax + b，这些点连接起来就是一条曲线，但曲线并不是一个椭圆。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;椭圆曲线有个特点，任意两个点能够得到这条椭圆曲线上的另外一点，这个操作称为打点，经过多次（比如d次）打点后，能够生成一个最终点（F）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的图中，A点称为基点（G）或者生成器。A可以和自己打点从而生成B点，在实际应用的时候，一般有基点就可以了。经过多次打点，就得到了最终点G。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ECC密码学的关键点就在于就算知道具体方程式、基点（G）、最终点（F），也无法知晓一共打点了多少次（d）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ECC中，打点次数(d)就是私钥，这通常是一个随机数，公钥就是最终点（F)，包含(x，y)两个分量，通常组合成一个数字来传输和存储。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ECC由方程式（比如a、b这样的方程式参数）、基点（G）、质数（P）组成。理论上方程式和各种参数组合可以是任意的，但是在密码学中，为了安全，系统预先定义了一系列的曲线，称为命名曲线（name curve），比如secp256k1就是一个命名曲线。对于开发者而言，在使用ECC密码学的时候，就是选择具体的命名曲线。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;命名曲线&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ECC本质上就是一个数学公式，任何人基于公式都可以设计出椭圆曲线，在实现的时候一定要注意ECC离散对数问题（Elliptic-Curve Discrete-Logarithm Problem，简称ECDLP），如果实现不当，那么ECC公式就会存在安全风险。为了简化ECC的使用，可以选用设计规范的命名曲线，命名曲线中包含了ECC椭圆曲线的参数，比如基点、有限域等，对于大部分开发者来说，如果要使用ECC椭圆曲线，要做的就是选择一条安全且性能高的命名曲线。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的命名曲线有 secp192r1、secp256r1、secp384r1、secp512r1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用GmSSL命令行可以查看所实现的命名曲线。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ gmssl ecparam -list_curves&lt;br/&gt;  secp112r1 : SECG/WTLS curve over a 112 bit prime field&lt;br/&gt;  secp112r2 : SECG curve over a 112 bit prime field&lt;br/&gt;  secp128r1 : SECG curve over a 128 bit prime field&lt;br/&gt;  secp128r2 : SECG curve over a 128 bit prime field&lt;br/&gt;  secp160k1 : SECG curve over a 160 bit prime field&lt;br/&gt;  secp160r1 : SECG curve over a 160 bit prime field&lt;br/&gt;  secp160r2 : SECG/WTLS curve over a 160 bit prime field&lt;br/&gt;  secp192k1 : SECG curve over a 192 bit prime field&lt;br/&gt;  secp224k1 : SECG curve over a 224 bit prime field&lt;br/&gt;  secp224r1 : NIST/SECG curve over a 224 bit prime field&lt;br/&gt;  secp256k1 : SECG curve over a 256 bit prime field&lt;br/&gt;  secp384r1 : NIST/SECG curve over a 384 bit prime field&lt;br/&gt;  secp521r1 : NIST/SECG curve over a 521 bit prime field&lt;br/&gt;  prime192v1: NIST/X9.62/SECG curve over a 192 bit prime field&lt;br/&gt;  prime192v2: X9.62 curve over a 192 bit prime field&lt;br/&gt;  prime192v3: X9.62 curve over a 192 bit prime field&lt;br/&gt;  prime239v1: X9.62 curve over a 239 bit prime field&lt;br/&gt;  prime239v2: X9.62 curve over a 239 bit prime field&lt;br/&gt;  prime239v3: X9.62 curve over a 239 bit prime field&lt;br/&gt;  prime256v1: X9.62/SECG curve over a 256 bit prime field&lt;br/&gt;  sect113r1 : SECG curve over a 113 bit binary field&lt;br/&gt;  sect113r2 : SECG curve over a 113 bit binary field&lt;br/&gt;  sect131r1 : SECG/WTLS curve over a 131 bit binary field&lt;br/&gt;  sect131r2 : SECG curve over a 131 bit binary field&lt;br/&gt;  sect163k1 : NIST/SECG/WTLS curve over a 163 bit binary field&lt;br/&gt;  sect163r1 : SECG curve over a 163 bit binary field&lt;br/&gt;  sect163r2 : NIST/SECG curve over a 163 bit binary field&lt;br/&gt;  sect193r1 : SECG curve over a 193 bit binary field&lt;br/&gt;  sect193r2 : SECG curve over a 193 bit binary field&lt;br/&gt;  sect233k1 : NIST/SECG/WTLS curve over a 233 bit binary field&lt;br/&gt;  sect233r1 : NIST/SECG/WTLS curve over a 233 bit binary field&lt;br/&gt;  sect239k1 : SECG curve over a 239 bit binary field&lt;br/&gt;  sect283k1 : NIST/SECG curve over a 283 bit binary field&lt;br/&gt;  sect283r1 : NIST/SECG curve over a 283 bit binary field&lt;br/&gt;  sect409k1 : NIST/SECG curve over a 409 bit binary field&lt;br/&gt;  sect409r1 : NIST/SECG curve over a 409 bit binary field&lt;br/&gt;  sect571k1 : NIST/SECG curve over a 571 bit binary field&lt;br/&gt;  sect571r1 : NIST/SECG curve over a 571 bit binary field&lt;br/&gt;  c2pnb163v1: X9.62 curve over a 163 bit binary field&lt;br/&gt;  c2pnb163v2: X9.62 curve over a 163 bit binary field&lt;br/&gt;  c2pnb163v3: X9.62 curve over a 163 bit binary field&lt;br/&gt;  c2pnb176v1: X9.62 curve over a 176 bit binary field&lt;br/&gt;  c2tnb191v1: X9.62 curve over a 191 bit binary field&lt;br/&gt;  c2tnb191v2: X9.62 curve over a 191 bit binary field&lt;br/&gt;  c2tnb191v3: X9.62 curve over a 191 bit binary field&lt;br/&gt;  c2pnb208w1: X9.62 curve over a 208 bit binary field&lt;br/&gt;  c2tnb239v1: X9.62 curve over a 239 bit binary field&lt;br/&gt;  c2tnb239v2: X9.62 curve over a 239 bit binary field&lt;br/&gt;  c2tnb239v3: X9.62 curve over a 239 bit binary field&lt;br/&gt;  c2pnb272w1: X9.62 curve over a 272 bit binary field&lt;br/&gt;  c2pnb304w1: X9.62 curve over a 304 bit binary field&lt;br/&gt;  c2tnb359v1: X9.62 curve over a 359 bit binary field&lt;br/&gt;  c2pnb368w1: X9.62 curve over a 368 bit binary field&lt;br/&gt;  c2tnb431r1: X9.62 curve over a 431 bit binary field&lt;br/&gt;  wap-wsg-idm-ecid-wtls1: WTLS curve over a 113 bit binary field&lt;br/&gt;  wap-wsg-idm-ecid-wtls3: NIST/SECG/WTLS curve over a 163 bit binary field&lt;br/&gt;  wap-wsg-idm-ecid-wtls4: SECG curve over a 113 bit binary field&lt;br/&gt;  wap-wsg-idm-ecid-wtls5: X9.62 curve over a 163 bit binary field&lt;br/&gt;  wap-wsg-idm-ecid-wtls6: SECG/WTLS curve over a 112 bit prime field&lt;br/&gt;  wap-wsg-idm-ecid-wtls7: SECG/WTLS curve over a 160 bit prime field&lt;br/&gt;  wap-wsg-idm-ecid-wtls8: WTLS curve over a 112 bit prime field&lt;br/&gt;  wap-wsg-idm-ecid-wtls9: WTLS curve over a 160 bit prime field&lt;br/&gt;  wap-wsg-idm-ecid-wtls10: NIST/SECG/WTLS curve over a 233 bit binary field&lt;br/&gt;  wap-wsg-idm-ecid-wtls11: NIST/SECG/WTLS curve over a 233 bit binary field&lt;br/&gt;  wap-wsg-idm-ecid-wtls12: WTLS curve over a 224 bit prime field&lt;br/&gt;  Oakley-EC2N-3: &lt;br/&gt;        IPSec/IKE/Oakley curve &lt;span&gt;#3 over a 155 bit binary field.&lt;/span&gt;&lt;br/&gt;        Not suitable &lt;span&gt;for&lt;/span&gt; ECDSA.&lt;br/&gt;        Questionable extension field!&lt;br/&gt;  Oakley-EC2N-4: &lt;br/&gt;        IPSec/IKE/Oakley curve &lt;span&gt;#4 over a 185 bit binary field.&lt;/span&gt;&lt;br/&gt;        Not suitable &lt;span&gt;for&lt;/span&gt; ECDSA.&lt;br/&gt;        Questionable extension field!&lt;br/&gt;  brainpoolP160r1: RFC 5639 curve over a 160 bit prime field&lt;br/&gt;  brainpoolP160t1: RFC 5639 curve over a 160 bit prime field&lt;br/&gt;  brainpoolP192r1: RFC 5639 curve over a 192 bit prime field&lt;br/&gt;  brainpoolP192t1: RFC 5639 curve over a 192 bit prime field&lt;br/&gt;  brainpoolP224r1: RFC 5639 curve over a 224 bit prime field&lt;br/&gt;  brainpoolP224t1: RFC 5639 curve over a 224 bit prime field&lt;br/&gt;  brainpoolP256r1: RFC 5639 curve over a 256 bit prime field&lt;br/&gt;  brainpoolP256t1: RFC 5639 curve over a 256 bit prime field&lt;br/&gt;  brainpoolP320r1: RFC 5639 curve over a 320 bit prime field&lt;br/&gt;  brainpoolP320t1: RFC 5639 curve over a 320 bit prime field&lt;br/&gt;  brainpoolP384r1: RFC 5639 curve over a 384 bit prime field&lt;br/&gt;  brainpoolP384t1: RFC 5639 curve over a 384 bit prime field&lt;br/&gt;  brainpoolP512r1: RFC 5639 curve over a 512 bit prime field&lt;br/&gt;  brainpoolP512t1: RFC 5639 curve over a 512 bit prime field&lt;br/&gt;  sm2p256v1 : SM2 curve over a 256 bit prime field&lt;br/&gt;  wapip192v1: WAPI curve over a 192 bit prime field&lt;br/&gt;  sm9bn256v1: SM9 BN curve over a 256 bit prime field&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 sm2p256v1、wapip192v1、sm9bn256v1 就是国密定义的命名曲线。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;国密SM2算法&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SM2算法就是一种ECC算法，准确来说，就是设计了一条ECC命名曲线。在《GMT 0003-2012》这份标准中，有SM2算法的设计背景知识，有兴趣的可以了解，对于开发者而言，最重要的是《GMT 0005-2012》标准中的曲线参数：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3490740740740741&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibQ4mtgHYXv6I2wbKslbeib7VTCdtGvpyrd5qNW1iaH3hL8KPKCliaveDlpXIA7AkZibF6Xpc8yvMibYPqK3KAKAVDVg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在的网络库，比如NSS、OpenSSL、libtomcrypt等，都有ECC算法的支持，要在网络库中加入SM2算法支持，只需加入命名曲线的参数即可。比如在GmSSL代码的 ec_curve.c 文件中就有 sm2p256v1 命名曲线的参数定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    EC_CURVE_DATA h;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; data[&lt;span&gt;0&lt;/span&gt; + &lt;span&gt;32&lt;/span&gt; * &lt;span&gt;6&lt;/span&gt;];&lt;br/&gt;} _EC_SM2_PRIME_256V1 = {&lt;br/&gt;    {&lt;br/&gt;        NID_X9_62_prime_field, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;/* no seed */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;/* p */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFE&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0x00&lt;/span&gt;, &lt;span&gt;0x00&lt;/span&gt;, &lt;span&gt;0x00&lt;/span&gt;, &lt;span&gt;0x00&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;/* a */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFE&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0x00&lt;/span&gt;, &lt;span&gt;0x00&lt;/span&gt;, &lt;span&gt;0x00&lt;/span&gt;, &lt;span&gt;0x00&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFC&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;/* b */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x28&lt;/span&gt;, &lt;span&gt;0xE9&lt;/span&gt;, &lt;span&gt;0xFA&lt;/span&gt;, &lt;span&gt;0x9E&lt;/span&gt;, &lt;span&gt;0x9D&lt;/span&gt;, &lt;span&gt;0x9F&lt;/span&gt;, &lt;span&gt;0x5E&lt;/span&gt;, &lt;span&gt;0x34&lt;/span&gt;, &lt;span&gt;0x4D&lt;/span&gt;, &lt;span&gt;0x5A&lt;/span&gt;, &lt;span&gt;0x9E&lt;/span&gt;, &lt;span&gt;0x4B&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;0xCF&lt;/span&gt;, &lt;span&gt;0x65&lt;/span&gt;, &lt;span&gt;0x09&lt;/span&gt;, &lt;span&gt;0xA7&lt;/span&gt;, &lt;span&gt;0xF3&lt;/span&gt;, &lt;span&gt;0x97&lt;/span&gt;, &lt;span&gt;0x89&lt;/span&gt;, &lt;span&gt;0xF5&lt;/span&gt;, &lt;span&gt;0x15&lt;/span&gt;, &lt;span&gt;0xAB&lt;/span&gt;, &lt;span&gt;0x8F&lt;/span&gt;, &lt;span&gt;0x92&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;0xDD&lt;/span&gt;, &lt;span&gt;0xBC&lt;/span&gt;, &lt;span&gt;0xBD&lt;/span&gt;, &lt;span&gt;0x41&lt;/span&gt;, &lt;span&gt;0x4D&lt;/span&gt;, &lt;span&gt;0x94&lt;/span&gt;, &lt;span&gt;0x0E&lt;/span&gt;, &lt;span&gt;0x93&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;/* x */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x32&lt;/span&gt;, &lt;span&gt;0xC4&lt;/span&gt;, &lt;span&gt;0xAE&lt;/span&gt;, &lt;span&gt;0x2C&lt;/span&gt;, &lt;span&gt;0x1F&lt;/span&gt;, &lt;span&gt;0x19&lt;/span&gt;, &lt;span&gt;0x81&lt;/span&gt;, &lt;span&gt;0x19&lt;/span&gt;, &lt;span&gt;0x5F&lt;/span&gt;, &lt;span&gt;0x99&lt;/span&gt;, &lt;span&gt;0x04&lt;/span&gt;, &lt;span&gt;0x46&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;0x6A&lt;/span&gt;, &lt;span&gt;0x39&lt;/span&gt;, &lt;span&gt;0xC9&lt;/span&gt;, &lt;span&gt;0x94&lt;/span&gt;, &lt;span&gt;0x8F&lt;/span&gt;, &lt;span&gt;0xE3&lt;/span&gt;, &lt;span&gt;0x0B&lt;/span&gt;, &lt;span&gt;0xBF&lt;/span&gt;, &lt;span&gt;0xF2&lt;/span&gt;, &lt;span&gt;0x66&lt;/span&gt;, &lt;span&gt;0x0B&lt;/span&gt;, &lt;span&gt;0xE1&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;0x71&lt;/span&gt;, &lt;span&gt;0x5A&lt;/span&gt;, &lt;span&gt;0x45&lt;/span&gt;, &lt;span&gt;0x89&lt;/span&gt;, &lt;span&gt;0x33&lt;/span&gt;, &lt;span&gt;0x4C&lt;/span&gt;, &lt;span&gt;0x74&lt;/span&gt;, &lt;span&gt;0xC7&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;/* y */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0xBC&lt;/span&gt;, &lt;span&gt;0x37&lt;/span&gt;, &lt;span&gt;0x36&lt;/span&gt;, &lt;span&gt;0xA2&lt;/span&gt;, &lt;span&gt;0xF4&lt;/span&gt;, &lt;span&gt;0xF6&lt;/span&gt;, &lt;span&gt;0x77&lt;/span&gt;, &lt;span&gt;0x9C&lt;/span&gt;, &lt;span&gt;0x59&lt;/span&gt;, &lt;span&gt;0xBD&lt;/span&gt;, &lt;span&gt;0xCE&lt;/span&gt;, &lt;span&gt;0xE3&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;0x6B&lt;/span&gt;, &lt;span&gt;0x69&lt;/span&gt;, &lt;span&gt;0x21&lt;/span&gt;, &lt;span&gt;0x53&lt;/span&gt;, &lt;span&gt;0xD0&lt;/span&gt;, &lt;span&gt;0xA9&lt;/span&gt;, &lt;span&gt;0x87&lt;/span&gt;, &lt;span&gt;0x7C&lt;/span&gt;, &lt;span&gt;0xC6&lt;/span&gt;, &lt;span&gt;0x2A&lt;/span&gt;, &lt;span&gt;0x47&lt;/span&gt;, &lt;span&gt;0x40&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;0x02&lt;/span&gt;, &lt;span&gt;0xDF&lt;/span&gt;, &lt;span&gt;0x32&lt;/span&gt;, &lt;span&gt;0xE5&lt;/span&gt;, &lt;span&gt;0x21&lt;/span&gt;, &lt;span&gt;0x39&lt;/span&gt;, &lt;span&gt;0xF0&lt;/span&gt;, &lt;span&gt;0xA0&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;/* order */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFE&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0x72&lt;/span&gt;, &lt;span&gt;0x03&lt;/span&gt;, &lt;span&gt;0xDF&lt;/span&gt;, &lt;span&gt;0x6B&lt;/span&gt;, &lt;span&gt;0x21&lt;/span&gt;, &lt;span&gt;0xC6&lt;/span&gt;, &lt;span&gt;0x05&lt;/span&gt;, &lt;span&gt;0x2B&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;0x53&lt;/span&gt;, &lt;span&gt;0xBB&lt;/span&gt;, &lt;span&gt;0xF4&lt;/span&gt;, &lt;span&gt;0x09&lt;/span&gt;, &lt;span&gt;0x39&lt;/span&gt;, &lt;span&gt;0xD5&lt;/span&gt;, &lt;span&gt;0x41&lt;/span&gt;, &lt;span&gt;0x23&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码中的order就是参数表中的 n。对于大部分ECC操作来说，不需要该值，但在计算签名的时候会对n取模。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也可以通过GmSSL查看命名曲线的参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ gmssl ecparam -name sm2p256v1 -out sm2p256v1.pem&lt;br/&gt;$ gmssl ecparam -&lt;span&gt;in&lt;/span&gt; sm2p256v1.pem -text -param_enc explicit -noout&lt;br/&gt;Field Type: prime-field&lt;br/&gt;Prime:&lt;br/&gt;    00:ff:ff:ff:fe:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:&lt;br/&gt;    ff:ff:ff:ff:ff:ff:00:00:00:00:ff:ff:ff:ff:ff:&lt;br/&gt;    ff:ff:ff&lt;br/&gt;A:   &lt;br/&gt;    00:ff:ff:ff:fe:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:&lt;br/&gt;    ff:ff:ff:ff:ff:ff:00:00:00:00:ff:ff:ff:ff:ff:&lt;br/&gt;    ff:ff:&lt;span&gt;fc&lt;/span&gt;&lt;br/&gt;B:   &lt;br/&gt;    28:e9:fa:9e:9d:9f:5e:34:4d:5a:9e:4b:cf:65:09:&lt;br/&gt;    a7:f3:97:89:f5:15:ab:8f:92:dd:bc:bd:41:4d:94:&lt;br/&gt;    0e:93&lt;br/&gt;Generator (uncompressed):&lt;br/&gt;    04:32:c4:ae:2c:1f:19:81:19:5f:99:04:46:6a:39:&lt;br/&gt;    c9:94:8f:e3:0b:bf:f2:66:0b:e1:71:5a:45:89:33:&lt;br/&gt;    4c:74:c7:bc:37:36:a2:f4:f6:77:9c:59:bd:ce:e3:&lt;br/&gt;    6b:69:21:53:d0:a9:87:7c:c6:2a:47:40:02:df:32:&lt;br/&gt;    e5:21:39:f0:a0&lt;br/&gt;Order: &lt;br/&gt;    00:ff:ff:ff:fe:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:&lt;br/&gt;    ff:ff:72:03:df:6b:21:c6:05:2b:53:bb:f4:09:39:&lt;br/&gt;    d5:41:23&lt;br/&gt;Cofactor:  1 (0x1)&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小结&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文从非对称密码算法开始，逐步介绍到国密SM2算法。我们可以看到，SM2并不是一个全新设计的算法，而是借助现有的ECC理论，设计了一条命名曲线。这样，在已经实现了ECC算法的网络库上增加SM2算法的支持就非常简单，只需要将曲线参数添加即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一套完整的公开密码算法，更重要的作用是用于密钥交换和数字签名，在后面的文章将继续探讨这些话题，敬请关注！&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI3NTQyMzEzNQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/ibQ4mtgHYXv4tOEn4Uicn7b1ITAz13SSd95USUDHGciaIrrd3whtY0IwTvH5NXTpe0LMq5YerBI24lMw5plu7T2DA/0?wx_fmt=png&quot; data-nickname=&quot;云水木石&quot; data-alias=&quot;ourpoeticlife&quot; data-signature=&quot;生活不只是眼前的编程，还有远方的读书、跑步、旅行。谈谈人工智能，读读闲书，来场说走就走的旅行，就这样。&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibQ4mtgHYXv50C2zJtfH5icNbOicm63Mwia4EaZdIJtQDz9rJLxS6LBsVgWJXtbJIFBaAH2nzu7tBEic76fFUEphPjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d7580bf3aaa6fc7d40cc7167081f8f5e</guid>
<title>卧槽，线上数据删错了，差点被老板开除</title>
<link>https://toutiao.io/k/exd77nu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h1&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxODkzNTQ3Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uL371281oDFEpxenPicr7Kh8c9P0I97yVWw9JfljjPy5gVBLDiaIrWkzAGHGib09Kib4TQtyw8jpLicW3yoyibMY8yMA/0?wx_fmt=png&quot; data-nickname=&quot;苏三说技术&quot; data-alias=&quot;&quot; data-signature=&quot;「苏三说技术」 维护者目前就职于某知名互联网公司，从事开发、架构和部分管理工作。实战经验丰富，对jdk、spring、springboot、springcloud、mybatis等开源框架源码有一定研究，欢迎关注，和我一起交流。&quot;/&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是开发、测试，还是DBA，都难免会涉及到数据库的操作，比如：创建某张表，添加某个字段、添加数据、更新数据、删除数据、查询数据等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常情况下还好，但如果操作数据库时出现失误，比如：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;删除订单数据时where条件写错了，导致多删了很多用户订单。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更新会员有效时间时，一次性把所有会员的有效时间都更新了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修复线上数据时，改错了，想还原。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有很多很多场景，我就不一一列举了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果出现线上环境数据库误操作怎么办？有没有后悔药？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是有的，请各位看官仔细往下看。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.不要用聊天工具发sql语句&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常开发人员写好sql语句之后，习惯通过聊天工具，比如：qq、钉钉、或者腾讯通等，发给&lt;code&gt;团队老大&lt;/code&gt;或者&lt;code&gt;DBA&lt;/code&gt;在线上环境执行。但由于有些聊天工具，对部分&lt;code&gt;特殊字符&lt;/code&gt;会自动转义，而且有些消息由于&lt;code&gt;内容太长&lt;/code&gt;，会被自动分成多条消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样会导致团队老大或者DBA复制出来的sql不一定是正确的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他们需要手动拼接成一条&lt;code&gt;完整的sql&lt;/code&gt;，有时甚至需要把转义后的字符替换回以前的特殊字符，无形之中会浪费很多额外的时间。即使最终sql拼接好了，真正执行sql的人，心里一定很虚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，强烈建议你把要在线上执行的sql语句用&lt;code&gt;邮件&lt;/code&gt;发过去，可以避免使用聊天工具的一些弊端，减少一些误操作的机会。而且有个存档，方便今后有问题的时候回溯原因。很多聊天工具只保留最近&lt;code&gt;7天&lt;/code&gt;的历史记录，邮件会保留更久一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;别用聊天工具发sql语句！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;别用聊天工具发sql语句！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;别用聊天工具发sql语句！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重要的事情说三遍，它真的能减少一些误操作。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.把sql语句压缩成一行&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些时候，开发人员写的sql语句很长，使用了各种&lt;code&gt;join&lt;/code&gt;和&lt;code&gt;union&lt;/code&gt;，而且使用美化工具，将一条sql变成了多行。在复制sql的时候，自己都无法确定sql是否完整。（为了装逼，把自己也坑了，哈哈哈）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线上环境有时候需要通过命令行连接数据库，比如：mysql，你把sql语句复制过来后，在命令行界面执行，由于屏幕滚动太快，这时根本无法确定sql是否都执行成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对这类问题，强烈建议把sql语句&lt;code&gt;压缩成一行&lt;/code&gt;，去掉多余的&lt;code&gt;换行符&lt;/code&gt;和&lt;code&gt;空格&lt;/code&gt;，可以有效的减少一些误操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sql压缩工具&lt;/code&gt;推荐使用：https://tool.lu/sql/&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.操作数据之前先select一下&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要特别说明的是：本文的操作数据主要指&lt;code&gt;修改&lt;/code&gt;和&lt;code&gt;删除&lt;/code&gt;数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，由于我们人为失误，把where条件写错了。但没有怎么仔细检查，就把sql语句直接执行了。影响范围小还好，如果影响几万、几十万，甚至几百万行数据，我们可能要哭了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对这种情况，在操作数据之前，把sql先改成&lt;code&gt;select count(*)&lt;/code&gt;语句，比如：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;update order set status=1 where status=0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改成：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;count&lt;/span&gt;(*) &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;status&lt;/span&gt;=&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查一下该sql执行后影响的记录行数，做到自己心中有数。也给自己一次测试sql是否正确，确认是否执行的机会。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.操作数据sql加limit&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使通过上面的&lt;code&gt;select&lt;/code&gt;语句确认了sql语句没有问题，执行后影响的记录行数是对的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也建议你不要立刻执行，建议在正在执行的时候，加上&lt;code&gt;limit&lt;/code&gt; + &lt;code&gt;select出的记录行数&lt;/code&gt;。例如：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;update order set status=1 where status=0 limit 1000&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设有一次性更新的数据太多，所有相关记录行都会被锁住，造成长时间的锁等待，而造成用户请求超时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，加&lt;code&gt;limit&lt;/code&gt;可以避免一次性操作太多数据，对服务器的cpu造成影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一个最重要的原因：加&lt;code&gt;limit&lt;/code&gt;后，操作数据的影响范围是完全可控的。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.update时更新修改人和修改时间&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多人写&lt;code&gt;update&lt;/code&gt;语句时，如果要修改状态，就只更新状态，不管其他的字段。比如：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;update order set status=1 where status=0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这条sql会把&lt;code&gt;status&lt;/code&gt;等于0的数据，全部更新成1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来发现业务逻辑有问题，不应该这么更新，需要把&lt;code&gt;status&lt;/code&gt;状态回滚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时你可能会很自然想到这条sql：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;update order set status=0 where status=1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但仔细想想又有些不对。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样不是会把有部分以前&lt;code&gt;status&lt;/code&gt;就是1的数据更新成0？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这回真的要哭了，呜呜呜。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，送你一个好习惯：在更新数据的时候，同时更新&lt;code&gt;修改人&lt;/code&gt;和&lt;code&gt;修改时间&lt;/code&gt;字段。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;update order set status=1,edit_date=now(),edit_user=&#x27;admin&#x27; where status=0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;这样在恢复数据时就能通过&lt;/span&gt;&lt;code&gt;修改人&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code&gt;修改时间&lt;/code&gt;&lt;span&gt;字段过滤数据了。&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面需要用到的&lt;code&gt;修改时间&lt;/code&gt;通过这条sql语句可以轻松找到：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; edit_user ,edit_date &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;`order`&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;by&lt;/span&gt; edit_date &lt;span class=&quot;code-snippet__keyword&quot;&gt;desc&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;50&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;当然，如果是高并发系统不建议这种批量更新方式，可能会锁表一定时间，造成请求超时。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些同学可能会问：为什么要同时更新修改人，只更新修改时间不行吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要有如下的原因：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为了标识非正常用户操作，方便后面统计和定位问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有些情况下，在执行sql语句的过程中，正常用户产生数据的修改时间跟你的可能一模一样，导致回滚时数据查多了。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.多用逻辑删除，少用物理删除&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在业务开发中，删除数据是必不可少的一种业务场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些人开发人员习惯将表设计成&lt;code&gt;物理删除&lt;/code&gt;，根据主键只用一条&lt;code&gt;delete&lt;/code&gt;语句就能轻松搞定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他们给出的理由是：&lt;code&gt;节省数据库的存储空间&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想法是好的，但是现实很残酷。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有条极重要的数据删错了，想恢复怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时只剩八个字：没有数据，恢复不了。（PS：或许通过binlog二进制文件可以恢复）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果之前设计表的时候用的&lt;code&gt;逻辑删除&lt;/code&gt;，上面的问题就变得好办了。删除数据时，只需&lt;code&gt;update&lt;/code&gt;删除状态即可，例如：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;update&lt;/span&gt; order set del_status=&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;,edit_date=now(),edit_user=&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;admin&#x27;&lt;/span&gt; where id=&lt;span class=&quot;code-snippet__number&quot;&gt;123&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如出现异常，要恢复数据，把该id的删除状态还原即可，例如：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;update&lt;/span&gt; order set del_status=&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;,edit_date=now(),edit_user=&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;admin&#x27;&lt;/span&gt; where id=&lt;span class=&quot;code-snippet__number&quot;&gt;123&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.操作数据之前先做备份&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果只是修改了少量的数据，或者只执行了一两条sql语句，通过上面的&lt;code&gt;修改人&lt;/code&gt;和&lt;code&gt;修改时间&lt;/code&gt;字段，在需要回滚时，能快速的定位到正确的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是如果修改的记录行数很多，并且执行了多条sql，产生了很多&lt;code&gt;修改时间&lt;/code&gt;。这时，你可能就要犯难了，没法一次性找出哪些数据需要回滚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这类问题，可以将表做备份。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用如下sql备份：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;table&lt;/span&gt; order_bak_2021031721 &lt;span class=&quot;code-snippet__keyword&quot;&gt;like&lt;/span&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;`order`&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;into&lt;/span&gt; order_bak_2021031721 &lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;`order`&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先创建一张一模一样的表，然后把数据复制到新表中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以简化成一条sql：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;table&lt;/span&gt; order_bak_2021031722 &lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;`order`&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;创建表的同时复制数据到新表中。&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;此外，建议在表名中加上&lt;code&gt;bak&lt;/code&gt;和&lt;code&gt;时间&lt;/code&gt;，一方面是为了通过表名快速识别出哪些表是备份表，另一方面是为了备份多次时好做区分。因为有时需要执行多次sql才能把数据修复好，这种情况建议把表备份多次，如果出现异常，把数据回滚到最近的一次备份，可以节省很多重复操作的时间。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;恢复数据时，把sql语句改成&lt;code&gt;select&lt;/code&gt;语句，先在备份库找出相关数据，每条数据对应一条&lt;code&gt;update&lt;/code&gt;语句，还原到老表中。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.中间结果写入临时表&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们要先用一条sql查询出要更新的记录的id，然后通过这些id更新数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;批量更新之后，发现不对，要回滚数据。但由于有些数据已更新，此时使用相同的sql相同的条件，却查不出上次相同的id了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，我们开始慌了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对这种情况，我们可以先将第一次查询的id存入一张&lt;code&gt;临时表&lt;/code&gt;，然后通过&lt;code&gt;临时表&lt;/code&gt;中的id作为查询条件更新数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要恢复数据，只用通过&lt;code&gt;临时&lt;/code&gt;表中的id作为查询条件更新数据即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改完，3天之后，如果没有出现问题，就可以把&lt;code&gt;临时表&lt;/code&gt;删掉了。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.表名前面一定要带库名&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在写sql时为了方便，习惯性不带数据库名称。比如：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;update order set status=1,edit_date=now(),edit_user=&#x27;admin&#x27; where status=0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;假如有多个数据库中有相同的表&lt;/span&gt;&lt;code&gt;order&lt;/code&gt;&lt;span&gt;，表结构一模一样，只是数据不一样。&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于执行sql语句的人一个小失误，进错数据库了。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;trade1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后执行了这条sql语句，结果悲剧了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有个非常有效的预防这类问题的方法是加&lt;code&gt;数据库名&lt;/code&gt;：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;update&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;`trade2`&lt;/span&gt;.&lt;span class=&quot;code-snippet__string&quot;&gt;`order`&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;status&lt;/span&gt;=&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;,edit_date=&lt;span class=&quot;code-snippet__keyword&quot;&gt;now&lt;/span&gt;(),edit_user=&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;admin&#x27;&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;status&lt;/span&gt;=&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;这样即使执行sql语句前进错数据库了，也没什么影响。&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.字段增删改的限制&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，我们少不了对表字段的操作，比如：新加、修改、删除字段，但每种情况都不一样。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;新加的字段一定要允许为空&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新加的字段一定要允许为空。为什么要这样设计呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常情况下，如果程序新加了字段，一般是先在数据库中加字段，然后再发程序的最新代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么是这种顺序？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为如果先发程序，然后在数据库中加字段。在该程序刚部署成功，但数据库新字段还没来得及加的这段时间内，最新程序中，所有使用了新加字段的增删改查sql都会报字段不存在的异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，就按先在数据库中加字段，再发程序的顺序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果数据库中新加的字段非空，最新的程序还没发，线上跑的还是老代码，这时如果有&lt;code&gt;insert&lt;/code&gt;操作，就会报字段不能为空的异常。因为新加的非空字段，老代码是没法赋值的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以说新加的字段一定要允许为空。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，这种设计更多的考虑是为了程序发布失败时的回滚操作。如果新加的字段允许为空，则可以不用回滚数据库，只需回滚代码即可，是不是很方便？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;不允许删除字段&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;删除字段是不允许的，特别是必填字段一定不能删除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么这么说？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设开发人员已经把程序改成不使用删除字段了，接下来如何部署呢？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果先把程序部署好了，还没来得及删除数据库相关表字段。当有&lt;code&gt;insert&lt;/code&gt;请求时，由于数据库中该字段是必填的，会报必填字段不能为空的异常。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果先把数据库中相关表字段删了，程序还没来得及发。这时所有涉及该删除字段的&lt;code&gt;增删改查&lt;/code&gt;，都会报字段不存在的异常。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，线上环境必填字段一定不能删除的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;根据实际情况修改字段&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改字段要分为这三种情况：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.修改字段名称&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改字段名称也不允许，跟删除必填字段的问题差不多。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果把程序部署好了，还没来得及修改数据库中表字段名称。这时所有涉及该字段的&lt;code&gt;增删改查&lt;/code&gt;，都会报字段不存在的异常。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果先把数据库中字段名称改了，程序还没来得及发。这时所有涉及该字段的&lt;code&gt;增删改查&lt;/code&gt;，同样也会报字段不存在的异常。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，线上环境字段名称一定不要修改。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.修改字段类型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改字段类型时一定要兼容之前的数据。例如：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;tinyint改成int可以，但int改成tinyint要仔细衡量一下。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;varchar改成text可以，但text改成varchar要仔细衡量一下。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.修改字段长度&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字段长度建议改大，通常情况下，不建议改小。如果一定要改小，要先确认该字段可能会出现的最大长度，避免&lt;code&gt;insert&lt;/code&gt;操作时出现字段太长的异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，建议改大也需要设置一个合理的长度，避免数据库资源浪费。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文分享了10种减少数据库误操作的方法，并非所有场景都适合你。特别是在一些高并发，或者单表数据量非常大的场景，你需要根据实际情况酌情选择。但我敢肯定的是读完这篇文章，你一定会有一些收获，因为大部分方法对你来说是适用的，可能会让你少走很多弯路，强烈建议收藏。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b9cd0b8524a3c274f4411262ea21b7bc</guid>
<title>Java 线程的那些状态们</title>
<link>https://toutiao.io/k/fhks4c3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;346&quot; data-backw=&quot;574&quot; data-croporisrc=&quot;https://mp.weixin.qq.com/cgi-bin/photogalleryproxy?action=proxy&amp;amp;url=https%3A%2F%2Fpixabay.com%2Fget%2Fg8559b59c705f5d71e4ecad6cf0c3932fd38abfce9e734a0ebe3dd0ad2669927045b97d31e2e6df208473fdf2d78b2ea8ac19fd6c10232df2fba260841eb017d6_1280.jpg%3Fpermalink&amp;amp;supplier=4&amp;amp;from_public_pic=1&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;773.7979094076654&quot; data-ratio=&quot;0.603125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jOD3PUUxTibMuUInUIJZDQv2ZvK6SPXg1WbibwXE3Sfa088bquwibm8fsy1SsGnz1VuD2icnKu9VIVpPQUmmNnEa0Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;Java线程（或者说计算机线程），是有一些状态来表示当前线程运行信息的，可以通过jsatck命令来查看Java进程中线程函数栈信息，其中就包括了Java线程状态。&lt;/p&gt;&lt;p&gt;在分析Java线程状态之前，我们先来看下进程、线程、协程这些概念之间的区别：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;对于开发小伙伴来讲，了解Java线程状态，有利于加深对线程的理解，有助于解决线程死锁、线程阻塞等问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Java Thread类型的&lt;code&gt;State&lt;/code&gt;枚举就定义了如下6种线程状态，这些状态之间会进行切换直到线程终止为止，类似于状态机流转。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; State {&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Thread state for a thread which has not yet started.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    NEW,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Thread state for a runnable thread.  A thread in the runnable&lt;br/&gt;     * state is executing in the Java virtual machine but it may&lt;br/&gt;     * be waiting for other resources from the operating system&lt;br/&gt;     * such as processor.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    RUNNABLE,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Thread state for a thread blocked waiting for a monitor lock.&lt;br/&gt;     * A thread in the blocked state is waiting for a monitor lock&lt;br/&gt;     * to enter a synchronized block/method or&lt;br/&gt;     * reenter a synchronized block/method after calling&lt;br/&gt;     * {&lt;span&gt;@link&lt;/span&gt; Object#wait() Object.wait}.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    BLOCKED,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Thread state for a waiting thread.&lt;br/&gt;     * A thread is in the waiting state due to calling one of the&lt;br/&gt;     * following methods:&lt;br/&gt;     * &amp;lt;ul&amp;gt;&lt;br/&gt;     *   &amp;lt;li&amp;gt;{&lt;span&gt;@link&lt;/span&gt; Object#wait() Object.wait} with no timeout&amp;lt;/li&amp;gt;&lt;br/&gt;     *   &amp;lt;li&amp;gt;{&lt;span&gt;@link&lt;/span&gt; #join() Thread.join} with no timeout&amp;lt;/li&amp;gt;&lt;br/&gt;     *   &amp;lt;li&amp;gt;{&lt;span&gt;@link&lt;/span&gt; LockSupport#park() LockSupport.park}&amp;lt;/li&amp;gt;&lt;br/&gt;     * &amp;lt;/ul&amp;gt;&lt;br/&gt;     *&lt;br/&gt;     * &amp;lt;p&amp;gt;A thread in the waiting state is waiting for another thread to&lt;br/&gt;     * perform a particular action.&lt;br/&gt;     *&lt;br/&gt;     * For example, a thread that has called &amp;lt;tt&amp;gt;Object.wait()&amp;lt;/tt&amp;gt;&lt;br/&gt;     * on an object is waiting for another thread to call&lt;br/&gt;     * &amp;lt;tt&amp;gt;Object.notify()&amp;lt;/tt&amp;gt; or &amp;lt;tt&amp;gt;Object.notifyAll()&amp;lt;/tt&amp;gt; on&lt;br/&gt;     * that object. A thread that has called &amp;lt;tt&amp;gt;Thread.join()&amp;lt;/tt&amp;gt;&lt;br/&gt;     * is waiting for a specified thread to terminate.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    WAITING,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Thread state for a waiting thread with a specified waiting time.&lt;br/&gt;     * A thread is in the timed waiting state due to calling one of&lt;br/&gt;     * the following methods with a specified positive waiting time:&lt;br/&gt;     * &amp;lt;ul&amp;gt;&lt;br/&gt;     *   &amp;lt;li&amp;gt;{&lt;span&gt;@link&lt;/span&gt; #sleep Thread.sleep}&amp;lt;/li&amp;gt;&lt;br/&gt;     *   &amp;lt;li&amp;gt;{&lt;span&gt;@link&lt;/span&gt; Object#wait(long) Object.wait} with timeout&amp;lt;/li&amp;gt;&lt;br/&gt;     *   &amp;lt;li&amp;gt;{&lt;span&gt;@link&lt;/span&gt; #join(long) Thread.join} with timeout&amp;lt;/li&amp;gt;&lt;br/&gt;     *   &amp;lt;li&amp;gt;{&lt;span&gt;@link&lt;/span&gt; LockSupport#parkNanos LockSupport.parkNanos}&amp;lt;/li&amp;gt;&lt;br/&gt;     *   &amp;lt;li&amp;gt;{&lt;span&gt;@link&lt;/span&gt; LockSupport#parkUntil LockSupport.parkUntil}&amp;lt;/li&amp;gt;&lt;br/&gt;     * &amp;lt;/ul&amp;gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    TIMED_WAITING,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Thread state for a terminated thread.&lt;br/&gt;     * The thread has completed execution.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    TERMINATED;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这些Java线程状态图如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jOD3PUUxTibMuUInUIJZDQv2ZvK6SPXg1FY3Zl18upPOj5RIDRYnHLpz5qvTmZfQh0Kr8VFZSia9dznJDo9a1AfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;注意，RUNNABLE状态时的线程不一定就是RUNNING的，有可能CPU还在执行其他线程而没有调度到该线程。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;我们知道了Java层面对于线程状态的几种定义，那么Java/JDK底层是基于什么机制来实现线程管理的呢&lt;/strong&gt;？下面咱们写个示例Demo进行分析：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@SuppressWarnings&lt;/span&gt;(&lt;span&gt;&quot;all&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MainDemo&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object obj1 = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Lock lock = &lt;span&gt;new&lt;/span&gt; ReentrantLock();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                LockSupport.park();&lt;br/&gt;            }&lt;br/&gt;        }, &lt;span&gt;&quot;t1&quot;&lt;/span&gt;).start();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                LockSupport.park(TimeUnit.DAYS.toNanos(&lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;            }&lt;br/&gt;        }, &lt;span&gt;&quot;t2&quot;&lt;/span&gt;).start();&lt;br/&gt;&lt;br/&gt;        lock.lock();&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                lock.lock();&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;zzz222&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        }, &lt;span&gt;&quot;t3&quot;&lt;/span&gt;).start();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    Thread.sleep(&lt;span&gt;1000000000&lt;/span&gt;);&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }, &lt;span&gt;&quot;t4&quot;&lt;/span&gt;).start();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (obj1) {&lt;br/&gt;            &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;                &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;synchronized&lt;/span&gt; (obj1) {&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;zzz&quot;&lt;/span&gt;);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }, &lt;span&gt;&quot;t5&quot;&lt;/span&gt;).start();&lt;br/&gt;&lt;br/&gt;            Thread.sleep(&lt;span&gt;1000000000&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码起了5个子线程，名字分别是t1、t2到t5，其中t1执行&lt;code&gt;LockSupport.park()&lt;/code&gt;阻塞，t2执行&lt;code&gt;LockSupport.park(long)&lt;/code&gt;阻塞，t3执行&lt;code&gt;lock.lock()&lt;/code&gt;阻塞，t4执行&lt;code&gt;Thread.sleep()&lt;/code&gt;阻塞，t5执行&lt;code&gt;synchronized(obj)&lt;/code&gt;阻塞。&lt;/p&gt;&lt;p&gt;通过&lt;code&gt;jstack&lt;/code&gt;命令可以查看Java线程栈，如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.175&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jOD3PUUxTibMuUInUIJZDQv2ZvK6SPXg1lJvM1INuyODHOBk9k3gicHX8WicLj2Ppr9O0NHrQ6FdSk0bpnKd7woibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;但是它不能看到JDK和系统层面的线程栈，此时可以通过&lt;code&gt;pstack命令&lt;/code&gt;来查看，如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.35234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jOD3PUUxTibMuUInUIJZDQv2ZvK6SPXg1hichxA9lDl1EQnTj74g9eoAOU8j63IVnPs4bpSR3hsBoRFnJibdAASbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;那么Java线程栈怎么和系统层线程栈关联起来呢&lt;/strong&gt;？这个时候可以通过Java线程栈中nid（十六进制）和系统层线程栈中LWP是否相等关联起来。比如t1线程的线程栈如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jOD3PUUxTibMuUInUIJZDQv2ZvK6SPXg1OSyibDoaNUDfM1uFmOngJQMGg9T3QpT1mZ7WzOiaDqlIFJH6sKssC4Vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;通过对t1-t5线程栈进行分析，这些线程都处于&lt;em&gt;TIMED_WAITING&lt;/em&gt;或者&lt;em&gt;WAITING&lt;/em&gt;状态，它们的JDK层面都是走到了方法&lt;code&gt;pthread_cond_wait&lt;/code&gt;或&lt;code&gt;pthread_cond_timedwait&lt;/code&gt;，而这些就是系统层pthread库中方法了，对于学过 Linux C 的同学肯定都不会陌生。感兴趣的同学可以按照上面的命令查看下所有线程的整个线程栈信息。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-style-type=&quot;2&quot; data-tools=&quot;新媒体排版&quot; data-id=&quot;8633&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt; 推荐阅读 &lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;figure&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>