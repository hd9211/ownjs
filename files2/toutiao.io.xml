<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f5e1dbe38b99ae7931c092a4b26824b7</guid>
<title>最值得阅读的数据仓库书籍推荐</title>
<link>https://toutiao.io/k/l28dnm9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content post-body&quot;&gt;&lt;p&gt;从事数仓工作几年了，在工作学习过程也看了很多数据仓库方面的，此处整理了对自己帮助较大的部分，给大家推荐一下，希望能帮助到大家。&lt;/p&gt;
&lt;h3 id=&quot;SQL必知必会&quot;&gt;&lt;a href=&quot;#SQL必知必会&quot; class=&quot;headerlink&quot; title=&quot;SQL必知必会&quot;/&gt;SQL必知必会&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://static.studytime.xin/article/20210228140754.png?x-oss-process=image/resize,h_300&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;《SQL必知必会 第4版(图灵出品）》这本书是学习数据库的入门级经典书籍，经典中的经典，里面知识点虽然都比较基础，不过讲解的清晰简介，也比较全面。这也是我看过的最棒的SQL入门书啦，短小精悍，实用性超强，一点也不枯燥，SQL小白必备书籍，五星。&lt;/p&gt;
&lt;h3 id=&quot;大数据之路：阿里巴巴大数据实践&quot;&gt;&lt;a href=&quot;#大数据之路：阿里巴巴大数据实践&quot; class=&quot;headerlink&quot; title=&quot;大数据之路：阿里巴巴大数据实践&quot;/&gt;大数据之路：阿里巴巴大数据实践&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://static.studytime.xin/article/20210228141036.png?x-oss-process=image/resize,h_300&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大数据之路-阿里巴巴大数据实践，这本书是目前读到的对自己帮助最大的一本书，为什么说这本书对自己帮助最大，因为本书中讲解了阿里大数据实践方案，特别是数据模型的设计以及实现，工作中80%的问题都在这本书能找到答案，最贴近工作，最能直接转换成生产力的书，再次强调一定一定要看！！&lt;/p&gt;
&lt;h3 id=&quot;数据仓库工具箱-第3版-——维度建模权威指南&quot;&gt;&lt;a href=&quot;#数据仓库工具箱-第3版-——维度建模权威指南&quot; class=&quot;headerlink&quot; title=&quot;数据仓库工具箱(第3版)——维度建模权威指南&quot;/&gt;数据仓库工具箱(第3版)——维度建模权威指南&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://static.studytime.xin/article/20210228141105.png?x-oss-process=image/resize,h_300&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;《数据仓库工具箱—维度建模的完全指南》是数据仓库建模方面的经典著作，1996年第一版出版被认为是数据仓库方面具有里程碑意义的事件。作者kimballl是数据仓库方面的权威，他将多年的数据仓库建模实战经验、技巧融入本书。他提出的许多维度建模概念被广泛应用于数据仓库的设计和开发中。本文不仅仅对数仓进行了概括讲述，也对数仓建设方法论进行了较为完善的讲解，同时文章内引用了大量行业建模经验，市面上很少在维度建模比它更具权威性，理论性特别强，早期入门不建议看这两本书，但是当你工作一段时间后再来看这本书，一定要看，会受益匪浅。&lt;/p&gt;
&lt;h3 id=&quot;大数据浪潮之巅&quot;&gt;&lt;a href=&quot;#大数据浪潮之巅&quot; class=&quot;headerlink&quot; title=&quot;大数据浪潮之巅&quot;/&gt;大数据浪潮之巅&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://static.studytime.xin/article/20210228141133.png?x-oss-process=image/resize,h_300&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;《大数据浪潮之巅》是一本大数据技术的发展史，也是一本商业与技术结合的指导手册。在这本书中你会看到：世界 IT 巨头的大数据技术革新与企业沉浮、硅谷和中国大数据公司典型的技术与商业融合案例、大数据企业采用的商业模式与战略得失、大数据技术浪潮来临时不同企业做的应对与选择等等，如果你对大数据发展历程，大数据生态、各个核心组件行业地位与发展，以及未来大数据房展方向疑问等，可以去看看，知识扩展类数据。&lt;/p&gt;
&lt;h3 id=&quot;数据化运营：系统方法与实践案例&quot;&gt;&lt;a href=&quot;#数据化运营：系统方法与实践案例&quot; class=&quot;headerlink&quot; title=&quot;数据化运营：系统方法与实践案例&quot;/&gt;数据化运营：系统方法与实践案例&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://static.studytime.xin/article/20210228141155.png?x-oss-process=image/resize,h_300&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本书从实践出发，结合工作中数据运营经验，以应用案例为主线，通过业务分析+代码实践这种更“接地气”的方式讲述数据的应用。书中对搭建数据监控指标体系、数据分析、数据挖掘、AB Test、埋点策略、用户画像建模等常见数据运营方式做了详细介绍。&lt;/p&gt;
&lt;p&gt;您可以关注公众号 “白程序员的自习室” 回复 “数仓书籍推荐” 来领取电子书。&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9104b97fa0560f4d065c6ab7cc899692</guid>
<title>硬核！漫画图解 HTTP 基础 + 面试题</title>
<link>https://toutiao.io/k/rmckht1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;blockquote&gt;&lt;p&gt;文章持续更新，可以微信搜一搜「golang小白成长记」第一时间阅读，回复【教程】获golang免费视频教程。本文已经收录在GitHub https://github.com/xiaobaiTech/golangFamily , 有大厂面试完整考点和成长路线，欢迎Star。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img data-ratio=&quot;2.3391959798994977&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrEOLVsZs70k5AcZ7Kj8VAaFCn2IxsiccFkYTO1VibibnbtiaIawr7SboXC8w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;398&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.447719298245614&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrE3qZicIZ9g0GgOn0lsEu0tRYcicSTm02Uklst5g5Yyt3kQa8zg4LZ6zag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2850&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h1&gt;&lt;span&gt;什么是HTTP&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;HTTP 全称&lt;strong&gt;超⽂文本传输协议&lt;/strong&gt;，也就是&lt;strong&gt;H&lt;/strong&gt;yper&lt;strong&gt;T&lt;/strong&gt;ext &lt;strong&gt;T&lt;/strong&gt;ransfer &lt;strong&gt;P&lt;/strong&gt;rotocol。&lt;br/&gt;其中我们常见的&lt;strong&gt;文本，图片，视频&lt;/strong&gt;这些东西都可以用超文本进行表示，而我常看的猫片，也属于超文本，所以大家不要再说我偷偷看猫片了，我只是在看超文本。HTTP只是定义了一套传输超文本的规则，只要符合了这一套规则，不管你是用iphone，还是用老爷机，都可以实现猫片的传输。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5171306209850107&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrE1yzbyHae0QvV8fBvK2DxjWiadOTfcg06ZxCvibd1rMaSVicibaoaYoBKbA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;934&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h1&gt;&lt;span&gt;七层网络&lt;/span&gt;&lt;/h1&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7202702702702702&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrE1TeyxpDmoafh8Bj3TJ1GANKEa8E6ibuJtTjmf7sSj8JKyaKsKQR2Jhg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;740&quot; title=&quot;网络协议&quot;/&gt;&lt;figcaption&gt;网络协议&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;大概了解了&lt;strong&gt;HTTP&lt;/strong&gt;后，给大家看看它在它们家族里的地位。HTTP位于&lt;strong&gt;应用层&lt;/strong&gt;，跟它类似的协议还有常见的&lt;strong&gt;FTP协议&lt;/strong&gt;，常见的&lt;strong&gt;某影天堂&lt;/strong&gt;的下载链接曾经经常是以&lt;strong&gt;FTP开头&lt;/strong&gt;的。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.36675461741424803&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrEHOUhRiaAHeiaH2ibjBo3a85WoIdLEO7akzjJGuLUHJOr3lS0DFLzXmzdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1516&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h1&gt;&lt;span&gt;HTTP报文格式&lt;/span&gt;&lt;/h1&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8658043654001617&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrEftmEXb72BqPP0vNibG855QmNic2eQ9NZD1b5icO1rKMwW5Wyq6ibBjwtFA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1237&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.906&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrELyicjsjC1XfsQbKqBFxdjdY6E7aBjpVDFkmQfvfdJejedodS1ELvpPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;&lt;p&gt;有点抽象？不知道小白说的啥？那实操一下，用&lt;code&gt;wireshark&lt;/code&gt;抓包看一下猫片里的请求报文和响应报文具体长什么样子吧&lt;/p&gt;&lt;h2&gt;&lt;span&gt;请求报文&lt;/span&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;GET /cmaskboss/164203142_30_1.enhance.webmask HTTP/1.1&lt;br/&gt;Host: upos-sz-staticks3.bilivideo.com&lt;br/&gt;Connection: keep-alive&lt;br/&gt;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36&lt;br/&gt;Accept: */*&lt;br/&gt;Origin: https://www.bilibili.com&lt;br/&gt;Sec-Fetch-Site: cross-site&lt;br/&gt;Sec-Fetch-Mode: cors&lt;br/&gt;Sec-Fetch-Dest: empty&lt;br/&gt;Referer: https://www.bilibili.com/&lt;br/&gt;Accept-Encoding: identity&lt;br/&gt;Accept-Language: zh-CN,zh;q=0.9&lt;br/&gt;Range: bytes=0-16&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这上面第一行的GET 就是&lt;strong&gt;请求方法&lt;/strong&gt;，&lt;code&gt;/cmaskboss/164203142_30_1.enhance.webmask&lt;/code&gt; 则是 &lt;strong&gt;URL&lt;/strong&gt; , 而&lt;code&gt;HTTP/1.1&lt;/code&gt;则是&lt;strong&gt;协议版本&lt;/strong&gt;。接下来从&lt;code&gt;Host&lt;/code&gt;开始到最后一行&lt;code&gt;Range&lt;/code&gt;，都是&lt;strong&gt;Headers头&lt;/strong&gt;。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;响应报文&lt;/span&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;HTTP/1.1 &lt;span&gt;206&lt;/span&gt; Partial Content&lt;br/&gt;&lt;span&gt;Content-Type: application/octet-stream&lt;br/&gt;Content-Length: 17&lt;br/&gt;Connection: keep-alive&lt;br/&gt;Server: Tengine&lt;br/&gt;ETag: &quot;92086de1e6d1d4791fb950a0ac7e30ba&quot;&lt;br/&gt;Date: Sat, 30 Jan 2021 09:31:31 GMT&lt;br/&gt;Last-Modified: Sun, 04 Oct 2020 01:54:28 GMT&lt;br/&gt;Expires: Mon, 01 Mar 2021 09:31:31 GMT&lt;br/&gt;Age: 1018695&lt;br/&gt;Content-Range: bytes 0-16/353225&lt;br/&gt;Accept-Ranges: bytes&lt;br/&gt;X-Application-Context: application&lt;br/&gt;x-kss-request-id: 75bcbfa8ab194e3c825e89c81a912692&lt;br/&gt;x-kss-BucketOwner: MjAwMDAyMDEwNw==&lt;br/&gt;X-Info-StorageClass: -&lt;br/&gt;Content-MD5: kght4ebR1HkfuVCgrH4wug==&lt;br/&gt;X-Cache-Status: HIT from KS-CLOUD-JH-MP-01-03&lt;br/&gt;X-Cache-Status: HIT from KS-CLOUD-TJ-UN-14-13&lt;br/&gt;X-Cache-Status: HIT from KS-CLOUD-LF-UN-11-25&lt;br/&gt;Access-Control-Allow-Origin: https://www.bilibili.com&lt;br/&gt;Access-Control-Allow-Headers: Origin,X-Requested-With,Content-Type,Accept,range&lt;br/&gt;X-Cdn-Request-ID: 7e2c783ca7d392624118593ec1dc66bc&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类似请求报文，&lt;code&gt;HTTP/1.1&lt;/code&gt;是&lt;strong&gt;协议版本&lt;/strong&gt;，&lt;code&gt;206&lt;/code&gt;是&lt;strong&gt;状态码&lt;/strong&gt;，&lt;code&gt;Partial Content&lt;/code&gt; 则是&lt;strong&gt;状态描述符&lt;/strong&gt;。接下来从&lt;code&gt;Content-Type&lt;/code&gt;开始到最后一行&lt;code&gt;X-Cdn-Request-ID&lt;/code&gt;都是&lt;strong&gt;Headers信息&lt;/strong&gt;。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;报文信息解读&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;其实上面的抓包信息，在浏览器里按F12就能看到，之所以要用&lt;code&gt;wireshark&lt;/code&gt;可能&lt;strong&gt;只是装X效果比较好吧&lt;/strong&gt;。按下F12看到的响应数据就跟下图展示的那样。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.8342541436464088&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrE22P3ic8ibogfmLuE2AKvhPsZiaRN7YnVs0NfOdhejwGEOHvArpLPBAZOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1086&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;1.请求数据&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.017786561264822&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrEmorI6ucwY46Z9YfwzXqX6eBBsU55hqFxXDnYd2O1mAMbENuaTEMlcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1012&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2.响应数据&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.094758064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrEs2qgWqFdk4F0FCIgENfhUQ0tCKbvS5Z6mhiapFlSx3ibXN26t1W2DibEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;992&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3.Request URL&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;URL是什么&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;URL 代表着是统一资源定位符（Uniform Resource Locator）。作用是为了告诉使用者 某个资源在 Web 上的地址。这个资源可以是一个 HTML 页面，一个 CSS 文档，一幅图像或一个猫片等等。上面我们请求猫片的URL就是 &lt;code&gt;https://upos-sz-staticks3.bilivideo.com/cmaskboss/164203142_30_1.enhance.webmask&lt;/code&gt; 这里面细分，又可以分为好几个部分。&lt;/p&gt;&lt;p&gt;表示该URL的协议部分为http还是https，会用//为分隔符。上面的URL表示网页用的是HTTPS协议，而上面提到的X影天堂用的则是ftp协议的下载链接。&lt;/p&gt;&lt;p&gt;域名是&lt;code&gt;upos-sz-staticks3.bilivideo.com&lt;/code&gt;，在发送请求前，会向DNS服务器解析IP，如果已经知道ip，还可以跳过DNS解析那一步，直接把IP当做域名部分使用。&lt;/p&gt;&lt;p&gt;域名后面有些时候会带有端口，和域名之间用:分隔，端口不是一个URL的必须的部分。当网址为&lt;strong&gt;http://&lt;/strong&gt;时，默认端口为&lt;strong&gt;80&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当网址为&lt;strong&gt;https://&lt;/strong&gt;时，默认端口为&lt;strong&gt;443&lt;/strong&gt;，以上两种都可以省略端口号。上面的URL其实&lt;strong&gt;省略了443端口&lt;/strong&gt;号。&lt;/p&gt;&lt;p&gt;从域名的第一个/开始到最后一个/为止，是虚拟目录的部分。虚拟目录也不是URL必须的部分，本例中的虚拟目录是&lt;code&gt;/cmaskboss/&lt;/code&gt;&lt;/p&gt;&lt;p&gt;从域名最后一个/开始到?为止，是文件名部分；如果没有?，则是从域名最后一个/开始到#为止，是文件名部分；如果没有?和#，那么就从域名的最后一个/从开始到结束，都是文件名部分。本例中的文件名是&lt;code&gt;164203142_30_1.enhance.webmask&lt;/code&gt;，文件名也不是一个URL的必须部分。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;URL 和 URI 的区别&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;其实一直有个误解，很多人以为URI是URL的子集，其实应该反过来。URL是URI的子集才对。简单解释下。&lt;br/&gt;假设&quot;小白&quot;(URI)是一种资源，而&quot;在迪丽亦巴的怀里&quot;表明了一个位置。如果你想要找到（locate）小白，那么你可以到&quot;在迪丽亦巴怀里&quot;找到小白，而&quot;在迪丽亦巴怀里的/小白&quot;才是我们常说的URL。而&quot;在迪丽亦巴怀里的/小白&quot;（URL）显然是&quot;小白&quot;（URI）的子集，毕竟，&quot;小白&quot;还可能是&quot;在牛亦菲怀里的/小白&quot;（其他URL）。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.46277097078228085&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrEFiaeOdEvCaLYicNsr6bSjG9Ks6lQ60rDyfJzkLicol39IBG7nhWAsrqTA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1061&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;4.Request Method&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;HTTP 定义了一组&lt;strong&gt;请求方法&lt;/strong&gt;，以表明要对给定资源执行的操作。指示针对给定资源要执行的期望动作.。虽然他们也可以是名词，但这些请求方法有时被称为HTTP动词.。每一个请求方法都实现了不同的语义。&lt;/p&gt;&lt;p&gt;这次请求B站猫片的请求里用的是GET，意味着获取。但其实HTTP定义了多种请求方法，来满足各种需求。除了Get，还有几个POST、HEAD、OPTIONS、PUT、DELETE、TRACE 和 CONNECT。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.0987012987012987&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrEQd3YkOiax8WhkOpaDcEQGbWAohMh63t9JCWS39nibYCS7iauaR6wcFjKA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;385&quot;/&gt;&lt;/p&gt;&lt;p&gt;常见的各个请求方法的具体功能如下：&lt;/p&gt;&lt;h3&gt;&lt;span&gt;GET&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;请求指定的页面信息，并返回消息主体(body)+头信息(header)。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;HEAD：&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;HEAD和GET本质是一样的，区别在于HEAD只返回头信息(header)，不返回消息主体(body)。大家不要以为它没用，它跟GET和POST一样，在http/1.0的时候就存在了，实属三元老之一了。主要用途&lt;/p&gt;&lt;h3&gt;&lt;span&gt;POST&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;向服务器提交数据。这个方法用途广泛，几乎目前所有的提交操作都是靠这个完成。POST跟GET最常用，但最大的区别在于，POST每次调用都可能会修改数据，是非幂等的，而GET类似于只读，是幂等的。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;PUT：&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;这个方法比较少见。在HTTP规范中POST是非等幂的，多次调用会产生不同的结果。比如：创建一个用户,由于网络原因或是其他原因多创建了几次,那么将会有多个用户被创建。而PUT id/xiaobai 则会创建一个id为 xiaobai 的用户，多次调用还是会创建的结果是一样的，所以PUT是等幂的。但是一般为了避免造成心智负担，实战中也会使用POST替代PUT。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;DELETE：&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;删除某一个资源。基本上这个也很少见，一般实战中如果是删除操作，也是使用POST来替代。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;OPTIONS：&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;options是什么&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;它用于获取当前URL所支持的方法。若请求成功，则它会在HTTP响应头部中带上给各种“Allow”的头，表明某个请求在对应的服务器中都支持哪种请求方法。比如下图：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.0512820512820513&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrEcPHg8kxmK0OWwicbic1jduvicafhOXgHhcmAsLntSULkNahoU6vrKDyRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1014&quot;/&gt;&lt;/p&gt;&lt;p&gt;这里面需要关注的点有两个&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Request Header里的关键字段&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.1807372175980975&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrEUicpNnu4UKJptMXMDM4etg3x2zffQicpk5uSGC2uK1gOTb9bmpQibN6dw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;841&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Response Header里的关键字段&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.33753943217665616&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrEn0mxNyyCMvUqQwAJoxHLN6rR022bZIOg09RSISGLiahtj19JRhxDCzA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;951&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;code&gt;Options&lt;/code&gt;堪称是网络协议中的老实人，就好像老实人刚谈了个女朋友，每次牵手前都要问下人家 “我可以牵你的手吗？”， “我可以抱你吗？”，得到了答应后才会下手。差点被这老实人气质感动得留下了不争气的泪水。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9850993377483444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrEt4hwlvQGsRBIwrWddOUQY3zTmX1yIRFDHlInXJVHDySdT2oHRwLCfg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;604&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;什么时候需要使用options&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;在&lt;strong&gt;跨域&lt;/strong&gt;（记住这个词，待会解释）的情况下，浏览器发起&lt;strong&gt;复杂请求前&lt;/strong&gt;会&lt;strong&gt;自动&lt;/strong&gt;发起 options 请求。跨域共享标准规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 options 方法发起一个预检请求，从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。&lt;/p&gt;&lt;p&gt;这里提到了两个关键词：&lt;/p&gt;&lt;h4&gt;&lt;span&gt;什么是简单请求和复杂请求。&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;某些请求不会触发 CORS 预检请求，这样的请求一般称为&quot;简单请求&quot;，而会触发预检的请求则为&quot;复杂请求&quot;。&lt;/p&gt;&lt;p&gt;1.简单请求&lt;/p&gt;&lt;p&gt;2.复杂请求&lt;/p&gt;&lt;p&gt;由此可见，因为上述请求在获取B站资源的请求Headers里带有 &lt;code&gt;Access-Control-Request-Headers: range&lt;/code&gt; , 而&lt;code&gt;range&lt;/code&gt;正好不在简单请求的条件2中提到的Headers范围里，因此属于&lt;strong&gt;复杂请求&lt;/strong&gt;，于是触发预检options请求。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;什么是跨域&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;刚刚提到了一个词叫&lt;strong&gt;跨域&lt;/strong&gt;，那什么是跨域呢？在了解跨域之前，首先要了解一个概念：&lt;strong&gt;同源&lt;/strong&gt;。所谓&lt;strong&gt;同源&lt;/strong&gt;是指，&lt;strong&gt;域名、协议、端口均相同&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.906&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrELyicjsjC1XfsQbKqBFxdjdY6E7aBjpVDFkmQfvfdJejedodS1ELvpPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;&lt;p&gt;不明白没关系，举个例子。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.23585598824393827&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrE8323QcdLJjeAVnz0BaiaQfPNEjcEUKd1snzibibq9g58odsdkaNjELuCA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1361&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;需要特别注意的是，localhost和127.0.0.1虽然都指向本机，但也&lt;strong&gt;不属于同源&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;而&lt;strong&gt;非同源&lt;/strong&gt;之间网页调用就是我们所说的&lt;strong&gt;跨域&lt;/strong&gt;。在&lt;strong&gt;浏览器&lt;/strong&gt;同源策略限制下，向不同&lt;strong&gt;源&lt;/strong&gt;发送XHR请求，&lt;strong&gt;浏览器&lt;/strong&gt;认为该请求不受信任，禁止请求，具体表现为请求后不正常响应。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;options带来什么问题&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;由此可见，复杂请求的条件其实非常容易满足，而一旦满足复杂请求的条件，则浏览器便会发送2次请求（一次预检options，一次复杂请求），这一次options就一来一回（一个RTT），显然会导致延迟和不必要的网络资源浪费，高并发情况下则可能为服务器带来严重的性能消耗。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;2.287878787878788&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrEXbNa1I3v7aico54ibiaq1HVvOWSQBA5WC9I2Fnv6dHIXibAVlyZkvgK8RQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;924&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;如何优化options&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;每次复杂请求前都会调用一次options，这其实非常没有必要。因为大部分时候相同的请求，短时间内获得的结果是不会变的，是否可以通过浏览器缓存省掉这一次查询？&lt;/p&gt;&lt;p&gt;&lt;code&gt;Access-Control-Max-Age&lt;/code&gt;就是优化这个流程中使用的一个Header。它的作用是当你每次请求&lt;code&gt;options&lt;/code&gt;方法时，服务端返回调用支持的方法（Access-Control-Allow-Methods ）和Headers（Access-Control-Allow-Headers）有哪些，同时告诉你，它在接下来 &lt;code&gt;Access-Control-Max-Age&lt;/code&gt;时间（单位是秒）里都支持，则这段时间内，不再需要使用options进行请求。特别注意的是，当&lt;code&gt;Access-Control-Max-Age&lt;/code&gt;的值为-1时，表示禁用缓存，每一次请求都需要发送预检请求，即用OPTIONS请求进行检测。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.1715976331360947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrEuicSFP7ocJArXFp1nfeKkw78EvAgA1JgibdNTPwNtwuCibL6iaayLtibdwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1014&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;5.Status Code&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;状态码是什么&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;HTTP Status Code是常说的HTTP状态码。当用户访问一个网页时，浏览器会向网页所在服务器发出请求。服务器则会根据请求作出响应，而状态码则是响应的一部分，代表着本次请求的结果。所有状态码的第一个数字代表了响应的大概含义，组合上第二第三个数字则可以表示更具体的原因。如果请求失败了，通过这个状态码，大概初步判断出这次请求失败的原因。以下是五类状态码的含义。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.43193997856377275&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrE8TglTFFicSf4DL9XSQXYaY6ibXicWTMicO0EqjFLe9icRRgZruBvLUxLYbw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;933&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;状态码流程&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;可以根据以下流程图了解下各类状态码间的关系。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5417348608837971&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrEW0CsR8ERKn65Lm2TEngVGJliarrsBvmq7ofib1DY3GDxa0icaeRNS3zxw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1222&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.998759305210918&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrEmLXtPbG8cPfoibcPKiafgCsYIKuYwPoIiaZKzSEozwRduNuuku0q22P3Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1612&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;img data-ratio=&quot;2.8615209988649264&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrEojbeia7juhLfgic5ic6pPE4V3licCOPEC7bsWIDzESRNQBOEXibpcYQStQQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1762&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.8120649651972158&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrEqqbkxZmX326mfOHlrhBCMDHiarcricYcxRF0zhVF5BbcaOXSreWcY6PA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;862&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;常见状态码介绍&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;这是最常见的状态码。代表请求已成功，数据也正常返回。而B站猫片里虽然响应成功了，但却不是200，而是206，是为什么呢，接下去继续看看。&lt;/p&gt;&lt;p&gt;这个状态码在上面B站请求的响应结果。服务器已经成功处理了部分 GET 请求。类似于B站看视频或者迅雷这类的 HTTP下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;307 Temporary Redirect&lt;/p&gt;&lt;p&gt;内部重定向。重定向的意思是，当你输入一个网址的时候，浏览器会自动帮你跳转到另外一个网址上。比如，当你在浏览器输入框输入&lt;code&gt;http://www.baidu.com/&lt;/code&gt;时。由于使用http并不安全，百度会自动帮你跳转到它对应的https网页上。而此时，需要重定向的地址，会通过&lt;code&gt;Response Headers&lt;/code&gt;的&lt;code&gt;Location&lt;/code&gt;返回&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6003717472118959&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrE4jsEsticM9rrxpWfkACHicLlYEQZtjHtMRLX0V851g1iap772pzcGaKlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1076&quot;/&gt;&lt;/p&gt;&lt;p&gt;404 Not Found&lt;/p&gt;&lt;p&gt;请求失败，请求所希望得到的资源未被在服务器上发现。出现这个错误的最有可能的原因是服务器端没有这个页面，或者是Request Method与注册URL的Method不一致，比如我有一个URL在服务端注册的Request Method 为 &lt;strong&gt;POST&lt;/strong&gt;，但调用的时候却错误用了&lt;strong&gt;GET&lt;/strong&gt;，则也会出现404错误。&lt;/p&gt;&lt;p&gt;499 Client has closed connection&lt;/p&gt;&lt;p&gt;网络请求过程中，由于服务端处理时间过长，客户端超时。一般常见于，后端服务器处理时间过长，而客户端也设置了一个超时等待时间，客户端等得“不耐烦”了，主动关掉连接时报出。&lt;/p&gt;&lt;figure/&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrEc39zPecdHQoyzVasylAMR4mnQPK1bdenbose5V165NFtxb808HW73Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;502 Bad Gateway&lt;/p&gt;&lt;p&gt;服务器方面无法给予正常的响应。一般常见于服务器崩溃后，nginx 无法正常收到服务端的响应，给客户端返回502状态码。&lt;/p&gt;&lt;figure&gt;&lt;br/&gt;&lt;/figure&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6921875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrEc7m7jb5VMiaWOSGl9zHMwUbTcTyjegfygfia4iamrFwiakHPwRPPiaOZ5HQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;504 Gateway Timeout&lt;/p&gt;&lt;p&gt;网络请求过程中，由于服务端处理时间过长，网关超时。一般常见于，后端服务器逻辑处理时间过长，甚至长于 nginx设置的最长等待时间时报错。它跟 499 状态码非常像，区别在于499 表示的是客户端超时，504是网关超时。如果是499超时，可以考虑修改客户端的代码调整超时时间，如果是504，则考虑调整nginx的超时配置。&lt;/p&gt;&lt;figure&gt;&lt;br/&gt;&lt;/figure&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.71015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrEXTkeldSlJwU2iatpaM4ERtV4q5KGOeAXS9UaSCky7ticQG8bQI4sblicg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;6. Headers&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;Content-Length&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Content-Length&lt;/code&gt;是HTTP的消息长度, 用&lt;strong&gt;十进制数字&lt;/strong&gt;表示。&lt;code&gt;Content-Length&lt;/code&gt;首部指出报文中消息的当前实际字节大小。如果消息文本进行了gzip压缩的话， &lt;code&gt;Content-Length&lt;/code&gt;指的就是压缩后的大小而不是原始大小。&lt;/p&gt;&lt;p&gt;正常情况下&lt;code&gt;Content-Length&lt;/code&gt;是不需要手动去设置的，大部分语言的网络库都会自动封装好，但是如果在一些特殊情况下，出现&lt;code&gt;Content-Length&lt;/code&gt;与实际要发送的消息大小不一致，就会出现一些问题。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;如果&lt;code&gt;Content-Length&lt;/code&gt; &amp;lt; 实际长度&lt;/p&gt;&lt;p&gt;下面启动一个HTTP服务器，所有语言都一样，示例里使用了golang。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;  &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;io/ioutil&quot;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;net/http&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// w表示response对象，返回给客户端的内容都在对象里处理&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// r表示客户端请求对象，包含了请求头，请求参数等等&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;index&lt;/span&gt;&lt;span&gt;(w http.ResponseWriter, r *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  b, _ := ioutil.ReadAll(r.Body)&lt;br/&gt;  fmt.Printf(&lt;span&gt;&quot;request body=%#v, content_length=%v \nheaders=%v&quot;&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;(b), r.ContentLength, r.Header)&lt;br/&gt;  &lt;span&gt;// 往w里写入内容，就会在浏览器里输出&lt;/span&gt;&lt;br/&gt;  fmt.Fprintf(w, &lt;span&gt;string&lt;/span&gt;(b))&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 设置路由，如果访问/，则调用index方法&lt;/span&gt;&lt;br/&gt;  http.HandleFunc(&lt;span&gt;&quot;/&quot;&lt;/span&gt;, index)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 启动web服务，监听9090端口&lt;/span&gt;&lt;br/&gt;  err := http.ListenAndServe(&lt;span&gt;&quot;:9999&quot;&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;      log.Fatal(&lt;span&gt;&quot;ListenAndServe: &quot;&lt;/span&gt;, err)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在控制台输入&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot; style=&quot;font-size: inherit;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;&quot;&amp;gt; curl -L -X POST &#x27;http://127.0.0.1:9999&#x27; -H &#x27;Content-Type: application/json&#x27; -H &#x27;Content-Length: 5&#x27; -d &#x27;1234567&#x27; |  jq&lt;br/&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt; Total    % Received % Xferd  Average Speed   Time    Time     Time  Current&lt;/span&gt;&lt;br/&gt;                               Dload  Upload   Total   Spent    Left  Speed&lt;br/&gt;100    12  100     5  100     7    828   1160 --:--:-- --:--:-- --:--:--  1400&lt;br/&gt;12345&lt;br/&gt;&amp;lt;/span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输入的body是 &lt;code&gt;1234567&lt;/code&gt;，共&lt;strong&gt;7个数字&lt;/strong&gt;，但是输入的 &lt;code&gt;Content-Length&lt;/code&gt;为 5。到了服务器那，收到了 &lt;code&gt;12345&lt;/code&gt;，共&lt;strong&gt;5个数字&lt;/strong&gt;，数量上跟输入的&lt;code&gt;Content-Length&lt;/code&gt;一致。由此可见当&lt;code&gt;Content-Length&lt;/code&gt; &amp;lt; 实际长度， 消息会被截断。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果&lt;code&gt;Content-Length&lt;/code&gt; &amp;gt;  实际长度&lt;/p&gt;&lt;p&gt;还是上面的服务端代码，但是控制台输入以下命令&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; curl -L -X POST &lt;span&gt;&#x27;http://127.0.0.1:9999&#x27;&lt;/span&gt; -H &lt;span&gt;&#x27;Content-Type: application/json&#x27;&lt;/span&gt; -H &lt;span&gt;&#x27;Content-Length: 100&#x27;&lt;/span&gt; -d &lt;span&gt;&#x27;1234567&#x27;&lt;/span&gt; | jq&lt;/span&gt;&lt;br/&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt; Total    % Received % Xferd  Average Speed   Time    Time     Time  Current&lt;/span&gt;&lt;br/&gt;                               Dload  Upload   Total   Spent    Left  Speed&lt;br/&gt;100     7    0     0    0     7      0      0 --:--:--  0:01:19 --:--:--     0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这次情况不太一样，会发现请求一直阻塞没有返回。这是因为输入的body是 &lt;code&gt;1234567&lt;/code&gt;，共&lt;strong&gt;7个数字&lt;/strong&gt;，但是输入的 &lt;code&gt;Content-Length&lt;/code&gt;为 100。也就是服务端一直认为这次的body&lt;strong&gt;长度为100&lt;/strong&gt;，但是目前只收到了&lt;strong&gt;部分消息（长度为7）&lt;/strong&gt;，剩余的长度为93的消息由于各种原因&lt;strong&gt;还在路上&lt;/strong&gt;，因此选择&lt;strong&gt;傻傻等待剩下的消息&lt;/strong&gt;，就造成了上面提到的阻塞。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;Range&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.8592592592592593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrEVaMJquVzGtic48Ox4ViaUib5jHGGVdXqI82yboz41zoSanrzvy1bp7bBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1350&quot;/&gt;&lt;/p&gt;&lt;p&gt;视频播放需要支持用户调整播放进度，支持让用户选择直接跳到中间部分开始播放。为了实现这个功能，需要通过HTTP Range Requests 协议用于指定需要获取视频片段。而 Request Header里的range头则是用于指定要请求文件的起始和结束位置。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.0528846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrEhuXVdGdfNfW6T2CxylwwdpziaHLaBkULA29eHzoXe24W8usPhbqIVgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;832&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.1063348416289593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrEXEjQ6JQl8YuiaQkQ9oicUPntZX6goqia444Gqu9HwK1nicQrhV47VF5KSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;884&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;如果服务器不支持，直接忽略 Range 头，浏览器会正常按流式加载整个视频文件，以状态码 200 响应即可。另外，当我们在 html 中放一个 video 标签，浏览器会直接发起一个 &lt;code&gt;Range: bytes=0-&lt;/code&gt; 的请求，向服务器请求从开始到结尾的完整文件。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果服务器支持 Range Requests，会读取视频文件，并将他的第 162653～242638 字节提取出来，响应码为 206，则浏览器会在接收到足够字节（比如当前播放进度往后推20s）时结束掉请求，以节省网络流量；当播放进度继续往前，缓存不够时，浏览器会发起一个新的 Range Requests 请求，请求的 Range 直接从缓存结尾的字节开始，只加载剩余的部分文件。同时返回的Response Headers中有一个 content-range 的字段域，用于告诉了客户端发送了多少数据。content-range  描述了响应覆盖的范围和整个实体长度。一般格式：&lt;code&gt;Content-Range：开始字节位置-结束字节位置／文件大小（byte）&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;长连接和短连接&lt;/span&gt;&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Connection: close&lt;/p&gt;&lt;p&gt;表示请求响应完成之后立即关闭连接，这是HTTP/1.0请求的默认值。每次请求都经过“创建tcp连接 -&amp;gt; 请求资源 -&amp;gt; 响应资源 -&amp;gt; 释放连接”这样的过程&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Connection: keep-alive&lt;/p&gt;&lt;p&gt;表示连接不立即关闭，可以继续响应下一个请求。HTTP/1.1的请求默认使用一个持久连接。可以做到只建立一次连接，多次资源请求都复用该连接，完成后关闭。流程上是 建立tcp连接 -&amp;gt; 请求资源 -&amp;gt; 响应资源 -&amp;gt; … （保持连接）…  -&amp;gt;  第n次请求资源 -&amp;gt; 第n次响应资源 -&amp;gt; 释放连接。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在http1.1中Request Header和Reponse Header中都有可能出现一个Connection: keep-alive 头信息。Request Header里的Connection: keep-alive 头是为了告诉服务端，客户端想要以长连接形式进行通信。而Response Header里的Connection: keep-alive 头是服务端告诉客户端，我的服务器支持以长连接的方式进行通信。如果不能使用长连接，会&lt;strong&gt;返回  Connection: close ，相当于告诉客户端“我不支持长连接，你死了这条心，老老实实用短连接吧&lt;/strong&gt;” 。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;HTTP为什么要使用长连接&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;我们知道 HTTP 建立在 TCP 传输层协议之上，而 TCP 的建立需要三次握手，关闭需要四次挥手，这些步骤都需要时间，带给 HTTP 的就是请求响应时延。如果使用短连接，那么每次数据传输都需要经历一次上面提到的几个步骤，如果能只连接一次，保持住这个连接不断开，期间通信就可以省下建立连接和断开连接的过程，对于提升HTTP性能有很大的帮助。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;2.885157096424702&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrECxhRZULRugDkTicq4Hv0WU1S6F8EWgvpR4L4NanZTjIS0icRXgNfuAiaQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;923&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.9989154013015185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrEPF5akEr3ZCdjKMSu5NLVzV1Gpdic7zMAhWY8xGFWibV0LiaUBPgDd9yJQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;922&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;长连接&lt;/strong&gt;可以&lt;strong&gt;省去较多的TCP建立和关闭的操作，减少浪费，节约时间&lt;/strong&gt;。对于频繁请求资源的客户来说，较适用长连接。但是在长连接的应用场景下，需要有一方主动关闭连接。如果客户端和服务端之间的连接一直不关闭的话，连接数则会越来越多，严重的时候会造成资源占用过高。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;解决方案也比较简单。如果这些连接其实长时间内并没有任何数据传输的话，那其实属于空闲连接，这时候可以在服务端设置空闲连接的存活时间，超过一定时间后由服务端主动断掉，从而保证无用连接及时释放。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;Cookies是什么&lt;/span&gt;&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Cookie 是浏览器访问服务器后，服务器传给浏览器的一段数据。里面一般带有该浏览器的身份信息。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;浏览器需要保存这段数据，不得轻易删除。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;此后每次浏览器访问该服务器，都必须带上这段数据。服务器用使用这段数据确认浏览器身份信息。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;&lt;span&gt;Cookie的作用&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;Cookie 一般有两个作用。&lt;/p&gt;&lt;p&gt;1.识别用户身份。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;举个例子。用户 A 用浏览器访问了“猫猫网”，“猫猫网”的服务器就会立刻给 A 返回一段Cookie数据，内含「uid=a」。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当 A 再次访问“猫猫网”下的其他页面时，比如跳转到“猫猫交友评论”，就会附带上「uid=a」这段数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;同理，用户 B 用浏览器访问“猫猫网” 时，就给 B 分配了一段Cookie数据，内含「uid=b」。B 之后访问“猫猫网”的时候，就会一直带上「uid=b」这段数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;因此“猫猫网”的服务器通过Cookie数据就能区分 A 和 B 两个用户了。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;2.持久化用户信息。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;因为cookies的数据会被用户浏览器保存到本地下。因此可以利用这一特点保持一些简单的用户数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;比如一些博客网站，可以通过cookies记录下用户的性别年龄等信息，以此进行一些个性化展示。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当然上面提到的都是一些比较粗糙的场景，是为了方便大家理解cookies的功能。实际使用cookies会非常谨慎。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;Referrer Policy 和 Referrer&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.1950207468879668&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrETULWrTtorwZiauv1NhQ1roIQsHMZRicfYrDZOqp0JqRgHXpqFcXUugCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;482&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;Referrer是什么&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;Referrer 是HTTP请求header的报文头，用于指明当前流量的来源参考页面，常被用于分析用户来源等信息。通过这个信息，我们可以知道访客是怎么来到当前页面的。比如在上面的请求截图里，可以看出我是使用&lt;code&gt;https://www.bilibili.com/&lt;/code&gt;访问的视频资源。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;Referrer Policy 是什么&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;为什么要这么麻烦呢？因为有些网站一些用户敏感信息，比如 sessionid 或是 token 放在地址栏里，如果当做Referrer字段全部传递的话，那第三方网站就会拿到这些信息，会有一定的安全隐患。所以就有了 Referrer Policy，用于过滤 Referrer 报头内容。&lt;/p&gt;&lt;p&gt;比如在上面的请求截图里，可以看出我是使用&lt;code&gt;strict-origin-when-cross-origin&lt;/code&gt;策略，含义是跨域时将当前页面URL过滤掉参数及路径部分，仅将协议、域名和端口（如果有的话）当作 Referrer。否则 Referrer 还是传递当前页的全路径。同时当发生降级（比如从 https:// 跳转到 http:// ）时，不传递 Referrer 报头。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Cache-control&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;什么是cache-control&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;cache-control，用于控制浏览器缓存。简而言之，当某人访问网站时，其浏览器将在本地保存某些资源，例如图像和网站数据。当该用户重新访问同一网站时，缓存控制设置的规则会确定该用户是否从本地缓存中加载这些资源，或者浏览器是否必须向服务器发送新资源的请求。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;什么是浏览器缓存&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;浏览器缓存是指浏览器本地保存网站资源，以便不必再次通过网络从服务器获取它们。例如，“猫猫网”的背景图像可以保存到本地缓存中，这样在用户第二次访问该页面时，该图像将从用户的本地文件加载，剩下网络获取资源的时间，页面加载速度就会更快。&lt;/p&gt;&lt;p&gt;但是浏览器也不会永远把这些网站资源放在本地，否则本地磁盘就会炸，所以会限定保存资源的时间，这叫生存时间（TTL）。如果 TTL 过期后用户请求缓存的资源，浏览器必须再次通过网络与服务器建立连接并重新下载这个资源。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;常见的缓存控制策略&lt;/span&gt;&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;cache-control: private&lt;br/&gt;具有“private”指令的响应只能由客户端缓存，不能由中间代理（例如 CDN或代理）缓存。这些资源通常是包含私密数据的资源，例如显示用户个人信息的网站。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;cache-control: public&lt;br/&gt;相反，“public”指令表示资源可以由任何缓存存储。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;cache-control: no-store&lt;br/&gt;带有“no-store”指令的响应无法缓存到任何位置，也永不缓存。也就是说，用户每次请求此数据时，都必须将请求发送到源站服务器以获取新副本。此指令通常保留给包含极其敏感数据的资源，例如银行帐户信息。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;cache-control: max-age&lt;br/&gt;此指令指定了生存时间，也就是资源在下载后可以缓存多少秒钟。例如，如果将最大期限设置为 1800，则首次从服务器请求资源后的 1800 秒（30 分钟）内，后续请求都会向用户提供该资源的缓存版本。如果 30 分钟后用户再次请求资源，则客户端需要向服务器重新请求该资源。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;cache-control: no-cache&lt;/p&gt;&lt;p&gt;从B站截图里可以看出，使用的缓存控制指令是&lt;code&gt;cache-control: no-cache&lt;/code&gt;。它表示，只有先检查资源没有更新版本后，才可使用所请求资源的缓存版本。那么问题来了，怎么判断资源是否有更新版本呢？这就需要 &lt;code&gt;ETag&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;ETag&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.072549019607843&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrEtNDibEzkbVcyCtxRtV7EichMJKoVnIszoCxTOCaibwq4T2D9ic7wcaw6rA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1020&quot;/&gt;&lt;/p&gt;&lt;p&gt;Etag是 Entity tag的缩写，是服务端的一个资源版本的令牌标识。在 HTTP 响应头中将其传送到客户端。每当资源更新时，此令牌会更新。&lt;/p&gt;&lt;p&gt;比如，浏览器第一次请求资源的时候，服务端返回了这个资源的&lt;code&gt;ETag: &quot;095933fff2323351d3b495f2f879616f1762f752&quot;&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;当浏览器再次请求这个资源的时候，浏览器会将&lt;code&gt;If-None-Match: &quot;095933fff2323351d3b495f2f879616f1762f752&quot;&lt;/code&gt; 传输给服务端，服务端拿到该ETAG，对比资源是否发生变化。&lt;/p&gt;&lt;p&gt;此过程可确保用户始终获得资源的最新版本，并且无需进行不必要的下载。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;果然B站是个充满学习氛围的地方，看个猫片都能学到这么多硬核知识。接下来我打算去舞蹈区看看有没有适合你们的知识点。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.002&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrE5FjleBe3Ny5XrFjla3LiaefbEKdEbQicuBMB2qlW8qCMkKTkKSrTdekg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;&lt;p&gt;我是小白，有空？一起在知识的海洋里呛水啊，懂我意思？&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.8574561403508771&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrEuTnic9sSf39YRzqLQbH5YyWO7NibiapL3KXq2fC54ynWibPuMSwkicqSMBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;912&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/FmVWPHrDdnlAaoSXY0YM0UFgz62fPnrEaMTUbapm8DVqiaVqCwq7qBRtvOQ3DhPPV9ibeAzRh8txzmzAzlGUlPRg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;- [1] 计算机网络自动向下&lt;/p&gt;&lt;p&gt;- [2] 极客时间-趣谈网络协议&lt;/p&gt;&lt;p&gt;- [3] 极客时间-透视HTTP&lt;/p&gt;&lt;p&gt;- [4] 图解HTTP&lt;/p&gt;&lt;p&gt;- [5] 漫画形象-小肥柴&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fb3431f8de8b8a817a483ecafdec39d7</guid>
<title>字符串匹配：Boyer–Moore 算法 （详细图文）</title>
<link>https://toutiao.io/k/vc2yvr7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-body&quot;&gt;
  &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm&quot;&gt;Boyer–Moore 算法&lt;/a&gt;
是用来在字符串中搜索一个子字符串的算法。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;marked&quot;&gt;
本文内容较多，需要读者静心阅读。
&lt;/span&gt;&lt;/p&gt;
      &lt;h3 id=&quot;问题&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          问题 &lt;a href=&quot;#问题&quot; class=&quot;heading-anchor&quot;&gt;¶&lt;/a&gt;
        
        &lt;/span&gt;
      &lt;/h3&gt;

&lt;p&gt;在长度为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; 的字符串 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s&lt;/code&gt; 中搜索长度为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m&lt;/code&gt; 的子串 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt; 的位置。&lt;/p&gt;

&lt;p&gt;本文以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ABCDABEABDCBCDDBBCDBACD&lt;/code&gt; 为主串 ，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BCDBACD&lt;/code&gt; 为子串，作为用例。&lt;/p&gt;
    
      &lt;h3 id=&quot;算法过程&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          算法过程 &lt;a href=&quot;#算法过程&quot; class=&quot;heading-anchor&quot;&gt;¶&lt;/a&gt;
        
        &lt;/span&gt;
      &lt;/h3&gt;

&lt;p&gt;首先将两个字符串左对齐，对子串 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt; 进行 &lt;span class=&quot;marked&quot;&gt;自右向左&lt;/span&gt; 的逐一比对。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-100&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-1.png-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-1.png&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 1.1 - 自右向左开始比对
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;第一次比对，即在字符 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E&lt;/code&gt; 失配。
由于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E&lt;/code&gt; 不在子串 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt; 中，因此，可以直接把整个子串右移到其右边。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-100&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-2.png-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-2.png&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 1.2 - 右移 p 到失配处右侧
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;继续向前匹配，此时在下图 1.3 中的红色部分失配。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-100&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-3.png-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-3.png&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 1.3 - 第二次失配的情况
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;但是，失配的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; 在子串 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt; 中，就在当前位置靠左一位的位置。
要想子串和主串在附近匹配成功，至少字符 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; 要对的齐。
为了避免错过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; 的匹配，只能找到靠的最近的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; 对齐，也就是右移一位。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-100&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-4.png-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-4.png&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 1.4 - 右移 p 和失配处对齐
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;继续向前匹配，在下图 1.5 中的红色部分失配。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-100&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-5.png-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-5.png&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 1.5 - 第三次失配的情况
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;沿用刚才上面的思路，失配的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;D&lt;/code&gt; 也在子串中，右移 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt; ，让它们对齐：&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-100&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-6.jpeg-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-6.jpeg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 1.6 - 右移 p 和失配处对齐
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;总结出来规律了，
&lt;span class=&quot;marked&quot;&gt;
当失配的时候，右移子串，使得主串中失配的字符和子串中左边最近的相同字符对齐。如果不存在相同字符，就把整个子串右移到失配字符的右侧。
&lt;/span&gt;&lt;/p&gt;
    
      &lt;h4 id=&quot;坏字符的办法&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          坏字符的办法 &lt;a href=&quot;#坏字符的办法&quot; class=&quot;heading-anchor&quot;&gt;¶&lt;/a&gt;
        
        &lt;/span&gt;
      &lt;/h4&gt;

&lt;p&gt;常把失配处的字符叫做「坏字符」，每次右移，就要把 &lt;strong&gt;坏字符和子串中最近的坏字符对齐&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;Boyer–Moore 算法和 &lt;a href=&quot;/post/algorithm-string-searching-kmp&quot;&gt;KMP 算法&lt;/a&gt; 的思路类似，都是在失配处动脑筋，跳过无必要的比对，以加快搜索。&lt;/p&gt;

&lt;p&gt;按这个思路，可以继续匹配下去，直到命中。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-100&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-7.jpeg-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-7.jpeg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 1.7 - 对齐「坏字符」的匹配办法
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;
    
      &lt;h4 id=&quot;好后缀的办法&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          好后缀的办法 &lt;a href=&quot;#好后缀的办法&quot; class=&quot;heading-anchor&quot;&gt;¶&lt;/a&gt;
        
        &lt;/span&gt;
      &lt;/h4&gt;

&lt;p&gt;上面坏字符的办法，还不够快。&lt;/p&gt;

&lt;p&gt;比如下面这次对齐：&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-100&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-8.png-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-8.png&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 1.8 - 存在优化点的右移对齐
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;此时，已知的信息是，主串中有已经匹配好的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CD&lt;/code&gt; ，它同时也是子串 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt; 的后缀，常叫做「好后缀」。&lt;/p&gt;

&lt;p&gt;要想子串在附近和主串匹配成功，它们的共同子串 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CD&lt;/code&gt; 就要对的齐，所以，把对齐坏字符的办法应用到好后缀上，
找到最近的好后缀进行右移对齐。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-100&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-9.png-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-9.png&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 1.9 - 好后缀对齐的办法
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;如此一来，右移的更多了些。&lt;/p&gt;

&lt;p&gt;好后缀的办法就是，
&lt;span class=&quot;marked&quot;&gt;&lt;strong&gt;失配时，右移子串，使得主串中的好后缀和子串中左边最近的重复串对齐&lt;/strong&gt; &lt;/span&gt; 。
同样的，如果存在好后缀，而左边没有重复串时，那么直接把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt; 右移到整个好后缀右边就好了。&lt;/p&gt;

&lt;p&gt;综合两个办法后，整个搜索过程优化为下面的样子，总体上比只用坏字符的办法，少了两步。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-100&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-10.jpeg-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-10.jpeg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 2.1 - 综合「坏字符」和「好后缀」办法的查找过程
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;当存在好后缀的时候，由于其长度比坏字符要小，所以一般的，在子串的左边出现的概率相对更低。因此，优化效果更明显，
但不尽然。&lt;span class=&quot;marked&quot;&gt;&lt;strong&gt;综合使用时采用右移距离更大的一个&lt;/strong&gt;&lt;/span&gt; 。&lt;/p&gt;
    
      &lt;h3 id=&quot;编码思路&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          编码思路 &lt;a href=&quot;#编码思路&quot; class=&quot;heading-anchor&quot;&gt;¶&lt;/a&gt;
        
        &lt;/span&gt;
      &lt;/h3&gt;

&lt;p&gt;先考虑失配时迭代变量如何跳转的问题。&lt;/p&gt;

&lt;p&gt;假设，主串和子串的迭代变量分别是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;j&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;在失配时，显然， 子串回到尾巴，即 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;j → m - 1&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;marked&quot;&gt;
关键是计算失配时 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i&lt;/code&gt; 的迭代量。
&lt;/span&gt;&lt;/p&gt;
    
      &lt;h5 id=&quot;坏字符的办法-1&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          坏字符的办法
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;先考虑坏字符的办法。遇到一个坏字符的时候，假设子串中左边最近的坏字符对子串尾巴的距离是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;从下图可以推断出主串的迭代量就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt;：&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-100&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-11.jpeg-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-11.jpeg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 2.2 - 主串失配时的迭代量
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;特殊地，坏字符在子串左边不存在时，主串迭代的量应是子串长度 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m&lt;/code&gt; ，则取 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d = m&lt;/code&gt; 来满足。&lt;/p&gt;
    
      &lt;h5 id=&quot;好后缀的办法-1&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          好后缀的办法
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;对于好后缀的办法，道理是相似的 。&lt;/p&gt;

&lt;p&gt;把拿来对齐的左边的重复串叫做 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeat&lt;/code&gt;，
把对齐好后缀的过程，看作对齐 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeat&lt;/code&gt; 前面那个字符的过程，即可复用上面的思路。
如此一来，假设 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeat&lt;/code&gt; 前面字符到尾巴字符的距离是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt; ，则失配的时候，主串的迭代量就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt;。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-100&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-12.jpeg-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-12.jpeg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 2.3 - 主串失配时的迭代量
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;进一步地，若假设重复串 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeat&lt;/code&gt; 的头部的位置是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt; 的话， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt; 其实是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m - t&lt;/code&gt; 。&lt;/p&gt;

&lt;div id=&quot;good-suffix-matched-begin&quot;&gt;
  &lt;p&gt;如果重复串 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeat&lt;/code&gt; 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt; 的开头，前面没有字符，此时主串的迭代量是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m&lt;/code&gt;，而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt; 恰好是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; ，仍然满足 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d = m - t&lt;/code&gt; 的关系。
下面的图 2.4 构造了这种情况 （为说明问题，对本文用例稍加改造）：&lt;/p&gt;

  &lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-100&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-12-1.jpeg-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-12-1.jpeg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 2.4 - 重复串 repeat 恰好在子串开头的情况
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
  &lt;p/&gt;

&lt;/div&gt;

&lt;div id=&quot;good-suffix-case-not-in-left&quot;&gt;
  &lt;p&gt;但是，如果重复串 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeat&lt;/code&gt; 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt; 的左边不存在，情况变得复杂起来，分情况讨论：&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;span id=&quot;good-suffix-partial-match&quot;&gt;&lt;strong&gt;好后缀部分匹配到了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt; 的一个前缀&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

      &lt;p&gt;下图 2.5 构造了这一种情况，此时应该右移到对齐 「匹配到的部分」。&lt;/p&gt;

      &lt;p&gt;在下图中需要对齐绿色的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CD&lt;/code&gt; 。
可以看到此时的主串迭代量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt; 比搜索串的长度 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m&lt;/code&gt; 要大。&lt;/p&gt;

      &lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-100&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-12-2.jpeg-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-12-2.jpeg&quot; alt=&quot;&quot;/&gt;
    
     
    &lt;figcaption&gt;图 2.5 - 好后缀部分匹配到子串的前缀的情况
       
    &lt;/figcaption&gt;
     
   
 &lt;/figure&gt;
      &lt;p/&gt;

      &lt;p&gt;为了进一步找出计算公式，可以虚假地构造一部分前缀 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fake&lt;/code&gt;，即可套用 &lt;a href=&quot;#good-suffix-matched-begin&quot;&gt;完全匹配到开头&lt;/a&gt; 的情况。&lt;/p&gt;

      &lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-100&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-12-3.jpeg-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-12-3.jpeg&quot; alt=&quot;&quot;/&gt;
    
     
    &lt;figcaption&gt;图 2.6 - 构造虚拟前缀来套用完全匹配的情况
       
    &lt;/figcaption&gt;
     
   
 &lt;/figure&gt;
      &lt;p/&gt;

      &lt;p&gt;可以看到， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d = m + len(fake)&lt;/code&gt; ，实际即是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m + len(suffix) - len(prefix)&lt;/code&gt;。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;strong&gt;好后缀在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt; 的左边完全没有匹配上&lt;/strong&gt;&lt;/p&gt;

      &lt;p&gt;主串迭代量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt; 则是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m + 好后缀长度&lt;/code&gt;。&lt;/p&gt;

      &lt;p&gt;下图 2.7 构造了这一种情况。可以看到，这是第一个情况，即 &lt;a href=&quot;#good-suffix-partial-match&quot;&gt;部分匹配前缀&lt;/a&gt; 的一种特例。&lt;/p&gt;

      &lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-100&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-12-4.jpeg-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-12-4.jpeg&quot; alt=&quot;&quot;/&gt;
    
     
    &lt;figcaption&gt;图 2.7 - 好后缀和搜索串完全失配的情况
       
    &lt;/figcaption&gt;
     
   
 &lt;/figure&gt;
      &lt;p/&gt;
    &lt;/li&gt;
  &lt;/ol&gt;

&lt;/div&gt;

&lt;p&gt;总而言之，好后缀的办法，分为两种情况：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;好后缀在左边&lt;/strong&gt;：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d = m - t&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;好后缀不在左边&lt;/strong&gt;：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d = m + len(suffix) - len(prefix)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;事实上，无论坏字符的办法、还是好后缀的办法，
 &lt;span class=&quot;marked&quot;&gt;&lt;strong&gt;失配情况下，主串的迭代量是与主串无关的&lt;/strong&gt; &lt;/span&gt; 。&lt;/p&gt;
    
      &lt;h4 id=&quot;坏字符表&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          坏字符表 &lt;a href=&quot;#坏字符表&quot; class=&quot;heading-anchor&quot;&gt;¶&lt;/a&gt;
        
        &lt;/span&gt;
      &lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;#坏字符的办法-1&quot;&gt;前面所说的&lt;/a&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt; 预处理成为一个表格，包括两个维度：主串中的坏字符 和 子串失配的位置，如下图所示 （问号表示其他字符）：&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-80&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-13.jpeg-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-13.jpeg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 3.1 - 坏字符表格
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;假设字符集的大小是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S&lt;/code&gt; （一般取 &lt;a href=&quot;https://www.ascii-code.com/&quot;&gt;ASCII 表&lt;/a&gt; 的大小 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;256&lt;/code&gt;） 。
事实上，此表格可以用归纳的方法，以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(S * m)&lt;/code&gt; 的线性时间复杂度计算得出。&lt;/p&gt;

&lt;p&gt;其方法是，
假设当前格子对应的子串失配的字符是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p[k]&lt;/code&gt; ，自上而下，自左而右进行填表：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第一列，全部填写 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m&lt;/code&gt; 。&lt;/li&gt;
  &lt;li&gt;如果「坏字符」等于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p[k-1]&lt;/code&gt; 的话，则填入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m - 1 - k&lt;/code&gt; 。&lt;/li&gt;
  &lt;li&gt;否则，拷贝当前格子左边格子的数值。&lt;/li&gt;
&lt;/ul&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-80&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-14.jpeg-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-14.jpeg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 3.2 - 坏字符表格的填表方式
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;这个表格的空间占用则是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(S * m)&lt;/code&gt; 。
实际中，大多数的编码实现都只取最后一列，即只采用一个一维表格，其具有常数大小的空间占用。
例如，&lt;a href=&quot;https://golang.org/src/strings/search.go&quot; target=&quot;_blank&quot;&gt;Golang 官方的字符串搜索&lt;/a&gt;
采用 Boyer-Moore 算法，构建的是一维坏字符表。&lt;/p&gt;

&lt;p&gt;另外，&lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm#Implementations&quot; target=&quot;_blank&quot;&gt;Boyer-Moore 算法 - 维基百科&lt;/a&gt;
中也确有指出 &lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm#The_bad_character_rule&quot;&gt;创建二维坏字符表的方法&lt;/a&gt;，
并且有给出使用二维坏字符表的 Python 实现。&lt;/p&gt;

&lt;p&gt;采用一维坏字符表时，表格含义即退化为：&lt;strong&gt;坏字符在子串中最右侧出现的位置，距离尾巴字符的距离&lt;/strong&gt; 。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-50&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-15.jpeg-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-15.jpeg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 3.3 - 坏字符表格的退化
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;同时，构建坏字符表格的方法也会更简单：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;初始化一维表格 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;table&lt;/code&gt; 的每一项是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m&lt;/code&gt; 。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;假设 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt; 的尾巴字符的位置是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;last = m-1&lt;/code&gt; ：&lt;/p&gt;

    &lt;p&gt;对尾巴左边的每个字符 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;char = p[k]&lt;/code&gt; ，不断覆盖 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;table[char] = last - k&lt;/code&gt; 即可。&lt;/p&gt;

    &lt;p&gt;上面注意 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k = 0..(last - 1)&lt;/code&gt; ，尾巴字符左边的字符才有可能成为坏字符的对齐目标。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一维的坏字符表格如下所示：&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-60&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-16.png-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-16.png&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 3.4 - 一维的坏字符表格
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;details id=&quot;code-ComputeBadCharTable&quot;&gt;
  &lt;summary&gt;C 语言实现 - 填写坏字符表&lt;/summary&gt;
  &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// ComputeBadCharTable 计算一维坏字符表&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ComputeBadCharTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 初始化每一个字符的坏字符表值为 m&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ALPHABET_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 对尾巴左边的字符，不断覆盖它到尾巴 last 的距离&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 坏字符的对齐目标绝不在尾巴字符上。&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/details&gt;
    
      &lt;h4 id=&quot;好后缀表&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          好后缀表 &lt;a href=&quot;#好后缀表&quot; class=&quot;heading-anchor&quot;&gt;¶&lt;/a&gt;
        
        &lt;/span&gt;
      &lt;/h4&gt;

&lt;p&gt;好后缀表的构造一般被认为是 Boyer-Moore 算法中最难的部分。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#好后缀的办法-1&quot;&gt;前面已经分析&lt;/a&gt; 好后缀方法中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt; 存在两种情况。&lt;/p&gt;

&lt;p&gt;明确现在的问题，对于搜索串 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt; 的所有后缀 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;suffix(k)&lt;/code&gt; ，找出对应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt;，其中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k&lt;/code&gt; 是失配的位置。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-80&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-17.jpeg-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-17.jpeg&quot; alt=&quot;&quot;/&gt;
    
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;假设存放 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt; 的一维数组是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;table&lt;/code&gt; ，考虑此表格如何填写。&lt;/p&gt;

&lt;p&gt;参考 &lt;a href=&quot;#好后缀的办法-1&quot;&gt;前面的分析&lt;/a&gt; ， 共有两种情况，分两次填表。&lt;/p&gt;

&lt;p&gt;先处理第二种情况的填表过程，即 &lt;a href=&quot;#good-suffix-case-not-in-left&quot;&gt;好后缀不在左边的情况&lt;/a&gt;。&lt;/p&gt;

&lt;div id=&quot;why-good-suffix0case2-first&quot;&gt;
  &lt;p&gt;原因在于，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;table&lt;/code&gt; 的意义是失配时，主串迭代的多少。
第二种情况的值更大。
先填写更大的，再覆盖以小的， 这样才不至于错过小迭代量的匹配点。&lt;/p&gt;
&lt;/div&gt;
    
      &lt;h5 id=&quot;好后缀不在左边的情况&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          好后缀不在左边的情况
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;为方便说明，本部分的搜索串的示例调整为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DDDBDDD&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;参考 &lt;a href=&quot;#好后缀的办法-1&quot;&gt;前面的分析&lt;/a&gt; ，此情况下的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d = m + len(suffix) - len(prefix)&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;举例来说，当好后缀为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BDDD&lt;/code&gt; 的时候，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt; 的求值如下图所示：&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-100&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-18.jpeg-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-18.jpeg&quot; alt=&quot;&quot;/&gt;
    
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;问题是：如何找到搜索串的每一个后缀的部分匹配前缀 ？&lt;/p&gt;

&lt;p&gt;下图中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;suffix(k)&lt;/code&gt; 表示在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k&lt;/code&gt; 处失配时的好后缀，黄色框表示其对应的部分匹配前缀，
右边依次列出前缀的长度：&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-100&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-19.jpeg-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-19.jpeg&quot; alt=&quot;&quot;/&gt;
    
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;前缀长度的变化是有规律的，从上而下填写：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果后缀是一个前缀，计算 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;len(prefix) = len(suffix)&lt;/code&gt; ，并记录为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;last_prefix_length&lt;/code&gt; 。&lt;/li&gt;
  &lt;li&gt;否则，沿用上一次的计算结果： &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;len(prefix) = last_prefix_length&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;是否和 &lt;a href=&quot;/post/algorithm-string-searching-kmp#头尾公共长度&quot;&gt;KMP 算法的 next 数组计算方式&lt;/a&gt; 类似呢。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;len(prefix)&lt;/code&gt; 的计算清楚之后，此情况的填表过程即得到解决。&lt;/p&gt;

&lt;details id=&quot;code-ComputeGoodSuffixTableCaseNotInLeft&quot;&gt;
  &lt;summary&gt;C 语言实现 - 填写好后缀表 - 好后缀不在搜索串的左边的情况 &lt;/summary&gt;

  &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// ComputeGoodSuffixTableCaseNotInLeft&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 填写好后缀表，处理情况：好后缀不在搜索串的左边的情况&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ComputeGoodSuffixTableCaseNotInLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_prefix_length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 失配位置在 m - 1 时，好后缀无意义，设为跳动最少 1&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// i 表示后缀的起始位置&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// k 表示失配的位置&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suffix_length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;suffix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prefix_length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strncmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suffix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suffix_length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 如果后缀是一个前缀&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;prefix_length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suffix_length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;last_prefix_length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prefix_length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 否则，沿用上次结果&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;prefix_length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_prefix_length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 计算 d&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suffix_length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prefix_length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/details&gt;
    
      &lt;h5 id=&quot;好后缀在左边的情况&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          好后缀在左边的情况
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;为方便说明，本部分的搜索串的示例调整为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DCDBCDACD&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;参考 &lt;a href=&quot;#好后缀的办法-1&quot;&gt;前面的分析&lt;/a&gt; ，此情况下的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d = m - t&lt;/code&gt; ，
如何计算 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt; 取决于如何找到左边&lt;strong&gt;最右的&lt;/strong&gt;重复串。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-100&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-20.png-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-20.png&quot; alt=&quot;&quot;/&gt;
    
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;引入一个概念：&lt;strong&gt;最长公共后缀&lt;/strong&gt; ，如图所示：&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-100&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-21.png-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-21.png&quot; alt=&quot;&quot;/&gt;
    
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;details id=&quot;code-GetLongestCommonSuffixLength&quot;&gt;
  &lt;summary&gt; C 语言实现 - 最长公共后缀长度&lt;/summary&gt;

  &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// GetLongestCommonSuffixLength 返回字符串 a 和 b 的最长公共后缀长度。&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 比如 &#x27;simple&#x27; 和 &#x27;example&#x27; 的最长公共后缀是 &#x27;mple&#x27; ，长度是 4.&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GetLongestCommonSuffixLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a_length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b_length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a_length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b_length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a_length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b_length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/details&gt;

&lt;p&gt;&lt;span class=&quot;marked&quot;&gt;
&lt;strong&gt;如果左边存在重复串，那么它是一个前缀 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt; 的最长公共后缀&lt;/strong&gt;
&lt;/span&gt; 。&lt;/p&gt;

&lt;p&gt;下图中，两个前缀串和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt; 的最长公共后缀相同，取长的那个。
这样才能找到 &lt;strong&gt;最右的&lt;/strong&gt; 重复串。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-100&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-22.jpeg-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-22.jpeg&quot; alt=&quot;&quot;/&gt;
    
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;也就是，&lt;span class=&quot;marked&quot;&gt;前缀要从短往长去找，用长的去覆盖短的计算结果 &lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;如果前缀以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt; 下标结尾， 显然 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t = e + 1 - len(suffix)&lt;/code&gt; 。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-100&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-23.jpeg-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-23.jpeg&quot; alt=&quot;&quot;/&gt;
    
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;至此，思路如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt; 的每个前缀，计算它和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt; 的最长公共后缀，设其长度 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;len&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;即确定了长度为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;len&lt;/code&gt; 的后缀，相应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt; 亦可得出。&lt;/li&gt;
  &lt;li&gt;长的前缀的计算结果覆盖短的。&lt;/li&gt;
&lt;/ul&gt;

&lt;details&gt;

  &lt;summary&gt; 进一步的说明 &lt;/summary&gt;

  &lt;p&gt;为方便说明，将搜索串 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt; 的例子调整为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACDBCDABCD&lt;/code&gt; 。&lt;/p&gt;

  &lt;p&gt;后缀 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CD&lt;/code&gt; 对应的前缀则是：&lt;/p&gt;

  &lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-100&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-24.jpeg-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-24.jpeg&quot; alt=&quot;&quot;/&gt;
    
     
   
    &lt;/figure&gt;
  &lt;p/&gt;

  &lt;p&gt;注意的是，此情况下重复串的位置，在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prefix1&lt;/code&gt; 结尾。&lt;/p&gt;

  &lt;p&gt;并非巧合，重复串和好后缀左边的字符必然不同，
否则右移后坏字符仍然失配。&lt;/p&gt;

  &lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-100&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-25.jpeg-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-25.jpeg&quot; alt=&quot;&quot;/&gt;
    
     
   
    &lt;/figure&gt;
  &lt;p/&gt;

&lt;/details&gt;

&lt;details id=&quot;code-ComputeGoodSuffixTableCaseInLeft&quot;&gt;
  &lt;summary&gt;C 语言实现 - 填写好后缀表 - 好后缀在搜索串的左边的情况 &lt;/summary&gt;

  &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// ComputeGoodSuffixTableCaseInLeft&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 填写好后缀表，处理情况：好后缀在搜索串的左边的情况&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ComputeGoodSuffixTableCaseInLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// e 表示对应的前缀的结尾位置&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 前缀字符串&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 前缀的长度&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prefix_length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 最长公共后缀的长度，即好后缀的长度&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suffix_length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;GetLongestCommonSuffixLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prefix_length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;suffix_length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 好后缀长度 &amp;gt; 0 才有意义&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// t 是重复串的起始位置&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suffix_length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 失配字符的位置&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suffix_length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 填表，覆盖&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/details&gt;

&lt;details id=&quot;code-ComputeGoodSuffixTable&quot;&gt;
  &lt;summary&gt;C 语言实现 - 填写好后缀表 - 综合两种情况 &lt;/summary&gt;

  &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// ComputeGoodSuffixTable 计算好后缀表的方法&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ComputeGoodSuffixTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 先处理第二种情况：好后缀在搜索串左边不存在的情况&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 即好后缀和搜索串部分匹配或者完全不匹配的情况&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ComputeGoodSuffixTableCaseNotInLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 再处理第一种情况：好后缀在搜索串左边存在的情况&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ComputeGoodSuffixTableCaseInLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/details&gt;
    
      &lt;h3 id=&quot;查找过程&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          查找过程 &lt;a href=&quot;#查找过程&quot; class=&quot;heading-anchor&quot;&gt;¶&lt;/a&gt;
        
        &lt;/span&gt;
      &lt;/h3&gt;

&lt;p&gt;可以看到，&lt;strong&gt;坏字符表和好后缀表只和搜索串有关，可以提前生成&lt;/strong&gt; 。&lt;/p&gt;

&lt;p&gt;至此，已可以完成整个 Boyer-Moore 算法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对搜索串，填写坏字符表和好后缀表&lt;/li&gt;
  &lt;li&gt;先对齐主串和搜索串。&lt;/li&gt;
  &lt;li&gt;自右向左匹配。&lt;/li&gt;
  &lt;li&gt;失配时，挑选两张表中最大的跳转量，作为主串的迭代量。&lt;/li&gt;
&lt;/ul&gt;

&lt;details id=&quot;code-BoyerMoore&quot;&gt;
  &lt;summary&gt;C 语言实现 - BoyerMoore 查找 &lt;/summary&gt;

  &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define max(a, b) ((a &amp;lt; b) ? b : a)
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// BoyerMoore 从长度为 n 的字符串 s 中查找长度为 m 的字符串 p ， 返回其位置.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 找不到则返回 -1&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;BoyerMoore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bad_char_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ALPHABET_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;good_suffix_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;ComputeBadCharTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bad_char_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ComputeGoodSuffixTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;good_suffix_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 初始化，i, j 右对齐&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 自右向左匹配&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 命中, 返回起始位置&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 失配时，跳转的多少，选取坏字符表和好后缀表中最大的跳转量&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bad_char_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;good_suffix_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/details&gt;

&lt;p&gt;此外，Go 语言的实现可以参考官方的 &lt;a href=&quot;https://golang.org/src/strings/search.go&quot; target=&quot;_blank&quot;&gt;search.go&lt;/a&gt; 。&lt;/p&gt;
    
      &lt;h3 id=&quot;复杂度分析&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          复杂度分析 &lt;a href=&quot;#复杂度分析&quot; class=&quot;heading-anchor&quot;&gt;¶&lt;/a&gt;
        
        &lt;/span&gt;
      &lt;/h3&gt;

&lt;p&gt;一维坏字符表构建的时间复杂度是常数的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(S + m)&lt;/code&gt; ，其中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S&lt;/code&gt; 是所考虑的字符集的大小。
二维坏字符表构建的时间复杂度则是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(S * m)&lt;/code&gt; ，均是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m&lt;/code&gt; 相关的线性时间复杂度。&lt;/p&gt;

&lt;p&gt;好后缀表在两种情况下的构建的时间复杂度均为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(m^2)&lt;/code&gt; ，不过一般情况下搜索串的长度相对主串会很小，
&lt;a href=&quot;https://golang.org/src/strings/search.go&quot;&gt;Golang 的官方实现&lt;/a&gt; 对好后缀表的构建方法亦和本文的一致。&lt;/p&gt;

&lt;p&gt;事实上，
&lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm#The_good_suffix_rule&quot; target=&quot;_blank&quot;&gt;Boyer-Moore 算法 - 维基百科&lt;/a&gt;
告诉我们，好后缀表可以在线性时间内构建，可以参考其给出的
&lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm#Implementations&quot; target=&quot;_blank&quot;&gt;Python 实现&lt;/a&gt; ，
其中采用的是 Z-算法。&lt;/p&gt;

&lt;p&gt;查找过程的时间复杂度是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(m * n)&lt;/code&gt; ，其中最好情形如下图所示，时间复杂度是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(n / m)&lt;/code&gt; ：&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-100&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-26.jpeg-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-26.jpeg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;Boyer-Moore 算法的最好情形
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;最坏情形的时间复杂度是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(m * n)&lt;/code&gt; ，退化成为简易的二次循环匹配：&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload width-100&quot; src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-27.jpeg-small.svg&quot; data-src=&quot;/assets/images/posts/algorithm-string-searching-boyer-moore/explain-algorithm-boyer-moore-27.jpeg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;Boyer-Moore 算法的最坏情形
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;
    
      &lt;h3 id=&quot;结语&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          结语 &lt;a href=&quot;#结语&quot; class=&quot;heading-anchor&quot;&gt;¶&lt;/a&gt;
        
        &lt;/span&gt;
      &lt;/h3&gt;

&lt;p&gt;Boyer-Moore 的坏字符办法和好后缀办法，可以综合使用，也可以单独使用一种，其中坏字符的办法实现更简单一些。&lt;/p&gt;

&lt;p&gt;事实上，我认为 Boyer-Moore 算法远不如 &lt;a href=&quot;/post/algorithm-string-searching-kmp&quot;&gt;KMP 算法&lt;/a&gt;
干练精巧，其主体查找过程虽然更容易理解，但是两种表格的计算，尤其是好后缀表的构建，
确是相对复杂的。&lt;/p&gt;

&lt;p&gt;相关阅读：&lt;a href=&quot;/post/algorithm-string-searching-kmp&quot;&gt;字符串匹配 - KMP 算法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;（完）&lt;/p&gt;
  &lt;/div&gt;


&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5fdad7290582cf8742b0a555d5a4ef2f</guid>
<title>你知道你在电脑上怎么被监控了吗</title>
<link>https://toutiao.io/k/q87ai3n</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4FRMwYHkzw4SOT1gRuFKeK59CFqqxl0ibFO802ibcZ3iceT1Dur1vPOzEfj0k2z6sibDiaicn2LltqLDTuUdCOmibdptg/640&quot; data-ratio=&quot;0.7906976744186046&quot; data-w=&quot;86&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;点击上方&lt;span data-mid=&quot;&quot;&gt;蓝字&lt;/span&gt;关注公众号&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;strong/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;title&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-none-contnet=&quot;t&quot;&gt;A&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;技术应用背景：&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;目前已知在杀毒厂商以及游戏厂商的安全对抗过程中，常常需要准确的监控收集并进行检测用户创建打开的EXE应用程序是否是安全的。同时也可以将此技术应用于其他应用的安全对抗方案中。那么如何去准确的监控和收集用户每次点击打开的EXE应用程序信息呢？接下来我就进行还原实现下如何准确的监控并收集用户每次点击打开EXE应用程序技术。&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;title&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-none-contnet=&quot;t&quot;&gt;A&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;效果展示：&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;下图展示的是开启监控程序，这是进行监控电脑上包括系统自启动EXE程序以及用户主动点击启动应用程序的信息。&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;image&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr5z1Pkp8z74Agj9n9j6KibcviatdLk8UYVoqt3mcCPVdYgic0Xnw7e0LbJm9Xp0N4eV8fxvfAEmicclQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.2891566265060241&quot; data-w=&quot;664&quot;/&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;strong/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;title&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-none-contnet=&quot;t&quot;&gt;A&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;功能代码实现：&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;实现监控用户所有创建打开EXE程序的数据需要以下几个步骤：&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;strong/&gt;1.通过调用CoInitializeEx函数，进行对COM初始化。&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;2.通过调用 CoCreateInstance函数， 获得WMI的定位器。&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;3.通过调用IWbemLocator::ConnectServer函数，并指定函数的参数 strNetworkResource 的值为 &quot;root\cimv2&quot;, 从而实现连接到 &quot;IWbemServices&quot;服务器。&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;4. 通过调用CoSetProxyBlanket函数，进行设置 IWbemServices的代理，目的是为了WMI 服务能够模拟客户端角色。&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;5.通过调用 ExecNotificationQuery函数， 来进行查询接收事件。&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;divider&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lYDNMgmFjur6mfkPywZNgKZYXia5C4lA8Kd6CUYOibay3HbIfxBnNXH3v6jQZf6QquSL5dt6qYMrtQGh7go67FZg/640&quot; data-ratio=&quot;0.13953488372093023&quot; data-w=&quot;516&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;下图这部分代码主要的目的是为了初始化COM和WMI的设置。&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;image&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr5z1Pkp8z74Agj9n9j6KibcvZvkXed3BpspebKdSuIEh6vRQCCJYtThzuIIicmclcBMDu3e4xMVMdVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5130111524163569&quot; data-w=&quot;807&quot;/&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;下面代码主要实现查询接收事件，也就是通过ExecNotificationQuery查询来循环获取用户所创建打开的所有EXE的数据。&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;image&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr5z1Pkp8z74Agj9n9j6KibcvPtZOTOLHkjsfRnTH1Ric2n2NRfNrySrL9AF3wdSX3kAq2wuulzLMQiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.8285714285714286&quot; data-w=&quot;910&quot;/&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;strong/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;title&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-none-contnet=&quot;t&quot;&gt;A&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;知识背景清单：&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;概述：WMI技术算得上是一个很古老的技术，它是由微软提供的，同时也是一种非常可靠的解决方案。WMI它还有一个非常大的优势，可以进行访问远程电脑。它是Windows操作系统中管理数据和操作的基础模块，&lt;strong&gt;它提供了一个通过操作系统、网络和企业环境去管理本地或远程计算机的统一接口集&lt;/strong&gt;。&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;divider&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lYDNMgmFjur6mfkPywZNgKZYXia5C4lA8Kd6CUYOibay3HbIfxBnNXH3v6jQZf6QquSL5dt6qYMrtQGh7go67FZg/640&quot; data-ratio=&quot;0.13953488372093023&quot; data-w=&quot;516&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;strong&gt;WMI技术可以应用于：&lt;/strong&gt;&lt;/p&gt;&lt;section mpa-paragraph-type=&quot;body&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;查询获取正在运行进程信息；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;查询获取正在运行线程信息；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;查询获取桌面信息；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;查询获取环境变量信息；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;查询获取驱动信息；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;查询获取文件夹信息；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;查询获取系统信息和系统服务；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;查询获取硬件信息；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;查询获取磁盘相关信息。&lt;/p&gt;&lt;p&gt;---&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;strong/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;secondTitle&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;WMI相关概念&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;1.WBEM它的全称:&lt;strong&gt;Web Based Enterprise Management(基于web的企业管理)&lt;/strong&gt;,它是一种行业规范，建立在企业网络中访问和共享管理信息的标准。&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;2.WMI它的全称&lt;strong&gt;:Windows Management Instrumentation(Windows管理工具)&lt;/strong&gt;,它是WBEM的Windows实现，也就是它要遵守WBEM规则。通过WMI，我们可以获取关于硬件和软件的相关数据，也可以提供关于硬件或软件服务的数据给WMI。&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;3.COM 它的全称：&lt;strong&gt;Component Object Model(组件对象模型)&lt;/strong&gt;，它是由微软推出的一套接口规范，通过设定不同组件之间需要遵守的标准与协议，主要用来跨语言、跨进程之间的模块通信。&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;strong/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;secondTitle&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;WMI相关函数&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;strong&gt;CoInitializeEx函数详解&lt;/strong&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;image&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr5z1Pkp8z74Agj9n9j6KibcvqXz54s7iacYaVHvjxD2KKn42ichYZOe6TveyG72ibrfjHQjVWCe011uZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.24787775891341257&quot; data-w=&quot;589&quot;/&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;strong&gt;2. &lt;/strong&gt;&lt;strong&gt;CoCreateInstance函数详解&lt;/strong&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;image&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr5z1Pkp8z74Agj9n9j6KibcvSv79mLypDbQveibdaMGfBULd21wxeUhfDBM5ra9ic9TWE5Pghl8uwVTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.2957957957957958&quot; data-w=&quot;666&quot;/&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;strong&gt;3. &lt;/strong&gt;&lt;strong&gt;ConnectServer函数详解&lt;/strong&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;image&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr5z1Pkp8z74Agj9n9j6KibcvV6JlLiaicKug0GWAOzNpN0xCnwXsuSZdicDot1iaRClNia8HXY9wjT9icSkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.3125778331257783&quot; data-w=&quot;803&quot;/&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;strong&gt;4. &lt;/strong&gt;&lt;strong&gt;CoSetProxyBlanket函数详解&lt;/strong&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;strong&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr5z1Pkp8z74Agj9n9j6KibcvNXtXibYQwWpAQc9jYhSqmZMAwzH28NM7RtGPJg8NTj4WAW07UFZL14Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.28716216216216217&quot; data-w=&quot;888&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;strong&gt;5.&lt;/strong&gt;&lt;strong&gt;ExecNotificationQuery函数详解&lt;/strong&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;strong&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr5z1Pkp8z74Agj9n9j6Kibcv2dXL6OtyK1W6KVrTIFYkoVwZRk75PiakEX37LkfanU2r7Wic3KibOYOdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.1986754966887417&quot; data-w=&quot;906&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;strong/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;secondTitle&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;WMI架构解析&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;下图的WMI架构图来源于MSDN，我们可以从架构图中很清晰的看到WMI主要分为3的层结构。&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;image&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr5z1Pkp8z74Agj9n9j6KibcvD7LC4OwswXnEz1sMBaHG1aHr4oHqlA0doVcqbNxF0xjcY1End8DCww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.7762237762237763&quot; data-w=&quot;858&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;divider&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lYDNMgmFjur6mfkPywZNgKZYXia5C4lA8Kd6CUYOibay3HbIfxBnNXH3v6jQZf6QquSL5dt6qYMrtQGh7go67FZg/640&quot; data-ratio=&quot;0.13953488372093023&quot; data-w=&quot;516&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;strong&gt;&lt;strong&gt;1.WMI providers&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;and Managed object(WMI提供者和管理对象)&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;WMI提供者是一个监控一个或者多个的托管对象的COM接口。&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;托管对象是指逻辑或者物理组件，例如硬盘驱动器、网络适配器、数据库系统、操作系统、进程或者服务。&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;WMI提供者通过托管对象提供的数据向WMI服务提供数据，同时将WMI服务的请求传递给托管对象。&lt;strong&gt;&lt;strong/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;WMI提供者是由实现逻辑的DLL和承载着描述数据和操作的类的托管对象格式MOF(Managed Object Format)文件组成。其中这个两个文件都保存在\Windows\System32\wbem目录下。&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;image&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr5z1Pkp8z74Agj9n9j6KibcvrgCxPOiaVLQ37lsyibqlPo44V35X0vQzmIMPYGjNA82oNVBCsgmq6ylQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.9188311688311688&quot; data-w=&quot;616&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;divider&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lYDNMgmFjur6mfkPywZNgKZYXia5C4lA8Kd6CUYOibay3HbIfxBnNXH3v6jQZf6QquSL5dt6qYMrtQGh7go67FZg/640&quot; data-ratio=&quot;0.13953488372093023&quot; data-w=&quot;516&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;strong&gt;&lt;strong&gt;2.WMI Infrastructure(WMI基础结构)&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;WMI的基础结构是Windows系统的系统组件。它主要包含两个模块：包含WMI Core(WMI核心)的&lt;strong&gt;WMI Service(WMI服务)&lt;/strong&gt;和&lt;strong&gt;WMI Repository(WMI存储库)&lt;/strong&gt;。&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;  WMI存储库是通过WMI Namespace(WMI命名空间)组织起来的。在系统启动时，WMI服务会创建例如root\cimv2、root\default、root\subscription等等命名空间。&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;strong&gt;WMI服务扮演着WMi提供者、管理应用和WMI存储库之间的协调者角色。&lt;/strong&gt;一般来说，它是通过一个共享的服务进程svchost来实施工作的。当第一个管理应用向WMI命名空间发起连接时，WMI服务将会启动。当管理应用不再调用WMI时，WMI服务将会关闭或者进入低内存状态。&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;divider&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lYDNMgmFjur6mfkPywZNgKZYXia5C4lA8Kd6CUYOibay3HbIfxBnNXH3v6jQZf6QquSL5dt6qYMrtQGh7go67FZg/640&quot; data-ratio=&quot;0.13953488372093023&quot; data-w=&quot;516&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;strong&gt;&lt;strong&gt;3.WMI Consumers(WMI使用者)&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;strong&gt;&lt;strong/&gt;&lt;/strong&gt; 它位于WMI构架的最顶层，它是WMI技术使用的载体。对于使用C++代码实现我们就可以直接通过COM技术直接与下层进行通信。对于.net平台语言，则要使用System.Management域相关功能与下层进行通信。WMI的使用者，可以进行查询、枚举数据，也可以运行Provider的方法，还可以向WMI订阅消息。其中这些数据操作都是要有相应的Provider来提供。&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.5757575757575757&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/V2zhcryr8Zo4NvmbFib8EPluyESUibdLfBj0loe2wicEHa7EV2abdbP19XibsaU5riaNjZfuGx0icbtIFR5JvPVHUEjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;66&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.5757575757575757&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QpwCAeQOZQ9PQib59RhM16L4hwNTEAfwXgkP09Z2A2W1W5XarZiamGGm04xIhJv953UfEEG2z6IvQZUvGpIQ4Qhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;66&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;/p&gt;&lt;p mpa-paragraph-type=&quot;body&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-mpa-category=&quot;模板&quot; data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/G5JibjasY9UHkSMYSrOWlOVLHIXicfYxxbvHkvmqBjsEMpV4Ijos5xBCdicNLP1gzJicZkul5ibNUDNHtrl1ClGgeibA/640&quot; data-ratio=&quot;1&quot; data-w=&quot;99&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;扫码二维码&lt;/p&gt;&lt;p data-mid=&quot;&quot;&gt;获取更多精彩&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-cropselx1=&quot;59&quot; data-cropselx2=&quot;151&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;92&quot; data-ratio=&quot;0.43515625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr73zSwcXZqibGOEOLIv6w47ibvnRAPgtm9Qh4AU3kVpkM03wlO0QZQpcuOLmpdLiarShg496FFr5L5Fw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>91cf63c5de3240b55d8143e9feb94181</guid>
<title>「Typing」开源：3 步打造属于自己的实时文字互动社交 App</title>
<link>https://toutiao.io/k/0bez9rt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了与开发者一起更好地探索互动实时消息的更多可能性，我们&lt;/span&gt;&lt;span&gt;基于声网&lt;/span&gt;&lt;span&gt;云信令/ RTM（Real-time Messaging）SDK&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;开源了一个实时文字互动 Demo——&lt;strong&gt;「Typing」&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;从体验来讲，「Typing」与音视频通话更为类似。对方打字时的速度或每一个停顿都可以被看见，并且实时展示的文字信息与数据也不会有历史留存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;开源地址：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/AgoraIO-Community/typing/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;https://github.com/AgoraIO-Community/typing/releases&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;2.0274725274725274&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/iaJdNvKAPusQk1COeHliceKDho9Zia335VQ9aAcYtt6oEia6ctqfLEuwQRmty2Uk6e6wnH59ArYxV8GQiciaPv0NzJmQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;364&quot;/&gt;&lt;/p&gt;&lt;p line=&quot;3Hza&quot;&gt;&lt;span&gt;「Typing」Demo演示&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;3Hza&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样一种几乎“无时延”、无留存信息的互动方式在很多针对 Z 世代群体（&lt;/span&gt;&lt;span&gt;&lt;em&gt;Generation-Z，一般是指在1995年——2009年出生的一代&lt;/em&gt;&lt;/span&gt;&lt;span&gt;）进行开发的 App 中也受到了广泛的应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p line=&quot;pzjW,fC7p,ctaV,OdbL,C1Ng,iNYs,7Doj&quot;&gt;&lt;span&gt;比如主打 00 后社交新模式的「Honk」就是一款致力于“消除”社交延时的文字对话互动 App，希望通过“真阅后即焚”的 100% 实时、无历史数据留存的私密体验，让使用者体验到几乎无时间差的熟人社交型文字互动。在「Honk」上线的第二天，下载排名就达到了美国 iOS 社交类榜单的第 10 位。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;FpeX,Sf5R&quot;&gt;&lt;span&gt;                  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.42685185185185187&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusRqTr1wsBbzzDLtn2YbgREXcHaPI3P5bZGJvWN4m8MAyB37ZBVnzH7jACHhtqvibMze0Dn53EpY8cw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p line=&quot;pjyN&quot;&gt;&lt;span&gt;Honk丨图片来源：Sensor Tower&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;72Qh&quot;&gt; &lt;/p&gt;&lt;p line=&quot;gfbh&quot;&gt;&lt;span&gt;&lt;span&gt;Z 世代是伴随着互联网和社交媒体长大的一代，相较于其他群体而言，他们对于技术和互联网社交的需求显得更为原始本能——实时互动、安全及熟人社交。&lt;/span&gt;而 「Honk」 之所以能够颠覆传统的文本消息互动体验，&lt;/span&gt;&lt;span&gt;背后依靠的正是实时消息技术&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;gfbh&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6aVaON9Kibf6ibic5RkMCpub0xbVCW5kH5xtxxWHmrrEzGXZpTKu3MSQlRq9VAvzSBTPmQmRJ3XzRrGib6qzGM5Eeg/640?wx_fmt=png&quot; data-w=&quot;11&quot; data-type=&quot;png&quot;/&gt; &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;关于实时消息&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;strong/&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/US10Gcd0tQGYLDQ4mkzRQRu3MPsRBxdl5IQicKIHJk3ySTIJotQ6RTEDdcfGGVBZrMicve2tNujEh6JZCouU984g/640?wx_fmt=png&quot; data-w=&quot;11&quot; data-type=&quot;png&quot;/&gt;&lt;/section&gt;&lt;p line=&quot;TQ04&quot;&gt;&lt;span&gt;通常实时消息可以分为两种&lt;/span&gt;&lt;span&gt;，一种是帮助用户来交流的消息，比如文字消息、点赞、送礼物、发弹幕等。另一种则是信令消息，比&lt;/span&gt;&lt;span&gt;如聊天室中禁言踢人的权限管理、上麦请求等。与微信、Snapchat 等这类即时通讯聊天软件相比，&lt;/span&gt;&lt;span&gt;实时消息传输的重点在于信令、消息传输的低延时和高送达率上&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;Pseg&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;KcMc&quot;&gt;&lt;span&gt;声网&lt;strong&gt;云信令/RTM （Real-time Messaging）SDK &lt;/strong&gt;是一个通用的消息系统，主要是为了解决实时场景下信令的低延迟和高并发问题。云信令/RTM （Real-time Messaging）SDK 的服务器端采用分布式架构，没有一个单点或者中心式的情况，通过多机房多路保活机制，智能优化路径，在其它节点失效时可以自动转移，选择最优节点路径传输。因此，可以有效保证传输的稳定性与可靠性，在性能方面也可以支持高吞吐量和低延时。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;2URF&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;aeoF&quot;&gt;&lt;span&gt;我们尝试基于声网云信令/RTM（Real-time Messaging） SDK 实现了 「Honk」 中的实时文字消息聊天功能，并作为 Demo 开源。&lt;/span&gt;&lt;span&gt;希望可以抛砖引玉，与社区的开发者们一起探索更多基于实时信令和虚拟键盘的互动实时消息的新玩儿法&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;Gy9g&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6aVaON9Kibf6ibic5RkMCpub0xbVCW5kH5xtxxWHmrrEzGXZpTKu3MSQlRq9VAvzSBTPmQmRJ3XzRrGib6qzGM5Eeg/640?wx_fmt=png&quot; data-w=&quot;11&quot; data-type=&quot;png&quot;/&gt; &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;「Typing」开源&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;strong/&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/US10Gcd0tQGYLDQ4mkzRQRu3MPsRBxdl5IQicKIHJk3ySTIJotQ6RTEDdcfGGVBZrMicve2tNujEh6JZCouU984g/640?wx_fmt=png&quot; data-w=&quot;11&quot; data-type=&quot;png&quot;/&gt;&lt;/section&gt;&lt;p line=&quot;Pdr2&quot;&gt;&lt;span&gt;目前的「Typing」Demo 中，我们提供了类似 「Honk」 的实时文字聊天，以及点击对方聊天框发送震动的功能，开发者只需要简单的几步就可以实现。以 iOS 版为例：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;h5&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;▎&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;安装&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;span&gt;更改目录为&lt;/span&gt;&lt;code&gt;iOS&lt;/code&gt;&lt;span&gt;文件夹，运行以下命令安装项目依赖项，&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;pod&lt;/span&gt; install&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;输入验证，生成正确的&lt;/span&gt;&lt;code&gt;xcworkspace&lt;/code&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;▎&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;获取 App ID&lt;/strong&gt;&lt;/span&gt;&lt;/h5&gt;&lt;section&gt;&lt;span&gt;要构建并运行示例应用程序，需要获取一个应用 ID :&lt;br/&gt;👉1、在agora.io创建一个开发者帐户。完成注册过程后，会重新回到仪表板。&lt;br/&gt;👉2、在左侧的仪表板树中导航到项目 &amp;gt; 项目列表。&lt;br/&gt;👉3、保存仪表板上的 App ID 以备以后使用。&lt;br/&gt;👉4、生成一个临时访问 Token (24 小时内有效) 从仪表板页面给定的通道名称，保存以后使用。（访问该网址可获取临时的 RTM Token：https://webdemo.agora.io/token-builder/）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;注：对于安全性要求更高的场景，如果想要部署自己的RTM Token服务器，请参阅文档(https://docs.agora.io/cn/Real-time-Messaging/token_server_rtm)&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;接下来，打开&lt;/span&gt;&lt;code&gt;&lt;span&gt;Typing.xcworkspace&lt;/span&gt;&lt;/code&gt; &lt;span&gt;并编辑&lt;/span&gt;&lt;code&gt;&lt;span&gt;KeyCenter.swift&lt;/span&gt;&lt;/code&gt; &lt;span&gt;文件。在&lt;/span&gt;&lt;code&gt;&lt;span&gt;KeyCenter&lt;/span&gt;&lt;/code&gt;&lt;span&gt;中更新&lt;/span&gt;&lt;code&gt;&lt;span&gt;&amp;lt;#Your App Id#&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，用仪表盘生成的 Token 更改&lt;/span&gt;&lt;code&gt;&lt;span&gt;&amp;lt;#Temp Access Token#&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;注：如果建立的项目没有打开&lt;/span&gt;&lt;/em&gt;&lt;em&gt;&lt;code&gt;&lt;span&gt;security token&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，&lt;span&gt;可以将 token 变量保留为&lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;nil&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;Swift&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;    &lt;span&gt;struct&lt;/span&gt; KeyCenter {&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;let&lt;/span&gt; AppId: String = &amp;lt;&lt;span&gt;#Your App Id#&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;        &lt;span&gt;// assign token to nil if you have not enabled app certificate&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; Token: String? = &amp;lt;&lt;span&gt;#Temp Access Token#&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p line=&quot;8f8e&quot;&gt; &lt;span/&gt;&lt;/p&gt;&lt;p line=&quot;bspr&quot;&gt;&lt;span&gt;目前，该 Demo 支持 iOS 与 Android 平台。对于 Android 平台的小伙伴，可以选择下载打包好的 apk 文件，直接体验「Typing」。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;bspr&quot;&gt;&lt;/p&gt;&lt;p line=&quot;bspr&quot;&gt;&lt;span&gt;点击&lt;/span&gt;&lt;strong&gt;&lt;span&gt;【阅读原文】&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;获取 apk 文件下载链接&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;318q&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p line=&quot;318q&quot;&gt;&lt;/p&gt;&lt;p line=&quot;5e3w&quot;&gt;&lt;span&gt;我们相信，关于声网&lt;span&gt;云信令/RTM&lt;/span&gt;&lt;span&gt;（Real-time Messaging）&lt;/span&gt;&lt;span&gt;SD&lt;/span&gt;&lt;span&gt;K&lt;/span&gt; 的应用场景和使用方式在不断涌现&lt;/span&gt;&lt;span&gt;的新需求下，还有很大的待挖掘潜力。&lt;span&gt;例如，或许你可以考虑把手机键盘&lt;/span&gt;&lt;span&gt;变成一个简易的虚拟钢琴键盘，为对方弹奏一首简单的小乐曲？&lt;/span&gt;开发者可以通过「Typing」，快速了解声网云信令/RTM（Real-time Messaging） SDK的基本用法，并且继续探索除了文字实时交流之外的，基于各种类型虚拟键盘所进行的 1 对 1 实时互动。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p line=&quot;rnJ2&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p line=&quot;UoX7&quot;&gt;&lt;span&gt;如果你对「Typing」感兴趣的话，可以进入我们的讨论群与社区的开发者们进行交流，也可以在 GitHub 仓库提交 Issue 留下你的问题、收藏/Fork「Typing」项目，或是通过 Pull Request 提交你的创意与成果。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;TyfQ&quot;&gt; &lt;/p&gt;&lt;p line=&quot;TyfQ&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;扫描下方二维码&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;TyfQ&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;加入「Typing」讨论群&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;g11y&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9982285208148804&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusQk1COeHliceKDho9Zia335VQ4SWbiabP64jYyMDInCeV7fE868ibicSNwZr7GOTFNRAV4jC4L6998GicNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1129&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;44&quot; data-backw=&quot;546&quot; data-ratio=&quot;0.08152173913043478&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JfPHISqGiaLL7BLQicibx5HkEpdia9NJRexOyL8sGcc1SU7mrzqRweBTznRv8sNR0NFhv1ibxjfIuZTEGq0AzHfSaCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2208&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;js_darkmode__192&quot;&gt;&lt;span&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;js_darkmode__192&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NjU4NzE0Mg==&amp;amp;mid=2247484416&amp;amp;idx=2&amp;amp;sn=d6893a4dbdb37d6ab0324631c95af969&amp;amp;chksm=fbc385e9ccb40cff9e6f9611bb8fd483a1195d4d2b2d6d9feb4e5c493bcd8ea4475354739221&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;直播回顾｜RTM 助力信令与消息全球实时互通&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;js_darkmode__192&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NjU4NzE0Mg==&amp;amp;mid=2247484388&amp;amp;idx=1&amp;amp;sn=2709984f65787608aa32b934232d5a7a&amp;amp;chksm=fbc3820dccb40b1bc4367d5b2b1ad95649f8f935198ac5067d58a5f50a94391ea967a526c326&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Agora 教程 | 如何在 Unity 游戏中用 RTM SDK 实现消息聊天&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;js_darkmode__192&quot;&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NjU4NzE0Mg==&amp;amp;mid=2247484449&amp;amp;idx=1&amp;amp;sn=886008c3b764d212f40ced20ede743a6&amp;amp;chksm=fbc385c8ccb40cde9195b49219f4240e7cecdc2e9d57f06ba9a68b5684ee54e02b114f7c6d02&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Agora 开源 | MoonLight —— 助你实现更好的iOS/Mac 自动化性能测试&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;p line=&quot;init&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.08152173913043478&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JfPHISqGiaLL7BLQicibx5HkEpdia9NJRexOyL8sGcc1SU7mrzqRweBTznRv8sNR0NFhv1ibxjfIuZTEGq0AzHfSaCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2208&quot;/&gt;&lt;/p&gt;&lt;p line=&quot;ZH1R&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaJdNvKAPusQJtwiak2rx7tgB1YnGHSvMGZYhMqVEtoSOQxrE46BZpMchvWicxafXomVSe1wl37ibdIeYTlM77mbjw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.3037037037037037&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>