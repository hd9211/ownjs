<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>9273932874fc786e9ac675d3ab0f6936</guid>
<title>浅谈如何搭建知识体系 | 码农周刊第 319 期</title>
<link>https://toutiao.io/k/dufazik</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;浅谈如何搭建知识体系 | 码农周刊第 319 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第319期（2020-09-23）&lt;/h2&gt;
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=319&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3190&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_316.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=319&amp;amp;aid=19803&amp;amp;url=https%3A%2F%2Fwww.sheca.com%2Fassets%2Fwwx%2Fpage1.html%3Fsite%3Dkaifazhe02&quot; target=&quot;_blank&quot;&gt;SHECA 提供 SSL 证书一站式服务，为你的网络安全保驾护航，上海 CA 权威认证&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=319&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;HDFS + Clickhouse + Spark&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;致力于提供一套简单方便、专业可靠、无限可能的 H5 落地页最佳实践。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;9NFL 是京东自研的联邦学习平台。整个平台的内核基于 TensorFlow，并根据业务进行了性能优化，调度则基于 k8s。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;ChatUI 是由达摩院阿里小蜜孵化的对话式界面组件，目前支持阿里经济体 80 多个事业部，数千个 Chatbot，承载着达摩院前沿技术，专注于智能对话领域的设计和技术研发体系，应用至消费者可体验的对话式界面。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;适合新手&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;模型性能杀器解读&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;有用&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;详细介绍&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;深入讲解&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;第二弹&lt;/p&gt;
        
        &lt;p&gt;customize personal network&lt;/p&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://github.com/aweiu/scroll-switch&quot; target=&quot;_blank&quot;&gt;GitHub 地址&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;两种不错的思路&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://golang.design/history/&quot; target=&quot;_blank&quot;&gt;文档地址&lt;/a&gt;&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;一枚有趣的程序员&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 436138 即可&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;致力于为企业提供性能优化领域的全方位解决方案&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 423497 即可&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;分享一些信息安全相关的文章&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 393298 即可&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;编程、成长、正能量！&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 381811 即可&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;分享Go语言相关内容&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 133906 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=319&amp;amp;aid=19892&amp;amp;url=http%3A%2F%2Fstore.dangdang.com%2Fgys_04001_3tk3&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/book_319.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;擦亮慧眼&lt;/p&gt;
        
        &lt;p&gt;个人经历&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>015dd179ed5d19618d9f6fbc2569ddc3</guid>
<title>Spring Boot 启动原理</title>
<link>https://toutiao.io/k/itvkvui</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1&amp;gt; 大家都知道SpringBoot是通过main函数启动的，这里面跟踪代码到处都没有找到while(true)，为什么启动后可以一直跑？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2&amp;gt; SpringBoot默认使用tomcat作为web容器。大家也可以通过在pom文件中exclusion掉tomcat，denpendency jetty 的方法来使用jetty。那SpringBoot是怎么做到在不同web容器之间切换的呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2&amp;gt; 传统的web容器比如jetty本质上是直接通过java start.jar 来启动，之后来加载spring上下文的，SpringBoot通过main函数是怎么来启动web容器的呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本文就这三个问题展开论述。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;问题1分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;问题1很简单，启动后一直跑是因为启动了线程池。原理就是有非deamon的线程在跑。Java虚拟机规范定义要等所有用户线程都运行完才会退出。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以这个原理就和下面启动线程池一样&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7517875383043923&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicZABgRrbBAG33MvWnr6W1icyeBluAHR6lFIGx0XRCZRSN9qZHnjYnyWXHHmEqJQM44G4tnaUX5kJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;979&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;程序员修炼之道教我们：不要假定，要证明。虽然jetty使用线程池是常识，我们也来跟踪下源码，看看线程池是在哪里初始化的：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;org.springframework.boot.web.embedded.jetty.JettyServletWebServerFactory类里，创建Server的使用使用线程池作为初始化参数。然后创建了socket连接来监听端口。（对于socket连接有之前没接触过的，可以自己查一下。建议动手实践。&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485101&amp;amp;idx=1&amp;amp;sn=c95f1a3fa03af199c78d59bb29ea411c&amp;amp;chksm=fafdec03cd8a6515f61cf42d3ce94ee7bc465f445cb61d4644d259c55a661cce4ab1a6dc4738&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《Java异常处理总结》&lt;/a&gt;这篇文章里有不错的简单小例子可以实操下。）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5701219512195121&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicZABgRrbBAG33MvWnr6W1icUaFAlvSC5f8P9NuvBj7ajGvHDMvdibH7sC16YIjOoCzP2GvkqlGecSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;984&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;到这里，大家应该都明白了为什么启动后一直不停。但是又有疑问了：JettyServletWebServerFactory是个什么东东？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;问题2分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;关于问题2，我们写个最简单的类来debug一下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.17950963222416813&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicZABgRrbBAG33MvWnr6W1icQzRDtiaYapYwGiaPzTLeq7cCbVIqxmfWMwdPb2wCUTJEFYWWJV0Yc0vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1142&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;进入SpringAppication.run的源码可以看到，里面创建了一个context，默认是AnnotationConfigServletWebServerApplicationContext。一初始化，在Bean定义里就加载了spring开天辟地的5个Bean。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7903494176372712&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicZABgRrbBAG33MvWnr6W1icfmBmUbAmFZyZrV8JVjuQA5z8BsuaDOIAg6pVgJ11Fk3020D6icxvVtA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1202&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;继续向下执行走到AbstractApplicationContext的refresh方法，执行到onRefresh时，你进入方法里发现实际上执行的是&lt;/p&gt;&lt;p&gt;ServletWebServerApplicationContext的onFresh&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6649746192893401&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicZABgRrbBAG33MvWnr6W1icz6Zic8dlFIeYHLPPNI8f8STg0mXPZn9iaXSx768bbLdGmHEP4EHE40XA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;985&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里面实际只做了一件事：创建web服务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.31267345050878814&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicZABgRrbBAG33MvWnr6W1icNH46T5npWwQhQJqSPDg4tib60Q4yB24LhetuDxfdngLdQia3m6WgdRPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1081&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;进入这个方法，debug到getWebServerFactory&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.504225352112676&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicZABgRrbBAG33MvWnr6W1icqn8LnMmFPCYFJGoAYm3cz1KokTpXabOWVKYzoaTLRM6vBia9zK5RJhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1065&quot;/&gt;&lt;/p&gt;&lt;p&gt;来看一下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4768480909829407&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicZABgRrbBAG33MvWnr6W1icibjRmZN3tCG5Fib5lVUH9xbGtVE19evG0R58z6Jolib9mMhuYicpJpHqNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1231&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;获取的正式JettyServletWebServerFactory。为啥不是TomcatServlet呢？ServletWebServerFactoryAutoConfiguration的源码很好的说明了这个问题。源码的大意是当tomcat依赖存在就用tomcat，不然就按顺序找jetty存不存在，不存在再找Undertow存不存在。找到了就返回这个bean作为Servlet的工厂类。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;@Configuration&lt;br/&gt;@AutoConfigureOrder(-&lt;span&gt;2147483648&lt;/span&gt;)&lt;br/&gt;@ConditionalOnClass({ServletRequest.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;@ConditionalOnWebApplication(&lt;br/&gt;    type = Type.SERVLET&lt;br/&gt;)&lt;br/&gt;@EnableConfigurationProperties({ServerProperties.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;@Import({ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.&lt;span&gt;class, &lt;/span&gt;EmbeddedTomcat.&lt;span&gt;class, &lt;/span&gt;EmbeddedJetty.&lt;span&gt;class, &lt;/span&gt;EmbeddedUndertow.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;&lt;span&gt;public class &lt;/span&gt;ServletWebServerFactoryAutoConfiguration {&lt;br/&gt;    &lt;span&gt;public &lt;/span&gt;ServletWebServerFactoryAutoConfiguration() {&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @Bean&lt;br/&gt;    &lt;span&gt;public &lt;/span&gt;ServletWebServerFactoryCustomizer servletWebServerFactoryCustomizer(ServerProperties serverProperties) {&lt;br/&gt;        &lt;span&gt;return new &lt;/span&gt;ServletWebServerFactoryCustomizer(serverProperties)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;    @Bean&lt;br/&gt;    @ConditionalOnClass(&lt;br/&gt;        name = {&lt;span&gt;&quot;org.apache.catalina.startup.Tomcat&quot;&lt;/span&gt;}&lt;br/&gt;    )&lt;br/&gt;    &lt;span&gt;public &lt;/span&gt;TomcatServletWebServerFactoryCustomizer tomcatServletWebServerFactoryCustomizer(ServerProperties serverProperties) {&lt;br/&gt;        &lt;span&gt;return new &lt;/span&gt;TomcatServletWebServerFactoryCustomizer(serverProperties)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public static class &lt;/span&gt;BeanPostProcessorsRegistrar &lt;span&gt;implements &lt;/span&gt;ImportBeanDefinitionRegistrar&lt;span&gt;, &lt;/span&gt;BeanFactoryAware {&lt;br/&gt;        &lt;span&gt;private &lt;/span&gt;ConfigurableListableBeanFactory beanFactory&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        public &lt;/span&gt;BeanPostProcessorsRegistrar() {&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;public void &lt;/span&gt;setBeanFactory(BeanFactory beanFactory) &lt;span&gt;throws &lt;/span&gt;BeansException {&lt;br/&gt;            &lt;span&gt;if &lt;/span&gt;(beanFactory &lt;span&gt;instanceof &lt;/span&gt;ConfigurableListableBeanFactory) {&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.beanFactory = (ConfigurableListableBeanFactory)beanFactory&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;public void &lt;/span&gt;registerBeanDefinitions(AnnotationMetadata importingClassMetadata&lt;span&gt;, &lt;/span&gt;BeanDefinitionRegistry registry) {&lt;br/&gt;            &lt;span&gt;if &lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.beanFactory != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.registerSyntheticBeanIfMissing(registry&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;webServerFactoryCustomizerBeanPostProcessor&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;WebServerFactoryCustomizerBeanPostProcessor.&lt;span&gt;class&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;                this&lt;/span&gt;.registerSyntheticBeanIfMissing(registry&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;errorPageRegistrarBeanPostProcessor&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;ErrorPageRegistrarBeanPostProcessor.&lt;span&gt;class&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;}&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;private void &lt;/span&gt;registerSyntheticBeanIfMissing(BeanDefinitionRegistry registry&lt;span&gt;, &lt;/span&gt;String name&lt;span&gt;, &lt;/span&gt;Class&amp;lt;?&amp;gt; beanClass) {&lt;br/&gt;            &lt;span&gt;if &lt;/span&gt;(ObjectUtils.isEmpty(&lt;span&gt;this&lt;/span&gt;.beanFactory.getBeanNamesForType(beanClass&lt;span&gt;, true, false&lt;/span&gt;))) {&lt;br/&gt;                RootBeanDefinition beanDefinition = &lt;span&gt;new &lt;/span&gt;RootBeanDefinition(beanClass)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;                &lt;/span&gt;beanDefinition.setSynthetic(&lt;span&gt;true&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;                &lt;/span&gt;registry.registerBeanDefinition(name&lt;span&gt;, &lt;/span&gt;beanDefinition)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;至此第二个问题也真相大白。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;问题3分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第三个问题是传统的web容器比如jetty本质上是直接通过java start.jar 来启动，之后来加载spring上下文的，SpringBoot通过main函数是怎么来启动web容器。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个问题在前面问题分析过程中也给了很多线索。我们来回顾下：SpringApplication.run里会创建Spring的应用上下文，默认是AnnotationConfigServletWebServerApplicationContext。首先会加载Spring开天辟地的5个Bean。然后它初始化各种Bean工厂。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;SpringBoot在ServletWebServerApplicationContext中重载了onRefresh方法，除了以前Spring默认的onRefresh方法外还增加了createWebServer方法，在这个方法中对Web容器进行了初始化工作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;span&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;version&amp;gt;&lt;/span&gt;${spring.boot.version}&lt;span&gt;&amp;lt;/version&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;exclusions&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &amp;lt;exclusion&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-logging&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &amp;lt;/exclusion&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &amp;lt;exclusion&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-tomcat&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &amp;lt;/exclusion&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &amp;lt;exclusion&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &amp;lt;groupId&amp;gt;&lt;/span&gt;com.fasterxml.jackson.core&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &amp;lt;artifactId&amp;gt;&lt;/span&gt;jackson-databind&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &amp;lt;/exclusion&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;/exclusions&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-jetty&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;version&amp;gt;&lt;/span&gt;${spring.boot.version}&lt;span&gt;&amp;lt;/version&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;exclusions&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &amp;lt;exclusion&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &amp;lt;groupId&amp;gt;&lt;/span&gt;org.eclipse.jetty.aggregate&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &amp;lt;artifactId&amp;gt;&lt;/span&gt;jetty-all&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &amp;lt;/exclusion&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;/exclusions&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因为选择servlet容器是类似于使用基于条件的注解方式。因为当exclusion掉tomcat后，只有jetty满足条件，所以会加载JettyServletWebServerFactory。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过getWebServer方法会new一个WebServer对象，new对象的方法会调用initialize方法，在这个方法中会对容器进行初始化并启动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而容器启动的基本原理就是创建个线程池和网络套接字。用线程去处理套接字读写的内容。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;文本用带有少许说明的三个问题开场展开论述，实际是使用了麦肯锡大法中的SCQA架构。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;SCQA架构是金字塔模型里面突出的一个论述方法，即“情境（Situation）、冲突（Complication）、问题（Question）、答案（Answer）”。可以帮助我们在陈述事实时条理更为清晰、有效。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;SCQA其实只是麦肯锡做了总结。这个方法李清照都在用：&lt;/p&gt;&lt;p&gt;昨夜雨疏风骤，浓睡不消残酒 （情境）&lt;/p&gt;&lt;p&gt;试问卷帘人，渠道海棠依旧（冲突）&lt;/p&gt;&lt;p&gt;知否，知否（问题）&lt;/p&gt;&lt;p&gt;应是绿肥红瘦（答案）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;文章正文看似一步步回答问题，实际上在讲述怎样去看spring源码，了解spring原理的一个过程。即：带着问题去看，debug跟踪源码验证 的方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7a53ecb04a542e322e1c2909f157e613</guid>
<title>漏桶、令牌桶限流算法的 Go 语言实现</title>
<link>https://toutiao.io/k/ur64xby</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;限流&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;限流又称为流量控制（流控），通常是指限制到达系统的并发请求数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们生活中也会经常遇到限流的场景，比如：某景区限制每日进入景区的游客数量为 8 万人；沙河地铁站早高峰通过站外排队逐一放行的方式限制同一时间进入车站的旅客数量等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;限流虽然会影响部分用户的使用体验，但是却能在一定程度上保障系统的稳定性，不至于崩溃（大家都没了用户体验）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而互联网上类似需要限流的业务场景也有很多，比如电商系统的秒杀、微博上突发热点新闻、双十一购物节、12306 抢票等等。这些场景下的用户请求量通常会激增，远远超过平时正常的请求量，此时如果不加任何限制很容易就会将后端服务打垮，影响服务的稳定性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，一些厂商公开的 API 服务通常也会限制用户的请求次数，比如百度地图开放平台等会根据用户的付费情况来限制用户的请求数等。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.47890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iavQtPTYuxWXAqzXeib7Axngdby4TPzn2ibV2x23WxiaDP0yLxanjWm1zWicSG7uibHogZq712GoUtib0D8IkRRmkOg3w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;常用的限流策略&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;漏桶&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;漏桶法限流很好理解，假设我们有一个水桶按固定的速率向下方滴落一滴水，无论有多少请求，请求的速率有多大，都按照固定的速率流出，对应到系统中就是按照固定的速率处理请求。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.88828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iavQtPTYuxWXAqzXeib7Axngdby4TPzn2ibicHJYjLg9JtMndbibvFwgnjKVLzmGMRBSn50AAMiasGEl9FP6jTrHOmQw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;漏桶算法原理&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;漏桶法的关键点在于漏桶始终按照固定的速率运行，但是它并不能很好的处理有大量突发请求的场景，毕竟在某些场景下我们可能需要提高系统的处理效率，而不是一味的按照固定速率处理请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于漏桶的实现，uber 团队有一个开源的https://github.com/uber-go/ratelimit实现。使用方法也比较简单，&lt;code&gt;Take()&lt;/code&gt; 方法会返回漏桶下一次滴水的时间。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&quot;go.uber.org/ratelimit&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    rl := ratelimit.New(&lt;span&gt;100&lt;/span&gt;) &lt;span&gt;// per second&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    prev := time.Now()&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt;        now := rl.Take()&lt;br/&gt;        fmt.Println(i, now.Sub(prev))&lt;br/&gt;        prev = now&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Output:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 0 0&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 1 10ms&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 2 10ms&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 3 10ms&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 4 10ms&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 5 10ms&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 6 10ms&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 7 10ms&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 8 10ms&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 9 10ms&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的源码实现也比较简单，这里大致说一下关键的地方，有兴趣的同学可以自己去看一下完整的源码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;限制器是一个接口类型，其要求实现一个&lt;code&gt;Take()&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Limiter &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// Take方法应该阻塞已确保满足 RPS&lt;/span&gt;&lt;br/&gt; Take() time.Time&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现限制器接口的结构体定义如下，这里可以重点留意下&lt;code&gt;maxSlack&lt;/code&gt;字段，它在后面的&lt;code&gt;Take()&lt;/code&gt;方法中的处理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; limiter &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; sync.Mutex                &lt;span&gt;// 锁&lt;/span&gt;&lt;br/&gt; last       time.Time      &lt;span&gt;// 上一次的时刻&lt;/span&gt;&lt;br/&gt; sleepFor   time.Duration  &lt;span&gt;// 需要等待的时间&lt;/span&gt;&lt;br/&gt; perRequest time.Duration  &lt;span&gt;// 每次的时间间隔&lt;/span&gt;&lt;br/&gt; maxSlack   time.Duration  &lt;span&gt;// 最大的富余量&lt;/span&gt;&lt;br/&gt; clock      Clock          &lt;span&gt;// 时钟&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;limiter&lt;/code&gt;结构体实现&lt;code&gt;Limiter&lt;/code&gt;接口的&lt;code&gt;Take()&lt;/code&gt;方法内容如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Take 会阻塞确保两次请求之间的时间走完&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Take 调用平均数为 time.Second/rate.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(t *limiter)&lt;/span&gt; &lt;span&gt;Take&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;.&lt;span&gt;Time&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; t.Lock()&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; t.Unlock()&lt;br/&gt;&lt;br/&gt; now := t.clock.Now()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 如果是第一次请求就直接放行&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; t.last.IsZero() {&lt;br/&gt;  t.last = now&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; t.last&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// sleepFor 根据 perRequest 和上一次请求的时刻计算应该sleep的时间&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// 由于每次请求间隔的时间可能会超过perRequest, 所以这个数字可能为负数，并在多个请求之间累加&lt;/span&gt;&lt;br/&gt; t.sleepFor += t.perRequest - now.Sub(t.last)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 我们不应该让sleepFor负的太多，因为这意味着一个服务在短时间内慢了很多随后会得到更高的RPS。&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; t.sleepFor &amp;lt; t.maxSlack {&lt;br/&gt;  t.sleepFor = t.maxSlack&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 如果 sleepFor 是正值那么就 sleep&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; t.sleepFor &amp;gt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  t.clock.Sleep(t.sleepFor)&lt;br/&gt;  t.last = now.Add(t.sleepFor)&lt;br/&gt;  t.sleepFor = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  t.last = now&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; t.last&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码根据记录每次请求的间隔时间和上一次请求的时刻来计算当次请求需要阻塞的时间——&lt;code&gt;sleepFor&lt;/code&gt;，这里需要留意的是&lt;code&gt;sleepFor&lt;/code&gt;的值可能为负，在经过间隔时间长的两次访问之后会导致随后大量的请求被放行，所以代码中针对这个场景有专门的优化处理。&lt;code&gt;maxSlack&lt;/code&gt;默认值可以通过创建限制器的&lt;code&gt;New&lt;/code&gt;函数看到。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;New&lt;/span&gt;&lt;span&gt;(rate &lt;span&gt;int&lt;/span&gt;, opts ...Option)&lt;/span&gt; &lt;span&gt;Limiter&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; l := &amp;amp;limiter{&lt;br/&gt;  perRequest: time.Second / time.Duration(rate),&lt;br/&gt;  maxSlack:   &lt;span&gt;-10&lt;/span&gt; * time.Second / time.Duration(rate),&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, opt := &lt;span&gt;range&lt;/span&gt; opts {&lt;br/&gt;  opt(l)&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; l.clock == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  l.clock = clock.New()&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; l&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;令牌桶&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;令牌桶其实和漏桶的原理类似，令牌桶按固定的速率往桶里放入令牌，并且只要能从桶里取出令牌就能通过，令牌桶支持突发流量的快速处理。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.88828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iavQtPTYuxWXAqzXeib7Axngdby4TPzn2ibl4oJRhUGtuA8lC8nlRPWItQPAH0h6CFhrFgRFNUqcOgBJ2VGEFqTlw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;令牌桶原理&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于从桶里取不到令牌的场景，我们可以选择等待也可以直接拒绝并返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于令牌桶的 Go 语言实现，大家可以参照https://github.com/juju/ratelimit。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个库支持多种令牌桶模式，并且使用起来也比较简单。 &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建令牌桶的方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 创建指定填充速率和容量大小的令牌桶&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewBucket&lt;/span&gt;&lt;span&gt;(fillInterval time.Duration, capacity &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt; *&lt;span&gt;Bucket&lt;/span&gt;&lt;br/&gt;// 创建指定填充速率、容量大小和每次填充的令牌数的令牌桶&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewBucketWithQuantum&lt;/span&gt;&lt;span&gt;(fillInterval time.Duration, capacity, quantum &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt; *&lt;span&gt;Bucket&lt;/span&gt;&lt;br/&gt;// 创建填充速度为指定速率和容量大小的令牌桶&lt;br/&gt;// &lt;span&gt;NewBucketWithRate&lt;/span&gt;&lt;span&gt;(0.1, 200)&lt;/span&gt; 表示每秒填充20个令牌&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewBucketWithRate&lt;/span&gt;&lt;span&gt;(rate &lt;span&gt;float64&lt;/span&gt;, capacity &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt; *&lt;span&gt;Bucket&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;取出令牌的方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 非阻塞的取token&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(tb *Bucket)&lt;/span&gt; &lt;span&gt;Take&lt;/span&gt;&lt;span&gt;(count &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;.&lt;span&gt;Duration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(tb *Bucket)&lt;/span&gt; &lt;span&gt;TakeAvailable&lt;/span&gt;&lt;span&gt;(count &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt;&lt;br/&gt;// 最多等&lt;span&gt;maxWait&lt;/span&gt;时间取&lt;span&gt;token&lt;/span&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(tb *Bucket)&lt;/span&gt; &lt;span&gt;TakeMaxDuration&lt;/span&gt;&lt;span&gt;(count &lt;span&gt;int64&lt;/span&gt;, maxWait time.Duration)&lt;/span&gt; &lt;span&gt;(time.Duration, &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;// 阻塞的取&lt;span&gt;token&lt;/span&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(tb *Bucket)&lt;/span&gt; &lt;span&gt;Wait&lt;/span&gt;&lt;span&gt;(count &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(tb *Bucket)&lt;/span&gt; &lt;span&gt;WaitMaxDuration&lt;/span&gt;&lt;span&gt;(count &lt;span&gt;int64&lt;/span&gt;, maxWait time.Duration)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽说是令牌桶，但是我们没有必要真的去生成令牌放到桶里，我们只需要每次来取令牌的时候计算一下，当前是否有足够的令牌可以使用就可以了，具体的计算公式如下。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;当前令牌数 = 上一次剩余的令牌数 + (本次取令牌的时刻-上一次取令牌的时刻)/放置令牌的时间间隔 * 每次放置的令牌数&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;github.com/juju/ratelimit这个库中关于令牌数计算的具体实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(tb *Bucket)&lt;/span&gt; &lt;span&gt;adjustavailableTokens&lt;/span&gt;&lt;span&gt;(tick &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; tb.availableTokens &amp;gt;= tb.capacity {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; tb.availableTokens += (tick - tb.latestTick) * tb.quantum&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; tb.availableTokens &amp;gt; tb.capacity {&lt;br/&gt;  tb.availableTokens = tb.capacity&lt;br/&gt; }&lt;br/&gt; tb.latestTick = tick&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取令牌的&lt;code&gt;TakeAvailable&lt;/code&gt;函数关键部分的源码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(tb *Bucket)&lt;/span&gt; &lt;span&gt;takeAvailable&lt;/span&gt;&lt;span&gt;(now time.Time, count &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; count &amp;lt;= &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; tb.adjustavailableTokens(tb.currentTick(now))&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; tb.availableTokens &amp;lt;= &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; count &amp;gt; tb.availableTokens {&lt;br/&gt;  count = tb.availableTokens&lt;br/&gt; }&lt;br/&gt; tb.availableTokens -= count&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; count&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家从代码中也可以看到其实令牌桶的实现并没有很复杂。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;gin 框架中使用限流中间件&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 gin 框架构建的项目中，我们可以将限流组件定义成中间件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里使用令牌桶作为限流策略，编写一个限流中间件如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;RateLimitMiddleware&lt;/span&gt;&lt;span&gt;(fillInterval time.Duration, &lt;span&gt;cap&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(c *gin.Context)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; bucket := ratelimit.NewBucket(fillInterval, &lt;span&gt;cap&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(c *gin.Context)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 如果取不到令牌就返回响应&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; bucket.TakeAvailable(&lt;span&gt;1&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   c.String(http.StatusOK, &lt;span&gt;&quot;rate limit...&quot;&lt;/span&gt;)&lt;br/&gt;   c.Abort()&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  c.Next()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于该限流中间件的注册位置，我们可以按照不同的限流策略将其添加到不同的地方，例如：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果要对全站限流就可以添加成全局的中间件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果是某一组路由需要限流，那么就只需添加到对应的路由组即可。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7994981fa4c5839f4282122de6b17fe8</guid>
<title>如何学习 FPGA</title>
<link>https://toutiao.io/k/3tro911</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content&quot;&gt;&amp;#13;

&lt;p&gt;首先给大家推荐一下我老师大神的人工智能教学网站。教学不仅零基础，通俗易懂，而且非常风趣幽默，还时不时有内涵黄段子！&lt;a href=&quot;https://www.captainbed.net/lhyd&quot;&gt;点这里可以跳转到网站&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;PS：笔者强烈建议诸位注册一个EETOP的账号，每天签到或者发贴、回贴就有积分了，里面的资源非常丰富，各种软件、资料都能找到。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;一、入门首先要掌握HDL（HDL=verilog+VHDL）。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;       第一句话是：还没学数电的先学&lt;a href=&quot;http://bbs.eetop.cn/thread-157244-1-1.html&quot;&gt;&lt;strong&gt;数电&lt;/strong&gt;&lt;/a&gt;。然后你可以选择verilog或者VHDL，有C语言基础的，建议选择VHDL。因为verilog太像C了，很容易混淆，最后你会发现，你花了大量时间去区分这两种语言，而不是在学习如何使用它。当然，你思维能转得过来，也可以选verilog，毕竟在国内verilog用得比较多。&lt;/p&gt;



&lt;p&gt;       接下来，首先找本实例抄代码。抄代码的意义在于熟悉语法规则和编译器（这里的编译器是硅编译器又叫综合器，常用的编译器有：&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/46275247&quot;&gt;&lt;strong&gt;Quartus&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;http://bbs.eetop.cn/thread-451518-1-1.html&quot;&gt;&lt;strong&gt;ISE&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;http://bbs.eetop.cn/thread-598057-1-1.html&quot;&gt;&lt;strong&gt;Vivado&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;http://bbs.eetop.cn/thread-558981-1-1.html&quot;&gt;&lt;strong&gt;Design Compiler&lt;/strong&gt;&lt;/a&gt; 、&lt;a href=&quot;http://www.synopsys.com/Tools/Implementation/FPGAImplementation/Pages/default.aspx&quot;&gt;&lt;strong&gt;Synopsys&lt;/strong&gt;&lt;/a&gt;的&lt;a href=&quot;http://bbs.eetop.cn/thread-412008-1-1.html&quot;&gt;&lt;strong&gt;VCS&lt;/strong&gt;&lt;/a&gt;、iverilog、&lt;strong&gt;&lt;a href=&quot;http://www.latticesemi.com/Products.aspx&quot;&gt;Lattice&lt;/a&gt;&lt;/strong&gt;的&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/51379364&quot;&gt;&lt;strong&gt;Diamond&lt;/strong&gt;&lt;/a&gt;、Microsemi/Actel的&lt;a href=&quot;https://www.microsemi.com/products/fpga-soc/design-support/fpga-soc-design&quot;&gt;&lt;strong&gt;Libero&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;http://bbs.eetop.cn/thread-578576-1-1.html&quot;&gt;&lt;strong&gt;Synplify pro&lt;/strong&gt;&lt;/a&gt;），然后再模仿着写，最后不看书也能写出来。编译完代码，就打开RTL图，看一下综合出来是什么样的电路&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;       HDL是硬件描述语言，突出硬件这一特点，所以要&lt;strong&gt;用数电的思维去思考HDL，而不是用C语言或者其它高级语言&lt;/strong&gt;，如果不能理解这句话的，可以看《&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/46730523&quot;&gt;&lt;strong&gt;什么是硬件以及什么是软件&lt;/strong&gt;&lt;/a&gt;》。在这一阶段，推荐的教材是&lt;strong&gt;《&lt;a href=&quot;http://product.dangdang.com/24036476.html&quot;&gt;Verilog传奇&lt;/a&gt;》、《&lt;a href=&quot;http://bbs.eetop.cn/thread-281674-1-1.html&quot;&gt;Verilog HDL高级数字设计&lt;/a&gt;》&lt;/strong&gt;或者是《&lt;a href=&quot;http://search.dangdang.com/?key=%20%D3%C3%D3%DA%C2%DF%BC%AD%D7%DB%BA%CF%B5%C4VHDL&amp;amp;act=input&quot;&gt;&lt;strong&gt;用于逻辑综合的VHDL&lt;/strong&gt;&lt;/a&gt;》。不看书也能写出个三段式状态机就可以进入下一阶段了。&lt;/p&gt;



&lt;p&gt;       此外，你手上必须准备Verilog或者VHDL的官方文档，《&lt;a href=&quot;http://bbs.eetop.cn/thread-556080-1-1.html&quot;&gt;&lt;strong&gt;verilog_IEEE官方标准手册-2005_IEEE_P1364&lt;/strong&gt;&lt;/a&gt;》、《&lt;a href=&quot;http://bbs.eetop.cn/thread-436703-1-1.html&quot;&gt;&lt;strong&gt;IEEE Standard VHDL Language_2008&lt;/strong&gt;&lt;/a&gt;》，以便遇到一些语法问题的时候能查一下。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;二、独立完成中小规模的数字电路设计。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;       现在，你可以设计一些数字电路了，像交通灯、电子琴、DDS等等，推荐的教材是《&lt;a href=&quot;http://bbs.eetop.cn/viewthread.php?tid=587313&quot;&gt;&lt;strong&gt;Verilog HDL应用程序设计实例精讲&lt;/strong&gt;&lt;/a&gt;》。在这一阶段，你要做到的是：给你一个指标要求或者时序图，你能用HDL设计电路去实现它。这里你需要一块开发板，可以选&lt;a href=&quot;https://www.altera.com/support/literature/lit-index.smartphone.html&quot;&gt;&lt;strong&gt;Altera&lt;/strong&gt;&lt;/a&gt;的cyclone IV系列，或者&lt;a href=&quot;http://china.xilinx.com/support.html&quot;&gt;&lt;strong&gt;Xilinx&lt;/strong&gt;&lt;/a&gt;的Spantan 6。&lt;strong&gt;还没掌握HDL之前千万不要买开发板，因为你买回来也没用&lt;/strong&gt;。这里你没必要每次编译通过就下载代码，咱们用&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/47988847&quot;&gt;&lt;strong&gt;modelsim仿真&lt;/strong&gt;&lt;/a&gt;（此外还有&lt;a href=&quot;http://bbs.eetop.cn/thread-452999-1-1.html&quot;&gt;&lt;strong&gt;QuestaSim&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;http://bbs.eetop.cn/thread-471086-1-1.html&quot;&gt;&lt;strong&gt;NC verilog&lt;/strong&gt;&lt;/a&gt;、Diamond的Active-HDL、VCS、Debussy/&lt;a href=&quot;http://wenku.baidu.com/link?url=1cMQfcz0XQVXzvk2bOj_hLCfy6EAZR8KmlmRl-7pMnq-BCz8bLzYhfmQXcV9aqxVO0EB9rfV0X1nXgEpUUmUOQFv682BHIUB8HFUwOGfNoO&quot;&gt;&lt;strong&gt;Verdi&lt;/strong&gt;&lt;/a&gt;等仿真工具），如果仿真都不能通过那就不用下载了，肯定不行的。在这里先掌握简单的testbench就可以了。推荐的教材是《&lt;a href=&quot;http://bbs.eetop.cn/thread-413725-1-1.html&quot;&gt;&lt;strong&gt;WRITING TESTBENCHES Functional Verification of HDL Models&lt;/strong&gt;&lt;/a&gt;》。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;三、掌握设计方法和设计原则。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;       你可能发现你综合出来的电路尽管没错，但有很多警告。这个时候，你得学会同步设计原则、优化电路，是速度优先还是面积优先，时钟树应该怎样设计，怎样同步两个异频时钟等等。推荐的教材是《&lt;a href=&quot;http://bbs.eetop.cn/thread-335134-1-1.html&quot;&gt;&lt;strong&gt;FPGA权威指南&lt;/strong&gt;&lt;/a&gt;》、《&lt;a href=&quot;https://www.amazon.cn/IP%E6%A0%B8%E8%8A%AF%E5%BF%97-%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E5%90%B4%E6%B6%9B/dp/B0153NAS28/ref=sr_1_1?ie=UTF8&amp;amp;qid=1460103068&amp;amp;sr=8-1&amp;amp;keywords=IP%E6%A0%B8%E8%8A%AF%E5%BF%97-%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3&quot;&gt;&lt;strong&gt;IP核芯志-数字逻辑设计思想&lt;/strong&gt;&lt;/a&gt;》、《Altera FPGA/CPLD设计》第二版的&lt;a href=&quot;http://bbs.eetop.cn/thread-236729-1-1.html?tid=236729&amp;amp;extra=page%3D1&amp;amp;page=1&quot;&gt;&lt;strong&gt;基础篇&lt;/strong&gt;&lt;/a&gt;和&lt;a href=&quot;http://bbs.eetop.cn/thread-429297-1-1.html&quot;&gt;&lt;strong&gt;高级篇&lt;/strong&gt;&lt;/a&gt;两本。学会加快编译速度（增量式编译、LogicLock），静态&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/48687161&quot;&gt;&lt;strong&gt;时序分析&lt;/strong&gt;&lt;/a&gt;（&lt;a href=&quot;http://wenku.baidu.com/link?url=f55u1aL6d5XKysDuD4keltciKNk46aUXn39IF0hINNjaTqHxOeh34PfZDkudvU3JuI1RuwT9DPsow_kRFe9qhWYZbG7uWVo-AoAAylvlLP3&quot;&gt;&lt;strong&gt;timequest&lt;/strong&gt;&lt;/a&gt;），嵌入式逻辑分析仪（&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/47623501&quot;&gt;&lt;strong&gt;signaltap&lt;/strong&gt;&lt;/a&gt;）就算是通关了。如果有不懂的地方可以暂时跳过，因为这部分还需要足量的实践，才能有较深刻的理解。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;四、学会提高开发效率。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;        因为Quartus和ISE的编辑器功能太弱，影响了开发效率。所以建议使用&lt;strong&gt;&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/48092291&quot;&gt;Sublime text编辑器&lt;/a&gt;&lt;/strong&gt;中代码片段的功能，以减少重复性劳动。Modelsim也是常用的仿真工具，学会TCL/TK以编写适合自己的&lt;strong&gt;&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/50001035&quot;&gt;DO文件&lt;/a&gt;&lt;/strong&gt;，使得仿真变得自动化，推荐的教材是《&lt;a href=&quot;http://www.jb51.net/books/304937.html&quot;&gt;&lt;strong&gt;TCL/TK入门经典&lt;/strong&gt;&lt;/a&gt;》。你可能会手动备份代码，但是专业人士都是用版本控制器&lt;strong&gt;&lt;a href=&quot;https://www.runoob.com/git/git-tutorial.html&quot;&gt;Git&lt;/a&gt;&lt;/strong&gt;的，可以提高工作效率。文件比较器&lt;a href=&quot;http://www.beyondcompare.cc/xiazai.html&quot;&gt;&lt;strong&gt;Beyond Compare&lt;/strong&gt;&lt;/a&gt;也是个比较常用的工具，Git也有比较功能。此外，你也可以使用&lt;a href=&quot;http://bbs.eetop.cn/thread-387263-1-4.html&quot;&gt;&lt;strong&gt;System Verilog&lt;/strong&gt;&lt;/a&gt;来替代testbench，这样效率会更高一些。如果你是做IC验证的，就必须掌握System Verilog和验证方法学（UVM）。推荐的教材是《&lt;a href=&quot;http://bbs.eetop.cn/thread-587167-1-1.html&quot;&gt;&lt;strong&gt;Writing Testbenches using SystemVerilog&lt;/strong&gt;&lt;/a&gt;》、《&lt;a href=&quot;http://bbs.eetop.cn/thread-479340-1-1.html&quot;&gt;&lt;strong&gt;The UVM Primer&lt;/strong&gt;&lt;/a&gt;》、《&lt;a href=&quot;http://bbs.eetop.cn/thread-387263-1-1.html&quot;&gt;&lt;strong&gt;System Verilog1800-2012语法手册&lt;/strong&gt;&lt;/a&gt;》。&lt;/p&gt;



&lt;p&gt;         掌握了TCL/TK之后，可以学习&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/52093292&quot;&gt;&lt;strong&gt;虚拟Jtag&lt;/strong&gt;&lt;/a&gt;（ISE也有类似的工具）制作属于自己的调试工具，此外，有时间的话，最好再学个python。脚本，意味着一劳永逸。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;五、增强理论基础。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;        这个时候，你已经会使用FPGA了，但是还有很多事情做不了（比如，FIR滤波器、&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/51146507&quot;&gt;&lt;strong&gt;PID算法&lt;/strong&gt;&lt;/a&gt;、OFDM等），因为理论没学好。我大概地分几个方向供大家参考，后面跟的是要掌握的理论课。&lt;/p&gt;



&lt;p&gt;1、信号处理——&lt;strong&gt;&lt;a href=&quot;https://blog.csdn.net/k331922164/article/details/55006763&quot;&gt;信号与系统&lt;/a&gt;&lt;/strong&gt;、数字信号处理、数字图像处理、现代数字信号处理、盲信号处理、自适应滤波器原理、雷达信号处理&lt;/p&gt;



&lt;p&gt;2、接口应用——如：&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/51429544&quot;&gt;&lt;strong&gt;UART&lt;/strong&gt;&lt;/a&gt;、&lt;strong&gt;&lt;a href=&quot;https://wenku.baidu.com/view/1d162f7187c24028915fc3da.html?from=search&quot;&gt;SPI&lt;/a&gt;&lt;/strong&gt;、&lt;a href=&quot;https://wenku.baidu.com/view/8f9df95f804d2b160b4ec0b3.html?from=search&quot;&gt;&lt;strong&gt;IIC&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/53349360&quot;&gt;&lt;strong&gt;USB&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;https://wenku.baidu.com/view/f6cf8081d4d8d15abe234ecb.html&quot;&gt;&lt;strong&gt;CAN&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;http://bbs.eetop.cn/thread-600329-1-1.html&quot;&gt;&lt;strong&gt;PCIE&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;http://www.rapidio.org/&quot;&gt;&lt;strong&gt;Rapid IO&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;https://wenku.baidu.com/view/c1609388d4d8d15abe234e6f.html&quot;&gt;&lt;strong&gt;DDR&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;http://www.jb51.net/books/66960.html&quot;&gt;&lt;strong&gt;TCP/IP&lt;/strong&gt;&lt;/a&gt;、&lt;strong&gt;&lt;a href=&quot;https://wenku.baidu.com/view/8093e3edf8c75fbfc77db296.html&quot;&gt;SPI4.2&lt;/a&gt;&lt;/strong&gt;(10G以太网接口)、&lt;a href=&quot;http://bbs.eetop.cn/thread-594135-1-1.html&quot;&gt;&lt;strong&gt;SATA&lt;/strong&gt;&lt;/a&gt;、光纤、&lt;strong&gt;&lt;a href=&quot;http://bbs.eetop.cn/thread-315534-1-1.html&quot;&gt;DisplayPort&lt;/a&gt;&lt;/strong&gt;、HDMI&lt;/p&gt;



&lt;p&gt;3、无线通信——信号与系统、数字信号处理、通信原理、移动通信基础、随机过程、信息论与编码&lt;/p&gt;



&lt;p&gt;4、CPU设计——计算机组成原理、&lt;strong&gt;&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/44681093&quot;&gt;单片机&lt;/a&gt;&lt;/strong&gt;、计算机体系结构、编译原理、&lt;strong&gt;&lt;a href=&quot;https://riscv.org/risc-v-cores/&quot;&gt;RISC-V&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;5、仪器仪表——模拟电子技术、高频电子线路、电子测量技术、智能仪器原理及应用&lt;/p&gt;



&lt;p&gt;6、控制系统——自动控制原理、现代控制理论、过程控制工程、模糊控制器理论与应用&lt;/p&gt;



&lt;p&gt;7、压缩、编码、加密——数论、抽象代数、现代编码技术、信息论与编码、数据压缩导论、应用密码学、音频信息处理技术、数字视频编码技术原理&lt;/p&gt;



&lt;p&gt;       现在你发现，原来FPGA会涉及到那么多知识，你可以选一个感兴趣的方向，但是工作中很有可能用到其中几个方向的知识，所以理论还是学得越多越好。如果你要更上一层，数学和英语是不可避免的。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;六、学会使用MATLAB仿真。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;        设计FPGA算法的时候，多多少少都会用到MATLAB，比如&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/51648707&quot;&gt;&lt;strong&gt;CRC&lt;/strong&gt;&lt;/a&gt;的系数矩阵、数字滤波器系数、各种表格和文本处理等。此外，MATLAB还能用于调试HDL（用MATLAB的计算结果跟用HDL算出来的一步步对照，可以知道哪里出问题）。推荐的教材是《&lt;a href=&quot;http://www.jb51.net/books/104042.html&quot;&gt;&lt;strong&gt;MATLAB宝典&lt;/strong&gt;&lt;/a&gt;》和杜勇的《&lt;a href=&quot;http://search.dangdang.com/?key=%CA%FD%D7%D6%C2%CB%B2%A8%C6%F7%B5%C4MATLAB%D3%EBFPGA%CA%B5%CF%D6&amp;amp;act=input&quot;&gt;&lt;strong&gt;数字滤波器的MATLAB与FPGA实现&lt;/strong&gt;&lt;/a&gt;》。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;七、足量的实践。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;       这个时候你至少读过几遍芯片手册（&lt;strong&gt;&lt;a href=&quot;https://www.altera.com/support/literature/lit-index.html&quot;&gt;官网&lt;/a&gt;&lt;/strong&gt;有），然后可以针对自己的方向，做一定量的实践了（期间要保持良好的&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/52166038&quot;&gt;&lt;strong&gt;代码风格&lt;/strong&gt;&lt;/a&gt;，&lt;a href=&quot;http://blog.csdn.net/k331922164?viewmode=list&quot;&gt;&lt;strong&gt;增加元件例化语句的可读性&lt;/strong&gt;&lt;/a&gt;，绘制&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/50541541&quot;&gt;&lt;strong&gt;流程图/时序图&lt;/strong&gt;&lt;/a&gt;，&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/50539863&quot;&gt;&lt;strong&gt;撰写文档&lt;/strong&gt;&lt;/a&gt;的习惯）。比如：通信类的可以做调制解调算法，仪表类的可以做总线分析仪等等。不过这些算法，在书上只是给了个公式、框图而已，跟实际的差距很大，你甚至会觉得书上的东西都很肤浅。那么，你可以在&lt;a href=&quot;http://www.cnki.net/&quot;&gt;&lt;strong&gt;知网&lt;/strong&gt;&lt;/a&gt;、&lt;strong&gt;&lt;a href=&quot;http://wenku.baidu.com/&quot;&gt;百度文库&lt;/a&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;a href=&quot;http://bbs.eetop.cn/&quot;&gt;EETOP论坛&lt;/a&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;a href=&quot;http://opencores.org/projects&quot;&gt;opencores&lt;/a&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;a href=&quot;http://blog.chinaaet.com/&quot;&gt;ChinaAET&lt;/a&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;a href=&quot;http://tool.yovisun.com/scihub/&quot;&gt;SCI-HUB&lt;/a&gt;&lt;/strong&gt;、Q群共享、博客上面找些相关资料（校外的朋友可以在淘宝买个知网账号）。其实，当你到了这个阶段，你已经达到了职业级水平，有空就多了解一些前沿技术，这将有助于你的职业规划。&lt;/p&gt;



&lt;p&gt;        在工作当中，或许你需要关注很多协议和行业标准，协议可以在EETOP上面找到，而标准（如：国家标准GB和GB/T，国际标准ISO）就推荐《&lt;a href=&quot;http://www.biaozhuns.com/&quot;&gt;&lt;strong&gt;标准网&lt;/strong&gt;&lt;/a&gt;》和《&lt;a href=&quot;http://www.bzfxw.com/&quot;&gt;&lt;strong&gt;标准分享网&lt;/strong&gt;&lt;/a&gt;》。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;八、图像处理。&lt;/strong&gt;（这部分只写给想学图像处理的朋友，也是由浅入深的路线）&lt;/p&gt;



&lt;p&gt;1、Photoshop。花一、两周的时间学习PS，对图像处理有个大概的了解，知道各种图片格式、直方图、色相、通道、滤镜、拼接等基本概念，并能使用它。这部分是0基础，目的让大家对图像处理有个感性的认识，而不是一上来就各种各样的公式推导。推荐《&lt;strong&gt;&lt;a href=&quot;http://www.jb51.net/books/100972.html&quot;&gt;Photoshop CS6完全自学教程&lt;/a&gt;&lt;/strong&gt;》。&lt;/p&gt;



&lt;p&gt;2、基于MATLAB或OpenCV的图像处理。有C/C++基础的可以学习OpenCV，否则的话，建议学MATLAB。这个阶段下，只要学会简单的调用函数即可，暂时不用深究实现的细节。推荐《&lt;strong&gt;&lt;a href=&quot;http://bbs.eetop.cn/thread-305112-1-1.html&quot;&gt;数字图像处理matlab版&lt;/a&gt;&lt;/strong&gt;》、《&lt;strong&gt;&lt;a href=&quot;http://www.jb51.net/books/86684.html&quot;&gt;学习OpenCV&lt;/a&gt;&lt;/strong&gt;》。&lt;/p&gt;



&lt;p&gt;3、图像处理的基础理论。这部分的理论是需要高数、复变、线性代数、信号与系统、数字信号处理等基础，基础不好的话，建议先补补基础再来。看不懂的理论也可以暂时先放下，或许学到后面就自然而然地开窍了。推荐《&lt;strong&gt;&lt;a href=&quot;http://bbs.eetop.cn/thread-252932-1-1.html&quot;&gt;数字图像处理&lt;/a&gt;&lt;/strong&gt;》。&lt;/p&gt;



&lt;p&gt;4、基于FPGA的图像处理。把前面学到的理论运用到FPGA上面，如果这时你有前面第七个阶段的水平，你将轻松地独立完成图像算法设计（图像处理是离不开接口的，上面第五个阶段有讲）。推荐《&lt;strong&gt;&lt;a href=&quot;https://www.amazon.cn/dp/B00BPXFUVK/ref=wl_it_dp_o_pd_nS_ttl?_encoding=UTF8&amp;amp;colid=1KD25DEC6Q598&amp;amp;coliid=I1BCWMH1TX87Q5&quot;&gt;基于FPGA的嵌入式图像处理系统设计&lt;/a&gt;&lt;/strong&gt;》、《&lt;a href=&quot;http://product.dangdang.com/24171633.html#preface&quot;&gt;&lt;strong&gt;基于FPGA的数字图像处理原理及应用&lt;/strong&gt;&lt;/a&gt;》。&lt;/p&gt;



&lt;p&gt;5、进一步钻研数学。要在算法上更上一层，必然需要更多的数学，所以这里建议学习&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/52842206&quot;&gt;&lt;strong&gt;实分析&lt;/strong&gt;&lt;/a&gt;、&lt;strong&gt;&lt;a href=&quot;http://wenku.baidu.com/link?url=Fk0k8pCAe8PlvAk35gVwQgYUbMaQ8FILvJXINDJA-1jyB1bDaMvRi-D-e3zl4-CUdHwdpEqasojlnPeA2_cW5UbbF1l0Ig2OM1bTd_6pn_q&quot;&gt;泛涵分析&lt;/a&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;a href=&quot;http://wenku.baidu.com/link?url=sIxDcV7Aju1bNj0eqZj1-1zJrs0P1ZCg558bXfyO5NDNo6oRWz5QHl3fcAoe41yxi_oH9k0DuPy_7qznsF7QLEMNUh8ELJR-cFuzpZavrve&quot;&gt;小波分析&lt;/a&gt;&lt;/strong&gt;等。&lt;/p&gt;



&lt;p&gt;下面这两个阶段是给感兴趣的朋友介绍的。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;九、数电的尽头是模电。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;       现在FPGA内部的事情是难不到你的，但是信号出了FPGA，你就没法控制了。这个时候必须学好模电。比如：电路分析、模拟电子技术、高频电子线路、PCB设计、EMC、SI、PI等等，能设计出一块带两片DDR3的FPGA开发板，就算通关了。具体的学习路线可以参考本博客的《&lt;strong&gt;&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/45102489&quot;&gt;如何学习硬件设计——理论篇&lt;/a&gt;&lt;/strong&gt;》和《&lt;strong&gt;&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/46844339&quot;&gt;如何学习硬件设计——实践篇&lt;/a&gt;&lt;/strong&gt;》。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;十、学无止境。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;       能到这个境界，说明你已经很厉害了，但是还有很多东西要学的，因为FPGA常常要跟CPU交互，也就是说你得经常跟软件工程师交流，所以也得懂点软件方面的知识。比如ARM（Xilinx的ZYNQ和Altera的SOC会用到ARM的硬核，请参考本博客的《&lt;strong&gt;&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/50629131&quot;&gt;如何学习嵌入式软件&lt;/a&gt;&lt;/strong&gt;》）、&lt;strong&gt;&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/78734859&quot;&gt;DSP&lt;/a&gt;&lt;/strong&gt;、Linux、安卓、上位机（&lt;a href=&quot;http://blog.csdn.net/k331922164/article/details/52729675&quot;&gt;&lt;strong&gt;QT&lt;/strong&gt;&lt;/a&gt;、C#、JAVA）都可以学一下，反正学无止境的。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;十一、其它问题。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;a、为什么不推荐学习NIOS II和MicroBlaze等软核？&lt;/p&gt;



&lt;p&gt;      1、性价比不高，一般的软核性能大概跟Cortex M3或M4差不多，用FPGA那么贵的东西去做一个性能一般的CPU，在工程上是非常不划算的。不如另外加一块M3。&lt;/p&gt;



&lt;p&gt;      2、加上软核，可能会影响到其它的逻辑的功能。这是在资源并不十分充足的情况下，再加上软核，导致布局布线变得相当困难。&lt;/p&gt;



&lt;p&gt;      3、软核不开源，出现Bug的时候，不容易调试。&lt;/p&gt;



&lt;p&gt;      4、工程上很少使用，极有可能派不上用场。&lt;/p&gt;



&lt;p&gt;b、为什么不推荐0基础学习ZYNQ或SOC？&lt;/p&gt;



&lt;p&gt;      1、容易让人有傍同心理。傍同心理是指一个人通过渲染与自己有亲近关系的人的杰出，来掩盖和弥补自己在这方面的不足，从而获得心理上的平衡。自己在学习很厉害的东西，然后也感觉自己很厉害，但这只是错觉而已。&lt;/p&gt;



&lt;p&gt;      2、入门应该学习尽量简单的东西，要么专心学习ARM，要么专心学习FPGA。这样更容易有成就感，增强信心。&lt;/p&gt;



&lt;p&gt;      3、ZYNQ和SOC的应用领域并不广，还有很多人没听过这种东西，导致求职的不利。&lt;/p&gt;



&lt;p&gt;      4、开发工具编译时间长，浪费较多时间。&lt;/p&gt;



&lt;p&gt;      5、绝大多数工作，都只是负责一方面，也就是说另一方面，很有可能派不上用场。&lt;/p&gt;



&lt;p&gt;c、为什么已经存在那么多IP核，仍然需要写HDL？&lt;/p&gt;



&lt;p&gt;      1、问这种问题的，一般是学生，他们没有做过产品，没有遇到过工程上的问题。&lt;/p&gt;



&lt;p&gt;      2、IP核并非万能，不能满足所有需求。&lt;/p&gt;



&lt;p&gt;      3、尽量少用闭源IP核，一旦出问题，这种黑匣子很可能让产品难产。&lt;/p&gt;



&lt;p&gt;      4、深入理解底一层次，可以更好地使用高一层次。该法则可以适用于所有编程语言。&lt;/p&gt;



&lt;p&gt;d、推荐一些微电子的教学视频。&lt;/p&gt;



&lt;p&gt;      可以参考本博客的《&lt;strong&gt;&lt;a href=&quot;https://blog.csdn.net/k331922164/article/details/85047746&quot;&gt;微电子教学视频–Silicon Run等&lt;/a&gt;&lt;/strong&gt;》。&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;https://www.captainbed.net/lhyd&quot;&gt;点这里可以跳转到人工智能网站&lt;/a&gt;&lt;/p&gt;
&amp;#13;
&lt;/div&gt;&amp;#13;
&amp;#13;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c90d4a32b56534e3eba0c0d4b7e6ca01</guid>
<title>基于 f2 从零实现移动端可视化编辑器</title>
<link>https://toutiao.io/k/wtfv8vn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4871447902571042&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt01149Id07WaR2gmS0gVc15lGC13AqjWNBB82r3mQHzoNOVibyv2iaAw49Okv8TFAYP3ySmT7T1BUyibXW8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1478&quot;/&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading-11&quot;&gt;&lt;span&gt;往期推荐&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-id=&quot;heading-0&quot;&gt;前言&lt;/h2&gt;&lt;section&gt;&lt;span&gt;笔者之前花了大量的时间在思考如何设计和实现H5页面可视化编辑器&lt;span&gt;H5-Dooring&lt;/span&gt;，从第一个版本到现在经历了很多次版本迭代和优化，也收到了很多宝贵的建议，目前刚好完成了移动端数据可视化的基本设计和落地方案，在这里特地总结和复盘一下。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们先来看看实现的基本预览图：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-height=&quot;600&quot; data-ratio=&quot;0.37053245805981033&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/dFTfMt01149Id07WaR2gmS0gVc15lGC1WfnBf633r9SQic0XSyw4sG8P7d2XEcgzGwLhl5hdWyiaxMz62sEnVZRw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1371&quot; data-width=&quot;800&quot;/&gt;&lt;/section&gt;&lt;h2 data-id=&quot;heading-1&quot;&gt;你将收获&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;基于&lt;span&gt;antv/f2&lt;/span&gt;实现可视化图形组件的封装&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如何设计表格编辑器并集成到&lt;span&gt;antd&lt;/span&gt;的Form中&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据可视化组件的&lt;span&gt;schema&lt;/span&gt;约定&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;利用&lt;span&gt;js-xlsx&lt;/span&gt;解析&lt;span&gt;Excel&lt;/span&gt;文件并导入到&lt;span&gt;Table&lt;/span&gt;中作为可视化组件的&lt;span&gt;数据源&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-id=&quot;heading-2&quot;&gt;正文&lt;/h2&gt;&lt;section&gt;&lt;span&gt;在开始正式实现之前笔者先对&lt;span&gt;H5数据可视化&lt;/span&gt;做一个基本的介绍，方便大家理解其价值。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-id=&quot;heading-3&quot;&gt;&lt;strong&gt;1. H5数据可视化方案的应用场景&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;随着人工智能和大数据的快速发展，数据可视化设计在移动端的应用越来越多，主要体现在&lt;span&gt;数据图表&lt;/span&gt;，也就是我们常见的&lt;span&gt;柱状图&lt;/span&gt;，&lt;span&gt;折线图&lt;/span&gt;，&lt;span&gt;条形图&lt;/span&gt;，&lt;span&gt;雷达图&lt;/span&gt;等。它们能很形象的展示不同产品或者某类特征的变化趋势，从而为我们决策提供依据。比如说我们常见的&lt;span&gt;性格测试雷达图&lt;/span&gt;，各类金融app比较爱玩的某某g票的&lt;span&gt;趋势预测折线图&lt;/span&gt;，运营人比较喜欢用的&lt;span&gt;漏斗模型&lt;/span&gt;等，几乎任何领域都有自己的可视化应用。如下图几个例子：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img data-height=&quot;600&quot; data-ratio=&quot;0.7407407407407407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt01149Id07WaR2gmS0gVc15lGC1oLs3OrNfQkcLbp2icmN275QIcTiaVNbRMCajGiawNpMiaOpNKU9eIqLBwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1296&quot; data-width=&quot;800&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-height=&quot;600&quot; data-ratio=&quot;0.7519142419601837&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt01149Id07WaR2gmS0gVc15lGC1rq3CZMwdn8hzQv2ud4rwjGpqxH9QonfzlFbefnNXmf45r4NyTs5CRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1306&quot; data-width=&quot;800&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-height=&quot;600&quot; data-ratio=&quot;0.7763975155279503&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt01149Id07WaR2gmS0gVc15lGC19hH7n8t2jkKEib9Zk6DNvdJvkfVfr5NblpgQTOj3xPfL3H39UoG1U4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1288&quot; data-width=&quot;800&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;所以为了满足企业对移动端场景下的可视化需求，能设计一款针对移动端的傻瓜式可视化搭建平台是非常有实际意义的，目前也有很多公司在做，在&lt;span&gt;商业智能&lt;/span&gt;领域也有不错的应用。接下来笔者就来带大家一起实现一个这样的&lt;span&gt;H5数据可视化&lt;/span&gt;搭建平台。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-id=&quot;heading-4&quot;&gt;&lt;strong&gt;2. H5数据可视化设计平台的实现方式&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;目前市面上已有的比较流行的可视化库有&lt;span&gt;echart&lt;/span&gt;，&lt;span&gt;antv&lt;/span&gt;，&lt;span&gt;D3.js&lt;/span&gt;等，针对于移动端而言，笔者还是觉得&lt;span&gt;antv/f2&lt;/span&gt;更加适合，其官网介绍如下：&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;F2 是一个专注于移动，开箱即用的可视化解决方案，完美支持 H5 环境同时兼容多种环境（Node, 小程序，Weex），完备的图形语法理论，满足你的各种可视化需求，专业的移动设计指引为你带来最佳的移动端图表体验。&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;我们就暂且相信它官网的描述，接下来的技术实现笔者也会基于&lt;span&gt;f2&lt;/span&gt;做可视化组件的二次封装。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-id=&quot;heading-5&quot;&gt;&lt;strong&gt;2.1 需求设计&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;笔者在开发产品之前的一贯风格就是先要理清需求，只有在需求确定之后我们才能做更加合适的技术选型和方案，所以笔者在此带大家分析一下&lt;span&gt;移动端可视化编辑器&lt;/span&gt;的需求设计。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img data-height=&quot;600&quot; data-ratio=&quot;0.3689922480620155&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt01149Id07WaR2gmS0gVc15lGC196OmdEYQTAENOGBiaJPFHxcK8eQaXdUNd5SZQ0DtmyZd6USYhHLVSuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2580&quot; data-width=&quot;800&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;上图为一个可视化组件编辑器的基本模型，组成结构大致为：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;图表组件&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据源&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;属性编辑器（组件标题，颜色，对齐等属性）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;所以说我们大致可以抽象为如下原型：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-height=&quot;600&quot; data-ratio=&quot;0.5356234096692112&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt01149Id07WaR2gmS0gVc15lGC13OQQanN30GCzvobtNaUhzbrPaVO1Vicmu9skWepIag6D5mJn7wIkfkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1572&quot; data-width=&quot;800&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;组件列表为我们提供选择不同组件的能力，画布区域主要用来拖拽图形和调整图形位置，大小，编辑器用来定制图形的“形状”和数据源导入。在了解基本的需求之后我们来进行接下来的开发工作。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-id=&quot;heading-6&quot;&gt;&lt;strong&gt;2.2 基于&lt;span&gt;antv/f2&lt;/span&gt;实现可视化图形组件的封装&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;由于市场上暂时没有比较成熟的基于&lt;span&gt;f2&lt;/span&gt;的&lt;span&gt;react&lt;/span&gt;组件等封装， 所以这里笔者对其做一个简单的二次封装来实现我们的组件定制的需求。对于组件列表，为了提高加载性能，笔者用&lt;span&gt;图片占位符&lt;/span&gt;代替。数据传递方式和&lt;/span&gt;&lt;span&gt;H5-Dooring&lt;/span&gt;&lt;span&gt;已有组件的拖拽一致,这里就不一一介绍了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在开发组件之前我们先安装一下&lt;span&gt;f2&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;yarn add antv/f2&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;复制代码&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;为了进一步降低移动端代码体积和提高加载性能，我们在引入组件时可以按需引入：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// 引入核心包&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; Core = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;@antv/f2/lib/core&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;@antv/f2/lib/geom/line&#x27;&lt;/span&gt;); &lt;span&gt;// 只加载折线图&lt;/span&gt;&lt;br/&gt;&lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;@antv/f2/lib/geom/area&#x27;&lt;/span&gt;); &lt;span&gt;// 只加载面积图&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;复制代码&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;按需引入的方式官网上有详细的说明，感兴趣的可以学习了解一下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在上面的需求分析中我们大致了解了可视化组件需要设置的属性，这里我们先整理一下以便接下来对可视化组件的封装：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img data-height=&quot;600&quot; data-ratio=&quot;0.7313084112149533&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt01149Id07WaR2gmS0gVc15lGC1ETsOYHR9sic4qbctySZtQuezxghJiaf2H4fyautbibQpN5bqYcC8j2BQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1712&quot; data-width=&quot;800&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们来看看&lt;span&gt;Chart&lt;/span&gt;组件的实现：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// components/Chart&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { Chart } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;@antv/f2&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; React, { memo, PropsWithChildren, useEffect, useRef } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; ChartImg &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;@/assets/chart.png&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; styles &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./index.less&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;type DataItem = {&lt;br/&gt;  name: string;&lt;br/&gt;  value: number;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;interface XChartProps {&lt;br/&gt;  isTpl: boolean;&lt;br/&gt;  title: string;&lt;br/&gt;  color: string;&lt;br/&gt;  size: number;&lt;br/&gt;  paddingTop: number;&lt;br/&gt;  data: &lt;span&gt;Array&lt;/span&gt;&amp;lt;DataItem&amp;gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; XChart = (props: PropsWithChildren&amp;lt;XChartProps&amp;gt;) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { isTpl, data, color, size, paddingTop, title } = props;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; chartRef = useRef(&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;  useEffect(() =&amp;gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!isTpl) {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; chart = &lt;span&gt;new&lt;/span&gt; Chart({&lt;br/&gt;        el: chartRef.current || &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;        pixelRatio: &lt;span&gt;window&lt;/span&gt;.devicePixelRatio, &lt;span&gt;// 指定分辨率&lt;/span&gt;&lt;br/&gt;      });&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// step 2: 处理数据&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; dataX = data.map(item =&amp;gt; ({ ...item, value: &lt;span&gt;Number&lt;/span&gt;(item.value) }));&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// Step 2: 载入数据源&lt;/span&gt;&lt;br/&gt;      chart.source(dataX);&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// Step 3：创建图形语法，绘制柱状图，由 genre 和 sold 两个属性决定图形位置，genre 映射至 x 轴，sold 映射至 y 轴&lt;/span&gt;&lt;br/&gt;      chart&lt;br/&gt;        .interval()&lt;br/&gt;        .position(&lt;span&gt;&#x27;name*value&#x27;&lt;/span&gt;)&lt;br/&gt;        .color(&lt;span&gt;&#x27;name&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// Step 4: 渲染图表&lt;/span&gt;&lt;br/&gt;      chart.render();&lt;br/&gt;    }&lt;br/&gt;  }, []);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&amp;lt;div &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;{styles.chartWrap}&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &amp;lt;div className={styles.chartTitle} style={{ color, fontSize: size, paddingTop }}&amp;gt;&lt;br/&gt;        {title}&lt;br/&gt;      &amp;lt;/div&amp;gt;&lt;br/&gt;      {isTpl ? &amp;lt;img src={ChartImg} alt=&quot;dooring chart&quot; /&amp;gt; : &amp;lt;canvas ref={chartRef}&amp;gt;&amp;lt;/canvas&amp;gt;}&lt;br/&gt;    &amp;lt;/div&amp;gt;&lt;br/&gt;  );&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;export default memo(XChart);&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;复制代码&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;以上Chart组件就基本封装完毕，如果有更多定制化需求，也可以自行添加。代码中我们采用&lt;span&gt;typescript&lt;/span&gt;和&lt;span&gt;React Hooks&lt;/span&gt;开发，为了对组件进行做优化，我们用了&lt;span&gt;memo&lt;/span&gt;，如果对这些技术点不熟悉的，稍后可以移步我的&lt;span&gt;react hooks&lt;/span&gt;和&lt;span&gt;typescript&lt;/span&gt;相关的文章学习。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上只是完成了基本的可视化组件的封装，接下来的重点是实现可视化组件和表单编辑器之间的联动。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-id=&quot;heading-7&quot;&gt;&lt;strong&gt;2.3 设计表格编辑器并集成到&lt;span&gt;antd&lt;/span&gt;的Form中&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;表格编辑器的实现我们主要基于&lt;span&gt;antd&lt;/span&gt;的&lt;span&gt;Table&lt;/span&gt;组件来实现，当我们点击数据源的时候，会弹出表格编辑器，我们先来看看效果：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img data-height=&quot;600&quot; data-ratio=&quot;0.534769833496572&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt01149Id07WaR2gmS0gVc15lGC10F8kiaVvZDfRUP95wicgk4BhzZXosKML6Ya5ONuyWhBo8URiar9YB8Q7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2042&quot; data-width=&quot;800&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;我们可以直接对数据源进行编辑，比如修改数据，删除数据，添加数据，也即是&lt;span&gt;CURD&lt;/span&gt;的那套流程。并且支持导入excel数据，这块笔者将在下一章节来实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可编辑表格实现原理就是在表格中加入状态，分为查看模式和编辑模式，编辑模式采用input框，在失焦时进行保存/切换查看状态。添加行的逻辑主要是动态插入一条数据，这块实现也比较简单，具体实现感兴趣的朋友可参考我的&lt;/span&gt;&lt;span&gt;源码&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;部分代码参考如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// 添加行&lt;/span&gt;&lt;br/&gt;handleAdd = () =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { count, dataSource } = &lt;span&gt;this&lt;/span&gt;.state;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; newData = {&lt;br/&gt;    key: count,&lt;br/&gt;    name: &lt;span&gt;`dooring &lt;span&gt;${count}&lt;/span&gt;`&lt;/span&gt;,&lt;br/&gt;    value: &lt;span&gt;32&lt;/span&gt;,&lt;br/&gt;  };&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; newDataSource = [...dataSource, newData];&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.setState({&lt;br/&gt;    dataSource: newDataSource,&lt;br/&gt;    count: count + &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;  });&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.props.onChange &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.props.onChange(newDataSource);&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 保存行数据&lt;/span&gt;&lt;br/&gt;handleSave = row =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; newData = [...this.state.dataSource];&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; index = newData.findIndex(item =&amp;gt; row.key === item.key);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; item = newData[index];&lt;br/&gt;  newData.splice(index, &lt;span&gt;1&lt;/span&gt;, {&lt;br/&gt;    ...item,&lt;br/&gt;    ...row,&lt;br/&gt;  });&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.setState({ dataSource: newData });&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.props.onChange &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.props.onChange(newData);&lt;br/&gt;};&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;复制代码&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;上面代码的this.props.onChange主要是为了&lt;span&gt;antd&lt;/span&gt;的&lt;span&gt;Form&lt;/span&gt;能接受到变化，使&lt;span&gt;Table Editor&lt;/span&gt;成为&lt;span&gt;Form&lt;/span&gt;的“受控组件”。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-id=&quot;heading-8&quot;&gt;&lt;strong&gt;2.4 利用&lt;span&gt;js-xlsx&lt;/span&gt;解析&lt;span&gt;Excel&lt;/span&gt;文件并导入到&lt;span&gt;Table&lt;/span&gt;中作为可视化组件的&lt;span&gt;数据源&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;对于上面介绍的数据源录入，我们有两种模式：&lt;span&gt;手动录入&lt;/span&gt;和&lt;span&gt;文件导入&lt;/span&gt;。设计文件导入主要是为了更好的用户体验，这里为了实现该功能我们可以采用社区比较火的&lt;span&gt;js-xlsx&lt;/span&gt;，一款专业的解析excel数据的插件，而且可以输出多种数据类型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们先来安装一下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt; npm install xlsx&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;复制代码&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;读取excel文件数据代码如下：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// 读取本地excel文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;readLocalFile&lt;/span&gt;(file, callback) {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; reader = &lt;span&gt;new&lt;/span&gt; FileReader();&lt;br/&gt;    reader.onload = &lt;span&gt;function&lt;/span&gt;(e) {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; data = e.target.result;&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; formData = XLSX.read(data, {type: &lt;span&gt;&#x27;binary&#x27;&lt;/span&gt;});&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(callback) callback(formData);&lt;br/&gt;    };&lt;br/&gt;    reader.readAsBinaryString(file);&lt;br/&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;复制代码&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;有了以上代码，我们只需要在导入excel的按钮上绑定事件并解析数据即可实现导入功能。大家可以尝试一下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上就基本实现了我们的真个体系设计，后面的雷达图，折线图等实现原理也类似。我们看看用&lt;span&gt;H5-Dooring&lt;/span&gt;配置出的几个案例：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img data-height=&quot;600&quot; data-ratio=&quot;0.875886524822695&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt01149Id07WaR2gmS0gVc15lGC16NgcOjpibG6rFUsdt3RS7dFPiaLNiccDJytWqgD9W1ZnShVr89KUicmCOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1692&quot; data-width=&quot;800&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-height=&quot;600&quot; data-ratio=&quot;0.9919678714859438&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt01149Id07WaR2gmS0gVc15lGC1VqpK88EKB1yrUg3YG64eamHkiawgrEibLTnWaCiaOwrK8so9mbMj4hCFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1494&quot; data-width=&quot;800&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;当然大家也可以在&lt;span&gt;H5-Dooring&lt;/span&gt;定制自己的&lt;span&gt;H5数据可视化面板&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-id=&quot;heading-9&quot;&gt;&lt;strong&gt;3. 总结&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;以上教程笔者已经集成到&lt;span&gt;H5-Dooring&lt;/span&gt;中，对于一些更复杂的交互功能，通过合理的设计也是可以实现的，大家可以自行探索研究。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;github搜索：&lt;/span&gt;&lt;span&gt;H5在线编辑器H5-Dooring&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading-10&quot;&gt;最后&lt;/h2&gt;&lt;p&gt;&lt;span&gt;如果想学习更多H5游戏, webpack，node，gulp，css3，javascript，nodeJS，canvas数据可视化等前端知识和实战，欢迎在《趣谈前端》一起学习讨论，共同探索前端的边界。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.14355555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt01149Id07WaR2gmS0gVc15lGC1C1qaqZgI6CqhVkdRxibpjQqRILqZibMcNXuOGqvE5iaib40g90xfcSSlZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;4500&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;mp-qa class=&quot;js_uneditable custom_select_card qa_iframe&quot; data-pluginname=&quot;insertquestion&quot; data-id=&quot;1521455992444665857&quot; data-bizuin=&quot;MzU2Mzk1NzkwOA==&quot; data-title=&quot;基于vue或react框架下的数据可视化方案， 你知道哪些呢？遇到过哪些问题？&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>