<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>68f92b4b87c0c49f3ce19d44fad8d348</guid>
<title>用 Python 轻松完成一个 Saga 分布式事务，保姆级教程</title>
<link>https://toutiao.io/k/kbrldxv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;银行跨行转账业务是一个典型分布式事务场景，假设 A 需要跨行转账给 B，那么就涉及两个银行的数据，无法通过一个数据库的本地事务保证转账的 ACID，只能够通过分布式事务来解决。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;分布式事务&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;分布式事务在分布式环境下，为了满足可用性、性能与降级服务的需要，降低一致性与隔离性的要求，一方面遵循 BASE 理论：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另一方面，分布式事务也部分遵循 ACID 规范：&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;SAGA&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;Saga 是这一篇数据库论文SAGAS提到的一个分布式事务方案。其核心思想是将长事务拆分为多个本地短事务，由 Saga 事务协调器协调，如果各个本地事务成功完成那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前可用于 SAGA 的开源框架，主要为 Java 语言，其中以 seata 为代表。我们的例子采用 go 语言，使用的分布式事务框架为https://github.com/yedf/dtm，它对分布式事务的支持非常优雅。下面来详细讲解 SAGA 的组成：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DTM 事务框架里，有 3 个角色，与经典的 XA 分布式事务一样：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面看一个成功完成的 SAGA 时序图，就很容易理解 SAGA 分布式事务：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7671691792294807&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9m9OfQX94VtmicKKfY1TghX3qLX9OrR6YRrxr4ncicK0Q2909bKaz70HClYuUicd73DCicoZ9B1Ocgia5rxCGM1Y0WA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1194&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;SAGA 实践&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;对于我们要进行的银行转账的例子，我们将在正向操作中，进行转入转出，在补偿操作中，做相反的调整。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先我们创建账户余额表：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;CREATE TABLE dtm_busi.&lt;span&gt;`user_account`&lt;/span&gt; (&lt;br/&gt;  &lt;span&gt;`id`&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) AUTO_INCREMENT PRIMARY KEY,&lt;br/&gt;  &lt;span&gt;`user_id`&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) not NULL UNIQUE ,&lt;br/&gt;  &lt;span&gt;`balance`&lt;/span&gt; decimal(&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;) NOT NULL DEFAULT &lt;span&gt;&#x27;0.00&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`create_time`&lt;/span&gt; datetime DEFAULT now(),&lt;br/&gt;  &lt;span&gt;`update_time`&lt;/span&gt; datetime DEFAULT now()&lt;br/&gt;);&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;我们先编写核心业务代码，调整用户的账户余额&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;saga_adjust_balance&lt;/span&gt;&lt;span&gt;(cursor, uid, amount)&lt;/span&gt;:&lt;br/&gt;  affected = utils.sqlexec(cursor, &lt;span&gt;&quot;update dtm_busi.user_account set balance=balance+%d where user_id=%d and balance &amp;gt;= -%d&quot;&lt;/span&gt; %(amount, uid, amount))&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; affected == &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;raise&lt;/span&gt; Exception(&lt;span&gt;&quot;update error, balance not enough&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;下面我们来编写具体的正向操作 /补偿操作的处理函数&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@app.post(&quot;/api/TransOutSaga&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;trans_out_saga&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;br/&gt;  saga_adjust_balance(c, out_uid, &lt;span&gt;-30&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;span&gt;&quot;dtm_result&quot;&lt;/span&gt;: &lt;span&gt;&quot;SUCCESS&quot;&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@app.post(&quot;/api/TransOutCompensate&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;trans_out_compensate&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;br/&gt;  saga_adjust_balance(c, out_uid, &lt;span&gt;30&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;span&gt;&quot;dtm_result&quot;&lt;/span&gt;: &lt;span&gt;&quot;SUCCESS&quot;&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@app.post(&quot;/api/TransInSaga&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;trans_in_saga&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;br/&gt;  saga_adjust_balance(c, in_uid, &lt;span&gt;30&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;span&gt;&quot;dtm_result&quot;&lt;/span&gt;: &lt;span&gt;&quot;SUCCESS&quot;&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@app.post(&quot;/api/TransInCompensate&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;trans_in_compensate&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;br/&gt;  saga_adjust_balance(c, in_uid, &lt;span&gt;-30&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;span&gt;&quot;dtm_result&quot;&lt;/span&gt;: &lt;span&gt;&quot;SUCCESS&quot;&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;到此各个子事务的处理函数已经 OK 了，然后是开启 SAGA 事务，进行分支调用&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# 这是 dtm 服务地址&lt;/span&gt;&lt;br/&gt;dtm = &lt;span&gt;&quot;http://localhost:8080/api/dtmsvr&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 这是业务微服务地址&lt;/span&gt;&lt;br/&gt;svc = &lt;span&gt;&quot;http://localhost:5000/api&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    req = {&lt;span&gt;&quot;amount&quot;&lt;/span&gt;: &lt;span&gt;30&lt;/span&gt;}&lt;br/&gt;    s = saga.Saga(dtm, utils.gen_gid(dtm))&lt;br/&gt;    s.add(req, svc + &lt;span&gt;&quot;/TransOutSaga&quot;&lt;/span&gt;, svc + &lt;span&gt;&quot;/TransOutCompensate&quot;&lt;/span&gt;)&lt;br/&gt;    s.add(req, svc + &lt;span&gt;&quot;/TransInSaga&quot;&lt;/span&gt;, svc + &lt;span&gt;&quot;/TransInCompensate&quot;&lt;/span&gt;)&lt;br/&gt;    s.submit()&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;至此，一个完整的 SAGA 分布式事务编写完成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果您想要完整运行一个成功的示例，那么参考这个例子yedf/dtmcli-py-sample，将它运行起来非常简单&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# 部署启动 dtm&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 需要 docker 版本 18 以上&lt;/span&gt;&lt;br/&gt;git &lt;span&gt;clone&lt;/span&gt; https://github.com/yedf/dtm&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; dtm&lt;br/&gt;docker-compose up&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 另起一个命令行&lt;/span&gt;&lt;br/&gt;git &lt;span&gt;clone&lt;/span&gt; https://github.com/yedf/dtmcli-py-sample&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; dtmcli-py-sample&lt;br/&gt;pip3 install flask dtmcli requests&lt;br/&gt;flask run&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 另起一个命令行&lt;/span&gt;&lt;br/&gt;curl localhost:5000/api/fireSaga&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;处理网络异常&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;假设提交给 dtm 的事务中，调用转入操作时，出现短暂的故障怎么办？按照 SAGA 事务的协议，dtm 会重试未完成的操作，这时我们要如何处理？故障有可能是转入操作完成后出网络故障，也有可能是转入操作完成中出现机器宕机。如何处理才能够保障账户余额的调整是正确无问题的？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这类网络异常的妥当处理，是分布式事务中的大难题，异常情况包括三类：重复请求、空补偿、悬挂，都需要正确处理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DTM 提供了子事务屏障功能，保证上述异常情况下的业务逻辑，只会有一次正确顺序下的成功提交。（子事务屏障详情参考分布式事务最经典的七种解决方案的子事务屏障环节）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们把处理函数调整为：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@app.post(&quot;/api/TransOutSaga&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;trans_out_saga&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;with&lt;/span&gt; barrier.AutoCursor(conn_new()) &lt;span&gt;as&lt;/span&gt; cursor:&lt;br/&gt;    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;busi_callback&lt;/span&gt;&lt;span&gt;(c)&lt;/span&gt;:&lt;br/&gt;      saga_adjust_balance(c, out_uid, &lt;span&gt;-30&lt;/span&gt;)&lt;br/&gt;    barrier_from_req(request).call(cursor, busi_callback)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;span&gt;&quot;dtm_result&quot;&lt;/span&gt;: &lt;span&gt;&quot;SUCCESS&quot;&lt;/span&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;这里的 barrier_from_req(request).call(cursor, busi_callback)调用会使用子事务屏障技术，保证 busi_callback 回调函数仅被提交一次&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;您可以尝试多次调用这个 TransIn 服务，仅有一次余额调整。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;处理回滚&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;假如银行将金额准备转入用户 2 时，发现用户 2 的账户异常，返回失败，会怎么样？我们调整处理函数，让转入操作返回失败&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@app.post(&quot;/api/TransInSaga&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;trans_in_saga&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;span&gt;&quot;dtm_result&quot;&lt;/span&gt;: &lt;span&gt;&quot;FAILURE&quot;&lt;/span&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;我们给出事务失败交互的时序图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9514237855946399&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9m9OfQX94VtmicKKfY1TghX3qLX9OrR6YncG3HWV2EseElpJTqCDlDlibr0D9l8efuvZbHQXibDXEB6sZ0yt8GwBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1194&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里有一点，TransIn 的正向操作什么都没有做，就返回了失败，此时调用 TransIn 的补偿操作，会不会导致反向调整出错了呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不用担心，前面的子事务屏障技术，能够保证 TransIn 的错误如果发生在提交之前，则补偿为空操作；TransIn 的错误如果发生在提交之后，则补偿操作会将数据提交一次。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;您可以将返回错误的 TransIn 改成：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@app.post(&quot;/api/TransInSaga&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;trans_in_saga&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;with&lt;/span&gt; barrier.AutoCursor(conn_new()) &lt;span&gt;as&lt;/span&gt; cursor:&lt;br/&gt;    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;busi_callback&lt;/span&gt;&lt;span&gt;(c)&lt;/span&gt;:&lt;br/&gt;      saga_adjust_balance(c, in_uid, &lt;span&gt;30&lt;/span&gt;)&lt;br/&gt;    barrier_from_req(request).call(cursor, busi_callback)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;span&gt;&quot;dtm_result&quot;&lt;/span&gt;: &lt;span&gt;&quot;FAILURE&quot;&lt;/span&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;最后的结果余额依旧会是对的，原理可以参考：分布式事务最经典的七种解决方案的子事务屏障环节&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;在这篇文章里，我们介绍了 SAGA 的理论知识，也通过一个例子，完整给出了编写一个 SAGA 事务的过程，涵盖了正常成功完成，异常情况，以及成功回滚的情况。相信读者通过这边文章，对 SAGA 已经有了深入的理解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;文中使用的 dtm 是新开源的 Golang 分布式事务管理框架，功能强大，支持 TCC 、SAGA 、XA 、事务消息等事务模式，支持 Go 、python 、PHP 、node 、csharp 等语言的。同时提供了非常简单易用的接口。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;阅读完此篇干货，欢迎大家访问项目https://github.com/yedf/dtm，给颗星星支持！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击左下角的“阅读原文”，可以直接访问项目&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>59d12297ad701a713e907b604e9179fd</guid>
<title>理解 Java 中对象基础 Object 类</title>
<link>https://toutiao.io/k/oqq4xnq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; role=&quot;option&quot; title=&quot;链接&quot; class=&quot;article-tag__list single-tag__wrp js_single&quot; data-len=&quot;1&quot;&gt;
                                            
                                                                                    &lt;span class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4Njg0MzYwNw==&amp;amp;action=getalbum&amp;amp;album_id=1342230680016683009#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;1342230680016683009&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;#&lt;/span&gt;Java编程基础系列&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span class=&quot;article-tag-card__right&quot;&gt;&lt;span class=&quot;weui-hidden_abs&quot;&gt;,&lt;/span&gt;29个&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h1&gt;&lt;span&gt;一、Object简述&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;源码注释：Object类是所有类层级关系的Root节点，作为所有类的超类，包括数组也实现了该类的方法，注意这里说的很明确，指类层面。&lt;/p&gt;&lt;p&gt;所以在Java中有一句常说的话，一切皆对象，这话并不离谱。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1、显式扩展&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;结论验证&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;既然Object作为所有类的父级别的类，则不需要在显式的添加继承关系，&lt;code&gt;Each01&lt;/code&gt;编译期就会提示移除冗余。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Each01&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;new&lt;/span&gt; Each01().hashCode()+&lt;span&gt;&quot;;&quot;&lt;/span&gt;+&lt;span&gt;new&lt;/span&gt; ObjEa02().hashCode());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ObjEa02&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ObjEa03&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ObjEa02&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里&lt;code&gt;Each01&lt;/code&gt;与&lt;code&gt;ObjEa02&lt;/code&gt;对象实例都有Object类中的&lt;code&gt;hashCode&lt;/code&gt;方法，这里对既有结论的验证。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;编译文件&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;再从JVM编译层面看下字节码文件，是如何加载，使用&lt;code&gt;javap -c&lt;/code&gt;命令查看编译后的文件，注意Jdk版本&lt;code&gt;1.8&lt;/code&gt;；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;javap -c Each01.class&lt;br/&gt;Compiled from &lt;span&gt;&quot;Each01.java&quot;&lt;/span&gt;&lt;br/&gt;public class com.base.object.each.Each01 {&lt;br/&gt;  public com.base.object.each.Each01();&lt;br/&gt;    Code:&lt;br/&gt;       0: aload_0&lt;br/&gt;       1: invokespecial &lt;span&gt;#1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V&lt;/span&gt;&lt;br/&gt;       4: &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;javap -c ObjEa02.class &lt;br/&gt;Compiled from &lt;span&gt;&quot;Each01.java&quot;&lt;/span&gt;&lt;br/&gt;class com.base.object.each.ObjEa02 {&lt;br/&gt;  com.base.object.each.ObjEa02();&lt;br/&gt;    Code:&lt;br/&gt;       0: aload_0&lt;br/&gt;       1: invokespecial &lt;span&gt;#1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V&lt;/span&gt;&lt;br/&gt;       4: &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;javap -c ObjEa03.class &lt;br/&gt;Compiled from &lt;span&gt;&quot;Each01.java&quot;&lt;/span&gt;&lt;br/&gt;class com.base.object.each.ObjEa03 extends com.base.object.each.ObjEa02 {&lt;br/&gt;  com.base.object.each.ObjEa03();&lt;br/&gt;    Code:&lt;br/&gt;       0: aload_0&lt;br/&gt;       1: invokespecial &lt;span&gt;#1 // Method com/base/object/each/ObjEa02.&quot;&amp;lt;init&amp;gt;&quot;:()V&lt;/span&gt;&lt;br/&gt;       4: &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;invokespecial命令&lt;/strong&gt;：可以查看Jvm的官方文档中的指令说明，调用实例化方法，和父类的初始化方法调用等，这里通过三个类的层级关系，再次说明Object超类不需要显式继承，即使显式声明但编译后源码依旧会清除冗余。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、引用与对象&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通常把下面过程称为：创建一个object对象；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Object object = &lt;span&gt;new&lt;/span&gt; Object() ;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;细节描述：声明对象引用&lt;code&gt;object&lt;/code&gt;；通过&lt;code&gt;new&lt;/code&gt;关键字创建对象并基于默认构造方法初始化；将对象引用&lt;code&gt;object&lt;/code&gt;指向创建的对象。&lt;/p&gt;&lt;p&gt;这一点可以基于Jvm运行流程去理解，所以当对象一旦失去全部引用时，会被标记为垃圾对象，在垃圾收集器运行时清理。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;接受任意数据类型对象的引用&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;既然Object作为Java中所有对象的超类，则根据继承关系的特点，以及向上转型机制，Object可以接受任意数据类型对象的引用，例如在集合容器或者传参过程，不确定对象类型时可以使用Object：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Each02&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 向上转型&lt;/span&gt;&lt;br/&gt;        Object obj01 = &lt;span&gt;new&lt;/span&gt; Each02Obj01(&lt;span&gt;&quot;java&quot;&lt;/span&gt;) ;&lt;br/&gt;        System.out.println(obj01);&lt;br/&gt;        &lt;span&gt;// 向下转型&lt;/span&gt;&lt;br/&gt;        Each02Obj01 each02Obj01 = (Each02Obj01)obj01;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;name=&quot;&lt;/span&gt;+each02Obj01.getName());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Each02Obj01&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name ;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Each02Obj01&lt;/span&gt;&lt;span&gt;(String name)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;this&lt;/span&gt;.name = name; }&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Each02Obj01{&quot;&lt;/span&gt; +&lt;span&gt;&quot;name=&#x27;&quot;&lt;/span&gt; + name +&lt;span&gt;&#x27;}&#x27;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getName&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; name; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里要强调一下这个向上转型的过程：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Object obj01 = &lt;span&gt;new&lt;/span&gt; Each02Obj01(&lt;span&gt;&quot;java&quot;&lt;/span&gt;) ;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过上面流程分析，这里创建一个父类引用&lt;code&gt;obj01&lt;/code&gt;，并指向子类&lt;code&gt;Each02Obj01&lt;/code&gt;对象，所以在输出的时候，调用的是子类的&lt;code&gt;toString&lt;/code&gt;方法。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、基础方法&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、getClass&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在程序运行时获取对象的实例类，进而可以获取详细的结构信息并进行操作：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; Class&amp;lt;?&amp;gt; getClass();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该方法在泛型，反射，动态代理等机制中有很多场景应用。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、toString&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;返回对象的字符串描述形式，Object提供的是类名与无符号十六进制的哈希值组合表示，为了能返回一个信息明确的字符串，子类通常会覆盖该方法：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; getClass().getName()+&lt;span&gt;&quot;@&quot;&lt;/span&gt;+Integer.toHexString(hashCode());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在Java中，打印对象的时候，会执行&lt;code&gt;String.valueOf&lt;/code&gt;转换为字符串，该方法的底层依旧是对象的&lt;code&gt;toString&lt;/code&gt;方法：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;println&lt;/span&gt;&lt;span&gt;(Object x)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    String s = String.valueOf(x);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String &lt;span&gt;valueOf&lt;/span&gt;&lt;span&gt;(Object obj)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (obj == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;&quot;null&quot;&lt;/span&gt; : obj.toString();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;3、equals与hashCode&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;equals：判断两个对象是否相等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;hashCode：返回对象的哈希码值；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;hashCode&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;equals&lt;/span&gt;&lt;span&gt;(Object obj)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt; == obj);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;equals&lt;/code&gt;判断方法需要考量实际的场景与策略，例如常见的公民注册后分配的身份ID是不能修改的，但是名字可以修改，那么就可能存在这样的场景：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;EachUser eachUser01 = &lt;span&gt;new&lt;/span&gt; EachUser(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;&quot;A&quot;&lt;/span&gt;) ;&lt;br/&gt;EachUser eachUser02 = &lt;span&gt;new&lt;/span&gt; EachUser(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;&quot;B&quot;&lt;/span&gt;) ;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;EachUser&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer cardId ;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从程序本身看，这确实是创建两个对象，但是放在场景下，这的确是描述同一个人，所以这时候可以在&lt;code&gt;equals&lt;/code&gt;方法中定义比较规则，如果ID相同则视为同一个对象：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;equals&lt;/span&gt;&lt;span&gt;(Object obj)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (obj != &lt;span&gt;null&lt;/span&gt;){&lt;br/&gt;        EachUser compareObj = (EachUser)obj ;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.cardId.intValue()==compareObj.cardId ;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Boolean.FALSE ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里还要注意值类型和引用类型的区别，如果出现&lt;code&gt;null&lt;/code&gt;比较情况，要返回false。&lt;/p&gt;&lt;p&gt;通常在子类中会同时覆盖这两个方法，这样做法在集合容器的设计上已经体现的淋漓尽致。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4、thread相关&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;wait：线程进入waiting等待状态，不会争抢锁对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;notify：随机通知一个在该对象上等待的线程；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;notifyAll：唤醒在该对象上所有等待的线程；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;wait&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; timeout)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;notify&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;notifyAll&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意这里：&lt;code&gt;native&lt;/code&gt;关键字修饰的方法，即调用的是原生函数，也就是常说的基于C/C++实现的本地方法，以此提高和系统层面的交互效率降低交互复杂程度。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;5、clone&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;返回当前对象的拷贝：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; Object &lt;span&gt;clone&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; CloneNotSupportedException&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关于该方法的细节规则极度复杂，要注意下面几个核心点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对象必须实现Cloneable接口才可以被克隆；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据类型：值类型，String类型，引用类型；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;深浅拷贝的区别和与之对应的实现流程；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在复杂的包装类型中，组合的不同变量类型；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;6、finalize&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当垃圾收集器确认该对象上没有引用时，会调用finalize方法，即清理内存释放资源：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;finalize&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{ }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通常子类不会覆盖该方法，除非在子类中有一些其他必要的资源清理动作。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、生命周期&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、作用域&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在下面main方法执行结束之后，无法再访问&lt;code&gt;Each05Obj01&lt;/code&gt;的实例对象，因为对象的引用&lt;code&gt;each05&lt;/code&gt;丢失：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Each05&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Each05Obj01 each05 = &lt;span&gt;new&lt;/span&gt; Each05Obj01 (&lt;span&gt;99&lt;/span&gt;) ;&lt;br/&gt;        System.out.println(each05);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里就会存在一个问题，引用丢失导致对象无法访问，但是对象在此时可能还是存在的，并没有释放内存的占用。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、垃圾回收机制&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Java通过new创建的对象会在堆中开辟内存空间存储，当对象失去所有引用时会被标记为垃圾对象，进而被回收；&lt;/p&gt;&lt;p&gt;这里涉及下面几个关键点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Jvm中垃圾收集器会监控创建的对象 ；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当判断对象不存在引用时，会执行清理动作；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;完成对象清理后会重新整理内存空间；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这里存在一个很难理解的概念，即&lt;strong&gt;对象不存在引用的判断&lt;/strong&gt;，也就是常说的&lt;strong&gt;可达性分析算法&lt;/strong&gt;：基于对象到根对象的引用链是否可达来判断对象是否可以被回收；GC-Roots根引用集合，也可以变相理解为存活对象的集合。(详见JVM系列)&lt;/p&gt;&lt;p&gt;通过Object对象的分析，结合Java方方面面的机制和设计，可以去意会一些所谓的编程思想。&lt;/p&gt;&lt;p&gt;&lt;span&gt;同系列&lt;/span&gt;： &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4Njg0MzYwNw==&amp;amp;mid=2247485361&amp;amp;idx=1&amp;amp;sn=02df70811415c226e59d85c3b525ee04&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;List分析&lt;/a&gt; | &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4Njg0MzYwNw==&amp;amp;mid=2247485374&amp;amp;idx=1&amp;amp;sn=2371c8682f059031b6ffd23c5c412202&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Map分析&lt;/a&gt; | &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4Njg0MzYwNw==&amp;amp;mid=2247485441&amp;amp;idx=1&amp;amp;sn=108c562fea4866828059aadfc9225969&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;IO流核心&lt;/a&gt; | &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4Njg0MzYwNw==&amp;amp;mid=2247485423&amp;amp;idx=1&amp;amp;sn=184ff3fd0e4f19db54e1487a076fd9df&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;动态代理&lt;/a&gt; | &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4Njg0MzYwNw==&amp;amp;mid=2247485449&amp;amp;idx=1&amp;amp;sn=adc58b6641d8cd486f05b8aa3904ce65&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;面向对象&lt;/a&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、源代码地址&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;GitEE·地址&lt;br/&gt;https://gitee.com/cicadasmile/java-base-parent&lt;br/&gt;Wiki·地址&lt;br/&gt;https://gitee.com/cicadasmile/butte-java-note/wikis&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4Njg0MzYwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBCuF3zfJnqPKpUia4wfn1FUtTHpxxkR5HvbicPgOjibPicX0goMOkny1NdkLAJvBaqrYh3UdwMjiaDQMA/0?wx_fmt=png&quot; data-nickname=&quot;知了一笑&quot; data-alias=&quot;cicada_smile&quot; data-signature=&quot;积累是一个孤独且枯燥的过程&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6c0ee13bec73862989e38b91a997e2f0</guid>
<title>服务运行过程中磁盘坏道引起的思考</title>
<link>https://toutiao.io/k/jmqq86o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;同事发现一个有重要服务在运行的物理机上，一个目录&lt;span&gt;虽&lt;/span&gt;&lt;span&gt;然&lt;/span&gt;&lt;span&gt;够用，&lt;/span&gt;但是比另一台同样服务的机器相比，空间很小。我们还是跟SA沟通了此事。最终SA跟厂商确认是因为磁盘有坏道引起。因为我们磁盘阵列采用的是RAID1模式，所以并不影响服务运行，但是为了保证服务的稳定性，我们还是决定对磁盘进行修复。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;结果呢，在约好的时间点，大家按照操作流程很轻松的修复了。但是前期我们做了很多工作。如果实际操作的时候并不轻松，而是突然出现了意外的情况或者没有考虑到的步骤，虽然最终结果是有惊无险，那也说明我们的前期准备是非常失败的。如果是一次飞机飞行，那就是在拿着生命开玩笑了。而轻松完成也只是入门等级，整个过程，我给自己打60分。&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;涉及的一些基本硬件知识&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;RAID&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;RAID是磁盘阵列，常用的模式有RAID0、RAID1、RAID5、RAID6、RAID10（这里读RAID一零）。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;RAID0是机器使用两块硬盘，写文件的时候，采用分片模式，就是把文件拆成均等的两块，同时写入，这样速度比使用一块硬盘提高一倍。可用容量为硬盘容量之和。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;RAID1是机器使用两块硬盘，写文件的时候，采用镜像模式，就是把文件写入一块硬盘，之后再复制一份到另一块硬盘。这样速度和一块硬盘基本相同，两块硬盘容量其实只能用一半。但是通过冗余进行容灾，可以允许一块硬盘损坏，不影响服务的运行。我们这次就是这种情况。&lt;/section&gt;&lt;p&gt;RAID5又称为分布式磁盘，是兼顾容量、速度和容灾的一个方案。至少要有3块硬盘组成，采用单校验机制(XOR校验)。原数据和校验数据会分开均匀保存到各块磁盘上。可允许一块硬盘损坏。举个例子，我有一段数据要保存，内容是：&lt;/p&gt;&lt;p&gt;&lt;span&gt;1 2 3 4 5 6  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;则：&lt;/p&gt;&lt;section&gt;RAID6是在RAID5的基础上又增加一种校验方式，至少要有4块盘，从而可以允许两块硬盘损坏。由于复杂度高，功能比不高，所以一般RAID10或者RAID01这样的组合模式更常用。&lt;/section&gt;&lt;section&gt;RAID10是组合RAID1和RAID0，用4块硬盘。数据有一块盘做镜像模式，一块盘做分片模式，虽然容量还是只有一半，但是速度提高了一倍，也可以容灾。&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;rebuild&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;采用RAID1模式，一块硬盘损坏，要更换可以采用热插拔，之后会执行2到3小时的rebuild操作。rebuild过程重要做：磁盘检查和数据复制两件事情。&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.5706214689265536&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlib4hNibbAMK8XYKAOAibmZVrgm8rPOT8icOpHyQc7Eh23NzcAzRjyQskECqD5mQAJ9BqmrQpdvZOJcNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;354&quot;/&gt;&lt;/p&gt;&lt;section&gt;根据不同的硬件型号，rebuild过程中会有指示灯显示磁盘状态。比如有的rebuild过程中显示黄色，完成后显示绿色，代表状态是online。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;rebuild过程实际不影响服务运行，但是这个过程中读写硬盘会比较频繁，通常建议隔离业务。&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;事件处理过程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;事件处理开始，我们看到的现象就是根目录的空间很小，其他目录都是好几百G，这个目录只有十几G。经过层层追问，最终和厂商一起查出是磁盘坏道引起。SA希望我们把业务隔离1天。而这个服务比较特殊，受外部制约，使用了一个十几年前架构的闭源MQ。我们只有两机房部署，每个机房都是单机运行，其他备份都是冷备。所以整体而言，磁盘修复过程中是单机运行的。所以我们和SA沟通，尽量缩短修复时间。最终我们的整个包含隔离和恢复业务耗时缩短为7个小时。&lt;/section&gt;&lt;section&gt;做好准备之后，我们把整个处理过程整理成完整的时序；设计好异常处理流程；为了应对磁盘修复不好这种场景，我们制定了磁盘回退的异常处理；为了应对不但磁盘没有修好，反而整个物理机不能用的场景，我们制定了不得已启用冷备机器的异常处理，这个处理需要进行网络变更，流程复杂，所以更要提前沟通好；然后我们统计好处理当天的业务量，估算好最坏影响时的影响的交易；还带上厂商的分析等数据。总共打印出四张纸，我带着去找领导汇报。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;结果领导的两个问题，证明我没有把事情彻底搞清楚。一个是每个机房真的只能一台机器运行吗？因为用的MQ是闭源的，对接方也不清楚到底是为什么只能一台机器运行。确认的事情是对接方一个机房只给了一个IP，之前也咨询过网络，是否可以使用虚拟IP。网络说不可以，但是具体的理由说的不是很清楚。另外一个说RAID1应该是热插拔的，应该是插上就能用。&lt;span&gt;建议说是否rebuild过程中就灰度一点点流量进来。这样主要目的是如果另外一台机器故障，流量可以自动全切到这个机房，达到容灾的目的。领导还强调了一个关键词：概率。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;带着这个问题，我又和同事调研了一下。同事调研到不能用VIP的根本原因是通道消息序列号问题。通道消息序列号是内存计算的，每发送或收到一条消息，消息序列号自动加1.通道两端的序列号相差大于1，通道的状态则从running变成fail。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;另外一件事是概率的问题：我们认为单机运行7个小时是没有问题的，是因为按照之前的运行情况，这7个小时发生事情的概率很小。所以我们认为这7个小时过程中完全隔离业务是无损的方案。实际情况是没有发生问题是概率性的，不是确定的。而事情上rebuild过程中发生问题的概率也很低。SA制定的流程是从修复过程不出问题出发，因为他们做的是IAAS层的工作。而我们作为SAAS层，应该从整体对业务影响角度出发。领导还提了一个问题：7个小时能确保人会一点不走神的在那里盯着吗？如果另一台服务器一旦出现故障，从发现到处理，中间处理时间会很长。因为手动处理是需要沟通，并且操作要走审批。恢复不会很快。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;针对这个问题，我让同事在修复开始前，调整告警调整阈值，一笔失败或者超时则短信告警。同时，我们又反思了在制定时序时的目标设定：无损交易下进行修复。但是没有仔细考虑一旦单机运行时，运行机器发生问题时，必然交易损失，要手动来启用EOP，那就是故障。而只是在硬盘插拔时隔离流量，rebuild过程手动验证服务正常之后，切一点点流量，实际也是无损的，而且很可能rebuild过程中，一点正式流量都不会达到这台rebuild中的机器。只是一旦另一台机器出现问题，服务可以自动走这台机器，不会造成故障(实际还有别的因素，实际自动容灾行不通，这里说明避免给我们自己的同事造成误导，不影响对问题的说明)。所以我们最终决定rebuild过程中切一点点流量，实际证明确实是无损的。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;总结思考&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;实际操作是整个处理过程的冰山一角，有惊无险就已经输了。&lt;/section&gt;&lt;section&gt;一次把所有事情做对是最高效的。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;再早几年的时候，我发现自己会经常想出来一些生活中的句子，觉得不亚于电影里的经典台词。而在工作中，我经常需要发表一些自己的论点或者总结思考。而这时候，我总觉得自己说的是陈词滥调。我总结了原因，从记事起，为生活思考是一种习惯，当我晚上在校园里一圈圈的走，当我坐车上，在车窗的玻璃哈气上涂鸦，我都在思考。而自己为工作又思考了多少，思考了多久。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;大学的时候，有个韩剧叫《黄真伊》，女主说：“艺术最需要的是痛苦。&lt;span&gt;”&lt;/span&gt;从方法学的角度，痛苦起的作用是触发人的深度思考。所谓兴趣是最好的老师原理也是因为有兴趣所以自然而然的会多为此思考。而现在我在事情的处理过程中思考还远远不够。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1b1a6d449be7ac7487634e54e8818621</guid>
<title>实现 LRU 缓存机制</title>
<link>https://toutiao.io/k/3kvcfbi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;LRU&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;LRU&lt;/code&gt;, Least Recently Used，即最近最少使用，当容量不足时，优先淘汰最久未使用的数据。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;核心方法&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用一个队列来存储数据，最近使用的数据存在队尾，最久未使用的数据存在队首。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1、get (key)&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当对某个 &lt;code&gt;key&lt;/code&gt; 进行访问时，将数据移至队尾。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2、put (key, value)&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当添加一个元素时&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果 &lt;code&gt;key&lt;/code&gt; 存在，则覆盖 &lt;code&gt;value&lt;/code&gt; ，并将数据移至队尾&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 &lt;code&gt;key&lt;/code&gt; 不存在，则直接插入到队尾&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果容量不足时，则删除队首的数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实现方法&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实现方法1，双链表 + 哈希表&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class LruCache {&lt;br/&gt;&lt;br/&gt;    private HashMap&amp;lt;Integer, Node&amp;gt; map;&lt;br/&gt;&lt;br/&gt;    private DoubleList cache;&lt;br/&gt;&lt;br/&gt;    private final int &lt;span&gt;cap&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    public LruCache(int &lt;span&gt;cap&lt;/span&gt;) {&lt;br/&gt;        this.map = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;        this.cache = new DoubleList();&lt;br/&gt;        this.cap = &lt;span&gt;cap&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public int get(int key) {&lt;br/&gt;        Node node = map.get(key);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (node == null) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; -1;&lt;br/&gt;        }&lt;br/&gt;        // 将元素移至队尾&lt;br/&gt;        makeRecently(key);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; node.val;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public void put(int key, int value) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (map.containsKey(key)) {&lt;br/&gt;            //先删除，再添加&lt;br/&gt;            deleteKey(key);&lt;br/&gt;            addRecently(key, value);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        //如果达到容量最大值，则删除队首元素&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (cache.size() == &lt;span&gt;cap&lt;/span&gt;) {&lt;br/&gt;            removeLatestRecently();&lt;br/&gt;        }&lt;br/&gt;        addRecently(key, value);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    private void makeRecently(int key) {&lt;br/&gt;        Node node = map.get(key);&lt;br/&gt;        //删除当前元素&lt;br/&gt;        cache.remove(node);&lt;br/&gt;        //将元素加至队尾&lt;br/&gt;        cache.addLast(node);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 新增一个元素，加至队尾&lt;br/&gt;     */&lt;br/&gt;    private void addRecently(int key, int value) {&lt;br/&gt;        Node node = new Node(key, value);&lt;br/&gt;        map.put(key, node);&lt;br/&gt;        cache.addLast(node);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    private void deleteKey(int key) {&lt;br/&gt;        Node node = map.get(key);&lt;br/&gt;        map.remove(key);&lt;br/&gt;        cache.remove(node);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    private void &lt;span&gt;&lt;span&gt;removeLatestRecently&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        Node node = cache.removeFirst();&lt;br/&gt;        map.remove(node.key);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;class DoubleList {&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 两个首位虚节点&lt;br/&gt;     */&lt;br/&gt;    Node head, tail;&lt;br/&gt;&lt;br/&gt;    int size;&lt;br/&gt;&lt;br/&gt;    public &lt;span&gt;&lt;span&gt;DoubleList&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        head = new Node(0, 0);&lt;br/&gt;        tail = new Node(0, 0);&lt;br/&gt;        head.next = tail;&lt;br/&gt;        tail.pre = head;&lt;br/&gt;        size = 0;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 队尾是新元素&lt;br/&gt;     */&lt;br/&gt;    public void addLast(Node node) {&lt;br/&gt;        node.next = tail;&lt;br/&gt;        node.pre = tail.pre;&lt;br/&gt;        tail.pre.next = node;&lt;br/&gt;        tail.pre = node;&lt;br/&gt;        size++;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 删除节点&lt;br/&gt;     */&lt;br/&gt;    public void remove(Node node) {&lt;br/&gt;        node.pre.next = node.next;&lt;br/&gt;        node.next.pre = node.pre;&lt;br/&gt;        size--;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 删除队首最老的元素&lt;br/&gt;     */&lt;br/&gt;    public Node &lt;span&gt;&lt;span&gt;removeFirst&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (head.next == tail) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; null;&lt;br/&gt;        }&lt;br/&gt;        Node first = head.next;&lt;br/&gt;        remove(first);&lt;br/&gt;        size--;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; first;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public int &lt;span&gt;&lt;span&gt;size&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; size;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;class Node {&lt;br/&gt;&lt;br/&gt;    int key;&lt;br/&gt;&lt;br/&gt;    int val;&lt;br/&gt;&lt;br/&gt;    Node pre;&lt;br/&gt;&lt;br/&gt;    Node next;&lt;br/&gt;&lt;br/&gt;    public Node(int key, int val) {&lt;br/&gt;        this.key = key;&lt;br/&gt;        this.val = val;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实现方法2，借助 LinkedHashMap&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class LinkedLruCache {&lt;br/&gt;&lt;br/&gt;    private LinkedHashMap&amp;lt;Integer, Integer&amp;gt; cacheMap = new LinkedHashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    private int &lt;span&gt;cap&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    public LinkedLruCache(int &lt;span&gt;cap&lt;/span&gt;) {&lt;br/&gt;        this.cap = &lt;span&gt;cap&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public int get(int key) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!cacheMap.containsKey(key)) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; -1;&lt;br/&gt;        }&lt;br/&gt;        Integer val = cacheMap.get(key);&lt;br/&gt;        //先删除，再添加&lt;br/&gt;        cacheMap.remove(key);&lt;br/&gt;        cacheMap.put(key, val);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; val;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public void put(int key, int val) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (cacheMap.containsKey(key)) {&lt;br/&gt;            //先删除，再添加&lt;br/&gt;            cacheMap.remove(key);&lt;br/&gt;            cacheMap.put(key, val);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        //达到容量后，删除第一个元素&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (cacheMap.size() == &lt;span&gt;cap&lt;/span&gt;) {&lt;br/&gt;            Integer firstKey = cacheMap.keySet().iterator().next();&lt;br/&gt;            cacheMap.remove(firstKey);&lt;br/&gt;        }&lt;br/&gt;        cacheMap.put(key, val);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实现方式3，继承 LinkedHashMap&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要设置 &lt;code&gt;accessOrder = true&lt;/code&gt;，在元素被访问后会被移至队尾。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class LinkedHashMapCache extends LinkedHashMap {&lt;br/&gt;&lt;br/&gt;    private int &lt;span&gt;cap&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    public LinkedHashMapCache(int &lt;span&gt;cap&lt;/span&gt;) {&lt;br/&gt;        super(16, 0.75f, &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;        this.cap = &lt;span&gt;cap&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    public boolean removeEldestEntry(Map.Entry eldest) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; this.cap &amp;lt; size();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LRU 算法经常被用于缓存淘汰的策略，例如 MySQL、Redis 都有用到 LRU，当我们需要自己实现一个类似缓存时，也可以采用以上的方式实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5OTk5NjkyNA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/RMOHqs13Zw3wjzRJyMM7TENNicGjdtoeFTc5tia1QBBib9j5pujtHdjmia5LHwib9Dm5sIhD70tRyecllBK65hWcD7w/0?wx_fmt=png&quot; data-nickname=&quot;郭儿的跋涉&quot; data-alias=&quot;WE_LINE&quot; data-signature=&quot;30岁的郭儿的跋涉。&quot; data-from=&quot;1&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b98e79241a965fcfda56501c922d5d59</guid>
<title>亿级流量治理系列：常用的限流算法有哪些？</title>
<link>https://toutiao.io/k/vmyvgf0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; role=&quot;option&quot; title=&quot;链接&quot; class=&quot;article-tag__list single-tag__wrp js_single&quot; data-len=&quot;1&quot;&gt;
                                            
                                                                                    &lt;span class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU5MzY4NTMwOQ==&amp;amp;action=getalbum&amp;amp;album_id=2002502353043668996#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;2002502353043668996&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;#&lt;/span&gt;流量治理系列&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span class=&quot;article-tag-card__right&quot;&gt;&lt;span class=&quot;weui-hidden_abs&quot;&gt;,&lt;/span&gt;2个&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;点击上方蓝字“设为星标”&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU5MzY4NTMwOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/JReUsicfmEPZJL75J8t2KRIBkH377m1xmSasTiaZkbH1ALNn1tSgbMVyY7KnTpGO9A0Bnzh8IOYhmckmib9U5SgpQ/0?wx_fmt=png&quot; data-nickname=&quot;架构摆渡人&quot; data-alias=&quot;jiagoubaiduren&quot; data-signature=&quot;架构摆渡人，助你通往架构师方向的领路人。本号会定期分享架构相关的文章，专注于架构方向，关注我们，下一个架构师就是你。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5714285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/5mcydv0qFicXzFsgOt7fWRZ6jAeG9zhzouNZNH0VxZKHibuVlq9U111AVmg9d4fDy86NhewMnfrSCKf3ia0EBf0zA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;42&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;前言&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上篇文章&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU5MzY4NTMwOQ==&amp;amp;mid=2247485271&amp;amp;idx=1&amp;amp;sn=cd0e67ebe92b534dcc9635fc1c6fcc54&amp;amp;chksm=fe0df905c97a701305c885f8f5b15bc03efbff3bedc4322dc53d9f49a796035481ffee12af16&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《为什么大公司都要做流量治理？》&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《为什么大公司都要做流量治理？》&lt;/a&gt;跟大家聊了下做流量治理的真正目的是什么。如果你要开发一个流量治理的平台或者一个限流的框架，那么必不可少的就是要选择一种合适的限流算法。本篇文章就跟大家聊聊目前常用的限流算法有哪些。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5714285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/5mcydv0qFicXzFsgOt7fWRZ6jAeG9zhzouNZNH0VxZKHibuVlq9U111AVmg9d4fDy86NhewMnfrSCKf3ia0EBf0zA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;42&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;计数器&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;计数器是最简单，最直接明了的限流算法。说白了就是进行数字累加操作，也就是count++ 这你总能看懂吧！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;单机限流可以直接使用LongAdder或者&lt;span&gt;AtomicLong这些原子类进行计数操作即可。用&lt;/span&gt;Semaphore也可以，Semaphore内部本身就是计数器的方式实现。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;集群限流可以使用Redis的incr进行计数累加即可，用其他的存储也可以，核心就是要有集中存储计数的地方。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;计数器算法也分为两种形式，一种是有时间段的限制，另一种是没有时间段的限制。&lt;/span&gt;&lt;/section&gt;&lt;p line=&quot;faJw&quot;&gt; &lt;/p&gt;&lt;h2 data-foldable-wrapper=&quot;&quot;&gt;&lt;section&gt;&lt;section data-mpa-template=&quot;t&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有时间段限制&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h2&gt;&lt;p line=&quot;fOaR&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有时间段限制就是你限流的时长是多少，一般我们都会以秒为单位。比如限制QPS为1000。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有时间限制会存在一个临界区的问题，假设第1秒中的第999毫秒的时候，来了800个请求，这个时候是没有超过1000 QPS的限制。然后第2秒的1毫秒来了800个请求，相隔几毫秒，很有可能前面的请求还没执行完成，这么又来了，其实这个时候的请求已经超出了你系统能够承受的范围了，也就失去了限流的效果。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;F5IH&quot;&gt; &lt;/p&gt;&lt;p line=&quot;Ilk5&quot;&gt;&lt;img data-ratio=&quot;0.546031746031746&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JReUsicfmEPZBu30Vj1N8hKGKjUSOSXw6iavK1bibksMtaRkENiccViaKxMibGw6Hudk8WFw5shH9Wgsksk8ianib3EgOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1260&quot;/&gt;&lt;/p&gt;&lt;p line=&quot;UrOp&quot;&gt; &lt;/p&gt;&lt;p line=&quot;hEXk&quot;&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;如果非得要用有时间限制的计数器算法，那么可以将时间单位调的越小越好。当然还有其他的算法能够解决这个临界区的问题，下面会介绍到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-foldable-wrapper=&quot;&quot;&gt;&lt;section&gt;&lt;section data-mpa-template=&quot;t&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;无时间段限制&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;无时间段限制就不会存在临界区的问题，请求进来数量加一，请求结束数量减一。将并发量最高永远限制在你想要的范围内。跟Semaphore是一样的作用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个其实跟我们去饭店吃饭一样，饭店总共10个座位，坐满了你就得在外面等着叫号。如果有客人吃完离开了，空了一个座位出来，下一个客人才能进去。这样就能永远保证进去的人不超过饭店的座位数量，也在厨师和服务员能够服务的范围之内。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;4c1b&quot;&gt; &lt;/p&gt;&lt;section&gt;&lt;span&gt;伪代码示列：&lt;/span&gt;&lt;/section&gt;&lt;p line=&quot;rDw6&quot;&gt; &lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@Slf4j&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class RatelimitFilter implements Filter {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    private AtomicLong atomicLong = new AtomicLong();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        HttpServletRequest request = (HttpServletRequest)servletRequest;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        try {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            long currentQps = atomicLong.incrementAndGet();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            log.info(&quot;当前QPS: {}&quot;, currentQps);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            if (currentQps &amp;gt; 1) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                throw new RuntimeException(&quot;限流中。。。。&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            try {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                // 模拟业务耗时&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                TimeUnit.SECONDS.sleep(2);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            } catch (InterruptedException e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                e.printStackTrace();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } finally {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            atomicLong.decrementAndGet();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p line=&quot;WSbr&quot;&gt; &lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5714285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/5mcydv0qFicXzFsgOt7fWRZ6jAeG9zhzouNZNH0VxZKHibuVlq9U111AVmg9d4fDy86NhewMnfrSCKf3ia0EBf0zA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;42&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;滑动窗口&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;了解滑动窗口前先需要了解下固定窗口，固定窗口比较简单，也就相当于固定大小。比如限制1秒内的访问次数，那么这个1秒就是一个固定的时间窗口。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;oKNq&quot;&gt; &lt;/p&gt;&lt;p line=&quot;Z91B&quot;&gt;&lt;img data-ratio=&quot;0.3526570048309179&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JReUsicfmEPZBu30Vj1N8hKGKjUSOSXw6OxcUrmUefNmMYusGwZ2XKtu687Z0O0zoBaV7UD6mEvS2MDrP830WgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;滑动窗口可以将固定窗口再进行细分成多个窗口，比如将1秒中的固定窗口细分成5个窗口，那么每个窗口的时间就是200毫秒。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;GJK2&quot;&gt; &lt;/p&gt;&lt;p line=&quot;8iRB&quot;&gt;&lt;img data-ratio=&quot;0.20950965824665677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JReUsicfmEPZBu30Vj1N8hKGKjUSOSXw6uDjIy2JLeC2B0tic6jVqD08HYFicoScticqKTsKFbibe9tqpIEPyUg1ANg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1346&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设每秒钟限流100，在201ms-1000ms之间的时候来了99个请求，不满足限流条件，放行。在第2秒的100ms的时候来了999个请求，这个时候多余的请求会被限制。当前窗口的范围是1秒的201ms~2秒的200ms。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;nNHO&quot;&gt;&lt;img data-ratio=&quot;0.42462311557788945&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JReUsicfmEPZBu30Vj1N8hKGKjUSOSXw6Cib0NKOSbgUmhmuGpq7xduGuXAU0rWgLaFyxz8iaM9nHeSyYEUkgnbSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1592&quot;/&gt;&lt;/p&gt;&lt;p line=&quot;IJi1&quot;&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;通过滑动窗口算法，同时也能解决了上面计数算法临界区的问题。窗口是一直滑动的，计算的数量也不是固定时间内的，而是随着窗口的滑动一直在变化。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;26wD&quot;&gt; &lt;/p&gt;&lt;p line=&quot;EGgr&quot;&gt;&lt;img data-ratio=&quot;0.36442048517520215&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JReUsicfmEPZBu30Vj1N8hKGKjUSOSXw6DbJFklVzRTYcS2JjGpib1icyib6nc2VibdoxDBxPSibb1NLCsm95ia2B0D1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1855&quot;/&gt;&lt;/p&gt;&lt;p line=&quot;FQmR&quot;&gt; &lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5714285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/5mcydv0qFicXzFsgOt7fWRZ6jAeG9zhzouNZNH0VxZKHibuVlq9U111AVmg9d4fDy86NhewMnfrSCKf3ia0EBf0zA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;42&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;漏桶&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;漏桶算法能够很好的保证稳定性，可以将突发的高流量以固定的速度流出来保证稳定性。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我记得小时候，家里每年都会酿米酒，甜甜的米酒很好喝。当然我们不是来讲米酒好不好喝的问题，而是要讲解漏洞算法。那么漏桶算法跟米有又有什么联系呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;酿好的米酒会装在酒坛里面，有时候村里的其他人需要用到米酒的时候，如果自己家里没有酿的话就会去别人家买，一般都是拿一个瓶子来装，比如我们的可乐瓶子。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是可乐瓶子的入口很小，直接往里面倒酒的话很容易洒出来。这个时候就有一个装酒的漏斗，这个东西就跟我们今天要讲的漏桶一样，下面很小，上面很大。酒就相当于流量，倒入这个漏桶里面，然后会从下面很小的口流出来，这个速度是固定的，这么说相信大家一定明白了什么是漏桶算法吧。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;I5pa&quot;&gt; &lt;/p&gt;&lt;p line=&quot;77Rw&quot;&gt;&lt;img data-ratio=&quot;1.1224899598393574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JReUsicfmEPZBu30Vj1N8hKGKjUSOSXw6BOrerVrXoVbSMbdtP9IxKd54xcckXgPxp44U46OAlkxQ6vMaGBJuwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;996&quot;/&gt;&lt;/p&gt;&lt;p line=&quot;baA3&quot;&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;漏桶算法的优点是能够以固定的速率去控制流量，稳定性比较好。缺点就是无法应对突发流量的来袭，我们来分析具体的分析下这个缺点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设你的漏桶出口固定了每秒钟只能通过100个请求，如果此时有150个请求，无论你后方的系统能不能抗住这150个请求，通过漏桶算法都会将另外50个请求进行拦截，只能等前面的100个请求结束后才能继续放行剩下的50个请求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么有没有什么算法既能做流量控制，又能应对突发流量的场景呢？接下来为你介绍&lt;strong&gt;令牌桶算法&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5714285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/5mcydv0qFicXzFsgOt7fWRZ6jAeG9zhzouNZNH0VxZKHibuVlq9U111AVmg9d4fDy86NhewMnfrSCKf3ia0EBf0zA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;42&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;令牌桶&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;令牌桶算法用比较官方的术语来解释就是：一个有固定容量的桶，按一定的速度往桶里面放令牌，如果桶里面装不下令牌了就不放了。有请求进来就去桶里面获取对应的令牌，能拿到令牌就可以通过，拿不到就拒绝，也就是限流了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们还是用生活中的方式来解释下令牌桶的原理，有天你带着你的女朋友去吃自助餐，那些吃的你们可以随便拿，如果拿完了，是不是就得等待餐厅重新供应了才行，这就是限流了。同时，餐厅会定时的供应新的食物，食物供应上了，你能够拿到了那就是放行，相当于拿到了令牌。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有令牌如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;hrmr&quot;&gt;&lt;img data-ratio=&quot;0.571619812583668&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JReUsicfmEPZBu30Vj1N8hKGKjUSOSXw6LP50al4XCOo6hnmyjDrrfgjuseAvV53tov2rhMQRwcvV7TaS6MibL8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1494&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;无令牌如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;JLt2&quot;&gt;&lt;span line-inline=&quot;rYO4&quot;&gt;&lt;img data-ratio=&quot;0.571619812583668&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JReUsicfmEPZBu30Vj1N8hKGKjUSOSXw60XaWc6WicF9zc46FpasCuHq6mX9ick9liaib4VsOG1iafKgsWib8YADWfdjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1494&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;1wFs&quot;&gt; &lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5714285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/5mcydv0qFicXzFsgOt7fWRZ6jAeG9zhzouNZNH0VxZKHibuVlq9U111AVmg9d4fDy86NhewMnfrSCKf3ia0EBf0zA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;42&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;总结&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文对目前主流的限流算法进行了讲解，相信大家有了一个初步的认识。这些算法在面试中也经常被问到，同时我也是通过各种生活中的案例来举例，希望大家能够彻底的理解这些算法的原理。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;09s7&quot; data-folding-hover=&quot;&quot;&gt; &lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;大家好，我是从古代穿越过来的美男子：&lt;strong&gt;架构摆渡人&lt;/strong&gt;。我将把我的武功秘籍全部传授与你们，觉得有用请分享给身边的朋友。来个三连吧，感谢各位！&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>