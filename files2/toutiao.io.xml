<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>2409a874b625213881f487873a5b15ba</guid>
<title>Rust 开源：24 个绝佳框架、项目及资料库</title>
<link>https://toutiao.io/k/b2sfp14</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;关注「&lt;/span&gt;&lt;span&gt;Rust编程指北&lt;/span&gt;&lt;span&gt;」，一起学习 Rust，给未来投资&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了方便阅读，本文采用中英文对照的方式，英文颜色浅一些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rust has a very lively and fast-paced open source ecosystem, with a ton of contributors working on a ton of awesome projects.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rust拥有一个无比活跃且快节奏的开源生态系统，海量贡献者在这个系统中开展海量优质项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;And if you are asking – what can I build in Rust? The answer is almost everything.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而如果你还感到困惑：我能借助Rust打造什么呢？答案是：它几乎无所不能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;This article will feature some of the open-source Rust libraries, frameworks, and repositories that could be useful to study or use for your own project.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文将对一些开源Rust资料库、框架及储存库进行介绍，它们值得研究，而且或许还能直接运用到你的项目中去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;For your convenience, I’ve split them into fields such as web development, game development, blockchain, and others. Let’s dig in!&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了方便起见，我将分领域进行介绍，分别涵盖网页开发、游戏开发、区块链和其他领域。咱们开动吧！&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;Web development frameworks for Rust&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;Rust网站开发框架&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Can you build a web app with Rust? Definitely!&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你能用Rust建设一个网站应用吗？当然能！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rust has multiple extremely fast web frameworks – Rocket, Actix Web, and Yew – and you can use the one that matches your needs and preferences.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rust拥有多个极其快速的web框架——Rocket、Actix Web以及Yew——你可以根据自己的需求和偏好自行选择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rocket&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Rocket&lt;/span&gt;&lt;span&gt; is the most accessible web framework in the Rust ecosystem for beginners. It is highly customizable and helps you kickstart a new application quickly. At the same time, it avoids a lot of unnecessary boilerplate. Rocket also has many features included, which means that you won’t need to go far from the framework to build everything you need.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Rocket是Rust生态系统中最适合初学者使用的web框架。它&lt;/span&gt;&lt;span&gt;的可定制程度很高&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;能够&lt;/span&gt;&lt;span&gt;帮助&lt;/span&gt;&lt;span&gt;你&lt;/span&gt;&lt;span&gt;快速启动一个新的应用程序。同时，它&lt;/span&gt;&lt;span&gt;也规避了&lt;/span&gt;&lt;span&gt;许多不必要的样板&lt;/span&gt;&lt;span&gt;文件&lt;/span&gt;&lt;span&gt;。Rocket还&lt;/span&gt;&lt;span&gt;有&lt;/span&gt;&lt;span&gt;许多功能，这意味着&lt;/span&gt;&lt;span&gt;，在构建你需要的一切的时候，你都无需&lt;/span&gt;&lt;span&gt;远离&lt;/span&gt;&lt;span&gt;这个&lt;/span&gt;&lt;span&gt;框架。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;In contrast to Actix Web, the framework runs on nightly Rust – the “experimental” version of the language.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;与Actix Web相比，该框架在&lt;/span&gt;&lt;span&gt;所谓的nightly &lt;/span&gt;&lt;span&gt;Rust上&lt;/span&gt;&lt;span&gt;运行&lt;/span&gt;&lt;span&gt;——&lt;/span&gt;&lt;span&gt;这是&lt;/span&gt;&lt;span&gt;该语言的“实验”版本。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Actix Web&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Actix Web&lt;/span&gt;&lt;span&gt; is usually thought to be more performant and stable than Rocket. Underneath, it works with the actor model used in &lt;/span&gt;&lt;span&gt;Erlang&lt;/span&gt;&lt;span&gt; and &lt;/span&gt;&lt;span&gt;Akka.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;人们通常认为&lt;/span&gt;&lt;span&gt;Actix Web比Rocket性能更好、更&lt;/span&gt;&lt;span&gt;加&lt;/span&gt;&lt;span&gt;稳定。&lt;/span&gt;&lt;span&gt;在底层&lt;/span&gt;&lt;span&gt;，它与Erlang和Akka中使用的actor模型一&lt;/span&gt;&lt;span&gt;同&lt;/span&gt;&lt;span&gt;工作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;In contrast to Rocket, it’s less “batteries included”, meaning that you will most likely need to use third-party libraries for extra functionality.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;与Rocket相比，它&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;“内置组件”更少，这意味着你很可能需要使用第三方&lt;/span&gt;&lt;span&gt;资料&lt;/span&gt;&lt;span&gt;库来实现额外的功能。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Yew&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Yew&lt;/span&gt;&lt;span&gt; is a Rust framework for creating web apps with WebAssembly. Among its main benefits, it lists a component-based framework like in React and Elm, outstanding performance because of the multi-thread support, and JavaScript interoperability.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Yew&lt;/span&gt;&lt;span&gt;&lt;span&gt; 是一个Rust框架&lt;/span&gt;&lt;span&gt;，用于通过&lt;/span&gt;&lt;span&gt;WebAssembly创建web应用。它的主要优点是，它列出了一个基于组件的框架——这和React&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;Elm&lt;/span&gt;&lt;span&gt;是一样的；&lt;/span&gt;&lt;span&gt;由于多线程支持&lt;/span&gt;&lt;span&gt;，它具&lt;/span&gt;&lt;span&gt;有出色的性能&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;span&gt;以及JavaScript的互操作性。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;As of now, it is not production-ready but should be an excellent choice for side projects and internal tooling, especially if you want to work with WASM.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;到目前为止，它还不能用于生产，但是对于&lt;/span&gt;&lt;span&gt;编外&lt;/span&gt;&lt;span&gt;项目和内部工具来说，它应该是一个很好的选择——特别是如果&lt;/span&gt;&lt;span&gt;你&lt;/span&gt;&lt;span&gt;想使用WASM&lt;/span&gt;&lt;span&gt;的话&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Zola&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;If you need something quick and simple to serve a static website, &lt;/span&gt;&lt;span&gt;Zola&lt;/span&gt;&lt;span&gt; is a fantastic tool to create fast and scalable web pages without any other dependencies or JS bloat.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如果你需要一&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt;快速和简单的&lt;/span&gt;&lt;span&gt;工具&lt;/span&gt;&lt;span&gt;服务&lt;/span&gt;&lt;span&gt;于&lt;/span&gt;&lt;span&gt;静态网站，&lt;/span&gt;&lt;span&gt;那么&lt;/span&gt;&lt;span&gt;Zola&lt;/span&gt;&lt;span&gt;就&lt;/span&gt;&lt;span&gt;是一个奇妙的工具，&lt;/span&gt;&lt;span&gt;它可以帮助&lt;/span&gt;&lt;span&gt;创建快速&lt;/span&gt;&lt;span&gt;、可扩展&lt;/span&gt;&lt;span&gt;网页，没有任何其他&lt;/span&gt;&lt;span&gt;依赖关系&lt;/span&gt;&lt;span&gt;或JS膨胀。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Warp&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Warp&lt;/span&gt;&lt;span&gt; is a web server framework written in Rust. In comparison to Rocket and Actix, it is rather slim for a web framework and will provide you only with basic functionality out of the box.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Warp是一个用Rust编写的web服务器框架。作为一个web框架，与Rocket和Actix相比，它显得相当精简，只提供基本的开箱即用功能。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;Game development&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;游戏开发&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;shape type=&quot;#_x0000_t75&quot; filled=&quot;f&quot;&gt;&lt;imagedata title=&quot;image1&quot;/&gt;&lt;/shape&gt;&lt;img data-ratio=&quot;0.35108153078202997&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmhrPEkIgHWliawq4e2aWibGNqCIvh08aUriaH6gpN9BKqhH3Iwj5XR5tXlln8NmS6kUtsfib751t15BRWWnj893Rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;601&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rust is exceptional for game development for the same reason that C++ is: it is predictably performant. Here are some of the engines you can use to build your own Rust game.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;与C++一样，Rust在游戏开发&lt;/span&gt;&lt;span&gt;领域也有上佳表现&lt;/span&gt;&lt;span&gt;:它&lt;/span&gt;&lt;span&gt;具备让人感到踏实的&lt;/span&gt;&lt;span&gt;性能&lt;/span&gt;&lt;span&gt;表现&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;以下介绍的是一些游戏引擎，借助它们，你可以创建自己的Rust游戏。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Bevy&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Two of the main Rust game engines are Bevy and Amethyst. Among them, &lt;/span&gt;&lt;span&gt;Bevy&lt;/span&gt;&lt;span&gt; is the newer and cooler one. It is a simple, data-driven engine and can essentially be called Amethyst 2.0 since it is heavily inspired by it.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Rust的两个主要&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;游戏引擎&lt;/span&gt;&lt;span&gt;分别&lt;/span&gt;&lt;span&gt;是Bevy和Amethyst。其中，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Bevy&lt;/span&gt;&lt;span&gt;&lt;span&gt; 更新&lt;/span&gt;&lt;span&gt;，也&lt;/span&gt;&lt;span&gt;更酷。&lt;/span&gt;&lt;span&gt;它&lt;/span&gt;&lt;span&gt;是一个简单的数据驱动的引擎，本质上可以被称为Amethyst 2.0，因为它&lt;/span&gt;&lt;span&gt;很大程度上&lt;/span&gt;&lt;span&gt;受到了&lt;/span&gt;&lt;span&gt;后者&lt;/span&gt;&lt;span&gt;的启发。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;For more info on Bevy, you can check out the &lt;/span&gt;&lt;span&gt;Bevy book.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;欲知&lt;/span&gt;&lt;span&gt;更多关于Bevy的信息，&lt;/span&gt;&lt;span&gt;你可以参看&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Bevy &lt;/span&gt;&lt;span&gt;手册&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Amethyst&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Amethyst&lt;/span&gt;&lt;span&gt; is the more mature one of the two and, because of that, has more features that you might need for a large-scale project and better integrations with 3rd party libraries. But, Bevy is catching up fast. If you are searching for an engine for your new project, I’d recommend looking at them both and seeing which one you like better.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;二者相比较的话，&lt;/span&gt;&lt;span&gt;Amethyst&lt;/span&gt;&lt;span&gt;更加成熟。&lt;/span&gt;&lt;span&gt;正因为如此，它拥有更多&lt;/span&gt;&lt;span&gt;你在大型项目中可能用得着&lt;/span&gt;&lt;span&gt;的特性，并&lt;/span&gt;&lt;span&gt;且&lt;/span&gt;&lt;span&gt;与第三方&lt;/span&gt;&lt;span&gt;资料&lt;/span&gt;&lt;span&gt;库&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;集成&lt;/span&gt;&lt;span&gt;度也更好&lt;/span&gt;&lt;span&gt;。但是，Bevy正在迎头赶上。如果你正在为你的新项目寻找引擎&lt;/span&gt;&lt;span&gt;的话&lt;/span&gt;&lt;span&gt;，我&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;建议&lt;/span&gt;&lt;span&gt;是你把这两个引擎都研究一下&lt;/span&gt;&lt;span&gt;，看看&lt;/span&gt;&lt;span&gt;自己&lt;/span&gt;&lt;span&gt;更喜欢哪一个。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;ggez&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;If you are searching for something simple to start off, &lt;/span&gt;&lt;span&gt;ggez&lt;/span&gt;&lt;span&gt; is a lightweight cross-platform game framework for making 2D games with minimal friction.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你找的是一个简单的工具用于起步阶段的话，ggez是一个轻量级的跨平台游戏框架，可以帮助你在阻力最小的情况下开发2D游戏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.0016611295681063123&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmhrPEkIgHWliawq4e2aWibGNqCIvh08aUeuxZUsdAnSDZJibibnb0IDPFicGgwHrdHAZkM5ibmQEA0p5yw0x1xh2TXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;602&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;If you want to read more on game development in Rust, check out &lt;/span&gt;&lt;span&gt;Are we game yet?&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如欲了解更多在Rust上开发游戏的内容，请参看&lt;/span&gt;&lt;span&gt;开始游戏了吗&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;Operating systems&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;操作系统&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.35108153078202997&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmhrPEkIgHWliawq4e2aWibGNqCIvh08aUtO0yIhI3qlyQV63HvicZdT0CgEBpqewI81xa52zY1kslR1X6uxibx6Jw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;601&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Rust is an excellent alternative to C in operating system development since it offers the same level of performance while taking care of memory safety. Actually, developers &lt;/span&gt;&lt;span&gt;are investigating&lt;/span&gt;&lt;span&gt; the possibility of adding Rust to the Linux kernel, and Microsoft &lt;/span&gt;&lt;span&gt;is experimenting with it&lt;/span&gt;&lt;span&gt; as well.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Rust在操作系统开发中是C语言的&lt;/span&gt;&lt;span&gt;绝佳&lt;/span&gt;&lt;span&gt;替代品，因为它在保证内存安全的同时提供了相同水&lt;/span&gt;&lt;span&gt;准&lt;/span&gt;&lt;span&gt;的性能。实际上，开发人员正在研究将Rust添加到Linux内核的可能性，微软也&lt;/span&gt;&lt;span&gt;正&lt;/span&gt;&lt;span&gt;在对此&lt;/span&gt;&lt;span&gt;展开&lt;/span&gt;&lt;span&gt;试验。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Here are some open-source operating systems that are written purely in Rust:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下是一些纯粹使用Rust语言编写的开源操作系统：&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Redox&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Redox&lt;/span&gt;&lt;span&gt; is an operating system written in Rust that uses Rust’s innovations to build a modern microkernel.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redox是一个用Rust编写的操作系统，借助Rust的创新来构建现代微核。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;intermezzOS&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;intermezzOS&lt;/span&gt;&lt;span&gt; is a teaching operating system, specifically focused on introducing systems programming concepts to experienced developers from other programming areas.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;intermezzOS是一&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt;教学操作系统，侧重于向来自其他编程领域的有经验的开发人员介绍系统编程概念。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Theseus&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Theseus&lt;/span&gt;&lt;span&gt; is a new OS written in Rust that presents a novel OS structure and claims to avoid the phenomenon of state spill, a thing that occurs when one entity’s state is permanently changed through interactions with another.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Theseus&lt;/span&gt;&lt;span&gt;&lt;span&gt; 是一个用Rust&lt;/span&gt;&lt;span&gt;编写&lt;/span&gt;&lt;span&gt;的新操作系统，它提出了一个新的操作系统结构，并声称可以避免状态溢出现象——即一个实体的状态通过与另一个实体的交互而永久改变。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;There’s quite a lot to read about – here’s a &lt;/span&gt;&lt;span&gt;paper&lt;/span&gt;&lt;span&gt; on the project.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;这方面还有很多东西可以读，详情请参看这篇&lt;/span&gt;&lt;span&gt;文章&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;GUI development&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;图形用户界面开发&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.35108153078202997&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmhrPEkIgHWliawq4e2aWibGNqCIvh08aUxSEWOUYhzDQicVS7lFA6nxIYYTibFsQay6MKor72se4IAvs0vf6vwlEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;601&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;While Rust isn’t well known for its capability for building captivating user interfaces, there’s still a lot of good libraries to build GUIs with.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;虽然Rust在构建吸引人的用户界面方面并不出名，但仍然有很多好的&lt;/span&gt;&lt;span&gt;资料&lt;/span&gt;&lt;span&gt;库可以用来构建&lt;/span&gt;&lt;span&gt;图形用户界面&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Druid&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Druid&lt;/span&gt;&lt;span&gt; is an experimental Rust-native UI toolkit with a focus on building simple, polished user experiences. It is data-oriented and inspired by modern frameworks such as Flutter, SwiftUI, and others.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Druid&lt;/span&gt;&lt;span&gt; 是一个实验性的Rust原生UI工具包，专注于构建简单、精致的用户体验。它是面向数据的，并受到了Flutter、SwiftUI等现代框架的启发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;To learn more about it, you can check out the &lt;/span&gt;&lt;span&gt;Druid book.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如欲了解更多，请参看&lt;/span&gt;&lt;span&gt;Druid &lt;/span&gt;&lt;span&gt;手册&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Iced&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Iced&lt;/span&gt;&lt;span&gt; is a cross-platform GUI library with a focus on simplicity and type safety. It’s heavily inspired by Elm. While it is still experimental right now, it is an excellent option for creating GUIs right in Rust for your side project.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Iced是一个关注&lt;/span&gt;&lt;span&gt;简洁&lt;/span&gt;&lt;span&gt;性和类型安全的跨平台&lt;/span&gt;&lt;span&gt;图形用户界面&lt;/span&gt;&lt;span&gt;库。它很大程度上&lt;/span&gt;&lt;span&gt;受到了Elm的启发&lt;/span&gt;&lt;span&gt;。虽然它现在还处于实验阶段，但它是在Rust中为项目创建&lt;/span&gt;&lt;span&gt;图形用户界面&lt;/span&gt;&lt;span&gt;的绝佳选择。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;The Orbital Widget Toolkit&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;轨道部件工具包&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;The Orbital Widget Toolkit&lt;/span&gt;&lt;span&gt; is a cross-platform toolkit for building scalable user interfaces with Rust. It’s focused on speed, ease of use, and cross-platform compatibility.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;轨道部件工具包&lt;/span&gt;&lt;span&gt;&lt;span&gt;是一个跨平台的工具包，用于&lt;/span&gt;&lt;span&gt;借助&lt;/span&gt;&lt;span&gt;Rust构建可&lt;/span&gt;&lt;span&gt;扩展&lt;/span&gt;&lt;span&gt;用户界面。它专注于速度、易用性和跨平台兼容性。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Tauri&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Tauri&lt;/span&gt;&lt;span&gt; is a framework for building desktop applications for Windows, Linux, and macOS. With it, you can use any front-end framework that compiles to HTML/CSS/JS for building UIs, and Rust as the backend.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Tauri&lt;/span&gt;&lt;span&gt;&lt;span&gt; 是用于为Windows、Linux和macOS构建桌面应用的框架。&lt;/span&gt;&lt;span&gt;有了&lt;/span&gt;&lt;span&gt;它，你&lt;/span&gt;&lt;span&gt;就&lt;/span&gt;&lt;span&gt;可以使用任何可以编译成HTML/CSS/JS来构建&lt;/span&gt;&lt;span&gt;用户界面&lt;/span&gt;&lt;span&gt;的前端框架，并将Rust作为后端。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmhrPEkIgHWliawq4e2aWibGNqCIvh08aUeuxZUsdAnSDZJibibnb0IDPFicGgwHrdHAZkM5ibmQEA0p5yw0x1xh2TXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.0016611295681063123&quot; data-w=&quot;602&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;If you want to learn more about GUI development possibilities in Rust, &lt;/span&gt;&lt;span&gt;here’s a big post&lt;/span&gt;&lt;span&gt; that covers most of the libraries.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如欲&lt;/span&gt;&lt;span&gt;了解更多关于&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;Rust中开发&lt;/span&gt;&lt;span&gt;图形用户界面&lt;/span&gt;&lt;span&gt;的可能性，&lt;/span&gt;&lt;span&gt;可以参看这篇&lt;/span&gt;&lt;span&gt;干货贴&lt;/span&gt;&lt;span&gt;，里面&lt;/span&gt;&lt;span&gt;涵盖了大部分&lt;/span&gt;&lt;span&gt;资料&lt;/span&gt;&lt;span&gt;库。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;Blockchain&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;区块链&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.35108153078202997&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmhrPEkIgHWliawq4e2aWibGNqCIvh08aU42oz47AjrsENMPblO3pG3qnYrIgtxHUp7l2qAtCHSG2Yb6H3xdGibyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;601&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;OpenEthereum&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;The main goal of &lt;/span&gt;&lt;span&gt;OpenEthereum&lt;/span&gt;&lt;span&gt; is to be the fastest, lightest, and most secure Ethereum client. It is developed with Rust and claims to provide core infrastructure that is essential for speedy and reliable services.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Open&lt;/span&gt;&lt;span&gt;以太坊&lt;/span&gt;&lt;span&gt;&lt;span&gt; 的主要目标是成为最快、最轻、最安全的以太坊客户端。它是&lt;/span&gt;&lt;span&gt;用&lt;/span&gt;&lt;span&gt;Rust开发的，并声称提供&lt;/span&gt;&lt;span&gt;了对快速可靠服务至关重要的&lt;/span&gt;&lt;span&gt;核心基础设施。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Lighthouse&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Lighthouse&lt;/span&gt;&lt;span&gt; is an open-source Ethereum 2.0 client, written in Rust and maintained by Sigma Prime.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Lighthouse&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;是一个开源以太坊2.0客户端，是用Rust编写的，由Sigma Prime维护。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Parity Technologies: Polkadot and Substrate&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;奇偶校验技术：Polkadot和Substrate&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;Parity Technologies works on building blockchain infrastructure for the decentralized web.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;奇偶校验技术&lt;/span&gt;&lt;span&gt;致力于为去中心化的网络构建区块链基础设施。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Among its projects are &lt;/span&gt;&lt;span&gt;Substrate&lt;/span&gt;&lt;span&gt;, a modular framework for blockchain development, and &lt;/span&gt;&lt;span&gt;Polkadot, a network of blockchains. Both of these projects heavily use Rust in their implementations.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;该公司的项目包括用于区块链开发的模块化框架Substrate和区块链网络Polkadot。这两个项目&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;实现&lt;/span&gt;&lt;span&gt;过程&lt;/span&gt;&lt;span&gt;都大量&lt;/span&gt;&lt;span&gt;借助&lt;/span&gt;&lt;span&gt;了Rust&lt;/span&gt;&lt;span&gt;语言&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;Other projects&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;其他项目&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.35108153078202997&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmhrPEkIgHWliawq4e2aWibGNqCIvh08aUT5iasUGVAl3JZUhzhehOGP8bvCibjiaicmeEvk27ccbw4VRCibLWFejkbcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;601&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Here are some of the projects that don’t fit into any given category. Hope you can find something awesome in this collection of “things”. :)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下项目不属于任何特定类别。愿你能在这些“东西”中找到一些很棒的东西。：）&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Servo&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Servo&lt;/span&gt;&lt;span&gt; is a web engine prototype written in Rust. It’s the result of Mozilla’s work on creating a new, open-source browser engine. In 2020, Servo moved on from Mozilla to being hosted by the Linux Foundation.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Servo&lt;/span&gt;&lt;span&gt;&lt;span&gt; 是一个用Rust编写的web引擎原型。Mozilla致力于创建一个新的开源浏览器引擎&lt;/span&gt;&lt;span&gt;，而Servo就是其努力&lt;/span&gt;&lt;span&gt;的成果。2020年，Servo从Mozilla转向Linux基金会托管。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Servo is supposed to be safer than the browsers written in C++ due to Rust’s memory safety guarantees that reduce the number of vulnerabilities.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Servo 被认为比用C++编写的浏览器更安全，因为Rust的内存安全保证&lt;/span&gt;&lt;span&gt;能够&lt;/span&gt;&lt;span&gt;减少漏洞数量。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;swc&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;swc&lt;/span&gt;&lt;span&gt; is a superfast JavaScript/TypeScript compiler. In comparison to Babel, it has been benchmarked to increase the compilation speed at least 18 times.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;swc&lt;/span&gt;&lt;span&gt; 是一个超快的JavaScript/TypeScript编译器。与Babel相比，它的编译速度至少提高了18倍。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Ruffle&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Want to run all the cool Flash games that Adobe has recently disabled support for? You can use &lt;/span&gt;&lt;span&gt;Ruffle, a Flash player emulator written in Rust.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;你&lt;/span&gt;&lt;span&gt;想运行Adobe最近禁用的所有&lt;/span&gt;&lt;span&gt;超酷的&lt;/span&gt;&lt;span&gt;Flash游戏吗?你可以使用&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Ruffle&lt;/span&gt;&lt;span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;它是&lt;/span&gt;&lt;span&gt;一个用Rust编写的Flash播放模拟器。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;You can try it out on &lt;/span&gt;&lt;span&gt;ruffle.rs.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击&lt;/span&gt;&lt;span&gt;ruffle.rs&lt;/span&gt;&lt;span&gt;试试吧。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Lunatic&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Lunatic&lt;/span&gt;&lt;span&gt; is an experimental platform that uses WASM instances as actors to structure execution. It is heavily inspired by &lt;/span&gt;&lt;span&gt;Erlang.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Lunatic&lt;/span&gt;&lt;span&gt;&lt;span&gt; 是一个实验平台，它使用WASM实例作为参与者来&lt;/span&gt;&lt;span&gt;构建&lt;/span&gt;&lt;span&gt;执行。它很大程度上受到了&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Erlang&lt;/span&gt;&lt;span&gt;的启发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;It is supposed to unite the good sides of WASM and Erlang, enabling you to build actor-based systems that are both fault-tolerant and blazingly fast.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;它&lt;/span&gt;&lt;span&gt;旨在&lt;/span&gt;&lt;span&gt;将WASM和Erlang的优点&lt;/span&gt;&lt;span&gt;整合&lt;/span&gt;&lt;span&gt;起来，使&lt;/span&gt;&lt;span&gt;你&lt;/span&gt;&lt;span&gt;能够构建既容错又快速的基于参与者的系统。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Starship&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Starship&lt;/span&gt;&lt;span&gt; is a fast, customizable, and intelligent prompt for those that want to make their shell cooler.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Starship&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;是一个快速的、可定制的智能提示符，适合那些希望自己的外壳更酷的人。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;MeiliSearch&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;MeiliSearch&lt;/span&gt;&lt;span&gt; is a powerful, fast, easy to use, and customizable search engine that’s also typo-tolerant. Now that’s a lot of adjectives! You can set it up for your own project instead of a custom and probably worse-performing solution.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MeiliSearch&lt;/span&gt;&lt;span&gt;&lt;span&gt; 是一个强大&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;快速&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;易于&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;可定制&lt;/span&gt;&lt;span&gt;、具有容错性&lt;/span&gt;&lt;span&gt;的搜索引擎。&lt;/span&gt;&lt;span&gt;这可真是一大堆&lt;/span&gt;&lt;span&gt;形容词啊!&lt;/span&gt;&lt;span&gt;你&lt;/span&gt;&lt;span&gt;可以&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;项目&lt;/span&gt;&lt;span&gt;里用它&lt;/span&gt;&lt;span&gt;，而不是&lt;/span&gt;&lt;span&gt;转投&lt;/span&gt;&lt;span&gt;定制的&lt;/span&gt;&lt;span&gt;，而且可能性能&lt;/span&gt;&lt;span&gt;更差的解决方案。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;Have anything to add?&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;还有什么要补充的吗？&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;As you can see, the ecosystem is vast, and there is a lot to explore. I certainly wasn’t able to cover everything. If you know of a project that deserves to be here, don’t be afraid to let us know on &lt;/span&gt;&lt;span&gt;Twitter!&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;正如你所看到的，&lt;/span&gt;&lt;span&gt;这个&lt;/span&gt;&lt;span&gt;生态系统&lt;/span&gt;&lt;span&gt;非常&lt;/span&gt;&lt;span&gt;巨大，有很多&lt;/span&gt;&lt;span&gt;内容&lt;/span&gt;&lt;span&gt;可以探索。当然，我&lt;/span&gt;&lt;span&gt;在这一无法一一详述&lt;/span&gt;&lt;span&gt;。如果你知道&lt;/span&gt;&lt;span&gt;什么&lt;/span&gt;&lt;span&gt;值得在这里&lt;/span&gt;&lt;span&gt;讨论&lt;/span&gt;&lt;span&gt;的项目，&lt;/span&gt;&lt;span&gt;请在&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Twitter&lt;/span&gt;&lt;span&gt;上告诉我们!&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;If you want to learn more about Rust, I suggest going to our blog’s &lt;/span&gt;&lt;span&gt;Rust section. Have fun!&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如欲了解更多关于Rust的内容，建议访问我们博客上的&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;专篇（https://serokell.io/blog/rust）&lt;/span&gt;&lt;span&gt;。祝你开心！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原文链接：https://serokell.io/blog/open-source-rust&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;觉得不错，点个赞吧&lt;/p&gt;&lt;p&gt;扫码关注「&lt;span&gt;Rust编程指北&lt;/span&gt;」&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kmhrPEkIgHUOxOIbBEsyACGOicYC9vRw0NtRrW7BsnWWmBjtwvOLEO75Yxib6ViagwACCA1z7p29eG6HCad48fXAA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>682a8772255876bcc2d08c5f74554ac4</guid>
<title>使用 Go defer 要小心这 2 个雷区</title>
<link>https://toutiao.io/k/ye8mh35</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是煎鱼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 语言中 defer 是一个非常有意思的关键字特性。例子如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; fmt.Println(&lt;span&gt;&quot;煎鱼了&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;脑子进&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;脑子进&lt;br/&gt;煎鱼了&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前几天我的读者群内有小伙伴讨论起了下面这个问题：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6857142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4j5DWNOwFianbpNnjqOghR07YfDzZ9rk5vclcUzSUJJoh1kY5KZORcNIOw9LFxRMicE4RdUYlbhBjwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1330&quot;/&gt;&lt;figcaption&gt;读者群的聊天截图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来讲，&lt;strong&gt;问题就是针对在 &lt;code&gt;for&lt;/code&gt; 循环里搞 defer 关键字，是否会造成什么性能影响&lt;/strong&gt;？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为在 Go 语言的底层数据结构设计上 defer 是链表的数据结构：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6497297297297298&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4j5DWNOwFianbpNnjqOghR07IeOiaSsWAhpwrtjcW6libeoAsnrVibjibQIrgfRy5c5fn2Cqib2Kq2bTxZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;925&quot;/&gt;&lt;figcaption&gt;defer 基本底层结构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家担心如果循环过大 defer 链表会巨长，不够 “精益求精”。又或是猜想会不会 Go defer 的设计和 Redis 数据结构设计类似，自己做了优化，其实没啥大影响？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天这篇文章，我们就来探索循环 Go defer，造成底层链表过长会不会带来什么问题，若有，具体有什么影响？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开始吸鱼之路。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;defer 性能优化 30%&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在早年 Go1.13 时曾经对 defer 进行了一轮性能优化，在大部分场景下 提高了 defer 30% 的性能：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4045734388742304&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4j5DWNOwFianbpNnjqOghR07DDPUAK32entwibdibwhHiahPoc5NGWfFY9zgBibe3OIcwbSXYW9xdw06Bw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2274&quot;/&gt;&lt;figcaption&gt;Go defer 1.13 优化记录&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来回顾一下 Go1.13 的变更，看看 Go defer 优化在了哪里，这是问题的关键点。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;以前和现在对比&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go1.12 及以前，调用 Go defer 时汇编代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    0x0070 00112 (main.go:6)    CALL    runtime.deferproc(SB)&lt;br/&gt;    0x0075 00117 (main.go:6)    TESTL    AX, AX&lt;br/&gt;    0x0077 00119 (main.go:6)    JNE    137&lt;br/&gt;    0x0079 00121 (main.go:7)    XCHGL    AX, AX&lt;br/&gt;    0x007a 00122 (main.go:7)    CALL    runtime.deferreturn(SB)&lt;br/&gt;    0x007f 00127 (main.go:7)    MOVQ    56(SP), BP&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go1.13 及以后，调用 Go defer 时汇编代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; 0x006e 00110 (main.go:4) MOVQ AX, (SP)&lt;br/&gt; 0x0072 00114 (main.go:4) CALL runtime.deferprocStack(SB)&lt;br/&gt; 0x0077 00119 (main.go:4) TESTL AX, AX&lt;br/&gt; 0x0079 00121 (main.go:4) JNE 139&lt;br/&gt; 0x007b 00123 (main.go:7) XCHGL AX, AX&lt;br/&gt; 0x007c 00124 (main.go:7) CALL runtime.deferreturn(SB)&lt;br/&gt; 0x0081 00129 (main.go:7) MOVQ 112(SP), BP&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从汇编的角度来看，像是原本调用 &lt;code&gt;runtime.deferproc&lt;/code&gt; 方法改成了调用 &lt;code&gt;runtime.deferprocStack&lt;/code&gt; 方法，难道是做了什么优化？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们&lt;strong&gt;抱着疑问&lt;/strong&gt;继续看下去。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;defer 最小单元：_defer&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相较于以前的版本，Go defer 的最小单元 &lt;code&gt;_defer&lt;/code&gt; 结构体主要是新增了 &lt;code&gt;heap&lt;/code&gt; 字段：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; _defer struct {&lt;br/&gt; siz     int32&lt;br/&gt; siz     int32 // includes both arguments and results&lt;br/&gt; started bool&lt;br/&gt; heap    bool&lt;br/&gt; sp      uintptr // sp at time of defer&lt;br/&gt; pc      uintptr&lt;br/&gt; fn      *funcval&lt;br/&gt; ...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该字段用于标识这个 &lt;code&gt;_defer&lt;/code&gt; 是在堆上，还是在栈上进行分配，其余字段并没有明确变更，那我们可以把聚焦点放在 &lt;code&gt;defer&lt;/code&gt; 的堆栈分配上了，看看是做了什么事。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;deferprocStack&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func deferprocStack(d *_defer) {&lt;br/&gt; gp := getg()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; gp.m.curg != gp {&lt;br/&gt;  throw(&lt;span&gt;&quot;defer on system stack&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt; &lt;br/&gt; d.started = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; d.heap = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; d.sp = getcallersp()&lt;br/&gt; d.pc = getcallerpc()&lt;br/&gt;&lt;br/&gt; *(*uintptr)(unsafe.Pointer(&amp;amp;d._panic)) = 0&lt;br/&gt; *(*uintptr)(unsafe.Pointer(&amp;amp;d.link)) = uintptr(unsafe.Pointer(gp._defer))&lt;br/&gt; *(*uintptr)(unsafe.Pointer(&amp;amp;gp._defer)) = uintptr(unsafe.Pointer(d))&lt;br/&gt;&lt;br/&gt; return0()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一块代码挺常规的，主要是获取调用 &lt;code&gt;defer&lt;/code&gt; 函数的函数栈指针、传入函数的参数具体地址以及PC（程序计数器），这块在前文 《深入理解 Go defer》 有详细介绍过，这里就不再赘述了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个 &lt;code&gt;deferprocStack&lt;/code&gt; 特殊在哪呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到它把 &lt;code&gt;d.heap&lt;/code&gt; 设置为了 &lt;code&gt;false&lt;/code&gt;，也就是代表 &lt;code&gt;deferprocStack&lt;/code&gt; 方法是针对将 &lt;code&gt;_defer&lt;/code&gt; 分配在栈上的应用场景的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;deferproc&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题来了，它又在哪里处理分配到堆上的应用场景呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func newdefer(siz int32) *_defer {&lt;br/&gt; ...&lt;br/&gt; d.heap = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; d.link = gp._defer&lt;br/&gt; gp._defer = d&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; d&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的 &lt;code&gt;newdefer&lt;/code&gt; 是在哪里调用的呢，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func deferproc(siz int32, fn *funcval) { // arguments of fn follow fn&lt;br/&gt; ...&lt;br/&gt; sp := getcallersp()&lt;br/&gt; argp := uintptr(unsafe.Pointer(&amp;amp;fn)) + unsafe.Sizeof(fn)&lt;br/&gt; callerpc := getcallerpc()&lt;br/&gt;&lt;br/&gt; d := newdefer(siz)&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常明确，先前的版本中调用的 &lt;code&gt;deferproc&lt;/code&gt; 方法，现在被用于对应分配到堆上的场景了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小结&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可以确定的是 &lt;code&gt;deferproc&lt;/code&gt; 并没有被去掉，而是流程被优化了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Go 编译器会根据应用场景去选择使用 &lt;code&gt;deferproc&lt;/code&gt; 还是 &lt;code&gt;deferprocStack&lt;/code&gt; 方法，他们分别是针对分配在堆上和栈上的使用场景。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;优化在哪儿&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要优化在于其 defer 对象的堆栈分配规则的改变，措施是：编译器对 &lt;code&gt;defer&lt;/code&gt; 的 &lt;code&gt;for-loop&lt;/code&gt; 迭代深度进行分析。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// src/cmd/compile/internal/gc/esc.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; ODEFER:&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; e.loopdepth == &lt;span&gt;1&lt;/span&gt; { &lt;span&gt;// top level&lt;/span&gt;&lt;br/&gt;  n.Esc = EscNever &lt;span&gt;// force stack allocation of defer record (see ssa.go)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;break&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 Go 编译器检测到循环深度（loopdepth）为 1，则设置逃逸分析的结果，将分配到栈上，否则分配到堆上。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// src/cmd/compile/internal/gc/ssa.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; ODEFER:&lt;br/&gt; d := callDefer&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; n.Esc == EscNever {&lt;br/&gt;  d = callDeferStack&lt;br/&gt; }&lt;br/&gt; s.call(n.Left, d)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以此免去了以前频繁调用 &lt;code&gt;systemstack&lt;/code&gt;、&lt;code&gt;mallocgc&lt;/code&gt; 等方法所带来的大量性能开销，来达到大部分场景提高性能的作用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;循环调用 defer&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到问题本身，知道了 defer 优化的原理后。那 “循环里搞 defer 关键字，是否会造成什么性能影响？”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最直接的影响就是这大约 30% 的性能优化直接全无，且由于姿势不正确，理论上 defer 既有的开销（链表变长）也变大，性能变差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此我们要避免以下两种场景的代码：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;显式循环：在调用 defer 关键字的外层有显式的循环调用，例如：&lt;code&gt;for-loop&lt;/code&gt; 语句等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;隐式循环：在调用 defer 关键字有类似循环嵌套的逻辑，例如：&lt;code&gt;goto&lt;/code&gt; 语句等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;显式循环&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个例子是直接在代码的 &lt;code&gt;for&lt;/code&gt; 循环中使用 defer 关键字：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt;= &lt;span&gt;99&lt;/span&gt;; i++ {&lt;br/&gt;  &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   fmt.Println(&lt;span&gt;&quot;脑子进煎鱼了&quot;&lt;/span&gt;)&lt;br/&gt;  }()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个也是最常见的模式，无论是写爬虫时，又或是 Goroutine 调用时，不少人都喜欢这么写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这属于显式的调用了循环。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;隐式循环&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个例子是在代码中使用类似 &lt;code&gt;goto&lt;/code&gt; 关键字：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; i := &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;food:&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {}()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; i == &lt;span&gt;1&lt;/span&gt; {&lt;br/&gt;  i -= &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;goto&lt;/span&gt; food&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种写法比较少见，因为 &lt;code&gt;goto&lt;/code&gt; 关键字有时候甚至会被列为代码规范不给使用，主要是会造成一些滥用，所以大多数就选择其实方式实现逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这属于隐式的调用，造成了类循环的作用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然，Defer 在设计上并没有说做的特别的奇妙。他主要是根据实际的一些应用场景进行了优化，达到了较好的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然本身 defer 会带一点点开销，但并没有想象中那么的不堪使用。除非你 defer 所在的代码是需要频繁执行的代码，才需要考虑去做优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;否则没有必要过度纠结，在实际上，猜测或遇到性能问题时，看看 PProf 的分析，看看 defer 是不是在相应的 hot path 之中，再进行合理优化就好。&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓的优化，可能也只是去掉 defer 而采用手动执行，并不复杂。在编码时避免踩到 defer 的显式和隐式循环这 2 个雷区就可以达到性能最大化了。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7bde04f4daf634219245239d724f1140</guid>
<title>面试官：两个 nil 比较结果是什么？</title>
<link>https://toutiao.io/k/otmhhst</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;背景&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;哈喽，大家好，我是&lt;code&gt;asong&lt;/code&gt;。前几天在一个交流群里看到了一道非常有意思的面试题，今天把它分享出来，我们先来看一下这个道题：&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;fmt.Println(&lt;span&gt;nil&lt;/span&gt;== &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两个&lt;code&gt;nil&lt;/code&gt;的比较结果是什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;true&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;、还是无法编译？大家先思考着，文中揭晓答案。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;写在开始：&lt;strong&gt;建议你们看一下这个视频：https://www.youtube.com/watch?v=ynoY2xz-F8s&lt;/strong&gt;  &lt;strong&gt;需要翻墙哈，看完这个你对&lt;code&gt;nil&lt;/code&gt;会有一个新的理解。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go中&lt;code&gt;nil&lt;/code&gt;的定义&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;Go&lt;/code&gt;官方文档中，对&lt;code&gt;nil&lt;/code&gt;的定义如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// nil is a predeclared identifier representing the zero value for a&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// pointer, channel, func, interface, map, or slice type.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; Type &lt;span&gt;// Type must be a pointer, channel, func, interface, map, or slice type&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;nil&lt;/code&gt;是一个预先声明的标识符，代表指针(&lt;code&gt;pointer&lt;/code&gt;)、通道(&lt;code&gt;channel&lt;/code&gt;)、函数(&lt;code&gt;func&lt;/code&gt;)、接口(&lt;code&gt;interface&lt;/code&gt;)、&lt;code&gt;map&lt;/code&gt;、切片(&lt;code&gt;slice&lt;/code&gt;)。也可以这么理解：指针、通道、函数、接口、map、切片的零值就是&lt;code&gt;nil&lt;/code&gt;，就像布尔类型的零值是&lt;code&gt;false&lt;/code&gt;、整型的零值是&lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;深入理解&lt;code&gt;nil&lt;/code&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;nil&lt;/code&gt;根本不是关键字&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看一段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;nil&lt;/span&gt; := &lt;span&gt;&quot;this is nil&quot;&lt;/span&gt;&lt;br/&gt; fmt.Println(&lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;this is &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那再改成这样呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;nil&lt;/span&gt; := &lt;span&gt;&quot;this is nil&quot;&lt;/span&gt;&lt;br/&gt; fmt.Println(&lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; slice []&lt;span&gt;string&lt;/span&gt; = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; fmt.Println(slice)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;# command-line-arguments&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;6&lt;/span&gt;: cannot use &lt;span&gt;nil&lt;/span&gt; (&lt;span&gt;type&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) as &lt;span&gt;type&lt;/span&gt; []&lt;span&gt;string&lt;/span&gt; in assignment&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译的时候直接报错了，因为这个&lt;code&gt;nil&lt;/code&gt;是一个&lt;code&gt;string&lt;/code&gt;类型，所以从这里确定&lt;code&gt;nil&lt;/code&gt;在&lt;code&gt;Go&lt;/code&gt;语言中并不是关键字，我们可以随意定义变量名为&lt;code&gt;nil&lt;/code&gt;（不过不建议这么用）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;nil&lt;/code&gt;的默认类型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般预声明标识符都会有一个默认类型，比如&lt;code&gt;Go&lt;/code&gt;语言中的&lt;code&gt;itoa&lt;/code&gt;默认类型就是&lt;code&gt;int&lt;/code&gt;，那么&lt;code&gt;nil&lt;/code&gt;的默认类型呢？我们写个例子来看一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;const&lt;/span&gt; val1 = &lt;span&gt;iota&lt;/span&gt;&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;%T\n&quot;&lt;/span&gt;,val1)&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; val2 = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;%T\n&quot;&lt;/span&gt;,val2)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;# command-line-arguments&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;6&lt;/span&gt;: use of untyped &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在编译时就已经报错，编译器告诉我们使用了无类型的&lt;code&gt;nil&lt;/code&gt;，所以我们可以得出结论：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;nil&lt;/code&gt;是没有默认类型的，它的类型具有不确定性，我们在使用它时必须要提供足够的信息能够让编译器推断&lt;code&gt;nil&lt;/code&gt;期望的类型。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;nil&lt;/code&gt;的比较&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;nil&lt;/code&gt;的比较我们可以分为以下两种情况：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看一下&lt;code&gt;nil&lt;/code&gt;标识符的比较，也就是我们开头那一道面试题，先看一下运行结果呢：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;# command-line-arguments&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;8&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: &lt;span&gt;nil&lt;/span&gt; == &lt;span&gt;nil&lt;/span&gt; (operator == not defined on &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过编译结果我们可以看出&lt;code&gt;==&lt;/code&gt;符号对于&lt;code&gt;nil&lt;/code&gt;来说是一种未定义的操作，所以是不可以比较两个&lt;code&gt;nil&lt;/code&gt;的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着我们来看一看&lt;code&gt;nil&lt;/code&gt;的值比较，因为&lt;code&gt;nil&lt;/code&gt;是没有类型的，是在编译期根据上下文确定的，所以要比较&lt;code&gt;nil&lt;/code&gt;的值也就是比较不同类型的&lt;code&gt;nil&lt;/code&gt;，这又分为同一个类型的&lt;code&gt;nil&lt;/code&gt;值比较和不同类型&lt;code&gt;nil&lt;/code&gt;值的比较，分这两种情况我们分别来验证一下。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;// 指针类型的nil比较&lt;/span&gt;&lt;br/&gt; fmt.Println((*&lt;span&gt;int64&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;) == (*&lt;span&gt;int64&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;))&lt;br/&gt; &lt;span&gt;// channel 类型的nil比较&lt;/span&gt;&lt;br/&gt; fmt.Println((&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;) == (&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;))&lt;br/&gt; &lt;span&gt;// func类型的nil比较&lt;/span&gt;&lt;br/&gt; fmt.Println((&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;)&lt;span&gt;(&lt;span&gt;nil&lt;/span&gt;)&lt;/span&gt; == &lt;span&gt;(&lt;span&gt;func&lt;/span&gt;()&lt;/span&gt;)&lt;span&gt;(&lt;span&gt;nil&lt;/span&gt;)&lt;/span&gt;) // &lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; 只能与&lt;span&gt;nil&lt;/span&gt;进行比较&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// interface类型的nil比较&lt;/span&gt;&lt;br/&gt; fmt.Println((&lt;span&gt;interface&lt;/span&gt;{})(&lt;span&gt;nil&lt;/span&gt;) == (&lt;span&gt;interface&lt;/span&gt;{})(&lt;span&gt;nil&lt;/span&gt;))&lt;br/&gt; &lt;span&gt;// map类型的nil比较&lt;/span&gt;&lt;br/&gt; fmt.Println((&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;) == (&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;)) &lt;span&gt;// map 只能与nil进行比较&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// slice类型的nil比较&lt;/span&gt;&lt;br/&gt; fmt.Println(([]&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;) == ([]&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;)) &lt;span&gt;// slice 只能与nil进行比较&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;# command-line-arguments&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;28&lt;/span&gt;: invalid operation: (&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;)&lt;span&gt;(&lt;span&gt;nil&lt;/span&gt;)&lt;/span&gt; == &lt;span&gt;(&lt;span&gt;func&lt;/span&gt;()&lt;/span&gt;)&lt;span&gt;(&lt;span&gt;nil&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;span&gt;func&lt;/span&gt; can only be compared to &lt;span&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt;:&lt;span&gt;36&lt;/span&gt;: invalid operation: (&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;) == (&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;) (&lt;span&gt;map&lt;/span&gt; can only be compared to &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt;:&lt;span&gt;27&lt;/span&gt;: invalid operation: ([]&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;) == ([]&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;) (slice can only be compared to &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从运行结果我们可以看出，指针类型&lt;code&gt;nil&lt;/code&gt;、&lt;code&gt;channel&lt;/code&gt;类型的&lt;code&gt;nil&lt;/code&gt;、&lt;code&gt;interface&lt;/code&gt;类型可以相互比较，而&lt;code&gt;func&lt;/code&gt;类型、&lt;code&gt;map&lt;/code&gt;类型、&lt;code&gt;slice&lt;/code&gt;类型只能与&lt;code&gt;nil&lt;/code&gt;标识符比较，两个类型相互比较是不合法的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; ptr *&lt;span&gt;int64&lt;/span&gt; = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; cha &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt; = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; fun &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; = &lt;span&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; inter &lt;span&gt;interface&lt;/span&gt;{} = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; ma &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt; = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; slice []&lt;span&gt;int64&lt;/span&gt; = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; fmt.Println(ptr == cha)&lt;br/&gt; fmt.Println(ptr == fun)&lt;br/&gt; fmt.Println(ptr == inter)&lt;br/&gt; fmt.Println(ptr == ma)&lt;br/&gt; fmt.Println(ptr == slice)&lt;br/&gt;&lt;br/&gt; fmt.Println(cha == fun)&lt;br/&gt; fmt.Println(cha == inter)&lt;br/&gt; fmt.Println(cha == ma)&lt;br/&gt; fmt.Println(cha == slice)&lt;br/&gt;&lt;br/&gt; fmt.Println(fun == inter)&lt;br/&gt; fmt.Println(fun == ma)&lt;br/&gt; fmt.Println(fun == slice)&lt;br/&gt;&lt;br/&gt; fmt.Println(inter == ma)&lt;br/&gt; fmt.Println(inter == slice)&lt;br/&gt;&lt;br/&gt; fmt.Println(ma == slice)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;# command-line-arguments&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: ptr == cha (mismatched types *&lt;span&gt;int64&lt;/span&gt; and &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt;)&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;15&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: ptr == fun (mismatched types *&lt;span&gt;int64&lt;/span&gt; and &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: ptr == ma (mismatched types *&lt;span&gt;int64&lt;/span&gt; and &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt;)&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: ptr == slice (mismatched types *&lt;span&gt;int64&lt;/span&gt; and []&lt;span&gt;int64&lt;/span&gt;)&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: cha == fun (mismatched types &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt; and &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;22&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: cha == ma (mismatched types &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt; and &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt;)&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;23&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: cha == slice (mismatched types &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt; and []&lt;span&gt;int64&lt;/span&gt;)&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: fun == inter (operator == not defined on &lt;span&gt;&lt;span&gt;func&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;26&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: fun == ma (mismatched types &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;27&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: fun == slice (mismatched types &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; []&lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;27&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: too many errors&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从运行结果我们可以得出，只有指针类型和channel类型与接口类型可以比较，其他类型的之间是不可以相互比较的。为什么指针类型、channel类型可以和接口类型进行比较呢？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这个答案，先空着，因为我也没有想明白，不是说/任何类型都实现了interface{}类型吗？这里没想明白，期待你们的解答。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;nil&lt;/code&gt;在不同类型中使用需要注意的问题&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;interface&lt;/code&gt;与&lt;code&gt;nil&lt;/code&gt;比较要注意的一个点&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看一个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; err := Todo()&lt;br/&gt; fmt.Println(err == &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Err &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; err &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Code &lt;span&gt;int64&lt;/span&gt;&lt;br/&gt; Msg &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Todo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;Err&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; res *err&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果是&lt;code&gt;false&lt;/code&gt;，在&lt;code&gt;Todo&lt;/code&gt;方法内我们声明了一个变量&lt;code&gt;res&lt;/code&gt;，这个变量是一个指针类型，零值是&lt;code&gt;nil&lt;/code&gt;，返回的是接口类型，按理说返回值接口类型也应是&lt;code&gt;nil&lt;/code&gt;才对，但是结果却不是这样。这是因为我们忽略了接口类型的一个概念，interface 不是单纯的值，而是分为类型和值。所以必须要类型和值同时都为 &lt;code&gt;nil&lt;/code&gt; 的情况下，&lt;code&gt;interface&lt;/code&gt; 的 &lt;code&gt;nil&lt;/code&gt; 判断才会为 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个新手很容易出现的问题，大家一定要注意这个问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一个&lt;code&gt;nil&lt;/code&gt;的&lt;code&gt;map&lt;/code&gt;读写数据是否会发生&lt;code&gt;panic&lt;/code&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于这种问题，我们直接写个例子测试一下就好：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; m &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt;&lt;br/&gt; fmt.Println(m[&lt;span&gt;&quot;asoong&quot;&lt;/span&gt;])&lt;br/&gt; m[&lt;span&gt;&quot;asong&quot;&lt;/span&gt;] = &lt;span&gt;&quot;Golang梦工厂&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;&lt;span&gt;panic&lt;/span&gt;: assignment to entry in &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;map&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;goroutine &lt;span&gt;1&lt;/span&gt; [running]:&lt;br/&gt;main.main()&lt;br/&gt;        &lt;span&gt;go&lt;/span&gt;/src/asong.cloud/Golang_Dream/code_demo/slice_demo/&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt; +&lt;span&gt;0xed&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据运行结果我们可以看出，一个&lt;code&gt;nil&lt;/code&gt;的&lt;code&gt;map&lt;/code&gt;可以读数据，但是不可以写入数据，否则会发生&lt;code&gt;panic&lt;/code&gt;，所以要使用&lt;code&gt;map&lt;/code&gt;一定要使用&lt;code&gt;make&lt;/code&gt;进行初始化。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;关闭&lt;code&gt;nil&lt;/code&gt;的&lt;code&gt;channel&lt;/code&gt;会引发&lt;code&gt;panic&lt;/code&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; cha &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; &lt;span&gt;close&lt;/span&gt;(cha)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;panic&lt;/span&gt;: &lt;span&gt;close&lt;/span&gt; of &lt;span&gt;nil&lt;/span&gt; channel&lt;br/&gt;&lt;br/&gt;goroutine &lt;span&gt;1&lt;/span&gt; [running]:&lt;br/&gt;main.main()&lt;br/&gt;       /&lt;span&gt;go&lt;/span&gt;/src/asong.cloud/Golang_Dream/code_demo/slice_demo/&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;5&lt;/span&gt; +&lt;span&gt;0x2a&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据运行结果我们可以得出关闭一个&lt;code&gt;nil&lt;/code&gt;的&lt;code&gt;channel&lt;/code&gt;会导致程序&lt;code&gt;panic&lt;/code&gt;，在使用上我们要注意这个问题，还有有一个需要注意的问题：&lt;strong&gt;一个&lt;code&gt;nil&lt;/code&gt;的&lt;code&gt;channel&lt;/code&gt;读写数据都会造成永远阻塞。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一个为&lt;code&gt;nil&lt;/code&gt;的&lt;code&gt;slice&lt;/code&gt;使用注意事项&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; slice []&lt;span&gt;int64&lt;/span&gt; = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; fmt.Println(&lt;span&gt;len&lt;/span&gt;(slice))&lt;br/&gt; fmt.Println(&lt;span&gt;cap&lt;/span&gt;(slice))&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;range&lt;/span&gt; slice{&lt;br/&gt;&lt;br/&gt; }&lt;br/&gt; fmt.Println(slice[&lt;span&gt;0&lt;/span&gt;])&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;panic&lt;/span&gt;: runtime error: index out of &lt;span&gt;range&lt;/span&gt; [&lt;span&gt;0&lt;/span&gt;] with length &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;goroutine &lt;span&gt;1&lt;/span&gt; [running]:&lt;br/&gt;main.main()&lt;br/&gt;        /&lt;span&gt;go&lt;/span&gt;/src/asong.cloud/Golang_Dream/code_demo/slice_demo/&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt; +&lt;span&gt;0xf2&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据这个例子，我们可以得出如下结论：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;一个为&lt;code&gt;nil&lt;/code&gt;的索引，不可以进行索引，否则会引发&lt;code&gt;panic&lt;/code&gt;，其他操作是可以。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;方法接收者为&lt;code&gt;nil&lt;/code&gt;时是否会引发&lt;code&gt;panic&lt;/code&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; m *man&lt;br/&gt; fmt.Println(m.GetName())&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; man &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m *man)&lt;/span&gt;&lt;span&gt;GetName&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;asong&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;asong&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据运行结果我们可以看出，方法接收者为&lt;code&gt;nil&lt;/code&gt;时，我们仍然可以访问对应的方法，但是要注意方法内的写法，否则也会引发&lt;code&gt;panic&lt;/code&gt;。上面的代码改成这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; m *man&lt;br/&gt; fmt.Println(m.GetName())&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; man &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Name &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m *man)&lt;/span&gt;&lt;span&gt;GetName&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; m.Name&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;&lt;span&gt;panic&lt;/span&gt;: runtime error: invalid memory address or &lt;span&gt;nil&lt;/span&gt; pointer dereference&lt;br/&gt;[signal SIGSEGV: segmentation violation code=&lt;span&gt;0x1&lt;/span&gt; addr=&lt;span&gt;0x0&lt;/span&gt; pc=&lt;span&gt;0x10a6ec3&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;goroutine &lt;span&gt;1&lt;/span&gt; [running]:&lt;br/&gt;main.(*man).GetName(...)&lt;br/&gt;        &lt;span&gt;go&lt;/span&gt;/src/asong.cloud/Golang_Dream/code_demo/slice_demo/&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;&lt;br/&gt;main.main()&lt;br/&gt;        &lt;span&gt;go&lt;/span&gt;/src/asong.cloud/Golang_Dream/code_demo/slice_demo/&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt; +&lt;span&gt;0x23&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就是直接引发&lt;code&gt;panic&lt;/code&gt;，所以为了程序健壮性我们要做一次指针判空处理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;空指针是一个没有任何值的指针&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; a = (*&lt;span&gt;int64&lt;/span&gt;)(unsafe.Pointer(&lt;span&gt;uintptr&lt;/span&gt;(&lt;span&gt;0x0&lt;/span&gt;)))&lt;br/&gt; fmt.Println(a == &lt;span&gt;nil&lt;/span&gt;)  &lt;span&gt;//true&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们用了&lt;code&gt;0x0&lt;/code&gt;做了一个小实验，正好证明了空指针就是一个没有指向任何值的指针。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章接近尾声啦，我们来揭晓一下文章开始的答案，用文中&lt;code&gt;nil&lt;/code&gt;比较的知识点正好可以解答这个问题，&lt;code&gt;nil&lt;/code&gt;标识符是没有类型的，所以&lt;code&gt;==&lt;/code&gt;对于&lt;code&gt;nil&lt;/code&gt;来说是一种未定义的操作，不可以进行比较，而这个在&lt;code&gt;python&lt;/code&gt;中是可以比较的，在 &lt;code&gt;python&lt;/code&gt; 中，两个&lt;code&gt;None&lt;/code&gt; 值永远相等，不要弄混了朋友们。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最后建议你们看一下这个视频：https://www.youtube.com/watch?v=ynoY2xz-F8s&lt;/strong&gt;  &lt;strong&gt;需要翻墙哈，看完这个你对&lt;code&gt;nil&lt;/code&gt;会有一个新的理解。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;好啦，这篇文章就到这里啦，素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：加我vx拉你入群，或者公众号获取入群二维码&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;翻译了一份Machinery中文文档，会定期进行维护，有需要的小伙伴们后台回复[machinery]即可获取。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我是asong，一名普普通通的程序猿，让我们一起慢慢变强吧。欢迎各位的关注，我们下期见~~~&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/k5430ljpYPNFVT6F1cSh4LJhic7wX9o3cmPicXrYcyvAxtKDVTg3PzTQicpw8wLIc59lVPs6c0UrWDwr1qnwq67UA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐往期文章：&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c2787fd151d25dc80c43be2159289d5b</guid>
<title>源码解析 GitHub 上 14.1k Star 的 RocketMQ</title>
<link>https://toutiao.io/k/0pi916j</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Ly9fQtHVgNmLTAOicuhahBE0jkfiajcTsV5yBW4eKI357LoU2xsQia7QDQLaKmbib9CdqrLVUDT5611PvbKFqOYfUg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;103160&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;前言&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p hm_fix=&quot;367:433&quot;&gt;&lt;span&gt;Apache RocketMQ 作为广为人知的开源消息中间件，诞生于阿里巴巴，于 2016 年捐赠给了 Apache。从 RocketMQ 4.0 到如今最新的 v4.7.1，不论是在阿里巴巴内部还是外部社区，都赢得了广泛的关注和好评。 &lt;/span&gt;&lt;/p&gt;&lt;p hm_fix=&quot;367:433&quot;&gt;&lt;/p&gt;&lt;p hm_fix=&quot;367:433&quot;&gt;&lt;span&gt;本文将站在发送方视角，通过阅读 RocketMQ Producer 源码，来分析在事务消息发送中 RocketMQ 是如何工作的。&lt;/span&gt;&lt;/p&gt;&lt;p hm_fix=&quot;367:433&quot;&gt;&lt;/p&gt;&lt;p hm_fix=&quot;367:433&quot;&gt;&lt;span&gt;需要说明的是，本文所贴代码，均来自 4.7.1 版本的 RocketMQ 源码。本文中所讨论的发送，仅指从 Producer 发送到 Broker 的过程，并不包含 Broker 将消息投递到 Consumer 的过程。 &lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;103158&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;宏观概览&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;RocketMQ 事务消息发送流程： &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img data-ratio=&quot;1.0369487485101312&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNmLTAOicuhahBE0jkfiajcTsVDl4ERgF5I6BfeDXn5oIKbgZqX5YY5wnSLO294bwolicdaYSuaoj0Ftg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;6712&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;结合源码来看，RocketMQ 的事务消息 TransactionMQProducer 的 sendMessageInTransaction 方法，实际调用了 DefaultMQProducerImpl 的 sendMessageInTransaction 方法。我们进入 sendMessageInTransaction 方法，整个事务消息的发送流程清晰可见。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先，做发送前检查，并填入必要参数，包括设 prepare 事务消息。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;源码清单-1&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public TransactionSendResult sendMessageInTransaction(final Message msg,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    final LocalTransactionExecuter localTransactionExecuter, final Object arg)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    throws MQClientException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    TransactionListener transactionListener = getCheckListener(); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        if (null == localTransactionExecuter &amp;amp;&amp;amp; null == transactionListener) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        throw new MQClientException(&quot;tranExecutor is null&quot;, null);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // ignore DelayTimeLevel parameter&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (msg.getDelayTimeLevel() != 0) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_DELAY_TIME_LEVEL);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Validators.checkMessage(msg, this.defaultMQProducer);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    SendResult sendResult = null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, &quot;true&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, this.defaultMQProducer.getProducerGroup());&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;进入发送处理流程： &lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;源码清单-2&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    try {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        sendResult = this.send(msg);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } catch (Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        throw new MQClientException(&quot;send message Exception&quot;, e);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;根据 broker 返回的处理结果决策本地事务是否执行，半消息发送成功则开始本地事务执行： &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;源码清单-3 &lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Throwable localException = null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    switch (sendResult.getSendStatus()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        case SEND_OK: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            try {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (sendResult.getTransactionId() != null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    msg.putUserProperty(&quot;__transactionId__&quot;, sendResult.getTransactionId());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                String transactionId = msg.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (null != transactionId &amp;amp;&amp;amp; !&quot;&quot;.equals(transactionId)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    msg.setTransactionId(transactionId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (null != localTransactionExecuter) { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    localTransactionState = localTransactionExecuter.executeLocalTransactionBranch(msg, arg);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                } else if (transactionListener != null) { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    log.debug(&quot;Used new transaction API&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    localTransactionState = transactionListener.executeLocalTransaction(msg, arg); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (null == localTransactionState) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    localTransactionState = LocalTransactionState.UNKNOW;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (localTransactionState != LocalTransactionState.COMMIT_MESSAGE) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    log.info(&quot;executeLocalTransactionBranch return {}&quot;, localTransactionState);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    log.info(msg.toString());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            } catch (Throwable e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                log.info(&quot;executeLocalTransactionBranch exception&quot;, e);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                log.info(msg.toString());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                localException = e;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        case FLUSH_DISK_TIMEOUT:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        case FLUSH_SLAVE_TIMEOUT:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        case SLAVE_NOT_AVAILABLE:  // 当备broker状态不可用时，半消息要回滚，不执行本地事务&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        default:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;本地事务执行结束，根据本地事务状态进行二阶段处理：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;源码清单-4&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    try {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        this.endTransaction(sendResult, localTransactionState, localException);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } catch (Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        log.warn(&quot;local transaction execute &quot; + localTransactionState + &quot;, but end broker transaction failed&quot;, e);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 组装发送结果&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    return transactionSendResult;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;接下来，我们深入每个阶段代码分析。 &lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;103158&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;深扒内幕&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;strong&gt;Ⅰ 阶段发送&lt;br/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;重点分析 send 方法。进入 send 方法后，我们发现，RocketMQ 的事务消息的一阶段，使用了 SYNC 同步模式：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;源码清单-5 &lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public SendResult send(Message msg,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    return this.sendDefaultImpl(msg, CommunicationMode.SYNC, null, timeout);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这一点很容易理解，毕竟事务消息是要根据一阶段发送结果来决定要不要执行本地事务的，所以一定要阻塞等待 broker 的 ack。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们进入 DefaultMQProducerImpl.java 中去看 sendDefaultImpl 方法的实现，通过读这个方法的代码，来尝试了解在事务消息的一阶段发送过程中 producer 的行为。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;值得注意的是，这个方法并非为事务消息定制，甚至不是为 SYNC 同步模式定制的，因此读懂了这段代码，基本可以对 RocketMQ 的消息发送机制有了一个较为全面的认识。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这段代码逻辑非常通畅，不忍切片。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了节省篇幅，将代码中较为繁杂但信息量不大的部分以注释代替，尽可能保留流程的完整性。个人认为较为重要或是容易被忽略的部分，以注释标出，后文还有部分细节的详细解读。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;源码清单-6&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;private SendResult sendDefaultImpl(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Message msg,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    final CommunicationMode communicationMode,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    final SendCallback sendCallback,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    final long timeout&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    this.makeSureStateOK();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 一、消息有效性校验。见后文&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Validators.checkMessage(msg, this.defaultMQProducer);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    final long invokeID = random.nextLong();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    long beginTimestampFirst = System.currentTimeMillis();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    long beginTimestampPrev = beginTimestampFirst;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    long endTimestamp = beginTimestampFirst;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 获取当前topic的发送路由信息，主要是要broker，如果没找到则从namesrv获取&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (topicPublishInfo != null &amp;amp;&amp;amp; topicPublishInfo.ok()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        boolean callTimeout = false;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        MessageQueue mq = null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Exception exception = null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        SendResult sendResult = null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 二、发送重试机制。见后文&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        int timesTotal = communicationMode == CommunicationMode.SYNC ? 1 + this.defaultMQProducer.getRetryTimesWhenSendFailed() : 1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        int times = 0;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        String[] brokersSent = new String[timesTotal];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        for (; times &amp;lt; timesTotal; times++) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            // 第一次发送是mq == null， 之后都是有broker信息的&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            String lastBrokerName = null == mq ? null : mq.getBrokerName();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            // 三、rocketmq发送消息时如何选择队列？——broker异常规避机制 &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            MessageQueue mqSelected = this.selectOneMessageQueue(topicPublishInfo, lastBrokerName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            if (mqSelected != null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                mq = mqSelected;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                brokersSent[times] = mq.getBrokerName();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                try {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    beginTimestampPrev = System.currentTimeMillis();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (times &amp;gt; 0) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        //Reset topic with namespace during resend.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        msg.setTopic(this.defaultMQProducer.withNamespace(msg.getTopic()));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    long costTime = beginTimestampPrev - beginTimestampFirst;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (timeout &amp;lt; costTime) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        callTimeout = true;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    // 发送核心代码&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    sendResult = this.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout - costTime);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    endTimestamp = System.currentTimeMillis();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    // rocketmq 选择 broker 时的规避机制，开启 sendLatencyFaultEnable == true 才生效&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    switch (communicationMode) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    // 四、RocketMQ的三种CommunicationMode。见后文&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        case ASYNC: // 异步模式&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            return null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        case ONEWAY: // 单向模式&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            return null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        case SYNC: // 同步模式&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            if (sendResult.getSendStatus() != SendStatus.SEND_OK) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                if (this.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                    continue;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            return sendResult;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        default:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                } catch (RemotingException e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    // ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    // 自动重试&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                } catch (MQClientException e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    // ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    // 自动重试&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                } catch (MQBrokerException e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                   // ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    // 仅返回码==NOT_IN_CURRENT_UNIT==205 时自动重试&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    // 其他情况不重试，抛异常&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                } catch (InterruptedException e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                   // ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    // 不重试，抛异常&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            } else {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        if (sendResult != null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            return sendResult;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 组装返回的info信息，最后以MQClientException抛出&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // ... ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 超时场景抛RemotingTooMuchRequestException&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        if (callTimeout) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            throw new RemotingTooMuchRequestException(&quot;sendDefaultImpl call timeout&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 填充MQClientException异常信息&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    validateNameServerSetting();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    throw new MQClientException(&quot;No route info of this topic: &quot; + msg.getTopic() + FAQUrl.suggestTodo(FAQUrl.NO_TOPIC_ROUTE_INFO),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        null).setResponseCode(ClientErrorCode.NOT_FOUND_TOPIC_EXCEPTION);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、消息有效性校验&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;源码清单-7&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; Validators.checkMessage(msg, this.defaultMQProducer);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在此方法中校验消息的有效性，包括对 topic 和消息体的校验。topic 的命名必须符合规范，且避免使用内置的系统消息 TOPIC。消息体长度 &amp;gt; 0 &amp;amp;&amp;amp; 消息体长度 &amp;lt;= 1024*1024*4 = 4M 。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;源码清单-8 &lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public static void checkMessage(Message msg, DefaultMQProducer defaultMQProducer)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    throws MQClientException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (null == msg) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        throw new MQClientException(ResponseCode.MESSAGE_ILLEGAL, &quot;the message is null&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // topic&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Validators.checkTopic(msg.getTopic());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Validators.isNotAllowedSendTopic(msg.getTopic());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // body&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (null == msg.getBody()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        throw new MQClientException(ResponseCode.MESSAGE_ILLEGAL, &quot;the message body is null&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (0 == msg.getBody().length) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        throw new MQClientException(ResponseCode.MESSAGE_ILLEGAL, &quot;the message body length is zero&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (msg.getBody().length &amp;gt; defaultMQProducer.getMaxMessageSize()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        throw new MQClientException(ResponseCode.MESSAGE_ILLEGAL,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &quot;the message body size over max value, MAX: &quot; + defaultMQProducer.getMaxMessageSize());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;二、发送重试机制&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Producer 在消息发送不成功时，会自动重试，最多发送次数 = retryTimesWhenSendFailed + 1 = 3 次 。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;值得注意的是，并非所有异常情况都会重试，从以上源码中可以提取到的信息告诉我们，在以下三种情况下，会自动重试：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1）发生 RemotingException，MQClientException 两种异常之一时&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2）发生 MQBrokerException 异常，且 ResponseCode 是 NOT_IN_CURRENT_UNIT = 205 时&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3）SYNC 模式下，未发生异常且发送结果状态非 SEND_OK &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在每次发送消息之前，会先检查是否在前面这两步就已经耗时超长（超时时长默认 3000ms），若是，则不再继续发送并且直接返回超时，不再重试。这里说明了 2 个问题：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1）producer 内部自动重试对业务应用而言是无感知的，应用看到的发送耗时是包含所有重试的耗时在内的；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2）一旦超时意味着本次消息发送已经以失败告终，原因是超时。这个信息最后会以 RemotingTooMuchRequestException 的形式抛出。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里需要指出的是，在 RocketMQ 官方文档中指出，发送超时时长是 10s，即 10000ms，网上许多人对 rocketMQ 的超时时间解读也认为是 10s。然而代码中却明明白白写着 3000ms，最终我 debug 之后确认，默认超时时间确实是 3000ms。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、broker 的异常规避机制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;源码清单-9&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;MessageQueue mqSelected = this.selectOneMessageQueue(topicPublishInfo, lastBrokerName);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这行代码是发送前选择 queue 的过程。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里涉及 RocketMQ 消息发送高可用的的一个核心机制，latencyFaultTolerance。这个机制是 Producer 负载均衡的一部分，通过 sendLatencyFaultEnable 的值来控制，默认是 false 关闭状态，不启动 broker 故障延迟机制，值为 true 时启用 broker 故障延迟机制，可由 Producer 主动打开。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;选择队列时，开启异常规避机制，则根据 broker 的工作状态避免选择当前状态不佳的 broker 代理，不健康的 broker 会在一段时间内被规避，不开启异常规避机制时，则按顺序选取下一个队列，但在重试场景下会尽量选择不同于上次发送 broker 的 queue。每次消息发送都会通过 updateFaultItem 方法来维护 broker 的状态信息。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;源码清单-10&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public void updateFaultItem(final String brokerName, final long currentLatency, boolean isolation) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (this.sendLatencyFaultEnable) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 计算延迟多久，isolation表示是否需要隔离该broker，若是，则从30s往前找第一个比30s小的延迟值，再按下标判断规避的周期，若30s，则是10min规避；&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 否则，按上一次发送耗时来决定规避时长；&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        long duration = computeNotAvailableDuration(isolation ? 30000 : currentLatency);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        this.latencyFaultTolerance.updateFaultItem(brokerName, currentLatency, duration);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;深入到 selectOneMessageQueue 方法内部一探究竟： &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;源码清单-11&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public MessageQueue selectOneMessageQueue(final TopicPublishInfo tpInfo, final String lastBrokerName) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (this.sendLatencyFaultEnable) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 开启异常规避&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        try {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            int index = tpInfo.getSendWhichQueue().getAndIncrement();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            for (int i = 0; i &amp;lt; tpInfo.getMessageQueueList().size(); i++) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                int pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (pos &amp;lt; 0)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    pos = 0;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                // 按顺序取下一个message queue作为发送的queue&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                MessageQueue mq = tpInfo.getMessageQueueList().get(pos);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                // 当前queue所在的broker可用，且与上一个queue的broker相同，&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                // 或者第一次发送，则使用这个queue&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (latencyFaultTolerance.isAvailable(mq.getBrokerName())) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (null == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        return mq;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            final String notBestBroker = latencyFaultTolerance.pickOneAtLeast();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            int writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            if (writeQueueNums &amp;gt; 0) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                final MessageQueue mq = tpInfo.selectOneMessageQueue();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (notBestBroker != null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    mq.setBrokerName(notBestBroker);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                return mq;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            } else {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                latencyFaultTolerance.remove(notBestBroker);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } catch (Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            log.error(&quot;Error occurred when selecting message queue&quot;, e);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        return tpInfo.selectOneMessageQueue();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 不开启异常规避，则随机自增选择Queue&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    return tpInfo.selectOneMessageQueue(lastBrokerName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;四、RocketMQ 的三种 CommunicationMode:&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;源码清单-12&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; public enum CommunicationMode {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    SYNC,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ASYNC,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ONEWAY,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;以上三种模式指的都是消息从发送方到达 broker 的阶段，不包含 broker 将消息投递给订阅方的过程。三种模式的发送方式的差异： &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span data-type=&quot;strong&quot;&gt;单向模式：&lt;/span&gt;ONEWAY。消息发送方只管发送，并不关心 broker 处理的结果如何。这种模式下，由于处理流程少，发送耗时非常小，吞吐量大，但不能保证消息可靠不丢，常用于流量巨大但不重要的消息场景，例如心跳发送等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span data-type=&quot;strong&quot;&gt;异步模式：&lt;/span&gt;ASYNC。消息发送方发送消息到 broker 后，无需等待 broker 处理，拿到的是 null 的返回值，而由一个异步的线程来做消息处理，处理完成后以回调的形式告诉发送方发送结果。异步处理时如有异常，返回发送方失败结果之前，会经过内部重试（默认 3 次，发送方不感知）。这种模式下，发送方等待时长较小，吞吐量较大，消息可靠，用于流量大但重要的消息场景。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span data-type=&quot;strong&quot;&gt;同步模式：&lt;/span&gt;SYNC。消息发送方需等待 broker 处理完成并明确返回成功或失败，在消息发送方拿到消息发送失败的结果之前，也会经历过内部重试（默认 3 次，发送方不感知）这种模式下，发送方会阻塞等待消息处理结果，等待时长较长，消息可靠，用于流量不大但重要的消息场景。需要强调的是，事务消息的一阶段半事务消息的处理是同步模式。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在 sendKernelImpl 方法中也可以看到具体的实现差异。ONEWAY 模式最为简单，不做任何处理。负责发送的 sendMessage 方法参数中，相比同步模式，异步模式多了回调方法、包含 topic 发送路由元信息的 topicPublishInfo、包含发送 broker 信息的 instance、包含发送队列信息的 producer、重试次数。另外，异步模式下，会对有压缩的消息先做 copy。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;源码清单-13&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    switch (communicationMode) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                case ASYNC:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    Message tmpMessage = msg;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    boolean messageCloned = false;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (msgBodyCompressed) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        //If msg body was compressed, msgbody should be reset using prevBody.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        //Clone new message using commpressed message body and recover origin massage.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        //Fix bug:https://github.com/apache/rocketmq-externals/issues/66&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        tmpMessage = MessageAccessor.cloneMessage(msg);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        messageCloned = true;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        msg.setBody(prevBody);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (topicWithNamespace) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        if (!messageCloned) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            tmpMessage = MessageAccessor.cloneMessage(msg);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            messageCloned = true;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), this.defaultMQProducer.getNamespace()));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    long costTimeAsync = System.currentTimeMillis() - beginStartTime;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (timeout &amp;lt; costTimeAsync) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        throw new RemotingTooMuchRequestException(&quot;sendKernelImpl call timeout&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        brokerAddr,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        mq.getBrokerName(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        tmpMessage,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        requestHeader,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        timeout - costTimeAsync,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        communicationMode,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        sendCallback,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        topicPublishInfo,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        this.mQClientFactory,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        this.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        context,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        this);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                case ONEWAY:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                case SYNC:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    long costTimeSync = System.currentTimeMillis() - beginStartTime;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (timeout &amp;lt; costTimeSync) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        throw new RemotingTooMuchRequestException(&quot;sendKernelImpl call timeout&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        brokerAddr,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        mq.getBrokerName(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        msg,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        requestHeader,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        timeout - costTimeSync,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        communicationMode,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        context,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        this);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                default:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    assert false;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;官方文档中有这样一张图，十分清晰的描述了异步通信的详细过程： &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7951612903225806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNmLTAOicuhahBE0jkfiajcTsV4AKcLrWhyF8miaO2ib338nYR6kH0Olz0fKAJj74RbKmeXX49C9s9YA0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;620&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-id=&quot;heading8&quot; data-type=&quot;heading&quot; top=&quot;10608&quot;&gt;&lt;strong&gt;Ⅱ 阶段发送&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;源码清单-3 体现了本地事务的执行，localTransactionState 将本地事务执行结果与事务消息二阶段的发送关联起来。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;值得注意的是，如果一阶段的发送结果是 SLAVE&lt;em data-type=&quot;italic&quot;&gt;NOT&lt;/em&gt;AVAILABLE，即便 broker 不可用时，也会将 localTransactionState 置为 Rollback，此时将不会执行本地事务。之后由 endTransaction 方法负责二阶段提交，见源码清单-4。具体到 endTransaction 的实现：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;源码清单-14&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public void endTransaction(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    final SendResult sendResult,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    final LocalTransactionState localTransactionState,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    final Throwable localException) throws RemotingException, MQBrokerException, InterruptedException, UnknownHostException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    final MessageId id;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (sendResult.getOffsetMsgId() != null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        id = MessageDecoder.decodeMessageId(sendResult.getOffsetMsgId());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } else {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        id = MessageDecoder.decodeMessageId(sendResult.getMsgId());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    String transactionId = sendResult.getTransactionId();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    final String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(sendResult.getMessageQueue().getBrokerName());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    EndTransactionRequestHeader requestHeader = new EndTransactionRequestHeader();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    requestHeader.setTransactionId(transactionId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    requestHeader.setCommitLogOffset(id.getOffset());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    switch (localTransactionState) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        case COMMIT_MESSAGE:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        case ROLLBACK_MESSAGE:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        case UNKNOW:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        default:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            break;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    requestHeader.setProducerGroup(this.defaultMQProducer.getProducerGroup());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    requestHeader.setTranStateTableOffset(sendResult.getQueueOffset());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    requestHeader.setMsgId(sendResult.getMsgId());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    String remark = localException != null ? (&quot;executeLocalTransactionBranch exception: &quot; + localException.toString()) : null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 采用oneway的方式发送二阶段消息&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, requestHeader, remark,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        this.defaultMQProducer.getSendMsgTimeout());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在二阶段发送时，之所以用 oneway 的方式发送，个人理解这正是因为事务消息有一个特殊的可靠机制——回查。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;103158&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;消息回查&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当 Broker 经过了一个特定的时间，发现依然没有得到事务消息的二阶段是否要提交或者回滚的确切信息，Broker 不知道 Producer 发生了什么情况（可能 producer 挂了，也可能 producer 发了 commit 但网络抖动丢了，也可能……于是主动发起回查。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;事务消息的回查机制，更多的是在 broker 端的体现。RocketMQ 的 broker 以 Half 消息、Op 消息、真实消息三个不同的 topic 来将不同发送阶段的事务消息进行了隔离，使得 Consumer 只能看到最终确认 commit 需要投递出去的消息。其中详细的实现逻辑在本文中暂不多赘述，后续可另开一篇专门来从 Broker 视角来解读。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;回到 Producer 的视角，当收到了 Broker 的回查请求，Producer 将根据消息检查本地事务状态，根据结果决定提交或回滚，这就要求 Producer 必须指定回查实现，以备不时之需。当然，正常情况下，并不推荐主动发送 UNKNOW 状态，这个状态毫无疑问会给 broker 带来额外回查开销，只在出现不可预知的异常情况时才启动回查机制，是一种比较合理的选择。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外，4.7.1 版本的事务回查并非无限回查，而是最多回查 15 次：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;源码清单-15&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@ImportantField&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; transactionCheckMax = &lt;span class=&quot;code-snippet__number&quot;&gt;15&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;103158&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;附录&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;官方给出 Producer 的默认参数如下（其中超时时长的参数，在前文中也已经提到，debug 的结果是默认 3000ms，并非 10000ms）: &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.2637920101458465&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNmLTAOicuhahBE0jkfiajcTsV7nBG45ZwiabY4T2gDBC7nGH2gjzzNjqSciaIZMic2BOiagUVFMd6uCT6ZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1577&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2198581560283688&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNmLTAOicuhahBE0jkfiajcTsV54PyJwR4hxTtibmGBmXccL0ibjLAfu3btKicibicVcCh3iaJTJcgLGYI0VPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1128&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;800&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNn8rstVfDv9pmtT4bLjphmE9ibjzMtp0CJxtiajyHY2FHl8hybIco0ic95eB1qEVRSawKUewKf8tJJmQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDk2MzUzMQ==&amp;amp;mid=2247486650&amp;amp;idx=1&amp;amp;sn=784145d54e857ce11868d4cbad3d0bda&amp;amp;chksm=f9e3181ece94910821d22af6a60146002d5146212e6ff9e27bbd2f3cb12870a8aecb68ac10e5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; hasload=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1578125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNlPfEPWbrSBV8RjAicxu6ib8nljInd37m3CNoh32xOuZwydrQbYKUNEcBjCIdsGssfGuroWVHp261Jw/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDk2MzUzMQ==&amp;amp;mid=2247486733&amp;amp;idx=1&amp;amp;sn=f6a91f5b14657a092af97e1e3542f023&amp;amp;chksm=f9e319a9ce9490bfdecd9534bdd95785ba8833f4023928de7776e49f82df91ba58ada2d95ab7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; hasload=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1578125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNlPfEPWbrSBV8RjAicxu6ib8nsF7Afp0llC6pt2IohPcGX2UufSQOOJcWiab87PqHncu605tQ9kuXWuw/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDk2MzUzMQ==&amp;amp;mid=2247486753&amp;amp;idx=1&amp;amp;sn=c87fb126e0c01521d467779ad4bfba18&amp;amp;chksm=f9e31985ce949093debaba15869d02e1f86246709d099d074bc7019a101cf6420882e8868543&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; hasload=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1578125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNlPfEPWbrSBV8RjAicxu6ib8nfia6TWiaJOibukYxQCeOVXLaLxjypNWQljBLCYATiaPUW0ibiaeHgnBQ2CaA/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;hr/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages __bg_gif&quot; data-ratio=&quot;0.3359173126614987&quot; data-s=&quot;300,640&quot; data-type=&quot;gif&quot; data-w=&quot;1548&quot; data-backw=&quot;357&quot; data-backh=&quot;120&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Ly9fQtHVgNkW5XM01qD7S0PrzSL4XF4j8aP07jS3gN59VyiaInelAh9R0icHicaYmTnc9ev8xM4PK8HltbeQTOleQ/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;79&quot; data-ratio=&quot;0.214900947459087&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ly9fQtHVgNm5Jr4A4hmb8QKTl1n7uicZzqJ75oyzVLvGCkK9QhzGgc2Ux9GiaXicf7UUG4Ns1GMyr0YkTIU7fNeHQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;点击下方“&lt;/span&gt;&lt;span&gt;&lt;strong&gt;阅读原文&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;”，了解「mPaaS」更多资讯。&lt;/span&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4c2795b53bd304dd6c355d3ed8b311d6</guid>
<title>[译] 工作六年后，对软件开发的一些新观点</title>
<link>https://toutiao.io/k/r4thw3m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;一个人的智力是否属于上乘，要看脑子里能否同时容纳两种相反的思想而无碍其处世行事；今天 pshu 翻译了一位有 6 年工作经验的软件工程师的观点。希望这些立场鲜明的观点可以成为你提高大脑容量的素材。&lt;/p&gt;&lt;p&gt;&lt;span&gt;原文地址 &lt;/span&gt;&lt;span&gt;https://chriskiehl.com/article/thoughts-after-6-years&lt;/span&gt;&lt;span&gt; 《Software development topics I&#x27;ve changed my mind on after 6 years in the industry》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;h1&gt;以前怀疑但现在认同的观点&lt;/h1&gt;&lt;h4&gt;当你需要和不同经验的开发人员一起合作时，使用强类型语言更适合一些（译者注：如Typescript）&lt;/h4&gt;&lt;h4&gt;站立会议（晨会的一种形式）对帮助新人很有用&lt;/h4&gt;&lt;h4&gt;回顾会（scrum 开发模式中用来总结前一次迭代中得失的会议）还是有其存在意义的，因为它能帮忙我们纠正开发过程中的错误；它并不是敏捷开发中 scrum master 想出来浪费时间多余的会议。&lt;/h4&gt;&lt;h4&gt;软件架构很重要。一个好的抽象配上一个糟糕的实现不会对代码造成多严重的影响；但是一个错误的抽象和分层遗漏，就导致代码很容易变烂。&lt;/h4&gt;&lt;h4&gt;Java 并不垃圾。&lt;/h4&gt;&lt;h4&gt;投机取巧、奇技淫巧的代码不是好代码；代码的可读性最重要。&lt;/h4&gt;&lt;h4&gt;不要迷信编程范式，任何编程范式中都可能写出烂代码。&lt;/h4&gt;&lt;h4&gt;所谓的“最佳实践”都是有具体场景的，并不是万金油。如果盲目地追求“最佳实践”，那很有可能成为最佳笨蛋。&lt;/h4&gt;&lt;h4&gt;如果没有必要，合格的工程师是不会主动去设计一个可扩展的系统。&lt;/h4&gt;&lt;h4&gt;代码的静态分析很有用（译者注：比如 lint，但是纠结具体的规则，参见后面“始终认同的观点”的第一条）&lt;/h4&gt;&lt;h4&gt;DRY（Don’t Repeat yourself ）只是用来规避一类特殊的问题，而不是一个目标。&lt;/h4&gt;&lt;h4&gt;一般情况下，关系型数据库(RDBMS)比非关系型数据库(NoSQL)好。&lt;/h4&gt;&lt;h4&gt;函数式编程只是一个工具，不是灵丹妙药&lt;/h4&gt;&lt;h1&gt;新学习到的观点&lt;/h1&gt;&lt;h4&gt;编程时遵循的原则应该按照以下顺序：YAGNI, SOLID, DRY。&lt;/h4&gt;&lt;blockquote&gt;&lt;p&gt;YAGNI：You aren&#x27;t gonna need it, 不要去写你目前不需要的功能，大部分预测未来是无效的; &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;SOLID：面向对象设计中的 5 个原则：&lt;/p&gt;&lt;p&gt; Single-responsibility principle单一职责原则&lt;/p&gt;&lt;p&gt; Open–closed principle 对扩展开放对修改掉封闭原则，也简称开闭原则&lt;/p&gt;&lt;p&gt;&lt;span&gt; Liskov substitution principle 李氏替换原则&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; Interface segregation principle 接口隔离原则&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; Dependency inversion principle 依赖翻转原则 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;DRY：Don&#x27;t repeat yourself, 只做一次原则&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果你这三个缩写都懂，那么可以尝试用自己的想法和这个观点PK下，如果这些名词都不懂，最好空杯心态先接受学习下。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4&gt;纸和笔仍旧是最好的编程工具，但他们仍未被大量使用&lt;/h4&gt;&lt;h4&gt;在纯粹主义和实用主义之间做一个折中，通常都会是个好主意&lt;/h4&gt;&lt;h4&gt;增加更多的技术栈并不是一个好主意&lt;/h4&gt;&lt;h4&gt;直接和用户沟通往往能花更少的时间并且更加准确地了解问题。&lt;/h4&gt;&lt;h4&gt;“可扩展性”这个词在程序员心中是种神秘的迷信；只要提了这个词就会驱使他们进入癫狂的疯狂状态；做再残酷的事情好像都是合理的。&lt;/h4&gt;&lt;h4&gt;尽管戴着“工程师”这个高帽，但是他们大部分工程师决策都是盲目地使用现有的技术框架或者编程模式，不做任何技术分析和调研。&lt;/h4&gt;&lt;h4&gt;90%甚至 93%的项目经理在项目中其实可有可无；即使明天他们突然消失了，也不会对项目有任何负面影响，甚至可能还能提高效率。&lt;/h4&gt;&lt;h4&gt;在进行了 100 多场面试之后，我发现面试是完全没有用的；但我也不知道如何更好地面试。&lt;/h4&gt;&lt;h1&gt;始终认同的观点&lt;/h1&gt;&lt;h4&gt;纠结于代码风格，lint规则和其他琐事的人都是疯子&lt;/h4&gt;&lt;h4&gt;代码覆盖率和代码质量之间没有关系&lt;/h4&gt;&lt;h4&gt;单体仓库在大多数情况下更好。&lt;/h4&gt;&lt;h4&gt;TDD纯粹主义者最菜。他们脆弱的小脑袋里面容不下其他现存的工作方式。&lt;/h4&gt;&lt;p&gt;在工作10年后，我们再看看这些看法有什么改变。&lt;/p&gt;&lt;p&gt;翻译完。&lt;/p&gt;&lt;h1&gt;译者随笔&lt;/h1&gt;&lt;p&gt;pshu 刚看到这篇文章就很喜欢，篇幅不长，但是能带来很多的思维的碰撞。让人陷入思考读到这样的文章已经赚到了，如果还能锻炼出在脑子里同时容纳两个相反的观点的技能就赚翻了。试想 pshu 工作十年了是不是也该写篇类似的文章了。（我会更新的）&lt;/p&gt;&lt;p&gt;在翻译的时候学到了一个新的词组 cargo-cult，直译过来是货物崇拜，是一种宗教形式，特别容易出现于一些与世隔绝的原住民中。当货物崇拜者看见外来的先进科技物品，便会将之当作神祇般崇拜。在原文中用这个概念来指出大部分的软件工程师，对各种技术框架不假思索直接利用，这种现象已经有了一个专有的名词Cargo Cult Programming，硬邦邦地直译过来就是货物崇拜编程。现在常说的“工具人”除了外部的因素外，那内部的原因就是放弃思考或者眼界有限造成的Cargo Cult Programming了。在现在这么爱讲“卷”不“卷”的环境下，突然学习到了这么一个词似乎也可以给打破卷提供一个思路。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>