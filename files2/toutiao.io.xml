<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>0d154af95dca3de8b9ed1b191632d541</guid>
<title>Golang 简洁架构实战</title>
<link>https://toutiao.io/k/vjw1dlc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：bearluo，腾讯 IEG 运营开发工程师&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;文中项目代码位置：https://github.com/devYun/go-clean-architecture&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 golang 不像 java 一样有一个统一的编码模式，所以我们和其他团队一样，采用了 &lt;a href=&quot;https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md&quot; data-linktype=&quot;2&quot;&gt;Go 面向包的设计和架构分层&lt;/a&gt;这篇文章介绍的一些理论，然后再结合以往的项目经验来进行分包：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;├── cmd/&lt;br/&gt;│   └── main.go //启动函数&lt;br/&gt;├── etc&lt;br/&gt;│   └── dev_conf.yaml              // 配置文件&lt;br/&gt;├── global&lt;br/&gt;│   └── global.go //全局变量引用，如数据库、kafka等&lt;br/&gt;├── internal/&lt;br/&gt;│       └── service/&lt;br/&gt;│           └── xxx_service.go //业务逻辑处理类&lt;br/&gt;│           └── xxx_service_test.go&lt;br/&gt;│       └── model/&lt;br/&gt;│           └── xxx_info.go//结构体&lt;br/&gt;│       └── api/&lt;br/&gt;│           └── xxx_api.go//路由对应的接口实现&lt;br/&gt;│       └── router/&lt;br/&gt;│           └── router.go//路由&lt;br/&gt;│       └── pkg/&lt;br/&gt;│           └── datetool//时间工具类&lt;br/&gt;│           └── jsontool//json 工具类&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实上面的这个划分只是简单的将功能分了一下包，在项目实践的过程中还是有很多问题。比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对于功能实现我是通过 function 的参数传递还是通过结构体的变量传递？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用一个数据库的全局变量引用传递是否安全？是否存在过度耦合？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在代码实现过程中几乎全部都是依赖于实现，而不是依赖于接口，那么将 MySQL 切换为 MongDB 是不是要修改所有的实现？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以现在在我们工作中随着代码越来越多，代码中各种 init，function，struct，全局变量感觉也越来越乱。每个模块不独立，看似按逻辑分了模块，但没有明确的上下层关系，每个模块里可能都存在配置读取，外部服务调用，协议转换等。久而久之服务不同包函数之间的调用慢慢演变成网状结构，数据流的流向和逻辑的梳理变得越来越复杂，很难不看代码调用的情况下搞清楚数据流向。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.785472972972973&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas7ZJjbRFkHmYsjMFO7Gvpia6zKNZNzgxtsJdUdmTDqERnYmTdUeDcicNZYL1Yu9V2nUhCZficRxo8yw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;592&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过就像《重构》中所说：先让代码工作起来-如果代码不能工作，就不能产生价值；然后再试图将它变好-通过对代码进行重构，让我们自己和其他人更好地理解代码，并能按照需求不断地修改代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我觉得是时候自我改变一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;The Clean Architecture&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在简洁架构里面对我们的项目提出了几点要求：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;独立于框架。该架构不依赖于某些功能丰富的软件库的存在。这允许你把这些框架作为工具来使用，而不是把你的系统塞进它们有限的约束中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可测试。业务规则可以在没有 UI、数据库、Web 服务器或任何其他外部元素的情况下被测试。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;独立于用户界面。UI 可以很容易地改变，而不用改变系统的其他部分。例如，一个 Web UI 可以被替换成一个控制台 UI，而不改变业务规则。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;独立于数据库。你可以把 Oracle 或 SQL Server 换成 Mongo、BigTable、CouchDB 或其他东西。你的业务规则不受数据库的约束。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;独立于任何外部机构。事实上，你的业务规则根本不知道外部世界的任何情况。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7344559585492227&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas7ZJjbRFkHmYsjMFO7Gvpia1Mic3QVs9ohKJicsI0n0ia2x8EQTWxwwiaA3jrSKLEzox7Ak4iaDiaRkuVKg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;772&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图中同心圆代表各种不同领域的软件。一般来说，越深入代表你的软件层次越高。外圆是战术实现机制，内圆的是战略核心策略。对于我们的项目来说，代码依赖应该由外向内，单向单层依赖，这种依赖包含代码名称，或类的函数，变量或任何其他命名软件实体。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于简洁架构来说分为了四层：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Entities：实体&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Usecase：表达应用业务规则，对应的是应用层，它封装和实现系统的所有用例；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Interface Adapters：这一层的软件基本都是一些适配器，主要用于将用例和实体中的数据转换为外部系统如数据库或 Web 使用的数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Framework &amp;amp; Driver：最外面一圈通常是由一些框架和工具组成，如数据库 Database, Web 框架等；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么对于我的项目来说，也分为了四层：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5564516129032258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas7ZJjbRFkHmYsjMFO7GvpiaOV1uicwcx1wjU7LWLQhAtf4Vlk2KOT9ktnHK2QQ8DwBsJIAwrSCQiaRg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;代码分层&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;models&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;封装了各种实体类对象，与数据库交互的、与 UI 交互的等等，任何的实体类都应该放在这里。如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Article &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; ID        &lt;span&gt;int64&lt;/span&gt;     &lt;span&gt;`json:&quot;id&quot;`&lt;/span&gt;&lt;br/&gt; Title     &lt;span&gt;string&lt;/span&gt;    &lt;span&gt;`json:&quot;title&quot;`&lt;/span&gt;&lt;br/&gt; Content   &lt;span&gt;string&lt;/span&gt;    &lt;span&gt;`json:&quot;content&quot;`&lt;/span&gt;&lt;br/&gt; UpdatedAt time.Time &lt;span&gt;`json:&quot;updated_at&quot;`&lt;/span&gt;&lt;br/&gt; CreatedAt time.Time &lt;span&gt;`json:&quot;created_at&quot;`&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;repo&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里存放的是数据库操作类，数据库 CRUD 都在这里。需要注意的是，这里不包含任何的业务逻辑代码，很多同学喜欢将业务逻辑也放到这里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果使用 ORM，那么这里放入的 ORM 操作相关的代码；如果使用微服务，那么这里放的是其他服务请求的代码；&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;service&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是业务逻辑层，所有的业务过程处理代码都应该放在这里。这一层会决定是请求 repo 层的什么代码，是操作数据库还是调用其他服务；所有的业务数据计算也应该放在这里；这里接受的入参应该是 controller 传入的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;api&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是接收外部请求的代码，如：gin 对应的 handler、gRPC、其他 REST API 框架接入层等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;面向接口编程&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了 models 层，层与层之间应该通过接口交互，而不是实现。如果要用 service 调用 repo 层，那么应该调用 repo 的接口。那么修改底层实现的时候我们上层的基类不需要变更，只需要更换一下底层实现即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如我们想要将所有文章查询出来，那么可以在 repo 提供这样的接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; repo&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;context&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/models&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// IArticleRepo represent the article&#x27;s repository contract&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; IArticleRepo &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; Fetch(ctx context.Context, createdDate time.Time, num &lt;span&gt;int&lt;/span&gt;) (res []models.Article, err error)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个接口的实现类就可以根据需求变更，比如说当我们想要 mysql 来作为存储查询，那么只需要提供一个这样的基类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; mysqlArticleRepository &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; DB *gorm.DB&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// NewMysqlArticleRepository will create an object that represent the article.Repository interface&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewMysqlArticleRepository&lt;/span&gt;&lt;span&gt;(DB *gorm.DB)&lt;/span&gt; &lt;span&gt;IArticleRepo&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &amp;amp;mysqlArticleRepository{DB}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m *mysqlArticleRepository)&lt;/span&gt; &lt;span&gt;Fetch&lt;/span&gt;&lt;span&gt;(ctx context.Context, createdDate time.Time,&lt;br/&gt; num &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(res []models.Article, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt; err = m.DB.WithContext(ctx).Model(&amp;amp;models.Article{}).&lt;br/&gt;  Select(&lt;span&gt;&quot;id,title,content, updated_at, created_at&quot;&lt;/span&gt;).&lt;br/&gt;  Where(&lt;span&gt;&quot;created_at &amp;gt; ?&quot;&lt;/span&gt;, createdDate).Limit(num).Find(&amp;amp;res).Error&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果改天想要换成 MongoDB 来实现我们的存储，那么只需要定义一个结构体实现 IArticleRepo 接口即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么在 service 层实现的时候就可以按照我们的需求来将对应的 repo 实现注入即可，从而不需要改动 service 层的实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; articleService &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; articleRepo repo.IArticleRepo&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// NewArticleService will create new an articleUsecase object representation of domain.ArticleUsecase interface&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewArticleService&lt;/span&gt;&lt;span&gt;(a repo.IArticleRepo)&lt;/span&gt; &lt;span&gt;IArticleService&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &amp;amp;articleService{&lt;br/&gt;  articleRepo: a,&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Fetch&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(a *articleService)&lt;/span&gt; &lt;span&gt;Fetch&lt;/span&gt;&lt;span&gt;(ctx context.Context, createdDate time.Time, num &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(res []models.Article, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; num == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  num = &lt;span&gt;10&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; res, err = a.articleRepo.Fetch(ctx, createdDate, num)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;依赖注入 DI&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;依赖注入，英文名 dependency injection，简称 DI 。DI 以前在 java 工程里面经常遇到，但是在 go 里面很多人都说不需要，但是我觉得在大型软件开发过程中还是有必要的，否则只能通过全局变量或者方法参数来进行传递。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于具体什么是 DI，简单来说就是被依赖的模块，在创建模块时，被注入到（即当作参数传入）模块的里面。想要更加深入的了解什么是 DI 这里再推荐一下 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Dependency_injection&quot; data-linktype=&quot;2&quot;&gt;Dependency injection &lt;/a&gt;和 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//martinfowler.com/articles/injection.html&quot; data-linktype=&quot;2&quot;&gt;Inversion of Control Containers and the Dependency Injection pattern&lt;/a&gt; 这两篇文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不用 DI 主要有两大不方便的地方，一个是底层类的修改需要修改上层类，在大型软件开发过程中基类是很多的，一条链路改下来动辄要修改几十个文件；另一方面就是就是层与层之间单元测试不太方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为采用了依赖注入，在初始化的过程中就不可避免的会写大量的 new，比如我们的项目中需要这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/api&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/api/handlers&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/app&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/repo&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/service&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// 初始化db&lt;/span&gt;&lt;br/&gt; db := app.InitDB()&lt;br/&gt; &lt;span&gt;//初始化 repo&lt;/span&gt;&lt;br/&gt; repository := repo.NewMysqlArticleRepository(db)&lt;br/&gt; &lt;span&gt;//初始化service&lt;/span&gt;&lt;br/&gt; articleService := service.NewArticleService(repository)&lt;br/&gt; &lt;span&gt;//初始化api&lt;/span&gt;&lt;br/&gt; handler := handlers.NewArticleHandler(articleService)&lt;br/&gt; &lt;span&gt;//初始化router&lt;/span&gt;&lt;br/&gt; router := api.NewRouter(handler)&lt;br/&gt; &lt;span&gt;//初始化gin&lt;/span&gt;&lt;br/&gt; engine := app.NewGinEngine()&lt;br/&gt; &lt;span&gt;//初始化server&lt;/span&gt;&lt;br/&gt; server := app.NewServer(engine, router)&lt;br/&gt; &lt;span&gt;//启动&lt;/span&gt;&lt;br/&gt; server.Start()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么对于这么一段代码，我们有没有办法不用自己写呢？这里我们就可以借助框架的力量来生成我们的注入代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 go 里面 DI 的工具相对来说没有 java 这么方便，技术框架一般主要有：wire、dig、fx 等。由于 wire 是使用代码生成来进行注入，性能会比较高，并且它是 google 推出的 DI 框架，所以我们这里使用 wire 进行注入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;wire 的要求很简单，新建一个 wire.go 文件（文件名可以随意），创建我们的初始化函数。比如，我们要创建并初始化一个 server 对象，我们就可以这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//+build wireinject&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;github.com/google/wire&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/api&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/api/handlers&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/app&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/repo&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/service&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;InitServer&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; *&lt;span&gt;app&lt;/span&gt;.&lt;span&gt;Server&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; wire.Build(&lt;br/&gt;  app.InitDB,&lt;br/&gt;  repo.NewMysqlArticleRepository,&lt;br/&gt;  service.NewArticleService,&lt;br/&gt;  handlers.NewArticleHandler,&lt;br/&gt;  api.NewRouter,&lt;br/&gt;  app.NewServer,&lt;br/&gt;  app.NewGinEngine)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &amp;amp;app.Server{}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，第一行的注解：+build wireinject，表示这是一个注入器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在函数中，我们调用&lt;code&gt;wire.Build()&lt;/code&gt;将创建 Server 所依赖的类型的构造器传进去。写完 wire.go 文件之后执行 wire 命令，就会自动生成一个 wire_gen.go 文件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Code generated by Wire. DO NOT EDIT.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//go:generate go run github.com/google/wire/cmd/wire&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//+build !wireinject&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/api&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/api/handlers&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/app&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/repo&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/service&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Injectors from wire.go:&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;InitServer&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; *&lt;span&gt;app&lt;/span&gt;.&lt;span&gt;Server&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; engine := app.NewGinEngine()&lt;br/&gt; db := app.InitDB()&lt;br/&gt; iArticleRepo := repo.NewMysqlArticleRepository(db)&lt;br/&gt; iArticleService := service.NewArticleService(iArticleRepo)&lt;br/&gt; articleHandler := handlers.NewArticleHandler(iArticleService)&lt;br/&gt; router := api.NewRouter(articleHandler)&lt;br/&gt; server := app.NewServer(engine, router)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; server&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到 wire 自动帮我们生成了 InitServer 方法，此方法中依次初始化了所有要初始化的基类。之后在我们的 main 函数中就只需调用这个 InitServer 即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; server := InitServer()&lt;br/&gt; server.Start()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;测试&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面我们定义好了每一层应该做什么，那么对于每一层我们应该都是可单独测试的，即使另外一层不存在。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;models 层：这一层就很简单了，由于没有依赖任何其他代码，所以可以直接用 go 的单测框架直接测试即可；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;repo 层：对于这一层来说，由于我们使用了 mysql 数据库，那么我们需要 mock mysql，这样即使不用连 mysql 也可以正常测试，我这里使用 github.com/DATA-DOG/go-sqlmock 这个库来 mock 我们的数据库；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;service 层：因为 service 层依赖了 repo 层，因为它们之间是通过接口来关联，所以我这里使用 github.com/golang/mock/gomock 来 mock repo 层；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;api 层：这一层依赖 service 层，并且它们之间是通过接口来关联，所以这里也可以使用 gomock 来 mock service 层。不过这里稍微麻烦了一点，因为我们接入层用的是 gin，所以还需要在单测的时候模拟发送请求；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于我们是通过 github.com/golang/mock/gomock 来进行 mock ，所以需要执行一下代码生成，生成的 mock 代码我们放入到 mock 包中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;mockgen -destination .\mock\repo_mock.go -&lt;span&gt;source&lt;/span&gt; .\repo\repo.go -package mock&lt;br/&gt;&lt;br/&gt;mockgen -destination .\mock\service_mock.go -&lt;span&gt;source&lt;/span&gt; .\service\service.go -package mock&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这两个命令会通过接口帮我自动生成 mock 函数。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;repo 层测试&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在项目中，由于我们用了 gorm 来作为我们的 orm 库，所以我们需要使用 github.com/DATA-DOG/go-sqlmock 结合 gorm 来进行 mock：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;getSqlMock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(mock sqlmock.Sqlmock, gormDB *gorm.DB)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;//创建sqlmock&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; err error&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; db *sql.DB&lt;br/&gt; db, mock, err = sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;panic&lt;/span&gt;(err)&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;//结合gorm、sqlmock&lt;/span&gt;&lt;br/&gt; gormDB, err = gorm.Open(mysql.New(mysql.Config{&lt;br/&gt;  SkipInitializeWithVersion: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  Conn:                      db,&lt;br/&gt; }), &amp;amp;gorm.Config{})&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; != err {&lt;br/&gt;  log.Fatalf(&lt;span&gt;&quot;Init DB with sqlmock failed, err %v&quot;&lt;/span&gt;, err)&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Test_mysqlArticleRepository_Fetch&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; createAt := time.Now()&lt;br/&gt; updateAt := time.Now()&lt;br/&gt; &lt;span&gt;//id,title,content, updated_at, created_at&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; articles = []models.Article{&lt;br/&gt;  {&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;test1&quot;&lt;/span&gt;, &lt;span&gt;&quot;content&quot;&lt;/span&gt;, updateAt, createAt},&lt;br/&gt;  {&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&quot;test2&quot;&lt;/span&gt;, &lt;span&gt;&quot;content2&quot;&lt;/span&gt;, updateAt, createAt},&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; limit := &lt;span&gt;2&lt;/span&gt;&lt;br/&gt; mock, db := getSqlMock()&lt;br/&gt;&lt;br/&gt; mock.ExpectQuery(&lt;span&gt;&quot;SELECT id,title,content, updated_at, created_at FROM `articles` WHERE created_at &amp;gt; ? LIMIT 2&quot;&lt;/span&gt;).&lt;br/&gt;  WithArgs(createAt).&lt;br/&gt;  WillReturnRows(sqlmock.NewRows([]&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;id&quot;&lt;/span&gt;, &lt;span&gt;&quot;title&quot;&lt;/span&gt;, &lt;span&gt;&quot;content&quot;&lt;/span&gt;, &lt;span&gt;&quot;updated_at&quot;&lt;/span&gt;, &lt;span&gt;&quot;created_at&quot;&lt;/span&gt;}).&lt;br/&gt;   AddRow(articles[&lt;span&gt;0&lt;/span&gt;].ID, articles[&lt;span&gt;0&lt;/span&gt;].Title, articles[&lt;span&gt;0&lt;/span&gt;].Content, articles[&lt;span&gt;0&lt;/span&gt;].UpdatedAt, articles[&lt;span&gt;0&lt;/span&gt;].CreatedAt).&lt;br/&gt;   AddRow(articles[&lt;span&gt;1&lt;/span&gt;].ID, articles[&lt;span&gt;1&lt;/span&gt;].Title, articles[&lt;span&gt;1&lt;/span&gt;].Content, articles[&lt;span&gt;1&lt;/span&gt;].UpdatedAt, articles[&lt;span&gt;1&lt;/span&gt;].CreatedAt))&lt;br/&gt;&lt;br/&gt; repository := NewMysqlArticleRepository(db)&lt;br/&gt; result, err := repository.Fetch(context.TODO(), createAt, limit)&lt;br/&gt;&lt;br/&gt; assert.Nil(t, err)&lt;br/&gt; assert.Equal(t, articles, result)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;service 层测试&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里主要就是用我们 gomock 生成的代码来 mock repo 层：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Test_articleService_Fetch&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; ctl := gomock.NewController(t)&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; ctl.Finish()&lt;br/&gt; now := time.Now()&lt;br/&gt; mockRepo := mock.NewMockIArticleRepo(ctl)&lt;br/&gt;&lt;br/&gt; gomock.InOrder(&lt;br/&gt;  mockRepo.EXPECT().Fetch(context.TODO(), now, &lt;span&gt;10&lt;/span&gt;).Return(&lt;span&gt;nil&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;),&lt;br/&gt; )&lt;br/&gt;&lt;br/&gt; service := NewArticleService(mockRepo)&lt;br/&gt;&lt;br/&gt; fetch, _ := service.Fetch(context.TODO(), now, &lt;span&gt;10&lt;/span&gt;)&lt;br/&gt; fmt.Println(fetch)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;api 层测试&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于这一层，我们不仅要 mock service 层，还需要发送 httptest 来模拟请求发送：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestArticleHandler_FetchArticle&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt; ctl := gomock.NewController(t)&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; ctl.Finish()&lt;br/&gt; createAt, _ := time.Parse(&lt;span&gt;&quot;2006-01-02&quot;&lt;/span&gt;, &lt;span&gt;&quot;2021-12-26&quot;&lt;/span&gt;)&lt;br/&gt; mockService := mock.NewMockIArticleService(ctl)&lt;br/&gt;&lt;br/&gt; gomock.InOrder(&lt;br/&gt;  mockService.EXPECT().Fetch(gomock.Any(), createAt, &lt;span&gt;10&lt;/span&gt;).Return(&lt;span&gt;nil&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;),&lt;br/&gt; )&lt;br/&gt;&lt;br/&gt; article := NewArticleHandler(mockService)&lt;br/&gt;&lt;br/&gt; gin.SetMode(gin.TestMode)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Setup your router, just like you did in your main function, and&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// register your routes&lt;/span&gt;&lt;br/&gt; r := gin.Default()&lt;br/&gt; r.GET(&lt;span&gt;&quot;/articles&quot;&lt;/span&gt;, article.FetchArticle)&lt;br/&gt;&lt;br/&gt; req, err := http.NewRequest(http.MethodGet, &lt;span&gt;&quot;/articles?num=10&amp;amp;create_date=2021-12-26&quot;&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  t.Fatalf(&lt;span&gt;&quot;Couldn&#x27;t create request: %v\n&quot;&lt;/span&gt;, err)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; w := httptest.NewRecorder()&lt;br/&gt; &lt;span&gt;// Perform the request&lt;/span&gt;&lt;br/&gt; r.ServeHTTP(w, req)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Check to see if the response was what you expected&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; w.Code != http.StatusOK {&lt;br/&gt;  t.Fatalf(&lt;span&gt;&quot;Expected to get status %d but instead got %d\n&quot;&lt;/span&gt;, http.StatusOK, w.Code)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是我对 golang 的项目中发现问题的一点点总结与思考，思考的先不管对不对，总归是解决了我们当下的一些问题。不过，项目总归是需要不断重构完善的，所以下次有问题的时候下次再改呗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于我上面的总结和描述感觉有不对的地方，请随时指出来一起讨论。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目代码位置：https://github.com/devYun/go-clean-architecture&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;Reference&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://github.com/bxcodec/go-clean-arch&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://medium.com/hackernoon/golang-clean-archithecture-efd6d7c43047&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://farer.org/2021/04/21/go-dependency-injection-wire/&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAA0_UNB6vpCAAAAAstQy6ubaLX4KHWvLEZgBPE0aI4ZQMdbqX8zNPgMItZQQz4rQdaRbVIBysIUiC8&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7Ym3K77SEULgkialjqVumGh686o9cicHyYnbAb5R4UXceUUaUEurOc2IPUzKspc9alaHjby4Yx0oLv0wEgoFGgcGgWr1X06rsBywTA&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SZ&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdXHXUb10FCpaLrBro4SnibHBTMwCnlic495e1C5zumZNOPzZG0ydlmopuficFcAhfROkY&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;数学真的很美&amp;#10;&amp;#10;#代码 #codepen&amp;#10;&quot; data-nonceid=&quot;14800752956677343128&quot; data-type=&quot;video&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5b5757ec885e4503627332fd4429e9f4</guid>
<title>携程的混合办公，到底行不行？12个Vue小技巧；2022年之Web开发新基准｜码农周刊VIP会员专属邮件周报 Vol.080</title>
<link>https://toutiao.io/k/lk15pdx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bd7939ae190ad84b93178027a966482e</guid>
<title>一款开源NFT市场</title>
<link>https://toutiao.io/k/xsynx5j</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e8c06cf843925534975c8f755b9f7b17</guid>
<title>Golang 语言 gRPC 服务怎么同时支持 gRPC 和 HTTP 客户端调用？</title>
<link>https://toutiao.io/k/emhzf5r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;大家好，我是 frank。&lt;br/&gt;欢迎大家点击标题下方&lt;span&gt;蓝色&lt;/span&gt;文字「Golang 语言开发栈」关注公众号。&lt;br/&gt;&lt;strong&gt;设为星标&lt;/strong&gt;，第一时间接收推送文章。&lt;br/&gt;&lt;strong&gt;文末扫码&lt;/strong&gt;，加群一起学 Golang 语言。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;介绍&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于 gRPC 的文章，我们之前写过几篇，如果读者朋友还对 gRPC 不了解，我建议您可以翻阅一下公众号的历史文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们需要提供 gRPC 服务的 RESTful API 时，可以先创建一个 gRPC 客户端服务，在 gRPC 客户端服务编写 RESTful API，接收到 HTTP 请求时，通过 gRPC 客户端服务调用 gRPC 服务端服务的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信读者朋友们也意识到，仅仅为了提供 RESTful API 而编写一个 gRPC 客户端服务，显然有些小题大做。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在不借助 gRPC 客户端服务的前提下，gRPC 服务端服务怎么同时支持 gRPC 和 HTTP 客户端调用？今天我们介绍一个 protoc 插件 gRPC-Gateway。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;gRPC-Gateway&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;gRPC-Gateway 是 protoc 的一个插件。它读取 gRPC 服务定义并生成一个反向代理服务器，该服务器将 RESTful JSON API 转换为 gRPC。此服务器是根据 gRPC 定义中的自定义选项生成的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;gRPC-Gateway 可帮助您同时以 gRPC 和 RESTful 风格提供 API。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们开始编码之前，需要一些先决条件。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先，我们需要先搭建一个 Go 环境。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 go get 工具下载一些依赖包。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 go mod init 工具创建一个 go.mod 文件。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;依赖包列表：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; go get github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-grpc-gateway&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; go get google.golang.org/protobuf/cmd/protoc-gen-go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; go get google.golang.org/grpc/cmd/protoc-gen-go-grpc&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;gRPC-Gateway 实战&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在完成以上先决条件后，我们创建一个 gRPC 服务端服务，本文我们创建一个 ToDoList gRPC 服务。在创建 gRPC 服务之前，我们使用 protocol buffers 创建一个 proto 文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;创建 proto 文件&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;service ToDoList {&lt;br/&gt;  rpc CreateToDoList (ToDoListDetail) returns (CreateToDoListResult) {}&lt;br/&gt;  rpc ReadToDoList (ToDoListPage) returns (ReadToDoListByPage) {}&lt;br/&gt;}&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;生成 gRPC 服务端存根&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 protoc 命令工具生成存根&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;protoc -I proto \&lt;br/&gt;   --go_out &lt;span&gt;./pb/todoPb&lt;/span&gt; --go_opt paths=source_relative \&lt;br/&gt;   --go-grpc_out ./pb/todoPb --go-grpc_opt paths=source_relative \&lt;br/&gt;   proto/toDoList.proto&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行上面 protoc 命令工具，生成一个 &lt;code&gt;*.pb.go&lt;/code&gt; 文件和一个 &lt;code&gt;*_grpc.pb.go&lt;/code&gt; 文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;编写剩余 Go 代码&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建 main.go&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; InitEngine()&lt;br/&gt; lis, err := net.Listen(&lt;span&gt;&quot;tcp&quot;&lt;/span&gt;, address)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  log.Fatalf(&lt;span&gt;&quot;failed to listen: %v&quot;&lt;/span&gt;, err)&lt;br/&gt; }&lt;br/&gt; server := grpc.NewServer()&lt;br/&gt; pb.RegisterToDoListServer(server, &lt;span&gt;new&lt;/span&gt;(service.ToDoList))&lt;br/&gt; log.Printf(&lt;span&gt;&quot;server listening at %v\n&quot;&lt;/span&gt;, lis.Addr())&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err := server.Serve(lis); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  log.Fatalf(&lt;span&gt;&quot;failed to serve: %v&quot;&lt;/span&gt;, err)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;blockquote&gt;&lt;blockquote&gt;&lt;p&gt;完整代码，请参阅 Github。&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;添加 gRPC-Gateway 选项&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;gRPC-Gateway 使用 google.api.http 选项定义 gRPC 服务如何映射到 JSON 请求和响应，使用 protoc 时，每个 RPC 必须使用 google.api.http 选项定义 HTTP 方法和路径。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，我们需要将 google/api/http.proto 导入添加到 proto 文件中。我们还需要添加我们想要的 HTTP -&amp;gt; gRPC 映射。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;syntax = &quot;proto3&quot;;&lt;br/&gt;&lt;br/&gt;import &quot;google/api/annotations.proto&quot;;&lt;br/&gt;&lt;br/&gt;service ToDoList {&lt;br/&gt;  rpc CreateToDoList (ToDoListDetail) returns (CreateToDoListResult) {&lt;br/&gt;    option (google.api.http) = {&lt;br/&gt;      post: &quot;/v1/todolist/add&quot;&lt;br/&gt;      body: &quot;*&quot;&lt;br/&gt;    };&lt;br/&gt;  }&lt;br/&gt;  rpc ReadToDoList (ToDoListPage) returns (ReadToDoListByPage) {&lt;br/&gt;    option (google.api.http) = {&lt;br/&gt;      get: &quot;/v1/todolist/select&quot;&lt;br/&gt;    };&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于 HTTP 和 gRPC 映射的更多内容，可以参阅 Google API 文档。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;生成 gRPC-Gateway 存根&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，我们已将 gRPC-Gateway 选项添加到 proto 文件中，我们需要使用 gRPC-Gateway 生成器来生成存根。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用 protoc 生成存根之前，我们需要将一些依赖项复制到 proto 文件目录中。将 googleapis 的子集从官方存储库下载并复制到本地 proto 文件目录中。如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;.&lt;br/&gt;├── dao&lt;br/&gt;│   ├── mysql.go&lt;br/&gt;│   └── toDoList.go&lt;br/&gt;├── grpc-gateway&lt;br/&gt;│   └── main.go&lt;br/&gt;├── main.go&lt;br/&gt;├── pb&lt;br/&gt;│   └── todoPb&lt;br/&gt;│       ├── toDoList.pb.go&lt;br/&gt;│       ├── toDoList.pb.gw.go&lt;br/&gt;│       └── toDoList_grpc.pb.go&lt;br/&gt;├── proto&lt;br/&gt;│   ├── google&lt;br/&gt;│   │   └── api&lt;br/&gt;│   │       ├── annotations.proto&lt;br/&gt;│   │       └── http.proto&lt;br/&gt;│   └── toDoList.proto&lt;br/&gt;└── service&lt;br/&gt;    └── toDoList.go&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 protoc 生成存根&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;protoc -I proto \&lt;br/&gt;  --go_out ./pb/todoPb --go_opt paths=source_relative \&lt;br/&gt;  --go-grpc_out ./pb/todoPb --go-grpc_opt paths=source_relative \&lt;br/&gt;  --grpc-gateway_out ./pb/todoPb --grpc-gateway_opt paths=source_relative \&lt;br/&gt;  proto/toDoList.proto&lt;br/&gt;  &lt;br/&gt;protoc-go-inject-tag -XXX_skip=xorm -input=./pb/todoPb/toDoList.pb.go&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行以上 protoc 命令工具，生成一个 &lt;code&gt;*.gw.pb.go&lt;/code&gt; 文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建 grpc-gateway 目录，并创建 main.go 文件，创建 gRPC-Gateway 多路复用器。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; ctx := context.Background()&lt;br/&gt; ctx, cancel := context.WithCancel(ctx)&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; cancel()&lt;br/&gt;&lt;br/&gt; mux := runtime.NewServeMux()&lt;br/&gt; opts := []grpc.DialOption{grpc.WithTransportCredentials(insecure.NewCredentials())}&lt;br/&gt; err := pb.RegisterToDoListHandlerFromEndpoint(ctx, mux, grpcServerEndpoint, opts)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  log.Fatalf(&lt;span&gt;&quot;Fail to register gRPC gateway service endpoint: %v&quot;&lt;/span&gt;, err)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err = http.ListenAndServe(&lt;span&gt;&quot;:8080&quot;&lt;/span&gt;, mux); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  log.Fatalf(&lt;span&gt;&quot;Could not setup HTTP endpoint: %v&quot;&lt;/span&gt;, err)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;blockquote&gt;&lt;blockquote&gt;&lt;p&gt;完整代码，请参阅 Github。&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;启动服务&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;grpc 服务&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go run main.go&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;gRPC-Gateway&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go run grpc-gateway/main.go&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;cURL 测试&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;curl http://127.0.0.1:8080/v1/todolist/select?page=1&amp;amp;count=2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;响应结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;    &lt;span&gt;&quot;todolist&quot;&lt;/span&gt;: [&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;&quot;id&quot;&lt;/span&gt;: &lt;span&gt;&quot;1&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;content&quot;&lt;/span&gt;: &lt;span&gt;&quot;编程写代码&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;datetime&quot;&lt;/span&gt;: &lt;span&gt;&quot;1632541505&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;created&quot;&lt;/span&gt;: &lt;span&gt;&quot;1632541505&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;updated&quot;&lt;/span&gt;: &lt;span&gt;&quot;1632541505&quot;&lt;/span&gt;&lt;br/&gt;        },&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;&quot;id&quot;&lt;/span&gt;: &lt;span&gt;&quot;2&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;content&quot;&lt;/span&gt;: &lt;span&gt;&quot;编程写代码&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;datetime&quot;&lt;/span&gt;: &lt;span&gt;&quot;1632543373&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;created&quot;&lt;/span&gt;: &lt;span&gt;&quot;1632543373&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;updated&quot;&lt;/span&gt;: &lt;span&gt;&quot;1632543373&quot;&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    ]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;04 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们介绍 gRPC-Gateway 如何实现同时支持 gRPC 和 RESTful 风格的 API。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 HTTP 请求到达 gRPC-Gateway 时，它会将 JSON 数据解析为 protobuf 消息。然后，它使用解析的 protobuf 消息发出正常的 Go gRPC 客户端请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go gRPC 客户端将 protobuf 结构编码为 protobuf 二进制格式，并将其发送到 gRPC 服务器。gRPC 服务器处理请求并以 protobuf 二进制格式返回响应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go gRPC 客户端将其解析为 protobuf 消息，并将其返回到 gRPC-Gateway，后者将 protobuf 消息编码为 JSON 并将其返回到原始客户端。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7057220708446866&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gf7zJ2NXUibGsSgtDw5dk9tGslAGJFHzho58JAia7HZxgLAjoIyL4dUrEkIaQtcA4GSfNf4iaMhMT2kRgqBXANNVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1468&quot;/&gt;&lt;/p&gt;&lt;p&gt;图片来自 gRPC-Gateway 官方文档&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247485838&amp;amp;idx=1&amp;amp;sn=d0614ea793a8407b943e6c66a1dedb58&amp;amp;chksm=9f81a3e0a8f62af6a0f1260ac4c40b2a76855606f874b67944057f1ee2d2495960cbc120205d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Golang 语言怎么打印结构体指针类型字段的值？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Golang 语言怎么打印结构体指针类型字段的值？&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247485227&amp;amp;idx=1&amp;amp;sn=057e69ee48a8ad55a759afc53bcdd349&amp;amp;chksm=9f81ad45a8f62453c8c3fcc258cae92ea061e490d229fe223cff2c3c2bf15c86c34026fea6b3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Golang 语言 gRPC 使用的接口设计语言 protobuf&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Golang 语言 gRPC 使用的接口设计语言 protobuf&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247485291&amp;amp;idx=1&amp;amp;sn=89626702df6d071c121b79a72d04d348&amp;amp;chksm=9f81ad05a8f62413a4c3e8aabbec696e53b3e62477e24855a43dd122f199347a03833f10b7c7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Golang 语言 gRPC 到底是什么？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Golang 语言 gRPC 到底是什么？&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247485338&amp;amp;idx=1&amp;amp;sn=c5f3ae0f7a7d81621c8ecfcd745d386a&amp;amp;chksm=9f81adf4a8f624e280927dd758fbae212b4e1d8ae02d52a42bf0787aa411d4797943b7123543&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Golang 语言 gRPC 怎么使用？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Golang 语言 gRPC 怎么使用？&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247485405&amp;amp;idx=1&amp;amp;sn=909ee026535a88d632bfcd3c120c571f&amp;amp;chksm=9f81adb3a8f624a5a5bf2d2740024f94e700ac3bd01b589691c04df13fff646dbe9cc11ab3dc&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Golang 语言编写 gRPC 实战项目&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Golang 语言编写 gRPC 实战项目&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;br/&gt;https://github.com/grpc-ecosystem/grpc-gateway &lt;br/&gt;https://github.com/googleapis/googleapis &lt;br/&gt;https://github.com/googleapis/googleapis.github.io/ &lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9e7ab6e88b40fca3236188b2cea3a677</guid>
<title>还在用ES查日志吗，快看看石墨文档 Clickhouse 日志架构玩法</title>
<link>https://toutiao.io/k/pqacedc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2&gt;1 背景&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;石墨文档全部应用部署在Kubernetes上，每时每刻都会有大量的日志输出，我们之前主要使用SLS和ES作为日志存储。但是我们在使用这些组件的时候，发现了一些问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们经过一番调研后，发现使用Clickhouse能够很好的解决以上问题，并且Clickhouse省存储空间，非常省钱，所以我们选择了Clickhouse方案存储日志。但当我们深入研究后，Clickhouse作为日志存储有许多落地的细节，但业界并没有很好阐述相关Clickhouse采集日志的整套流程，以及没有一款优秀的Clickhouse日志查询工具帮助分析日志，为此我们写了一套Clickhouse日志系统贡献给开源社区，并将Clickhouse的日志采集架构的经验做了总结。先上个Clickhouse日志查询界面，让大家感受下石墨最懂前端的后端程序员。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45555555555555555&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOMWWU8ZTZO7g79A0N2xvpdkZBwibyvClDdvhzYSEJT6cRYRZe7vyMtMmakJsGKnCkHv5VBPRh7peiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;2 架构原理图&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们将日志系统分为四个部分：日志采集、日志传输、日志存储、日志管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47314814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOMWWU8ZTZO7g79A0N2xvpdkGibW2a4icu6kdRWXibhkRz3RuF2Iic7lOuqFSl41oIcONsxu8XztP3ACHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下我们按照这四大部分，阐述其中的架构原理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;3 日志采集&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;3.1 采集方式&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kubernetes容器内日志收集的方式通常有以下三种方案&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下是三种采集方式的优缺点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.35234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOMWWU8ZTZO7g79A0N2xvpdkfaY5RO1OWfzwuJ2e8261DlBRZLuLpvSPSPKmPfMJkVEib8kPVQWibdGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们主要采用DaemonSet方式和网络方式采集日志。DaemonSet方式用于ingress、应用日志的采集，网络方式用于大数据日志的采集。以下我们主要介绍下DeamonSet方式的采集方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;3.2 日志输出&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上面的介绍中可以看到，我们的DaemonSet会有两种方式采集日志类型，一种是标准输出，一种是文件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;引用元乙的描述：虽然使用 Stdout 打印日志是 Docker 官方推荐的方式，但大家需要注意：这个推荐是基于容器只作为简单应用的场景，实际的业务场景中我们还是建议大家尽可能使用文件的方式，主要的原因有以下几点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Stdout 性能问题，从应用输出 stdout 到服务端，中间会经过好几个流程（例如普遍使用的JSONLogDriver）：应用 stdout -&amp;gt; DockerEngine -&amp;gt; LogDriver -&amp;gt; 序列化成 JSON -&amp;gt; 保存到文件 -&amp;gt; Agent 采集文件 -&amp;gt; 解析 JSON -&amp;gt; 上传服务端。整个流程相比文件的额外开销要多很多，在压测时，每秒 10 万行日志输出就会额外占用 DockerEngine 1 个 CPU 核；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Stdout 不支持分类，即所有的输出都混在一个流中，无法像文件一样分类输出，通常一个应用中有 AccessLog、ErrorLog、InterfaceLog（调用外部接口的日志）、TraceLog 等，而这些日志的格式、用途不一，如果混在同一个流中将很难采集和分析；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从这个描述中，我们可以看出在docker中输出文件在采集到日志中心是一个更好的实践。所有日志采集工具都支持采集文件日志方式，但是我们在配置日志采集规则的时候，发现开源的一些日志采集工具，例如fluentbit、filebeat在DaemonSet部署下采集文件日志是不支持追加例如pod、namespace、container_name、container_id等label信息，并且也无法通过这些label做些定制化的日志采集。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.30546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOMWWU8ZTZO7g79A0N2xvpdkPWaKQ1ShXX8sic61TfpFnpyIZXB46SE4DoXHKuBRNufrQE04iazDp84w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于无法追加label信息的原因，我们暂时放弃了DeamonSet部署下文件日志采集方式，采用的是基于DeamonSet部署下标准输出的采集方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;3.3 &lt;/span&gt;日志目录&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下列举了日志目录的基本情况&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.30546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOMWWU8ZTZO7g79A0N2xvpdk3epwTxZs4QxiaVM4mAPFs2ibEepmk4O7OOaNLQYCaaPib2jVVmg16WHVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为我们采集日志是使用的标准输出模式，所以根据上表我们的LogCollector只需要挂载/var/log，/var/lib/docker/containers两个目录。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;3.3.1 标准输出日志目录&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;应用的标准输出日志存储在/var/log/containers目录下，文件名是按照K8S日志规范生成的。这里以nginx-ingress的日志作为一个示例。我们通过ls /var/log/containers/ | grep nginx-ingress指令，可以看到nginx-ingress的文件名。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.03743961352657005&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOMWWU8ZTZO7g79A0N2xvpdkRWkQfXomJXQW9HNTAS04022NscIzrNsiaGR44FEc2ibOJQWqBCJSmjyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;nginx-ingress-controller-mt2wx_kube-system_nginx-ingress-controller-be3741043eca1621ec4415fd87546b1beb29480ac74ab1cdd9f52003cf4abf0a.log&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们参照K8S日志的规范：/var/log/containers/%{DATA:pod_name}_%{DATA:namespace}_%{GREEDYDATA:container_name}-%{DATA:container_id}.log。可以将nginx-ingress日志解析为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过以上的日志解析信息，我们的LogCollector 就可以很方便的追加pod、namespace、container_name、container_id的信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;3.3.2 容器信息目录&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;应用的容器信息存储在/var/lib/docker/containers目录下，目录下的每一个文件夹为容器ID，我们可以通过cat config.v2.json获取应用的docker基本信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1632016632016632&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOMWWU8ZTZO7g79A0N2xvpdkicmn3dTxIC5ibSMJaqqCiaibrQWuw13hpn0NHPwILeUwxz9czVQXgGZ22A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;962&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;3.4 LogCollector采集日志&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;h4&gt;&lt;strong&gt;3.4.1 配置&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们LogCollector采用的是fluent-bit，该工具是cncf旗下的，能够更好的与云原生相结合。通过Mogo系统可以选择Kubernetes集群，很方便的设置fluent-bit configmap的配置规则。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOMWWU8ZTZO7g79A0N2xvpdkC4OJeBFrw6A3MOFOkrQ61HI5LpnxEJibqAPeMaEj2ibHU9g1iaTwjGnmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4&gt;&lt;strong&gt;3.4.2 数据结构&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;fluent-bit的默认采集数据结构&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Clickhouse如果使用@timestamp的时候，因为里面有@特殊字符，会处理的有问题。所以我们在处理fluent-bit的采集数据结构，会做一些映射关系，并且规定双下划线为Mogo系统日志索引，避免和业务日志的索引冲突。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如你的日志记录的是{&quot;id&quot;:1}，那么实际fluent-bit采集的日志会是{&quot;_time_&quot;:&quot;2022-01-15...&quot;,&quot;_log_&quot;:&quot;{\&quot;id\&quot;:1}&quot; 该日志结构会直接写入到kafka中，Mogo系统会根据这两个字段_time_、_log_设置clickhouse中的数据表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;3.4.3 采集&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果我们要采集ingress日志，我们需要在input配置里，设置ingress的日志目录，fluent-bit会把ingress日志采集到内存里。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.217680608365019&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOMWWU8ZTZO7g79A0N2xvpdkYZpmgZLoLj7ZX7gA3qdriamoOibNedjTiao4J9DXnib1obctuM7A51gNng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1052&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后我们在filter配置里，将log改写为_log_&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25212121212121213&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOMWWU8ZTZO7g79A0N2xvpdkVFzgd5ia3xNIFicE5YPdsnicFQvwY0ib4pYXSicNrWeS3yxSEaBoOMKPiaPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;825&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后我们在ouput配置里，将追加的日志采集时间设置为_time_，设置好日志写入的kafka borkers和kafka topics，那么fluent-bit里内存的日志就会写入到kafka中&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2948294829482948&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOMWWU8ZTZO7g79A0N2xvpdkyfY4HSiaUSrAp3KH85lanDSq2zePxlIeZ808DZmvTI5DYfO3u0XLfyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;909&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;日志写入到Kafka中_log_需要为json，如果你的应用写入的日志不是json，那么你就需要根据fluent-bit的parser文档，调整你的日志写入的数据结构：https://docs.fluentbit.io/manual/pipeline/filters/parser&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;4 日志传输&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kafka主要用于日志传输。上文说到我们使用fluent-bit采集日志的默认数据结构，在下图kafka工具中我们可以看到日志采集的内容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5420641803989592&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOMWWU8ZTZO7g79A0N2xvpdkT46icVqAsvxjC6SWL8d6eaeP3H8jdAoNHv0jaKy1Kdsg4OKsI7UgD1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2306&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在日志采集过程中，会由于不用业务日志字段不一致，解析方式是不一样的。所以我们在日志传输阶段，需要将不同数据结构的日志，创建不同的Clickhouse表，映射到Kafka不同的Topic。这里以ingress为例，那么我们在Clickhouse中需要创建一个ingress_stdout_stream的Kafka引擎表，然后映射到Kafka的ingress-stdout Topic里。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;5 日志存储&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们会使用三种表，用于存储一种业务类型的日志。&lt;/span&gt;&lt;/p&gt;&lt;pre data-language=&quot;sql&quot;&gt;create table logger.ingress_stdout_stream&lt;br/&gt;(&lt;br/&gt;_source_ String,&lt;br/&gt;_pod_name_ String,&lt;br/&gt;_namespace_ String,&lt;br/&gt;_node_name_ String,&lt;br/&gt;_container_name_ String,&lt;br/&gt;_cluster_ String,&lt;br/&gt;_log_agent_ String,&lt;br/&gt;_node_ip_ String,&lt;br/&gt;_time_ Float64,&lt;br/&gt;_log_ String&lt;br/&gt;)&lt;br/&gt;engine = Kafka SETTINGS kafka_broker_list = &#x27;kafka:9092&#x27;, kafka_topic_list = &#x27;ingress-stdout&#x27;, kafka_group_name = &#x27;logger_ingress_stdout&#x27;, kafka_format = &#x27;JSONEachRow&#x27;, kafka_num_consumers = 1;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;pre data-language=&quot;sql&quot;&gt;CREATE MATERIALIZED VIEW logger.ingress_stdout_view TO logger.ingress_stdout AS&lt;br/&gt;SELECT&lt;br/&gt;    toDateTime(toInt64(_time_)) AS _time_second_,&lt;br/&gt;fromUnixTimestamp64Nano(toInt64(_time_*1000000000),&#x27;Asia/Shanghai&#x27;) AS _time_nanosecond_,&lt;br/&gt;_pod_name_,&lt;br/&gt;_namespace_,&lt;br/&gt;_node_name_,&lt;br/&gt;_container_name_,&lt;br/&gt;_cluster_,&lt;br/&gt;_log_agent_,&lt;br/&gt;_node_ip_,&lt;br/&gt;_source_,&lt;br/&gt;_log_ AS _raw_log_,JSONExtractInt(_log_, &#x27;status&#x27;) AS status,JSONExtractString(_log_, &#x27;url&#x27;) AS url&lt;br/&gt;FROM logger.ingress_stdout_stream where 1=1;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;pre data-language=&quot;sql&quot;&gt;create table logger.ingress_stdout&lt;br/&gt;(&lt;br/&gt;_time_second_ DateTime,&lt;br/&gt;_time_nanosecond_ DateTime64(9, &#x27;Asia/Shanghai&#x27;),&lt;br/&gt;_source_ String,&lt;br/&gt;_cluster_ String,&lt;br/&gt;_log_agent_ String,&lt;br/&gt;_namespace_ String,&lt;br/&gt;_node_name_ String,&lt;br/&gt;_node_ip_ String,&lt;br/&gt;_container_name_ String,&lt;br/&gt;_pod_name_ String,&lt;br/&gt;_raw_log_ String,&lt;br/&gt;status Nullable(Int64),&lt;br/&gt;url Nullable(String),&lt;br/&gt;)&lt;br/&gt;engine = MergeTree PARTITION BY toYYYYMMDD(_time_second_)&lt;br/&gt;ORDER BY _time_second_&lt;br/&gt;TTL toDateTime(_time_second_) + INTERVAL 7 DAY&lt;br/&gt;SETTINGS index_granularity = 8192;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;6 总结流程&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4274640088593577&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOMWWU8ZTZO7g79A0N2xvpdkWYJ5E88z5XjCbpsQeIcibtAgPGeLlL1WOlicJTZp7ODZt9PvSx6SSTHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;903&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;7 Mogo界面展示&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;查询日志界面&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4166666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOMWWU8ZTZO7g79A0N2xvpdk8yZTBHx0FTNqSZ9ub5wZBVK0g9G9Wlas5UNibBRjJibMxiadPBWtYVJ3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;设置日志采集配置界面&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32592592592592595&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOMWWU8ZTZO7g79A0N2xvpdkyuzaKekCzoApdLx6iaDOmDj89icaC6pdqQjR2ZZmn6LOb12GficSiaMAvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上文档描述是针对石墨Kubernetes的日志采集，想了解物理机采集日志方案的，可以在下文中找到《Mogo使用文档》的链接，运行docker-compose体验Mogo 全部流程，查询Clickhouse日志。限于篇幅有限，Mogo的日志报警功能，下次再讲解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;8 资料&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0MjAxNjk0OA==&amp;amp;mid=2247485948&amp;amp;idx=3&amp;amp;sn=7c02fad7d064b9aac88817715abb581d&amp;amp;scene=21#wechat_redirect&quot; data-href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0MjAxNjk0OA==&amp;amp;mid=2247485948&amp;amp;idx=3&amp;amp;sn=7c02fad7d064b9aac88817715abb581d&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;参考阅读：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;技术原创及架构实践文章，欢迎通过公众号菜单「联系我们」进行投稿。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;高可用架构&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;改变互联网的构建方式&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwMDU1MTE1OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapONl06YmHad4csRU93kcbJ76JIWzEAmOSVooibFHHkzfWzzkc7dpU4H06Wp9F6Z687vIghdawxvl47A/0?wx_fmt=png&quot; data-nickname=&quot;高可用架构&quot; data-alias=&quot;ArchNotes&quot; data-signature=&quot;高可用架构公众号。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>