<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>98ee5bbf770316434e25a88816084598</guid>
<title>面试：为了进阿里，必须掌握 HashMap 源码原理和面试题（图解版一）</title>
<link>https://toutiao.io/k/vl7rvfr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1 cid=&quot;n0&quot; mdtype=&quot;heading&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;欢迎关注公众号【&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;Ccww技术博客&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;】，原创技术文章第一时间推出&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/h1&gt;&lt;hr/&gt;&lt;h3 cid=&quot;n2&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p cid=&quot;n3&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;集合在基础面试中是必备可缺的一部分，其中重要的HashMap更是少不了，那面试官会面试中提问那些问题呢，这些在JDK1.7和1.8有什么区别？？&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n4&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n6&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;HashMap的底层原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n8&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;HashMap的hash哈希函数的设计原理，以及HashMap下标获取方式？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n10&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;HashMap扩容机制，hashMap中什么时候需要进行扩容，扩容resize()又是如何实现的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n12&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;hashMap中put是如何实现的 ，JDK1.7和1.8有什么区别？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n14&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;hashMap中get是如何实现的&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n16&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;其他涉及问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n17&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n19&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;HashMap具备的特性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n21&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;为什么Hash的底层数据长度总为2的N次方？如果输入值不是2的幂比如10会怎么样？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n23&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;加载因子为什么是 0.75？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n25&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;哈希表如何解决Hash冲突&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n27&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;当有哈希冲突时，HashMap 是如何查找并确认元素的？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n29&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;HashMap 是线程安全的吗，为什么不是线程安全的？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;hr/&gt;&lt;h3 cid=&quot;n32&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;1. HashMap的底层原理&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p cid=&quot;n33&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;JDK1.7使用的是数组+ 单链表的数据结构。JDK1.8之后，使用的是数组+链表+红黑树的数据结构&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n34&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;HashMap数据结构图（jdk1.8）&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n35&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.573943661971831&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDriatqsuMHWsaacfH3j6lpw9YmAsnANIrHEz6efzy1BvJDibR7ib8pRaPC6Ik4Qdhiae8Ym3UKJknoLOYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;568&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; TREEIFY_THRESHOLD = &lt;span class=&quot;code-snippet__number&quot;&gt;8&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; UNTREEIFY_THRESHOLD = &lt;span class=&quot;code-snippet__number&quot;&gt;6&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; MIN_TREEIFY_CAPACITY = &lt;span class=&quot;code-snippet__number&quot;&gt;64&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p cid=&quot;n37&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;从HashMap常量中可以看出，当链表的深度达到8的时候，也就是默认阈值TREEIFY_THRESHOLD=8，就会自动扩容把链表转成红黑树的数据结构来把时间复杂度从O(n)变成O(logN)提高了效率，而且当进行resize操作时，若桶中数量少于6则从树转成链表。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n38&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;那为什么数据结构需要从JDK1.7换成JDK1.8的数组+链表+红黑树？&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n39&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;在JDK1.7中，当相同的hash值时，HashMap不断地产生碰撞，那么相同key位置的链表就会不断增长，当查询HashMap的相应key值的Vaule值时，就会去循环遍历这个超级大的链表，查询性能非常低下。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n40&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;但在JDK1.8当链表超过8个节点数时，将会让红黑树来替代链表，查询性能得到了很好的提升，从原来的是O(n)到O(logn)。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h3 cid=&quot;n42&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;2. HashMap的hash哈希函数的设计原理，以及HashMap下标获取 hash &amp;amp;（n - 1）？&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h4 cid=&quot;n43&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;hash哈希函数的设计原理&lt;/span&gt;&lt;/h4&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;java&quot; cid=&quot;n44&quot; mdtype=&quot;fences&quot;&gt;&lt;span&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;hash&lt;/span&gt;(&lt;span&gt;Object&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;int&lt;/span&gt; &lt;span&gt;h&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;key&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;?&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; : (&lt;span&gt;h&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;.&lt;span&gt;hashCode&lt;/span&gt;()) &lt;span&gt;^&lt;/span&gt; (&lt;span&gt;h&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.32936507936507936&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDriatqsuMHWsaacfH3j6lpw9YDRqM9pcmhradXMYnxd3AwDG1nKSzxeoaoZ6KEE8frPKic89rp9PhhyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;756&quot;/&gt;&lt;/p&gt;&lt;h4 cid=&quot;n51&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;HashMap下标获取h % n = h &amp;amp;（n - 1）&lt;/span&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5994729907773386&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDriatqsuMHWsaacfH3j6lpw9YS3QHaO147Jxib8Z1r3iaZv1q9C4KE8jOqQnMia8q82GeSo0moQGiafz7eA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;759&quot;/&gt;&lt;/h4&gt;&lt;p cid=&quot;n58&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;设计原因：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n59&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n61&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;一定要尽可能降低hash碰撞，越分散越好；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n63&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;算法一定要尽可能高效，因为这是高频操作, 因此采用位运算；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p cid=&quot;n64&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h3 cid=&quot;n65&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;3. HashMap扩容机制resize（）&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n66&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;HashMap扩容步骤分成两步：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n73&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;获取新值：新的容量值newCap ，新的扩容阀界值newThr获取&lt;/span&gt;&lt;/h4&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Node&amp;lt;K,V&amp;gt;[] oldTab = table;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; oldCap = (oldTab == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) ? &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; : oldTab.length;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; oldThr = threshold;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; newCap, newThr = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;threshold = newThr;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Node[newCap];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; table = newTab;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (oldCap &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (oldCap &amp;gt;= MAXIMUM_CAPACITY) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            threshold = Integer.MAX_VALUE;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;             &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; oldTab;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; ((newCap = oldCap &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                   oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           newThr = oldThr &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n74&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n81&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n83&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;如果此时oldCap&amp;gt;=MAXIMUM_CAPACITY(1 &amp;lt;&amp;lt; 30)，表示已经到了最大容量，这时还要往map中put数据，则阈值设置为整数的最大值 Integer.MAX_VALUE，直接返回这个oldTab的内存地址&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n85&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;如果扩容之后的新容量小于最大容量 ，且老的数组容量大于等于默认初始化容量（16），那么新数组的扩容阀值设置为老阀值的2倍（左移1位相当于乘以2，newCap = oldCap &amp;lt;&amp;lt; 1），阈值也double（newThr= oldThr &amp;lt;&amp;lt; 1）;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (oldThr &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;newCap = oldThr;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;....&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (newThr == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt; ft = (&lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt;)newCap * loadFactor;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt;)MAXIMUM_CAPACITY ?&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;)ft : Integer.MAX_VALUE);  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           newCap = DEFAULT_INITIAL_CAPACITY;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           newThr = (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p cid=&quot;n93&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p cid=&quot;n93&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;数据迁移&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n96&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;如果oldTab老数组不为空，说明是扩容操作，那么涉及到元素的转移操，遍历老数组，如果当前位置元素不为空，那么需要转移该元素到新数组。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (e.next == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;)  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;newTab[e.hash &amp;amp; (newCap - &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;)] = e;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (e &lt;span class=&quot;code-snippet__keyword&quot;&gt;instanceof&lt;/span&gt; TreeNode)  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          ((TreeNode&amp;lt;K,V&amp;gt;)e).split(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;, newTab, j, oldCap);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Node&amp;lt;K,V&amp;gt; loHead = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;, loTail = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Node&amp;lt;K,V&amp;gt; hiHead = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;, hiTail = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Node&amp;lt;K,V&amp;gt; next;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;do&lt;/span&gt; {  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    next = e.next;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; ((e.hash &amp;amp; oldCap) == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (loTail == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                 loHead = e;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              loTail.next = e;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          loTail = e;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (hiTail == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                      hiHead = e;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                   hiTail.next = e;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                hiTail = e;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; ((e = next) != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (loTail != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      loTail.next = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      newTab[j] = loHead;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (hiTail != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       hiTail.next = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       newTab[j + oldCap] = hiHead;                  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/ul&gt;&lt;p cid=&quot;n744&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span&gt;JDK1.8对&lt;/span&gt;&lt;code&gt;resize()&lt;/code&gt;&lt;span&gt;扩容方法进行了优化，&lt;/span&gt;&lt;strong&gt;经过rehash之后，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n744&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;是不是有点不明白呢？那我们来用图来解析一下：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n746&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;结合&lt;code&gt;e.hash &amp;amp; oldCapn&lt;/code&gt;取值判断是在高位还是在低位，即如图（a）表示扩容前的key1和key2两种key确定索引位置的示例，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.27328431372549017&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDriatqsuMHWsaacfH3j6lpw9YBHLgyPRCRaOWZZFFF2y2Jh19A0r6BnwazHiaEAmP4sAdAcoslj6so5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1632&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图（b）表示扩容后key1和key2两种key确定索引，元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.18984962406015038&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDriatqsuMHWsaacfH3j6lpw9Yms5OpiboDtic3ZScNgicBBx8sgerWlElOnZQLN4p31QcQD2KVP0iahQFVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1064&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“&lt;/span&gt;&lt;code&gt;&lt;span&gt;原索引+oldCap&lt;/span&gt;&lt;/code&gt;&lt;span&gt;”，可以看看下图为16扩充为32的resize示意图：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5757097791798107&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDriatqsuMHWsaacfH3j6lpw9YYvu72ssibnLME4icwlRWbWF5bVRQnXia85OleqdibVTBdPsYAzOxldBaqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在JDK1.7中rehash扩容的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同的链表元素会倒置，但是在JDK1.8进行了优化，从上图可以看出，JDK1.8链表元素不会倒置。&lt;/span&gt;&lt;span&gt;因此不会出现链表死循环的问题。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于篇幅过长，将分成两篇来介绍，接下来内容看&lt;/span&gt;&lt;span&gt;《面试：为了进阿里，必须掌握HashMap源码原理和面试题（图解版二）》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n158&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;各位看官还可以吗？喜欢的话，动动手指点个再看💗呗！！谢谢支持！&lt;span md-inline=&quot;linebreak&quot;&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n158&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;欢迎扫码关注，原创技术文章第一时间推出&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.36857142857142855&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;350&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgfBz2Ve78FylxcGWmXaueSuqPguurBCWEkeY1ibeLl1wlxUyibdesc4YeuiaJJjSt6HTiab2iaHyXyyicA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ca7b1683b01879920d7a83d2ca230803</guid>
<title>[译] 仅用 18 行 JavaScript 构建一个倒数计时器</title>
<link>https://toutiao.io/k/qijww23</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3724053724053724&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0ANAsyE4nMbsnrRoddRZl3UltwVTlHofjZZWC4VtyKS2BtDaLdB1cXKyZOpLj4GvWpaSntOJvYWwgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1638&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;来源：https://www.sitepoint.com，作者：Nilson Jacques&lt;/span&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第100期了，回馈粉丝，文末参与送书活动！&lt;/span&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有时候，你会需要构建一个JavaScript倒计时时钟。你可能会有一个活动、一个销售、一个促销或一个游戏。你可以用原生的JavaScript构建一个时钟，而不是去找一个插件。尽管有很多很棒的时钟插件，但是使用原生JavaScript可以带来以下好处：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;你的代码将是轻量级的，因为它将具有零依赖性。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;你的网站将表现得更好。你不需要加载外部脚本和样式表。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;你将拥有更多的控制权。你将会建立一个完全按照你的意愿来表现的时钟。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以，废话不多说，下面是如何在短短的18行JavaScript中制作自己的倒计时钟。&lt;/span&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;目录：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1.基本时钟：倒数到特定的日期或时间&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2.设置有效的结束日期&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.计算剩余时间&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.将时间转换为可用格式&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;5.将时钟数据输出为可重复使用的对象&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;6.在页面上显示时钟，并在时钟为零时停止时钟&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;7.准备展示你的时钟&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;7.1 消除初始延迟&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;7.2 避免不断重建时钟&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;7.3 添加前导0&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;8.更进一步&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;8.1 自动调节时钟&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;8.2 从用户到达起将计时器设置为10分钟&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;8.3 跨页面保持时钟进度&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;9.有关客户端时间的重要警告&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;10.总结&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;11.代码&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.基本时钟：倒数到特定的日期或时间&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以下是创建基本时钟所需步骤的简要概述：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;设置有效的结束日期。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;计算剩余时间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将时间转换为可用格式。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将时钟数据输出为可重复使用的对象。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在页面上显示时钟，并在时钟为零时停止时钟。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.设置有效的结束日期&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，你需要设置一个有效的结束日期。这应该是JavaScript的 Date.parse() 方法可以理解的任何格式的字符串。例如：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ISO 8601格式：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; deadline = &lt;span&gt;&#x27;2015-12-31&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;简短格式：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; deadline = &lt;span&gt;&#x27;31/12/2015&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;或者，长格式：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; deadline = &lt;span&gt;&#x27;December 31 2015&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这些格式中的每一种都允许你指定一个准确的时间和一个时区（或者在ISO日期的情况下指定一个与UTC的偏移）。例如：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; deadline = &lt;span&gt;&#x27;December 31 2015 23:59:59 GMT+0200&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.计算剩余时间&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下一步是计算剩余时间。我们需要编写一个函数，该函数需要一个表示给定结束时间的字符串（如上所述）。然后，我们计算该时间与当前时间之间的时差。看起来像这样：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getTimeRemaining&lt;/span&gt;(&lt;span&gt;endtime&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; total = &lt;span&gt;Date&lt;/span&gt;.parse(endtime) - &lt;span&gt;Date&lt;/span&gt;.parse(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;());&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; seconds = &lt;span&gt;Math&lt;/span&gt;.floor( (total/&lt;span&gt;1000&lt;/span&gt;) % &lt;span&gt;60&lt;/span&gt; );&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; minutes = &lt;span&gt;Math&lt;/span&gt;.floor( (total/&lt;span&gt;1000&lt;/span&gt;/&lt;span&gt;60&lt;/span&gt;) % &lt;span&gt;60&lt;/span&gt; );&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; hours = &lt;span&gt;Math&lt;/span&gt;.floor( (total/(&lt;span&gt;1000&lt;/span&gt;*&lt;span&gt;60&lt;/span&gt;*&lt;span&gt;60&lt;/span&gt;)) % &lt;span&gt;24&lt;/span&gt; );&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; days = &lt;span&gt;Math&lt;/span&gt;.floor( total/(&lt;span&gt;1000&lt;/span&gt;*&lt;span&gt;60&lt;/span&gt;*&lt;span&gt;60&lt;/span&gt;*&lt;span&gt;24&lt;/span&gt;) );&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    total,&lt;br/&gt;    days,&lt;br/&gt;    hours,&lt;br/&gt;    minutes,&lt;br/&gt;    seconds&lt;br/&gt;  };&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，我们要创建一个变量 &lt;/span&gt;&lt;code&gt;&lt;span&gt;total&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 以保留到截止日期为止的剩余时间。&lt;/span&gt;&lt;code&gt;&lt;span&gt;Date.parse()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数将时间字符串转换为毫秒值，这样我们就可以将两次相减，得到中间的时间量。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; total = &lt;span&gt;Date&lt;/span&gt;.parse(endtime) - &lt;span&gt;Date&lt;/span&gt;.parse(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.将时间转换为可用格式&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在我们要将毫秒转换为天，小时，分钟和秒。让我们以秒为例：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; seconds = &lt;span&gt;Math&lt;/span&gt;.floor( (t/&lt;span&gt;1000&lt;/span&gt;) % &lt;span&gt;60&lt;/span&gt; );&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;让我们分解一下这里发生的事情。&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将毫秒除以1000可转换为秒：&lt;/span&gt;&lt;code&gt;&lt;span&gt;(t/1000)&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将总秒数除以60，然后取余数。你不需要所有的秒，只需要计算分钟数后剩下的那些：&lt;/span&gt;&lt;code&gt;&lt;span&gt;(t/1000) % 60&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;四舍五入到最接近的整数。这是因为你需要完整的秒数，而不是几分之一秒：&lt;/span&gt;&lt;code&gt;&lt;span&gt;Math.floor((t/1000)％60)&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;重复此逻辑，将毫秒转换为分钟，小时和天。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1600180410767&quot; data-category_id_list=&quot;1|11|16|17|22|24|26|27|28|29|3|31|32|35|36|37|39|41|42|43|45|46|47|48|49|5|50|51|52|53|54|55|6|7|8&quot; data-id=&quot;1600180410767&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.将时钟数据输出为可重复使用的对象&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在准备好几天，几小时，几分钟和几秒钟之后，我们现在可以将数据作为可重复使用的对象返回：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;  total,&lt;br/&gt;  days,&lt;br/&gt;  hours,&lt;br/&gt;  minutes,&lt;br/&gt;  seconds&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个对象允许你调用你的函数，并获得任何计算值。这是如何获取剩余分钟数的示例：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;getTimeRemaining(deadline).minutes&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;方便吧？&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6.在页面上显示时钟，并在时钟为零时停止时钟&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在我们有了一个可以吐出剩余天数、小时、分钟和秒数的函数，我们就可以建立我们的时钟了。首先，我们将创建以下HTML元素来保存时钟：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;clockdiv&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然后，我们将编写一个函数，在新的div中输出时钟数据：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;initializeClock&lt;/span&gt;(&lt;span&gt;id, endtime&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; clock = &lt;span&gt;document&lt;/span&gt;.getElementById(id);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; timeinterval = setInterval(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; t = getTimeRemaining(endtime);&lt;br/&gt;    clock.innerHTML = &lt;span&gt;&#x27;days: &#x27;&lt;/span&gt; + t.days + &lt;span&gt;&#x27;&amp;lt;br&amp;gt;&#x27;&lt;/span&gt; +&lt;br/&gt;                      &lt;span&gt;&#x27;hours: &#x27;&lt;/span&gt;+ t.hours + &lt;span&gt;&#x27;&amp;lt;br&amp;gt;&#x27;&lt;/span&gt; +&lt;br/&gt;                      &lt;span&gt;&#x27;minutes: &#x27;&lt;/span&gt; + t.minutes + &lt;span&gt;&#x27;&amp;lt;br&amp;gt;&#x27;&lt;/span&gt; +&lt;br/&gt;                      &lt;span&gt;&#x27;seconds: &#x27;&lt;/span&gt; + t.seconds;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (t.total &amp;lt;= &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      clearInterval(timeinterval);&lt;br/&gt;    }&lt;br/&gt;  },&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;该函数有两个参数，这两个参数是包含时钟的元素的id，以及倒计时的结束时间。在函数内部，我们将声明一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;clock&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 变量，并使用它来保存对时钟容器div的引用。这意味着我们不必一直查询DOM。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来，我们将使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;setInterval&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 每秒执行一个匿名函数。此功能将执行以下操作：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;计算剩余时间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将剩余时间输出到我们的div。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果剩余时间为零停止计时。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此时，剩下的唯一步骤是像这样运行时钟：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;initializeClock(&lt;span&gt;&#x27;clockdiv&#x27;&lt;/span&gt;, deadline);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;恭喜你！现在，你仅用18行JavaScript就拥有了一个基本时钟。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7.准备展示你的时钟&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在设置时钟样式之前，我们需要进行一些改进。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;消除初始延迟，使你的时钟立即显示。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;让时钟脚本更有效率，这样它就不会连续重建整个时钟。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;根据需要添加前导零。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7.1 消除初始延迟&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在时钟中，我们使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;setInterval&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 每秒更新一次显示。多数情况下，这很好，除非在开始时会有一秒钟的延迟。要消除此延迟，我们必须在间隔开始之前更新一次时钟。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;让我们将传递给 &lt;/span&gt;&lt;code&gt;&lt;span&gt;setInterval&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的匿名函数移到其自己的单独函数中，我们可以将此函数命名为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;updateClock&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;setInterval&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 外调用一次 &lt;/span&gt;&lt;code&gt;&lt;span&gt;updateClock&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数，然后在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;setInterval&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 内再次调用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在你的JavaScript中，替换这个&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; timeinterval = setInterval(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; { ... },&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;新代码&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;updateClock&lt;/span&gt;()&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; t = getTimeRemaining(endtime);&lt;br/&gt;  clock.innerHTML = &lt;span&gt;&#x27;days: &#x27;&lt;/span&gt; + t.days + &lt;span&gt;&#x27;&amp;lt;br&amp;gt;&#x27;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&#x27;hours: &#x27;&lt;/span&gt;+ t.hours + &lt;span&gt;&#x27;&amp;lt;br&amp;gt;&#x27;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&#x27;minutes: &#x27;&lt;/span&gt; + t.minutes + &lt;span&gt;&#x27;&amp;lt;br&amp;gt;&#x27;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&#x27;seconds: &#x27;&lt;/span&gt; + t.seconds;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (t.total &amp;lt;= &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    clearInterval(timeinterval);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;updateClock(); &lt;span&gt;// 首先运行一函数能以避免延迟&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; timeinterval = setInterval(updateClock,&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7.2 避免不断重建时钟&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们需要使时钟脚本更高效，我们只想更新时钟中的数字，而不是每秒重建整个时钟。实现此目的的一种方法是将每个数字放在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;span&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 标签内，并仅更新这些 &lt;/span&gt;&lt;code&gt;&lt;span&gt;span&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的内容。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这是HTML：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;clockdiv&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    Days: &lt;span&gt;&amp;lt;&lt;span&gt;span&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;days&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;span&lt;/span&gt;&amp;gt;&amp;lt;&lt;span&gt;br&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    Hours: &lt;span&gt;&amp;lt;&lt;span&gt;span&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;hours&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;span&lt;/span&gt;&amp;gt;&amp;lt;&lt;span&gt;br&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    Minutes: &lt;span&gt;&amp;lt;&lt;span&gt;span&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;minutes&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;span&lt;/span&gt;&amp;gt;&amp;lt;&lt;span&gt;br&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    Seconds: &lt;span&gt;&amp;lt;&lt;span&gt;span&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;seconds&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;span&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在让我们参考这些元素。在定义 &lt;/span&gt;&lt;code&gt;&lt;span&gt;clock&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 变量的位置之后添加以下代码&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; daysSpan = clock.querySelector(&lt;span&gt;&#x27;.days&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; hoursSpan = clock.querySelector(&lt;span&gt;&#x27;.hours&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; minutesSpan = clock.querySelector(&lt;span&gt;&#x27;.minutes&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; secondsSpan = clock.querySelector(&lt;span&gt;&#x27;.seconds&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来，我们需要修改 &lt;/span&gt;&lt;code&gt;&lt;span&gt;updateClock&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数，使其只更新数字。新的代码是这样的：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;updateClock&lt;/span&gt;()&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; t = getTimeRemaining(endtime);&lt;br/&gt;&lt;br/&gt;    daysSpan.innerHTML = t.days;&lt;br/&gt;    hoursSpan.innerHTML = t.hours;&lt;br/&gt;    minutesSpan.innerHTML = t.minutes;&lt;br/&gt;    secondsSpan.innerHTML = t.seconds;&lt;br/&gt;&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7.3 添加前导0&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在时钟不再每秒都在重建，我们还有另一件事要做：添加前导零。例如，不是让时钟显示7秒，而是显示07秒。一种简单的方法是在一个数的开头加上一串“0”，然后切掉最后两个数字。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例如，要在“seconds”值上添加前导零，你可以更改以下设置：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;secondsSpan.innerHTML = t.seconds;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;secondsSpan.innerHTML = (&lt;span&gt;&#x27;0&#x27;&lt;/span&gt; + t.seconds).slice(&lt;span&gt;-2&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果你愿意，你也可以在分钟和小时的前面加零。如果你已经走到这一步，恭喜你！你的时钟现在已经可以显示了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1600180422775&quot; data-category_id_list=&quot;1|11|16|17|22|24|26|27|28|29|3|31|32|35|36|37|39|41|42|43|45|46|47|48|49|5|50|51|52|53|54|55|6|7|8&quot; data-id=&quot;1600180422775&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8.更进一步&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以下示例演示了如何为某些用例扩展时钟。它们都是基于上面的基本例子。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8.1 自动调节时钟&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设我们想让时钟在特定的日子出现，而不是在其他的日子。例如，我们可能有一系列事件即将发生，而不希望每次都手动更新时钟。以下是如何提前安排事情的方法。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过在CSS中将其 &lt;/span&gt;&lt;code&gt;&lt;span&gt;display&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 属性设置为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;none&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来隐藏时钟，然后将以下内容添加到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;initializeClock&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数中（以 &lt;/span&gt;&lt;code&gt;&lt;span&gt;var clock&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 开头的行之后）。这将导致只有在调用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;initializeClock&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数后才会显示时钟：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;clock.style.display = &lt;span&gt;&#x27;block&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来，我们可以指定显示时钟的日期。这将替换截止日期变量（ &lt;/span&gt;&lt;code&gt;&lt;span&gt;deadline&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ）：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; schedule = [&lt;br/&gt;    [&lt;span&gt;&#x27;Jul 25 2015&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Sept 20 2015&#x27;&lt;/span&gt;],&lt;br/&gt;    [&lt;span&gt;&#x27;Sept 21 2015&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Jul 25 2016&#x27;&lt;/span&gt;],&lt;br/&gt;    [&lt;span&gt;&#x27;Jul 25 2016&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Jul 25 2030&#x27;&lt;/span&gt;]&lt;br/&gt;];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Schedule&lt;/code&gt;&lt;span&gt;数组中的每个元素代表一个开始日期和一个结束日期。如上所述，它可以包含时间和时区，但我在这里使用了普通的日期，以保持代码的可读性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后，当用户加载页面时，我们需要检查是否在指定的时间范围内。此代码应替换先前对 &lt;/span&gt;&lt;code&gt;&lt;span&gt;initializeClock&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数的调用：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 遍历schedule中的每个元素&lt;/span&gt;&lt;br/&gt;schedule.forEach(&lt;span&gt;(&lt;span&gt;[startDate, endDate]&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 以毫秒为单位放置日期以便于比较&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; startMs = &lt;span&gt;Date&lt;/span&gt;.parse(startDate);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; endMs = &lt;span&gt;Date&lt;/span&gt;.parse(endDate);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; currentMs = &lt;span&gt;Date&lt;/span&gt;.parse(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;());&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 如果当前日期在开始日期和结束日期之间，则显示时钟&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (endMs &amp;gt; currentMs &amp;amp;&amp;amp; currentMs &amp;gt;= startMs ) {&lt;br/&gt;    initializeClock(&lt;span&gt;&#x27;clockdiv&#x27;&lt;/span&gt;, endDate);&lt;br/&gt;  }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在，你可以提前安排你的时钟，而不必手动更新它。如果你愿意，你可以缩短代码。为了便于阅读，我把我的代码写得很啰嗦。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8.2 从用户到达起将计时器设置为10分钟&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;用户到达或开始特定任务后，有必要在给定的时间内设置倒计时。我们将在此处将计时器设置为10分钟，但是你可以使用任意时间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们需要做的就是用以下命令替换 &lt;/span&gt;&lt;code&gt;&lt;span&gt;deadline&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 变量：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; timeInMinutes = &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; currentTime = &lt;span&gt;Date&lt;/span&gt;.parse(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;());&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; deadline = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;(currentTime + timeInMinutes*&lt;span&gt;60&lt;/span&gt;*&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这段代码以当前时间为基准，增加10分钟。这些值将转换为毫秒，因此可以将它们加在一起并变成新的截止日期。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在我们有一个时钟，从用户到达时开始倒计时十分钟，你可以自由发挥，尝试不同的时间长度。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8.3 跨页面保持时钟进度&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有时，除了当前页面外，还需要保留时钟状态。如果我们想在整个网站上设置10分钟的计时器，则我们不希望在用户转到其他页面时重置该计时器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个解决方案是将时钟的结束时间保存在一个cookie中。这样一来，导航到一个新的页面就不会把结束时间重置到十分钟以后。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这是逻辑：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果Cookie中记录了截止日期，使用该截止日期。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果不存在Cookie，请设置一个新的截止日期并将其存储在Cookie中。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;要实现这一点，请使用以下命令替换 &lt;/span&gt;&lt;code&gt;&lt;span&gt;deadline&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 变量：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; deadline;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 如果有一个名为myClock的cookie，则使用该值作为截止日期&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;document&lt;/span&gt;.cookie &amp;amp;&amp;amp; &lt;span&gt;document&lt;/span&gt;.cookie.match(&lt;span&gt;&#x27;myClock&#x27;&lt;/span&gt;)){&lt;br/&gt;  &lt;span&gt;// 从Cookie获取截止日期值&lt;/span&gt;&lt;br/&gt;  deadline = &lt;span&gt;document&lt;/span&gt;.cookie.match(&lt;span&gt;/(^|;)myClock=([^;]+)/&lt;/span&gt;)[&lt;span&gt;2&lt;/span&gt;];&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 否则，请设置从现在开始10分钟的截止日期，&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 将其保存在具有该名称的cookie中&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 创建从现在开始10分钟的截止日期&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; timeInMinutes = &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; currentTime = &lt;span&gt;Date&lt;/span&gt;.parse(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;());&lt;br/&gt;  deadline = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;(currentTime + timeInMinutes*&lt;span&gt;60&lt;/span&gt;*&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 将截止日期存储在cookie中以供将来引用&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;document&lt;/span&gt;.cookie = &lt;span&gt;&#x27;myClock=&#x27;&lt;/span&gt; + deadline + &lt;span&gt;&#x27;; path=/; domain=.yourdomain.com&#x27;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;需要注意的是，你需要将 &lt;/span&gt;&lt;code&gt;&lt;span&gt;.yourdomain.com&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 改为你的实际域名。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;9.有关客户端时间的重要警告&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;JavaScript日期和时间是从用户的计算机上获取的，这意味着用户可以通过更改计算机上的时间来影响JavaScript时钟。在大多数情况下，这并不重要，但在一些超级敏感的情况下，就需要从服务器上获取时间。可以使用一些Node.js或Ajax来完成，这两者都超出了本教程的范围。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从服务器获取时间后，我们可以使用本教程中的相同技术来使用它。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;10.总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在完成本文中的示例之后，你现在知道了如何使用几行简单的JavaScript代码创建自己的倒计时计时器！我们已经了解了如何制作一个基本的倒计时时钟并有效地显示它。我们还介绍了添加一些有用的附加功能，包括日程安排、绝对时间与相对时间，以及在页面和网站访问之间用cookie保存状态。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下一步是什么？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;试着添加一些创意风格，或者新的功能（比如暂停和恢复按钮）。之后，如果你想出了任何很酷的时钟例子，你想分享，让我们在评论区见。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;11.代码&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本示例代码和演示地址：https://coding.zhangbing.site/view.html?url=./list/down-click.html&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5199374511336982&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0ANAsyE4nMbsnrRoddRZl3Ulz4YSjStP8ld5zicpEzrVUTPZFM8TsUrv018LNU7mnIAGrBmVomqtj9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2558&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;section&gt;&lt;mpcps frameborder=&quot;0&quot; class=&quot;js_editor_cps&quot; data-datakey=&quot;1600178414761_0.7220740555156842&quot; data-uid=&quot;1600178414759&quot; data-type=&quot;1&quot; data-product=&quot;&quot; data-templateid=&quot;list&quot; data-pid=&quot;29120617&quot; data-packid=&quot;&quot; data-smartnum=&quot;&quot; data-categoryid=&quot;3&quot; data-appid=&quot;wx831660fe3ded4389&quot; data-report=&quot;s0%3D0%26s1%3D0%26s2%3D0%26s3%3DJavaScript%25E9%25AB%2598%25E7%25BA%25A7%25E7%25A8%258B%25E5%25BA%258F%25E8%25AE%25BE%25E8%25AE%25A1%26s4%3D0%26s5%3D10%26s6%3Did_1600179496139_855052%26s7%3D%26s8%3D%26s9%3D%26s10%3D%26pid%3Dwx831660fe3ded4389_29120617%26uuid%3D3240205452442390687%26title%3DJavaScript%25E9%25AB%2598%25E7%25BA%25A7%25E7%25A8%258B%25E5%25BA%258F%25E8%25AE%25BE%25E8%25AE%25A1%2B%25E7%25AC%25AC4%25E7%2589%2588%26sid%3D3%26cid%3D3%26ratio%3D17.00%2525%26price%3D96.80%26&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;mpcps frameborder=&quot;0&quot; class=&quot;js_editor_cps&quot; data-datakey=&quot;1600178414762_0.4332142757043733&quot; data-uid=&quot;1600178414760&quot; data-type=&quot;1&quot; data-product=&quot;&quot; data-templateid=&quot;list&quot; data-pid=&quot;12883028&quot; data-packid=&quot;&quot; data-smartnum=&quot;&quot; data-categoryid=&quot;3&quot; data-appid=&quot;wxbdbc4659744ed70d&quot; data-report=&quot;s0%3D0%26s1%3D0%26s2%3D0%26s3%3DJavaScript%25E8%25AF%25AD%25E8%25A8%2580%25E7%25B2%25BE%25E9%25AB%2593%26s4%3D0%26s5%3D10%26s6%3Did_1600179516463_23250%26s7%3D%26s8%3D%26s9%3D%26s10%3D%26pid%3Dwxbdbc4659744ed70d_12883028%26uuid%3D32402054522077153266%26title%3DJavaScript%25E8%25AF%25AD%25E8%25A8%2580%25E7%25B2%25BE%25E9%25AB%2593%25E4%25B8%258E%25E7%25BC%2596%25E7%25A8%258B%25E5%25AE%259E%25E8%25B7%25B5%25EF%25BC%2588%25E7%25AC%25AC3%25E7%2589%2588%25EF%25BC%2589(%25E5%258D%259A%25E6%2596%2587%25E8%25A7%2586%25E7%2582%25B9%25E5%2587%25BA%25E5%2593%2581)%26sid%3D1%26cid%3D3%26ratio%3D18.00%2525%26price%3D136.80%26&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;福利时间&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我又来给大家送福利了，这么好的书不送几本给大家怎么行呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;福利送给「阅读、点赞、在看、评论」我的文章的读者们，你们的支持也是我持续输出最大的动力，&lt;span&gt;感恩&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本次抽奖有三个参与方式&lt;span&gt;「留言、在看&lt;span&gt;、现金&lt;/span&gt;红包抽奖」&lt;/span&gt;，当然都参与中奖概率更高哈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;为了避免中奖后失联，提前加我微信哈。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0ANpQDTG8tzUI7XTrYCicQaUYCZvxu69zuIYjJ5YB2icua8zRG0MPL9IFU09iboV7XOKwTicrr3ghkYeZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>53b6c73b207428153551725bfa2a60be</guid>
<title>多图，一文了解 8 种常见的数据结构</title>
<link>https://toutiao.io/k/d392rnj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;前几天和丙弟交流，他说我们写作的人都是在不停地燃烧自己，所以需要不停地补充燃料。对于他的观点，我不能再苟同了——所以我开始狂补计算机方面的基础知识，这其中就包括我相对薄弱的数据结构。&lt;/p&gt;&lt;p&gt;百度百科对数据结构的定义是：相互之间存在一种或多种特定关系的数据元素的集合。定义很抽象，需要大声地朗读几遍，才有点感觉。怎么让这种感觉来得更强烈，更亲切一些呢？我来列举一下常见的 8 种数据结构，数组、链表、栈、队列、树、堆、图、哈希表。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.47619047619047616&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaB93GW1ZTzqzXpD9CCprJZGt0iauuLJzMUkicfMhOARZhIGnyFCibjGJ1yg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1218&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这 8 种数据结构有什么区别呢？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;①、数组&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;按照索引查询元素的速度很快；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;按照索引遍历数组也很方便。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;②、链表&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;《算法（第 4 版）》一书中是这样定义链表的：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;链表是一种递归的数据结构，它或者为空（null），或者是指向一个结点（node）的引用，该节点还有一个元素和一个指向另一条链表的引用。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Java 的 LinkedList 类可以很形象地通过代码的形式来表示一个链表的结构：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LinkedList&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;transient&lt;/span&gt; Node&amp;lt;E&amp;gt; first;&lt;br/&gt;    &lt;span&gt;transient&lt;/span&gt; Node&amp;lt;E&amp;gt; last;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;        E item;&lt;br/&gt;        Node&amp;lt;E&amp;gt; next;&lt;br/&gt;        Node&amp;lt;E&amp;gt; prev;&lt;br/&gt;&lt;br/&gt;        Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.item = element;&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.next = next;&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.prev = prev;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是一种双向链表，当前元素 item 既有 prev 又有 next，不过 first 的 prev 为 null，last 的 next 为 null。如果是单向链表的话，就只有 next，没有 prev。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBVCicPIQYibicdxouzxnVM4uVFXzGuDKFE66zDiav3Zu1rmw2HGPl0CiafGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;670&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;单向链表的缺点是只能从头到尾依次遍历，而双向链表可进可退，既能找到下一个，也能找到上一个——每个节点上都需要多分配一个存储空间。&lt;/p&gt;&lt;p&gt;链表中的数据按照“链式”的结构存储，因此可以达到内存上非连续的效果，数组必须是一块连续的内存。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5788888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBkmpbvsf8IUTrTgwbNdeXjW4iba1tJPSmZR4jZsL5THQhMZZewibDmIibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;由于不必按照顺序的方式存储，链表在插入、删除的时候可以达到 O(1) 的时间复杂度（只需要重新指向引用即可，不需要像数组那样移动其他元素）。除此之外，链表还克服了数组必须预先知道数据大小的缺点，从而可以实现灵活的内存动态管理。&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不需要初始化容量；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以添加任意元素；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;插入和删除的时候只需要更新引用。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;含有大量的引用，占用的内存空间大；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;查找元素需要遍历整个链表，耗时。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;③、栈&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;栈就好像水桶一样，底部是密封的，顶部是开口，水可以进可以出。用过水桶的小伙伴应该明白这样一个道理：先进去的水在桶的底部，后进去的水在桶的顶部；后进去的水先被倒出来，先进去的水后被倒出来。&lt;/p&gt;&lt;p&gt;同理，栈按照“后进先出”、“先进后出”的原则来存储数据，先插入的数据被压入栈底，后插入的数据在栈顶，读出数据的时候，从栈顶开始依次读出。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9454545454545454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBbpJ3J7DZLmox5PicUyzBM5hnVC2W37CEKIwKbibvKZeaLlQbP3efwV4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;220&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;④、队列&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;队列就好像一段水管一样，两端都是开口的，水从一端进去，然后从另外一端出来。先进去的水先出来，后进去的水后出来。&lt;/p&gt;&lt;p&gt;和水管有些不同的是，队列会对两端进行定义，一端叫队头，另外一端就叫队尾。队头只允许删除操作（出队），队尾只允许插入操作（入队）。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.531700288184438&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBuqsHCTFJJS1QEbMQlWGYNibF1U0s2VBVQE9arW7rpjSmxHZhvgGEicOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;694&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;注意，栈是先进后出，队列是先进先出——两者虽然都是线性表，但原则是不同的，结构不一样嘛。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;⑤、树&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;树是一种典型的非线性结构，它是由 n（n&amp;gt;0）个有限节点组成的一个具有层次关系的集合。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9416666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBNG5VquqaTNkXHazARMOOHWI3hXmeKc8Pqibk63EFSHKCAh1XD7ccIVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;之所以叫“树”，是因为这种数据结构看起来就像是一个倒挂的树，只不过根在上，叶在下。树形数据结构有以下这些特点：&lt;/p&gt;&lt;p&gt;下图展示了树的一些术语：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8258064516129032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaB5fBXNTAjhGAkGPK1GSEtuWia41G9tutOp4sNS5qByTy6QFxYzfLibgzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;根节点是第 0 层，它的子节点是第 1 层，子节点的子节点为第 2 层，以此类推。&lt;/p&gt;&lt;p&gt;树的种类有很多种，常见的有：&lt;/p&gt;&lt;p&gt;假如有三个节点，一个是父节点，两个是同级的子节点，那么就有三种情况：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2653225806451613&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBlzDo0iadbvynC8D3O2VQwCJib581GmjqibPlhM09Mz9sHKwvfTmZbwOqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;假如有三个节点，一个是父节点，两个是不同级的子节点，那么就有六种情况：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.45483870967741935&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBvHIqQT4AgkchWGGIc86w157X4iaORtNbK1ia8WZ9qD0yGdLY8ibMjlC0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;三个节点组成的无序树，合起来就是九种情况。&lt;/p&gt;&lt;p&gt;完全二叉树：对于一颗二叉树，假设其深度为 d（d &amp;gt; 1）。除了第 d 层，其它各层的节点数目均已达最大值，且第 d 层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.716931216931217&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBibF1D0NMh3ELjuOuvN9kjlibkEJbIhyjcubicaia6ajugIOaS8kMyFG9uw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;756&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;拿上图来说，d 为 3，除了第 3 层，第 1 层、第 2 层 都达到了最大值（2 个子节点），并且第 3 层的所有节点从左向右联系地紧密排列（H、I、J、K、L），符合完全二叉树的要求。&lt;/p&gt;&lt;p&gt;满二叉树：一颗每一层的节点数都达到了最大值的二叉树。有两种表现形式，第一种，像下图这样（每一层都是满的），满足每一层的节点数都达到了最大值 2。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6475409836065574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBe3ctGhq7WqiapWQpNJNHAibn74hPPK6zUG8a359gb3RQ92PiaDDdcG4lA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;第二种，像下图这样（每一层虽然不满），但每一层的节点数仍然达到了最大值 2。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7481060606060606&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaB92VnLZdZEFYRW2f73UnhVuZAtTVzQRk0lhxhibgz1BnxWOhPuAOQ2Ew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1056&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;二叉查找树：英文名叫 Binary Search Tree，即 BST，需要满足以下条件：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5298387096774193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaByCLXibBBJdRBBiclOiaeLMxySmPxECdFOO43DpicHl0OGZIicmYC3LYel3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;基于二叉查找树的特点，它相比较于其他数据结构的优势就在于查找、插入的时间复杂度较低，为 O(logn)。假如我们要从上图中查找 5 个元素，先从根节点 7 开始找，5 必定在 7 的左侧，找到 4，那 5 必定在 4 的右侧，找到 6，那 5 必定在 6 的左侧，找到了。&lt;/p&gt;&lt;p&gt;理想情况下，通过 BST 查找节点，所需要检查的节点数可以减半。&lt;/p&gt;&lt;p&gt;平衡二叉树：当且仅当任何节点的两棵子树的高度差不大于 1 的二叉树。由前苏联的数学家 Adelse-Velskil 和 Landis 在 1962 年提出的高度平衡的二叉树，根据科学家的英文名也称为 AVL 树。&lt;/p&gt;&lt;p&gt;平衡二叉树本质上也是一颗二叉查找树，不过为了限制左右子树的高度差，避免出现倾斜树等偏向于线性结构演化的情况，所以对二叉搜索树中每个节点的左右子树作了限制，左右子树的高度差称之为平衡因子，树中每个节点的平衡因子绝对值不大于 1。&lt;/p&gt;&lt;p&gt;平衡二叉树的难点在于，当删除或者增加节点的情况下，如何通过左旋或者右旋的方式来保持左右平衡。&lt;/p&gt;&lt;p&gt;Java 中最常见的平衡二叉树就是红黑树，节点是红色或者黑色，通过颜色的约束来维持着二叉树的平衡：&lt;/p&gt;&lt;p&gt;1）每个节点都只能是红色或者黑色&lt;/p&gt;&lt;p&gt;2）根节点是黑色&lt;/p&gt;&lt;p&gt;3）每个叶节点（NIL 节点，空节点）是黑色的。&lt;/p&gt;&lt;p&gt;4）如果一个节点是红色的，则它两个子节点都是黑色的。也就是说在一条路径上不能出现相邻的两个红色节点。&lt;/p&gt;&lt;p&gt;5）从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5724815724815725&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBrmu2nPLWWjKOtn3TkgjDFBordKkDFBakyLRuQG6lrTFZdhUTEWhlgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;814&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5630252100840336&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBLHPViaSrBvypPqwsDJs7sFjUE2V1dL9RDBo0F9FJevfA8P2CtO8xLaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1190&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;⑥、堆&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;堆可以被看做是一棵树的数组对象，具有以下特点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;堆中某个节点的值总是不大于或不小于其父节点的值；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;堆总是一棵完全二叉树。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.42096774193548386&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBxz4ddlo5D4aLLkhoGj7hScRQR8Ipv0ototruVb7VVfJxd6pbQcXQzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;⑦、图&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;图是一种复杂的非线性结构，由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V，E），其中，G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5199501246882793&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaB5uNbXoX3qxZS5j4lakLGo6fcia44HylHMw57socSNs7lf0ul4oNnPiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上图共有 V0，V1，V2，V3 这 4 个顶点，4 个顶点之间共有 5 条边。&lt;/p&gt;&lt;p&gt;在线性结构中，数据元素之间满足唯一的线性关系，每个数据元素（除第一个和最后一个外）均有唯一的“前驱”和“后继”；&lt;/p&gt;&lt;p&gt;在树形结构中，数据元素之间有着明显的层次关系，并且每个数据元素只与上一层中的一个元素（父节点）及下一层的多个元素（子节点）相关；&lt;/p&gt;&lt;p&gt;而在图形结构中，节点之间的关系是任意的，图中任意两个数据元素之间都有可能相关。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;⑧、哈希表&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;哈希表（Hash Table），也叫散列表，是一种可以通过关键码值（key-value）直接访问的数据结构，它最大的特点就是可以快速实现查找、插入和删除。&lt;/p&gt;&lt;p&gt;数组的最大特点就是查找容易，插入和删除困难；而链表正好相反，查找困难，而插入和删除容易。哈希表很完美地结合了两者的优点， Java 的 HashMap 在此基础上还加入了树的优点。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.756701030927835&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBcJg9UngrA7Yh40PkVSOCIkcabXgUqCrxNTaWg9F7Vgn8v4WcsfBGKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;970&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;哈希函数在哈希表中起着⾮常关键的作⽤，它可以把任意长度的输入变换成固定长度的输出，该输出就是哈希值。哈希函数使得一个数据序列的访问过程变得更加迅速有效，通过哈希函数，数据元素能够被很快的进行定位。&lt;/p&gt;&lt;p&gt;若关键字为 k，则其值存放在 &lt;code&gt;hash(k)&lt;/code&gt; 的存储位置上。由此，不需要遍历就可以直接取得 k 对应的值。&lt;/p&gt;&lt;p&gt;对于任意两个不同的数据块，其哈希值相同的可能性极小，也就是说，对于一个给定的数据块，找到和它哈希值相同的数据块极为困难。再者，对于一个数据块，哪怕只改动它的一个比特位，其哈希值的改动也会非常的大——这正是 Hash 存在的价值！&lt;/p&gt;&lt;p&gt;尽管可能性极小，但仍然会发生，如果哈希冲突了，Java 的 HashMap 会在数组的同一个位置上增加链表，如果链表的长度大于 8，将会转化成红黑树进行处理——这就是所谓的拉链法（数组+链表）。&lt;/p&gt;&lt;p&gt;说句实在话，照这个进度恶补下去，我感觉要秃的节奏，不过，如果能够变得更强，值了——对，值了。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>123ab6d1941e70f503126895f108ebce</guid>
<title>前端插件化架构的探索和实践</title>
<link>https://toutiao.io/k/nul54or</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p cid=&quot;n2&quot; mdtype=&quot;paragraph&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;babel插件、webpack插件、vue-cli插件，为啥这么多的优秀框架都是使用插件系统？插件化架构是什么？带来了什么好处？可以应用到什么场景呢？&lt;/span&gt;&lt;/p&gt;&lt;h2 cid=&quot;n4&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;1. 插件化架构定义&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n6&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;插件化架构又称微核架构，指的是软件的内核相对较小，主要功能和业务逻辑都通过插件实现。插件化架构一般有两个核心的概念：内核和插件。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n13&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;内核一般会将要完成的所有业务进行抽象，抽象出最小粒度的基础接口，供插件方来调用。这样，插件开发的效率将会极大的提高。比方说，浏览器就是一个典型的插件化架构，浏览器是内核，页面是插件，这样通过不同的URL地址加载不同的页面，来提供非常丰富的功能。而且，我们开发网页时候，浏览器会提供很多API和能力，这些接口通过 window来挂载， 比如，DOM、BOM、Event、Location等等。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n15&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;设计一个完善的插件化架构的系统，包含三要素：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n16&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n18&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;plugCore&lt;/strong&gt;：插件内核，提供插件运行时，管理插件的加载、运行、卸载等生命周期（类比浏览器）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n20&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;pluginAPI&lt;/strong&gt;：插件运行时需要的基础接口（类比浏览器例子，相当于window）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n22&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;plugin&lt;/strong&gt;：一系列特定功能的独立模块（类比浏览器例子，相当于不同的网页）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5882352941176471&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxjNEfDicGsS6ZRDl34xYbqk6UEeWbuzxpqyCIvicgicicJsQCUrhLOkbMTFfOYibnXiaiaoSw35PwWNJZ3HQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;680&quot;/&gt;&lt;/p&gt;&lt;h2 cid=&quot;n25&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;2. 插件化架构的实践&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n27&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;我们将从&lt;strong&gt;plugCore&lt;/strong&gt;、 &lt;strong&gt;pluginAPI&lt;/strong&gt;和&lt;strong&gt;plugin&lt;/strong&gt;三要素，来解析jQuery、Babel和Vue CLI这三大优秀的开源库其插件化架构的实践。&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n29&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;2.1 jQuery的插件化架构&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n31&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;jQuery 是一个 JavaScript 库，极大地简化了JavaScript 编程，用更少的代码完成更多工作。早期浏览器的标准不统一，开发网页需要兼容不同浏览器的用户使用是一件十分痛苦的事情。jQuery在适配了不同浏览器的差异的基础上提供了更加完善易用API，供前端开发人员完成网页编程，使用jQuery编写的网页，在一套代码下也可以在不同厂商的浏览器上正常运行。在 MV* 框架流行之前，jQuery是绝对的扛霸子。jQuery是可扩展的，其拥有完善的插件体系，网页开发所需要的各种插件在其生态都可以找到。我们解析一下jQuery插件体系。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n33&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;插件定义：&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.24888392857142858&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxjNEfDicGsS6ZRDl34xYbqk6ny6wJxAoKyeUiaz6PJ6k0HKoAj6TibibDHX7xPBHjc4qno0HuApC8icLPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;896&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n36&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;特别说明：&lt;strong&gt;$.fn = jQuery.protype&lt;/strong&gt;(插件精髓)。jQuery的插件机制通过原型链来挂载。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n38&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;插件机制执行过程&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.14407988587731813&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxjNEfDicGsS6ZRDl34xYbqk6MgZKf7CibIvOaTc0GzAXOmEctOqXgMF51zOuvT114947Y5GVrO2kiaKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;701&quot;/&gt;&lt;/p&gt;&lt;h4 cid=&quot;n40&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;demo 示例&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.46405919661733613&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxjNEfDicGsS6ZRDl34xYbqk6ic98mTHBvfUib6NU1EWejuztnhXwp5b2Zeu1mficR0t13CIAibDukKrF5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;946&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n42&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;$app&lt;/strong&gt;便可以在原型链上查找到&lt;strong&gt;myPlugin&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5039145907473309&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxjNEfDicGsS6ZRDl34xYbqk6P0pP83vBpy1DqBOzrQm9rbehcBDqKdQWuU5uDtZaJEbO3NGoW71SNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1405&quot;/&gt;&lt;/p&gt;&lt;h4 cid=&quot;n44&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;从三要素来总结：&lt;/span&gt;&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n46&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n48&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;pluginCore&lt;/strong&gt;：通过原型链赋值来扩展不同的插件，再获得jQuery实例后可以被调用。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n50&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;pluginAPI&lt;/strong&gt;：jQuery包的核心接口，（jQuery依靠其优异的Api取胜）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n52&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;plugin&lt;/strong&gt;：无限制，可以是JavaScript的类型，一般是实现具体功能的模块，比如，日期选择器等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 cid=&quot;n54&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;2.2 Babel的插件化架构&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n56&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Babel 是一个工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。在代码转换的过程中会涉及许多特性和语法的转换，而且ECMAScript的提案总是不断地更新。如何组织大量（不断增加）的转换规则呢？我们来看看 Babel的工作原理。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n58&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Babel转换源码，分为三个步骤：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n60&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n62&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;解析（parse）&lt;/strong&gt;：进行词法分析（Lexical Analysis）和语法分析（Syntactic Analysis）以生成抽象语法树（AST）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n64&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;转换 (transform)&lt;/strong&gt;：遍历AST中每个节点并进行相应的转换操作，该过程通过使用不同的插件来实现各种特性和语法的转换；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n66&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;生成 (generate)&lt;/strong&gt;：根据AST生成目标代码。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n68&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.38204833141542&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxjNEfDicGsS6ZRDl34xYbqk6LaMdnNZZJqEYpIJUgAb4FAIW0Fiay2wp5icFmgYRF3kHjHWZXRcE8Wxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;869&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n68&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Babel在AST转换的过程（即上图的第2步），便使用插件化架构，下面将会详细讲解这个转换过程的插件化架构的使用。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n70&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;插件定义：&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3292583537082315&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxjNEfDicGsS6ZRDl34xYbqk6RbDLLXibASJD1lvacyZOpQ1BJ5A4M4lOicicDdlbwpprXEDnXUnBob1rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1227&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n73&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;插件是一个函数，返回值是一个包含visitor的对象。插件定义的部分概念说明：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n74&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n76&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;name&lt;/strong&gt;：插件名&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n78&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;pluginAPI&lt;/strong&gt;: 插件运行时传入的API&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n80&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;visitor&lt;/strong&gt;: 是一个对象，对象的key是AST的每节点的类型，对象的值是一个函数，AST转换的过程便在这里发生的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n82&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;nodePath&lt;/strong&gt;：是一个AST的节点的实例对象，详细可以参考：@babel/parser/src/parser/node.js [1]，其中， type字段 : 该节点的类型，常见类型：VariableDeclaration（变量声明）、VariableDeclarator（变量声明表达式）、ArrowFunctionExpression（箭头函数表达式）等等，详细可以参考@babel/types [2]。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n84&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;（笔者认为pluginAPI还应包括nodePath，因为，每个节点实例除了语法和词法描述，还包含需求语法间的转换方法）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n86&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;插件示例&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n88&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;箭头函数转换成普通函数的插件：@babel/plugin-transform-arrow-functions [3]源码：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.623020706455542&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxjNEfDicGsS6ZRDl34xYbqk6vn6A1JZA9rAEaU4b3U7G9GHTdfZyyXdBW8dACiaJ6p2NLbJu33NHPPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1642&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n91&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;插件的执行思路：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n92&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n94&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;第一步，执行该插件，获取到包含visitor对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n96&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;第二步，ATS遍历节点，检测nodePath的type === &#x27;ArrowFunctionExpression&#x27;，寻找到vistor对象的中key为 &lt;strong&gt;ArrowFunctionExpression&lt;/strong&gt;的函数；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n98&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;第三步，将nodePath传入该函数进行调用（AST在这步被修改）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n100&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;单个插件的执行思路很明确了，那么在ATS遍历过程，怎么做到多个插件一起工作呢？&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n102&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Babel在转换源码过程中，插件化架构的工作流程是这样的：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n103&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n105&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;第一步：通过解析babel的配置文件（或者命令行--plugins参数），获取Babel配置的所有插件的描述；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n107&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;第二步，将插件的require进内存，获得插件函数，并执行插件函数，获取到多个包含vistor字段对象；（详细逻辑：@babel/core/src/config/full.js [4]）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n109&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;第三步，将多个包含vistor字段对象整合成一个大的visitor源码展示（详细逻辑：@babel/core/src/transformation/index.js [5]）：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.40387596899224804&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxjNEfDicGsS6ZRDl34xYbqk6k1dwgcS6MiamgyGjvh4qibs8a2CIeu5egjnhhJa8icxFuFqwvxPyoe75w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1290&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n111&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;合并后的visitor对象：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.701376421304608&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxjNEfDicGsS6ZRDl34xYbqk6EeaS4ACehYB9bicw2pkerRhic9gibjHASrA4MOZuibBUFOAJ1SXlDCvUyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1671&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n113&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;visitor的对象中的值变成了 &lt;strong&gt;Array&amp;lt;function(nodePath)&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n119&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;从三要素来总结：&lt;/span&gt;&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n121&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n123&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;pluginCore&lt;/strong&gt;：插件加载并整合（即vistor合并)，AST遍历期间是调用查找vistor[NodeType]并依次调用；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n125&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;pluginAPI&lt;/strong&gt;：nodePath，提供不同类型节点的接口来转换AST节点；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n127&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;plugin&lt;/strong&gt;：visitor[NodeType]=function(nodepath)。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 cid=&quot;n129&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;2.3 vue-cli的插件化架构&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n131&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统。CLI插件是向你的 Vue 项目提供可选功能的 npm 包，例如 Babel/TypeScript 转译、ESLint 集成、单元测试和 end-to-end 测试等。Vue CLI 插件的名字以 @vue/cli-plugin- (内建插件) 或 vue-cli-plugin- (社区插件) 开头，非常容易使用。下面，我们将会解析cli插件的定义、执行、安装等过程。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n133&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;插件定义&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n134&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;插件必须是vue-cli-plugin-命名的npm包，并且目录结构也是要严格遵循文件命名来定义。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n136&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;em&gt;注意：@vue/cli-service [6],会通过 项目根目录下package.json中dependencies和devDependencies中定义的 npm包中符合插件命名规范的 npm包作为项目的插件。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2601536772777168&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxjNEfDicGsS6ZRDl34xYbqk6gMNWDRMLmSQgqYXkqOQHQe1VegcYfj0nf8D1y192AicEkFWa4IFKuvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;911&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n140&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;文件命名和内容说明：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.11036468330134357&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxjNEfDicGsS6ZRDl34xYbqk6lqgcIS6LYJoTjKeJjkhNrtR705BrhDm2owBH1VeHDPWMMTyB9ibtR0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1042&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3718079673135853&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxjNEfDicGsS6ZRDl34xYbqk6SPeErZo6VfYSTs8cgJPysm8P8J1OAgGDOYXr5lXQcoIHgXzJia6dtgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;979&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2668463611859838&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxjNEfDicGsS6ZRDl34xYbqk6MwYcib3LmLzGjibL7b7yfrYIWyN5r68NRnCsT0QWF7X61Uic4mH3sOZyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;742&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n152&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;详情可以去看Vue Cli 插件开发指南 [9]&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n154&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;我们把Vue CLI的插件执行分成两种情况：&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n161&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;第一种 安装流程&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n163&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;相比Babel的手动安装添加插件方式，Vue CLI的插件系统提供命令行的安装方式就显得很方便了。我们看看Vue Cli插件系统时怎么实现一行命令添加插件的功能。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n165&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;安装流程的执行思路如下：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n167&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n169&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;第一步：从命令行参数解析出插件名，使用npm（yarn）install vue-cli-plugin-xxx 安装插件，源码位置：@vue/cli/lib/add.js [10]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n171&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;第二步：require(&#x27;vue-cli-plugin-xxx/prompts&#x27;),并获取用户安装是选项结果pluginOptions，源码位置：@vue/cli/lib/invoke.js [11]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.18415841584158416&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxjNEfDicGsS6ZRDl34xYbqk6xeKyzpibWNhNY5FJzAa64OpDAHhSPDqLIia6MSaFsyNTfHGkAA4xObWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1010&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3983983983983984&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxjNEfDicGsS6ZRDl34xYbqk6xiaof0ASCDpFQ7laEAex0FkRrcocq5NZVOvd2hs5nxs4yAJdIXXXbgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;999&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n167&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n178&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;第四步：执行generator.generate方法。这步包括了三个关键步骤：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n179&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;1）require(vue-cli-plugin-xxx/generator)，获得插件的执行函数；&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n180&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;2）构建GeneratorAPI（即pluginAPI）；&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n181&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;3）调用&lt;strong&gt;generator.js&lt;/strong&gt;导出函数。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.14565587734241908&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxjNEfDicGsS6ZRDl34xYbqk6YTLflyMQcIsIqHdqvj8vjZr5iajjZmBJkmtEwBaA3bymNPMzcHrgiaSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1174&quot;/&gt;&lt;/p&gt;&lt;h4 cid=&quot;n187&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;第二种 运行流程&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n189&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;插件运行流程是由@vue/cli-service [14]这个插件系统定义的，这里的调用插件有两种：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.4026330224904004&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxjNEfDicGsS6ZRDl34xYbqk6ACLhNsPMTAr5Hw7uJ1BEu0jHf2tXKn2cIBzibYslz7d1UC53P8ic112A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1823&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n198&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;插件运行逻辑很简单：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2644230769230769&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxjNEfDicGsS6ZRDl34xYbqk6kqeiaDR2icHLsLtptOBcib4op6BibyCjx6oa0YyiaNib8iapicInbrF0yu9WEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1664&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n201&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;这两个流程的 pluginAPI是不一样的。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n208&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;从三要素来总结：&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n210&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;1）安装流程&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n211&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n213&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;pluginCore&lt;/strong&gt;：@vue/cli [17]通过命令行参数获得插件包名，然后安装插件的npm包，并执行&lt;strong&gt;prompts.js&lt;/strong&gt; 获得用户安装选项结果，然后，使用选项结果和&lt;strong&gt;generator.js&lt;/strong&gt;作为参数构造出generator，并在调用generator.generate中执行&lt;strong&gt;generator.js&lt;/strong&gt;函数；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n215&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;pluginAPI&lt;/strong&gt;：GeneratorAPI [18]，提供了源码修改、npm包管理、模版文件生成等功能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n217&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;plugin&lt;/strong&gt;：由&lt;strong&gt;prompts.js&lt;/strong&gt;和&lt;strong&gt;generator.js组成&lt;/strong&gt;，解决某种能力植入项目时，要处理的依赖。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n219&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;2）运行流程&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n220&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n222&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;pluginCore&lt;/strong&gt;：@vue/cli-service [19]，通过package.json中获得项目插件后，与系统内置插件合并，最后依次执行；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n224&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;pluginApI&lt;/strong&gt;：PluginAPI [20]，提供webpack配置修改和命令管理的能力；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n226&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;plugin&lt;/strong&gt;：&lt;strong&gt;index.js&lt;/strong&gt;文件，在不同命令下进行工作。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n228&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;一个插件系统是可以不多个插件类型，并且插件系统通过命令安装插件的实现，用户在使用插件系统时添加插件也是十分方便的。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 cid=&quot;n230&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;3. 插件化架构的应用&lt;/span&gt;&lt;/h2&gt;&lt;h3 cid=&quot;n232&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;3.1 应用场景&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n234&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;通过上述的实例，总结处理插件架构的应用场景。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n235&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n237&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;第一种：富&lt;strong&gt;pluginAPI&lt;/strong&gt;场景：代码在多种场景中运行，需要抹平场景中差异。（jQuery）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n239&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;第二种：富&lt;strong&gt;plugin&lt;/strong&gt;场景，插件系统，可预期需求会越来越多，适合通过更多的插件来简化系统的代码量（Babel）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n241&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;第三种：富&lt;strong&gt;pluginCore&lt;/strong&gt;和&lt;strong&gt;pluginAPI&lt;/strong&gt;场景，插件系统本身非常复杂，需要对开发人员要求极高，这时候，将复杂的工作放到内核和中pluginApi实现，剩下大部分的简单的编码工作留给插件方实现，插件方借助pluginApi也可以快速完成业务开发（Vue CLI）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 cid=&quot;n243&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;3.2 发展方向&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n245&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;通过建立一个插件标准，将研发流程沉淀的能力进行插件化编程，整个公司通过使用一套的插件系统（中台），这样意味着，我们不用重复造业务轮子，团队和企业可以持续积累自己的插件生态，让软件开可以像汽车等工业制造一样，打造一条标准化装配的流水线。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;参考链接：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;1. &lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/babel/babel/blob/31b361b736ee519180f9ea341e2a3e4e710d2ef4/packages/babel-parser/src/parser/node.js&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;2&lt;span&gt;.&lt;/span&gt; &lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://babeljs.io/docs/en/babel-types&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;3&lt;span&gt;.&lt;/span&gt; &lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://babeljs.io/docs/en/next/babel-plugin-transform-arrow-functions&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;4&lt;span&gt;.&lt;/span&gt; &lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/babel/babel/blob/fa975bf7cd2b9054faaff107a79e41dcaad305b1/packages/babel-core/src/config/full.js&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;5&lt;span&gt;.&lt;/span&gt; &lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/babel/babel/blob/fa975bf7cd2b9054faaff107a79e41dcaad305b1/packages/babel-core/src/transformation/index.js#L107&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;6&lt;span&gt;.&lt;/span&gt; &lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-service&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;7&lt;span&gt;.&lt;/span&gt; &lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/SBoudrias/Inquirer.js&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;8&lt;span&gt;.&lt;/span&gt; &lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-service&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;9&lt;span&gt;.&lt;/span&gt; &lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://cli.vuejs.org/zh/dev-guide/plugin-dev.html&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;10&lt;span&gt;.&lt;/span&gt; &lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/vuejs/vue-cli/blob/aee9e178e7c9598f317ceeed2940c94ac82e8340/packages/%40vue/cli/lib/add.js#L52&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;11&lt;span&gt;.&lt;/span&gt; &lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/vuejs/vue-cli/blob/aee9e178e7c9598f317ceeed2940c94ac82e8340/packages/%40vue/cli/lib/invoke.js#L69&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;12&lt;span&gt;.&lt;/span&gt; &lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/vuejs/vue-cli/blob/aee9e178e7c9598f317ceeed2940c94ac82e8340/packages/%40vue/cli/lib/Generator.js#L77&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;13&lt;span&gt;.&lt;/span&gt; &lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/vuejs/vue-cli/blob/aee9e178e7c9598f317ceeed2940c94ac82e8340/packages/%40vue/cli/lib/Generator.js#L149&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;14&lt;span&gt;.&lt;/span&gt; &lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-service&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;15&lt;span&gt;.&lt;/span&gt; &lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/vuejs/vue-cli/blob/aee9e178e7c9598f317ceeed2940c94ac82e8340/packages/%40vue/cli/lib/GeneratorAPI.js&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;16&lt;span&gt;.&lt;/span&gt; &lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/vuejs/vue-cli/blob/aee9e178e7c9598f317ceeed2940c94ac82e8340/packages/%40vue/cli-service/lib/PluginAPI.js&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;17&lt;span&gt;.&lt;/span&gt; &lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/vuejs/vue-cli/tree/aee9e178e7c9598f317ceeed2940c94ac82e8340/packages/%40vue/cli&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;18&lt;span&gt;.&lt;/span&gt; &lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/vuejs/vue-cli/blob/aee9e178e7c9598f317ceeed2940c94ac82e8340/packages/%40vue/cli/lib/GeneratorAPI.js&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;19&lt;span&gt;.&lt;/span&gt; &lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/vuejs/vue-cli/tree/aee9e178e7c9598f317ceeed2940c94ac82e8340/packages/%40vue/cli-service&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;20&lt;span&gt;.&lt;/span&gt; &lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/vuejs/vue-cli/blob/aee9e178e7c9598f317ceeed2940c94ac82e8340/packages/%40vue/cli-service/lib/PluginAPI.js&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;☆ &lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;END&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt; ☆&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;招聘信息&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot;&gt;&lt;p&gt;&lt;span&gt;OPPO互联网基础技术团队招聘一大波岗位，涵盖&lt;strong&gt;C++、Go、OpenJDK、Java、DevOps、Android、ElasticSearch&lt;/strong&gt;等多个方向，&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4MzE2MzY1OA==&amp;amp;mid=2247484254&amp;amp;idx=2&amp;amp;sn=bccee04adfd2c2e7d72b427c32f5891c&amp;amp;chksm=cf4ad43bf83d5d2d0d4ced10e8b047565e8fb765ab1ea62a5fb1c4d5b77a1ac8248a9afca96f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;请点击这里查看详细信息及JD&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;strong&gt;请点击这里查看详细信息及JD&lt;/strong&gt;&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你可能还喜欢&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot;&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4MzE2MzY1OA==&amp;amp;mid=2247484254&amp;amp;idx=1&amp;amp;sn=758ce50bf266cd560235f87ca5e5b82a&amp;amp;chksm=cf4ad43bf83d5d2d385a3324b806efba8138ad71c93268eb958ccaa364de4ac2ad94d2b9dd79&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;OPPO自研ESA DataFlow架构与实践&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4MzE2MzY1OA==&amp;amp;mid=2247484981&amp;amp;idx=1&amp;amp;sn=655df2396f6231e2c1b482665ec849d8&amp;amp;chksm=cf4ad150f83d5846d7dd529db5b299a6d6489a8be0a2d5ff033e8cd2e7e386ccccdb84346482&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;数据同步一致性保障：OPPO自研JinS数据同步框架实践&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4MzE2MzY1OA==&amp;amp;mid=2247484945&amp;amp;idx=1&amp;amp;sn=f3bbc20122db55510e03576e96da728a&amp;amp;chksm=cf4ad174f83d586279eddd4d30c077b3505467f7c50eb69f530fc7ca6edbff517d94fdb5c0b3&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;微服务全链路异步化实践&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4MzE2MzY1OA==&amp;amp;mid=2247484902&amp;amp;idx=1&amp;amp;sn=34904f4f3af88bed24a7e052f3526044&amp;amp;chksm=cf4ad283f83d5b959ca17d2560c1ba4c360bda3595418708a7898b1ed27c1b0331f3e2a54b1c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;Dubbo协议解析与ESA RPC实践&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4MzE2MzY1OA==&amp;amp;mid=2247484347&amp;amp;idx=1&amp;amp;sn=9b83ae42a6f1ffafc0fac18e8158050e&amp;amp;chksm=cf4ad4def83d5dc86b0232151cb72f2a03506265a87a9019410d9daea8d6105b72b9a508683a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;自研代码审查系统火眼Code Review实践&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;更多技术干货&lt;/span&gt;&lt;/p&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;扫码关注&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;OPPO互联网技术&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;120&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;120&quot; data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ECThdibSVDxjYDM1fnDY1N9LLUp4gJV8ulKxP20jO66gHdE8q9DgFIB5hvxfBxEERyWeSxpc6nor8SPgiadWNVsQ/640?wx_fmt=jpeg&quot;/&gt; &lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;95172&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-brushtype=&quot;text&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;我就知道你“在看”&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;1.0377358490566038&quot; data-type=&quot;gif&quot; data-w=&quot;53&quot; data-width=&quot;100%&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/ECThdibSVDxjYDM1fnDY1N9LLUp4gJV8uk9kQ2Hw3Ucae5fnjEfVb2noBlx2NuTgMwzuiceEL19F9prbiaKnZZd3A/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1c074b971507360f57f4173a3c949f57</guid>
<title>Python 之父为什么嫌弃 lambda 匿名函数？</title>
<link>https://toutiao.io/k/tvchzyj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;Python 支持 lambda 匿名函数，其扩展的 BNF 表示法是&lt;code&gt;&lt;span&gt;lambda_expr ::= &quot;lambda&quot; [parameter_list] &quot;:&quot; expression&lt;/span&gt;&lt;/code&gt;，也就是&lt;code&gt;&lt;span&gt;lambda 参数序列:表达式&lt;/span&gt;&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;这是一种便捷的函数定义方式，若翻译成我们熟知的函数形式，会是这个样子：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &amp;lt;&lt;span&gt;lambda&lt;/span&gt;&amp;gt;&lt;span&gt;(parameter_list)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; expression&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也就是说，&lt;strong&gt;Python 中的 lambda 函数是一种可接收多个参数的函数，返回值是一个表达式。&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;它最大的好处是单行简洁，不需要函数命名与换行缩进。&lt;/p&gt;&lt;p&gt;不得不说，匿名函数有时候是挺好用的，比如下文会介绍到的一些常见用法，它因此受到了不少人的推崇。&lt;/p&gt;&lt;p&gt;但是，匿名函数通常也会造成代码难以阅读，容易被人滥用，再加上 Python 只提供了对它的“残疾的”支持，所以又有一些观点不建议使用匿名函数。&lt;/p&gt;&lt;p&gt;事实上，&lt;strong&gt;Python 之父 &lt;span&gt;Guido van Rossum&lt;/span&gt; 就属于“不推荐使用派”，他甚至曾经（2005年）想要移除 &lt;span&gt;lambda&lt;/span&gt;，只不过最后妥协了。&lt;/strong&gt; &lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5329768270944741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTNSj00ComX3SuXopK3H6Rib9tNVVanR5ichhanXgCD4QWaM69DBBaWYFdwjvu2CPpPTesgnV4ibgqo7A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1122&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;出处：&lt;span&gt;https://www.artima.com/weblogs/viewpost.jsp?thread=98196&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;lambda 这一个由其他开发者贡献进来的特性（借鉴自 lisp 语言），存在了十多年，但是却被这门语言的创造者（兼首席设计师）所嫌弃，最后竟然还奇迹般地幸存了下来，对于这个故事，大家是否觉得挺有戏剧性的？&lt;/p&gt;&lt;p&gt;接下来，本文就仔细聊一聊这个处境尴尬却生命力顽强的 lambda 匿名函数吧！&lt;/p&gt;&lt;h2&gt;&lt;span&gt;1、lambda 怎么使用？&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;lambda 函数通常的用法是结合 map()、reduce()、filter()、sorted() 等函数一起使用，这些函数的共性是：&lt;strong&gt;都可以接收其它函数作为参数。&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;例如下面的几个例子：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;my_list = [&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 元素全加1，结果：[4, 2, 6, 5, 11]&lt;/span&gt;&lt;br/&gt;list(map(&lt;span&gt;lambda&lt;/span&gt; i:i+&lt;span&gt;1&lt;/span&gt;, my_list)) &lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 过滤小于10的元素，结果：[3, 1, 5, 4]&lt;/span&gt;&lt;br/&gt;list(filter(&lt;span&gt;lambda&lt;/span&gt; i:i&amp;lt;&lt;span&gt;10&lt;/span&gt;, my_list)) &lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 元素累加，结果：33&lt;/span&gt;&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; functools &lt;span&gt;import&lt;/span&gt; reduce&lt;br/&gt;reduce(&lt;span&gt;lambda&lt;/span&gt; i,j:i+j, my_list, &lt;span&gt;10&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 字典按值排序，结果：[(&#x27;b&#x27;, 1), (&#x27;a&#x27;, 3), (&#x27;d&#x27;, 4), (&#x27;c&#x27;, 5)]&lt;/span&gt;&lt;br/&gt;my_dict = {&lt;span&gt;&#x27;a&#x27;&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;&#x27;b&#x27;&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&#x27;c&#x27;&lt;/span&gt;:&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;&#x27;d&#x27;&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;}&lt;br/&gt;sorted(my_dict.items(), key=&lt;span&gt;lambda&lt;/span&gt; item:item[&lt;span&gt;1&lt;/span&gt;])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;初学者也许会觉得代码读不懂，但是只要记住“&lt;strong&gt;Python中的函数是一等公民&lt;/strong&gt;”，知道一个函数可以被作为另一个函数的参数或者返回值，就容易理解了。&lt;/p&gt;&lt;p&gt;比如对于 map() 函数的例子，你可以理解成这个形式：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;my_func = &lt;span&gt;lambda&lt;/span&gt; i:i+&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;list(map(my_func, my_list)) &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;甚至可以还原成普通的函数：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;add_one&lt;/span&gt;&lt;span&gt;(i)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; i+&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;list(map(add_one, my_list)) &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;map() 函数的第一个参数是一个函数，第二个参数是一个可迭代对象。这第一个参数会迭代地调用第二个参数中的元素，调用的结果以迭代器的形式返回。&lt;/p&gt;&lt;p&gt;这个例子使用了 list()，是为了方便一次性取出迭代器中的元素，直观地展示出来，在实际使用中，很可能会是基于迭代器的形式。&lt;/p&gt;&lt;section&gt;由这几种用法，我们可以总结出 lambda 函数的使用规律：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;它出现在需要使用函数的地方&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;它适合实现简单的功能&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;它是一次性的用途，不能在其它地方复用&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;它一般不会被独立使用，总是作为其它函数的一部分&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;2、lambda 有什么问题？&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;由上面的用法可以看出，使用 lambda 函数的代码比较紧凑简洁，所以有人称它体现了“Pythonic”的优雅思想。&lt;/p&gt;&lt;p&gt;但是，lambda 函数有没有什么缺陷呢？&lt;/p&gt;&lt;p&gt;有！当前的 lambda 函数有一个最大的问题，即只支持单行表达式，无法实现丰富的功能，例如无法在函数创建时使用语句（statement），无法使用 if-else 的判断条件，也无法使用 try-except 的异常捕获机制，等等。&lt;/p&gt;&lt;p&gt;这极大地限制了它的能力，导致了它被人诟病为“残疾的”。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;从技术实现的角度上看，&lt;/strong&gt; 这个问题可以通过语法层面的设计来解决。&lt;/p&gt;&lt;p&gt;在当年的邮件组讨论中，有人提出过一些解决思路，比如这封邮件：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.45154419595314166&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTNSj00ComX3SuXopK3H6Rib9U7W346dFAiarxWjwB1JJpYdyAX2wGlakiagibsDLWiatzdaHgPDSrDAPaw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;939&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;出处：&lt;/span&gt;&lt;span&gt;https://mail.python.org/pipermail/python-dev/2006-February/060654.html&lt;/span&gt;&lt;/section&gt;&lt;p&gt;它提出了一个&lt;code&gt;lambda args::suite&lt;/code&gt; 的想法，支持写成这样的形式：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ss = sorted(seq, key=(&lt;span&gt;lambda&lt;/span&gt; x::&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt;: &lt;span&gt;return&lt;/span&gt; abs(x)&lt;br/&gt;            &lt;span&gt;except&lt;/span&gt; TypeError: &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是，Guido 很快就否决了这个思路。&lt;/p&gt;&lt;p&gt;他写了一篇文章《&lt;span&gt;Language Design Is Not Just Solving Puzzles&lt;/span&gt;》来回应：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5336538461538461&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTNSj00ComX3SuXopK3H6Rib9j5PEib0VSVt0AqYzNm33opqJNvWTLn2qpFbAtpjfbicHWxq1zDyIynUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1248&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;出处：&lt;/span&gt;&lt;span&gt;https://www.artima.com/weblogs/viewpost.jsp?thread=147358&lt;/span&gt;&lt;/section&gt;&lt;p&gt;其基本观点是：&lt;strong&gt;不能光顾着解决一个问题/实现某种功能，就引入缺乏“Pythonicity”的语言设计。&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;那么，为什么 Guido 会认为这是一种不好的设计呢？&lt;/p&gt;&lt;section&gt;我试着概括一下，理由是：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;双冒号“::”凭空在此引入，但是跟切片语法中的“::”完全不同，而且跟 C++/Perl 中的作用域操作符用法也不同&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;即使不用双冒号，用其它符号表示（比如单冒号），还是难以接受，因为都会在一个表达式中嵌入缩进代码块。这就跟使用花括号和 begin/end 关键字来作语句分组（statement grouping）一样，都令人难以接受&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在 lambda 中实现其它功能并不重要，这还会让解析器变得复杂（需区分是否有缩进、记录缩进级别），显得小题大做了&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;简而言之，&lt;strong&gt;他认为简洁友好的用户体验更为重要，如果简洁的语法无法满足需求，就应该写成具名函数的形式，而非设计出复杂的匿名函数。&lt;/strong&gt; &lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、为什么 Guido 想移除 lambda？&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;上文提到的多行 lambda 语句（multi-statement lambda）事件发生在 2006 年，我们看到了 Guido 不想给 lambda 引入复杂设计的原因。&lt;/p&gt;&lt;p&gt;但是，早在 2005 年，Guido 就曾经想要从 Python 移除 lambda，他对它的“嫌弃”是一个“历史悠久”的传统……&lt;/p&gt;&lt;p&gt;在《&lt;span&gt;The fate of reduce() in Python 3000&lt;/span&gt;》这篇短文中，Guido 提出要一次性移除 reduce()、map()、filter() 以及 lambda。&lt;/p&gt;&lt;section&gt;移除 lambda 的理由如下：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对于不熟悉 Lisp 或 Scheme 的用户，lambda 这名字容易造成混淆&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;很多人误以为匿名函数能做嵌套函数不能做的事，但其实并无区别；存在lambda，就会造成不必要的选择，减少选择，可以简化思维&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;移除 reduce()、map() 和 filter() 后，就没必要写简短的局部函数了&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;回顾一下我们在前文中总结出的 lambda 的 4 条使用规律，可以发现它跟几个高阶函数（可以接收其它函数作为参数的函数）有较强的“寄生关系”，如果它们能移除了的话，lambda 确实就没有什么独立存留的意义了。&lt;/p&gt;&lt;p&gt;那么，为什么 Guido 觉得应该移除那几个高阶函数呢？&lt;/p&gt;&lt;section&gt;主要的理由有：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以替换成更加清晰的列表解析式或者生成器表达式，例如 filter(P,S) 可以写成 [x for x in S if P(x)]，map(F, S) 写成 [F(x) for x in S]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;至于 reduce()，他说这是最讨厌的，除了涉及 + 和 * 的少数用法，其它时候他总要拿出纸笔来画图解才能搞清楚。除了显式地写循环，他还针对 reduce() 的几种用法而提出了几个替代用法，包括引入新的 any() 和 all() 函数&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;总体而言，Guido 的想法暗合了《The Zen of Python》中的这一条：&lt;span&gt;&lt;strong&gt;There should be one-- and preferably only one --obvious way to do it。&lt;/strong&gt;&lt;/span&gt;&lt;strong/&gt; &lt;/p&gt;&lt;p&gt;但是回到现实，为了照顾某些人的习惯，以及对兼容性的考虑，Guido 最后保守地放弃了“清理异端”的计划。&lt;/p&gt;&lt;p&gt;因此，lambda 得以从 Python 最高独裁者的手上死里逃生。直到一年后，它试图兴风作浪（多行表达式），却惨遭镇压。&lt;/p&gt;&lt;p&gt;我仿佛听到了 Guido 的内心 OS：当初我想删除东西的时候，你们百般阻挠，现在你们想添加东西，哼，没门！……&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTNSj00ComX3SuXopK3H6Rib9lUibu3gfZcn38YFhK63B93mVb9OBibKZSmicEvwKHbsa4rU6LxuwbB2Aw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;哈哈，开了个玩笑。&lt;/p&gt;&lt;p&gt;Guido 的所有决定都体现了他的 Pythonic 设计美学、自恰的逻辑一致性以及对社区声音的权衡。&lt;/p&gt;&lt;p&gt;对于 lambda，我认可他的观点，而通过回溯语法发展的历史，我觉得自己对于 Python 的理解变得更为丰富了。不知道你可有同感？&lt;/p&gt;&lt;section&gt;&lt;mp-qa class=&quot;js_uneditable custom_select_card qa_iframe&quot; data-pluginname=&quot;insertquestion&quot; data-id=&quot;1527011052679430146&quot; data-bizuin=&quot;MzUyOTk2MTcwNg==&quot; data-title=&quot;聊聊你是怎么看的？&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;最后，附上几篇 Python 程序设计相关的文章作为延伸阅读：&lt;/section&gt;&lt;section&gt;&lt;span&gt;1、&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247484171&amp;amp;idx=1&amp;amp;sn=1dded6a1fe55a0821c7e9eef11b4ce36&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;len(x) 击败 x.len()，从内置函数看 Python 的设计思想&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247484343&amp;amp;idx=1&amp;amp;sn=3eaa4edfd9a26fee4918b969be7305d6&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;编程语言之问：何时该借用，何时该创造？&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3、&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247484675&amp;amp;idx=1&amp;amp;sn=8436b89275654b994458405d42f393ae&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Python 为什么要保留显式的 self ？&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;4、&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247485399&amp;amp;idx=1&amp;amp;sn=1bff48bcb6352f5a09cb7400e2ef8868&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Python 为什么使用缩进来划分代码块？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>