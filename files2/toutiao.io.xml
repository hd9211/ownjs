<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>8645772802041cebc925b043a382909e</guid>
<title>程序员系列之软技能</title>
<link>https://toutiao.io/k/xxf6n5x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img data-w=&quot;584&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4DaJ7DGCek7dc0NCUwMGadNCLLm8fFfDo2WKX72gFO21gTBC1sjNSf3pn1bR8gQTpBa55bFr6MUrM8uT9miawCw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;《软技能-代码之外得生存指南》译版在2016.8就有了，有幸拜读了，收获不少，结合书籍内容和自己的总结，梳理了一下。&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;心态&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;作为“打工人”，大部分程序员对于自己的定位是非常狭隘的，所谓的“螺丝钉”是对自己的标榜，往往是背了“八股文”，包装了项目经历，再加上那么一点点运气进入了厂子里，然后就真的变成了一个“工人”，自己只是任务执行者，完全不会想着在公司上班也是需要有经营思维的。&lt;br/&gt;程序员本质上是“匠人”，而在心态上，需要将自己作为“铁匠铺”进行经营。作为店铺的经营者，除了提供专业的服务，待人接物，影响力等等都需要下功夫。&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;目标&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;想成为什么样的人，想取得什么样的成就，想过什么样的生活……&lt;br/&gt;&lt;strong&gt;目标&lt;/strong&gt;——无论对于个人还是团队都是一切行动之根本。没有目标就跟在大海里航行没有目的地一样，有了目标，一切的行动才是有效的动作，否则就是在浪费资源。&lt;br/&gt;俗话说“人无远虑，必有近忧”，制定符合自身情况的短期目标、长期目标对于自身发展和成长是必不可少的。&lt;br/&gt;就拿“&lt;strong&gt;早起&lt;/strong&gt;”这件事来说，很多人都热衷于参加早起计划、早起打卡等，每天都在坚持着，但是往往坚持一段时间之后就不了了之，该晚睡还是晚睡，该晚起还是晚起。&lt;br/&gt;这是为什么呢？&lt;br/&gt;在我看来，这部分人就是没有确立自己的目标造成的。早起只是实现目标，到达目的地的一种实现方式。比如，我想&lt;strong&gt;减掉脂肪肝&lt;/strong&gt;，那么晚睡熬夜这样的行为就必须要制止，每天晚上进行5公里的慢跑，减少碳水的摄入，自然而然，在10点左右，身体自己就提醒你需要休息了，10点半入睡，休息6、7个小时，5点左右醒来就是非常容易的事情了。&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;人际交往&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;谈软技能，一定会说到人际交往，或者是高情商。对于一名程序员，好像说话、表达是永远过不去的坎儿，从我自身的经历来说，任何技能的掌握和熟练使用都需要无数次的重复练习。&lt;br/&gt;就拿沟通这件事来说，不会说话，不敢说话，不敢当众表达等等都是自我限定。想要有良好的沟通能力，没有速成的方法，只能有意识的进行大量的沟通练习，包括寻找机会与人说话，学习话术，事后反思总结等。&lt;br/&gt;“&lt;strong&gt;以自己为核心，每个人都希望自己很重要&lt;/strong&gt;”——这是人性的弱点，具有共性，所以一切沟通交流把握这一规律，无论你说什么，大概率人们是喜欢跟你聊天沟通的。&lt;br/&gt;具体沟通方式包括：&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;影响力&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;大部分的程序员，对于影响力对自身发展的重要性没有清楚的认知。更多人标榜的是“我只想安安静静码代码”。&lt;br/&gt;然而事实是，作为社会的一员，无论从事什么工作，社会属性都是人们绕不过去的内容。想要有所成就，让自己具有话语权，提升自己对他人的影响力是必须要走的道路。&lt;br/&gt;作为程序员，如何能提升自身的影响力呢？&lt;br/&gt;那就是“&lt;strong&gt;为他人增加价值&lt;/strong&gt;”，具体形式包括：&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;自学&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;作为技术工种，程序员与传统的技术工种一大重要不同点是，作为铁匠，只要你掌握了打铁的技术，靠着这项技术可以养活自己，而程序员从事的编码工作就需要不断的补充学习新的技术栈，所以自我驱动学习的能力是必备的技能之一。&lt;br/&gt;每个程序员都有自己的学习方式方法，这里介绍一种通用的方法，“十步学习法”。该方法分为两个阶段，其中，①-⑥为第一阶段，⑦-⑩为第二阶段。&lt;/p&gt;&lt;ul class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;①扫全局&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;②划范围&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;③定目标&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;④找资源&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;⑤列计划&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;⑥筛资源&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;⑦学习&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;⑧操作&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;⑨掌握&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;⑩为人师&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;对于一门新的技术或者语言，如何进行自学呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第一阶段（只做一次）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;第一阶段是准备阶段，只需要做一次。目标是让自己理清楚需要学习的内容、目标以及能够获取足够学习的资源。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;扫全局&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;第一个步骤就是对要学习的内容有一个全局性的了解，比如学习java语言，找到一本java语言的书籍，花少量的时间读下其中介绍性的章节，粗略浏览下内容即可。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;划范围&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;经过第一个步骤，对要学的东西有个基本的了解了，下一步就是集中精力去明确自己到底要学什么。&lt;br/&gt;还是以学习java语言为例，此时，你需要理解的是“这个题目到底有多大”，以及“如何将其分解为更小的范围”。在一定时间内，你不可能掌握关于java的一切知识，所以需要决定学习的重点和范围。如果你想了解java的基本语法规范，那么这就是你的学习范围。&lt;br/&gt;其中，在这一步中需要注意的点是：明确学习范围的时候要考虑&lt;strong&gt;时间因素&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;定目标&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;目标即评价&lt;/strong&gt;。在全力以赴启动之前，明确“成功”的含义极为重要。有了学习目标，就可以使用倒推的方式，明确实现目标需要的步骤。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;找资源&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;要尝试收集到多种多样的资源以帮助自己学习。包括但不限于，书籍、视频教程、公众号文章、开源项目、博客、在线文档或者培训机构等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;列计划&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;创建学习计划，按图索骥，即创建学习路径，给自己一个大纲。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;筛资源&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;按照学习计划，筛选出对于目标有帮助的资源。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二阶段（循环往复）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;这是一个不断迭代的过程，想要掌握一门语言或者技术，就需要不断的重复再重复。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;学习&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;开始学习的第一步是：&lt;strong&gt;慢&lt;/strong&gt;，需要浅尝辄止。类似玩儿游戏，一开始都要有导学部分，让自己熟悉操作，熟悉技能等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;操作&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;边玩边学。兴趣是最好的老师。先亲自操作和亲身体验，通过探索和实践进行学习。好处是你的大脑会自然产生各种问题，这些问题会引导自己走向答案，也更容易记忆，因为这些答案对你自己是重要的。模仿是一种好的学习手段。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;掌握&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;好奇心是学习特别是自学的重要组成部分。让问题和好奇，结合自己整理的资源，尽可能地汲取知识。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;为人师&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;乐为人师，方可融会贯通。走出自己的舒适区，给自己反思、补缺的机会。&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;拜师&amp;amp;收徒&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;传道授业，三人行必有我师，认老师同时做老师，保持谦逊而有自信的状态。共勉。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1e5330a728dde7fe4d84f3fe026c6d5c</guid>
<title>庖丁解 InnoDB 之 REDO LOG</title>
<link>https://toutiao.io/k/bpcscxg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left&quot; aria-describedby=&quot;js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzIzOTU0NTQ0MA==&amp;amp;action=getalbum&amp;amp;album_id=1530994292440301570#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;1530994292440301570&quot; data-tag_source=&quot;3&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#数据库&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;18个&lt;span class=&quot;weui-hidden_abs&quot;&gt;内容&lt;/span&gt;&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100019184&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6240234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naJlWnrTeROJt0xVJOoHoPC10DdMhibajeafWE1p64IojlE2HcVEvHicTWbqFNJw6xLuY90Tcc5afExA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据库故障恢复机制的前世今生一文&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span&gt;提到，今生&lt;/span&gt;&lt;span&gt;磁盘数据库为了在保证数据库的原子性(A, Atomic) 和持久性(D, Durability)的同时，还能以灵活的刷盘策略来充分利用磁盘顺序写的性能，会记录REDO和UNDO日志，即ARIES方法。本文将重点介绍REDO LOG的作用，记录的内容，组织结构，写入方式等内容，希望读者能够更全面准确的理解REDO LOG在InnoDB中的位置。本文基于MySQL 8.0代码。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;一  为什么需要记录REDO&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;为了取得更好的读写性能，InnoDB会将数据缓存在内存中（InnoDB Buffer Pool），对磁盘数据的修改也会落后于内存，这时如果进程或机器崩溃，会导致内存数据丢失，为了保证数据库本身的一致性和持久性，InnoDB维护了REDO LOG。修改Page之前需要先将修改的内容记录到REDO中，并保证REDO LOG早于对应的Page落盘，也就是常说的WAL，Write Ahead Log。当故障发生导致内存数据丢失后，InnoDB会在重启时，通过重放REDO，将Page恢复到崩溃前的状态。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;二  需要什么样的REDO&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;那么我们需要什么样的REDO呢？首先，REDO的维护增加了一份写盘数据，同时为了保证数据正确，事务只有在他的REDO全部落盘才能返回用户成功，REDO的写盘时间会直接影响系统吞吐，显而易见，REDO的数据量要尽量少。其次，系统崩溃总是发生在始料未及的时候，当重启重放REDO时，系统并不知道哪些REDO对应的Page已经落盘，因此REDO的重放必须可重入，即REDO操作要保证幂等。最后，为了便于通过并发重放的方式加快重启恢复速度，REDO应该是基于Page的，即一个REDO只涉及一个Page的修改。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;熟悉的读者会发现，数据量小是Logical Logging的优点，而幂等以及基于Page正是Physical Logging的优点，因此InnoDB采取了一种称为Physiological Logging的方式，来兼得二者的优势。所谓Physiological Logging，就是以Page为单位，但在Page内以逻辑的方式记录。举个例子，MLOG_REC_UPDATE_IN_PLACE类型的REDO中记录了对Page中一个Record的修改，方法如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;（Page ID，Record Offset，(Filed 1, Value 1) ... (Filed i, Value i) ... )&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其中，PageID指定要操作的Page页，Record Offset记录了Record在Page内的偏移位置，后面的Field数组，记录了需要修改的Field以及修改后的Value。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于Physiological Logging的方式采用了物理Page中的逻辑记法，导致两个问题：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1、需要基于正确的Page状态上重放REDO&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于在一个Page内，REDO是以逻辑的方式记录了前后两次的修改，因此重放REDO必须基于正确的Page状态。然而InnoDB默认的Page大小是16KB，是大于文件系统能保证原子的4KB大小的，因此可能出现Page内容成功一半的情况。InnoDB中采用了Double Write Buffer的方式来通过写两次的方式保证恢复的时候找到一个正确的Page状态。这部分会在之后介绍Buffer Pool的时候详细介绍。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、需要保证REDO重放的幂等&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Double Write Buffer能够保证找到一个正确的Page状态，我们还需要知道这个状态对应REDO上的哪个记录，来避免对Page的重复修改。为此，InnoDB给每个REDO记录一个全局唯一递增的标号LSN(Log Sequence Number)。Page在修改时，会将对应的REDO记录的LSN记录在Page上（FIL_PAGE_LSN字段），这样恢复重放REDO时，就可以来判断跳过已经应用的REDO，从而实现重放的幂等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;三  REDO中记录了什么内容&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;知道了InnoDB中记录REDO的方式，那么REDO里具体会记录哪些内容呢？为了应对InnoDB各种各样不同的需求，到MySQL 8.0为止，已经有多达65种的REDO记录。用来记录这不同的信息，恢复时需要判断不同的REDO类型，来做对应的解析。根据REDO记录不同的作用对象，可以将这65中REDO划分为三个大类：作用于Page，作用于Space以及提供额外信息的Logic类型。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1、作用于Page的REDO&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这类REDO占所有REDO类型的绝大多数，根据作用的Page的不同类型又可以细分为，Index Page REDO，Undo Page REDO，Rtree PageREDO等。比如MLOG_REC_INSERT，MLOG_REC_UPDATE_IN_PLACE，MLOG_REC_DELETE三种类型分别对应于Page中记录的插入，修改以及删除。这里还是以MLOG_REC_UPDATE_IN_PLACE为例来看看其中具体的内容：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022430&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7106598984771574&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6Nibvxmb54Flx7aiaAe8G6yIZ8wMLrr9v30nvMOHQOctzsBLtYJZcGmQFr12Ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;788&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其中，Type就是MLOG_REC_UPDATE_IN_PLACE类型，Space ID和Page Number唯一标识一个Page页，这三项是所有REDO记录都需要有的头信息，后面的是MLOG_REC_UPDATE_IN_PLACE类型独有的，其中Record Offset用给出要修改的记录在Page中的位置偏移，Update Field Count说明记录里有几个Field要修改，紧接着对每个Field给出了Field编号(Field Number)，数据长度（Field Data Length）以及数据（Filed Data）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、作用于Space的REDO&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这类REDO针对一个Space文件的修改，如MLOG_FILE_CREATE，MLOG_FILE_DELETE，MLOG_FILE_RENAME分别对应对一个Space的创建，删除以及重命名。由于文件操作的REDO是在文件操作结束后才记录的，因此在恢复的过程中看到这类日志时，说明文件操作已经成功，因此在恢复过程中大多只是做对文件状态的检查，以MLOG_FILE_CREATE来看看其中记录的内容：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022431&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.34760705289672544&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6Nibvxm7P8DfO33hjueB8iagupJbAcaiaTo00iayXK1KE1HCrmCbolagrTL367XQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;794&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同样的前三个字段还是Type，Space ID和Page Number，由于是针对Page的操作，这里的Page Number永远是0。在此之后记录了创建的文件flag以及文件名，用作重启恢复时的检查。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3、提供额外信息的Logic REDO&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;除了上述类型外，还有少数的几个REDO类型不涉及具体的数据修改，只是为了记录一些需要的信息，比如最常见的MLOG_MULTI_REC_END就是为了标识一个REDO组，也就是一个完整的原子操作的结束。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;4、REDO是如何组织的&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;所谓REDO的组织方式，就是如何把需要的REDO内容记录到磁盘文件中，以方便高效的REDO写入，读取，恢复以及清理。我们这里把REDO从上到下分为三层：逻辑REDO层、物理REDO层和文件层。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;1  逻辑REDO层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;这一层是真正的REDO内容，REDO由多个不同Type的多个REDO记录收尾相连组成，有全局唯一的递增的偏移sn，InnoDB会在全局log_sys中维护当前sn的最大值，并在每次写入数据时将sn增加REDO内容长度。如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022425&quot; data-ratio=&quot;0.18425925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6NibvxmFtWonN4yym5meCM7jx4zpMhkugubApmMz8a121HwOic5yYrql3iaSKhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;2  物理REDO层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;磁盘是块设备，InnoDB中也用Block的概念来读写数据，一个Block的长度OS_FILE_LOG_BLOCK_SIZE等于磁盘扇区的大小512B，每次IO读写的最小单位都是一个Block。除了REDO数据以外，Block中还需要一些额外的信息，下图所示一个Log Block的的组成，包括12字节的Block Header：前4字节中Flush Flag占用最高位bit，标识一次IO的第一个Block，剩下的31个个bit是Block编号；之后是2字节的数据长度，取值在[12，508]；紧接着2字节的First Record Offset用来指向Block中第一个REDO组的开始，这个值的存在使得我们对任何一个Block都可以找到一个合法的的REDO开始位置；最后的4字节Checkpoint Number记录写Block时的next_checkpoint_number，用来发现文件的循环使用，这个会在文件层详细讲解。Block末尾是4字节的Block Tailer，记录当前Block的Checksum，通过这个值，读取Log时可以明确Block数据有没有被完整写完。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022432&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.755359394703657&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6Nibvxm55e5h7VLWY5zsic5DbbjEDOBmqxXAyvAfH3rPHf1gzyD5hTGD5ngDYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;793&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Block中剩余的中间498个字节就是REDO真正内容的存放位置，也就是我们上面说的逻辑REDO。我们现在将逻辑REDO放到物理REDO空间中，由于Block内的空间固定，而REDO长度不定，因此可能一个Block中有多个REDO，也可能一个REDO被拆分到多个Block中，如下图所示，棕色和红色分别代表Block Header和Tailer，中间的REDO记录由于前一个Block剩余空间不足，而被拆分在连续的两个Block中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022433&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3241042345276873&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6Nibvxmibna4Q4X02S5E4NEdH7uw3EKV3fS8x3kHtevAFmJCiboKoTccWIpDzSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1228&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于增加了Block Header和Tailer的字节开销，在物理REDO空间中用LSN来标识偏移，可以看出LSN和SN之间有简单的换算关系：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;inline&lt;/span&gt; lsn_t &lt;span class=&quot;code-snippet__title&quot;&gt;log_translate_sn_to_lsn&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;lsn_t&lt;/span&gt; sn)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; (sn / LOG_BLOCK_DATA_SIZE * OS_FILE_LOG_BLOCK_SIZE +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          sn % LOG_BLOCK_DATA_SIZE + LOG_BLOCK_HDR_SIZE);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;SN加上之前所有的Block的Header以及Tailer的长度就可以换算到对应的LSN，反之亦然。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;3  文件层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;最终REDO会被写入到REDO日志文件中，以ib_logfile0、ib_logfile1...命名，为了避免创建文件及初始化空间带来的开销，InooDB的REDO文件会循环使用，通过参数innodb_log_files_in_group可以指定REDO文件的个数。多个文件收尾相连顺序写入REDO内容。每个文件以Block为单位划分，每个文件的开头固定预留4个Block来记录一些额外的信息，其中第一个Block称为Header Block，之后的3个Block在0号文件上用来存储Checkpoint信息，而在其他文件上留空：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022434&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.38461538461538464&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6NibvxmTAzy0aAEFk4M1vG724Ud0G5xMZBovt9HfXSD4qtSlzKiaC3cozHBcVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1248&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其中第一个Header Block的数据区域记录了一些文件信息，如下图所示，4字节的Formate字段记录Log的版本，不同版本的LOG，会有REDO类型的增减，这个信息是8.0开始才加入的；8字节的Start LSN标识当前文件开始LSN，通过这个信息可以将文件的offset与对应的lsn对应起来；最后是最长32位的Creator信息，正常情况下会记录MySQL的版本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022435&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.26136363636363635&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6NibvxmdchndRO3ehzuNibbYRX3rXnu6GOus51Fo4CpVeGRUdMtSydqibGNb3Aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;792&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在我们将REDO放到文件空间中，如下图所示，逻辑REDO是真正需要的数据，用sn索引，逻辑REDO按固定大小的Block组织，并添加Block的头尾信息形成物理REDO，以lsn索引，这些Block又会放到循环使用的文件空间中的某一位置，文件中用offset索引：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022436&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6162215628090999&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6Nibvxm6pMuoowVzEXaqFNNVutzRpmrX3UpMEDvR2icPYlibz16tqIHib8qxfFNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1011&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;虽然通过LSN可以唯一标识一个REDO位置，但最终对REDO的读写还需要转换到对文件的读写IO，这个时候就需要表示文件空间的offset，他们之间的换算方式如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; real_offset =&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__built_in&quot;&gt;log&lt;/span&gt;.current_file_real_offset + (lsn - &lt;span class=&quot;code-snippet__built_in&quot;&gt;log&lt;/span&gt;.current_file_lsn);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;切换文件时会在内存中更新当前文件开头的文件offset，current_file_real_offset，以及对应的LSN，current_file_lsn，通过这两个值可以方便地用上面的方式将LSN转化为文件offset。注意这里的offset是相当于整个REDO文件空间而言的，由于InnoDB中读写文件的space层实现支持多个文件，因此，可以将首位相连的多个REDO文件看成一个大文件，那么这里的offset就是这个大文件中的偏移。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;五  如何高效地写REDO&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;作为维护数据库正确性的重要信息，REDO日志必须在事务提交前保证落盘，否则一旦断电将会有数据丢失的可能，因此从REDO生成到最终落盘的完整过程成为数据库写入的关键路径，其效率也直接决定了数据库的写入性能。这个过程包括REDO内容的产生，REDO写入InnoDB Log Buffer，从InnoDB Log Buffer写入操作系统Page Cache，以及REDO刷盘，之后还需要唤醒等待的用户线程完成Commit。下面就通过这几个阶段来看看InnoDB如何在高并发的情况下还能高效地完成写REDO。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;1  REDO产生&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们知道事务在写入数据的时候会产生REDO，一次原子的操作可能会包含多条REDO记录，这些REDO可能是访问同一Page的不同位置，也可能是访问不同的Page（如Btree节点分裂）。InnoDB有一套完整的机制来保证涉及一次原子操作的多条REDO记录原子，即恢复的时候要么全部重放，要不全部不重放，这部分将在之后介绍恢复逻辑的时候详细介绍，本文只涉及其中最基本的要求，就是这些REDO必须连续。InnoDB中通过min-transaction实现，简称mtr，需要原子操作时，调用mtr_start生成一个mtr，mtr中会维护一个动态增长的m_log，这是一个动态分配的内存空间，将这个原子操作需要写的所有REDO先写到这个m_log中，当原子操作结束后，调用mtr_commit将m_log中的数据拷贝到InnoDB的Log Buffer。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;2  写入InnoDB Log Buffer&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;高并发的环境中，会同时有非常多的min-transaction(mtr)需要拷贝数据到Log Buffer，如果通过锁互斥，那么毫无疑问这里将成为明显的性能瓶颈。为此，从MySQL 8.0开始，设计了一套无锁的写log机制，其核心思路是允许不同的mtr，同时并发地写Log Buffer的不同位置。不同的mtr会首先调用log_buffer_reserve函数，这个函数里会用自己的REDO长度，原子地对全局偏移log.sn做fetch_add，得到自己在Log Buffer中独享的空间。之后不同mtr并行的将自己的m_log中的数据拷贝到各自独享的空间内。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;sn_t&lt;/span&gt; start_sn = &lt;span class=&quot;code-snippet__built_in&quot;&gt;log&lt;/span&gt;.sn.fetch_add(len);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3  &lt;/span&gt;&lt;span&gt;写入Page Cache&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;写入到Log Buffer中的REDO数据需要进一步写入操作系统的Page Cache，InnoDB中有单独的log_writer来做这件事情。这里有个问题，由于Log Buffer中的数据是不同mtr并发写入的，这个过程中Log Buffer中是有空洞的，因此log_writer需要感知当前Log Buffer中连续日志的末尾，将连续日志通过pwrite系统调用写入操作系统Page Cache。整个过程中应尽可能不影响后续mtr进行数据拷贝，InnoDB在这里引入一个叫做link_buf的数据结构，如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6NibvxmekgdbE25GqMdzrvOMRMf66ySsWEMV4OHUTHpSU81y5ia2Bq7tL54Mnw/0?wx_fmt=png&quot; data-cropx1=&quot;14.225454545454546&quot; data-cropx2=&quot;625.9200000000001&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;517.5922999048065&quot; data-fileid=&quot;100022437&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8461538461538461&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLFn4TAypL51subJv6NibvxmCLKUjgQcbiaeWUnaP9PMUvicKGKUls2jcLkEekrb1lN0M15F23a8GMvA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;611&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;link_buf是一个循环使用的数组，对每个lsn取模可以得到其在link_buf上的一个槽位，在这个槽位中记录REDO长度。另外一个线程从开始遍历这个link_buf，通过槽位中的长度可以找到这条REDO的结尾位置，一直遍历到下一位置为0的位置，可以认为之后的REDO有空洞，而之前已经连续，这个位置叫做link_buf的tail。下面看看log_writer和众多mtr是如何利用这个link_buf数据结构的。这里的这个link_buf为log.recent_written，如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6NibvxmUbZrpMfD5H3QKtzdjd2wow5wUibGt0bDMgZMQXHkic5oaL1LuUPjic4Ug/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;819&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;272.0553633217993&quot; data-fileid=&quot;100022440&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3321123321123321&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLFn4TAypL51subJv6NibvxmpN8mn0ZCgx4pRl7BFsicHzZzTjkdC4HmucGBibI1iaxztTPuibvx7F5CrQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;819&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图中上半部分是REDO日志示意图，write_lsn是当前log_writer已经写入到Page Cache中日志末尾，current_lsn是当前已经分配给mtr的的最大lsn位置，而buf_ready_for_write_lsn是当前log_writer找到的Log Buffer中已经连续的日志结尾，从write_lsn到buf_ready_for_write_lsn是下一次log_writer可以连续调用pwrite写入Page Cache的范围，而从buf_ready_for_write_lsn到current_lsn是当前mtr正在并发写Log Buffer的范围。下面的连续方格便是log.recent_written的数据结构，可以看出由于中间的两个全零的空洞导致buf_ready_for_write_lsn无法继续推进，接下来，假如reserve到中间第一个空洞的mtr也完成了写Log Buffer，并更新了log.recent_written*，如下图：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022439&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.31873479318734793&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6Nibvxm9KBiamc9iaicWymasKrTrvUFREuA8IJy9jpjqBoTE4v2UXeLfKJiaht0xQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;822&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这时，log_writer从当前的buf_ready_for_write_lsn向后遍历log.recent_written，发现这段已经连续：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022428&quot; data-ratio=&quot;0.30833333333333335&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6NibvxmzLPquoBOzVCsO4HxJHrHtvUFgDcXecOAATARf8ibiaPQU1olyEWCMdZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因此提升当前的buf_ready_for_write_lsn，并将log.recent_written的tail位置向前滑动，之后的位置清零，供之后循环复用：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022427&quot; data-ratio=&quot;0.32222222222222224&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6NibvxmTKmRj1pqtKiaT6ehGkic743U0rXgMXS3UDBbcxmVs5MKTLMt5MB7NTQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;紧接log_writer将连续的内容刷盘并提升write_lsn。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;4  刷盘&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;log_writer提升write_lsn之后会通知log_flusher线程，log_flusher线程会调用fsync将REDO刷盘，至此完成了REDO完整的写入过程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;5  唤醒用户线程&lt;/span&gt;&lt;br/&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;为了保证数据正确，只有REDO写完后事务才可以commit，因此在REDO写入的过程中，大量的用户线程会block等待，直到自己的最后一条日志结束写入。默认情况下innodb_flush_log_at_trx_commit = 1，需要等REDO完成刷盘，这也是最安全的方式。当然，也可以通过设置innodb_flush_log_at_trx_commit = 2，这样，只要REDO写入Page Cache就认为完成了写入，极端情况下，掉电可能导致数据丢失。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;大量的用户线程调用log_write_up_to等待在自己的lsn位置，为了避免大量无效的唤醒，InnoDB将阻塞的条件变量拆分为多个，log_write_up_to根据自己需要等待的lsn所在的block取模对应到不同的条件变量上去。同时，为了避免大量的唤醒工作影响log_writer或log_flusher线程，InnoDB中引入了两个专门负责唤醒用户的线程：log_wirte_notifier和log_flush_notifier，当超过一个条件变量需要被唤醒时，log_writer和log_flusher会通知这两个线程完成唤醒工作。下图是整个过程的示意图：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022441&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5029337803855826&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6NibvxmEgQd2vvkjCzyI1o2ZIk4CMFXk4kibSUJd4CGEia081zGngofK5bko4tQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1193&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;多个线程通过一些内部数据结构的辅助，完成了高效的从REDO产生，到REDO写盘，再到唤醒用户线程的流程，下面是整个这个过程的时序图：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022442&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6065573770491803&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6NibvxmepJ9QDOuibgiaq4wtgiaeV7SsVL4myZyQlb1nXzLoKq2vGrKnn7Qy2FFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1098&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;六  如何安全地清除REDO&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;由于REDO文件空间有限，同时为了尽量减少恢复时需要重放的REDO，InnoDB引入log_checkpointer线程周期性的打Checkpoint。重启恢复的时候，只需要从最新的Checkpoint开始回放后边的REDO，因此Checkpoint之前的REDO就可以删除或被复用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们知道REDO的作用是避免只写了内存的数据由于故障丢失，那么打Checkpiont的位置就必须保证之前所有REDO所产生的内存脏页都已经刷盘。最直接的，可以从Buffer Pool中获得当前所有脏页对应的最小REDO LSN：lwm_lsn。但光有这个还不够，因为有一部分min-transaction的REDO对应的Page还没有来的及加入到Buffer Pool的脏页中去，如果checkpoint打到这些REDO的后边，一旦这时发生故障恢复，这部分数据将丢失，因此还需要知道当前已经加入到Buffer Pool的REDO lsn位置：dpa_lsn。取二者的较小值作为最终checkpoint的位置，其核心逻辑如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;lsn_t&lt;/span&gt; lwm_lsn = buf_pool_get_oldest_modification_lwm();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;lsn_t&lt;/span&gt; dpa_lsn = log_buffer_dirty_pages_added_up_to_lsn(&lt;span class=&quot;code-snippet__built_in&quot;&gt;log&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;lsn_t&lt;/span&gt; checkpoint_lsn = &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::min(lwm_lsn, dpa_lsn);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;MySQL 8.0中为了能够让mtr之间更大程度的并发，允许并发地给Buffer Pool注册脏页。类似与log.recent_written和log_writer，&lt;/span&gt;&lt;span&gt;这里引入一个叫做recent_closed的link_buf来处理并发带来的空洞，由单独的线程log_closer来提升recent_closed的tail，也就是当前连续加入Buffer Pool脏页的最大LSN，这个值也就是上面提到的dpa_lsn。需要注意的是，由于这种乱序的存在，lwm_lsn的值并不能简&lt;/span&gt;&lt;span&gt;单的获取当前Buffer Pool中的最老的脏页的LSN，保守起见，&lt;/span&gt;&lt;span&gt;还需要减掉一个recent_closed的容量大小，也就是&lt;/span&gt;&lt;span&gt;最大的乱序范围，简化后的代码如下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;lsn_t&lt;/span&gt; lsn = buf_pool_get_oldest_modification_approx();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;lsn_t&lt;/span&gt; lag = &lt;span class=&quot;code-snippet__built_in&quot;&gt;log&lt;/span&gt;.recent_closed.capacity();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;lsn_t&lt;/span&gt; lwm_lsn = lsn - lag;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;lsn_t&lt;/span&gt; dpa_lsn = log_buffer_dirty_pages_added_up_to_lsn(&lt;span class=&quot;code-snippet__built_in&quot;&gt;log&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;lsn_t&lt;/span&gt; checkpoint_lsn = &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::min(lwm_lsn, dpa_lsn);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这里有一个问题，由于lwm_lsn已经减去了recent_closed的capacity，因此理论上这个值一定是小于dpa_lsn的。那么再去比较lwm_lsn和dpa_lsn来获取Checkpoint位置或许是没有意义的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上面已经提到，ib_logfile0文件的前三个Block有两个被预留作为Checkpoint Block，这两个Block会在打Checkpiont的时候交替使用，这样来避免写Checkpoint过程中的崩溃导致没有可用的Checkpoint。Checkpoint Block中的内容如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022443&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.29539641943734013&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6NibvxmNJp7FHWy7gcVWa5ib5DBYicHIY0v0O2k9CyjYazthepLIrAKmk1vxU7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;782&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先8个字节的Checkpoint Number，通过比较这个值可以判断哪个是最新的Checkpiont记录，之后8字节的Checkpoint LSN为打Checkpoint的REDO位置，恢复时会从这个位置开始重放后边的REDO。之后8个字节的Checkpoint Offset，将Checkpoint LSN与文件空间的偏移对应起来。最后8字节是前面提到的Log Buffer的长度，这个值目前在恢复过程并没有使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;七  总结&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;本文系统的介绍了InnoDB中REDO的作用、特性、组织结构、写入方式已经清理时机，基本覆盖了REDO的大多数内容。关于重启恢复时如何使用REDO将数据库恢复到正确的状态，将在之后介绍InnoDB故障恢复机制的时候详细介绍。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;[1] &lt;/span&gt;&lt;span&gt;MySQL 8.0.11Source Code Documentation: Format of redo log&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;https://dev.mysql.com/doc/dev/mysql-server/8.0.11/PAGE_INNODB_REDO_LOG_FORMAT.html?spm=ata.21736010.0.0.600e6f95JcmTlA&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[2] &lt;/span&gt;&lt;span&gt;MySQL 8.0: New Lock free, scalable WAL design&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;https://mysqlserverteam.com/mysql-8-0-new-lock-free-scalable-wal-design/?spm=ata.21736010.0.0.600e6f95JcmTlA&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[3] &lt;/span&gt;&lt;span&gt;How InnoDB handles REDO logging&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;https://www.percona.com/blog/2011/02/03/how-innodb-handles-redo-logging/?spm=ata.21736010.0.0.600e6f95JcmTlA&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[4] &lt;/span&gt;&lt;span&gt;MySQL Source Code&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;https://github.com/mysql/mysql-server?spm=ata.21736010.0.0.600e6f95JcmTlA&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[5] &lt;/span&gt;&lt;span&gt;数据库故障恢复机制的前世今生&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;http://catkang.github.io/2019/01/16/crash-recovery.html?spm=ata.21736010.0.0.600e6f95JcmTlA&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;博客园&amp;amp;阿里云联合征文活动——我修复的印象最深的一个bug&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;点击阅读原文来分享你的故事吧！&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100022449&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5263888888888889&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLFn4TAypL51subJv6NibvxmPmwfCISkRJRFRsgGIZX95gYD1CVfkugZ56icLPehoJRNwPDSS4c77Aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d9cd5deae673b41f6bd24de66b268e69</guid>
<title>CDP 客户数据管理平台体系化搭建</title>
<link>https://toutiao.io/k/a2qq9lj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left&quot; aria-describedby=&quot;js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4Njg0MzYwNw==&amp;amp;action=getalbum&amp;amp;album_id=1695231212027428866#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;1695231212027428866&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#数据洞察与分析&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;10个&lt;span class=&quot;weui-hidden_abs&quot;&gt;内容&lt;/span&gt;&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h1&gt;&lt;span&gt;一、Cdp系统简介&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、基本概念&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;客户数据平台(Customer-Data-Platform)，简称CDP；通过采集多方客户数据(主体与线索)等，从而进行精准的客户分析和人群细分，进而实现高效的客户维系和发掘以及日常营销运营。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100001828&quot; data-ratio=&quot;0.3078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAVvxzhIdNUpGeicL75dAsFlLlic5jBydzAEgCgRXDFwSZ252DReIGyic9ZqQBBv28ZnffiakA9Xn3cLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;业务面上看Cdp是客户管理流程上的一个节点，技术面上看是重度偏向数据分析的一个平台。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;数据构成&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;主体资料：多方客户（一方、三方、线下）数据汇集，基于唯一ID标识进行客户主体构建与行为数据映射，实现结构化的模型数据管理；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;行为线索：通过SDK埋点的方式，采集客户多种事件类型的行为数据，例如注册、登录、点击、浏览、购买等，作为客户跟进的核心线索；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;不断的完善客户主体的数据，完善相关画像分析，然后通过相关行为采集，进行精准实时的跟进，例如新客的浏览行为，老客户的点击等，都有潜在需求的可能，在Cdp系统采集到这类线索之后，迅速对客户进行沟通跟进，进行精准高效的服务。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;基础流程&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据采集：客户主体即多端(Web、APP、小程序等)注册用户的汇集或者渠道拓展的录入，线索多来自埋点手段的采集；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户模型：基于唯一客户ID标识，构建客户的主体结构，业务模型等，收集与整合多个业务场景下的需求数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据分析：对于客户数据的基本分析能力，常见的分层细化，标签化管理，画像与报表分析等，以此精准的识别客户；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;营销运营：上述的一系列操作，皆是为了能够对客户进行精细化的运营，以此提高客户价值降低维护的时间和营销成本；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;核心价值&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;流量背景下获取客户的成本是非常高的，所以获客之后的精细运营，避免大量流失就尤为重要，建立一批忠诚度高的客户是成本最低但价值最高的运营手段，而CDP系统就是为了支撑该策略的实现。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、对比Crm系统&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;与客户管理概念相关联的系统有不少，例如常说的CRM、CDP、DMP等等，可以不过度纠结这些系统的概念，只需要整体上有认识即可，在大多数场景中可能都是高度聚合在一个系统中，只是通过权限进行划分控制。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100001829&quot; data-ratio=&quot;0.28359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAVvxzhIdNUpGeicL75dAsFlLLibUZzdMBMFchcgEm2pkeqfic3zibmibpNUXV7ZEfkqYgXqYibW7c9FYfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;CDP：核心围绕客户数据的获取、管理、精细运营、营销等，促进客户产生交易行为；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CRM：核心围绕客户交易环节，数据层面相对静态，主要在于交易流程的管理、记录、服务等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DMP：核心围绕标签化的数据管理平台，与CDP有部分牵扯和联系，基于标签透视客户群体；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;系统平台的划分其本质是对业务流程节点的拆解，当业务复杂度较高时，这样有利于单个业务系统的快速迭代与扩展；在初期可能就一个管理系统，划分很多模块，以此降低开发和运维的成本；不同时期有不同的处理策略，对整个流程环节有清晰的认知才是应对业务多变的核心能力。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、业务周期&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、核心模块&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;客户主体&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;客户的基本档案信息，这类数据的最大特点就是变化的频率相对低，不易获取但是容易维护，除此之外相对完善的客户主体还包括：客户联系人、系统跟进人等模块；这样构成一个完整的客户主体档案。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;线索事件&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通过多个产品端和业务线，进行埋点采集数据，作为跟进客户的核心线索，可以精准触达用户的需求，例如新客注册、浏览点击、其背后都是需求的驱动，通过线索事件捕捉用户需求，进而进行跟进销售推广。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;客户跟进&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通过线索获取客户的潜在需求，进而进行快速跟进，明确客户的需求，不断维护客户的跟进记录，持续提供精准服务的能力，这里的跟进方式可以是多样的，例如电话、拜访、短信等。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;维度分析&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;对于客户的分析是多个方面的，常用的手段中，人群细分、标签化管理、业务报表、综合维度评分、流失预警、周期模型等，细致化的客群分析是数据识别的核心手段，这样从技术层面对客户有一次价值评估，在不同业务场景下跟进相应的重点客群。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;营销推广&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通过对客群数据的分析，以及标签化体系的建立，这样就可以对客群进行精准式的推广和营销，例如：基于标签的智能营销，基于种子人群的客户获取，数据越精准，营销的成本就越低，回馈的价值就越高。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、客户周期&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;Cdp平台背后的业务本质，即对客户生命周期的识别和管理，不同阶段下有相应策略与手段，例如常见的客户周期划分：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100001830&quot; data-ratio=&quot;0.340625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAVvxzhIdNUpGeicL75dAsFlGjhBFHBLUcNLqib2k5tTGPn5D8sOhH5h1KaLEauFB7a9q3Wib9mM8aXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;新客：新注册的用户，需求不明朗；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;普通客户：有特定的需求，但是具备一些不确定性；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;会员：需求明确，同时具备确定性；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;超级客户：提供专人跟进，差异化服务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;流失客户：持续跟进没有效果，多次唤醒失败；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;不管是什么类型的客户，都存在一定流失的风险，当客户流失情况出现时，从业务侧提供流失原因分析，也要从技术侧反思，是不是流程周期上不够细致，流失风险识别不及时等。&lt;/p&gt;&lt;p&gt;围绕客户数据采集和业务模型的搭建，从而明确客户的周期，建设已有客群的精细化运营能力。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、架构设计&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;对于任何业务平台的建设，首先都是明确其背后需要解决的业务逻辑，然后对业务流程进行拆解，模块化管理和落地实现，当基本结构完善后，就是不断的迭代和优化：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100001831&quot; data-ratio=&quot;0.70234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAVvxzhIdNUpGeicL75dAsFlnr0eziabdTEel16fpDHEoY1KgEdS3Wpv1GON0l443JRPYYASumvg5oQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;客户增长&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据采集：主要针对两个方面数据，主体资料持续完善，新数据与线索不断积累；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;渠道管理：数据采集来源的管理，不单是线上，还有线下，商务自拓等多个渠道；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;场景分析：不同场景下数据特点分析，识别高质量的采集环境，数据优先处理；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;质量监测：通过数据采集的维度，或者信息质量的识别，进行初始化过滤或者清洗；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;客户档案&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;主体数据：客户主体信息的完善，进而在各个业务环节使用，在结构上需要相对独立；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线索事件：在不同业务节点采集到的线索数据，不同线索事件的背后是需求的挖掘；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;跟进管理：跟进人员分配，跟进结果反馈，基于结果分析客户的需求是否明确，价值高低；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;客户分析&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;细化分层：数据分层是基础能力，例如基于：客单价、交易次数、区域划分、业务价值等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;标签识别：基于标签体系的客群管理，画像透视，在客户精准搜索和营销中十分关键；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;维度评分：综合评估客户的价值，例如常说的：活跃度、需求、购买力、数据完善度；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;周期模型：基于历史数据分析，阶段性评估客户所在的周期节点，进行策略化管理；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;流失预警：不同周期或者级别下的客户提供静默度分析，并提供预警信息，避免流失；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;客户营销&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;运营活动：在运营体系中，针对客群的特征，提供不同特点的活动，进行差异化的产品推广；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;营销策略：不同标签类别下的客户，进行差异化营销，或基于优质客群的共同特征营销；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;结果反馈：不管采用何种营销手段，对结果的反馈是至关重要的，以此验证优化营销策略；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;基础能力&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据存储：不同特点的数据采用相应的存储组件，在数据库选型上视野要开阔；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;搜索引擎：高度依赖数据的平台，对于搜索引擎建设极其重要，支撑多维度的数据查询；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务对接：例如Crm、DMP等系统对接，通常核心在数据层面，以及应用中的交互；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;上述是针对Cdp平台业务流转去分析的，像一些系统基础功能，例如：权限控制、操作日志等没有多余的描述，实际上当数据体量不断膨胀时，会逐步引入大数据相关组件、规则引擎等技术来处理。&lt;/p&gt;&lt;p&gt;很多能力都是在遇到问题情况下，找方案、学习、试错、处理、反思总结，然后就这样积累下来了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;同系列&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4Njg0MzYwNw==&amp;amp;mid=2247485392&amp;amp;idx=1&amp;amp;sn=6895452da3e827128f4b2ef6c9de46ca&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;业务数据清洗&lt;/a&gt;&lt;span&gt; ┃ &lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4Njg0MzYwNw==&amp;amp;mid=2247485218&amp;amp;idx=1&amp;amp;sn=fdce6722b571c35298f9d999b7df2395&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;数据服务设计&lt;/a&gt;&lt;span&gt; ┃ &lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4Njg0MzYwNw==&amp;amp;mid=2247485474&amp;amp;idx=1&amp;amp;sn=fe13e72fa60b103b4603d6567312c2f7&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;元数据管理&lt;/a&gt;&lt;span&gt; ┃ &lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4Njg0MzYwNw==&amp;amp;mid=2247485178&amp;amp;idx=1&amp;amp;sn=e7f42c9d54f6852556abfd01478f8d0b&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;数字营销概念&lt;/a&gt;&lt;span&gt; ┃ &lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4Njg0MzYwNw==&amp;amp;mid=2247485157&amp;amp;idx=1&amp;amp;sn=37b30d99a6d8f3a78cdc79b81b552416&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;标签业务应用&lt;/a&gt;&lt;span&gt; ┃&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、源代码地址&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;GitEE·地址&lt;br/&gt;https://gitee.com/cicadasmile&lt;br/&gt;Wiki·地址&lt;br/&gt;https://gitee.com/cicadasmile/butte-java-note/wikis&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4Njg0MzYwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBCuF3zfJnqPKpUia4wfn1FUtTHpxxkR5HvbicPgOjibPicX0goMOkny1NdkLAJvBaqrYh3UdwMjiaDQMA/0?wx_fmt=png&quot; data-nickname=&quot;知了一笑&quot; data-alias=&quot;cicada_smile&quot; data-signature=&quot;积累是一个孤独且枯燥的过程&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2d651b0165a1246f071364067b06690f</guid>
<title>Spring Boot 如何快速使用 Caffeine 缓存？</title>
<link>https://toutiao.io/k/uopg80d</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;引言&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们有学习&lt;code&gt;Caffeine&lt;/code&gt; 《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIyMjQwMTgyNA==&amp;amp;mid=2247483811&amp;amp;idx=1&amp;amp;sn=9d0b207044b5fe447169d630a7f77aab&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;本地缓存性能之王Caffeine&lt;/a&gt;》，并且也提到&lt;code&gt;SpringBoot&lt;/code&gt;默认使用的本地缓存也是&lt;code&gt;Caffeine&lt;/code&gt;啦，今天我们来看看&lt;code&gt;Caffeine&lt;/code&gt;如何与&lt;code&gt;SpringBoot&lt;/code&gt;集成的。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;集成caffeine&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;caffeine&lt;/code&gt;与&lt;code&gt;SpringBoot&lt;/code&gt;集成有两种方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一种是我们直接引入 &lt;code&gt;Caffeine&lt;/code&gt; 依赖，然后使用 &lt;code&gt;Caffeine&lt;/code&gt; 方法实现缓存。相当于使用原生api&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引入 &lt;code&gt;Caffeine&lt;/code&gt; 和 &lt;code&gt;Spring Cache&lt;/code&gt; 依赖，使用 &lt;code&gt;SpringCache&lt;/code&gt; 注解方法实现缓存。SpringCache帮我们封装了Caffeine
pom文件引入&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;spring-boot-starter-cache&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;com.github.ben-manes.caffeine&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;caffeine&amp;lt;/artifactId&amp;gt;&lt;br/&gt;    &amp;lt;version&amp;gt;&lt;span&gt;2.6&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;第一种方式&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先配置一个&lt;code&gt;Cache&lt;/code&gt;，通过构造者模式构建一个&lt;code&gt;Cache&lt;/code&gt;对象，然后后续关于缓存的增删查都是基于这个&lt;code&gt;cache&lt;/code&gt;对象。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CacheConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Cache&amp;lt;String, Object&amp;gt; &lt;span&gt;caffeineCache&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Caffeine.newBuilder()&lt;br/&gt;                &lt;span&gt;// 设置最后一次写入或访问后经过固定时间过期&lt;/span&gt;&lt;br/&gt;                .expireAfterWrite(&lt;span&gt;60&lt;/span&gt;, TimeUnit.SECONDS)&lt;br/&gt;                &lt;span&gt;// 初始的缓存空间大小&lt;/span&gt;&lt;br/&gt;                .initialCapacity(&lt;span&gt;100&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;// 缓存的最大条数&lt;/span&gt;&lt;br/&gt;                .maximumSize(&lt;span&gt;1000&lt;/span&gt;)&lt;br/&gt;                .build();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一种方式我们就一一不介绍了，基本上就是使用&lt;code&gt;caffeineCache&lt;/code&gt;来根据你自己的业务来操作以下方法&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100002017&quot; data-ratio=&quot;0.5081669691470054&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qu3ItokgsArSJjybsticsAcCYIGktqddg0T9yyrXoILLT9VvB0HBd6Bm5YtsYTxEsVlTXnHKfRGY5PbThgRqD8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;551&quot;/&gt;这种方式使用的话是对代码有侵入性的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;第二种方式&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;需要在SpingBoot启动类标上&lt;code&gt;EnableCaching&lt;/code&gt;注解，这个玩意跟很多框架都一样，比如我们肴集成&lt;code&gt;dubbo&lt;/code&gt;也需要标上&lt;code&gt;@EnableDubbole&lt;/code&gt;注解等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;@SpringBootApplication&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@EnableCaching&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DemoApplication&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            SpringApplication.run(DemoApplication&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;args&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在&lt;code&gt;application.yml&lt;/code&gt;配置我们的使用的缓存类型、过期时间、缓存策略等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;spring:&lt;br/&gt;  profiles:&lt;br/&gt;    active: dev&lt;br/&gt;  cache:&lt;br/&gt;    type: CAFFEINE&lt;br/&gt;    caffeine:&lt;br/&gt;      spec: maximumSize=&lt;span&gt;500&lt;/span&gt;,expireAfterAccess=&lt;span&gt;600&lt;/span&gt;s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们不习惯使用这种方式的配置，当然我们也可以使用&lt;code&gt;JavaConfig&lt;/code&gt;的配置方式来代替配置文件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CacheConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; CacheManager &lt;span&gt;cacheManager&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            CaffeineCacheManager cacheManager = &lt;span&gt;new&lt;/span&gt; CaffeineCacheManager();&lt;br/&gt;            cacheManager.setCaffeine(Caffeine.newBuilder()&lt;br/&gt;                    &lt;span&gt;// 设置最后一次写入或访问后经过固定时间过期&lt;/span&gt;&lt;br/&gt;                    .expireAfterAccess(&lt;span&gt;600&lt;/span&gt;, TimeUnit.SECONDS)&lt;br/&gt;                    &lt;span&gt;// 初始的缓存空间大小&lt;/span&gt;&lt;br/&gt;                    .initialCapacity(&lt;span&gt;100&lt;/span&gt;)&lt;br/&gt;                    &lt;span&gt;// 缓存的最大条数&lt;/span&gt;&lt;br/&gt;                    .maximumSize(&lt;span&gt;500&lt;/span&gt;));&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; cacheManager;&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来就是代码中如何来使用这个缓存了&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@CachePut&lt;/span&gt;(value = &lt;span&gt;&quot;user&quot;&lt;/span&gt;, key = &lt;span&gt;&quot;#userDTO.id&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; UserDTO &lt;span&gt;save&lt;/span&gt;&lt;span&gt;(UserDTO userDTO)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        userRepository.save(userDTO);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; userDTO;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@CacheEvict&lt;/span&gt;(value = &lt;span&gt;&quot;user&quot;&lt;/span&gt;, key = &lt;span&gt;&quot;#id&quot;&lt;/span&gt;)&lt;span&gt;//2&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;(Long id)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        logger.info(&lt;span&gt;&quot;删除了id、key为&quot;&lt;/span&gt; + id + &lt;span&gt;&quot;的数据缓存&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Cacheable&lt;/span&gt;(value = &lt;span&gt;&quot;user&quot;&lt;/span&gt;,key = &lt;span&gt;&quot;#id&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; UserDTO &lt;span&gt;getUserById&lt;/span&gt;&lt;span&gt;(Long id)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; userRepository.findOne(id);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述代码中我们可以看到有几个注解&lt;code&gt;@CachePut、@CacheEvict、@Cacheable&lt;/code&gt;我们只需要在方法上标上这几个注解，我们就能够使用缓存了，我们分别来介绍下这几个注解。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;@Cacheable&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;@Cacheable&lt;/code&gt;它是既可以标注在类上也可以标注在方法上，当它标记在类上的时候它表述这个类上面的所有方法都会支持缓存，同样的
当它作用在法上面时候它表示这个方法是支持缓存的。比如上面我们代码中的&lt;code&gt;getUserById&lt;/code&gt;这个方法第一次缓存里面没有数据，我们会去查询&lt;code&gt;DB&lt;/code&gt;，但是第二次来查询的时候就不会走&lt;code&gt;DB&lt;/code&gt;查询了，而是直接从缓存里面拿到结果就返回了。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;value 属性&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;@Cacheable&lt;/code&gt;的&lt;code&gt;value&lt;/code&gt;属性是必须指定的，其表示当前方法的返回值是会被缓存在哪个&lt;code&gt;Cache&lt;/code&gt;上的，对应&lt;code&gt;Cache&lt;/code&gt;的名称。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;key&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;@Cacheable&lt;/code&gt;的&lt;code&gt;key&lt;/code&gt; 有两种方式一种是我们自己显示的去指定我们的&lt;code&gt;key&lt;/code&gt;，还有一种默认的生成策略，默认的生成策略是&lt;code&gt;SimpleKeyGenerator&lt;/code&gt;这个类，这个生成&lt;code&gt;key&lt;/code&gt;的方式也比较简单我们可以看下它的源码：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object &lt;span&gt;generateKey&lt;/span&gt;&lt;span&gt;(Object... params)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 如果方法没有参数 key就是一个 new SimpleKey()&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (params.length == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; SimpleKey.EMPTY;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 如果方法只有一个参数 key就是当前参数&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (params.length == &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;   Object param = params[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (param != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !param.getClass().isArray()) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; param;&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 如果key是多个参数，key就是new SimpleKey ，不过这个SimpleKey对象的hashCode 和Equals方法是根据方法传入的参数重写的。&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; SimpleKey(params);&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述代码还是非常好理解的分为三种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;方法没有参数，那就new使用一个全局空的&lt;code&gt;SimpleKey&lt;/code&gt;对象来作为&lt;code&gt;key&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方法就一个参数，就使用当前参数来作为&lt;code&gt;key&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方法参数大于&lt;code&gt;1&lt;/code&gt;个，就&lt;code&gt;new&lt;/code&gt;一个&lt;code&gt;SimpleKey&lt;/code&gt;对象来作为&lt;code&gt;key&lt;/code&gt;，&lt;code&gt;new&lt;/code&gt; 这个&lt;code&gt;SimpleKey&lt;/code&gt;的时候用传入的参数重写了&lt;code&gt;SimpleKey&lt;/code&gt;的&lt;code&gt;hashCode&lt;/code&gt;和&lt;code&gt;equals&lt;/code&gt;方法，
至于为啥需要重写的原因话，就跟&lt;code&gt;Map&lt;/code&gt;用自定义对象来作为&lt;code&gt;key&lt;/code&gt;的时候必须要重写&lt;code&gt;hashCode&lt;/code&gt;和&lt;code&gt;equals&lt;/code&gt;方法原理是一样的，因为&lt;code&gt;caffein&lt;/code&gt;也是借助了&lt;code&gt;ConcurrentHashMap&lt;/code&gt;来实现，&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述代码我们可以发现默认生成&lt;code&gt;key&lt;/code&gt;只跟我们传入的参数有关系，如果我们有一个类里面如果存在多个没有参数的方法，然后我们使用了默认的缓存生成策略的话，就会造成缓存丢失。或者缓存相互覆盖，或者还有可能会发生&lt;code&gt;ClassCastException&lt;/code&gt; 因为都是使用同一个&lt;code&gt;key&lt;/code&gt;。比如下面这代码就会发生异常(&lt;code&gt;ClassCastException&lt;/code&gt;)&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;@Cacheable&lt;/span&gt;(value = &lt;span&gt;&quot;user&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; UserDTO &lt;span&gt;getUser&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        UserDTO userDTO = &lt;span&gt;new&lt;/span&gt; UserDTO();&lt;br/&gt;        userDTO.setUserName(&lt;span&gt;&quot;Java金融&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; userDTO;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;@Cacheable&lt;/span&gt;(value = &lt;span&gt;&quot;user&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; UserDTO2 &lt;span&gt;getUser1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        UserDTO2 userDTO2 = &lt;span&gt;new&lt;/span&gt; UserDTO2();&lt;br/&gt;        userDTO2.setUserName2(&lt;span&gt;&quot;javajr.cn&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; userDTO2;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以一般不怎么推荐使用默认的缓存生成&lt;code&gt;key&lt;/code&gt;的策略。如果非要用的话我们最好自己重写一下，带上方法名字等。类似于如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyKeyGenerator&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;SimpleKeyGenerator&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;generate&lt;/span&gt;&lt;span&gt;(Object target, Method method, Object... params)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Object generate = &lt;span&gt;super&lt;/span&gt;.generate(target, method, params);&lt;br/&gt;        String format = MessageFormat.format(&lt;span&gt;&quot;{0}{1}{2}&quot;&lt;/span&gt;, method.toGenericString(), generate);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; format;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;自定义key&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过&lt;code&gt;Spring&lt;/code&gt;的EL表达式来指定我们的&lt;code&gt;key&lt;/code&gt;。这里的EL表达式可以使用方法参数及它们对应的属性。使用方法参数时我们可以直接使用“&lt;code&gt;#参数名&lt;/code&gt;”或者“&lt;code&gt;#p参数index&lt;/code&gt;”这也是我们比较推荐的做法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;   &lt;span&gt;@Cacheable&lt;/span&gt;(value=&lt;span&gt;&quot;user&quot;&lt;/span&gt;, key=&lt;span&gt;&quot;#id&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; UserDTO &lt;span&gt;getUserById&lt;/span&gt;&lt;span&gt;(Long id)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        UserDTO userDTO = &lt;span&gt;new&lt;/span&gt; UserDTO();&lt;br/&gt;        userDTO.setUserName(&lt;span&gt;&quot;java金融&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; userDTO;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;@Cacheable&lt;/span&gt;(value=&lt;span&gt;&quot;user&quot;&lt;/span&gt;, key=&lt;span&gt;&quot;#p0&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; UserDTO &lt;span&gt;getUserById1&lt;/span&gt;&lt;span&gt;(Long id)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;@Cacheable&lt;/span&gt;(value=&lt;span&gt;&quot;user&quot;&lt;/span&gt;, key=&lt;span&gt;&quot;#userDTO.id&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; UserDTO &lt;span&gt;getUserById2&lt;/span&gt;&lt;span&gt;(UserDTO userDTO)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;@Cacheable&lt;/span&gt;(value=&lt;span&gt;&quot;user&quot;&lt;/span&gt;, key=&lt;span&gt;&quot;#p0.id&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; UserDTO &lt;span&gt;getUserById3&lt;/span&gt;&lt;span&gt;(UserDTO userDTO)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;@CachePut&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;@CachePut&lt;/code&gt;指定的属性是和&lt;code&gt;@Cacheable&lt;/code&gt;一样的，但是它们两个是有区别的，&lt;code&gt;@CachePut&lt;/code&gt;标注的方法不会先去查询缓存是否有值，而是每次都会先去执行该方法，然后把结果返回，并且结果也会缓存起来。&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100002016&quot; data-ratio=&quot;1.001349527665317&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qu3ItokgsArSJjybsticsAcCYIGktqddgpaJa1IOeib2vQyFpBsPyamSppu7omgLjQHPnsoYiclljK1J6os2Mk4dQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;741&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么是这样的一个流程我们可以去看看它的源码关键代码就是这一行，&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  Cache.ValueWrapper cacheHit = findCachedItem(contexts.get(CacheableOperation&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;))&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们使用方法上有&lt;code&gt;@Cacheable&lt;/code&gt;注解的时候再&lt;code&gt;contexts&lt;/code&gt;里面会把&lt;code&gt;CacheableOperation&lt;/code&gt;加入进去，只有contexts.get(CacheableOperation.class)取到的内容不为空的话，才会去从缓存里面取内容，否则的话&lt;code&gt;cacheHit&lt;/code&gt;会直接返回&lt;code&gt;null&lt;/code&gt;。至于contexts什么时候加入CacheableOperation的话我们看下&lt;code&gt;SpringCacheAnnotationParser#parseCacheAnnotations&lt;/code&gt;这个方法就会明白的。具体的源码就不展示了，感兴趣的可以自己去翻。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;@CacheEvict&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把缓存中数据删除，用法跟前面两个注解差不多有value和key属性，需要注意一点的是它多了一个属性&lt;code&gt;beforeInvocation&lt;/code&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;beforeInvocation&lt;/code&gt; 这个属性需要注意下它的默认值是false，false代表的意思是再执调用方法之前不删除缓存，只有方法执行成功之后才会去删除缓存。设置为&lt;code&gt;true&lt;/code&gt;的话调用方法之前会去删除一下缓存，方法执行成功之后还会去调用删除缓存这样就是双删了。如果方法执行异常的话就不会去删除缓存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;allEntrie&lt;/code&gt; 是否清空所有缓存内容，默认值为 &lt;code&gt;false&lt;/code&gt;，如果指定为 &lt;code&gt;true&lt;/code&gt;，则方法调用后将立即清空所有缓存&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;@Caching&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个组合注解集成了上面三个注解，有三个属性：&lt;code&gt;cacheable、put和evict&lt;/code&gt;，分别用于来指定&lt;code&gt;@Cacheable&lt;/code&gt;、&lt;code&gt;@CachePut&lt;/code&gt;和&lt;code&gt;@CacheEvict&lt;/code&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二种方式是侵入式的，它的实现原理也比较简单就是通过切面的方法拦截器来实现，拦截所有的方法，它的核心代码如下：看起来就跟我们的业务代码差不了多少，感兴趣的也可以去瞅一瞅。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (contexts.isSynchronized()) {&lt;br/&gt;   CacheOperationContext context = contexts.get(CacheableOperation&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;).&lt;span&gt;iterator&lt;/span&gt;().&lt;span&gt;next&lt;/span&gt;()&lt;/span&gt;;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (isConditionPassing(context, CacheOperationExpressionEvaluator.NO_RESULT)) {&lt;br/&gt;    Object key = generateKey(context, CacheOperationExpressionEvaluator.NO_RESULT);&lt;br/&gt;    Cache cache = context.getCaches().iterator().next();&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; wrapCacheValue(method, cache.get(key, () -&amp;gt; unwrapReturnValue(invokeOperation(invoker))));&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;catch&lt;/span&gt; (Cache.ValueRetrievalException ex) {&lt;br/&gt;     &lt;span&gt;// The invoker wraps any Throwable in a ThrowableWrapper instance so we&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;// can just make sure that one bubbles up the stack.&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;throw&lt;/span&gt; (CacheOperationInvoker.ThrowableWrapper) ex.getCause();&lt;br/&gt;    }&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// No caching required, only call the underlying method&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; invokeOperation(invoker);&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Process any early evictions&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// beforeInvocation 属性是否为true，如果是true就删除缓存&lt;/span&gt;&lt;br/&gt;  processCacheEvicts(contexts.get(CacheEvictOperation&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;), &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;CacheOperationExpressionEvaluator&lt;/span&gt;.&lt;span&gt;NO_RESULT&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Check if we have a cached item matching the conditions&lt;/span&gt;&lt;br/&gt;  Cache.ValueWrapper cacheHit = findCachedItem(contexts.get(CacheableOperation&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;))&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Collect puts from any @Cacheable miss, if no cached item is found&lt;/span&gt;&lt;br/&gt;  List&amp;lt;CachePutRequest&amp;gt; cachePutRequests = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (cacheHit == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;   collectPutRequests(contexts.get(CacheableOperation&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;),&lt;br/&gt;     &lt;span&gt;CacheOperationExpressionEvaluator&lt;/span&gt;.&lt;span&gt;NO_RESULT&lt;/span&gt;, &lt;span&gt;cachePutRequests&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  Object cacheValue;&lt;br/&gt;  Object returnValue;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (cacheHit != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !hasCachePut(contexts)) {&lt;br/&gt;   &lt;span&gt;// If there are no put requests, just use the cache hit&lt;/span&gt;&lt;br/&gt;   cacheValue = cacheHit.get();&lt;br/&gt;   returnValue = wrapCacheValue(method, cacheValue);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;// Invoke the method if we don&#x27;t have a cache hit&lt;/span&gt;&lt;br/&gt;   returnValue = invokeOperation(invoker);&lt;br/&gt;   cacheValue = unwrapReturnValue(returnValue);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Collect any explicit @CachePuts&lt;/span&gt;&lt;br/&gt;  collectPutRequests(contexts.get(CachePutOperation&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;), &lt;span&gt;cacheValue&lt;/span&gt;, &lt;span&gt;cachePutRequests&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Process any collected put requests, either from @CachePut or a @Cacheable miss&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (CachePutRequest cachePutRequest : cachePutRequests) {&lt;br/&gt;   cachePutRequest.apply(cacheValue);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Process any late evictions&lt;/span&gt;&lt;br/&gt;  processCacheEvicts(contexts.get(CacheEvictOperation&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;), &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;cacheValue&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; returnValue;&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;结束&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;由于自己才疏学浅，难免会有纰漏，假如你发现了错误的地方，还望留言给我指出来,我会对其加以修正。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果你觉得文章还不错，你的转发、分享、赞赏、点赞、留言就是对我最大的鼓励。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;感谢您的阅读,十分欢迎并感谢您的关注。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;站在巨人的肩膀上摘苹果:
https://www.cnblogs.com/fashflying/p/6908028.html#!comments&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5d2ebcf787895ad13c8605f309406e21</guid>
<title>K8S 部署 Spring Boot 项目</title>
<link>https://toutiao.io/k/usj54g2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在比较多的互联网公司都在尝试将微服务迁到云上，这样的能够通过一些成熟的云容器管理平台更为方便地管理微服务集群，从而提高微服务的稳定性，同时也能较好地提升团队开发效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是迁云存在一定的技术难点，今天这篇文章主要介绍如何从0开始搭建一套基于K8s部署的SpringBoot案例教程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基础环境准备：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;mac操作系统&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SpringBoot的简单Web工程&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;minikube的环境搭建&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装一个适合我们初级入门的k8s环境，比较好的推荐是使用minikube工具，同时使用该工具可以更好地降低我们对k8s的学习门槛。首先我们需要下载minikube文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;curl -Lo minikube https://github.com/kubernetes/minikube/releases/download/v1.5.0/minikube-linux-amd64 &amp;amp;&amp;amp; chmod +x minikube &amp;amp;&amp;amp; sudo mv minikube /usr/local/bin/&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在安装minikube的时候，尝试下载镜像的时候可能会卡住，例如出现下边的这类异常：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;【idea @ Mac】&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;minikube start --registry-mirror=https://w4i0ckag.mirror.aliyuncs.com&lt;br/&gt;😄  Darwin 10.15.3 上的 minikube v1.16.0&lt;br/&gt;✨  根据现有的配置文件使用 docker 驱动程序&lt;br/&gt;👍  Starting control plane node minikube in cluster minikube&lt;br/&gt;🚜  Pulling base image ...&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;E0126 17:03:30.131026   34416 cache.go:180] Error downloading kic artifacts:  failed to download kic base image or any fallback image&lt;br/&gt;🔥  Creating docker container (CPUs=2, Memory=1988MB) ...&lt;br/&gt;&lt;br/&gt;🤦  StartHost failed, but will try again: creating host: create: creating: setting up container node: preparing volume for minikube container: docker run --rm --entrypoint /usr/bin/test -v minikube:/var gcr.io/k8s-minikube/kicbase:v0.0.15-snapshot4@sha256:ef1f485b5a1cfa4c989bc05e153f0a8525968ec999e242efff871cbb31649c16 -d /var/lib: exit status 125&lt;br/&gt;stdout:&lt;br/&gt;&lt;br/&gt;stderr:&lt;br/&gt;Unable to find image &#x27;gcr.io/k8s-minikube/kicbase:v0.0.15-snapshot4@sha256:ef1f485b5a1cfa4c989bc05e153f0a8525968ec999e242efff871cbb31649c16&#x27; locally&lt;br/&gt;docker: Error response from daemon: Get https://gcr.io/v2/: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers).&lt;br/&gt;See &#x27;docker run --help&#x27;.&lt;br/&gt;&lt;br/&gt;🤷  docker &quot;minikube&quot; container is missing, will recreate.&lt;br/&gt;&lt;br/&gt;🔥  Creating docker container (CPUs=2, Memory=1988MB) ...&lt;br/&gt;😿  Failed to start docker container. Running &quot;minikube delete&quot; may fix it: recreate: creating host: create: creating: setting up container node: preparing volume for minikube container: docker run --rm --entrypoint /usr/bin/test -v minikube:/var gcr.io/k8s-minikube/kicbase:v0.0.15-snapshot4@sha256:ef1f485b5a1cfa4c989bc05e153f0a8525968ec999e242efff871cbb31649c16 -d /var/lib: exit status 125&lt;br/&gt;stdout:&lt;br/&gt;&lt;br/&gt;stderr:&lt;br/&gt;Unable to find image &#x27;gcr.io/k8s-minikube/kicbase:v0.0.15-snapshot4@sha256:ef1f485b5a1cfa4c989bc05e153f0a8525968ec999e242efff871cbb31649c16&#x27; locally&lt;br/&gt;docker: Error response from daemon: Get https://gcr.io/v2/: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers).&lt;br/&gt;See &#x27;docker run --help&#x27;.&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;❌  Exiting due to GUEST_PROVISION: Failed to start host: recreate: creating host: create: creating: setting up container node: preparing volume for minikube container: docker run --rm --entrypoint /usr/bin/test -v minikube:/var gcr.io/k8s-minikube/kicbase:v0.0.15-snapshot4@sha256:ef1f485b5a1cfa4c989bc05e153f0a8525968ec999e242efff871cbb31649c16 -d /var/lib: exit status 125&lt;br/&gt;stdout:&lt;br/&gt;&lt;br/&gt;stderr:&lt;br/&gt;Unable to find image &#x27;gcr.io/k8s-minikube/kicbase:v0.0.15-snapshot4@sha256:ef1f485b5a1cfa4c989bc05e153f0a8525968ec999e242efff871cbb31649c16&#x27; locally&lt;br/&gt;docker: Error response from daemon: Get https://gcr.io/v2/: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers).&lt;br/&gt;See &#x27;docker run --help&#x27;.&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;😿  If the above advice does not help, please let us know:&lt;br/&gt;👉  https://github.com/kubernetes/minikube/issues/new/choose&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时可以尝试先在宿主机上安装好对应的镜像文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;docker pull anjone/kicbase&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后minikube在启动的时候使用本地的镜像，这样可以减少minikube start过程的耗时。minikube下载了之后便到了启动环节：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;minikube start --vm-driver=docker --base-image=&quot;anjone/kicbase&quot;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果启动失败，不妨试试更换指定的镜像仓库，例如下边这段：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;minikube start &lt;br/&gt;--registry-mirror=https://bmtb46e4.mirror.aliyuncs.com &lt;br/&gt;--vm-driver=docker &lt;br/&gt;--base-image=&quot;anjone/kicbase&quot; &lt;br/&gt;--image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里头我大概介绍一下启动参数的含义：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--registry-mirror&lt;/code&gt; 这里的地址会和启动的minikube内部的docker.daemon文件中所指向的镜像仓库地址一致。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--vm-driver&lt;/code&gt; 虚拟机引擎 这里是指minikube的内部通过docker来作为核心&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--base-image&lt;/code&gt; 声明好基础镜像，如果宿主机内部有对应镜像，就不需要额外拉取&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--image-repository&lt;/code&gt; 拉取镜像的仓库&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当minikube启动成功之后，大致如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;【idea @ Mac】&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;minikube start --vm-driver=docker --base-image=&quot;anjone/kicbase&quot; &lt;br/&gt;😄  Darwin 10.15.3 上的 minikube v1.16.0&lt;br/&gt;✨  根据现有的配置文件使用 docker 驱动程序&lt;br/&gt;👍  Starting control plane node minikube in cluster minikube&lt;br/&gt;🤷  docker &quot;minikube&quot; container is missing, will recreate.&lt;br/&gt;🔥  Creating docker container (CPUs=2, Memory=1988MB) ...&lt;br/&gt;❗  This container is having trouble accessing https://k8s.gcr.io&lt;br/&gt;💡  To pull new external images, you may need to configure a proxy: https://minikube.sigs.k8s.io/docs/reference/networking/proxy/&lt;br/&gt;🐳  正在 Docker 19.03.2 中准备 Kubernetes v1.20.0…&lt;br/&gt;    ▪ Generating certificates and keys ...&lt;br/&gt;    ▪ Booting up control plane ...\&lt;br/&gt;&lt;br/&gt;    ▪ Configuring RBAC rules ...&lt;br/&gt;🔎  Verifying Kubernetes components...&lt;br/&gt;🌟  Enabled addons: default-storageclass&lt;br/&gt;🏄  Done! kubectl is now configured to use &quot;minikube&quot; cluster and &quot;default&quot; namespace by default&lt;br/&gt;【idea @ Mac】&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，接下来便到了部署SpringBoot应用的部分了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基于SpringBoot部署到k8s中&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们需要搭建一个简单的SpringBoot应用：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入dependency依赖&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打包docker镜像的配置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;finalName&lt;/span&gt;&amp;gt;&lt;/span&gt;打包出来的镜像名称&lt;span&gt;&amp;lt;/&lt;span&gt;finalName&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.2.5.RELEASE&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;!-- Docker maven plugin --&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.spotify&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;docker-maven-plugin&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.0.0&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;imageName&lt;/span&gt;&amp;gt;&lt;/span&gt;${project.artifactId}&lt;span&gt;&amp;lt;/&lt;span&gt;imageName&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;imageTags&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&amp;lt;&lt;span&gt;tag&lt;/span&gt;&amp;gt;&lt;/span&gt;1.0.1&lt;span&gt;&amp;lt;/&lt;span&gt;tag&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;/&lt;span&gt;imageTags&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;dockerDirectory&lt;/span&gt;&amp;gt;&lt;/span&gt;src/main/docker&lt;span&gt;&amp;lt;/&lt;span&gt;dockerDirectory&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;resources&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&amp;lt;&lt;span&gt;resource&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;&amp;lt;&lt;span&gt;targetPath&lt;/span&gt;&amp;gt;&lt;/span&gt;/&lt;span&gt;&amp;lt;/&lt;span&gt;targetPath&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;&amp;lt;&lt;span&gt;directory&lt;/span&gt;&amp;gt;&lt;/span&gt;${project.build.directory}&lt;span&gt;&amp;lt;/&lt;span&gt;directory&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;&amp;lt;&lt;span&gt;include&lt;/span&gt;&amp;gt;&lt;/span&gt;${project.build.finalName}.jar&lt;span&gt;&amp;lt;/&lt;span&gt;include&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&amp;lt;/&lt;span&gt;resource&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;/&lt;span&gt;resources&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;/&lt;span&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;!-- Docker maven plugin --&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着是简单的controller和启动类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(value = &lt;span&gt;&quot;/test&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(value = &lt;span&gt;&quot;/do-test&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;doTest&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;this is a test&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;success&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@SpringBootApplication&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WebApplication&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        SpringApplication.run(WebApplication&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编写Dockerfile的脚本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;FROM&lt;/span&gt; openjdk:&lt;span&gt;8&lt;/span&gt;-jdk-alpine&lt;br/&gt;&lt;span&gt;VOLUME&lt;/span&gt;&lt;span&gt; /tmp&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#将springboot-k8s-template.jar复制到容器内部 并且别名叫springboot-k8s-template-v1.jar&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ADD&lt;/span&gt;&lt;span&gt; springboot-k8s-template.jar springboot-k8s-template-v1.jar&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#相当于在容器中用cmd命令执行jar包  指定外部配置文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ENTRYPOINT&lt;/span&gt;&lt;span&gt; [&lt;span&gt;&quot;java&quot;&lt;/span&gt;,&lt;span&gt;&quot;-Djava.security.egd=file:/dev/./urandom&quot;&lt;/span&gt;,&lt;span&gt;&quot;-jar&quot;&lt;/span&gt;,&lt;span&gt;&quot;/springboot-k8s-template-v1.jar&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后进入到Dockerfile的目录底下，进行镜像的构建：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;【idea @ Mac】&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;docker build -t springboot-k8s-template:1.0 .&lt;br/&gt;[+] Building 0.5s (7/7) FINISHED                                                                                                                                                                &lt;br/&gt; =&amp;gt; [internal] load build definition from Dockerfile                                                                                                                                       0.0s&lt;br/&gt; =&amp;gt; =&amp;gt; transferring dockerfile: 419B                                                                                                                                                       0.0s&lt;br/&gt; =&amp;gt; [internal] load .dockerignore                                                                                                                                                          0.0s&lt;br/&gt; =&amp;gt; =&amp;gt; transferring context: 2B                                                                                                                                                            0.0s&lt;br/&gt; =&amp;gt; [internal] load metadata &lt;span&gt;for&lt;/span&gt; docker.io/library/openjdk:8-jdk-alpine                                                                                                                    0.0s&lt;br/&gt; =&amp;gt; [internal] load build context                                                                                                                                                          0.3s&lt;br/&gt; =&amp;gt; =&amp;gt; transferring context: 17.60MB                                                                                                                                                       0.3s&lt;br/&gt; =&amp;gt; CACHED [1/2] FROM docker.io/library/openjdk:8-jdk-alpine                                                                                                                               0.0s&lt;br/&gt; =&amp;gt; [2/2] ADD springboot-k8s-template.jar springboot-k8s-template-v1.jar                                                                                                                   0.1s&lt;br/&gt; =&amp;gt; exporting to image                                                                                                                                                                     0.1s&lt;br/&gt; =&amp;gt; =&amp;gt; exporting layers                                                                                                                                                                    0.1s&lt;br/&gt; =&amp;gt; =&amp;gt; writing image sha256:86d02961c4fa5bb576c91e3ebf031a3d8b140ddbb451b9613a2c4d601ac4d853                                                                                               0.0s&lt;br/&gt; =&amp;gt; =&amp;gt; naming to docker.io/library/springboot-k8s-template:1.0                                                                                                                             0.0s&lt;br/&gt;&lt;br/&gt;Use &lt;span&gt;&#x27;docker scan&#x27;&lt;/span&gt; to run Snyk tests against images to find vulnerabilities and learn how to fix them&lt;br/&gt;&lt;br/&gt;【idea @ Mac】&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;docker images | grep template&lt;br/&gt;springboot-k8s-template                                   1.0                                                     86d02961c4fa   48 seconds ago   122MB&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构建完成之后，将本地镜像打包发布到镜像仓库中，这里我是通过推送到阿里云镜像仓库的方式来处理的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;推送本地镜像到阿里云&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先是登录到docker仓库，然后记录对应的tag信息，最终推送镜像。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ docker login --username=[阿里云账户名称] registry.cn-qingdao.aliyuncs.com&lt;br/&gt;$ docker tag [ImageId] registry.cn-qingdao.aliyuncs.com/idea_hub/idea_resp:[镜像版本号]&lt;br/&gt;$ docker push registry.cn-qingdao.aliyuncs.com/idea_hub/idea_resp:[镜像版本号]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;【idea @ Mac】&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;docker images | grep config&lt;br/&gt;qiyu-framework-k8s-config          1.0           6168639757e9   2 minutes ago   122MB&lt;br/&gt;【idea @ Mac】&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;docker tag 6168639757e9 registry.cn-qingdao.aliyuncs.com/idea_hub/idea_resp:qiyu-framework-k8s-config-1.0&lt;br/&gt;【idea @ Mac】&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;docker push registry.cn-qingdao.aliyuncs.com/idea_hub/idea_resp:qiyu-framework-k8s-config-1.0&lt;br/&gt;The push refers to repository [registry.cn-qingdao.aliyuncs.com/idea_hub/idea_resp]&lt;br/&gt;1ace00556b41: Pushed &lt;br/&gt;ceaf9e1ebef5: Layer already exists &lt;br/&gt;9b9b7f3d56a0: Layer already exists &lt;br/&gt;f1b5933fe4b5: Layer already exists &lt;br/&gt;qiyu-framework-k8s-config-1.0: digest: sha256:50c1a87484f6cbec699d65321fa5bbe70f5ad6da5a237e95ea87c7953a1c80da size: 1159&lt;br/&gt;【idea @ Mac】&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100030876&quot; data-ratio=&quot;0.49836601307189543&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbudOUiab4IUl5ql83HMfVYq5QearNCKjlVMoJdqjubMhBthP55kxxibgHn22InUfJBk2SqV7SNAoNqQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;612&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将镜像文件打包并且推送到镜像仓库之后，可以通过在yaml文件中编写对应的镜像地址，这样就能保证在镜像下载的时候能从仓库拉取出对应的镜像文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常项目中我们会采用统一的yaml文件来进行pod节点的部署与构建。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;yaml配置文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;apps/v1&lt;/span&gt;  &lt;span&gt;#kubectl api-versions 可以通过这条指令去看版本信息&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Deployment&lt;/span&gt; &lt;span&gt;# 指定资源类别&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt; &lt;span&gt;#资源的一些元数据&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;springboot-k8s-template-deployment&lt;/span&gt; &lt;span&gt;#deloyment的名称&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;labels:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;app:&lt;/span&gt; &lt;span&gt;springboot-k8s-template-deployment&lt;/span&gt;  &lt;span&gt;#标签&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;replicas:&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;#创建pod的个数&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;selector:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;matchLabels:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;app:&lt;/span&gt; &lt;span&gt;springboot-k8s-template-deployment&lt;/span&gt; &lt;span&gt;#满足标签为这个的时候相关的pod才能被调度到&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;template:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;labels:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;app:&lt;/span&gt; &lt;span&gt;springboot-k8s-template-v1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;containers:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;springboot-k8s-template-v1&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;image:&lt;/span&gt; &lt;span&gt;registry.cn-qingdao.aliyuncs.com/idea_hub/idea_resp:1.0&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;imagePullPolicy:&lt;/span&gt; &lt;span&gt;IfNotPresent&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;containerPort:&lt;/span&gt; &lt;span&gt;8080&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于阿里云的镜像仓库需要用户账号密码权限访问，所以这里我们可以尝试简单一些的策略，登录minikube的内部，提前下载好对应的阿里云镜像。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 minikube ssh 指令即可登录到minikube的内部：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100030877&quot; data-ratio=&quot;0.24358974358974358&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbudOUiab4IUl5ql83HMfVYq5QhaKCsjFW9bSFNhyGxTbniaiahYwTbkSdKkjCrgmCvaavZrvpdia4RdRRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1872&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采用docker pull指令即可下载对应资源：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;docker@minikube:~$ docker pull registry.cn-qingdao.aliyuncs.com/idea_hub/idea_resp:springboot-k8s-template-&lt;span&gt;1.0&lt;/span&gt;&lt;br/&gt;springboot-k8s-template-&lt;span&gt;1.0&lt;/span&gt;: Pulling &lt;span&gt;from&lt;/span&gt; idea_hub/idea_resp&lt;br/&gt;e7c96db7181b: Already exists&lt;br/&gt;f910a506b6cb: Already exists&lt;br/&gt;c2274a1a0e27: Already exists&lt;br/&gt;d2fe98fe1e4e: Pull complete&lt;br/&gt;Digest: sha256:dc1c9caa101df74159c1224ec4d7dcb01932aa8f4a117bba603ffcf35e91c60c&lt;br/&gt;Status: Downloaded newer image for registry.cn-qingdao.aliyuncs.com/idea_hub/idea_resp:springboot-k8s-template-&lt;span&gt;1.0&lt;/span&gt;&lt;br/&gt;registry.cn-qingdao.aliyuncs.com/idea_hub/idea_resp:springboot-k8s-template-&lt;span&gt;1.0&lt;/span&gt;&lt;br/&gt;docker@minikube:~$&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看对应的镜像文件&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100030875&quot; data-ratio=&quot;0.059453032104637336&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbudOUiab4IUl5ql83HMfVYq5QQFDS5DTWBfzkqE0kYLEmcQtrQWWicXPkrheLu42uojhSdZOInrBy4CA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1682&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;镜像拉取策略可以对照官网的介绍来系统认识：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://kubernetes.io/docs/concepts/containers/images/&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在yaml文件里我选用了IfNotPresent策略，这条策略能够保证当本地有镜像的时候优先选用本地，没有才选择网络拉取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后是找到相关的yaml文件进行pod的部署启动。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;kubectl create -f ./k8s-springboot-template.yaml &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时通过 kubectl get pod 命令可以看到对应的pod节点：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100030878&quot; data-ratio=&quot;0.46135552913198574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbudOUiab4IUl5ql83HMfVYq5QRH72Mj3wzUvcv3vRDxfD3md9icZCRfJAwhplC8Zcv2DUwHXvjTArk9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1682&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终需要暴露deployment服务：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;【idea @ 拍了拍我的iterm2 说】&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; kubectl expose deployment springboot-k8s-template-deployment --type=NodePort&lt;br/&gt;service/springboot-k8s-template-deployment exposed&lt;br/&gt;【idea @ 拍了拍我的iterm2 说】&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; kubectl get pods&lt;br/&gt;NAME                                                  READY   STATUS    RESTARTS   AGE&lt;br/&gt;springboot-k8s-template-deployment-687f8bf86d-gqxcp   1/1     Running   0          7m50s&lt;br/&gt;springboot-k8s-template-deployment-687f8bf86d-lcq5p   1/1     Running   0          7m50s&lt;br/&gt;【idea @ 拍了拍我的iterm2 说】&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; minikube service springboot-k8s-template-deployment&lt;br/&gt;|-----------|------------------------------------|-------------|---------------------------|&lt;br/&gt;| NAMESPACE |                NAME                | TARGET PORT |            URL            |&lt;br/&gt;|-----------|------------------------------------|-------------|---------------------------|&lt;br/&gt;| default   | springboot-k8s-template-deployment |        8080 | http://192.168.49.2:31179 |&lt;br/&gt;|-----------|------------------------------------|-------------|---------------------------|&lt;br/&gt;🏃  Starting tunnel for service springboot-k8s-template-deployment.&lt;br/&gt;|-----------|------------------------------------|-------------|------------------------|&lt;br/&gt;| NAMESPACE |                NAME                | TARGET PORT |          URL           |&lt;br/&gt;|-----------|------------------------------------|-------------|------------------------|&lt;br/&gt;| default   | springboot-k8s-template-deployment |             | http://127.0.0.1:57109 |&lt;br/&gt;|-----------|------------------------------------|-------------|------------------------|&lt;br/&gt;🎉  正通过默认浏览器打开服务 default/springboot-k8s-template-deployment...&lt;br/&gt;❗  Because you are using a Docker driver on darwin, the terminal needs to be open to run it.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;暴露之后访问：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;http://127.0.0.1:57109/&lt;span&gt;test&lt;/span&gt;/&lt;span&gt;do&lt;/span&gt;-test&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;验证接口正常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;minikube日志查看：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; kubectl logs -f springboot-k8s-template-deployment-687f8bf86d-lcq5p&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100030879&quot; data-ratio=&quot;0.4043786220218931&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbudOUiab4IUl5ql83HMfVYq5Q2umiadc15PZcCibDLFyl7GJfXTykhfU3oJOtYx8OfsaNPl9afAaNCaNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3106&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>