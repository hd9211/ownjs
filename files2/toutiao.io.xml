<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>8327158ded316f9964c828a5a16354b0</guid>
<title>HTTP/2 做错了什么？刚刚辉煌 2 年就要被弃用了！？</title>
<link>https://toutiao.io/k/v5mm32h</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;article-content&quot;&gt;
&lt;p&gt;最近一段时间以来，关于HTTP/3的新闻有很多，越来越多的国际大公司已经开始使用HTTP/3了。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&quot;lazy&quot; src=&quot;https://www.hollischuang.com/wp-content/uploads/2020/12/16036129562310-4.jpg&quot; alt=&quot;&quot; class=&quot;aligncenter size-full wp-image-5936&quot; srcset=&quot;https://www.hollischuang.com/wp-content/uploads/2020/12/16036129562310-4.jpg 1298w, https://www.hollischuang.com/wp-content/uploads/2020/12/16036129562310-4-300x150.jpg 300w, https://www.hollischuang.com/wp-content/uploads/2020/12/16036129562310-4-1024x513.jpg 1024w, https://www.hollischuang.com/wp-content/uploads/2020/12/16036129562310-4-768x385.jpg 768w&quot; sizes=&quot;(max-width: 1298px) 100vw, 1298px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img loading=&quot;lazy&quot; src=&quot;https://www.hollischuang.com/wp-content/uploads/2020/12/16036129871026-4.jpg&quot; alt=&quot;&quot; class=&quot;aligncenter size-full wp-image-5935&quot; srcset=&quot;https://www.hollischuang.com/wp-content/uploads/2020/12/16036129871026-4.jpg 1318w, https://www.hollischuang.com/wp-content/uploads/2020/12/16036129871026-4-300x87.jpg 300w, https://www.hollischuang.com/wp-content/uploads/2020/12/16036129871026-4-1024x298.jpg 1024w, https://www.hollischuang.com/wp-content/uploads/2020/12/16036129871026-4-768x224.jpg 768w&quot; sizes=&quot;(max-width: 1318px) 100vw, 1318px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，HTTP/3已经是箭在弦上了，全面使用只是个时间问题，那么，作为一线开发者，我们也是时候了解下到底什么是HTTP/3，为什么需要HTTP/3了。&lt;/p&gt;
&lt;p&gt;于是，我准备开始写这篇文章，但是要想把HTTP/3的事情说清楚，一定绕不过的问题就是HTTP/2，所以写着写着，篇幅越来越多，于是我就把他们分成了上下两篇。&lt;/p&gt;
&lt;p&gt;这一篇我们主要来回顾下HTTP/2，然后再来重点看一下HTTP/2存在哪些问题，为什么要被弃用。&lt;/p&gt;
&lt;h3&gt;HTTP/2 辉煌不在？&lt;/h3&gt;
&lt;p&gt;虽然HTTP/2标准在2015年5月就以RFC 7540正式发表了，并且多数浏览器在2015年底就支持了。&lt;/p&gt;
&lt;p&gt;但是，真正被广泛使用起来要到2018年左右，但是也是在2018年，11月IETF给出了官方批准，认可HTTP-over-QUIC成为HTTP/3。&lt;/p&gt;
&lt;p&gt;2018年的时候，我写过一篇文章介绍《&lt;a href=&quot;https://www.hollischuang.com/archives/2066&quot;&gt;HTTP/2到底是什么？&lt;/a&gt;》，那时候HTTP/2还是个新技术，刚刚开始有软件支持，短短两年过去了，现在HTTP/3已经悄然而至了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根据W3Techs的数据，截至2019年6月，全球也仅有36.5%的网站支持了HTTP/2。&lt;/strong&gt;所以，可能很多网站还没开始支持HTTP/2，HTTP/3就已经来了。&lt;/p&gt;
&lt;p&gt;所以，对于很多网站来说，或许直接升级HTTP/3是一个更加正确的选择。&lt;/p&gt;
&lt;h3&gt;回顾 HTTP/2&lt;/h3&gt;
&lt;p&gt;在阅读本文之前，强烈建议大家先阅读下《&lt;a href=&quot;https://www.hollischuang.com/archives/2066&quot;&gt;HTTP/2到底是什么？&lt;/a&gt;》这篇文章，这里面介绍了HTTP的历史，介绍了各个版本的HTTP协议的诞生的背景。&lt;/p&gt;
&lt;p&gt;当你读到这里的时候，我默认大家对HTTP/2有了一定的基本了解。&lt;/p&gt;
&lt;p&gt;我们知道，HTTP/2的诞生，主要是为了解决HTTP/1.1中的效率问题，HTTP/2中最核心的技术就是多路复用技术，即允许同时通过单一的HTTP/2.0连接发起多重的请求-响应消息。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&quot;lazy&quot; src=&quot;https://www.hollischuang.com/wp-content/uploads/2020/12/16078443845209-4.jpg&quot; alt=&quot;&quot; class=&quot;aligncenter size-full wp-image-5943&quot; srcset=&quot;https://www.hollischuang.com/wp-content/uploads/2020/12/16078443845209-4.jpg 1982w, https://www.hollischuang.com/wp-content/uploads/2020/12/16078443845209-4-300x142.jpg 300w, https://www.hollischuang.com/wp-content/uploads/2020/12/16078443845209-4-1024x485.jpg 1024w, https://www.hollischuang.com/wp-content/uploads/2020/12/16078443845209-4-768x363.jpg 768w, https://www.hollischuang.com/wp-content/uploads/2020/12/16078443845209-4-1536x727.jpg 1536w&quot; sizes=&quot;(max-width: 1982px) 100vw, 1982px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时还实现了二进制分帧、header压缩、服务端推送等技术。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从HTTP/1.0诞生，一直到HTTP/2，在这24年里，HTTP协议已经做过了三次升级，但是有一个关键的技术点是不变的，那就是这所有的HTTP协议，都是基于TCP协议实现的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;流水的HTTP，铁打的TCP。这是因为相对于UDP协议，TCP协议更加可靠。&lt;/p&gt;
&lt;p&gt;虽然在HTTP/1.1的基础上推出HTTP/2大大的提升了效率，但是还是有很多人认为这只是个”临时方案”，这也是为什么刚刚推出没多久，业内就开始大力投入HTTP/3的研发与推广了。&lt;/p&gt;
&lt;p&gt;而这背后的深层次原因也正是因为他还是基于TCP协议实现的。&lt;strong&gt;TCP协议虽然更加可靠，但是还是存在着一定的问题&lt;/strong&gt;，接下来具体分析下。&lt;/p&gt;
&lt;h3&gt;HTTP/2 问题&lt;/h3&gt;
&lt;h4&gt;队头阻塞&lt;/h4&gt;
&lt;p&gt;队头阻塞翻译自英文head-of-line blocking，这个词并不新鲜，因为早在HTTP/1.1时代，就一直存在着队头阻塞的问题。&lt;/p&gt;
&lt;p&gt;但是很多人在一些资料中会看到有论点说HTTP/2解决了队头阻塞的问题。但是这句话只对了一半。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只能说HTTP/2解决了HTTP的队头阻塞问题，但是并没有解决TCP队头阻塞问题！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果大家对于HTTP的历史有一定的了解的话，就会知道。HTTP/1.1相比较于HTTP/1.0来说，最主要的改进就是引入了持久连接（keep-alive）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所谓的持久连接就是：在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img loading=&quot;lazy&quot; src=&quot;https://www.hollischuang.com/wp-content/uploads/2020/12/16078448717551-4.jpg&quot; alt=&quot;&quot; class=&quot;aligncenter size-full wp-image-5940&quot; srcset=&quot;https://www.hollischuang.com/wp-content/uploads/2020/12/16078448717551-4.jpg 1810w, https://www.hollischuang.com/wp-content/uploads/2020/12/16078448717551-4-300x202.jpg 300w, https://www.hollischuang.com/wp-content/uploads/2020/12/16078448717551-4-1024x688.jpg 1024w, https://www.hollischuang.com/wp-content/uploads/2020/12/16078448717551-4-768x516.jpg 768w, https://www.hollischuang.com/wp-content/uploads/2020/12/16078448717551-4-1536x1032.jpg 1536w&quot; sizes=&quot;(max-width: 1810px) 100vw, 1810px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;引入了持久连接之后，在性能方面，HTTP协议有了明显的提升。&lt;/p&gt;
&lt;p&gt;另外，HTTP/1.1允许在持久连接上使用请求管道，是相对于持久连接的又一性能优化。&lt;/p&gt;
&lt;p&gt;所谓请求管道，就是在HTTP响应到达之前，可以将多条请求放入队列，当第一条HTTP请求通过网络流向服务器时，第二条和第三条请求也可以开始发送了。在高时延网络条件下，这样做可以降低网络的环回时间，提高性能。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&quot;lazy&quot; src=&quot;https://www.hollischuang.com/wp-content/uploads/2020/12/16078448616542-4.jpg&quot; alt=&quot;&quot; class=&quot;aligncenter size-full wp-image-5941&quot; srcset=&quot;https://www.hollischuang.com/wp-content/uploads/2020/12/16078448616542-4.jpg 1032w, https://www.hollischuang.com/wp-content/uploads/2020/12/16078448616542-4-300x192.jpg 300w, https://www.hollischuang.com/wp-content/uploads/2020/12/16078448616542-4-1024x655.jpg 1024w, https://www.hollischuang.com/wp-content/uploads/2020/12/16078448616542-4-768x491.jpg 768w&quot; sizes=&quot;(max-width: 1032px) 100vw, 1032px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是，对于管道连接还是有一定的限制和要求的，其中一个比较关键的就是服务端必须按照与请求相同的顺序回送HTTP响应。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这也就意味着，如果一个响应返回发生了延迟，那么其后续的响应都会被延迟，直到队头的响应送达。这就是所谓的&lt;strong&gt;HTTP队头阻塞&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但是HTTP队头阻塞的问题在HTTP/2中得到了有效的解决。&lt;strong&gt;HTTP/2废弃了管道化的方式&lt;/strong&gt;，而是创新性的引入了帧、消息和数据流等概念。&lt;strong&gt;客户端和服务器可以把 HTTP 消息分解为互不依赖的帧，然后乱序发送，最后再在另一端把它们重新组合起来。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img loading=&quot;lazy&quot; src=&quot;https://www.hollischuang.com/wp-content/uploads/2020/12/16078452101126-4.jpg&quot; alt=&quot;&quot; class=&quot;aligncenter size-full wp-image-5939&quot; srcset=&quot;https://www.hollischuang.com/wp-content/uploads/2020/12/16078452101126-4.jpg 1982w, https://www.hollischuang.com/wp-content/uploads/2020/12/16078452101126-4-300x95.jpg 300w, https://www.hollischuang.com/wp-content/uploads/2020/12/16078452101126-4-1024x325.jpg 1024w, https://www.hollischuang.com/wp-content/uploads/2020/12/16078452101126-4-768x244.jpg 768w, https://www.hollischuang.com/wp-content/uploads/2020/12/16078452101126-4-1536x488.jpg 1536w&quot; sizes=&quot;(max-width: 1982px) 100vw, 1982px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因为没有顺序了，所以就不需要阻塞了，就有效的解决了HTTP对队头阻塞的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是，HTTP/2仍然会存在TCP队头阻塞的问题，那是因为HTTP/2其实还是依赖TCP协议实现的。&lt;/p&gt;
&lt;p&gt;TCP传输过程中会把数据拆分为一个个&lt;strong&gt;按照顺序&lt;/strong&gt;排列的数据包，这些数据包通过网络传输到了接收端，接收端再&lt;strong&gt;按照顺序&lt;/strong&gt;将这些数据包组合成原始数据，这样就完成了数据传输。&lt;/p&gt;
&lt;p&gt;但是如果其中的某一个数据包没有按照顺序到达，接收端会一直保持连接等待数据包返回，这时候就会阻塞后续请求。这就发生了&lt;strong&gt;TCP队头阻塞&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;HTTP/1.1的管道化持久连接也是使得同一个TCP链接可以被多个HTTP使用，但是HTTP/1.1中规定一个域名可以有6个TCP连接。而HTTP/2中，同一个域名只是用一个TCP连接。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;在HTTP/2中，TCP队头阻塞造成的影响会更大&lt;/strong&gt;，因为HTTP/2的多路复用技术使得多个请求其实是基于同一个TCP连接的，那如果某一个请求造成了TCP队头阻塞，那么多个请求都会受到影响。&lt;/p&gt;
&lt;h4&gt;TCP握手时长&lt;/h4&gt;
&lt;p&gt;一提到TCP协议，大家最先想到的一定是他的三次握手与四次关闭的特性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因为TCP是一种可靠通信协议，而这种可靠就是靠三次握手实现的，通过三次握手，TCP在传输过程中可以保证接收方收到的数据是完整，有序，无差错的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是，问题是三次握手是需要消耗时间的，这里插播一个关于网络延迟的概念。&lt;/p&gt;
&lt;p&gt;网络延迟又称为 RTT（Round Trip Time）。他是指一个请求从客户端浏览器发送一个请求数据包到服务器，再从服务器得到响应数据包的这段时间。RTT 是反映网络性能的一个重要指标。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&quot;lazy&quot; src=&quot;https://www.hollischuang.com/wp-content/uploads/2020/12/16078465903616-4.jpg&quot; alt=&quot;&quot; class=&quot;aligncenter size-full wp-image-5938&quot; srcset=&quot;https://www.hollischuang.com/wp-content/uploads/2020/12/16078465903616-4.jpg 822w, https://www.hollischuang.com/wp-content/uploads/2020/12/16078465903616-4-300x224.jpg 300w, https://www.hollischuang.com/wp-content/uploads/2020/12/16078465903616-4-768x574.jpg 768w&quot; sizes=&quot;(max-width: 822px) 100vw, 822px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们知道，TCP三次握手的过程客户端和服务器之间需要交互三次，那么也就是说需要消耗1.5 RTT。&lt;/p&gt;
&lt;p&gt;另外，如果使用的是安全的HTTPS协议，就还需要使用TLS协议进行安全数据传输，这个过程又要消耗一个RTT（TLS不同版本的握手机制不同，这里按照最小的消耗来算）&lt;/p&gt;
&lt;p&gt;那么也就是说，一个纯HTTP/2的连接，需要消耗1.5个RTT，如果是一个HTTPS连接，就需要消耗3-4个RTT。&lt;/p&gt;
&lt;p&gt;而具体消耗的时长根据服务器和客户端之间的距离则不尽相同，如果比较近的话，消耗在100ms以内，对于用来说可能没什么感知，但是如果一个RTT的耗时达到300-400ms，那么，一次连接建立过程总耗时可能要达到一秒钟左右，这时候，用户就会明显的感知到网页加载很慢。&lt;/p&gt;
&lt;h3&gt;升级TCP是否可行？&lt;/h3&gt;
&lt;p&gt;基于上面我们提到的这些问题，很多人提出来说：既然TCP存在这些问题，并且我们也知道这些问题的存在，甚至解决方案也不难想到，为什么不能对协议本身做一次升级，解决这些问题呢？&lt;/p&gt;
&lt;p&gt;其实，这就涉及到一个”&lt;strong&gt;协议僵化&lt;/strong&gt;“的问题。&lt;/p&gt;
&lt;p&gt;这样讲，我们在互联网上浏览数据的时候，数据的传输过程其实是极其复杂的。&lt;/p&gt;
&lt;p&gt;我们知道的，想要在家里使用网络有几个前提，首先我们要通过运行商开通网络，并且需要使用路由器，而路由器就是网络传输过程中的一个中间设备。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;中间设备是指插入在数据终端和信号转换设备之间，完成调制前或解调后某些附加功能的辅助设备。例如集线器、交换机和无线接入点、路由器、安全解调器、通信服务器等都是中间设备。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在我们看不到的地方，这种中间设备还有很多很多，&lt;strong&gt;一个网络需要经过无数个中间设备的转发才能到达终端用户。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果TCP协议需要升级，那么意味着需要这些中间设备都能支持新的特性，我们知道路由器我们可以重新换一个，但是其他的那些中间设备呢？尤其是那些比较大型的设备呢？更换起来的成本是巨大的。&lt;/p&gt;
&lt;p&gt;而且，除了中间设备之外，操作系统也是一个重要的因素，&lt;strong&gt;因为TCP协议需要通过操作系统内核来实现，而操作系统的更新也是非常滞后的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，这种问题就被称之为”中间设备僵化”，也是导致”协议僵化”的重要原因。这也是限制着TCP协议更新的一个重要原因。&lt;/p&gt;
&lt;p&gt;所以，近些年来，由IETF标准化的许多TCP新特性都因缺乏广泛支持而没有得到广泛的部署或使用！&lt;/p&gt;
&lt;h3&gt;放弃TCP？&lt;/h3&gt;
&lt;p&gt;上面提到的这些问题的根本原因都是因为HTTP/2是基于TPC实现导致的，而TCP协议自身的升级又是很难实现的。&lt;/p&gt;
&lt;p&gt;那么，剩下的解决办法就只有一条路，那就是放弃TCP协议。&lt;/p&gt;
&lt;p&gt;放弃TCP的话，就又有两个新的选择，是使用其他已有的协议，还是重新创造一个协议呢？&lt;/p&gt;
&lt;p&gt;看到这里，聪明的读者一定也想到了，&lt;strong&gt;创造新的协议一样会受到中间设备僵化的影响&lt;/strong&gt;。近些年来，因为在互联网上部署遭遇很大的困难，创造新型传输层协议的努力基本上都失败了！&lt;/p&gt;
&lt;p&gt;所以，想要升级新的HTTP协议，那么就只剩一条路可以走了，那就是基于已有的协议做一些改造和支持，UDP就是一个绝佳的选择了。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;因为HTTP/2底层是采用TCP协议实现的，虽然解决了HTTP队头阻塞的问题，但是对于TCP队头阻塞的问题却无能为力。&lt;/p&gt;
&lt;p&gt;TCP传输过程中会把数据拆分为一个个&lt;strong&gt;按照顺序&lt;/strong&gt;排列的数据包，这些数据包通过网络传输到了接收端，接收端再&lt;strong&gt;按照顺序&lt;/strong&gt;将这些数据包组合成原始数据，这样就完成了数据传输。&lt;/p&gt;
&lt;p&gt;但是如果其中的某一个数据包没有按照顺序到达，接收端会一直保持连接等待数据包返回，这时候就会阻塞后续请求。这就发生了&lt;strong&gt;TCP队头阻塞&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;另外，TCP这种可靠传输是靠三次握手实现的，TCP三次握手的过程客户端和服务器之间需要交互三次，那么也就是说需要消耗1.5 RTT。如果是HTTPS那么消耗的RTT就更多。&lt;/p&gt;
&lt;p&gt;而因为很多中间设备比较陈旧，更新换代成本巨大，这就导致TCP协议升级或者采用新的协议基本无法实现。&lt;/p&gt;
&lt;p&gt;所以，HTTP/3选择了一种新的技术方案，那就是基于UDP做改造，这种技术叫做QUIC。&lt;/p&gt;
&lt;p&gt;那么问题来了，HTTP/3是如何使用的UDP呢？做了哪些改造？如何保证连接的可靠性？UDP协议就没有僵化的问题了吗？&lt;/p&gt;
&lt;p&gt;这些问题我们在下一篇中深入分析。敬请期待！&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;https://http3-explained.haxx.se/&lt;/p&gt;
&lt;p&gt;https://baike.baidu.com/item/中间设备/3688874&lt;/p&gt;
&lt;p&gt;https://time.geekbang.org/column/article/150159&lt;/p&gt;
&lt;p&gt;https://juejin.cn/post/6844903853985366023&lt;/p&gt;
&lt;p&gt;https://time.geekbang.org/column/article/279164&lt;/p&gt;
&lt;center&gt;&lt;b&gt;(全文完)&lt;/b&gt;&lt;/center&gt;&lt;hr/&gt;&lt;center&gt;&lt;b&gt;扫描二维码，关注作者微信公众号&lt;/b&gt;&lt;/center&gt;&lt;img src=&quot;http://www.hollischuang.com/wp-content/uploads/2019/04/二维码.png&quot;/&gt;
&lt;/article&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fd4c6cb195815ccd897df8ddadd88377</guid>
<title>美团 Commit Log 规范</title>
<link>https://toutiao.io/k/r6tsfdv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;markdown-body mt-4&quot;&gt;
        &lt;h2 id=&quot;一背景&quot;&gt;&lt;strong&gt;一、背景&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Git每次提交代码都需要写commit message，一般来说，commit message应该清晰明了，说明本次提交的目的，具体做了什么操作等。但是在日常开发中，开发者提交的的commit message千奇百怪，中英文混合使用，这就导致后续代码维护成本特别大，有时自己都不知道自己的fix bug修改的是什么问题。基于以上这些问题，我们希望通过某种方式来监控用户的git commit message，让规范更好的服务于质量，提高大家的研发效率。&lt;/p&gt;
&lt;h2 id=&quot;二约定&quot;&gt;二、约定&lt;/h2&gt;
&lt;p&gt;所有项目的Commit Log的格式精确控制，增加可读性，便于查看变更历史，形成良好的git使用习惯。&lt;strong&gt;规范作为git hook的commit-msg和pre-receive执行，不合法无法提交&lt;/strong&gt;。全面执行后可自动化执行以下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;平台工具包可根据commit log直接生成每次版本的changelog。&lt;/li&gt;
&lt;li&gt;上线申请系统自动附带本次上线的commit log。&lt;/li&gt;
&lt;li&gt;要求每次提交认真思考，保持commit log的整洁性，每次commit的局部完整性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;三commit-log-format&quot;&gt;三、Commit Log Format&lt;/h2&gt;
&lt;p&gt;Commit Log包含三部分header、body、footer，其中header是必须的，格式固定，body在变更有必要详细解释时使用。&lt;/p&gt;
&lt;p&gt;commit log 格式&lt;/p&gt;
&lt;p&gt;Plain Text&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;types&amp;gt;(&amp;lt;scopes&amp;gt;): &amp;lt;subject&amp;gt;
&amp;lt;空行&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;空行&amp;gt;
&amp;lt;footer&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：冒号后面必须有一个小写空格，types和scopes可为多个，中间用逗号分隔。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举例&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h5 id=&quot;仅header&quot;&gt;仅header：&lt;/h5&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;fix(service,dao): 修改产品类型时不过滤产品Type

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;
&lt;h5 id=&quot;仅header涉及模块较多用代替&quot;&gt;仅header，涉及模块较多用*代替&lt;/h5&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;refactor(*): 修改DTO模型前缀

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;
&lt;h5 id=&quot;有header和body&quot;&gt;有header和body&lt;/h5&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;fix(language-service): Improve signature selection for pipes with args

Pipes with arguments like `slice:0` or `slice:0:1` should not produce
diagnostic errors.

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;
&lt;h5 id=&quot;有headerbodyfooter&quot;&gt;有header、body、footer&lt;/h5&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;func(core,logic): 添加礼包审核

添加商品编辑审核状态和回调，blablablabla

PRD：https://km.sankuai.com/page/194127085

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;1type&quot;&gt;1、Type&lt;/h3&gt;
&lt;p&gt;英文，小写。必须为下列中一个或多个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;func&lt;/strong&gt;: function，小功能。&lt;strong&gt;注意&lt;/strong&gt;：feat改成func了，避免大家按feature这个大粒度来提交，期望是按小功能点分批提交，另外避免跟feature分支规范混淆。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fix&lt;/strong&gt;: bug修复，包括编码过程中的逻辑修复，不特指线上bug修复&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;refactor&lt;/strong&gt;: 重构代码，非bug修复和性能优化，包括编码过程中的代码结构调整，不特指重构项目&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;impr&lt;/strong&gt;: improvement，小的代码设计改进&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;perf&lt;/strong&gt;: 性能优化&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;apm&lt;/strong&gt;: 仅监控打点、异常日志处理相关&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;chore&lt;/strong&gt;: 无关紧要的改动，例如删除用不到的注解、调整日志内容等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;jvm&lt;/strong&gt;: 仅JVM参数变更&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pom&lt;/strong&gt;: 仅依赖和版本变化&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;conf&lt;/strong&gt;: 仅配置变化，Spring配置、properties文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;docs&lt;/strong&gt;: 仅文档变更&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;style&lt;/strong&gt;: 代码格式调整，如import清理，代码格式化&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;test&lt;/strong&gt;: 单测和自动化case相关&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;typo&lt;/strong&gt;: 修复小的拼写错误&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;wip&lt;/strong&gt;: work in progress，少用，用于开发中的不完整提交，新工程开始时偶尔使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2scope&quot;&gt;2、Scope&lt;/h3&gt;
&lt;p&gt;英文，小写。表示变更的包或模块范围，可多个组合，若涉及范围较大，可用 * 代替。各服务可以自行定义，组内同学可轻易理解。通用scope列表如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;dto&lt;/strong&gt;: dto结构变化&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;core&lt;/strong&gt;: core包&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;service&lt;/strong&gt;: service层代码&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dao&lt;/strong&gt;: dao层代码&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sql&lt;/strong&gt;: sql代码变更&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除上述通用字段外，Scope中各方向可自行定义关键字。例如以下为商品平台中所定义字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;price&lt;/strong&gt;: 价格相关&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;stock&lt;/strong&gt;: 库存相关&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;product&lt;/strong&gt;: 商品相关&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;idl&lt;/strong&gt;: IDL文件变化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;3subject&quot;&gt;3、Subject&lt;/h3&gt;
&lt;p&gt;中文。标题简述修改，结尾不要有句号。&lt;/p&gt;
&lt;h3 id=&quot;4body&quot;&gt;4、Body&lt;/h3&gt;
&lt;p&gt;中文。修改的背景（为什么做这次修改），说明修改逻辑。&lt;/p&gt;

&lt;p&gt;中文。可以放置需求wiki或task链接，对以后其他同学blame很有用。&lt;/p&gt;
&lt;h2 id=&quot;四规范校验&quot;&gt;四、规范校验&lt;/h2&gt;
&lt;h4 id=&quot;1commit-log正则表达式持续集成工具会用到&quot;&gt;1、commit log正则表达式（持续集成工具会用到）：&lt;/h4&gt;
&lt;p&gt;Java代码块&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(^(\w+)\(([\w+,.\-_*]+?)\): .+(.|\n)*)|(^Automatic merge(.|\n)*)|(^Merge (.|\n)*)

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;2本地卡控&quot;&gt;2、本地卡控&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;本地hook：可自行加一个git hook，确保不合法commit log格式无法提交，在自己的工程里执行：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python

import sys, os, re
from subprocess import check_output

commit_msg_filepath = sys.argv[1]
commit_type = sys.argv[2] if len(sys.argv) &amp;gt; 2 else &#x27;&#x27;
branch = check_output([&#x27;git&#x27;, &#x27;symbolic-ref&#x27;, &#x27;--short&#x27;, &#x27;HEAD&#x27;]).strip()

print &quot;commit_type:&quot;, commit_type

with open(commit_msg_filepath, &#x27;r+&#x27;) as f:
    content = f.read()

    # ignore merge
    if content.startswith(&#x27;Merge&#x27;):
        sys.exit(0)

    result = re.match(&#x27;(\w+)\(([\w+,.\-_*]+?)\): .+(.|\n)*)&#x27;, content)
    if result is None:
        print &quot;ERROR: commit msg not match pattern &#x27;&amp;lt;type&amp;gt;(&amp;lt;scope&amp;gt;): &amp;lt;subject&amp;gt;&#x27;\n\t%s&quot; % content
        sys.exit(1)

    sys.exit(0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在git仓库一级目录下执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mv commit-msg.txt .git/hooks/commit-msg
chmod +x .git/hooks/commit-msg
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;五声明&quot;&gt;五、声明&lt;/h2&gt;
&lt;p&gt;本博客内容均为原创，授权公共号：&lt;strong&gt;肉眼品世界&lt;/strong&gt; 首发&lt;br/&gt;
原文链接：&lt;a href=&quot;https://lesofn.com/archives/mei-tuan-c-o-m-m-i-t--l-o-g-gui-fan&quot;&gt;https://lesofn.com/archives/mei-tuan-c-o-m-m-i-t--l-o-g-gui-fan&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作者简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;美团Java高级工程师，关注软件架构及职业成长，不定期分享各种技术、资源，对文章中涉及的技术感兴趣或有任何问题请关注微信交流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公共号：Java研发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/二维码小_1607785087313.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

    &lt;/article&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5b983da08b4aae513800113ea63f2fb8</guid>
<title>京东实时数据仓库开发实践</title>
<link>https://toutiao.io/k/esii5qo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;107&quot; data-backw=&quot;579&quot; data-ratio=&quot;0.18518518518518517&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPjTuPYwSYmjVJxtZDZEFrXJSAiaPqb8u3WgHqFxITvhsfqtJibbPEbLiccJdk3aymNMRzeo6Uwb9oyyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;324&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5610294117647059&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPho2nq0IicvpbVm8iawFp8lShWgVCqbazicthnVNzgynwdHAz3AZVgNI2r6meMuJicGpicfxKpke0yxtUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1360&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;font-variant-numeric: normal; font-variant-east-asian: normal; white-space: normal; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; line-height: 27.2px; widows: 1; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-bottom: -10px; margin-left: -8px; max-width: 100%; width: 18px; height: 18px; border-top: 8px solid rgb(54, 65, 173); border-left: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;br data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;/&gt;&lt;/section&gt;&lt;section data-bgopacity=&quot;50%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot; data-style=&quot;max-width: 100%; width: 543.333px; background: rgb(247, 247, 247); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot; data-darkmode-color-16008590572276=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16008590572276=&quot;rgb(0, 128, 255)&quot;&gt;分享嘉宾：王日宇 京东 大数据架构师&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;编辑整理：刘明&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;出品平台：DataFunTalk&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;max-width: 100%; width: 18px; height: 18px; border-bottom: 8px solid rgb(54, 65, 173); border-right: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;导读：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;本文主要介绍京东实时数据仓&lt;/span&gt;&lt;span&gt;库技术的过去和未来，使用Delta Lake完成离线数据的增量更新，建设批流一体开发分析体系简化传统数据仓库架构，以及京东的业务场景在数据湖上的落地经验和技术挑战。&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;01&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16008590572276=&quot;rgb(136, 151, 171)&quot; data-darkmode-original-color-16008590572276=&quot;rgb(63, 74, 89)&quot; data-style=&quot;color: rgb(63, 74, 89); font-family: 微软雅黑; font-size: 11pt; letter-spacing: 0.4pt; text-align: left; text-indent: 0pt; visibility: visible;&quot;&gt;&lt;strong&gt;&lt;span&gt;传统数据仓库面临的挑战&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 传统数据仓库的架构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;323&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5596465390279823&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPho2nq0IicvpbVm8iawFp8lShhXWRaNtfsLP8icqQsZVHUnDRQrI5PQgLMlzOMqYakZ6VvMoj5MnjdSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1358&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;首先介绍一下我们传统数据仓库的架构，目前主流的离线数据仓库是基于分布式存储分层的Lambda架构。&lt;/span&gt;&lt;span&gt;如上图所示，由上下两条链路构成，上面链路代表离线层的处理，下面链路代表实时层的处理。&lt;/span&gt;&lt;span&gt;这个链路既是现在设计架构上的链路，也是业务数据流转的链路，同样也是我&lt;/span&gt;&lt;span&gt;们日常开发维护的链路。&lt;/span&gt;&lt;span&gt;这套体系架构奠定了我们大数据分析的基础，也取得了很多收益。&lt;/span&gt;&lt;span&gt;但&lt;/span&gt;&lt;span&gt;随着技术的发展和业务上对实时性的要求越来越强，尤其近几年实时计算发展的特别快，现有的这套架构逐渐暴露出一些弊端。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于Lambda架构建设的实时数仓&lt;/span&gt;&lt;span&gt;，第一条是针对于实时性要求高的业务系统 ( 通常是秒级 ) 的数据流转链路，另一条就是传统意义上的离线计算 ( 通常是天级 ) 的数据流转链路，甚至有些业务系统还会有准实时计算的数据链路 ( 例如小时级延迟 )。&lt;/span&gt;&lt;span&gt;不同业务系统，根据不同的时效性去选择和设计数据处理加工方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 在传统数据仓库实践中遇到的问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;① ACID语义性无法保证&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;简单来说就是无法做到一边写入一边读取，我们目前更多依赖读写任务在调度时间上的错配来解决读写冲突，保证数据一致性。&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;② 离线入库潜在的不可靠性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;离线数据加工任务一般是T+1的，今天的生产数据，需要第二天凌晨抽取到大数据机房，然后进行后面的业务计算。有些业务系统的数据可能分布在全国各地数千个MySQL数据库中，假如其中某几个数据库出现问题，那么离线数据就会造成缺失，从而影响后面的数据分析计算的准确性。&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;③ 细粒度的数据更新功能缺失&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Hive中不支持update、delete这种细粒度操作，即使只更新Hive表中的某几条数据，都需要重写整个表，或至少重写整个分区，而一个分区就是一天的数据，整个操作就需要先读取一天的数据，然后计算后再写回去。这样的话，他所需的执行时间，读写数据量，资源消耗都是比较大的。&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;④ 数据流转路径复杂&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多情况下，处理离线数据和实时处理的数据逻辑都是一样的，只不过需要面向不同的场景。比如说离线要使用数据做更复杂的分析，实时需要做一些秒级或毫秒级的查询。这样的话，当业务逻辑有变化时，实时需要更新一次，离线还需要更新第二次，两条链路对应两份数据，很多时候，实时链路的处理结果和离线链路的处理结果甚至对不上。&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面就是针对目前数仓所涉及到的四个挑战的大致介绍，因此我们也是通过对数据湖的调研和实践，希望能在这四个方面对数仓建设有所帮助。接下来重点讲解下对数据湖的一些思考。&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;02&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16008590572276=&quot;rgb(136, 151, 171)&quot; data-darkmode-original-color-16008590572276=&quot;rgb(63, 74, 89)&quot; data-style=&quot;color: rgb(63, 74, 89); font-family: 微软雅黑; font-size: 11pt; letter-spacing: 0.4pt; text-align: left; text-indent: 0pt; visibility: visible;&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;实时数据湖的探索和经验&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 数据湖开源产品调研&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据湖大致是从19年慢慢火起来的，目前社区主流的开源产品主要有三种：Delta、Hudi和Iceberg。它们在功能实现上各有优劣，接下来简单对比一下。&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;324&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5612094395280236&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPho2nq0IicvpbVm8iawFp8lShuVH6npiaFMicicudYPZclMwod8hedQ2BLokWm3mu7GPBC08ZDdqzjRdMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1356&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上表是一个简单的社区热度统计：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Delta Lake：在17年的时候DataBricks就做了&lt;span&gt;D&lt;/span&gt;&lt;span&gt;elta&lt;/span&gt;&lt;span&gt; Lake&lt;/span&gt;的商业版，主要想解决的也是Lambda架构带来的数据存储和控制问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Hudi：支持快速的更新以及增量的拉取操作，包含copy on write 和 merge on read 两种表格式。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Iceberg：的初衷是想做一个标准的Table Format，代码抽象程度比较高，社区也正在进行Flink的读写支持。&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 选择Delta lake的原因&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面这个表格例举了部分功能点的对比，这些都是我们在做技术选型时比较关心的几个点。比如说ACID特性，历史回溯，多版本并发控制等。&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;324&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5605612998522895&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPho2nq0IicvpbVm8iawFp8lShMiay3UCy5wZibTwgmF9ZUl5R2iciceE19Ry34KYaw7OySZKjsDicsFRFyqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1354&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当时我们团队也在技术方案选型上讨论了很久，使用不同的应用场景做了不同方面的测试，最终选择了Delta。首先是因为功能完整性上比较符合我们的要求；其次我们本身将数据湖定位成基于离线计算的数据存储更新服务，再加上我们团队本身就承担着spark的基础研发工作，比如常见的sql查询优化，shuffle优化等等，对spark的了解会比较深入一些，所以我们最终选择Delta作为数据湖的基础，同时开发过程中吸取Hudi和Iceberg的各自特点。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;03&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16008590572276=&quot;rgb(136, 151, 171)&quot; data-darkmode-original-color-16008590572276=&quot;rgb(63, 74, 89)&quot; data-style=&quot;color: rgb(63, 74, 89); font-family: 微软雅黑; font-size: 11pt; letter-spacing: 0.4pt; text-align: left; text-indent: 0pt; visibility: visible;&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Delta Lake核心原理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. Delta Lake简介&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;引用来自官网对于Delta lake的一段介绍&quot;Delta是一个开源的带有ACID语义的存储控制层，其中Delta的数据表主要是由数据文件和事务日志两部分组成。&quot;&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;324&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.561119293078056&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPho2nq0IicvpbVm8iawFp8lShME2kxsLl8JQMpbed21D9sIBFIMhzhPBAtl5rvIYxqPEweWUFFJImzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1358&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如图所示，可以看到这是Delta表物理上的文件结构的组成，比如说我们有一个my_table表，与常规的离线Hive表不同的是，它下面会有一个_delta_log目录，这个_delta_log我们叫做Transaction log，也就是事务日志，然后就是常规的数据文件，数据文件的格式是parquet，日志文件的格式是普通的json格式。&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Transaction log是整个Delta核心，也是所有Delta功能实现的基础，所有对Delta的操作，无论是增删改还是修改表结构，都会被记录到Transaction log中。所以我们接下来重点介绍一下Transaction log是什么。&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 事务日志解析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;324&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5610294117647059&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPho2nq0IicvpbVm8iawFp8lShyG38D0zJiatVQURicybcq8eot9P3msgjYibRSKrHBorloicpWSpt1O12RQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1360&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Transaction log主要涉及到三方面的信息：&lt;/span&gt;&lt;span&gt;when，who，how&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一次事务就是一次commit，日志中会记录commit的基本信息，简单来说就是是谁在什么时候怎么做的commit，以截图中的日志为例，会有一个时间戳1600071805932来记录什么时候的commit，是STREAMING UPDATE做的commit的，commit内容是新增了8个数据文件。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;把涉及到的具体文件路径和统计信息写到log中，比如说他的文件名是什么，每个文件的大小是多少，是什么时间修改的，它都会记录。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;表的Metadata信息，字段名、字段类型、文件格式、配置属性等。这些与普通Hive表存在metastore里的内容是完全一样的。&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. Delta数据表读取流程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以一次添加数据的操作为例，简单介绍一下log的具体内容，以及Delta数据表的读取流程。&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5616236162361624&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPho2nq0IicvpbVm8iawFp8lSh7xl8PEhDnrKzghwNM3bwYEacR85Sf8k4YvSsj5mLxYAEMia9KUtQtYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1355&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Delta每次更新都会形成一个log，一系列的更新操作也就形成了多个log。log的命名是严格按照版本号递增的顺序命名的。Delta内部为了提高读取性能，每10个log会生成一个checkpoint文件，每次checkpoint都会把最新的checkpoint文件路径记录到_last_checkpoint文件中，这样随着时间的迁移整个表的变更操作都会被记录下来。&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Checkpoint简单来说是前面所有json log的总和，但并不是简单的堆在一起，他包括消除一些冗余信息的合并操作。比如说在3版本中新增了两个文件A和B，在10版本中删除了文件A，那么这个表就只剩下文件B了，此时checkpoint只会记录文件B，再加上本身checkpoint使用parquet列式格式保存，spark读取性能会提高很多。&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以图中左边的例子为例，总结一下Delta数据表具体读取流程：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;① 先使用_last_checkpoint找到最近的checkpoint文件，也就是图中的000010.checkpoint.parquet。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;② 再找到checkpoint文件之后的json log文件，就是图中的11版本和12版本的json。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;③ 最后合并所有json log和checkpoint log的记录，得到数据表在该版本状态下包含哪些具体的数据文件。&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4. Delta Lake特点&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有了Transaction log后，很容易实现下面一些特点：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持批流读写&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;提供ACID语义&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Update/delete的支持&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;历史版本回溯和审计&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;抽象存储接口&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;查询性能提升&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;04&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16008590572276=&quot;rgb(136, 151, 171)&quot; data-darkmode-original-color-16008590572276=&quot;rgb(63, 74, 89)&quot; data-style=&quot;color: rgb(63, 74, 89); font-family: 微软雅黑; font-size: 11pt; letter-spacing: 0.4pt; text-align: left; text-indent: 0pt; visibility: visible;&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;批流一体开发流程&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;使用Delta实时数据湖后我们的开发流程可以简化如下：&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;324&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5601476014760147&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPho2nq0IicvpbVm8iawFp8lShN7hz0HyMgia4sPz1L0ALK6eABsdjY2DgAAbnjbeqhFFjicOZIxr4LNVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1355&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如图所示，与上面的Lambda架构相比，只有一条数据流转链路。首先将业务数据库的binlog日志实时的写入kafka，然后通过SparkStreaming实时消费kafka中的数据，解析binglog日志后落入Delta数据湖中，因为整体的落数过程是实时的，所以下游既可以实时流处理也可以离线批处理。这样可以降低开发成本和存储成本，而且如果遇到脏数据的写入，整个回滚和Debug过程也会很方便。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;05&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16008590572276=&quot;rgb(136, 151, 171)&quot; data-darkmode-original-color-16008590572276=&quot;rgb(63, 74, 89)&quot; data-style=&quot;color: rgb(63, 74, 89); font-family: 微软雅黑; font-size: 11pt; letter-spacing: 0.4pt; text-align: left; text-indent: 0pt; visibility: visible;&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;最后做一下简单的总结：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Delta本身刚开源不久，内部有很多优秀特性没有开源出来，如直接使用SQL进行版本回溯，DFP动态文件裁剪，还有Z-Ordering，使用一些策略来优化数据存储分布，提高下游数据的查询效率等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;小文件和历史文件的清理问题。Delta每次写入数据时都要写一批小文件，HDFS对小文件是非常敏感的，如果小文件过多，namenode的压力会特别大。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Hive Connector的支持。社区的Hive Connector绑定的Spark Delta版本都是紧耦合的，有一些API的接口都不一样，需要自定义改造Hive Connector，支持生产环境上的版本。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;计算引擎和使用方式的支持。这一点主要是突出在Hive和Presto的使用上，无论是Hive还是Presto，如果想读一个Delta表的话，必须新建一个名字不一样的外部表，location指向Delta表的位置，这样对用户侧来说，读同样的数据，存在多个不同的表名，用起来会不太方便。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16008590572276=&quot;rgb(136, 151, 171)&quot; data-darkmode-original-color-16008590572276=&quot;rgb(63, 74, 89)&quot; data-style=&quot;color: rgb(63, 74, 89); font-family: 微软雅黑; font-size: 11pt; letter-spacing: 0.4pt; text-align: left; text-indent: 0pt; visibility: visible;&quot;&gt;今天的分享就到这里，谢谢大家。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;在文末分享、点赞、在看，给个3连击呗~&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;嘉宾介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;274&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;274&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;500&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vrk53t8TibicrOhUKmZqaRcO3v2ib1EJI9wgshNxUqVtv6oxss50Uu6c82DyibfBGia6ibyDI6nW1UicniaVK96oC3eu7w/640?wx_fmt=png&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;王日宇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;京东 | 大数据架构师&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;2018年加入京东大数据离线计算引擎开发团队，聚焦京东实时数据湖方案设计和应用场景落地，对SPARK内核和SQL执行优化方面拥有丰富的研发经验，对大规模分布式计算体系有深入的了解。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;社群推荐：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;欢迎加入 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;DataFunTalk 大数据 &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;交流群，跟同行零距离交流。&lt;strong&gt;识别二维码&lt;/strong&gt;，添加小助手微信，&lt;strong&gt;入群。&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;3&quot; data-cropselx2=&quot;223&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;227&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zHbzQPKIBPjWF4KeBlBY77bxkY6RkGYibHjAzoDzvpicWmiamn1unXwekUjw5gfc21jwoGBMEPxsUy3SW0RKicjZYA/640?wx_fmt=jpeg&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关于我们：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;DataFunTalk &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;专注于大数据、人工智能技术应用的分享与交流。发起于2017年，在北京、上海、深圳、杭州等城市举办超过100场线下沙龙、论坛及峰会，已邀请近600位专家和学者参与分享。其公众号 DataFunTalk 累计生产原创文章300+，百万+阅读，9万+精准粉丝。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;161&quot; data-backw=&quot;579&quot; data-ratio=&quot;0.27734375&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zHbzQPKIBPjDjicR2yOx02wNZLtRyVjaalkxbGB7NU2Paq7KM3MPhXtxKJy9M6Bs8EicpUtqCUe6fgfV4HSiaHs7Q/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;🧐&lt;strong&gt;分享、点赞、在看&lt;/strong&gt;，给个&lt;strong&gt;3连击&lt;/strong&gt;呗！&lt;strong&gt;👇&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b739c028657d51d2f627c49bd413ee64</guid>
<title>数据分析：复杂业务场景下，量化评估流程</title>
<link>https://toutiao.io/k/9fplpyf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1&gt;&lt;span&gt;一、量化思维&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;在编程体系中有很多复杂的业务是很难理解的，但是又需要做一个量化分析，给业务人员或者运营，或者用户一个参考标准，例如常见指数，芝麻分数，店铺等级，这类业务评定标准非常复杂，因为影响结果的因素很多。&lt;/p&gt;&lt;p&gt;在多个维度的业务考量模型中，有一个核心概念叫做权重，指某一因素或指标相对于某一事物的重要程度，其不同于一般的比重，体现的不仅仅是某一因素或指标所占的百分比，强调的是因素或指标的相对重要程度，倾向于贡献度或重要性。通常情况下每个维度的权重在0-1之间，所有维度的权重之和为1。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4588045234248788&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvD9zzPoQbeGo54SZMBwiaCmWOva1zRF2ysyFHwcJWth2ErJ0ZgvsTKqsNqKTHnGEVqsbPrgE7ZBxfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1238&quot;/&gt;&lt;/p&gt;&lt;p&gt;可以从一个实际案例来分析权重的概念，比如判断一个客户是否是重点运营的对象，通常会从每周登录次数，在线时长，交易量等维度考虑，如果客户A经常登录，但是没有核心业务交易，客户B很少登录，但是业务交易高，所以这里登录次数的权重就应该低于交易量这个维度。&lt;/p&gt;&lt;p&gt;如何确定权重占比，通常有两个思路，一借鉴专业业务人员的提供的经验，放到业务中不断尝试调优；二根据产品的分析数据，计算各个维度权重，也是需要在业务中不断尝试优化。&lt;/p&gt;&lt;p&gt;实际上复杂业务场景的量化过程是复杂且漫长的，需要对多个维度的数据做收集，有时候不但需要做周期性量化，例如几家大厂的信用分，也可能存在实时分析的场景，金融业务中的欺诈风控等，也有两种场景综合的实时推荐体系，都会用到量化流程。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、场景案例&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5156794425087108&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvD9zzPoQbeGo54SZMBwiaCmWZE7jbhu0899wX6kWxKzDk58JEWBfpicFTC6QHpMIu9dicbnuMicAY4DYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1148&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;1、综合评估&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;对用户、店铺、产品等多种场景做综合评估，把一个复杂的事物通过多个维度抽象分析，生成简单容易理解的评估结果，例如店铺等级、产品评分、用户综合指数等，进而对各个使用场景产生参考的依据。从结果来看可能是很容易理解，但是获取结果的分析过程是相对复杂的，有的场景可能需要周期性执行评估模型，有的场景可能需要实时计算，还有可能是两种情况结合即依赖周期评估，也需要参考实时计算。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、场景推荐&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;这个场景相对复杂度较高，例如用户进行搜索，但是又勾选一系列排除或者必要条件，这在搜索类的功能中很常见，在处理时不但要对用户的搜索条件做最高的匹配度分析，还要基于搜索结果做最优排序，这种就存在两个阶段评估，第一个阶段匹配最优搜索条件，第二阶段对匹配结果做最优选排序，最大可能的给出用户想要的搜索结果。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、风控评分&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;在金融领域内，这是很常见的一种风控模型，即对用户多个维度统计，做维度评分然后累加到一起，风控分越高，说明该用户风险越大，进而阻止高风险交易。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;4、理财指数&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;这个场景很常见，在金融理财类的APP中，使用之前必须经过一个测评体系，来判断用户的风险承受能力：例如保守型、积极型等，当用户购买的产品属于高风险时，会提示和用户的风险承受能力不匹配，提示用户重新测评。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、实现思路&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、维度规则表&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;维护一份维度的评估规则表，classify_sign理解为同一业务场景下的划分标识，weight则标识该维度在评估中的比重。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;CREATE TABLE `evaluate_rule` (&lt;br/&gt;  `id` &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) NOT NULL AUTO_INCREMENT COMMENT &lt;span&gt;&#x27;主键ID&#x27;&lt;/span&gt;,&lt;br/&gt;  `classify_sign` varchar(&lt;span&gt;50&lt;/span&gt;) COLLATE utf8mb4_unicode_ci DEFAULT &lt;span&gt;&#x27;&#x27;&lt;/span&gt; COMMENT &lt;span&gt;&#x27;归类标识&#x27;&lt;/span&gt;,&lt;br/&gt;  `rule_value` varchar(&lt;span&gt;300&lt;/span&gt;) COLLATE utf8mb4_unicode_ci DEFAULT &lt;span&gt;&#x27;&#x27;&lt;/span&gt; COMMENT &lt;span&gt;&#x27;规则描述&#x27;&lt;/span&gt;,&lt;br/&gt;  `rule_type` &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) DEFAULT NULL COMMENT &lt;span&gt;&#x27;规则类型：1精准匹配，2范围，3模糊&#x27;&lt;/span&gt;,&lt;br/&gt;  `weight` decimal(&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;) DEFAULT &lt;span&gt;&#x27;0.00&#x27;&lt;/span&gt; COMMENT &lt;span&gt;&#x27;权重分布&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;PRIMARY &lt;span&gt;KEY&lt;/span&gt; &lt;span&gt;(`id`)&lt;/span&gt;&lt;br/&gt;) ENGINE&lt;/span&gt;=InnoDB AUTO_INCREMENT=&lt;span&gt;3&lt;/span&gt; DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT=&lt;span&gt;&#x27;评估项规则&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;2、描述规则&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;对于规则的具体描述，核心就是两个字段，规则值以及匹配到该规则获取的结果。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RuleValue&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 规则值描述&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Object ruleValue ;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 规则匹配结果&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Object ruleResult ;&lt;br/&gt;    &lt;span&gt;// 基础构造&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;RuleValue&lt;/span&gt;&lt;span&gt;(Object ruleValue, Object ruleResult)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.ruleValue = ruleValue;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.ruleResult = ruleResult;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 省略 Get 和 Set&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;3、封装匹配值&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;为了简化参数在模型中传递的复杂度，统一封装匹配因素的数据在一个数据模型中，这里以城市和标签两个因素做流程测试。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MatchItem&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 城市&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String city ;&lt;br/&gt;    &lt;span&gt;// 标签&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String tag ;&lt;br/&gt;    &lt;span&gt;// 基础构造&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;MatchItem&lt;/span&gt;&lt;span&gt;(String city, String tag)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.city = city;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.tag = tag;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 省略 Get 和 Set&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;4、评估逻辑实现&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;这里只是对两种情况做简单的实现描述，在实际的开发场景中，数据和匹配规格都是十分复杂的，在整个评估模型实现&lt;/span&gt;流程&lt;span&gt;需要不断优化。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AssessBizService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger LOG = LoggerFactory.getLogger(AssessBizService.class);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; EvaluateRuleDao evaluateRuleDao ;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 业务评估流程&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;assessBiz&lt;/span&gt; &lt;span&gt;(MatchItem matchItem)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 精准匹配城市&lt;/span&gt;&lt;br/&gt;        EvaluateRuleEntity evaluateRule01 = evaluateRuleDao.getBySign(&lt;span&gt;&quot;assess-biz&quot;&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        List&amp;lt;RuleValue&amp;gt; cityRuleList = JSONArray.parseArray(evaluateRule01.getRuleValue(), RuleValue.class);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (RuleValue cityRule:cityRuleList){&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (cityRule.getRuleValue().equals(matchItem.getCity())){&lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; result = Integer.parseInt(String.valueOf(cityRule.getRuleResult()));&lt;br/&gt;                LOG.info(&lt;span&gt;&quot;匹配项:{},匹配结果:{}&quot;&lt;/span&gt;,matchItem.getCity(),result*evaluateRule01.getWeight());&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt; ;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 模糊匹配标签&lt;/span&gt;&lt;br/&gt;        EvaluateRuleEntity evaluateRule02 = evaluateRuleDao.getBySign(&lt;span&gt;&quot;assess-biz&quot;&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;        List&amp;lt;RuleValue&amp;gt; tagRuleList = JSONArray.parseArray(evaluateRule02.getRuleValue(), RuleValue.class);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (RuleValue tagRule:tagRuleList){&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (String.valueOf(tagRule.getRuleValue()).contains(matchItem.getTag())){&lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; result = Integer.parseInt(String.valueOf(tagRule.getRuleResult()));&lt;br/&gt;                LOG.info(&lt;span&gt;&quot;匹配项:{},匹配结果:{}&quot;&lt;/span&gt;,matchItem.getTag(),result*evaluateRule02.getWeight());&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt; ;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;&lt;span&gt;四、源代码地址&lt;/span&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;GitHub·地址&lt;br/&gt;https:&lt;span&gt;//github.com/cicadasmile/data-manage-parent&lt;/span&gt;&lt;br/&gt;GitEE·地址&lt;br/&gt;https:&lt;span&gt;//gitee.com/cicadasmile/data-manage-parent&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3783359497645212&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCjMheLZtcM2iaVMBOpIUKR4CDRCG9FLT5K6NmGXvG7exrW0TSuDjnTKJQ5PDq8j8Y7PHDd17Z3gicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot;/&gt;&lt;span/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d6daf3df4558beaceaf8b623f36e111e</guid>
<title>并发编程：信号量的使用方法和其实现原理</title>
<link>https://toutiao.io/k/59jykba</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是信号量&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;信号量是并发编程中常见的一种同步机制，在需要控制访问资源的线程数量时就会用到信号量，关于什么是信号量这个问题，我引用一下维基百科对信号量的解释，大家就明白了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;信号量的概念是计算机科学家 &lt;strong&gt;Dijkstra&lt;/strong&gt; （Dijkstra算法的发明者）提出来的，广泛应用在不同的操作系统中。系统中，会给每一个进程一个信号量，代表每个进程当前的状态，未得到控制权的进程，会在特定的地方被迫停下来，等待可以继续进行的信号到来。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果信号量是一个任意的整数，通常被称为计数信号量（Counting semaphore），或一般信号量（general semaphore）；如果信号量只有二进制的0或1，称为二进制信号量（binary semaphore）。在linux系统中，二进制信号量（binary semaphore）又称互斥锁（Mutex）&lt;/p&gt;&lt;p&gt;&lt;span&gt;计数信号量具备两种操作动作，称为V（&lt;/span&gt;&lt;code&gt;signal()&lt;/code&gt;&lt;span&gt;）与P（&lt;/span&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;span&gt;）（即部分参考书常称的“PV操作”）。&lt;/span&gt;&lt;span&gt;V操作会增加信号&lt;/span&gt;量&lt;span&gt;S的数值，P操作会减少它。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;运行方式：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;初始化信号量，给与它一个非负数的整数值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;运行P（&lt;/span&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;span&gt;），信号&lt;/span&gt;量&lt;span&gt;S的值将被减少。&lt;/span&gt;&lt;span&gt;企图进入&lt;/span&gt;临界区&lt;span&gt;的进程，需要先运行P（&lt;/span&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;span&gt;）。&lt;/span&gt;&lt;span&gt;当信号&lt;/span&gt;量&lt;span&gt;S减为负值时，进程会被阻塞住，不能继续；&lt;/span&gt;&lt;span&gt;当信号&lt;/span&gt;量&lt;span&gt;S不为负值时，进程可以获准进入临界区。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;运行V（&lt;/span&gt;&lt;code&gt;signal()&lt;/code&gt;&lt;span&gt;），信号量S的值会被增加。&lt;/span&gt;&lt;span&gt;结束离开&lt;/span&gt;临界区&lt;span&gt;的进程，将会运行V（&lt;/span&gt;&lt;code&gt;signal()&lt;/code&gt;&lt;span&gt;）。&lt;/span&gt;&lt;span&gt;当信号&lt;/span&gt;量&lt;span&gt;S不为负值时，先前被阻塞住的其他进程，将可获准进入&lt;/span&gt;临界区&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们一般用信号量保护一组资源，比如数据库连接池、一组客户端的连接等等。&lt;strong&gt;每次获取资源时都会将信号量中的计数器减去对应的数值，在释放资源时重新加回来。当遇到信号量资源不够时尝试获取的线程就会进入休眠，等待其他线程释放归还信号量&lt;/strong&gt;。如果信号量是只有0和1的二进位信号量，那么，它的 P/V 就和互斥锁的 Lock/Unlock 一样了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go语言中的信号量表示&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Go&lt;/code&gt; 内部使用信号量来控制&lt;code&gt;goroutine&lt;/code&gt;的阻塞和唤醒，比如互斥锁&lt;code&gt;sync.Mutex&lt;/code&gt;结构体定义的第二个字段就是一个信号量。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Mutex &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    state &lt;span&gt;int32&lt;/span&gt;&lt;br/&gt;    sema  &lt;span&gt;uint32&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;信号量的PV操作在&lt;code&gt;Go&lt;/code&gt;内部是通过下面这几个底层函数实现的&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;runtime_Semacquire&lt;/span&gt;&lt;span&gt;(s *&lt;span&gt;uint32&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;runtime_SemacquireMutex&lt;/span&gt;&lt;span&gt;(s *&lt;span&gt;uint32&lt;/span&gt;, lifo &lt;span&gt;bool&lt;/span&gt;, skipframes &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;runtime_Semrelease&lt;/span&gt;&lt;span&gt;(s *&lt;span&gt;uint32&lt;/span&gt;, handoff &lt;span&gt;bool&lt;/span&gt;, skipframes &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面几个函数都是&lt;code&gt;Go&lt;/code&gt;语言内部使用的，我们不能在编程时直接使用。不过&lt;code&gt;Go&lt;/code&gt; 语言的扩展并发原语包中提供了带权重的信号量 &lt;code&gt;semaphore.Weighted&lt;/code&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;使用信号量前，需先在项目里安装&lt;code&gt;golang.org/x/sync/&lt;/code&gt;包&lt;/p&gt;&lt;p&gt;安装方法：&lt;strong&gt;go get -u golang.org/x/sync&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以按照不同的权重对资源的访问进行管理，这个结构体对外提供了四个方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;semaphore.NewWeighted&lt;/strong&gt; 用于创建新的信号量，通过参数(n int64) 指定信号量的初始值。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;semaphore.Weighted.Acquire&lt;/strong&gt; 阻塞地获取指定权重的资源，如果当前没有空闲资源，就会陷入休眠等待；相当于 P 操作，你可以一次获取多个资源，如果没有足够多的资源，调用者就会被阻塞。它的第一个参数是 Context，这就意味着，你可以通过 Context 增加超时或者 cancel 的机制。如果是正常获取了资源，就返回 &lt;code&gt;nil&lt;/code&gt;；否则，就返回&lt;code&gt;ctx.Err()&lt;/code&gt;，信号量不改变。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;semaphore.Weighted.Release&lt;/strong&gt; 用于释放指定权重的资源；相当于 V 操作，可以将 n 个资源释放，返还给信号量。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;semaphore.Weighted.TryAcquire&lt;/strong&gt; 非阻塞地获取指定权重的资源，如果当前没有空闲资源，就会直接返回 &lt;code&gt;false&lt;/code&gt;；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;在Go编程里使用信号量&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际应用&lt;code&gt;Go&lt;/code&gt;语言开发程序时，有哪些场景适合使用信号量呢？&lt;strong&gt;在需要控制访问资源的线程数量时就会需要信号量&lt;/strong&gt;，我来举个例子帮助你理解。假设我们有一组要抓取的页面，资源有限最多允许我们同时执行三个抓取任务，当同时有三个抓取任务在执行时，在执行完一个抓取任务后才能执行下一个排队等待的任务。当然这个问题用Channel也能解决，不过这次我们使用Go提供的信号量原语来解决这个问题，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&quot;context&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;sync&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;golang.org/x/sync/semaphore&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;doSomething&lt;/span&gt;&lt;span&gt;(u &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;span&gt;// 模拟抓取任务的执行&lt;/span&gt;&lt;br/&gt;    fmt.Println(u)&lt;br/&gt;    time.Sleep(&lt;span&gt;2&lt;/span&gt; * time.Second)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; (&lt;br/&gt;    Limit  = &lt;span&gt;3&lt;/span&gt; &lt;span&gt;// 同時并行运行的goroutine上限&lt;/span&gt;&lt;br/&gt;    Weight = &lt;span&gt;1&lt;/span&gt; &lt;span&gt;// 每个goroutine获取信号量资源的权重&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    urls := []&lt;span&gt;string&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;&quot;http://www.example.com&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;http://www.example.net&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;http://www.example.net/foo&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;http://www.example.net/bar&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;http://www.example.net/baz&quot;&lt;/span&gt;,&lt;br/&gt;    }&lt;br/&gt;    s := semaphore.NewWeighted(Limit)&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; w sync.WaitGroup&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; _, u := &lt;span&gt;range&lt;/span&gt; urls {&lt;br/&gt;        w.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(u &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;            s.Acquire(context.Background(), Weight)&lt;br/&gt;            doSomething(u)&lt;br/&gt;            s.Release(Weight)&lt;br/&gt;            w.Done()&lt;br/&gt;        }(u)&lt;br/&gt;    }&lt;br/&gt;    w.Wait()&lt;br/&gt;    &lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;All Done&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go语言信号量的实现原理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Go&lt;/code&gt;语言扩展库中的信号量是使用互斥锁和List 实现的。互斥锁实现其它字段的保护，而 List 实现了一个等待队列，等待者的通知是通过 &lt;code&gt;Channel&lt;/code&gt; 的通知机制实现的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;信号量的数据结构&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看一下信号量&lt;code&gt;semaphore.Weighted&lt;/code&gt;的数据结构：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Weighted &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    size    &lt;span&gt;int64&lt;/span&gt;         &lt;span&gt;// 最大资源数&lt;/span&gt;&lt;br/&gt;    cur     &lt;span&gt;int64&lt;/span&gt;         &lt;span&gt;// 当前已被使用的资源&lt;/span&gt;&lt;br/&gt;    mu      sync.Mutex    &lt;span&gt;// 互斥锁，对字段的保护&lt;/span&gt;&lt;br/&gt;    waiters list.List     &lt;span&gt;// 等待队列&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;size&lt;/code&gt;字段用来记录信号量拥有的最大资源数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;cur&lt;/code&gt;标识当前已被使用的资源数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;mu&lt;/code&gt;是一个互斥锁用来提供对其他字段的临界区保护。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;waiters&lt;/code&gt;表示申请资源时由于可使用资源不够而陷入阻塞等待的调用者列表。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Acquire请求信号量资源&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;方法会监控资源是否可用，而且还要检测传递进来的&lt;code&gt;context.Context&lt;/code&gt;对象是否发送了超时过期或者取消的信号，我们来看一下它的代码实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(s *Weighted)&lt;/span&gt; &lt;span&gt;Acquire&lt;/span&gt;&lt;span&gt;(ctx context.Context, n &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    s.mu.Lock()&lt;br/&gt;    &lt;span&gt;// 如果恰好有足够的资源，也没有排队等待获取资源的goroutine，&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 将cur加上n后直接返回&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; s.size-s.cur &amp;gt;= n &amp;amp;&amp;amp; s.waiters.Len() == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;      s.cur += n&lt;br/&gt;      s.mu.Unlock()&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;// 请求的资源数大于能提供的最大的资源数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 这个任务处理不了，走错误处理逻辑&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; n &amp;gt; s.size {&lt;br/&gt;      s.mu.Unlock()&lt;br/&gt;      &lt;span&gt;// 依赖ctx的状态返回，否则一直等待&lt;/span&gt;&lt;br/&gt;      &amp;lt;-ctx.Done()&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; ctx.Err()&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 现存资源不够, 需要把调用者加入到等待队列中&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 创建了一个ready chan,以便被通知唤醒&lt;/span&gt;&lt;br/&gt;    ready := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{})&lt;br/&gt;    w := waiter{n: n, ready: ready}&lt;br/&gt;    elem := s.waiters.PushBack(w)&lt;br/&gt;    s.mu.Unlock()&lt;br/&gt;  &lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 等待&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done(): &lt;span&gt;// context的Done被关闭&lt;/span&gt;&lt;br/&gt;      err := ctx.Err()&lt;br/&gt;      s.mu.Lock()&lt;br/&gt;      &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; &amp;lt;-ready: &lt;span&gt;// 如果被唤醒了，忽略ctx的状态&lt;/span&gt;&lt;br/&gt;        err = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;default&lt;/span&gt;: &lt;span&gt;// 通知waiter&lt;/span&gt;&lt;br/&gt;        isFront := s.waiters.Front() == elem&lt;br/&gt;        s.waiters.Remove(elem)&lt;br/&gt;        &lt;span&gt;// 通知其它的waiters,检查是否有足够的资源&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; isFront &amp;amp;&amp;amp; s.size &amp;gt; s.cur {&lt;br/&gt;          s.notifyWaiters()&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;      s.mu.Unlock()&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &amp;lt;-ready: &lt;span&gt;// 等待者被唤醒了&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果调用者请求不到信号量的资源就会被加入等待者列表里，这里等待者列表的结构体定义是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; waiter struct {&lt;br/&gt; n     int64&lt;br/&gt; ready chan&amp;lt;- struct{} // 当调用者可以获取到信号量资源时, close调这个chan&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;包含了两个字段，调用者请求的资源数，以及一个ready 通道。ready通道会在调用者可以被重新唤醒的时候被&lt;code&gt;close&lt;/code&gt;调，从而起到通知正在阻塞读取ready通道的等待者的作用。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;NotifyWaiters 通知等待者&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;notifyWaiters&lt;/code&gt;方法会逐个检查队列里等待的调用者，如果现存资源够等待者请求的数量n，或者是没有等待者了，就返回：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(s *Weighted)&lt;/span&gt; &lt;span&gt;notifyWaiters&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;      next := s.waiters.Front()&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; next == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt; &lt;span&gt;// 没有等待者了，直接返回&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;  &lt;br/&gt;&lt;br/&gt;      w := next.Value.(waiter)&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; s.size-s.cur &amp;lt; w.n {&lt;br/&gt;        &lt;span&gt;// 如果现有资源不够队列头调用者请求的资源数，就退出所有等待者会继续等待&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 这里还是按照先入先出的方式处理是为了避免饥饿&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;&lt;br/&gt;      s.cur += w.n&lt;br/&gt;      s.waiters.Remove(next)&lt;br/&gt;      &lt;span&gt;close&lt;/span&gt;(w.ready)&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;notifyWaiters&lt;/code&gt;方法是按照先入先出的方式唤醒调用者。当释放 100 个资源的时候，如果第一个等待者需要 101 个资源，那么，队列中的所有等待者都会继续等待，即使队列后面有的等待者只需要 1 个资源。这样做的目的是避免饥饿，否则的话，资源可能总是被那些请求资源数小的调用者获取，这样一来，请求资源数巨大的调用者，就没有机会获得资源了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Release归还信号量资源&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Release&lt;/code&gt;方法就很简单了，它将当前计数值减去释放的资源数 n，并调用&lt;code&gt;notifyWaiters&lt;/code&gt;方法，尝试唤醒等待队列中的调用者，看是否有足够的资源被获取。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(s *Weighted)&lt;/span&gt; &lt;span&gt;Release&lt;/span&gt;&lt;span&gt;(n &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    s.mu.Lock()&lt;br/&gt;    s.cur -= n&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; s.cur &amp;lt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;      s.mu.Unlock()&lt;br/&gt;      &lt;span&gt;panic&lt;/span&gt;(&lt;span&gt;&quot;semaphore: released more than held&quot;&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;    s.notifyWaiters()&lt;br/&gt;    s.mu.Unlock()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;Go&lt;/code&gt;语言中信号量有时候也会被&lt;code&gt;Channel&lt;/code&gt;类型所取代，因为一个 buffered chan 也可以代表 n 个资源。不过既然&lt;code&gt;Go&lt;/code&gt;语言通过&lt;code&gt;golang.orgx/sync&lt;/code&gt;扩展库对外提供了&lt;code&gt;semaphore.Weight&lt;/code&gt;这一种信号量实现，遇到使用信号量的场景时还是尽量使用官方提供的实现。在使用的过程中我们需要注意以下的几个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Acquire&lt;/code&gt;和 &lt;code&gt;TryAcquire&lt;/code&gt;方法都可以用于获取资源，前者会阻塞地获取信号量。后者会非阻塞地获取信号量，如果获取不到就返回&lt;code&gt;false&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Release&lt;/code&gt;归还信号量后，会以先进先出的顺序唤醒等待队列中的调用者。如果现有资源不够处于等待队列前面的调用者请求的资源数，所有等待者会继续等待。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果一个&lt;code&gt;goroutine&lt;/code&gt;申请较多的资源，由于上面说的归还后唤醒等待者的策略，它可能会等待比较长的时间。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>