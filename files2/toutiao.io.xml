<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>93558c72d8cb89efc710398988c42bed</guid>
<title>Java 线程池总结</title>
<link>https://toutiao.io/k/4z3o5gw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;Java线程池的写法和参数是面试中出现频率很高的基础题。越是基础的东西，特别是对高阶职位的面试者，需要回答的符合自己面试的职位等级。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;这里也不能说是一个多么好的答案，只是说如果是我，我怎么回答，仅供参考。以下回答可想象为面试官的问题是：谈谈线程池。&lt;/section&gt;&lt;section&gt;主要的思路是作为一个宽泛的问题，回答需要体现结构化的思维，这是必选项。在此基础上，可以体现深度，这是加分项。&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;回答&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;线程池设计目标&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;Java的线程主流实现都是采用&lt;span&gt;&lt;strong&gt;内核级线程&lt;/strong&gt;&lt;/span&gt;实现，创建线程要进行操作系统状态切换。为了避免资源过度消耗需要设法重用线程执行多个任务。线程池就是一个线程缓存，负责对线程进行统一分配、调优与监控。&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;线程池实现&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3477406679764244&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8eRqdxL261ptdgllN1sRBnzvrVJ4UQibWWKxm5Uv2cnS5hUKVtkj67aWnIqaiaxweqycnNhzsYJvTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1527&quot;/&gt;&lt;/p&gt;&lt;section&gt;如上图所示，线程池的Java实现都是继承于JUC(java.util.concurrent)的Executor接口。这个接口只有一个execute方法，代表了其行为。ExecutorService接口继承Executor，加上了生命周期的处理方法。其常用实现类如：ThreadPoolExecutor、ScheduledThreadPoolExecutor、ForkJoinPool的默认参数构造类都有在Executors这个工具类里直接实例化。&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;但是阿里巴巴开发手册不推荐使用Executors这个工具类。&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2966360856269113&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8eRqdxL261ptdgllN1sRBnx35gicziapBjKRiagEsicicpboyZrODspibicib5ic7HYCMiboBQp0pZnQC0iarjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;981&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;于是，我们需要自己了解ThreadPoolExecutor初始化参数的含义和使用方法。&lt;/section&gt;&lt;pre&gt;&lt;span&gt;/**&lt;br/&gt; * Creates a new {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;ThreadPoolExecutor} with the given initial&lt;br/&gt; * parameters and default rejected execution handler.&lt;br/&gt; *&lt;br/&gt; * &lt;/span&gt;&lt;span&gt;@param &lt;/span&gt;&lt;span&gt;corePoolSize &lt;/span&gt;&lt;span&gt;the number of threads to keep in the pool, even&lt;br/&gt; *        if they are idle, unless {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;allowCoreThreadTimeOut} is set&lt;br/&gt; * &lt;/span&gt;&lt;span&gt;@param &lt;/span&gt;&lt;span&gt;maximumPoolSize &lt;/span&gt;&lt;span&gt;the maximum number of threads to allow in the&lt;br/&gt; *        pool&lt;br/&gt; * &lt;/span&gt;&lt;span&gt;@param &lt;/span&gt;&lt;span&gt;keepAliveTime &lt;/span&gt;&lt;span&gt;when the number of threads is greater than&lt;br/&gt; *        the core, this is the maximum time that excess idle threads&lt;br/&gt; *        will wait for new tasks before terminating.&lt;br/&gt; * &lt;/span&gt;&lt;span&gt;@param &lt;/span&gt;&lt;span&gt;unit &lt;/span&gt;&lt;span&gt;the time unit for the {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;keepAliveTime} argument&lt;br/&gt; * &lt;/span&gt;&lt;span&gt;@param &lt;/span&gt;&lt;span&gt;workQueue &lt;/span&gt;&lt;span&gt;the queue to use for holding tasks before they are&lt;br/&gt; *        executed.  This queue will hold only the {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;Runnable}&lt;br/&gt; *        tasks submitted by the {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;execute} method.&lt;br/&gt; * &lt;/span&gt;&lt;span&gt;@param &lt;/span&gt;&lt;span&gt;threadFactory &lt;/span&gt;&lt;span&gt;the factory to use when the executor&lt;br/&gt; *        creates a new thread&lt;br/&gt; * &lt;/span&gt;&lt;span&gt;@throws &lt;/span&gt;&lt;span&gt;IllegalArgumentException if one of the following holds:&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;&lt;br/&gt; &lt;/span&gt;&lt;span&gt;*         {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;corePoolSize &amp;lt; 0}&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;&lt;br/&gt; &lt;/span&gt;&lt;span&gt;*         {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;keepAliveTime &amp;lt; 0}&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;&lt;br/&gt; &lt;/span&gt;&lt;span&gt;*         {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;maximumPoolSize &amp;lt;= 0}&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;&lt;br/&gt; &lt;/span&gt;&lt;span&gt;*         {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;maximumPoolSize &amp;lt; corePoolSize}&lt;br/&gt; * &lt;/span&gt;&lt;span&gt;@throws &lt;/span&gt;&lt;span&gt;NullPointerException if {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;workQueue}&lt;br/&gt; *         or {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;threadFactory} is null&lt;br/&gt; */&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;ThreadPoolExecutor&lt;/span&gt;(&lt;span&gt;int &lt;/span&gt;corePoolSize&lt;span&gt;,&lt;br/&gt;                          int &lt;/span&gt;maximumPoolSize&lt;span&gt;,&lt;br/&gt;                          long &lt;/span&gt;keepAliveTime&lt;span&gt;,&lt;br/&gt;                          &lt;/span&gt;TimeUnit unit&lt;span&gt;,&lt;br/&gt;                          &lt;/span&gt;BlockingQueue&amp;lt;Runnable&amp;gt; workQueue&lt;span&gt;,&lt;br/&gt;                          &lt;/span&gt;ThreadFactory threadFactory) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;(corePoolSize&lt;span&gt;, &lt;/span&gt;maximumPoolSize&lt;span&gt;, &lt;/span&gt;keepAliveTime&lt;span&gt;, &lt;/span&gt;unit&lt;span&gt;, &lt;/span&gt;workQueue&lt;span&gt;,&lt;br/&gt;         &lt;/span&gt;threadFactory&lt;span&gt;, &lt;/span&gt;&lt;span&gt;defaultHandler&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;ThreadPoolExecutor有6个参数，第一个是核心线程数，如果线程池无事可做，还是会保留这些线程。第二个是最大线程数，超过核心线程数的部分都会在第三个和第四个参数合起来决定的最长空闲存活时间超过后被剔除。第五个参数是阻塞队列，线程忙不过来要去这里面排队。最后一个是线程池工厂，主要决定队列也装不下的线程怎么处理，默认策略是抛出异常。&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;线程池的5种状态设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.369672131147541&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8eRqdxL261ptdgllN1sRBn63JhIzHef1f9QicHHWP1sDOJgfZvGj0icm4ia9SLU9iaibkGjQAm6VUlOow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1220&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.47711088504577825&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8eRqdxL261ptdgllN1sRBnM9d6vLKMnsgy2PRUol8FqaMOdDnM5hia6pBuWNDhO7XJ0erg2iafjYFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;983&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;线程池的底层原理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;Java线程的实现是通过调用native方法调用操作系统的pthread API，由内核线程统一管理。一个实现了Runnable的类只是标识可用多线程运行，真正产生大开销的是new Thread()时进行的内核调用。而线程池技术将worker线程缓存下来进行重用。&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;补充问答&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;线程池的关闭&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;关闭线程池可以调用shutdownNow和shutdown两个方法来实现。&lt;br/&gt;shutdownNow：对正在执行的任务全部发出interrupt()，停止执行，对还未开始执行的任务全部取消，并且返回还没开始的任务列表。&lt;br/&gt;shutdown：当我们调用shutdown后，线程池将不再接受新的任务，但也不会去强制终止已经提交或者正在执行中的任务。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;线程池都有哪几种工作队列&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1、ArrayBlockingQueue&lt;br/&gt;是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。&lt;br/&gt;2、LinkedBlockingQueue&lt;br/&gt;一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列&lt;br/&gt;3、SynchronousQueue&lt;br/&gt;一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。&lt;br/&gt;4、PriorityBlockingQueue&lt;br/&gt;一个具有优先级的无限阻塞队列。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;ForkJoinPool的原理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;本质上将一个任务进一步细分，内部使用“工作窃取”算法，让任务在各个CPU上尽可能均衡。&lt;/section&gt;&lt;p&gt;（1）每个工作线程都有自己的工作队列WorkQueue；&lt;/p&gt;&lt;p&gt;（2）这是一个双端队列，它是线程私有的；&lt;/p&gt;&lt;p&gt;（3）ForkJoinTask中fork的子任务，将放入运行该任务的工作线程的队头，工作线程将以LIFO的顺序来处理工作队列中的任务；&lt;/p&gt;&lt;p&gt;（4）为了最大化地利用CPU，空闲的线程将从其它线程的队列中“窃取”任务来执行；&lt;/p&gt;&lt;p&gt;（5）从工作队列的尾部窃取任务，以减少竞争；&lt;/p&gt;&lt;p&gt;（6）双端队列的操作：push()/pop()仅在其所有者工作线程中调用，poll()是由其它线程窃取任务时调用的；&lt;/p&gt;&lt;p&gt;（7）当只剩下最后一个任务时，还是会存在竞争，是通过CAS来实现的；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;本文的回答部分从线程池实现目标、实现和关键设计、底层原理四个方面说明线程池，具有一定的系统性。补充问答部分作为问题的深入在面试时被深入提问问到或者面试官示意继续深入来说的时候使用。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a41e4aa97937778242dac50dea065437</guid>
<title>最近的一些 Java 面试小结</title>
<link>https://toutiao.io/k/ffm07xa</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前段时间陆续面试了一些大中小公司，踩了不少坑，挂了很多，同时也有不少感悟和收获。这里想把那段经历记录一下，如果能对亲们有所帮助就再好不过了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试的过程其实也是一个自我认识和学习的过程，即便暂时没打算跳槽，隔段时间出去面一面对自己还是有些好处的：不仅可以评估一下自己在市场的价值和竞争力，同时也能了解一些新技术、更新一下自己的技术栈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且在一个地方待久了，可能不自觉的就会陷入到一种「舒适区」，久而久之，就像温水里的青蛙，万一哪天被“优化”了可能会不知所措。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要从「项目」和「技术」两个方面进行总结，除此之外还有一些比较开放式的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;元旦过了，“金三银四”还会远吗？春节后有想法的亲们，可以嗨起来了！&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;项目&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有人说：三年一道坎。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于工作三年左右的伙伴们来说，「项目经历」可谓重中之重，可以说比具体的技术点更重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;技术点其实大同小异，有些临时刷刷题就能了解个大概。但项目经历往往难以临时编造，如果不是自己真实做过的项目、或者没有充分的准备，一旦面试官问得稍微深入很可能 hold 不住，面试扣分不少、甚至可能直接挂掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此不少面试官喜欢从项目入手，抽丝剥茧、步步深入，通过项目把技术点串起来考察。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同人的项目千差万别，但还是有一些共同亮点的：比如高并发场景，复杂的架构设计，JVM 调优及问题排查等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些亮点有的话固然更好，但如果平时 CRUD 居多、没太多的亮点，其实也不必太慌，技术亮点不多的话，可以多思考一些业务上的亮点，比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;业务模型比较复杂&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对业务整体的架构设计很熟悉&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务模块拆分比较合理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自己在业务中做过哪些扩展和优化？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务数据的上下游流转是怎样的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;遇到过什么问题，如何解决的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;等等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些其实也是亮点，可以让面试官看到你平时对业务有自己的思考和理解，而不是只关注自己的那一块，不只是写代码的机器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实面试官对你的项目是一无所知的，他的印象仅仅停留在你简历上描述的那些文字（而且有些面试官可能是被临时拉过来的，别问我为什么知道🐶）。面试官通常的开场白就是让你自我介绍，其实这也是一个考察语言组织能力和口头表达能力的地方。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;技术&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们面的毕竟是技术岗，技术本身的重要性不言而喻。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;技术面试中，最重要的可以说是「技术体系」。也就是你不仅要有技术的深度和广度，更要能把它们串起来，其实有不少技术点是相通或相似的，如果面试中能够触类旁通、举一反三，是一个很好的加分项。比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Redis 的 AOF 和 MySQL 的 bin log&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring 中的 BeanDefinition 和 JVM 中类的元信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;布隆过滤器和 HashMap&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;等等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;技术的积累虽然主要在平时，但刷刷面试题还是很有必要的，有不少其实就是所谓的“八股文”。这里主要列出本人面试过程中真实遇到的一些面试题，仅供参考。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程池&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;锁&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;synchronized 锁升级过程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ReentrantLock&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实现原理（AQS）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;公平锁如何实现？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;volatile 特性&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;HashMap&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;HashMap &amp;amp; ConcurrentHashMap 实现原理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ConcurrentHashMap 如何实现线程安全&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;MySQL&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;索引&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;分类？使用场景？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;InnoDB 索引的结构（B+树），为什么不用 B 树？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何查看索引的使用情况？Explain 关注哪些字段？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;事务&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;常用数据结构&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;常见缓存问题&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;缓存穿透、缓存击穿、缓存雪崩、热点 key&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何解决上述问题？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;持久化：RDB、AOF，二者区别&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis 为什么快？线程模型是怎样的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存满了怎么办？淘汰策略有哪些？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用什么集群框架？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Spring&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;IoC、AOP 实现&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务传播特性、失效场景&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JDK &amp;amp; CGLib 区别&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring Boot 启动原理&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Dubbo&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Dubbo 架构&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;负载均衡算法、容错策略、灰度测试&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SPI 机制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RPC 调用过程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RPC &amp;amp; HTTP&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;二者区别与联系&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么 Spring Cloud 使用 HTTP 而非 RPC？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;JVM&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;运行时内存划分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;垃圾收集算法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个对象的内存分配过程？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CMS 收集器&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;收集过程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;哪个过程会有 STW？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何处理内存碎片问题？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;G1 收集器特点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;GC Roots 有哪些？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JVM 常用参数配置有哪些？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存占用过多，如何排查？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;RocketMQ&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;整体架构&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何保证消息的可靠性？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何实现顺序消息？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费者接口幂等设计&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务消息实现&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;分布式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;分布式锁&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Redis 如何实现？命令？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ZooKeeper 如何实现？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取锁失败时如何处理？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;分布式事务&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;2PC：缺点？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3PC：解决了 2PC 什么问题？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TCC：缺点？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最终一致性：MQ 实现流程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实现框架（Seata）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;其他&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了上面的「项目」和「技术」，可能还会问到一些其他问题，比如场景设计与分析、算法，还可能有一些比较开放的问题，下面介绍下我所遇到的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;场景设计&amp;amp;分析&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比较典型的场景设计，电商类的公司很可能会问到，网上有很多案例和文章分析，这里不再赘述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个应该不是热门，本人也就遇到过一次，不过那一次被搞得有点懵，可能更多的是考察思路，大家可以多思考一下。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;JVM 问题排查：线上 JVM 内存、CPU 飙升，如何去排查？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要涉及一些常用的 Linux 命令和 JDK 自带工具，比如 top、jstack、jmap 等，以及阿里的开源工具 Arthas 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然在实际情况中我们可能很少有机会接触（小小开发通常没权限，还是要运维大佬支持），但这些工具还是要了解的，可以在本地跑个 Demo 去验证，以免到时候答不上来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如线上所有机器（包括服务器、数据库、缓存服务器）全部宕机，如何处理？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;PS: 这些场景设计和分析的问题，通常比较综合，一般是考察对一个场景的整体设计，或者分析和解决问题的思路。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;算法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;PS: 算法问题遇到的不是很多，有些考察算法可能就是单纯的面试流程。当然，字节这类的公司除外，想去的话肯定还是要刷很多算法的。&lt;/p&gt;&lt;p&gt;相比之下，大部分公司更注重「项目深度」和「技术体系」，或者给出一些实际的场景，考察分析和解决问题的经验和思路。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;开放问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些问题比较开放，没有固定的答案，可能就是面试官想看下你的临场发挥吧。遇到的几个问题如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;有没有带过人？经历是怎样的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果你作为 PM，如何从整体协调一个项目？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果你在团队推行 DDD，你会怎么做？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你有什么缺点？优点？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;未来三年的职业规划？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在公司主要有哪些成长？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;上级、同事对你的评价？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最近在看什么书？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;末了&lt;/span&gt;&lt;/h1&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;面试流程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我所接触的面试大部分是「三轮技术面 + HR 面」的形式，也有一些是两轮技术面，不同公司可能不太一样。一面一般是电话面初筛，后面二三轮技术面和 HR 面通常在一起。这样其实也挺好，跑一趟就行了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;心态&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试的心态也很重要。其实你跟面试官之间是平等的，面试的过程是让他对你更加了解，而不是他对你的考核。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我刚开始面的时候，&lt;/span&gt;&lt;span&gt;由于好久没面试，再加上本来就不太爱说话，刚开始紧张的不行，后来面了几次之后才逐渐有点感觉。&lt;/span&gt;&lt;span&gt;如果较长时间没面试，可以先面一两家练练手、找找感觉。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，整个面试时间也不建议拖得太久，否则整个过程会比较累，最好还是一鼓作气。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;啰里啰嗦一堆，其实面试还是挺看运气的，如果跟面试官聊得比较投机，对你的评分自然也不错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，预祝想跳槽的亲们一路绿灯！&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_gif/ophTb90oYCR6eOZrkKMnznEahtiajNrSAicJDk24paw3VDzbZRLXgyibXWEuZ4qhuSgXoeFaqj1gpV96gVpZCHc7g/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;639&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>42bc75cd64241cbc794bf5403b6e3c09</guid>
<title>[译] 为什么我们不用数据库生成 ID？</title>
<link>https://toutiao.io/k/v3hruzg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;strong&gt;先介绍一下背景 🔭&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;团队正在一个为 SQL Server 构建数据目录项目的历程中，我们&lt;strong&gt;优化系统以实现解耦&lt;/strong&gt;。这对我们来说非常重要，从根本上来说，我归结为两个核心原则，希望每个软件专业人员都能认同：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下面是 protoactor-go 开源项目里的一句话 “software should be composed, not built”，与我要在本文陈述的观点非常相似：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6776429809358753&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOPic8xZ6eSB2CCoNIUrBPVMM8XsiafXfgc6K1EqrLF71ibMqcKC2Ffbwa6vxZ4c2tj2rtqrwP2wDhLRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1154&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;对持久化有何影响？🤔&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;考虑到前面总体原则，我们不想把自己的状态持久化耦合到一个特定的数据库引擎上。从实际情况来看，就是说不将持久化的具体关注点传递到领域层。之所以要实现这一点，因为我们今天对规则的认知可能会让我们依赖某种具体数据库技术，比如 SQL Server，但并不能确保它能满足未来的能力需求。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有了这个具体的要求，持久化就需要出现在域事件而不是存储系统中，这也导致不同的存储需求。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;幸运的是，有一些广为人知的、经过实战检验的模式可以解决这个问题，如结合 CQRS 领域驱动设计中的聚合设计等。因此这里的假设是，实现理想状态对我们来说是低成本的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;代码生成 ID 还是数据库生成 ID 🔬&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;许多数据存储系统（如 SQL Server）都具备为每条记录（如行、文档等）生成唯一标识符的方法。当将新记录插入表中时，使用自动增量键可以生成唯一编号。当我们要插入一条新记录时，数据库引擎就自动完成自增主键，并且可以确保该键对于表是唯一的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是如果依赖数据库来为我们业务域生成唯一标识符，这将让&lt;strong&gt;业务层与数据存储系统耦合在一起&lt;/strong&gt;。如果我们想切换一个不支持生成自动增量主键的数据存储系统，那就不能简单更换。而且，每个数据存储系统生成标识符的方式都不一样，这可能会导致我们最终使用不同的主键类型。除此之外，这些类型的生成方式可能不适合分布式系统。例如，当我们在 SQL Server 数据库中拥有一个生成主键的表时，我们没有一个简单的方法在分布式环境中水平扩展这个表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;通过让业务域的消费者（即通过命令和查询与域通信的传输层）负责唯一键的标识符生成&lt;/strong&gt;，就可以克服这些问题。它减少对环境的依赖性，又反过来让我们不用依赖数据库来生成 Id。这种方法还有一个好处：它可以支持分布式。例如，我们可以将一个表分区到两个物理 SQL Server上，并分担查询的请求。如果我们有一个自动增量的字段，这在 SQL Server 上就不行了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;我们决定做什么？🚀&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;基于这些事实，我们决定让业务域层来生成域集合的标识符。我们在域层内将这些标识符表示为 64 位无符号整数。域消费者可以根据自己的上下文自由决定应该用什么表示方式（例如ASP.NET Core MVC 可以将标识符序列化为字符串，以便于其客户端消费资源对象等）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;为什么要 64 位整型，而不是 UUID？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最后，您可能想知道为什么使用64位整数。此处的主要目的是使我们能够甚至跨聚合根生成唯一的标识符。&lt;span&gt;考虑到几乎每个平台都有对应的 API，UUID 是非常方便的调用方式（例如 .NET 中 Guid.NewGuid() 等）。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;UUID 最大的问题是存储和索引方面的成本与开销&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，虽然对我们来说不是大问题。不过，在分布式系统中，已经有一些成熟的方法来生成唯一标识符作为更高效的主键类型，比如使用 64 位整数。Twitter Snowflake (1) 算法就是其中之一，这让我们选择了 64 位整数而不是 UUID。我们使用的是 Rob Janssen 的开源 IdGen (2) 库，它是一个适用于 .NET 的 Twitter Snowflake 类型的 ID 生成器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(1) https://developer.twitter.com/en/docs/basics/twitter-ids.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(2) https://github.com/RobThree/IdGen&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;英文原文：&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://medium.com/ingeniouslysimple/why-did-we-shift-away-from-database-generated-ids-7e0e54a49bb3&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;参考阅读：&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文由高可用架构翻译，技术原创及架构实践文章，欢迎通过公众号菜单「联系我们」进行投稿。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;高可用架构&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;改变互联网的构建方式&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;img data-w=&quot;200&quot; data-type=&quot;jpeg&quot; data-s=&quot;300,640&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/8XkvNnTiapOPOK9rQud9XibGhPOPsA3gA8Wr4CEnzmhfZQzSGu0Q09GOuk18S9icZtuVnQewvyqZtOWyDnJPBDn1A/640?wx_fmt=jpeg&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b17c607b2c4ca2393d987c45c92e4f8a</guid>
<title>uni-app 使用前的调研和开发心得</title>
<link>https://toutiao.io/k/wyg3rez</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;/p&gt;&lt;p line=&quot;CTTC&quot;&gt;&lt;span&gt;之前的工时系统是原生的小程序实现，由于产品逻辑需要优化，代码混乱又仅限微信平台使用，公司致力于想给工时系统重构后支持多平台，并对外开放使用，使之成为一款真正的商业产品。经过前期调研后，uni-app对于多平台的支持最好，且易于上手，于是采用该框架对工时系统进行改造。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;Hspc&quot;&gt; &lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;uni-app介绍&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p line=&quot;OuC6&quot;&gt;&lt;span&gt;uni，读 you ni，是统一的意思。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;NS7n&quot;&gt;&lt;span&gt;很多人以为小程序是微信先推出的，其实，DCloud才是这个行业的开创者。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;h9un&quot;&gt;&lt;span&gt;DCloud于2012年开始研发小程序技术，优化webview的功能和性能，并加入W3C和HTML5中国产业联盟，推出了HBuilder开发工具，为后续产业化做准备。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;07qC&quot;&gt;&lt;span&gt;2015年，DCloud正式商用了自己的小程序，产品名为“流应用”，它不是B/S模式的轻应用，而是能接近原生功能、性能的动态App，并且即点即用。为将该技术发扬光大，DCloud将技术标准捐献给工信部旗下的HTML5中国产业联盟，并推进各家流量巨头接入该标准，开展小程序业务。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;wRSo&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;bPZM&quot;&gt;&lt;span&gt;在2015年9月，DCloud推进微信团队开展小程序业务，演示了流应用的秒开应用、扫码获取应用、分享链接获取应用等众多场景案例，以及分享了webview体验优化的经验。微信团队经过分析，于2016年初决定上线小程序业务，但其没有接入联盟标准，而是订制了自己的标准。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;EtWW&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;Xq53&quot;&gt;&lt;span&gt;DCloud持续在业内普及小程序理念，推进各大流量巨头，包括手机厂商，陆续上线类似小程序/快应用等业务。部分公司接入了联盟标准，但更多公司因利益纷争严重，标准难以统一。技术是纯粹的，不应该因为商业利益而分裂。开发者面对如此多的私有标准不是一件正确的事情。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;Xq53&quot;&gt;&lt;/p&gt;&lt;p line=&quot;Mmyx&quot;&gt;&lt;span&gt;既然各巨头无法在标准上达成一致，那么就通过这个框架为开发者抹平各平台差异。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;IHSX&quot;&gt;&lt;span&gt;这，就是uni-app的由来。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;因为多年积累，所以DCloud拥有300多万开发者，并不意外&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;因为DCloud一直都有小程序的iOS、Android引擎，所以uni-app的App端和小程序端保持高度一致，并不意外&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;因为DCloud在引擎上的持续投入，所以uni-app的App端功能、性能比大多数小程序引擎都优秀，并不意外&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;因为DCloud对各家小程序太了解了，所以做好抹平各端差异的跨端框架，并不意外&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p line=&quot;D7Fs&quot;&gt;&lt;span&gt;现在，uni-app已经是业内最风靡的应用框架，支撑着6亿手机用户的庞大生态。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;INsn&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;较其它跨平台框架的优势&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;跨端数量更多&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;平台能力不受限&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;性能体验更优秀&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;周边生态丰富&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;学习成本低&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;开发成本低&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p line=&quot;N3lu&quot;&gt;&lt;span&gt;几大跨平台开发框架性能和兼容性对比：微信原生版、wepy版、mpvue版、taro版、uni-app版、chalemeon版 https://github.com/dcloudio/test-framework&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;akqU&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;前置条件&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p line=&quot;iR4u&quot;&gt;&lt;span&gt;基本上是&lt;span&gt;Vue&lt;/span&gt;和&lt;span&gt;微信小程序&lt;/span&gt;的结合，看了uni-app的介绍和背景，就知道为什么小程序的接口组件命名和uni-app几乎一样了&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;BjgV&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;开发工具&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p line=&quot;dVmT&quot;&gt;&lt;span&gt;HBuilderX （轻如编辑器，强如IDE），官方IDE下载地址&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;可视化的方式比较简单，HBuilderX 内置相关环境，开箱即用，无需配置node ，内置浏览器及时预览，更多功能可通过插件实现&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果你之前习惯了使用其它的如VS code、Sublime Text编辑器，在工具栏里可以选择预设快捷键方案切换里选择对应的工具类型，几乎无成本就上手了&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;工具里内嵌了强大的代码块功能，通过预设的变量生成某一段代码，还支持自定义，可以通过自定义代码块教程学习如何生成你自己的代码块，可以节省很多的时间&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;创建项目时可以选择你的应用类型，生成默认模版&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第一次运行时，在工具栏的运行&lt;span&gt;-&amp;gt; 运行到小程序模拟器 -&amp;gt; 微信开发者工具，首次需要配置微信开发者工具的安装路径，然后点击运行即可调起微信开发者工具（&lt;/span&gt;&lt;span&gt;如果出现调不起来的情况，请到微信开发者工具设置菜单-&amp;gt;安全设置里把服务端口开启&lt;/span&gt;&lt;span&gt;）；新建项目目录不是选择uni-app的项目根目录，选择的是根目录下面的unpackage-&amp;gt;dist-&amp;gt;dev-&amp;gt;mp-weixin，运行的是编译后的代码&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;建议平时开发选择内嵌浏览器进行及时预览，修改及生效，还可以通过扫描地址栏上方的二维码在手机上预览（必须连的是同一个局域网），调试和浏览器一样打开审查元素&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p line=&quot;QG1a&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;强大的开发者生态&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p line=&quot;ulDD&quot;&gt;&lt;span&gt;uni-app拥有丰富的插件市场，这里都是开发者贡献的插件，让开发更高效，不必重复造轮子，当然你也可以为开源贡献参与其中，详情见插件开发指南，同时&lt;span&gt;兼容 NPM 包管理系统 uni-app完整支持 NPM ，&lt;/span&gt;活跃的社区氛围，有问题或者交流可以去社区发帖&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;1PD2&quot;&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;如何实现优雅的跨端&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p line=&quot;X4Fi&quot;&gt;&lt;span&gt;不同平台特有的API支持条件编译，在 C 语言中，通过 #ifdef、#ifndef 的方式，为 windows、mac 等不同 os 编译不同的代码，uni-app 参考这个思路，为 uni-app 提供了条件编译手段，在一个工程里优雅的完成了平台个性化实现 。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;saM0&quot;&gt;&lt;span&gt;条件编译是利用注释实现的，在不同语法里注释写法不一样：&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;3X3V&quot;&gt;&lt;span&gt;js使用 &lt;span&gt;// 注释&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;nWy5&quot;&gt;&lt;span&gt;css 使用 &lt;span&gt;/* 注释 */&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;B6Ta&quot;&gt;&lt;span&gt;vue/nvue 模板里使用 &lt;span&gt;&amp;lt;!-- 注释 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;r4k7&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;rulU&quot;&gt;&lt;span&gt;&lt;strong&gt;uni-app也是支持钉钉小程序的，调试工具用的是支付宝开发者工具，在运行菜单里原本没有钉钉这一项，需要增加拓展，方法参见&lt;/strong&gt;https://ask.dcloud.net.cn/article/36353&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;1RFB&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;uni-app开发较原生开发对比&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p line=&quot;HBGP&quot;&gt;&lt;span&gt;&lt;strong&gt;优势&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;目录结构清晰，页面文件由原来的wxml，wxss，json，js四个文件变成现在的一个vue文件&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;支持scss和less写法，通过它的变量、继承、嵌套、运算等特性和函数增加css开发效率，减少代码量&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在uni-app中可以通过vuex插件来全局管理数据&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p line=&quot;FW0L&quot;&gt;&lt;span&gt;&lt;strong&gt;劣势&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;编译调试比较麻烦，编译时间长，编译一次本地缓存数据被清除，需要登陆和缓存的过程对于调试增加了时间成本&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;多平台发布需要多写一些条件编译代码，要了解各平台的差异性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;原生开发定义全局变量和方法可在app.js中直接定义，全局变量一般用globalData表示，uni-app中几种常见的实现方式有：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p line=&quot;k8Ov&quot;&gt;&lt;strong&gt;&lt;span&gt;公用模块&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p line=&quot;k8Ov&quot;&gt;&lt;/p&gt;&lt;p line=&quot;yDCN&quot;&gt;&lt;span&gt;定义一个公用的模块，用来组织和管理这些全局的变量，在需要的页面引入，一般放在根目录下common目录里，然后用的时候在页面中引入该模块，这种方式维护起来比较方便，但是用的时候每次都得引入&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;Scfr&quot;&gt;&lt;span&gt;&lt;strong&gt;挂载到Vue.prototype&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;cuDl&quot;&gt;&lt;span&gt;在main.js中挂载属性/方法&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import req from &#x27;./api/index&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import util from &#x27;./utils/util&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Vue.prototype.api = &#x27;http://uniapp.dcloud.io&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Vue.prototype.now = Date.now || function () {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  return new Date().getTime();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Vue.prototype.$api = req&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Vue.prototype.$util = util&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p line=&quot;ARrh&quot;&gt;&lt;span&gt;引用的时候&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;script&amp;gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  export default {  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    data() {  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        return {};  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    },  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    onLoad(){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        console.log(&#x27;now:&#x27; + this.now());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    },  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    methods: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      getProjectWorktime(userId, workDay) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    this.$api.wktime.getWktimeStatus(userId,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          {workDay: workDay}).then(res =&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            console.log(res)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          })&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p line=&quot;Dlmt&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;&lt;strong&gt;globalData定义全局变量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;Dlmt&quot; linespacing=&quot;115&quot;&gt;&lt;/p&gt;&lt;p line=&quot;PuQB&quot;&gt;&lt;span&gt;小程序中有个globalData概念，可以在 App 上声明全局变量。Vue 之前是没有这类概念的，但 uni-app 引入了globalData概念，并且在包括H5、App等平台都实现了。在 App.vue 可以定义 globalData ，也可以使用 API 读写这个值。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;script&amp;gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  export default {  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    globalData: {  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        text: &#x27;text&#x27;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p line=&quot;OhNR&quot;&gt;&lt;span&gt;在其它页面中取值的方式&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;getApp().globalData.text&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p line=&quot;kNAz&quot;&gt;&lt;span&gt;&lt;strong&gt;uni-app的本地存储&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;kNAz&quot;&gt;&lt;/p&gt;&lt;p line=&quot;VliU&quot;&gt;&lt;span&gt;uni.storage的键值对存储，这个是全端支持的。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;95Tz&quot;&gt;&lt;span&gt;uni-app的Storage在不同端的实现不同，uni.storage在app侧，映射为plus.storage；h5侧映射为localstorage；各个小程序平台映射为其自带的storage键值对存储：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;H5端为localStorage，浏览器限制5M大小，是缓存概念，可能会被清理&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;App端为原生的plus.storage，无大小限制，不是缓存，持久化&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;各个小程序端为其自带的storage api，数据存储生命周期跟小程序本身一致，即除用户主动删除或超过一定时间被自动清理，否则数据都一直可用。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;微信小程序单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;支付宝小程序单条数据转换成字符串后，字符串长度最大200*1024。同一个支付宝用户，同一个小程序缓存总上限为10MB。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;百度、头条小程序文档未说明大小限制&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p line=&quot;wOZ7&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;span&gt;常见的平台差异处理（目前仅对微信小程序和H5）&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;H5页面底部菜单是包含在页面高度内的，如果postion置为fixed的话，&lt;span&gt;bottom: 0; &lt;/span&gt;&lt;span&gt;需要写成&lt;/span&gt;&lt;span&gt;bottom: var(--window-bottom);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;登陆逻辑需要用在模版里插入条件编译，逻辑里需要注入不同的登陆方法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!-- #ifdef H5 --&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;H5登陆&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!-- #endif --&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!-- #ifndef H5 --&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;其它平台登陆&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!-- #endif --&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;br/&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;非H5端默认并未启用 scoped，如需要隔离组件样式可以在 style 标签增加 scoped 属性，H5端为了隔离页面间的样式默认启用了 scoped&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;在所有的tabbar页面跳转都要用navigateto,来确保tabbar的list不发生任何改变，而小程序不受影响（&lt;/span&gt;&lt;span&gt;出现的异常是在h5中tabbar页面用redirect跳转到非tabbar页面，底部菜单仍存在&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p line=&quot;zODt&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;发布注意事项&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p line=&quot;TWZR&quot;&gt;&lt;span&gt;uni-app各端能运行的是编译后的代码，文件位于根目录下unpackage-&amp;gt;dist-&amp;gt;build/dev，build目录是发布的代码，dev是本地预览的代码&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;bz7C&quot;&gt;&lt;span&gt;&lt;strong&gt;H5端发布：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;点击发行-&amp;gt;网站-H5手机版，需要配置网站域名，编译到代码中解决接口请求跨域的问题&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;根目录下manifest.json文件关于h5配置，注意选择路由模式，hash和history，运行的基础路径，就是域名解析对应的服务器上项目的目录&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p line=&quot;re2C&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;思考及感想&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;OsYs&quot;&gt;&lt;span&gt;之前听过一个大佬的一句话：如果我只能给其他程序员一个建议，那就是编写小的代码块，你要多写小方法、小功能、小程序。写完不断思考如何精简你的代码，如何完善你的逻辑，只有基本功扎实了，你才能在大的系统和程序里游刃有余。&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>587c8e5f9bde6991481fed6ec0649283</guid>
<title>人人都是 LSP？：种子与文件下载的相爱相杀</title>
<link>https://toutiao.io/k/mkgyw4w</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;img data-backh=&quot;106&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.3364102564102564&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzgjVsz4716uLlBxK4ibbhqcsrfZElYmj5WKYswtBdYJQ0v2tcDNJ2QSQSnpbOTa1M1YpTQuFpn1Pw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;975&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h2&gt;前言&lt;/h2&gt;&lt;p&gt;世界上根本没有 LSP，又或者，人人都是 LSP。&lt;/p&gt;&lt;p&gt;说起种子，你会想到什么？&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9606986899563319&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzgjVsz4716uLlBxK4ibbhqcXdRGxV2yqX1EU0UCXWVOsJE7JfR0ibiaNXHxM1q2XAYMEwt1L2MViaYKA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;229&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;是农民伯伯春天播下，秋天就会收获果实的东西？还是以&lt;code&gt;.torrent&lt;/code&gt;结尾的文件？&lt;/p&gt;&lt;p&gt;如果是前者，那你一定是一个热爱大自然的人。如果是后者，你一定是一个“热爱生活”的人。&lt;/p&gt;&lt;p&gt;不过今天我们要聊的不是大自然的那个种子，而是 LSP 们喜闻乐见的这个种子。&lt;/p&gt;&lt;h2&gt;P2P 与 BitTorrent 协议&lt;/h2&gt;&lt;p&gt;所谓“种子”（或者叫种子文件），其实就是以&lt;code&gt;.torrent&lt;/code&gt;结尾的文件，而他之所以叫种子，是因为这个文件里包含了你需要获取的文件的相关信息。就和自然界中的种子一样，包含了日后形成一颗果实所需要的最基本的成分。&lt;/p&gt;&lt;p&gt;而这个&lt;code&gt;.torrent&lt;/code&gt;后缀其实指的是支持 BitTorrent 协议的文件。BitTorrent 简称 BT，俗称比特流。看到这，想必你已经有些印象了吧，我们常说的 BT 种子和种子其实是一种东西。&lt;/p&gt;&lt;p&gt;那么这个 BitTorrent 协议是什么？&lt;/p&gt;&lt;p&gt;不急，在介绍 BitTorrent 之前，先让我们梦回高中课堂，回想一下以前抄作业的时光。&lt;/p&gt;&lt;h3&gt;抄作业的例子&lt;/h3&gt;&lt;p&gt;&lt;img data-backh=&quot;241&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.7665130568356375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzgjVsz4716uLlBxK4ibbhqccTIKhfqgSovZz83U8vhUaR5UGP0EQMuOzfOhLMh2qHDbtEeXOiaSTwQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1302&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;如上图所示，学霸在写完作业后，要把作业借给同学抄，但是一次只能借给一个人，且其他人只能抄学霸的作业，那么如果想要让学霸在内的 7 个人都写完作业，取决与学霸写作业的速度和每个同学抄作业的速度。我们知道，这样的效率一定是很低下的，所以聪明的学霸想出了第二个办法。如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;222&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.7050898203592815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzgjVsz4716uLlBxK4ibbhqcYpcDOCZh4KKTZCuIuzILkRH3ia9KHs85zdI2Fbm52Qlbqt8cU2xCz0g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1336&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;学霸的办法就是，把作业分成几块，让每个人抄不同的部分，比如 A 抄单选题、B 抄多选题、C 抄填空题……然后每个人再把自己抄到的作业和其他人抄到的作业互换，这样，所有人都可以在规定时间内把所有的作业都抄完了，以此实现效率的提升。&lt;/p&gt;&lt;h3&gt;P2P 与文件下载&lt;/h3&gt;&lt;p&gt;&lt;img data-backh=&quot;95&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.3031437125748503&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzgjVsz4716uLlBxK4ibbhqcEpOxOfVeLHb7d7pIMnrOgdeWs4ukiansyluibaNV64B0vJ8VEFqofAOg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1336&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;之所以要先提抄作业这个事情，是因为这两种方案和下载文件颇为相似。&lt;/p&gt;&lt;p&gt;传统的文件下载就和上面的第一种方案类似，如上图所示，客户端向服务器发送“我要下文件”，服务器便将文件再发给客户端，这是一个很常见的场景，在这个场景中，客户端下载文件的速率取决于两个因素：服务器的&lt;strong&gt;上传带宽&lt;/strong&gt;和客户端的&lt;strong&gt;下载带宽&lt;/strong&gt;。带宽是指在单位时间（一般指的是 1 秒钟）内能传输的数据量。&lt;/p&gt;&lt;p&gt;而一旦需要下载的文件数量是多个时，下载的总时间便受到下载数量 N 的限制，即越多的人下载某一个文件时，理论上所需要的下载时间就越长，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;120&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.38173652694610777&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzgjVsz4716uLlBxK4ibbhqciaLXgeAR2Wqa1q5eIibb5akuWjsvdGE9U7iaiaibamMqAmiazhalFlJoRFWQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1336&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;这种用户体验显然是很糟糕的，那么有没有什么好的方法解决这个问题呢？这就要请出我们本期的“天降猛男”——P2P&lt;strong&gt;（peer-to-peer）&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;这里的 P2P，和点对点（point-to-point）的协议程序不同，它是&lt;strong&gt;用户群对用户群（peer-to-peer）&lt;/strong&gt;，当然也不是我们前几年经常听见的暴雷的 P2P（互联网金融点对点借贷平台）。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;本文所说的 P2P 是一种架构模式，就和我们之前说过的 C/S（客户端/服务端）架构类似。&lt;/p&gt;&lt;p&gt;在 P2P 模式中，服务和资源&lt;strong&gt;分布化&lt;/strong&gt;，资源不集中存储在某些设备上，而是&lt;strong&gt;分散存储&lt;/strong&gt;在运行 P2P 程序的设备上，每一个对等方都可以为其他对等方提供服务。&lt;/p&gt;&lt;p&gt;还是拿抄作业这个例子来说，学霸的第二个方案就是一个很典型的 P2P 模式。他将自己的作业分成填空、选择、单选、多选等部分，然后分别送给 6 个人，这样当每个人都有自己的一部分副本后，就可以不用再找学霸本人要作业了，直接找其他拥有和自己副本不同的人索取然后互换资源即可。&lt;/p&gt;&lt;p&gt;在互联网，P2P 模式也有一个非常重要的，乃至影响了所有 LSP 的应用，即 BitTorrent，也就是本文开篇所说的种子。&lt;/p&gt;&lt;h2&gt;BitTorrent 协议&lt;/h2&gt;&lt;p&gt;维基百科对 BitTorrent 的解释是：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;BitTorrent 协议（简称 BT，俗称比特洪流、BT 下载）是用在对等网络中文件分享的网络协议程序。和点对点（point-to-point）的协议程序不同，它是&lt;strong&gt;用户群对用户群（peer-to-peer）。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;BitTorrent 协议是架构于 TCP/IP 协议之上的一个 P2P&lt;strong&gt;文件传输通信协议&lt;/strong&gt;，处于 TCP/IP 结构的应用层。&lt;/p&gt;&lt;p&gt;简而言之就是 BitTorrent 是一个用来传输文件的协议，和第二个抄作业案例的特性类似，该协议的特点是，用户越多，即下载同一文件的人越多，下载该文件的速度越快。且下载后，继续维持上传的状态，就可以“分享”，成为其用户端节点下载的种子文件（.torrent），同时上传及下载。&lt;/p&gt;&lt;p&gt;在大多数人感觉中 BitTorrent 与 P2P 成了对等的一组概念，而它也的确将 P2P 技术发展到了近乎完美的地步。&lt;/p&gt;&lt;h3&gt;原理&lt;/h3&gt;&lt;p&gt;介绍完 BitTorrent 协议后，我们来说说他的原理吧。&lt;/p&gt;&lt;p&gt;其实和学霸将作业分成选择题、填空题等给其他人抄的道理一样，BitTorrent 协议也是将需要下载的文件虚拟分成大小相等的块，这些块的大小被要求成 2k 的整数次方（由于是虚拟分块，硬盘上并不产生各个块文件），并把每个块的索引信息和 Hash 验证码写入 .torrent 文件（即种子文件，也简称为“种子”）中，作为被下载文件的&lt;strong&gt;“索引”&lt;/strong&gt;。  下载者要下载文件内容，需要先得到相应的 .torrent 文件，然后使用 BT 客户端软件进行下载。&lt;/p&gt;&lt;p&gt;而.torrent 文件其本质就是一张信息清单，存储了一些信息，如下图所示，其中就包括了文件大小、哈希值、tracker 地址等信息。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;97&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.30732292917166865&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzgjVsz4716uLlBxK4ibbhqcYIHu3P9lYXPsiciasSibSHCicsLLwrYB7jfNCIiajGZg0I5bVmvzsA18e3A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;833&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;下载时，BT 客户端首先解析 .torrent 文件得到 Tracker 地址，然后连接 Tracker 服务器。Tracker 服务器回应下载者的请求，&lt;strong&gt;提供下载者其他下载者（包括发布者）的 IP&lt;/strong&gt;。或者，BT 客户端也可解析 .torrent 文件得到 nodes 路由表，然后连接路由表中的有效节点，由网络节点提供下载者其他下载者的 IP。&lt;/p&gt;&lt;p&gt;下载者再连接其他下载者，根据 .torrent 文件，两者分别对方告知自己已经有的块，然后交换对方没有的数据。此时不需要其他服务器参或者其他网络节点的参与，分散了单个线路上的数据流量，因此减轻了服务器负担。&lt;/p&gt;&lt;p&gt;下载者每得到一个块，需要算出下载块的 Hash 验证码与 .torrent 文件中的对比，如果一样则说明块正确，不一样则需要重新下载这个块。&lt;/p&gt;&lt;p&gt;因此，下载的人越多，提供的带宽也越多，种子也会越来越多，下载速度就越快。&lt;/p&gt;&lt;p&gt;如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;213&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.6763636363636364&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzgjVsz4716uLlBxK4ibbhqcmvJneloiaLIRWZbGU25lqyrbdrribJbuCNnhqaEKjYyH3ibL8nMiaIZXpg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;825&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;从 BT 客户端角度考虑，下载原理分为以下几步：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;根据 BitTorrent 协议，文件发布者会根据要发布的文件生成提供一个 .torrent 文件。客户端可从 Web 服务器上下载种子文件，并从中得到 Tracker 服务器 URL。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;根据 Tracker URL 与 Tracker 服务器建立连接，并从服务器上得到 Peers 信息。&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;根据 Peers 信息与一个 Peer 建立连接，依据 Peer wire 协议完成握手，并从 Peer 端下载数据文件。同时监听 Peer 的连接，并给 Peer 上传数据文件。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;Tracker 没了怎么办？&lt;/h3&gt;&lt;p&gt;从上面的分析中我们得知，想要利用种子下载资源，第一步就是根据种子里的信息获取到 Tracker 地址，那么这时候问题就来了，如果运营商掐断了你和 Tracker 服务器间的连接了怎么办？&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9919093851132686&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzgjVsz4716uLlBxK4ibbhqc5FpPmdbLdzyr8HShEQjASDKxHZjGibJicpRn3KqAPVk9JOrB4f3DSZXA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;618&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;有两种解决方案：&lt;/p&gt;&lt;h3&gt;PT&lt;/h3&gt;&lt;p&gt;第一种是采用一种不会被运营商掐断的 Tracker 服务器，PT（英语：Private Tracker），即私有种子服务器。他与 BT 最大的不同点为：可进行私密范围下载。由于是私有的，所以一般的 PT 网站都是采用的邀请制，由已注册的用户向自己所信任的人发送邀请，以确保用户质量。例如紫荆站就是南大人专属的网络资源的 PT 站点（需要在连接到校园网的状态下登录）。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;说个题外话，紫荆花的花语是矢志不渝，而这个网站之所以叫紫荆，是因为开发者曾约定和他的女朋友一起在南大种一朵紫荆花，虽然最后因为学校的原因没有种成，但意外诞生了紫荆 PT 来纪念他们的爱情。就像紫荆的作者说的，紫荆是胡同写给他的领导“紫荆 MM”的一封情书，即“你的心里，刻着我的名字”。&lt;/p&gt;&lt;p&gt;不说了，这就去吃柠檬。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.95&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzgjVsz4716uLlBxK4ibbhqctAQYvnc1dFBgPXPNhwslTiboFyKZ4UOkR5HJGSvibj8X4RC6MeZHGCMA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;DHT 网络&lt;/h3&gt;&lt;p&gt;&lt;img data-backh=&quot;201&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.6375158428390367&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzgjVsz4716uLlBxK4ibbhqcPY7Dj4OI7z2icZEiabJNRGO6IetLGtOdyCtSicm2d283sk71tPqMOpoAg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;789&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;第二种解决方案便是 DHT 网络了，维基百科对他的解释是：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;DHT 全称为分布式哈希表（Distributed Hash Table），是一种分布式存储方法。在不需要服务器的情况下，每个客户端负责一个小范围的路由，并负责存储一小部分数据，从而实现整个 DHT 网络的寻址和存储。使用支持该技术的 BT 下载软件，用户无需连上 Tracker 就可以下载，因为软件会在 DHT 网络中寻找下载同一文件的其他用户并与之通讯，开始下载任务。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;不知道上面这种解释能否理解，我换个说法，大家可能就清楚了。&lt;/p&gt;&lt;p&gt;曾经有一个非常著名的理论：最多通过五个人你就能够认识世界上任何一个陌生人，即&lt;strong&gt;六度分离理论&lt;/strong&gt;。在 DHT 网络中，每个节点就跟人一样，你可以通过你的朋友，或者你朋友的朋友，或者你朋友的朋友的朋友，只需要不断递归即可找到你想要的资源地址。这样的话，在一个网络中也就不需要 Tracker 服务器了，又或者说，在这个网络中，所有的机器都充当了 Tracker 服务器。再回顾开篇说的那句，世界上根本没有 LSP，又或者，人人都是 LSP。这么一想，是不是有那味了。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9867256637168141&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzgjVsz4716uLlBxK4ibbhqcs5iaTJ7E5VJED2WXF2GbkulAssu3bniaia02jreIib6XKGbovVbey0PIDw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;226&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;而这也是磁力链接的原理。所以其实磁力下载和种子下载的&lt;strong&gt;本质&lt;/strong&gt;都是 P2P 下载，都是&lt;strong&gt;让每个下载者分享资源片段，从而拼凑出一个完整的资源，下载者既是资源的消费者，又是资源的传播者。&lt;/strong&gt;他们之间的区别仅仅是&lt;strong&gt;寻找其他下载者的方式不同&lt;/strong&gt;。由于篇幅的原因，本文便不详细介绍磁力链接查找下载者的方式了，有兴趣的小伙伴们可以搜索相关的资料学习下。&lt;/p&gt;&lt;h3&gt;发展&lt;/h3&gt;&lt;p&gt;看到这想必你对 BT 种子已经有了一定的了解了。其实 BT 技术早已涉及我们生活的方方面面了，以在线游戏为例，有些在线游戏的在线更新（如魔兽世界）就是采用 BT 的技术。所以当每次有改版时，动辄数百 MB 的更新档，透过游戏厂商所提供的更新程序，以 BT 的方式进行下载分流。这为以往的其他种在线游戏，每次重大改版就必须重新压制光盘，或是等待单一下载点的下载方式，带来另一种节省成本的经营模式。&lt;/p&gt;&lt;p&gt;技术是把双刃剑，利用 BT 传播非收费性内容的好处有目共睹，但利用 BT 免费发布著作权内容肯定损害著作权所有者的合法权益，因此是否应因此立法全面禁止 BT 仍然是一个焦点问题。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;169&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.5362563237774031&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzgjVsz4716uLlBxK4ibbhqcU7eXy1oXssocicw6Jq9o4XafnyoxJnTpMP5kdRQU8AR3PKPph4eFBdA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;593&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;对于大多数 85 后，90 后来说，第一次接触 BT 种子想必和一个名为“快播”的播放器是脱不了干系的，我至今仍然记得王欣的那句技术本无罪。其实 Facebook 创立之初就是为了找到好看的女生，BT 的也是靠着他的作者科亨收集了些免费的色情电影才吸引到更多的人来测试他的程序，不得不说，某种程度上，ghs 真的促进了互联网技术的发展。&lt;/p&gt;&lt;h2&gt;最后&lt;/h2&gt;&lt;p&gt;以上就是本文的全部内容了，如果你觉得还不错的话，欢迎点赞关注转发支持一波，你们的支持是我肝文的最大动力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>