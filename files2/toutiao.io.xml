<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>812e47fdbac33faffa4f87f7ff4a6b58</guid>
<title>[译] 如何优化您的日常决策</title>
<link>https://toutiao.io/k/88ebc7h</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;Post-body&quot;&gt;
                    &lt;p&gt;当今的生活和工作都是&lt;strong&gt;快节奏&lt;/strong&gt;的，人们每天都会遇到各种各样的事情，并需要做出做相应的&lt;strong&gt;决策&lt;/strong&gt;：哪些事情先做，哪些事情后做，哪些事情应该做，哪些事情不应该做。前些天有读到一篇文章：&lt;a href=&quot;https://jamesclear.com/design-default&quot; rel=&quot; nofollow ugc&quot;&gt;How to Optimize Your Daily Decisions&lt;/a&gt;，作者所做的思考，以及给出的建议，不仅通俗易懂，而且也方便用于日常工作、生活。因此有翻译成中文，分享给有需要的朋友；以下是原文。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lovejade.oss-cn-shenzhen.aliyuncs.com/decisions.png&quot; title=&quot;&quot; alt=&quot;如何优化您的日常决策&quot;/&gt;&lt;/p&gt;

&lt;p&gt;您可能会假设人们购买产品是因为它们是什么，但事实是，我们经常购买东西是因为它们的位置。例如，与视线齐平的商店货架上的商品往往比不太显眼的货架上的商品购买得更多。&lt;/p&gt;

&lt;p&gt;在畅销书 &lt;a href=&quot;https://jamesclear.com/book/nudge&quot; rel=&quot; nofollow ugc&quot; title=&quot;理查德·塞勒 (Richard Thaler) 和卡斯·桑斯坦 (Cass Sunstein) 的推动&quot;&gt;Nudge&lt;/a&gt; ( &lt;a href=&quot;https://jamesclear.com/ebook/nudge&quot; rel=&quot; nofollow ugc&quot; title=&quot;轻推电子书&quot;&gt;Kindle&lt;/a&gt; | &lt;a href=&quot;https://jamesclear.com/audiobook/nudge&quot; rel=&quot; nofollow ugc&quot; title=&quot;轻推有声读物&quot;&gt;Audiobook&lt;/a&gt; ) 中，作者 Richard Thaler 和 Cass Sunstein 解释了我们日常决策受周围世界影响的各种方式。视线水平的货架对我们购买习惯的影响只是一个例子。&lt;/p&gt;

&lt;p&gt;这是另一个：&lt;/p&gt;

&lt;p&gt;过道的尽头是零售商的赚钱机器。根据《纽约时报》引用的数据，可口可乐 45% 的销售额专门来自过道尽头的货架。&lt;/p&gt;

&lt;p&gt;这就是为什么这很重要：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一些东西&lt;/strong&gt;必须放在与视线齐平的架子上。必须在过道尽头的架子上放&lt;em&gt;一些东西&lt;/em&gt;。某些东西必须是默认选择。某些东西必须是最能见度和最突出的选项。这不仅适用于商店，而且适用于我们生活的几乎每个领域。您的办公室、汽车、厨房和客厅都有默认选择。&lt;/p&gt;

&lt;p&gt;我的论点是这样的：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果你为生活中的默认而设计，而不是接受交给你的任何东西，那么过上更好的生活会更容易&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;现在让我们谈谈如何做到这一点。&lt;/p&gt;

&lt;h2&gt;默认设计&lt;/h2&gt;

&lt;p&gt;尽管我们中的大多数人在任何特定时刻都有做出广泛选择的自由，但我们经常根据所处的环境做出决定。&lt;/p&gt;

&lt;p&gt;例如，如果我想这样做，我可以在写这篇文章时喝一杯啤酒。但是，我目前坐在办公桌前，旁边放着一杯水。看不到啤酒。虽然我有能力起床、步行到我的车、开车去商店和买啤酒，但我可能不会，因为我周围有更简单的选择——即饮用水。在这种情况下，喝一口水是默认的决定，很容易的决定。&lt;/p&gt;

&lt;p&gt;考虑在您的个人和职业生涯中如何设计您的默认决定。例如：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;如果您睡觉时将手机放在床边，那么醒来后立即查看社交媒体和电子邮件可能是默认决定。&lt;/li&gt;
&lt;li&gt;如果你走进你的客厅，你的沙发和椅子都面向电视机，那么看电视很可能是默认的决定。&lt;/li&gt;
&lt;li&gt;如果您在厨房里放酒，那么持续饮酒更有可能成为默认决定。&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;当然，默认值也可以是正数。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;如果你在工作时在办公桌旁边放一个哑铃，那么做一些快速的弯举更有可能是默认的决定。&lt;/li&gt;
&lt;li&gt;如果你全天都带着水瓶，那么喝水而不是苏打水更有可能是默认的决定。&lt;/li&gt;
&lt;li&gt;如果您将牙线放在可见的位置（例如牙刷旁边），则使用牙线更可能是默认决定。&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;研究人员将环境违约对我们决策的影响称为&lt;a href=&quot;https://jamesclear.com/choice-architecture&quot; rel=&quot; nofollow ugc&quot; title=&quot;选择架构&quot;&gt;选择架构&lt;/a&gt;。重要的是要意识到您可以成为您选择的架构师。您可以设计为默认。&lt;/p&gt;

&lt;h2&gt;如何优化您的默认决策&lt;/h2&gt;

&lt;p&gt;以下是我在尝试为我的生活中的默认设计时发现的一些有用的策略：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;简单&lt;/strong&gt;。当您经常被噪音包围时，很难将注意力集中在信号上。当你的厨房里堆满垃圾食品时，要吃得健康就更难了。当您在浏览器中打开 10 个选项卡时，更难以专注于阅读博客文章。当您陷入&lt;a href=&quot;https://jamesclear.com/multitasking-myth&quot; rel=&quot; nofollow ugc&quot; title=&quot;多任务处理的神话：为什么更少的优先级会导致更好的工作&quot;&gt;一心多用的神话&lt;/a&gt;时，完成最重要的任务就更加困难了。如有疑问，消除选项。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;视觉提示&lt;/strong&gt;。在超市中，将商品放在与视线齐平的货架上会使它们更具视觉效果并且更有可能被购买。在超市之外，您可以使用诸如&lt;a href=&quot;https://jamesclear.com/paper-clips&quot; rel=&quot; nofollow ugc&quot; title=&quot;如何通过使用回形针策略坚持每天的好习惯&quot;&gt;回形针法&lt;/a&gt;或&lt;a href=&quot;https://jamesclear.com/stop-procrastinating-seinfeld-strategy&quot; rel=&quot; nofollow ugc&quot; title=&quot;如何使用宋飞正传策略停止拖延你的目标&quot;&gt;宋飞策略之&lt;/a&gt;类的视觉提示来创建一个环境，在视觉上将您的行为推向正确的方向。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;选择退出与选择加入&lt;/strong&gt;。有一项&lt;a href=&quot;https://jamesclear.com/environment-design-organ-donation&quot; rel=&quot; nofollow ugc&quot; title=&quot;器官捐献与环境设计&quot;&gt;著名的器官捐赠研究&lt;/a&gt;揭示了多个欧洲国家如何提高器官捐赠率：他们要求公民选择不捐赠而不是选择捐赠。通过提前让未来的自己养成更好的习惯，你可以在生活中做一些类似的事情。例如，您可以将瑜伽课程安排在下周，而您今天感到有动力。当您的锻炼开始时，您必须证明选择退出是合理的，而不是激励自己选择加入。&lt;/p&gt;

&lt;p&gt;默认设计归结为一个非常简单的前提：改变你的环境，让好的行为更容易，坏的行为更难。&lt;/p&gt;

&lt;h2&gt;为您设计与由您设计&lt;/h2&gt;

&lt;p&gt;默认选择本身并不坏，但整个世界的设计都没有考虑到您的目标。事实上，许多公司的目标与您的目标直接竞争（食品公司可能希望您购买他们的薯片袋，而您想减肥）。出于这个原因，您应该谨慎接受每一个默认值，就好像它应该是最佳选择一样。&lt;/p&gt;

&lt;p&gt;我通过过自己设计的生活而不是接受别人给我的标准生活，从而获得了更多的成功。质疑一切。你需要改变、调整和改变你的环境，直到它符合你想要的生活。&lt;/p&gt;

&lt;p&gt;是的，你周围的世界塑造了你的习惯和选择，但有一件重要的事情需要意识到：首先必须有人来塑造这个世界。现在，有人可以是你。&lt;/p&gt;

&lt;p&gt;如果你想要更多关于改掉坏习惯和养成好习惯的实用想法，请查看我的书&lt;a href=&quot;https://jamesclear.com/book/atomic-habits&quot; rel=&quot; nofollow ugc&quot;&gt;原子习惯&lt;/a&gt;，它会告诉你习惯的微小改变如何带来显着的结果。&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;通过该文的阅读，可以给生活、工作带来哪些启示？下面跟大家分享一些（如您有更多建议，欢迎留言分享）：&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;定时对浏览器所打开的页面，加以阅读、消化、整理，然后关闭；从而提升专注；&lt;/li&gt;
&lt;li&gt;不再将短视频、微信等浪费时间，却没有太大价值的应用，放置手机桌面显眼位置；&lt;/li&gt;
&lt;li&gt;如您也有游戏瘾，周末将至，列出读一本书，或看几部电影的计划，尽量不去想玩游戏这事儿；&lt;/li&gt;
&lt;li&gt;如一定要玩儿，那么再玩了几盘，尽兴之后，删除游戏，让下次打开游戏，变得困难......&lt;/li&gt;&lt;/ol&gt;
                &lt;/div&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e63eede9020243e8a06784ed26e9eccb</guid>
<title>近期做的稳定性建设总结</title>
<link>https://toutiao.io/k/ic0wg6u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;背景&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;近期业界频繁出现较大的稳定性事故，引发社会舆情。湖北十堰也发生了安全的大事故。海因里希法则告诉我们：一件重大事故的背后总是有29件轻微事故+300件潜在隐患。我们要把这些事件当做镜子做好自身的稳定性建设。&lt;/section&gt;&lt;section&gt;我们的项目目前平稳运行，架构设计上也能满足现阶段的需求。所以近期做的稳定性建设并非轰轰烈烈的大事件，却对未来的长远稳定性至关重要。如果一个工程或者项目需要做大手术了，甚至派上了公司级的专家一起来建设，那直接说明之前做的太烂了，遇到了大问题，估计要走马换将了。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;很多朋友听到这里就会很无奈，在上一篇&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485721&amp;amp;idx=1&amp;amp;sn=8cac3b1db8338b9f0ba4e50db65945ce&amp;amp;chksm=fafde3b7cd8a6aa1805193fc1b2115285ad1c5362dcaa4097fc11de4947e2e37d4449e2d9602&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《社招面试的架构分析》&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《社招面试的架构分析》&lt;/a&gt;里，我也提到社招面试中很大一部分比重是要介绍自己实际做的项目业绩。做这些小事能有业绩吗？以后有什么值得说的吗？我的回答是：太有了。&lt;/section&gt;&lt;section&gt;&lt;img data-backh=&quot;210&quot; data-backw=&quot;509&quot; data-ratio=&quot;0.4125560538116592&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicnnsx1NRszaH7tOYc9e8rLjmC7iccpGjLMvGQ14R30a2DWg1UbjdibWrviakwU0PjOBpNic6NHhRibyNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;/section&gt;&lt;section&gt;一个好的项目从功能演进方面大体经历：支撑业务、快速支撑业务、引领业务三个阶段。从稳定性建设来说，大体经历从0-1的基本稳定阶段和1到无限的稳定性加固阶段。“稳定性是第一性”，一旦稳定性出现问题，我们的功能演进就会回退到疲于奔命的支撑业务阶段。由于本篇文章功能演进不是重心，所以只告诉大家可以在面试中这么跟面试官讲：&lt;br/&gt;&lt;/section&gt;&lt;section&gt;我们的项目稳定性不错，日交易量十几个亿的情况下，SLA5个9以上。假设我们的系统连续5分钟系统成功率低于50%，就需要上报科技司、国务院了，所以我们有严格的事故定级标准，从最高的s0到最低的s9。s9定级要求影响总交易在5笔以下。实际上我在任的三年没有出过s9及以上的事故。(这里只是举个例子，大家还是要照自己的实际情况描述，要点是我们的系统很重要，对稳定性要求很高，这个场景下还做的不错。做的都是交易量不大的项目也不用担心，面试官关心的是从表述中体现出来的：格局、站位、层面和视野)&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总体思路&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;1、独立出运维工程，将保障逻辑和业务逻辑分离，保障逻辑频繁迭代更新不影响业务逻辑稳定性&lt;/p&gt;&lt;p&gt;2、制定日志规范，新增集中采集日志，并据此新增监控告警，比外部先发现问题，并可以方便的进行问题排查和统计&lt;/p&gt;&lt;p&gt;3、规范和梳理现有监控告警，查缺补漏，合理设定告警阈值和级别，提高告警敏感度&lt;/p&gt;&lt;p&gt;4、告警治理，现有隐患各个击破，将平时告警数降为0&lt;/p&gt;&lt;p&gt;5、合理根据业务增长情况进行扩容&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;细节FAQ&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;这里举几个在方案评审时被问到的问题和回复以及具体实施过程中遇到问题的排查的解决思路用问答的形式表述如下：&lt;br/&gt;&lt;/section&gt;&lt;p&gt;Q1：在日志规范中规定在请求的开始和结束都需要打印日志，结束日志的内容包含了开始日志的内容，打印开始日志的意义是什么？&lt;/p&gt;&lt;p&gt;A：快速排查定位问题的需要&lt;/p&gt;&lt;section&gt;在需要对问题进行排查定位的场景，可以快速清晰的看到整个请求的过程。包括什么时间点接收到请求、什么时间点处理请求。&lt;/section&gt;&lt;section&gt;针对这个问题同学发起了连环问，问我结束时间-cost不就是开始时间吗？&lt;br/&gt;&lt;/section&gt;&lt;section&gt;是的，但是在实际排查问题的场景，需要尽量减少人工转换，快速定位，牺牲一点存储降低排查难度是值得的。同时，针对处理中间出现了问题，没有达到请求结束的场景，也可以定位到出现问题的环节。&lt;/section&gt;&lt;section&gt;连环问继续：如果是请求没有达到结束，直接try catch finally来处理，或者是通过请求成功率就可以定位了呀？&lt;br/&gt;&lt;/section&gt;&lt;section&gt;我们的try catch建议是catch exception，但是实际情况中有可能发生error级别的异常，这时候未必可以走到finally。我们没有必要在所有的场景都加上try catch还是要根据实际需要。如果请求出现成功率下降，那么影响的不是一笔交易，在需要针对具体一笔进行排查的时候，我们怎么知道请求成功率影响的是哪一笔呢？当然，通过复杂的排查和计算是可以最终实现定位的，但是我们要快速定位，尽量减少对开发人员的技术要求。同时，从容灾容错上考虑，我们需要对监控机制进行容灾，万一一个监控机制发生了问题，也可以最终定位到问题。这就是为什么系统有zabbix监控、&lt;span&gt;Prometheus监控等多项监控共存，指标上和角度上有区别也有重复，区别是为了根据具体场景快速定位，重复是为了容灾一个监控组件出现了问题也能定位。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Q2：收到一个可用内存不足10%的告警，经过了两个小时才自动恢复到87%，所在的机器出现一笔请求超时&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;A：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现象&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1&amp;gt;对业务进行了解发现开始出现问题的时间点，有收到外部MQ发过来的大报文，虽然报文做了分片但是每个分片还是有几M大并且下发条数多，集中下发。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2&amp;gt;分别在问题机器和其他相同应用的不同机器上执行top命令，观察到问题机器和其他机器上jvm内存占用差不多并且稳定。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3&amp;gt;执行free -h命令观察到cache/buffer下降到1G以下，内存使用率的计算规则是(1-available)/total。available虽然大家都说是大体上等于free+buffer/cache。因为buffe/cache可以快速被释放。但是实际上当cache/buffer下降到一定数值，available的值远远小于&lt;span&gt;free&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;buffer&lt;/span&gt;&lt;span&gt;/cach&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;。本次问题发生的时间点，机器可用内存7.6G，&lt;span&gt;free&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;buffer&lt;/span&gt;&lt;span&gt;/cach&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;下降了200M，但是available却下降了500M多。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4&amp;gt;&lt;span&gt;收到外部MQ发过来的大报文&lt;/span&gt;时间段网卡占用情况从平时0.5M以下飙升到20M TPS&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;5&amp;gt;&lt;span&gt;出现一笔请求超&lt;/span&gt;&lt;span&gt;时正在下发大报文的高峰期，请求方发请求到机器接收到请求时间间隔是几毫秒。收到请求后机器会将请求转发给MQ，用了3秒多。而请求方设置了5秒超时。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;6&amp;gt;所有环节cpu使用率都很低&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;7&amp;gt;20天前在另外一台机器上也发生了内存升高到90%以上的现象&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;分析&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;此问题的根本原因是外部短时间内下发大量大报文(受节假日影响当天的报文略高于其他天)，从根本上治理需要和外部(大佬级别，我们完全没有主动权)一起进行架构方面的调整，不现实也没有必要用此牛刀。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;表现为虚机层面内存资源不足，影响了IO速率。因为高峰IO TPS20M，针对现在的千兆网卡、万兆网卡来说，并不大。问题并不在网络通道上，而在机器本身。而IO需要大量内存：内核态和用户态之间数据传输等环节的数据拷贝。研究过NIO、netty、linux内核等技术的应该都知道：IO无非就是分配内存、操作fd文件描述符和调用中断等命令的过程。因为现象中可以看到&lt;span&gt;jvm&lt;/span&gt;&lt;span&gt;内存&lt;/span&gt;&lt;span&gt;是没有问题的&lt;/span&gt;，这里的瓶颈就在系统内存不足上。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以短期我们制定SOP/EOP，应对临时问题。中期提申请进行纵向扩容。纵向扩容说白了就是增加物理内存。有人就要问了是不是扩机器数量也能解决问题。这种处理方式大概是能治病但是不一定对症。意思可以理解为吃广谱抗菌药来治疗感冒，有一定帮助但不是针对性的处理。因为扩机器是减少了请求数从而减少了内存占用量。但是万一有个大请求就是把内存飚高了呢？linux的设计如果内存高到一定程度自身的很多功能会受到影响，导致不符合预期。需要从根本上升高内存。并且扩内存实施成本更低，不需要程序的发布。就是低峰期暂停程序，插个内存条。当然，长期上业务量在上涨，但是我们还没有进行水平扩容。需要我们计算业务增长量进行合理扩机器。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有的朋友会觉得这个处理方式并不高大上。牛逼的处理方式是调整个linux参数啥的。现在也算比较流行的一个词叫做：不可变服务器。&lt;span&gt;“传统”的部署方式中，对系统的改动都会呈现在服务器上，从而增加了风险。&lt;/span&gt;&lt;span&gt;采用不可变部署方式，&lt;/span&gt;服务器都是公司统一标准化的，那么变更只要考虑应用程序的发布，而应用程序一旦发布也不允许改变，就成了不可变服务。不可变性可以增加系统的稳定性。在一个规模比较大的公司，就算可以通过技术解决资源的问题，从整体角度，还是通用方案更加可取。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Q3：有个MQ服务偶尔会在并发量高的情况下有响应耗时高的问题，这个MQ是闭源的收费服务。怀疑是内部实现用的是短连接造成的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;A：排查人员review代码发现每次发送消息都调用了close方法，怀疑是短连接造成的。首先来说close方法有没有直接把连接关闭不能从名称上来判断，还是需要看实现。比如连接池方式的close实现实际上是把连接归还了连接池。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以使用netstat命令观察连接的状态，如果状态一直是established，应该是长连接。具体建立了几个长连接就看对应的&lt;span&gt;establish&lt;/span&gt;&lt;span&gt;ed&lt;/span&gt;的数量。具体原理就是常见的一个面试考题了：TCP三次握手：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6014418125643667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicBQKq12r4ibHKbDaRFmvNFSAQuhJKibWW5XtIQuqECVa8ZOSGokiarl0e0LUXsbVb0BUm0HR4atE1nw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;971&quot;/&gt;&lt;/p&gt;&lt;p&gt;TCP四次挥手：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6495238095238095&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicBQKq12r4ibHKbDaRFmvNFSrwEuqibuaZJZmwx2Jcm4yia3mHHtuib3BEhKic4ZI5YFDibvzb0lyFOmMOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;525&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;看netstat的状态就可以了解处于TCP的哪个阶段了。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;相关阅读&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>65c9716f5112485d2dbb749cbfed662e</guid>
<title>Ethers.js 非权威开发指南（下）</title>
<link>https://toutiao.io/k/jqofcc1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;container wrapper post&quot;&gt;&lt;div class=&quot;post-header&quot;&gt;&lt;h1 class=&quot;title&quot;&gt;Ethers.js 非权威开发指南（下）&lt;/h1&gt;&lt;p class=&quot;meta&quot;&gt;胡键 Posted at — Jun 20, 2021
&lt;span class=&quot;meta&quot; id=&quot;busuanzi_container_page_pv&quot;&gt;阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;p class=&quot;share-component&quot; data-sites=&quot;qq,weibo,wechat,douban,twitter,facebook&quot; data-description=&quot;Share.js - 一键分享到微博，QQ空间，腾讯微博，人人，豆瓣&quot;/&gt;&lt;div class=&quot;markdown&quot;&gt;&lt;p&gt;本系列的&lt;a href=&quot;./ethersjs-indefinitive-guide-part1.html&quot;&gt;上篇&lt;/a&gt;已经展示了连接钱包，调用合约和确定交易状态的全过程，对于一般的 dapp 开发已经完全足够。但对于有格调的开发者来讲，这些还不足以满足他们的胃口。那么，在下篇，你们将看到一些更加高级和特别的东西：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如何处理以太坊的事件？&lt;/li&gt;&lt;li&gt;如何监听特定合约的特定事件？&lt;/li&gt;&lt;li&gt;如何查询以太坊的过往历史？&lt;/li&gt;&lt;li&gt;如何获取导致交易产生的合约函数的输入参数？&lt;/li&gt;&lt;li&gt;对于高阶合约函数（即，接受另一个合约的函数为输入值），该如何调用？&lt;/li&gt;&lt;li&gt;如何实现签名（含 EIP712）？&lt;/li&gt;&lt;li&gt;如何获得某个账户的公钥？&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;相信以上这些重口味问题的答案应该不会让各位失望。&lt;/p&gt;&lt;h2 id=&quot;监听事件&quot;&gt;监听事件&lt;/h2&gt;&lt;p&gt;通常，事件监听的需求来自于朴素的诉求：及时得到状态更新的通知。这种需求不仅仅局限于异步方法的调用，对于稍微复杂的一些程序，事件机制的引入也会让整个应用的架构得到简化。&lt;/p&gt;&lt;p&gt;Ethers.js 在 Provider 和 Contract 层面都提供了事件的支持，并且方法名称也有重叠。其中用得较多的方法如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;on&lt;/code&gt;，对特定事件添加监听器。&lt;/li&gt;&lt;li&gt;&lt;code&gt;off&lt;/code&gt;，移除某事件全部监听器。&lt;/li&gt;&lt;li&gt;&lt;code&gt;once&lt;/code&gt;，添加事件监听器，并且在事件处理完成后自动移除。它和 &lt;code&gt;on&lt;/code&gt; 的区别在于：&lt;ul&gt;&lt;li&gt;&lt;code&gt;on&lt;/code&gt; 没有移除事件监听器这一步骤，会继续监听后续事件；&lt;/li&gt;&lt;li&gt;&lt;code&gt;once&lt;/code&gt; 处理完当前事件之后，不再监听，对后续到来的事件不再处理；&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;dapp-典型的监听事件架构&quot;&gt;dapp 典型的监听事件架构&lt;/h3&gt;&lt;p&gt;虽然 Provider 和 Contract 提供了监听以太坊事件的方法，但要是不加区分到处引用这两个对象来添加事件处理函数，整个应用的代码仍不可避免地会陷入混乱。通常的做法都会结合前端框架的状态管理来做，实现上层业务代码和底层合约代码的解耦，同时又能及时得到通知。&lt;/p&gt;&lt;p&gt;通常做法如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;定义状态管理涉及的业务对象，此过程类似 db 或者 domain 的设计。&lt;/li&gt;&lt;li&gt;在事件处理函数内，基于所监听的事件，更新对应的状态对象。&lt;/li&gt;&lt;li&gt;在业务代码部分订阅业务对象的更新事件，在该事件处理函数内完成页面状态更新。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;对于 Angular 来讲：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;状态更新部分涉及对象&lt;/li&gt;&lt;/ol&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-fallback&quot; data-lang=&quot;fallback&quot;&gt;Provider / Contract EventListners &amp;gt; Akita Service
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;订阅状态更新涉及对象&lt;/li&gt;&lt;/ol&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-fallback&quot; data-lang=&quot;fallback&quot;&gt;Akita Query &amp;gt; Subscribers
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于 Svelte 来讲，更简单，整个过程简化为：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-fallback&quot; data-lang=&quot;fallback&quot;&gt;Provider / Contract EventListners &amp;gt; Store  &amp;gt; Reactive 语句 / 变量
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为对 React 和 Vue 不熟，这里就此略过，但机制应该都是一样的。&lt;/p&gt;&lt;h3 id=&quot;使用-provider-监听&quot;&gt;使用 Provider 监听&lt;/h3&gt;&lt;p&gt;Provider 适合粗放型事件监听，值得注意的几个事件：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;block&lt;/code&gt;，新区块生成&lt;/li&gt;&lt;li&gt;&lt;code&gt;error&lt;/code&gt;，错误发生&lt;/li&gt;&lt;li&gt;&lt;code&gt;txHash 值&lt;/code&gt;，tx 被确认&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;其他事件请参见 Ethers.js 的文档。&lt;/p&gt;&lt;p&gt;一般来讲，你不会需要上面的第三个事件（即&lt;code&gt;txHash 值&lt;/code&gt;），采用&lt;a href=&quot;./ethersjs-indefinitive-guide-part1.html&quot;&gt;本系列上篇&lt;/a&gt;中介绍的方法要更简单一些。&lt;/p&gt;&lt;p&gt;&lt;code&gt;block&lt;/code&gt; 事件在你需要一口气跟踪多个状态时最为有效，比如一次交易的变化可能导致多个地方的状态发生变化：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;账户余额&lt;/li&gt;&lt;li&gt;交易对内部双边余额的变化&lt;/li&gt;&lt;li&gt;计价合约的参数变化&lt;/li&gt;&lt;li&gt;……&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;note&quot;&gt;&lt;p&gt;&lt;strong&gt;本文是付费文章，剩余内容请访问以下链接支付之后继续阅读：&lt;/strong&gt;&lt;/p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/vwhXB3ZmHQD5r_y-3BfRkg&quot;&gt;付费链接&lt;/a&gt;&lt;p&gt;
（已付费：1）&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>77290d22c9ca90ece1309b39017f6af9</guid>
<title>在 Golang 中是锁或 Channel 还是 Atomic</title>
<link>https://toutiao.io/k/4ycv1d9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;  与其他编程语言一样在并发环境下如不对多个&lt;strong&gt;goroutine&lt;/strong&gt;（线程）访问或修改的共享资源元素的进行控制，让进入&lt;strong&gt;临界区&lt;/strong&gt;的对象互斥。就可能会出现数据异常情况；&lt;br/&gt;  一个&lt;strong&gt;非线程安全&lt;/strong&gt;对象如下，如不对Id的访问进行控制，多个goroutine进行更新Id字段是就会出现数据不一致的情况，如下示例：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Conf &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;  Id &lt;span&gt;int32&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;func&lt;/span&gt;(c *Conf)&lt;span&gt;update&lt;/span&gt;(n &lt;span&gt;int32&lt;/span&gt;){&lt;br/&gt;  c.Id +=n&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  启动100个goroutine用于更新对象c中的Id字段值，此时由于出现&lt;strong&gt;多个协程同时进入临界区&lt;/strong&gt;同时对Id变量进行修改。导致对象c中的Id字段值出现了不可预知的情况。此时程序输出的结果可能是：98、93、95等；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;() {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; c=&amp;amp;Conf{}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := 0; i&amp;lt;100;i++  {&lt;br/&gt;&lt;span&gt;go&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;(n &lt;span&gt;int&lt;/span&gt;) {&lt;br/&gt;&lt;span&gt;//模拟停顿&lt;/span&gt;&lt;br/&gt;time.Sleep(1*time.Millisecond)&lt;br/&gt;c.update(1)&lt;br/&gt;}(i)&lt;br/&gt; }&lt;br/&gt;time.Sleep(10*time.Second)&lt;br/&gt;fmt.Println(c.Id)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  下面分别使用锁与channel对临界区进行并发控制，使得输出得到正常的结果，并简单对比两者的性能；&lt;/p&gt;&lt;h2&gt;使用锁&lt;/h2&gt;&lt;p&gt;  现在在结构体Conf中添加一个读写锁变量sync.RWMutex，此时Conf继承了RWMutex中所有的方法字段等。通过此对象就可以对Id变量的访问进行加锁， struct变为如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Conf&lt;/span&gt; struct {&lt;br/&gt;  &lt;span&gt;Id&lt;/span&gt; &lt;span&gt;int32&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;sync&lt;/span&gt;.&lt;span&gt;RWMutex&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;定义一个新方法，此方法使用了锁对临界区访问进行了并发控制：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt;(&lt;span&gt;c&lt;/span&gt; *Conf) updateOfLock(n int32){&lt;br/&gt;   &lt;span&gt;c&lt;/span&gt;.&lt;span&gt;Lock&lt;/span&gt;()&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;c&lt;/span&gt;.&lt;span&gt;Unlock&lt;/span&gt;()&lt;br/&gt;   &lt;span&gt;c&lt;/span&gt;.&lt;span&gt;Id&lt;/span&gt; +=n&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  此时程序总是能够输出正确的结果：100&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;() {&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; c=&amp;amp;Conf{}&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i := 0; i&amp;lt;100;i++  {&lt;br/&gt;&lt;span&gt;go&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;(n &lt;span&gt;int&lt;/span&gt;) {&lt;br/&gt;&lt;span&gt;//模拟停顿&lt;/span&gt;&lt;br/&gt;time.Sleep(1*time.Millisecond)&lt;br/&gt;c.updateOfLock(1)&lt;br/&gt;}(i)&lt;br/&gt;}&lt;br/&gt;time.Sleep(10*time.Second)&lt;br/&gt;fmt.Println(c.Id)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;使用channel&lt;/h2&gt;&lt;p&gt;  用channel控制临界资源的访问，原理也非常简单，创建一个长度为1的channel变量，进去临界区前往channel中写入一个值，由于长度为1，此时别的协程将无法往channel中写入值堵塞在此处channel上，前一个协程访问完临界区后从channel读取值，此后别的协程可再此往channel中写入值，从而能够进入临界区，结构体修改如下；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Conf &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;   Id &lt;span&gt;int32&lt;/span&gt;&lt;br/&gt;   lockChan &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; (c *Conf) &lt;span&gt;updateOfChannel&lt;/span&gt;(n &lt;span&gt;int32&lt;/span&gt;) {&lt;br/&gt;   c.lockChan&amp;lt;-&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;() {&amp;lt;-c.lockChan}()&lt;br/&gt;   c.Id +=n&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  使用channel进行并发控制，需要注意取出lockChan中的值，此处使用了defer用于控制channel值的释放。&lt;/p&gt;&lt;pre&gt;&lt;code&gt; &lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; c=&amp;amp;Conf{lockChan: &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;,1)}&lt;br/&gt;     &lt;span&gt;for&lt;/span&gt; i := 0; i&amp;lt;100;i++  {&lt;br/&gt;&lt;span&gt;go&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;(n &lt;span&gt;int&lt;/span&gt;) {&lt;br/&gt;&lt;span&gt;//模拟停顿&lt;/span&gt;&lt;br/&gt;time.Sleep(1*time.Millisecond)&lt;br/&gt;c.updateOfChannel(1)&lt;br/&gt;}(i)&lt;br/&gt;     }&lt;br/&gt;time.Sleep(10*time.Second)&lt;br/&gt;fmt.Println(c.Id)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;原子变量&lt;/h2&gt;&lt;p&gt;  无需修改Conf结构体，直接调用atomic的相关方法即可，方法如下，此时也是能够得到正确的值；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;  &lt;span&gt;func&lt;/span&gt; (c *Conf) &lt;span&gt;updateOfAtomic&lt;/span&gt;(n &lt;span&gt;int32&lt;/span&gt;) {&lt;br/&gt;    atomic.AddInt32(&amp;amp;c.Id,n)&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;性能简单对比&lt;/h3&gt;&lt;p&gt;  通过跑Golang基准测试看看锁、原子变量、channel三者的性能如何，毫无疑问原子变量肯定是性能最好的，这是对底层的CAS操作连临界区都没有产生；这里主要对比锁与channel性能，三个测试函数都和下函数类似；&lt;/p&gt;&lt;pre&gt;&lt;code&gt; &lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkAtomicTest&lt;/span&gt;(b *testing.B) {&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; &lt;span&gt;c&lt;/span&gt;=&amp;amp;&lt;span&gt;Conf&lt;/span&gt;{}&lt;br/&gt;     &lt;span&gt;for&lt;/span&gt; i := 0; i&amp;lt;b.&lt;span&gt;N&lt;/span&gt;;i++  {&lt;br/&gt;       &lt;span&gt;c&lt;/span&gt;.updateOfAtomic(1)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  此时可以看到毫无悬念的atomic原子操作的方式性能最高，比其他两种低一个数量级，锁的方式比channel时间快了一倍，每次平均执行时间只需44.45纳秒，而channel每次需要84.12ns纳秒；当然此处的只是简单对比；&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;img data-ratio=&quot;0.3783783783783784&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mGZDOXnuCWze9Afwt0UUyXB5Tlu84eK2YDF0sOXBN1u80sxq7A02rrt3oQZStFu9Sxx24A7HE6kc4a5fb2VOPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;666&quot;/&gt;&lt;/p&gt;&lt;p&gt;  能用atomic时肯定是用atomic，至于锁和channel选哪个，还是要看应用场景、业务逻辑、可维护性等，总体来说两者性能差别不算太大，如果不太熟悉channel在过于复杂的业务逻辑中channel或许可读性会降低；但golang中的两个核心就是goroutine和channel；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7a3acff39791502f1a954dcdaf4eeb2b</guid>
<title>一文理解 MySQL 的锁机制与死锁排查</title>
<link>https://toutiao.io/k/gnbgq3w</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-source-line=&quot;1&quot;&gt;MySQL的并发控制是在数据安全性和并发处理能力之间的权衡，通过不同的锁策略来决定对系统开销和性能的影响。&lt;/p&gt;&lt;h2 data-source-line=&quot;3&quot;&gt;基础知识&lt;/h2&gt;&lt;p data-source-line=&quot;5&quot;&gt;为了后续的解释更加容易理解，这里列举一些基本概念的解释。&lt;/p&gt;&lt;h3 data-source-line=&quot;7&quot;&gt;悲观锁&lt;/h3&gt;&lt;p data-source-line=&quot;9&quot;&gt;悲观锁指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。&lt;/p&gt;&lt;p data-source-line=&quot;11&quot;&gt;select...for update是MySQL提供的实现悲观锁的方式。在悲观锁的情况下，为了保证事务的隔离性，其它事务无法修改这些数据。&lt;/p&gt;&lt;blockquote data-source-line=&quot;13&quot;&gt;&lt;p&gt;现在互联网高并发的架构中，受到fail-fast思路的影响，悲观锁已经比较少见了。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-source-line=&quot;15&quot;&gt;乐观锁&lt;/h3&gt;&lt;p data-source-line=&quot;17&quot;&gt;相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。&lt;/p&gt;&lt;p data-source-line=&quot;19&quot;&gt;而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（Version）记录机制实现：通过为数据库表增加一个数字类型的&lt;code&gt;version&lt;/code&gt;字段，当读取数据时，将&lt;code&gt;version&lt;/code&gt;字段的值一同读出，数据每更新一次，对此&lt;code&gt;version&lt;/code&gt;值+1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的&lt;code&gt;version&lt;/code&gt;值进行比对，如果数据库表当前版本号与第一次取出来的&lt;code&gt;version&lt;/code&gt;值相等，则予以更新，否则认为是过期数据，返回更新失败。&lt;/p&gt;&lt;h2 data-source-line=&quot;21&quot;&gt;锁的粒度&lt;/h2&gt;&lt;p data-source-line=&quot;23&quot;&gt;MySQL定义了两种锁的粒度：表级、行级。&lt;/p&gt;&lt;h3 data-source-line=&quot;25&quot;&gt;表锁&lt;/h3&gt;&lt;p data-source-line=&quot;27&quot;&gt;由MySQL Server控制，分为读锁和写锁。优点是开销小，加锁快；不会出现死锁；缺点是锁定粒度大，发生锁冲突的概率最高，并发度最低。表锁适合查询多、更新少的场景。&lt;/p&gt;&lt;p data-source-line=&quot;29&quot;&gt;当对表加了读锁，则会话只能读取当前被加锁的表，其它会话仍然可以对表进行读取但不能写入。&lt;/p&gt;&lt;p data-source-line=&quot;31&quot;&gt;当对表加了写锁，则会话可以读取或写入被加锁的表，其它会话不能对加锁的表进行读取或写入。&lt;/p&gt;&lt;h3 data-source-line=&quot;33&quot;&gt;行锁&lt;/h3&gt;&lt;p data-source-line=&quot;35&quot;&gt;由存储引擎实现，InnoDB支持，而MyISAM不支持。优点是开销大，加锁慢；会出现死锁；缺点是锁定粒度最小，发生锁冲突的概率最低，并发度也最高。InnoDB引擎下默认使用行级锁。行级锁适合按索引更新频率高的场景。&lt;/p&gt;&lt;p data-source-line=&quot;37&quot;&gt;InnoDB是MySQL最常用的存储引擎，本文以此为角度讲解MySQL的锁机制。有关MySQL存储引擎和有关B-Tree的知识，可以查看博客《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyNzgyNzAwNg==&amp;amp;mid=2247483969&amp;amp;idx=1&amp;amp;sn=03eef5982173baa0e8dba05c1549f401&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;彻底搞懂MySQL的索引&lt;/a&gt;》&lt;/p&gt;&lt;h2 data-source-line=&quot;40&quot;&gt;行锁的分类&lt;/h2&gt;&lt;h3 data-source-line=&quot;42&quot;&gt;1. 记录锁&lt;/h3&gt;&lt;p data-source-line=&quot;44&quot;&gt;记录锁（Record lock）在唯一索引列或主键列记录上加锁，且该值存在，否则加锁类型为间隙锁。例如&lt;code&gt;SELECT a FROM t WHERE a = 12 FOR UPDATE&lt;/code&gt;，对值为12的索引进行锁定，防止其它事务插入、删除、更新值为12的记录行。&lt;/p&gt;&lt;h3 data-source-line=&quot;46&quot;&gt;2. 间隙锁&lt;/h3&gt;&lt;p data-source-line=&quot;48&quot;&gt;间隙锁（Gap Lock），只有在可重复读、串行化隔离级别才有，在索引记录之间的间隙中加锁，或者是在某一条索引之前或者之后加锁，并不包括该索引本身。&lt;/p&gt;&lt;p data-source-line=&quot;50&quot;&gt;例如：&lt;code&gt;SELECT a FROM t WHERE a &amp;gt; 15 and a &amp;lt; 20 FOR UPDATE&lt;/code&gt;，且a存在的值为1、2、5、10、15、20，则将(15,20)的间隙锁住。&lt;/p&gt;&lt;p data-source-line=&quot;52&quot;&gt;间歇锁的范围：&lt;/p&gt;&lt;ol data-source-line=&quot;54&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;对主键或唯一索引当前读时，where条件全部精确命中(=或者in)，这种场景本身就不会出现幻读，所以只会加记录锁。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;没有索引的列当前读操作时，会加全表gap锁，生产环境要注意。（所有主键x锁，所有主键间隙gap锁）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;非唯一索引列，如果where条件部分命中(&amp;gt;、&amp;lt;、like等)或者全未命中，则会加附近Gap间隙锁。例如，某表数据如下，非唯一索引2,6,9,9,11,15。&lt;code&gt;delete from table where another_id = 9&lt;/code&gt;要操作非唯一索引列9的数据，gap锁将会锁定的列是(6,11)，该区间内无法插入数据。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;更多情况看文末的图片总结。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;59&quot;&gt;在使用范围条件检索并锁定记录时，间歇锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。&lt;/p&gt;&lt;p data-source-line=&quot;61&quot;&gt;间隙锁和间隙锁之间是互不冲突的，间隙锁唯一的作用就是为了防止其他事务的插入，在RR（可重复读）级别下解决了幻读的问题。&lt;/p&gt;&lt;p data-source-line=&quot;63&quot;&gt;例如id有3,4,5，间隙锁锁定id&amp;gt;3的数据，是指的4及后面的数字都会被锁定。这样的话加入新的数据id=6，就会被阻塞，从而避免了幻读。&lt;/p&gt;&lt;blockquote data-source-line=&quot;65&quot;&gt;&lt;p&gt;快照读与当前读将在下一篇博客《一文理解MySQL的事务原则与事务隔离》进行详解&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-source-line=&quot;67&quot;&gt;3. 临键锁&lt;/h3&gt;&lt;p data-source-line=&quot;69&quot;&gt;临键锁（Next-Key Lock）是记录锁和间隙锁的合集。只有在可重复读、串行化隔离级别才有。&lt;/p&gt;&lt;p data-source-line=&quot;71&quot;&gt;&lt;img data-ratio=&quot;0.4596774193548387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OqTAl3WTC7EbEQBRzIuuyOlamgzFW5ewDH52amtOsbdOhLjJuPhnDG3iaTdXNib4VjGGQ4GERjceTx6guwh3GTYA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;620&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;73&quot;&gt;例如一个索引有10,11,13,20这四个值。InnoDB可以根据需要使用记录锁将10，11，13，20四个索引锁住，也可以使用间隙锁将(-∞,10)，(10,11)，(11,13)，(13,20)，(20,+∞)五个范围区间锁住。而临键锁是记录锁和间隙锁的合集。&lt;/p&gt;&lt;h3 data-source-line=&quot;75&quot;&gt;4. 插入意向锁&lt;/h3&gt;&lt;p data-source-line=&quot;77&quot;&gt;插入意向锁（Insert Intention Locks），是一种特殊的间隙锁，只有在执行INSERT操作时才会加锁，插入意向锁之间不冲突，可以向一个间隙中同时插入多行数据，但插入意向锁与间隙锁是冲突的，当有间隙锁存在时，插入语句将被阻塞，正是这个特性解决了幻读的问题。&lt;/p&gt;&lt;blockquote data-source-line=&quot;80&quot;&gt;&lt;p&gt;假设有一个记录索引包含键值4和7，不同的事务分别插入5和6，每个事务都会产生一个加在4-7之间的插入意向锁，获取在插入行上的排它锁，但是不会被互相锁住，因为数据行并不冲突。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-source-line=&quot;82&quot;&gt;意向锁&lt;/h3&gt;&lt;p data-source-line=&quot;84&quot;&gt;innodb的意向锁主要用户多粒度的锁并存的情况。比如事务A要在一个表上加S锁，如果表中的一行已被事务B加了X锁，那么该锁的申请也应被阻塞。如果表中的数据很多，逐行检查锁标志的开销将很大，系统的性能将会受到影响。为了解决这个问题，可以在表级上引入新的锁类型来表示其所属行的加锁情况，这就引出了“意向锁”的概念。&lt;/p&gt;&lt;p data-source-line=&quot;86&quot;&gt;举个例子，如果表中记录1亿，事务A把其中有几条记录上了行锁了，这时事务B需要给这个表加表级锁，如果没有意向锁的话，那就要去表中查找这一亿条记录是否上锁了。如果存在意向锁，那么假如事务A在更新一条记录之前，先加意向锁，再加X锁，事务B先检查该表上是否存在意向锁，存在的意向锁是否与自己准备加的锁冲突，如果有冲突，则等待直到事务A释放，而无须逐条记录去检测。事务B更新表时，其实无须知道到底哪一行被锁了，它只要知道反正有一行被锁了就行了。&lt;/p&gt;&lt;p data-source-line=&quot;88&quot;&gt;意向锁的主要作用是处理行锁和表锁之间的矛盾，能够显示“某个事务正在某一行上持有了锁，或者准备去持有锁”。&lt;/p&gt;&lt;h2 data-source-line=&quot;90&quot;&gt;锁的模式&lt;/h2&gt;&lt;p data-source-line=&quot;92&quot;&gt;共享锁和排它锁都是行级锁。意向共享锁和意向排他锁是表级锁。意向共享锁和意向排他锁都是系统自动添加和自动释放的，整个过程无需人工干预。&lt;/p&gt;&lt;h3 data-source-line=&quot;94&quot;&gt;1. 共享锁&lt;/h3&gt;&lt;p data-source-line=&quot;96&quot;&gt;共享锁（S锁，Shared Lock）：又称读锁，允许一个事务去读数据集，阻止其他事务获得该数据集的排他锁。共享锁与共享锁可以同时使用。举例：若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。&lt;/p&gt;&lt;h3 data-source-line=&quot;98&quot;&gt;2. 排他锁&lt;/h3&gt;&lt;p data-source-line=&quot;100&quot;&gt;排他锁（X锁，Exclusive Lock）：又称写锁，允许获取排他锁的事务更新数据，阻止其他事务获得相同的数据集的共享锁和排他锁。排它锁与排它锁、共享锁都不兼容。举例：若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。&lt;/p&gt;&lt;h3 data-source-line=&quot;102&quot;&gt;3. 意向共享锁&lt;/h3&gt;&lt;p data-source-line=&quot;104&quot;&gt;意向共享锁（IS锁，Intention Shared Lock）：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。&lt;/p&gt;&lt;h3 data-source-line=&quot;106&quot;&gt;4. 意向排他锁&lt;/h3&gt;&lt;p data-source-line=&quot;108&quot;&gt;意向排他锁（IX锁，Intention Exclusive Lock）：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。&lt;/p&gt;&lt;p data-source-line=&quot;110&quot;&gt;IS锁和IX锁的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，以避免用遍历的方式来查看表中有没有上锁的记录，也就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是兼容的。&lt;/p&gt;&lt;p data-source-line=&quot;112&quot;&gt;意向锁之间不会发生冲突，但共享锁、排它锁、意向锁之间会发生冲突，表级别各种锁的兼容性如下表所示。&lt;/p&gt;&lt;table data-source-line=&quot;113&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;兼容性&lt;/th&gt;&lt;th&gt;&lt;code&gt;X&lt;/code&gt;&lt;/th&gt;&lt;th&gt;&lt;code&gt;IX&lt;/code&gt;&lt;/th&gt;&lt;th&gt;&lt;code&gt;S&lt;/code&gt;&lt;/th&gt;&lt;th&gt;&lt;code&gt;IS&lt;/code&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;X&lt;/code&gt;&lt;/td&gt;&lt;td&gt;不兼容&lt;/td&gt;&lt;td&gt;不兼容&lt;/td&gt;&lt;td&gt;不兼容&lt;/td&gt;&lt;td&gt;不兼容&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;IX&lt;/code&gt;&lt;/td&gt;&lt;td&gt;不兼容&lt;/td&gt;&lt;td&gt;兼容&lt;/td&gt;&lt;td&gt;不兼容&lt;/td&gt;&lt;td&gt;兼容&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;S&lt;/code&gt;&lt;/td&gt;&lt;td&gt;不兼容&lt;/td&gt;&lt;td&gt;不兼容&lt;/td&gt;&lt;td&gt;兼容&lt;/td&gt;&lt;td&gt;兼容&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;IS&lt;/code&gt;&lt;/td&gt;&lt;td&gt;不兼容&lt;/td&gt;&lt;td&gt;兼容&lt;/td&gt;&lt;td&gt;兼容&lt;/td&gt;&lt;td&gt;兼容&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 data-source-line=&quot;120&quot;&gt;5. 自增锁&lt;/h3&gt;&lt;p data-source-line=&quot;122&quot;&gt;AUTO-INC Locks，自增锁，是一种特殊的表锁。当表有设置自增&lt;code&gt;auto_increment&lt;/code&gt;列，在插入数据时会先获取自增锁，其它事务将会被阻塞插入操作，自增列+1后释放锁，如果事务回滚，自增值也不会回退，所以自增列并不一定是连续自增的。（MySQL 从 5.1.22 版本开始，引入了一种可选的轻量级锁（mutex）机制来代替AUTOINC锁。见于参考文档3）&lt;/p&gt;&lt;h3 data-source-line=&quot;124&quot;&gt;6. 元数据锁&lt;/h3&gt;&lt;p data-source-line=&quot;126&quot;&gt;元数据锁（metadata lock），MySQL Server控制，表级锁，是维护表元数据的数据一致性，保证在表上有活动事务（显式或隐式）的时候，不可以对元数据进行写入操作。从MySQL5.5版本开始引入了MDL锁，来保护表的元数据信息，用于解决或者保证DDL操作与DML操作之间的一致性。&lt;/p&gt;&lt;p data-source-line=&quot;128&quot;&gt;对于引入MDL，其主要解决了2个问题：&lt;/p&gt;&lt;ol data-source-line=&quot;130&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;事务隔离问题，比如在可重复隔离级别下，会话A在2次查询期间，会话B对表结构做了修改，两次查询结果就会不一致，无法满足可重复读的要求。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据复制的问题，比如会话A执行了多条更新语句期间，另外一个会话B做了表结构变更并且先提交，就会导致slave在重做时，先重做alter，再重做update时就会出现复制错误的现象。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;133&quot;&gt;每执行一条DML、DDL语句时都会申请MDL锁，DML操作需要MDL读锁，DDL操作需要MDL写锁（MDL加锁过程是系统自动控制，无法直接干预，读读共享，读写互斥，写写互斥），申请MDL锁的操作会形成一个队列，队列中写锁获取优先级高于读锁。&lt;/p&gt;&lt;p data-source-line=&quot;135&quot;&gt;一旦出现MDL写锁等待，不但当前操作会被阻塞，同时还会阻塞后续该表的所有操作（不过在MySQL5.6的时候推出了online ddl机制，使得排队的MDL写锁进行降级，防止对MDL读锁的阻塞）。&lt;/p&gt;&lt;h3 data-source-line=&quot;137&quot;&gt;加锁时机&lt;/h3&gt;&lt;ul data-source-line=&quot;139&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;SELECT xxx 查询语句正常情况下为快照读，只加元数据读锁，直到事务结束。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;SELECT xxx LOCK IN SHARE MODE 语句为当前读，加S锁和元数据读锁，直到事务结束。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;SELECT xxx FOR UPDATE 语句为当前读，加X锁和元数据读锁，直到事务结束。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;DML语句（INSERT、DELETE、UPDATE）为当前读，加X锁和元数据读锁，直到事务结束。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;DDL语句（ALTER、CREATE等）加元数据写锁，且是隐式提交不能回滚，直到事务结束。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-source-line=&quot;145&quot;&gt;&lt;p&gt;为什么DDL语句会隐式提交？因为DDL是数据定义语言，在数据库中承担着创建、删除和修改的重要的职责。一旦发生问题，带来的后果很可能是不可估量的。于是在每执行完一次后就进行提交，可以保证流畅性，数据不会发生阻塞，同时也会提高数据库的整体性能。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-source-line=&quot;147&quot;&gt;线上踩坑举例：由于DDL语句存在隐式提交，所以如果会话A开始了事务，进行了DML操作，然后进行了DDL操作，然后会话A回滚事务。此时会话A回滚的事务是一个空事务，因为DDL操作执行的时候会进行一次隐式提交&lt;/p&gt;&lt;h3 data-source-line=&quot;149&quot;&gt;行锁锁住整表的场景&lt;/h3&gt;&lt;ol data-source-line=&quot;151&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;SQL语句没有使用索引会把整张表锁住。例如事务里进行整表update；用到前缀like；字段没有加索引；数据库优化将索引查询转全表扫描等等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Mysql在5.6版本之前，直接修改表结构的过程中会锁表。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-source-line=&quot;154&quot;&gt;&lt;p&gt;“查询每个表索引，并使用最佳索引，除非优化程序认为使用表扫描更有效。一次使用扫描是基于最佳索引是否跨越了表的30％以上，但是固定百分比不再决定使用索引还是扫描。现在，优化器更加复杂，并且根据附加因素（如表大小，行数和I / O块大小）进行估计。”见于参考文档1。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-source-line=&quot;156&quot;&gt;实验操作下的加锁情况分析&lt;/h3&gt;&lt;p data-source-line=&quot;158&quot;&gt;以下结论基于MySQL5.6，以InnoDB默认的RR级别来实验，只用来方便理解本文提到的锁机制。恐有纰漏，敬请谅解。&lt;/p&gt;&lt;p data-source-line=&quot;160&quot;&gt;&lt;img data-ratio=&quot;0.8625254582484725&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7EbEQBRzIuuyOlamgzFW5ewNCBDeyhI7KgaXpDamDFb0m6aiaW9T7sc74ANWwUbaeVtZ5XQsvlicE7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;982&quot;/&gt;&lt;/p&gt;&lt;h2 data-source-line=&quot;162&quot;&gt;死锁排查&lt;/h2&gt;&lt;p data-source-line=&quot;164&quot;&gt;INFORMATION_SCHEMA提供对数据库元数据的访问、关于MySQL服务器的信息，如数据库或表的名称、列的数据类型或访问权限。其中有一个关于InnoDB数据库引擎表的集合，里面有记录数据库事务和锁的相关表。&lt;/p&gt;&lt;p data-source-line=&quot;166&quot;&gt;MySQL有关事务和锁的四条命令：&lt;/p&gt;&lt;ol data-source-line=&quot;168&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;SELECT * FROM information_schema.INNODB_TRX;&lt;/code&gt;命令是用来查看当前运行的所有事务。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;SELECT * FROM information_schema.INNODB_LOCKs;&lt;/code&gt;命令是用来查看当前出现的锁。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;SELECT * FROM information_schema.INNODB_LOCK_waits;&lt;/code&gt;命令是用来查看锁等待的对应关系。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;show engine innodb status \G;&lt;/code&gt;命令是用来获取最近一次的死锁信息。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-source-line=&quot;173&quot;&gt;&lt;p&gt;在查询结果中可以看到是否有表锁等待或者死锁。如果有死锁发生，可以通过&lt;code&gt;KILL trx_mysql_thread_id&lt;/code&gt;来杀掉当前运行的事务。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-source-line=&quot;175&quot;&gt;查询事务与锁的命令行&lt;/h3&gt;&lt;p data-source-line=&quot;177&quot;&gt;死锁是并发系统中常见的问题，同样也会出现在数据库MySQL的并发读写请求场景中。当两个及以上的事务，双方都在等待对方释放已经持有的锁或因为加锁顺序不一致造成循环等待锁资源，就会出现“死锁”。常见的报错信息为&quot;Deadlock found when trying to get lock...&quot;&lt;/p&gt;&lt;p data-source-line=&quot;179&quot;&gt;MySQL死锁问题排查的常见思路：&lt;/p&gt;&lt;ol data-source-line=&quot;180&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;通过多终端模拟并发事务，复现死锁。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过上面四条命令，查看事务与锁的信息。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过explain可以查看执行计划。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;184&quot;&gt;发生死锁异常后，通过开启InnoDB的监控机制来获取实时的死锁信息，它会周期性（每隔 15 秒）打印 InnoDb 的运行状态到 mysqld服务的错误日志文件中。&lt;/p&gt;&lt;p data-source-line=&quot;186&quot;&gt;InnoDB的监控较为重要的有标准监控（Standard InnoDB Monitor）和锁监控（InnoDB Lock Monitor），通过对应的系统参数可以将其开启。&lt;/p&gt;&lt;pre data-source-line=&quot;187&quot;&gt;&lt;code&gt;&lt;span&gt;set&lt;/span&gt; &lt;span&gt;GLOBAL&lt;/span&gt; innodb_status_output=&lt;span&gt;ON&lt;/span&gt;;&lt;span&gt;开启标准监控&lt;/span&gt;&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; &lt;span&gt;GLOBAL&lt;/span&gt; innodb_status_output_locks;&lt;span&gt;开启所监控&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;192&quot;&gt;另外，MySQL 提供了一个系统参数&lt;code&gt;innodb_print_all_deadlocks&lt;/code&gt;专门用于记录死锁日志，当发生死锁时，死锁日志会记录到 MySQL 的错误日志文件中。&lt;/p&gt;&lt;p data-source-line=&quot;194&quot;&gt;另外，MySQL 提供了一个系统参数&lt;code&gt;innodb_print_all_deadlocks&lt;/code&gt;专门用于记录死锁日志，当发生死锁时，死锁日志会记录到 MySQL 的错误日志文件中。&lt;/p&gt;&lt;h3 data-source-line=&quot;196&quot;&gt;如何尽可能避免死锁&lt;/h3&gt;&lt;ol data-source-line=&quot;198&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;合理的设计索引，区分度高的列放到组合索引前面，使业务SQL尽可能通过索引定位更少的行，减少锁竞争。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;尽量按主键/索引去查找记录，范围查找增加了锁冲突的可能性，也不要利用数据库做一些额外额度计算工作。比如有的程序会用到&lt;code&gt;select … where … order by rand();&lt;/code&gt;这样的语句，类似这样的语句用不到索引，因此将导致整个表的数据都被锁住。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;以固定的顺序访问表和行。比如两个更新数据的事务，事务A更新数据的顺序为1，2;事务B更新数据的顺序为2，1。这样更可能会造成死锁。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;205&quot;&gt;参考文档：&lt;/p&gt;&lt;ol data-source-line=&quot;206&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;http://www.searchdoc.cn/rdbms/mysql/dev.mysql.com/doc/refman/5.7/en/where-optimization.com.coder114.cn.html&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-record-locks&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://dev.mysql.com/doc/refman/5.7/en/innodb-auto-increment-handling.html&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>