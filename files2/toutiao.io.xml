<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>d6e63d8b0d428afb165e85d6d031d399</guid>
<title>高并发最强计数器 LongAdder，究竟是怎么实现的？</title>
<link>https://toutiao.io/k/gdjef2c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;LongAdder和AtomicLong类似，但是在多线程更新的情况下LongAdder具有更高的性能。&lt;/span&gt;&lt;span&gt;LongAdder更适合统计类的场景，例如监控统计、计数统计等。&lt;/span&gt;&lt;span&gt;例如我们想实现一个单词计数器，可以通过如下代码实现&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 定义一个ConcurrentHashMap存放单词和计数的映射，key为单词，value是LongAdder&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, LongAdder&amp;gt; wordCounterMap = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 这个是单词次数统计操作&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addCount&lt;/span&gt;&lt;span&gt;(String word)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;// 首先读一次，在word重复较多的场景下能够减少锁冲突，因为computeIfAbsent方法内部有加锁&lt;/span&gt;&lt;br/&gt;LongAdder counter = wordCounterMap.get(word);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (counter == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt; &lt;span&gt;// 如果当前map还没有word映射，则通过computeIfAbsent原子性创建映射&lt;/span&gt;&lt;br/&gt; counter = wordCounterMap.computeIfAbsent(word, &lt;span&gt;new&lt;/span&gt; Function&amp;lt;String, LongAdder&amp;gt;() {&lt;br/&gt; &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; LongAdder &lt;span&gt;apply&lt;/span&gt;&lt;span&gt;(String s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LongAdder();&lt;br/&gt; }&lt;br/&gt; });&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 调用对应的counter.add方法原子性加1&lt;/span&gt;&lt;br/&gt;counter.add(&lt;span&gt;1L&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;LongAdder类继承自Striped64类，LongAdder类中并没有字段，状态都保存在Striped64中。LongAdder封装了add和sum两个方法，add方法负责修改计数，sum读取计数。&lt;/p&gt;&lt;p&gt;Striped64采取了分片的思想提高并发度，其中保存了一个long类型的base字段和一个Cell数组，每个Cell中也有一个value字段。当没有冲突的时候，会通过cas base字段来更新，当出现冲突的时候，会更新cell数组，当cell数组更新冲突时，会进行cell数组扩容来减少冲突。&lt;/p&gt;&lt;p&gt;LongAdder的add更新逻辑为&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;649&quot; data-backw=&quot;558&quot; data-ratio=&quot;1.1622516556291391&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bfAhkMkS9hM9xMDN0gdMctmicrjRibibXMylL8krlV3VvQT0vQ9yRwftZG0O07qpZzFeIsns4XSML7jxQ3udeeNWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1208&quot;/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LongAdder&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Striped64&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Cell[] cs; &lt;span&gt;long&lt;/span&gt; b, v; &lt;span&gt;int&lt;/span&gt; m; Cell c;&lt;br/&gt;        &lt;span&gt;// 首先判断cells是否为空，如果不为空说明已经出现了多线程cas base冲突，则进入到if语句中&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 如果为空，则会尝试cas base值，如果更新成功，返回，否则进入到if语句中&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; ((cs = cells) != &lt;span&gt;null&lt;/span&gt; || !casBase(b = base, b + x)) {&lt;br/&gt;            &lt;span&gt;boolean&lt;/span&gt; uncontended = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;// 如果cells是空的或者cas更新当前线程对应的cell值冲突，则调用longAccumulate方法，longAccumulate方法负责cells初始化、扩容、尝试减少冲突等逻辑&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (cs == &lt;span&gt;null&lt;/span&gt; || (m = cs.length - &lt;span&gt;1&lt;/span&gt;) &amp;lt; &lt;span&gt;0&lt;/span&gt; ||&lt;br/&gt;                (c = cs[getProbe() &amp;amp; m]) == &lt;span&gt;null&lt;/span&gt; ||&lt;br/&gt;                !(uncontended = c.cas(v = c.value, v + x)))&lt;br/&gt;                longAccumulate(x, &lt;span&gt;null&lt;/span&gt;, uncontended);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// sum方法的逻辑比较简单，把base和所有cell的value加起来就是sum总和。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;sum&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Cell[] cs = cells;&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; sum = base;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (cs != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (Cell c : cs)&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (c != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;                    sum += c.value;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; sum;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;再看下Striped64类，先定义了一个Cell类，并且用@Contended注解标注来避免伪共享问题。Cell中有一个value字段表示当前这个cell的值。所有的cell和base加起来就是最终的值。Cell类也提供了cas方法，内部是通过VarHandle类实现的，这个类似之前版本的Unsafe的功能。然后Stripe64类中定义了cells数组、base变量和cellsBusy自旋锁字段。cell数组用来存储各个分片内的值。base变量会在没有线程竞争的时候使用，减少内存占用。cellsBusy起到一个简单的自旋锁，当线程通过cas从0改成1时说明这个线程获取到了锁。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7885714285714286&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bfAhkMkS9hM9xMDN0gdMctmicrjRibibXMyN0mVgqyib0JZcgwHuh1wicicEbJNDJ8YdGLU00x3zJ25PhqkM4lQJ0WKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1400&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Striped64&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Number&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@jdk&lt;/span&gt;.internal.vm.annotation.Contended &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Cell&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; value;&lt;br/&gt;        Cell(&lt;span&gt;long&lt;/span&gt; x) { value = x; }&lt;br/&gt;        &lt;span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;cas&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; cmp, &lt;span&gt;long&lt;/span&gt; val)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; VALUE.compareAndSet(&lt;span&gt;this&lt;/span&gt;, cmp, val);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;reset&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            VALUE.setVolatile(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;0L&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;reset&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; identity)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            VALUE.setVolatile(&lt;span&gt;this&lt;/span&gt;, identity);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;getAndSet&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; val)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;long&lt;/span&gt;)VALUE.getAndSet(&lt;span&gt;this&lt;/span&gt;, val);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// VarHandle mechanics&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; VarHandle VALUE;&lt;br/&gt;        &lt;span&gt;static&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                MethodHandles.Lookup l = MethodHandles.lookup();&lt;br/&gt;                VALUE = l.findVarHandle(Cell&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &quot;&lt;span&gt;value&lt;/span&gt;&quot;, &lt;span&gt;long&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (ReflectiveOperationException e) {&lt;br/&gt;                &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ExceptionInInitializerError(e);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; NCPU = Runtime.getRuntime().availableProcessors();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Table of cells. When non-null, size is a power of 2.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; Cell[] cells;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Base value, used mainly when there is no contention, but also as&lt;br/&gt;     * a fallback during table initialization races. Updated via CAS.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; base;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Spinlock (locked via CAS) used when resizing and/or creating Cells.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; cellsBusy;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Striped64类的核心方法是longAccumulate，它会尝试找到当前线程对应的cell，并且在需要的时候完成cells数组初始化、cell对象初始化、扩容、调整probe值解决冲突等逻辑，流程图如下&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6074074074074074&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bfAhkMkS9hM9xMDN0gdMctmicrjRibibXMyicJwAUWRaIsfics9iaSw57fFU5Aw8nswoXj3z4XurbaWYQhFJra253dTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1890&quot;/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;longAccumulate&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; x, LongBinaryOperator fn,&lt;br/&gt;                              &lt;span&gt;boolean&lt;/span&gt; wasUncontended)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; h;&lt;br/&gt;        &lt;span&gt;// 通过当前Thread的probe值判断如果没有初始化，就调用ThreadLocalRandom.current()方法触发初始化，初始化后会设置probe值。&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; ((h = getProbe()) == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;     &lt;span&gt;// int p = probeGenerator.addAndGet(PROBE_INCREMENT);&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;// int probe = (p == 0) ? 1 : p; // skip 0&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;// U.putInt(t, PROBE, probe);&lt;/span&gt;&lt;br/&gt;            ThreadLocalRandom.current(); &lt;span&gt;// force initialization&lt;/span&gt;&lt;br/&gt;     &lt;br/&gt;            h = getProbe();&lt;br/&gt;            wasUncontended = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; collide = &lt;span&gt;false&lt;/span&gt;;                &lt;span&gt;// True if last slot nonempty&lt;/span&gt;&lt;br/&gt;        done: &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;            Cell[] cs; Cell c; &lt;span&gt;int&lt;/span&gt; n; &lt;span&gt;long&lt;/span&gt; v;&lt;br/&gt;     &lt;span&gt;// 当前cells不为空的时候，会优先使用cells进行更新&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;// TOOD 什么情况下cells != null 但是cells.length == 0呢?&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((cs = cells) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (n = cs.length) &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;  &lt;span&gt;// 通过probe与n-1与操作找到当前线程对应的cells数组的下标，如果为空，则需要加锁进行初始化Cell对象&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; ((c = cs[(n - &lt;span&gt;1&lt;/span&gt;) &amp;amp; h]) == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;// 乐观锁判断&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (cellsBusy == &lt;span&gt;0&lt;/span&gt;) {       &lt;span&gt;// Try to attach new Cell&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;// 乐观创建Cell对象，为什么在这里创建而不是在下面获取到锁之后创建呢？主要是为了减少加锁中的操作开销减小锁粒度&lt;/span&gt;&lt;br/&gt;                        Cell r = &lt;span&gt;new&lt;/span&gt; Cell(x);   &lt;span&gt;// Optimistically create&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// 获取自旋锁&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (cellsBusy == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; casCellsBusy()) {&lt;br/&gt;                            &lt;span&gt;try&lt;/span&gt; {               &lt;span&gt;// Recheck under lock&lt;/span&gt;&lt;br/&gt;           &lt;span&gt;// 拿到锁之后，需要再判断下，因为可能有其他线程在casCellsBusy之前已经执行过下面的代码了。&lt;/span&gt;&lt;br/&gt;                                Cell[] rs; &lt;span&gt;int&lt;/span&gt; m, j;&lt;br/&gt;    &lt;span&gt;// 这里为什么需要再判断cells不为null且length不大于0呢? 难道从外层的if进来之后，cells可能重新被置为null？&lt;/span&gt;&lt;br/&gt;                                &lt;span&gt;if&lt;/span&gt; ((rs = cells) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;br/&gt;                                    (m = rs.length) &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp;&lt;br/&gt;        &lt;span&gt;// 再check下对应的cell有没有创建了&lt;/span&gt;&lt;br/&gt;                                    rs[j = (m - &lt;span&gt;1&lt;/span&gt;) &amp;amp; h] == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;               &lt;span&gt;// 没有创建则使用我们创建的初始值为x的cell赋值&lt;/span&gt;&lt;br/&gt;                                    rs[j] = r;&lt;br/&gt;        &lt;span&gt;// 退出循环&lt;/span&gt;&lt;br/&gt;                                    &lt;span&gt;break&lt;/span&gt; done;&lt;br/&gt;                                }&lt;br/&gt;                            } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                                cellsBusy = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;                            }&lt;br/&gt;                            &lt;span&gt;continue&lt;/span&gt;;           &lt;span&gt;// Slot is now non-empty&lt;/span&gt;&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                    collide = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;  &lt;span&gt;// cells刚创建的时候，wasUncontended为true则会走到下面的cas&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// LongAdder中调用add如果add cell cas失败，wasUncontended会是false，则不会再尝试cas，直接走到修改probe再重试的逻辑&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!wasUncontended)       &lt;span&gt;// CAS already known to fail&lt;/span&gt;&lt;br/&gt;                    wasUncontended = &lt;span&gt;true&lt;/span&gt;;      &lt;span&gt;// Continue after rehash&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 进行一次cas 当前cell的尝试&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (c.cas(v = c.value,&lt;br/&gt;                               (fn == &lt;span&gt;null&lt;/span&gt;) ? v + x : fn.applyAsLong(v, x)))&lt;br/&gt;                    &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// cas失败并且当前数组数量已经大于等于cpu数量了或者发生了扩容，则&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (n &amp;gt;= NCPU || cells != cs)&lt;br/&gt;      &lt;span&gt;// cell数组数量大于等于cpu数量后不再扩容，或者已经被其他线程扩容过了，都重置collide变量标记位当前没有冲突，这样就不会走到下面的扩容逻辑中了&lt;/span&gt;&lt;br/&gt;                    collide = &lt;span&gt;false&lt;/span&gt;;            &lt;span&gt;// At max size or stale&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!collide)&lt;br/&gt;      &lt;span&gt;// collide为false的时候，就会进行修改probe并重试并修改collide为true，这样下次就会走到下面的else if也就是扩容逻辑。&lt;/span&gt;&lt;br/&gt;                    collide = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// 当和其他线程出现碰撞的时候，会进行扩容，这里也加上自旋锁&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (cellsBusy == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; casCellsBusy()) {&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;// double check，防止其他线程已经进行了修改&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (cells == cs)        &lt;span&gt;// Expand table unless stale&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;// 扩容cells数组为当前双倍长度，和HashMap不同的是这里的扩容不需要转移数据，因为Striped64对外表示的是总和。&lt;/span&gt;&lt;br/&gt;                            cells = Arrays.copyOf(cs, n &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                        cellsBusy = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;                    }&lt;br/&gt;&lt;br/&gt;                    collide = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;                    &lt;span&gt;continue&lt;/span&gt;;                   &lt;span&gt;// Retry with expanded table&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;  &lt;span&gt;// 走到这里说明之前出现了锁竞争，通过类似随机数的调整修改当前线程的probe值，来尝试减少冲突&lt;/span&gt;&lt;br/&gt;                h = advanceProbe(h);&lt;br/&gt;            }&lt;br/&gt;     &lt;span&gt;// cells为空的时候，需要进行cells数组初始化，cellsBusy变量起到了自旋锁的作用，成功cas cellsBusy从0到1的线程，会负责初始化cells数组&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (cellsBusy == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; cells == cs &amp;amp;&amp;amp; casCellsBusy()) {&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {                           &lt;span&gt;// Initialize table&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// 再check下, 这是防止判断cellsBusy ==0 &amp;amp;&amp;amp; cells==cs后还没执行casCellsBusy时，有其他线程先完成了初始化&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// 如果是这种情况，cells和cs不是相同的值，则会在下次循环在上面的if语句中处理&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (cells == cs) {&lt;br/&gt;   &lt;span&gt;// 数组默认大小为2&lt;/span&gt;&lt;br/&gt;                        Cell[] rs = &lt;span&gt;new&lt;/span&gt; Cell[&lt;span&gt;2&lt;/span&gt;];&lt;br/&gt;   &lt;span&gt;// 等同于用prob取余获取当前线程对应的cell，创建Cell对象&lt;/span&gt;&lt;br/&gt;                        rs[h &amp;amp; &lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;new&lt;/span&gt; Cell(x);&lt;br/&gt;   &lt;span&gt;// 把新创建的数组赋值给Striped64的cells字段&lt;/span&gt;&lt;br/&gt;                        cells = rs;&lt;br/&gt;                        &lt;span&gt;break&lt;/span&gt; done;&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                    cellsBusy = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;     &lt;span&gt;// 最后的降级，会尝试使用base cas更新，如果cas成功，返回，否则继续循环重试&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;// 发生的时机&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// Fall back on using base&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (casBase(v = base,&lt;br/&gt;                             (fn == &lt;span&gt;null&lt;/span&gt;) ? v + x : fn.applyAsLong(v, x)))&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt; done;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;AtomicLong和LongAdder的选择&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;大部分情况下AtomicLong都能满足需求，通过AtomicLong我们能够实现原子更新(incrementAndGet, compareAndSet等方法），保证线程安全等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当写多读少，且写可能出现较多竞争时，可以考虑使用LongAdder，适用的场景例如有请求次数统计这样的监控场景&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对内存占用比较敏感时，更适合用AtomicLong&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;span&gt;更多参考资料&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Optimistic lock, pessimistic lock, CAS lock, spin lock, do you know?&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0c1090e40ded81efb85445300e45a599</guid>
<title>选公司，就要去上升期的</title>
<link>https://toutiao.io/k/hd0xtfs</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;174&quot; data-backw=&quot;365&quot; data-ratio=&quot;0.4767123287671233&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/cvQbJDZsKLp6wejHtKTRbqqQyt0wMk9K1wNtuwRqQTJAPOJ1KiaqSeSRbIJRTicVicKpDKRndBodY2DBNN20tvWwA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;365&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原创：小姐姐味道（微信公众号ID：xjjdog），欢迎分享，转载请保留出处。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;人的发展，还是要看时机的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我不由想起了呆过的一家公司。2年时间，我们的团队，由刚开始的100多人，发展到最后的2000多人，经历了一次次的技术迭代升级。这是一笔宝贵的财富，我的技术水平，也得到了极大的提升。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常的感谢我们当时的技术总监。如果不是他亲自挂帅，带我们完成了一波波的技术升级，我不会了解到统一、正确的思路，能够节省多少时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一次，我将简单的回忆一下&lt;strong&gt;数据治理&lt;/strong&gt;方面的迭代，希望能从中找到一些共通的东西。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来一波重要的思路总结。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当年，入职第二天，领导给我的第一个任务，就是选一个长远的、能扩展、能维护的数据库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于历史的原因，公司的数据库选用了Oracle，但过了几年，噩梦开始了。Oracle极度复杂，在换了几个DBA后，没人敢动这台机器。领导萌生了换Oracle的念头，是因为一次事故。有一次，因为系统断电，Oracle死活启动不起来，给Oracle的技术支持打电话，结果来回推脱，到最后只能花了非常高的价钱，请一些代理机构来解决。大家得出的结论是：Oracle的技术支持并不可靠，还经常发生宰客行为。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;核心技术要掌握在自己手里。经过在&lt;code&gt;db-engines&lt;/code&gt;进行调研，综合国内的招聘情况，我们最终还是保守的选择了&lt;code&gt;MySQL&lt;/code&gt;，而不是性能更高功能更全的&lt;code&gt;Postgresql&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;曾经想过全部使用NoSQL，但被领导果断的被判定为&lt;code&gt;无知&lt;/code&gt;。虽然现在有各种各样的数据库，比如时序数据库、海量存储、各种NoSQL等，但目前使用最多的，还是RDBMS。在RDBMS方面，在互联网，Oracle的优势，已经完全比不上MySQL了。原因就在于MySQL的技术栈，工具全人才多，而且具有良好的扩展性。如果在一个&lt;code&gt;互联网公司&lt;/code&gt;，领导选择采购Oracle，那一般是判定他的脑子被驴踢了，或者采购的脑子被钱砸了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以前的领导，脑子肯定是被驴踢了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但选择了MySQL，就要承受MySQL所带来的技术投入。随着系统的变大，这种投入也逐渐膨胀，但总体看来还是好于&lt;code&gt;表面买放心&lt;/code&gt;的Oracle。在这期间，我经历了数据清洗、数据迁移、各种分层的数据库模型建设，是一笔非常宝贵的经验。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 重构填坑&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在接下来很长一段时间里，我们做的工作就是重构、填坑。我知道这很难，很多公司就死在这一环，因为它需要持续的投入。在此期间，如果同时要求功能性建设的话，这个战线就会拉的很长，很少有领导能够撑过这一环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幸运的是，我们的领导有魄力，能够向长远的目光去看，顶住了短期的&lt;code&gt;无业绩&lt;/code&gt;压力，之后的很多改造和扩展顺风顺水，节省了很多人力和财力。但这种未雨绸缪的领导毕竟是少数的，我后面遇到的大多数公司，都是被销售和产品牵着鼻子走，到最后系统越做越烂以至于无法维护。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那对于数据库来说，我都获取了哪些经验呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小的系统叠加代码，可能会陷入玩SQL的状态。加功能，堆代码，一行SQL走天下，使用的SQL函数，也是越来越偏门。这个非常有意思，你的sql玩的越6，那么给后人埋的坑，越多。你的一句魔幻SQL，会给后人带来十倍甚至几十倍的重构代价。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是为什么不使用Oracle这样一些数据库的原因，因为里面80%的附加功能，基本上是用不到的。即使是MySQL，按照公司的规范，一些官宣的特性，在公司内也是严格禁止的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为功能和扩展性，完全是相反的两回事。除非是访问量固定，或者是外包这样的一锤子买卖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着业务的发展，系统的性能也发生了瓶颈，报应也如期而至，以前的技巧变成了现在的累赘。很快，以前用Oracle时写的一些代码，开始显现出它的弊端。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;各种慢查询层出不穷，查询界面一直转圈&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;经常就发生全文扫描，DBA疲于奔命，最后撂挑子不干了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;想要加缓存，发现无从下手，牵一发动全身&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;想要分库分表，结果根本找不到能分的维度，只好在一次次的讨论会中灰溜溜的承认现实&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多老板搞不明白。我原本一个好好的系统，为什么用户量才翻了一倍，大部分代码就得重写呢？很多项目经理搞不明白。技术人员在那里优化了好几个月，为什么我的功能体验不升反降呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那是因为。你的团队，在相当长的一段时间里，在填坑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;凡是都有规范，都有定律。照顾了工期，质量就要打折，如果加上开发人员并没有长远意识的话，接下来很大的工作，就是填坑。坑填不完，接下来的工作就无法进行。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 数据表的类型&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首当其冲的，就是数据库表的重构。比如以什么ali规范为标准：一个超过3个表的联合查询业务，大概率是不合理的。这个虽然极端，但却是非常重要的指导意见。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;忘掉什么数据库范式，我们将存在两类表：小表和宽表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的改造过程，也是按照这种划分方式进行的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5936555891238671&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLrqXicmwZ2YNJiasvwQIZUlKgoDBrUAF37cARRc87oLAzauQsoMXrKy0RTOW9r3TquErPE52HOeoy7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;662&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小表提供了最基本的数据，可能一个简单的KV就完成了。一些联合查询，并不通过SQL进行JOIN查询，因为我们吃过这个东西的亏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式系统的特点，就是小耗时的多次查询，比机器hang在那里更加有生命力。换句话说，程序里循环1000次10毫秒的查询，比单次查询耗费6秒要强的多。松散的结果，不仅在业务上能支持天马行空的自由组合，在扩展性上也更胜一筹。唯一的一个弱点，就是编码的要求高了，代码量多了，不过这也是我们所希望的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这对一些运行系统来说，是天大的福音。但是问题又来了，统计性的工作又该怎么做？比如报表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是宽表的用途了。宽表通过冗余的方式，提供了某个重要功能常用的分析数据。这种表的字段一般都特别多，在写入时通过拼接获取冗余数据，一般用在读多写少的场景。所以到最后，我们的业务数据，根据查询的维度，写了很多份。不同的团队维护着不同维度的副本，也是团队成员开始爆炸、业务开始飞速发展的开始。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么要这么做？主要还是解耦。有时候，我们通过MQ等分发数据；有时候，我们通过Binlog分发数据。同一份数据，因为维度的不同，有着不同的用途，最主要的业务就减少了宕机的风险。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 分库分表&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理想很美好，但现实很骨感。在我们打算把大表小表方案落实的时候，一件更重要的事渐渐的浮上水面：我们的数据量已经到了一定级别，需要进行分库分表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也证明了领导的先见之明，如果采用的是Oracle数据库，我们的IT费用将会因为购入新的数据库实例急剧飙升。纵向扩展Oracle也能暂时的解决问题，但它总有爆发的一天。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分库分表分为纵向拆分和横向拆分。按照业务进行拆分这一块，我们本身就已经做的很好了，倒是单表的上限处理（比如十几亿的订单表），费了我们很大的功夫。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4857142857142857&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLrqXicmwZ2YNJiasvwQIZUlKgFpibZSopUHmgOUs6U2j7icrbryjqVzCp38Q69t2ibCIL62DwjxUC2R3wA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;805&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前行业内的分库分表方案，集中在以代理方式存在的MyCat，还有以驱动形式存在的ShardingJDBC。为了尽量的少引入额外的维护成本，加上它们的效果都差不多，我们最后的评估，采用的就是ShardingJDBC。当然它的弱点也是很明显的：以Java驱动形式存在，不支持异构系统，比如golang开发语言。幸运的是技术爆炸这一块研发部控制的很好，我们的多数系统是Java的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让人感叹技术统一的好处。永远不要为了尝鲜，引入一些与公司架构不一致的东西，会给所有人带来困扰。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;技术组件好选，但等到真正落实下来，却非常的痛。一句原本好好运行的语句，到了分库分表环境下，竟然就不能运行。归根揭底还是SQL写的太不规范了，用了一些不标准的东西，比如用了&lt;code&gt;distinct&lt;/code&gt;、&lt;code&gt;having&lt;/code&gt;、&lt;code&gt;union&lt;/code&gt;等。这些在单库表的情况下，运行的很好。但到了分库分表环境下，由于组件的限制，它们通常不能好好工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这部分是最耗时的折腾。有些SQL由于改不动了，我们最后几乎把业务重写了一遍，最终使用最简单的CRUD完成了所有的功能。如果想要我再来第二遍的话，我会毫不犹豫的说：No。我会在项目开始设计的时候，就避免这些问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 数据同步&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;终于完成了数据库的扩展性，只要硬件够，可以支持到天荒地老了。现在有时间有精力，来看一下数据同步的问题了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面我们说了，有一大堆小表和大表，用在不同的场景。这些分库分表的原始表，我们就可以把它当作小表，需要把它同步到其他地方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同业务通过共享数据库来共享数据不得不说是个非常蠢的主意。这个时候就需要一些数据同步工具。我们采用了两种同步方式。一种是消息，一种是binlog。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5950413223140496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLrqXicmwZ2YNJiasvwQIZUlKggibamjyyx8pc7dtiaXWibwcaElpn9jlBl9ib6cuPAiczdvrGSlNPrknJctQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;726&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一些有着明显业务属性的信息，我们是通过消息分享的。比如订单，在信息落地到DB后，我们会同时发送一条MQ消息。对订单信息感兴趣的业务方，只需要订阅对应的主题就可以了。当然这里有一个非常大的话题，就是分布式事务（关于这部分，我会在其他文章中分享），来保证消息能够发送成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一些有着共通特性的数据，因为技术原因需要扩展成宽表，或者转化为其他维度的查询数据的时候，就可以通过binlog，把数据共享出去。对于MySQL来说，国内的canal组件，能够非常容易的完成这个转变，我们选的就是这门技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那什么时候用MQ，什么时候用Binlog呢？MQ的信息流明显是比Binlog清晰的，但它的开发难度大，有更多要考虑的因素。如果非要找个边界的话。我觉得MQ主要用在跨业务方的数据交互上，而Binlog是用在自己业务组内的技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了不对主库造成影响，我们一般会拉出多个从库，甚至是从库的从库。一部分从库参与读写分离的业务，一部分从库，就专门为Canal提供数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我离开这家公司的时候，领导正在带领着兄弟们搞异地机房的数据同步。我知道很多公司可能永远用不上，但没有亲身经历这一块，还是有一点小遗憾的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 数据仓库&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据同步是个非常脏的活，经常因为异常，造成了同步终止，这时候依赖的业务方就会陷入抓狂状态中。更脏的活，还是ETL。非常的佩服做数据清洗的同事们，是他们让专注于业务开发的同学，用着清清爽爽的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是这样令人啼笑皆非，因为某些需求，我们需要把分库分表完的数据，重新给合起来。比如某些报表业务需要全量的数据。那就需要把所有的数据汇总到一个地方进行查询，比如ElasticSearch、MongoDB等。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.727027027027027&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLrqXicmwZ2YNJiasvwQIZUlKgtDyFiclfPUDfHyovCjpMhoG6gweiaQ8vZI4RIpRJiaqIBUDSUQdnY80Dw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;740&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据仓库有很多选择。如果数据量适中，就可以选择ElasticSearch，MongoDB等。如果数据量非常大，那就需要考虑Hbase，Druid等大数据产品。在我们这里，按照功能分了三个层次：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;RDBMS（MySQL）作为原始的数据存储，提供扁平快的数据通道&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ElasticSearch作为大型宽表，分布式的类RT的存储。用来存储一些中等规模的数据，并提供一些中延迟的搜索功能，比如商品搜索等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Hbase、Druid作为海量的存储系统，存储系统所有的历史记录，并提供离线分析功能&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在的风向，是使用一些分布式的数据库，比如PolarDB、TiDB等，由于它们在接入层采用的是MySQL协议，所以数据迁移起来、代码改起来是相对简单的。我们有部分非核心业务，已经迁入了这种分布式数据库，但是核心数据还是不敢动，需要更多的时间进行验证。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. 总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这几年走下来，我觉得最重要的收获，是对于技术的规划性，而不是&lt;code&gt;车到山前必有路&lt;/code&gt;的勇往直前。这种工作，需要有能量的人去做。我们的技术总监，对于技术如何迭代，思路是非常清晰的，加上他一直在力推这些事情，就节省了非常多的&lt;code&gt;论证&lt;/code&gt;时间和&lt;code&gt;扯皮&lt;/code&gt;时间。在后面的从业生涯中，我再也没见过这样的技术总监。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;作者简介：&lt;strong&gt;小姐姐味道&lt;/strong&gt;  (xjjdog)，一个不允许程序员走弯路的公众号。聚焦基础架构和Linux。十年架构，日百亿流量，与你探讨高并发世界，给你不一样的味道。我的个人微信xjjdog0，欢迎添加好友，进一步交流。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>caf28f58a427d5711e6ee6dd1b105524</guid>
<title>几个预防并发搞垮下游服务的方法</title>
<link>https://toutiao.io/k/my9cl6k</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上一篇文章 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247488047&amp;amp;idx=1&amp;amp;sn=1ae50b6a3ee03bad64d2972ed61cc8f2&amp;amp;chksm=fa80c3b8cdf74aaea9f4430e99c1674376b9e25734b64e5b07f8c000c42187bc575b4d3b3153&amp;amp;token=1042060650&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;我用休眠做并发控制，搞垮了下游服务&lt;/strong&gt;&lt;/a&gt; 发出去后得到不少网友的回应，有人问自己平时用的方案行不行，有人建议借鉴TCP的拥塞控制策略，动态地调整发起的并发数，还有人问为啥我要管下游抗不抗得住。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我就来总结几种调用下游服务时做并发控制的方案。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;因为我们这篇文章是科普向的文章，主要目的是总结一下应该怎么在享受并发带来效率提升的同时做好并发控制让整个系统的上下游都能更稳定一些，不对限流、控制到底该哪个服务加，出了事故谁负责做讨论。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;并发控制方案&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们提到用休眠做并发控制的最大弊端是，没有考虑下游服务的感受，每次开固定数量的&lt;code&gt;goroutine&lt;/code&gt; 去执行任务后，调用者休眠 1s 再来，而不是等待下游服务的反馈再开启下一批任务执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;badConcurrency&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; batchSize := &lt;span&gt;500&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  data, _ := queryDataWithSizeN(batchSize)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(data) == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; _, item := &lt;span&gt;range&lt;/span&gt; data {&lt;br/&gt;   &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(i &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    doSomething(i)&lt;br/&gt;   }(item)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  time.Sleep(time.Second * &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外上游还有请求分配不均的问题，休眠的时候完全没有请求，休眠结束后不管下游有没有执行完成马上又发起一批新的请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们应该从&lt;strong&gt;等待下游反馈&lt;/strong&gt;和&lt;strong&gt;请求分配尽量均匀&lt;/strong&gt;两个角度去做并发控制，当然实际项目中应该是两方面结合才行。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本文的可执行示例代码请访问下面的链接查看：&lt;/p&gt;&lt;p&gt;https://github.com/kevinyan815/gocookbook/blob/master/codes/prevent_over_concurrency/main.go&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;使用限流器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在向下游发起并发请求时可以通过限流器做一下限流，如果达到限制就阻塞直到能再次发起请求。一听到&lt;strong&gt;阻塞直到blabla&lt;/strong&gt; 有的同学是不是马上内心小激动想用 &lt;code&gt;channel&lt;/code&gt; 去实现一个限流器啦，「此处应用咳嗽声」其实完全没必要Golang 官方限流器 &lt;code&gt;time/rate&lt;/code&gt;包的 Wait 方法就能给我们提供了这个功能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;useRateLimit&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; limiter := rate.NewLimiter(rate.Every(&lt;span&gt;1&lt;/span&gt;*time.Second), &lt;span&gt;500&lt;/span&gt;)&lt;br/&gt; batchSize := &lt;span&gt;500&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  data, _ :=queryDataWithSizeN(batchSize)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(data) == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   fmt.Println(&lt;span&gt;&quot;End of all data&quot;&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; _, item := &lt;span&gt;range&lt;/span&gt; data {&lt;br/&gt;   &lt;span&gt;// 阻塞直到令牌桶有充足的Token&lt;/span&gt;&lt;br/&gt;   err := limiter.Wait(context.Background())&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Error: &quot;&lt;/span&gt;, err)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(i &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    doSomething(i)&lt;br/&gt;   }(item)&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 模拟调用下游服务&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;doSomething&lt;/span&gt;&lt;span&gt;(i &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; time.Sleep(&lt;span&gt;2&lt;/span&gt; * time.Second)&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;End:&quot;&lt;/span&gt;, i)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 模拟查询N条数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;queryDataWithSizeN&lt;/span&gt;&lt;span&gt;(size &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(dataList []&lt;span&gt;int&lt;/span&gt;, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; rand.Seed(time.Now().Unix())&lt;br/&gt; dataList = rand.Perm(size)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;time/rate&lt;/code&gt;包提供的限流器采用的是令牌桶算法，使用&lt;code&gt;Wait&lt;/code&gt;方法是当桶中没有足够的令牌时调用者会阻塞直到能取到令牌，当然也可以通过&lt;code&gt;Wait&lt;/code&gt;方法接受的&lt;code&gt;Context&lt;/code&gt;参数设置等待超时时间。限流器往桶中放令牌的速率是恒定的这样比单纯使用&lt;code&gt;time.Sleep&lt;/code&gt;请求更均匀些。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;关于time/rate 限流器的使用方法的详解，请查看我之前的文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247487689&amp;amp;idx=1&amp;amp;sn=051594d3f745643e48da384c3af3be91&amp;amp;chksm=fa80c15ecdf748488edce7900ca9d7eb78d0c7fdc622b3c046eaeedcb24143c709630ec23372&amp;amp;token=1042060650&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Golang官方限流器的用法详解&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用了限流器了之后，只是让我们的并发请求分布地更均匀了，最好我们能在受到下游反馈完成后再开始下次并发。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;使用WaitGroup&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以等上批并发请求都执行完后再开始下一批任务，估计大部分同学听到这马上就会想到应该加&lt;code&gt;WaitGroup&lt;/code&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;WaitGroup&lt;/strong&gt;适合用于并发-等待的场景：一个&lt;code&gt;goroutine&lt;/code&gt;在检查点(Check Point)等待一组执行任务的 worker &lt;code&gt;goroutine&lt;/code&gt; 全部完成，如果在执行任务的这些worker &lt;code&gt;goroutine&lt;/code&gt; 还没全部完成，等待的 &lt;code&gt;goroutine&lt;/code&gt; 就会阻塞在检查点，直到所有woker &lt;code&gt;goroutine&lt;/code&gt; 都完成后才能继续执行。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;useWaitGroup&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt; batchSize := &lt;span&gt;500&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  data, _ := queryDataWithSizeN(batchSize)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(data) == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   fmt.Println(&lt;span&gt;&quot;End of all data&quot;&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; wg sync.WaitGroup&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; _, item := &lt;span&gt;range&lt;/span&gt; data {&lt;br/&gt;   wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(i &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    doSomething(i)&lt;br/&gt;    wg.Done()&lt;br/&gt;   }(item)&lt;br/&gt;  }&lt;br/&gt;  wg.Wait()&lt;br/&gt;&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;Next bunch of data&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里调用程序会等待这一批任务都执行完后，再开始查下一批数据进行下一批请求，等待时间取决于这一批请求中最晚返回的那个响应用了多少时间。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;使用Semaphore&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你不想等一批全部完成后再开始下一批，也可以采用一个完成后下一个补上的策略，这种比使用&lt;code&gt;WaitGroup&lt;/code&gt;做并发控制，如果下游资源够，整个任务的处理时间会更快一些。这种策略需要使用信号量（Semaphore）做并发控制，Go 语言里通过扩展库&lt;code&gt;golang.org/x/sync/semaphore&lt;/code&gt; 提供了信号量并发原语。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;关于信号量的使用方法和实现原理，可以读读我以前的文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247486856&amp;amp;idx=1&amp;amp;sn=06efbf5cc3db1007e4c6af1e892b7ef6&amp;amp;chksm=fa80dc1fcdf755092b67ab7da96b74601bdf801a6914d7e241e5a55e3c1f2878dae2287c8001&amp;amp;token=1042060650&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;并发编程-信号量的使用方法和其实现原理&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的程序改为使用信号量&lt;code&gt;semaphore.Weighted&lt;/code&gt;做并发控制的示例如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;useSemaphore&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; concurrentNum &lt;span&gt;int64&lt;/span&gt; = &lt;span&gt;10&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; weight &lt;span&gt;int64&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; batchSize &lt;span&gt;int&lt;/span&gt; = &lt;span&gt;50&lt;/span&gt;&lt;br/&gt; s := semaphore.NewWeighted(concurrentNum)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  data, _ := queryDataWithSizeN(batchSize)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(data) == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   fmt.Println(&lt;span&gt;&quot;End of all data&quot;&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; _, item := &lt;span&gt;range&lt;/span&gt; data {&lt;br/&gt;      s.Acquire(context.Background(), weight)&lt;br/&gt;   &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(i &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    doSomething(i)&lt;br/&gt;    s.Release(weight)&lt;br/&gt;   }(item)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;使用生产者消费者模式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也有不少读者回复说得加线程池才行，因为每个人公司里可能都有在用的线程池实现，直接用就行，我在这里就不再献丑给大家实现线程池了。在我看来我们其实是需要实现一个生产者和消费者模式，让线程池帮助我们限制只有固定数量的消费者线程去做下游服务的调用，而生产者则是将数据存储里取出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;channel&lt;/code&gt; 正好能够作为两者之间的媒介。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;useChannel&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; batchSize := &lt;span&gt;50&lt;/span&gt;&lt;br/&gt; dataChan := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; wg sync.WaitGroup&lt;br/&gt; wg.Add(batchSize + &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;// 生产者&lt;/span&gt;&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;   data, _ := queryDataWithSizeN(batchSize)&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(data) == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; _, item := &lt;span&gt;range&lt;/span&gt; data {&lt;br/&gt;    dataChan &amp;lt;- item&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;close&lt;/span&gt;(dataChan)&lt;br/&gt;  wg.Done()&lt;br/&gt; }()&lt;br/&gt;    &lt;span&gt;// 消费者&lt;/span&gt;&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;50&lt;/span&gt;; i++ {&lt;br/&gt;   &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;     &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;     &lt;span&gt;case&lt;/span&gt; v, ok := &amp;lt;- dataChan:&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; !ok {&lt;br/&gt;       wg.Done()&lt;br/&gt;       &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;      doSomething(v)&lt;br/&gt;     }&lt;br/&gt;    }&lt;br/&gt;   }()&lt;br/&gt;  }&lt;br/&gt; }()&lt;br/&gt;&lt;br/&gt; wg.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个代码实现里，如果用&lt;code&gt;ErrorGroup&lt;/code&gt;代替&lt;code&gt;WaitGroup&lt;/code&gt;的话还能更简化一些，这个就留给读者自己探索吧。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;关于&lt;code&gt;ErrorGroup&lt;/code&gt;的用法总结，推荐阅读文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247486940&amp;amp;idx=1&amp;amp;sn=782b674858cb3d972a6e0be9f2f7ac6a&amp;amp;chksm=fa80dc4bcdf7555d4937c68bc88b06e4c17978f7c3e07f2a3b170db33182180c06957382b0d3&amp;amp;token=1042060650&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;觉得WaitGroup不好用？试试ErrorGroup吧！&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过文章里总结的一些方法，我们也能看出来并发编程的场景下，&lt;strong&gt;除了关注发起的并发线程数外，更重要的是还需要关注被异步调用的下层服务的反馈，不是一味的加并发数就能解决问题&lt;/strong&gt;的。理解我们为什么在并发编程中要关注下层服务的反馈是很重要的，否则我们列举的那些方案其实都可以在&lt;code&gt;goroutine&lt;/code&gt;里再开&lt;code&gt;goroutine&lt;/code&gt;，不关心是否执行完成直接返回，无限套娃下去。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>256785e85826a1800aade26b1f4bf55c</guid>
<title>研效优化实践：聊聊单元测试那些事儿</title>
<link>https://toutiao.io/k/yb5nswt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：ciuwaalu，腾讯安全平台部后台开发&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;研发效能提升是一个系统化的庞大工程，它涵盖了软件交付的整个生命周期，涉及到产品、架构、开发、测试、运维等各个环节。而单元测试作为软件中最小可测试单元的检查验证环节，可以说是这个庞大工程中最细致但又不可忽视的一个细节因素。本文内容梳理自安全平台部测试效能提升的经验实践，从零开始介绍探讨单测的方法论和优化思路，期望为大家带来参考，欢迎共同交流。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是单元测试？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在最开始，我们先看看大家认为的单元测试是什么：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在计算机编程中，单元测试是一种软件测试方法，通过该方法对源代码的各个单元（一个或多个计算机程序模块的集合以及相关的控制数据、使用过程和操作过程）进行测试以确定它们是否符合使用要求。—— 维基百科《Unit testing》&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;一个单元测试是一段自动化的代码，这段代码调用被测试的工作单元，之后对这个单元的单个最终结果的某些假设进行检验。单元测试几乎都是用单元测试框架编写的。单元测试容易编写，能快速运行。单元测试可靠、可读，并且可维护。只要产品代码不发生变化，单元测试的结果是稳定的。—— Roy Osherove《单元测试的艺术》&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上这些定义为了严谨起见，都是长长的一大段。在这里，我们结合工程实践经验，给出一个“太长不看”版的定义，这个定义不太严谨但更为简单：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;开发同学&lt;/strong&gt; 在 &lt;strong&gt;编码阶段&lt;/strong&gt; 以 &lt;strong&gt;函数方法&lt;/strong&gt; 为粒度编写测试用例，检验 &lt;strong&gt;代码逻辑&lt;/strong&gt; 的正确性。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个一句话定义里，有四个核心要素：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;角色：开发同学&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;单元测试是开发同学工作的一部分，而不是测试同学的工作内容。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;阶段：编码阶段&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;单元测试是在开发编码阶段进行的，而不是转测试之后才开始的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;粒度：函数方法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;单元测试主要针对函数方法，而不是整个模块或系统。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;检验：代码逻辑&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;单元测试主要验证函数方法中的代码逻辑实现，而不是模块接口、系统架构、用户需求。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合测试 V 型图，可以清晰看到单元测试在项目周期中所处的位置阶段。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5738095238095238&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavl9AxD71LyfJVCnqUbiac6nOe9mMm97O005O81W4nz0cseFf44gn2QPdjk15NJKVrF6c2JOibhiczXA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;840&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;单元测试有什么好处？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们不打算罗列《单元测试的N大优势》《写单元测试的N大好处》，只说一条最核心的：&lt;strong&gt;单元测试可以尽早发现编码中的低级错误。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;越早发现问题，也越容易解决问题。很显然：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果问题在编码阶段、由开发同学通过单元测试发现，开发同学可以&lt;strong&gt;立即修复&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果问题在转测之后、由测试同学发现，可能会走&lt;strong&gt;缺陷单&lt;/strong&gt;，修复流程时间长，影响项目进展&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果问题在测试阶段未被发现，而在上线后才触发，需要运维同学回滚，甚至可能会导致&lt;strong&gt;现网事故&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来自微软的数据，不同测试阶段发现BUG的平均耗时，供参考：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;单元测试阶段，平均耗时 3.25 小时&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;集成测试阶段，平均耗时 6.25 小时 (+92%)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统测试阶段，平均耗时 11.5 小时 (+254%)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;低级错误造成重大损失的例子实在太多了。&lt;span&gt;有了单元测试，可以避免 &lt;/span&gt;&lt;strong&gt;面向运气开发，面向回滚发布&lt;/strong&gt;&lt;span&gt;，打破“不知道有没有BUG ~ 上线出事回滚 ~ 紧急修复 ~ 代码质量逐渐劣化 ~ 不知道有没有新BUG” 的恶性循环。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;黑盒与白盒&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在软件测试理论中，常常将被测试对象视为一个盒子，这个神秘的盒子接受一些输入，并做某些处理工作，产生特定的输出结果。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;2.2869565217391306&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavl9AxD71LyfJVCnqUbiac6nynvfJ3Zd6g2D8MVFaghynF8ibPFHxJR7J5XRnT5CotAfkiawZabSfPSQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;230&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在构造输入数据进行测试时：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果知道盒子的用途，但&lt;strong&gt;不知道盒子的构造&lt;/strong&gt;，就是&lt;strong&gt;黑盒测试&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果知道盒子的用途，也&lt;strong&gt;知道盒子的构造&lt;/strong&gt;，就是&lt;strong&gt;白盒测试&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;白盒测试一般只在单元测试中使用，黑盒测试在单元测试、集成测试等各个阶段都可以使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以下方这个函数为例子，看看单元测试中如何应用黑盒与白盒测试。首先需要明确，设计单元测试，我们肯定是知道这个函数的具体用途、输入参数和返回结果的含义（即知道盒子的用途）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 从 IPv4 报文中提取源 IP 地址&lt;br/&gt;uint32_t GetSrcAddrFromIPv4Packet(const void *buffer, size_t size);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们手上只有编译好的二进制库文件，不知道函数的内部实现方式，通过想象这个函数在上线后会遇到什么类型的输入，设计了一些合法和非法的 IP 报文来做验证，此时是 &lt;strong&gt;黑盒测试&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们手上有函数源代码，一边看着函数实现，一边根据代码里的分支、逻辑构造各种输入，此时是 &lt;strong&gt;白盒测试&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如看到函数内部的 &lt;code&gt;if (buffer == nullptr) return -1;&lt;/code&gt; 设计了一个空缓冲区的用例；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如看到函数内部的 &lt;code&gt;if (size &amp;lt; sizeof(iphdr)) return -1;&lt;/code&gt;  设计了缓冲区大小为 19Bytes 的用例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在大部分情况下，我们是自己给自己写的函数做单元测试，当运用黑盒测试的思路时，要 &lt;strong&gt;假装&lt;/strong&gt; 被测函数是别人写的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;覆盖&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在单元测试中，覆盖率是一个常用的评估指标。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓覆盖，可以简单理解为 “被执行过”。具体来说：在某个测试用例中，执行了某行代码，则可以说这行代码“被覆盖”；同样，当某个分支的真/假条件都被取到时，则可以说这个分支“被覆盖了”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的覆盖可以分为这几种：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们有一个这么一个待测函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;int foo(int a, int b, int c, int d) {&lt;br/&gt;    int result = 0;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (a &amp;amp;&amp;amp; b)                        // 分支 1&lt;br/&gt;        result += a;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (c || d)                        // 分支 2&lt;br/&gt;        result += c;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;语句覆盖&lt;/strong&gt; 是指 每条语句都被执行一次。当输入 &lt;code&gt;a=1, b=1, c=1, d=1&lt;/code&gt;  一组用例时可以达到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;分支覆盖&lt;/strong&gt; 是指 每个分支 真/假 条件都被执行一次。当输入 &lt;code&gt;a=1, b=1, c=1, d=1&lt;/code&gt; 以及 &lt;code&gt;a=0, b=0, c=0, d=0&lt;/code&gt; 两组用例时可以达到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;条件覆盖&lt;/strong&gt; 是指 每个分支的条件组合方式都被执行一次。当输入 &lt;code&gt;a=1, b=1, c=1, d=1&lt;/code&gt;（真真）、&lt;code&gt;a=1, b=0, c=1, d=0&lt;/code&gt;（真假）、&lt;code&gt;a=0, b=1, c=0, d=1&lt;/code&gt;（假真）、&lt;code&gt;a=0, b=0, c=0, d=0&lt;/code&gt;（假假）四组用例时可以达到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;语句覆盖是最容易达到、也是最弱的覆盖方式。在工程实践中，考虑到测试成本及测试效果，分支覆盖的覆盖率是最常使用的考察指标。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;桩与驱动&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们还有这么一个待测函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;void foo(int a) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (a &amp;gt; 0) {&lt;br/&gt;        A();&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        B();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;foo()&lt;/code&gt; 调用了外部函数 &lt;code&gt;A()&lt;/code&gt; &lt;code&gt;B()&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设 &lt;code&gt;A()&lt;/code&gt; 是一个很重的函数（操作 DB、文件或者网络通信……），进行单元测试时，我们不希望引入这些外部依赖，而是希望调用 &lt;code&gt;A()&lt;/code&gt; 时立即返回一些提前准备好的“假数据”，这时需要“仿冒”一个 &lt;code&gt;A()&lt;/code&gt;，这个伪造过程就叫做 &lt;strong&gt;插桩&lt;/strong&gt;，假冒的 &lt;code&gt;A()&lt;/code&gt; 就称为 &lt;strong&gt;桩函数（stub）&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在做测试时，需要写一个函数来调用 &lt;code&gt;foo()&lt;/code&gt;，这个调用者就是 &lt;strong&gt;驱动（driver）&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;单元测试简单实践&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一个简单的单元测试&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个单元测试用例至少包含：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个简单但完整的单元测试看起来会是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 待测函数&lt;br/&gt;int add(int a, int b) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; a + b;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 测试用例&lt;br/&gt;void &lt;span&gt;&lt;span&gt;TestAdd&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;//       被测对象      预期输出&lt;br/&gt;//         |||          |&lt;br/&gt;    assert(add(1, 2) == 3);&lt;br/&gt;//  ||||||     |  |&lt;br/&gt;//   断言      输入数据&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 执行测试&lt;br/&gt;int &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    TestAdd();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Given-When-Then&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单元测试中 被测函数、断言、输入数据、预期输出 几个要素，可以通过经典模板 Given-When-Then(GWT) 来做一些严谨的描述。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Given&lt;/strong&gt; 描述测试的前置条件或初始状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;When&lt;/strong&gt; 描述测试过程中发生的行为&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Then&lt;/strong&gt; 描述测试结束后断言输出结果&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 GWT 来描述上一节的用例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;assert(&lt;br/&gt;  add(      // When  - 测试过程发生的行为 - 调用被测函数 add()&lt;br/&gt;    1, 2    // Given - 测试前置条件和初始状态 - 用例输入参数&lt;br/&gt;  )&lt;br/&gt;  == 3      // Then  - 测试结束断言输出结果 - 断言预期输出&lt;br/&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些现代化的测试框架（例如 catch2）对 GWT 描述做了表达上的优化。下方粘贴了一段单元测试代码示例，有对 GWT 更为具体的描述：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SCENARIO( &lt;span&gt;&quot;vectors can be sized and resized&quot;&lt;/span&gt;, &lt;span&gt;&quot;[vector]&quot;&lt;/span&gt; ) {&lt;br/&gt;    GIVEN( &lt;span&gt;&quot;A vector with some items&quot;&lt;/span&gt; ) {&lt;br/&gt;        std::vector&amp;lt;int&amp;gt; v( 5 );&lt;br/&gt;&lt;br/&gt;        REQUIRE( v.size() == 5 );  // REQUIRE() 即 assert()&lt;br/&gt;        REQUIRE( v.capacity() &amp;gt;= 5 );&lt;br/&gt;&lt;br/&gt;        WHEN( &lt;span&gt;&quot;the size is increased&quot;&lt;/span&gt; ) {&lt;br/&gt;            v.resize( 10 );&lt;br/&gt;&lt;br/&gt;            THEN( &lt;span&gt;&quot;the size and capacity change&quot;&lt;/span&gt; ) {&lt;br/&gt;                REQUIRE( v.size() == 10 );&lt;br/&gt;                REQUIRE( v.capacity() &amp;gt;= 10 );&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        WHEN( &lt;span&gt;&quot;the size is reduced&quot;&lt;/span&gt; ) {&lt;br/&gt;            v.resize( 0 );&lt;br/&gt;&lt;br/&gt;            THEN( &lt;span&gt;&quot;the size changes but not capacity&quot;&lt;/span&gt; ) {&lt;br/&gt;                REQUIRE( v.size() == 0 );&lt;br/&gt;                REQUIRE( v.capacity() &amp;gt;= 5 );&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;组织结构&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原则：单元测试尽可能以函数方法等&lt;strong&gt;较小粒度&lt;/strong&gt;进行组织。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们有下边一个类，设计单元测试时，最好以各个功能函数为测试目标，而不是将类本身为测试目标：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// IPv4 报文解析&lt;br/&gt;struct IPv4Parser {&lt;br/&gt;    IPv4Parser(const void *buffer, size_t size);&lt;br/&gt;&lt;br/&gt;    size_t   GetHeaderSize();   // 获取头部大小&lt;br/&gt;    uint32_t GetSrcAddr();      // 获取源 IP&lt;br/&gt;    uint32_t GetDstAddr();      // 获取目的 IP&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建议：为 &lt;code&gt;GetHeaderSize()&lt;/code&gt; &lt;code&gt;GetSrcAddr()&lt;/code&gt; &lt;code&gt;GetDstAddr()&lt;/code&gt; 分别构造不同的测试输入数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不建议：为 &lt;code&gt;IPv4Parser&lt;/code&gt; 类构造测试输入数据，然后对 &lt;code&gt;GetHeaderSize()&lt;/code&gt; &lt;code&gt;GetSrcAddr()&lt;/code&gt; &lt;code&gt;GetDstAddr()&lt;/code&gt; 使用同样的数据进行单元测试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的测试框架都支持通过测试套件（TestSuite）对测试用例（TestCase）在&lt;strong&gt;逻辑上&lt;/strong&gt;进行组织，测试套件可以嵌套，整个单元测试可以组织为树状结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的测试框架还支持 Fixture。Fixture 是对&lt;strong&gt;测试环境&lt;/strong&gt;进行组织，通过 &lt;code&gt;SetUp()&lt;/code&gt; &lt;code&gt;TearDown()&lt;/code&gt; 函数，以方便进行测试开始前的准备工作，以及测试完成后的清理工作。Fixture 一般会与测试套件结合使用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5214814814814814&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavl9AxD71LyfJVCnqUbiac6nYdRw3m7EAdXG3x7ib3kp1s0rZZ3FyLZyf6SeYcYpbLhW1z6pJgibIvjw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1350&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;组织单元测试的几点准则：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;轻量：不要有过多的前置条件或外部依赖&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;section&gt;轻量的测试用例易于重复执行，方便重现和定位问题。&lt;/section&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;独立：同一个测试套件的不同的用例相互独立&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;测试用例之间尽量独立，避免依赖，可乱序执行，结果稳定复现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;隔离：使用测试套件隔离资源&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;使用测试套件与 Fixture 隔离测试用例的资源依赖，以方便管理。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;用例设计&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计单元测试用例中有很多方法：等价类划分、边界值分析、路径测试……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实践中，我们可以设计覆盖 &lt;strong&gt;正常流程 &amp;amp; 异常流程&lt;/strong&gt; 两大类用例：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;正常流程通过输入合法的 典型数据、边界值 看&lt;strong&gt;基本功能&lt;/strong&gt;是否正确实现&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异常流程通过输入非法数据看&lt;strong&gt;异常处理&lt;/strong&gt;流程是否符合预期&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个函数的内部实现可能是 &lt;strong&gt;异常处理-正常流程-异常处理-正常流程&lt;/strong&gt; 的重复，比如这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;size_t IPv4Parser::&lt;span&gt;&lt;span&gt;GetHeaderSize&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;  // 异常处理&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (buffer_size &amp;lt; sizeof(iphdr)) &lt;span&gt;return&lt;/span&gt; 0;&lt;br/&gt;&lt;br/&gt;  // 正常流程&lt;br/&gt;  auto ip = (const iphdr*) buffer;&lt;br/&gt;&lt;br/&gt;  // 异常处理&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (ip-&amp;gt;version != 4) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  // ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此我们在设计测试用例时，可以：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先设计覆盖 &lt;strong&gt;正常流程&lt;/strong&gt; 的用例，构造一些&lt;strong&gt;合法&lt;/strong&gt;的输入：一个典型的 IP 报文，一个有扩展头部的 IP 报文，一个带有 TCP/UDP payload 的 IP 报文……&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其次设计覆盖 &lt;strong&gt;异常流程&lt;/strong&gt; 的用例，构造一些&lt;strong&gt;非法&lt;/strong&gt;的输入：空指针，不完整的 IP 头，非 IP 协议……&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后再考虑一些边界情况：一个不带 payload 的 IP 报文，一个大小为 64K 上限的 IP 报文，一个头部完整但payload 不完整的 IP 报文……&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在设计测试用例过程中，可能会遇到被测函数需要与外部 DB、文件、网络交互的情况，这时候需要使用 Fakes/Stubs/Mocks 进行模拟：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Fakes：包含了生产环境下具体实现的简化版本的对象&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;比如模拟的数据库对象、文件描述符、网络连接等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Stubs：包含了预定义好的数据并且在测试时返回给调用者的对象&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;比如很多组预定义好的输入、输出数据，比如数据库查询结果。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Mocks：仅记录它们的调用信息的对象&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;比如模拟的文件保存接口、数据发送接口等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实践中通常并不纠结这几个词语的区别，常被统称为 &lt;strong&gt;插桩&lt;/strong&gt;，对应的工具也一般被称作 &lt;strong&gt;Mock 工具&lt;/strong&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;C++ 单元测试&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;常见单元测试框架&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.44280442804428044&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavl9AxD71LyfJVCnqUbiac6nItCQSmzpxXq5edVtl2sAeF9CzjK8CWFaKby8l4DRTUbIgibvbSxtoTA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1626&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;G&lt;/span&gt;&lt;span&gt;oogleTest 是老牌测试框架，功能完善，用户很多。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Catch2 是现代化测试框架，提供了很多特色功能，依赖简单，可以一试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Boost.Test 是 Boost 自带的测试框架，依赖 Boost 的程序可以直接使用，功能强大。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一些 Mock 工具&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;编译参数选项&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;开启调试信息：&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关闭优化和代码保护：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-O0&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-fno-inline&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-fno-access-control&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;覆盖率：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--coverage&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-fprofile-arcs&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-ftest-coverage&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Python 单元测试&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击阅读&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649761883&amp;amp;idx=2&amp;amp;sn=5662bb837bff12f79a1be41ccbd1825b&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《研效优化实践：Python单测——从入门到起飞》&lt;/a&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小经验分享&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三条准则&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;单元测试必须经常跑&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;错误做法：为了完成 KPI 写了一堆测试，跑一次就不管了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;正确做法：持续集成，自动化运行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;从增量到存量，从主要到次要&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从覆盖新模块、新功能做起，单元测试先跑起来再说&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不要追求 100% 的覆盖率，但主要功能逻辑要完成覆盖测试&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;测试用例需要逐步积累&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;上线前已经有了第一批用例，每次迭代都会增加新用例来覆盖变更&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实践经验&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;思路：以黑盒指导功能验证，以白盒提升覆盖率&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;黑盒测试为主：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;黑盒测试验证功能逻辑实现是否正确&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不关心内部实现方式，代码优化重构用例仍可复用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;白盒测试为辅：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;白盒测试关注黑盒测试用例遗漏的分支、路径&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以聚焦于异常处理逻辑是否合理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;项目工期紧时可推迟进行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;可能踩到的坑&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;不要被高覆盖率骗了&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;单元测试的目标是发现问题，不是追求高覆盖率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;宏、模板等语法功能可能会使得覆盖率虚高&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Debug/Release 目标结果不一致&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Debug 目标关闭优化，启用堆栈保护，某些错误代码可正常执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单测在 Debug 下跑完后，建议在 Release 下再跑一次&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码合并导致单测失败&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;小A和小B分别开发新功能，push 前单测都通过了，MR 后单测却挂了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用持续集成发现问题&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;提高代码的可测性&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在编码过程中，多多考虑代码的可测性，可以让单元测试事半功倍：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;开发过程及时编写测试用例，&lt;strong&gt;边开发边测试&lt;/strong&gt;，不要等全部开发完毕了才开始写测试用例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;函数功能简单，避免随机性，以免测试结果不稳定&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;函数减少输入输出，使简单的输入数据组合可以完成测试覆盖&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;遵循 SOLID 原则&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最后&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际研发与测试工作中，单元测试是保证代码质量的有效手段，也是效能优化实践的重要一环。安平研效团队仍在持续探索优化中，若大家在工作中遇到相关问题，欢迎一起交流探讨，共同把研效工作做好、做强。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fafc2dc718d55138eaa943bb4debf618</guid>
<title>如何清晰地掌握 Android 应用中后台任务的执行情况？</title>
<link>https://toutiao.io/k/qpbpvde</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot; usegifprops=&quot;[object Object]&quot;&gt;&lt;p&gt;Android Studio 包含了许多像 &lt;b&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/145238588&quot; class=&quot;internal&quot;&gt;布局检查器&lt;/a&gt;&lt;/b&gt; 和 &lt;b&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/141689768&quot; class=&quot;internal&quot;&gt;数据库检查器&lt;/a&gt;&lt;/b&gt; 这样的检查器，来帮助您调查并了解应用在运行时的内部状态。在 &lt;b&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/375208544&quot; class=&quot;internal&quot;&gt;Android Studio Arctic Fox&lt;/a&gt;&lt;/b&gt; 中，我们发布了一个新的检查器 (Background Task Inspector)，用于帮助您监控和调试在应用中使用 WorkManager 2.5.0 或更高版本所调度的 Worker。&lt;/p&gt;&lt;p&gt;对于运行后台的异步任务，甚至是在应用被关闭之后的情况下，都推荐使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/topic/libraries/architecture/workmanager&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;WorkManager&lt;/a&gt;&lt;/b&gt;。虽然可以很方便的将任务配置成 WorkManager 的 Worker，但将 Worker 加入到队列中后就很难监控它的执行情况，遇到问题也不方便调试。&lt;/p&gt;&lt;p&gt;您可以通过后台任务检查器轻松地监控一个 Worker 的工作状态，查看它和与其链接的其他 Worker 的关系，或者检查 Worker 的输出、频率及其他与时间相关的信息。让我们通过一个示例项目来看看后台任务检查器能做些什么。&lt;/p&gt;&lt;p&gt;我将使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/android/architecture-components-samples/tree/main/WorkManagerSample&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;architectural-components 仓库&lt;/a&gt;&lt;/b&gt; 中的 WorkManager 示例应用来演示后台任务检查器 (需要将工程中 versions.gradle 里的 versions.work 设置为 2.5.0 或更高版本以使得 Background Task Inspect 更好的工作)。如果您想试一试，可以检出该仓库并随着阅读文章一起尝试。该应用使用 WorkManager 将用户所选择的滤镜应用在已挑选的照片上。用户可以通过该应用在图库中选择一张图片或者简单地使用一张库存照片。为了演示后台任务检查器如何工作，我将会运行应用并选择一张图片来应用滤镜。&lt;/p&gt;&lt;figure data-size=&quot;small&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-021c937850e4a1374a7d0f2e500d4ab0_b.gif&quot; data-size=&quot;small&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;2220&quot; data-thumbnail=&quot;https://pic1.zhimg.com/v2-021c937850e4a1374a7d0f2e500d4ab0_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-021c937850e4a1374a7d0f2e500d4ab0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;2220&quot; data-thumbnail=&quot;https://pic1.zhimg.com/v2-021c937850e4a1374a7d0f2e500d4ab0_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-021c937850e4a1374a7d0f2e500d4ab0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-021c937850e4a1374a7d0f2e500d4ab0_b.gif&quot;/&gt;&lt;figcaption&gt;△ 为选定的图像应用所选的滤镜&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这些滤镜都是作为 WorkManager Worker 实现的。稍等一会儿该应用就会展示应用了所选滤镜的图片。在不了解示例应用的情况下，来看看我还能通过后台任务检查器知道些什么。&lt;/p&gt;&lt;p&gt;选择菜单栏上的 View &amp;gt; Tool Windows &amp;gt; App Inspection 打开后台任务检查器。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-33016edf404b18c5411d41d09e52a9cd_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;700&quot; data-rawheight=&quot;538&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-33016edf404b18c5411d41d09e52a9cd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;700&quot; data-rawheight=&quot;538&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-33016edf404b18c5411d41d09e52a9cd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-33016edf404b18c5411d41d09e52a9cd_b.jpg&quot;/&gt;&lt;figcaption&gt;△ View &amp;amp;amp;gt; Tool Windows &amp;amp;amp;gt; App Inspection&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;在 App Inspection (应用检查) 窗口中选择 Background Task Inspector 栏后，我在 API 级别 26 或更高的设备/模拟器上再次运行该应用。如果没有自动选中应用，在下拉菜单中选择应用进程。连接到应用进程后，就可以回到我正在运行的应用，选择所有的滤镜并点击 &quot;APPLY&quot;。此时我可以在后台任务检查器中看到运行中的作业列表。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-efde8e8a059a324e1a89284df87030bd_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;700&quot; data-rawheight=&quot;216&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-efde8e8a059a324e1a89284df87030bd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;700&quot; data-rawheight=&quot;216&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-efde8e8a059a324e1a89284df87030bd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-efde8e8a059a324e1a89284df87030bd_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 正在运行的作业列表&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;后台任务检查器列出了所有正在运行、已失败和已完成作业的类名、当前状态、开始时间、重试次数以及输出数据。点击列表中的一个作业打开 Work Details 面板。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-80bc7aead273abbf198ee99b14bcf797_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;700&quot; data-rawheight=&quot;222&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-80bc7aead273abbf198ee99b14bcf797_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;700&quot; data-rawheight=&quot;222&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-80bc7aead273abbf198ee99b14bcf797_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-80bc7aead273abbf198ee99b14bcf797_b.jpg&quot;/&gt;&lt;figcaption&gt;△ Work Details 面板&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;该面板提供了 Worker 的 Description (描述)、Execution (执行情况)、WorkContinuation (工作延续性) 和 Results (结果)。让我们来仔细看看每个部分。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fa90d8cc5d7580fe58145fe38a01cb0c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;627&quot; data-rawheight=&quot;152&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-fa90d8cc5d7580fe58145fe38a01cb0c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;627&quot; data-rawheight=&quot;152&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-fa90d8cc5d7580fe58145fe38a01cb0c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-fa90d8cc5d7580fe58145fe38a01cb0c_b.jpg&quot;/&gt;&lt;figcaption&gt;△ Work Details&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Description (描述) 一节列出了 Worker 包含完全限定软件包名称、指派给它的标签和它的 UUID。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-79c796c0e28b93de9386f49d1cfe009d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;507&quot; data-rawheight=&quot;107&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-79c796c0e28b93de9386f49d1cfe009d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;507&quot; data-rawheight=&quot;107&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-79c796c0e28b93de9386f49d1cfe009d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-79c796c0e28b93de9386f49d1cfe009d_b.jpg&quot;/&gt;&lt;figcaption&gt;△ Execution&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;接下来，Execution (执行情况) 一节展示了 Worker 的约束 (如果有)、运行频率、状态以及是哪个类创建了该 worker 并将其加入了队列。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-112e318aa1a61f3dcd102dac11f4f2f9_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;602&quot; data-rawheight=&quot;199&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-112e318aa1a61f3dcd102dac11f4f2f9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;602&quot; data-rawheight=&quot;199&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-112e318aa1a61f3dcd102dac11f4f2f9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-112e318aa1a61f3dcd102dac11f4f2f9_b.jpg&quot;/&gt;&lt;figcaption&gt;△ WorkContinuation&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;WorkContinuation (工作延续性) 一节显示了该 Worker 在工作链上的位置。您可以检查前一个、后一个或工作链上的其他 Worker (如果有)。您可以通过点击另一个 Worker 的 UUID 导航到它的详情。在这个工作链上，我能看到应用使用了 5 个不同的 Worker。Worker 的数量根据用户选择的滤镜情况可能有所不同。&lt;/p&gt;&lt;p&gt;这是个很棒的功能，但当您面对不熟悉的应用时不一定能想象出工作链。而后台任务检查器另一个很棒的特性就是它能够以图形化的形式展示工作链。仅需点击 WorkContinuation 一节中的 &quot;Show in graph&quot; 链接或点击作业列表顶部的 &quot;show Graph View&quot; 按钮来切换到 Graph View 即可。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3bca49781bd8ca1c744dc0115de473bc_b.gif&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2582&quot; data-rawheight=&quot;836&quot; data-thumbnail=&quot;https://pic1.zhimg.com/v2-3bca49781bd8ca1c744dc0115de473bc_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-3bca49781bd8ca1c744dc0115de473bc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2582&quot; data-rawheight=&quot;836&quot; data-thumbnail=&quot;https://pic1.zhimg.com/v2-3bca49781bd8ca1c744dc0115de473bc_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-3bca49781bd8ca1c744dc0115de473bc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-3bca49781bd8ca1c744dc0115de473bc_b.gif&quot;/&gt;&lt;figcaption&gt;△ Graph View&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Graph View 能帮您了解 Worker 的顺序、在不同阶段之间传递的数据以及它们各自的状态。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e20b60a93d0bb6ac15590e0d2937d39a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;620&quot; data-rawheight=&quot;115&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-e20b60a93d0bb6ac15590e0d2937d39a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;620&quot; data-rawheight=&quot;115&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-e20b60a93d0bb6ac15590e0d2937d39a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-e20b60a93d0bb6ac15590e0d2937d39a_b.jpg&quot;/&gt;&lt;figcaption&gt;△ Results&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Work Details 面板的最后一节是 Results 窗格。在这一节您能看到选中的 Worker 的开始时间、重试次数及输出数据。&lt;/p&gt;&lt;p&gt;现在假设我想测试当一个 Worker 停止时会发生什么。为了实现这个目的，我将再次运行应用，选择 Worker，等它的状态变为正在运行后点击左上角的 &quot;Cancel Selected Work&quot; 按钮。一旦我这么做了，我选择的 Worker 和链中剩余的 Worker 的状态都将变为 Canceled。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5a062b9c5e8fb0144bb847d1eb716ddc_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;700&quot; data-rawheight=&quot;318&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-5a062b9c5e8fb0144bb847d1eb716ddc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;700&quot; data-rawheight=&quot;318&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-5a062b9c5e8fb0144bb847d1eb716ddc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-5a062b9c5e8fb0144bb847d1eb716ddc_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 您可以取消任何正在运行的 Worker&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;如果您的应用中包含像这样复杂的链式关系，那 Graph View 就会很有用。您能够在这个图中快速查看一组复杂的 Worker 之间的关系并监控它们的进展。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5797dfef65e70aee8ba99c5152ee5dc4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;700&quot; data-rawheight=&quot;367&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-5797dfef65e70aee8ba99c5152ee5dc4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;700&quot; data-rawheight=&quot;367&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-5797dfef65e70aee8ba99c5152ee5dc4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-5797dfef65e70aee8ba99c5152ee5dc4_b.jpg&quot;/&gt;&lt;figcaption&gt;△ WorkManager 艺术展示 =)&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;如果您想用后台任务检查器尝试一些更复杂的图形或者制作一些 WorkManager 艺术，请参阅 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gist.github.com/yenerm/60207091db3b9c1b0eca9b70f6475cd7&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;DummyWorker 代码&lt;/a&gt;&lt;/b&gt;，并将其 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gist.github.com/yenerm/b9744b24614fb29cedf47e36df3248b4&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;加入到 continuation 对象&lt;/a&gt;&lt;/b&gt; 中。&lt;/p&gt;&lt;p&gt;后台任务检查器将会跟随 Android Studio Arctic Fox 的发布一同推出，但您现在就可以在 &lt;b&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/375208544&quot; class=&quot;internal&quot;&gt;最新的 Arctic Fox 版本&lt;/a&gt;&lt;/b&gt; 中试用！如果您的应用使用了 WorkManager，请尝试使用并告诉我们您的想法，或者和我们分享您的 WorkManager 艺术！&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>