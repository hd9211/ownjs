<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>cb0a51d8ebddc6b71980236f4745b12e</guid>
<title>「码农周刊 VIP 会员专属邮件周报」每周五发送，赶紧上车吧！</title>
<link>https://toutiao.io/k/zskhwzb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;我爱程序员&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;developerWorks&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;我们的产品：《码农周刊》 http://manong.io/ 、《开发者头条》 http://toutiao.io/&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ef837d0286ce7a1866ce8c839df10d49</guid>
<title>[推荐] 你管这破玩意儿叫高可用</title>
<link>https://toutiao.io/k/qudsbeg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;span&gt;今天我们来聊一下互联网三高（高并发、高性能、高可用）中的高可用，看完本文相信能解开你关于高可用设计的大部分困惑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;高可用（High availability，即 HA）的主要目的是为了保障「业务的连续性」，即在用户眼里，业务永远是正常（或者说基本正常）对外提供服务的。高可用主要是针对架构而言，那么要做好高可用，就要首先设计好架构，第一步我们一般会采用分层的思想将一个庞大的 IT 系统拆分成为应用层，中间件，数据存储层等独立的层，每一层再拆分成为更细粒度的组件，第二步就是让每个组件对外提供服务，毕竟每个组件都不是孤立存在的，都需要互相协作，对外提供服务才有意义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要保证架构的高可用，就要保证架构中所有组件以及其对外暴露服务都要做高可用设计，任何一个组件或其服务没做高可用，都意味着系统存在风险。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么这么多组件该怎么做高可用设计呢，其实任何组件要做高可用，都离不开「冗余」和「自动故障转移」，众所周知单点是高可用的大敌，所以组件一般是以集群（至少两台机器）的形式存在的，这样只要某台机器出现问题，集群中的其他机器就可以随时顶替，这就是「冗余」。简单计算一下，假设一台机器的可用性为 90%，则两台机器组成的集群可用性为 1-0.1*0.1 = 99%，所以显然冗余的机器越多，可用性越高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但光有冗余还不够，如果机器出现问题，需要人工切换的话也是费时费力，而且容易出错，所以我们还需要借助第三方工具（即仲裁者）的力量来实现「自动」的故障转移，以达到实现&lt;/span&gt;&lt;span&gt;近实时&lt;/span&gt;&lt;span&gt;的故障转移的目的，&lt;/span&gt;&lt;span&gt;近实时的故障转移才是高可用的主要意义&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;怎样的系统可以称之为高可用呢，业界一般用几个“九”来衡量系统的可用性，如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6686103012633625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxECjvy7L8AZicH8XP4AbRqRxpFgsx4rKKOTOmCL4lL9I6QzGdh2yvZgeN7kX6qd3px0MLvjibfGauA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1029&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般实现两个 9 很简单，毕竟每天宕机 14 分钟已经严重影响业务了，这样的公司迟早歇菜，大厂一般要求 4 个 9，其他要求严苛的业务要达到五个九以上，比如如果因为一个电脑的故障导致所有列车停驶，那么就会有数以万计的人正常生活受到阻碍，这种情况就要求五个九以上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来我们就来一起看看架构中的各个组件如何借助「冗余」和「自动故障转移」来实现高可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 互联网架构剖析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前多数互联网都会采用微服务架构，常见架构如下:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9707792207792207&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFF2y5qicTib6bSVPvebnjeAzMMqAWTWB2r5Bx5Vwz2THY50RIic1nBMmgQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;924&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到架构主要分以下几层：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;接入层&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：主要由 F5 硬件或 LVS 软件来承载所有的流量入口；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;反向代理层&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Nginx，主要负责根据 URL 来分发流量，限流等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;网关&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：主要负责流控、风控、协议转换等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;站点层&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：主要负责调用会员，促销等基本服务来装配 JSON 等数据并返回给客户端；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;基础 service&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：其实与站点层都属于微服务，是平级关系，只不过基础 service 属于基础设施，能被上层的各个业务层 server 调用而已；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;存储层&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：也就是 DB，如 MySQL、Oracle 等，一般由基础 service 调用返回给站点层；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;中间件&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：ZK、ES、Redis、MQ 等，主要起到加速访问数据等功能，在下文中我们会简单介绍下各个组件的作用。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如前所述，要实现整体架构的高可用，必须要实现每一层组件的高可用，接下来我们就来分别看一下每一层的组件都是如何实现高可用的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 接入层 &amp;amp; 反向代理层&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这两层的高可用都和 keepalived 有关，所以我们结合起来一起看。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0052447552447552&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFVgylNIdGrhDkSF8FibpNr6eoUGjEibuCFm4bmcz5ibszdZ6XefKTwG9LA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;572&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对外，两个 LVS 以主备的形式对外提供服务，注意只有 master 在工作（即此时的 VIP 在 master 上生效），另外一个 backup 在 master 宕机之后会接管 master 的工作，那么 backup 怎么知道 master 是否正常呢？答案是通过 keepalived，在主备机器上都装上 keepalived 软件，启动后就会通过心跳检测彼此的健康状况，一旦  master 宕机，keepalived 会检测到，从而 backup 自动转成 master 对外提供服务，此时 VIP 地址（即图中的 115.204.94.139）即在 backup 上生效，也就是我们常说的「IP漂移」，通过这样的方式即解决了 LVS 的高可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;keepalived 的心跳检测主要通过发送 ICMP 报文，或者利用 TCP 的端口连接和扫描检测来检测的，同样的，它也可以用来检测 Nginx 暴露的端口，这样的话如果某些 Nginx 不正常 Keepalived 也能检测到并将其从 LVS 能转发的服务列表中剔出。Nginx也能通过端口检测服务健康状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;借用 keepalived 这个第三方工具，同时实现了 LVS 和 Nginx 的高可用，同时在出现故障时也可以将宕机情况发送到对应开发人员的邮箱以让他们及时收到通知处理，确实很方便，Keepalived 应用广泛，下文我们会看到它也可以用在 MySQL 上来实现 MySQL 的高可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 微服务&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来我们再来看一下「网关」、「站点层」、「基础服务层」，这三者一般就是我们所说的微服务架构组件。当然这些微服务组件还需要通过一些 RPC 框架如 Dubbo 来支撑才能通信，所以微服务要实现高可用，就意味着 Dubbo 这些 RPC 框架也要提供支撑微服务高可用的能力，我们就以 Dubbo 为例来看下它是如何实现高可用的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们先来简单地看下 Dubbo 的基本架构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7773584905660378&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFvmiaryD4ebUrFo6Be22J24afz1w72oyUlyOemjYH7ZBccsV5RpcyCMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1060&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;思路也很简单，首先是 Provider（服务提供者）向 Registry（注册中心，如 ZK 或 Nacos 等）注册服务，然后 Consumer（服务消费者）向注册中心订阅和拉取 Provider 服务列表，获取服务列表后，Consumer 就可以根据其负载均衡策略选择其中一个  Provider 来向其发出请求，当其中某个 Provider 不可用（下线或者因为 GC 阻塞等）时，会被注册中心及时监听（通过心跳机制）到，也会及时推送给 Consumer，这样 Consumer 就能将其从可用的 Provider 列表中剔除，也就实现了故障的自动转移，不难看出，注册中心就起到了类似 keepalived 的作用。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4. 中间件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们再来看下这些中间件如 ZK、Redis 等是如何实现高可用的呢。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.1 ZooKeeper（ZK）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;h4/&gt;&lt;h4/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上一节微服务中我们提到了注册中心，那我们就以 ZK 为例来看看它的高可用是如何实现的，先来看下它的整体架构图如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5825&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGF48MtucWD8DPMCz0mfjqytSlSvljubib3ia1xIR6La51orJIssR1ISmZA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;800&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Zookeeper 中的主要角色如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Leader&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;即领导者，在集群中只有一个 Leader，主要承担了以下的功能：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;事务请求的唯一调度和处理者，保证集群事务处理的顺序性，所有 Follower 的写请求都会转给 Leader 执行，用来保证事务的一致性；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;集群内部各服务器的调度者：处理好事务请求后，会将数据广播同步到各个 Follower，统计 Follower 写入成功的数量，超过半数 Follower 写入成功，Leader 就会认为写请求提交成功，通知所有的 Follower commit 这个写操作，保证事后哪怕是集群崩溃恢复或者重启，这个写操作也不会丢失。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Follower&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;处理客户端非事务请求、转发事务请求给 leader 服务器；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;参与事物请求 Proposal 的投票（需要半数以上服务器通过才能通知 leader commit 数据; Leader 发起的提案，要求 Follower 投票）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;参与 Leader 选举的投票。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;画外音：Zookeeper 3.0 之后新增了一种 Observer 的角色，不过与此处讨论的 ZK 高可用关系不是很大，为了简化问题，所以省略。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到由于只有一个 Leader，很显然，此 Leader 存在单点隐患，那么 ZK 是怎么解决此问题的呢，首先 Follower 与 Leader 会用心跳机制保持连接，如果 Leader 出现问题了（宕机或者因为 FullGC 等原因无法响应），Follower 就无法感知到 Leader 的心跳，就会认为 Leader 出问题了，于是它们就会发起投票选举，最终在多个 Follower 中选出一个 Leader 来（这里主要用到了 Zookeeper Atomic Broadcast，即 ZAB 协议，它是为 ZK 专门设计的一种支持崩溃恢复的一致性协议），选举的细节不是本文重点，就不在此详述了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了 ZAB 协议，业界上常用的还有 Paxos，Raft 等协议算法，也可以用在 Leader 选举上，也就是是在分布式架构中，这些协议算法承担了“第三者”也就是仲裁者的作用，以承担故障的自动转移。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.2 Redis&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis 的高可用需要根据它的部署模式来看看，主要分为「主从模式」和「Cluster 分片模式」两种。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h5&gt;&lt;strong&gt;&lt;span&gt;主从模式&lt;/span&gt;&lt;/strong&gt;&lt;/h5&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先来看一下主从模式，架构如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0134529147982063&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFFWlG0mOU7CGJ7PocwSNywKzyqLicoR0dPFSGYSZxeyqpyz4vBib9j39g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;446&quot; title=&quot;主从模式&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;主从模式&lt;/span&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;主从模式即一主多从（一个或者多个从节点），其中主节点主要负责读和写，然后会将数据同步到多个从节点上，Client 也可以对多个从节点发起读请求，这样可以减轻主节点的压力，但和 ZK 一样，由于只有一个主节点，存在单点隐患，所以必须引入第三方仲裁者的机制来判定主节点是否宕机以及在判定主节点宕机后快速选出某个从节点来充当主节点的角色，这个第三方仲裁者在 Redis 中我们一般称其为「哨兵」（sentinel），当然哨兵进程本身也有可能挂掉，所以为了安全起见，需要部署多个哨兵（即哨兵集群）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4821428571428572&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFjCMq4hjcVibRr7ODrhBwMJG1wfAJOaO3F5VGpJ9GyEAgTWhM1yPyEAg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;504&quot; title=&quot;哨兵集群&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;哨兵集群&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些哨兵通过 Gossip（流言） 协议来接收关于主服务器是否下线的信息，并在判定主节点宕机后使用 Raft 协议来选举出新的主节点。&lt;/span&gt;&lt;/p&gt;&lt;h5&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5&gt;&lt;strong&gt;&lt;span&gt;Cluster 分片集群&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主从模式看似完美，但存在以下几个问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;主节点写的压力难以降低：因为只有一个主节点能接收写请求，如果在高并发的情况下，写请求如果很高的话可能会把主节点的网卡打满，造成主节点对外无法服务；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;主节点的存储能力受到单机存储容量的限制：因为不管是主节点还是从节点，存储的都是全量缓存数据，那么随着业务量的增长，缓存数据很可能直线上升，直到达到存储瓶颈；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;同步风暴：因为数据都是从 master 同步到 slave 的，如果有多个从节点的话，master 节点的压力会很大。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了解决主从模式的以上问题，分片集群应运而生，所谓分片集群即将数据分片，每一个分片数据由相应的主节点负责读写，这样的话就有多个主节点来分担写的压力，并且每个节点只存储部分数据，也就解决了单机存储瓶颈的问题，但需要注意的是每个主节点都存在单点问题，所以需要针对每个主节点做高可用，整体架构如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.731457800511509&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGF14icPLDKtw0iagY9sFicsZrFDibZESUInZXgbAq2J6iaaAtF7z6EEWiaoIOg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;782&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原理也很简单，在 Proxy 收到 client 执行的 redis 的读写命令后，首先会对 key 进行计算得出一个值，如果这个值落在相应 master 负责的数值范围（一般将每个数字称为槽，Redis 一共有 16384 个槽）之内，那就把这条 redis 命令发给对应的 master 去执行，可以看到每个 master 节点只负责处理一部分的 redis 数据，同时为了避免每个 master 的单点问题，也为其配备了多个从节点以组成集群，当主节点宕机时，集群会通过 Raft 算法来从从节点中选举出一个主节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.3 Elasticsearch（ES）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再来看一下 ES 是如何实现高可用的，在 ES 中，数据是以分片（Shard）的形式存在的。如下图所示，一个节点中索引数据共分为三个分片存储：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4613259668508287&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFicqfXTgHCVicUOE5iaLX0J1ogI140QfpkaQGCRAW6U52VNXeq3gj4DPtQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;362&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但只有一个节点的话，显然存在和 Redis 的主从架构一样的单点问题，这个节点挂了，ES 也就挂了，所以显然需要创建多个节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46344086021505376&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFYLmibg8rMgib2wCwcTicmiaoElKcI3ZnR5UrkHTxaOAFAjg4OAmfQ7h20g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;930&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一旦创建了多个节点，分片（图中 P 为主分片，R 为副本分片）的优势就体现出来了，可以将分片数据分布式存储到其它节点上，极大提升了数据的水平扩展能力，同时每个节点都能承担读写请求，采用负载均衡的形式避免了单点的读写压力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ES 的写机制与 Redis 和 MySQL 的主从架构有些差别（后两者的写都是直接向 master 节点发起写请求，而 ES 则不是），所以这里稍微解释一下 ES 的工作原理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先说下节点的工作机制，节点（Node）分为主节点（Master Node）和从结点（Slave Node），主节点的主要职责是负责集群层面的相关操作，管理集群变更，如创建或删除索引，跟踪哪些节点是集群的一部分，并决定哪些分片分配给相关的节点，主节点也只有一个，一般通过类 Bully 算法来选举出来，如果主节点不可用了，则其他从节点也可以通过此算法来选举以实现集群的高可用，任何节点都可以接收读写请求以达到负载均衡的目的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再说一下分片的工作原理，分片分为主分片（Primary Shard，即图中 P0，P1，P2）和副本分片（Replica Shard，即图中 R0，R1，R2），主分片负责数据的写操作，所以虽然任何节点可以接收读写请求，但如果此节点接收的是写请求并且没有写数据所在的主分片话，此节点会将写请求调度到主分片所在的节点上，写入主分片后，主分片再把数据复制到其他节点的副本分片上，以有两个副本的集群为例，写操作如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3515704154002026&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGF693SL8F4eVU8zOQjwcndJIKL38DBIp1ThXwpnDZjSicvibq8N8N0zEcQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;987&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h4&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.4 Message Queue（MQ）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ES 利用数据分片来提升高可用和水平扩展能力的思想也应用在其他组件的架构设计上，我们以 MQ 中的 Kafka 为例再来看下数据分片的应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6520833333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGF5QticRNDibRbvK5yY68X5bXiaUKboEibtbFBfVHhPBoUXg5K3B17WXkGyw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot; title=&quot;Kafka 高可用设计，图片来自《武哥漫谈IT》&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;Kafka 高可用设计，图片来自《武哥漫谈IT》&lt;/span&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;如上是 Kafka 集群，可以看到每个 Topic 的 Partition 都分布式存储在其它消息服务器上，这样一旦某个 Partition 不可用，可以从 follower 中选举出 leader 继续服务，不过与 ES 中的数据分片不同的是，follower Partition 属于冷备，也就是说在正常情况下不会对外服务，只有在 leader 挂掉之后从 follower 中选举出 leader 后它才能对外提供服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5. 存储层&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来我们再来看一下最后一层，存储层（DB），这里我们以 MySQL 为例来简单地讨论一下其高可用设计，其实大家如果看完了以上的高可用设计，会发现 MySQL 的高可用也不过如此，思想都是类似的，与 Redis 类似，它也分主从和分片（即我们常说的分库分表）两种架构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主从的话与 LVS 类似，一般使用 keepalived 的形式来实现高可用，如下所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.647766323024055&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFgHR6pzBAx1fEzzgiaaax5JBlcWFXOz4uiaNBBBGlX2YYzGngfYOCpKBg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;582&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果 master 宕机了，Keepalived 也会及时发现，于是从库会升级主库，并且 VIP 也会“漂移”到原从库上生效，所以说大家在工程配置的 MySQL 地址一般是 VIP 以保证高可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据量大了之后就要分库分表了，于是就有了多主，就像 Redis 的分片集群一样，需要针对每个主配备多个从，如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5478170478170478&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFmmhvFuzrI226JU1zyEKGwOdvecu8iaLXLVw2Cko1p5ppByw4Hd8k8tw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;962&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;之前有读者问分库分表之后为啥还要做主从，现在我想大家应该都明白了，不是为了解决读写性能问题，主要是为了实现高可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完了架构层面的高可用设计，相信大家对高可用的核心思想「冗余」和「自动故障转移」会有更深刻的体会，观察以上架构中的组件你会发现冗余的主要原因是因为只有一主，为什么不能有多主呢，也不是不可以，但这样在分布式系统下要保证数据的一致性是非常困难的，尤其是节点多了的话，数据之间的同步更是一大难题，所以多数组件采用一主的形式，然后再在主和多从之间同步，多数组件之所以选择一主本质上是技术上的 tradeoff。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么做好每个组件的高可用之后是否整个架构就真的可用了呢，非也，这只能说迈出了第一步，在生产上还有很多突发情况会让我们的系统面临挑战，比如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;瞬时流量问题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：比如我们可能会面临秒杀带来的瞬时流量激增导致系统的承载能力被压垮，这种情况可能影响日常交易等核心链路，所以需要做到系统之间的隔离，如单独为秒杀部署一套独立的集群；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;安全问题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：比如 DDOS 攻击，爬虫频繁请求甚至删库跑路等导致系统拒绝服务；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;代码问题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：比如代码 bug 引起内存泄露导致 FullGC 导致系统无法响应等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;部署问题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：在发布过程中如果贸然中止当前正在运行的服务也是不行的，需要做到优雅停机，平滑发布；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第三方问题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：比如我们之前的服务依赖第三方系统，第三方可能出问题导致影响我们的核心业务；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;不可抗力&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：如机房断电，所以需要做好容灾，异地多活，之前我司业务就由于机房故障导致服务四小时不可用，损失惨重。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以除了做好架构的高可用之外，我们还需要在做好系统隔离，限流，熔断，风控，降级，对关键操作限制操作人权限等措施以保证系统的可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里特别提一下降级，这是为了保证系统可用性采取的常用的措施，简单举几个例子：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;我们之前对接过一个第三方资金方由于自身原因借款功能出了问题导致无法借款。这种情况为了避免引起用户恐慌，于是我们在用户申请第三方借款的时候返回了一个类似「为了提升你的额度，资金方正在系统升级」这样的文案，避免了客诉；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在流媒体领域，当用户观看直播出现严重卡顿时，很多企业的第一选择不是查 log 排查问题，而是为用户自动降码率。因为比起画质降低，卡得看不了显然会让用户更痛苦；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;双十一零点高峰期，我们把用户的注册登录等非核心功能给停掉了，以保证下单等核心流程的顺利。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外我们最好能做到事前防御，在系统出问题前把它扼杀在摇篮里，所以我们需要做单元测试，做全链路压测等来发现问题，还需要针对 CPU，线程数等做好&lt;strong&gt;监控&lt;/strong&gt;，当其达到我们设定的域值时就触发告警以让我们及时发现修复问题（我司之前就碰到过一个类似的&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651486188&amp;amp;idx=1&amp;amp;sn=46cc45885e42c0d5028359ba85193eca&amp;amp;chksm=bd251b938a529285c1ade09ffeac58fc88e997b02c028cd911514861e278b243efdc4e26b9e1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;‍生产事故复盘‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;生产事故复盘&lt;/span&gt;&lt;/a&gt;&lt;span&gt;大家可以看一下），此外在做好单元测试的前提下，依然有可能因为代码的潜在 bug 引起线上问题，所以我们需要在关键时间（比如双十一期间）封网（也就是不让发布代码）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外我们还需要在出事后能快速定位问题，快速回滚，这就需要记录每一次的发布时间，发布人等，这里的发布不仅包括工程的发布，还包括配置中心等的发布。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2505733944954128&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFDZduepG2dgaBNDNkI7HVfXQ2l4WMzgHtc2Wiasgm0SHiaLdPZKWbZ4ew/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3488&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;画外音：上图是我司的发布记录，可以看到有代码变更，回滚等，这样如果发现有问题的话可以一键回滚。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后我们以一张图来总结一下高可用的常见手段：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7684887459807074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGF6n4vJibqCjicK5G405dyccnUoPVfU14fp7TtyfiaYbW89nEumuWJkAW7g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;622&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651506905&amp;amp;idx=2&amp;amp;sn=be4dc72831a156ff656ca5c40e643944&amp;amp;chksm=bd25a4a68a522db0b135b5fb87ffc5b76c27aeeaf9407a3ca7beadda7b47b61e06a963556516&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;B站高可用架构实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;B站高可用架构实践&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651496233&amp;amp;idx=2&amp;amp;sn=213ecb44769419caa0121e90e12d57e7&amp;amp;chksm=bd25f3568a527a40763d094b84609e27bea2b05e42819bb0898f97907a4ebb67c5a33fc7f9ff&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Kafka宕机后不再高可用？探究Kafka高可用实现&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Kafka宕机后不再高可用？探究Kafka高可用实现&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651498116&amp;amp;idx=2&amp;amp;sn=dcc1fb4707cbc355679d4f1c9af91c72&amp;amp;chksm=bd25cafb8a5243ed6ffcfb07c004c1a4518d98a6c503fd457cfff099c3fa46fee3d48a870ebd&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Elastic Job从单点到高可用、同城主备、同城双活&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Elastic Job从单点到高可用、同城主备、同城双活&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点赞和在看就是最大的支持❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9a956ed1c93b6e6321cedbaea6d0f255</guid>
<title>[推荐] 消息队列经典十连问，你能扛到第几问？</title>
<link>https://toutiao.io/k/8jfl3pp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好呀。金三银四即将来临，整理了十道十分经典的消息队列面试题，看完肯定对面试有帮助的，大家一起加油哈~&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;什么是消息队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息队列的应用场景&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息队列如何解决消息丢失问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息队列如何保证消息的顺序性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息有可能发生重复消费吗？如何幂等处理？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何处理消息队列的消息积压问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息队列技术选型，Kafka还是RocketMQ，还是RabbitMQ&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息中间件如何做到高可用？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何保证数据一致性，事务消息如何实现&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果让你写一个消息队列，该如何进行架构设计？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 什么是消息队列&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以把消息队列理解为一个&lt;strong&gt;使用队列来通信&lt;/strong&gt;的组件。它的本质，就是个&lt;strong&gt;转发器&lt;/strong&gt;，包含&lt;strong&gt;发消息、存消息、消费消息&lt;/strong&gt;的过程。最简单的消息队列模型如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2651869158878505&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZXia000yHwcrHRuBWJkhDaIYnL9QPC0hNk3Kor0vJCVVLKUKYvNbf7FA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;856&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通常说的消息队列，简称&lt;strong&gt;MQ（Message Queue）&lt;/strong&gt;，它其实就指&lt;strong&gt;消息中间件&lt;/strong&gt;，当前业界比较流行的开源消息中间件包括：&lt;code&gt;RabbitMQ、RocketMQ、Kafka&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 消息队列有哪些使用场景。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候面试官会换个角度问你，&lt;strong&gt;为什么使用消息队列&lt;/strong&gt;。你可以回答以下这几点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;应用解耦&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;流量削峰&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异步处理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息通讯&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;远程调用&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 应用解耦&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个常见业务场景：下单扣库存，用户下单后，订单系统去通知库存系统扣减。传统的做法就是订单系统直接调用库存系统：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3371710526315789&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZYuic2iaAbIW1SicOAg37ictQ6GSMAaqnxg5YcB1SePEQD3AaK3ib1VD9hoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;608&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果库存系统&lt;strong&gt;无法访问&lt;/strong&gt;，下单就会失败，订单和库存系统存在耦合关系&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果业务又接入一个营销积分服务，那订单下游系统要扩充，如果未来接入越来越多的下游系统，那订单系统代码需要经常&lt;strong&gt;修改&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6386554621848739&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZng2aZTdnOJWNq87kyVibrfiaicAvaDRADBFImjSIXTDlJwjJdmQMPaaIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;595&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何解决这个问题&lt;/strong&gt;呢？可以引入消息队列&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36862244897959184&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZpibLq2pOkKrDWkfjjchpuy2MZg9PvQTIrs62Usrn83mAz0oaQu0icGUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;784&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;订单系统：用户下单后，消息写入到消息队列，返回下单成功&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;库存系统：订阅下单消息，获取下单信息，进行库存扣减操作。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 流量削峰&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流量削峰也是&lt;strong&gt;消息队列的常用场景&lt;/strong&gt;。我们做秒杀实现的时候，需要避免流量暴涨，打垮应用系统的风险。可以在应用前面加入消息队列。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21443965517241378&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZdMrO0WO8XT83PWIsWAR8WqCthjtv24R0WOEupKPWDiaFlCibQ3hyTYYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;928&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设秒杀系统每秒最多可以处理&lt;code&gt;2k&lt;/code&gt;个请求，每秒却有&lt;code&gt;5k&lt;/code&gt;的请求过来，可以引入消息队列，秒杀系统每秒从消息队列拉2k请求处理得了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些伙伴担心这样会出现&lt;strong&gt;消息积压&lt;/strong&gt;的问题，&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;首先秒杀活动不会每时每刻都那么多请求过来，&lt;strong&gt;高峰期过去后&lt;/strong&gt;，积压的请求可以慢慢处理；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其次，如果消息队列长度超过最大数量，可以直接抛弃用户请求或跳转到错误页面；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 异步处理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们经常会遇到这样的业务场景：用户注册成功后，给它发个短信和发个邮件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果注册信息入库是30ms，发短信、邮件也是30ms，三个动作&lt;strong&gt;串行执行&lt;/strong&gt;的话，会比较耗时，响应90ms：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2062062062062062&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZ8jSz7ABG9r0kW3ic6wjc4eLoUW1bJj10aRfLlkIiaod2v6fUTp3h0tAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;999&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果采用并行执行的方式，可以减少响应时间。注册信息入库后，同时异步发短信和邮件。如何实现异步呢，用消息队列即可，就是说，注册信息入库成功后，写入到消息队列（这个一般比较快，如只需要3ms），然后异步读取发邮件和短信。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4047856430707876&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZlfr89uPw7yMN54YNugsJHicwic57feIXiaW98cSuYwTVoD1dicZHFFX8Wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1003&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 消息通讯&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息队列内置了高效的通信机制，可用于消息通讯。如实现点对点消息队列、聊天室等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5 远程调用&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们公司基于MQ，自研了远程调用框架。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 消息队列如何解决消息丢失问题？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个消息从生产者产生，到被消费者消费，主要经过这3个过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24957841483979765&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZ8f2bfhS3xcKmA5DNC7J0fFOlf29B1L35fQYjljrPhPcJyzYnowRVLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;593&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此如何保证MQ不丢失消息，可以从这三个阶段阐述：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 生产者保证不丢消息&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产端如何保证不丢消息呢？&lt;strong&gt;确保生产的消息能到达存储端&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是&lt;strong&gt;RocketMQ&lt;/strong&gt;消息中间件，Producer生产者提供了三种发送消息的方式，分别是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产者要想发消息时保证消息不丢失，可以：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;采用&lt;strong&gt;同步方式&lt;/strong&gt;发送，send消息方法返回&lt;strong&gt;成功&lt;/strong&gt;状态，就表示消息正常到达了存储端Broker。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果send消息&lt;strong&gt;异常&lt;/strong&gt;或者返回&lt;strong&gt;非成功&lt;/strong&gt;状态，可以&lt;strong&gt;重试&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以使用事务消息，RocketMQ的事务消息机制就是为了保证零丢失来设计的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 存储端不丢消息&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何保证存储端的消息不丢失呢？确保消息&lt;strong&gt;持久化&lt;/strong&gt;到磁盘。大家很容易想到就是&lt;strong&gt;刷盘机制&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刷盘机制分&lt;strong&gt;同步刷盘和异步刷盘&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;生产者消息发过来时，只有持久化到磁盘，RocketMQ的存储端Broker才返回一个成功的ACK响应，这就是&lt;strong&gt;同步刷盘&lt;/strong&gt;。它保证消息不丢失，但是影响了性能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异步刷盘的话，只要消息写入PageCache缓存，就返回一个成功的ACK响应。这样提高了MQ的性能，但是如果这时候机器断电了，就会丢失消息。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Broker一般是&lt;strong&gt;集群部署&lt;/strong&gt;的，有master主节点和slave从节点。消息到Broker存储端，只有主节点和从节点都写入成功，才反馈成功的ack给生产者。这就是&lt;strong&gt;同步复制&lt;/strong&gt;，它保证了消息不丢失，但是降低了系统的吞吐量。与之对应的就是&lt;strong&gt;异步复制&lt;/strong&gt;，只要消息写入主节点成功，就返回成功的ack，它速度快，但是会有性能问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 消费阶段不丢消息&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者执行完业务逻辑，再反馈会Broker说消费成功，这样才可以保证消费阶段不丢消息。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 消息队列如何保证消息的顺序性。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息的有序性，就是指可以按照消息的发送顺序来消费。有些业务对消息的顺序是有要求的，比如&lt;strong&gt;先下单再付款，最后再完成订单&lt;/strong&gt;，这样等。假设生产者先后产生了两条消息，分别是下单消息（M1），付款消息（M2），M1比M2先产生，&lt;strong&gt;如何保证M1比M2先被消费&lt;/strong&gt;呢。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3372013651877133&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZ2Kax0UIQ5ECaMmHLLOYJHBbhM1Sb7eHznIb0IQ18OxMypMJKl2ib0Ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1465&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了保证消息的顺序性，可以&lt;strong&gt;将M1、M2发送到同一个Server&lt;/strong&gt;上，当M1发送完收到ack后，M2再发送。如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32085932085932084&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZQTwczcBJgGsiczQ1gWAMqUNeicyhGL0JgAooiarb5pw8wMTiaeEFgOQRqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1443&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样还是可能会有问题，因为从MQ服务器到消费端，可能&lt;strong&gt;存在网络延迟&lt;/strong&gt;，虽然M1先发送，但是它&lt;strong&gt;比M2晚到&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3224461431549687&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZicyDBQP63Nw3V53KiaPiaaicXiajloFsMOaarib89B4KP08dmz5yNBr6gomA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1439&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那还能怎么办才能保证消息的顺序性呢？将M1和M2发往&lt;strong&gt;同一个消费者&lt;/strong&gt;，且发送M1后，等到消费端ACK成功后，才发送M2就得了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3388543823326432&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZjQI3ibREicKYdAbOfJf23A1GW6l1VGFJz5Tnyy0LtZP8nzRfSgiacLZmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1449&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息队列保证顺序性&lt;strong&gt;整体思路&lt;/strong&gt;就是这样啦。比如Kafka的全局有序消息，就是&lt;strong&gt;这种思想&lt;/strong&gt;的体现: 就是生产者发消息时，1个&lt;code&gt;Topic&lt;/code&gt;只能对应1个&lt;code&gt;Partition&lt;/code&gt;，一个 &lt;code&gt;Consumer&lt;/code&gt;，内部单线程消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这样&lt;strong&gt;吞吐量太低&lt;/strong&gt;，一般保证消息&lt;strong&gt;局部有序&lt;/strong&gt;即可。在发消息的时候指定&lt;code&gt;Partition Key&lt;/code&gt;，Kafka对其进行Hash计算，根据计算结果决定放入哪个&lt;code&gt;Partition&lt;/code&gt;。这样Partition Key相同的消息会放在同一个Partition。然后多消费者单线程消费指定的Partition。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.消息队列有可能发生重复消费，如何避免，如何做到幂等？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息队列是可能发生重复消费的。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;生产端为了保证消息的可靠性，它可能往MQ服务器重复发送消息，直到拿到成功的ACK。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再然后就是消费端，消费端消费消息一般是这个流程：&lt;strong&gt;拉取消息、业务逻辑处理、提交消费位移&lt;/strong&gt;。假设业务逻辑处理完，事务提交了，但是需要更新消费位移时，消费者却挂了，这时候另一个消费者就会拉到重复消息了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何幂等处理重复消息呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我之前写过一篇幂等设计的文章，大家有兴趣可以看下哈：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&amp;amp;mid=2247497427&amp;amp;idx=1&amp;amp;sn=2ed160c9917ad989eee1ac60d6122855&amp;amp;chksm=cf2229faf855a0ecf5eb34c7335acdf6420426490ee99fc2b602d54ff4ffcecfdab24eeab0a3&amp;amp;token=429828252&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;聊聊幂等设计&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幂等处理重复消息，简单来说，就是搞个本地表，带&lt;strong&gt;唯一业务标记的&lt;/strong&gt;，利用主键或者唯一性索引，每次处理业务，先校验一下就好啦。又或者用redis缓存下业务标记，每次看下是否处理过了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 如何处理消息队列的消息积压问题&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息积压是因为生产者的生产速度，大于消费者的消费速度。遇到消息积压问题时，我们需要先排查，是不是有bug产生了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不是bug，我们可以&lt;strong&gt;优化一下消费的逻辑&lt;/strong&gt;，比如之前是一条一条消息消费处理的话，我们可以确认是不是可以优为&lt;strong&gt;批量处理消息&lt;/strong&gt;。如果还是慢，我们可以考虑水平扩容，增加Topic的队列数，和消费组机器的数量，提升整体消费能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是bug导致几百万消息持续积压几小时。有如何处理呢？需要解决bug，&lt;strong&gt;临时紧急扩容&lt;/strong&gt;，大概思路如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;先修复consumer消费者的问题，以确保其恢复消费速度，然后将现有consumer 都停掉。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;新建一个 topic，partition 是原来的 10 倍，临时建立好原先10倍的queue 数量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. 消息队列技术选型，Kafka还是RocketMQ，还是RabbitMQ&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先可以对比下它们优缺点：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;Kafka&lt;/th&gt;&lt;th&gt;RocketMQ&lt;/th&gt;&lt;th&gt;RabbitMQ&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;单机吞吐量&lt;/td&gt;&lt;td&gt;17.3w/s&lt;/td&gt;&lt;td&gt;11.6w/s&lt;/td&gt;&lt;td&gt;2.6w/s（消息做持久化）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;开发语言&lt;/td&gt;&lt;td&gt;Scala/Java&lt;/td&gt;&lt;td&gt;Java&lt;/td&gt;&lt;td&gt;Erlang&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;主要维护者&lt;/td&gt;&lt;td&gt;Apache&lt;/td&gt;&lt;td&gt;Alibaba&lt;/td&gt;&lt;td&gt;Mozilla/Spring&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;订阅形式&lt;/td&gt;&lt;td&gt;基于topic，按照topic进行正则匹配的发布订阅模式&lt;/td&gt;&lt;td&gt;基于topic/messageTag，按照消息类型、属性进行正则匹配的发布订阅模式&lt;/td&gt;&lt;td&gt;提供了4种：direct, topic ,Headers和fanout。fanout就是广播模式&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;持久化&lt;/td&gt;&lt;td&gt;支持大量堆积&lt;/td&gt;&lt;td&gt;支持大量堆积&lt;/td&gt;&lt;td&gt;支持少量堆积&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;顺序消息&lt;/td&gt;&lt;td&gt;支持&lt;/td&gt;&lt;td&gt;支持&lt;/td&gt;&lt;td&gt;不支持&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;集群方式&lt;/td&gt;&lt;td&gt;天然的Leader-Slave，无状态集群，每台服务器既是Master也是Slave&lt;/td&gt;&lt;td&gt;常用 多对’Master-Slave’ 模式，开源版本需手动切换Slave变成Master&lt;/td&gt;&lt;td&gt;支持简单集群，&#x27;复制’模式，对高级集群模式支持不好。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;性能稳定性&lt;/td&gt;&lt;td&gt;较差&lt;/td&gt;&lt;td&gt;一般&lt;/td&gt;&lt;td&gt;好&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;RabbitMQ是开源的，比较稳定的支持，活跃度也高，但是不是Java语言开发的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;很多公司用RocketMQ，比较成熟，是阿里出品的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8. 消息中间件如何做到高可用&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息中间件如何保证高可用呢？单机是没有高可用可言的，高可用都是对集群来说的，一起看下kafka的高可用吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 的基础集群架构，由多个&lt;code&gt;broker&lt;/code&gt;组成，每个&lt;code&gt;broker&lt;/code&gt;都是一个节点。当你创建一个&lt;code&gt;topic&lt;/code&gt;时，它可以划分为多个&lt;code&gt;partition&lt;/code&gt;，而每个&lt;code&gt;partition&lt;/code&gt;放一部分数据，分别存在于不同的 broker 上。也就是说，一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些伙伴可能有疑问，每个&lt;code&gt;partition&lt;/code&gt;放一部分数据，如果对应的broker挂了，那这部分数据是不是就丢失了？那还谈什么高可用呢？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Kafka 0.8 之后，提供了复制品副本机制来保证高可用，即每个 partition 的数据都会同步到其它机器上，形成多个副本。然后所有的副本会选举一个 leader 出来，让leader去跟生产和消费者打交道，其他副本都是follower。写数据时，leader 负责把数据同步给所有的follower，读消息时，
直接读 leader 上的数据即可。如何保证高可用的？就是假设某个 broker 宕机，这个broker上的partition 在其他机器上都有副本的。如果挂的是leader的broker呢？其他follower会重新选一个leader出来。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9. 如何保证数据一致性，事务消息如何实现&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一条普通的MQ消息，从产生到被消费，大概流程如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5354713313896987&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZJLn0HKnR8oYQxibORz2wDQ5icnThm2xwUzSyxXlGichibptOeUIjFMLT6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1029&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;生产者产生消息，发送带MQ服务器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MQ收到消息后，将消息持久化到存储系统。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MQ服务器返回ACk到生产者。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MQ服务器把消息push给消费者&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费者消费完消息，响应ACK&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MQ服务器收到ACK，认为消息消费成功，即在存储中删除消息。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们举个&lt;strong&gt;下订单&lt;/strong&gt;的例子吧。订单系统创建完订单后，再发送消息给下游系统。如果订单创建成功，然后消息没有成功发送出去，下游系统就无法感知这个事情，出导致数据不一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何保证数据一致性呢？可以使用&lt;strong&gt;事务消息&lt;/strong&gt;。一起来看下事务消息是如何实现的吧。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6591549295774648&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZViaNwEDJupeX148JES81ic3QTSNb8MyFgjatIbiaIyEwWbS9CQXWw7mGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1065&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;生产者产生消息，发送一条&lt;strong&gt;半事务消息&lt;/strong&gt;到MQ服务器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MQ收到消息后，将消息持久化到存储系统，这条消息的状态是&lt;strong&gt;待发送&lt;/strong&gt;状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MQ服务器返回ACK确认到生产者，此时MQ不会触发消息推送事件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生产者执行本地事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果本地事务执行成功，即commit执行结果到MQ服务器；如果执行失败，发送rollback。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果是正常的commit，MQ服务器更新消息状态为&lt;strong&gt;可发送&lt;/strong&gt;；如果是rollback，即删除消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果消息状态更新为可发送，则MQ服务器会push消息给消费者。消费者消费完就回ACK。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果MQ服务器长时间没有收到生产者的commit或者rollback，它会反查生产者，然后根据查询到的结果执行最终状态。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10. 让你写一个消息队列，该如何进行架构设计？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题面试官主要考察三个方面的知识点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;你有没有对消息队列的架构原理比较了解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;考察你的个人设计能力&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;考察编程思想，如什么高可用、可扩展性、幂等等等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;遇到这种设计题，大部分人会很蒙圈，因为平时没有思考过类似的问题。大多数人平时埋头增删改啥，不去思考框架背后的一些原理。有很多类似的问题，比如让你来设计一个 Dubbo 框架，或者让你来设计一个MyBatis 框架，你会怎么思考呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回答这类问题，并不要求你研究过那技术的源码，你知道那个技术框架的基本结构、工作原理即可。设计一个消息队列，我们可以从这几个角度去思考：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7301231802911534&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZzWDtNaqf4UoDQ7z13CImnSw1sNnvO34gnxVCGF2ZHJU2ZXVLDBSMibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;893&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;首先是消息队列的整体流程，producer发送消息给broker，broker存储好，broker再发送给consumer消费，consumer回复消费确认等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;producer发送消息给broker，broker发消息给consumer消费，那就需要两次RPC了，RPC如何设计呢？可以参考开源框架Dubbo，你可以说说服务发现、序列化协议等等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;broker考虑如何持久化呢，是放文件系统还是数据库呢，会不会消息堆积呢，消息堆积如何处理呢。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费关系如何保存呢？点对点还是广播方式呢？广播关系又是如何维护呢？zk还是config server&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息可靠性如何保证呢？如果消息重复了，如何幂等处理呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息队列的高可用如何设计呢？可以参考Kafka的高可用保障机制。多副本 -&amp;gt; leader &amp;amp; follower -&amp;gt; broker 挂了重新选举 leader 即可对外服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息事务特性，与本地业务同个事务，本地消息落库;消息投递到服务端，本地才删除；定时任务扫描本地消息库，补偿发送。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MQ得伸缩性和可扩展性，如果消息积压或者资源不够时，如何支持快速扩容，提高吞吐？可以参照一下 Kafka 的设计理念，broker -&amp;gt; topic -&amp;gt; partition，每个 partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考与感谢&lt;/span&gt;&lt;/h2&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;阿里RocketMQ如何解决消息的顺序&amp;amp;重复两大硬伤？: &lt;em&gt;https://dbaplus.cn/news-21-1123-1.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;消息中间件面试题：如何解决消息队列的延时以及过期失效问题？: &lt;em&gt;https://jsbintask.cn/2019/01/28/interview/interview-middleware-manymessage/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;消息队列设计精要: &lt;em&gt;https://zhuanlan.zhihu.com/p/21649950&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;MQ消息最终一致性解决方案: &lt;em&gt;https://juejin.cn/post/6844903951448408071&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b38fa017c9a1af130515b2a42adb2b6c</guid>
<title>[推荐] 如果你是一个Golang面试官，你会问哪些问题？</title>
<link>https://toutiao.io/k/yvw61mc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小土这两天本来想在公司发个面经，于是偶然搜到了这篇 &lt;span&gt;如果你是一个Golang面试官，你会问哪些问题？&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;,文章下面也有很多大佬的优秀回答，感兴趣的同学可以查看原文了解更多内容。下面小土主要收集了两个回答。另外小土在语雀也搜集了不少Gopher面经，&lt;span&gt;面试题库收集&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;回答 1:&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;作者：混血王子
链接：https://www.zhihu.com/question/67846139/answer/2105444792&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没有假如，我就是一个Golang面试官，来自百度。同时我到百度之前也面过头条，腾讯，小米，高德的golang，基本都过了。我回答应该还是比较有说服力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上，golang的问题只占我面试问题的20%左右。问东西的顺序不一定是下面的顺序，有的时候我会根据简历选择二分法难度来问，直接问一个难度适中的问题。说上来就继续二分法筛。下面是我问过的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1，make和new差别，引用类型的意义&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2，逃逸分析&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3，channel的实现&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4，gmp与gc，重点问题（网络io等待队列，读写屏障）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5，map的实现，重点问题（sync.map的实现，map实现随机的方法）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;期间会根据实际情况，从这几个题发散问一些细节，但是难度不会太难了。因为我面的是p6级别的，问源码有点欺负人了。另外会问一个开发性问题，你写go遇到的坑点。从这里也可以发散问一些，但是不会问太多了。这几个问题在10分钟之内肯定要问完的。我的面试范围和我之前遇到过的面试基本都在&lt;span&gt;https://draveness.me/golang/&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt; 内，这个教程还是非常不错的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些问题不一定都要答上来，我是综合考察的，我写这几个题目也不是让大家去背这几个题的，只是想告诉大家面试的难度一般如何，顺便说几个经典题目。另外我主要关注的问题其实主要是mysql，redis，mq，算法，分布式。有人看的话，我就补充一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;9.7 补充mysql&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先声明一下，我说的面试题都是个人向的，其实大家要面哪家公司的时候，搜那家公司的面试题用处其实不大，因为面试官并没有说题库，或者统一标准的说法。如果我去了其他家公司当面试官我一样也会这么问（注意是提问方式和难度，题目我会换的）。而你碰到百度其他面试官，也很可能不会按我这么问。另外，因为我面的校招到10年的都有，所以具体问法也会灵活调整。说到校招，这次大校招我也被安排当面试官了，校招的朋友也可以关注一下，如果能答出来，那就惊喜级别&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;补充一下我对mysql的考察方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1，八股，为什么用b+树不用b树&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以第一题为分界线，答出来了问下面的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2，说说对mvcc的理解&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3，幻读是怎么解决的&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4，redo，undo的作用和实现&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;5，事务的实现&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答不出第一题就问，下面就是纯八股了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2，索引怎么建&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3，联合索引最左前缀&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4，聚簇索引与回表&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果觉得前半部分回答得不行，就会转问后半部分的简单题。和上面一样，我问的问题和我遇见过的问题，基本都在《&lt;em&gt;MySQL技术内幕&lt;/em&gt;:InnoDB存储引擎》姜承尧老师的书里面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;9.8 补充redis&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;redis的东西虽然不多，但是也是必问的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1，底层数据结构实现，重点问题如：压缩列表&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2，aof与rdb，重点问题如：aof重写机制&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3，为什么用跳表&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4，分布式锁与redlock&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5，三种分布式的结构&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6，大KEY&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本上说明白一半就行了，和上面一样，我问的问题和我遇见过的问题，大部分都在《Redis设计与实现》里面。因为redis的问题都不算难，如果全答上来了，我可能会问一个：在扩容rehash的时候scan扫集合，会不会扫到重复的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;9.9 补充mq+es+分布式&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那就补一下剩下的常问问题吧，mq主要是kafka。下面基本上工作3年之内不怎么问，3年以上的说上1/3到1/2就通过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1，kafka的零拷贝和顺序io 零拷贝最好说说细节，其实就是用户空间和内核空间mmap&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2，kafka的分片，分片的读一致性（水位和活跃组？忘了叫什么了）和写一致性怎么保证&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3，es的倒排索引，和分片的查询召回&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4，分布式锁，redis redlock etcd&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5，分布式事务 2pc 3pc tcc&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6，分布式共识协议 raft和paxos&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7，分布式数据库 CAP BASE的概念 etcd tidb的了解&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;额外的问题，只有简历写了我才会问&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1，k8s的应用和架构（k8s其实我也没深入研究，随便）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2，监控prometheus，比如里面时序数据库TSDB&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3，微服务架构的内容，比如服务发现和链路追踪的工具&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4，校招的话问问tcp&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5，其他我感兴趣的东西&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6，算法题必问，一般先选一个中等偏难的，难度参见周赛第三题。要是很顺畅就加一个第四题难度（困难），做不出来就换一个第二题难度（中等偏简单）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7，架构设计，因为我只是一面，这种问题一般留给二面问。不过我给的建议是，mysql分表，redis缓存，kafka削峰这三板斧&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写在最后，其实我的标准只有一个，我的所有提问也是围绕这一标准来的，就是让我感受到你对技术的热情，对技术路线有清晰规划，并且正在进行系统性地有条理的学习持续一年以上，比如看书，事实上我也是这么要求自己的。我相信满足了这个条件，你面其他公司也很容易。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;回答2:&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;作者：HelloKaton
链接：https://www.zhihu.com/question/67846139/answer/257359743&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章翻译自一位外国友人的关于面试后端程序员的文章，我比较喜爱这篇文章。一是因为它极大的拓宽了我的视角，另一方面是其中的一些问题非常具有启发性。不仅对于面试者，对于面试官来说也是个不错的参考。于是迫不及待的翻译了一下，给各位看官做个参考。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原文参见 &lt;span&gt;@arialdomartini&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;的: &lt;span&gt;Back-End Developer Interview Questions&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是原文翻译。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;通用问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开放式问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设计模式相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码设计相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;语言相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Web相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据库相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非关系型数据库相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码版本管理相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;并发问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分布式系统相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;软件生命周期和团队管理相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;逻辑和算法相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;软件架构相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面向服务架构(SOA)和微服务(Microservice)相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;安全相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;比尔盖茨式问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码示例问题&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;通用问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;语言设计中空引用(&lt;span&gt;null reference&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;)的存在有什么问题？假设你想要将空引用的概念从你的首选语言中移除，可能导致什么结果？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么函数式编程重要？什么时候适用函数式语言？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设计(design)、架构(architecture)、功能(functionality)和美学(aesthetic)之间有什么区别？讨论一下。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;微软、谷歌、欧朋(opera)和火狐这类公司是如何从他们的浏览器中获利的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么打开TCP套接字有很大的开销？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;封装的重要性体现在哪儿？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是实时系统？它与普通系统有什么区别？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实时语言(real-time language)和堆内存分配(heap memory allocation)之间的关系是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不变性(Immutability)是指: (变量的)值只能在创建的时候被设置一次，之后就不能被改变。为什么不变性对写更加安全的代码有帮助？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可变值(mutable values)和不可变值(immutable values)有哪些优缺点？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是O/R阻抗失衡(Object-Relational impedence mismatch)？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果你需要使用缓存，你使用哪些原则来确定缓存的大小？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TCP和HTTP有什么区别？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在客户端渲染(client-side rendering)和服务端渲染(server-side rendering)之间，你是如何权衡的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何在一个不可靠的协议之上构建一个可靠的通信协议？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;开放式问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;为什么人们会抵制变化？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何向你的祖母解释什么是线程？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;作为一个软件工程师，你想要既要有创新力，又要产出具有可预测性。采用什么策略才能使这两个目标可以共存呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是好的代码？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;解释什么是流(Streaming)和如何实现一个流？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;假设你的公司给你一周的时间，用来改善你和同事的生活: 你将如何使用这一周？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本周你学了什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;所有的设计中都会有美学元素(aesthetic element)的存在。问题是，你认为美学元素是你的朋友还是敌人？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;列出最近你读过的5本书。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;假设目前有个大型公司（非常有钱），他们的开发流程是瀑布式流程（Waterfall），如果需要你在他们公司引入持续交付（&lt;span&gt;Continue Devivery&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;），你会怎么做？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们来谈谈&quot;&lt;em&gt;重复造轮子&lt;/em&gt;&quot;,&quot;&lt;em&gt;非我发明症&lt;/em&gt;&quot;, &quot;&lt;em&gt;吃自己做出来的狗粮&lt;/em&gt;&quot;的这些做法吧。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(注: 重复造轮子: Reinventing the wheel; 非我发明症:Not Invented Here Syndrome; 吃自己做出来的狗粮: Eating Your Own Dog Food)&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在你当前的工作流中，什么事情是你计划下一步需要自动化的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么写软件是困难的？是什么使软件的维护变得困难？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你更喜欢在全新项目（Green Field Project）上工作还是在已有项目(Brown Field Project)基础上工作？为什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当你在浏览器地址栏输入google.com回车之后都发生了什么?&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当操作系统CPU处于空闲的时候，它可能在处理哪些事情？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何向一个5岁的孩子解释什么是Unicode/数据库事务？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何维护单体架构(monolithic architecture)？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个&quot;专业的开发者&quot;意味着什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;软件开发是艺术、是技艺还是工程？你的观点是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&quot;喜欢这个的人也喜欢...&quot;，如何在一个电子商务商店里实现这种功能？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么在创新上，企业会比创业公司慢些？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么说，你不应该尝试应用自己发明或者设计的密码学？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;设计模式相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;请用一个例子表明，全局对象是邪恶的存在。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;假设你工作的系统不支持事务性，你会如何从头开始实现它？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是好莱坞原则（Hollywood Principles）？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关于迪米特法则(最少知识原则): 写一段代码违反它, 然后修复它。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（注: 迪米特法则：the Law of Demeter, 最少知识原则：the Principle of Least Knowledge）&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Active-Record模式有什么限制和缺陷？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Data-Mapper模式和Active-Record模式有什么区别？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;空对象模式(Null Object Pattern)的目的是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么组合(Composition)比继承(Inheritance)更好？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是反腐败层(Anti-corruption Layer)?&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你可以写一个线程安全的单例(Singleton)类吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据抽象(Data Abstraction)能力是指能改变实现而不影响客户端的这种能力。请构造一个一个例子，违反这个特性，并且尝试修复它。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你是如何处理依赖关系地狱(Dependency Hell)的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么说goto语句是恶魔般的存在？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;健壮性是进行软件设计时的一个通用原则，它建议 &lt;em&gt;“发送时要保守，接收时要开放”&lt;/em&gt;。这也经常被写成，“做一个有耐心的读者，做一个谨慎的作者”。你能解释一些这背后的逻辑吗？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;译者注：&quot;发送时要保守，接收时要开发&quot;的原文是：&quot;Be conservative in what you send, be liberal in what you accept&quot;，有点类似于“严于律己，宽于待人”的意味。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码设计相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;你在进行软件设计时会考虑软件测试吗？软件测试是如何影响软件设计的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内聚和耦合的区别是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重构在哪些场景下有用？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码中的注释有用吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设计和架构有什么区别？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么在测试驱动开发(TDD)中是先写测试，再写代码？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;C++支持多继承，Java允许类实现多个接口。这些特性对正交性有什么影响？使用多继承和使用多接口有区别吗？[这个问题来自Andrew .Hunt 和 David Thomas写的《程序员修炼之道》]&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在存储过程（Stored Procedures）中写业务逻辑有什么优缺点？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;语言相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;告诉我你的首选语言的三个最坏的缺陷。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么现在函数式编程这么越来越受关注？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;闭包是什么？它有什么用途？闭包和类有什么共同点？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;泛型有什么用途？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是高阶函数？有什么用途？用你的首选语言写个例子出来。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;讨论一下，如何写一个循环，然后把它转换成递归函数，要避免易变性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有些语言将函数视为第一公民，这是什么意思？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用一个例子说明匿名函数是有用的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是动态方法调度(Dynamic Method Dispatch)？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;名字空间(Namespace)有什么用？有什么可以替代它的吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;谈谈Java和C#之间的互操作性(Interoperability) (任选其他两门语言都行)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么很多软件工程师不喜欢Java？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你认为好的语言好在哪里？差的语言差在哪里？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写两个函数，一个是&quot;引用透明的(Referentially Transparent)&quot;，另一个是&quot;引用不透明的(Referentially Opaque)&quot;。讨论之。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是栈？什么是堆？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么一个语言中，&quot;函数是第一公民&quot;是很重要的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模式匹配(Pattern Matching)和Switch语句(Switch clauses)的区别在哪儿？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么有些语言设计上没有异常机制？这有什么优缺点？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果&lt;code&gt;Cat&lt;/code&gt;是一个&lt;code&gt;Animal&lt;/code&gt;, 那么&lt;code&gt;TaskCare&amp;lt;Cat&amp;gt;&lt;/code&gt;是一个&lt;code&gt;TakeCare&amp;lt;Animal&amp;gt;&lt;/code&gt;吗？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;web相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;为什么&quot;第一方cookie(first-party cookie)&quot;和&quot;第三方cookie(third-party cookie)&quot;被如此不同的对待？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据库相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果要你将一个项目从MySQL迁移至PostgreSQL中，你会如何迁移？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么&lt;code&gt;SELECT * FROM table WHERE field = null&lt;/code&gt;不能匹配空的字段？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是ACID(原子性，一致性，隔离性，持久性)原则？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你是如何进行数据库模式(Database schema)迁移的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;延迟加载(lazy loading)是如何实现的？什么场景下有用？他有什么缺陷？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是N+1问题？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何找出应用中开销最大的查询？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;非关系型数据库相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;什么是最终一致性(Eventual Consistency)？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关于CAP理论，举一些CP、AP、CA系统的例子。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NoSQL是如何解决可伸缩性的挑战的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么情况下你会使用类似于MongoDB的文档数据库而不是关系型数据库（如Mysql或者PostgreSQL）？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码版本管理相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;为什么在Mercurial或者git中(管理)分支比SVN容易？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分散式版本控制系统（比如git），相比集中式版本控制系统（如svn）有哪些优势和劣势？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(注:集中式版本控制系统: Centralized Version Control Systems；分散式版本控制系统: Distributed Version Control Systems)&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;能描述一下什么是GitHubFlow和GitFlow工作流吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是rebase？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么合并操作(merge)在Mercurial和git中比在SVN和CVS中容易？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;并发问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;为什么我们需要并发呢？解释一下。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么测试多线程/并发代码这么困难？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是竞争条件（Race Condition）？用任何一个语言写一个例子。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是死锁？用代码解释一下。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是饿死？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是Wait-Free算法？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;分布式系统相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;怎么测试一个分布式系统？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么场景下你会在两个系统中采用异步通信机制？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;远程过程调用的通用缺点是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果你为了可扩展性和鲁棒性而构建一个分布式的系统，分别在封闭安全的网络环境情况下，和地理上的位置不同但是网络环境不是封闭和安全的情况下，你会考虑什么不同的事情？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在Web应用中如何管理容错性？在桌面端呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在分布式系统中，如何处理故障？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;让我们来谈谈网络分裂(network partitions)后有的几种恢复的手段吧。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你认为分布式计算中有哪些谬论？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你在什么时候会使用Request/Response模式，什么时候使用Publish/Subscribe模式？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;软件生命周期和团队管理相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;什么是敏捷（Agility）？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你是如何处理遗留代码（Legacy Code）的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;假设我是你们公司的CEO，请向我解释什么是看板，并且说服我在它上面投资。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;敏捷（Agility）和瀑布（Waterfall）之间的最大区别是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;作为团队管理者，你对会议太多这个问题是如何处理的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你会如何处理延期很长时间了的项目？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&quot;&lt;em&gt;个体与交互重于过程和工具&lt;/em&gt;&quot;和&quot;&lt;em&gt;客户协作重于合同谈判&lt;/em&gt;&quot;占了敏捷宣言（Agile Manifesto）的一半，谈论一下这两个观念。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果你是你们公司的CTO，你会采取什么样的决策？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你觉得项目经理有用吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果要你组织一个弹性工作制的开发团队（即没有强制工作时间的要求），并且假期制度是&quot;按需休假&quot;，你会如何做？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你会如何管理一个人员流动非常高的团队？如何在不加薪的条件下说服团队成员不要离开？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;除了代码之外，你最关注你的同事的哪3项素质？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关于代码，你最希望非技术人员能知道的的三件事是什么？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;逻辑和算法相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;只用LIFO栈如何构造一个FIFO队列？只用FIFO队列如何构造一个LIFO栈？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写一段有栈溢出的代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写一个尾递归版本的阶乘函数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用任何一个语言，写一个REPL，功能是echo你输入的字符串。然后将它演化成一个逆波兰表达式的计算器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果需要你设计一个文件系统磁盘碎片整理程序，你会如何设计？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写一个生成随机迷宫的程序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写一段有内存泄漏的示例代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;随机生成一个的数字序列，里面每个数字都不同。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写一个简单的垃圾回收系统。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用任何一门语言，写一个基本的消息代理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写一个基础的web服务器，然后画一张线路图，展示你将来还想要实现的功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何对一个10GB的文件进行排序？如果是10TB的数据，你会采用什么方法？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;请实现&lt;code&gt;rnd()&lt;/code&gt;函数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;软件架构相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;什么情况下缓存是没用的，甚至是危险的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么事件驱动的架构能提高可扩展性(scalability)？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么样的代码是可读性强的代码？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;紧急设计(Emergent Design)和演化架构(Evolutionary Architecture)之间的区别是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;横向扩展(scale out) vs 纵向扩展(scale up): 有什么区别？分别在什么场景下使用？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分布式系统中如何处理&quot;故障切换(failover)&quot;和&quot;用户会话(user session)&quot;？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是CQRS(Command Query Responsibility Segregation)?他和最早的Command-Query Separation原则有什么区别？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是三层架构？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何设计一个可扩展性高的系统？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;处理C10k问题的策略有哪些？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果让你来设计一个去中心化的P2P系统，你会如何设计？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么CGI的扩展性不好？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在设计系统时，你如何防止供应商依赖(&lt;span&gt;Vendor Lock-in&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;)？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在可扩展性上，发布/订阅(Publish-Subscribe)模式有什么缺点？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;80年代以后，CPU有哪些变化？这些变化，对编程产生了什么影响？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;性能生命周期(performace lifecycle)中，你认为哪个部分是需要考虑进去的？如何管理？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;除了恶意攻击造成的拒绝服务现象以外，哪些设计或者架构上的问题会导致拒绝服务？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;性能和可扩展性之间有什么关系？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么时候紧耦合是OK的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个系统要有什么特征才能适配云计算环境(Cloud Ready)？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Does unity of design imply an aristocracy of architects?&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;面向服务架构(SOA)和微服务(Microservice)相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在SOA中，为什么长期存活的事务(Long-lived transation)不被看好，而Saga却被看好？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SOA和MicroService之间有什么区别？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们来谈谈Web服务的版本管理、版本兼容性、重大变更管理这些事情吧.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在saga中事务和补偿操作(compensation operation)之间的区别是什么？在SOA中呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;微服务不能做得太&quot;微&quot;，你认为什么时候微服务太&quot;微&quot;了？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MicroService架构的优劣是什么？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;安全相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;什么是双因素认证(Two Factor Authentication)？在一个已有的Web应用中，你如何实现这种机制？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;比尔盖茨式问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果你把一面镜子放在扫描仪上，会发生什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;假设有一个和你完全一样的克隆人，而他是你的上司，你愿意和他工作吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;现在请你面试一下我。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么Quora上的回答会比Yahoo Answer上的回答好？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对手是现代语言，你的任务是要为Cobol辩护，你会如何进行？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;10年后的你是什么样子？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;假设你是我老板，我被解雇了。你会如何通知我？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我想要重构一个系统，而你想要从头重写。我们来争论一下该怎么弄吧。然后我们反转角色，再争论一下。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;老板要你对公司撒谎，你的反应是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果你可以穿越到以前，你会给年轻时候的你什么建议？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码示例问题:&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;function &lt;span&gt;hookupevents&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;3&lt;/span&gt;; i++) {&lt;br/&gt;    document.getElementById(&lt;span&gt;&quot;button&quot;&lt;/span&gt; + i)&lt;br/&gt;      .addEventListener(&lt;span&gt;&quot;click&quot;&lt;/span&gt;, function() { &lt;br/&gt;        alert(i); &lt;br/&gt;      });&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;关于类型擦除(Type Erasure)，这段Java代码的输出是什么？为什么？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ArrayList&amp;lt;Integer&amp;gt; li = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();&lt;br/&gt;ArrayList&amp;lt;Float&amp;gt; lf = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Float&amp;gt;();&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (li.getClass() == lf.getClass()) &lt;span&gt;// evaluates to true&lt;/span&gt;&lt;br/&gt;  System.out.println(&lt;span&gt;&quot;Equal&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Stack&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Object[] elements;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_INITIAL_CAPACITY = &lt;span&gt;16&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Stack&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        elements = &lt;span&gt;new&lt;/span&gt; Object[DEFAULT_INITIAL_CAPACITY];&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;push&lt;/span&gt;&lt;span&gt;(Object e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ensureCapacity();&lt;br/&gt;        elements[size++] = e;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;pop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (size == &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; EmptyStackException();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; elements[--size];&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Ensure space for at least one more element, roughly&lt;br/&gt;     * doubling the capacity each time the array needs to grow.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;ensureCapacity&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (elements.length == size)&lt;br/&gt;            elements = Arrays.copyOf(elements, &lt;span&gt;2&lt;/span&gt; * size + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;if&lt;/code&gt;语句，或者更加通用点，条件表达式通常是过程式编程/命令式编程的形式。你能去掉这段代码中的&lt;code&gt;switch&lt;/code&gt;语句，用面向对象的方式来修改这段代码吗？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Formatter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Service service;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Formatter&lt;/span&gt;&lt;span&gt;(Service service)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.service = service;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;doTheJob&lt;/span&gt;&lt;span&gt;(String theInput)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String response = service.askForPermission();&lt;br/&gt;        &lt;span&gt;switch&lt;/span&gt; (response) {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;FAIL&quot;&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;error&quot;&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;OK&quot;&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; String.format(&lt;span&gt;&quot;%s%s&quot;&lt;/span&gt;, theInput, theInput);&lt;br/&gt;        &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TheService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; FileHandler fileHandler;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; FooRepository fooRepository;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;TheService&lt;/span&gt;&lt;span&gt;(FileHandler fileHandler, FooRepository fooRepository)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.fileHandler = fileHandler;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.fooRepository = fooRepository;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;Execute&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; String file)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; String rewrittenUrl = fileHandler.getXmlFileFromFileName(file);&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; String executionId = fileHandler.getExecutionIdFromFileName(file);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; ((executionId == &lt;span&gt;&quot;&quot;&lt;/span&gt;) || (rewrittenUrl == &lt;span&gt;&quot;&quot;&lt;/span&gt;)) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        Foo knownFoo = fooRepository.getFooByXmlFileName(rewrittenUrl);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (knownFoo == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; knownFoo.DoThat(file);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span/&gt;)&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    HRESULT error = S_OK;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(SUCCEEDED(Operation1()))&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(SUCCEEDED(Operation2()))&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(SUCCEEDED(Operation3()))&lt;br/&gt;            {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt;(SUCCEEDED(Operation4()))&lt;br/&gt;                {&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;                {&lt;br/&gt;                    error = OPERATION4FAILED;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;            {&lt;br/&gt;                error = OPERATION3FAILED;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        {&lt;br/&gt;            error = OPERATION2FAILED;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;    {&lt;br/&gt;        error = OPERATION1FAILED;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; error;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你是一个Golang面试官，你会问哪些问题？欢迎留言讨论。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;如果你是一个Golang面试官，你会问哪些问题？: &lt;span&gt;https://www.zhihu.com/question/67846139&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;面试题库收集: &lt;span&gt;https://www.yuque.com/go-interview/set/interview-index&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;https://draveness.me/golang/: &lt;span&gt;https://link.zhihu.com/?target=https%3A//draveness.me/golang/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;@arialdomartini: &lt;span&gt;https://link.zhihu.com/?target=https%3A//github.com/arialdomartini&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;Back-End Developer Interview Questions: &lt;span&gt;https://link.zhihu.com/?target=https%3A//github.com/arialdomartini/Back-End-Developer-Interview-Questions&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;null reference: &lt;span&gt;https://link.zhihu.com/?target=http%3A//programmers.stackexchange.com/questions/12777/are-null-references-really-a-bad-thing&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;Continue Devivery: &lt;span&gt;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Continuous_delivery&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;当你在浏览器地址栏输入google.com回车之后都发生了什么?: &lt;span&gt;https://link.zhihu.com/?target=https%3A//github.com/alex/what-happens-when&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;Vendor Lock-in: &lt;span&gt;https://link.zhihu.com/?target=https%3A//sourcemaking.com/antipatterns/vendor-lock-in&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c021697c8c14bf4560f7876f8dfb8ca9</guid>
<title>[推荐] Go 高性能编程技法</title>
<link>https://toutiao.io/k/405ts7m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：dablelv，腾讯 IEGggG 后台开发工程师&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;代码的稳健、可读和高效是我们每一个 coder 的共同追求。本文将结合 Go 语言特性，为书写效率更高的代码，从常用数据结构、内存管理和并发，三个方面给出相关建议。话不多说，让我们一起学习 Go 高性能编程的技法吧。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;常用数据结构&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.反射虽好，切莫贪杯&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标准库 reflect 为 Go 语言提供了运行时动态获取对象的类型和值以及动态创建对象的能力。反射可以帮助抽象和简化代码，提高开发效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言标准库以及很多开源软件中都使用了 Go 语言的反射能力，例如用于序列化和反序列化的 json、ORM 框架 gorm、xorm 等。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1 优先使用 strconv 而不是 fmt&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本数据类型与字符串之间的转换，优先使用 strconv 而不是 fmt，因为前者性能更佳。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Bad&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt; s := fmt.Sprint(rand.Int())&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;BenchmarkFmtSprint&lt;span&gt;-4&lt;/span&gt;    &lt;span&gt;143&lt;/span&gt; ns/op    &lt;span&gt;2&lt;/span&gt; allocs/op&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Good&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt; s := strconv.Itoa(rand.Int())&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;BenchmarkStrconv&lt;span&gt;-4&lt;/span&gt;    &lt;span&gt;64.2&lt;/span&gt; ns/op    &lt;span&gt;1&lt;/span&gt; allocs/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么性能上会有两倍多的差距，因为 fmt 实现上利用反射来达到范型的效果，在运行时进行类型的动态判断，所以带来了一定的性能损耗。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2 少量的重复不比反射差&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时，我们需要一些工具函数。比如从 uint64 切片过滤掉指定的元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用反射，我们可以实现一个类型泛化支持扩展的切片过滤函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// DeleteSliceElms 从切片中过滤指定元素。注意：不修改原切片。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;DeleteSliceElms&lt;/span&gt;&lt;span&gt;(i &lt;span&gt;interface&lt;/span&gt;{}, elms ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;/span&gt;{} {&lt;br/&gt; &lt;span&gt;// 构建 map set。&lt;/span&gt;&lt;br/&gt; m := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;interface&lt;/span&gt;{}]&lt;span&gt;struct&lt;/span&gt;{}, &lt;span&gt;len&lt;/span&gt;(elms))&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, v := &lt;span&gt;range&lt;/span&gt; elms {&lt;br/&gt;  m[v] = &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 创建新切片，过滤掉指定元素。&lt;/span&gt;&lt;br/&gt; v := reflect.ValueOf(i)&lt;br/&gt; t := reflect.MakeSlice(reflect.TypeOf(i), &lt;span&gt;0&lt;/span&gt;, v.Len())&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; v.Len(); i++ {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; _, ok := m[v.Index(i).Interface()]; !ok {&lt;br/&gt;   t = reflect.Append(t, v.Index(i))&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; t.Interface()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，我们可能只需要操作一个类型的切片，利用反射实现的类型泛化扩展的能力压根没用上。退一步说，如果我们真地需要对 uint64 以外类型的切片进行过滤，拷贝一次代码又何妨呢？可以肯定的是，绝大部份场景，根本不会对所有类型的切片进行过滤，那么反射带来好处我们并没有充分享受，但却要为其带来的性能成本买单。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// DeleteU64liceElms 从 []uint64 过滤指定元素。注意：不修改原切片。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;DeleteU64liceElms&lt;/span&gt;&lt;span&gt;(i []&lt;span&gt;uint64&lt;/span&gt;, elms ...&lt;span&gt;uint64&lt;/span&gt;)&lt;/span&gt; []&lt;span&gt;uint64&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// 构建 map set。&lt;/span&gt;&lt;br/&gt; m := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;uint64&lt;/span&gt;]&lt;span&gt;struct&lt;/span&gt;{}, &lt;span&gt;len&lt;/span&gt;(elms))&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, v := &lt;span&gt;range&lt;/span&gt; elms {&lt;br/&gt;  m[v] = &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 创建新切片，过滤掉指定元素。&lt;/span&gt;&lt;br/&gt; t := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;uint64&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;len&lt;/span&gt;(i))&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, v := &lt;span&gt;range&lt;/span&gt; i {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; _, ok := m[v]; !ok {&lt;br/&gt;   t = &lt;span&gt;append&lt;/span&gt;(t, v)&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; t&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面看一下二者的性能对比。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkDeleteSliceElms&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; slice := []&lt;span&gt;uint64&lt;/span&gt;{&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;}&lt;br/&gt; elms := []&lt;span&gt;interface&lt;/span&gt;{}{&lt;span&gt;uint64&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;), &lt;span&gt;uint64&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;), &lt;span&gt;uint64&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;), &lt;span&gt;uint64&lt;/span&gt;(&lt;span&gt;7&lt;/span&gt;), &lt;span&gt;uint64&lt;/span&gt;(&lt;span&gt;9&lt;/span&gt;)}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = DeleteSliceElms(slice, elms...)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkDeleteU64liceElms&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; slice := []&lt;span&gt;uint64&lt;/span&gt;{&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;}&lt;br/&gt; elms := []&lt;span&gt;uint64&lt;/span&gt;{&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = DeleteU64liceElms(slice, elms...)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上面的基准测试。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; test -bench=. -benchmem main/reflect &lt;br/&gt;goos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/reflect&lt;br/&gt;cpu: Intel(R) Core(TM) i7&lt;span&gt;-9750&lt;/span&gt;H CPU @ &lt;span&gt;2.60&lt;/span&gt;GHz&lt;br/&gt;BenchmarkDeleteSliceElms&lt;span&gt;-12&lt;/span&gt;              &lt;span&gt;1226868&lt;/span&gt;               &lt;span&gt;978.2&lt;/span&gt; ns/op           &lt;span&gt;296&lt;/span&gt; B/op         &lt;span&gt;16&lt;/span&gt; allocs/op&lt;br/&gt;BenchmarkDeleteU64liceElms&lt;span&gt;-12&lt;/span&gt;            &lt;span&gt;8249469&lt;/span&gt;               &lt;span&gt;145.3&lt;/span&gt; ns/op            &lt;span&gt;80&lt;/span&gt; B/op          &lt;span&gt;1&lt;/span&gt; allocs/op&lt;br/&gt;PASS&lt;br/&gt;ok      main/reflect    &lt;span&gt;3.809&lt;/span&gt;s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，反射涉及了额外的类型判断和大量的内存分配，导致其对性能的影响非常明显。随着切片元素的递增，每一次判断元素是否在 map 中，因为 map 的 key 是不确定的类型，会发生变量逃逸，触发堆内存的分配。所以，可预见的是当元素数量增加时，性能差异会越来大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当使用反射时，请问一下自己，我真地需要它吗？&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3 慎用 binary.Read 和 binary.Write&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;binary.Read 和 binary.Write 使用反射并且很慢。如果有需要用到这两个函数的地方，我们应该手动实现这两个函数的相关功能，而不是直接去使用它们。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;encoding/binary 包实现了数字和字节序列之间的简单转换以及 varints 的编码和解码。varints 是一种使用可变字节表示整数的方法。其中数值本身越小，其所占用的字节数越少。Protocol Buffers 对整数采用的便是这种编码方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中数字与字节序列的转换可以用如下三个函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Read 从结构化二进制数据 r 读取到 data。data 必须是指向固定大小值的指针或固定大小值的切片。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Read&lt;/span&gt;&lt;span&gt;(r io.Reader, order ByteOrder, data &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Write 将 data 的二进制表示形式写入 w。data 必须是固定大小的值或固定大小值的切片，或指向此类数据的指针。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Write&lt;/span&gt;&lt;span&gt;(w io.Writer, order ByteOrder, data &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Size 返回 Wirte 函数将 v 写入到 w 中的字节数。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Size&lt;/span&gt;&lt;span&gt;(v &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面以我们熟知的 C 标准库函数 ntohl() 函数为例，看看 Go 利用 binary 包如何实现。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Ntohl 将网络字节序的 uint32 转为主机字节序。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Ntohl&lt;/span&gt;&lt;span&gt;(bys []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;uint32&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; r := bytes.NewReader(bys)&lt;br/&gt; err = binary.Read(buf, binary.BigEndian, &amp;amp;num)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 如将 IP 127.0.0.1 网络字节序解析到 uint32&lt;/span&gt;&lt;br/&gt;fmt.Println(Ntohl([]&lt;span&gt;byte&lt;/span&gt;{&lt;span&gt;0x7f&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0x1&lt;/span&gt;})) &lt;span&gt;// 2130706433 &amp;lt;nil&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们针对 uint32 类型手动实现一个 ntohl() 呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NtohlNotUseBinary&lt;/span&gt;&lt;span&gt;(bys []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;uint32&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;uint32&lt;/span&gt;(bys[&lt;span&gt;3&lt;/span&gt;]) | &lt;span&gt;uint32&lt;/span&gt;(bys[&lt;span&gt;2&lt;/span&gt;])&amp;lt;&amp;lt;&lt;span&gt;8&lt;/span&gt; | &lt;span&gt;uint32&lt;/span&gt;(bys[&lt;span&gt;1&lt;/span&gt;])&amp;lt;&amp;lt;&lt;span&gt;16&lt;/span&gt; | &lt;span&gt;uint32&lt;/span&gt;(bys[&lt;span&gt;0&lt;/span&gt;])&amp;lt;&amp;lt;&lt;span&gt;24&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 如将 IP 127.0.0.1 网络字节序解析到 uint32&lt;/span&gt;&lt;br/&gt;fmt.Println(NtohlNotUseBinary([]&lt;span&gt;byte&lt;/span&gt;{&lt;span&gt;0x7f&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0x1&lt;/span&gt;})) &lt;span&gt;// 2130706433&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该函数也是参考了 encoding/binary 包针对大端字节序将字节序列转为 uint32 类型时的实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面看下剥去反射前后二者的性能差异。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkNtohl&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _, _ = Ntohl([]&lt;span&gt;byte&lt;/span&gt;{&lt;span&gt;0x7f&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0x1&lt;/span&gt;})&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkNtohlNotUseBinary&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = NtohlNotUseBinary([]&lt;span&gt;byte&lt;/span&gt;{&lt;span&gt;0x7f&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0x1&lt;/span&gt;})&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上面的基准测试，结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go &lt;span&gt;test&lt;/span&gt; -bench=BenchmarkNtohl.* -benchmem main/reflect&lt;br/&gt;goos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/reflect&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz&lt;br/&gt;BenchmarkNtohl-12                       13026195                81.96 ns/op           60 B/op          4 allocs/op&lt;br/&gt;BenchmarkNtohlNotUseBinary-12           1000000000               0.2511 ns/op          0 B/op          0 allocs/op&lt;br/&gt;PASS&lt;br/&gt;ok      main/reflect    1.841s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可见使用反射实现的 encoding/binary 包的性能相较于针对具体类型实现的版本，性能差异非常大。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.避免重复的字符串到字节切片的转换&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要反复从固定字符串创建字节 slice，因为重复的切片初始化会带来性能损耗。相反，请执行一次转换并捕获结果。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Bad&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt; w.Write([]&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;Hello world&quot;&lt;/span&gt;))&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;BenchmarkBad&lt;span&gt;-4&lt;/span&gt;   &lt;span&gt;50000000&lt;/span&gt;   &lt;span&gt;22.2&lt;/span&gt; ns/op&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Good&lt;/span&gt;&lt;br/&gt;data := []&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;Hello world&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt; w.Write(data)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;BenchmarkGood&lt;span&gt;-4&lt;/span&gt;  &lt;span&gt;500000000&lt;/span&gt;   &lt;span&gt;3.25&lt;/span&gt; ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.指定容器容量&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽可能指定容器容量，以便为容器预先分配内存。这将在后续添加元素时减少通过复制来调整容器大小。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 指定 map 容量提示&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在尽可能的情况下，在使用 make() 初始化的时候提供容量信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[T1]T2, hint)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;向 make() 提供容量提示会在初始化时尝试调整 map 的大小，这将减少在将元素添加到 map 时为 map 重新分配内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，与 slice 不同。map capacity 提示并不保证完全的抢占式分配，而是用于估计所需的 hashmap bucket 的数量。因此，在将元素添加到 map 时，甚至在指定 map 容量时，仍可能发生分配。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Bad&lt;/span&gt;&lt;br/&gt;m := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]os.FileInfo)&lt;br/&gt;&lt;br/&gt;files, _ := ioutil.ReadDir(&lt;span&gt;&quot;./files&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; _, f := &lt;span&gt;range&lt;/span&gt; files {&lt;br/&gt;    m[f.Name()] = f&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// m 是在没有大小提示的情况下创建的； 在运行时可能会有更多分配。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Good&lt;/span&gt;&lt;br/&gt;files, _ := ioutil.ReadDir(&lt;span&gt;&quot;./files&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;m := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]os.FileInfo, &lt;span&gt;len&lt;/span&gt;(files))&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; _, f := &lt;span&gt;range&lt;/span&gt; files {&lt;br/&gt;    m[f.Name()] = f&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// m 是有大小提示创建的；在运行时可能会有更少的分配。&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 指定切片容量&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在尽可能的情况下，在使用 make() 初始化切片时提供容量信息，特别是在追加切片时。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;make&lt;/span&gt;([]T, length, capacity)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与 map 不同，slice capacity 不是一个提示：编译器将为提供给 make() 的 slice 的容量分配足够的内存，这意味着后续的 append() 操作将导致零分配（直到 slice 的长度与容量匹配，在此之后，任何 append 都可能调整大小以容纳其他元素）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; size = &lt;span&gt;1000000&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Bad&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;0&lt;/span&gt;; n &amp;lt; b.N; n++ {&lt;br/&gt; data := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; k := &lt;span&gt;0&lt;/span&gt;; k &amp;lt; size; k++ {&lt;br/&gt;     data = &lt;span&gt;append&lt;/span&gt;(data, k)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;BenchmarkBad&lt;span&gt;-4&lt;/span&gt;    &lt;span&gt;219&lt;/span&gt;    &lt;span&gt;5202179&lt;/span&gt; ns/op&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Good&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;0&lt;/span&gt;; n &amp;lt; b.N; n++ {&lt;br/&gt; data := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, size)&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; k := &lt;span&gt;0&lt;/span&gt;; k &amp;lt; size; k++ {&lt;br/&gt;     data = &lt;span&gt;append&lt;/span&gt;(data, k)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;BenchmarkGood&lt;span&gt;-4&lt;/span&gt;   &lt;span&gt;706&lt;/span&gt;    &lt;span&gt;1528934&lt;/span&gt; ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行基准测试：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=^BenchmarkJoinStr -benchmem &lt;br/&gt;BenchmarkJoinStrWithOperator-8    66930670    17.81 ns/op    0 B/op    0 allocs/op&lt;br/&gt;BenchmarkJoinStrWithSprintf-8      7032921    166.0 ns/op    64 B/op   4 allocs/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.字符串拼接方式的选择&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1 行内拼接字符串推荐使用运算符+&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;行内拼接字符串为了书写方便快捷，最常用的两个方法是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;行内字符串的拼接，主要追求的是代码的简洁可读。&lt;code&gt;fmt.Sprintf()&lt;/code&gt; 能够接收不同类型的入参，通过格式化输出完成字符串的拼接，使用非常方便。但因其底层实现使用了反射，性能上会有所损耗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运算符 + 只能简单地完成字符串之间的拼接，非字符串类型的变量需要单独做类型转换。行内拼接字符串不会产生内存分配，也不涉及类型地动态转换，所以性能上优于&lt;code&gt;fmt.Sprintf()&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;从性能出发，兼顾易用可读，如果待拼接的变量不涉及类型转换且数量较少（&amp;lt;=5），行内拼接字符串推荐使用运算符 +，反之使用 &lt;code&gt;fmt.Sprintf()&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面看下二者的性能对比。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Good&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkJoinStrWithOperator&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s1, s2, s3 := &lt;span&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span&gt;&quot;bar&quot;&lt;/span&gt;, &lt;span&gt;&quot;baz&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = s1 + s2 + s3&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Bad&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkJoinStrWithSprintf&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s1, s2, s3 := &lt;span&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span&gt;&quot;bar&quot;&lt;/span&gt;, &lt;span&gt;&quot;baz&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = fmt.Sprintf(&lt;span&gt;&quot;%s%s%s&quot;&lt;/span&gt;, s1, s2, s3)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行基准测试结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=^BenchmarkJoinStr -benchmem .&lt;br/&gt;BenchmarkJoinStrWithOperator-8    70638928    17.53 ns/op     0 B/op    0 allocs/op&lt;br/&gt;BenchmarkJoinStrWithSprintf-8      7520017    157.2 ns/op    64 B/op    4 allocs/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2 非行内拼接字符串推荐使用 strings.Builder&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字符串拼接还有其他的方式，比如&lt;code&gt;strings.Join()&lt;/code&gt;、&lt;code&gt;strings.Builder&lt;/code&gt;、&lt;code&gt;bytes.Buffer&lt;/code&gt;和&lt;code&gt;byte[]&lt;/code&gt;，这几种不适合行内使用。当待拼接字符串数量较多时可考虑使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看下其性能测试的对比。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkJoinStrWithStringsJoin&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s1, s2, s3 := &lt;span&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span&gt;&quot;bar&quot;&lt;/span&gt;, &lt;span&gt;&quot;baz&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = strings.Join([]&lt;span&gt;string&lt;/span&gt;{s1, s2, s3}, &lt;span&gt;&quot;&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkJoinStrWithStringsBuilder&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s1, s2, s3 := &lt;span&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span&gt;&quot;bar&quot;&lt;/span&gt;, &lt;span&gt;&quot;baz&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; builder strings.Builder&lt;br/&gt;  _, _ = builder.WriteString(s1)&lt;br/&gt;  _, _ = builder.WriteString(s2)&lt;br/&gt;  _, _ = builder.WriteString(s3)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkJoinStrWithBytesBuffer&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s1, s2, s3 := &lt;span&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span&gt;&quot;bar&quot;&lt;/span&gt;, &lt;span&gt;&quot;baz&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; buffer bytes.Buffer&lt;br/&gt;  _, _ = buffer.WriteString(s1)&lt;br/&gt;  _, _ = buffer.WriteString(s2)&lt;br/&gt;  _, _ = buffer.WriteString(s3)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkJoinStrWithByteSlice&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s1, s2, s3 := &lt;span&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span&gt;&quot;bar&quot;&lt;/span&gt;, &lt;span&gt;&quot;baz&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; bys []&lt;span&gt;byte&lt;/span&gt;&lt;br/&gt;  bys= &lt;span&gt;append&lt;/span&gt;(bys, s1...)&lt;br/&gt;  bys= &lt;span&gt;append&lt;/span&gt;(bys, s2...)&lt;br/&gt;  _ = &lt;span&gt;append&lt;/span&gt;(bys, s3...)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkJoinStrWithByteSlicePreAlloc&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s1, s2, s3 := &lt;span&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span&gt;&quot;bar&quot;&lt;/span&gt;, &lt;span&gt;&quot;baz&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  bys:= &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;)&lt;br/&gt;  bys= &lt;span&gt;append&lt;/span&gt;(bys, s1...)&lt;br/&gt;  bys= &lt;span&gt;append&lt;/span&gt;(bys, s2...)&lt;br/&gt;  _ = &lt;span&gt;append&lt;/span&gt;(bys, s3...)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基准测试结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=^BenchmarkJoinStr .&lt;br/&gt;goos: windows&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/perf&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9700 CPU @ 3.00GHz&lt;br/&gt;BenchmarkJoinStrWithStringsJoin-8               31543916                36.39 ns/op&lt;br/&gt;BenchmarkJoinStrWithStringsBuilder-8            30079785                40.60 ns/op&lt;br/&gt;BenchmarkJoinStrWithBytesBuffer-8               31663521                39.58 ns/op&lt;br/&gt;BenchmarkJoinStrWithByteSlice-8                 30748495                37.34 ns/op&lt;br/&gt;BenchmarkJoinStrWithByteSlicePreAlloc-8         665341896               1.813 ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从结果可以看出，&lt;code&gt;strings.Join()&lt;/code&gt;、&lt;code&gt;strings.Builder&lt;/code&gt;、&lt;code&gt;bytes.Buffer&lt;/code&gt;和&lt;code&gt;byte[]&lt;/code&gt; 的性能相近。如果结果字符串的长度是可预知的，使用 &lt;code&gt;byte[]&lt;/code&gt; 且预先分配容量的拼接方式性能最佳。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以如果对性能要求非常严格，或待拼接的字符串数量足够多时，建议使用  &lt;code&gt;byte[]&lt;/code&gt; 预先分配容量这种方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;综合易用性和性能，一般推荐使用&lt;code&gt;strings.Builder&lt;/code&gt;来拼接字符串。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;string.Builder&lt;/code&gt;也提供了预分配内存的方式 Grow：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkJoinStrWithStringsBuilderPreAlloc&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s1, s2, s3 := &lt;span&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span&gt;&quot;bar&quot;&lt;/span&gt;, &lt;span&gt;&quot;baz&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; builder strings.Builder&lt;br/&gt;  builder.Grow(&lt;span&gt;9&lt;/span&gt;)&lt;br/&gt;  _, _ = builder.WriteString(s1)&lt;br/&gt;  _, _ = builder.WriteString(s2)&lt;br/&gt;  _, _ = builder.WriteString(s3)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用了 Grow 优化后的版本的性能测试结果如下。可以看出相较于不预先分配空间的方式，性能提升了很多。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BenchmarkJoinStrWithStringsBuilderPreAlloc-8    60079003                20.95 ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.遍历 []struct{} 使用下标而不是 range&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 中遍历切片或数组有两种方式，一种是通过下标，一种是 range。二者在功能上没有区别，但是在性能上会有区别吗？&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.1 []int&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先看一下遍历基本类型切片时二者的性能差别，以 []int 为例。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// genRandomIntSlice 生成指定长度的随机 []int 切片&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;genRandomIntSlice&lt;/span&gt;&lt;span&gt;(n &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; []&lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; rand.Seed(time.Now().UnixNano())&lt;br/&gt; nums := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, n)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++ {&lt;br/&gt;  nums = &lt;span&gt;append&lt;/span&gt;(nums, rand.Int())&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; nums&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkIndexIntSlice&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; nums := genRandomIntSlice(&lt;span&gt;1024&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; tmp &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; k := &lt;span&gt;0&lt;/span&gt;; k &amp;lt; &lt;span&gt;len&lt;/span&gt;(nums); k++ {&lt;br/&gt;   tmp = nums[k]&lt;br/&gt;  }&lt;br/&gt;  _ = tmp&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkRangeIntSlice&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; nums := genRandomIntSlice(&lt;span&gt;1024&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; tmp &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; _, num := &lt;span&gt;range&lt;/span&gt; nums {&lt;br/&gt;   tmp = num&lt;br/&gt;  }&lt;br/&gt;  _ = tmp&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行测试结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=IntSlice$ .&lt;br/&gt;goos: windows&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/perf&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9700 CPU @ 3.00GHz&lt;br/&gt;BenchmarkIndexIntSlice-8         5043324               236.2 ns/op&lt;br/&gt;BenchmarkRangeIntSlice-8         5076255               239.1 ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;genRandomIntSlice()&lt;/code&gt; 函数用于生成指定长度元素类型为 int 的切片。从最终的结果可以看到，遍历 []int 类型的切片，下标与 range 遍历性能几乎没有区别。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.2 []struct{}&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么对于稍微复杂一点的 []struct 类型呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Item &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; id  &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; val [&lt;span&gt;1024&lt;/span&gt;]&lt;span&gt;byte&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkIndexStructSlice&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; items [&lt;span&gt;1024&lt;/span&gt;]Item&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; tmp &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; j := &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;len&lt;/span&gt;(items); j++ {&lt;br/&gt;   tmp = items[j].id&lt;br/&gt;  }&lt;br/&gt;  _ = tmp&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkRangeIndexStructSlice&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; items [&lt;span&gt;1024&lt;/span&gt;]Item&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; tmp &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; k := &lt;span&gt;range&lt;/span&gt; items {&lt;br/&gt;   tmp = items[k].id&lt;br/&gt;  }&lt;br/&gt;  _ = tmp&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkRangeStructSlice&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; items [&lt;span&gt;1024&lt;/span&gt;]Item&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; tmp &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; _, item := &lt;span&gt;range&lt;/span&gt; items {&lt;br/&gt;   tmp = item.id&lt;br/&gt;  }&lt;br/&gt;  _ = tmp&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行测试结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=StructSlice$ .&lt;br/&gt;goos: windows&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/perf&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9700 CPU @ 3.00GHz&lt;br/&gt;BenchmarkIndexStructSlice-8              5079468               234.9 ns/op&lt;br/&gt;BenchmarkRangeIndexStructSlice-8         5087448               236.2 ns/op&lt;br/&gt;BenchmarkRangeStructSlice-8                38716               32265 ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出，两种通过 index 遍历 []struct 性能没有差别，但是 range 遍历 []struct 中元素时，性能非常差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;range 只遍历 []struct 下标时，性能比 range 遍历  []struct 值好很多。从这里我们应该能够知道二者性能差别之大的原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Item 是一个结构体类型 ，Item 由两个字段构成，一个类型是 int，一个是类型是 [1024]byte，如果每次遍历 []Item，都会进行一次值拷贝，所以带来了性能损耗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，因为 range 时获取的是值拷贝的副本，所以对副本的修改，是不会影响到原切片。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.3 []*struct&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那如果切片中是指向结构体的指针，而不是结构体呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// genItems 生成指定长度 []*Item 切片&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;genItems&lt;/span&gt;&lt;span&gt;(n &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; []*&lt;span&gt;Item&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; items := &lt;span&gt;make&lt;/span&gt;([]*Item, &lt;span&gt;0&lt;/span&gt;, n)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++ {&lt;br/&gt;  items = &lt;span&gt;append&lt;/span&gt;(items, &amp;amp;Item{id: i})&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; items&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkIndexPointer&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; items := genItems(&lt;span&gt;1024&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; tmp &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; k := &lt;span&gt;0&lt;/span&gt;; k &amp;lt; &lt;span&gt;len&lt;/span&gt;(items); k++ {&lt;br/&gt;   tmp = items[k].id&lt;br/&gt;  }&lt;br/&gt;  _ = tmp&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkRangePointer&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; items := genItems(&lt;span&gt;1024&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; tmp &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; _, item := &lt;span&gt;range&lt;/span&gt; items {&lt;br/&gt;   tmp = item.id&lt;br/&gt;  }&lt;br/&gt;  _ = tmp&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行性能测试结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=Pointer$ main/perf&lt;br/&gt;goos: windows&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/perf&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9700 CPU @ 3.00GHz&lt;br/&gt;BenchmarkIndexPointer-8           773634              1521 ns/op&lt;br/&gt;BenchmarkRangePointer-8           752077              1514 ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;切片元素从结构体 Item 替换为指针 *Item 后，for 和 range 的性能几乎是一样的。而且使用指针还有另一个好处，可以直接修改指针对应的结构体的值。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.4 小结&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;range 在迭代过程中返回的是元素的拷贝，index 则不存在拷贝。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 range 迭代的元素较小，那么 index 和 range 的性能几乎一样，如基本类型的切片 []int。但如果迭代的元素较大，如一个包含很多属性的 struct 结构体，那么 index 的性能将显著地高于 range，有时候甚至会有上千倍的性能差异。对于这种场景，建议使用 index。如果使用 range，建议只迭代下标，通过下标访问元素，这种使用方式和 index 就没有区别了。如果想使用 range 同时迭代下标和值，则需要将切片/数组的元素改为指针，才能不影响性能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;内存管理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.使用空结构体节省内存&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1 不占内存空间&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 中，我们可以使用 unsafe.Sizeof 计算出一个数据类型实例需要占用的字节数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;unsafe&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; fmt.Println(unsafe.Sizeof(&lt;span&gt;struct&lt;/span&gt;{}{}))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上面的例子将会输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; run main.&lt;span&gt;go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，Go 中空结构体 struct{} 是不占用内存空间，不像 C/C++ 中空结构体仍占用 1 字节。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2 用法&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为空结构体不占据内存空间，因此被广泛作为各种场景下的占位符使用。一是节省资源，二是空结构体本身就具备很强的语义，即这里不需要任何值，仅作为占位符，达到的代码即注释的效果。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2.1 实现集合（Set）&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言标准库没有提供 Set 的实现，通常使用 map 来代替。事实上，对于集合来说，只需要 map 的键，而不需要值。即使是将值设置为 bool 类型，也会多占据 1 个字节，那假设 map 中有一百万条数据，就会浪费 1MB 的空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此呢，将 map 作为集合（Set）使用时，可以将值类型定义为空结构体，仅作为占位符使用即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Set &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;struct&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(s Set)&lt;/span&gt; &lt;span&gt;Has&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; _, ok := s[key]&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; ok&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(s Set)&lt;/span&gt; &lt;span&gt;Add&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s[key] = &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(s Set)&lt;/span&gt; &lt;span&gt;Delete&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;delete&lt;/span&gt;(s, key)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s := &lt;span&gt;make&lt;/span&gt;(Set)&lt;br/&gt; s.Add(&lt;span&gt;&quot;foo&quot;&lt;/span&gt;)&lt;br/&gt; s.Add(&lt;span&gt;&quot;bar&quot;&lt;/span&gt;)&lt;br/&gt; fmt.Println(s.Has(&lt;span&gt;&quot;foo&quot;&lt;/span&gt;))&lt;br/&gt; fmt.Println(s.Has(&lt;span&gt;&quot;bar&quot;&lt;/span&gt;))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想使用 Set 的完整功能，如初始化（通过切片构建一个 Set）、Add、Del、Clear、Contains 等操作，可以使用开源库 &lt;a href=&quot;https://github.com/deckarep/golang-set&quot; data-linktype=&quot;2&quot;&gt;golang-set&lt;/a&gt;。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2.2 不发送数据的信道&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;worker&lt;/span&gt;&lt;span&gt;(ch &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &amp;lt;-ch&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;do something&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{})&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; worker(ch)&lt;br/&gt; ch &amp;lt;- &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt; &lt;span&gt;close&lt;/span&gt;(ch)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候使用 channel 不需要发送任何的数据，只用来通知子协程（goroutine）执行任务，或只用来控制协程的并发。这种情况下，使用空结构体作为占位符就非常合适了。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2.3 仅包含方法的结构体&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Door &lt;span&gt;struct&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(d Door)&lt;/span&gt; &lt;span&gt;Open&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;Open the door&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(d Door)&lt;/span&gt; &lt;span&gt;Close&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;Close the door&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在部分场景下，结构体只包含方法，不包含任何的字段。例如上面例子中的 Door，在这种情况下，Door 事实上可以用任何的数据结构替代。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Door &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Door &lt;span&gt;bool&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是 int 还是 bool 都会浪费额外的内存，因此呢，这种情况下，声明为空结构体最合适。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. struct 布局要考虑内存对齐&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 为什么需要内存对齐&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问。比如 32 位的 CPU ，字长为 4 字节，那么 CPU 访问内存的单位也是 4 字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么设计的目的，是减少 CPU 访问内存的次数，加大 CPU 访问内存的吞吐量。比如同样读取 8 个字节的数据，一次读取 4 个字节那么只需要读取 2 次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU 始终以字长访问内存，如果不进行内存对齐，很可能增加 CPU 访问内存的次数，例如：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6060606060606061&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasXic8UMQ0Bbvu6iaXLy4Q8sF3gkkRyxjMxonRLkWx29jDvibWPibibkoglDhHxPorbalQiaTJNDYRfFKGw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;990&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;变量 a、b 各占据 3 字节的空间，内存对齐后，a、b 占据 4 字节空间，CPU 读取 b 变量的值只需要进行一次内存访问。如果不进行内存对齐，CPU 读取 b 变量的值需要进行 2 次内存访问。第一次访问得到 b 变量的第 1 个字节，第二次访问得到 b 变量的后两个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这个例子中也可以看到，内存对齐对实现变量的原子性操作也是有好处的，每次内存访问是原子的，如果变量的大小不超过字长，那么内存对齐后，对该变量的访问就是原子的，这个特性在并发场景下至关重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简言之：合理的内存对齐可以提高内存读写的性能，并且便于实现变量操作的原子性。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 Go 内存对齐规则&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译器一般为了减少 CPU 访存指令周期，提高内存的访问效率，会对变量进行内存对齐。Go 作为一门追求高性能的后台编程语言，当然也不例外。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go Language Specification 中 &lt;a href=&quot;https://go.dev/ref/spec#Size_and_alignment_guarantees&quot; data-linktype=&quot;2&quot;&gt;Size and alignment guarantees&lt;/a&gt; 描述了内存对齐的规则。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1.For a variable x of any type: unsafe.Alignof(x) is at least 1.
2.For a variable x of struct type: unsafe.Alignof(x) is the largest of all the values unsafe.Alignof(x.f) for each field f of x, but at least 1.
3.For a variable x of array type: unsafe.Alignof(x) is the same as the alignment of a variable of the array&#x27;s element type.&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;对于任意类型的变量 x ，unsafe.Alignof(x) 至少为 1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于结构体类型的变量 x，计算 x 每一个字段 f 的 unsafe.Alignof(x.f)，unsafe.Alignof(x) 等于其中的最大值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于数组类型的变量 x，unsafe.Alignof(x) 等于构成数组的元素类型的对齐系数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中函数 &lt;code&gt;unsafe.Alignof&lt;/code&gt; 用于获取变量的对齐系数。对齐系数决定了字段的偏移和变量的大小，两者必须是对齐系数的整数倍。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3 合理的 struct 布局&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为内存对齐的存在，合理的 struct 布局可以减少内存占用，提高程序性能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; demo1 &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; a &lt;span&gt;int8&lt;/span&gt;&lt;br/&gt; b &lt;span&gt;int16&lt;/span&gt;&lt;br/&gt; c &lt;span&gt;int32&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; demo2 &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; a &lt;span&gt;int8&lt;/span&gt;&lt;br/&gt; c &lt;span&gt;int32&lt;/span&gt;&lt;br/&gt; b &lt;span&gt;int16&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; fmt.Println(unsafe.Sizeof(demo1{})) &lt;span&gt;// 8&lt;/span&gt;&lt;br/&gt; fmt.Println(unsafe.Sizeof(demo2{})) &lt;span&gt;// 12&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，同样的字段，因字段排列顺序不同，最终会导致不一样的结构体大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个字段按照自身的对齐系数来确定在内存中的偏移量，一个字段因偏移而浪费的大小也不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来逐个分析，首先是 demo1：a 是第一个字段，默认是已经对齐的，从第 0 个位置开始占据 1 字节。b 是第二个字段，对齐系数为 2，因此，必须空出 1 个字节，偏移量才是 2 的倍数，从第 2 个位置开始占据 2 字节。c 是第三个字段，对齐倍数为 4，此时，内存已经是对齐的，从第 4 个位置开始占据 4 字节即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此 demo1 的内存占用为 8 字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 demo2：a 是第一个字段，默认是已经对齐的，从第 0 个位置开始占据 1 字节。c 是第二个字段，对齐倍数为 4，因此，必须空出 3 个字节，偏移量才是 4 的倍数，从第 4 个位置开始占据 4 字节。b 是第三个字段，对齐倍数为 2，从第 8 个位置开始占据 2 字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;demo2 的对齐系数由 c 的对齐系数决定，也是 4，因此，demo2 的内存占用为 12 字节。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36891385767790263&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasXic8UMQ0Bbvu6iaXLy4Q8sFf2TJrMgXLEuDYFxgsuQ7cIph3SKr8DCwljibicSS85OZiaItevkL7rxnQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1068&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;因此，在对内存特别敏感的结构体的设计上，我们可以通过调整字段的顺序，将字段宽度从小到大由上到下排列，来减少内存的占用。&lt;/strong&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4 空结构与空数组对内存对齐的影响&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;空结构与空数组在 Go 中比较特殊。没有任何字段的空 struct{} 和没有任何元素的 array 占据的内存空间大小为 0。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为这一点，空 struct{} 或空 array 作为其他 struct 的字段时，一般不需要内存对齐。但是有一种情况除外：即当 struct{} 或空 array 作为结构体最后一个字段时，需要内存对齐。因为如果有指针指向该字段，返回的地址将在结构体之外，如果此指针一直存活不释放对应的内存，就会有内存泄露的问题（该内存不因结构体释放而释放）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; demo3 &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; a &lt;span&gt;struct&lt;/span&gt;{}&lt;br/&gt; b &lt;span&gt;int32&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; demo4 &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; b &lt;span&gt;int32&lt;/span&gt;&lt;br/&gt; a &lt;span&gt;struct&lt;/span&gt;{}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; fmt.Println(unsafe.Sizeof(demo3{})) &lt;span&gt;// 4&lt;/span&gt;&lt;br/&gt; fmt.Println(unsafe.Sizeof(demo4{})) &lt;span&gt;// 8&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，demo3{} 的大小为 4 字节，与字段 b 占据空间一致，而 demo4{} 的大小为 8 字节，即额外填充了 4 字节的空间。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.减少逃逸，将变量限制在栈上&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;变量逃逸一般发生在如下几种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;变量较大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;变量大小不确定&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;变量类型不确定&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回指针&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回引用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;闭包&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道变量逃逸的原因后，我们可以有意识的控制变量不发生逃逸，将其控制在栈上，减少堆变量的分配，降低 GC 成本，提高程序性能。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 小的拷贝好过引用&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小的拷贝好过引用，什么意思呢，就是尽量使用栈变量而不是堆变量。下面举一个反常识的例子，来证明小的拷贝比在堆上创建引用变量要好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道 Go 里面的 Array 以 pass-by-value 方式传递后，再加上其长度不可扩展，考虑到性能我们一般很少使用它。实际上，凡事无绝对。有时使用数组进行拷贝传递，比使用切片要好。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// copy/copy.go&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; capacity = &lt;span&gt;1024&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;arrayFibonacci&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; [&lt;span&gt;capacity&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; d [capacity]&lt;span&gt;int&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;len&lt;/span&gt;(d); i++ {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; i &amp;lt;= &lt;span&gt;1&lt;/span&gt; {&lt;br/&gt;   d[i] = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  d[i] = d[i&lt;span&gt;-1&lt;/span&gt;] + d[i&lt;span&gt;-2&lt;/span&gt;]&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; d&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;sliceFibonacci&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; []&lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; d := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, capacity)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;len&lt;/span&gt;(d); i++ {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; i &amp;lt;= &lt;span&gt;1&lt;/span&gt; {&lt;br/&gt;   d[i] = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  d[i] = d[i&lt;span&gt;-1&lt;/span&gt;] + d[i&lt;span&gt;-2&lt;/span&gt;]&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; d&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面看一下性能对比。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkArray&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = arrayFibonacci()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkSlice&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = sliceFibonacci()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上面的基准测试，将得到如下结果。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=. -benchmem -gcflags=&quot;-l&quot; main/copy&lt;br/&gt;goos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/copy&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz&lt;br/&gt;BenchmarkArray-12         692400              1708 ns/op               0 B/op          0 allocs/op&lt;br/&gt;BenchmarkSlice-12         464974              2242 ns/op            8192 B/op          1 allocs/op&lt;br/&gt;PASS&lt;br/&gt;ok      main/copy       3.908s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从测试结果可以看出，对数组的拷贝性能却比使用切片要好。为什么会这样呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sliceFibonacci() 函数中分配的局部变量切片因为要返回到函数外部，所以发生了逃逸，需要在堆上申请内存空间。从测试也过也可以看出，arrayFibonacci() 函数没有内存分配，完全在栈上完成数组的创建。这里说明了对于一些短小的对象，栈上复制的成本远小于在堆上分配和回收操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意，运行上面基准测试时，传递了禁止内联的编译选项 &quot;-l&quot;，如果发生内联，那么将不会出现变量的逃逸，就不存在堆上分配内存与回收的操作了，二者将看不出性能差异。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译时可以借助选项 -gcflags=-m 查看编译器对上面两个函数的优化决策。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go build  -gcflags=-m copy/copy.go&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; &lt;span&gt;command&lt;/span&gt;-line-arguments&lt;/span&gt;&lt;br/&gt;copy/copy.go:5:6: can inline arrayFibonacci&lt;br/&gt;copy/copy.go:17:6: can inline sliceFibonacci&lt;br/&gt;copy/copy.go:18:11: make([]int, capacity) escapes to heap&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，arrayFibonacci() 和 sliceFibonacci() 函数均可内联。sliceFibonacci() 函数中定义的局部变量切片逃逸到了堆。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么多大的变量才算是小变量呢？对 Go 编译器而言，超过一定大小的局部变量将逃逸到堆上，不同的 Go 版本的大小限制可能不一样。一般是 &amp;lt;64KB，局部变量将不会逃逸到堆上。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 返回值 VS 返回指针&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值传递会拷贝整个对象，而指针传递只会拷贝地址，指向的对象是同一个。返回指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收(GC)的负担。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择返回指针。对于只读的占用内存较小的结构体，直接返回值能够获得更好的性能。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3 返回值使用确定的类型&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果变量类型不确定，那么将会逃逸到堆上。所以，函数返回值如果能确定的类型，就不要使用 interface{}。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是以上面斐波那契数列函数为例，看下返回值为确定类型和 interface{} 的性能差别。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; capacity = &lt;span&gt;1024&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;arrayFibonacci&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; [&lt;span&gt;capacity&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; d [capacity]&lt;span&gt;int&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;len&lt;/span&gt;(d); i++ {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; i &amp;lt;= &lt;span&gt;1&lt;/span&gt; {&lt;br/&gt;   d[i] = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  d[i] = d[i&lt;span&gt;-1&lt;/span&gt;] + d[i&lt;span&gt;-2&lt;/span&gt;]&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; d&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;arrayFibonacciIfc&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;/span&gt;{} {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; d [capacity]&lt;span&gt;int&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;len&lt;/span&gt;(d); i++ {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; i &amp;lt;= &lt;span&gt;1&lt;/span&gt; {&lt;br/&gt;   d[i] = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  d[i] = d[i&lt;span&gt;-1&lt;/span&gt;] + d[i&lt;span&gt;-2&lt;/span&gt;]&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; d&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkArray&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = arrayFibonacci()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkIfc&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = arrayFibonacciIfc()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上面的基准测试结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=. -benchmem main/copy&lt;br/&gt;goos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/copy&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz&lt;br/&gt;BenchmarkArray-12         832418              1427 ns/op               0 B/op          0 allocs/op&lt;br/&gt;BenchmarkIfc-12           380626              2861 ns/op            8192 B/op          1 allocs/op&lt;br/&gt;PASS&lt;br/&gt;ok      main/copy       3.742s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可见，函数返回值使用 interface{} 返回时，编译器无法确定返回值的具体类型，导致返回值逃逸到堆上。当发生了堆上内存的申请与回收时，性能会差一点。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.sync.Pool 复用对象&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1 简介&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Pool 是 sync 包下的一个组件，可以作为保存临时取还对象的一个“池子”。个人觉得它的名字有一定的误导性，因为 Pool 里装的对象可以被无通知地被回收，可能 sync.Cache 是一个更合适的名字。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Pool 是可伸缩的，同时也是并发安全的，其容量仅受限于内存的大小。存放在池中的对象如果不活跃了会被自动清理。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2 作用&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于很多需要重复分配、回收内存的地方，sync.Pool 是一个很好的选择。频繁地分配、回收内存会给 GC 带来一定的负担，严重的时候会引起 CPU 的毛刺，而 sync.Pool 可以将暂时不用的对象缓存起来，待下次需要的时候直接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力，提升系统的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一句话总结：用来保存和复用临时对象，减少内存分配，降低 GC 压力。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.3 如何使用&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Pool 的使用方式非常简单，只需要实现 New 函数即可。对象池中没有对象时，将会调用 New 函数创建。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们有一个“学生”结构体，并复用改结构体对象。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Student &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Name   &lt;span&gt;string&lt;/span&gt;&lt;br/&gt; Age    &lt;span&gt;int32&lt;/span&gt;&lt;br/&gt; Remark [&lt;span&gt;1024&lt;/span&gt;]&lt;span&gt;byte&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; studentPool = sync.Pool{&lt;br/&gt;    New: &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;/span&gt;{} { &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;(Student) &lt;br/&gt;    },&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后调用 Pool 的 Get() 和 Put() 方法来获取和放回池子中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;stu := studentPool.Get().(*Student)&lt;br/&gt;json.Unmarshal(buf, stu)&lt;br/&gt;studentPool.Put(stu)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Get() 用于从对象池中获取对象，因为返回值是 interface{}，因此需要类型转换。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Put() 则是在对象使用完毕后，放回到对象池。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4 性能差异&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以 bytes.Buffer 字节缓冲器为例，利用 sync.Pool 复用 bytes.Buffer 对象，避免重复创建与回收内存，来看看对性能的提升效果。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; bufferPool = sync.Pool{&lt;br/&gt; New: &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;/span&gt;{} {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &amp;amp;bytes.Buffer{}&lt;br/&gt; },&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; data = &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;10000&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkBufferWithPool&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;0&lt;/span&gt;; n &amp;lt; b.N; n++ {&lt;br/&gt;  buf := bufferPool.Get().(*bytes.Buffer)&lt;br/&gt;  buf.Write(data)&lt;br/&gt;  buf.Reset()&lt;br/&gt;  bufferPool.Put(buf)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkBuffer&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;0&lt;/span&gt;; n &amp;lt; b.N; n++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; buf bytes.Buffer&lt;br/&gt;  buf.Write(data)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=. -benchmem main/pool&lt;br/&gt;goos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/pool&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz&lt;br/&gt;BenchmarkBufferWithPool-12      11987966                97.12 ns/op            0 B/op          0 allocs/op&lt;br/&gt;BenchmarkBuffer-12               1246887              1020 ns/op           10240 B/op          1 allocs/op&lt;br/&gt;PASS&lt;br/&gt;ok      main/pool       3.510s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子创建了一个 bytes.Buffer 对象池，每次只执行 Write 操作，及做一次数据拷贝，耗时几乎可以忽略。而内存分配和回收的耗时占比较多，因此对程序整体的性能影响更大。从测试结果也可以看出，使用了 Pool 复用对象，每次操作不再有内存分配。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.5 在标准库中的应用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 标准库也大量使用了 sync.Pool，例如 fmt 和 encoding/json。以 fmt 包为例，我们看下其是如何使用 sync.Pool 的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看一下最常用的标准格式化输出函数 Printf() 函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Printf formats according to a format specifier and writes to standard output.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// It returns the number of bytes written and any write error encountered.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Printf&lt;/span&gt;&lt;span&gt;(format &lt;span&gt;string&lt;/span&gt;, a ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;(n &lt;span&gt;int&lt;/span&gt;, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; Fprintf(os.Stdout, format, a...)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续看 Fprintf() 的定义。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Fprintf formats according to a format specifier and writes to w.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// It returns the number of bytes written and any write error encountered.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Fprintf&lt;/span&gt;&lt;span&gt;(w io.Writer, format &lt;span&gt;string&lt;/span&gt;, a ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;(n &lt;span&gt;int&lt;/span&gt;, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; p := newPrinter()&lt;br/&gt; p.doPrintf(format, a)&lt;br/&gt; n, err = w.Write(p.buf)&lt;br/&gt; p.free()&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Fprintf() 函数的参数是一个 io.Writer，Printf() 传的是 os.Stdout，相当于直接输出到标准输出。这里的 newPrinter 用的就是 sync.Pool。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// go version go1.17 darwin/amd64&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// pp is used to store a printer&#x27;s state and is reused with sync.Pool to avoid allocations.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; pp &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    buf buffer&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; ppFree = sync.Pool{&lt;br/&gt; New: &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;/span&gt;{} { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;(pp) },&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// newPrinter allocates a new pp struct or grabs a cached one.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;newPrinter&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; *&lt;span&gt;pp&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; p := ppFree.Get().(*pp)&lt;br/&gt; p.panicking = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; p.erroring = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; p.wrapErrs = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; p.fmt.init(&amp;amp;p.buf)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; p&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// free saves used pp structs in ppFree; avoids an allocation per invocation.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(p *pp)&lt;/span&gt; &lt;span&gt;free&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// Proper usage of a sync.Pool requires each entry to have approximately&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// the same memory cost. To obtain this property when the stored type&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// contains a variably-sized buffer, we add a hard limit on the maximum buffer&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// to place back in the pool.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// See https://golang.org/issue/23199&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;cap&lt;/span&gt;(p.buf) &amp;gt; &lt;span&gt;64&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;10&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; p.buf = p.buf[:&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt; p.arg = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; p.value = reflect.Value{}&lt;br/&gt; p.wrappedErr = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; ppFree.Put(p)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;fmt.Printf() 的调用是非常频繁的，利用 sync.Pool 复用 pp 对象能够极大地提升性能，减少内存占用，同时降低 GC 压力。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;并发编程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.关于锁&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1 无锁化&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加锁是为了避免在并发环境下，同时访问共享资源产生的安全问题。那么，在并发环境下，是否必须加锁？答案是否定的。并非所有的并发都需要加锁。适当地降低锁的粒度，甚至采用无锁化的设计，更能提升并发能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无锁化主要有两种实现，无锁数据结构和串行无锁。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1.1 无锁数据结构&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用硬件支持的原子操作可以实现无锁的数据结构，原子操作可以在 lock-free 的情况下保证并发安全，并且它的性能也能做到随 CPU 个数的增多而线性扩展。很多语言都提供 CAS 原子操作（如 Go 中的 atomic 包和 C++11 中的 atomic 库），可以用于实现无锁数据结构，如无锁链表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以一个简单的线程安全单向链表的插入操作来看下无锁编程和普通加锁的区别。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; list&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;sync&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;sync/atomic&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&quot;golang.org/x/sync/errgroup&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Node 链表节点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Node &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Value &lt;span&gt;interface&lt;/span&gt;{}&lt;br/&gt; Next  *Node&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 有锁单向链表的简单实现&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// WithLockList 有锁单向链表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; WithLockList &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Head *Node&lt;br/&gt; mu   sync.Mutex&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Push 将元素插入到链表的首部&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(l *WithLockList)&lt;/span&gt; &lt;span&gt;Push&lt;/span&gt;&lt;span&gt;(v &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; l.mu.Lock()&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; l.mu.Unlock()&lt;br/&gt; n := &amp;amp;Node{&lt;br/&gt;  Value: v,&lt;br/&gt;  Next:  l.Head,&lt;br/&gt; }&lt;br/&gt; l.Head = n&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// String 有锁链表的字符串形式输出&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(l WithLockList)&lt;/span&gt; &lt;span&gt;String&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s := &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt; cur := l.Head&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; cur == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; s != &lt;span&gt;&quot;&quot;&lt;/span&gt; {&lt;br/&gt;   s += &lt;span&gt;&quot;,&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  s += fmt.Sprintf(&lt;span&gt;&quot;%v&quot;&lt;/span&gt;, cur.Value)&lt;br/&gt;  cur = cur.Next&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; s&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 无锁单向链表的简单实现&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// LockFreeList 无锁单向链表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; LockFreeList &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Head atomic.Value&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Push 有锁&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(l *LockFreeList)&lt;/span&gt; &lt;span&gt;Push&lt;/span&gt;&lt;span&gt;(v &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  head := l.Head.Load()&lt;br/&gt;  headNode, _ := head.(*Node)&lt;br/&gt;  n := &amp;amp;Node{&lt;br/&gt;   Value: v,&lt;br/&gt;   Next:  headNode,&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; l.Head.CompareAndSwap(head, n) {&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// String 有锁链表的字符串形式输出&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(l LockFreeList)&lt;/span&gt; &lt;span&gt;String&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s := &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt; cur := l.Head.Load().(*Node)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; cur == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; s != &lt;span&gt;&quot;&quot;&lt;/span&gt; {&lt;br/&gt;   s += &lt;span&gt;&quot;,&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  s += fmt.Sprintf(&lt;span&gt;&quot;%v&quot;&lt;/span&gt;, cur.Value)&lt;br/&gt;  cur = cur.Next&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; s&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的实现有几点需要注意一下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）无锁单向链表实现时在插入时需要进行 CAS 操作，即调用&lt;code&gt;CompareAndSwap()&lt;/code&gt;方法进行插入，如果插入失败则进行 for 循环多次尝试，直至成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）为了方便打印链表内容，实现一个&lt;code&gt;String()&lt;/code&gt;方法遍历链表，且使用值作为接收者，避免打印对象指针时无法生效。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ol start=&quot;5&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;If an operand implements method String() string, that method will be invoked to convert the object to a string, which will then be formatted as required by the verb (if any).&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们分别对两种链表做一个并发写入的操作验证一下其功能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;br/&gt; &lt;span&gt;&quot;main/list&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ConcurWriteWithLockList 并发写入有锁链表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ConcurWriteWithLockList&lt;/span&gt;&lt;span&gt;(l *WithLockList)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; g errgroup.Group&lt;br/&gt; &lt;span&gt;// 10 个协程并发写入链表&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt;  i := i&lt;br/&gt;  g.Go(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   l.Push(i)&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt; _ = g.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ConcurWriteLockFreeList 并发写入无锁链表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ConcurWriteLockFreeList&lt;/span&gt;&lt;span&gt;(l *LockFreeList)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; g errgroup.Group&lt;br/&gt; &lt;span&gt;// 10 个协程并发写入链表&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt;  i := i&lt;br/&gt;  g.Go(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   l.Push(i)&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt; _ = g.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// 并发写入与遍历打印有锁链表&lt;/span&gt;&lt;br/&gt; l1 := &amp;amp;list.WithLockList{}&lt;br/&gt; list.ConcurWriteWithLockList(l1)&lt;br/&gt; fmt.Println(l1)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 并发写入与遍历打印无锁链表&lt;/span&gt;&lt;br/&gt; l2 := &amp;amp;list.LockFreeList{}&lt;br/&gt; list.ConcurWriteLockFreeList(l2)&lt;br/&gt; fmt.Println(l2)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，多次运行上面的&lt;code&gt;main()&lt;/code&gt;函数的结果可能会不相同，因为并发是无序的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;8,7,6,9,5,4,3,1,2,0&lt;br/&gt;9,8,7,6,5,4,3,2,0,1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面再看一下链表 Push 操作的基准测试，对比一下有锁与无锁的性能差异。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkWriteWithLockList&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; l := &amp;amp;WithLockList{}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;0&lt;/span&gt;; n &amp;lt; b.N; n++ {&lt;br/&gt;  l.Push(n)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;BenchmarkWriteWithLockList&lt;span&gt;-8&lt;/span&gt;    &lt;span&gt;14234166&lt;/span&gt;                &lt;span&gt;83.58&lt;/span&gt; ns/op&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkWriteLockFreeList&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; l := &amp;amp;LockFreeList{}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;0&lt;/span&gt;; n &amp;lt; b.N; n++ {&lt;br/&gt;  l.Push(n)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;BenchmarkWriteLockFreeList&lt;span&gt;-8&lt;/span&gt;    &lt;span&gt;15219405&lt;/span&gt;                &lt;span&gt;73.15&lt;/span&gt; ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出无锁版本比有锁版本性能高一些。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1.2 串行无锁&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;串行无锁是一种思想，就是避免对共享资源的并发访问，改为每个并发操作访问自己独占的资源，达到串行访问资源的效果，来避免使用锁。不同的场景有不同的实现方式。比如网络 I/O 场景下将&lt;strong&gt;单 Reactor 多线程模型&lt;/strong&gt;改为&lt;strong&gt;主从 Reactor 多线程模型&lt;/strong&gt;，避免对同一个消息队列锁读取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我介绍的是后台微服务开发经常遇到的一种情况。我们经常需要并发拉取多方面的信息，汇聚到一个变量上。那么此时就存在对同一个变量互斥写入的情况。比如批量并发拉取用户信息写入到一个 map。此时我们可以将每个协程拉取的结果写入到一个临时对象，这样便将并发地协程与同一个变量解绑，然后再将其汇聚到一起，这样便可以不用使用锁。即独立处理，然后合并。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.19331742243436753&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasXic8UMQ0Bbvu6iaXLy4Q8sFJCE3nO5BibRwkgEf3biaawPGIsxcJ6qQib7aSFQdIlmaRrYHz1Zs5D9WA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1676&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了模拟上面的情况，简单地写个示例程序，对比下性能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;sync&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&quot;golang.org/x/sync/errgroup&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ConcurWriteMapWithLock 有锁并发写入 map&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ConcurWriteMapWithLock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; m := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; mu sync.Mutex&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; g errgroup.Group&lt;br/&gt; &lt;span&gt;// 10 个协程并发写入 map&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt;  i := i&lt;br/&gt;  g.Go(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   mu.Lock()&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; mu.Unlock()&lt;br/&gt;   m[i] = i * i&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt; _ = g.Wait()&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; m&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ConcurWriteMapLockFree 无锁并发写入 map&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ConcurWriteMapLockFree&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; m := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;// 每个协程独占一 value&lt;/span&gt;&lt;br/&gt; values := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;// 10 个协程并发写入 map&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; g errgroup.Group&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt;  i := i&lt;br/&gt;  g.Go(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   values[i] = i * i&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt; _ = g.Wait()&lt;br/&gt; &lt;span&gt;// 汇聚结果到 map&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i, v := &lt;span&gt;range&lt;/span&gt; values {&lt;br/&gt;  m[i] = v&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; m&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看下二者的性能差异：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkConcurWriteMapWithLock&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;0&lt;/span&gt;; n &amp;lt; b.N; n++ {&lt;br/&gt;  _ = ConcurWriteMapWithLock()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;BenchmarkConcurWriteMapWithLock&lt;span&gt;-8&lt;/span&gt;         &lt;span&gt;218673&lt;/span&gt;              &lt;span&gt;5089&lt;/span&gt; ns/op&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkConcurWriteMapLockFree&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;0&lt;/span&gt;; n &amp;lt; b.N; n++ {&lt;br/&gt;  _ = ConcurWriteMapLockFree()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;BenchmarkConcurWriteMapLockFree&lt;span&gt;-8&lt;/span&gt;         &lt;span&gt;316635&lt;/span&gt;              &lt;span&gt;4048&lt;/span&gt; ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2 减少锁竞争&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果加锁无法避免，则可以采用分片的形式，减少对资源加锁的次数，这样也可以提高整体的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如 Golang 优秀的本地缓存组件  &lt;a href=&quot;https://github.com/allegro/bigcache&quot; data-linktype=&quot;2&quot;&gt;bigcache&lt;/a&gt; 、&lt;a href=&quot;https://github.com/patrickmn/go-cache&quot; data-linktype=&quot;2&quot;&gt;go-cache&lt;/a&gt;、&lt;a href=&quot;https://github.com/coocood/freecache&quot; data-linktype=&quot;2&quot;&gt;freecache&lt;/a&gt; 都实现了分片功能，每个分片一把锁，采用分片存储的方式减少加锁的次数从而提高整体性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以一个简单的示例，通过对&lt;code&gt;map[uint64]struct{}&lt;/code&gt;分片前后并发写入的对比，来看下减少锁竞争带来的性能提升。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; (&lt;br/&gt; num = &lt;span&gt;1000000&lt;/span&gt;&lt;br/&gt; m0  = &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;struct&lt;/span&gt;{}, num)&lt;br/&gt; mu0 = sync.RWMutex{}&lt;br/&gt; m1  = &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;struct&lt;/span&gt;{}, num)&lt;br/&gt; mu1 = sync.RWMutex{}&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ConWriteMapNoShard 不分片写入一个 map。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ConWriteMapNoShard&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; g := errgroup.Group{}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; num; i++ {&lt;br/&gt;  g.Go(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   mu0.Lock()&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; mu0.Unlock()&lt;br/&gt;   m0[i] = &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt; _ = g.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ConWriteMapTwoShard 分片写入两个 map。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ConWriteMapTwoShard&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; g := errgroup.Group{}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; num; i++ {&lt;br/&gt;  g.Go(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; i&amp;amp;&lt;span&gt;1&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;    mu0.Lock()&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; mu0.Unlock()&lt;br/&gt;    m0[i] = &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   mu1.Lock()&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; mu1.Unlock()&lt;br/&gt;   m1[i] = &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt; _ = g.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看下二者的性能差异：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkConWriteMapNoShard&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  ConWriteMapNoShard()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;BenchmarkConWriteMapNoShard&lt;span&gt;-12&lt;/span&gt;                 &lt;span&gt;3&lt;/span&gt;         &lt;span&gt;472063245&lt;/span&gt; ns/op&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkConWriteMapTwoShard&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  ConWriteMapTwoShard()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;BenchmarkConWriteMapTwoShard&lt;span&gt;-12&lt;/span&gt;                &lt;span&gt;4&lt;/span&gt;         &lt;span&gt;310588155&lt;/span&gt; ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，通过对分共享资源的分片处理，减少了锁竞争，能明显地提高程序的并发性能。可以预见的是，随着分片粒度地变小，性能差距会越来越大。当然，分片粒度不是越小越好。因为每一个分片都要配一把锁，那么会带来很多额外的不必要的开销。可以选择一个不太大的值，在性能和花销上寻找一个平衡。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3 优先使用共享锁而非互斥锁&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果并发无法做到无锁化，优先使用共享锁而非互斥锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓互斥锁，指锁只能被一个 Goroutine 获得。共享锁指可以同时被多个 Goroutine 获得的锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 标准库 sync 提供了两种锁，互斥锁（sync.Mutex）和读写锁（sync.RWMutex），读写锁便是共享锁的一种具体实现。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3.1 sync.Mutex&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;互斥锁的作用是保证共享资源同一时刻只能被一个 Goroutine 占用，一个 Goroutine 占用了，其他的 Goroutine 则阻塞等待。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3859223300970874&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasXic8UMQ0Bbvu6iaXLy4Q8sFuDDfnQxBm08cRBpsiacfibcOFSnm1wWmtkBp9zFNeaq0WMdl55LehQCQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;824&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Mutex 提供了两个导出方法用来使用锁。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Lock()   &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;Unlock()   &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过在访问共享资源前前用 Lock 方法对资源进行上锁，在访问共享资源后调用 Unlock 方法来释放锁，也可以用 defer 语句来保证互斥锁一定会被解锁。在一个 Go 协程调用 Lock 方法获得锁后，其他请求锁的协程都会阻塞在 Lock 方法，直到锁被释放。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3.2 sync.RWMutex&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读写锁是一种共享锁，也称之为多读单写锁 (multiple readers, single writer lock)。在使用锁时，对获取锁的目的操作做了区分，一种是读操作，一种是写操作。因为同一时刻允许多个 Gorouine 获取读锁，所以是一种共享锁。但写锁是互斥的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，有如下几种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;读锁之间不互斥，没有写锁的情况下，读锁是无阻塞的，多个协程可以同时获得读锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写锁之间是互斥的，存在写锁，其他写锁阻塞。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写锁与读锁是互斥的，如果存在读锁，写锁阻塞，如果存在写锁，读锁阻塞。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.20430107526881722&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasXic8UMQ0Bbvu6iaXLy4Q8sFVsSVEskUxvXv93ibFYdsQUHpHLE2zY5zsMZE93VeYn3eK15R9sSpZWA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1674&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.RWMutex 提供了五个导出方法用来使用锁。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Lock()    &lt;span&gt;// 加写锁&lt;/span&gt;&lt;br/&gt;Unlock()   &lt;span&gt;// 释放写锁&lt;/span&gt;&lt;br/&gt;RLock()    &lt;span&gt;// 加读锁&lt;/span&gt;&lt;br/&gt;RUnlock()   &lt;span&gt;// 释放读锁&lt;/span&gt;&lt;br/&gt;RLocker() Locker &lt;span&gt;// 返回读锁，使用 Lock() 和 Unlock() 进行 RLock() 和 RUnlock()&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读写锁的存在是为了解决读多写少时的性能问题，读场景较多时，读写锁可有效地减少锁阻塞的时间。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3.3 性能对比&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大部分业务场景是读多写少，所以使用读写锁可有效提高对共享数据的访问效率。最坏的情况，只有写请求，那么读写锁顶多退化成互斥锁。所以优先使用读写锁而非互斥锁，可以提高程序的并发性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们测试三种情景下，互斥锁和读写锁的性能差异。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;读多写少(读占 80%)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;读写一致(各占 50%)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;读少写多(读占 20%)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先根据互斥锁和读写锁分别实现对共享 map 的并发读写。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// OpMapWithMutex 使用互斥锁读写 map。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// rpct 为读操作占比。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;OpMapWithMutex&lt;/span&gt;&lt;span&gt;(rpct &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; m := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;struct&lt;/span&gt;{})&lt;br/&gt; mu := sync.Mutex{}&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; wg sync.WaitGroup&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++ {&lt;br/&gt;  i := i&lt;br/&gt;  wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;   mu.Lock()&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; mu.Unlock()&lt;br/&gt;   &lt;span&gt;// 写操作。&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; i &amp;gt;= rpct {&lt;br/&gt;    m[i] = &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt;    time.Sleep(time.Microsecond)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;// 读操作。&lt;/span&gt;&lt;br/&gt;   _ = m[i]&lt;br/&gt;   time.Sleep(time.Microsecond)&lt;br/&gt;  }()&lt;br/&gt; }&lt;br/&gt; wg.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// OpMapWithRWMutex 使用读写锁读写 map。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// rpct 为读操作占比。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;OpMapWithRWMutex&lt;/span&gt;&lt;span&gt;(rpct &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; m := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;struct&lt;/span&gt;{})&lt;br/&gt; mu := sync.RWMutex{}&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; wg sync.WaitGroup&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++ {&lt;br/&gt;  i := i&lt;br/&gt;  wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;   &lt;span&gt;// 写操作。&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; i &amp;gt;= rpct {&lt;br/&gt;    mu.Lock()&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; mu.Unlock()&lt;br/&gt;    m[i] = &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt;    time.Sleep(time.Microsecond)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;// 读操作。&lt;/span&gt;&lt;br/&gt;   mu.RLock()&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; mu.RUnlock()&lt;br/&gt;   _ = m[i]&lt;br/&gt;   time.Sleep(time.Microsecond)&lt;br/&gt;  }()&lt;br/&gt; }&lt;br/&gt; wg.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;入参 rpct 用来调节读操作的占比，来模拟读写占比不同的场景。rpct 设为 80 表示读多写少(读占 80%)，rpct 设为 50 表示读写一致(各占 50%)，rpct 设为 20 表示读少写多(读占 20%)。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkMutexReadMore&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  OpMapWithMutex(&lt;span&gt;80&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkRWMutexReadMore&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  OpMapWithRWMutex(&lt;span&gt;80&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkMutexRWEqual&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  OpMapWithMutex(&lt;span&gt;50&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkRWMutexRWEqual&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  OpMapWithRWMutex(&lt;span&gt;50&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkMutexWriteMore&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  OpMapWithMutex(&lt;span&gt;20&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkRWMutexWriteMore&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  OpMapWithRWMutex(&lt;span&gt;20&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行当前包下的所有基准测试，结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dablelv@DABLELV-MB0 mutex % go test -bench=.&lt;br/&gt;goos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/mutex&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz&lt;br/&gt;BenchmarkMutexReadMore-12                   2462            485917 ns/op&lt;br/&gt;BenchmarkRWMutexReadMore-12                 8074            145690 ns/op&lt;br/&gt;BenchmarkMutexRWEqual-12                    2406            498673 ns/op&lt;br/&gt;BenchmarkRWMutexRWEqual-12                  4124            303693 ns/op&lt;br/&gt;BenchmarkMutexWriteMore-12                  1906            532350 ns/op&lt;br/&gt;BenchmarkRWMutexWriteMore-12                2462            432386 ns/op&lt;br/&gt;PASS&lt;br/&gt;ok      main/mutex      9.532s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可见读多写少的场景，使用读写锁并发性能会更优。可以预见的是如果写占比更低，那么读写锁带的并发效果会更优。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里需要注意的是，因为每次读写 map 的操作耗时很短，所以每次睡眠一微秒（百万分之一秒）来增加耗时，不然对共享资源的访问耗时，小于锁处理的本身耗时，那么使用读写锁带来的性能优化效果将变得不那么明显，甚至会降低性能。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.限制协程数量&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 协程数过多的问题&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.1 程序崩溃&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 程（goroutine）是由 Go 运行时管理的轻量级线程。通过它我们可以轻松实现并发编程。但是当我们无限开辟协程时，将会遇到致命的问题。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; wg sync.WaitGroup&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; math.MaxInt32; i++ {&lt;br/&gt;  wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(i &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;   fmt.Println(i)&lt;br/&gt;   time.Sleep(time.Second)&lt;br/&gt;  }(i)&lt;br/&gt; }&lt;br/&gt; wg.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子实现了 math.MaxInt32 个协程的并发，&lt;code&gt;2^31 - 1&lt;/code&gt; 约为 20 亿个，每个协程内部几乎没有做什么事情。正常的情况下呢，这个程序会乱序输出 0 ~ 2^31-1 个数字。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序会像预期的那样顺利的运行吗？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go run main.go&lt;br/&gt;...&lt;br/&gt;108668&lt;br/&gt;1142025&lt;br/&gt;panic: too many concurrent operations on a single file or socket (max 1048575)&lt;br/&gt;&lt;br/&gt;goroutine 1158408 [running]:&lt;br/&gt;internal/poll.(*fdMutex).rwlock(0xc0000ae060, 0x0)&lt;br/&gt;        /usr/local/go/src/internal/poll/fd_mutex.go:147 +0x11b&lt;br/&gt;internal/poll.(*FD).writeLock(...)&lt;br/&gt;        /usr/local/go/src/internal/poll/fd_mutex.go:239&lt;br/&gt;internal/poll.(*FD).Write(0xc0000ae060, {0xc12cadf690, 0x8, 0x8})&lt;br/&gt;        /usr/local/go/src/internal/poll/fd_unix.go:262 +0x72&lt;br/&gt;os.(*File).write(...)&lt;br/&gt;        /usr/local/go/src/os/file_posix.go:49&lt;br/&gt;os.(*File).Write(0xc0000ac008, {0xc12cadf690, 0x1, 0xc12ea62f50})&lt;br/&gt;        /usr/local/go/src/os/file.go:176 +0x65&lt;br/&gt;fmt.Fprintln({0x10c00e0, 0xc0000ac008}, {0xc12ea62f90, 0x1, 0x1})&lt;br/&gt;        /usr/local/go/src/fmt/print.go:265 +0x75&lt;br/&gt;fmt.Println(...)&lt;br/&gt;        /usr/local/go/src/fmt/print.go:274&lt;br/&gt;main.main.func1(0x0)&lt;br/&gt;        /Users/dablelv/work/code/test/main.go:16 +0x8f&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行的结果是程序直接崩溃了，关键的报错信息是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;panic: too many concurrent operations on a single file or socket (max 1048575)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对单个 file/socket 的并发操作个数超过了系统上限，这个报错是 fmt.Printf 函数引起的，fmt.Printf 将格式化后的字符串打印到屏幕，即标准输出。在 Linux 系统中，标准输出也可以视为文件，内核（Kernel）利用文件描述符（File Descriptor）来访问文件，标准输出的文件描述符为 1，错误输出文件描述符为 2，标准输入的文件描述符为 0。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简而言之，系统的资源被耗尽了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那如果我们将 fmt.Printf 这行代码去掉呢？那程序很可能会因为内存不足而崩溃。这一点更好理解，每个协程至少需要消耗 2KB 的空间，那么假设计算机的内存是 4GB，那么至多允许 4GB/2KB = 1M 个协程同时存在。那如果协程中还存在着其他需要分配内存的操作，那么允许并发执行的协程将会数量级地减少。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.2 协程的代价&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面的例子过于极端，一般情况下程序也不会无限开辟协程，旨在说明协程数量是有限制的，不能无限开辟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们开辟很多协程，但不会导致程序崩溃，可以吗？如果真要这么做的话，我们应该清楚地知道，协程虽然轻量，但仍有开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 的开销主要是三个方面：创建（占用内存）、调度（增加调度器负担）和删除（增加 GC 压力）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;空间上，一个 Go 程占用约 2K 的内存，在源码 src/runtime/runtime2.go里面，我们可以找到 Go 程的结构定义type g struct。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;时间上，协程调度也会有 CPU 开销。我们可以利用runntime.Gosched()让当前协程主动让出 CPU 去执行另外一个协程，下面看一下协程之间切换的耗时。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; NUM = &lt;span&gt;10000&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;cal&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; NUM; i++ {&lt;br/&gt;  runtime.Gosched()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// 只设置一个 Processor&lt;/span&gt;&lt;br/&gt; runtime.GOMAXPROCS(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt; start := time.Now().UnixNano()&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; cal()&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; NUM; i++ {&lt;br/&gt;  runtime.Gosched()&lt;br/&gt; }&lt;br/&gt; end := time.Now().UnixNano()&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;total %vns per %vns&quot;&lt;/span&gt;, end-start, (end-start)/NUM)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;total 997200ns per 99ns&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可见一次协程的切换，耗时大概在 100ns，相对于线程的微秒级耗时切换，性能表现非常优秀，但是仍有开销。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;GC 开销
创建 Go 程到运行结束，占用的内存资源是需要由 GC 来回收，如果无休止地创建大量 Go 程后，势必会造成对 GC 的压力。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;runtime&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;runtime/debug&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;sync&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;createLargeNumGoroutine&lt;/span&gt;&lt;span&gt;(num &lt;span&gt;int&lt;/span&gt;, wg *sync.WaitGroup)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; wg.Add(num)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; num; i++ {&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;  }()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// 只设置一个 Processor 保证 Go 程串行执行&lt;/span&gt;&lt;br/&gt; runtime.GOMAXPROCS(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;// 关闭GC改为手动执行&lt;/span&gt;&lt;br/&gt; debug.SetGCPercent(&lt;span&gt;-1&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; wg sync.WaitGroup&lt;br/&gt; createLargeNumGoroutine(&lt;span&gt;1000&lt;/span&gt;, &amp;amp;wg)&lt;br/&gt; wg.Wait()&lt;br/&gt; t := time.Now()&lt;br/&gt; runtime.GC() &lt;span&gt;// 手动GC&lt;/span&gt;&lt;br/&gt; cost := time.Since(t)&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;GC cost %v when goroutine num is %v\n&quot;&lt;/span&gt;, cost, &lt;span&gt;1000&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; createLargeNumGoroutine(&lt;span&gt;10000&lt;/span&gt;, &amp;amp;wg)&lt;br/&gt; wg.Wait()&lt;br/&gt; t = time.Now()&lt;br/&gt; runtime.GC() &lt;span&gt;// 手动GC&lt;/span&gt;&lt;br/&gt; cost = time.Since(t)&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;GC cost %v when goroutine num is %v\n&quot;&lt;/span&gt;, cost, &lt;span&gt;10000&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; createLargeNumGoroutine(&lt;span&gt;100000&lt;/span&gt;, &amp;amp;wg)&lt;br/&gt; wg.Wait()&lt;br/&gt; t = time.Now()&lt;br/&gt; runtime.GC() &lt;span&gt;// 手动GC&lt;/span&gt;&lt;br/&gt; cost = time.Since(t)&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;GC cost %v when goroutine num is %v\n&quot;&lt;/span&gt;, cost, &lt;span&gt;100000&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GC cost 0s when goroutine num is 1000&lt;br/&gt;GC cost 2.0027ms when goroutine num is 10000&lt;br/&gt;GC cost 30.9523ms when goroutine num is 100000&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当创建的 Go 程数量越多，GC 耗时越大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的分析目的是为了尽可能地量化 Goroutine 的开销。虽然官方宣称用 Golang 写并发程序的时候随便起个成千上万的 Goroutine 毫无压力，但当我们起十万、百万甚至千万个 Goroutine 呢？Goroutine 轻量的开销将被放大。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 限制协程数量&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;系统地资源是有限，协程是有代价的，为了保护程序，提高性能，我们应主动限制并发的协程数量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以利用信道 channel 的缓冲区大小来实现。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; wg sync.WaitGroup&lt;br/&gt; ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{}, &lt;span&gt;3&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt;  ch &amp;lt;- &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt;  wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(i &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;   log.Println(i)&lt;br/&gt;   time.Sleep(time.Second)&lt;br/&gt;   &amp;lt;-ch&lt;br/&gt;  }(i)&lt;br/&gt; }&lt;br/&gt; wg.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上例中创建了缓冲区大小为 3 的 channel，在没有被接收的情况下，至多发送 3 个消息则被阻塞。开启协程前，调用&lt;code&gt;ch &amp;lt;- struct{}{}&lt;/code&gt;，若缓存区满，则阻塞。协程任务结束，调用 &amp;lt;-ch 释放缓冲区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.WaitGroup 并不是必须的，例如 Http 服务，每个请求天然是并发的，此时使用 channel 控制并发处理的任务数量，就不需要 sync.WaitGroup。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;2022/03/06 20:37:02 0&lt;br/&gt;2022/03/06 20:37:02 2&lt;br/&gt;2022/03/06 20:37:02 1&lt;br/&gt;2022/03/06 20:37:03 3&lt;br/&gt;2022/03/06 20:37:03 4&lt;br/&gt;2022/03/06 20:37:03 5&lt;br/&gt;2022/03/06 20:37:04 6&lt;br/&gt;2022/03/06 20:37:04 7&lt;br/&gt;2022/03/06 20:37:04 8&lt;br/&gt;2022/03/06 20:37:05 9&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从日志中可以很容易看到，每秒钟只并发执行了 3 个任务，达到了协程并发控制的目的。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3 协程池化&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的例子只是简单地限制了协程开辟的数量。在此基础之上，基于对象复用的思想，我们可以重复利用已开辟的协程，避免协程的重复创建销毁，达到池化的效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;协程池化，我们可以自己写一个协程池，但不推荐这么做。因为已经有成熟的开源库可供使用，无需再重复造轮子。目前有很多第三方库实现了协程池，可以很方便地用来控制协程的并发数量，比较受欢迎的有：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面以 panjf2000/ants 为例，简单介绍其使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ants 是一个简单易用的高性能 Goroutine 池，实现了对大规模 Goroutine 的调度管理和复用，允许使用者在开发并发程序的时候限制 Goroutine 数量，复用协程，达到更高效执行任务的效果。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/panjf2000/ants&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// Use the common pool&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt;  i := i&lt;br/&gt;  ants.Submit(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   fmt.Println(i)&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt; time.Sleep(time.Second)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 ants，我们简单地使用其默认的协程池，直接将任务提交并发执行。默认协程池的缺省容量 math.MaxInt32。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果自定义协程池容量大小，可以调用 NewPool 方法来实例化具有给定容量的池，如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Set 10000 the size of goroutine pool&lt;/span&gt;&lt;br/&gt;p, _ := ants.NewPool(&lt;span&gt;10000&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4 小结&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Golang 为并发而生。Goroutine 是由 Go 运行时管理的轻量级线程，通过它我们可以轻松实现并发编程。Go 虽然轻量，但天下没有免费的午餐，无休止地开辟大量 Go 程势必会带来性能影响，甚至程序崩溃。所以，我们应尽可能的控制协程数量，如果有需要，请复用它。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.使用 sync.Once 避免重复执行&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 简介&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Once 是 Go 标准库提供的使函数只执行一次的实现，常应用于单例模式，例如初始化配置、保持数据库连接等。作用与 init 函数类似，但有区别。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;init 函数是当所在的 package 首次被加载时执行，若迟迟未被使用，则既浪费了内存，又延长了程序加载时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sync.Once 可以在代码的任意位置初始化和调用，因此可以延迟到使用时再执行，并发场景下是线程安全的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在多数情况下，sync.Once 被用于控制变量的初始化，这个变量的读写满足如下三个条件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当且仅当第一次访问某个变量时，进行初始化（写）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;变量初始化过程中，所有读都被阻塞，直到初始化完成；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;变量仅初始化一次，初始化完成后驻留在内存里。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 原理&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Once 用来保证函数只执行一次。要达到这个效果，需要做到两点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;计数器，统计函数执行次数；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程安全，保障在多 Go 程的情况下，函数仍然只执行一次，比如锁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2.1 源码&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面看一下 sync.Once 结构，其有两个变量。使用 done 统计函数执行次数，使用锁 m 实现线程安全。果不其然，和上面的猜想一致。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Once is an object that will perform exactly one action.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// A Once must not be copied after first use.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Once &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// done indicates whether the action has been performed.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// It is first in the struct because it is used in the hot path.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// The hot path is inlined at every call site.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// Placing done first allows more compact instructions on some architectures (amd64/386),&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// and fewer instructions (to calculate offset) on other architectures.&lt;/span&gt;&lt;br/&gt; done &lt;span&gt;uint32&lt;/span&gt;&lt;br/&gt; m    Mutex&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Once 仅提供了一个导出方法 Do()，参数 f 是只会被执行一次的函数，一般为对象初始化函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// go version go1.17 darwin/amd64&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Do calls the function f if and only if Do is being called for the&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// first time for this instance of Once. In other words, given&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//  var once Once&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// if once.Do(f) is called multiple times, only the first call will invoke f,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// even if f has a different value in each invocation. A new instance of&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Once is required for each function to execute.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Do is intended for initialization that must be run exactly once. Since f&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// is niladic, it may be necessary to use a function literal to capture the&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// arguments to a function to be invoked by Do:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//  config.once.Do(func() { config.init(filename) })&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Because no call to Do returns until the one call to f returns, if f causes&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Do to be called, it will deadlock.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// If f panics, Do considers it to have returned; future calls of Do return&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// without calling f.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(o *Once)&lt;/span&gt; &lt;span&gt;Do&lt;/span&gt;&lt;span&gt;(f &lt;span&gt;func&lt;/span&gt;()&lt;/span&gt;)&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// Note: Here is an incorrect implementation of Do:&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// if atomic.CompareAndSwapUint32(&amp;amp;o.done, 0, 1) {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//  f()&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// }&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// Do guarantees that when it returns, f has finished.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// This implementation would not implement that guarantee:&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// given two simultaneous calls, the winner of the cas would&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// call f, and the second would return immediately, without&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// waiting for the first&#x27;s call to f to complete.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// This is why the slow path falls back to a mutex, and why&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// the atomic.StoreUint32 must be delayed until after f returns.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; atomic.LoadUint32(&amp;amp;o.done) == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// Outlined slow-path to allow inlining of the fast-path.&lt;/span&gt;&lt;br/&gt;  o.doSlow(f)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(o *Once)&lt;/span&gt; &lt;span&gt;doSlow&lt;/span&gt;&lt;span&gt;(f &lt;span&gt;func&lt;/span&gt;()&lt;/span&gt;)&lt;/span&gt; {&lt;br/&gt; o.m.Lock()&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; o.m.Unlock()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; o.done == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;defer&lt;/span&gt; atomic.StoreUint32(&amp;amp;o.done, &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  f()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;抛去大段的注释，可以看到 sync.Once 实现非常简洁。Do() 函数中，通过对成员变量 done 的判断，来决定是否执行传入的任务函数。执行任务函数前，通过锁保证任务函数的执行和 done 的修改是一个互斥操作。在执行任务函数前，对 done 做一个二次判断，来保证任务函数只会被执行一次，done 只会被修改一次。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2.2  done 为什么是第一个字段&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从字段 done 前有一段注释，说明了done 为什么是第一个字段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;done 在热路径中，done 放在第一个字段，能够减少 CPU 指令，也就是说，这样做能够提升性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;热路径（hot path）是程序非常频繁执行的一系列指令，sync.Once 绝大部分场景都会访问 o.done，在热路径上是比较好理解的。如果 hot path 编译后的机器码指令更少，更直接，必然是能够提升性能的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么放在第一个字段就能够减少指令呢？因为结构体第一个字段的地址和结构体的指针是相同的，如果是第一个字段，直接对结构体的指针解引用即可。如果是其他的字段，除了结构体指针外，还需要计算与第一个值的偏移（calculate offset）。在机器码中，偏移量是随指令传递的附加值，CPU 需要做一次偏移值与指针的加法运算，才能获取要访问的值的地址。因为，访问第一个字段的机器代码更紧凑，速度更快。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;参考 &lt;a href=&quot;https://stackoverflow.com/questions/59174176/what-does-hot-path-mean-in-the-context-of-sync-once&quot; data-linktype=&quot;2&quot;&gt;What does “hot path” mean in the context of sync.Once? - StackOverflow&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3 性能差异&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以一个简单示例，来说明使用 sync.Once 保证函数只会被执行一次和多次执行，二者的性能差异。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考虑一个简单的场景，函数 ReadConfig 需要读取环境变量，并转换为对应的配置。环境变量在程序执行前已经确定，执行过程中不会发生改变。ReadConfig 可能会被多个协程并发调用，为了提升性能（减少执行时间和内存占用），使用 sync.Once 是一个比较好的方式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Config &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; GoRoot &lt;span&gt;string&lt;/span&gt;&lt;br/&gt; GoPath &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; (&lt;br/&gt; once   sync.Once&lt;br/&gt; config *Config&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ReadConfigWithOnce&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; *&lt;span&gt;Config&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; once.Do(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  config = &amp;amp;Config{&lt;br/&gt;   GoRoot: os.Getenv(&lt;span&gt;&quot;GOROOT&quot;&lt;/span&gt;),&lt;br/&gt;   GoPath: os.Getenv(&lt;span&gt;&quot;GOPATH&quot;&lt;/span&gt;),&lt;br/&gt;  }&lt;br/&gt; })&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; config&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ReadConfig&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; *&lt;span&gt;Config&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &amp;amp;Config{&lt;br/&gt;  GoRoot: os.Getenv(&lt;span&gt;&quot;GOROOT&quot;&lt;/span&gt;),&lt;br/&gt;  GoPath: os.Getenv(&lt;span&gt;&quot;GOPATH&quot;&lt;/span&gt;),&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看下二者的性能差异。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkReadConfigWithOnce&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = ReadConfigWithOnce()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkReadConfig&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = ReadConfig()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行测试结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=. main/once&lt;br/&gt;goos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/once&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz&lt;br/&gt;BenchmarkReadConfigWithOnce-12          670438965                1.732 ns/op&lt;br/&gt;BenchmarkReadConfig-12                  13339154                87.46 ns/op&lt;br/&gt;PASS&lt;br/&gt;ok      main/once       3.006s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Once 中保证了 Config 初始化函数仅执行了一次，避免了多次重复初始化，在并发环境下很有用。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.使用 sync.Cond 通知协程&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1 简介&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Cond 是基于互斥锁/读写锁实现的条件变量，用来协调想要访问共享资源的那些 Goroutine，当共享资源的状态发生变化的时候，sync.Cond 可以用来通知等待条件发生而阻塞的 Goroutine。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Cond 基于互斥锁/读写锁，它和互斥锁的区别是什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;互斥锁 sync.Mutex 通常用来保护共享的临界资源，条件变量 sync.Cond 用来协调想要访问共享资源的 Goroutine。当共享资源的状态发生变化时，sync.Cond 可以用来通知被阻塞的 Goroutine。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2 使用场景&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Cond 经常用在多个 Goroutine 等待，一个 Goroutine 通知（事件发生）的场景。如果是一个通知，一个等待，使用互斥锁或 channel 就能搞定了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们想象一个非常简单的场景：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一个协程在异步地接收数据，剩下的多个协程必须等待这个协程接收完数据，才能读取到正确的数据。在这种情况下，如果单纯使用 chan 或互斥锁，那么只能有一个协程可以等待，并读取到数据，没办法通知其他的协程也读取数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候，就需要有个全局的变量来标志第一个协程数据是否接受完毕，剩下的协程，反复检查该变量的值，直到满足要求。或者创建多个 channel，每个协程阻塞在一个 channel 上，由接收数据的协程在数据接收完毕后，逐个通知。总之，需要额外的复杂度来完成这件事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言在标准库 sync 中内置一个 sync.Cond 用来解决这类问题。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.3 原理&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Cond 内部维护了一个等待队列，队列中存放的是所有在等待这个 sync.Cond 的 Go 程，即保存了一个通知列表。sync.Cond 可以用来唤醒一个或所有因等待条件变量而阻塞的 Go 程，以此来实现多个 Go 程间的同步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Cond 的定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Cond implements a condition variable, a rendezvous point&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// for goroutines waiting for or announcing the occurrence&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// of an event.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Each Cond has an associated Locker L (often a *Mutex or *RWMutex),&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// which must be held when changing the condition and&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// when calling the Wait method.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// A Cond must not be copied after first use.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Cond &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; noCopy noCopy&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// L is held while observing or changing the condition&lt;/span&gt;&lt;br/&gt; L Locker&lt;br/&gt;&lt;br/&gt; notify  notifyList&lt;br/&gt; checker copyChecker&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个 Cond 实例都会关联一个锁 L（互斥锁 *Mutex，或读写锁 *RWMutex），当修改条件或者调用 Wait 方法时，必须加锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Cond 的四个成员函数定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// NewCond returns a new Cond with Locker l.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewCond&lt;/span&gt;&lt;span&gt;(l Locker)&lt;/span&gt; *&lt;span&gt;Cond&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &amp;amp;Cond{L: l}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NewCond 创建 Cond 实例时，需要关联一个锁。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Wait atomically unlocks c.L and suspends execution&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// of the calling goroutine. After later resuming execution,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Wait locks c.L before returning. Unlike in other systems,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Wait cannot return unless awoken by Broadcast or Signal.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Because c.L is not locked when Wait first resumes, the caller&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// typically cannot assume that the condition is true when&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Wait returns. Instead, the caller should Wait in a loop:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//    c.L.Lock()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//    for !condition() {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//        c.Wait()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//    ... make use of condition ...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//    c.L.Unlock()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Cond)&lt;/span&gt; &lt;span&gt;Wait&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; c.checker.check()&lt;br/&gt; t := runtime_notifyListAdd(&amp;amp;c.notify)&lt;br/&gt; c.L.Unlock()&lt;br/&gt; runtime_notifyListWait(&amp;amp;c.notify, t)&lt;br/&gt; c.L.Lock()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Wait 用于阻塞调用者，等待通知。调用 Wait 会自动释放锁 c.L，并挂起调用者所在的 goroutine。如果其他协程调用了 Signal 或 Broadcast 唤醒了该协程，那么 Wait 方法在结束阻塞时，会重新给 c.L 加锁，并且继续执行 Wait 后面的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对条件的检查，使用了 for !condition() 而非 if，是因为当前协程被唤醒时，条件不一定符合要求，需要再次 Wait 等待下次被唤醒。为了保险起，使用 for 能够确保条件符合要求后，再执行后续的代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Signal wakes one goroutine waiting on c, if there is any.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// It is allowed but not required for the caller to hold c.L&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// during the call.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Cond)&lt;/span&gt; &lt;span&gt;Signal&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; c.checker.check()&lt;br/&gt; runtime_notifyListNotifyOne(&amp;amp;c.notify)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Broadcast wakes all goroutines waiting on c.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// It is allowed but not required for the caller to hold c.L&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// during the call.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Cond)&lt;/span&gt; &lt;span&gt;Broadcast&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; c.checker.check()&lt;br/&gt; runtime_notifyListNotifyAll(&amp;amp;c.notify)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Signal 只唤醒任意 1 个等待条件变量 c 的 goroutine，无需锁保护。Broadcast 唤醒所有等待条件变量 c 的 goroutine，无需锁保护。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4 使用示例&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们实现一个简单的例子，三个协程调用 Wait() 等待，另一个协程调用 Broadcast() 唤醒所有等待的协程。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; done = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;&lt;span&gt;(name &lt;span&gt;string&lt;/span&gt;, c *sync.Cond)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; c.L.Lock()&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; !done {&lt;br/&gt;  c.Wait()&lt;br/&gt; }&lt;br/&gt; log.Println(name, &lt;span&gt;&quot;starts reading&quot;&lt;/span&gt;)&lt;br/&gt; c.L.Unlock()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;(name &lt;span&gt;string&lt;/span&gt;, c *sync.Cond)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; log.Println(name, &lt;span&gt;&quot;starts writing&quot;&lt;/span&gt;)&lt;br/&gt; time.Sleep(time.Second)&lt;br/&gt; done = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; log.Println(name, &lt;span&gt;&quot;wakes all&quot;&lt;/span&gt;)&lt;br/&gt; c.Broadcast()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; cond := sync.NewCond(&amp;amp;sync.Mutex{})&lt;br/&gt;&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; read(&lt;span&gt;&quot;reader1&quot;&lt;/span&gt;, cond)&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; read(&lt;span&gt;&quot;reader2&quot;&lt;/span&gt;, cond)&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; read(&lt;span&gt;&quot;reader3&quot;&lt;/span&gt;, cond)&lt;br/&gt; write(&lt;span&gt;&quot;writer&quot;&lt;/span&gt;, cond)&lt;br/&gt;&lt;br/&gt; time.Sleep(time.Second * &lt;span&gt;3&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;done 即多个 Goroutine 阻塞等待的条件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;read() 调用 Wait() 等待通知，直到 done 为 true。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;write() 接收数据，接收完成后，将 done 置为 true，调用 Broadcast() 通知所有等待的协程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;write() 中的暂停了 1s，一方面是模拟耗时，另一方面是确保前面的 3 个 read 协程都执行到 Wait()，处于等待状态。main 函数最后暂停了 3s，确保所有操作执行完毕。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go run main.go&lt;br/&gt;2022/03/07 17:20:09 writer starts writing&lt;br/&gt;2022/03/07 17:20:10 writer wakes all&lt;br/&gt;2022/03/07 17:20:10 reader3 starts reading&lt;br/&gt;2022/03/07 17:20:10 reader1 starts reading&lt;br/&gt;2022/03/07 17:20:10 reader2 starts reading&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多关于 sync.Cond 的讨论可参考 &lt;a href=&quot;https://stackoverflow.com/questions/36857167/how-to-correctly-use-sync-cond&quot; data-linktype=&quot;2&quot;&gt;How to correctly use sync.Cond? - StackOverflow&lt;/a&gt;。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.5 注意事项&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Cond 不能被复制的原因，并不是因为其内部嵌套了 Locker。因为 NewCond 时传入的 Mutex/RWMutex 指针，对于 Mutex 指针复制是没有问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要原因是 sync.Cond 内部是维护着一个 Goroutine 通知队列 notifyList。如果这个队列被复制的话，那么就在并发场景下导致不同 Goroutine 之间操作的 notifyList.wait、notifyList.notify 并不是同一个，这会导致出现有些 Goroutine 会一直阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从等待队列中按照顺序唤醒，先进入等待队列，先被唤醒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用 Wait() 函数前，需要先获得条件变量的成员锁，原因是需要互斥地变更条件变量的等待队列。在 Wait() 返回前，会重新上锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考文献&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;最近好文：&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649768568&amp;amp;idx=1&amp;amp;sn=68dc084a79407a41762f8705b28e1257&amp;amp;chksm=beccd10389bb5815ae094ed7423a32f421fd143d724cbf0330efaeaf0382e683e575e6350f30&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;在鹅厂工作1到11年的程序媛&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;在鹅厂工作1到11年的程序媛&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649769049&amp;amp;idx=1&amp;amp;sn=b8ac0e6409b073758fa0bbcde1acd952&amp;amp;chksm=beccd72289bb5e34bacb76669650d8ebb70563fb35b381f452f20c62b86968f2efbeb98d8337&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;技术她力量，鹅厂女博士的寻“豹”之旅&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;技术她力量，鹅厂女博士的寻“豹”之旅&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649769274&amp;amp;idx=1&amp;amp;sn=a46fc1574ecbf5cfddd1f40af9cb1b4f&amp;amp;chksm=beccd64189bb5f57f80799fd2ea51c7669942254a2223dea55fe7d2bfa5762410a784dec8e2f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;微信全文搜索技术优化&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;微信全文搜索技术优化&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAgDAS3gDsiAAAAAstQy6ubaLX4KHWvLEZgBPE8KIMcXtxZL38zNPgMIvt27oRctxLQngBmm2RSmIU&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7YmwgiahniaXswqz4S6B63dgPBSkQM1Pibkk08bsnRVMG0MKAZ26U5ESqSNFtReXFxmYaalxffR57exzXKicibmO91qDTVFBh9zBPSEAA&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdWOPjH6MHTJcta8qxWU2YJYIzYZjHP3n6pJIp2mTCHqh9rqZQPUvWCEgUCyBuJ4114&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;我的程序媛同事们，节日快乐~&amp;#10;&amp;#10;#不被定义的她 #程序媛 #女性 &amp;#10;&quot; data-nonceid=&quot;6143725764114518706&quot; data-type=&quot;video&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5ODYwMjI2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasvpPfMrktl2xvC9A325p8Qa9dFeEzxZmZ2O1XuFGsVXyQhG9Dia8J8nTXVtzNcHozr0umH3R4iboXg/0?wx_fmt=png&quot; data-nickname=&quot;腾讯技术工程&quot; data-alias=&quot;Tencent_TEG&quot; data-signature=&quot;腾讯技术官方号。腾讯技术创新、前沿领域发布解读平台。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>