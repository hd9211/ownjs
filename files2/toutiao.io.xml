<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ec20dfe09d10feb86b90018891a151fc</guid>
<title>Spring 中定义 bean 的 12 种方法，真的绝了</title>
<link>https://toutiao.io/k/88jw8t4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxODkzNTQ3Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uL371281oDHlDcdbjNJic1yCwAu2dmJ9AunIQh9DXdm5JE7v9libnPgJQicoaGs9Eiaee2kPeFGWJxsPkZ9zCQbrIw/0?wx_fmt=png&quot; data-nickname=&quot;苏三说技术&quot; data-alias=&quot;susanSayJava&quot; data-signature=&quot;作者就职于知名互联网公司，掘金月度优秀作者，从事开发、架构和部分管理工作。实战经验丰富，对jdk、spring、springboot、springcloud、mybatis等开源框架源码有一定研究，欢迎关注，和我一起交流。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在庞大的java体系中，spring有着举足轻重的地位，它给每位开发者带来了极大的便利和惊喜。我们都知道spring是创建和管理bean的工厂，它提供了多种定义bean的方式，能够满足我们日常工作中的多种业务场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了，你知道spring中有哪些方式可以定义bean？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我估计很多人会说出以下三种：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2583547557840617&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF3eclmVcRAt9Ribqd3SaGhhv86vee0KJibhgC7lR05RKSuX7t9VLFNIGvLuqBWHdABjmDMrsxkCezQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1556&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，但我想说的是以上三种方式只是开胃小菜，实际上spring的功能远比你想象中更强大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;各位看官如果不信，请继续往下看。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. xml文件配置bean&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先从&lt;code&gt;xml配置bean&lt;/code&gt;开始，它是spring最早支持的方式。后来，随着&lt;code&gt;springboot&lt;/code&gt;越来越受欢迎，该方法目前已经用得很少了，但我建议我们还是有必要了解一下。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.1 构造器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你之前有在bean.xml文件中配置过bean的经历，那么对如下的配置肯定不会陌生：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;bean id=&lt;span&gt;&quot;personService&quot;&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;&quot;com.sue.cache.service.test7.PersonService&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;&amp;lt;/bean&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式是以前使用最多的方式，它默认使用了无参构造器创建bean。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然我们还可以使用有参的构造器，通过&lt;code&gt;&amp;lt;constructor-arg&amp;gt;&lt;/code&gt;标签来完成配置。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;bean id=&lt;span&gt;&quot;personService&quot;&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;&quot;com.sue.cache.service.test7.PersonService&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;   &amp;lt;constructor-arg index=&lt;span&gt;&quot;0&quot;&lt;/span&gt; value=&lt;span&gt;&quot;susan&quot;&lt;/span&gt;&amp;gt;&amp;lt;/constructor-arg&amp;gt;&lt;br/&gt;   &amp;lt;constructor-arg index=&lt;span&gt;&quot;1&quot;&lt;/span&gt; ref=&lt;span&gt;&quot;baseInfo&quot;&lt;/span&gt;&amp;gt;&amp;lt;/constructor-arg&amp;gt;&lt;br/&gt;&amp;lt;/bean&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;index&lt;/code&gt;表示下标，从0开始。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;value&lt;/code&gt;表示常量值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ref&lt;/code&gt;表示引用另一个bean&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.2 setter方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，spring还提供了另外一种思路：通过setter方法设置bean所需参数，这种方式耦合性相对较低，比有参构造器使用更为广泛。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先定义Person实体：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Person&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; age;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它里面包含：成员变量name和age，getter/setter方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在bean.xml文件中配置bean时，加上&lt;code&gt;&amp;lt;property&amp;gt;&lt;/code&gt;标签设置bean所需参数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;bean id=&lt;span&gt;&quot;person&quot;&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;&quot;com.sue.cache.service.test7.Person&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;   &amp;lt;property name=&lt;span&gt;&quot;name&quot;&lt;/span&gt; value=&lt;span&gt;&quot;susan&quot;&lt;/span&gt;&amp;gt;&amp;lt;/constructor-arg&amp;gt;&lt;br/&gt;   &amp;lt;property name=&lt;span&gt;&quot;age&quot;&lt;/span&gt; value=&lt;span&gt;&quot;18&quot;&lt;/span&gt;&amp;gt;&amp;lt;/constructor-arg&amp;gt;&lt;br/&gt;&amp;lt;/bean&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.3 静态工厂&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式的关键是需要定义一个工厂类，它里面包含一个创建bean的静态方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SusanBeanFactory&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Person &lt;span&gt;createPerson&lt;/span&gt;&lt;span&gt;(String name, &lt;span&gt;int&lt;/span&gt; age)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Person(name, age);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来定义Person类如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@AllArgsConstructor&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@NoArgsConstructor&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Person&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; age;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它里面包含：成员变量name和age，getter/setter方法，无参构造器和全参构造器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在bean.xml文件中配置bean时，通过&lt;code&gt;factory-method&lt;/code&gt;参数指定静态工厂方法，同时通过&lt;code&gt;&amp;lt;constructor-arg&amp;gt;&lt;/code&gt;设置相关参数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;bean &lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;&quot;com.sue.cache.service.test7.SusanBeanFactory&quot;&lt;/span&gt; factory-method=&lt;span&gt;&quot;createPerson&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;   &amp;lt;constructor-arg index=&lt;span&gt;&quot;0&quot;&lt;/span&gt; value=&lt;span&gt;&quot;susan&quot;&lt;/span&gt;&amp;gt;&amp;lt;/constructor-arg&amp;gt;&lt;br/&gt;   &amp;lt;constructor-arg index=&lt;span&gt;&quot;1&quot;&lt;/span&gt; value=&lt;span&gt;&quot;18&quot;&lt;/span&gt;&amp;gt;&amp;lt;/constructor-arg&amp;gt;&lt;br/&gt;&amp;lt;/bean&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.4 实例工厂方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式也需要定义一个工厂类，但里面包含非静态的创建bean的方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SusanBeanFactory&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Person &lt;span&gt;createPerson&lt;/span&gt;&lt;span&gt;(String name, &lt;span&gt;int&lt;/span&gt; age)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Person(name, age);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Person类跟上面一样，就不多说了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后bean.xml文件中配置bean时，需要先配置工厂bean。然后在配置实例bean时，通过&lt;code&gt;factory-bean&lt;/code&gt;参数指定该工厂bean的引用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;bean id=&lt;span&gt;&quot;susanBeanFactory&quot;&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;&quot;com.sue.cache.service.test7.SusanBeanFactory&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;&amp;lt;/bean&amp;gt;&lt;br/&gt;&amp;lt;bean factory-bean=&lt;span&gt;&quot;susanBeanFactory&quot;&lt;/span&gt; factory-method=&lt;span&gt;&quot;createPerson&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;   &amp;lt;constructor-arg index=&lt;span&gt;&quot;0&quot;&lt;/span&gt; value=&lt;span&gt;&quot;susan&quot;&lt;/span&gt;&amp;gt;&amp;lt;/constructor-arg&amp;gt;&lt;br/&gt;   &amp;lt;constructor-arg index=&lt;span&gt;&quot;1&quot;&lt;/span&gt; value=&lt;span&gt;&quot;18&quot;&lt;/span&gt;&amp;gt;&amp;lt;/constructor-arg&amp;gt;&lt;br/&gt;&amp;lt;/bean&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.5 FactoryBean&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道大家有没有发现，上面的实例工厂方法每次都需要创建一个工厂类，不方面统一管理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时我们可以使用&lt;code&gt;FactoryBean&lt;/code&gt;接口。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserFactoryBean&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;FactoryBean&lt;/span&gt;&amp;lt;&lt;span&gt;User&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; User &lt;span&gt;getObject&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; Class&amp;lt;?&amp;gt; getObjectType() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在它的&lt;code&gt;getObject&lt;/code&gt;方法中可以实现我们自己的逻辑创建对象，并且在&lt;code&gt;getObjectType&lt;/code&gt;方法中我们可以定义对象的类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在bean.xml文件中配置bean时，只需像普通的bean一样配置即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;bean id=&lt;span&gt;&quot;userFactoryBean&quot;&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;&quot;com.sue.async.service.UserFactoryBean&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;&amp;lt;/bean&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;轻松搞定，so easy。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：getBean(&quot;userFactoryBean&quot;);获取的是getObject方法中返回的对象。而getBean(&quot;&amp;amp;userFactoryBean&quot;);获取的才是真正的UserFactoryBean对象。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过上面五种方式，在bean.xml文件中把bean配置好之后，spring就会自动扫描和解析相应的标签，并且帮我们创建和实例化bean，然后放入spring容器中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽说基于xml文件的方式配置bean，简单而且非常灵活，比较适合一些小项目。但如果遇到比较复杂的项目，则需要配置大量的bean，而且bean之间的关系错综复杂，这样久而久之会导致xml文件迅速膨胀，非常不利于bean的管理。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. Component注解&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决bean太多时，xml文件过大，从而导致膨胀不好维护的问题。在spring2.5中开始支持：&lt;code&gt;@Component&lt;/code&gt;、&lt;code&gt;@Repository&lt;/code&gt;、&lt;code&gt;@Service&lt;/code&gt;、&lt;code&gt;@Controller&lt;/code&gt;等注解定义bean。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你有看过这些注解的源码的话，就会惊奇得发现：其实后三种注解也是&lt;code&gt;@Component&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.485&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF3eclmVcRAt9Ribqd3SaGhhTHXro0Ea7SvvYM85mPiaUOasZaHV6Fm0Zgv0iaHXp0sPEVvpsUDukeicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot;/&gt;&lt;img data-ratio=&quot;0.47017543859649125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF3eclmVcRAt9Ribqd3SaGhhmAhpibMAtVAbj5N880cFQL691Cto4kDk6Gxkh9lqCv88rRmXBkwuibIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1140&quot;/&gt;&lt;img data-ratio=&quot;0.49222797927461137&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF3eclmVcRAt9Ribqd3SaGhh8GcvFgMWKzTELdclr5xbn6Ym5GuRWkPeMqzJxuiaia6eicmD7novwpYyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1158&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;@Component&lt;/code&gt;系列注解的出现，给我们带来了极大的便利。我们不需要像以前那样在bean.xml文件中配置bean了，现在只用在类上加Component、Repository、Service、Controller，这四种注解中的任意一种，就能轻松完成bean的定义。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PersonService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;data&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，这四种注解在功能上没有特别的区别，不过在业界有个不成文的约定：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Controller 一般用在控制层&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Service 一般用在业务层&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Repository 一般用在数据层&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Component 一般用在公共组件上&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;太棒了，简直一下子解放了我们的双手。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，需要特别注意的是，通过这种&lt;code&gt;@Component&lt;/code&gt;扫描注解的方式定义bean的前提是：&lt;strong&gt;需要先配置扫描路径&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前常用的配置扫描路径的方式如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在applicationContext.xml文件中使用&lt;code&gt;&amp;lt;context:component-scan&amp;gt;&lt;/code&gt;标签。例如：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;context:component-scan base-&lt;span&gt;package&lt;/span&gt;=&lt;span&gt;&quot;com.sue.cache&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在springboot的启动类上加上&lt;code&gt;@ComponentScan&lt;/code&gt;注解，例如：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@ComponentScan&lt;/span&gt;(basePackages = &lt;span&gt;&quot;com.sue.cache&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@SpringBootApplication&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Application&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; SpringApplicationBuilder(Application&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;).&lt;span&gt;web&lt;/span&gt;(&lt;span&gt;WebApplicationType&lt;/span&gt;.&lt;span&gt;SERVLET&lt;/span&gt;).&lt;span&gt;run&lt;/span&gt;(&lt;span&gt;args&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;直接在&lt;code&gt;SpringBootApplication&lt;/code&gt;注解上加，它支持ComponentScan功能：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@SpringBootApplication&lt;/span&gt;(scanBasePackages = &lt;span&gt;&quot;com.sue.cache&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Application&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; SpringApplicationBuilder(Application&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;).&lt;span&gt;web&lt;/span&gt;(&lt;span&gt;WebApplicationType&lt;/span&gt;.&lt;span&gt;SERVLET&lt;/span&gt;).&lt;span&gt;run&lt;/span&gt;(&lt;span&gt;args&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，如果你需要扫描的类跟springboot的入口类，在同一级或者子级的包下面，无需指定&lt;code&gt;scanBasePackages&lt;/code&gt;参数，spring默认会从入口类的同一级或者子级的包去找。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@SpringBootApplication&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Application&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; SpringApplicationBuilder(Application&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;).&lt;span&gt;web&lt;/span&gt;(&lt;span&gt;WebApplicationType&lt;/span&gt;.&lt;span&gt;SERVLET&lt;/span&gt;).&lt;span&gt;run&lt;/span&gt;(&lt;span&gt;args&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，除了上述四种&lt;code&gt;@Component&lt;/code&gt;注解之外，springboot还增加了&lt;code&gt;@RestController&lt;/code&gt;注解，它是一种特殊的&lt;code&gt;@Controller&lt;/code&gt;注解，所以也是&lt;code&gt;@Component&lt;/code&gt;注解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;@RestController&lt;/code&gt;还支持&lt;code&gt;@ResponseBody&lt;/code&gt;注解的功能，即将接口响应数据的格式自动转换成json。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5528169014084507&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF3eclmVcRAt9Ribqd3SaGhhSPLSEcKkUoPbVicx7LHib7XmbKEib2hibSjHOsdKhWT9KDm8VmrffZ3DoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1136&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;@Component&lt;/code&gt;系列注解已经让我们爱不释手了，它目前是我们日常工作中最多的定义bean的方式。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. JavaConfig&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;@Component&lt;/code&gt;系列注解虽说使用起来非常方便，但是bean的创建过程完全交给spring容器来完成，我们没办法自己控制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring从3.0以后，开始支持JavaConfig的方式定义bean。它可以看做spring的配置文件，但并非真正的配置文件，我们需要通过编码java代码的方式创建bean。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Person &lt;span&gt;person&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Person();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JavaConfig类上加&lt;code&gt;@Configuration&lt;/code&gt;注解，相当于配置了&lt;code&gt;&amp;lt;beans&amp;gt;&lt;/code&gt;标签。而在方法上加&lt;code&gt;@Bean&lt;/code&gt;注解，相当于配置了&lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt;标签。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，springboot还引入了一些列的&lt;code&gt;@Conditional&lt;/code&gt;注解，用来控制bean的创建。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@ConditionalOnClass&lt;/span&gt;(Country&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;    @&lt;span&gt;Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;Person&lt;/span&gt; &lt;span&gt;person&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Person();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;@ConditionalOnClass&lt;/code&gt;注解的功能是当项目中存在Country类时，才实例化Person类。换句话说就是，如果项目中不存在Country类，就不实例化Person类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个功能非常有用，相当于一个开关控制着Person类，只有满足一定条件才能实例化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring中使用比较多的Conditional还有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ConditionalOnBean&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ConditionalOnProperty&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ConditionalOnMissingClass&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ConditionalOnMissingBean&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ConditionalOnWebApplication&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你对这些功能比较感兴趣，可以看看《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxODkzNTQ3Nw==&amp;amp;mid=2247485964&amp;amp;idx=1&amp;amp;sn=6b228b315461498aa3e2ac241341f72a&amp;amp;chksm=f9800cd6cef785c07022577cec282c3f990e35d80ee5cb07219681ed4db71cddabb9fcbeabd2&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;spring中那些让你爱不释手的代码技巧（续集）&lt;/a&gt;》，这是我之前写的一篇文章，里面做了更详细的介绍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面用一张图整体认识一下@Conditional家族:&lt;img data-ratio=&quot;1.169811320754717&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF3eclmVcRAt9Ribqd3SaGhhTILKC5GT32WNFUic7uiccXeSlWcy34bcw1ibfeeRW0ZXuTJVKwsRGCvSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;954&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nice，有了这些功能，我们终于可以告别麻烦的xml时代了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. Import注解&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过前面介绍的@Configuration和@Bean相结合的方式，我们可以通过代码定义bean。但这种方式有一定的局限性，它只能创建该类中定义的bean实例，不能创建其他类的bean实例，如果我们想创建其他类的bean实例该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时可以使用&lt;code&gt;@Import&lt;/code&gt;注解导入。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.1 普通类&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring4.2之后&lt;code&gt;@Import&lt;/code&gt;注解可以实例化普通类的bean实例。例如：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先定义了Role类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Role&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Long id;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来使用@Import注解导入Role类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Import&lt;/span&gt;(Role&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;@&lt;span&gt;Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在调用的地方通过&lt;code&gt;@Autowired&lt;/code&gt;注解注入所需的bean。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Role role;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/test&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(role);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;test&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;聪明的你可能会发现，我没有在任何地方定义过Role的bean，但spring却能自动创建该类的bean实例，这是为什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也许正是&lt;code&gt;@Import&lt;/code&gt;注解的强大之处。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，有些朋友可能会问：&lt;code&gt;@Import&lt;/code&gt;注解能定义单个类的bean，但如果有多个类需要定义bean该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;恭喜你，这是个好问题，因为&lt;code&gt;@Import&lt;/code&gt;注解也支持。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Import&lt;/span&gt;({Role&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;User&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;@&lt;span&gt;Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;甚至，如果你想偷懒，不想写这种&lt;code&gt;MyConfig&lt;/code&gt;类，springboot也欢迎。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Import({Role.class, User.class})&lt;br/&gt;@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class,&lt;br/&gt;        DataSourceTransactionManagerAutoConfiguration.class})&lt;br/&gt;public class Application {&lt;br/&gt;&lt;br/&gt;    public static void main(String[] args) {&lt;br/&gt;        new SpringApplicationBuilder(Application.class).web(WebApplicationType.SERVLET).run(args);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以将@Import加到springboot的启动类上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样也能生效？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;springboot的启动类一般都会加@SpringBootApplication注解，该注解上加了@SpringBootConfiguration注解。&lt;img data-ratio=&quot;0.7370753323485968&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF3eclmVcRAt9Ribqd3SaGhhwgJsdHziagaIlcXylY5WJ1h5FQU9IYialJsyH3SRia6KcXr7BjxruR1xA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1354&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而@SpringBootConfiguration注解，上面又加了@Configuration注解&lt;img data-ratio=&quot;0.4376899696048632&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF3eclmVcRAt9Ribqd3SaGhh2MiafibYzbFbIGcFoMCqiboLUBuemvaMiakEstakf5XgGHKBqkscE8tPNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;658&quot;/&gt;所以，springboot启动类本身带有@Configuration注解的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;意不意外？惊不惊喜？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.2 Configuration类&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面介绍了@Import注解导入普通类的方法，它同时也支持导入Configuration类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先定义一个Configuration类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyConfig2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; User &lt;span&gt;user&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Role &lt;span&gt;role&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Role();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在另外一个Configuration类中引入前面的Configuration类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Import&lt;/span&gt;({MyConfig2&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;@&lt;span&gt;Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式，如果MyConfig2类已经在spring指定的扫描目录或者子目录下，则MyConfig类会显得有点多余。因为MyConfig2类本身就是一个配置类，它里面就能定义bean。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果MyConfig2类不在指定的spring扫描目录或者子目录下，则通过MyConfig类的导入功能，也能把MyConfig2类识别成配置类。这就有点厉害了喔。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;其实下面还有更高端的玩法&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;swagger作为一个优秀的文档生成框架，在spring项目中越来越受欢迎。接下来，我们以swagger2为例，介绍一下它是如何导入相关类的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，我们引入swagger相关jar包之后，只需要在springboot的启动类上加上&lt;code&gt;@EnableSwagger2&lt;/code&gt;注解，就能开启swagger的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中@EnableSwagger2注解中导入了Swagger2DocumentationConfiguration类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2557651991614256&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF3eclmVcRAt9Ribqd3SaGhhAz5vXXTffj5N2LBN31fLK1uNHxWMia1sGWdNcPdXdwRZzrZ8XAGqtMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;954&quot;/&gt;该类是一个Configuration类，它又导入了另外两个类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;SpringfoxWebMvcConfiguration&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SwaggerCommonConfiguration&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5802098950524738&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF3eclmVcRAt9Ribqd3SaGhhnu9on6HGzoto4C6cLG0YJvgWs3vYkpkVObdEOocM1sibt5sOF7IBNpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1334&quot;/&gt;SpringfoxWebMvcConfiguration类又会导入新的Configuration类，并且通过@ComponentScan注解扫描了一些其他的路径。&lt;img data-ratio=&quot;0.8225806451612904&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF3eclmVcRAt9Ribqd3SaGhhPwxbiaR9pVhr64A1j6a6Hj7do1ibcOtvtAexH25TzHd2NciapWggszrNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SwaggerCommonConfiguration同样也通过@ComponentScan注解扫描了一些额外的路径。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46647230320699706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF3eclmVcRAt9Ribqd3SaGhhLKLJeE0AZsf7w26iaST1zpPotp3WphfYy9LWRR9QRx2Brbohzjc49eA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;686&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如此一来，我们通过一个简单的&lt;code&gt;@EnableSwagger2&lt;/code&gt;注解，就能轻松的导入swagger所需的一系列bean，并且拥有swagger的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有什么好说的，狂起点赞，简直完美。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.3 ImportSelector&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面提到的Configuration类，它的功能非常强大。但怎么说呢，它不太适合加复杂的判断条件，根据某些条件定义这些bean，根据另外的条件定义那些bean。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，这种需求该怎么实现呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时就可以使用&lt;code&gt;ImportSelector&lt;/code&gt;接口了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先定义一个类实现&lt;code&gt;ImportSelector&lt;/code&gt;接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DataImportSelector&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ImportSelector&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; String[] selectImports(AnnotationMetadata importingClassMetadata) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; String[]{&lt;span&gt;&quot;com.sue.async.service.User&quot;&lt;/span&gt;, &lt;span&gt;&quot;com.sue.async.service.Role&quot;&lt;/span&gt;};&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重写&lt;code&gt;selectImports&lt;/code&gt;方法，在该方法中指定需要定义bean的类名，注意要包含完整路径，而非相对路径。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在MyConfig类上@Import导入这个类即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Import&lt;/span&gt;({DataImportSelector&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;@&lt;span&gt;Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;朋友们是不是又发现了一个新大陆？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，这个注解还有更牛逼的用途。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;@EnableAutoConfiguration注解中导入了AutoConfigurationImportSelector类，并且里面包含系统参数名称：&lt;code&gt;spring.boot.enableautoconfiguration&lt;/code&gt;。&lt;img data-ratio=&quot;0.7138508371385084&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF3eclmVcRAt9Ribqd3SaGhhvqCpMJaEmG5FuXK0HoWy6jKzUllyoEvNaSXWEC7BWicoP3teavQWOJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1314&quot;/&gt;AutoConfigurationImportSelector类实现了&lt;code&gt;ImportSelector&lt;/code&gt;接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.21478260869565216&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF3eclmVcRAt9Ribqd3SaGhhA2nxyKfJTC3MB0ItHKO8Y18KX7RuMjoViafoF2klvLGMgtFSI6D0rmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2300&quot;/&gt;并且重写了&lt;code&gt;selectImports&lt;/code&gt;方法，该方法会根据某些注解去找所有需要创建bean的类名，然后返回这些类名。其中在查找这些类名之前，先调用isEnabled方法，判断是否需要继续查找。&lt;img data-ratio=&quot;0.5162287480680062&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF3eclmVcRAt9Ribqd3SaGhhfiaLHkkSePWVmUlVL1pF4obLDPUqQBQqUDyWpBvSwgJgy0UDWtfbZhg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1294&quot;/&gt;该方法会根据ENABLED_OVERRIDE_PROPERTY的值来作为判断条件。&lt;img data-ratio=&quot;0.27257799671592775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF3eclmVcRAt9Ribqd3SaGhhib8XibXCzAgqaTkJyVQkt5icdmqqBLI6Vic12aLDZOGjbM9muOuNZVgG9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1218&quot;/&gt;而这个值就是&lt;code&gt;spring.boot.enableautoconfiguration&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换句话说，这里能根据系统参数控制bean是否需要被实例化，优秀。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我个人认为实现ImportSelector接口的好处主要有以下两点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;把某个功能的相关类，可以放到一起，方面管理和维护。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重写selectImports方法时，能够根据条件判断某些类是否需要被实例化，或者某个条件实例化这些bean，其他的条件实例化那些bean等。我们能够非常灵活的定制化bean的实例化。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.4 ImportBeanDefinitionRegistrar&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过上面的这种方式，确实能够非常灵活的自定义bean。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但它的自定义能力，还是有限的，它没法自定义bean的名称和作用域等属性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有需求，就有解决方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们一起看看&lt;code&gt;ImportBeanDefinitionRegistrar&lt;/code&gt;接口的神奇之处。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先定义CustomImportSelector类实现ImportBeanDefinitionRegistrar接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CustomImportSelector&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ImportBeanDefinitionRegistrar&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;registerBeanDefinitions&lt;/span&gt;&lt;span&gt;(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        RootBeanDefinition roleBeanDefinition = &lt;span&gt;new&lt;/span&gt; RootBeanDefinition(Role&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        registry.registerBeanDefinition(&lt;span&gt;&quot;role&quot;&lt;/span&gt;, roleBeanDefinition);&lt;br/&gt;&lt;br/&gt;        RootBeanDefinition userBeanDefinition = &lt;span&gt;new&lt;/span&gt; RootBeanDefinition(User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        userBeanDefinition.setScope(ConfigurableBeanFactory.SCOPE_PROTOTYPE);&lt;br/&gt;        registry.registerBeanDefinition(&lt;span&gt;&quot;user&quot;&lt;/span&gt;, userBeanDefinition);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重写&lt;code&gt;registerBeanDefinitions&lt;/code&gt;方法，在该方法中我们可以获取&lt;code&gt;BeanDefinitionRegistry&lt;/code&gt;对象，通过它去注册bean。不过在注册bean之前，我们先要创建BeanDefinition对象，它里面可以自定义bean的名称、作用域等很多参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在MyConfig类上导入上面的类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Import&lt;/span&gt;({CustomImportSelector&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;@&lt;span&gt;Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们所熟悉的fegin功能，就是使用ImportBeanDefinitionRegistrar接口实现的：&lt;img data-ratio=&quot;0.5291828793774319&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF3eclmVcRAt9Ribqd3SaGhh4xGb6icoZcZicobzBKl4wibJB1D62XMMU7p3eY7JsxsRV9zdxAC4reu1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1542&quot;/&gt;具体细节就不多说了，有兴趣的朋友可以加我微信找我私聊。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. PostProcessor&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，spring还提供了专门注册bean的接口：&lt;code&gt;BeanDefinitionRegistryPostProcessor&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该接口的方法postProcessBeanDefinitionRegistry上有这样一段描述：&lt;img data-ratio=&quot;0.3464788732394366&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF3eclmVcRAt9Ribqd3SaGhhcsRfRiaqYZGTsaqdsV4l0fGakUlnIcG4JyP8rV3aibForMI2pEN2PqEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1420&quot;/&gt;修改应用程序上下文的内部bean定义注册表标准初始化。所有常规bean定义都将被加载，但是还没有bean被实例化。这允许进一步添加在下一个后处理阶段开始之前定义bean。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用这个接口来定义bean，我们要做的事情就变得非常简单了。只需定义一个类实现&lt;code&gt;BeanDefinitionRegistryPostProcessor&lt;/code&gt;接口。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyRegistryPostProcessor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BeanDefinitionRegistryPostProcessor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;postProcessBeanDefinitionRegistry&lt;/span&gt;&lt;span&gt;(BeanDefinitionRegistry registry)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        RootBeanDefinition roleBeanDefinition = &lt;span&gt;new&lt;/span&gt; RootBeanDefinition(Role&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        registry.registerBeanDefinition(&lt;span&gt;&quot;role&quot;&lt;/span&gt;, roleBeanDefinition);&lt;br/&gt;&lt;br/&gt;        RootBeanDefinition userBeanDefinition = &lt;span&gt;new&lt;/span&gt; RootBeanDefinition(User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        userBeanDefinition.setScope(ConfigurableBeanFactory.SCOPE_PROTOTYPE);&lt;br/&gt;        registry.registerBeanDefinition(&lt;span&gt;&quot;user&quot;&lt;/span&gt;, userBeanDefinition);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;postProcessBeanFactory&lt;/span&gt;&lt;span&gt;(ConfigurableListableBeanFactory beanFactory)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重写&lt;code&gt;postProcessBeanDefinitionRegistry&lt;/code&gt;方法，在该方法中能够获取&lt;code&gt;BeanDefinitionRegistry&lt;/code&gt;对象，它负责bean的注册工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过细心的朋友可能会发现，里面还多了一个&lt;code&gt;postProcessBeanFactory&lt;/code&gt;方法，没有做任何实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法其实是它的父接口：&lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;里的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.36856745479833103&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF3eclmVcRAt9Ribqd3SaGhhJE1RAAK7g0wc7TZ6fucUiaaeIoEKohtpPoeGzwLrVE9dXPXb4mNYVOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1438&quot;/&gt;在应用程序上下文的标准bean工厂之后修改其内部bean工厂初始化。所有bean定义都已加载，但没有bean将被实例化。这允许重写或添加属性甚至可以初始化bean。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyPostProcessor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BeanFactoryPostProcessor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;postProcessBeanFactory&lt;/span&gt;&lt;span&gt;(ConfigurableListableBeanFactory beanFactory)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        DefaultListableBeanFactory registry = (DefaultListableBeanFactory)beanFactory;&lt;br/&gt;        RootBeanDefinition roleBeanDefinition = &lt;span&gt;new&lt;/span&gt; RootBeanDefinition(Role&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        registry.registerBeanDefinition(&lt;span&gt;&quot;role&quot;&lt;/span&gt;, roleBeanDefinition);&lt;br/&gt;&lt;br/&gt;        RootBeanDefinition userBeanDefinition = &lt;span&gt;new&lt;/span&gt; RootBeanDefinition(User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        userBeanDefinition.setScope(ConfigurableBeanFactory.SCOPE_PROTOTYPE);&lt;br/&gt;        registry.registerBeanDefinition(&lt;span&gt;&quot;user&quot;&lt;/span&gt;, userBeanDefinition);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然这两个接口都能注册bean，那么他们有什么区别？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;BeanDefinitionRegistryPostProcessor 更侧重于bean的注册&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;BeanFactoryPostProcessor 更侧重于对已经注册的bean的属性进行修改，虽然也可以注册bean。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，有些朋友可能会问：既然拿到BeanDefinitionRegistry对象就能注册bean，那通过BeanFactoryAware的方式是不是也能注册bean呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从下面这张图能够看出DefaultListableBeanFactory就实现了BeanDefinitionRegistry接口。&lt;img data-ratio=&quot;0.4461883408071749&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF3eclmVcRAt9Ribqd3SaGhhD2SFCiakicKE72xbqIb5Z0ibWcgc5tNkWdZQTFdnsRYURKic6Eia1AAuvSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1784&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一来，我们如果能够获取DefaultListableBeanFactory对象的实例，然后调用它的注册方法，不就可以注册bean了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说时迟那时快，定义一个类实现&lt;code&gt;BeanFactoryAware&lt;/code&gt;接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BeanFactoryRegistry&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BeanFactoryAware&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setBeanFactory&lt;/span&gt;&lt;span&gt;(BeanFactory beanFactory)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        DefaultListableBeanFactory registry = (DefaultListableBeanFactory) beanFactory;&lt;br/&gt;        RootBeanDefinition rootBeanDefinition = &lt;span&gt;new&lt;/span&gt; RootBeanDefinition(User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        registry.registerBeanDefinition(&lt;span&gt;&quot;user&quot;&lt;/span&gt;, rootBeanDefinition);&lt;br/&gt;&lt;br/&gt;        RootBeanDefinition userBeanDefinition = &lt;span&gt;new&lt;/span&gt; RootBeanDefinition(User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        userBeanDefinition.setScope(ConfigurableBeanFactory.SCOPE_PROTOTYPE);&lt;br/&gt;        registry.registerBeanDefinition(&lt;span&gt;&quot;user&quot;&lt;/span&gt;, userBeanDefinition);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重写&lt;code&gt;setBeanFactory&lt;/code&gt;方法，在该方法中能够获取BeanFactory对象，它能够强制转换成DefaultListableBeanFactory对象，然后通过该对象的实例注册bean。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你满怀喜悦的运行项目时，发现竟然报错了：&lt;img data-ratio=&quot;0.24338624338624337&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF3eclmVcRAt9Ribqd3SaGhhduLuSZLdBUVUkrpWFSU5mcCEvF6DaIB6ic1kypNQ2eYKxyPPJnAkguA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1890&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么会报错？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring中bean的创建过程顺序大致如下：&lt;img data-ratio=&quot;2.353932584269663&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF3eclmVcRAt9Ribqd3SaGhh5vCcbXezk84CzoVKpNevjLFaT5mR6ZAwwcc5ViaBGPzhHxr7O3PibOuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;356&quot;/&gt;&lt;code&gt;BeanFactoryAware&lt;/code&gt;接口是在bean创建成功，并且完成依赖注入之后，在真正初始化之前才被调用的。在这个时候去注册bean意义不大，因为这个接口是给我们获取bean的，并不建议去注册bean，会引发很多问题。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;此外，ApplicationContextRegistry和ApplicationListener接口也有类似的问题，我们可以用他们获取bean，但不建议用它们注册bean。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d21f02ff9f474c395339e7cc39eaa4d1</guid>
<title>工具 | 一款专门为 Mac OSX 系统打造的，集多功能于一身的 SSH 客户端工具</title>
<link>https://toutiao.io/k/shxvkd4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>984c70cce950386d8e77e9691edd2ca2</guid>
<title>Java 线程池原理及最佳实践（1.5W 字，面试必问）</title>
<link>https://toutiao.io/k/39edoom</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1. 概述&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.1 线程池是什么&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;创建线程本身开销大，反复创建并销毁，过多的占用内存。所以有大量线程创建考虑使用线程池&lt;/strong&gt;。线程池不用反复创建线程达到&lt;strong&gt;线程的复用&lt;/strong&gt;，更具配置合理利用cpu和内存减少了开销，性能会得到提高，还能统一管理任务&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如服务器收到大量请求，每个请求都分配线程去处理，对服务器性能考验就比较大，如果创建5个以上线程考虑使用线程池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而本文描述线程池是JDK中提供的ThreadPoolExecutor类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，使用线程池可以带来一系列好处：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;降低资源消耗&lt;/strong&gt;：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;提高响应速度&lt;/strong&gt;：任务到达时，无需等待线程创建即可立即执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;提高线程的可管理性&lt;/strong&gt;：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;提供更多更强大的功能&lt;/strong&gt;：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.2 线程池解决的问题是什么&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统无法合理管理内部的资源分布，会降低系统的稳定性。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finance, computing and equipment management.——wikipedia&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在了解完“是什么”和“为什么”之后，下面我们来一起深入一下线程池的内部实现原理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2. 基本使用介绍及其相关参数和注重点&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来先看下面两张类图&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;&lt;strong&gt;ThreadPoolExecutor&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8817733990147784&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7B8iaauAfclNS8iaicfWRyHOeImut4ZIg01R5nltibITjmEeD6ABfPlpVOWJggxHkicgTHcOZHEQDCRHicvJWx3MQDbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;406&quot;/&gt;&lt;figcaption&gt;image-20210627142834199&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;&lt;strong&gt;ScheduledThreadPoolExecutor&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7111853088480802&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7B8iaauAfclNS8iaicfWRyHOeImut4ZIg01xBlSWT1U3NFFp6poh1eDE0bFdys0GADJCfl5AHay1a8ZYRvCOBga7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;599&quot;/&gt;&lt;figcaption&gt;image-20210627142859123&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;和&lt;code&gt;ScheduledThreadPoolExecutor&lt;/code&gt;算是我们最常用的线程池类了，从上面我们可以看到这俩个最终都实现了&lt;code&gt;Executor&lt;/code&gt;和&lt;code&gt;ExecutorService&lt;/code&gt;这两个接口，实际上主要的接口定义都是在&lt;code&gt;ExecutorService&lt;/code&gt;中&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.549469964664311&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7B8iaauAfclNS8iaicfWRyHOeImut4ZIg01D9IiaVUMwicg9YOeKHTkrOtvIqLLJibKTLalo4PJ4NCyqcmqK7MsZh15w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;566&quot;/&gt;&lt;figcaption&gt;image-20210627143249342&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3573487031700288&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7B8iaauAfclNS8iaicfWRyHOeImut4ZIg01voyoZJ2DsfOibCnsbWAVPoibQTJSoQ9jUZo47CALVic3N8BQBD1RFgPMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;694&quot;/&gt;&lt;figcaption&gt;image-20210627143331102&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来着重讲解一下&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;的使用及其相关介绍&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们来看下它的构造方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;   &lt;span&gt;int&lt;/span&gt; corePoolSize,&lt;br/&gt;   &lt;span&gt;int&lt;/span&gt; maximumPoolSize,&lt;br/&gt;   &lt;span&gt;long&lt;/span&gt; keepAliveTime,&lt;br/&gt;   TimeUnit unit,&lt;br/&gt;   BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,&lt;br/&gt;   ThreadFactory threadFactory,&lt;br/&gt;   RejectedExecutionHandler handler)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参数说明：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;线程池在完成初始化之后，默认情况下，线程池中不会有任何线程，线程池会等有任务来的时候再去创建线程。核心线程创建出来后即使超出了线程保持的存活时间配置也不会销毁，核心线程只要创建就永驻了，就等着新任务进来进行处理。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;maximumPoolSize&lt;/code&gt;:线程池最大线程数量&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;核心线程忙不过来且任务存储队列满了的情况下，还有新任务进来的话就会继续开辟线程，但是也不是任意的开辟线程数量，线程数（包含核心线程）达到&lt;code&gt;maximumPoolSize&lt;/code&gt;后就不会产生新线程了，就会执行拒绝策略。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;keepAliverTime&lt;/code&gt;：当活跃线程数大于核心线程数时，空闲的多余线程最大存活时间&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果线程池当前的线程数多于&lt;code&gt;corePoolSize&lt;/code&gt;，那么如果多余的线程空闲时间超过&lt;code&gt;keepAliveTime&lt;/code&gt;，那么这些多余的线程（超出核心线程数的那些线程）就会被回收。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;比如：&lt;code&gt;TimeUnit.MILLISECONDS&lt;/code&gt;、&lt;code&gt;TimeUnit.SECONDS&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;核心线程数满了后还有任务继续提交到线程池的话，就先进入&lt;code&gt;workQueue&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;code&gt;workQueue&lt;/code&gt;通常情况下有如下选择：&lt;/p&gt;&lt;p&gt;&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;：无界队列，意味着无限制，其实是有限制，大小是int的最大值。也可以自定义大小。&lt;/p&gt;&lt;p&gt;&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;：有界队列，可以自定义大小，到了阈值就开启新线程（不会超过&lt;code&gt;maximumPoolSize&lt;/code&gt;）。&lt;/p&gt;&lt;p&gt;&lt;code&gt;SynchronousQueue&lt;/code&gt;：&lt;code&gt;Executors.newCachedThreadPool();&lt;/code&gt;默认使用的队列。也不算是个队列，他不没有存储元素的能力。&lt;/p&gt;&lt;p&gt;一般都采取&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;，因为他也可以设置大小，可以取代&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;有界队列。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;threadFactory&lt;/code&gt;：当线程池需要新的线程时，会用&lt;code&gt;threadFactory&lt;/code&gt;来生成新的线程&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;默认采用的是&lt;code&gt;DefaultThreadFactory&lt;/code&gt;，主要负责创建线程。&lt;code&gt;newThread()&lt;/code&gt;方法。创建出来的线程都在同一个线程组且优先级也是一样的。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;handler&lt;/code&gt;：拒绝策略，任务量超出线程池的配置限制或执行shutdown还在继续提交任务的话，会执行&lt;code&gt;handler&lt;/code&gt;的逻辑。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;默认采用的是&lt;code&gt;AbortPolicy&lt;/code&gt;，遇到上面的情况，线程池将直接采取直接拒绝策略，也就是直接抛出异常。&lt;code&gt;RejectedExecutionException&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;实际上JDK为了我们方便使用线程池，提供了一个&lt;code&gt;Executors&lt;/code&gt;工具来为我们快速方便的创建出线程池&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Executors创建返回ThreadPoolExecutor对象的方法共有三种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Executors#newCachedThreadPool =&amp;gt; 创建可缓存的线程池&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Executors#newSingleThreadExecutor =&amp;gt; 创建单线程的线程池&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Executors#newFixedThreadPool =&amp;gt; 创建固定长度的线程池&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Executors#newCachedThreadPool方法&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService &lt;span&gt;newCachedThreadPool&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;0&lt;/span&gt;, Integer.MAX_VALUE,&lt;br/&gt;                                  &lt;span&gt;60L&lt;/span&gt;, TimeUnit.SECONDS,&lt;br/&gt;                                  &lt;span&gt;new&lt;/span&gt; SynchronousQueue&amp;lt;Runnable&amp;gt;());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CachedThreadPool是一个根据需要创建新线程的线程池&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;corePoolSize =&amp;gt; 0，核心线程池的数量为0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;maximumPoolSize =&amp;gt; Integer.MAX_VALUE，可以认为最大线程数是无限的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;keepAliveTime =&amp;gt; 60L&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;unit =&amp;gt; 秒&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;workQueue =&amp;gt; SynchronousQueue&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个任务提交时，corePoolSize为0不创建核心线程，SynchronousQueue是一个不存储元素的队列，可以理解为队里永远是满的，因此最终会创建非核心线程来执行任务。对于非核心线程空闲60s时将被回收。&lt;strong&gt;因为Integer.MAX_VALUE非常大，可以认为是可以无限创建线程的，在资源有限的情况下容易引起OOM异常&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Executors#newSingleThreadExecutor方法&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService &lt;span&gt;newFixedThreadPool&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; nThreads)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(nThreads, nThreads,&lt;br/&gt;                                  &lt;span&gt;0L&lt;/span&gt;, TimeUnit.MILLISECONDS,&lt;br/&gt;                                  &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SingleThreadExecutor是单线程线程池，只有一个核心线程&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;corePoolSize =&amp;gt; 1，核心线程池的数量为1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;maximumPoolSize =&amp;gt; 1，只可以创建一个非核心线程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;keepAliveTime =&amp;gt; 0L&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;unit =&amp;gt; 毫秒&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;workQueue =&amp;gt; LinkedBlockingQueue&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个任务提交时，首先会创建一个核心线程来执行任务，如果超过核心线程的数量，将会放入队列中，&lt;strong&gt;因为LinkedBlockingQueue是长度为Integer.MAX_VALUE的队列，可以认为是无界队列，因此往队列中可以插入无限多的任务，在资源有限的时候容易引起OOM异常&lt;/strong&gt;，同时因为无界队列，maximumPoolSize和keepAliveTime参数将无效，压根就不会创建非核心线程&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Executors#newFixedThreadPool方法&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService &lt;span&gt;newFixedThreadPool&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; nThreads)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(nThreads, nThreads,&lt;br/&gt;                                  &lt;span&gt;0L&lt;/span&gt;, TimeUnit.MILLISECONDS,&lt;br/&gt;                                  &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FixedThreadPool是固定核心线程的线程池，固定核心线程数由用户传入&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;corePoolSize =&amp;gt; 1，核心线程池的数量为1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;maximumPoolSize =&amp;gt; 1，只可以创建一个非核心线程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;keepAliveTime =&amp;gt; 0L&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;unit =&amp;gt; 毫秒&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;workQueue =&amp;gt; LinkedBlockingQueue&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;它和SingleThreadExecutor类似，唯一的区别就是核心线程数不同，并且由于使用的是LinkedBlockingQueue，在资源有限的时候容易引起OOM异常&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;因此由上面的结论，可以看出使用&lt;code&gt;Executors&lt;/code&gt;创建出的线程池是有可能引起内存溢出的，所以我们并不推荐甚至不允许使用&lt;code&gt;Executors&lt;/code&gt;来创建线程池&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程池的流程运转原理&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提交一个任务到线程池中，线程池的处理流程如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、判断&lt;strong&gt;线程池里的核心线程&lt;/strong&gt;是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、判断&lt;strong&gt;线程池里的线程&lt;/strong&gt;是否都处于工作状态&lt;span&gt;[线程数量是否达到最大值]&lt;/span&gt;，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5933014354066986&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7B8iaauAfclNS8iaicfWRyHOeImut4ZIg01aggh3qZRBibhKWkEcvv9nY7W7dgntibB8oyXqnTeOEkTwDGb04ibSmMxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;627&quot;/&gt;&lt;figcaption&gt;image-20210627171512964&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他的参数都比较容易理解，所以我们来着重看下拒绝策略&lt;code&gt;handler&lt;/code&gt;这个参数，其类型为&lt;code&gt;RejectedExecutionHandler&lt;/code&gt;，当线程池达到最大值并且线程数也达到最大值时才会工作，当队列和线程池都满了，说明线程池处于饱和状态，那么必须对新提交的任务采用一种特殊的策略来进行处理。这个策略默认配置是&lt;code&gt;AbortPolicy&lt;/code&gt;，表示无法处理新的任务而抛出异常。JAVA提供了4种策略：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;AbortPolicy&lt;/code&gt;：直接抛出异常&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;CallerRunsPolicy&lt;/code&gt;：只用调用所在的线程运行任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;DiscardOldestPolicy&lt;/code&gt;：丢弃队列里最近的一个任务，并执行当前任务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;DiscardPolicy&lt;/code&gt;：不处理，丢弃掉。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.33038999264164826&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7B8iaauAfclNS8iaicfWRyHOeImut4ZIg01xibXIhFWPFtzs4ViaWuQfMx1esRdicUlZ5ePFFInsnibRVxagbZqj76Adw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1359&quot;/&gt;&lt;figcaption&gt;image-20210627174730111&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;当然我们上面也说了&lt;code&gt;handler&lt;/code&gt;是一个&lt;code&gt;RejectedExecutionHandler&lt;/code&gt;的类型，所以我们也可以实现这个接口来创建一个我们自己的拒绝策略&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;自定义拒绝策略&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拒绝策略是一个接口，其设计如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;RejectedExecutionHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;rejectedExecution&lt;/span&gt;&lt;span&gt;(Runnable r, ThreadPoolExecutor executor)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户可以通过实现这个接口去定制拒绝策略，在手动配置线程池时的构造函数传入或者通过方法&lt;code&gt;setRejectedExecutionHandler&lt;/code&gt; 在线程池运行期间改变拒绝任务的策略。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; corePoolSize,&lt;br/&gt;                              &lt;span&gt;int&lt;/span&gt; maximumPoolSize,&lt;br/&gt;                              &lt;span&gt;long&lt;/span&gt; keepAliveTime,&lt;br/&gt;                              TimeUnit unit,&lt;br/&gt;                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,&lt;br/&gt;                              ThreadFactory threadFactory,&lt;br/&gt;                              RejectedExecutionHandler handler)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;//省略其他代码&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.handler = handler;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setRejectedExecutionHandler&lt;/span&gt;&lt;span&gt;(RejectedExecutionHandler handler)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (handler == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException();&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.handler = handler;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbortPolicyWithReport&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ThreadPoolExecutor&lt;/span&gt;.&lt;span&gt;AbortPolicy&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(AbortPolicyWithReport&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String threadName;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; URL url;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; lastPrintTime = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Semaphore guard = &lt;span&gt;new&lt;/span&gt; Semaphore(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;AbortPolicyWithReport&lt;/span&gt;&lt;span&gt;(String threadName, URL url)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.threadName = threadName;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.url = url;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;rejectedExecution&lt;/span&gt;&lt;span&gt;(Runnable r, ThreadPoolExecutor e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String msg = String.format(&lt;span&gt;&quot;Thread pool is EXHAUSTED!&quot;&lt;/span&gt; +&lt;br/&gt;                     &lt;span&gt;&quot; Thread Name: %s, Pool Size: %d (active: %d, core: %d, max: %d, largest: %d), Task: %d (completed: %d),&quot;&lt;/span&gt; +&lt;br/&gt;                     &lt;span&gt;&quot; Executor status:(isShutdown:%s, isTerminated:%s, isTerminating:%s), in %s://%s:%d!&quot;&lt;/span&gt;,&lt;br/&gt;                     threadName, e.getPoolSize(), e.getActiveCount(), e.getCorePoolSize(), e.getMaximumPoolSize(), e.getLargestPoolSize(),&lt;br/&gt;                     e.getTaskCount(), e.getCompletedTaskCount(), e.isShutdown(), e.isTerminated(), e.isTerminating(),&lt;br/&gt;                     url.getProtocol(), url.getIp(), url.getPort());&lt;br/&gt;        logger.warn(msg);&lt;br/&gt;        dumpJStack();&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RejectedExecutionException(msg);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;dumpJStack&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       &lt;span&gt;//......&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;拒绝策略的执行&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从调用&lt;code&gt;execute()&lt;/code&gt;方法，经过一系列判断，当该任务被判断需要被被拒绝后，会接着执行&lt;code&gt;reject(command)&lt;/code&gt; ，最终就会执行具体实现&lt;code&gt;RejectedExecutionHandler&lt;/code&gt;接口的&lt;code&gt;rejectedExecution(r,executor)&lt;/code&gt; 方法了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;reject&lt;/span&gt;&lt;span&gt;(Runnable command)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        handler.rejectedExecution(command, &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3. 线程池结合SpringBoot实战(结合项目)&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;SpringBoot使用线程池我们常见的有两种方式：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用默认的线程池&lt;code&gt;@Async&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用自定义的线程池&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方式一：通过@Async注解调用&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步：在Application启动类上面加上&lt;code&gt;@EnableAsync&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@SpringBootApplication&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@EnableAsync&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadpoolApplication&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        SpringApplication.run(ThreadpoolApplication&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;args&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步：在需要异步执行的方法上加上@Async注解&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AsyncTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(&lt;span&gt;this&lt;/span&gt;.getClass());&lt;br/&gt;    &lt;span&gt;@Async&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;hello&lt;/span&gt;&lt;span&gt;(String name)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;//这里使用logger 方便查看执行的线程是什么&lt;/span&gt;&lt;br/&gt;        logger.info(&lt;span&gt;&quot;异步线程启动 started.&quot;&lt;/span&gt;+name);  &lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三步：测试类进行测试验证&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    AsyncTest asyncTest;&lt;br/&gt;    &lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;contextLoads&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        asyncTest.hello(&lt;span&gt;&quot;afsasfasf&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//一定要休眠 不然主线程关闭了，子线程还没有启动&lt;/span&gt;&lt;br/&gt;        Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看打印的日志：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;INFO 2276 --- [           main] c.h.s.t.t.ThreadpoolApplicationTests     : Started ThreadpoolApplicationTests in 3.003 seconds (JVM running for 5.342)&lt;/p&gt;&lt;p&gt;INFO 2276 --- [         task-1] c.h.s.threadpool.threadpool.AsyncTest    : 异步线程启动 started.afsasfasf&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以清楚的看到新开了一个&lt;code&gt;task-1&lt;/code&gt;的线程执行任务。验证成功！！！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;***注意：***&lt;code&gt;@Async&lt;/code&gt;注解失效常景&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方式二：使用自定义的线程池&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在默认配置信息里面是没有线程池的拒绝策略设置的方法的，如果需要更换拒绝策略就需要自定义线程池，并且如果项目当中需要多个自定义的线程池，又要如何进行管理呢？&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;自定义Configuration&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步：创建一个ThreadPoolConfig 先只配置一个线程池，并设置拒绝策略为CallerRunsPolicy&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Configuration&lt;br/&gt;public &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadPoolConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    @Bean(&lt;span&gt;&quot;taskExecutor&quot;&lt;/span&gt;)&lt;br/&gt;    public Executor taskExecutor() {&lt;br/&gt;        ThreadPoolTaskExecutor taskExecutor = &lt;span&gt;new&lt;/span&gt; ThreadPoolTaskExecutor();&lt;br/&gt;        &lt;span&gt;//设置线程池参数信息&lt;/span&gt;&lt;br/&gt;        taskExecutor.setCorePoolSize(&lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;        taskExecutor.setMaxPoolSize(&lt;span&gt;50&lt;/span&gt;);&lt;br/&gt;        taskExecutor.setQueueCapacity(&lt;span&gt;200&lt;/span&gt;);&lt;br/&gt;        taskExecutor.setKeepAliveSeconds(&lt;span&gt;60&lt;/span&gt;);&lt;br/&gt;        taskExecutor.setThreadNamePrefix(&lt;span&gt;&quot;myExecutor--&quot;&lt;/span&gt;);&lt;br/&gt;        taskExecutor.setWaitForTasksToCompleteOnShutdown(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;        taskExecutor.setAwaitTerminationSeconds(&lt;span&gt;60&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//修改拒绝策略为使用当前线程执行&lt;/span&gt;&lt;br/&gt;        taskExecutor.setRejectedExecutionHandler(&lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor.CallerRunsPolicy());&lt;br/&gt;        &lt;span&gt;//初始化线程池&lt;/span&gt;&lt;br/&gt;        taskExecutor.initialize();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; taskExecutor;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后执行之前写的测试代码发现，使用的线程池已经变成自定义的线程池了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;INFO 12740 --- [  myExecutor--2] c.h.s.t.t.ThreadpoolApplicationTests     : threadPoolTaskExecutor 创建线程&lt;/p&gt;&lt;p&gt;INFO 12740 --- [  myExecutor--1] c.h.s.threadpool.threadpool.AsyncTest    : 异步线程启动 started.async注解创建&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步：如果配置有多个线程池,该如何指定线程池呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Configuration&lt;br/&gt;public &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadPoolConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;       @Bean(&lt;span&gt;&quot;taskExecutor&quot;&lt;/span&gt;)&lt;br/&gt;    public Executor taskExecutor() {&lt;br/&gt;        ThreadPoolTaskExecutor taskExecutor = &lt;span&gt;new&lt;/span&gt; ThreadPoolTaskExecutor();&lt;br/&gt;        &lt;span&gt;//设置线程池参数信息&lt;/span&gt;&lt;br/&gt;        taskExecutor.setCorePoolSize(&lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;        taskExecutor.setMaxPoolSize(&lt;span&gt;50&lt;/span&gt;);&lt;br/&gt;        taskExecutor.setQueueCapacity(&lt;span&gt;200&lt;/span&gt;);&lt;br/&gt;        taskExecutor.setKeepAliveSeconds(&lt;span&gt;60&lt;/span&gt;);&lt;br/&gt;        taskExecutor.setThreadNamePrefix(&lt;span&gt;&quot;myExecutor--&quot;&lt;/span&gt;);&lt;br/&gt;        taskExecutor.setWaitForTasksToCompleteOnShutdown(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;        taskExecutor.setAwaitTerminationSeconds(&lt;span&gt;60&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//修改拒绝策略为使用当前线程执行&lt;/span&gt;&lt;br/&gt;        taskExecutor.setRejectedExecutionHandler(&lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor.CallerRunsPolicy());&lt;br/&gt;        &lt;span&gt;//初始化线程池&lt;/span&gt;&lt;br/&gt;        taskExecutor.initialize();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; taskExecutor;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @Bean(&lt;span&gt;&quot;poolExecutor&quot;&lt;/span&gt;)&lt;br/&gt;    public Executor poolExecutor() {&lt;br/&gt;        ThreadPoolTaskExecutor taskExecutor = &lt;span&gt;new&lt;/span&gt; ThreadPoolTaskExecutor();&lt;br/&gt;        &lt;span&gt;//设置线程池参数信息&lt;/span&gt;&lt;br/&gt;        taskExecutor.setCorePoolSize(&lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;        taskExecutor.setMaxPoolSize(&lt;span&gt;50&lt;/span&gt;);&lt;br/&gt;        taskExecutor.setQueueCapacity(&lt;span&gt;200&lt;/span&gt;);&lt;br/&gt;        taskExecutor.setKeepAliveSeconds(&lt;span&gt;60&lt;/span&gt;);&lt;br/&gt;        taskExecutor.setThreadNamePrefix(&lt;span&gt;&quot;myExecutor2--&quot;&lt;/span&gt;);&lt;br/&gt;        taskExecutor.setWaitForTasksToCompleteOnShutdown(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;        taskExecutor.setAwaitTerminationSeconds(&lt;span&gt;60&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//修改拒绝策略为使用当前线程执行&lt;/span&gt;&lt;br/&gt;        taskExecutor.setRejectedExecutionHandler(&lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor.CallerRunsPolicy());&lt;br/&gt;        &lt;span&gt;//初始化线程池&lt;/span&gt;&lt;br/&gt;        taskExecutor.initialize();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; taskExecutor;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @Bean(&lt;span&gt;&quot;taskPoolExecutor&quot;&lt;/span&gt;)&lt;br/&gt;    public Executor taskPoolExecutor() {&lt;br/&gt;        ThreadPoolTaskExecutor taskExecutor = &lt;span&gt;new&lt;/span&gt; ThreadPoolTaskExecutor();&lt;br/&gt;        &lt;span&gt;//设置线程池参数信息&lt;/span&gt;&lt;br/&gt;        taskExecutor.setCorePoolSize(&lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;        taskExecutor.setMaxPoolSize(&lt;span&gt;50&lt;/span&gt;);&lt;br/&gt;        taskExecutor.setQueueCapacity(&lt;span&gt;200&lt;/span&gt;);&lt;br/&gt;        taskExecutor.setKeepAliveSeconds(&lt;span&gt;60&lt;/span&gt;);&lt;br/&gt;        taskExecutor.setThreadNamePrefix(&lt;span&gt;&quot;myExecutor3--&quot;&lt;/span&gt;);&lt;br/&gt;        taskExecutor.setWaitForTasksToCompleteOnShutdown(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;        taskExecutor.setAwaitTerminationSeconds(&lt;span&gt;60&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//修改拒绝策略为使用当前线程执行&lt;/span&gt;&lt;br/&gt;        taskExecutor.setRejectedExecutionHandler(&lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor.CallerRunsPolicy());&lt;br/&gt;        &lt;span&gt;//初始化线程池&lt;/span&gt;&lt;br/&gt;        taskExecutor.initialize();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; taskExecutor;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行测试类，直接报错说找到多个类，不知道加载哪个类：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;No qualifying bean of type &#x27;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&#x27; available: expected single matching bean but found 3: taskExecutor,taskPoolExecutor&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于测试类当中是这样自动注入的:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;ThreadPoolTaskExecutor threadPoolTaskExecutor; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考虑到@Autowired 以及@Resource两个注入时的存在多个类如何匹配问题，然后发现只要我们在注入时指定具体的bean就会调用对应的线程池！！！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即修改测试类如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    AsyncTest asyncTest;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    ThreadPoolTaskExecutor poolExecutor; &lt;span&gt;//会去匹配 @Bean(&quot;poolExecutor&quot;) 这个线程池&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;contextLoads&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        asyncTest.hello(&lt;span&gt;&quot;async注解创建&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//一定要休眠 不然主线程关闭了，子线程还没有启动&lt;/span&gt;&lt;br/&gt;        poolExecutor.submit(&lt;span&gt;new&lt;/span&gt; Thread(()-&amp;gt;{&lt;br/&gt;            logger.info(&lt;span&gt;&quot;threadPoolTaskExecutor 创建线程&quot;&lt;/span&gt;);&lt;br/&gt;        }));&lt;br/&gt;        Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后得到如下信息：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;INFO 13636 --- [ myExecutor2--1] c.h.s.t.t.ThreadpoolApplicationTests     : threadPoolTaskExecutor 创建线程 INFO 13636 --- [  myExecutor--1] c.h.s.threadpool.threadpool.AsyncTest    : 异步线程启动 started.async注解创建&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意&lt;/strong&gt;：如果是使用的@Async注解，只需要在注解里面指定bean的名称就可以切换到对应的线程池去了。如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;@Async&lt;/span&gt;(&lt;span&gt;&quot;taskPoolExecutor&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;hello&lt;/span&gt;&lt;span&gt;(String name)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        logger.info(&lt;span&gt;&quot;异步线程启动 started.&quot;&lt;/span&gt;+name);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意&lt;/strong&gt;：如果有多个线程池，但是在@Async注解里面没有指定的话，会默认加载第一个配置的线程池&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;submit和executor区别&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;execute和submit都属于线程池的方法，execute只能提交Runnable类型的任务，而submit既能提交Runnable类型任务也能提交Callable类型任务。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;execute会直接抛出任务执行时的异常，submit会吃掉异常，可通过Future的get方法&lt;span&gt;[会阻塞]&lt;/span&gt;将任务执行时的异常重新抛出。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;execute所属顶层接口是Executor,submit所属顶层接口是ExecutorService，实现类ThreadPoolExecutor重写了execute方法,抽象类AbstractExecutorService重写了submit方法。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;submit和execute由于参数不同有四种实现形式，如下所示，本文主要研究这四种形式在各自使用场景下的区别和联系&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;这种提交的方式会返回一个Future对象，这个Future对象代表这线程的执行结果&lt;br/&gt;当主线程调用Future的get方法的时候会获取到从线程中返回的结果数据。&lt;br/&gt;如果在线程的执行过程中发生了异常，get会获取到异常的信息。&lt;br/&gt;&amp;lt;T&amp;gt; &lt;span&gt;Future&amp;lt;T&amp;gt; &lt;span&gt;submit&lt;/span&gt;&lt;span&gt;(Callable&amp;lt;T&amp;gt; task)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;当线程正常结束的时候调用Future的get方法会返回result对象，当线程抛出异常的时候会获取到对应的异常的信息。&lt;br/&gt;&amp;lt;T&amp;gt; &lt;span&gt;Future&amp;lt;T&amp;gt; &lt;span&gt;submit&lt;/span&gt;&lt;span&gt;(Runnable task, T result)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;提交一个Runable接口的对象，这样当调用get方法的时候，如果线程执行成功会直接返回&lt;span&gt;null&lt;/span&gt;，如果线程执行异常会返回异常的信息&lt;br/&gt;Future&amp;lt;?&amp;gt; submit(Runnable task);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(Runnable command)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;execute提交的方式只能提交一个Runnable的对象，且该方法的返回值是void，也即是提交后如果线程运行后，和主线程就脱离了关系了，当然可以设置一些变量来获取到线程的运行结果。并且当线程的执行过程中抛出了异常通常来说主线程也无法获取到异常的信息的，只有通过ThreadFactory主动设置线程的异常处理类才能感知到提交的线程中的异常信息。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4. 线程池原理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 主要介绍线程池中线程复用原理&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;对于线程池的复用原理，可以简单的用一句话概括：创建指定数量的线程并开启，判断当前是否有任务执行，如果有则执行任务。再通俗易懂一些：创建指定数量的线程并运行，重写run方法，循环从任务队列中取Runnable对象，执行Runnable对象的run方法。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6384105960264901&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7B8iaauAfclNS8iaicfWRyHOeImut4ZIg01aibaicpjsUrsCB1PMs6nXplRKHE864ZzUuvpygBF2x9REFdhMU2eBgzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;755&quot;/&gt;&lt;figcaption&gt;image-20210702000757740&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;接下来开始手写线程池吧，注意是简易线程池，跟JDK自带的线程池无法相提并论，在这里我省略了判断当前线程数有没有大于核心线程数的步骤，简化成直接从队列中取任务，对于理解原理来说已然足矣，代码如下：&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyExecutorService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 一直保持运行的线程&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; List&amp;lt;WorkThread&amp;gt; workThreads;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;     * 任务队列容器&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; BlockingDeque&amp;lt;Runnable&amp;gt; taskRunables;&lt;br/&gt;     &lt;span&gt;/*&lt;br/&gt;     * 线程池当前是否停止&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isWorking = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;MyExecutorService&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; workThreads, &lt;span&gt;int&lt;/span&gt; taskRunables)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.workThreads = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.taskRunables = &lt;span&gt;new&lt;/span&gt; LinkedBlockingDeque&amp;lt;&amp;gt;(taskRunables);&lt;br/&gt;        &lt;span&gt;//直接运行核心线程&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; workThreads; i++) {&lt;br/&gt;            WorkThread workThread = &lt;span&gt;new&lt;/span&gt; WorkThread();&lt;br/&gt;            workThread.start();&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.workThreads.add(workThread);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * WorkThread累，线程池的任务类，类比JDK的worker&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WorkThread&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (isWorking || taskRunables.size() != &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;//获取任务&lt;/span&gt;&lt;br/&gt;                Runnable task = taskRunables.poll();&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (task != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    task.run();&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//执行execute，jdk中会存在各种判断，这里省略了&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(Runnable runnable)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//把任务加入队列&lt;/span&gt;&lt;br/&gt;        taskRunables.offer(runnable);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//停止线程池&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;shutdown&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.isWorking = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;&lt;strong&gt;测试&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//测试自定义的线程池&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    MyExecutorService myExecutorService = &lt;span&gt;new&lt;/span&gt; MyExecutorService(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;//运行8次&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;8&lt;/span&gt;; i++) {&lt;br/&gt;        myExecutorService.execute(() -&amp;gt; {&lt;br/&gt;            System.out.println(Thread.currentThread().getName() + &lt;span&gt;&quot;task begin&quot;&lt;/span&gt;);&lt;br/&gt;        });&lt;br/&gt;    }&lt;br/&gt;    myExecutorService.shutdown();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;通过以上分析并手写线程池，我们应该已经基本理解了线程池的复用机制原理，实际上JDK的实现机制远比我们手写的要复杂的多，主要有以下两点，可以让我们进一步加深理解：&lt;/p&gt;&lt;/blockquote&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当有新任务来的时候，首先判断当前的线程数有没有超过核心线程数，如果没超过则直接新建一个线程来执行新的任务，如果超过了则判断缓存队列有没有满，没满则将新任务放进缓存队列中，如果队列已满并且线程池中的线程数已经达到了指定的最大线程数，那就根据相应的策略拒绝任务，默认为抛异常。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当缓存队列中的任务都执行完毕后，线程池中的线程数如果大于核心线程数并且已经超过了指定的存活时间（存活时间通过队列的poll方法传入，如果指定时间内没有获取到任务，则break退出，线程运行结束），就销毁多出来的线程，直到线程池中的线程数等于核心线程数。此时剩余的线程会一直处于阻塞状态，等待新的任务到来。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;有兴趣可以看这块的源码，大致的思想就是：&lt;/p&gt;&lt;p&gt;&lt;code&gt;首先，线程池会有一个管理任务的队列，这个任务队列里存放的就是各种任务，线程池会一直不停循环的去查看消息队里有没有接到任务，如果没有，则继续循环，如果有了则开始创建线程，如果给这个线程池设定的容量是10个线程，那么当有任务的时候就会调用创建线程的函数方法去根据当前任务总数量依次创建线程（这里创建线程的函数方法都是你提前些好了的），线程中会写好循环获取任务队列里任务的逻辑、判断是否销毁该线程的逻辑、进入等待的逻辑，这样线程一旦创建出来就会循环的去查询任务队列里的任务，拿到任务后就执行，执行任务完毕后判断是否销毁该线程，如果不销毁就进入等待（sleep），等待时间过后继续查询消息是否有任务，如此循环，直到逻辑判断需要销毁该线程为止（一般都是根据设定时间去判断是否销毁，例如在线程创建的时候设置一个计时器去控制，如果180秒都没有接到新的任务，则销毁该线程） 。&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>460d974019b2cb789fb2de570a833b87</guid>
<title>工欲善其事，必先利其器之 gdb 五大高级用法</title>
<link>https://toutiao.io/k/khg0dob</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;本篇文章讲解gdb的一些高级用法，在我们的开发生涯中，调试是很重要的技能，而在linux下开发，最常用的调试工具就是gdb了，所以这里介绍几种gdb比较高级的用法，助力我们的调试技能。&lt;/p&gt;&lt;p&gt;还是先看下思维导图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.47578125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RNfZGZNpL1BQ7hedicLIGxTCnJzKNA6BjHodLicIPBdiayYfcleyTMVS5H1ew7HTx2cdicJQCsJyG2WUyn5vZ3trQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figure/&gt;&lt;h4&gt;&lt;span&gt;1. gdb怎么调试多线程&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;gdb调试多线程时，默认情况下是所有线程同时都在执行，但是假设我们想只有一个线程继续执行，其他线程都暂停呢？下面就来看一看该怎么实现这个功能。&lt;/p&gt;&lt;p&gt;有这么一段多线程代码，如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;//test.cpp&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;print1_msg&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt; *arg)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;print1_msg\n&quot;&lt;/span&gt;);&lt;br/&gt;        usleep(&lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;print2_msg&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt; *arg)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;print2_msg\n&quot;&lt;/span&gt;);&lt;br/&gt;        usleep(&lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;pthread_t&lt;/span&gt; id1, id2;&lt;br/&gt;    pthread_create(&amp;amp;id1, &lt;span&gt;NULL&lt;/span&gt;, print1_msg, &lt;span&gt;NULL&lt;/span&gt;);&lt;br/&gt;    pthread_create(&amp;amp;id2, &lt;span&gt;NULL&lt;/span&gt;, print2_msg, &lt;span&gt;NULL&lt;/span&gt;);&lt;br/&gt;    pthread_join(id1, &lt;span&gt;NULL&lt;/span&gt;);  &lt;span&gt;//使主线程等待该线程结束后才结束，否则主线程很快结束，该线程没有机会执行&lt;/span&gt;&lt;br/&gt;    pthread_join(id2, &lt;span&gt;NULL&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;假设我们因为线上的问题，然后想要程序只执行线程函数&lt;code&gt;print1_msg&lt;/code&gt;，但不能修改代码，那要怎么办呢？&lt;/p&gt;&lt;p&gt;首先我们使用&lt;code&gt;g++ -g test.cpp -l pthread -o test&lt;/code&gt;生成可执行文件，然后使用&lt;code&gt;gdb ./test&lt;/code&gt;进入gdb模式，如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;(gdb) b test.cpp:28  #b就是break，打断点&lt;br/&gt;Breakpoint 1 at 0x40074e: file test.cpp, line 28.&lt;br/&gt;(gdb) r  #r即run，运行程序&lt;br/&gt;Starting program: /root/test &lt;br/&gt;[Thread debugging using libthread_db enabled]&lt;br/&gt;Using host libthread_db library &quot;/lib64/libthread_db.so.1&quot;.&lt;br/&gt;[New Thread 0x40a00940 (LWP 26623)]&lt;br/&gt;print1_msg&lt;br/&gt;[New Thread 0x41401940 (LWP 26624)]&lt;br/&gt;&lt;br/&gt;Thread 1 hit Breakpoint 1, main () at test.cpp:28&lt;br/&gt;28        pthread_join(id1, NULL);  //使主线程等待该线程结束后才结束，否则主线程很快结束，该线程没有机会执行&lt;br/&gt;(gdb) info thread   #显示当前进程的所有线程，第1号线程就是进程自身&lt;br/&gt;  Id   Target Id         Frame &lt;br/&gt;* 1    Thread 0x2aaaaae794d0 (LWP 26619) main () at test.cpp:28&lt;br/&gt;  2    Thread 0x40a00940 (LWP 26623) 0x00000036f289a901 in nanosleep () from /lib64/libc.so.6&lt;br/&gt;  3    Thread 0x41401940 (LWP 26624) 0x00000036f28d4971 in clone () from /lib64/libc.so.6&lt;br/&gt;(gdb) thread 2  #进入序号为2的线程&lt;br/&gt;[Switching to thread 2 (Thread 0x40a00940 (LWP 26623))]&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;0  0x00000036f289a901 &lt;span&gt;in&lt;/span&gt; nanosleep () from /lib64/libc.so.6&lt;/span&gt;&lt;br/&gt;(gdb) set scheduler-locking on   #只有当前被调试线程会执行&lt;br/&gt;(gdb) c&lt;br/&gt;Continuing.&lt;br/&gt;print1_msg&lt;br/&gt;print1_msg&lt;br/&gt;print1_msg&lt;br/&gt;print1_msg&lt;br/&gt;print1_msg&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;大家可以看看注释，这样一番操作以后，实际上就只有第一个线程在执行了，此时如果执行gdb命令&lt;code&gt;set scheduler-locking off&lt;/code&gt;就会继续执行所有线程了。&lt;/p&gt;&lt;p&gt;下面介绍一下多线程调试中会比较多用到的gdb命令:&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;gdb命令&lt;/th&gt;&lt;th&gt;命令的作用&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;info thread&lt;/td&gt;&lt;td&gt;显示当前进程的所有线程，第一列代表线程序号，第1号线程就是进程自身，序号前面带*的就是当前正在执行的线程&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;thread id&lt;/td&gt;&lt;td&gt;id代表线程序号，比如thread 2就是表示进入2号线程&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;set scheduler-locking on&lt;/td&gt;&lt;td&gt;设置该命令后，表示只有当前线程会被执行，其他线程相当于被锁住，会暂停&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;set scheduler-locking off&lt;/td&gt;&lt;td&gt;不锁定任何线程，设置该命令后，表示所有线程都会被执行，也是gdb的默认值&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;set scheduler-locking step&lt;/td&gt;&lt;td&gt;单步执行当前线程时，其他线程不会被执行，但此模式下不能执行continue、finish、until命令，一旦执行，那么其他线程都会被唤醒&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;show scheduler-locking&lt;/td&gt;&lt;td&gt;显示当前scheduler-locking的状态&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;thread apply 1 2 command&lt;/td&gt;&lt;td&gt;让线程序号为1和2的线程执行某个gdb命令，其中的command是gdb命令，比如thread apply 1 2 info local，让序号为1和2的线程打印出所有局部变量&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;thread apply all command&lt;/td&gt;&lt;td&gt;command是gdb命令，让所有线程执行某个gdb命令&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4&gt;&lt;span&gt;2. gdb怎么调试多进程&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;gdb调试多进程时最常用的是两个属性：follow-fork-mode和detach-on-fork，分别使用&lt;code&gt;set follow-fork-mode parent|child&lt;/code&gt;和&lt;code&gt;set detach-on-fork on|off&lt;/code&gt;这样的形式来进行设置，一般来讲，这两个命令是联合起来起作用的，下面就介绍一下他们的作用，如下：&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;follow-fork-mode&lt;/th&gt;&lt;th&gt;detach-on-fork&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;parent&lt;/td&gt;&lt;td&gt;on&lt;/td&gt;&lt;td&gt;此种场景是gdb默认场景，表明gdb此时只调试父进程，包括打断点等都只对父进程起作用，子进程就继续运行，此时gdb不控制子进程&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;parent&lt;/td&gt;&lt;td&gt;off&lt;/td&gt;&lt;td&gt;此种场景下gdb同时控制父子进程，父进程可以正常调试，但子进程被gdb设置为暂停状态，不会继续执行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;child&lt;/td&gt;&lt;td&gt;on&lt;/td&gt;&lt;td&gt;此种场景下gdb只控制子进程，gdb的所有命令都只对子进程起作用，父进程会继续运行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;child&lt;/td&gt;&lt;td&gt;off&lt;/td&gt;&lt;td&gt;此种场景下gdb同时控制父子进程，子进程可以正常调试，但父进程被gdb设置为暂停状态，不会继续执行&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;此外还有一些其他调试多进程会用到的命令，如下：&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;gdb命令&lt;/th&gt;&lt;th&gt;作用说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;show follow-fork-mode&lt;/td&gt;&lt;td&gt;显示follow-fork-mode状态&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;show detach-on-fork&lt;/td&gt;&lt;td&gt;显示detach-on-fork状态&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;info inferiors&lt;/td&gt;&lt;td&gt;查询gdb当前可调试的进程&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;inferior&lt;/td&gt;&lt;td&gt;切换调试的进程，其中infer number是info inferiors命令打印出来的进程序号&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;接下来我们使用一个案例来说明上述命令的使用，有如下一段代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;//test.cpp&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; ( fork() &amp;gt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;this is parent\n&quot;&lt;/span&gt;);&lt;br/&gt;            sleep(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;this is son\n&quot;&lt;/span&gt;);&lt;br/&gt;            sleep(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;实际情况下代码肯定不能我这么写哈，要考虑到僵尸进程的产生，我这里只是为了排除其他干扰来说明gdb调试多进程的过程，所以写的很简洁。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;假设这段代码编译后产生的执行文件为&lt;code&gt;test&lt;/code&gt;，我们接着使用gdb对它进行调试，首先使用一下基本的命令，如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;(gdb) show follow-fork-mode&lt;br/&gt;Debugger response to a program call of fork or vfork is &quot;parent&quot;.&lt;br/&gt;(gdb) show detach-on-fork&lt;br/&gt;Whether gdb will detach the child of a fork is on.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;打印处理这两种设置模式的默认值，这个跟我们前面说的这个是gdb默认场景是一致的哈，此时我们分别在父进程和子进程代码处设置断点，然后运行看一下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;(gdb) b test.cpp:11&lt;br/&gt;Breakpoint 1 at 0x40064e: file test.cpp, line 11.&lt;br/&gt;(gdb) b test.cpp:19&lt;br/&gt;Breakpoint 2 at 0x400664: file test.cpp, line 19.&lt;br/&gt;(gdb) r&lt;br/&gt;Starting program: /root/test &lt;br/&gt;this is son&lt;br/&gt;&lt;br/&gt;Breakpoint 1, main () at test.cpp:11&lt;br/&gt;11                printf(&quot;this is parent\n&quot;);&lt;br/&gt;(gdb) this is son&lt;br/&gt;this is son&lt;br/&gt;this is son&lt;br/&gt;this is son&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到只命中了父进程的断点，而子进程依然我行我素的运行。&lt;/p&gt;&lt;p&gt;接着假设我此时只想调试子进程，并且不想父进程继续运行，gdb命令如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;(gdb) set follow-fork-mode child&lt;br/&gt;(gdb) set detach-on-fork off&lt;br/&gt;(gdb) b test.cpp:11&lt;br/&gt;Breakpoint 1 at 0x40064e: file test.cpp, line 11.&lt;br/&gt;(gdb) b test.cpp:19&lt;br/&gt;Breakpoint 2 at 0x400664: file test.cpp, line 19.&lt;br/&gt;(gdb) r&lt;br/&gt;Starting program: /root/test &lt;br/&gt;[New process 29409]&lt;br/&gt;Reading symbols from /root/test...done.&lt;br/&gt;Reading symbols from /usr/lib64/libstdc++.so.6...done.&lt;br/&gt;[Switching to process 29409]&lt;br/&gt;&lt;br/&gt;Thread 2.1 hit Breakpoint 2, main () at test.cpp:19&lt;br/&gt;19                printf(&quot;this is son\n&quot;);&lt;br/&gt;(gdb) c&lt;br/&gt;Continuing.&lt;br/&gt;this is son&lt;br/&gt;&lt;br/&gt;Thread 2.1 hit Breakpoint 2, main () at test.cpp:19&lt;br/&gt;19                printf(&quot;this is son\n&quot;);&lt;br/&gt;(gdb) c&lt;br/&gt;Continuing.&lt;br/&gt;this is son&lt;br/&gt;&lt;br/&gt;Thread 2.1 hit Breakpoint 2, main () at test.cpp:19&lt;br/&gt;19                printf(&quot;this is son\n&quot;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时父子进程都被gdb控制，并且只有子进程会命中断点，父进程被暂停了，所以既没有命中断点也没有继续执行。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;3. gdb怎么调试正在运行中的进程&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;在实际情况中有很多场景，我们需要去调试正在运行中的进程，此时该怎么调试呢，有两种办法：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;gdb&lt;/p&gt;&lt;program&gt;PID或者gdb -p PID，program是进程名，PID是进程在操作系统中的进程号，用ps命令查看即可，两种命令作用是一样的；&lt;/program&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;gdb&lt;/p&gt;&lt;program&gt;以后，在gdb模式下attach PID也可以起到同样的作用，即挂载某个进程到gdb中；&lt;/program&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;上述两种方法进入调试模式后，如果不想继续调试直接在gdb模式下使用detach命令取消gdb挂载的进程即可。&lt;/p&gt;&lt;p&gt;下面用一个案例来说明一下，假设有下面这段代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    {&lt;br/&gt;        i++;&lt;br/&gt;        sleep(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;程序已经运行一段时间了，此时我想知道i的值是多少了，该怎么办呢，首先用ps命令查出进程的ID为29549，然后&lt;code&gt;gdb -p 29549&lt;/code&gt;进入gdb模式，使用如下gdb命令查看即可：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;(gdb) b test.cpp:10&lt;br/&gt;Breakpoint 1 at 0x4005bb: file test.cpp, line 10.&lt;br/&gt;(gdb) c&lt;br/&gt;Continuing.&lt;br/&gt;&lt;br/&gt;Breakpoint 1, main () at test.cpp:10&lt;br/&gt;10            i++;&lt;br/&gt;(gdb) p i&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;1 = 165&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;4. gdb怎么调试生成的core文件&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;core文件一般是产生段错误产生的哈，也就是使用空指针或者有内存越界之类的动作会产生，但要产生core文件也是需要设置的，一般linux下使用ulimit命令即可，比如使用&lt;code&gt;ulimit -c&lt;/code&gt;看下打印的值，如果不是unlimited，那么使用&lt;code&gt;ulimit -c unlimited&lt;/code&gt;设置一下即可，关于ulimit命令的更多使用这里就不多做介绍了。&lt;/p&gt;&lt;p&gt;我的机器现在已经开启了core文件生成的开关，那么现在有这么一段代码，如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; *str = &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;%s\n&quot;&lt;/span&gt;, str);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后执行，果不其然，输出了&lt;code&gt;段错误 (core dumped)&lt;/code&gt;这样的语句，可见是产生了core文件，我这里产生的core文件名为&lt;code&gt;core.29626&lt;/code&gt;，此时我们可以使用&lt;code&gt;gdb &amp;lt;program&amp;gt; core.29626&lt;/code&gt;这样的命令来进入gdb进行调试，如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;(gdb) bt&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;0  0x00000036f2879ba0 &lt;span&gt;in&lt;/span&gt; strlen () from /lib64/libc.so.6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;1  0x00000036f28631cb &lt;span&gt;in&lt;/span&gt; puts () from /lib64/libc.so.6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;2  0x00000000004005c8 &lt;span&gt;in&lt;/span&gt; main () at test.cpp:6&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用bt命令即可查看出错的到底是哪个函数，哪行代码啦。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;5. gdb怎么查看c++中类对象的详细信息&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;假设有这么一段c++代码，如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CPeople&lt;/span&gt;&lt;br/&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; age;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CBigPeople&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; CPeople&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; height;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    CPeople *people = &lt;span&gt;new&lt;/span&gt; CBigPeople;&lt;br/&gt;    &lt;span&gt;delete&lt;/span&gt; people;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们使用gdb查看people所指向的类型，如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;(gdb) p *people&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;2 = {_vptr.CPeople = 0x4008b0 &amp;lt;vtable &lt;span&gt;for&lt;/span&gt; CBigPeople+16&amp;gt;, age = 0}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;很显然默认情况下gdb没能显示出来真实类型，我们打开一个开关，如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;(gdb) set print object on&lt;br/&gt;(gdb) p *people&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;3 = (CBigPeople) {&amp;lt;CPeople&amp;gt; = {_vptr.CPeople = 0x4008b0 &amp;lt;vtable &lt;span&gt;for&lt;/span&gt; CBigPeople+16&amp;gt;, age = 0}, height = 0}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是类型都显示在一行里面，如果是简单类型还好，如果类型很复杂的时候，这个就很难看了，所以我们可以让gdb显示树形结构，如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;(gdb) set print pretty on&lt;br/&gt;(gdb) p *people&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;5 = (CBigPeople) {&lt;/span&gt;&lt;br/&gt;  &amp;lt;CPeople&amp;gt; = {&lt;br/&gt;    _vptr.CPeople = 0x4008c0 &amp;lt;vtable for CBigPeople+16&amp;gt;, &lt;br/&gt;    age = 0&lt;br/&gt;  }, &lt;br/&gt;  members of CBigPeople: &lt;br/&gt;  height = 0&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;6. 小结&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;其实linux下调试gdb真的是个很强大的命令，仔细研究一下，我们会发现，只要我们能想到的功能，gdb真的都能实现，同时我们要善用gdb的help命令，它可以打印出所有的gdb命令和它的作用，如果你不想打印那么多，你可以只打印某个单一命令或者某一类命令，比如：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;(gdb) help shell  #打印出gdb中shell命令的作用，它可以让我们直接在gdb下执行shell命令&lt;br/&gt;Execute the rest of the line as a shell command.&lt;br/&gt;With no arguments, run an inferior shell.&lt;br/&gt;(gdb) help info  #打印出gdb中info开头的所有命令&lt;br/&gt;Generic command for showing things about the program being debugged.&lt;br/&gt;&lt;br/&gt;List of info subcommands:&lt;br/&gt;&lt;br/&gt;info address -- Describe where symbol SYM is stored&lt;br/&gt;info all-registers -- List of all registers and their contents&lt;br/&gt;info args -- Argument variables of current stack frame&lt;br/&gt;info auto-load -- Print current status of auto-loaded files&lt;br/&gt;info auxv -- Display the inferior&#x27;s auxiliary vector&lt;br/&gt;info bookmarks -- Status of user-settable bookmarks&lt;br/&gt;info breakpoints -- Status of specified breakpoints (all user-settable breakpoints if no argument)&lt;br/&gt;info checkpoints -- IDs of currently known checkpoints&lt;br/&gt;info classes -- All Objective-C classes&lt;br/&gt;info common -- Print out the values contained in a Fortran COMMON block&lt;br/&gt;info copying -- Conditions for redistributing copies of GDB&lt;br/&gt;info dcache -- Print information on the dcache performance&lt;br/&gt;info display -- Expressions to display when program stops&lt;br/&gt;......  #篇幅有限，后续省略了&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;好了，本篇文章就为大家介绍到这里，觉得内容对你有用的话，记得顺手点个在看哦~&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4b840835fc196fdbf95a4252390e7e2e</guid>
<title>作为程序员，遇到问题时你的解决手段是什么？</title>
<link>https://toutiao.io/k/m768nz2</link>
<content:encoded>&lt;div&gt;&lt;body id=&quot;readabilityBody&quot;&gt;
    


    &lt;p id=&quot;ReactApp&quot;/&gt;
    
    
    
    
    
    
    
    
    

    
    




    
    
    
      
    
    
      
    
    
    
      
      
      
      
      
      
      
      
    
    
    
  &lt;/body&gt;
&lt;/div&gt;</content:encoded>
</item>
</channel></rss>