<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b93b512443ed8f91b10007c6fa41f47e</guid>
<title>秋天的第一份 IT 技术周刊 | 码农周刊第 320 期</title>
<link>https://toutiao.io/k/9ew44gv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;秋天的第一份 IT 技术周刊 | 码农周刊第 320 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第320期（2020-09-29）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3200&quot; target=&quot;_blank&quot;&gt;秋天的第一份 IT 技术周刊，请查收！&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3200&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_320.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;思考和实践&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;由 JavaScript 之父 Brendan Eich 与 ES6 规范首席作者 Allen Wirfs-Brock 联合编写，详细记载和解读了自 1995 年语言诞生到 2015 年 ES6 规范制定为止，共计 20 年的 JavaScript 语言演化经历。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;支持 mp4, flv, m3u8 及 rtmp 协议的直播，支持移动端，PC 端。&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;利器&lt;/p&gt;
        
        &lt;p&gt;实打实的干货&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;容易踩的坑&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;细致分析&lt;/p&gt;
        
        &lt;p&gt;方案和思路&lt;/p&gt;
        
        &lt;p&gt;一些实践和工具&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;报告详情&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;深入探讨&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;java相关技术分享&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 444692 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 444414 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 435415 即可&lt;/p&gt;
        
        &lt;p&gt;不定期更新一些机器学习算法，方便大家浏览，然后一起学习，一起进步&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 104739 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 99181 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;本书深入地讲解了 Go 语言常见特性的内部机制和实现方式，大部分内容源自对 Go 语言源码的分析，并从中提炼出实现原理。欢迎到&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;兑换阅读。&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;值得推荐&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;无代码开发平台&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>03b97af5dc01145e9bb4be3e19a83d7c</guid>
<title>[推荐] 大写的服，看完这篇你还不懂 RocketMQ 算我输</title>
<link>https://toutiao.io/k/rhwgf1q</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;目录&lt;/span&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;RocketMQ介绍&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RocketMQ概念&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么要用RocketMQ？&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;异步解耦&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;削峰填谷&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分布式事务最终一致性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据分发&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;RocketMQ架构&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RocketMQ消息类型&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;普通消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;顺序消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;定时消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务消息&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;最佳实践&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;消息重试&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息过滤&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费幂等&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;本地事务消息封装&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;参考代码&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;RocketMQ 介绍&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Apache RocketMQ 是一款 低延迟、高并发、高可用、高可靠的分布式消息中间件。消息队列 RocketMQ 可为分布式应用系统提供异步解耦和削峰填谷的能力，同时也具备互联网应用所需的海量消息堆积、高吞吐、可靠重试等特性。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;RocketMQ 概念&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Topic：消息主题，用于将一类的消息进行归类，比如订单主题，就是所有订单相关的消息都可以由这个主题去承载，生产者向这个主题发送消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生产者：负责生产消息并发送消息到 Topic 的角色。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费者：负责从 Topic 接收并消费消息 的角色。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息：生产者向 Topic 发送的内容，会被消费者消费。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息属性：生产者发送的时候可以为消息自定义一些业务相关的属性，比如 Message Key 和 Tag 等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Group：一类生产者或消费者，这类生产者或消费者通常生产或消费同一类消息，且消息发布或订阅的逻辑一致。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么要使用 RocketMQ？&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;异步解耦&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着微服务架构的流行，服务之间的关系梳理非常重要。异步解耦可以降低服务之间的耦合程度，同时也能提高服务的吞吐量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用异步解耦的业务场景非常多，因为每个行业的业务都会不太一样，以一些比较通用的业务来说明相信大家都能理解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如电商行业的下单业务场景，以最简单的下单流程来说，下单流程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;锁库存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建订单&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户支付&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;扣减库存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;给用户发送购买短信通知&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;给用户增加积分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通知商家发货&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以下单成功后，用户进行支付，支付完成会有个逻辑叫支付回调，在回调里面需要去做一些业务逻辑。首先来看下同步处理需要花费的时间，如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8276923076923077&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WRLYshvT39yRB3l2e8jw3eweF6730wFCZ4PAWf4tzhgkR4AoJLYtF9szlOg6eWjUD3Gxtzc9ZTdT8Bc1udZ4vA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1300&quot;/&gt;&lt;figcaption&gt;同步流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的下单流程从 3 到 5 都是可以采用异步流程进行处理，对于用户来说，支付完成后他就不需要关注后面的流程了。后台慢慢处理就行了，这样就能简化三个步骤，提高回调的处理时间。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7907692307692308&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WRLYshvT39yRB3l2e8jw3eweF6730wFCibkpExnhLribAMiak4dBvr6ZwlSc5BunBmZgGYK8KM2vBd6vQl9TYurJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1300&quot;/&gt;&lt;figcaption&gt;异步流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;削峰填谷&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;削峰填谷指的是在大流量的冲击下，利用 RocketMQ 可以抗住瞬时的大流量，保护系统的稳定性，提升用户体验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在电商行业，最常见的流量冲击就是秒杀活动了，利用 RocketMQ 来实现一个完整的秒杀业务还是与很多需要做的工作，不在本文的范围内，后面有机会可以单独跟大家聊聊。想告诉大家的是像诸如此类的场景可以利用 RocketMQ 来扛住高并发，&lt;strong&gt;前提是业务场景支持异步处理&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.39337175792507206&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WRLYshvT39yRB3l2e8jw3eweF6730wFCtw9PS4iaBRc64SI1EKGgicpyg8oaPftjtlfQrUnKqae77iaLkuC3K0pRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1388&quot;/&gt;&lt;figcaption&gt;削峰填谷&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分布式事务最终一致性&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，分布式事务有 2PC，TCC，最终一致性等方案。其中使用消息队列来做最终一致性方案是比较常用的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在电商的业务场景中，交易相关的核心业务一定要确保数据的一致性。通过引入消息队列 RocketMQ 版的分布式事务，既可以实现系统之间的解耦，又可以保证最终的数据一致性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据分发&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据分发指的是可以将原始数据分发到多个需要使用这份数据的系统中，实现数据异构的需求。最常见的有将数据分发到 ES, Redis 中为业务提供搜索，缓存等服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了手动通过消息机制进行数据分发，还可以订阅 Mysql 的 binlog 来分发，在分发这个场景，需要使用 RocketMQ 的顺序消息来保证数据的一致性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6413662239089184&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WRLYshvT39yRB3l2e8jw3eweF6730wFCMEN47LYbjXf1QcEzBA3HV04Rv1xAt08k1kOeuYUSbgVY894liavo3sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1054&quot;/&gt;&lt;figcaption&gt;数据分发&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;RocketMQ 架构&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5866523143164694&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WRLYshvT39yRB3l2e8jw3eweF6730wFCUsRaIHjtKib9LjMYwXzaibiaFgIeibvH5MbEMNoLgCqNyibWtAusRyOpyfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;929&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图片来源阿里云官方文档&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Name Server：是一个几乎无状态节点，可集群部署，在消息队列 RocketMQ 版中提供命名服务，更新和发现 Broker 服务。就是一个注册中心。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Broker：消息中转角色，负责存储消息，转发消息。分为 Master Broker 和 Slave Broker，一个 Master Broker 可以对应多个 Slave Broker，但是一个 Slave Broker 只能对应一个 Master Broker。Broker 启动后需要完成一次将自己注册至 Name Server 的操作；随后每隔 30s 定期向 Name Server 上报 Topic 路由信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生产者：与 Name Server 集群中的其中一个节点（随机）建立长链接（Keep-alive），定期从 Name Server 读取 Topic 路由信息，并向提供 Topic 服务的 Master Broker 建立长链接，且定时向 Master Broker 发送心跳。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费者：与 Name Server 集群中的其中一个节点（随机）建立长连接，定期从 Name Server 拉取 Topic 路由信息，并向提供 Topic 服务的 Master Broker、Slave Broker 建立长连接，且定时向 Master Broker、Slave Broker 发送心跳。Consumer 既可以从 Master Broker 订阅消息，也可以从 Slave Broker 订阅消息，订阅规则由 Broker 配置决定。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;RocketMQ 消息类型&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocketMQ 支持丰富的消息类型，可以满足多场景的业务需求。不同的消息有不同的应用场景，下面为大家介绍常用的四种消息类型。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;普通消息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;普通消息是指 RocketMQ 中无特性的消息。当没有特殊的业务场景，使用普通消息就够了。如果有特殊的场景，就可以使用特殊的消息类型，比如顺序，事务等。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;同步发送&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同步发送：消息发送方发送出去一条消息，会同步得到服务端返回的结果。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;异步发送&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步发送：消息发送方发出去一条消息，不用等待服务端返回结果，可以接着发送下一条消息。发送方可以通过回调接口接收服务端响应，并处理响应结果。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;单向发送&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单向发送：消息发送方只负责发送消息，发送出去后就不管了，这种方式发送速度非常快，存在丢失消息的风险。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;顺序消息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顺序消息是指生产者按照一定的先后顺序发布消息；消费者按照既定的先后顺序订阅消息，即先发布的消息一定会先被消费者接收到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如数据分发的场景，如果我们订阅了 Mysql 的 binlog 来进行数据异构。消息要是没有顺序，就会出现数据错乱问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如新增一条 id=1 的数据，然后马上删除。这样就产生了两条消息。正常的消费顺序是先新增，然后删除，此时数据是没有的。如果消息没有顺序，删除的先被消费了，然后消费新增的，此时数据还在，没被删除掉，就会导致不一致。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;定时消息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定时消息是指消息具备定时发送的功能，当消息发送到服务端后，不会立即投递给消费者。而是要等到消息指定的时间后才会投递给消费者进行消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;延迟消息也就是定时消息，定时消息是定在某个时间点进行发送，比如 2020-11-11 12:00:00 发送。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;延迟消息一般是在当前发送时间的基础上延迟多久进行发送，比如当前时间是 2020-09-10 12:00:00，延迟 10 分钟，那么消息发送成功后将在 2020-09-10 12:10:00 进行投递给消费者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定时消息可以在订单超时未支付自动取消等场景使用。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;事务消息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocketMQ 提供类似 X/Open XA 的分布式事务功能，通过 RocketMQ 事务消息能达到分布式事务的最终一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;交互流程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.30058774139378674&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WRLYshvT39yRB3l2e8jw3eweF6730wFCIHfAO6ics1CYRahssJcP0kPvD72QyicQenL1N5H6nobXTXzFdzBnTBkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1191&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图片来源阿里云官方文档&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;发送方首先发送半事务消息到 RocketMQ 服务端。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;RocketMQ 服务端接收到消息，然后将消息持久化成功之后，向发送方返回 Ack 确认消息已经发送成功，此时消息为半事务消息，不会投递给消费方。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;收到半事务消息的 Ack 后，发送方开始执行本地事务逻辑。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;发送方根据本地事务执行结果向服务端提交二次确认，如果本地事务执行成则进行消息的 Commit，如果执行失败则进行消息的 Rollback，服务端收到 Commit 状态则将半事务消息标记为可投递，消费方最终将收到该消息；服务端收到 Rollback 状态则删除半事务消息，消费方将不会收到该消息。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果出现意外情况，步骤 4 没有进行消息的二次确认，等待固定时间后服务端将对该消息发起消息回查。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。发送方根据检查得到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤 4 对半事务消息进行操作。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最佳实践&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消息重试&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息在消费方消费失败后，RocketMQ 服务端会重新进行消息的投递，知道消费者成功消费消息，当然重试有次数限制，默认 16 次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息重试在一定程度上保证了消息不丢失，通过重试来达到最终被消费的目的。需要注意的是消费者在消费的时候一定要等本地业务成功后才能进行 ACK(消费确认)，不然就会出现消费失败，但是已经 ACK，消息将不会重复投递。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果采取异步消费的方式，需要进行异步转同步，等异步操作完才进行 ACK，具体可以参考我之前写的一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMDY0Nzk2Mw==&amp;amp;mid=2650321872&amp;amp;idx=1&amp;amp;sn=bdf6dd2f80e7c8715294102312358b00&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;https://mp.weixin.qq.com/s/Bbh1GDpmkLhZhw5f0POJ2A&lt;/a&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后需要做好对应的监控，如果重试了 4，5 次还是失败的，基本上后面重试也是失败的。这个时候需要让开发人员知道，该人工处理的就人工介入。或者直接监控死信队列。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消息过滤&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息主题，一般用于一类消息的统一分类。比如订单主题，但是订单下的消息会分为很多种。比如创建订单，取消订单等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同类型的消息有不同的业务处理，我们可以统一定义消息格式，然后通过一个字段去区分消息类型来做不同的业务逻辑。不好的点在于所有消息都会推送到消费方，不能按需消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 RocketMQ 中可以给消息指定 tag，通过 tag 来区分消息类型。消费者可以根据 Tag 在 RocketMQ 服务端完成消息过滤，以确保消费者最终只消费到其关注的消息类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我曾经遇到过一个 tag 没有正确使用的方式，只有一个 MQ 实例，用 tag 来区分环境。所有消息都在一个主题中，测试环境消费测试环境的 tag，线上消费线上的 tag。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式的问题在于消息没做隔离，线上线下的消息都在一起。另一个就是 tag 被固定成了环境的区分，无法用于消息类型场景，导致只能建多个 topic 来承载多个业务消息类型。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WRLYshvT39yRB3l2e8jw3eweF6730wFCqictcwKk1wCSsicMytY1SyYdrwUzYBnZO8lZunLpMYntOrp20I8JiacibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1224&quot;/&gt;&lt;figcaption&gt;消息过滤&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消费模式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocketMQ 消费模式有两种，集群消费和广播消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;集群消费：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7480314960629921&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WRLYshvT39yRB3l2e8jw3eweF6730wFCSUFMHKtFJOuGHnILtHCM9bvbWVE7Sz86rH6ptibA8aNfQTvFTPOLfng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1016&quot;/&gt;&lt;figcaption&gt;集群消费&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者部署了多个实例我们称之为一个集群，集群消费只会被其中的某一个实例进行消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;适合大部分的业务场景，大部分的场景我们的消息只允许被消费一次，而且只能有一个消费者去消费，比如支付回调场景，如果一个消息被多个实例同时消费，那么就会出现同时去修改订单状态，同时去扣减库存的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;广播消费：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5386819484240688&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WRLYshvT39yRB3l2e8jw3eweF6730wFCr341ibDwv1uhRQ2K2cNs6jaKZthbLlCaYtcBjYLSczwfCEafZkmU3Yg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1396&quot;/&gt;&lt;figcaption&gt;广播消费&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;广播消费会让集群中每个实例都消费一次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们使用了本地缓存，当数据变更的时候，我们需要刷新每个节点本地的缓存，所以每个节点都需要收到消息。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消费幂等&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幂等问题，无论是在 API 请求场景还是在消息消费场景，都会遇到。一条消息不能重复消费多次这个肯定是要保证的，因为我们不能保证消息发送方不发送多次，也不能保证消息不重复投递。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocketMQ 的 Exactly-Once 投递语义，就是用于解决幂等问题。Exactly-Once 是指发送到消息系统的消息只能被消费端处理且仅处理一次，即使生产端重试消息发送导致某消息重复投递，该消息在消费端也只被消费一次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最佳的幂等处理方式还是需要有一个唯一的业务标识，虽然每条消息都有 MessageId，但是不建议用 MessageId 来做幂等判断，在发送消息的时候，可以为每条消息设置一个 MessageKey，这个 MessageKey 就可以用来做业务的唯一标识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于幂等怎么处理，就不细讲了。可以参考我之前写的一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMDY0Nzk2Mw==&amp;amp;mid=2650323102&amp;amp;idx=1&amp;amp;sn=cb6c190ae15a4fe4855782b6fc82fd8a&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;https://mp.weixin.qq.com/s/9fhqnbeXPz7-7x0Eadd8DA&lt;/a&gt;，通用的幂等实现方案。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3988684582743989&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WRLYshvT39yRB3l2e8jw3eweF6730wFCMJC8Mzo0e4fqXvyFF155T27svDzCica0aoWe5zeBNCEGCbDc0icNSDqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1414&quot;/&gt;&lt;figcaption&gt;消费幂等&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;本地事务消息封装&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面介绍了事务消息，RocketMQ 的事务消息采用了二阶段提交的方式。并且结合了消息反查的机制来确保最终一致性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从使用层面来说，每个业务场景都要去实现一个反查的逻辑，有点烦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面介绍另一种经常被使用的方式，就是本地事务消息。本地消息表这个方案最初是 ebay 提出的，本地事务消息需要在服务对应的数据库中创建一个消息表，发送消息的时候不是真正的将消息发送给 MQ，而是往消息表中插入一条消息数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;插入的动作跟本地的业务逻辑是同一个事务，如果本地事务执行成功，消息才会落表成功，才会发送给 MQ, 本地事务失败，消息数据回滚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后需要有一个专门的程序去拉取消息表中未发送的消息投递给 MQ，如果投递失败，可以一直重试，直到成功或者人工介入。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.28541666666666665&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WRLYshvT39yRB3l2e8jw3eweF6730wFCaMoqMpSqOlSP1cBwHVG8n6xGGnuLKP6g4A3gGPPv6yPNkGwSf1NDTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;figcaption&gt;本地事务消息&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息写到消息表，然后会一直给 MQ 发送，这个步骤没问题。如果 MQ 收到消息后，消息还在 PageCache 中的时候，Broker 宕机了，这个时候是会出现消息丢失。当然你也可以使用同步刷盘等方式来避免丢失。假如我们就是异步刷盘，有办法保证消息不丢失吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们提到，RocketMQ 的事务消息会有回查的机制，消息表的方式，也需要有一个机制来保证消息被消费了，否则就需要不断的重试去发送消息，直到消息被消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在消息表中需要有一个字段来标识当前这条消息的状态，比如 未发送，已发送，已消费。当消息还是未发送的时候就会被发送到 MQ, 如果发送成功了，状态就是已发送。但是过了几分钟，状态还是已发送，这个时候就要去做一些动作了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个场景下，有可能是消费者跟不上生产的速度，消息堆积了，导致消息一直没被消费。另一种可能就是消息是不是丢失了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以获取对应的消息堆积数据来判断是否消息堆积了，如果不是就重新发送消息给 MQ，知道消息被消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;问题是消息被消费了，我怎么知道？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像我是用的云服务，是有对应的 Open API 可以直接查询消息轨迹。开源的应该也有，没有仔细去研究，跟商业版应该差不多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据消息轨迹就可以知道消息有没有被消费，到此为止流程结束。消息发送给 MQ 如果失败会重试，消息如果长时间没消费，也会重新发送，即使最后进入了死信队列，也可以通过死信队列的监控来人工干预，一定会是最终一致性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跟自带的事务消息比，本地消息表的方式不需要实现回查逻辑，但是要增加消息表，同时也要配套各种发送，检查等逻辑，也挺麻烦了。特别是当消息量大的时候，如何快速的将消息表中的消息发送出去，也需要做很多处理，简单的查表轮询在量大的情况下不太适用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两种方式都可以使用，能实现我们要的目的即可。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考代码&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地事务消息相关的代码可以微信搜索「&lt;strong&gt;猿天地&lt;/strong&gt;」，回复关键字「kitty」获取即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;码字不易，可以的话来个三连击，感谢！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;关于作者&lt;/strong&gt;：尹吉欢，简单的技术爱好者，《Spring Cloud 微服务-全栈技术与案例解析》, 《Spring Cloud 微服务 入门 实战与进阶》作者, 公众号&lt;strong&gt;猿天地&lt;/strong&gt;发起人。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我整理了一份很全的学习资料，感兴趣的可以微信搜索「&lt;strong&gt;猿天地&lt;/strong&gt;」，回复关键字 「&lt;strong&gt;学习资料&lt;/strong&gt;」获取我整理好了的 Spring Cloud，Spring Cloud Alibaba，Sharding-JDBC 分库分表，任务调度框架 XXL-JOB，MongoDB，爬虫等相关资料。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>43d424946a9241f8fce048597b848287</guid>
<title>[推荐] 解密 Go 协程的栈内存管理</title>
<link>https://toutiao.io/k/fkrobd3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用程序的内存会分成堆区（Heap）和栈区（Stack）两个部分，&lt;strong&gt;程序在运行期间可以主动从堆区申请内存空间，这些内存由内存分配器分配并由垃圾收集器负责回收&lt;/strong&gt;。&lt;strong&gt;栈区的内存由编译器自动进行分配和释放，栈区中存储着函数的参数以及局部变量，它们会随着函数的创建而创建，函数的返回而销毁&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;网管碎碎念：&lt;/strong&gt;堆和栈都是编程语言里的虚拟概念，并不是说在物理内存上有堆和栈之分，两者的主要区别是栈是每个线程或者协程独立拥有的，从栈上分配内存时不需要加锁。而整个程序在运行时只有一个堆，从堆中分配内存时需要加锁防止多个线程造成冲突，同时回收堆上的内存块时还需要运行可达性分析、引用计数等算法来决定内存块是否能被回收，所以从分配和回收内存的方面来看栈内存效率更高。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;Go&lt;/code&gt;应用程序运行时，每个&lt;code&gt;goroutine&lt;/code&gt;都维护着一个自己的栈区，这个栈区只能自己使用不能被其他&lt;code&gt;goroutine&lt;/code&gt;使用。&lt;strong&gt;栈区的初始大小是2KB&lt;/strong&gt;（比x86_64架构下线程的默认栈2M要小很多），在&lt;code&gt;goroutine&lt;/code&gt;运行的时候栈区会按照需要增长和收缩，占用的内存最大限制的默认值在64位系统上是1GB。栈大小的初始值和上限这部分的设置都可以在&lt;code&gt;Go&lt;/code&gt;的源码&lt;code&gt;runtime/stack.go&lt;/code&gt;里找到：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// rumtime.stack.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// The minimum size of stack used by Go code&lt;/span&gt;&lt;br/&gt;_StackMin = &lt;span&gt;2048&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; maxstacksize &lt;span&gt;uintptr&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;20&lt;/span&gt; &lt;span&gt;// enough until runtime.main sets it for real&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实栈内存空间、结构和初始大小在最开始并不是2KB，也是经过了几个版本的更迭&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;v1.0 ~ v1.1 — 最小栈内存空间为 4KB；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;v1.2 — 将最小栈内存提升到了 8KB；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;v1.3 — 使用&lt;strong&gt;连续栈&lt;/strong&gt;替换之前版本的分段栈；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;v1.4 — 将最小栈内存降低到了 2KB；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分段栈和连续栈&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;分段栈&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 1.3 版本前使用的栈结构是分段栈，随着&lt;code&gt;goroutine&lt;/code&gt; 调用的函数层级的深入或者局部变量需要的越来越多时，运行时会调用 &lt;code&gt;runtime.morestack&lt;/code&gt; 和 &lt;code&gt;runtime.newstack&lt;/code&gt;创建一个新的栈空间，这些栈空间是不连续的，但是当前 &lt;code&gt;goroutine&lt;/code&gt; 的多个栈空间会以双向链表的形式串联起来，运行时会通过指针找到连续的栈片段：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9885931558935361&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4FKriblLnWa6aXcpXyuysvWWo5VhvVBial7Ticl7855OhSCD9dgMp1qzyibJ1DWs0QicRR97icAU7I134w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1052&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分段栈虽然能够按需为当前 &lt;code&gt;goroutine&lt;/code&gt; 分配内存并且及时减少内存的占用，但是它也存在一个比较大的问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果当前 &lt;code&gt;goroutine&lt;/code&gt; 的栈几乎充满，那么任意的函数调用都会触发栈的扩容，当函数返回后又会触发栈的收缩，如果在一个循环中调用函数，栈的分配和释放就会造成巨大的额外开销，这被称为热分裂问题（Hot split）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，Go在1.2版本的时候不得不将栈的初始化内存从4KB增大到了8KB。后来把采用连续栈结构后，又把初始栈大小减小到了2KB。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;连续栈&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;连续栈可以解决分段栈中存在的两个问题，其核心原理就是每当程序的栈空间不足时，初始化一片比旧栈大两倍的新栈并将原栈中的所有值都迁移到新的栈中，新的局部变量或者函数调用就有了充足的内存空间。使用连续栈机制时，栈空间不足导致的扩容会经历以下几个步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;调用用&lt;code&gt;runtime.newstack&lt;/code&gt;在内存空间中分配更大的栈内存空间；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用&lt;code&gt;runtime.copystack&lt;/code&gt;将旧栈中的所有内容复制到新的栈中；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;将指向旧栈对应变量的指针重新指向新栈&lt;/strong&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用&lt;code&gt;runtime.stackfree&lt;/code&gt;销毁并回收旧栈的内存空间；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6382730455075846&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4FKriblLnWa6aXcpXyuysvWbfJaj1C2qAyjuLXK51PkV6PPIRWuyRFUgL60Pb6c9a18MsrhmEs6wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1714&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;copystack&lt;/code&gt;会把旧栈里的所有内容拷贝到新栈里然后调整所有指向旧栈的变量的指针指向到新栈， 我们可以用下面这个程序验证下，栈扩容后同一个变量的内存地址会发生变化。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; x [&lt;span&gt;10&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;br/&gt; &lt;span&gt;println&lt;/span&gt;(&amp;amp;x)&lt;br/&gt; a(x)&lt;br/&gt; &lt;span&gt;println&lt;/span&gt;(&amp;amp;x)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//go:noinline&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;&lt;span&gt;(x [10]&lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;println&lt;/span&gt;(&lt;span&gt;`func a`&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; y [&lt;span&gt;100&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;br/&gt; b(y)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//go:noinline&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;b&lt;/span&gt;&lt;span&gt;(x [100]&lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;println&lt;/span&gt;(&lt;span&gt;`func b`&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; y [&lt;span&gt;1000&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;br/&gt; c(y)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//go:noinline&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;c&lt;/span&gt;&lt;span&gt;(x [1000]&lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;println&lt;/span&gt;(&lt;span&gt;`func c`&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序的输出可以看到在栈扩容前后，变量&lt;code&gt;x&lt;/code&gt;的内存地址的变化：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;0xc000030738&lt;br/&gt;...&lt;br/&gt;...&lt;br/&gt;0xc000081f38&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;栈区的内存管理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面说了每个&lt;code&gt;goroutine&lt;/code&gt;都维护着自己的栈区，栈结构是连续栈，是一块连续的内存，在&lt;code&gt;goroutine&lt;/code&gt;的类型定义的源码里我们可以找到标记着栈区边界的&lt;code&gt;stack&lt;/code&gt;信息，&lt;code&gt;stack&lt;/code&gt;里记录着栈区边界的高位内存地址和低位内存地址：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; g &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; stack       stack&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; stack &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; lo &lt;span&gt;uintptr&lt;/span&gt;&lt;br/&gt; hi &lt;span&gt;uintptr&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;全局栈缓存&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;栈空间在运行时中包含两个重要的全局变量，分别是 &lt;code&gt;runtime.stackpool&lt;/code&gt; 和&lt;code&gt;runtime.stackLarge&lt;/code&gt;，这两个变量分别表示全局的栈缓存和大栈缓存，前者可以分配小于 32KB 的内存，后者用来分配大于 32KB 的栈空间：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;// Number of orders that get caching. Order 0 is FixedStack&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// and each successive order is twice as large.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// We want to cache 2KB, 4KB, 8KB, and 16KB stacks. Larger stacks&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// will be allocated directly.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// Since FixedStack is different on different systems, we&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// must vary NumStackOrders to keep the same maximum cached size.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//   OS               | FixedStack | NumStackOrders&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//   -----------------+------------+---------------&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//   linux/darwin/bsd | 2KB        | 4&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//   windows/32       | 4KB        | 3&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//   windows/64       | 8KB        | 2&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//   plan9            | 4KB        | 3&lt;/span&gt;&lt;br/&gt;_NumStackOrders = &lt;span&gt;4&lt;/span&gt; - sys.PtrSize/&lt;span&gt;4&lt;/span&gt;*sys.GoosWindows - &lt;span&gt;1&lt;/span&gt;*sys.GoosPlan9&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; stackpool [_NumStackOrders]mSpanList&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; stackpoolItem &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; mu   mutex&lt;br/&gt; span mSpanList&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; stackLarge &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; lock mutex&lt;br/&gt; free [heapAddrBits - pageShift]mSpanList&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//go:notinheap&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; mSpanList &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; first *mspan &lt;span&gt;// first span in list, or nil if none&lt;/span&gt;&lt;br/&gt; last  *mspan &lt;span&gt;// last span in list, or nil if none&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到这两个用于分配空间的全局变量都与内存管理单元 &lt;code&gt;runtime.mspan&lt;/code&gt; 有关，所以我们栈内容的申请也是跟前面文章里的一样，先去当前线程的对应尺寸的&lt;code&gt;mcache&lt;/code&gt;里去申请，不够的时候&lt;code&gt;mache&lt;/code&gt;会从全局的&lt;code&gt;mcental&lt;/code&gt;里取内存等等，想了解这部分具体细节的同学可以参考前面的文章&lt;strong&gt;《&lt;/strong&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247485736&amp;amp;idx=1&amp;amp;sn=921a9dfe3d638074b68a4fd072ea3cb9&amp;amp;chksm=fa80d8bfcdf751a948ea49ee620ca9d88ff0a62b4ad4e3a53321fee6813b8f90098fd72f7b11&amp;amp;token=401640573&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;图解Go内存管理器的内存分配策略&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;》&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实从调度器和内存分配的角度来看，如果运行时只使用全局变量来分配内存的话，势必会造成线程之间的锁竞争进而影响程序的执行效率，栈内存由于与线程关系比较密切，所以在每一个线程缓存 &lt;code&gt;runtime.mcache&lt;/code&gt; 中都加入了栈缓存减少锁竞争影响。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; mcache &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;  ...&lt;br/&gt;  alloc [numSpanClasses]*mspan&lt;br/&gt;  &lt;br/&gt; stackcache [_NumStackOrders]stackfreelist&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; stackfreelist &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; list gclinkptr&lt;br/&gt; size &lt;span&gt;uintptr&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;栈扩容&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译器会为函数调用插入运行时检查&lt;code&gt;runtime.morestack&lt;/code&gt;，它会在几乎所有的函数调用之前检查当前&lt;code&gt;goroutine&lt;/code&gt; 的栈内存是否充足，如果当前栈需要扩容，会调用&lt;code&gt;runtime.newstack&lt;/code&gt; 创建新的栈：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;newstack&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   ......&lt;br/&gt;   &lt;span&gt;// Allocate a bigger segment and move the stack.&lt;/span&gt;&lt;br/&gt;   oldsize := gp.stack.hi - gp.stack.lo&lt;br/&gt;   newsize := oldsize * &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; newsize &amp;gt; maxstacksize {&lt;br/&gt;       &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;runtime: goroutine stack exceeds &quot;&lt;/span&gt;, maxstacksize, &lt;span&gt;&quot;-byte limit\n&quot;&lt;/span&gt;)&lt;br/&gt;      throw(&lt;span&gt;&quot;stack overflow&quot;&lt;/span&gt;)&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// The goroutine must be executing in order to call newstack,&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// so it must be Grunning (or Gscanrunning).&lt;/span&gt;&lt;br/&gt;   casgstatus(gp, _Grunning, _Gcopystack)&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// The concurrent GC will not scan the stack while we are doing the copy since&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// the gp is in a Gcopystack status.&lt;/span&gt;&lt;br/&gt;   copystack(gp, newsize, &lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; stackDebug &amp;gt;= &lt;span&gt;1&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;stack grow done\n&quot;&lt;/span&gt;)&lt;br/&gt;   }&lt;br/&gt;   casgstatus(gp, _Gcopystack, _Grunning)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;旧栈的大小是通过我们上面说的保存在&lt;code&gt;goroutine&lt;/code&gt;中的&lt;code&gt;stack&lt;/code&gt;信息里记录的栈区内存边界计算出来的，然后用旧栈两倍的大小创建新栈，创建前会检查是新栈的大小是否超过了单个栈的内存上限。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;   oldsize := gp.stack.hi - gp.stack.lo&lt;br/&gt;   newsize := oldsize * &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; newsize &amp;gt; maxstacksize {&lt;br/&gt;       &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;runtime: goroutine stack exceeds &quot;&lt;/span&gt;, maxstacksize, &lt;span&gt;&quot;-byte limit\n&quot;&lt;/span&gt;)&lt;br/&gt;      throw(&lt;span&gt;&quot;stack overflow&quot;&lt;/span&gt;)&lt;br/&gt;   }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果目标栈的大小没有超出程序的限制，会将 &lt;code&gt;goroutine&lt;/code&gt; 切换至 &lt;code&gt;_Gcopystack&lt;/code&gt; 状态并调用 &lt;code&gt;runtime.copystack&lt;/code&gt; 开始栈的拷贝，在拷贝栈的内存之前，运行时会先通过&lt;code&gt;runtime.stackalloc&lt;/code&gt; 函数分配新的栈空间：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;copystack&lt;/span&gt;&lt;span&gt;(gp *g, newsize &lt;span&gt;uintptr&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; old := gp.stack&lt;br/&gt; used := old.hi - gp.sched.sp&lt;br/&gt;  &lt;span&gt;// 创建新栈&lt;/span&gt;&lt;br/&gt; &lt;span&gt;new&lt;/span&gt; := stackalloc(&lt;span&gt;uint32&lt;/span&gt;(newsize))&lt;br/&gt; ...&lt;br/&gt;  &lt;span&gt;// 把旧栈的内容拷贝至新栈&lt;/span&gt;&lt;br/&gt; memmove(unsafe.Pointer(&lt;span&gt;new&lt;/span&gt;.hi-ncopy), unsafe.Pointer(old.hi-ncopy), ncopy)&lt;br/&gt;  ...&lt;br/&gt;  &lt;span&gt;// 调整指针&lt;/span&gt;&lt;br/&gt;  adjustctxt(gp, &amp;amp;adjinfo)&lt;br/&gt;  &lt;span&gt;// groutine里记录新栈的边界&lt;/span&gt;&lt;br/&gt;  gp.stack = &lt;span&gt;new&lt;/span&gt;&lt;br/&gt;  ...&lt;br/&gt;  &lt;span&gt;// 释放旧栈&lt;/span&gt;&lt;br/&gt;  stackfree(old)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新栈的初始化和数据的复制是一个比较简单的过程，整个过程中最复杂的地方是将指向源栈中内存的指针调整为指向新的栈，这一步完成后就会释放掉旧栈的内存空间了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过修改一下源码文件&lt;code&gt;runtime.stack.go&lt;/code&gt;，把常量&lt;code&gt;stackDebug&lt;/code&gt;的值修改为1，使用命令&lt;strong&gt;go build -gcflags -S main.go&lt;/strong&gt; 运行文章最开始的那个例子，观察栈的初始化和扩容过程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;stackalloc 2048&lt;br/&gt;stackcacherefill order=0&lt;br/&gt;  allocated 0xc000030000&lt;br/&gt;...&lt;br/&gt;copystack gp=0xc000000180 [0xc000030000 0xc0000306e0 0xc000030800] -&amp;gt; [0xc00005c000 0xc00005cee0 0xc00005d000]/4096&lt;br/&gt;stackfree 0xc000030000 2048&lt;br/&gt;stack grow done&lt;br/&gt;...&lt;br/&gt;copystack gp=0xc000000180 [0xc00005c000 0xc00005c890 0xc00005d000] -&amp;gt; [0xc000064000 0xc000065890 0xc000066000]/8192&lt;br/&gt;stackfree 0xc00005c000 4096&lt;br/&gt;stack grow done&lt;br/&gt;...&lt;br/&gt;copystack gp=0xc000000180 [0xc000064000 0xc000065890 0xc000066000] -&amp;gt; [0xc00006c000 0xc00006f890 0xc000070000]/16384&lt;br/&gt;stackfree 0xc000064000 8192&lt;br/&gt;stack grow done&lt;br/&gt;...&lt;br/&gt;copystack gp=0xc000000180 [0xc00006c000 0xc00006f890 0xc000070000] -&amp;gt; [0xc000070000 0xc000077890 0xc000078000]/32768&lt;br/&gt;stackfree 0xc00006c000 16384&lt;br/&gt;stack grow done&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;栈缩容&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;goroutine&lt;/code&gt;运行的过程中，如果栈区的空间使用率不超过1/4，那么在垃圾回收的时候使用&lt;code&gt;runtime.shrinkstack&lt;/code&gt;进行栈缩容，当然进行缩容前会执行一堆前置检查，都通过了才会进行缩容&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;shrinkstack&lt;/span&gt;&lt;span&gt;(gp *g)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; ...&lt;br/&gt; oldsize := gp.stack.hi - gp.stack.lo&lt;br/&gt; newsize := oldsize / &lt;span&gt;2&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; newsize &amp;lt; _FixedStack {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; avail := gp.stack.hi - gp.stack.lo&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; used := gp.stack.hi - gp.sched.sp + _StackLimit; used &amp;gt;= avail/&lt;span&gt;4&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; copystack(gp, newsize)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要触发栈的缩容，新栈的大小会是原始栈的一半，不过如果新栈的大小低于程序的最低限制 2KB，那么缩容的过程就会停止。缩容也会调用扩容时使用的 &lt;code&gt;runtime.copystack&lt;/code&gt; 函数开辟新的栈空间，将旧栈的数据拷贝到新栈以及调整原来指针的指向。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们上面的那个例子里，当&lt;code&gt;main&lt;/code&gt;函数里的其他函数执行完后，只有&lt;code&gt;main&lt;/code&gt;函数还在栈区的空间里，如果这个时候系统进行垃圾回收就会对这个&lt;code&gt;goroutine&lt;/code&gt;的栈区进行缩容。在这里我们可以在程序里通过调用&lt;code&gt;runtime.GC&lt;/code&gt;，强制系统进行垃圾回收，来试验看一下栈缩容的过程和效果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;var&lt;/span&gt; x [&lt;span&gt;10&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;println&lt;/span&gt;(&amp;amp;x)&lt;br/&gt;   a(x)&lt;br/&gt;   runtime.GC()&lt;br/&gt;   &lt;span&gt;println&lt;/span&gt;(&amp;amp;x)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行命令&lt;strong&gt;go build -gcflags -S main.go&lt;/strong&gt;后会看到类似下面的输出。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;shrinking stack 32768-&amp;gt;16384&lt;br/&gt;stackalloc 16384&lt;br/&gt;  allocated 0xc000076000&lt;br/&gt;copystack gp=0xc000000180 [0xc00007a000 0xc000081e60 0xc000082000] -&amp;gt; [0xc000076000 0xc000079e60 0xc00007a000]/16384&lt;br/&gt;...&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;栈内存是应用程序中重要的内存空间，它能够支持本地的局部变量和函数调用，栈空间中的变量会与栈一同创建和销毁，这部分内存空间不需要工程师过多的干预和管理，现代的编程语言通过逃逸分析减少了我们的工作量，理解栈内存空间的分配对于理解 Go 语言的运行时有很大的帮助。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;看到这里了，如果喜欢我的文章可以帮我点个赞和在看把分享给更多小伙伴，我会每周通过技术文章分享我的所学所见，感谢你的支持。微信搜索关注公众号「网管叨bi叨」第一时间获取我的文章推送。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6cb7840e9466bcfe26737b70f755eddf</guid>
<title>[推荐] 如何设计一个牛逼的 API 接口</title>
<link>https://toutiao.io/k/j1aredh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在日常开发中，总会接触到各种接口。前后端数据传输接口，第三方业务平台接口。一个平台的前后端数据传输接口一般都会在内网环境下通信，而且会使用安全框架，所以安全性可以得到很好的保护。这篇文章重点讨论一下提供给第三方平台的业务接口应当如何设计？我们应该考虑哪些问题？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6288659793814433&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgiaG5BicLkVecicCqe1jClBRZd1d7AB7ysyBqCXszBDLVTiasaBWZKDKxO3xVdMha3Mm4blXCUS5dU0kVMKdW91Pg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;776&quot;/&gt;&lt;/p&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要从以上三个方面来设计一个安全的API接口。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一 安全性问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安全性问题是一个接口必须要保证的规范。如果接口保证不了安全性，那么你的接口相当于直接暴露在公网环境中任人蹂躏。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.1 调用接口的先决条件-token&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取token一般会涉及到几个参数&lt;code&gt;appid&lt;/code&gt;，&lt;code&gt;appkey&lt;/code&gt;，&lt;code&gt;timestamp&lt;/code&gt;，&lt;code&gt;nonce&lt;/code&gt;，&lt;code&gt;sign&lt;/code&gt;。我们通过以上几个参数来获取调用系统的凭证。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;appid&lt;/code&gt;和&lt;code&gt;appkey&lt;/code&gt;可以直接通过平台线上申请，也可以线下直接颁发。&lt;code&gt;appid&lt;/code&gt;是全局唯一的，每个&lt;code&gt;appid&lt;/code&gt;将对应一个客户，&lt;code&gt;appkey&lt;/code&gt;需要高度保密。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;timestamp&lt;/code&gt;是时间戳，使用系统当前的unix时间戳。时间戳的目的就是为了减轻DOS攻击。防止请求被拦截后一直尝试请求接口。服务器端设置时间戳阀值，如果请求时间戳和服务器时间超过阀值，则响应失败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;nonce&lt;/code&gt;是随机值。随机值主要是为了增加&lt;code&gt;sign&lt;/code&gt;的多变性，也可以保护接口的幂等性，相邻的两次请求&lt;code&gt;nonce&lt;/code&gt;不允许重复，如果重复则认为是重复提交，响应失败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sign&lt;/code&gt;是参数签名，将&lt;code&gt;appkey&lt;/code&gt;，&lt;code&gt;timestamp&lt;/code&gt;，&lt;code&gt;nonce&lt;/code&gt;拼接起来进行md5加密（当然使用其他方式进行不可逆加密也没问题）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;token&lt;/code&gt;，使用参数&lt;code&gt;appid&lt;/code&gt;，&lt;code&gt;timestamp&lt;/code&gt;，&lt;code&gt;nonce&lt;/code&gt;，&lt;code&gt;sign&lt;/code&gt;来获取token，作为系统调用的唯一凭证。&lt;code&gt;token&lt;/code&gt;可以设置一次有效（这样安全性更高），也可以设置时效性，这里推荐设置时效性。如果一次有效的话这个接口的请求频率可能会很高。&lt;code&gt;token&lt;/code&gt;推荐加到请求头上，这样可以跟业务参数完全区分开来。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.2 使用POST作为接口请求方式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般调用接口最常用的两种方式就是GET和POST。两者的区别也很明显，GET请求会将参数暴露在浏览器URL中，而且对长度也有限制。为了更高的安全性，所有接口都采用POST方式请求。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.3 客户端IP白名单&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ip白名单是指将接口的访问权限对部分ip进行开放。这样就能避免其他ip进行访问攻击，设置ip白名单比较麻烦的一点就是当你的客户端进行迁移后，就需要重新联系服务提供者添加新的ip白名单。设置ip白名单的方式很多，除了传统的防火墙之外，spring cloud alibaba提供的组件sentinel也支持白名单设置。为了降低api的复杂度，推荐使用防火墙规则进行白名单设置。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.4 单个接口针对ip限流&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;限流是为了更好的维护系统稳定性。使用redis进行接口调用次数统计，ip+接口地址作为key，访问次数作为value，每次请求value+1，设置过期时长来限制接口的调用频率。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.5 记录接口请求日志&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用aop全局记录请求日志，快速定位异常请求位置，排查问题原因。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.6 敏感数据脱敏&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在接口调用过程中，可能会涉及到订单号等敏感数据，这类数据通常需要脱敏处理，最常用的方式就是加密。加密方式使用安全性比较高的&lt;code&gt;RSA&lt;/code&gt;非对称加密。非对称加密算法有两个密钥，这两个密钥完全不同但又完全匹配。只有使用匹配的一对公钥和私钥，才能完成对明文的加密和解密过程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二 幂等性问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幂等性是指任意多次请求的执行结果和一次请求的执行结果所产生的影响相同。说的直白一点就是查询操作无论查询多少次都不会影响数据本身，因此查询操作本身就是幂等的。但是新增操作，每执行一次数据库就会发生变化，所以它是非幂等的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幂等问题的解决有很多思路，这里讲一种比较严谨的。提供一个生成随机数的接口，随机数全局唯一。调用接口的时候带入随机数。第一次调用，业务处理成功后，将随机数作为key，操作结果作为value，存入redis，同时设置过期时长。第二次调用，查询redis，如果key存在，则证明是重复提交，直接返回错误。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三 数据规范问题&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.1 版本控制&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一套成熟的API文档，一旦发布是不允许随意修改接口的。这时候如果想新增或者修改接口，就需要加入版本控制，版本号可以是整数类型，也可以是浮点数类型。一般接口地址都会带上版本号，http://ip:port//v1/list。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.2 响应状态码规范&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个牛逼的API，还需要提供简单明了的响应值，根据状态码就可以大概知道问题所在。我们采用http的状态码进行数据封装，例如200表示请求成功，4xx表示客户端错误，5xx表示服务器内部发生错误。状态码设计参考如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;分类&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1xx&lt;/td&gt;&lt;td&gt;信息，服务器收到请求，需要请求者继续执行操作&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2xx&lt;/td&gt;&lt;td&gt;成功&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3xx&lt;/td&gt;&lt;td&gt;重定向，需要进一步的操作以完成请求&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4xx&lt;/td&gt;&lt;td&gt;客户端错误，请求包含语法错误或无法完成请求&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5xx&lt;/td&gt;&lt;td&gt;服务端错误&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;状态码枚举类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; CodeEnum {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 根据业务需求进行添加&lt;/span&gt;&lt;br/&gt;    SUCCESS(&lt;span&gt;200&lt;/span&gt;,&lt;span&gt;&quot;处理成功&quot;&lt;/span&gt;),&lt;br/&gt;    ERROR_PATH(&lt;span&gt;404&lt;/span&gt;,&lt;span&gt;&quot;请求地址错误&quot;&lt;/span&gt;),&lt;br/&gt;    ERROR_SERVER(&lt;span&gt;505&lt;/span&gt;,&lt;span&gt;&quot;服务器内部发生错误&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; code;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String message;&lt;br/&gt;    &lt;br/&gt;    CodeEnum(&lt;span&gt;int&lt;/span&gt; code, String message) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.code = code;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.message = message;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getCode&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; code;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setCode&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; code)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.code = code;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getMessage&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; message;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setMessage&lt;/span&gt;&lt;span&gt;(String message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.message = message;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.3 统一响应数据格式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了方便给客户端响应，响应数据会包含三个属性，状态码（code）,信息描述（message）,响应数据（data）。客户端根据状态码及信息描述可快速知道接口，如果状态码返回成功，再开始处理数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;响应结果定义及常用方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;R&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Serializable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = &lt;span&gt;793034041048451317L&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; code;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String message;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Object data = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getCode&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; code;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setCode&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; code)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.code = code;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getMessage&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; message;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setMessage&lt;/span&gt;&lt;span&gt;(String message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.message = message;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;getData&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; data;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 放入响应枚举&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; R &lt;span&gt;fillCode&lt;/span&gt;&lt;span&gt;(CodeEnum codeEnum)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.setCode(codeEnum.getCode());&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.setMessage(codeEnum.getMessage());&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 放入响应码及信息&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; R &lt;span&gt;fillCode&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; code, String message)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.setCode(code);&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.setMessage(message);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 处理成功，放入自定义业务数据集合&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; R &lt;span&gt;fillData&lt;/span&gt;&lt;span&gt;(Object data)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.setCode(CodeEnum.SUCCESS.getCode());&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.setMessage(CodeEnum.SUCCESS.getMessage());&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.data = data;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇文章从安全性、幂等性、数据规范等方面讨论了API设计规范。除此之外，一个好的API还少不了一个优秀的接口文档。接口文档的可读性非常重要，虽然很多程序员都不喜欢写文档，而且不喜欢别人不写文档。为了不增加程序员的压力，推荐使用swagger或其他接口管理工具，通过简单配置，就可以在开发中测试接口的连通性，上线后也可以生成离线文档用于管理API。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4df88e9d7742e6aadbce9e47f50f77de</guid>
<title>[推荐] 研发效能杂谈</title>
<link>https://toutiao.io/k/zacmqw3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-content&quot;&gt;&lt;p&gt;研发效能是什么？为什么现在都在谈如何提高研发效能？研发效能对于一个企业到底有多重要？本文按照Why、What、How三步走沉淀梳理了研发效能相关的知识点。&lt;/p&gt;




&lt;h2&gt;一. 为什么要提升研发效能&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;传统的职能部门组织架构带来的效率竖井问题&lt;/li&gt;
&lt;li&gt;人力的增加没有让项目进度加快&lt;/li&gt;
&lt;li&gt;长久加班导致团队士气低落，后续的效率降低&lt;/li&gt;
&lt;li&gt;上线前加班、熬夜，压力大&lt;/li&gt;
&lt;li&gt;上线后Bug、事故频发，实现效果与需求不匹配&lt;/li&gt;
&lt;li&gt;各种重复低效工作，疲于应付业务&lt;/li&gt;
&lt;li&gt;想要有限的人力做更多的产出&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;二. 什么是研发效能&lt;/h2&gt;

&lt;p&gt;对于一个企业来说，追求的是企业效能的最大化，包括：利润、用户规模、客户满意度、运营效率等。而对于需要研发自有产品的互联网公司来说，研发效能则是服务于企业效能的至关重要的因素。&lt;/p&gt;

&lt;p&gt;一个软件研发的完整流程如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/post_images/dev/devprocess.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;此流程交付期望产品的效率和能力，即研发效能。更进一步的《研发效率破局之道》中将研发效能定义为团队能够持续地为用户产生有效价值的效率，包括 &lt;strong&gt;有效性（Effectiveness）、效率（Efficiency）和可持续性（Sustainability）&lt;/strong&gt; 三个方面。其增加的可持续性指出研发效能应该着眼于长期效果。&lt;/p&gt;

&lt;p&gt;一句话来讲，研发效能就是持续快速交付价值的能力。&lt;/p&gt;

&lt;h2&gt;三. 如何提升研发效能&lt;/h2&gt;

&lt;p&gt;对应于第一部分中讲述的软件开发流程，如果想要提升研发效能，那么需要落实到研发流程（组织结构、项目管理、持续交付）、工程方法、个人效能以管理和文化的实践上。本文重点从研发流程、工程方法两方面来讲。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/post_images/dev/whole.png&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;3.1 衡量指标&lt;/h3&gt;

&lt;p&gt;评估一个组织持续快速交付价值的能力，需要一组可量化的数据或参数，用来跟踪和评估开发过程的“健康”状况。&lt;/p&gt;

&lt;h4&gt;3.1.1 指标分类&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;持续发布能力

&lt;ul&gt;
&lt;li&gt;发布频率：单位时间内的有效发布次数&lt;/li&gt;
&lt;li&gt;发布前置时间：从代码提交到功能上线花费的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;需求响应周期

&lt;ul&gt;
&lt;li&gt;交付周期时间：从确认用户提出的需求开始，到需求上线经历的平均时长。&lt;/li&gt;
&lt;li&gt;开发周期时间：从开发团队理解需求开始，到需求可以上线所经历的平均时长。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交付吞吐率


&lt;/li&gt;
&lt;li&gt;交付过程质量：质量内建

&lt;ul&gt;
&lt;li&gt;缺陷创建和修复时间分布：缺陷能够持续和及时地被发现，并在发现后尽快修复。&lt;/li&gt;
&lt;li&gt;缺陷库存：开发过程控制缺陷库存量，让产品始终处于接近可发布状态，是持续交付的基础&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交付质量：系统的可用性


&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;3.1.2 通用目标&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;2：2周交付周期。从想法提出并确认到上线的时间。【跨职能、组织的协调一致和紧密协作】&lt;/li&gt;
&lt;li&gt;1：1周开发周期。从需求设计完成（对开发就绪）到达到可上线的时间。【需求的拆分和管理，开发团队的分工协作模式，持续交付实践】&lt;/li&gt;
&lt;li&gt;1：1小时的发布前置时间。代码提交后可以在1小时内完成发布。【持续交付流水线】&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;3.1.3 选择优化指标&lt;/h4&gt;

&lt;p&gt;流程中总是有一个核心瓶颈。分析关键路径、定位瓶颈，针对优化&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用指标来发现问题而不是做绩效考核&lt;/li&gt;
&lt;li&gt;使用指标来检验优化效果&lt;/li&gt;
&lt;li&gt;使用价值流图/累积流程图发现全局瓶颈，从而确定需要提升的度量指标&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;3.2 组织结构&amp;amp;&amp;amp;项目管理&lt;/h3&gt;

&lt;h4&gt;3.2.1 组织结构&lt;/h4&gt;

&lt;p&gt;避免“效率竖井”： 采用以业务为单位的组织架构，保证业务线全栈配齐，目标一致。并从全局定位瓶颈进而进行优化工作。&lt;/p&gt;

&lt;h4&gt;3.2.2 项目管理&lt;/h4&gt;

&lt;p&gt;使用敏捷开发来提升研发效率&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;敏捷 = 价值观 + 原则 + 一系列符合价值观和原则的方法。

&lt;ul&gt;
&lt;li&gt;软件应该一直处于可工作状态&lt;/li&gt;
&lt;li&gt;每个迭代都能将软件部署到一个类生产环境中，并向用户演示&lt;/li&gt;
&lt;li&gt;迭代长度不超过两周&lt;/li&gt;
&lt;li&gt;透明性、协作性、纪律性和持续改进&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用MVP，度量驱动开发&lt;/li&gt;
&lt;li&gt;流程尽快流动：工程方法支撑&lt;/li&gt;
&lt;li&gt;发现整个流程中的瓶颈，并解决：可视化工作流、事故复盘&lt;/li&gt;
&lt;li&gt;避免“小瀑布”

&lt;ul&gt;
&lt;li&gt;价值排序&lt;/li&gt;
&lt;li&gt;满足客户需要&lt;/li&gt;
&lt;li&gt;需求拆分成能够独立测试的需求！！！&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;看板

&lt;ul&gt;
&lt;li&gt;从个人转变到关注价值流动：待开发-&amp;gt;设计-&amp;gt;开发-&amp;gt;开发自测-&amp;gt;代码评审-&amp;gt;测试-&amp;gt;完成&lt;/li&gt;
&lt;li&gt;明确的“完成的定义”DoD，明确了状态迁移必须完成的活动&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;从实际出发、以终为始：以实用主义的态度，从原则出发，灵活优化流程&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;一个可供参考的项目管理标准动作可见：&lt;a href=&quot;https://www.rowkey.cn/blog/2020/07/31/project-manage/&quot;&gt;项目管理标准模板&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;3.3 持续交付&lt;/h3&gt;

&lt;p&gt;持续交付指的是在短周期内完成软件产品，以保证软件保持在随时可以发布的状态。让每一个变更都经过一条自动化的检验流水线，来检查每一个变更的质量，通过就进入下一个阶段。&lt;strong&gt;其不是一种工具，而是一种实践！&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;不要阻塞开发人员&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;每个团队指定构建负责人或者发布工程师：优化交付流水线，提升交付效率&lt;/li&gt;
&lt;li&gt;项目状态，应该对参与整个过程（包括构建、部署、测试和发布）的所有人都是可见的&lt;/li&gt;
&lt;li&gt;风险管理

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;迭代增量式交付&lt;/strong&gt;是有效风险管理的关键&lt;/li&gt;
&lt;li&gt;手工测试环境、试运行环境和生产环境总是需要严格的访问控制&lt;/li&gt;
&lt;li&gt;让风险识别成为每日立会的一部分&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;审计

&lt;ul&gt;
&lt;li&gt;手工测试环境、试运行环境和生产环境总是需要严格的访问控制：指定谁能够访问“特权”环境。&lt;/li&gt;
&lt;li&gt;要求每次部署都要进行审计，以确切知道到底修改了哪些内容。&lt;/li&gt;
&lt;li&gt;文档自动化、自文档&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;具体可见：&lt;a href=&quot;https://www.rowkey.cn/blog/2020/06/15/cd/&quot;&gt;持续交付这点事&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;3.3 工程方法&lt;/h3&gt;

&lt;h4&gt;3.3.1 技术债&lt;/h4&gt;

&lt;p&gt;在开发产品或者功能的过程中，没有使用最佳的实现方法而引入的技术问题。需要持续关注业务和技术债。对业务机会敏感，敢放手一搏大量借贷，也知道什么时候必须偿还技术债。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;利用技术债的好处，必要时要大胆“举债前行”&lt;/li&gt;
&lt;li&gt;控制技术债，在适当的时候偿还适当部分的技术债。&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;3.4.2 云计算&lt;/h4&gt;

&lt;p&gt;利用好云计算带来的&lt;strong&gt;服务化、自助化和弹性伸缩&lt;/strong&gt;三大优势。初创公司在业务刚起步时，使用 SaaS 或者 PaaS 快速开发业务；业务成长到一定规模之后，再逐步转到 IaaS 以及私有云降低成本。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;细节抽象得越多，云服务商负责的部分就越多，我们就越能够聚焦自己的业务，从而提高研发效能&lt;/li&gt;
&lt;li&gt;使用云资源时，通过工具或者 API 调用来完成工作，减少人工参与，达到自动化&lt;/li&gt;
&lt;li&gt;资源共享、弹性伸缩&lt;/li&gt;
&lt;li&gt;容器：不可变基础设施；基于K8S建设PaaS&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;在使用云计算时，要妥善处理它带来的挑战，比如分布式系统带来的安全和控制方面的问题。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;自治和集中管理相结合：信息可视化（系统整体的质量看板、调用链追踪）&lt;/li&gt;
&lt;li&gt;错误处理&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;3.4.3 测试机制&lt;/h4&gt;

&lt;p&gt;上文持续交付一部分中最关键的其实就是测试部分，只有具有完善、可靠的测试机制，才能保证研发质量和交付效果，才能从根本上提高研发效能。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;测试左移：质量内建，即持续交付中的测试机制。

&lt;ul&gt;
&lt;li&gt;按照功能的维度管理团队，让整个功能团队对产品负责；改变团队成员对测试工作的认知&lt;/li&gt;
&lt;li&gt;把测试添加到开发和产品需求步骤中&lt;/li&gt;
&lt;li&gt;频繁测试，快速测试：提升测试运行的速度，并行运行、提高构建速度、精准测试、分层测试、减少不必要的用例&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;测试右移

&lt;ul&gt;
&lt;li&gt;利用线上的真实环境测试：需要有完备的数据隔离机制&lt;/li&gt;
&lt;li&gt;测试人员介入线上监控和预警，及时发现问题并跟进解决&lt;/li&gt;
&lt;li&gt;混沌工程：即在真实环境中通过模拟各种不可预期的故障来验证系统稳定性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;3.4.4 平台化&lt;/h4&gt;

&lt;p&gt;通过抽象共性组件、功能，达到代码、功能复用，从而减少重复开发，提高研发效能。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;技术平台：技术设施的复用&lt;/li&gt;
&lt;li&gt;数据中台：数据沉淀和输出能力&lt;/li&gt;
&lt;li&gt;移动中台：前端组件、跨平台开发、插件化、热加载&lt;/li&gt;
&lt;li&gt;业务中台


&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;相关资料可见：&lt;a href=&quot;https://www.rowkey.cn/blog/2019/11/23/middle-talk/&quot;&gt;中台简谈&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;3.5 个人效能&lt;/h3&gt;

&lt;p&gt;如何提高开发人员自身的开发效率，除了每个人自身的天赋能力外，也有一些可以刻意使用的高效工具和方法。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;高效工作方法


&lt;/li&gt;
&lt;li&gt;高效开发工具

&lt;ul&gt;
&lt;li&gt;好的IDE&lt;/li&gt;
&lt;li&gt;操作系统快捷键&lt;/li&gt;
&lt;li&gt;思维导图软件&lt;/li&gt;
&lt;li&gt;学习笔记软件&lt;/li&gt;
&lt;li&gt;文档撰写工具&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;持续学习：不断地学习新的开发技能，从而提升自己的开发效率&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;此外，还可以通过技术管理从外部驱动个人效能的提升，这在下面的技术管理部分会讲。&lt;/p&gt;

&lt;h3&gt;3.6 管理和文化&lt;/h3&gt;

&lt;h4&gt;3.6.1 技术管理&lt;/h4&gt;

&lt;p&gt;管理包括：看方向、管人、管事。做好技术管理是提高研发效能的关键部分。其中，3.4节个人效能部分的数字驱动也是技术管理的一部分。主要步骤包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;制定目标：兼顾业务目标和技术目标&lt;/li&gt;
&lt;li&gt;目标管理：使用OKR等目标管理方案&lt;/li&gt;
&lt;li&gt;计划并执行去实现目标&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;此外，技术管理中一个很难的问题是如何进行考核。这里可以使用数字化的方式，以驱动个人效能的提升。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;选择个人效能度量指标&lt;/li&gt;
&lt;li&gt;根据代码提交日志自动生成工作日报和周报、个人贡献值&lt;/li&gt;
&lt;li&gt;综合多维数据构建个人的数据画像

&lt;ul&gt;
&lt;li&gt;社会地位：用排名、榜单来实现；&lt;/li&gt;
&lt;li&gt;工作本身：用复合型报告去综合评价，告知员工究竟做得好不好&lt;/li&gt;
&lt;li&gt;自我改变：通过雷达图，进行多维度的数据分析，精准提炼员工的优点与不足，员工可以有针对性的取长补短。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;需要说明的是，如果指标不能全方面的衡量，就不要做为考核指标，仅仅用于发现问题，解决问题！&lt;/p&gt;

&lt;p&gt;一个可参考的技术管理标准动作模板见：&lt;a href=&quot;https://www.rowkey.cn/blog/2020/04/25/tech-leader-manage/&quot;&gt;技术管理标准模板&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;3.6.2 团队文化&lt;/h4&gt;

&lt;p&gt;团队文化是团队成员共同认可的价值观和行为准则，良好且有效的文化是保障团队高效产出的关键部分。很多互联网公司都是工程师文化主导的，包括Facebook、Google、百度等。他们也都具有自己独特的企业文化价值观，如百度的简单可依赖、谷歌的不作恶、Netflix的自由和责任。建立团队文化的步骤如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定义：总结、明确自己团队的文化，提炼出简单易记的文字。&lt;/li&gt;
&lt;li&gt;主张：各种形式的传播。从我自己的经历来看，不断地念经是其中最有效的方式。&lt;/li&gt;
&lt;li&gt;追求：在奖惩中体现出文化价值观的作用。如对于文化价值观贯彻优秀的同学给与公开的肯定与奖励。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;四. 参考资料&lt;/h2&gt;



&lt;/div&gt;



  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>