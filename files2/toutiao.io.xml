<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>6e3f47e93c7e234f6a7ddf69148c0c61</guid>
<title>多业务建模在美团搜索排序中的实践</title>
<link>https://toutiao.io/k/8l0f3yf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;引言&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;排序流程简介&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;多业务建模实践&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;总结和展望&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;作者简介&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;引言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;美团的使命是“帮大家吃得更好，生活更好”，美团 App 承载的业务包括外卖、到店餐饮、买菜、优选、酒店、旅游、休闲娱乐等各类生活服务。美团首页的搜索是美团 App 上各类生活服务最大的流量分发入口，每天为数千万的用户提供各种服务。美团搜索排序是一个典型的多业务混合排序建模问题，一个典型的多业务搜索场景是当用户搜索地点，如 “望京” 的时候，用户的需求不是很明确，此时搜索的结果页如下图 1 所示，下方的商家列表中会包含望京附近餐饮、电影、休闲娱乐、酒店等多种业务的结果，这就是一个多业务混合排序场景。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;2.1638888888888888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsX8ibXbOGUp22la4nuBG3fWRM9icgqShy5fmf1zECrhauNmsLMHQAkzCiaHuZgickiaHt5u6jerQAhbVyg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图1 美团搜索结果页面&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而多业务场景存在如下几点挑战：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;因业务之间存在共性和特性，如何让模型兼顾这两种特性，实现更好的数据学习。比如到店餐饮对距离特征非常敏感，而旅游景点业务对距离特征相对不敏感。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;业务天然存在高频和低频特性（&lt;/span&gt;&lt;span&gt;比如外卖和旅游&lt;/span&gt;&lt;span&gt;），导致模型的训练数据中多业务样本数量不平衡。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;各个业务往往有自己不同的主目标，如何满足不同业务的目标，最终能够提升搜索的用户体验。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文分享了美团搜索中的多业务排序建模优化工作，我们主要聚焦在到店商家多业务场景，后续的内容会分为以下四个部分：第一部分是对美团搜索排序分层架构进行简单介绍；第二部分会介绍多路融合层上的多业务融合建模；第三部分会介绍精排模型的多业务排序建模；最后一部分是总结和展望。希望能对从事相关工作的同学有所启发或者帮助。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;排序流程简介&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;美团搜索系统流程如下图 2 所示，整体流程分为数据层、召回层、排序层和展示层。其中排序层分为以下几个子部分：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;粗排层&lt;/strong&gt;：使用相对简单的模型对召回候选集进行初步过滤，实现排序效果和性能的 Trade-off。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;多路融合层&lt;/strong&gt;：使用查询词特征、上下文场景特征构建配额模型，进行不同业务候选集的数量控制，实现用户需求的精确理解。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;精排层&lt;/strong&gt;：使用亿级别特征的深度学习模型，捕捉各种显式和隐式信号，实现 Item 排序分数的精准预估。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;重排层&lt;/strong&gt;：使用小模型和各种机制对精排后的结果进行调序，实现精细定向的优化。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;异构排序层&lt;/strong&gt;：使用深度学习模型对异构聚块进行排序，实现多业务的高承载。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;多层排序架构设计主要是为了平衡排序效果和性能。本文后续提到的多业务建模优化工作主要从多路融合层和精排层进行介绍。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7811307665626084&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsX8ibXbOGUp22la4nuBG3fWR8rlnGEzSSicm0yRViaXU8saiaic0VgjicVk9bviaMibQ7Jf1rBXlfHfJFGJ2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2883&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图2 系统架构图&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;多业务建模实践&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;多业务配额模型（多路融合层）&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;随着美团业务的发展，美团搜索接入了到餐、到综、酒店、旅游等业务。对于业务意图模糊的搜索词，比如用户搜索“五道口”，需要根据用户、查询词、场景等多种因素来综合判断用户的业务意图。为了融合不同业务的召回结果，给 L2 精排一个比例合适的候选集，我们设计了一个多业务配额模型来平衡多业务召回的比例。这种基于配额对多路召回结果进行合并的做法在搜索、推荐场景中十分常用，比如淘宝首页搜索、美团推荐等。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了多路召回的灵活接入，适配美团搜索业务的发展，我们不断迭代搜索配额模型。下面将详细介绍美团多业务配额模型的迭代过程，文章后续部分会将多业务配额模型（&lt;/span&gt;&lt;span&gt;Multi-Business Quota Model&lt;/span&gt;&lt;span&gt;）简称为MQM。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.5751173708920188&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsX8ibXbOGUp22la4nuBG3fWR4NBibeWDKGtQiaFP9G8torwFwnfRQrmJrr7B1vHgEhBWzhwUVvvWWcYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1278&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图3 多路融合过程&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一维目标多业务配额&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;考虑到大搜结果存在多路不同业务的召回，为了刻画用户搜索 Query 对三路业务召回的意图强弱，我们采用多目标的建模方式，以每一路召回是否被点击、下单为目标进行建模，实现了多业务配额初版模型 MQM-V1。该模型输出各路召回的点击、下单联合概率，作为最终的配额分布。在特征层面，我们使用 Query 维度特征、Context 维度特征、Cross 维度特征、User 维度特征，来刻画用户在不同场景的实时个性化需求。MQM-V1 模型结构如下图 4 所示。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8704581358609794&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsX8ibXbOGUp22la4nuBG3fWRMqorIKotAf1SibtLtVhJGXT1WWbbq1r5s91Wv5nOsLI4r1k6jsGBU2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1899&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图4 MQM-V1 模型结构图&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MQM-V1 版本上线后，整体线上点击率 +0.53%，各业务访购率基本持平。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二维目标多业务配额&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;随着大搜召回策略的不断迭代，大搜不仅引入了按业务拆分的召回方式，而且引入了向量检索、地理位置近邻检索等跨多业务的异构召回方式，导致大搜召回策略不断增加，多业务配额模型也面临新召回源带来的冷启动问题。同时，为了加强多业务配额模型的个性化，我们参考借鉴了[6]中用户行为序列建模的方法。综上，该版本 MQM-V2 与 MQM-V1 区别如下：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;建模目标上，从以召回方式点击的一维目标升级到召回方式叉乘业务的二维目标，使得多路融合的粒度也更细、精度更高。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;行为序列建模模块引入Transformer Layer。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;为了解决新召回源接入的冷启动问题，我们引入了人工经验层，包括业务先验和历史统计，综合模型输出决定每一路召回的配额。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8262967430639324&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsX8ibXbOGUp22la4nuBG3fWRnWiasDcO5qehBJNK5knBRC86FNU9nGODdx49ezNMfHTDymPwDOWyZpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2487&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图5 MQM-V2 模型结构图&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MQM-V2 版本上线后，各业务指标率均有提升，其中旅游访购率 +2%，到餐访购率 +0.57%，到综、酒店访购率持平。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;多业务排序模型（精排层）&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从美团搜索精排模型升级为 DNN 模型，一直到 2019 年底，美团搜索的精排模型结构是业界主流的 Embedding&amp;amp;MLP 的范式结构，期间我们也尝试过业界提出的模型结构比如PNN[1]、DeepFM[2]、DCN[3]、AutoInt[4]、FiBiNet[5]等等。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;随着迭代的进行，我们发现针对特定业务的优化难以在精排模型发挥作用，为了兼顾各个业务的特性，支持各个业务更加有效的针对性迭代优化，需要探索出一种模型结构来适配美团搜索这样的多业务场景。下面会具体介绍精排模型在多业务建模上的发展史，文章后续部分将多业务精排模型（&lt;/span&gt;&lt;span&gt;Multi-Business Network&lt;/span&gt;&lt;span&gt;）简称为 MBN。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;独立子网络拆分&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;考虑到酒店和旅游在美团大搜排序策略的流量里面占比较少，而针对小流量的相关优化在目前统一的 Embedding&amp;amp;MLP 模型结构里面很难体现，我们尝试了如图 6 所示的人工自定义多塔模型 MBN-V1 结构：主网络复用目前的模型结构。具体情况介绍参考[6]中的行为序列建模部分，增加酒店和旅游独立子网络；酒店子网络的输入包括酒店独有特征和主网络的打分输出，旅游子网络的输入包括旅游独有特征、主网络的打分输出、主网络最后一层 FC，酒店和旅游子塔输入不同是因为业务逻辑不同导致数据分布差异大，这是实践出的结果，最终的输出是对三个输出的加权求和。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9833518312985572&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsX8ibXbOGUp22la4nuBG3fWR25o4viaUO0tr3iadMavI29PuxpHLCFOLzq0ICpQ5XjjlLrnwhyDFic2fA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1802&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图6 MBN-V1 模型结构图&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;针对加权求和的权重部分，我们采取了两种方式对权重进行设定：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一种，采用硬切分的方式，就是说权重向量是一个 One-hot 稀疏向量：对酒店商家进行预测，只选取酒店子网络的输出，其余类推。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二种，采用软切分的方式，把多业务配额模型的输出作为权重值。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;线上实验发现第二种方法比第一种好，我们认为采用硬切分会导致子塔分支的参数只能被对应业务的数据更新，而各业务的数据占比不均导致学习不佳，而软切分会达到一种知识迁移的作用。最终线上的效果相比统一的 Embedding&amp;amp; MLP 模型，整体旅游取得了正向效果：其中整体点击率 +0.17%，其余业务访购率效果基本持平。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;子网络权重自学习&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基于第一版多业务精排模型取得了初步正向效果，我们继续添加美食业务子塔，同时考虑到 MBN-V1 依赖配额模型的输出，这样会导致配额模型的变更可能会对精排模型的效果产生影响，针对这些因素我们上线了第二版多业务模型 MBN-V2，模型结构如图7所示。相比 MBN-V1 的区别如下：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;添加美食业务的独立子网络。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;解耦精排模型和配额模型，在精排模型中集成权重生成子网络，该子网络的输入主要是一些 Query 维度，Context 维度的特征。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7390761548064919&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsX8ibXbOGUp22la4nuBG3fWRyNLnm4xrxIjniaQHyNC5loy3Y1fVo825ARyqwtmfviabYCz7uGKTgcBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2403&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图7 MBN-V2 模型结构图&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;线上实验效果：MBN-V2 相比 MBN-V1，整体点击率 +0.1%，业务访购率效果基本持平。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;子网络特征自适应&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在第二版模型的基础上，我们进一步添加到综业务子塔，随着子网络的变多，目前对于子网络的输入采用人工设计，这种方式需要花费大量的时间进行离线实验。考虑到目前的多业务子塔结构十分类似业界的多任务学习，我们也尝试引入业界的多任务学习结构；同时，我们针对 MBN-V2 中的权重子网络输出进行分析发现其输出的权重对不同业务商户的输出差不多，那么会带来业务的针对性优化不明显。基于上述部分，我们迭代了第三版多业务精排 MBN-V3，结构如下图 8 所示，改进点如下：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8294898672257163&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsX8ibXbOGUp22la4nuBG3fWRVK5EIPmTISONPcJYpwaj8iaz8AhEXMnibicsycXU8t83nNWaspH3VjAuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2862&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图8 MBN-V3 模型结构图&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;补充到综子网络，采用 MMoE[7]多任务学习结构，来自动学习特征表征输出给上层子网络，从而取代人工设计子网络的输入。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;精排模型的损失函数除了采用用户线上反馈计算的主 LambdaLoss 外，额外添加了业务的分类交叉熵 Loss，达到预测某业务 Item 得分时，对应的业务子塔权重最大的目的。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;线上实验效果：MBN-V3 相比 MBN-V2，整体点击率效果持平、美食业务访购率 +0.36%，到综业务访购率 +1.07%，酒店业务访购率 +0.27%，旅游业务访购率 +0.35%。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;多业务特征表达优化&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;虽然 MMoE 多任务学习结构在业界很多场景得到了应用，在我们的多业务建模场景也取得了有效验证，但是我们持续跟进业界前沿，并且结合业务场景进行落地。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们尝试了腾讯提出的 PLE[8]结构，迭代出多业务精排 MBN-V4。PLE 可以看成是 MMoE 的改进版，它对于每一个任务有自己特定的专家层，不同任务之间有共享的专家层，相比 MMoE 是所有专家输出的加权求和，PLE 子任务的输入是子任务独有的专家和共享专家输出的加权求和，更容易学出业务的特性；同时基于性能考虑，我们选取了单层 PLE 也即 CGC 结构，结构如下图9所示：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7927321668909825&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsX8ibXbOGUp22la4nuBG3fWRUD1RicnZl3596XcibRGLfHagjgFeC0NicRiavFZR1VH2iarumj1OvCzpibAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2972&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图9 MBN-V4 模型结构图&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;线上实验效果：MBN-V4 相比 MBN-V3，整体点击率 +0.1%，美食业务访购率 +0.53%，其余业务访购率波动持平；我们对 MMoE 和 CGC 的专家权重进行可视化如下图 10所示，分析发现：CGC 结构的专家层权重相比 MMoE 在同一业务多条样本之间的专家权重方差更小，更加稳定，说明 CGC 相比 MMoE 在特征表示上更加有优势。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsX8ibXbOGUp22la4nuBG3fWRxnegBZqqPLicicREhUP0CPrj6xXPP2aic2ve5JuCIHCBtmbicgr4EAegEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图10 MMoE、CGC 专家权重分析&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结和展望&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2019 年底开始，为了解决实际的多业务召回排序问题，美团搜索进行了大量探索，从工程到算法到产品形态各个层面丰富对多业务的支持。其中排序算法层面主要在多路召回融合层和精排层进行优化。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;多路融合层主要完成搜索结果从结果相关到结果优质的筛选过程，需要解决不同召回方式（&lt;/span&gt;&lt;span&gt;文本召回、推荐召回、向量召回&lt;/span&gt;&lt;span&gt;）和不同业务召回结果的融合截断问题，直接决定了用户能浏览到的结果候选集。这其中最重要的问题就是判断用户对各个业务的需求强弱以及各业务的召回质量，对每个业务结果和召回结果确定合适的精排准入标准。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;多业务配额模型通过整合用户实时需求、Query 的历史统计信息、搜索上下文信息和每个召回源质量情况，给出了每路召回、每个业务的应进入精排的比例。该模型保证了不同场景下精排候选集的结果多样性和优质性，实现了新业务、新召回方法接入的少侵入性，降低业务、召回接入成本。同时也为精排层分业务的网络结构提供了融合各个业务子网络结果的先验权重。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;精排层在多路融合层的基础上进一步对多业务搜索结果进行精细化排序建模打分。用户的需求和美团业务一样是多样的，为了能充分建模各种场景下的需求，精排多业务排序模型从底层数据（&lt;/span&gt;&lt;span&gt;丰富分业务的特征&lt;/span&gt;&lt;span&gt;）、模型结构到业务目标融合都进行了多轮迭代。其中模型结构和相应的目标融合直接对各种大小业务、场景和相应的业务目标进行了分片建模，有效地缓解了小业务小场景在统一建模中被大业务样本淹没的问题。同时该模型支持新老业务的快速迭代，各业务可以方便独立地迭代特征、模型结构和相应的目标。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上述优化覆盖了线上全流量，在搜索用户体验和各业务价值均有明显提升，但还有很多工作可以持续优化。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;业务独有特征利用&lt;/strong&gt;：目前我们采用对某些业务添加业务独有特征，其余业务对于这些缺失的独有特征给默认值，但是这样会带来很多冗余的计算量，这部分不管从效果还是性能方面都存在优化空间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;样本不平衡学习&lt;/strong&gt;：不同业务的数据量在美团搜索上差异大，如何让模型更好的学习出小业务的分布，我们正在探索迁移学习和 Meta-Learning 等方法。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;多目标优化&lt;/strong&gt;：美团搜索既要兼顾用户的搜索体验，也要服务美团各个业务的战略目标，所以各个业务的主优化指标不一定一致，多目标优化也是一个持续探索的方向。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文叙述的工作集中在美团多业务商家搜索排序上，同时随着优选、买菜、团好货、闪购等商品类业务的发展，我们也正在进行商品类多业务混排以及商家商品异构多业务混排工作。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;[1] &lt;/span&gt;&lt;a href=&quot;https://arxiv.org/pdf/1611.00144.pdf&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Product-based neural networks for user response prediction&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[2] &lt;/span&gt;&lt;a href=&quot;http://www.ijcai.org/proceedings/2017/0239.pdf&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;DeepFM: A Factorization-Machine based Neural Network for CTR Prediction&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[3] &lt;/span&gt;&lt;a href=&quot;https://arxiv.org/abs/1708.05123&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Deep &amp;amp; Cross Network for Ad Click Predictions&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[4] &lt;/span&gt;&lt;a href=&quot;https://arxiv.org/abs/1810.11921&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;AutoInt: Automatic Feature Interaction Learning via Self-Attentive Neural Networks&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[5] &lt;/span&gt;&lt;a href=&quot;https://arxiv.org/pdf/1905.09433.pdf&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;FiBiNET: Combining Feature Importance and Bilinear feature Interaction for Click-Through Rate Prediction&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[6] &lt;/span&gt;&lt;a href=&quot;https://tech.meituan.com/2020/04/16/transformer-in-meituan.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Transformer 在美团搜索排序中的实践&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[7] &lt;/span&gt;&lt;a href=&quot;https://dl.acm.org/doi/10.1145/3219819.3220007&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Modeling Task Relationships in Multi-task Learning with Multi-gate Mixture-of-Experts&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[8] &lt;/span&gt;&lt;a href=&quot;https://dl.acm.org/doi/abs/10.1145/3383313.3412236&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Progressive Layered Extraction (PLE): A Novel Multi-Task Learning (MTL) Model for Personalized Recommendations&lt;/span&gt;&lt;span/&gt;&lt;/a&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;作者简介&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;培浩、肖垚、晓江、家琪、陈胜、云森、永超、利前等，均来自美团平台搜索与 NLP 部。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;活动推荐&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWkROqbUOkxgoZReLFeaRAicEuwGlpeJ2p1JBAId600iaW9ib9XQQWaq4PoQHW9qI4dSJ1icaPyy0rcug/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;7月10日（&lt;span&gt;本周六&lt;/span&gt;）下午14:00-17:00，美团技术沙龙《深度解密美团网络通信服务》，主要从美团移动消息队列、QUIC网络协议库、HTTPDNS这几个方面给大家呈现美团在网络通信服务方面的一些实践，希望与业界技术同学一起交流学习。期待你的参与，点击&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://www.huodongxing.com/event/9603461375400?qd=wenmo&quot; textvalue=&quot;这里&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;这里&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;可以报名~~&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>897e5189725a3d7fc5490b7ed657c506</guid>
<title>小白也能看懂的 Java 内存模型</title>
<link>https://toutiao.io/k/75ecrat</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前言&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java并发编程系列开坑了，Java并发编程可以说是中高级研发工程师的必备素养，也是中高级岗位面试必问的问题，本系列就是为了带读者们系统的一步一步击破Java并发编程各个难点，打破屏障，在面试中所向披靡，拿到心仪的offer，Java并发编程系列文章依然采用图文并茂的风格，让小白也能秒懂。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java内存模型（&lt;code&gt;Java Memory Model&lt;/code&gt;）简称&lt;code&gt;J M M&lt;/code&gt;，作为Java并发编程系列的开篇，它是Java并发编程的基础知识，&lt;strong&gt;理解它能让你更好的明白线程安全到底是怎么一回事&lt;/strong&gt;。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;内容大纲&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7364975450081833&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nz5r5xzvcibKlFtALe7Ldo3KupuQWibh7f6BWeme9kVfDADU1IWicVfeMPfqHhoRFRV7Yn1N259icR5Dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;611&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;硬件内存模型&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序是指令与数据的集合，计算机执行程序时，是&lt;code&gt;C P U&lt;/code&gt;在执行每条指令，因为&lt;code&gt;C P U&lt;/code&gt;要从内存读指令，又要根据指令指示去内存读写数据做运算，所以执行指令就免不了与内存打交道，早期内存读写速度与&lt;code&gt;C P U&lt;/code&gt;处理速度差距不大，倒没什么问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;C P U缓存&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着&lt;code&gt;C P U&lt;/code&gt;技术快速发展，&lt;code&gt;C P U&lt;/code&gt;的速度越来越快，&lt;strong&gt;内存却没有太大的变化&lt;/strong&gt;，导致内存的读写（&lt;code&gt;IO&lt;/code&gt;）速度与&lt;code&gt;C P U&lt;/code&gt;的处理速度差距越来越大，为了解决这个问题，引入了缓存（&lt;code&gt;Cache&lt;/code&gt;）的设计，在&lt;code&gt;C P U&lt;/code&gt;与内存之间加上&lt;strong&gt;缓存层&lt;/strong&gt;，这里的缓存层就是指&lt;code&gt;C P U&lt;/code&gt;内的&lt;strong&gt;寄存器与高速缓存&lt;/strong&gt;（&lt;code&gt;L1,L2,L3&lt;/code&gt;）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.40359168241965976&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nz5r5xzvcibKlFtALe7Ldo3KrX8RSqrqNCzibp8wXWPMLiayuiaOLdlqKnALL5qXl2EBmtibZCTCo9B5FA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1058&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图中可以看出，寄存器最快，主内最慢，越快的存储空间越小，离&lt;code&gt;C P U&lt;/code&gt;越近，相反存储空间越大速度越慢，离&lt;code&gt;C P U&lt;/code&gt;越远。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;C P U如何与内存交互&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;C P U&lt;/code&gt;运行时，会将指令与数据从主存复制到缓存层，后续的读写与运算都是基于缓存层的指令与数据，运算结束后，再将结果从缓存层写回主存。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1233859397417503&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nz5r5xzvcibKlFtALe7Ldo3KqurCPM3wns7oibibHFqL2jd1qHhKBH8BicfO5YKua7ViaiaEzGpUQMmkEow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;697&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图可以看出，&lt;code&gt;C P U&lt;/code&gt;基本都是在和&lt;strong&gt;缓存层&lt;/strong&gt;打交道，采用&lt;strong&gt;缓存设计&lt;/strong&gt;弥补主存与&lt;code&gt;C P U&lt;/code&gt;处理速度的差距，这种设计不仅仅体现在硬件层面，在日常开发中，那些并发量高的业务场景都能看到，但是凡事都有利弊，缓存虽然加快了速度，同样也带来了在多线程场景存在的&lt;strong&gt;缓存一致性问题&lt;/strong&gt;，关于&lt;strong&gt;缓存一致性问题&lt;/strong&gt;后面会说，这里大家留个印象。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Java内存模型&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java内存模型（&lt;code&gt;Java Memory Model，J M M&lt;/code&gt;），后续都以&lt;code&gt;J M M&lt;/code&gt;简称，&lt;code&gt;J M M&lt;/code&gt; 是建立在&lt;strong&gt;硬件内存模型基础上的抽象模型&lt;/strong&gt;，并不是物理上的内存划分，简单说，为了&lt;strong&gt;使&lt;/strong&gt;&lt;code&gt;Java&lt;/code&gt;虚拟机(&lt;code&gt;Java Virtual Machine，J V M&lt;/code&gt;)在各平台下达到一致的内存交互效果，&lt;strong&gt;需要屏蔽下游不同硬件模型的交互差异，统一规范，为上游提供统一的使用接口。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;code&gt;J M M&lt;/code&gt;是保证&lt;code&gt;J V M&lt;/code&gt;在各平台下对计算机内存的交互都能保证效果一致的机制及规范&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0557432432432432&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nz5r5xzvcibKlFtALe7Ldo3KCbCcib789mafqkYeOP4Ml2wOb25JzajvktHOZuSuU1a4N1YWbwG1pzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;592&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;抽象结构&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;J M M&lt;/code&gt;抽象结构划分为线程本地缓存与主存，每个线程均有自己的本地缓存，本地缓存是线程&lt;strong&gt;私有&lt;/strong&gt;的，主存则是计算机内存，它是&lt;strong&gt;共享&lt;/strong&gt;的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8490028490028491&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nz5r5xzvcibKlFtALe7Ldo3K1HmibE9WC1rumvXibKcGqCoibz9CPoRaq0WbNFzlM6NFtZdnAJZo7y6og/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;702&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不难发现&lt;code&gt;J M M&lt;/code&gt;与硬件内存模型差别不大，可以简单的把&lt;strong&gt;线程&lt;/strong&gt;类比成&lt;strong&gt;Core核心&lt;/strong&gt;，&lt;strong&gt;线程本地缓存&lt;/strong&gt;类比成&lt;strong&gt;缓存层&lt;/strong&gt;，如下图所示&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6253469010175763&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nz5r5xzvcibKlFtALe7Ldo3Ke0fOEoBz3XMY4TqpYZ8x0WN2vEyLmI6cffB9oR08JcAPDibL8jcKQqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1081&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然内存交互规范好了，但是多线程场景必然存在线程安全问题（&lt;strong&gt;竞争共享资源&lt;/strong&gt;），为了使多线程能正确的同步执行，就需要保证并发的三大特性&lt;strong&gt;可见性、原子性、有序性&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;可见性&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个线程修改了共享变量的值，其他线程能够立即得知这个修改，这就是&lt;strong&gt;可见性&lt;/strong&gt;，如果无法保证，就会出现&lt;strong&gt;缓存一致性的问题&lt;/strong&gt;，&lt;code&gt;J M M&lt;/code&gt;规定，所有的变量都放在主存中，当线程使用变量时，先从缓存中获取，缓存未命中，再从主存复制到缓存，最终导致线程操作的都是自己缓存中的变量。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7294455066921606&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nz5r5xzvcibKlFtALe7Ldo3K78icClcrmTsSFNxrpGunnCRibgPue1krBpfwoATFHDStoAvgbTicop3Ag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1046&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程A执行流程&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;A&lt;/code&gt;从缓存获取变量&lt;code&gt;a&lt;/code&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;缓存未命中，从主存复制到缓存，此时&lt;code&gt;a&lt;/code&gt;是&lt;code&gt;0&lt;/code&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;A&lt;/code&gt;获取变量&lt;code&gt;a&lt;/code&gt;，执行计算&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;计算结果&lt;code&gt;1&lt;/code&gt;，写入缓存&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;计算结果&lt;code&gt;1&lt;/code&gt;，写入主存&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程B执行流程&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;B&lt;/code&gt;从缓存获取变量&lt;code&gt;a&lt;/code&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;缓存未命中，从主存复制到缓存，此时&lt;code&gt;a&lt;/code&gt;是&lt;code&gt;1&lt;/code&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;B&lt;/code&gt;获取变量a，执行计算&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;计算结果&lt;code&gt;2&lt;/code&gt;，写入缓存&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;计算结果&lt;code&gt;2&lt;/code&gt;，写入主存&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;A&lt;/code&gt;、&lt;code&gt;B&lt;/code&gt;两个线程执行完后，线程&lt;code&gt;A&lt;/code&gt;与线程&lt;code&gt;B&lt;/code&gt;缓存数据不一致，这就是&lt;strong&gt;缓存一致性问题&lt;/strong&gt;，一个是&lt;code&gt;1&lt;/code&gt;，另一个是&lt;code&gt;2&lt;/code&gt;，如果线程&lt;code&gt;A&lt;/code&gt;再进行一次&lt;code&gt;+1&lt;/code&gt;操作，写入主存的还是&lt;code&gt;2&lt;/code&gt;，也就是说两个线程对&lt;code&gt;a&lt;/code&gt;共进行了&lt;code&gt;3&lt;/code&gt;次&lt;code&gt;+1&lt;/code&gt;，期望的结果是&lt;code&gt;3&lt;/code&gt;，最终得到的结果却是&lt;code&gt;2&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决&lt;strong&gt;缓存一致性问题&lt;/strong&gt;，就要保证&lt;strong&gt;可见性&lt;/strong&gt;，思路也很简单，变量写入主存后，把其他线程缓存的该变量清空，这样其他线程缓存未命中，就会去主存加载。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7373929590865842&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nz5r5xzvcibKlFtALe7Ldo3K2ZfZkF2hovNPjPCld6h7D4Y3ro9FbERfT1s0zS5Zj2Th6Hiay5eNxHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1051&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程A执行流程&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;A&lt;/code&gt;从缓存获取变量&lt;code&gt;a&lt;/code&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;缓存未命中，从主存复制到缓存，此时&lt;code&gt;a&lt;/code&gt;是&lt;code&gt;0&lt;/code&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;A&lt;/code&gt;获取变量&lt;code&gt;a&lt;/code&gt;，执行计算&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;计算结果&lt;code&gt;1&lt;/code&gt;，写入缓存&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;计算结果&lt;code&gt;1&lt;/code&gt;，写入主存，并清空线程&lt;code&gt;B&lt;/code&gt;缓存&lt;code&gt;a&lt;/code&gt;变量&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程B执行流程&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;B&lt;/code&gt;从缓存获取变量&lt;code&gt;a&lt;/code&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;缓存未命中，从主存复制到缓存，此时&lt;code&gt;a&lt;/code&gt;是&lt;code&gt;1&lt;/code&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;B&lt;/code&gt;获取变量a，执行计算&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;计算结果&lt;code&gt;2&lt;/code&gt;，写入缓存&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;计算结果&lt;code&gt;2&lt;/code&gt;，写入主存，并清空线程&lt;code&gt;A&lt;/code&gt;缓存&lt;code&gt;a&lt;/code&gt;变量&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;A&lt;/code&gt;、&lt;code&gt;B&lt;/code&gt;两个线程执行完后，线程&lt;code&gt;A&lt;/code&gt;缓存是空的，此时线程A再进行一次&lt;code&gt;+1&lt;/code&gt;操作，会从主存加载（先从缓存中获取，缓存未命中，再从主存复制到缓存）得到&lt;code&gt;2&lt;/code&gt;，最后写入主存的是&lt;code&gt;3&lt;/code&gt;，&lt;code&gt;Java&lt;/code&gt;中提供了&lt;code&gt;volatile&lt;/code&gt;修饰变量保证&lt;strong&gt;可见性&lt;/strong&gt;（本文重点是&lt;code&gt;J M M&lt;/code&gt;，所以不会对&lt;code&gt;volatile&lt;/code&gt;做过多的解读）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看似问题都解决了，然而上面描述的场景是建立在理想情况（&lt;strong&gt;线程有序的执行&lt;/strong&gt;），实际中线程可能是并发（&lt;strong&gt;交替执行&lt;/strong&gt;），也可能是并行，只保证&lt;strong&gt;可见性&lt;/strong&gt;仍然会有问题，所以还需要保证&lt;strong&gt;原子性&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;原子性&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;原子性&lt;/strong&gt;是指一个或者多个操作在&lt;code&gt;C P U&lt;/code&gt;执行的过程中不被中断的特性，要么执行，要不执行，不能执行到一半，为了直观的了解什么是&lt;strong&gt;原子性&lt;/strong&gt;，看看下面这段代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;int a=0;&lt;br/&gt;a++;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;原子性操作：&lt;code&gt;int a=0&lt;/code&gt;只有一步操作，就是赋值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非原子操作：&lt;code&gt;a++&lt;/code&gt;有三步操作，读取值、计算、赋值&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果多线程场景进行&lt;code&gt;a++&lt;/code&gt;操作，仅保证&lt;strong&gt;可见性&lt;/strong&gt;，没有保证&lt;strong&gt;原子性&lt;/strong&gt;，同样会出现问题。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7420998980632009&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nz5r5xzvcibKlFtALe7Ldo3KJ4AQk0nxu1gvQ6JD9wOHOJuOIwlbBcqa7B26wDKV0Og8xBLvdjudXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;981&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;并发场景（线程交替执行）&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;A&lt;/code&gt;读取变量&lt;code&gt;a&lt;/code&gt;到缓存，&lt;code&gt;a&lt;/code&gt;是&lt;code&gt;0&lt;/code&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;进行&lt;code&gt;+1&lt;/code&gt;运算得到结果&lt;code&gt;1&lt;/code&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;切换到&lt;code&gt;B&lt;/code&gt;线程&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;code&gt;B&lt;/code&gt;线程执行完整个流程，&lt;code&gt;a=1&lt;/code&gt;写入主存&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;A&lt;/code&gt;恢复执行，把结果&lt;code&gt;a=1&lt;/code&gt;写入缓存与主存&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;最终结果错误&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;并行场（线程同时执行）&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;A&lt;/code&gt;与线程&lt;code&gt;B&lt;/code&gt;同时执行，可能线程&lt;code&gt;A&lt;/code&gt;执行运算&lt;code&gt;+1&lt;/code&gt;的时候，线程&lt;code&gt;B&lt;/code&gt;就已经全部执行完成，也可能两个线程同时计算完，同时写入，不管是那种，结果都是错误的。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决此问题，只要把多个操作变成一步操作，即保证&lt;strong&gt;原子性&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6750700280112045&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nz5r5xzvcibKlFtALe7Ldo3KHF58hCExYpMlLUZY7EGUBYTmatkYr6v47G37HYRJvbqR5dzv2jetkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;714&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Java&lt;/code&gt;中提供了&lt;code&gt;synchronized&lt;/code&gt;（&lt;strong&gt;同时满足有序性、原子性、可见性&lt;/strong&gt;）可以保证结果的原子性（&lt;strong&gt;注意这里的描述&lt;/strong&gt;），&lt;code&gt;synchronized&lt;/code&gt;保证原子性的原理很简单，因为&lt;code&gt;synchronized&lt;/code&gt;可以对代码片段上锁，防止多个线程并发执行同一段代码（本文重点是&lt;code&gt;J M M&lt;/code&gt;，所以不会对&lt;code&gt;synchronized&lt;/code&gt;做过多的解读）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5281899109792285&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nz5r5xzvcibKlFtALe7Ldo3K8SEwouwpPIFH2BUHJW73bvkoUKXzjz8PMJhk0BZ2gvEJxkdDwAIEEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1348&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;并发场景（线程&lt;code&gt;A&lt;/code&gt;与线程&lt;code&gt;B&lt;/code&gt;交替执行）&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;A&lt;/code&gt;获取锁成功&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;A&lt;/code&gt;读取变量&lt;code&gt;a&lt;/code&gt;到缓存，进行&lt;code&gt;+1&lt;/code&gt;运算得到结果&lt;code&gt;1&lt;/code&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;此时切换到了&lt;code&gt;B&lt;/code&gt;线程&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;B&lt;/code&gt;获取锁失败，阻塞等待&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;切换回线程&lt;code&gt;A&lt;/code&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;A&lt;/code&gt;执行完所有流程，主存&lt;code&gt;a=1&lt;/code&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程A释放锁成功，通知线程&lt;code&gt;B&lt;/code&gt;获取锁&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程B获取锁成功，读取变量&lt;code&gt;a&lt;/code&gt;到缓存，此时&lt;code&gt;a=1&lt;/code&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程B执行完所有流程，主存&lt;code&gt;a=2&lt;/code&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程B释放锁成功&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;并行场景&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;A&lt;/code&gt;获取锁成功&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;B&lt;/code&gt;获取锁失败，阻塞等待&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;A&lt;/code&gt;读取变量&lt;code&gt;a&lt;/code&gt;到缓存，进行&lt;code&gt;+1&lt;/code&gt;运算得到结果&lt;code&gt;1&lt;/code&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;A&lt;/code&gt;执行完所有流程，主存&lt;code&gt;a=1&lt;/code&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;A&lt;/code&gt;释放锁成功，通知线程&lt;code&gt;B&lt;/code&gt;获取锁&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;B&lt;/code&gt;获取锁成功，读取变量&lt;code&gt;a&lt;/code&gt;到缓存，此时&lt;code&gt;a=1&lt;/code&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;B&lt;/code&gt;执行完所有流程，主存&lt;code&gt;a=2&lt;/code&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;B&lt;/code&gt;释放锁成功&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;synchronized&lt;/code&gt;对共享资源代码段上锁，达到互斥效果，天然的解决了无法保证&lt;strong&gt;原子性、可见性、有序性&lt;/strong&gt;带来的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然在并行场&lt;code&gt;A&lt;/code&gt;线程还是被中断了，切换到了&lt;code&gt;B&lt;/code&gt;线程，但它依然需要等待&lt;code&gt;A&lt;/code&gt;线程执行完毕，才能继续，所以结果的原子性得到了保证。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;有序性&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在日常搬砖写代码时，可能大家都以为，程序运行时就是按照编写顺序执行的，但实际上不是这样，编译器和处理器为了优化性能，会对代码做重排，所以语句实际执行的先后顺序与输入的代码顺序可能一致，这就是&lt;strong&gt;指令重排序&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能读者们会有疑问“指令重排为什么能优化性能？”，其实&lt;code&gt;C P U&lt;/code&gt;会对重排后的指令做并行执行，达到优化性能的效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;重排序前的指令&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7966101694915254&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nz5r5xzvcibKlFtALe7Ldo3KZTnw7zheJjRtTQqxHYcynSqoBQyNd8WCrxnFvuad7TtfEhMsGITV2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;767&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;重排序后的指令&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7609022556390977&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nz5r5xzvcibKlFtALe7Ldo3KEOURe4eGsWH23iak4FDE4QHLwL5CVR30GFHo0U3xAdibwNOmcBavLnrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;665&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重排序后，对&lt;code&gt;a&lt;/code&gt;操作的指令发生了改变，节省了一次&lt;code&gt;Load a&lt;/code&gt;和&lt;code&gt;Store a&lt;/code&gt;，达到性能优化效果，这就是重排序带来的好处。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重排遵循&lt;code&gt;as-if-serial&lt;/code&gt;原则，编译器和处理器不会对&lt;strong&gt;存在数据依赖关系&lt;/strong&gt;的操作做重排序，因为这种重排序会改变执行结果（&lt;strong&gt;即不管怎么重排序，单线程程序的执行结果不能被改变&lt;/strong&gt;），下面这种情况，就属于数据依赖。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;int i = 10&lt;br/&gt;int j = 10&lt;br/&gt;//这就是数据依赖，int i 与 int j 不能排到 int c下面去&lt;br/&gt;int c = i + j&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但也仅仅只是针对单线程，多线程场景可没这种保证，假设&lt;code&gt;A、B&lt;/code&gt;两个线程，线程&lt;code&gt;A&lt;/code&gt;代码段无数据依赖，线程&lt;code&gt;B&lt;/code&gt;依赖线程&lt;code&gt;A&lt;/code&gt;的结果，如下图（&lt;strong&gt;假设保证了可见性&lt;/strong&gt;）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8477777777777777&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nz5r5xzvcibKlFtALe7Ldo3KfTClzelnrkUu99F8B7YQAiaHZIicg7IWosSMcFN0scclSAuhXyTlxTHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;禁止重排场景（i默认0）&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;A&lt;/code&gt;执行&lt;code&gt;i = 10&lt;/code&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;A&lt;/code&gt;执行&lt;code&gt;b = true&lt;/code&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;B&lt;/code&gt;执行&lt;code&gt;if( b )&lt;/code&gt;通过验证&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;B&lt;/code&gt;执行&lt;code&gt;i = i + 10&lt;/code&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;最终结果&lt;code&gt;i&lt;/code&gt;是&lt;code&gt;20&lt;/code&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;重排场景（i默认0）&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;A&lt;/code&gt;执行&lt;code&gt;b = true&lt;/code&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;B&lt;/code&gt;执行&lt;code&gt;if( b )&lt;/code&gt;通过验证&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;B&lt;/code&gt;执行&lt;code&gt;i = i + 10&lt;/code&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程&lt;code&gt;A&lt;/code&gt;执行&lt;code&gt;i = 10&lt;/code&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;最终结果&lt;code&gt;i&lt;/code&gt;是&lt;code&gt;10&lt;/code&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为解决重排序，使用Java提供的&lt;code&gt;volatile&lt;/code&gt;修饰变量同时保证&lt;strong&gt;可见性、有序性&lt;/strong&gt;，被&lt;code&gt;volatile&lt;/code&gt;修饰的变量会加上&lt;strong&gt;内存屏障禁止排序&lt;/strong&gt;（本文重点是&lt;code&gt;J M M&lt;/code&gt;，所以不会对&lt;code&gt;volatile&lt;/code&gt;做过多的解读）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;三大特性的保证&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;特性&lt;/th&gt;&lt;th&gt;volatile&lt;/th&gt;&lt;th&gt;synchronized&lt;/th&gt;&lt;th&gt;Lock&lt;/th&gt;&lt;th&gt;Atomic&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;可见性&lt;/td&gt;&lt;td&gt;可以保证&lt;/td&gt;&lt;td&gt;可以保证&lt;/td&gt;&lt;td&gt;可以保证&lt;/td&gt;&lt;td&gt;可以保证&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;原子性&lt;/td&gt;&lt;td&gt;无法保证&lt;/td&gt;&lt;td&gt;可以保证&lt;/td&gt;&lt;td&gt;可以保证&lt;/td&gt;&lt;td&gt;可以保证&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;有序性&lt;/td&gt;&lt;td&gt;一定程度保证&lt;/td&gt;&lt;td&gt;可以保证&lt;/td&gt;&lt;td&gt;可以保证&lt;/td&gt;&lt;td&gt;无法保证&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;关于我&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是阿星，一个热爱技术的Java程序猿，公众号  &lt;strong&gt;&lt;span&gt;「程序猿阿星」&lt;/span&gt;&lt;/strong&gt; 里将会定期分享操作系统、计算机网络、Java、分布式、数据库等精品原创文章，2021，与您在 Be Better 的路上共同成长！。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常感谢各位小哥哥小姐姐们能 看到这里，原创不易，文章有帮助可以「点个赞」或「分享与评论」，都是支持（莫要白嫖）！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;愿你我都能奔赴在各自想去的路上，我们下篇文章见！&lt;/p&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a40985235bc5acf268d666650448e995</guid>
<title>Linux 网络新技术基石：​eBPF 和 XDP</title>
<link>https://toutiao.io/k/goswbka</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;hi，大家好，欢迎来到极客重生的世界，今天给大家分享的是Linux 网络新技术，当前正流行网络技是什么？那就是eBPF和XDP技术，&lt;/span&gt;Cilium+eBPF超级火热，Google GCP也刚刚全面转过来。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span&gt;新技术出现的历史原因&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2 mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;廉颇老矣，尚能饭否&lt;/span&gt;&lt;/strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/h2&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;iptables/netfilter&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;iptables/netfilter 是上个时代Linux网络提供的优秀的防火墙技术，扩展性强，能够满足当时大部分网络应用需求，如果不知道iptables/netfilter是什么&lt;span&gt;&lt;span&gt;，&lt;/span&gt;请参考之前文章：&lt;/span&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyMTIzMTkzNA==&amp;amp;mid=2247506496&amp;amp;idx=1&amp;amp;sn=c629e22f0de944c0940ffb3a665b726f&amp;amp;chksm=c1842d11f6f3a407e2200d28da9033c23a411bdc64f85ddb756c0ff36d660eed38338e611d1f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;一个奇葩的网络问题，把技术砖家&quot;搞蒙了&quot;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt; ，&lt;/span&gt;里面对iptables/netfilter技术有详细介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但该框架也存在很多明显问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;netfilter&lt;/span&gt;&lt;span&gt; 框架在IP层，报文需要经过链路层，IP层才能被处理，如果是需要丢弃报文，会白白浪费很多CPU资源，影响整体性能；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7893432465923172&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6nibzSpsZlIHwzjIYJa7ZvTUTzgGyucfcmrV2oXL2ymlIdupS3CYy2PGO1giazNRUoPiblCIxQHWnwQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;807&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上图所示，极端情况下，报文需要依次遍历所有规则，才能匹配中，极大影响报文处理性能；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;netfilter 框架类似一套可以自由添加策略规则专家系统，并没有对添加规则进行合并优化，这些都严重依赖操作人员技术水平，随着规模的增大，规则数量n成指数级增长，而报文处理又是0（n）复杂度，最终性能会直线下降。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;内核协议栈&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5740112994350283&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6nj6QFbU1dhIQWqgwbG7hdO6LiaDTLXrYBBrLKicTMBU9Gc9ibNo3mXMEdwIia1XaYFuQFP83om89s9zg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;885&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着互联网流量越来愈大, 网卡性能越来越强，Linux内核协议栈在10Mbps/100Mbps网卡的慢速时代是没有任何问题的，那个时候应用程序大部分时间在等网卡送上来数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在到了1000Mbps/10Gbps/40Gbps网卡的时代，数据被很快地收入，协议栈复杂处理逻辑，效率捉襟见肘，把大量报文堵在内核里。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;各类链表在多CPU环境下的同步开销。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;不可睡眠的软中断路径过长。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;sk_buff的分配和释放。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;内存拷贝的开销。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;上下文切换造成的cache miss。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;…&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是，内核协议栈各种优化措施应着需求而来：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;网卡RSS，多队列。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;中断线程化。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分割锁粒度。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Busypoll。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;…&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但却都是见招拆招，治标不治本。问题的根源不是这些机制需要优化，而是这些机制需要推倒重构。蒸汽机车刚出来的时候，马车夫为了保持竞争优势，不是去换一匹昂贵的快马，而是卖掉马去买一台蒸汽机装上。基本就是这个意思。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;重构的思路很显然有两个：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;upload方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;别让应用程序等内核了，让应用程序自己去网卡直接拉数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;offload方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;别让内核处理网络逻辑了，让网卡自己处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总之，绕过内核就对了，内核协议栈背负太多历史包袱。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;DPDK&lt;/strong&gt;&lt;/span&gt;让用户态程序直接处理网络流，bypass掉内核，使用独立的CPU专门干这个事。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;XDP&lt;/strong&gt;&lt;/span&gt;让灌入网卡的eBPF程序直接处理网络流，bypass掉内核，使用网卡NPU专门干这个事&lt;strong&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如此一来，内核协议栈就不再参与数据平面的事了，留下来专门处理诸如路由协议，远程登录等控制平面和管理平面的数据流。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;改善iptables/netfilter的规模瓶颈，提高Linux内核协议栈IO性能，&lt;/span&gt;&lt;span&gt;内核需要提供新解决方案，那就是eBPF/XDP框架，让我们来看一看，这套框架是如何解决问题的。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span&gt;eBPF到底是什么?&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;‍‍‍‍‍&lt;/span&gt;e&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;BPF的历史&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;BPF 是 Linux 内核中高度灵活和高效的类似虚拟机的技术，允许以安全的方式在各个挂钩点执行字节码。它用于许多 Linux 内核子系统，最突出的是网络、跟踪和安全（例如沙箱）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5352112676056338&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6mhcZBGEw04CPU7YpgGCQ21YHTH1k6dfB5BDCT6JX9btibcIvzOISVcgMXJSeM7BXPfovUDC7KfWMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;781&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;BPF架构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;BPF 是一个通用目的 RISC 指令集，其最初的设计目标是：用 C 语言的一个子集编 写程序，然后用一个编译器后端（例如 LLVM）将其编译成 BPF 指令，稍后内核再通 过一个位于内核中的（in-kernel）即时编译器（JIT Compiler）将 BPF 指令映射成处理器的原生指令（opcode ），以取得在内核中的最佳执行性能。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.603082851637765&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6nj6QFbU1dhIQWqgwbG7hdOzQtJSNSrwLLvaLnOHqcTXJaOcZf3XBWAq9a2OdiaFddB6039nsDaahA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;519&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;BPF指令&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;尽管 BPF 自 1992 年就存在，扩展的 Berkeley Packet Filter (eBPF) 版本首次出现在 Kernel3.18中，如今被称为“经典”BPF (cBPF) 的版本已过时。许多人都知道 cBPF是tcpdump使用的数据包过滤语言。现在Linux内核只运行 eBPF，并且加载的 cBPF 字节码在程序执行之前被透明地转换为内核中的eBPF表示。除非指出 eBPF 和 cBPF 之间的明确区别，一般现在说的BPF就是指eBPF。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;e&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;BPF总体设计&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5630397236614854&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6mhcZBGEw04CPU7YpgGCQ21ckKpFCZ7s0c5M3nbgw3y68WbLJoficiaGS9STIyxZBRia8cHnOdfqn6Bw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1158&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;BPF 不仅通过提供其指令集来定义自己，而且还通过提供围绕它的进一步基础设施，例如充当高效键/值存储的映射、与内核功能交互并利用内核功能的辅助函数、调用其他 BPF 程序的尾调用、安全加固原语、用于固定对象（地图、程序）的伪文件系统，以及允许将 BPF 卸载到网卡的基础设施。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;LLVM 提供了一个 BPF后端，因此可以使用像 clang 这样的工具将 C 编译成 BPF 目标文件，然后可以将其加载到内核中。BPF与Linux 内核紧密相连，允许在不牺牲本机内核性能的情况下实现完全可编程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;eBPF总体设计包括以下几个部分：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;eBPF Runtime&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4381918819188192&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6mhcZBGEw04CPU7YpgGCQ21S0hYUdncRriaWljziaUCKOJ7XOQ1UAswCCYliaFI7icYtrEV0SZPtTRGSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1084&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;eBPF Hooks&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5679245283018868&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6mhcZBGEw04CPU7YpgGCQ21ZfPGXWKXeYTfHLLAa2IKDic6hUfPnHVK6GiaBs301SYiaRyNId2y5ZwjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1060&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;eBPF Maps&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4386792452830189&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6mhcZBGEw04CPU7YpgGCQ21tPibo2ibZxjrwk0e76g8iaJpdHwCFwfgsE6o1dKd66uF9xrXOT3J0RDxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1060&quot;/&gt;&lt;/p&gt;&lt;p&gt;Map 类型&lt;/p&gt;&lt;p&gt;- Hash tables, Arrays&lt;/p&gt;&lt;p&gt;- LRU (Least Recently Used)&lt;/p&gt;&lt;p&gt;- Ring Buffer&lt;/p&gt;&lt;p&gt;- Stack Trace&lt;/p&gt;&lt;p&gt;- LPM (Longest Prefix match)&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;作用&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;程序状态&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;程序配置&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;程序间共享数据&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;和用户空间共享状态、指标和统计&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;eBPF Helpers&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.40384615384615385&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6mhcZBGEw04CPU7YpgGCQ21DLLOvQrSbBIgPOxYWzeXefgibrJao4M4DxibibSX5txvGkgIlf6rKpicvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1040&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有哪些Helpers？&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;随机数&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;获取当前时间&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;map访问&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;获取进程/cgroup 上下文&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;处理网络数据包和转发&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;访问套接字数据&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;执行尾调用&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;访问进程栈&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;访问系统调用参数&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;...&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;eBPF Tail and Function Calls&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2611336032388664&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6mhcZBGEw04CPU7YpgGCQ21bvdQhByhRib1icXPaj8nEG4pVSh5d0TvUygSzfWGdEBibDPbp9kFuRZlw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;988&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;尾调用有什么用？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;● 将程序链接在一起&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;● 将程序拆分为独立的逻辑组件&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;● 使 BPF 程序可组合&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;函数调用有什么用？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;● 重用内部的功能程序&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;● 减少程序大小（避免内联）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;eBPF JIT Compiler&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6120058565153733&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6mhcZBGEw04CPU7YpgGCQ21mfgzOuEDWO2oyHkTEVlcFW3b8qyk8ickEuT9kTicEWibuwLBuyL3gNibPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;683&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;确保本地执行性能而不需要了解CPU&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将 BPF字节码编译到CPU架构特定指令集&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;eBPF可以做什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.575139146567718&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6mhcZBGEw04CPU7YpgGCQ21mqT3QgJoEibaGNrAPCBaezMtw51MY6RDrjkywQMKeVL9d261588fLwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;539&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;eBPF 开源 Projects&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6mhcZBGEw04CPU7YpgGCQ21NaHTwMbtGUaibbicBCQGicnDxvO1gakP3XvS3A37ktNylBAYgDzoZyYsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Cilium&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;‍‍‍‍&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5733113673805601&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6mhcZBGEw04CPU7YpgGCQ21pDs2SmzusloP8Cvn11WMg51JQOR7lH4XVic7jmvr1nAf58osX1g485w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;607&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5869106263194933&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6nj6QFbU1dhIQWqgwbG7hdOVIIpxGsRdOTXelMILzjDQmUz9NCMgC22JnicHLvia1YLQZVvKXrttZnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1421&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Cilium&lt;/span&gt;在它的 datapath 中重度&lt;/span&gt;&lt;span&gt;使用了 BPF 技术&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6mhcZBGEw04CPU7YpgGCQ21phKN4IBgqM8BhcJ3dcM0lviaGFbrTsQPs6IAqg2nSCqE2xg7PovZo3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Cilium 是位于 Linux kernel 与容器编排系统的中间层。向上可以为容器配置网络，向下可以向 Linux 内核生成 BPF 程序来控制容器的安全性和转发行为。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;利用 Linux BPF，Cilium 保留了透明地插入安全可视性 + 强制执行的能力，但这种方式基于服务 /pod/ 容器标识（与传统系统中的 IP 地址识别相反），并且可以根据应用层进行过滤 （例如 HTTP）。因此，通过将安全性与寻址分离，Cilium 不仅可以在高度动态的环境中应用安全策略，而且除了提供传统的第 3 层和第 4 层分割之外，还可以通过在 HTTP 层运行来提供更强的安全隔离&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;BPF 的使用使得 Cilium 能够以高度可扩展的方式实现以上功能，即使对于大规模环境也不例外&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对比传统容器网络（采用iptables/netfilter）：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5601851851851852&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/cYSwmJQric6nj6QFbU1dhIQWqgwbG7hdOMmTjR3KaiaxVD1Oeic86ibXic8ftqAKPoeI1HXiazvBIbP9L5f9fdhsVvrA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;eBPF主机路由允许绕过主机命名空间中所有的 iptables 和上层网络栈，以及穿过Veth对时的一些上下文切换，以节省资源开销。网络数据包到达网络接口设备时就被尽早捕获，并直接传送到Kubernetes Pod的网络命名空间中。在流量出口侧，数据包同样穿过Veth对，被eBPF捕获后，直接被传送到外部网络接口上。eBPF直接查询路由表，因此这种优化完全透明。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;基于eBPF中的kube-proxy网络技术正在替换基于iptables的kube-proxy技术，与Kubernetes中的原始kube-proxy相比，eBPF中的kuber-proxy替代方案具有一系列重要优势，例如更出色的性能、可靠性以及可调试性等等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;BCC(BPF Compiler Collection)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;BCC 是一个框架，它使用户能够编写嵌入其中的 eBPF 程序的 Python 程序。该框架主要针对涉及应用程序和系统分析/跟踪的用例，其中 eBPF 程序用于收集统计信息或生成事件，用户空间中的对应部分收集数据并以人类可读的形式显示。运行 python 程序将生成 eBPF 字节码并将其加载到内核中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4077568134171908&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6mhcZBGEw04CPU7YpgGCQ21z7ElGK2CyNlPWiadEQ4dN0JKfouXjmcIGCbR7YkzjQp5cZu9gEV53yw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;954&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;bpftrace&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;bpftrace 是一种用于 Linux eBPF 的高级跟踪语言，可在最近的 Linux 内核 (4.x) 中使用。bpftrace 使用 LLVM 作为后端将脚本编译为 eBPF 字节码，并利用 BCC 与 Linux eBPF 子系统以及现有的 Linux 跟踪功能进行交互：内核动态跟踪 (kprobes)、用户级动态跟踪 (uprobes) 和跟踪点. bpftrace 语言的灵感来自 awk、C 和前身跟踪器，例如 DTrace 和 SystemTap。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3924731182795699&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6mhcZBGEw04CPU7YpgGCQ21gAw4gv6HhkzJjqmwbBheAxVtsl4uCSMHr9zYyVjiavlFXAYE5zc5gDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;930&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;eBPF Go 库&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;eBPF Go 库提供了一个通用的 eBPF 库，它将获取 eBPF 字节码的过程与 eBPF 程序的加载和管理解耦。eBPF 程序通常是通过编写高级语言创建的，然后使用 clang/LLVM 编译器编译为 eBPF 字节码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5287846481876333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6mhcZBGEw04CPU7YpgGCQ21D4ZF1sFleoI6w86ksriaQv9zGhBa1XcX7B6lqUFPFxYLEnlzs7xic6bg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;938&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;libbpf C/C++ 库&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;libbpf 库是一个基于 C/C++ 的通用 eBPF 库，它有助于解耦从 clang/LLVM 编译器生成的 eBPF 目标文件加载到内核中，并通过提供易于使用的库 API 来抽象与 BPF 系统调用的交互应用程序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5120925341745531&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6mhcZBGEw04CPU7YpgGCQ21zS9gak7grtSYlDdITV1pYXF2P6BScdWZnR0h2mYAXzbwib7Am6hYA6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;951&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span&gt;那XDP又是什么?&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;XDP的全称是：&lt;strong&gt; eXpress Data Path&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;XDP 是Linux 内核中提供高性能、可编程的网络数据包处理框架。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;XDP整体框架&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6mhcZBGEw04CPU7YpgGCQ21yEsfia4WFia9sz6NXOFx163Wt5ymHQjbeQ4pib52eOPkAzIsgRPuzxtCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;XDP总体设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.0681818181818181&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6mhcZBGEw04CPU7YpgGCQ21oiblJrLqn4u6psXmQMOHX0v69bb9nrn2RxYhXlCuYxQvKqG6oRMB4aA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;616&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;XDP总体设计包括以下几个部分：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;XDP驱动&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;网卡驱动中XDP程序的一个挂载点，每当网卡接收到一个数据包就会执行这个XDP程序；XDP程序可以对数据包进行逐层解析、按规则进行过滤，或者对数据包进行封装或者解封装，修改字段对数据包进行转发等；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;BPF虚拟机&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;并没有在图里画出来，一个XDP程序首先是由用户编写用受限制的C语言编写的，然后通过clang前端编译生成BPF字节码，字节码加载到内核之后运行在eBPF虚拟机上，虚拟机通过即时编译将XDP字节码编译成底层二进制指令；eBPF虚拟机支持XDP程序的动态加载和卸载；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;BPF maps&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;存储键值对，作为用户态程序和内核态XDP程序、内核态XDP程序之间的通信媒介，类似于进程间通信的共享内存访问；用户态程序可以在BPF映射中预定义规则，XDP程序匹配映射中的规则对数据包进行过滤等；XDP程序将数据包统计信息存入BPF映射，用户态程序可访问BPF映射获取数据包统计信息；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;BPF程序校验器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;XDP程序肯定是我们自己编写的，那么如何确保XDP程序加载到内核之后不会导致内核崩溃或者带来其他的安全问题呢？程序校验器就是在将XDP字节码加载到内核之前对字节码进行安全检查，比如判断是否有循环，程序长度是否超过限制，程序内存访问是否越界，程序是否包含不可达的指令；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;XDP Action&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;XDP用于报文的处理，支持如下action：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;enum xdp_action {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    XDP_ABORTED = 0,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    XDP_DROP,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    XDP_PASS,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    XDP_TX,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    XDP_REDIRECT,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;br/&gt;&lt;/pre&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;XDP_DROP&lt;/span&gt;&lt;span&gt;：在驱动层丢弃报文，通常用于实现DDos或防火墙&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;XDP_PASS&lt;/span&gt;&lt;span&gt;：允许报文上送到内核网络栈，同时处理该报文的CPU会分配并填充一个skb，将其传递到GRO引擎。之后的处理与没有XDP程序的过程相同。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;XDP_TX&lt;/span&gt;&lt;span&gt;：&lt;span&gt;从当前网卡发送出去&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;XDP_REDIRECT&lt;/span&gt;&lt;span&gt;：&lt;span&gt;从其他网卡发送出去&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;XDP_ABORTED&lt;/span&gt;&lt;span&gt;：表示程序产生了异常，其行为和 XDP_DROP相同，但 &lt;/span&gt;&lt;span&gt;XDP_ABORTED&lt;/span&gt;&lt;span&gt; 会经过 trace_xdp_exception tracepoint，因此可以通过 tracing 工具来监控这种非正常行为。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;AF_XDP&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;AF_XDP 是为高性能数据包处理而优化的地址族，AF_XDP 套接字使 XDP 程序可以将帧重定向到用户空间应用程序中的内存缓冲区。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;XDP设计原则&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;XDP 专为高性能而设计。它使用已知技术并应用选择性约束来实现性能目标&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;XDP 还具有可编程性。无需修改内核即可即时实现新功能&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;XDP 不是内核旁路。它是内核协议栈的快速路径&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;XDP 不替代TCP/IP 协议栈。与协议栈协同工作&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;XDP 不需要任何专门的硬件。它支持网络硬件的少即是多原则&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;XDP技术优势&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;及时处理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;高性能优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;无锁设计&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;批量I/O操作&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不需要分配skbuff&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持网络卸载&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持网卡RSS&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;指令虚拟机&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;可扩展模型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持应用处理（如应用层协议GRO）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持将BPF程序卸载到网卡&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;BPF程序可以移植到用户空间或其他操作系统&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;可编程性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;包检测，BPF程序发现的动作&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;灵活（无循环）协议头解析&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可能由于流查找而有状态&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;简单的包字段重写（encap/decap）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;XDP 工作模式&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;XDP 有三种工作模式，默认是 &lt;code&gt;native&lt;/code&gt;（原生）模式，当讨论 XDP 时通常隐含的都是指这 种模式。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Native XDP&lt;/span&gt;&lt;/p&gt;&lt;p&gt;默认模式，在这种模式中，XDP BPF 程序直接运行在网络驱动的早期接收路径上（ early receive path）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Offloaded XDP&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在这种模式中，XDP BPF程序直接 offload 到网卡。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Generic XDP&lt;/span&gt;&lt;/p&gt;&lt;p&gt;对于还没有实现 native 或 offloaded XDP 的驱动，内核提供了一个 generic XDP 选 项，这种设置主要面向的是用内核的 XDP API 来编写和测试程序的开发者，对于在生产环境使用XDP，推荐要么选择native要么选择offloaded模式&lt;span&gt;‍‍‍‍‍&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;XDP vs DPDK&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5131195335276968&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6mhcZBGEw04CPU7YpgGCQ219cJF9wSlSJUZxLRMu8Zj1MNRWxBvNWVbT97ciaIpCATchL742BA1nicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;686&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;相对于DPDK，XDP：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;优点&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;无需第三方代码库和许可&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;同时支持轮询式和中断式网络&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;无需分配大页&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;无需专用的CPU&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;无需定义新的安全网络模型&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;缺点&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;注意XDP的性能提升是有代价的，它牺牲了通用型和公平性&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;如何选择？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;XDP适合场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DDoS防御&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;防火墙&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;基于XDP_TX的负载均衡&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;网络统计&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;流量监控&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;栈前过滤/处理&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;...&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;XDP例子&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下面是&lt;span&gt;一个最小的完整 XDP 程序&lt;/span&gt;，实现丢弃包的功能（&lt;code&gt;xdp-example.c&lt;/code&gt;）：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#include &amp;lt;linux/bpf.h&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#ifndef __section&lt;br/&gt;# define __section(NAME)                  \&lt;br/&gt;   __attribute__((section(NAME), used))&lt;br/&gt;#endif&lt;br/&gt;&lt;/span&gt;&lt;br/&gt;__section(&lt;span&gt;&quot;prog&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;xdp_drop&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt; xdp_md &lt;span&gt;*&lt;/span&gt;ctx)&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; XDP_DROP;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;char&lt;/span&gt; __license[] __section(&lt;span&gt;&quot;license&quot;&lt;/span&gt;) &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;GPL&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;用下面的命令编译并加载到内核：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;clang &lt;span&gt;-O2&lt;/span&gt; &lt;span&gt;-Wall&lt;/span&gt; &lt;span&gt;-target&lt;/span&gt; bpf &lt;span&gt;-c&lt;/span&gt; xdp-example.c &lt;span&gt;-o&lt;/span&gt; xdp-example.o&lt;br/&gt;&lt;span&gt;$ &lt;/span&gt;ip &lt;span&gt;link set &lt;/span&gt;dev em1 xdp obj xdp-example.o&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以上命令将一个 XDP 程序 attach 到一个网络设备，需要是 Linux 4.11 内核中支持 XDP 的设备，或者 4.12+ 版本的内核。&lt;span/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;eBPF/XDP 作为Linux网络革新技术正在悄悄改变着Linux网络发展模式。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;eBPF正在将Linux内核转变为微内核，越来越多的新内核功能采用eBPF实现，让新增内核功能更加快捷高效。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;总&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;体而言，基于业界基准测试结果，eBPF 显然是解决具有挑战性的云原生需求的最佳技术。&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;参考&amp;amp;延伸阅读&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;The eXpress Data Path: &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Fast Programmable Packet Processing in
the Operating System Kernel&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://docs.cilium.io/en/v1.6/bpf/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;bpf-rethinkingthelinuxkernel-200303183208&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://ebpf.io/what-is-ebpf/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.kernel.org/doc/html/latest/networking/af_xdp.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://cilium.io/blog/2021/05/11/cni-benchmark&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://blog.csdn.net/dog250/article/details/107243696&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;看完一键三连&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在看&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;，&lt;span&gt;&lt;strong&gt;转发&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;点赞&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;是对文章最大的赞赏，极客重生感谢你&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6nibzSpsZlIHwzjIYJa7ZvTU7Ea6w4tv8iaCVELpNF3ib1sSO8RKd6nVpiblWPVuib3fC2q4iagOXKGywag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-mid=&quot;t4&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyMTIzMTkzNA==&amp;amp;mid=2247510568&amp;amp;idx=1&amp;amp;sn=79f335aaab5c0a36c0a66c5bfb1619ae&amp;amp;chksm=c1845d79f6f3d46f81b6fd24335eb8994c9daf21b6846d80af2cad73d9f638c5dda48b02892c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;图解Linux 内核TCP/IP 协议栈实现|Linux网络硬核系列&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyMTIzMTkzNA==&amp;amp;mid=2247507565&amp;amp;idx=1&amp;amp;sn=a8b175c3ce3cfd8932ce4002c1769084&amp;amp;chksm=c184293cf6f3a02a6134fb9d713450099518317a836a8225f26f252e1f3a345802e05dedaff1&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;网络排障全景指南手册v1.0精简版pdf&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyMTIzMTkzNA==&amp;amp;mid=2247506496&amp;amp;idx=1&amp;amp;sn=c629e22f0de944c0940ffb3a665b726f&amp;amp;chksm=c1842d11f6f3a407e2200d28da9033c23a411bdc64f85ddb756c0ff36d660eed38338e611d1f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;一个奇葩的网络问题&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;284&quot; data-backw=&quot;482&quot; data-ratio=&quot;0.5886454183266933&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6lUKBHKhPTpV4yeia7QkuK3dBTbkEFS5vYqfBsXeT0ZW8cjUnxft7IBiblia6NfVdA1yA3ffLnUKHCOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1004&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4d2b9639f2f550a56bbee7aeb02615f3</guid>
<title>十二张图，踹开消息队列的大门</title>
<link>https://toutiao.io/k/bfhn09h</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;消息队列つ登场&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是老三，是一个电商公司的程序员，负责订单系统的开发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;掉了不少头发之后，我完成了用户订单支付的开发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;订单支付的业务是这样的。用户支付完成之后，我需要更新订单状态，这一部分是在本系统完成的。接下来，我要调用库存系统，减库存，好了，剩下的就是库存系统的事情了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2714508580343214&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeE5gzC3zlmXKQbOOoKBsIicm1Q0OqMtibEB8VS0jkSXmRs3uqwC9vhvJibPPPJCPazmYdAm3brR1E1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;641&quot;/&gt;&lt;figcaption&gt;订单支付-1&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发、联调、测试、上线，我的小日子变得清闲起来，每天就是在群里吹牛打屁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可是没过两天，产品妹子，找过来了，她说，她想加个功能，用户完成订单支付以后，要增加用户的积分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没问题，so easy，噼里啪啦，我两天就做完了，无非是调用一下会员系统。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeE5gzC3zlmXKQbOOoKBsIicCAZQicIjZK0OpgRPlJ9Phpc1xcS0QHU5KBtb2VwHp0UCEUIAtibYfqibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;figcaption&gt;订单支付-2&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这天，正和沙雕群友斗图的时候，产品妹子过来，他说要接入消息系统，好，搞！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又过两天，她说要添加营销系统，行吧，干！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又过两天，她说要搞推荐系统，嗯……，来吧！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又过两天……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是系统就变成了这个样子：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.852359208523592&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeE5gzC3zlmXKQbOOoKBsIicmjP260QicOf22UOoUdmh6VvH9c0SLc7EstvibEUicao2876rnfThIBlEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;657&quot;/&gt;&lt;figcaption&gt;订单支付-3&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就这样，我过上了暗无天日的日子，我要维护和若干个系统的对接，每次他们发布新版本，我都要跟着值班。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我要迭代，也要改和几个系统的对接代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;周一，营销系统；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;周二，库存系统；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这天，眼圈发黑的我正在和下游服务撕巴的时候，突然忍不住两腿战战，她来了，产品&lt;span&gt;妹&lt;/span&gt;（女）&lt;span&gt;子&lt;/span&gt;（王）来了——她是我不能拒绝的女人。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;脆弱的眼泪流了满面，我的猿生一片灰暗……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没想到，代救星出现了，我的好朋友傲天过来了，拿鼻孔看着我。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“你个Loser，竟不知道用消息队列，怪不得天天被人欺负，哼！”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一语惊醒梦中人，为什么不用消息队列啊？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是我引入消息队列，对系统进行了重构。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7621621621621621&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeE5gzC3zlmXKQbOOoKBsIicN8f4fFWvMgLcugqgLkpFOFIc5IqsH1sFV22IyxlWTPssCeq513Vp3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;740&quot;/&gt;&lt;figcaption&gt;消息队列重构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这下好了，我只管&lt;code&gt;更新订单状态&lt;/code&gt;，剩下的丢给消息队列，你们这些下游自己去消息队列消费消息就好了，别来缠着我了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入消息队列之后，又是一个闲适的下午。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我没有在群聊里扯扯，因为我退群了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前几天，我受到了前所未有的伤害——&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我在群里嘲讽一个老哥，技术真菜，连消息队列都不会！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老哥反手就发出他和女朋友的合照，“单身狗，技术好又怎么样，连个女朋友都没有！”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我瞬间san值狂掉！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“程序员单身，不算单身……new个对象的事，能算单身么？”接连着便是什么难懂的话，什么“没有妹子”，什么“哲学”之类，引得众人都哄笑起来，群里充满了快活的空气。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是，这个下午我盯着空空如也的需求单发呆，公司真的没有妹子么？……&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;好了，冗长的前奏结束了，接下来该进入正文了😂。&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;消息队列つ用途&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的前言中，我们已经了解了消息队列最重要的一个用途：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过消息队列，降低系统间的耦合，避免过多的调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就好像公司的行政小姐姐要通知一件事情，她通常会是在群里发一个公告，然后我们扣1就行了。要是一个个通知，她要通知几十上百次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是上面我们提到的订单支付，支付之后，我们要扣减库存、增加积分、发送消息等等，这样一来这个链路就长了，链路一长，响应时间就变长了。引入消息队列，除了&lt;code&gt;更新订单状态&lt;/code&gt;，其它的都可以&lt;strong&gt;异步&lt;/strong&gt;去做，这样一来就来，就能更快地响应我们的上游。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7268195413758723&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeE5gzC3zlmXKQbOOoKBsIicY4jy7PECwwibIInP8C2wg7gMysM9xicFnibSRb9vlVooSeuiap8yMGx0Eg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1003&quot;/&gt;&lt;figcaption&gt;消息队列异步&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么不用多线程之类的方式做异步呢？——&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;嗨，只用多线程做异步，不是还得写代码去调那一堆下游吗，所以这又回到了解耦这个问题上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息队列同样可以用来削峰。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用一个比喻，一条河流，假如它的下游能容纳的水量是有限的，为了防止洪水冲垮堤坝，我们应该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以在上游修建一个水库，洪峰来的时候，我们先把水给蓄起来，闸口里只放出下游能承受地住的水量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;放在我们的系统，也是一个道理。比如秒杀系统，平时流量很低，但是要做秒杀活动，秒杀的时候流量疯狂怼进来，你的服务器，&lt;strong&gt;Redis&lt;/strong&gt;，&lt;strong&gt;MySQL&lt;/strong&gt;各自的承受能力都不一样，直接全部流量照单全收肯定有问题啊，严重点可能直接打挂了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以一样，我们可以把请求放到队列里面，只放出我们下游服务能处理的流量，这样就能抗住短时间的大流量了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2372448979591837&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeE5gzC3zlmXKQbOOoKBsIicPpuKRSiaPibfBibSSfibLhR7FTBahFp8NYdWvJbkYhiaOtmw8vqYZfkZNhg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;392&quot;/&gt;&lt;figcaption&gt;削峰&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了这三大用途之外，还可以利用队列本身的顺序性，来满足消息必须按顺序投递的场景；利用队列 + 定时任务来实现消息的延时消费 ……&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;消息队列つ本质&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过气老北鼻马老师有三招——&lt;code&gt;接&lt;/code&gt;、&lt;code&gt;化&lt;/code&gt;、&lt;code&gt;发&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息队列核心有三板斧：&lt;code&gt;发&lt;/code&gt;、&lt;code&gt;存&lt;/code&gt;、&lt;code&gt;消费&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产者先将消息投递一个叫做「队列」的容器中，然后再从这个容器中取出消息，最后再转发给消费者[1]。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.25340599455040874&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeE5gzC3zlmXKQbOOoKBsIicVKfMM7fKkeaticgNiaW087CswoKlWWgeftUpcJbkZVoOibJrK6nxlZE2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;734&quot;/&gt;&lt;figcaption&gt;消息队列核心&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这个图便是消息队列最原始的模型，它包含了消息队列中的一两个关键词&lt;code&gt;消息&lt;/code&gt;和队列&lt;code&gt;队列&lt;/code&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;消息：就是要传输的数据，可以是最简单的文本字符串，也可以是自定义的复杂格式。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;队列：大家应该再熟悉不过了，是一种先进先出数据结构。它是存放消息的容器，消息从队尾入队，从队头出队，入队即发消息的过程，出队即收消息的过程。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以消息队列的本质就是&lt;strong&gt;把要传输的数据放在队列中。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;围绕着这个本质：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;把数据放到消息队列的角色就是&lt;code&gt;生产者&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;把数据从队列中取出的就是&lt;code&gt;消费者&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;消息队列つ模型&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[1]我们上面已经了解了消息队列模型的本质，随着应用场景的变化，消息队列的模型逐渐发生了一些演进。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就好像我们的文字通讯，最开始单对单地发消息，后来可以群发，再后来，可以拉一个群聊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最初的消息队列就是上一节讲的原始模型，它是一个严格意义上的队列（Queue）。消息按照什么顺序写进去，就按照什么顺序读出来。不过，队列没有 “读” 这个操作，读就是出队，从队头中 “删除” 这个消息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2691771269177127&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeE5gzC3zlmXKQbOOoKBsIicMw97nyZBdHp8N5CbLibOoVeiaj3BeOkxiaJf9SbvSUPY8UFliaGnJB85tg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;717&quot;/&gt;&lt;figcaption&gt;队列模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有多个生产者往同一个队列里面发送消息，这个队列中可以消费到的消息，就是这些生产者生产的所有消息的合集。消息的顺序就是这些生产者发送消息的自然顺序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有多个消费者接收同一个队列的消息，这些消费者之间实际上是竞争的关系，每个消费者只能收到队列中的一部分消息，也就是说任何一条消息只能被其中的一个消费者收到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果需要将一份消息数据分发给多个消费者，并且每个消费者都要求收到全量的消息。很显然，队列模型无法满足这个需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个可行的方案是：为每个消费者创建一个单独的队列，让生产者发送多份。这种做法比较笨，而且同一份数据会被复制多份，也很浪费空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，就演化出了另外一种消息模型：发布-订阅模型。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4049586776859504&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeE5gzC3zlmXKQbOOoKBsIicD3ibc4rwibFfHDBHslEd7m5NBPBfNQSkWHdKqNShWKPic4BVb3Sczg9Fw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;847&quot;/&gt;&lt;figcaption&gt;发布-订阅模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在发布 -  订阅模型中，消息的发送方称为发布者（Publisher），消息的接收方称为订阅者（Subscriber），服务端存放消息的容器称为主题（Topic）。发布者将消息发送到主题中，订阅者在接收消息之前需要先“订阅主题”。“订阅”在这里既是一个动作，同时还可以认为是主题在消费时的一个逻辑副本，每份订阅中，订阅者都可以接收到主题的所有消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仔细对比下它和 “队列模式” 的异同：生产者就是发布者，队列就是主题，消费者就是订阅者，无本质区别。唯一的不同点在于：一份消息数据是否可以被多次消费。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;消息队列つ代价&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;天下没有白吃的午餐——这句话放在系统设计中同样适用。引入了消息队列，解决了一些问题，但同时也增加了系统的复杂性和维护成本。[5]&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面说，我们引入了消息队列，降低了系统间的耦合，但是，我们对消息队列的依赖也变重了，想想，要是消息队列挂了，那我们下游就全凉了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8208955223880597&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeE5gzC3zlmXKQbOOoKBsIic6CwZPy7qia7T3ia3EFHHPic2nVUv3Hdy3PPut0mpGmYPdIMfEmbXUhbnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;737&quot;/&gt;&lt;figcaption&gt;消息队列故障&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我们消息队列的部署必须保证高可用，至少是&lt;code&gt;主/从&lt;/code&gt;，一般都得&lt;code&gt;集群/分布式&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们将数据写到消息队列上，下游服务没来得及取消息队列的数据，突然挂了。&lt;strong&gt;如果没有做任何的措施，我们的数据就丢了&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4957983193277311&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeE5gzC3zlmXKQbOOoKBsIiceDxg1kNAxj1GQv9ZOtlS1yGJq1t0HoZ7Tgucib1MUD6vEhtOGA7nXYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;595&quot;/&gt;&lt;figcaption&gt;消息丢失&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那可怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息队列中的数据得想办法存在别的地方，这样才尽可能减少数据的丢失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题又来了，存在哪呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同步存储还是异步存储？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要是我们网络延迟或者什么原因，导致下游重复消费怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们这个问题是在消息队列解决？还是在下游服务解决？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有其它的顺序消息等等问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些问题都是选型时候需要充分考虑的。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;消息队列つ选择&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前在市面上比较主流的主要有四大消息中间件：&lt;strong&gt;Kafka、ActiveMQ、RabbitMQ、RocketMQ&lt;/strong&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它们的对比我整理了一张图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;2.0169172932330826&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeE5gzC3zlmXKQbOOoKBsIic7icKJ51RAUChicibicW0QogMyfjxYyDO0IAx204qUoLHEnepVtdJT8mBMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1596&quot;/&gt;&lt;figcaption&gt;四大消息队列对比&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;消息队列つ终焉&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，到这我们就了解了消息队列的一些基础的知识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;门外汉，这个门，你入了吗？我反正是在里面打滚了。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&quot;简单的事情重复做，重复的事情认真做，认真的事情有创造性地做！&quot;——&lt;/p&gt;&lt;p&gt;我是三分恶，一个能文能武的全栈开发。&lt;/p&gt;&lt;p&gt;&lt;code&gt;点赞&lt;/code&gt;、&lt;code&gt;关注&lt;/code&gt;不迷路，咱们下期见！&lt;/p&gt;&lt;/blockquote&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;big data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/big&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;section&gt;&lt;span&gt;[1].《吃透MQ系列》核心基础全在这里了(https://www.cnblogs.com/luojunwu/p/14478927.html)&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[2].《进大厂系列》系列-消息队列基础(https://www.cnblogs.com/aobing/p/11893352.html)&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[3].知乎问答：消息队列怎么能通俗点解释？(https://www.zhihu.com/question/321144623)&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[4].系统学习消息队列分享（四） 消息模型：主题和队列有什么区别？(https://www.cnblogs.com/wt645631686/p/11409005.html)&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[5].什么是消息队列？(https://juejin.cn/post/6844903817348136968)&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7ec43d0a1ec680cd6f0ac370578364e8</guid>
<title>常见的软件设计原则</title>
<link>https://toutiao.io/k/424q2hi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;戳蓝字「TopCoder&lt;/span&gt;&lt;span&gt;」关注我们哦！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;290&quot; data-backw=&quot;504&quot; data-croporisrc=&quot;https://mp.weixin.qq.com/cgi-bin/photogalleryproxy?action=proxy&amp;amp;url=https%3A%2F%2Finews.gtimg.com%2Fnewsapp_bt%2F0%2F5002a6gmh3kqgk44%2F0%3Fappid%3D764c87a2b97faf28&amp;amp;supplier=5&amp;amp;from_public_pic=1&quot; data-cropx1=&quot;48.120209059233446&quot; data-cropx2=&quot;946.3641114982578&quot; data-cropy1=&quot;42.77351916376307&quot; data-cropy2=&quot;557.8379790940767&quot; data-ratio=&quot;0.5746102449888641&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jOD3PUUxTibMm6KwZyghlfMDzb9Ylt3NdEb5M9jWWlKpdE1kVVPGBtzWZ4IeibYV0SkYWU82rMYIm1sN6kGqPQVA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;898&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;设计模式就是软件设计中沉淀出的一些代码设计经验，设计模式主要是基于OOP角度来总结的。&lt;/p&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;软件设计原则的目的是 代码复用性、代码可扩展性、代码可维护性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;常见的软件设计原则分为：&lt;strong&gt;单一职责、开闭原则、接口隔离、里式替换、迪米特原则、依赖倒置原则&lt;/strong&gt;。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;单一职责&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;一个类或者方法只有一个职责，只有一个引起它变化的原因。&lt;/p&gt;&lt;p&gt;如果一个类有2个以上的职责，这些职责就耦合在一起了，会导致其中一个变化时，会影响到其他责任。多个职责耦合在一起，会影响代码复用性、对测试不友好。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;开闭原则&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;开闭原则就是说对扩展开放，对修改关闭。&lt;/p&gt;&lt;p&gt;在程序需要进行拓展的时候，尽量不去修改原有的代码，实现一个热插拔的效果。一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，通过实现类达到扩展需求。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;里氏代换原则&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;里氏代换原则(Liskov Substitution Principle LSP)是面向对象设计的基本原则之一。里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;依赖倒置原则&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;所谓依赖倒置原则（Dependence Inversion Principle）就是要&lt;strong&gt;依赖于抽象，不要依赖于具体实现&lt;/strong&gt;。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。&lt;/p&gt;&lt;p&gt;实现开闭原则的关键是抽象化，并且从抽象化导出具体化实现，如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要手段。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;接口隔离原则&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;接口隔离原则(Interface  Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;迪米特法则&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。也就是说一个软件实体应当尽可能少的与其他实体发生相互作用。这样，当一个模块修改时，就会尽量少的影响其他的模块，扩展会相对容易，这是对软件实体之间通信的限制，它要求限制软件实体之间通信的宽度和深度。&lt;/p&gt;&lt;p&gt;日常开发工作中，使用上述设计原则虽然不能保证写出完美的系统，但是可以保证系统实现不会差，基本的扩展性可维护性还是能够满足的。如果有些场景下，不能严格按照软件设计原则来实现，起码的隔离性要求还是要满足的，这样才能保证在后续修改时控制影响面，避免改动牵一发而动全身。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-style-type=&quot;2&quot; data-tools=&quot;新媒体排版&quot; data-id=&quot;8633&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt; 推荐阅读 &lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;figure&gt;&lt;span/&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>