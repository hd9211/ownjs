<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f9c14c8b1030d7499ee68a8e043f8f44</guid>
<title>做业务系统研发如何做到认真负责？</title>
<link>https://toutiao.io/k/6iusrlx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;相信大家都有这样的问题，天天写业务代码的程序员，怎么成为技术大牛？下面给大家分享下我对这个问题的看法，仅代表个人看法，比较粗浅，希望大家不要介意。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序员大部分在做这两种事情，一是通过技术支持业务部门，二是通过技术支持技术部门，我们大部分做的是前者，因为前者的岗位比较多，例如几百人的技术部门，基础平台组也就 20 人左右，还有大部分公司的盈利还是靠业务，所以支持业务部门的程序员非常重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务代码整天做的并不全是对数据库的 CRUD ，它是搭建在各种业务基础框架代码之上的，其实业务的基础框架并没有足够完美到让我们纯粹只做 CRUD 之类的工作，还是有很多需要完善的地方，这都是写业务代码需要考虑的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来基于研发流程角度，分享程序员在业务系统开发中如何做到认真负责。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;开发前做好需求评估&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需求评估会上，一定要弄清楚这 3 个问题：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需求评估后再进行开发内部技术评审，涉及到 数据库设计、接口设计、第三方接口交互等，同时还要考虑代码的封装性、可维护性、可扩展性等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发人员也尽量提供一份功能改动点的文档出来，说清楚改动了哪些点，哪些重要的点被改动了，让测试人员做好评估。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;提测前做好冒烟测试&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与测试人员过冒烟测试用例时一定要拉上产品经理，主要是为了保证新功能完整性，旧功能回归场景是否全，有无漏掉的场景等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发人员需积极主动地推动联调工作，同时对涉及到的主流程进行自测，保证主流程没问题，便于测试人员的工作顺利开展。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果涉及到 C 端用户的接口，需要对接口进行压测，通过压测发现瓶颈所在，提早优化。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;上线前做好回滚预案&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提前做好上线准备：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;考虑代码合并是否有冲突，如果有冲突提前做好合并工作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果涉及到 SQL，提前整理出涉及到的 SQL 语句，不要临时上线出现漏掉的情况，同时还要考虑历史数据是否需要修复。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果涉及到后台管理系统，提前配置好 RBAC 的权限。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果涉及到定时脚本，提前配置好 Job 的执行任务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果涉及到配置，提前做好准备。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提前做好回滚预案：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;根据各自的发布系统，提前做好回滚方案，涉及到多端的提前沟通好。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果涉及到改动比较大，必须使用灰度发布，先用小部分流量测试，慢慢再开放全量。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;上线后密切观察指标&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日志监控：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;容器性能监控，查看内存、CPU 曲线是否正常；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用次数、响应时长及 HTTP 状态码监控；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异常业务状态码告警时，需要输出堆栈信息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对外提供的接口，记录响应时间、入参、出参，需考虑敏感数据脱敏；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用第三方服务，记录响应时间、入参、出参；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据监控：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;新增用户数监控；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发送短信数监控；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用优惠券订单数监控；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;退款订单数监控；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;未支付订单数监控；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;... 等等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上线后需要密切关注以上指标，查看有无超预期情况、接口超时情况、接口错误日志等。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;业务群反馈&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果上线后，产品/业务在群里反馈一些异常数据，需要排查的，不要每次都通过代码去定位，要考虑做成小工具让产品/业务自己使用，不要每次都反馈到研发处理。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;加分项&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;需求的分析能力，对产品的了解和掌握；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;行业知识背景，对行业市场的技术方案把握；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;技术框架的熟悉、设计能力；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;努力抽象出跨项目可用的代码库。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;及时汇报；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;业务是饭碗，业务做不好，其他什么都别谈，业务才是解决用户问题的核心。&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3649122807017544&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/go9jpG3BuhSgPWaHKyJBicNNsuF8w3M8icxO4FapeT1fHQIicegugNFQeaXIn78Sld4zmbvbWHCK0DmqXj1rS5LibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1710&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f363a3a8f8b32b0ea642349b24311898</guid>
<title>什么是 TMD 的 MVP（最小可行性产品）?</title>
<link>https://toutiao.io/k/t4xmyfk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry&quot;&gt;
      
        &lt;p&gt;&lt;img src=&quot;http://qiniu.gafata.com/2021-01-25-Untitled.png?imageView2/2/w/600&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;No, 今天我们说的不是詹姆斯。&lt;/p&gt;
&lt;p&gt;而是&lt;/p&gt;
&lt;p&gt;Minimum Viable Product(MVP) – 最小可实行产品&lt;/p&gt;
&lt;a id=&quot;more&quot;/&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.gafata.com/2021-01-25-Untitled%201.png?imageView2/2/w/600&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这张图很流行，在很多地方都能看到。很多人也是看完之后会心一笑，但却很少人真的能遵循这样的MVP原则来开发自己的产品。下面我们就来解释下图片背后到底是在说什么？&lt;/p&gt;
&lt;h1 id=&quot;第一种示例：错误的方式&quot;&gt;&lt;a href=&quot;#第一种示例：错误的方式&quot; class=&quot;headerlink&quot; title=&quot;第一种示例：错误的方式&quot;/&gt;第一种示例：错误的方式&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://qiniu.gafata.com/2021-01-25-Untitled%202.png?imageView2/2/w/600&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一排的图片是错误的方式开发产品&lt;/p&gt;
&lt;p&gt;很多的项目的失败是因为直到产品100%完成之后才发布。然而，人们普遍会产生疑问-谁会花钱买个半成品？&lt;/p&gt;
&lt;p&gt;“先生，这是我们的第一个版本的产品，一个轮子，你觉得怎么样？”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.gafata.com/2021-01-25-Untitled%203.png?imageView2/2/w/600&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用户肯定会说“你为什么给我的是一个车轮子？我要的是一辆汽车！你让我那个车轮子当独轮车吗？”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.gafata.com/2021-01-25-Untitled%204.png?imageView2/2/w/600&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当每次的产品接近完成的时候，用户会很生气的使用你的产品。因为这些只是车零件的一部分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.gafata.com/2021-01-25-Untitled%205.png?imageView2/2/w/600&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个例子里，用户最终很高兴得到了他的汽车。但现实情况却往往不是这样的。过程中，大部分时间里是没有经过用户的使用测试的，最终做出来的产品很可能不是用户需要的。所以，这个笑脸只是理想中的情况。&lt;/p&gt;
&lt;p&gt;不管怎样，第一排的过程是错误的。理论上是渐进迭代式的，但是由于缺少实际的反馈，因此风险很大-而且并不灵活。&lt;/p&gt;
&lt;h1 id=&quot;第二种示例-应该是这样&quot;&gt;&lt;a href=&quot;#第二种示例-应该是这样&quot; class=&quot;headerlink&quot; title=&quot;第二种示例 - 应该是这样&quot;/&gt;第二种示例 - 应该是这样&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://qiniu.gafata.com/2021-01-25-Untitled%206.png?imageView2/2/w/600&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们来用不同的方式。我们还是同样的需求 - 用户订购了一辆车。但是这次我们不仅仅是造一辆车。取而代之的是我们以满足用户潜在需求为出发点。事实证明，他的基本需求是“我需要更快地从A到达B”，而汽车只是解决这一问题的一种可能。汽车只是一个隐喻，你可以认为是任何一种定制产品的开发情况。&lt;/p&gt;
&lt;p&gt;因此，团队应该提供他们能想到的最小的东西，从而使客户进行测试并得到反馈。有人可能将其称为MVP（最小可行性产品），但将其称为最早可测试产品更贴切。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.gafata.com/2021-01-25-Untitled%207.png?imageView2/2/w/600&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随便你叫它什么（根据这个隐喻……有人称他们的第一个版本为产品的“滑板版本”）。&lt;/p&gt;
&lt;p&gt;客户不太可能对此感到满意。这离他订购的汽车很远。没关系！这是关键-目前我们不希望使客户满意。我们可能会让一些早期使用者感到高兴，但目前我们的主要目标只是学习。理想情况下，会事先向客户明确说明这一点，因此用户也不会太失望。&lt;/p&gt;
&lt;p&gt;但是，与第一种情况中的车轮不一样，滑板实际上是一种可用的产品，可以帮助客户从A转到B。虽然不是很好，但总比没有好。因此，我们告诉客户“不用担心，项目尚未完成，这只是许多迭代中的第一个。我们仍然打算制造一辆汽车，但与此同时，请尝试一下并希望给我们反馈。”大胆思考，但以实用可行性的产品迭代交付。&lt;/p&gt;
&lt;p&gt;我们可能会学到一些真正令人惊讶的东西。 假设客户说他讨厌滑板，我们问为什么，然后他说“我讨厌颜色”。 我们就像“呃…。 颜色？ 就这样？”。 客户说：“是的，把它变蓝！ 除此之外，还可以！”。 &lt;/p&gt;
&lt;p&gt;关键问题是“我们开始思考最便宜，最快捷的方式是什么？” 我们能比滑板早交付一些东西吗？ 汽车票可以吗？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.gafata.com/2021-01-25-Untitled%208.png?imageView2/2/w/600&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这会帮助解决客户的问题吗？ 也许（也许不是），但是我们一定会通过将其交到实际用户手中来学习一些东西。 精益创业提供了一个很好的模型，该模型基于列出有关用户的实际假设，然后系统地进行验证。&lt;/p&gt;
&lt;p&gt;你不需要在所有用户上测试产品，也不需要构建产品来测试某些产品。 即使在单个用户上测试原型，也将教给你更多的知识。&lt;/p&gt;
&lt;p&gt;但是，回到滑板示例。&lt;/p&gt;
&lt;p&gt;在办公室里玩了一会滑板之后，客户说：“好吧，很有趣，它的确使我更快的去到咖啡机旁边。但这很不稳定。 我太容易掉下来了。”&lt;/p&gt;
&lt;p&gt;因此，下一次迭代我们将尝试解决该问题，或者至少了解更多有关它的信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.gafata.com/2021-01-25-Untitled%209.png?imageView2/2/w/600&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;客户现在可以在办公室附近闲逛而不会掉下来！&lt;/p&gt;
&lt;p&gt;用户快乐吗？并非如此，他仍然有点想要那辆车。但与此同时，他实际上正在使用该产品，并向我们提供了反馈。他最大的抱怨是，由于车轮小且没有间断，很难在建筑物之间走更长的距离。因此，下一次发布时，产品变成了自行车。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.gafata.com/2021-01-25-Untitled%2010.png?imageView2/2/w/600&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，客户可以在建筑物之间进行活动。 Yiihaaa！&lt;/p&gt;
&lt;p&gt;我们在这个过程中了解到了一些东西：客户喜欢新鲜空气的感觉。客户主要是在建筑物之间四处走动。&lt;/p&gt;
&lt;p&gt;自行车可能比最初设想的汽车是更好的产品。实际上，在测试该产品时，我们可能会发现对于汽车而言，路径太窄了。我们只是节省了客户大量的时间和金钱，并在更少的时间内为他提供了更好的产品！&lt;/p&gt;
&lt;p&gt;现在你可能在想：“我们可以通过对客户背景和需求的前期分析？”想法不错，但是在我所见过的大多数实际产品开发场景中，无论你进行了多少前期分析，当将第一个实际发行版交到真实用户手中时，你仍然会感到惊讶，而且跟你想象的甚至完全相反。&lt;/p&gt;
&lt;p&gt;是的，进行一些前期分析，在开始开发之前尽可能多地发现问。但是，不要花太多时间在上面，也不要过于相信分析 - 开始进行原型设计和发布，这是真正的有价值的东西。&lt;/p&gt;
&lt;p&gt;无论如何，回到故事。也许客户想要更多。有时他需要去另一个城市，而自行车骑行太慢且出汗。因此，在下一次迭代中，我们添加了一个引擎。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.gafata.com/2021-01-25-Untitled%2011.png?imageView2/2/w/600&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该模型特别适用于软件产品，因为软件很“软”。可以随时随地“变形”产品，而不是每次都必须重建硬件。但是，即使在硬件项目中，提供原型来观察和学习客户如何使用你的产品也有巨大的好处。只是迭代趋向于更长一些（几个月而不是几周）。甚至像丰田和特斯拉这样的实际汽车公司在开发新汽车模型之前也进行了大量原型设计（草图，3D模型，全尺寸粘土模型等）。&lt;/p&gt;
&lt;p&gt;那么现在怎么办？同样，也许顾客对摩托车感到满意。我们可以比计划提前结束项目。大多数产品到处都是没人使用的复杂性和功能。迭代方法实际上是一种更少交付，并用最简单的、便宜的方法解决用户问题。从而不断的趋向于完美。&lt;/p&gt;
&lt;p&gt;再一次，客户可以选择是否继续修改需求而继续。实际上，我们最终可能会得到与最初设想的完全相同的汽车。但是，在此过程中，我们会获得重要的见识，而最终得到一些稍有不同的东西。像这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.gafata.com/2021-01-25-Untitled%2012.png?imageView2/2/w/600&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;顾客喜出望外！ 为什么？ 因为我们过程中了解到他喜欢新鲜空气，所以最终得到了一辆敞篷车。 毕竟他确实得到了一辆车，但是比原先计划的要好！&lt;/p&gt;
&lt;p&gt;因此，让我们思考一下。&lt;/p&gt;
&lt;p&gt;”你的滑板是什么？“&lt;br/&gt;最上面的情景（轮胎的交付方式）很糟糕，因为我们一直在交付客户根本无法使用的东西。除非你知道自己在做什么-你的产品几乎没有什么复杂性和风险，也许你已经完成了数百次此类工作-然后从头再来，在一切准备就绪之后交付。&lt;/p&gt;
&lt;p&gt;但是，我见过的大多数产品开发工作都过于复杂且冒险，”完美的产品”方法经常导致巨大的昂贵失败。所以关键的问题是你的“滑板”是什么？&lt;/p&gt;
&lt;p&gt;在产品开发中，应该做的第一件事（在描述了您要为谁解决的问题之后）是确定你的滑板对应的产出对象。可以将滑板视为比喻为最小的东西，你可以将其交给实际用户并获得真实的反馈。&lt;/p&gt;
&lt;p&gt;这将为你提供急需的反馈循环，并为你和客户提供对项目的控制权-你可以过程中不断学习和进行更改，而不仅仅是遵循计划并希望最终会有一个好结果。&lt;/p&gt;
&lt;p&gt;让我们来看一些真实的例子。&lt;/p&gt;
&lt;h1 id=&quot;例子1：Spotify音乐播放器&quot;&gt;&lt;a href=&quot;#例子1：Spotify音乐播放器&quot; class=&quot;headerlink&quot; title=&quot;例子1：Spotify音乐播放器&quot;/&gt;例子1：Spotify音乐播放器&lt;/h1&gt;&lt;p&gt;Spotify现在是一款非常漂亮的产品。 但开始不是这样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.gafata.com/2021-01-25-Untitled%2013.png?imageView2/2/w/600&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作为2006年的一家初创公司，Spotify的建立基于一些关键假设：人们喜欢流媒体音乐，唱片公司和艺术家希望人们合法地使用音乐，并且从技术上来说，快速稳定的流媒体是可行的。记住，这是在2006年，当时播放器（如Real Player）是一种非常糟糕的体验，而盗版音乐随处可见。 挑战的技术部分是：“当按下‘播放’按钮时，是否有可能使客户立即播放音乐？ 是否有可能摆脱令人讨厌的‘缓冲’进度条？”&lt;/p&gt;
&lt;p&gt;从小处开始并不意味着你不能从大处着想。 这是他们构想的早期草图之一：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.gafata.com/2021-01-25-Untitled%2014.png?imageView2/2/w/600&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Spotify没有花非常多时间在打造一个完整的产品，从假设是否成立出发，坐下来来并Hack了一个技术原型，放入笔记本电脑上的任何翻录音乐，然后开始进行疯狂的实验以寻找方法来使播放快速稳定。交付指标是“从按下播放到听到音乐需要多少毫秒？”。效果是它应该立即播放，并继续流畅播放而不会出现卡顿现象！&lt;/p&gt;
&lt;p&gt;“我们无聊地花了很多时间来关注延迟，因为没人关心，因为我们一心想让你感觉硬盘上拥有世界上所有音乐。对小细节的痴迷有时会使一切变得不同。我认为这是对最小可行产品概念的最大误解。这就是MVP中的V。” -Daniel Ek，Spotify联合创始人兼首席执行官&lt;/p&gt;
&lt;p&gt;一旦他们有了能看的过去的东西，他们就开始对自己，家人和朋友进行测试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.gafata.com/2021-01-25-Untitled%2015.png?imageView2/2/w/600&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最初的版本无法发布给更多的听众，它完全没有打磨，除了能够找到和播放一些硬编码的歌曲外，基本上没有其他功能，也没有法律协议或商业模式。 那是他们的“滑板”。&lt;/p&gt;
&lt;p&gt;但是他们无耻地将滑板交到了真正的用户（朋友和家人）手中，他们很快就得到了所需的答案。是的，这在技术上是可能的。是的，人们绝对喜欢这个产品（或更喜欢这个产品将来的样子）！ 假设得到验证！ 这个运行中的原型帮助说服了音乐唱片公司和投资者。&lt;/p&gt;
&lt;h1 id=&quot;例子2：LinkedIn&quot;&gt;&lt;a href=&quot;#例子2：LinkedIn&quot; class=&quot;headerlink&quot; title=&quot;例子2：LinkedIn&quot;/&gt;例子2：LinkedIn&lt;/h1&gt;&lt;p&gt;LinkedIn于2003年5月5日成立，创建于联合创始人Reid Hoffman的客厅。 在一个月内，有4,500位用户注册。 现在，它已经被微软收购，在全球拥有5亿名用户。 而这是他们的第一个版本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.gafata.com/2021-01-25-Untitled%2016.png?imageView2/2/w/600&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h1 id=&quot;例子3：Facebook&quot;&gt;&lt;a href=&quot;#例子3：Facebook&quot; class=&quot;headerlink&quot; title=&quot;例子3：Facebook&quot;/&gt;例子3：Facebook&lt;/h1&gt;&lt;p&gt;Facebook在全球拥有19.4亿用户，这是地球上最受欢迎的社交网络，另外还有两个主要平台Instagram和WhatsApp。 创始人马克·扎克伯格（Mark Zuckerberg）于2004年在哈佛大学的宿舍里和几个朋友一起创立了Facebook。早期的版本看起来并不像每天使用的Facebook一样多，但足以吸引纽约广告公司和硅谷投资者的注意力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.gafata.com/2021-01-25-Untitled%2017.png?imageView2/2/w/600&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.gafata.com/2021-01-25-Untitled%2018.png?imageView2/2/w/600&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h1 id=&quot;例子4：Airbnb&quot;&gt;&lt;a href=&quot;#例子4：Airbnb&quot; class=&quot;headerlink&quot; title=&quot;例子4：Airbnb&quot;/&gt;例子4：Airbnb&lt;/h1&gt;&lt;p&gt;成立于2008年，Airbnb希望提供一种替代酒店住宿的方式，并为房主在其房屋空置时赚钱提供一种途径。 现在，Airbnb在65,000个城镇和城市中拥有超过300万个房源，迄今已有1.6亿客人次，并以310亿美元的估值筹集了34亿美元的资金。 这就是Airbnb早期的样子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.gafata.com/2021-01-25-Untitled%2019.png?imageView2/2/w/600&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，以上就是全部内容，我们来总结下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MVP只是一个术语，有各种各样的说法，明白其背后的意思，怎么说并不重要。&lt;/li&gt;
&lt;li&gt;避免使用“完美”的交付，进行复杂，创新的产品开发。而要迭代地和增量地进行。&lt;/li&gt;
&lt;li&gt;首先确定你的“滑板”-最早的可测试产品。志存高远，但要收起你的骄傲，做好你的“滑板”。&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;http://qiniu.gafata.com/2020-11-20-indiemaker.jpeg?imageView2/2/w/800&quot;/&gt;&lt;br/&gt;&lt;span&gt;和我一起做独立变现产品吧&lt;/span&gt;&lt;br/&gt;&lt;/center&gt;
      
    &lt;/div&gt;
    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d442b0d5bd525610d2ee382bc60f0853</guid>
<title>价值百万的技术人创业复盘</title>
<link>https://toutiao.io/k/z91auhw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;朝九晚五上下班的人体会不到创业的激情，创过业的人反而更能体会工作中带来的成长，如果你准备创业，看看下面这几条心得体会，也许能少走一些弯路。别人的成功无法复制，但别人的失败，可以给你敲响警钟，让你清醒。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;先找到真正问题再开发对应的产品&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;千万不能颠倒过来，先做出产品再去找市场，让市场来匹配你的产品，很明显这个逻辑是不通的。到市场上寻找问题并解决这个问题，肯定会赢得一部分市场，而市场自然会回馈你利润，那怕是个小而美的存在，做成一个收入的渠道也不错。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;找能力互补的合作伙伴&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;技能同质化很不利于团队的成长，因为你无法获取到其它领域的见解。能力互补才能发挥各自的优势专长，让搞技术的去跑市场做销售，除非他很擅长，否则不专业的人干出的同样是不专业的事。一个团队中如果有外向型人才，如营销销售运营等，相比而言更能存活的长久一些，他们能解决部分公司的生存压力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;避免自融来做产研&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做产研，是一个很烧钱、风险未知的事。虽然每个创业者都想自己做产品，依靠边际利润做大做强，但现实总会教你如何做事更好，等需要继续加大投入时，如果没有外部资金的介入，对团队都是极大的考验。卖房子卖车孤注一掷养团队，最后成事的有，但只是极少数，特别是一些需要投入很大的产研。如果少投入就可以做出来现金流的商业模式，风险倒不是很大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些企业采用迂回技巧发展，先从技术外委服务做起，然后慢慢形成自己的产品，再依托产品销售。眼下SaaS的兴起，很多小需求都有标准化的产品推出；针对中大型企业的解决方案，小企业也无门拉来业务，所以对小微团队而言，生死考验基本是每一天都要面对的事情。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;不要过分喜爱自己的产品&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;人们做决策时，总会受到沉没成本的影响。自己费尽心血耗资巨大，研发出来的产品从心理上是不愿意放弃这个东西，但市场就是市场，不会因为你的幻想而给你买单，你只有迎合他或者承认市场现在运行的方式，才能生存下去，进而才会有发展的可能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创造需求对于大部分人都是不现实的，吴军老师《硅谷来信》中提到的“工程师五个等级理论”，大部分人注定只能在五级或四级之间徘徊，更遑论开创一个行业。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;不可以埋头做产品，忽略了市场&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做产品的过程肯定是一个与市场不断磨合的过程，当市场风向已经发生转变时，即便沉没成本巨大，也要悬崖勒马即时掉头转向，否则会有更多的损失。多数情况下，虽不至于闭门造车，但很多想法要靠拍脑袋拍出来的也不靠谱，哪怕一个小小的功能。简单的可以向目标群体询问意见，有实力的可以做A/B测试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现实中不存在完美的产品，刚好融合完美的市场。忽略了市场声音的产品，最终没有出路，只有关闭服务器，止损出局。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;不熟悉的业务，不碰&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要是你的伙伴懂但你不懂的情况下，很容易陷入被动。当出现问题时，你不知如何去解决，因为你是门外汉。如果一个事态自己不能掌控或没有发言权的话，只能是在边缘带活动，这是一种不长久的状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;钱花了，事做了，最终没成功，你的挫败感更强，你连自己失败的都不知道，更谈不上在行业里的积累。做成了，最后也没你什么事，同样还有挫败感，因为你没深入的参与进去。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我跟他们不一样，我的产品跟他们的也不一样，最后你会发现，其实都很类似，自己并不是出彩的那一个。&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages __bg_gif&quot; data-ratio=&quot;0.18524332810047095&quot; data-type=&quot;gif&quot; data-w=&quot;637&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/pia7eNKm5ribqUytKORCNqLeBt05FGia804Dvp5iaPybs893QB9yC6sM0KuFeJmoYEhBmicSQkJ5vU6aIpKZhyMOeEA/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;独乐乐不如众乐乐&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c0412ddf6613077b2345c71cafdac506</guid>
<title>Go 精妙的互斥锁设计</title>
<link>https://toutiao.io/k/bitszv2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;em&gt;Some people, when confronted with a problem, think, “I know, I’ll use threads,” and then two they hav erpoblesms.&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7870968&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_gif/HR9EgRcLqUsyUfTS2iagtcnf9Zb1ZMSfLL6k1TkEGqUEFkoGVdlu8LNicoibo4owMXiciagW7TOngvwm3PA8D1AS1Cw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;155&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;1. 竞争条件&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;多线程程序在多核CPU机器上访问共享资源时，难免会遇到问题。我们可以来看一个例子&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Cnt &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Add&lt;/span&gt;&lt;span&gt;(iter &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; iter; i++ {&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;        Cnt++&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;}&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;    wg := &amp;amp;sync.WaitGroup{}&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;2&lt;/span&gt;; i++ {&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;        wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;        &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;            Add(&lt;span&gt;100000&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;            wg.Done()&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;        }()&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;    wg.Wait()&lt;br/&gt;&lt;span&gt;19&lt;/span&gt;    fmt.Println(Cnt)&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;很明显，程序的预期结果是200000，但实际的输出却是不可确定的，可能为100910、101364或者其他数值，这就是典型的多线程访问冲突问题。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.1359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/HR9EgRcLqUvZZylnYYweTloiaz06JAB577ot21A9QvE4FwadWZT2RhgOvcsUdMQnCZVTDzYxoqxyNfViba5we3Ig/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;利用&lt;/span&gt;&lt;code&gt;&lt;span&gt;go tool trace&lt;/span&gt;&lt;/code&gt;&lt;span&gt;分析工具（需要在代码中加入&lt;/span&gt;&lt;code&gt;&lt;span&gt;runtime/trace&lt;/span&gt;&lt;/code&gt;&lt;span&gt;包获取程序运行信息，此处省略），查看该程序运行期间goroutine的执行情况如上图所示。其中G20和G19就是执行&lt;/span&gt;&lt;code&gt;&lt;span&gt;Add()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;函数的两个goroutine，它们在执行期间并行地访问了共享变量&lt;/span&gt;&lt;code&gt;&lt;span&gt;Cnt&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;类似这种情况，即两个或者多个线程读写某些共享数据，而最后的结果取决于程序运行的精确时序，这就是&lt;strong&gt;竞争条件&lt;/strong&gt;（race condition）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7870968&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_gif/HR9EgRcLqUsyUfTS2iagtcnf9Zb1ZMSfLL6k1TkEGqUEFkoGVdlu8LNicoibo4owMXiciagW7TOngvwm3PA8D1AS1Cw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;155&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 临界区与互斥&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;怎样避免竞争条件？实际上凡涉及共享内存、共享文件以及共享任何资源的情况都会引发上文例子中类似的错误，要避免这种错误，关键是要找出某种途径来阻止多线程同时读写共享的数据。换言之，我们需要的是&lt;strong&gt;互斥&lt;/strong&gt;（mutual exclusion），即以某种手段确保当一个线程在使用一个共享变量或文件时，其他线程不能做同样的操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们把对共享内存进行访问的程序片段称作&lt;strong&gt;临界区&lt;/strong&gt;（critical section），例如上例中的&lt;/span&gt;&lt;code&gt;&lt;span&gt;Cnt++&lt;/span&gt;&lt;/code&gt;&lt;span&gt;片段。从抽象的角度看，我们希望的多线程行为如下图所示。线程A在t1时刻进入临界区，执行一段时间后，在t2时刻线程B试图进入临界区，但是这是不能被允许的，因为同一时刻只能运行一个线程在临界区内，而此时已经有一个线程在临界区内。我们通过某种互斥手段，将B暂时挂起直到线程A离开临界区，即t3时刻B进入临界区。最后，B执行完临界区代码后，离开临界区。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4921875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/HR9EgRcLqUvZZylnYYweTloiaz06JAB57Bicknb5cE1pIsb6wwWqSafEucGfvvYibcWLmJvZa0RhuJ6w9POIhibEtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;如果我们能够合理地安排，使得两个线程不可能同时处于临界区中，就能够避免竞争条件。因此，我们将代码稍作调整如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; (&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;    Cnt &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;    mu sync.Mutex&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;)&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Add&lt;/span&gt;&lt;span&gt;(iter &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;    mu.Lock()&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; iter; i++ {&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;        Cnt++&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;    mu.Unlock()&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;此时，程序执行得到了预期结果200000。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.15&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/HR9EgRcLqUvZZylnYYweTloiaz06JAB57wRUA1XfSYtIZcKqEREuRfsCxiblXzr8XRKC3nURfPabH93fIsXmfQnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;程序运行期间的执行情况如上图所示。其中G8和G7是执行&lt;/span&gt;&lt;code&gt;&lt;span&gt;Add()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;函数的两个goroutine，通过加入&lt;/span&gt;&lt;code&gt;&lt;span&gt;sync.Mutex&lt;/span&gt;&lt;/code&gt;&lt;span&gt;互斥锁，G8和G7就不再存在竞争条件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要明确的是，只有在多核机器上才会发生竞争条件，只有多线程对共享资源做了写操作时才有可能发生竞态问题，只要资源没有发生变化，多个线程读取相同的资源就是安全的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7870968&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_gif/HR9EgRcLqUsyUfTS2iagtcnf9Zb1ZMSfLL6k1TkEGqUEFkoGVdlu8LNicoibo4owMXiciagW7TOngvwm3PA8D1AS1Cw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;155&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;3. Go互斥锁设计&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;互斥锁是实现互斥功能的常见实现，Go中的互斥锁即&lt;/span&gt;&lt;code&gt;&lt;span&gt;sync.Mutex&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。本文将基于Go 1.15.2版本，对互斥锁的实现深入研究。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;type&lt;/span&gt; Mutex &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;    state &lt;span&gt;int32&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;    sema  &lt;span&gt;uint32&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;}&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; (&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;    mutexLocked = &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;iota&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;    mutexWoken&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;    mutexStarving&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;    mutexWaiterShift = &lt;span&gt;iota&lt;/span&gt;   &lt;span&gt;// mutexWaiterShift值为3，通过右移3位的位运算，可计算waiter个数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;    starvationThresholdNs = &lt;span&gt;1e6&lt;/span&gt; &lt;span&gt;// 1ms，进入饥饿状态的等待时间&lt;/span&gt;&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;state&lt;/span&gt;&lt;/code&gt;&lt;span&gt;字段表示当前互斥锁的状态信息，它是&lt;/span&gt;&lt;code&gt;&lt;span&gt;int32&lt;/span&gt;&lt;/code&gt;&lt;span&gt;类型，其低三位的二进制位均有相应的状态含义。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;mutexLocked&lt;/span&gt;&lt;/code&gt;&lt;span&gt;是&lt;/span&gt;&lt;code&gt;&lt;span&gt;state&lt;/span&gt;&lt;/code&gt;&lt;span&gt;中的低1位，用二进制表示为&lt;strong&gt;0001&lt;/strong&gt;（为了方便，这里只描述后4位），它代表该互斥锁是否被加锁。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;mutexWoken&lt;/span&gt;&lt;/code&gt;&lt;span&gt;是低2位，用二进制表示为&lt;strong&gt;0010&lt;/strong&gt;，它代表互斥锁上是否有被唤醒的goroutine。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;mutexStarving&lt;/span&gt;&lt;/code&gt;&lt;span&gt;是低3位，用二进制表示为&lt;strong&gt;0100&lt;/strong&gt;，它代表当前互斥锁是否处于饥饿模式。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;state&lt;/span&gt;&lt;/code&gt;&lt;span&gt;剩下的29位用于统计在互斥锁上的等待队列中goroutine数目（&lt;/span&gt;&lt;code&gt;&lt;span&gt;waiter&lt;/span&gt;&lt;/code&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;默认的&lt;/span&gt;&lt;code&gt;&lt;span&gt;state&lt;/span&gt;&lt;/code&gt;&lt;span&gt;字段（无锁状态）如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.1046875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/HR9EgRcLqUvZZylnYYweTloiaz06JAB57RlLzH4oFdekmMNgiaf0mrQUfmrATQfAsfVfNLNfgGhb8LTVr0cfcNmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;sema&lt;/span&gt;&lt;/code&gt;&lt;span&gt;字段是信号量，用于控制goroutine的阻塞与唤醒，下文中会有介绍到。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;3.1 两种模式&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;Go实现的互斥锁有两种模式，分别是&lt;strong&gt;正常模式&lt;/strong&gt;和&lt;strong&gt;饥饿模式&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在正常模式下，waiter按照先进先出（&lt;strong&gt;FIFO&lt;/strong&gt;）的方式获取锁，但是一个刚被唤醒的waiter与新到达的goroutine竞争锁时，大概率是干不过的。新来的goroutine有一个优势：它已经在CPU上运行，并且有可能不止一个新来的，因此waiter极有可能失败。在这种情况下，waiter还需要在等待队列中排队。为了避免waiter长时间抢不到锁，当waiter超过 1ms 没有获取到锁，它就会将当前互斥锁切换到饥饿模式，防止等待队列中的waiter被饿死。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在饥饿模式下，锁的所有权直接从解锁（unlocking）的goroutine转移到等待队列中的队头waiter。新来的goroutine不会尝试去获取锁，也不会自旋。它们将在等待队列的队尾排队。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果某waiter获取到了锁，并且满足以下两个条件之一，它就会将锁从饥饿模式切换回正常模式。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;它是等待队列的最后一个goroutine&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;它等待获取锁的时间小于1ms&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;饥饿模式是在 Go 1.9版本引入的，它防止了队列尾部waiter一直无法获取锁的问题。与饥饿模式相比，正常模式下的互斥锁性能更好。因为相较于将锁的所有权明确赋予给唤醒的waiter，直接竞争锁能降低整体goroutine获取锁的延时开销。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;3.2 加锁&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;既然被称作锁，那就存在加锁和解锁的操作。&lt;/span&gt;&lt;code&gt;&lt;span&gt;sync.Mutex&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的加锁&lt;/span&gt;&lt;code&gt;&lt;span&gt;Lock()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;代码如下&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m *Mutex)&lt;/span&gt; &lt;span&gt;Lock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; atomic.CompareAndSwapInt32(&amp;amp;m.state, &lt;span&gt;0&lt;/span&gt;, mutexLocked) {&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; race.Enabled {&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;            race.Acquire(unsafe.Pointer(m))&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;8&lt;/span&gt;    m.lockSlow()&lt;br/&gt;&lt;span&gt;9&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;代码非常简洁，首先通过CAS判断当前锁的状态（CAS的原理和实现可以参照小菜刀写的&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwNTA4MDAwMQ==&amp;amp;mid=2247484574&amp;amp;idx=1&amp;amp;sn=5bbe2668e64455f428c70f00c09f28a2&amp;amp;chksm=97371030a04099263dfbf16dc24438f409166a053fd9fef802f9f9e4f8fd3c4aba9dd97df8f8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《同步原语的基石》&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《同步原语的基石》&lt;/a&gt;一文）。如果锁是完全空闲的，即&lt;/span&gt;&lt;code&gt;&lt;span&gt;m.state&lt;/span&gt;&lt;/code&gt;&lt;span&gt;为0，则对其加锁，将&lt;/span&gt;&lt;code&gt;&lt;span&gt;m.state&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的值赋为1，此时加锁后的&lt;/span&gt;&lt;code&gt;&lt;span&gt;state&lt;/span&gt;&lt;/code&gt;&lt;span&gt;如下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.10859375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/HR9EgRcLqUvZZylnYYweTloiaz06JAB571HOpficibZZQ8iaXJNcQRiaYLJr357Nrp19GAJt1JYcABDC7TUuzloWaew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果，当前锁已经被其他goroutine加锁，则进入&lt;/span&gt;&lt;code&gt;&lt;span&gt;m.lockSlow()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;逻辑。&lt;/span&gt;&lt;code&gt;&lt;span&gt;lockSlow&lt;/span&gt;&lt;/code&gt;&lt;span&gt;函数比较长，这里我们分段阐述。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.2.1 初始化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m *Mutex)&lt;/span&gt; &lt;span&gt;lockSlow&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;    &lt;span&gt;var&lt;/span&gt; waitStartTime &lt;span&gt;int64&lt;/span&gt;  &lt;span&gt;// 用于计算waiter的等待时间&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;    starving := &lt;span&gt;false&lt;/span&gt;        &lt;span&gt;// 饥饿模式标志&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;    awoke := &lt;span&gt;false&lt;/span&gt;           &lt;span&gt;// 唤醒标志&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;    iter := &lt;span&gt;0&lt;/span&gt;                &lt;span&gt;// 统计当前goroutine的自旋次数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;    old := m.state           &lt;span&gt;// 保存当前锁的状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;    ...&lt;br/&gt;&lt;span&gt;8&lt;/span&gt;}    &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;第一段程序是做一些初始化状态、标志的动作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.2.2 自旋&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;lockSlow&lt;/span&gt;&lt;/code&gt;&lt;span&gt;函数余下的代码，就是一个大的&lt;/span&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt;&lt;/code&gt;&lt;span&gt;循环，首先看自旋部分。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; { &lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;// 判断是否能进入自旋&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; old&amp;amp;(mutexLocked|mutexStarving) == mutexLocked &amp;amp;&amp;amp; runtime_canSpin(iter) {&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;        &lt;span&gt;// !awoke 判断当前goroutine是不是在唤醒状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;        &lt;span&gt;// old&amp;amp;mutexWoken == 0 表示没有其他正在唤醒的goroutine&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;        &lt;span&gt;// old&amp;gt;&amp;gt;mutexWaiterShift != 0 表示等待队列中有正在等待的goroutine&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; !awoke &amp;amp;&amp;amp; old&amp;amp;mutexWoken == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; old&amp;gt;&amp;gt;mutexWaiterShift != &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp;&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;            &lt;span&gt;// 尝试将当前锁的低2位的Woken状态位设置为1，表示已被唤醒&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;            &lt;span&gt;// 这是为了通知在解锁Unlock()中不要再唤醒其他的waiter了&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;            atomic.CompareAndSwapInt32(&amp;amp;m.state, old, old|mutexWoken) {&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;            awoke = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;        &lt;span&gt;// 自旋&lt;/span&gt;&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;        runtime_doSpin()&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;        iter++&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;        old = m.state&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;        &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;19&lt;/span&gt;    ...&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;关于自旋，这里需要简单阐述一下。自旋是自旋锁的行为，它通过忙等待，让线程在某段时间内一直保持执行，从而避免线程上下文的调度开销。&lt;strong&gt;自旋锁对于线程只会阻塞很短时间的场景是非常合适的&lt;/strong&gt;。很显然，单核CPU是不适合使用自旋锁的，因为，在同一时间只有一个线程是处于运行状态，假设运行线程A发现无法获取锁，只能等待解锁，但因为A自身不挂起，所以那个持有锁的线程B没有办法进入运行状态，只能等到操作系统分给A的时间片用完，才能有机会被调度。这种情况下使用自旋锁的代价很高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在本场景中，之所以想让当前goroutine进入自旋行为的依据是，我们乐观地认为：&lt;strong&gt;当前正在持有锁的goroutine能在较短的时间内归还锁&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;runtime_canSpin()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;函数的实现如下&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;//go:linkname sync_runtime_canSpin sync.runtime_canSpin&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;sync_runtime_canSpin&lt;/span&gt;&lt;span&gt;(i &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;// active_spin = 4&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; i &amp;gt;= active_spin || ncpu &amp;lt;= &lt;span&gt;1&lt;/span&gt; || gomaxprocs &amp;lt;= &lt;span&gt;int32&lt;/span&gt;(sched.npidle+sched.nmspinning)+&lt;span&gt;1&lt;/span&gt; {&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; p := getg().m.p.ptr(); !runqempty(p) {&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;由于自旋本身是空转CPU的，所以如果使用不当，反倒会降低程序运行性能。结合函数中的判断逻辑，这里总结出来goroutine能进入自旋的条件如下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面说到，自旋行为就是让当前goroutine并不挂起，占用cpu资源。我们看一下&lt;/span&gt;&lt;code&gt;&lt;span&gt;runtime_doSpin()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的实现。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;//go:linkname sync_runtime_doSpin sync.runtime_doSpin&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;sync_runtime_doSpin&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;    procyield(active_spin_cnt)  &lt;span&gt;// active_spin_cnt = 30&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;runtime_doSpin&lt;/span&gt;&lt;/code&gt;&lt;span&gt;调用了&lt;/span&gt;&lt;code&gt;&lt;span&gt;procyield&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，其实现如下（以amd64为例）&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;TEXT runtime·procyield(SB),NOSPLIT,$0-0&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;    MOVL    cycles+0(FP), AX&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;again:&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;    PAUSE&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;    SUBL    $1, AX&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;    JNZ again&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;    RET&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;很明显，所谓的忙等待就是执行 30 次 &lt;/span&gt;&lt;code&gt;&lt;span&gt;PAUSE&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 指令，通过该指令占用 CPU 并消耗 CPU 时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.2.3 计算期望状态&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面说过，当前goroutine进入自旋是需要满足相应条件的。如果不满足自旋条件，则进入以下逻辑。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;        &lt;span&gt;// old是锁当前的状态，new是期望的状态，以期于在后面的CAS操作中更改锁的状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;new&lt;/span&gt; := old&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; old&amp;amp;mutexStarving == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;      &lt;span&gt;// 如果当前锁不是饥饿模式，则将new的低1位的Locked状态位设置为1，表示加锁&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;            &lt;span&gt;new&lt;/span&gt; |= mutexLocked&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; old&amp;amp;(mutexLocked|mutexStarving) != &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;      &lt;span&gt;// 如果当前锁已被加锁或者处于饥饿模式，则将waiter数加1，表示当前goroutine将被作为waiter置于等待队列队尾&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;            &lt;span&gt;new&lt;/span&gt; += &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; mutexWaiterShift&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; starving &amp;amp;&amp;amp; old&amp;amp;mutexLocked != &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;      &lt;span&gt;// 如果当前锁处于饥饿模式，并且已被加锁，则将低3位的Starving状态位设置为1，表示饥饿&lt;/span&gt;&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;            &lt;span&gt;new&lt;/span&gt; |= mutexStarving&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;    &lt;span&gt;// 当awoke为true，则表明当前goroutine在自旋逻辑中，成功修改锁的Woken状态位为1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; awoke {&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&amp;amp;mutexWoken == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;                throw(&lt;span&gt;&quot;sync: inconsistent mutex state&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;19&lt;/span&gt;            }&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;      &lt;span&gt;// 将唤醒标志位Woken置回为0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;21&lt;/span&gt;      &lt;span&gt;// 因为在后续的逻辑中，当前goroutine要么是拿到锁了，要么是被挂起。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;22&lt;/span&gt;      &lt;span&gt;// 如果是挂起状态，那就需要等待其他释放锁的goroutine来唤醒。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;23&lt;/span&gt;      &lt;span&gt;// 假如其他goroutine在unlock的时候发现Woken的位置不是0，则就不会去唤醒，那该goroutine就无法再醒来加锁。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;24&lt;/span&gt;            &lt;span&gt;new&lt;/span&gt; &amp;amp;^= mutexWoken&lt;br/&gt;&lt;span&gt;25&lt;/span&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;这里需要重点理解一下位操作&lt;strong&gt;A |= B&lt;/strong&gt;，它的含义就是在B的二进制位为1的位，将A对应的二进制位设为1，如下图所示。因此，&lt;/span&gt;&lt;code&gt;&lt;span&gt;new |= mutexLocked&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的作用就是将&lt;/span&gt;&lt;code&gt;&lt;span&gt;new&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的最低一位设置为1。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.25546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/HR9EgRcLqUvZZylnYYweTloiaz06JAB579XzvmF74FPjeTud6fRm4enhDBWZDWnRVtFYQOEFAUbApSnrBGlPo2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.2.4 更新期望状态&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在上一步，我们得到了锁的期望状态，接下来通过CAS将锁的状态进行更新。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;        &lt;span&gt;// 尝试将锁的状态更新为期望状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; atomic.CompareAndSwapInt32(&amp;amp;m.state, old, &lt;span&gt;new&lt;/span&gt;) {&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;      &lt;span&gt;// 如果锁的原状态既不是被获取状态，也不是处于饥饿模式&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;      &lt;span&gt;// 那就直接返回，表示当前goroutine已获取到锁&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;            &lt;span&gt;if&lt;/span&gt; old&amp;amp;(mutexLocked|mutexStarving) == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;                &lt;span&gt;break&lt;/span&gt; &lt;span&gt;// locked the mutex with CAS&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;            }&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;      &lt;span&gt;// 如果走到这里，那就证明当前goroutine没有获取到锁&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;      &lt;span&gt;// 这里判断waitStartTime != 0就证明当前goroutine之前已经等待过了，则需要将其放置在等待队列队头&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;            queueLifo := waitStartTime != &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;            &lt;span&gt;if&lt;/span&gt; waitStartTime == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;        &lt;span&gt;// 如果之前没有等待过，就以现在的时间来初始化设置&lt;/span&gt;&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;                waitStartTime = runtime_nanotime()&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;            }&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;      &lt;span&gt;// 阻塞等待&lt;/span&gt;&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;            runtime_SemacquireMutex(&amp;amp;m.sema, queueLifo, &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;      &lt;span&gt;// 被信号量唤醒之后检查当前goroutine是否应该表示为饥饿&lt;/span&gt;&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;      &lt;span&gt;// （这里表示为饥饿之后，会在下一轮循环中尝试将锁的状态更改为饥饿模式）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;19&lt;/span&gt;      &lt;span&gt;// 1. 如果当前goroutine已经饥饿（在上一次循环中更改了starving为true）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;      &lt;span&gt;// 2. 如果当前goroutine已经等待了1ms以上&lt;/span&gt;&lt;br/&gt;&lt;span&gt;21&lt;/span&gt;            starving = starving || runtime_nanotime()-waitStartTime &amp;gt; starvationThresholdNs&lt;br/&gt;&lt;span&gt;22&lt;/span&gt;            &lt;span&gt;// 再次获取锁状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;23&lt;/span&gt;      old = m.state&lt;br/&gt;&lt;span&gt;24&lt;/span&gt;      &lt;span&gt;// 走到这里，如果此时锁仍然是饥饿模式&lt;/span&gt;&lt;br/&gt;&lt;span&gt;25&lt;/span&gt;      &lt;span&gt;// 因为在饥饿模式下，锁是直接交给唤醒的goroutine&lt;/span&gt;&lt;br/&gt;&lt;span&gt;26&lt;/span&gt;      &lt;span&gt;// 所以，即把锁交给当前goroutine&lt;/span&gt;&lt;br/&gt;&lt;span&gt;27&lt;/span&gt;            &lt;span&gt;if&lt;/span&gt; old&amp;amp;mutexStarving != &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;28&lt;/span&gt;        &lt;span&gt;// 如果当前锁既不是被获取也不是被唤醒状态，或者等待队列为空&lt;/span&gt;&lt;br/&gt;&lt;span&gt;29&lt;/span&gt;        &lt;span&gt;// 这代表锁状态产生了不一致的问题&lt;/span&gt;&lt;br/&gt;&lt;span&gt;30&lt;/span&gt;                &lt;span&gt;if&lt;/span&gt; old&amp;amp;(mutexLocked|mutexWoken) != &lt;span&gt;0&lt;/span&gt; || old&amp;gt;&amp;gt;mutexWaiterShift == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;31&lt;/span&gt;                    throw(&lt;span&gt;&quot;sync: inconsistent mutex state&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;32&lt;/span&gt;                }&lt;br/&gt;&lt;span&gt;33&lt;/span&gt;        &lt;span&gt;// 因为当前goroutine已经获取了锁，delta用于将等待队列-1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;34&lt;/span&gt;                delta := &lt;span&gt;int32&lt;/span&gt;(mutexLocked - &lt;span&gt;1&lt;/span&gt;&amp;lt;&amp;lt;mutexWaiterShift)&lt;br/&gt;&lt;span&gt;35&lt;/span&gt;        &lt;span&gt;// 如果当前goroutine中的starving标志不是饥饿&lt;/span&gt;&lt;br/&gt;&lt;span&gt;36&lt;/span&gt;        &lt;span&gt;// 或者当前goroutine已经是等待队列中的最后一个了&lt;/span&gt;&lt;br/&gt;&lt;span&gt;37&lt;/span&gt;        &lt;span&gt;// 就通过delta -= mutexStarving和atomic.AddInt32操作将锁的饥饿状态位设置为0，表示为正常模式&lt;/span&gt;&lt;br/&gt;&lt;span&gt;38&lt;/span&gt;                &lt;span&gt;if&lt;/span&gt; !starving || old&amp;gt;&amp;gt;mutexWaiterShift == &lt;span&gt;1&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;39&lt;/span&gt;                    delta -= mutexStarving&lt;br/&gt;&lt;span&gt;40&lt;/span&gt;                }&lt;br/&gt;&lt;span&gt;41&lt;/span&gt;                atomic.AddInt32(&amp;amp;m.state, delta)&lt;br/&gt;&lt;span&gt;42&lt;/span&gt;        &lt;span&gt;// 拿到锁退出，业务逻辑处理完之后，需要调用Mutex.Unlock()方法释放锁&lt;/span&gt;&lt;br/&gt;&lt;span&gt;43&lt;/span&gt;                &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;&lt;span&gt;44&lt;/span&gt;            }&lt;br/&gt;&lt;span&gt;45&lt;/span&gt;      &lt;span&gt;// 如果锁不是饥饿状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;46&lt;/span&gt;      &lt;span&gt;// 因为当前goroutine已经被信号量唤醒了&lt;/span&gt;&lt;br/&gt;&lt;span&gt;47&lt;/span&gt;      &lt;span&gt;// 那就将表示当前goroutine状态的awoke设置为true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;48&lt;/span&gt;      &lt;span&gt;// 并且将自旋次数的计数iter重置为0，如果能满足自旋条件，重新自旋等待&lt;/span&gt;&lt;br/&gt;&lt;span&gt;49&lt;/span&gt;            awoke = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;50&lt;/span&gt;            iter = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;51&lt;/span&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;52&lt;/span&gt;      &lt;span&gt;// 如果CAS未成功,更新锁状态，重新一个大循环&lt;/span&gt;&lt;br/&gt;&lt;span&gt;53&lt;/span&gt;            old = m.state&lt;br/&gt;&lt;span&gt;54&lt;/span&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;这里需要理解一下&lt;/span&gt;&lt;code&gt;&lt;span&gt;runtime_SemacquireMutex(s *uint32, lifo bool, skipframes int)&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数，&lt;strong&gt;它是用于同步库的sleep原语&lt;/strong&gt;，它的实现是位于&lt;/span&gt;&lt;code&gt;&lt;span&gt;src/runtime/sema.go&lt;/span&gt;&lt;/code&gt;&lt;span&gt;中的&lt;/span&gt;&lt;code&gt;&lt;span&gt;semacquire1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;函数，与它类似的还有&lt;/span&gt;&lt;code&gt;&lt;span&gt;runtime_Semacquire(s *uint32)&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数。两个睡眠原语需要等到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;*s&amp;gt;0&lt;/span&gt;&lt;/code&gt;&lt;span&gt; （本场景中 &lt;/span&gt;&lt;code&gt;&lt;span&gt;m.sema&amp;gt;0&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ），然后原子递减 &lt;/span&gt;&lt;code&gt;&lt;span&gt;*s&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;code&gt;&lt;span&gt;SemacquireMutex&lt;/span&gt;&lt;/code&gt;&lt;span&gt;用于分析竞争的互斥对象，如果&lt;/span&gt;&lt;code&gt;&lt;span&gt;lifo&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（本场景中&lt;/span&gt;&lt;code&gt;&lt;span&gt;queueLifo&lt;/span&gt;&lt;/code&gt;&lt;span&gt;）为true，则将等待者排在等待队列的队头。&lt;/span&gt;&lt;code&gt;&lt;span&gt;skipframes&lt;/span&gt;&lt;/code&gt;&lt;span&gt;是从&lt;/span&gt;&lt;code&gt;&lt;span&gt;SemacquireMutex&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的调用方开始计数，表示在跟踪期间要忽略的帧数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，运行到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SemacquireMutex&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 就证明当前goroutine在前面的过程中获取锁失败了，就需要sleep原语来阻塞当前goroutine，并通过信号量来排队获取锁：如果是新来的goroutine，就需要放在队尾；如果是被唤醒的等待锁的goroutine，就放在队头。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.3 解锁&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;前面说过，有加锁就必然有解锁。我们来看解锁的过程：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m *Mutex)&lt;/span&gt; &lt;span&gt;Unlock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; race.Enabled {&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;        _ = m.state&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;        race.Release(unsafe.Pointer(m))&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;  &lt;span&gt;// new是解锁的期望状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;new&lt;/span&gt; := atomic.AddInt32(&amp;amp;m.state, -mutexLocked)&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; != &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;        m.unlockSlow(&lt;span&gt;new&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;通过原子操作&lt;/span&gt;&lt;code&gt;&lt;span&gt;AddInt32&lt;/span&gt;&lt;/code&gt;&lt;span&gt;想将锁的低1位&lt;/span&gt;&lt;code&gt;&lt;span&gt;Locked&lt;/span&gt;&lt;/code&gt;&lt;span&gt;状态位置为0。然后判断新的&lt;/span&gt;&lt;code&gt;&lt;span&gt;m.state&lt;/span&gt;&lt;/code&gt;&lt;span&gt;值，如果值为0，则代表当前锁已经完全空闲了，结束解锁，否则进入&lt;/span&gt;&lt;code&gt;&lt;span&gt;unlockSlow()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;逻辑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里需要注意的是，锁空闲有两种情况，第一种是完全空闲，它的状态就是锁的初始状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.1046875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/HR9EgRcLqUvZZylnYYweTloiaz06JAB57RlLzH4oFdekmMNgiaf0mrQUfmrATQfAsfVfNLNfgGhb8LTVr0cfcNmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二种空闲，是指的当前锁没被占有，但是会有等待拿锁的goroutine，只是还未被唤醒，例如以下状态的锁也是空闲的，它有两个等待拿锁的goroutine（未唤醒状态）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.10859375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/HR9EgRcLqUvZZylnYYweTloiaz06JAB57uRLHnpictIIUNiaVqcTwdm5qXPLaCbyfyIXOQL9PjqWUrYicBMfvPsLsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下是&lt;/span&gt;&lt;code&gt;&lt;span&gt;unlockSlow&lt;/span&gt;&lt;/code&gt;&lt;span&gt;函数实现。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m *Mutex)&lt;/span&gt; &lt;span&gt;unlockSlow&lt;/span&gt;&lt;span&gt;(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int32&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;  &lt;span&gt;// 1. 如果Unlock了一个没有上锁的锁，则会发生panic。&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;new&lt;/span&gt;+mutexLocked)&amp;amp;mutexLocked == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;      throw(&lt;span&gt;&quot;sync: unlock of unlocked mutex&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;   }&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;// 2. 正常模式&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&amp;amp;mutexStarving == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;      old := &lt;span&gt;new&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;      &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;        &lt;span&gt;// 如果锁没有waiter,或者锁有其他以下已发生的情况之一，则后面的工作就不用做了，直接返回&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;        &lt;span&gt;// 1. 锁处于锁定状态，表示锁已经被其他goroutine获取了&lt;/span&gt;&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;        &lt;span&gt;// 2. 锁处于被唤醒状态，这表明有等待goroutine被唤醒，不用再尝试唤醒其他goroutine&lt;/span&gt;&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;        &lt;span&gt;// 3. 锁处于饥饿模式，那么锁之后会被直接交给等待队列队头goroutine&lt;/span&gt;&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; old&amp;gt;&amp;gt;mutexWaiterShift == &lt;span&gt;0&lt;/span&gt; || old&amp;amp;(mutexLocked|mutexWoken|mutexStarving) != &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;         }&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;        &lt;span&gt;// 如果能走到这，那就是上面的if判断没通过&lt;/span&gt;&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;        &lt;span&gt;// 说明当前锁是空闲状态，但是等待队列中有waiter，且没有goroutine被唤醒&lt;/span&gt;&lt;br/&gt;&lt;span&gt;19&lt;/span&gt;        &lt;span&gt;// 所以，这里我们想要把锁的状态设置为被唤醒，等待队列waiter数-1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; = (old - &lt;span&gt;1&lt;/span&gt;&amp;lt;&amp;lt;mutexWaiterShift) | mutexWoken&lt;br/&gt;&lt;span&gt;21&lt;/span&gt;        &lt;span&gt;// 通过CAS操作尝试更改锁状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; atomic.CompareAndSwapInt32(&amp;amp;m.state, old, &lt;span&gt;new&lt;/span&gt;) {&lt;br/&gt;&lt;span&gt;23&lt;/span&gt;           &lt;span&gt;// 通过信号量唤醒goroutine，然后退出&lt;/span&gt;&lt;br/&gt;&lt;span&gt;24&lt;/span&gt;            runtime_Semrelease(&amp;amp;m.sema, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;25&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;&lt;span&gt;26&lt;/span&gt;         }&lt;br/&gt;&lt;span&gt;27&lt;/span&gt;        &lt;span&gt;// 这里是CAS失败的逻辑&lt;/span&gt;&lt;br/&gt;&lt;span&gt;28&lt;/span&gt;        &lt;span&gt;// 因为在for循环中，锁的状态有可能已经被改变了，所以这里需要及时更新一下状态信息&lt;/span&gt;&lt;br/&gt;&lt;span&gt;29&lt;/span&gt;        &lt;span&gt;// 以便下个循环里作判断处理&lt;/span&gt;&lt;br/&gt;&lt;span&gt;30&lt;/span&gt;         old = m.state&lt;br/&gt;&lt;span&gt;31&lt;/span&gt;      }&lt;br/&gt;&lt;span&gt;32&lt;/span&gt;   &lt;span&gt;// 3. 饥饿模式&lt;/span&gt;&lt;br/&gt;&lt;span&gt;33&lt;/span&gt;   } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;// 因为是饥饿模式，所以非常简单&lt;/span&gt;&lt;br/&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;// 直接唤醒等待队列队头goroutine即可&lt;/span&gt;&lt;br/&gt;&lt;span&gt;36&lt;/span&gt;      runtime_Semrelease(&amp;amp;m.sema, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;37&lt;/span&gt;   }&lt;br/&gt;&lt;span&gt;38&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;在这里，需要理解一下&lt;/span&gt;&lt;code&gt;&lt;span&gt;runtime_Semrelease(s *uint32, handoff bool, skipframes int)&lt;/span&gt;&lt;/code&gt;&lt;span&gt;函数。&lt;strong&gt;它是用于同步库的wakeup原语&lt;/strong&gt;，&lt;/span&gt;&lt;code&gt;&lt;span&gt;Semrelease&lt;/span&gt;&lt;/code&gt;&lt;span&gt;原子增加&lt;/span&gt;&lt;code&gt;&lt;span&gt;*s&lt;/span&gt;&lt;/code&gt;&lt;span&gt;值（本场景中&lt;/span&gt;&lt;code&gt;&lt;span&gt;m.sema&lt;/span&gt;&lt;/code&gt;&lt;span&gt;），并通知阻塞在&lt;/span&gt;&lt;code&gt;&lt;span&gt;Semacquire&lt;/span&gt;&lt;/code&gt;&lt;span&gt;中正在等待的goroutine。如果&lt;/span&gt;&lt;code&gt;&lt;span&gt;handoff&lt;/span&gt;&lt;/code&gt;&lt;span&gt;为真，则将计数直接传递给队头waiter。&lt;/span&gt;&lt;code&gt;&lt;span&gt;skipframes&lt;/span&gt;&lt;/code&gt;&lt;span&gt;是从&lt;/span&gt;&lt;code&gt;&lt;span&gt;Semrelease&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的调用方开始计数，表示在跟踪期间要忽略的帧数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7870968&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_gif/HR9EgRcLqUsyUfTS2iagtcnf9Zb1ZMSfLL6k1TkEGqUEFkoGVdlu8LNicoibo4owMXiciagW7TOngvwm3PA8D1AS1Cw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;155&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;从代码量而言，go中互斥锁的代码非常轻量简洁，通过巧妙的位运算，仅仅采用state一个字段就实现了四个字段的效果，非常之精彩。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是，代码量少并不代表逻辑简单，相反，它很复杂。互斥锁的设计中包含了大量的位运算，并包括了两种不同锁模式、信号量、自旋以及调度等内容，读者要真正理解加解锁的过程并不容易，这里再做一个简单回顾总结。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在正常模式下，waiter按照先进先出的方式获取锁；在饥饿模式下，锁的所有权直接从解锁的goroutine转移到等待队列中的队头waiter。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;模式切换&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果当前 goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果当前 goroutine 是互斥锁最后一个waiter，或者等待的时间小于 1ms，互斥锁切换回正常模式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;加锁&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果锁是完全空闲状态，则通过CAS直接加锁。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果锁处于正常模式，则会尝试自旋，通过持有CPU等待锁的释放。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果当前goroutine不再满足自旋条件，则会计算锁的期望状态，并尝试更新锁状态。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在更新锁状态成功后，会判断当前goroutine是否能获取到锁，能获取锁则直接退出。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当前goroutine不能获取到锁时，则会由sleep原语&lt;/span&gt;&lt;code&gt;&lt;span&gt;SemacquireMutex&lt;/span&gt;&lt;/code&gt;&lt;span&gt;陷入睡眠，等待解锁的goroutine发出信号进行唤醒。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;唤醒之后的goroutine发现锁处于饥饿模式，则能直接拿到锁，否则重置自旋迭代次数并标记唤醒位，重新进入步骤2中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;解锁&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果通过原子操作&lt;/span&gt;&lt;code&gt;&lt;span&gt;AddInt32&lt;/span&gt;&lt;/code&gt;&lt;span&gt;后，锁变为完全空闲状态，则直接解锁。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果解锁一个没有上锁的锁，则直接抛出异常。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果锁处于正常模式，且没有goroutine等待锁释放，或者锁被其他goroutine设置为了锁定状态、唤醒状态、饥饿模式中的任一种（非空闲状态），则会直接退出；否则，会通过wakeup原语&lt;/span&gt;&lt;code&gt;&lt;span&gt;Semrelease&lt;/span&gt;&lt;/code&gt;&lt;span&gt;唤醒waiter。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果锁处于饥饿模式，会直接将锁的所有权交给等待队列队头waiter，唤醒的waiter会负责设置&lt;/span&gt;&lt;code&gt;&lt;span&gt;Locked&lt;/span&gt;&lt;/code&gt;&lt;span&gt;标志位。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;另外，从Go的互斥锁带有自旋的设计而言，如果我们通过&lt;/span&gt;&lt;code&gt;&lt;span&gt;sync.Mutex&lt;/span&gt;&lt;/code&gt;&lt;span&gt;只锁定执行耗时很低的关键代码，例如锁定某个变量的赋值，性能是非常不错的（因为等待锁的goroutine不用被挂起，持有锁的goroutine会很快释放锁）。&lt;strong&gt;所以，我们在使用互斥锁时，应该只锁定真正的临界区&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;mu.Lock()&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;defer&lt;/span&gt; mu.Unlock()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;写如上的代码，是很爽。但是，你有想过这会带来没必要的性能损耗吗？&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span&gt;&lt;strong&gt;福利&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span/&gt;&lt;span&gt;我为大家整理了一份&lt;/span&gt;&lt;span&gt;从入门到进阶的Go学习资料礼包&lt;/span&gt;&lt;span&gt;，包含学习建议：入门看什么，进阶看什么。&lt;/span&gt;&lt;span&gt;关注公众号 「polarisxu」，回复 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;ebook&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 获取；还可以回复「&lt;strong&gt;进群&lt;/strong&gt;」，和数万 Gopher 交流学习。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UWba2ryLMqm8cgtrMXjG1BLGg46vQNmUompBL02uYYwic9RicPbCnlKdZiacBF5Wv6RLgmGIqnBnwuWyP82ibYusiag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6967e6810b4f03ecf6314479ad829662</guid>
<title>教你如何使用 Node + Express + Typescript 开发一个应用</title>
<link>https://toutiao.io/k/6yxdar1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;Express是nodejs开发中普遍使用的一个框架，下面要谈的是如何结合Typescript去使用。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;目标&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;我们的目标是能够使用Typescript快速开发我们的应用程序，而最终我们的应用程序却是编译为原始的JavaScript代码，以由nodejs运行时来执行。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;初始化设置&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;首要的是我们要创建一个目录名为&lt;code&gt;express-typescript-app&lt;/code&gt;来存放我们的项目代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;mkdir express-typescript-app&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; express-typescript-app&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了实现我们的目标，首先我们需要区分哪些是线上程序依赖项，哪些是开发依赖项，这样可以确保最终编译的代码都是有用的。&lt;/p&gt;&lt;p&gt;在这个教程中，将使用yarn命令作为程序包管理器，当然npm也是一样可以的。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;生产环境依赖&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;express&lt;/code&gt;作为程序的主体框架，在生产环境中是必不可少的，需要安装&lt;/p&gt;&lt;pre&gt;&lt;code&gt;yarn &lt;span&gt;add&lt;/span&gt; express&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样当前目录下就生成了一个package.json 文件，里面暂时只有一个依赖&lt;/p&gt;&lt;h2&gt;&lt;span&gt;开发环境依赖项&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;在开发环境中我们将要使用Typescript编写代码。所以我们需要安装&lt;code&gt;typescript&lt;/code&gt;。另外也需要安装node和express的类型声明。安装的时候带上&lt;code&gt;- D&lt;/code&gt;参数来确保它是开发依赖。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;yarn&lt;/span&gt; add -D typescript &lt;span&gt;@types&lt;/span&gt;/express &lt;span&gt;@types&lt;/span&gt;/node&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装好之后，还有一点值得注意，我们并不想每次代码更改之后还需要手动去执行编译才生效。这样体验太不好了！所以我们需要额外添加几个依赖：&lt;/p&gt;&lt;p&gt;因此这两个依赖都是在开发的时候需要的，而不需编译进生产环境的。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;yarn &lt;span&gt;add&lt;/span&gt; -D ts-node nodemon&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;配置我们的程序运行起来&lt;/span&gt;&lt;/h2&gt;&lt;h4&gt;&lt;span&gt;配置Typescript文件&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;为我们将要用的typescript设置配置文件，创建&lt;code&gt;tsconfig.json&lt;/code&gt;文件&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;touch&lt;/span&gt; &lt;span&gt;tsconfig&lt;/span&gt;&lt;span&gt;.json&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在让我们给配置文件添加编译相关的配置参数：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;module: &quot;commonjs&quot;&lt;/code&gt; — 如果使用过node的都知道，这个作为编译代码时将被编译到最终代码是必不可少的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;esModuleInterop: true&lt;/code&gt; — 这个选项允许我们默认导出的时候使用*代替导出的内容。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;target: &quot;es6&quot;&lt;/code&gt; — 不同于前端代码，我们需要控制运行环境，得确保使用的node版本能正确识别ES6语法。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;rootDir: &quot;./&quot;&lt;/code&gt; — 设置代码的根目录为当前目录。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;outDir: &quot;./build&quot;&lt;/code&gt; — 最终将Typescript代码编译成执行的Javascript代码目录。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;strict: true&lt;/code&gt; — 允许严格类型检查。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;最终&lt;code&gt;tsconfig.json&lt;/code&gt;文件内容如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;compilerOptions&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;module&quot;&lt;/span&gt;: &lt;span&gt;&quot;commonjs&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;esModuleInterop&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;target&quot;&lt;/span&gt;: &lt;span&gt;&quot;es6&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;rootDir&quot;&lt;/span&gt;: &lt;span&gt;&quot;./&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;outDir&quot;&lt;/span&gt;: &lt;span&gt;&quot;./build&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;strict&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;配置package.json脚本&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;目前还没有 &lt;code&gt;package.json&lt;/code&gt;文件的scripts项，我们需要添加几个脚本：第一个是&lt;code&gt;start&lt;/code&gt;启动开发模式，另一个是 &lt;code&gt;build&lt;/code&gt;打包线上环境代码的命令。&lt;/p&gt;&lt;p&gt;启动开发模式我们需要执行&lt;code&gt;nodemon index.ts&lt;/code&gt;，而打包生产代码，我们已经在&lt;code&gt;tsconfig.json&lt;/code&gt;中给出了所有需要的信息，所以我们只需要执行&lt;code&gt;tsc&lt;/code&gt;命令。&lt;/p&gt;&lt;p&gt;此刻下面是你package.json文件中所有的内容，也可能由于我们创建项目的时间不一样，导致依赖的版本号不一样。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;dependencies&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;express&quot;&lt;/span&gt;: &lt;span&gt;&quot;^4.17.1&quot;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;devDependencies&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;@types/express&quot;&lt;/span&gt;: &lt;span&gt;&quot;^4.17.11&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;@types/node&quot;&lt;/span&gt;: &lt;span&gt;&quot;^14.14.22&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;nodemon&quot;&lt;/span&gt;: &lt;span&gt;&quot;^2.0.7&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;ts-node&quot;&lt;/span&gt;: &lt;span&gt;&quot;^9.1.1&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;typescript&quot;&lt;/span&gt;: &lt;span&gt;&quot;^4.1.3&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;Git配置&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;如果使用git来管理代码，还需要添加&lt;code&gt;.gitignore&lt;/code&gt;文件来忽视&lt;code&gt;node_modules&lt;/code&gt;目录和&lt;code&gt;build&lt;/code&gt;目录&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;touch&lt;/span&gt; &lt;span&gt;.gitignore&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;添加忽视的内容&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;node_modules&lt;/span&gt;&lt;br/&gt;build&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;至此，所有的安装过程已经结束，比单纯的无Typescript版本可能稍微复杂点。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;创建我们的Express应用&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;让我们来正式开始创建express应用。首先创建主文件&lt;code&gt;index.ts&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;touch&lt;/span&gt; &lt;span&gt;index&lt;/span&gt;&lt;span&gt;.ts&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后添加案例代码，在网页中输出“hello world”&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; express &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;express&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;const app = express();&lt;br/&gt;const PORT = &lt;span&gt;3000&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;app.get(&lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;(req, res)&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  res.send(&lt;span&gt;&#x27;Hello world&#x27;&lt;/span&gt;);&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;app.listen(PORT, &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(`&lt;span&gt;Express &lt;span&gt;with&lt;/span&gt; Typescript! http:&lt;span&gt;//localhost:${PORT}&lt;/span&gt;&lt;/span&gt;`);&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在终端命令行执行启动命令 &lt;code&gt;yarn run start&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;yarn&lt;/span&gt; run start&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来会输出以下内容：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[&lt;span&gt;nodemon&lt;/span&gt;] &lt;span&gt;2.0&lt;/span&gt;&lt;span&gt;.7&lt;/span&gt;&lt;br/&gt;[&lt;span&gt;nodemon&lt;/span&gt;] to restart at any time, enter `rs`&lt;br/&gt;[&lt;span&gt;nodemon&lt;/span&gt;] &lt;span&gt;watching &lt;span&gt;path&lt;/span&gt;(&lt;span&gt;s&lt;/span&gt;): *.*&lt;br/&gt;[nodemon] watching extensions: ts,json&lt;br/&gt;[nodemon] starting `ts-node index.ts`&lt;br/&gt;Express with Typescript! http:&lt;span&gt;//localhost:3000&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以看到nodemon模块已经监听到所有文件的变更后使用&lt;code&gt;ts-node index.ts&lt;/code&gt;命令启动了我们的应用。我们现在可以在浏览器打开网址&lt;code&gt;http://localhost:3000&lt;/code&gt;，将会看到网页中输出我们想要的“hello world”。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5932203389830508&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wokNJRf0ytqYNndvZIwgJ8ibicC5HOS8DZ34QOemHk2yx47prztdG8IF2s1Z9bWicDtKkhYPAh0ZpLGSuhYUVWUAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;472&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;&lt;span&gt;“Hello World”以外的功能&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;我们的 “Hello World”应用算是创建好了，但是我们不仅于此，还要添加一些稍微复杂点的功能，来丰富一下应用。大致功能包括：&lt;/p&gt;&lt;p&gt;让我们一个个去实现以上功能！&lt;/p&gt;&lt;h4&gt;&lt;span&gt;保存用户&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;首先，我们创建一个&lt;code&gt;types.ts&lt;/code&gt;文件来定义我们用到的&lt;code&gt;User&lt;/code&gt;类型。后面所有类型定义都写在这个文件中。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;touch&lt;/span&gt; &lt;span&gt;types&lt;/span&gt;&lt;span&gt;.ts&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后导出定义的&lt;code&gt;User&lt;/code&gt;类型&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; type User = { username: &lt;span&gt;string&lt;/span&gt;; password: &lt;span&gt;string&lt;/span&gt; };&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;好了。我们将使用内存来保存所有的用户，而不是数据库或者其它方式。根目录下创建一个&lt;code&gt;data&lt;/code&gt;目录，然后在里面新建&lt;code&gt;users.ts&lt;/code&gt;文件&lt;/p&gt;&lt;pre&gt;&lt;code&gt;mkdir &lt;span&gt;data&lt;/span&gt;&lt;br/&gt;touch &lt;span&gt;data&lt;/span&gt;/users.ts&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在在users.ts文件里创建一个User类型的空数组&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { User } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;../types&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; users: User[] = [];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;提交新用户&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;接下来我们希望向应用提交一个新用户。我们在这里将要用到处理请求参数的中间件&lt;code&gt;body-parse&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;yarn &lt;span&gt;add&lt;/span&gt; body-parser&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在主文件里导入并使用它&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; express &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;express&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; bodyParser &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;body-parser&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;const app = express();&lt;br/&gt;const PORT = &lt;span&gt;3000&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;app.use(bodyParser.urlencoded({ extended: &lt;span&gt;false&lt;/span&gt; }));&lt;br/&gt;&lt;br/&gt;app.get(&lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;(req, res)&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  res.send(&lt;span&gt;&#x27;Hello world&#x27;&lt;/span&gt;);&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;app.listen(PORT, &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(`&lt;span&gt;Express &lt;span&gt;with&lt;/span&gt; Typescript! http:&lt;span&gt;//localhost:${PORT}&lt;/span&gt;&lt;/span&gt;`);&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后，我们可以在users文件里创建POST请求处理程序。 该处理程序将执行以下操作：&lt;/p&gt;&lt;p&gt;让我们开始，首先，在&lt;code&gt;data/users.ts&lt;/code&gt;文件中创建一个&lt;code&gt;addUser&lt;/code&gt;的方法&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { User } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;../types&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; users: User[] = [];&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; addUser = &lt;span&gt;(&lt;span&gt;newUser: User&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  users.push(newUser);&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后回到&lt;code&gt;index.ts&lt;/code&gt;文件中添加一条&lt;code&gt;&quot;/users&quot;&lt;/code&gt;的路由&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; express &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;express&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; bodyParser &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;body-parser&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { addUser } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./data/users&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;const app = express();&lt;br/&gt;const PORT = &lt;span&gt;3000&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;app.use(bodyParser.urlencoded({ extended: &lt;span&gt;false&lt;/span&gt; }));&lt;br/&gt;&lt;br/&gt;app.get(&lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;(req, res)&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  res.send(&lt;span&gt;&#x27;Hello world&#x27;&lt;/span&gt;);&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;app.post(&lt;span&gt;&#x27;/users&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;(req, res)&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  const { username, password } = req.body;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!username?.trim() || !password?.trim()) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; res.status(&lt;span&gt;400&lt;/span&gt;).send(&lt;span&gt;&#x27;Bad username or password&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;  addUser({ username, password });&lt;br/&gt;  res.status(&lt;span&gt;201&lt;/span&gt;).send(&lt;span&gt;&#x27;User created&#x27;&lt;/span&gt;);&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;app.listen(PORT, &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(`&lt;span&gt;Express &lt;span&gt;with&lt;/span&gt; Typescript! http:&lt;span&gt;//localhost:${PORT}&lt;/span&gt;&lt;/span&gt;`);&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里的逻辑不复杂，我们简单解释一下，首先请求体中要包含&lt;code&gt;username&lt;/code&gt;和&lt;code&gt;password&lt;/code&gt;两个变量，而且使用&lt;code&gt;trim()&lt;/code&gt;函数去除收尾的空字符，保证它的长度大于0。如果不满足，返回&lt;code&gt;400&lt;/code&gt;状态和自定义错误信息。如果验证通过，则将用户信息添加到&lt;code&gt;users&lt;/code&gt;数组并且返回&lt;code&gt;201&lt;/code&gt;状态回来。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;注意：你有没有发现users数组是没有办法知道有没有同一个用户被添加两次的，我们暂且不考虑这种情况。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;让我们重新打开一个终端（不要关掉运行程序的终端），在终端里通过&lt;code&gt;curl&lt;/code&gt;命令来发出一个POST请求注册接口&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;curl&lt;/span&gt; -d &lt;span&gt;&quot;username=foo&amp;amp;password=bar&quot;&lt;/span&gt; -X POST http://localhost:3000/users&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你将会在终端的命令行中发现输出了下面的信息&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;User&lt;/span&gt; created&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后再请求一次接口，这次password仅仅为空字符串，测试一下请求失败的情况&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;curl&lt;/span&gt; -d &lt;span&gt;&quot;username=foo&amp;amp;password= &quot;&lt;/span&gt; -X POST http://localhost:3000/users&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;没有让我们失望，成功返回了一下错误信息&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Bad username &lt;span&gt;or&lt;/span&gt; password&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;登录功能&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;登录有点类似，我们从请求体中拿到&lt;code&gt;username&lt;/code&gt;和&lt;code&gt;password&lt;/code&gt;的值然后通过&lt;code&gt;Array.find&lt;/code&gt;方法去&lt;code&gt;users&lt;/code&gt;数组中查找相同的用户名和密码组合，返回&lt;code&gt;200&lt;/code&gt;状态码说明用户登录成功，而&lt;code&gt;401&lt;/code&gt;状态码表示用户不被授权，登录失败。&lt;/p&gt;&lt;p&gt;首先我们在&lt;code&gt;data/users.ts&lt;/code&gt;文件中添加getUser方法：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { User } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;../types&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;const users: User[] = [];&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; const addUser = &lt;span&gt;&lt;span&gt;(newUser: User)&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  users.push(newUser);&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; const getUser = &lt;span&gt;&lt;span&gt;(user: User)&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; users.find(&lt;br/&gt;    &lt;span&gt;&lt;span&gt;(u)&lt;/span&gt; =&amp;gt;&lt;/span&gt; u.username === user.username &amp;amp;&amp;amp; u.password === user.password&lt;br/&gt;  );&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里&lt;code&gt;getUser&lt;/code&gt;方法将会从&lt;code&gt;users&lt;/code&gt;数组里返回与之匹配用户或者&lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;接下来我们将在&lt;code&gt;index.ts&lt;/code&gt;里调用&lt;code&gt;getUser&lt;/code&gt;方法&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; express &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;express&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; bodyParser &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;body-parser&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { addUser, getUser } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./data/users&#x27;;&lt;br/&gt;&lt;br/&gt;const app = express();&lt;br/&gt;const PORT = 3000;&lt;br/&gt;&lt;br/&gt;app.use(bodyParser.urlencoded({ extended: false }));&lt;br/&gt;&lt;br/&gt;app.get(&#x27;/&#x27;, (req, res) =&amp;gt; {&lt;br/&gt;  res.send(&#x27;Hello word&#x27;);&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;app.post(&#x27;/users&#x27;, (req, res) =&amp;gt; {&lt;br/&gt;  const { username, password } = req.body;&lt;br/&gt;  if (!username?.trim() || !password?.trim()) {&lt;br/&gt;    return res.status(400).send(&#x27;Bad username or password&#x27;);&lt;br/&gt;  }&lt;br/&gt;  addUser({ username, password });&lt;br/&gt;  res.status(201).send(&#x27;User created&#x27;);&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;app.post(&#x27;/login&#x27;, (req, res) =&amp;gt; {&lt;br/&gt;  const { username, password } = req.body;&lt;br/&gt;  const found = getUser({username, password})&lt;br/&gt;  if (!found) {&lt;br/&gt;    return res.status(401).send(&#x27;Login failed&#x27;);&lt;br/&gt;  }&lt;br/&gt;  res.status(200).send(&#x27;Success&#x27;);&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;app.listen(PORT, () =&amp;gt; {&lt;br/&gt;  console.log(`Express with Typescript! http://localhost:${PORT}`);&lt;br/&gt;});&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在我们还是用curl命令去请求注册接口和登录接口，登录接口请求两次，一次成功一次失败&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;curl&lt;/span&gt; -d &lt;span&gt;&quot;username=joe&amp;amp;password=hard2guess&quot;&lt;/span&gt; -X POST http://localhost:3000/users&lt;br/&gt;&lt;span&gt;# User created&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;curl -d &lt;span&gt;&quot;username=joe&amp;amp;password=hard2guess&quot;&lt;/span&gt; -X POST http://localhost:3000/login&lt;br/&gt;&lt;span&gt;# Success&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;curl -d &lt;span&gt;&quot;username=joe&amp;amp;password=wrong&quot;&lt;/span&gt; -X POST http://localhost:3000/login&lt;br/&gt;&lt;span&gt;# Login failed&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;没问题，结果都按我们预想的顺利返回了&lt;/p&gt;&lt;h2&gt;&lt;span&gt;探索Express类型&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;您可能已经发现，讲到现在，好像都是一些基础的东西，Express里面比较深的概念没有涉及到，比如自定义路由，中间件和句柄等功能，我们现在就来重构它。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;自定义路由类型&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;或许我们希望的是创建这样一个标准的路由结构像下面这样&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; route = {&lt;br/&gt;  method: &lt;span&gt;&#x27;post&#x27;&lt;/span&gt;,&lt;br/&gt;  path: &lt;span&gt;&#x27;/users&#x27;&lt;/span&gt;,&lt;br/&gt;  middleware: [middleware1, middleware2],&lt;br/&gt;  handler: userSignup,&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们需要在&lt;code&gt;types.ts&lt;/code&gt;文件中定义一个&lt;code&gt;Route&lt;/code&gt;类型。同时也需要从Express库中导出相关的类型：&lt;code&gt;Request&lt;/code&gt;，&lt;code&gt;Response&lt;/code&gt;和&lt;code&gt;NextFunction&lt;/code&gt;。&lt;code&gt;Request&lt;/code&gt;表示客户端的请求数据类型，&lt;code&gt;Response&lt;/code&gt;是从服务器返回值类型，&lt;code&gt;NextFunction&lt;/code&gt;则是next()方法的签名，如果使用过express的中间件应该很熟悉。&lt;/p&gt;&lt;p&gt;在&lt;code&gt;types.ts&lt;/code&gt;文件中，重新定义Route类型&lt;/p&gt;&lt;pre&gt;&lt;code&gt;export &lt;span&gt;type&lt;/span&gt; User = { username: &lt;span&gt;string&lt;/span&gt;; password: &lt;span&gt;string&lt;/span&gt; };&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Method =&lt;br/&gt;  | &lt;span&gt;&#x27;get&#x27;&lt;/span&gt;&lt;br/&gt;  | &lt;span&gt;&#x27;head&#x27;&lt;/span&gt;&lt;br/&gt;  | &lt;span&gt;&#x27;post&#x27;&lt;/span&gt;&lt;br/&gt;  | &lt;span&gt;&#x27;put&#x27;&lt;/span&gt;&lt;br/&gt;  | &lt;span&gt;&#x27;delete&#x27;&lt;/span&gt;&lt;br/&gt;  | &lt;span&gt;&#x27;connect&#x27;&lt;/span&gt;&lt;br/&gt;  | &lt;span&gt;&#x27;options&#x27;&lt;/span&gt;&lt;br/&gt;  | &lt;span&gt;&#x27;trace&#x27;&lt;/span&gt;&lt;br/&gt;  | &lt;span&gt;&#x27;patch&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;export &lt;span&gt;type&lt;/span&gt; Route = {&lt;br/&gt;  method: Method;&lt;br/&gt;  &lt;span&gt;path&lt;/span&gt;: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  middleware: any[];&lt;br/&gt;  handler: any;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你熟悉express中间件的话，你应该知道一个典型的中间件长这样：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;middleware&lt;/span&gt;(&lt;span&gt;request, response, next&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// Do some logic with the request&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (request.body.something === &lt;span&gt;&#x27;foo&#x27;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;// Failed criteria, send forbidden resposne&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; response.status(&lt;span&gt;403&lt;/span&gt;).send(&lt;span&gt;&#x27;Forbidden&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// Succeeded, go to the next middleware&lt;/span&gt;&lt;br/&gt;  next();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由此可知，一个中间件需要传入三个参数，分别是&lt;code&gt;Request&lt;/code&gt;，&lt;code&gt;Response&lt;/code&gt;和&lt;code&gt;NextFunction&lt;/code&gt;类型。因此如果需要我们创建一个&lt;code&gt;Middleware&lt;/code&gt;类型：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { Request, Response, NextFunction } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;express&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;type Middleware = &lt;span&gt;&lt;span&gt;(req: Request, res: Response, next: NextFunction)&lt;/span&gt; =&amp;gt;&lt;/span&gt; any;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后express已经有了一个叫&lt;code&gt;RequestHandler&lt;/code&gt;类型，所以在这里我们只需要从express导出就好了，如果取个别名可以采用类型断言。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import { RequestHandler as Middleware } from &lt;span&gt;&#x27;express&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;export &lt;span&gt;type&lt;/span&gt; User = { username: &lt;span&gt;string&lt;/span&gt;; password: &lt;span&gt;string&lt;/span&gt; };&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Method =&lt;br/&gt;  | &lt;span&gt;&#x27;get&#x27;&lt;/span&gt;&lt;br/&gt;  | &lt;span&gt;&#x27;head&#x27;&lt;/span&gt;&lt;br/&gt;  | &lt;span&gt;&#x27;post&#x27;&lt;/span&gt;&lt;br/&gt;  | &lt;span&gt;&#x27;put&#x27;&lt;/span&gt;&lt;br/&gt;  | &lt;span&gt;&#x27;delete&#x27;&lt;/span&gt;&lt;br/&gt;  | &lt;span&gt;&#x27;connect&#x27;&lt;/span&gt;&lt;br/&gt;  | &lt;span&gt;&#x27;options&#x27;&lt;/span&gt;&lt;br/&gt;  | &lt;span&gt;&#x27;trace&#x27;&lt;/span&gt;&lt;br/&gt;  | &lt;span&gt;&#x27;patch&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;export &lt;span&gt;type&lt;/span&gt; Route = {&lt;br/&gt;  method: Method;&lt;br/&gt;  &lt;span&gt;path&lt;/span&gt;: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  middleware: Middleware[];&lt;br/&gt;  handler: any;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后我们只需要为&lt;code&gt;handler&lt;/code&gt;指定类型。这里的&lt;code&gt;handler&lt;/code&gt;应该是程序执行的最后一步，因此我们在设计的时候就不需要传入&lt;code&gt;next&lt;/code&gt;参数了，类型也就是&lt;code&gt;RequestHandler&lt;/code&gt;去掉第三个参数。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { Request, Response, RequestHandler &lt;span&gt;as&lt;/span&gt; Middleware } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;express&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; type User = { username: string; password: string };&lt;br/&gt;&lt;br/&gt;type Method =&lt;br/&gt;  | &lt;span&gt;&#x27;get&#x27;&lt;/span&gt;&lt;br/&gt;  | &lt;span&gt;&#x27;head&#x27;&lt;/span&gt;&lt;br/&gt;  | &lt;span&gt;&#x27;post&#x27;&lt;/span&gt;&lt;br/&gt;  | &lt;span&gt;&#x27;put&#x27;&lt;/span&gt;&lt;br/&gt;  | &lt;span&gt;&#x27;delete&#x27;&lt;/span&gt;&lt;br/&gt;  | &lt;span&gt;&#x27;connect&#x27;&lt;/span&gt;&lt;br/&gt;  | &lt;span&gt;&#x27;options&#x27;&lt;/span&gt;&lt;br/&gt;  | &lt;span&gt;&#x27;trace&#x27;&lt;/span&gt;&lt;br/&gt;  | &lt;span&gt;&#x27;patch&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; type Handler = &lt;span&gt;&lt;span&gt;(req: Request, res: Response)&lt;/span&gt; =&amp;gt;&lt;/span&gt; any;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; type Route = {&lt;br/&gt;  method: Method;&lt;br/&gt;  path: string;&lt;br/&gt;  middleware: Middleware[];&lt;br/&gt;  handler: Handler;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;添加一些项目结构&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;我们需要通过增加一些结构来把中间件和处理程序从index.ts文件中移除&lt;/p&gt;&lt;h4&gt;&lt;span&gt;创建处理器&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;我们把一些处理方法移到handlers目录中&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;mkdir&lt;/span&gt; handlers&lt;br/&gt;touch handlers/user.ts&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么在&lt;code&gt;handlers/user.ts&lt;/code&gt;文件中，我们添加如下代码。和用户注册相关的处理代码已经被我们从&lt;code&gt;index.ts&lt;/code&gt;文件中重构到这里。重要的是我们可以确定&lt;code&gt;signup&lt;/code&gt;方法满足我们定义的&lt;code&gt;Handlers&lt;/code&gt;类型&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { addUser } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;../data/users&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { Handler } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;../types&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; signup: Handler = &lt;span&gt;(&lt;span&gt;req, res&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { username, password } = req.body;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!username?.trim() || !password?.trim()) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; res.status(&lt;span&gt;400&lt;/span&gt;).send(&lt;span&gt;&#x27;Bad username or password&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;  addUser({ username, password });&lt;br/&gt;  res.status(&lt;span&gt;201&lt;/span&gt;).send(&lt;span&gt;&#x27;User created&#x27;&lt;/span&gt;);&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同样，我们把创建auth处理器添加login方法&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;touch&lt;/span&gt; handlers/auth.ts&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;添加以下代码&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { getUser } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;../data/users&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { Handler } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;../types&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; login: Handler = &lt;span&gt;(&lt;span&gt;req, res&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { username, password } = req.body;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; found = getUser({ username, password });&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!found) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; res.status(&lt;span&gt;401&lt;/span&gt;).send(&lt;span&gt;&#x27;Login failed&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;  res.status(&lt;span&gt;200&lt;/span&gt;).send(&lt;span&gt;&#x27;Success&#x27;&lt;/span&gt;);&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后也给我们的首页增加一个处理器&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;touch&lt;/span&gt; handlers/home.ts&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;功能很简单，只要输出文本&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { Handler } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;../types&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; const home: Handler = &lt;span&gt;&lt;span&gt;(req, res)&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  res.send(&lt;span&gt;&#x27;Hello world&#x27;&lt;/span&gt;);&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;中间件&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;现在还没有任何的自定义中间件，首先创建一个middleware目录&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;mkdir&lt;/span&gt; middleware&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们将添加一个打印客户端请求路径的中间件，取名&lt;code&gt;requestLogger.ts&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;touch&lt;/span&gt; middleware/requestLogger.ts&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从express库中导出需要定义的中间件类型的&lt;code&gt;RequestHandler&lt;/code&gt;类型&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { RequestHandler &lt;span&gt;as&lt;/span&gt; Middleware } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;express&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; const requestLogger: Middleware = &lt;span&gt;&lt;span&gt;(req, res, next)&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(req.path);&lt;br/&gt;  next();&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;创建路由&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;既然我们已经定义了一个新的Route类型和自己的一些处理器，就可以把路由定义独立出来一个文件，在根目录创建&lt;code&gt;routes.ts&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;touch&lt;/span&gt; &lt;span&gt;routes&lt;/span&gt;&lt;span&gt;.ts&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以下是该文件的所有代码，为了演示就只给&lt;code&gt;/login&lt;/code&gt;添加了&lt;code&gt;requestLogger&lt;/code&gt;中间件&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { login } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./handlers/auth&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { home } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./handlers/home&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { signup } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./handlers/user&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { requestLogger } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./middleware/requestLogger&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { Route } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./types&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; routes: Route[] = [&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;method&lt;/span&gt;: &lt;span&gt;&#x27;get&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;path&lt;/span&gt;: &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;middleware&lt;/span&gt;: [],&lt;br/&gt;    &lt;span&gt;handler&lt;/span&gt;: home,&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;method&lt;/span&gt;: &lt;span&gt;&#x27;post&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;path&lt;/span&gt;: &lt;span&gt;&#x27;/users&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;middleware&lt;/span&gt;: [],&lt;br/&gt;    &lt;span&gt;handler&lt;/span&gt;: signup,&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;method&lt;/span&gt;: &lt;span&gt;&#x27;post&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;path&lt;/span&gt;: &lt;span&gt;&#x27;/login&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;middleware&lt;/span&gt;: [requestLogger],&lt;br/&gt;    &lt;span&gt;handler&lt;/span&gt;: login,&lt;br/&gt;  },&lt;br/&gt;];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;重构index.ts文件&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;最后也是最重要的一步就是简化&lt;code&gt;index.ts&lt;/code&gt;文件。我们通过一个forEach循环routes文件中声明的路由信息来代替所有的route相关的代码。这样做最大的好处是为所有的路由定义了类型。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; express &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;express&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; bodyParser &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;body-parser&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { routes } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./routes&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;const app = express();&lt;br/&gt;const PORT = &lt;span&gt;3000&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;app.use(bodyParser.urlencoded({ extended: &lt;span&gt;false&lt;/span&gt; }));&lt;br/&gt;&lt;br/&gt;routes.forEach(&lt;span&gt;&lt;span&gt;(route)&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  const { method, path, middleware, handler } = route;&lt;br/&gt;  app[method](path, ...middleware, handler);&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;app.listen(PORT, &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(`&lt;span&gt;Express &lt;span&gt;with&lt;/span&gt; Typescript! http:&lt;span&gt;//localhost:${PORT}&lt;/span&gt;&lt;/span&gt;`);&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样看起来代码结构清晰多了，架构的好处就是如此。另外有了Typescript强类型的支持，保证了程序的稳定性。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;完整代码&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;Github&lt;/strong&gt;: &lt;br/&gt;https://github.com/fantingsheng/express-typescript-app&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>