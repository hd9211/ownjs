<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>bd7bfc4376ce573bae7556acd0db21c1</guid>
<title>Gopher 学习 Linux，这才是最正确的姿势</title>
<link>https://toutiao.io/k/acev52r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/oiccOczwQpFicFjP48rDgEmVAE0uIgJr7aM2jlZNkbPu3QHFCcdESeA4btj9eMHJxibG5DuyuOpeLcSSRU0lVfDxQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能提到运维使用的开发语言，大家第一个想到的应该就是 Python。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为它的库多，用起来之滑溜。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实 Go 用于运维方面的库也不少，今天就给大家介绍一个库，分分钟把服务器的资源信息，比如 CPU呀，内存呀的使用情况，扒得一清二楚。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.38745019920318724&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpFicFjP48rDgEmVAE0uIgJr7aBLplHgicic39pgK3YCJQOIkcmPd6uHy4rmOiawYNvrUia6CqvZR8ZsVcBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1004&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAxMDM4OTE4Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpFibibo18fyFiayicVL4FZV4ic7vibkR4NkVichWgwlZ3uURnJTGBrHNFpGafadfoQic1XOPPtgawW3kQuvNNA/0?wx_fmt=png&quot; data-nickname=&quot;GoLang全栈&quot; data-alias=&quot;GolangStackDev&quot; data-signature=&quot;我们专注于以go语言为核心，go名库，go框架，go+，go ORM，GRPC应用，设计模式，数据结构与算法，K8S，Docker，微服务的系列文章分享。&quot; data-from=&quot;0&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;我们用到的库&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方的 Github 地址：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;https://github.com/shirou/gopsutil&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看了下，在我写这篇文章的时候已经有 6.9k 的 start 了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0913580246913581&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpFicFjP48rDgEmVAE0uIgJr7adBjAIczeNW8HR6c13mWpgXic4kOjSCTzlcd6o7CEIqemmiaHV3VBusaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;810&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是他当前版本支持采集的信息。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;上代码&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们新建一个工程，在工程里面初始化 go mod 之后，直接 go get 就能安装完毕。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go get github.com/shirou/gopsutil/v3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;CPU使用情况&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先利用库来显示下当前电脑的 CPU 使用情况：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/shirou/gopsutil/v3/cpu&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;// 统计间隔，是否取单个还是总的&lt;/span&gt;&lt;br/&gt; p,_ := cpu.Percent(time.Second, &lt;span&gt;false&lt;/span&gt;)&lt;br/&gt; fmt.Println(p)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我就没处理采集错误的情况了，直接下划线忽略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个参数是统计间隔，你可以根据你的情况传入，秒，分，时都行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个参数为是否获取全部的总的统计，因为现在的电脑基本都是多核了吧，你可以传 true 返回的就是每个 CPU 的使用情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码放到 main 方法里面直接执行的结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ go run main.go &lt;br/&gt;[41.54228855767001]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我这里电脑的 CPU 当前使用情况为 41.54%&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;CPU使用情况&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存信息，全部在 mem 这个模块里面&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/shirou/gopsutil/v3/mem&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt;&lt;br/&gt; m,_ := mem.VirtualMemory()&lt;br/&gt; fmt.Println(m)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接执行就能得到下面一堆信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;span&gt;&quot;total&quot;&lt;/span&gt;:8589934592,&lt;span&gt;&quot;available&quot;&lt;/span&gt;:2171953152,&lt;span&gt;&quot;used&quot;&lt;/span&gt;:6417981440,&lt;span&gt;&quot;usedPercent&quot;&lt;/span&gt;:74.71513748168945,&lt;span&gt;&quot;free&quot;&lt;/span&gt;:95838208,&lt;span&gt;&quot;active&quot;&lt;/span&gt;:2128056320,&lt;span&gt;&quot;inactive&quot;&lt;/span&gt;:2076114944,&lt;span&gt;&quot;wired&quot;&lt;/span&gt;:2473566208,&lt;span&gt;&quot;laundry&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;buffers&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;cached&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;writeBack&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;dirty&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;writeBackTmp&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;shared&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;slab&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;sreclaimable&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;sunreclaim&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;pageTables&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;swapCached&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;commitLimit&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;committedAS&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;highTotal&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;highFree&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;lowTotal&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;lowFree&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;swapTotal&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;swapFree&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;mapped&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;vmallocTotal&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;vmallocUsed&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;vmallocChunk&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;hugePagesTotal&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;hugePagesFree&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;hugePageSize&quot;&lt;/span&gt;:0}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;美观升级&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果直接这样输出是不是太不美观了，咱们程序员也是追求美观的好不好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我再推荐一个库，用来格式化输出到我们控制台。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方 Github 库地址：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;github.com/olekukonko/tablewriter&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看下他的效果：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6314677930306231&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpFicFjP48rDgEmVAE0uIgJr7aiatZZ267cKHhAgYDfCpMicDlfAWLOOlr4uulUnBd3eWhf7xamgQQFfxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;947&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是不是一下就高大上了许多。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;安装使用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在项目下面直接执行 go get ：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go get github.com/olekukonko/tablewriter&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用思路很简单，我们需要构建一个二维的数组，然后直接丢给这个库渲染即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是我们把上面的信息一整合就得到了下面的这段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/olekukonko/tablewriter&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/shirou/gopsutil/v3/cpu&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/shirou/gopsutil/v3/mem&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;br/&gt; table := tablewriter.NewWriter(os.Stdout)&lt;br/&gt; table.SetHeader([]&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;项目&quot;&lt;/span&gt;, &lt;span&gt;&quot;数量&quot;&lt;/span&gt;, &lt;span&gt;&quot;百分比&quot;&lt;/span&gt;})&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 间隔，是否取单个还是总的&lt;/span&gt;&lt;br/&gt; p,_ := cpu.Percent(time.Second, &lt;span&gt;false&lt;/span&gt;)&lt;br/&gt; cpuCount,_ := cpu.Counts(&lt;span&gt;true&lt;/span&gt;)&lt;br/&gt; table.Append([]&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;CPU&quot;&lt;/span&gt;,&lt;br/&gt;  fmt.Sprintf(&lt;span&gt;&quot;%d核&quot;&lt;/span&gt;,cpuCount),&lt;br/&gt;  fmt.Sprintf(&lt;span&gt;&quot;%1.f%%&quot;&lt;/span&gt;,p[&lt;span&gt;0&lt;/span&gt;])})&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 内存信息&lt;/span&gt;&lt;br/&gt; m,_ := mem.VirtualMemory()&lt;br/&gt;&lt;br/&gt; table.Append([]&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;内存&quot;&lt;/span&gt;,&lt;br/&gt;  fmt.Sprintf(&lt;span&gt;&quot;%dG&quot;&lt;/span&gt;,m.Total/&lt;span&gt;1024&lt;/span&gt;/&lt;span&gt;1024&lt;/span&gt;/&lt;span&gt;1024&lt;/span&gt;),&lt;br/&gt;  fmt.Sprintf(&lt;span&gt;&quot;%1.f%%&quot;&lt;/span&gt;,m.UsedPercent)})&lt;br/&gt;&lt;br/&gt; table.Render()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接运行起来，就能看到下面的图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3145833333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpFicFjP48rDgEmVAE0uIgJr7aGHEPtSyM89hAibYt0lNJ4xe3B5SfqPsBiadMXdSWWQNXGgafWAGlqQmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f68eb03789761bfe2dd92bb0c1fe303a</guid>
<title>[译] Go 并不需要 Java 风格的 GC</title>
<link>https://toutiao.io/k/ksd0hqy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;&lt;p&gt;像Go、Julia和Rust这样的现代语言不需要像Java c#所使用的那样复杂的垃圾收集器。但这是为什么呢?&lt;/p&gt;
&lt;span id=&quot;more&quot;/&gt;

&lt;p&gt;我们首先要了解垃圾收集器是如何工作的，以及各种语言分配内存的方式有什么不同。首先，我们看看为什么Java需要如此复杂的垃圾收集器。&lt;/p&gt;
&lt;p&gt;本文将涵盖许多不同的垃圾收集器话题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么Java依赖快速GC？我将介绍Java语言本身中的一些设计选择，它们会给GC带来很大压力。&lt;/li&gt;
&lt;li&gt;内存碎片及其对GC设计的影响。为什么这对Java很重要，但对Go就不那么重要。&lt;/li&gt;
&lt;li&gt;值类型以及它们如何改变GC。&lt;/li&gt;
&lt;li&gt;分代垃圾收集器，以及Go为什么不需要它。&lt;/li&gt;
&lt;li&gt;逃逸分析 —— Go用来减少GC压力的一个技巧。&lt;/li&gt;
&lt;li&gt;压缩垃圾收集器 —— 这在Java中很重要，但是Go却不需要它。为什么?&lt;/li&gt;
&lt;li&gt;并发垃圾收集 —— Go通过使用多线程运行并发垃圾收集器来解决许多GC挑战。为什么用Java更难做到这一点。&lt;/li&gt;
&lt;li&gt;对Go GC的常见批评，以及为什么这种批评背后的许多假设往往是有缺陷的或完全错误的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;为什么Java比其他语言更需要快速的GC&quot;&gt;&lt;a href=&quot;#为什么Java比其他语言更需要快速的GC&quot; class=&quot;headerlink&quot; title=&quot;为什么Java比其他语言更需要快速的GC&quot;/&gt;为什么Java比其他语言更需要快速的GC&lt;/h1&gt;&lt;p&gt;基本上，Java将内存管理完全外包给它的垃圾收集器。事实证明，这是一个巨大的错误。然而，为了能够解释这一点，我需要介绍更多的细节。&lt;/p&gt;
&lt;p&gt;让我们从头说起。现在是1991年，Java的工作已经开始。垃圾收集器现在很流行。相关的研究看起来很有前途，Java的设计者们把赌注押在高级垃圾收集器上，它能够解决内存管理中的所有挑战。&lt;/p&gt;
&lt;p&gt;由于这个原因，Java中的所有对象——除了整数和浮点值等基本类型——都被设计为在堆上分配。在讨论内存分配时，我们通常会区分所谓的堆和栈。&lt;/p&gt;
&lt;p&gt;栈使用起来非常快，但空间有限，只能用于那些在函数调用的生命周期之内的对象。栈只适用于局部变量。&lt;/p&gt;
&lt;p&gt;堆可用于所有对象。Java基本上忽略了栈，选择在堆上分配所有东西，除了整数和浮点等基本类型。无论何时，在Java中写下 &lt;code&gt;new Something()&lt;/code&gt;消耗的都是堆上的内存。&lt;/p&gt;
&lt;p&gt;然而，就内存使用而言，这种内存管理实际上相当昂贵。你可能认为创建一个32位整数的对象只需要4字节的内存。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Knight&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; health;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;然而，为了让垃圾收集器能够工作，Java存储了一个头部信息，包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类型/Type — 标识对象属于的类或它的类型。&lt;/li&gt;
&lt;li&gt;锁/Lock — 用于同步语句。&lt;/li&gt;
&lt;li&gt;标记/Mark — 标记和清除（mark and sweep）垃圾收集器使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些数据通常为16字节。因此，头部信息与实际数据的比例是4:1。Java对象的c++源代码定义为：&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/oops/oop.hpp#l59&quot;&gt;OpenJDK基类&lt;/a&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;oopDesc&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;volatile&lt;/span&gt; markOop  _mark;   &lt;span class=&quot;comment&quot;&gt;// for mark and sweep&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    Klass*           _klass;   &lt;span class=&quot;comment&quot;&gt;// the type&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;内存碎片&quot;&gt;&lt;a href=&quot;#内存碎片&quot; class=&quot;headerlink&quot; title=&quot;内存碎片&quot;/&gt;内存碎片&lt;/h2&gt;&lt;p&gt;接下来的问题是内存碎片。当Java分配一个对象数组时，它实际上是创建一个引用数组，这些引用指向内存中的其他对象。这些对象最终可能分散在堆内存中。这对性能非常不利，因为现代微处理器不读取单个字节的数据。因为开始传输内存数据是比较慢的，每次CPU尝试访问一个内存地址时，CPU会读取一块连续的内存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/./go-does-not-need-a-java-style-gc/fragmentd-vs-contiguous-memory.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这块连续的内存块被称为cache line 。CPU有自己的缓存，它的大小比内存小得多。CPU缓存用于存储最近访问的对象，因为这些对象很可能再次被访问。如果内存是碎片化的，这意味着cache line也会被碎片化，CPU缓存将被大量无用的数据填满。CPU缓存的命中率就会降低。&lt;/p&gt;
&lt;h2 id=&quot;Java如何克服内存碎片&quot;&gt;&lt;a href=&quot;#Java如何克服内存碎片&quot; class=&quot;headerlink&quot; title=&quot;Java如何克服内存碎片&quot;/&gt;Java如何克服内存碎片&lt;/h2&gt;&lt;p&gt;为了解决这些主要的缺点，Java维护者在高级垃圾收集器上投入了大量的资源。他们提出了压缩（compact）的概念，也就是说，把对象移动到内存中相邻的块中。这个操作非常昂贵，将内存数据从一个位置移动到另一个位置会消耗CPU周期，更新指向这些对象的引用也会消耗CPU周期。&lt;/p&gt;
&lt;p&gt;这些引用被使用的时候，垃圾收集器没法更新它们。所以更新这些引用需要暂停所有的线程。这通常会导致Java程序在移动对象、更新引用和回收未使用内存的过程中出现数百毫秒的完全暂停。&lt;/p&gt;
&lt;h2 id=&quot;增加复杂性&quot;&gt;&lt;a href=&quot;#增加复杂性&quot; class=&quot;headerlink&quot; title=&quot;增加复杂性&quot;/&gt;增加复杂性&lt;/h2&gt;&lt;p&gt;为了减少这些长时间的暂停，Java使用了所谓的分代垃圾收集器（generational garbage collector）。这些都是基于以下前提：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在程序中分配的大多数对象很快就会被释放。因此，如果GC花更多时间来处理最近分配的对象，那么应该会减少GC的压力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这就是为什么Java将它们分配的对象分成两组：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;老年对象——在GC的多次标记和清除操作中幸存下来的对象。每次标记和扫描操作时，会更新一个分代计数器，以跟踪对象的“年龄”。&lt;/li&gt;
&lt;li&gt;年轻对象——这些对象的“年龄”较小，也就是说他们是最近才分配出来的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Java更积极地处理、扫描最近分配的对象，并检查它们是否应该被回收或移动。随着对象“年龄”的增长，它们会被移出年轻代区域。&lt;/p&gt;
&lt;p&gt;所有这些优化会带来更多的复杂度，它需要更多的开发工作量。它需要支付更多的钱来雇佣更优秀的开发者。&lt;/p&gt;
&lt;h1 id=&quot;现代语言如何避免与Java相同的缺陷&quot;&gt;&lt;a href=&quot;#现代语言如何避免与Java相同的缺陷&quot; class=&quot;headerlink&quot; title=&quot;现代语言如何避免与Java相同的缺陷&quot;/&gt;现代语言如何避免与Java相同的缺陷&lt;/h1&gt;&lt;p&gt;现代语言不需要像Java和c#那样复杂的垃圾收集器。这是在设计这些语言时，并没有像Java一样依赖垃圾回收器。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;figcaption&gt;&lt;span&gt;Go语言：创建一个包含15000个Point对象的数组&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Point &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    X, Y &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; points [&lt;span class=&quot;number&quot;&gt;15000&lt;/span&gt;]Point&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在上面的Go代码示例中，我们分配了15000个Point对象。这仅仅分配了一次内存，产生了一个指针。在Java中，这需要15000次内存分配，每次分配产生一个引用，这些应用也要单独管理起来。每个&lt;code&gt;Point&lt;/code&gt;对象都会有前面提到的16字节头部信息开销。而不管是在Go语言、Julia还是Rust中，你都不会看到头部信息，对象通常是没有这些头部信息的。&lt;/p&gt;
&lt;p&gt;在Java中，GC追踪和管理15000独立的对象。Go只需要追踪一个对象。&lt;/p&gt;
&lt;h2 id=&quot;值类型&quot;&gt;&lt;a href=&quot;#值类型&quot; class=&quot;headerlink&quot; title=&quot;值类型&quot;/&gt;值类型&lt;/h2&gt;&lt;p&gt;在除Java外的其他语言，基本上都支持值类型。下面的代码定义了一个矩形，用一个Min和Max点来定义它的范围。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Rect &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   Min, Max Point&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这就变成了一个连续的内存块。在Java中，这将变成一个&lt;code&gt;Rect&lt;/code&gt;对象，它引用了两个单独的对象，&lt;code&gt;Min&lt;/code&gt;和&lt;code&gt;Max&lt;/code&gt;对象。因此在Java中，一个&lt;code&gt;Rect&lt;/code&gt;实例需要3次内存分配，但在Go、Rust、C/c++和Julia中只需要1次内存分配。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/./go-does-not-need-a-java-style-gc/java-memory-frag-vs-contiguous-blocks.png&quot; alt=&quot;左边是Java风格的内存碎片。在Go, C/C++， Julia等程序中，在右边的连续内存块上。&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在将Git移植到Java时，缺少值类型造成了严重的问题。如果没有值类型，就很难获得良好的性能。正如Shawn O. Pearce&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://marc.info/?l=git&amp;amp;m=124111702609723&quot;&gt;在JGit开发者邮件列表上所说&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JGit一直纠结于没有一种有效的方式来表示SHA-1。C只需要输入&lt;code&gt;unsigned char[20]&lt;/code&gt;并将其内联到容器的内存分配中。Java中的&lt;code&gt;byte[20]&lt;/code&gt;将额外消耗16个字节的内存，而且访问速度较慢，因为这10个字节和容器对象位于不相邻的内存区域。我们试图通过将一个&lt;code&gt;byte[20]&lt;/code&gt;转换为5个int来解决这个问题，但这需要耗费额外的CPU指令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们在说什么?在Go语言中，我可以做和C/C++一样的事情，并定义一个像这样的结构:&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Sha1 &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   data [&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;]&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这些字节将位于一个完整的内存块中。而Java将创建一个指向其他地方的指针。&lt;/p&gt;
&lt;p&gt;Java开发人员意识到他们搞砸了，开发者确实需要值类型来获得良好的性能。你可以说这种说法比较夸张，但你需要解释一下&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://en.wikipedia.org/wiki/Project_Valhalla_(Java_language)&quot;&gt;Valhalla项目&lt;/a&gt;。这是Oracle为Java值类型所做的努力，这样做的原因正是我在这里所谈论的。&lt;/p&gt;
&lt;h2 id=&quot;值类型是不够的&quot;&gt;&lt;a href=&quot;#值类型是不够的&quot; class=&quot;headerlink&quot; title=&quot;值类型是不够的&quot;/&gt;值类型是不够的&lt;/h2&gt;&lt;p&gt;那么Valhalla项目能解决Java的问题吗?不是的。它仅仅是将Java带到了与c#同等的高度上。c#比Java晚几年出现，并且意识到垃圾收集器并不像大家想象的那么神奇。因此，他们增加了值类型。&lt;/p&gt;
&lt;p&gt;然而，在内存管理灵活性方面，这并没有使c#/Java与Go、C/C++等语言处于同等地位。Java不支持真正的指针。在Go中，我可以这样写：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;figcaption&gt;&lt;span&gt;Go语言指针用法&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ptr *Point = &amp;amp;rect.Min &lt;span class=&quot;comment&quot;&gt;// 把指向 Min 的指针存储到 ptr 中&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;*ptr = Point(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)         &lt;span class=&quot;comment&quot;&gt;// 替换 rect.Min 对象&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;就像在C/C++中一样，你可以在Go中获取对象的地址或对象的字段，并将其存储在一个指针中。然后，您可以传递这个指针，并使用它来修改所指向的字段。这意味着您可以在Go中创建大的值对象，并将其作为函数指针传递，来优化性能。在c#中情况要好一些，因为它对指针的支持&lt;em&gt;有限&lt;/em&gt;。前面的Go例子可以用c#写成：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;figcaption&gt;&lt;span&gt;C#指针用法&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;unsafe void foo() {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   ref var ptr = ref rect.Min;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   ptr = new Point(2, 4);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;然而c#的指针支持伴随着一些不适用于Go的警告:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用指针的代码必须标记为&lt;strong&gt;unsafe&lt;/strong&gt;。这会产生安全性较低且更容易崩溃的代码。&lt;/li&gt;
&lt;li&gt;必须是在堆栈上分配的纯值类型(所有结构字段也必须是值类型)。&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;fixed&lt;/strong&gt;的范围内，fixed关键字关闭了垃圾收集。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，在c#中使用值类型的正常和安全的方法是复制它们，因为这不需要定义unsafe或fixed的代码域。但对于较大的值类型，这可能会产生性能问题。Go就没有这些问题了。您可以在Go中创建指向由垃圾收集器管理的对象的指针。Go语言中，不需要像在c#中那样，将使用指针的代码单独标记出来。&lt;/p&gt;
&lt;h2 id=&quot;自定义二次分配器&quot;&gt;&lt;a href=&quot;#自定义二次分配器&quot; class=&quot;headerlink&quot; title=&quot;自定义二次分配器&quot;/&gt;自定义二次分配器&lt;/h2&gt;&lt;p&gt;使用正确的指针，你可以做很多值类型做不到的事情。一个例子就是创建二级分配器。Chandra Sekar S给出了一个例子：&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://blog.cskr.dev/posts/arena-allocation-in-go/&quot;&gt;Go中的 Arena 分配&lt;/a&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Arena []Node&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(arena *Arena)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Alloc&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;Node&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt;(*arena) == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        *arena = &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;([]Node, &lt;span class=&quot;number&quot;&gt;10000&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    n := &amp;amp;(*arena)[&lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt;(*arena)&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    *arena = (*arena)[:&lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt;(*arena)&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; n&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;为什么这些有用？如果你查看一些微基准测试，比如构造二叉树的算法，通常会发现Java比Go有很大的优势。这是因为构造二叉树算法通常用于测试垃圾收集器在分配对象时的速度。Java在这方面非常快，因为它使用了我们所说的bump指针。它只是增加一个指针值，而Go将在内存中寻找一个合适的位置来分配对象。然而，使用Arena分配器，你也可以在Go中快速构建二叉树。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;buildTree&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(item, depth &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, arena *Arena)&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;Node&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    n := arena.Alloc()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; depth &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        *n = Node{item, &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        *n = Node{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;              item,&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;              buildTree(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;*item&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;, depth&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;, arena),&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;              buildTree(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;*item, depth&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;, arena),&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; n&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这就是为什么真正的指针会有好处。你不能在一个连续的内存块中创建一个指向元素的指针，如下所示:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n := &amp;amp;(*arena)[len(*arena)-1]&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;Java-Bump分配器的问题&quot;&gt;&lt;a href=&quot;#Java-Bump分配器的问题&quot; class=&quot;headerlink&quot; title=&quot;Java Bump分配器的问题&quot;/&gt;Java Bump分配器的问题&lt;/h1&gt;&lt;p&gt;Java GC使用的bump分配器与Arena分配器类似，您只需移动一个指针就能获取下一个值。但开发者不需要手动指定使用Bump分配器。这可能看起来更智能。但它会导致一些在Go语言中没有的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;或早或晚，内存都需要进行压缩（compact），这涉及到移动数据和修复指针。Arena分配器不需要这样做。&lt;/li&gt;
&lt;li&gt;在多线程程序中，bump分配器需要锁(除非你使用线程本地存储)。这抹杀了它们的性能优势，要么是因为锁降低了性能，要么是因为线程本地存储将导致碎片化，这需要稍后进行压缩。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ian Lance Taylor是Go的创建者之一，他&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://groups.google.com/g/golang-nuts/c/KJiyv2mV2pU&quot;&gt;解释了bump分配器的问题&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一般来说，使用一组每个线程缓存来分配内存可能会更有效率，而在这一点上，你已经失去了bump分配器的优势。因此，我要断言，通常情况下，尽管有许多警告，但对多线程程序使用压缩内存分配器并没有真正的优势。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;分代GC和逃逸分析&quot;&gt;&lt;a href=&quot;#分代GC和逃逸分析&quot; class=&quot;headerlink&quot; title=&quot;分代GC和逃逸分析&quot;/&gt;分代GC和逃逸分析&lt;/h1&gt;&lt;p&gt;Java垃圾收集器有更多的工作要做，因为它分配了更多的对象。为什么？我们刚刚讲过了。如果没有值对象和真正的指针，在分配大型数组或复杂的数据结构时，它将总是以大量的对象告终。因此，它需要分代GC。&lt;/p&gt;
&lt;p&gt;分配更少对象的需求对Go语言有利。但Go语言还有另一个技巧。Go和Java在编译函数时都进行了逃逸分析。&lt;/p&gt;
&lt;p&gt;逃逸分析包括查看在函数内部创建的指针，并确定该指针是否逃逸出了函数范围。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;escapingPtr&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; []&lt;span class=&quot;title&quot;&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   values := []&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;{&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; values&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;fun nonEscapingPtr() &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    values = []&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;{&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; total &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; = addUp(values)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; total&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在第一个示例中，&lt;code&gt;values&lt;/code&gt;指向一个切片，这在本质上与指向数组的指针相同。它逃逸了是因为它被返回了。这意味着必须在堆上分配&lt;code&gt;values&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然而，在第二个例子中，指向&lt;code&gt;values&lt;/code&gt;的指针并不会离开&lt;code&gt;nonEscapingPtr&lt;/code&gt;函数。因此，可以在栈上分配&lt;code&gt;values&lt;/code&gt;，这个动作非常快速，并且代价也很小。逃逸分析本身只分析指针是否逃逸。&lt;/p&gt;
&lt;h2 id=&quot;Java逃逸分析的限制&quot;&gt;&lt;a href=&quot;#Java逃逸分析的限制&quot; class=&quot;headerlink&quot; title=&quot;Java逃逸分析的限制&quot;/&gt;Java逃逸分析的限制&lt;/h2&gt;&lt;p&gt;Java也做转义分析，但在使用上有更多的限制。从Java SE 16 Oracle文档覆盖热点虚拟机：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于不进行全局转义的对象，它不会将堆分配替换为堆栈分配。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而，Java使用了另一种称为&lt;em&gt;标量替换&lt;/em&gt;的技巧，它避免了将对象放在栈上的需要。本质上，它分解对象，并将其基本成员放在栈上。请记住，Java已经可以在栈上放置诸如&lt;code&gt;int&lt;/code&gt;和&lt;code&gt;float&lt;/code&gt;等基本值。然而，正如&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://pkolaczk.github.io/overhead-of-optional/&quot;&gt;Piotr Kołaczkowski&lt;/a&gt;在2021年发现的那样，在实践中，标量替换即使在非常微不足道的情况下也不起作用。&lt;/p&gt;
&lt;p&gt;相反，标量替换的主要的优点是避免了锁。如果你知道一个指针不会在函数之外使用，你也可以确定它不需要锁。&lt;/p&gt;
&lt;h2 id=&quot;Go语言逃逸分析的优势&quot;&gt;&lt;a href=&quot;#Go语言逃逸分析的优势&quot; class=&quot;headerlink&quot; title=&quot;Go语言逃逸分析的优势&quot;/&gt;Go语言逃逸分析的优势&lt;/h2&gt;&lt;p&gt;但是，Go使用逃逸分析来确定哪些对象可以在堆栈上分配。这大大减少了寿命短的对象的数量，这些对象本来可以从分代GC中受益。但是要记住，分代GC的全部意义在于利用最近分配的对象生存时间很短这一事实。然而，Go语言中的大多数对象可能会活得很长，因为生存时间短的对象很可能会被逃逸分析捕获。&lt;/p&gt;
&lt;p&gt;与Java不同，在Go语言中，逃逸分析也适用于复杂对象。Java通常只能成功地对字节数组等简单对象进行逃逸分析。即使是内置的ByteBuffer也不能使用标量替换在堆栈上进行分配。&lt;/p&gt;
&lt;h1 id=&quot;现代语言不需要压缩GC&quot;&gt;&lt;a href=&quot;#现代语言不需要压缩GC&quot; class=&quot;headerlink&quot; title=&quot;现代语言不需要压缩GC&quot;/&gt;现代语言不需要压缩GC&lt;/h1&gt;&lt;p&gt;您可以读到许多垃圾收集器方面的专家声称，由于内存碎片，Go比Java更有可能耗尽内存。这个论点是这样的：因为Go没有压缩垃圾收集器，内存会随着时间的推移而碎片化。当内存被分割时，你将到达一个点，将一个新对象装入内存将变得困难。&lt;/p&gt;
&lt;p&gt;然而，由于两个原因，这个问题大大减少了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Go不像Java那样分配那么多的小对象。它可以将大型对象数组作为单个内存块分配。&lt;/li&gt;
&lt;li&gt;现代的内存分配器，如谷歌的 TCMalloc 或英特尔的 Scalable Malloc 不会对内存进行分段。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在设计Java的时候，内存碎片是内存分配器的一个大问题。人们不认为这个问题可以解决。但即使回到1998年，在Java问世后不久，研究人员就开始解决这个问题。下面是&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://dl.acm.org/doi/10.1145/286860.286864&quot;&gt;Mark S. Johnstone和Paul R. Wilson的一篇论文&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这实质上加强了我们之前的结果，这些结果表明，内存碎片问题通常被误解了，好的分配器策略可以为大多数程序提供良好的内存使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此，设计Java内存分配策略时的许多假设都不再正确。&lt;/p&gt;
&lt;h1 id=&quot;分代GC-vs-并发GC的暂停&quot;&gt;&lt;a href=&quot;#分代GC-vs-并发GC的暂停&quot; class=&quot;headerlink&quot; title=&quot;分代GC vs 并发GC的暂停&quot;/&gt;分代GC vs 并发GC的暂停&lt;/h1&gt;&lt;p&gt;使用分代GC的Java策略旨在使垃圾收集周期更短。要知道，为了移动数据和修复指针，Java必须停止所有操作。如果停顿太久，将会降低程序的性能和响应能力。使用分代GC，每次检查的数据更少，从而减少了检查时间。&lt;/p&gt;
&lt;p&gt;然而，Go用一些替代策略解决了同样的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;因为不需要移动内存，也不需要固定指针，所以在GC运行期间要做的工作会更少。Go GC只做一个标记和清理：它在对象图中查找应该被释放的对象。&lt;/li&gt;
&lt;li&gt;它并发运行。因此，单独的GC线程可以在不停止其他线程的情况下寻找要释放的对象。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为什么Go可以并发运行GC而Java却不行？因为Go不会修复任何指针或移动内存中的任何对象。因此，不存在尝试访问一个对象的指针，而这个对象刚刚被移动，但指针还没有更新这种风险。不再有任何引用的对象不会因为某个并发线程的运行而突然获得引用。因此，平行移动“已经死亡”的对象没有任何危险。&lt;/p&gt;
&lt;p&gt;这是怎么回事？假设你有4个线程在一个Go程序中工作。其中一个线程在任意时间&lt;code&gt;T&lt;/code&gt;秒内执行临时GC工作，时间总计为4秒。&lt;/p&gt;
&lt;p&gt;现在想象一下，一个Java程序的GC只做了2秒的GC工作。哪个程序挤出了最多的性能?谁在&lt;code&gt;T&lt;/code&gt;秒内完成最多?听起来像Java程序，对吧?错了！&lt;/p&gt;
&lt;p&gt;Java程序中的4个工作线程将停止所有线程2秒。这意味着 2×4 = 8秒的工作在&lt;code&gt;T&lt;/code&gt;秒中丢失。因此，虽然Go的停止时间更长，但每次停止对程序工作的影响更小，因为所有线程都没有停止。因此，缓慢的并发GC的性能可能优于依赖于停止所有线程来执行其工作的较快GC。&lt;/p&gt;
&lt;h2 id=&quot;如果垃圾产生的速度比清理它的速度还快怎么办？&quot;&gt;&lt;a href=&quot;#如果垃圾产生的速度比清理它的速度还快怎么办？&quot; class=&quot;headerlink&quot; title=&quot;如果垃圾产生的速度比清理它的速度还快怎么办？&quot;/&gt;如果垃圾产生的速度比清理它的速度还快怎么办？&lt;/h2&gt;&lt;p&gt;反对当前垃圾收集器的一个流行观点是，活动工作线程产生垃圾的速度可能比垃圾收集器线程收集垃圾的速度快。在Java世界中，这被称为“并发模式失败”。&lt;/p&gt;
&lt;p&gt;在这种情况下，运行时别无选择，只能完全停止程序并等待GC周期完成。因此，当Go声称GC暂停时间非常低时，这种说法只适用于GC有足够的CPU时间和空间超过主程序的情况。&lt;/p&gt;
&lt;p&gt;但是Go语言有一个聪明的技巧来绕过&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://blog.golang.org/ismmkeynote&quot;&gt;Go GC大师Rick Hudson所描述的这个问题&lt;/a&gt;。Go使用的是所谓的“Pacer”。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果需要的话，Pacer会在加速标记的同时降低分配速度。在一个较高的水平，Pacer停止了Goroutine，它做了大量的分配，并让它做标记。工作量与Goroutine的分配成比例。这加快了垃圾收集器的速度，同时减慢了mutator的速度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Goroutines有点像在线程池上复用的绿色线程。基本上，Go接管正在运行产生大量垃圾的工作负载的线程，并让它们帮助GC清理这些垃圾。它会一直接管线程，直到GC的运行速度超过产生垃圾的协程。&lt;/p&gt;
&lt;h1 id=&quot;简而言之&quot;&gt;&lt;a href=&quot;#简而言之&quot; class=&quot;headerlink&quot; title=&quot;简而言之&quot;/&gt;简而言之&lt;/h1&gt;&lt;p&gt;虽然高级垃圾收集器解决了Java中的实际问题，但现代语言，如Go和Julia，从一开始就避免了这些问题，因此不需要使用Rolls Royce垃圾收集器。当您有了值类型、转义分析、指针、多核处理器和现代分配器时，Java设计背后的许多假设都被抛到了脑后。它们不再适用。&lt;/p&gt;
&lt;h1 id=&quot;GC的Tradeoff不再适用&quot;&gt;&lt;a href=&quot;#GC的Tradeoff不再适用&quot; class=&quot;headerlink&quot; title=&quot;GC的Tradeoff不再适用&quot;/&gt;GC的Tradeoff不再适用&lt;/h1&gt;&lt;p&gt;Mike Hearn在Medium上有一个非常受欢迎的故事，他批评了Go GC的说法：&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e&quot;&gt;现代垃圾收集&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Hearn的关键信息是GC设计中总是存在权衡。他的观点是，因为Go的目标是低延迟收集，他们将在许多其他指标上受到影响。这是一本有趣的读物，因为它涵盖了很多关于GC设计中的权衡的细节。&lt;/p&gt;
&lt;p&gt;首先，低延迟是什么意思?Go GC平均只暂停0.5毫秒，而各种Java收集器可能要花费数百毫秒。&lt;/p&gt;
&lt;p&gt;我认为Mike Hearn的论点的问题在于，它们基于一个有缺陷的前提，即所有语言的内存访问模式都是相同的。正如我在本文中所提到的，根本不是这样的。Go生成的需要GC管理的对象会少得多，并且它会使用逃逸分析提前清理掉很多对象。&lt;/p&gt;
&lt;h2 id=&quot;老技术本身就是坏的&quot;&gt;&lt;a href=&quot;#老技术本身就是坏的&quot; class=&quot;headerlink&quot; title=&quot;老技术本身就是坏的?&quot;/&gt;老技术本身就是坏的?&lt;/h2&gt;&lt;p&gt;Hearn的论点声明，简单的收集在某种程度上是不好的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Stop-the-world (STW)标记/清除是本科生计算机科学课程中最常用的GC算法。在做工作面试时，我有时会让应聘者谈论一些关于GC的内容，但几乎总是，他们要么将GC视为一个黑盒子，对它一无所知，要么认为它至今仍在使用这种非常古老的技术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是的，它可能是旧的，但是这种技术允许并发地运行GC，这是“现代”的技术不允许的。在我们拥有多核的现代硬件世界中，这一点更重要。&lt;/p&gt;
&lt;h2 id=&quot;Go-不是-C&quot;&gt;&lt;a href=&quot;#Go-不是-C&quot; class=&quot;headerlink&quot; title=&quot;Go 不是 C#&quot;/&gt;Go 不是 C#&lt;/h2&gt;&lt;p&gt;另一个说法:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于Go是一种具有值类型的相对普通的命令式语言，它的内存访问模式可能可以与C#相比较，后者的分代假设当然成立，因此.NET使用分代收集器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;事实并非如此。C#开发人员会尽量减少大值对象的使用，因为不能安全地使用与指针相关的代码。我们必须假设c#开发人员更喜欢复制值类型而不是使用指针，因为这可以在CLR中安全地完成。这自然会带来更高的开销。&lt;/p&gt;
&lt;p&gt;据我所知，C#也没有利用逃逸分析来减少堆上的短生命周期对象的产生。其次，C#并不擅长同时运行大量任务。Go可以利用它们的协程来同时加速收集，就像Pacer提到的那样。&lt;/p&gt;
&lt;h2 id=&quot;内存压缩整理&quot;&gt;&lt;a href=&quot;#内存压缩整理&quot; class=&quot;headerlink&quot; title=&quot;内存压缩整理&quot;/&gt;内存压缩整理&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;压缩：因为没有压缩，你的程序最终会把堆碎片化。我将在下面进一步讨论堆碎片。在缓存中整齐地放置东西也不会给您带来好处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这里，Mike Hearn对分配器的描述并不是最新的。TCMalloc等现代分配器基本上消除了这个问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;程序吞吐量:由于GC必须为每个周期做大量工作，这从程序本身窃取CPU时间，降低了它的速度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当您有一个并发GC时，这并不适用。所有其他线程都可以在GC工作时继续运行——不像Java，它必须停止整个世界。&lt;/p&gt;
&lt;h2 id=&quot;堆的开销&quot;&gt;&lt;a href=&quot;#堆的开销&quot; class=&quot;headerlink&quot; title=&quot;堆的开销&quot;/&gt;堆的开销&lt;/h2&gt;&lt;p&gt;Hearn提出了“并发模式失败”的问题，假设Go GC会有跟不上垃圾生成器的速度的风险。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;堆开销:因为通过标记/清除收集堆是非常慢的，你需要大量的空闲空间来确保你不会遭遇“并发模式失败”。默认的堆开销是100%，它会使你的程序需要的内存翻倍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我对这种说法持怀疑态度，因为我看到的许多现实世界的例子似乎都建议围棋程序使用更少的内存。更不用说，这忽略了Pacer的存在，它会抓住Goroutines，产生大量垃圾，让他们清理。&lt;/p&gt;
&lt;h1 id=&quot;为什么低延迟对Java也很重要&quot;&gt;&lt;a href=&quot;#为什么低延迟对Java也很重要&quot; class=&quot;headerlink&quot; title=&quot;为什么低延迟对Java也很重要&quot;/&gt;为什么低延迟对Java也很重要&lt;/h1&gt;&lt;p&gt;我们生活在一个Docker和微服务的世界。这意味着许多较小的程序相互通信和工作。想象一个请求要经过好几个服务。在一个链条，这些服务中如果有一个出现重大停顿，就会产生连锁反应。它会导致所有其他进程停止工作。如果管道中的下一个服务正在等待STW的垃圾收集，那么它将无法工作。&lt;/p&gt;
&lt;p&gt;因此，延迟/吞吐量的权衡不再是GC设计中的权衡。当多个服务一起工作时，高延迟将导致吞吐量下降。Java对高吞吐量和高延迟GC的偏好适用于单块世界。它不再适用于微服务世界。&lt;/p&gt;
&lt;p&gt;这是Mike Hearn观点的一个根本问题，他认为没有灵丹妙药，只有权衡取舍。它试图给人这样一种印象：Java的权衡是同样有效的。但权衡必须根据我们所生活的世界进行调整。&lt;/p&gt;
&lt;p&gt;简而言之，我认为Go语言已经做出了许多聪明的举动和战略选择。如果这只是任何人都可以做的trade-off，那么省去它是不可取的。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;本文翻译自 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://itnext.io/go-does-not-need-a-java-style-gc-ac99b8d26c60&quot;&gt;https://itnext.io/go-does-not-need-a-java-style-gc-ac99b8d26c60&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>55756621413fc82a39b50f055cd9c84d</guid>
<title>爱奇艺基础数据平台演进</title>
<link>https://toutiao.io/k/dvuzaji</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;爱奇艺基础数据平台主要是为了统一公司内部的基础数据交换规范，解决不同团队之间ID不统一问题（各团队都有自己独立的ID）、数据定义不统一、数据更新不及时等问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.41271676300578036&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvuibb2I9gbEsarsp7lCY9vFAm1lTdUtet7XTzCHQJY5d5IeXJcF9sEQm5BsC7ibPDy0iaLU5Z65qlYkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;865&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着公司业务发展，除了视频基础数据，还逐步对接了 UGC 视频、全网影视资料、资源位、直播、游戏、文学、电商等公司大部分业务方的基础数据，支持海量业务数据的存储、分发、在线查询、离线分析等服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前已有近百张数据表，总数据量数十亿，数据日增长百万级，日消息量千万级，覆盖公司几十个业务团队。&lt;br clear=&quot;all&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文将从爱奇艺数据平台在实际业务中解决HBase高可用、消息服务高可用以及平台整体服务水平扩展能力等方面，叙述爱奇艺的探索和实践。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;   &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;服务能力&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;爱奇艺基础数据平台主要提供以下能力：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4393063583815029&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvuibb2I9gbEsarsp7lCY9vFAjSgaVaNcZ1NuW9goviaz7ibfyh97QvPueBJLdfms0JcF7j2QialMSfoEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;865&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;02&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;   &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;整体架构&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5676300578034682&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvuibb2I9gbEsarsp7lCY9vFAibjJ2Afeeg5hzSQoRLkia1b2wiagyNibGMjRnNM8AHicl670NAw0LnmbGDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;865&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;接入层：提供HTTP、RPC协议访问，提供统一的消息监听和离线扫描SDK&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;统一管理平台：为对接业务提供便捷的开发工具，表定义查看、数据量、消息量、修改记录，实时查询等功能；同时也包含一站式的字段定义管理系统，可高效便捷地对业务表字段进行调整。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;服务治理：对于数据的访问都有精细化的权限控制、流量控制等功能&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;03&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;   &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;服务流程&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8737727910238429&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvuibb2I9gbEsarsp7lCY9vFAStzhg3hoL155ZFWFXpicg5jBqUX0v0AsXpNsPfAWfib3IN2M99nwp0VQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;713&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先需要通过统一管理平台，定义好表及其的字段类型结构，随后会发布基于Protobuf的数据定义包，通过这个包来使用分发平台中存储的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;生产业务通过ID服务、写入服务将数据写入平台，平台会先将数据入库HBase，后会发送一个更新通知消息，下游业务通过订阅消息获取到具体变更的ID及字段信息，再通过读取服务获取该ID的最新数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;平台内部也基于消息将本次变动的内容记录于HBase，方便业务排查定位问题，尤其是数据结果不对时，业务可以很快通过这个变更记录查询到是哪个业务在什么时间具体IP地址改动的数据，在实际工作场景中使用频率较高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于消息合并服务主要是对写入触发的消息进行相同ID写入的合并，减少发出的消息量，降低下游订阅业务的处理压力。我们针对消息区分了优先级，不同的优先级有不同的合并窗口时间，例如：直播等业务对时效性相对敏感，消息合并则窗口期更短。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;04&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;   &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt; 服务方案&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;  &lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;4.1 ID服务的高可用&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8546637744034707&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvuibb2I9gbEsarsp7lCY9vFAicdEIWf6ZaRMafC1ndPmXrY0Fvuib5BS6Ap2WOiaIibicicHAHg2iaY6CyQbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;461&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ID服务使用2个MySQL集群，其中一个MySQL示例只生成单数ID，另外一个MySQL生成双数ID，这样可以做到其中一个MySQL不可用时，另外一个MySQL可以正常提供服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.2  消息分发&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;平台本身存储了很多不同业务的数据表（例如：视频、直播、图书等），业务可以根据自己的业务需要可以订阅单个或多个不同的业务表消息并做一定规则的过滤，而这种场景属于比较普遍的，所以由平台本身实现比较合理，不用每个业务都做一遍。基于这种背景下我们最初使用了ActiveMQ的VirtualTopic做了大类的区分，但一段时间后我们发现这种方式并不够灵活，无法控制的更精细。为此我们自研了一个ActiveMQ插件来满足相对精细的消息分发控制，整体结构如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1305555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvuibb2I9gbEsarsp7lCY9vFAWCkeuIr8iaqgFTrJm3HFP7JON53ogGh5VlbnnKZ9qze3z3vm7tlzNKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过管理平台我们将规则通过一个特殊的Topic推送到插件，插件本身会监听这个Topic消息，将规则保存在内存中并持久化，插件会在每一条消息发送之前对消息进行一个路由，根据订阅规则匹配发送到1个或多个队列中，原理类似AOP机制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;05&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;   &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt; 问题及解决方案&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;5.1  HBase读取性能差的问题&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于本身平台业务场景决定，一次写入对应N次读取，所以在极端场景下，线上偶尔发生过HBase某个RegionServer宕机的情况，进而造成大量的超时情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前我们的主要解决的思路就是加缓存，读多写少就是缓存的主要场景。在数据库选型上，我们在Redis、CouchBase、MongoDB上进行了调研，最终选择了MongoDB，主要的原因是Redis和CouchBase在容量上不满足业务需求。在我们对MongoDB的压测中，性能方面也在可接受范围内。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缓存方案如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.530635838150289&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvuibb2I9gbEsarsp7lCY9vFAjMAjI8EymDfgGcF2Fmhato6bWcL6DzbQicDoZrY4CSEBl9TSNibaXzMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;865&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;写入服务每次请求都会生成一个唯一的SessionID，我们将这个ID作为数据的版本号，缓存是否失效使用这个版本号来判断。每次写入时更新缓存以及读取时缓存失效时更新缓存都为异步，主要是为了降低延时，以及避免缓存更新失败导致写入失败。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了保证缓存和HBase的一致性，每次请求都要读取HBase中存储的版本号，这也对HBase造成了较大的压力，为了解决这个问题，我们将HBase中SessionId设为单独列族，并设置IN_MEMORY =&amp;gt; ‘true’来优化。&lt;/span&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5.2  HBase可用性&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于全部数据都存储在HBase，所以提升HBase本身的可用性就尤为重要，目前单集群内的单节点故障，HBase本身的机制是可以保证的。但是如果整个集群故障或者集群所在机房出现了故障，如何能保证服务可用？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过调研目前开源版本HBase还没有相对完善的跨机房部署方案，例如单个机房故障情况下不影响服务正常使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们在结合服务特性的情况下设计的HBase同城主备高可用方案，如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.002808988764045&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvuibb2I9gbEsarsp7lCY9vFAOegBiaANIibk248F61o0bkZfqnjvmPfqTiaKe72dnYgLk1dhfzngKuUUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;712&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Mongo作为写入缓存，保存WAL（WriteAhead Log）Mongo三机房部署，高可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Synchronizer服务将WAL写入主HBase，异步服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主HBase与备用HBase建立数据同步。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;写入流程：Write服务只写入Mongo，由Synchronizer同步服务将数据同步到主HBase。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;读取流程：同时读取Mongo和HBase，将WAL最新数据与HBase数据合并得到最新数据返回，读取服务使用Hystrix进行熔断，如果主HBase宕了，Mongo中数据与备用HBase集群仍然可以合并出最新数据返回。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Mongo中WAL设置TTL，时间大于主库到从库的同步延迟。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前该方案已经在生产环境经历了2次故障，并且故障对读写无影响，上下游业务无感知。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5.3  ActiveMQ碰到的问题&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于第一个问题我们的处理这种问题的方式也比较简单粗暴，通过之前开发的插件对每一个队列进行阈值控制，超过一定阈值则不再继续发送消息并通知业务及时消费消息，这对业务本身是有一定影响的，对业务不友好，治标不治本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在经历了较多次线上问题后，我们决定考虑其他消息中间件，在调研了市面上主流的消息中间件后我们将Kafka和RocketMQ作为备选，在选型的时候我们主要考虑几个因素，可用性、可靠性、水平扩展能力，在这3项中两个中间件都满足需求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还有一个需要考虑的因素就是消息过滤或分发，因为存量队列都有订阅规则，考虑业务迁移成本问题，这个订阅规则实现还是由平台实现，对比发现RocketMQ支持在服务器端过滤，这个特点吸引了我们，在经过功能验证后，该功能满足需求，最终选型RocketMQ。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;部署方案如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.641399416909621&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvuibb2I9gbEsarsp7lCY9vFAhYn9COl2giakqyJbSu0LZzzglaQmHEoEuNug2MkOWeSaEHATnQMgaFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;686&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;单集群同城3机房部署，主从部署在不同机房，保证单节点宕机、单机房不可用消息发送和消息消费不受影响，并且消息消费的时效性也不受影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5431547619047619&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvuibb2I9gbEsarsp7lCY9vFAIP3KPZqEqxoNlTmaAlYMRULz5VyJoicQqibt6Q6gtJZ0Mt8V0ogqeewg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;672&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们还开发了基于RocketMQ客户端的SDK，过滤规则都存储在配置服务，由SDK负责将订阅规则推送到FilterServer，业务可以更简单的迁移到RocketMQ，消息过滤在集群端，所以效率更高，可以减少不必要的消息投递到客户端。上线后，彻底解决了之前ActiveMQ的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5.4  扩展读能力&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着业务的不断发展，对接的业务会越来越多，现有读写逻辑相对复杂，读取能力并不能完全达到水平扩展的能力。为了可以更好支撑未来的业务发展，需要进一步提升读取能力，使服务读取能力完全做到水平扩展。在数据库层面，通常有读写分离，也就是正常的读请求操作主库，其余纯读取的请求使用从库来解决这种问题，但是由于业务场景限制，很多业务都是通过订阅以及获取最新数据的方式来同步平台数据经过一定的业务处理、抽取、加工成最终业务想要的数据，所以单纯将所有用户的读取请求都转为读从库显然并不合适，而且这些请求中还有一部分读请求是写入业务的先读后写，但是这种方案也给了我们启发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于平台业务较复杂，无法单纯在数据库层面做读写分离，所以就新增一个业务层面的从库，通过业务服务同步主库数据，这样下游业务可以通过从库同步或者单纯读取数据，而且从库可以增加多个。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;服务方案如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7820895522388059&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvuibb2I9gbEsarsp7lCY9vFACOjIOmb5q9xy60SUZfBwgshJ1es73YdcWj5ibZvX8Swict8QOicThZ7MA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;670&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;新服务SlaveRead（从库）可通过消息+读取的方式从主库同步最新数据，更新后发出消息，提供给下游服务使用，业务可以以相同的方式在从库同步数据或者单纯的读取请求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从库与从库之间可以建立同步关系，这样整体同步的压力就不会压在主库上，避免从库多进而增加主库压力，最终实现了平台能力可水平扩展。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;06&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;   &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总体来说爱奇艺基础数据平台通过在技术和服务方案上的不断改进解决业务实际碰到的问题，在RocketMQ、HBase上也积累了一些实战经验。未来将继续探索提高平台整体服务能力、服务稳定性、性能等方面的技术及方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100011924&quot; data-ratio=&quot;0.1787037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/unymlvueOvueerUPUVMYMza5vavcoBFAwibibF9VfD46qrxQDAwKBxWBZwwfCmot67PMKBEQUSSI2Rm0XXUgnIBw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;看完心动了吗？&lt;br/&gt;&lt;/section&gt;&lt;section&gt;戳👇“&lt;span&gt;&lt;strong&gt;阅读原文&lt;/strong&gt;&lt;/span&gt;”直达招聘页面&lt;/section&gt;&lt;section&gt;&lt;span&gt;即刻加入爱奇艺！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;也许你还想看&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MjczMjM2NA==&amp;amp;mid=2247494796&amp;amp;idx=1&amp;amp;sn=f3aed56cc37686351a53e1fe842383b8&amp;amp;chksm=e97570afde02f9b9da2e5ba71ed3d87b11b73c79ce9c1f6b2c2fe2d54d5376c4f545b9cb377e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;爱奇艺数据质量监控的探索和实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;爱奇艺数据质量监控的探索和实践&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MjczMjM2NA==&amp;amp;mid=2247493125&amp;amp;idx=2&amp;amp;sn=37d159b5550dcf9a25f37624f17af340&amp;amp;chksm=e9757a26de02f330938798c6502a228c6a2e543604cbc009aff655b31f5c32b85d122fd68aea&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;OCR技术在爱奇艺的应用实践及演进&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;OCR技术在爱奇艺的应用实践及演进&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MjczMjM2NA==&amp;amp;mid=2247494796&amp;amp;idx=2&amp;amp;sn=2a6701f7861db159b38ce374191fbe47&amp;amp;chksm=e97570afde02f9b91460c43b0aa0a667dea0a0f17c6571d0506c611ed57d1a97eede42c4fe7b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;后Hadoop时代，爱奇艺如何有效整合大数据和AI平台？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;后Hadoop时代，爱奇艺如何有效整合大数据和AI平台？&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages __bg_gif wxw-img&quot; data-fileid=&quot;100011926&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/unymlvueOvuxdEeTYeJjvpHdMng1mqJfcnlzibBzbAcDdsvYiauaiabzjxJhzYFWOqJ7jn85w3lic3AFC7RgRIO7kQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;300&quot;/&gt;&lt;span&gt; 关注我们，更多精彩内容陪伴你！&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI0MjczMjM2NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/unymlvueOvv6PGRNuUZ19FlffMW6Dvd1Q25ibG31IIuWw5LWqIIM9B5gpfPXibWOvjs1Nku3sr0zvsWrRX94ETUQ/0?wx_fmt=png&quot; data-nickname=&quot;爱奇艺技术产品团队&quot; data-alias=&quot;iQIYI-TP&quot; data-signature=&quot;爱奇艺的技术产品团队&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9471dff97a601b2cded77b467119680d</guid>
<title>Grafana-Variable 配置小技巧</title>
<link>https://toutiao.io/k/0ypsbmu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content e-content&quot; itemprop=&quot;description articleBody&quot;&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;版权声明 本站原创文章 由 萌叔 发表
转载请注明 萌叔 | http://vearne.cc
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;Dashboard是Grafana中非常重要的概念，每个Dashboard都是一个巨大的看板，在Dashboard上可以配置Panel(图表)。在Dashboard中有个特别的配置–Variables，Variables提供了用户和面板交互，可以动态刷新面板。&lt;br/&gt;
有些特殊的场景，需要有些小技巧，否则Variables仍然无法满足我们的要求。&lt;/p&gt;
&lt;h2&gt;1. Case 1&lt;/h2&gt;
&lt;p&gt;我要查看不同股票的日线图&lt;br/&gt;
&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20211119/99435512-4920-11ec-8f17-1e00da114f95.jpeg&quot; alt=&quot;&quot; data-pagespeed-url-hash=&quot;3841541434&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;1.1 Query&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;SELECT
  trade_date AS &quot;time&quot;,
  close
FROM daily_data where ts_code = &quot;$ts_code&quot; order by trade_date
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ts_code是股票的代码，显然如果只看股票代码，很难想起这个代码究竟对应的是哪一只股票。&lt;/p&gt;
&lt;p&gt;最好的方式是如下图这样，在变量的下拉列表中，显示股票名称，但是在实际的Query中使用股票代码查询。&lt;br/&gt;
&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20211119/816ec39e-4921-11ec-bd19-1e00da114f95.jpeg&quot; alt=&quot;&quot; data-pagespeed-url-hash=&quot;132483617&quot;/&gt;&lt;br/&gt;
grafan支持这种玩法，称为text和value&lt;/p&gt;
&lt;h3&gt;1.2 变量配置&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;注意需要Grafana的版本在7.4.5 或以上&lt;/strong&gt;&lt;br/&gt;
&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20211119/c53a3814-4922-11ec-853d-1e00da114f95.jpeg&quot; alt=&quot;&quot; data-pagespeed-url-hash=&quot;3315176618&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;1.2.1 配置Query&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;select concat(name, &quot;#&quot;, ts_code) from target;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这一步会查出形如下面的结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;中国平安#601318.SH
三一重工#600031.SH
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;1.2.2 分离出text和value&lt;/h3&gt;
&lt;p&gt;配置Regex&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;/(?&amp;lt;text&amp;gt;.*)#(?&amp;lt;value&amp;gt;.*)/
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;2. Case 2&lt;/h2&gt;
&lt;p&gt;我们有一组MySQL实例需要监控，MySQL的数量多达几十个。&lt;br/&gt;
但是实际上大家都知道，MySQL是主从的，1个主和多个从构成了1个集群。每个集群单独为1个业务提供服务。&lt;br/&gt;
MySQL实例如果这样列出来，萌叔根本不可能知道，这个实例属于哪个集群，支撑那个业务。&lt;br/&gt;
&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20211119/8b66f58a-4924-11ec-b65b-1e00da114f95.jpeg&quot; alt=&quot;&quot; data-pagespeed-url-hash=&quot;289382613&quot;/&gt;&lt;br/&gt;
我们希望的效果，是先选择partner(业务方)，然后再选择再从这个集群中选出关心的实例&lt;br/&gt;
&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20211119/a1009db2-491d-11ec-a2c2-1e00da114f95.jpeg&quot; alt=&quot;&quot; data-pagespeed-url-hash=&quot;3408354864&quot;/&gt;&lt;br/&gt;
&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20211119/47a99634-4926-11ec-beb2-1e00da114f95.jpeg&quot; alt=&quot;&quot; data-pagespeed-url-hash=&quot;2451163454&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.1 Query&lt;/h3&gt;
&lt;p&gt;事实上，我们可以通过构建2个Variables来达到这个目标&lt;br/&gt;
&lt;img src=&quot;http://ut-bucket01.sh1a.qingstor.com/woshiaotian/20211119/2e63a83a-4927-11ec-801a-1e00da114f95.jpeg&quot; alt=&quot;&quot; data-pagespeed-url-hash=&quot;45826944&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;2.1.1 Query1&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;label_values(mysql_up, partner)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到变量partner&lt;/p&gt;
&lt;h4&gt;2.1.2 Query2&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;label_values(mysql_up{partner=&quot;$partner&quot;}, instance)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Query2引用Query1的结果&lt;/p&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://grafana.com/docs/grafana/latest/variables/filter-variables-with-regex/&quot;&gt;Filter variables with regex&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://grafana.com/docs/grafana/latest/variables/variable-examples/&quot;&gt;variables/variable-examples&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr/&gt;
&lt;h4&gt;打赏我&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://st.vearne.cc/2ob&quot; alt=&quot;微信支付码&quot; data-pagespeed-url-hash=&quot;552127054&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;clear&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>db6e8f09b18aef646e6de3eb3b628137</guid>
<title>LinkedIn 直播系统是如何实现每秒百万点赞的</title>
<link>https://toutiao.io/k/u3prgdi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-inner&quot;&gt;
                                                    
&lt;p&gt;现如今直播领域非常火爆，而一个大V的直播很容易就会吸引上百万的用户同时在线。LinkedIn的直播领域专家Akhilesh Gupta在QCon London 2020上介绍了LinkedIn是如何实现百万点赞的架构，本文就根据Akhilesh在会议上的介绍总结了相关的实现方法供大家参考。&lt;/p&gt;



&lt;h1&gt;场景分析&lt;/h1&gt;



&lt;p&gt;这个问题的使用场景很简单，就是我们有一个直播视频，然后有很多不同的用户在同时观看，每个用户都可以对视频进行点赞，系统需要把这个点赞的信息发送到每个正在观看视频的用户端，然后在他们对应的UI上显示点赞的图标。这里最大的挑战就是假如有大量的用户在同时观看并点赞，如何及时有效地把相关点赞的信息发送到观看的用户端。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-21.png&quot; alt=&quot;&quot; class=&quot;wp-image-1148&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-21.png 233w, https://donggeitnote.com/wp-content/uploads/2021/11/image-21-192x300.png 192w&quot; sizes=&quot;(max-width: 233px) 100vw, 233px&quot;/&gt;&lt;/figure&gt;



&lt;h1&gt;服务端如何把点赞信息发送到客户端&lt;/h1&gt;



&lt;p&gt;我们从最简单的架构开始，用户S点了一个赞，发送了一个HTTP的request到了后端，一方面这个点赞的消息会被保存到后端数据库，另一方面我们需要有一个方法来把这个点赞的消息发送到别的用户端（用户A）。Linked采用的方法很简单，就是在用户A打开视频的时候，和服务端建立一个HTTP长poll链接，这个链接不会disconnect，所以当server端有需要发送的信息（比如点赞消息），它就会直接通过这个链接发送到用户端。用户端只要根据server的URL来创建一个EventSource的object，然后根据收到的内容来独立处理就可以了。&lt;/p&gt;



&lt;p&gt;简单架构如下所示，S发送点赞的信息到后端，后端会把这个信息publish出去，然后实时的delivery的系统会把相应的信息发送到已经建立长链接的client端。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-22.png&quot; alt=&quot;&quot; class=&quot;wp-image-1149&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-22.png 421w, https://donggeitnote.com/wp-content/uploads/2021/11/image-22-300x186.png 300w&quot; sizes=&quot;(max-width: 421px) 100vw, 421px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;用户端收到的信息可能就是如下所示，它然后就可以解析进行处理了。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-23.png&quot; alt=&quot;&quot; class=&quot;wp-image-1150&quot;/&gt;&lt;/figure&gt;



&lt;h1&gt;服务端链接管理&lt;/h1&gt;



&lt;p&gt;有了上面简单的架构之后，我们知道信息的传递主要是靠这个长链接，那么当有很多用户的时候，server端如何来管理这些链接呢？LinkedIn使用的Akka来进行管理的，Akka是一个高性能高容错的分布式并行框架。它有实现一个很经典的Actor模型，Akka Actor拥有自己的状态和行为，行为会定义说我收到某一个信息之后如何修改状态，每个Actor都有一个mailbox，所有其它Actor发送过来的消息都会进入该邮箱。Actor很轻量，所以很容易就能够支持到百万级别的Actor（1G内存可支持约300万个Actor）。&lt;/p&gt;



&lt;p&gt;这样一来在LinkedIn的直播系统中，每个Actor的状态就是一个connection，行为就是一个publish event，它可以定义我们如何把event publish到长链接的另外一端（用户端）&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-24.png&quot; alt=&quot;&quot; class=&quot;wp-image-1151&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-24.png 450w, https://donggeitnote.com/wp-content/uploads/2021/11/image-24-300x183.png 300w&quot; sizes=&quot;(max-width: 450px) 100vw, 450px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;这样一来一个server就可以管理很多connection，当有一个点赞的信息到来的时候，就会发送到一个supervisor actor，然后它会把这个信息分发到不同的actor中，这些actor其实每一个就对应一个和用户端的链接，从而把相应的点赞信息发送给用户端。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-25.png&quot; alt=&quot;&quot; class=&quot;wp-image-1152&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-25.png 539w, https://donggeitnote.com/wp-content/uploads/2021/11/image-25-300x159.png 300w&quot; sizes=&quot;(max-width: 539px) 100vw, 539px&quot;/&gt;&lt;/figure&gt;



&lt;h1&gt;不同用户端的区分&lt;/h1&gt;



&lt;p&gt;上面的架构还是不错的，但是现实肯定不会这么简单，我们上面的架构中有一个点赞的信息就直接发送给了所有的用户端，事实上我们不同的用户可能在同时观看不同的直播，显然我们不应该把不同的直播点赞混淆，因此我们就需要一个机制来区分不同的直播。&lt;/p&gt;



&lt;p&gt;方法也很简单，就是当用户端建立连接的时候，告诉一下server你正在看的直播内容，这样有了一个mapping的关系，在我们发送点赞信息的时候就可以根据这个mapping的值找到应该发送的用户端，如下图所示：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-27.png&quot; alt=&quot;&quot; class=&quot;wp-image-1154&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-27.png 589w, https://donggeitnote.com/wp-content/uploads/2021/11/image-27-300x163.png 300w&quot; sizes=&quot;(max-width: 589px) 100vw, 589px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;这里当cid3看红色直播的时候会做一个subscribe，然后在server端把这个信息保存到一个mapping的表中，它会记录cid3在看红色直播。同样的也会记录绿色直播是cid5在看。这样一来随着时间的推移系统就会如下所示，当有一个点赞的消息过来了，我们假设是一个绿色直播的点赞，在supervisor这边就可以查询mapping的表格，从而知道需要把这个点赞的内容发送到cid1，cid2和cid5。这样就解决了不同用户端的区分问题。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-26.png&quot; alt=&quot;&quot; class=&quot;wp-image-1153&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-26.png 495w, https://donggeitnote.com/wp-content/uploads/2021/11/image-26-300x168.png 300w&quot; sizes=&quot;(max-width: 495px) 100vw, 495px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;在结束这一段之前，一个有趣的问题就是我们这个mapping的表是否需要persisted，还是说放在in-memory中就可以了，答案是in-memory就可以了，为什么呢？persisted的一个重要的目的就是说当server crash的时候我们还能够恢复，而这里假如我们的server crash了，其实它和用户端端的连接也就断了，你即使恢复了这个mapping的表也没有用，也还是没法发送消息给相应的用户端。这也就是为什么我们使用in-memory的mapping的原因。&lt;/p&gt;



&lt;h1&gt;多客户端的处理&lt;/h1&gt;



&lt;p&gt;有了上面的架构之后，基本的功能就实现了，但是问题也很明显，假如这个时候我们有很多的客户端，比如说一万个用户或者几十几百万个用户同时连接server，显然单个server是没有办法handle这么多链接的。这个时候怎么进行处理呢？思想其实很简单，就是使用更多的server来支持更多的客户端连接，我们这里先把这个server称之为frontend的server。我们把原本的dispatch放到另外的server中，这样整个架构就分成了下面这样的层级架构：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-28.png&quot; alt=&quot;&quot; class=&quot;wp-image-1155&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-28.png 443w, https://donggeitnote.com/wp-content/uploads/2021/11/image-28-300x186.png 300w&quot; sizes=&quot;(max-width: 443px) 100vw, 443px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;每个Frontend的server服务于一定数量的客户端，然后dispatcher只要负责向frontend发送相关的消息（点赞信息）即可，在frontend收到对应的消息之后，它会根据in-memory的mapping table来决定需要把消息发送给哪一个客户端，从而完成最终的消息传递。这个架构可以很好的服务几百万级别的用户端。&lt;/p&gt;



&lt;p&gt;现在还有一个问题需要解决，就是dispatcher是如何知道该把消息发送给哪个frontend，而不是说所有的frontend都发送呢？这个问题的解决方法和上面的不同用户端是类似的，假如我们能够让frontend也向dispatcher subscribe一下它感兴趣的直播视频，那么我们就可以只把相关的消息发送给他就可以了。所以需要在dispatcher端维护一个类似的mapping表，只是这次值不是client端id而是frontend的id而已。&lt;/p&gt;



&lt;p&gt;如下所示，和之前的client端到frontend的subscribe类似，在dispatcher中也维护了一个表格。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-29.png&quot; alt=&quot;&quot; class=&quot;wp-image-1156&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-29.png 580w, https://donggeitnote.com/wp-content/uploads/2021/11/image-29-300x161.png 300w&quot; sizes=&quot;(max-width: 580px) 100vw, 580px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;所以当点赞的消息到了dispatcher之后，它就可以把这个消息根据mapping表格的内容发送到对应的frontend端，如下所示：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-30.png&quot; alt=&quot;&quot; class=&quot;wp-image-1157&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-30.png 524w, https://donggeitnote.com/wp-content/uploads/2021/11/image-30-300x161.png 300w&quot; sizes=&quot;(max-width: 524px) 100vw, 524px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;然后各个frontend再根据in-memory的table把消息发送最终的客户端。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-31.png&quot; alt=&quot;&quot; class=&quot;wp-image-1158&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-31.png 537w, https://donggeitnote.com/wp-content/uploads/2021/11/image-31-300x215.png 300w&quot; sizes=&quot;(max-width: 537px) 100vw, 537px&quot;/&gt;&lt;/figure&gt;



&lt;h1&gt;多点赞的处理&lt;/h1&gt;



&lt;p&gt;这个时候我们解决了很多客户端的问题，但是假如我们同时有很多人在点赞，比如每秒有一万个人来点赞，上面提到的架构还需要改进吗？很显然，这个时候一个dispatcher可能会撑不住，解决的方法也很简单，就是增加dispatcher的机器，这样我们的架构就可以变成下面这样了：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-32.png&quot; alt=&quot;&quot; class=&quot;wp-image-1159&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-32.png 372w, https://donggeitnote.com/wp-content/uploads/2021/11/image-32-300x297.png 300w, https://donggeitnote.com/wp-content/uploads/2021/11/image-32-80x80.png 80w&quot; sizes=&quot;(max-width: 372px) 100vw, 372px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;多个dispatcher可以分别处理不同的点赞消息从而达到scale的目的。&lt;/p&gt;



&lt;p&gt;这个时候我们再回头来看看我们dispatcher中的mapping的表格是否需要persist还是说也像frontend那样放到in-memory中就可以了。这里显然还是存到一个key value的表中会比较好。原因也很简单，假如这里一个dispatcher出问题了，我们仍然希望别的dispatcher能够take它的职责，而不是就忽略它所对应的那些frontend server（和frontend那边不同的是，这里不是长连接，所以完全可以用不同的dispatcher来处理和frontend之间的通信）。这样一来整个架构就变成了下面这样。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-33.png&quot; alt=&quot;&quot; class=&quot;wp-image-1160&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-33.png 533w, https://donggeitnote.com/wp-content/uploads/2021/11/image-33-300x153.png 300w&quot; sizes=&quot;(max-width: 533px) 100vw, 533px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;所以这个时候整个流程就变成了，点赞信息发送到某个dispatcher，然后dispatcher会到key-value store去看哪些frontend对这个直播感兴趣，从而把相关的点赞信息发送到相关的frontend，frontend收到对应信息之后，再根据它的in-memory的表格决定最终发送到哪一个用户端。从而完成这个发送的流程。&lt;/p&gt;



&lt;h1&gt;多数据中心&lt;/h1&gt;



&lt;p&gt;目前来看整个架构运行得都很好，然后LinkedIn发现了一个新的问题，就是如何进行跨数据中心的处理，也就是说假如一个点赞的消息发生在一个数据中心，如何把这个消息dispatch到不同的数据中心，如下所示：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-34.png&quot; alt=&quot;&quot; class=&quot;wp-image-1161&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-34.png 542w, https://donggeitnote.com/wp-content/uploads/2021/11/image-34-300x193.png 300w&quot; sizes=&quot;(max-width: 542px) 100vw, 542px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;假设有三个数据中，然后在DC1有人对红色直播进行了点赞，我们如何把这个点赞消息发送的别的数据中心。这里其实有两种处理的方法：&lt;/p&gt;



&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;第一种就是subscribe的时候跨数据中心，这样每个数据中心的key-value store中都有别的数据中心的frontend的信息。&lt;/li&gt;&lt;li&gt;第二种就是subscribe还是单数据中心，但是dispatcher则进行跨数据中心的分发，然后让每个数据中心自己根据它本身的key-value store来决定是否需要进行分发。&lt;/li&gt;&lt;/ol&gt;



&lt;p&gt;LinkedIn选用了第二种方法来进行处理，如下图所示：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-35.png&quot; alt=&quot;&quot; class=&quot;wp-image-1162&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-35.png 566w, https://donggeitnote.com/wp-content/uploads/2021/11/image-35-300x185.png 300w&quot; sizes=&quot;(max-width: 566px) 100vw, 566px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;当第一个dispatcher收到信息的时候，它会把这个消息分发给所有的不同的数据中的dispatcher，然后各个dispatcher就可以按照之前的做法来做了。&lt;/p&gt;



&lt;h1&gt;性能数据&lt;/h1&gt;



&lt;p&gt;在有了上面的架构之后，我们来看看这样的架构可以支撑什么样QPS的场景，或者准确地说这样一套架构支撑一个1000万的同时在线的用户，并且每秒有5万用户点赞需要多少台机器。&lt;/p&gt;



&lt;p&gt;首先我们看第一个部分，就是每个frontend的server来同时支持多少客户端，LinkedIn测试的结果是可以支持&amp;gt;100,000客户端。也就是假如同时有1000万用户同时在线，需要100台frontend的机器就可以了。&lt;/p&gt;



&lt;p&gt;下面我们来看第二个部分，也就是一个dispatcher每秒能接收多少events，这个会决定我们假如我们有很多人同时点赞，需要多少dispatcher的机器才能够撑住，LinkedIn测试的结果是5K，也就是说假如每秒有5万用户点赞，我们只需要10台dispatcher的机器就可以撑住了。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-36.png&quot; alt=&quot;&quot; class=&quot;wp-image-1163&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-36.png 462w, https://donggeitnote.com/wp-content/uploads/2021/11/image-36-300x168.png 300w&quot; sizes=&quot;(max-width: 462px) 100vw, 462px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;最后我们来看看这个系统中，点赞到最终发送到用户端的延时是怎样的呢？这里测试的数据时间点t1是后端向dispatcher发送点赞的时间点，t2是frontend开始向客户端发送的时间点。这两个时间点之间的延时P90是75ms，还是很快的，当然另外两端和客户端的交互就收到很多不确定的因素影响了，不计入考虑也是可以理解的。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-37.png&quot; alt=&quot;&quot; class=&quot;wp-image-1164&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/11/image-37.png 544w, https://donggeitnote.com/wp-content/uploads/2021/11/image-37-300x137.png 300w&quot; sizes=&quot;(max-width: 544px) 100vw, 544px&quot;/&gt;&lt;/figure&gt;



&lt;h1&gt;总结&lt;/h1&gt;



&lt;p&gt;至此我们就把LinkedIn的这套点赞系统总结完毕了，它其实也可以应用任何直播中的数据交互系统，比如留言等等。大家感兴趣也可以参考原会议的视频： &lt;a href=&quot;https://www.infoq.com/presentations/linkedin-play-akka-distributed-systems/&quot;&gt;https://www.infoq.com/presentations/linkedin-play-akka-distributed-systems/&lt;/a&gt;。&lt;/p&gt;&lt;p class=&quot;post-views post-1146 entry-meta&quot;&gt;&amp;#13;
&lt;span class=&quot;post-views-icon dashicons dashicons-chart-bar&quot;/&gt;&amp;#13;
&lt;span class=&quot;post-views-label&quot;&gt;Post Views:&lt;/span&gt;&amp;#13;
&lt;span class=&quot;post-views-count&quot;&gt;167&lt;/span&gt;&amp;#13;
&lt;/p&gt;          &lt;nav class=&quot;pagination group&quot;&gt;
                      &lt;/nav&gt;
        &lt;/div&gt;

        
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>