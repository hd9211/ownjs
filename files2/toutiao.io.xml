<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>533848e8ec93fc54fb48eae8392ae4f9</guid>
<title>如何获取优质信息？推荐一种高手都在用的方式！</title>
<link>https://toutiao.io/k/5wlqiik</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavib3NlJt37DBSrTmLaGd7y82j0SCAaW8XmlHAt33xPM7x3iaib7e2IWPWRXJuoYJczl3ibCpPpQSyH2rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;你是通过什么方式&lt;/span&gt;&lt;span&gt;&lt;strong&gt;获取优质信息&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;呢？&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;公众号？博客？播客？短视频？微博？图书？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;今天推荐一种&lt;/span&gt;&lt;span&gt;&lt;strong&gt;高手都在用&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的「优质信息获取」方式！&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Newsletter&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavib3NlJt37DBSrTmLaGd7y82icbyrtFQ5edhQTZA13mpdrBmbianfFq2ib4Jiar4GBhSN4ppvVY1RrTgPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Newsletter中文可翻译成新闻信或电子报，是一个&lt;/span&gt;&lt;span&gt;&lt;strong&gt;基于电子邮件的信息分发&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;产品。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Newsletter多用于组织机构向客户推送相关新闻信息，一般机构网站首页上会有邮件订阅的链接。&lt;br/&gt;对于个人，Newsletter作为信息发布产品，有免中介、一对多自动分发的特点，开始&lt;/span&gt;&lt;span&gt;&lt;strong&gt;受到一些高手的青睐&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。比如一些知名记者开始逃离Facebook、Twitter等社交平台，面向用户推出付费Newsletter订阅服务。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavib3NlJt37DBSrTmLaGd7y82DrAxiaNsRbvwj4Zia3EfVibO9icDGEw4sXicqGia1qajnleLEU7q74qIa16w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份&lt;/span&gt;&lt;strong&gt;&lt;span&gt;专为广大程序员、编程爱好者们打造&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的IT技术周刊。每周发送。&lt;br/&gt;2013年9月12日创刊至今，已发送300多期，订阅用户超20万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;专业、简单、有用&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;2020年4月，为了给用户提供更优质的服务，我们面向码农周刊VIP会员推出了&lt;/span&gt;&lt;strong&gt;&lt;span&gt;Newsletter服务&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。目前已发送87期。&lt;br/&gt;以下内容节选自&lt;/span&gt;&lt;span&gt;&lt;strong&gt;码农周刊VIP会员专属Newsletter&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，供参考。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊VIP会员福利&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavib3NlJt37DBSrTmLaGd7y822mOhDWWbtShmv7DouHMmYgZx9sxtfRibCpF3MNjADgYSfNgPDl4p0Og/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 52 期码农周刊VIP会员专属&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Newsletter&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，让你及时掌握技术动向；&lt;br/&gt;2. 只限VIP会员加入的&lt;/span&gt;&lt;span&gt;&lt;strong&gt;交流圈子&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，让你与技术大牛切磋学习；&lt;br/&gt;3. VIP会员独享的&lt;/span&gt;&lt;span&gt;&lt;strong&gt;工作机会&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，为你介绍好公司的好机会；&lt;br/&gt;4. 更多会员福利，持续更新……&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何订阅「码农周刊VIP会员专属Newsletter」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. &lt;/span&gt;&lt;span&gt;&lt;strong&gt;微信扫描下方二维码&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，加入码农周刊VIP会员知识星球。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicibroqCN98y5SNT9NbfA3oHYQiaicFScHFfppgek7ZGicJiaHK45qc2zoccBibfEzIvzTsI4AB2xO2IaOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请&lt;/span&gt;&lt;span&gt;&lt;strong&gt;留意知识星球内的私信&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如行动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cdcc8aed2b1082a152db49ad76579c07</guid>
<title>[推荐] 系统架构的11条原则</title>
<link>https://toutiao.io/k/xbwjqgj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;基本原则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则一：价值为王&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解析：&lt;/p&gt;&lt;p&gt;价值为王的另一种说法叫做YAGNI。YAGNI 是 You aren’t gonna need it 的缩写。该原则的基本含义就是，不应该开发任何当前不使用的功能。因为这些占用开发成本的功能，可能根本没有人用。而且不仅仅是开发成本打了水漂，你还要不断投入维护成本，来保证这些无人使用的功能可以正常运行。&lt;/p&gt;&lt;p&gt;要了解阿姆达尔定律，它告诉我们，我们不可能无限制的提升系统某一部分的效率。要提升的总体效果有没有产生相应的价值。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则二：以终为始&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解析：&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484524&amp;amp;idx=1&amp;amp;sn=471a7ea978dece958c3b0285435551fe&amp;amp;chksm=fafdeec2cd8a67d43af8ef1a346b2f2b012eb738b44d0755e3b6d5a49f2ccede10fae94efe72&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;以终为始&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;以终为始&lt;/strong&gt;&lt;/a&gt;是一种思维模式，最早出自《黄帝内经》，先人是在告诫后人要在人生的春天就认真思考人生终点的意义和价值。其引申义有三：一是凡事要有目标；二是凡事要有计划；三是凡事要有原则。正所谓“凡事预则立，不预则废”。&lt;/p&gt;&lt;p&gt;白话来说，以终为始，就是在做事之前，先想想结果是什么样子的，这个结果是否能达到最初的目标。小心X-Y问题：为了解决 X问题，觉得用 Y 可以解，于是研究 Y 问题，结果搞到最后，发现原来要解决的 X 问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则三：分治原则&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解析：&lt;/p&gt;&lt;p&gt;做架构时不要想着一次性把所有的功能都做好，要拥抱 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485060&amp;amp;idx=1&amp;amp;sn=02720887a28154ede413f85fa0af29f6&amp;amp;chksm=fafdec2acd8a653cbbbc8995eb9dd17053288aaa1509a2fc5f74d1ccc7f33d9d307ca76dbe7f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;MVP&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;MVP&lt;/strong&gt;&lt;/a&gt;（Minimal Viable Product），最小可运行版本。先让程序完成最基本功能上线，根据反馈调整和决定下一步的迭代。&lt;/p&gt;&lt;p&gt;迭代着去做事情，敏捷开发的思路。对于每个功能点，创建里程碑，然后去迭代。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则四：服务自治&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解析：&lt;/p&gt;&lt;p&gt;在系统设计时，要考虑服务上线后，对于问题要自感知、自修复、自优化、自运维及自安全。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则五：拥抱变化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解析：&lt;/p&gt;&lt;h1&gt;&lt;span&gt;重视架构扩展性和可运维性。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484368&amp;amp;idx=1&amp;amp;sn=b3c8d41b98ecf2b976d0b025c0322055&amp;amp;chksm=fafde97ecd8a6068cc4d25f2766261870a67baa4cbf9dc0d4920302fcf09e74ee682025efabc&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;无状态的系统&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;无状态的系统&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的是可扩展的和直接的。任何时候都要考虑这一点，不要搞个不可扩展的，有状态的东东出来。否则，一旦需要改变，成本很高。&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则六：简单即正义&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解析：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485195&amp;amp;idx=1&amp;amp;sn=9aa72718cdcc24d872f0a89cf63ea34f&amp;amp;chksm=fafdeda5cd8a64b3a55f4de3fdc48d2ee396074d851f686b70a7e679dbcf26862348a79182eb&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;简单即正义&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;简单即正义&lt;/strong&gt;&lt;/a&gt;的另一种说法叫做KISS。KISS(Keep it simple,sutpid)保持每件事情都尽可能的简单。用最简单的解决方案来解决问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则七：尽量自动化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解析：&lt;/p&gt;&lt;p&gt;人力成本既慢又贵，还有经常不断的人工失误。如果不能降低人力成本，反而需要更多的人，那么这个架构设计一定是失败的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;稳定性原则&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则八：依赖最简&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解释：&lt;/p&gt;&lt;p&gt;依赖原则是&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484076&amp;amp;idx=1&amp;amp;sn=0c2b291a31ed53e9c8af06d131aabdd4&amp;amp;chksm=fafde802cd8a6114430a5c1eb8609481059341089ba2c4113012764578152570b6149780e3d5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;去除依赖、弱化依赖、控制依赖&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;&lt;span&gt;去除依赖、弱化依赖、控制依赖&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;。多一个依赖多一分风险。能不依赖则不依赖，能异步弱依赖不要同步强依赖。实在不能弱依赖的，比如必须要调用加密存储来获取数据库的密码，不然无法连接数据库，可以控制获取密码在服务启动时进行，如果获取不到则服务启动失败，因为现在都是集群部署，一台无法启动不影响整体提供服务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;原则九：不作不死&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解释：&lt;/p&gt;&lt;p&gt;尽可能的做较少的功能。当有疑问的时候，就不要去做，甚至干掉。很多功能从来不会被使用。最多留个扩展点就够了。&lt;/p&gt;&lt;p&gt;等到有人提出再说（除非是影响核心流程，否则就等到需要的时候再去做）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则十：容灾容错&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解析：&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485188&amp;amp;idx=1&amp;amp;sn=3618568ba3bf9c396195d8e2c4e6723d&amp;amp;chksm=fafdedaacd8a64bca74024452fb88a56ff99aa6bcd9ae841fca1b91cbff40d4dd78698b09dcc&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Everything fails! &quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;&lt;span&gt;Everything fails!&lt;/span&gt; &lt;/strong&gt;&lt;/a&gt;人都是要死的，机器都是要坏的。&lt;span&gt;如果一件事情有可能发生则在生产环境中一定会发生，架构中要做好容错设计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则十一：用成熟的技术&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解析：&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484324&amp;amp;idx=1&amp;amp;sn=78986320566babe59cc2c0da81c7f5b6&amp;amp;chksm=fafde90acd8a601ceff0bb501a0c1f6cd10b5408d3e4fed43d9e6c8605f800297abead8abdf5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;不要给别人的技术当小白鼠&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;不要给别人的技术当小白鼠&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;，不要因技术本身的问题影响系统的稳定。尽可能的使用红利大的主流技术，而不要自己发明轮子，更不要魔改。在技术选型上，千万不要被——“你看某个公司也在用这个技术”，或是一些在论坛上看到的一些程序员吐槽技术的观点（没有任何的数据，只有自己的喜好）来决定自己的技术，还是看看主流大多数公司实际在用的技术栈，会更靠谱一些。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一张图总结今天的内容：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.939443535188216&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRliccwBMXSp9icdrUcDBcn7aU7asr1qCfg79N67CR0uKsu5FONagZrGE0x2WgiaMVChYcPYMvSYGqzjtw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;611&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;&lt;span&gt;编程一生&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;因&lt;/span&gt;&lt;span&gt;为公众号平台更改了推送规则，如果不想错过内容，记得读完点一下“在看”，加个“星标”，这样每次新文章推送才会第一时间出现在你的订阅列表里。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486113&amp;amp;idx=1&amp;amp;sn=f3623b2cf257aa37ea83768fd4325762&amp;amp;chksm=fafde00fcd8a691928c66f7e484ab2b7f6fa7797dc32833a7f777bb4ebde58c010750f13c118&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;PDCA方法论&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;strong&gt;PDCA方法论&lt;/strong&gt;&lt;/a&gt;&lt;span&gt;，检查自己是否错过更新：&lt;/span&gt;&lt;span&gt;每周三晚上8点左右，我都会更新文章，如果你没有收到，记得点开【编程一生】公众号找一下(*^▽^*)&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>11c6e6c13d666cd49ad9099863374dfd</guid>
<title>[推荐] 腾讯一面：CORS为什么能保障安全？为什么只对复杂请求做预检？</title>
<link>https://toutiao.io/k/quomj0f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是Peter！提起CORS，大部分的文章都在写什么是简单请求、什么是复杂请求，复杂请求预检的流程又是怎样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果问你：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;CORS为什么要带上源，这是为了保障当前站点的安全还是目的服务器的安全？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么区分简单请求和复杂请求，只对复杂请求做预检？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章会围绕CORS是如何保障安全的的，讲清这几个问题。读完可以对CORS知其然，并知其所以然。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是CORS&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信每个前端的控制台都中都被打印过这样一段话，告诉你：你的跨域请求策略拦截啦！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39217252396166136&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cpWiaicnZTauaRgdAib2PSGgqBMLjZq5Wewsk7T8blKNh4EFIwETFEicuzZqsfSoqgicVb7cA65kIrYhFlibLP1NMGiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1252&quot;/&gt;首先要明确的一点，CORS的目的不是拦截请求，反倒是为了让其能正常请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CORS诞生的背景是「同源策略」。这是一个相当严苛的规定，它禁止了跨域的AJAX请求。但实际的开发中又有这样的需求，于是开一个口子——只要配置了CORS的对应规则，跨域请求就能正常进行。这也正和CORS的名字对应起来了——「跨域资源共享」，就是为了能让跨域请求在「同源策略」的大背景下进行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到上面提到控制台报错，这不是阻止你做跨域请求，而是提示你：因为没有按照CORS要求做配置，不得不暂时拦截。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;怎样配置CORS&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文讲清了，只要按照CORS要求做配置，就能突破同源策略的限制，下面将会讲述如何配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这部分不需要前端操心，完全后端来做：在响应头里面加一个字段&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;（允许请求的来源），这个值要把前端的源包含进去。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;举个例子：请求的后端接口是&lt;code&gt;http://fe_nian&lt;/code&gt;，你本地正在开发前端工程跑在8080端口。那么后端会在响应头里加上&lt;code&gt;Access-Control-Allow-Origin:*&lt;/code&gt;来允许&lt;code&gt;http://localhost:8080&lt;/code&gt;这个源去做跨域请求，因为&lt;code&gt;*&lt;/code&gt;是所有的意思。&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;跨域请求的流程&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CORS把请求分成简单请求和复杂请求，划分的依据是“是否会产生副作用”。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;简单贴一下定义，同时满足下面这两个条件的是简单请求&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;请求方法是HEAD/GET/POST&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;请求体的文件类型只能是form-urlencoded、form-data、text/plain（这类文章很多，不再赘述，可以看阮一峰-跨域资源共享）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于简单请求，流程如下：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46904315196998125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cpWiaicnZTauaRgdAib2PSGgqBMLjZq5WewdCaZAPVHWUm0oQw0JsicnMqzSksOHNC3l2KnwicU1SdIkXfBvbRaI2fA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1066&quot;/&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;浏览器发起请求，并且自动加上请求的来源&lt;code&gt;origin&lt;/code&gt;给服务器检查；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务器返回数据，并返回检查结果，配置CORS响应头；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;浏览器检查CORS响应头，如果包含了当前的源则放行，反之拦截；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里需要注意，浏览器是拦截响应，而不是拦截请求，跨域请求是发出去的，并且服务端做了响应，只是浏览器拦截了下来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于复杂请求，整个流程如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6577060931899642&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cpWiaicnZTauaRgdAib2PSGgqBMLjZq5Wew6fdpavWLd0xyAWkGicYNVby3nezXQ0v5GQxdgewJnRFeibZRrR82ynQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1116&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;浏览器发起预检请求，带上请求的来源&lt;code&gt;origin&lt;/code&gt;，不包含请求体；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务器返回检查结果，配置CORS头；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;浏览器发起真正请求；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;浏览器返回数据；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;浏览器会检查第2步中拿到的CORS头，如果没有包含当前的源，后续的第3、4步都不会进行，也就是不会发起真正请求。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么要带上源&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CORS给开发带来了便利，同时也带来了安全隐患——CSRF攻击。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的基本流程如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7623762376237624&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cpWiaicnZTauaRgdAib2PSGgqBMLjZq5WewpicDVS1cMTQiclT0BCA4w7UFS0piaPsMpYtJz4q7UKYdkXGDmDcvPYN8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1212&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;用户登录受害网站，把获取的身份凭证保存在浏览器的cookie中。也就是上图流程的①②③；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户用同一浏览器打开黑客网站，黑客网站向受害网站服务器发起一个恶意请求，这时浏览器会自动从cookie中取出身份凭证，把它带上。也就是上图的④⑤；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;受害网站服务端发现有身份凭证，恶意请求被成功受理；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果严格按照同源政策，第2步的跨域请求不能进行的，也就不会造成危害。所以CORS策略的心智模型是：所有跨域请求都是不安全的，浏览器要带上来源给服务器检验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果做过服务端开发，应该知道，服务端不存在跨域一说，去获取另一个服务器的资源是再顺畅不过的事情。因为服务端不像浏览器一样，作为“容器”存贮着用户身份凭证——也就是上面的第1步发生的事情，它去做跨域请求没有这样的风险。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么只对复杂请求做预检&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文提到，划分简单请求和复杂请求的依据是“是否产生副作用”。这里的副作用指对数据库做出修改：使用GET请求获取新闻列表，数据库中的记录不会做出改变，而使用PUT请求去修改一条记录，数据库中的记录就发生了改变。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于简单请求，浏览器只会在请求头加上一个&lt;code&gt;origin&lt;/code&gt;字段标识请求来源；对于非简单请求，浏览器会先发出一个预检请求，获得肯定回答后才会发送真正的请求，下面会讲清楚为什么这么做。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以假设网站被CSRF攻击了——黑客网站向银行的服务器发起跨域请求，并且这个银行的安全意识很弱，只要有登录凭证cookie就可以成功响应：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;黑客网站发起一个GET请求，目的是查看受害用户本月的账单。银行的服务器会返回正确的数据，不过影响并不大，而且由于浏览器的拦截，最后黑客也没有拿到这份数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;黑客网站发起一个PUT请求，目的是把受害用户的账户余额清零。浏览器会首先做一次预检，发现收到的响应并没有带上CORS响应头，于是真正的PUT请求不会发出；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幸好有预检机制，否则PUT请求一旦发出，黑客的攻击就成功了。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;结语&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到开头的两个问题，不难得出答案：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;对于跨域请求带上请求来源，是为了防止CSRF攻击；浏览器的心智模型是：跨域请求都是不安全的，CORS的机制是为了保障请求目的服务器的安全；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;依据是否对服务器有副作用，划分了简单请求和复杂请求（但由于历史原因，表单POST请求也被划分成了简单请求），预检机制会把不安全的复杂请求拦截下来，避免对服务器造成危害，而简单请求通常不会对服务器的资源作出修改，即使发出危害不大。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这篇文章对你有帮助，给我点个赞呗，这是我创作的动力～&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODIwMDY2OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/sz_mmbiz_png/3GPT1CHiaSVssAs3fYdfweBskcYpVTrKpyGRwvSia0MOULHpGU8497uAkHic3CSPvqbr1BGQY45zoj0rvLexzLVVA/0?wx_fmt=png&quot; data-nickname=&quot;前端巅峰&quot; data-alias=&quot;Java-Script-&quot; data-signature=&quot;不止前端&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点个在看更好！&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1bc37ffb67c1bf6b41cc4755432c4ed7</guid>
<title>[推荐] 解析分布式系统的缓存设计</title>
<link>https://toutiao.io/k/pucrtli</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;25&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;作者：vivo互联网服务器团队-Zhang Peng&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、缓存简介&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.1 什么是缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存就是数据交换的缓冲区。缓存的本质是一个内存 Hash。缓存是一种利用空间换时间的设计，其目标就是更快、更近：极大的提高。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;将数据写入/读取速度更快的存储（设备）；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将数据缓存到离应用最近的位置；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将数据缓存到离用户最近的位置。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;缓存是用于存储数据的硬件或软件的组成部分，以使得后续更快访问相应的数据。缓存中的数据可能是提前计算好的结果、数据的副本等。典型的应用场景：有 cpu cache, 磁盘 cache 等。本文中提及到缓存主要是指互联网应用中所使用的缓存组件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;缓存命中率是缓存的重要度量指标，命中率越高越好。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;24&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;缓存命中率 = 从缓存中读取次数 / 总读取次数&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.2 何时需要缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;引入缓存，会增加系统的复杂度。所以，引入缓存前，需要先权衡是否值得，考量点如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在数据层引入缓存，有以下几个好处：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.3 缓存的基本原理&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;根据业务场景，通常缓存有以下几种使用方式：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;懒汉式(读时触发)：先查询 DB 里的数据, 然后把相关的数据写入 Cache。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;饥饿式(写时触发)：写入 DB 后, 然后把相关的数据也写入 Cache。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;定期刷新：适合周期性的跑数据的任务，或者列表型的数据，而且不要求绝对实时性。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.4 缓存淘汰策略&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存淘汰的类型：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1）基于空间&lt;/strong&gt;：设置缓存空间大小。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）基于容量&lt;/strong&gt;：设置缓存存储记录数。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3）基于时间&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;缓存淘汰算法：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1）FIFO：先进先出&lt;/strong&gt;。在这种淘汰算法中，先进入缓存的会先被淘汰。这种可谓是最简单的了，但是会导致我们命中率很低。试想一下我们如果有个访问频率很高的数据是所有数据第一个访问的，而那些不是很高的是后面再访问的，那这样就会把我们的首个数据但是他的访问频率很高给挤出。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）LRU：最近最少使用算法&lt;/strong&gt;。在这种算法中避免了上面的问题，每次访问数据都会将其放在我们的队尾，如果需要淘汰数据，就只需要淘汰队首即可。但是这个依然有个问题，如果有个数据在 1 个小时的前 59 分钟访问了 1 万次(可见这是个热点数据),再后一分钟没有访问这个数据，但是有其他的数据访问，就导致了我们这个热点数据被淘汰。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3）LFU：最近最少频率使用&lt;/strong&gt;。在这种算法中又对上面进行了优化，利用额外的空间记录每个数据的使用频率，然后选出频率最低进行淘汰。这样就避免了 LRU 不能处理时间段的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这三种缓存淘汰算法，实现复杂度一个比一个高，同样的命中率也是一个比一个好。而我们一般来说选择的方案居中即可，即实现成本不是太高，而命中率也还行的 LRU。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、缓存的分类&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存从部署角度，可以分为客户端缓存和服务端缓存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;客户端缓存&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;HTTP 缓存&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;浏览器缓存&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;APP 缓存（1、&lt;span&gt;Android  2、&lt;/span&gt;&lt;span&gt;IOS）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;服务端缓存&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;CDN 缓存：存放 HTML、CSS、JS 等静态资源。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;反向代理缓存：动静分离，只缓存用户请求的静态资源。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据库缓存：数据库（如 MySQL）自身一般也有缓存，但因为命中率和更新频率问题，不推荐使用。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;进程内缓存：缓存应用字典等常用数据。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;分布式缓存：缓存数据库中的热点数据。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其中，CDN 缓存、反向代理缓存、数据库缓存一般由专职人员维护（运维、DBA）。&lt;span&gt;后端开发一般聚焦于进程内缓存、分布式缓存。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.1 HTTP 缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.2 CDN 缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;CDN 将数据缓存到离用户物理距离最近的服务器，使得用户可以就近获取请求内容。CDN 一般缓存静态资源文件（页面，脚本，图片，视频，文件等）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;国内网络异常复杂，跨运营商的网络访问会很慢。为了解决跨运营商或各地用户访问问题，可以在重要的城市，部署 CDN 应用。使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;321&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtyib8hzr838nIZicibTqibaqzR6WloDHz8S5o3bG5f06v6F97dv8f3wwghvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图片引用自：&lt;/span&gt;&lt;a href=&quot;https://www.creative-artworks.eu/why-use-a-content-delivery-network-cdn/&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Why use a CDN&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.1.1 CDN 原理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;CDN 的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1）未部署 CDN 应用前的网络路径：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在不考虑复杂网络的情况下，从请求到响应需要经过 3 个节点，6 个步骤完成一次用户访问操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2）部署 CDN 应用后网络路径：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;请求&lt;/strong&gt;：本机网络（局域网） =&amp;gt; 运营商网络&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;响应&lt;/strong&gt;：运营商网络 =&amp;gt; 本机网络（局域网）&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在不考虑复杂网络的情况下，从请求到响应需要经过 2 个节点，2 个步骤完成一次用户访问操作。与不部署 CDN 服务相比，减少了 1 个节点，4 个步骤的访问。极大的提高了系统的响应速度。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.1.2 CDN 特点&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;本地 Cache 加速&lt;/strong&gt;：提升访问速度，尤其含有大量图片和静态页面站点；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;实现跨运营商的网络加速&lt;/strong&gt;：消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;远程加速&lt;/strong&gt;：远程访问用户根据 DNS 负载均衡技术智能自动选择 Cache 服务器，选择最快的 Cache 服务器，加快远程访问的速度；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;带宽优化&lt;/strong&gt;：自动生成服务器的远程 Mirror（镜像）cache 服务器，远程用户访问时从 cache 服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点 WEB 服务器负载等功能。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;集群抗攻击&lt;/strong&gt;：广泛分布的 CDN 节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种 D.D.o.S 攻击对网站的影响，同时保证较好的服务质量。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;31&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;解决方案：主要缓存静态资源，动态资源建立多级缓存或准实时同步；&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;67&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;1.解决方案（主要是在性能和数据一致性二者间寻找一个平衡）。&lt;/p&gt;&lt;p&gt;2.设置缓存失效时间（1 个小时，过期后同步数据）。&lt;/p&gt;&lt;p&gt;3.针对资源设置版本号。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.2 反向代理缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;340&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5885558583106267&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtykNRn1bK3lEibicbVgYibCHgxSYn62bxI0h7kulr8D0PxXibbfkAagbEic7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1101&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.2.1 反向代理缓存原理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;反向代理位于应用服务器同一网络，处理所有对 WEB 服务器的请求。反向代理缓存的原理：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这种方式通过降低向 WEB 服务器的请求数，从而降低了 WEB 服务器的负载。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;反向代理缓存一般针对的是静态资源，而将动态资源请求转发到应用服务器处理。常用的缓存应用服务器有 Varnish，Ngnix，Squid。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.2.2 反向代理缓存比较&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;常用的代理缓存有 Varnish，Squid，Ngnix，简单比较如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Varnish 和 Squid 是专业的 cache 服务，Ngnix 需要第三方模块支持；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Varnish 采用内存型缓存，避免了频繁在内存、磁盘中交换文件，性能比 Squid 高；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Varnish 由于是内存 cache，所以对小文件如 css、js、小图片的支持很棒，后端的持久化缓存可以采用的是 Squid 或 ATS；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Squid 功能全而大，适合于各种静态的文件缓存，一般会在前端挂一个 HAProxy 或 Ngnix 做负载均衡跑多个实例；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Nginx 采用第三方模块 ncache 做的缓冲，性能基本达到 Varnish，一般作为反向代理使用，可以实现简单的缓存。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、进程内缓存&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;进程内缓存是指应用内部的缓存，标准的分布式系统，一般有多级缓存构成。本地缓存是离应用最近的缓存，一般可以将数据缓存到硬盘或内存。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;常见的本地缓存实现方案：HashMap、Guava Cache、Caffeine、Ehcache。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;3.1 ConcurrentHashMap&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;最简单的进程内缓存可以通过 JDK 自带的 HashMap 或 ConcurrentHashMap 实现。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;适用场景：不需要淘汰的缓存数据。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缺点：无法进行缓存淘汰，内存会无限制的增长。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.2 LRUHashMap&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;可以通过继承 LinkedHashMap 来实现一个简单的 LRUHashMap。重写 removeEldestEntry 方法，即可完成一个简单的最近最少使用算法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;锁竞争严重，性能比较低。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不支持过期时间。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;不支持自动刷新。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.3  Guava Cache&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;解决了LRUHashMap 中的几个缺点。Guava Cache 采用了类似 ConcurrentHashMap 的思想，分段加锁，减少锁竞争。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Guava Cache 对于过期的 Entry 并没有马上过期(也就是并没有后台线程一直在扫)，而是通过进行读写操作的时候进行过期处理，这样做的好处是避免后台线程扫描的时候进行全局加锁。直接通过查询，判断其是否满足刷新条件，进行刷新。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.4  Caffeine&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Caffeine 实现了 W-TinyLFU(LFU + LRU 算法的变种)，其命中率和读写吞吐量大大优于 Guava Cache。其实现原理较复杂，可以&lt;a target=&quot;_blank&quot; href=&quot;https://juejin.cn/post/6844903660653117447#comment&quot; textvalue=&quot;参考你应该知道的缓存进化史&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;参考你应该知道的缓存进化史&lt;/a&gt;。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.5 Ehcache&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;EhCache 是一个纯 Java 的进程内缓存框架，具有快速、精干等特点，是 Hibernate 中默认的 CacheProvider。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;快速、简单;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;支持多种缓存策略：LRU、LFU、FIFO 淘汰算法；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;缓存数据有两级：内存和磁盘，因此无需担心容量问题；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;缓存数据会在虚拟机重启的过程中写入磁盘；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可以通过 RMI、可插入 API 等方式进行分布式缓存；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;具有缓存和缓存管理器的侦听接口；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;支持多缓存管理器实例，以及一个实例的多个缓存区域；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;提供 Hibernate 的缓存实现。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.6 进程内缓存对比&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;常用进程内缓存技术对比：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;340&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5877502944640753&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFty1y6mRsm9kwvAyrPuwQSoajLA97CwMauXsASQA8LPUZxug5yZ7iawIgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;849&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;总结一下：如果不需要淘汰算法则选择 ConcurrentHashMap，如果需要淘汰算法和一些丰富的 API，推荐选择。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、分布式缓存&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;分布式缓存解决了进程内缓存最大的问题：如果应用是分布式系统，节点之间无法共享彼此的进程内缓存。&lt;span&gt;分布式缓存的应用场景：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;缓存经过复杂计算得到的数据。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;缓存系统中频繁访问的热点数据，减轻数据库压力。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不同分布式缓存的实现原理往往有比较大的差异。本文主要针对 Memcached 和 Redis 进行说明。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.1 Memcached&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Memcached 是一个高性能，分布式内存对象缓存系统，通过在内存里维护一个统一的巨大的 &lt;span&gt;Hash&lt;/span&gt; 表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;简单的说就是：将数据缓存到内存中，然后从内存中读取，从而大大提高读取速度。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;4.1.1 Memcached 特性&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;4.1.2 Memcached 工作原理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;1）内存管理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Memcached 利用 slab allocation 机制来分配和管理内存，它按照预先规定的大小，将分配的内存分割成特定长度的内存块，再把尺寸相同的内存块分成组，数据在存放时，根据键值 大小去匹配 slab 大小，找就近的 slab 存放，所以存在空间浪费现象。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这套内存管理效率很高，而且不会造成内存碎片，但是它最大的缺点就是会导致空间浪费。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）缓存淘汰策略&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Memcached 的缓存淘汰策略是 LRU + 到期失效策略。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当你在 Memcached 内存储数据项时，你有可能会指定它在缓存的失效时间，默认为永久。当 Memcached 服务器用完分配的内时，失效的数据被首先替换，然后是最近未使用的数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在 LRU 中，Memcached 使用的是一种 Lazy Expiration 策略：Memcached 不会监控存入的 key/vlue 对是否过期，而是在获取 key 值时查看记录的时间戳，检查 key/value 对空间是否过期，这样可减轻服务器的负载。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3）分区&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Memcached 服务器之间彼此不通信，它的分布式能力是依赖客户端来实现。具体来说，就是在客户端实现一种算法，根据 key 来计算出数据应该向哪个服务器节点读/写。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而这种选取集群节点的算法常见的有三种：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.2 Redis&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Redis 是一个开源（BSD 许可）的，基于内存的，多数据结构存储系统。可以用作数据库、缓存和消息中间件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Redis 还可以使用客户端分片来扩展写性能。内置了 复制（replication），LUA 脚本（Lua scripting），LRU 驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis 哨兵（Sentinel）和自动分区（Cluster）提供高可用性（high availability）。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;4.2.1 Redis 特性&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;201&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;volatile-lru&lt;/strong&gt;：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;volatile-ttl &lt;/strong&gt;：从已设置过期时间的数据集中挑选将要过期的数据淘汰；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;volatile-random&lt;/strong&gt;：从已设置过期时间的数据集中任意选择数据淘汰；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;allkeys-lru&lt;/strong&gt;：从所有数据集中挑选最近最少使用的数据淘汰；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;allkeys-random&lt;/strong&gt;：从所有数据集中任意选择数据进行淘汰；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;noeviction&lt;/strong&gt; ：禁止驱逐数据。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;提供两种持久化方式 - RDB 和 AOF。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过 Redis cluster 提供集群模式。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;4.2.2 Redis 原理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;1）缓存淘汰&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis 有两种数据淘汰实现；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）分区&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3）主从复制&lt;/strong&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;174&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;完整重同步&lt;/strong&gt;（full resychronization） - 用于初次复制。执行步骤与 SYNC 命令基本一致。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;部分重同步&lt;/strong&gt;（partial resychronization） - 用于断线后重复制。如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只需接收并执行这些写命令，即可将主从服务器的数据库状态保持一致。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4）数据一致性&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.3  分布式缓存对比&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;不同的分布式缓存功能特性和实现原理方面有很大的差异，因此他们所适应的场景也有所不同。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;95&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.16484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtyicZQSWfYwFXlF57YX4OpaqoO9wzrCuJKPrtBhTnAP4Nicica79UrXj0iaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这里选取三个比较出名的分布式缓存（MemCache，Redis，Tair）来作为比较：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;242&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.41813898704358066&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtyEXK2WQ488siamOyMcia9c5C6XSxBl3sNXNEmWs2N3ykTiam3iamVYdOJuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;849&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;MemCache&lt;/strong&gt;：只适合基于内存的缓存框架；且不支持数据持久化和容灾。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Redis&lt;/strong&gt;：支持丰富的数据结构，读写性能很高，但是数据全内存，必须要考虑资源成本，支持持久化。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Tair&lt;/strong&gt;：支持丰富的数据结构，读写性能较高，部分类型比较慢，理论上容量可以无限扩充。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;总结：如果服务对延迟比较敏感，Map/Set 数据也比较多的话，比较适合 Redis。如果服务需要放入缓存量的数据很大，对延迟又不是特别敏感的话，那就可以选择 Memcached。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、多级缓存&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.1 整体缓存框架&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;通常，一个大型软件系统的缓存采用多级缓存方案：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;278&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.48125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtyEELHaavtTEhnoTRJxcOYWqAicciaDZFop5TQiamRhS7FVeEMOHkTYic00A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;请求过程：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;浏览器向客户端发起请求，如果 CDN 有缓存则直接返回；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果 CDN 无缓存，则访问反向代理服务器；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果反向代理服务器有缓存则直接返回；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果反向代理服务器无缓存或动态请求，则访问应用服务器；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;应用服务器访问进程内缓存；如果有缓存，则返回代理服务器，并缓存数据（动态请求不缓存）；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果进程内缓存无数据，则读取分布式缓存；并返回应用服务器；应用服务器将数据缓存到本地缓存（部分）；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果分布式缓存无数据，则应用程序读取数据库数据，并放入分布式缓存；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.2 使用进程内缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如果应用服务是单点应用，那么进程内缓存当然是缓存的首选方案。对于进程内缓存，其本来受限于内存的大小的限制，以及进程缓存更新后其他缓存无法得知，所以一般来说进程缓存适用于:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这种方案存在以下问题：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.3 使用分布式缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如果应用服务是分布式系统，那么最简单的缓存方案就是直接使用分布式缓存。&lt;span&gt;其应用场景如图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;567&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.9809220985691574&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtyXVxSdRPbjQ3rpicCIYf2icAbUVZdaAsuKsugfX86sqtc64hrLB3FGIEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;629&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Redis 用来存储热点数据，如果缓存不命中，则去查询数据库，并更新缓存。&lt;span&gt;这种方案存在以下问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.4 使用多级缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;单纯使用进程内缓存和分布式缓存都存在各自的不足。如果需要更高的性能以及更好的可用性，我们可以将缓存设计为多级结构。将最热的数据使用进程内缓存存储在内存中，进一步提升访问速度。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个设计思路在计算机系统中也存在，比如 CPU 使用 L1、L2、L3 多级缓存，用来减少对内存的直接访问，从而加快访问速度。一般来说，多级缓存架构使用二级缓存已可以满足大部分业务需求，过多的分级会增加系统的复杂度以及维护的成本。因此，多级缓存不是分级越多越好，需要根据实际情况进行权衡。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一个典型的二级缓存架构，可以使用进程内缓存（如：Caffeine/Google Guava/Ehcache/HashMap）作为一级缓存；使用分布式缓存（如：Redis/Memcached）作为二级缓存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;5.4.1 多级缓存查询&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;612&quot; data-backw=&quot;578&quot; data-ratio=&quot;1.0585683297180044&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFty5dhCH92Ldn6I0qenjQySsWum1jkibRPVJuic8lmNOEia64HJ3YfnYRB1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;922&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;多级缓存查询流程如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;5.4.2 多级缓存更新&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对于 L1 缓存，如果有数据更新，只能删除并更新所在机器上的缓存，其他机器只能通过超时机制来刷新缓存。超时设定可以有两种策略:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;设置成写入后多少时间后过期；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;设置成写入后多少时间刷新。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于 L2 缓存，如果有数据更新，其他机器立马可见。但是，也必须要设置超时时间，其时间应该比 L1 缓存的有效时间长。&lt;span&gt;为了解决进程内缓存不一致的问题，设计可以进一步优化；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;405&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtyqZ7ZgCgtHDE3cMEACcd83kDoO3ichSdvuSPpJ65gCdiaEoaicLpCBLGWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;通过消息队列的发布、订阅机制，可以通知其他应用节点对进程内缓存进行更新。使用这种方案，即使消息队列服务挂了或不可靠，由于先执行了数据库更新，但进程内缓存过期，刷新缓存时，也能保证数据的最终一致性。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;六、缓存问题&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;6.1 缓存雪崩&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存雪崩是指缓存不可用或者大量缓存由于超时时间相同在同一时间段失效，大量请求直接访问数据库，数据库压力过大导致系统雪崩。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;举例来说，对于系统 A，假设每天高峰期每秒 5000 个请求，本来缓存在高峰期可以扛住每秒 4000 个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000 个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没有采用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解决缓存雪崩的主要手段如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;增加缓存系统可用性（事前）&lt;/strong&gt;。例如：部署 Redis Cluster（主从+哨兵），以实现 Redis 的高可用，避免全盘崩溃。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;采用多级缓存方案（事中）&lt;/strong&gt;。例如：本地缓存（Ehcache/Caffine/Guava Cache） + 分布式缓存（Redis/ Memcached）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;限流、降级、熔断方案&lt;/strong&gt;（事中），避免被流量打死。如：使用 Hystrix 进行熔断、降级。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;缓存如果支持&lt;strong&gt;持久化&lt;/strong&gt;，可以在恢复工作后恢复数据（事后）。如：Redis 支持持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上面的解决方案简单来说，就是多级缓存方案。系统收到一个查询请求，先查本地缓存，再查分布式缓存，最后查数据库，只要命中，立即返回。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解决缓存雪崩的辅助手段如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;6.2 缓存穿透&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存穿透是指：查询的数据在数据库中不存在，那么缓存中自然也不存在。所以，应用在缓存中查不到，则会去查询数据库。当这样的请求多了后，数据库的压力就会增大。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;解决缓存穿透，一般有两种方法：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1）缓存空值&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于返回为 NULL 的依然缓存，对于抛出异常的返回不进行缓存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.5835095137420718&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtyxQnpuZxFgzLpeDup59ZN9XLZlMqoXS2UI7NF0Hj185hAUcpZlHW1uw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;473&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;采用这种手段的会增加我们缓存的维护成本，需要在插入缓存的时候删除这个空缓存，当然我们可以通过设置较短的超时时间来解决这个问题。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2）过滤不可能存在的数据&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.5483193277310925&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtylc4NiaR6gRAtojMPBV1eM7gFNZaHHXyoMMWQvZVnsp0LSrUvQPGVGrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;制定一些规则过滤一些不可能存在的数据。可以使用布隆过滤器（针对二进制操作的数据结构，所以性能高），比如你的订单 ID 明显是在一个范围 1-1000，如果不是 1-1000 之内的数据那其实可以直接给过滤掉。&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;193&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;针对于一些恶意攻击，攻击带过来的大量 key 是不存在的，那么我们采用第一种方案就会缓存大量不存在 key 的数据。此时我们采用第一种方案就不合适了，我们完全可以先对使用第二种方案进行过滤掉这些 key。针对这种 key 异常多、请求重复率比较低的数据，我们就没有必要进行缓存，使用第二种方案直接过滤掉。而对于空数据的 key 有限的，重复率比较高的，我们则可以采用第一种方式进行缓存。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;6.3 缓存击穿&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存击穿是指，热点数据失效瞬间，大量请求直接访问数据库。例如，某些 key 是热点数据，访问非常频繁。如果某个 key 失效的瞬间，大量的请求过来，缓存未命中，然后去数据库访问，此时数据库访问量会急剧增加。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了避免这个问题，我们可以采取下面的两个手段:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;6.4 小结&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;上面逐一介绍了缓存使用中常见的问题。这里，从发生时间段的角度整体归纳一下缓存问题解决方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;事前&lt;/strong&gt;：Redis 高可用方案（Redis Cluster + 主从 + 哨兵），避免缓存全面崩溃。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;事中&lt;/strong&gt;：（一）采用多级缓存方案，本地缓存（Ehcache/Caffine/Guava Cache） + 分布式缓存（Redis/ Memcached）。（二）限流 + 熔断 + 降级（Hystrix），避免极端情况下，数据库被打死。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;事后&lt;/strong&gt;：Redis 持久化（RDB+AOF），一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;分布式缓存 Memcached ，由于数据类型不如 Redis 丰富，并且不支持持久化、容灾。所以，一般会选择 Redis 做分布式缓存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;七、缓存策略&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;7.1 缓存预热&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存预热是指系统启动后，直接查询热点数据并缓存。这样就可以避免用户请求的时候，先查询数据库，然后再更新缓存的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解决方案：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;7.2 如何缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;7.2.1 不过期缓存&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;缓存更新模式：&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;开启事务；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;写 SQL；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;提交事务；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;写缓存；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不要把写缓存操作放在事务中，尤其是写分布式缓存。因为网络抖动可能导致写缓存响应时间很慢，引起数据库事务阻塞。如果对缓存数据一致性要求不是那么高，数据量也不是很大，可以考虑定期全量同步缓存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这种模式存在这样的情况：存在事务成功，但缓存写失败的可能。但这种情况相对于上面的问题，影响较小。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;7.2.2 过期缓存&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;采用懒加载。对于热点数据，可以设置较短的缓存时间，并定期异步加载。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;7.3 缓存更新&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;一般来说，系统如果不是严格要求缓存和数据库保持一致性的话，尽量不要将读请求和写请求串行化。串行化可以保证一定不会出现数据不一致的情况，但是它会导致系统的吞吐量大幅度下降。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一般来说缓存的更新有两种情况:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;先删除缓存，再更新数据库；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;先更新数据库，再删除缓存；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;97&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;为什么是删除缓存，而不是更新缓存呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;你可以想想当有多个并发的请求更新数据，你并不能保证更新数据库的顺序和更新缓存的顺序一致，那就会出现数据库中和缓存中数据不一致的情况。所以一般来说考虑删除缓存。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于一个更新操作简单来说，就是先去各级缓存进行删除，然后更新数据库。&lt;span&gt;这个操作有一个比较大的问题，在对缓存删除完之后，有一个读请求，这个时候由于缓存被删除所以直接会读库，读操作的数据是老的并且会被加载进入缓存当中，后续读请求全部访问的老数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.2846580406654344&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtyeLibVGWQibiciaWia5xaR1wt5bohatPaf9GfialNMlWPlRmEeegdCYQzYomg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;541&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对缓存的操作不论成功失败都不能阻塞我们对数据库的操作，那么很多时候删除缓存可以用异步的操作，但是先删除缓存不能很好的适用于这个场景。先删除缓存也有一个好处是，如果对数据库操作失败了，那么由于先删除的缓存，最多只是造成 Cache Miss。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1）先更新数据库，再删除缓存&lt;/strong&gt;（注：更推荐使用这种策略）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果我们使用更新数据库，再删除缓存就能避免上面的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是同样的引入了新的问题：假设执行更新操作时，又接收到查询请求，此时就会返回缓存中的老数据。更麻烦的是，如果数据库更新操作执行失败，则缓存中可能永远是脏数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）应该选择哪种更新策略&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过上面的内容，我们知道，两种更新策略都存在并发问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;但是建议选择先更新数据库，再删除缓存，因为其并发问题出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且同时有一个并发写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果需要数据库和缓存保证强一致性，则可以通过 2PC 或 Paxos 协议来实现。但是 2PC 太慢，而 Paxos 太复杂，所以如果不是非常重要的数据，不建议使用强一致性方案。更详细的分析可以参考：&lt;a target=&quot;_blank&quot; href=&quot;https://www.cnblogs.com/rjzheng/p/9041659.html&quot; textvalue=&quot;分布式之数据库和缓存双写一致性方案解析&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;分布式之数据库和缓存双写一致性方案解析&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;八、总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;最后，通过一张思维导图来总结一下本文所述的知识点，帮助大家对缓存有一个系统性的认识。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;247&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.4265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtyczlLSaLVPgEsh7ick39BQ7S9aPzrtsicrKZ4Pv1ON7l8p9GP8WICZo8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;九、参考资料&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;https://book.douban.com/subject/25723064/&quot; textvalue=&quot;《大型网站技术架构：核心原理与案例分析》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;《大型网站技术架构：核心原理与案例分析》&lt;/a&gt;&lt;/p&gt;&lt;p&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;https://juejin.cn/post/6844903660653117447&quot; textvalue=&quot;你应该知道的缓存进化史&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;你应该知道的缓存进化史&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;https://juejin.cn/post/6844903665845665805&quot; textvalue=&quot;如何优雅的设计和使用缓存？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;如何优雅的设计和使用缓存？&lt;/a&gt;&lt;/p&gt;&lt;p&gt;4、&lt;a target=&quot;_blank&quot; href=&quot;https://www.jianshu.com/p/73ce0ef820f9&quot; textvalue=&quot;理解分布式系统中的缓存架构(上)&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;理解分布式系统中的缓存架构(上)&lt;/span&gt;&lt;/a&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;5、&lt;a target=&quot;_blank&quot; href=&quot;https://tech.meituan.com/2017/03/17/cache-about.html&quot; textvalue=&quot;缓存那些事&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;缓存那些事&lt;/a&gt;&lt;/p&gt;&lt;p&gt;6、&lt;a target=&quot;_blank&quot; href=&quot;https://www.cnblogs.com/rjzheng/p/9041659.html&quot; textvalue=&quot;分布式之数据库和缓存双写一致性方案解析&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;分布式之数据库和缓存双写一致性方案解析&lt;/span&gt;&lt;/a&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:203.title1&quot;&gt;&lt;p&gt;猜你喜欢&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7eae014cdc9c99ff5a243601dff7fffc</guid>
<title>[推荐] 技术开发人员如何制定自己的OKR</title>
<link>https://toutiao.io/k/zq8oiet</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;最近是Q2刚开始，又到了制定季度OKR的时候了，我发现很多技术开发小伙伴依然不知道怎么制定自己的OKR。要么就写“持续做每个迭代”，要么就“持续维护某个系统”，要么就是“积极响应产品需求”。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;前提：这里假定你对OKR已经有了一定的认识，假定你已对OKR制定要遵循的通用原则SMART比较熟悉。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;技术OKR为什么难写？&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;好多技术主要是跟迭代做需求。这时候想的是我只要按时把需求完成就可以了。但日常迭代本来就是你应该做的事情，你应该去想你如何才能更好地更快地完成你的工作。由于技术OKR不像业务OKR有明确的业务指标且最终是指向用户价值的，久而久之技术OKR有时候就会沦为形式。这些形式化的OKR其实没有任何的指导意义，反而浪费大家时间，这样的OKR要趁早删掉。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;全程“虚词”，没法衡量&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;技术OKR和通用OKR一样不能只有虚词，要有可衡量的指标或者数据。全程“持续、大力、全力、快速”的话，复盘的时候你自己都不知道怎么衡量“全力”是使出了多少力气。这些虚词可以有，但也要附带可衡量的内容。要么是上线个什么功能，要么是把目前存在的什么问题给解决掉，要么把某某的xx率提高到多少？要么是持续做某件事几次。总之得有个实际的内容可以衡量。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;OKR制定原则&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;O要制定的有挑战性，要有远方的感觉。&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;能量化尽量量化 ：就是要有数字指标。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不能量化要细化：不能量化的你就写工作内容本身。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不能细化要流程化：有的工作内容是重复性很高的工作。程序员有时候会时不时的接到一些类似取数据的工作，那么这些工作怎么体现在OKR里呢？这时候你可以把这个取数工作给流程化、文档化，这样就能体现出你的价值了。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;明确完成时间。最好明确完成时间，这样你的关键结果更具体。比如：4月5日前完成xxx项目上线。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;OKR参与原则&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本着自下而上和自上而下相结合的原则。有的公司的OKR完全是自上而下对齐结果，这样就会让一线员工没有参与感，也不鼓舞人心。所以自下而上的OKR比例至少占到40%。先让每个员工自己去盘点当下遇到的问题，我们要去往哪里，然后把这些写入自己的OKR。这样做的另外一个好处就是，往往一些细节上的问题只有操作者自己才知道的，通过这样的方式让整个企业运作在Deep Dive的层面。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;日常类重复工作怎么写入OKR&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个是很多人经常提到的问题，所以这里专门说一下。对于日常持续重复的类似取数等工作，自己可以写把脚本文档化之类的，总之就是让重复的事情变得尽量不去重复，甚至提供一个通用的能力让这些事情花的时间更少，对于这类日常工作可以考虑遵循DRY原则来制定你的OKR。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;可以参考的几个OKR制定方向&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;下面给大家提供一些不同方向的技术OKR思路供参考：&lt;/p&gt;&lt;p&gt;1、功能交付类。比如上线某个项目或某个功能等；&lt;/p&gt;&lt;p&gt;2、性能优化类。比如当下你的项目某些API性能较差，可以写降低某某API响应时间从300ms到200ms等；&lt;/p&gt;&lt;p&gt;3、代码优化类。比如完成xxx模块的重构，抽离xxx组件供所有模块使用等；&lt;/p&gt;&lt;p&gt;4、代码质量类。比如线上bug小于1个等；&lt;/p&gt;&lt;p&gt;5、迭代交付类。比如迭代交付平均周期小于8天；&lt;/p&gt;&lt;p&gt;6、技术文化类。比如至少输出5篇技术博客，至少做3次技术分享；&lt;/p&gt;&lt;p&gt;7、指标完善类。比如增加bug来源字段到bug统计中等；&lt;/p&gt;&lt;p&gt;8、组件开发类。比如至少20个业务方接入；&lt;/p&gt;&lt;p&gt;9、团队管理类。比如至少3人轮岗，每周与一位技术小伙伴对话，培养1-2位自驱闭环的产研负责人等；&lt;/p&gt;&lt;p&gt;10、规范标准类。比如制定CodeReview规范。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;总之你就记住一个原则：当下存在哪些问题，你要去往哪里。这样你就不愁你的OKR写不出来了。&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>