<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>89ae4371cbad6871a9102a0d61024e5b</guid>
<title>工具 | 腾讯开源的，基于 Whistle 实现的多账号多环境远程配置及抓包调试平台</title>
<link>https://toutiao.io/k/iq87lih</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;大家好，我是周刊菌。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1111&quot; data-ratio=&quot;2.002666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicWpQhTALEcfH5yHp9JpjJKGa3Nl1KhM1bkIbCDAZ3KMMCc2qGia3oibdkxPOSRGEiahg8iclAZpdU54A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;「码农周刊 VIP 会员」推出 38 周啦！感谢亲们的大力支持！第 038 期「码农周刊 VIP 会员专属邮件周报」已发送完毕，请注意查收。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;告诉大家一个好消息&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：已有数位上市公司 CTO 低调订阅了我们的「码农周刊 VIP 会员专属邮件周报」，感谢肯定！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;255&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;255&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ7PeUupLzwuuAibicnrRNxKcfCY7fIva78efKsUzANlCCAeuSQEGkGm34rKkzNRpzy6IiaiaHmBNA6DcA/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;「码农周刊 VIP 会员」是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;简介版&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;码农周刊 VIP 会员 = 全年 52 期「VIP 会员专属邮件周报」 + 只限 VIP 会员加入的交流圈子 + 大厂「内推机会」 + N 多福利&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;详细版&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击「阅读原文」即可查看详细介绍&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊 VIP 新年特惠&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;原价 365 元/年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;，现价仅需 108 元！&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;全年 52 期「VIP 会员专属邮件周报」&lt;br/&gt;只限 VIP 会员加入的交流圈子&lt;br/&gt;大厂「内推机会」&lt;br/&gt;N 多福利，你值得拥有！&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;CTO 们邀请你加入码农周刊 VIP，升职加薪不再难！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;31&quot; data-cropselx2=&quot;291&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;350&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav9LRTqibic3sUoh5tv76OXCpNTWbZ0gCYsFDShjwfRVvM157WDel2cr2dy5ghjxDCCwRc2Mu8bgehnA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3bfe1c29e220b7fe035788f19b70f32c</guid>
<title>认识 V8 引擎（一）</title>
<link>https://toutiao.io/k/tdc9eou</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.478125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/otHvoL6neeIDb5ZT3Bs326f22KuLGbcF5xcruFSlN3lKAXHbIQ4s8xlFUr9u9Y7upL9Ebajsb00B1HR3phzpYw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;V8 是一个由 Google 开发的，开源的，高性能的， JavaScript 及 WebAssembly 引擎，使用 C++ 编写。广泛应用于 Google Chrome 浏览器、Node.js 等等。跨平台支持 Windows(Win7以上)、macOS(10.12+)，以及各种 Linux 系统，包括 ARM 的手机系统。同时，V8 也可以独立的运行使用，嵌入集成到 C++ 的应用中。&lt;/p&gt;&lt;p&gt;JavaScript 引擎的主要作用是执行 JavaScript 代码。世界上第一款 JavaScript 引擎是 SpiderMonkey，由布兰登·艾克在网景公司开发，用于 Netscape Navigator 网页浏览器。传闻艾克在 1995年 5 月仅花了十天就把原型设计了出来。&lt;/p&gt;&lt;p&gt;早期的 JavaScript 引擎是通过解释器的方式解释执行，比如将源码转成抽象语法树（AST），然后解释执行，其运行效率并不高。但由于早期的浏览器网页还是以静态网页（HTML）为主，JavaScript 并未被广泛重度的应用，所以解释执行并未遇到太大问题。后来随着动态网页兴起，网页里开始运行越来越多复杂的应用，JavaScript 的瓶颈凸显了出来。&lt;/p&gt;&lt;p&gt;既然 JavaScript 运行性能不行，为什么不替换它呢？换成 Lua，Python 不香吗？或者再重新精心设计另外一门专用语言（WebAssembly）。其实替换 JavaScript 的尝试一直都在进行，但是JavaScript 在浏览器里的地位至今无人能撼动。主要原因我认为有三个：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;经过几十年的应用，JavaScript 已经成为事实标准，改变不易&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;JavaScript 对开发者非常友好，上手较其他语言更容易&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;随着 JIT 技术的引入，JavaScript 的性能已经不再是问题&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;前两个都是习惯问题，即使改变，慢慢也就适应了。但 JIT 技术的引入，几乎解决了 JavaScript 的性能问题，使得 JavaScript 的地位更加的牢固。在 JavaScript 中应用 JIT 的典型代表，就是我们今天的主角：V8。在引入我们的主题之前，我还要简要的介绍一下什么是 JIT 技术。&lt;/p&gt;&lt;p&gt;JIT 的全程是 just-in-time compilation，又译即时编译或实时编译。在 JIT 出现之前，高级编程语言要被计算机执行，通常通过两种方式来实现：AOT 和解释器。AOT 全程 ahead-of-time compilation，即代码预先通过编译器的编译，直接生成目标机器的机器码。因此它的运行效率最高，比如我们常用的 C/C++ 代码，通过 gcc/clang/msvc 等编译器，直接编译出机器码的二进制文件，其运行性能我们称之为原生性能。&lt;/p&gt;&lt;p&gt;既然 AOT 性能最高，全都用 AOT 不就得了？也不尽然。AOT 要求编译的代码是静态类型的，比如一个变量的类型在运行期间不允许变成另一种类型，也不允许动态的往类型里增加属性。而 JavaScript 是动态类型的，比如下面一段代码，变量 foo 的类型可以运行时随时变化：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; foo = &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;// foo is a int&lt;/span&gt;foo = &lt;span&gt;&quot;hello&quot;&lt;/span&gt;; &lt;span&gt;// foo change to a string&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Point&lt;/span&gt;() {&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;foo = &lt;span&gt;new&lt;/span&gt; Point(); &lt;span&gt;// foo change to a Point&lt;/span&gt;foo.x = &lt;span&gt;10&lt;/span&gt;;  &lt;span&gt;// foo add x property&lt;/span&gt;foo.y = &lt;span&gt;10&lt;/span&gt;;  &lt;span&gt;// foo add y property&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;foo 类型总是变来变去，给 AOT 编译器增加了很大的麻烦。同时，AOT 还有编译时间长，生成的目标文件大的问题。它不能像 Java 一样『一次编译，到处运行』，而是针对不同平台『编译多次，到处运行』。如果想像 JavaScript 一样做到『一次编写，到处运行』，就需要在用户的浏览器端，运行时实时的进行编译。这样一来，缓慢的编译过程又拖慢了代码的启动速度。&lt;/p&gt;&lt;p&gt;JIT 结合了 AOT 和解释器两者的优势。它可以运行时根据情况在两者之间切换。比如首次启动时，使用解释器来执行，这样保证了代码的启动速度，对于一些短小的一次性执行的代码非常友好。当代码运行一段时间，编译器发现某些代码频繁的反复执行，则切换到 JIT 模式即时的将这部分代码编译成机器码，之后再运行到这类代码时，则可以做到几乎以原生的速度执行。&lt;/p&gt;&lt;p&gt;现代语言的虚拟机几乎都拥有了 JIT 的能力。如 JVM JIT，LuaJIT。几大 JavaScript 引擎，例如微软的 Chakra、Mozilla 的 SpiderMonkey、苹果的 JavaScriptCore、谷歌的 V8，JIT 已经成了标配功能。而其中谷歌的 V8，是所有的 JavaScript 引擎的佼佼者。&lt;/p&gt;&lt;p&gt;为什么 V8 能做到这么优秀呢？我们后面慢慢来讲。我们先来看看 V8 是怎样诞生出来的。从维基百科里了解到，V8 的创建者是一名叫 Lars Bak 的丹麦程序员。我们来看看这位大神的履历：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;1991 年在 Sun 工作，开发 Self 虚拟机，成为业界最佳程序员之一&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;1994 年，离开 Sun，加入 LongView，设计和开发了高性能虚拟机 StrongTalk&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;1997 年，LongView 被 Sun 收购，主导开发了著名的 Java 虚拟机 HotSpot&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2002 年回到丹麦，创立名叫 OOVM 的公司。&lt;/p&gt;&lt;p&gt;2004年将公司卖给一家瑞士公司 Esmertec，随后又在该公司干了两年&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2006 年加入谷歌，在丹麦自己的农场开始开发 V8 引擎&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2008 年，开发的 V8 引擎和谷歌浏览器 Chrome 一起横空出世。&lt;/p&gt;&lt;p&gt;V8 处理 JavaScript 的速度比当时的 IE 浏览器快 56 倍&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2011 年主导开发并发布 Dart 语言。&lt;/p&gt;&lt;p&gt;如今应用火热的 Flutter 正是使用该语言进行开发&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;据说 2006 年是劈柴（Sundar Pichai，现谷歌 CEO）哥亲自给 Bak 打的电话，说谷歌正打算开发一款全新的浏览器，你来做高级经理，开发一个高性能的 JavaScript 引擎好不好？Bak 对开发 JavaScript 引擎很有兴趣，欣然接受了这份工作。但他说他不在乎当什么高级经理，在乎的是推动打破技术的边界，并且他不会回到加州，而是在丹麦自己的农场开始他的工作。他家农场距离加州总部相隔 8000 公里，相差了 9 个时区。&lt;/p&gt;&lt;p&gt;他在农场建立了办公室，家就在办公室对面。每天，他走过石子路到办公室，然后开始写代码。结束工作后，又穿过院子走回家，把工作彻底放下。他享受这种工作和生活分开的感觉。这也是他不想去硅谷的原因。他招募了自己的学生卡斯帕伦德一起来农场工作，命名了新的引擎名字叫 V8，以汽车 V 型 8 缸发动机命名，预示着这将是一款性能爆表的引擎。V8 从零开始开发的，一面世就秒杀了市面上所有的 JavaScript 引擎。&lt;/p&gt;&lt;p&gt;早期的 V8 版本，为了追求性能的极致，将源码转成抽象语法树之后，直接通过 Full-codegen 生成目标机器码。2010 年，又推出了 Crankshaft 编译优化器，在代码执行过程中，内置的 Profiler 记录热点函数，然后提交给 Crankshaft 进行优化，生成优化后的机器码，进一步提高执行的效率。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.56171875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/otHvoL6neeJ47LHtlZjYT9DE7OIatKia8QbvZzjZWK0rEubg7qamC1R87S1ibObFWFvmQUicPc8TC9VVnC6ALkUbA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;由于直接生成目标机器码，导致了占用内存大，编译时间长导致启动速度慢，2016 年 V8 设计了中间字节码 Ignition，以让 V8 能在内存更小的安卓设备上流畅的运行。2017 年推出 V8 5.9 版本，废弃了旧的 Full-codegen+Crankshaft 的编译架构，使用了 Ignition 字节码解释器和编译优化器 TurboFan，内存使用得到进一步降低，网页加载速度也得到大幅的提升。Ignition+TurboFan 的组合沿用至今。&lt;/p&gt;&lt;p&gt;2017 年 V8 5.7 版本，正式支持了 WebAssembly，一个基于浏览器设计的新的字节码标准。2018 年 V8 6.9 版本，引入 WebAssembly 基线编译器 Liftoff，极大提升了首次编译的效率，配合 TurboFan 编译优化器，在启动速度和运行性能上都得到了很大的提升。&lt;/p&gt;&lt;p&gt;截止目前，V8 最新的版本是 8.7，并且一直在不断的迭代进化之中。&lt;/p&gt;&lt;h4&gt;随想&lt;/h4&gt;&lt;p&gt;Lars Bak 从大学时才接触计算机，一直专注在虚拟机的领域，做出像 JVM HotSpot、V8、Dart 这样非凡的产品。这告诉我们，找准自己的兴趣和努力的方向，深耕下去，什么时候开始都不会迟。Bak 加入谷歌时，已经 41 岁。虽然之前他已经积累了不少的财富，但我相信他是由衷的不在乎谷歌的什么高级职位，在乎的只是用更好的技术，突破更多的技术边界。所以 V8 从一开始就是开源的，正如题图 2008 年 Chrome 发布时的宣传漫画里说的一样：『所以，其他浏览器也可以用它（V8），或者，如果有其他项目需要用到 JavaScript，开发者都可以直接使用 V8』&lt;/p&gt;&lt;p&gt;我喜欢写代码，但有时也因程序员 35 岁问题而困扰，了解了 Lars Bak 经历之后，我想，专研深耕自己的领域，专注到兴趣的事情来上，竞争力自然就加强了，也就真没有什么好焦虑了。&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c17efb7d11fbe584d9d66aa107e8f47d</guid>
<title>Spring 中那些让你爱不释手的代码技巧</title>
<link>https://toutiao.io/k/lev94mm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近越来越多的读者认可我的文章，还是件挺让人高兴的事情。有些读者私信我说希望后面多分享spring方面的文章，这样能够在实际工作中派上用场。正好我对spring源码有过一定的研究，并结合我这几年实际的工作经验，把spring中我认为不错的知识点总结一下，希望对您有所帮助。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;一 如何获取spring容器对象&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;1.实现BeanFactoryAware接口&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PersonService&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BeanFactoryAware&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; BeanFactory beanFactory;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setBeanFactory&lt;/span&gt;&lt;span&gt;(BeanFactory beanFactory)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.beanFactory = beanFactory;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Person person = (Person) beanFactory.getBean(&lt;span&gt;&quot;person&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现&lt;code&gt;BeanFactoryAware&lt;/code&gt;接口，然后重写&lt;code&gt;setBeanFactory&lt;/code&gt;方法，就能从该方法中获取到spring容器对象。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;2.实现ApplicationContextAware接口&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PersonService2&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ApplicationContextAware&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ApplicationContext applicationContext;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setApplicationContext&lt;/span&gt;&lt;span&gt;(ApplicationContext applicationContext)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.applicationContext = applicationContext;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Person person = (Person) applicationContext.getBean(&lt;span&gt;&quot;person&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现&lt;code&gt;ApplicationContextAware&lt;/code&gt;接口，然后重写&lt;code&gt;setApplicationContext&lt;/code&gt;方法，也能从该方法中获取到spring容器对象。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;3.实现ApplicationListener接口&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PersonService3&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ApplicationListener&lt;/span&gt;&amp;lt;&lt;span&gt;ContextRefreshedEvent&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ApplicationContext applicationContext;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onApplicationEvent&lt;/span&gt;&lt;span&gt;(ContextRefreshedEvent event)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        applicationContext = event.getApplicationContext();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Person person = (Person) applicationContext.getBean(&lt;span&gt;&quot;person&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现&lt;code&gt;ApplicationListener&lt;/code&gt;接口，需要注意的是该接口接收的泛型是&lt;code&gt;ContextRefreshedEvent&lt;/code&gt;类，然后重写&lt;code&gt;onApplicationEvent&lt;/code&gt;方法，也能从该方法中获取到spring容器对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，不得不提一下&lt;code&gt;Aware&lt;/code&gt;接口，它其实是一个空接口，里面不包含任何方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它表示已感知的意思，通过这类接口可以获取指定对象，比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过BeanFactoryAware获取BeanFactory&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过ApplicationContextAware获取ApplicationContext&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过BeanNameAware获取BeanName等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Aware&lt;/span&gt;接口是很常用的功能，目前包含如下功能：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.4293628808864265&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEUlz2dib4YZFUs4VdbFia35G0kuZ9UQR0ENVqxshRFbmAmkRBarpQibGtJxW17r0lewVIxVug8ub4CA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;722&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;二 如何初始化bean&lt;/span&gt;&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring中支持3种初始化bean的方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;xml中指定init-method方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用@PostConstruct注解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实现InitializingBean接口&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一种方法太古老了，现在用的人不多，具体用法就不介绍了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;1.使用@PostConstruct注解&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@PostConstruct&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===初始化===&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在需要初始化的方法上增加&lt;code&gt;@PostConstruct&lt;/code&gt;注解，这样就有初始化的能力。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;2.实现InitializingBean接口&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BService&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;InitializingBean&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;afterPropertiesSet&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===初始化===&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现&lt;code&gt;InitializingBean&lt;/code&gt;接口，重写&lt;code&gt;afterPropertiesSet&lt;/code&gt;方法，该方法中可以完成初始化功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里顺便抛出一个有趣的问题：&lt;code&gt;init-method&lt;/code&gt;、&lt;code&gt;PostConstruct&lt;/code&gt; 和 &lt;code&gt;InitializingBean&lt;/code&gt; 的执行顺序是什么样的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;决定他们调用顺序的关键代码在&lt;code&gt;AbstractAutowireCapableBeanFactory&lt;/code&gt;类的&lt;code&gt;initializeBean&lt;/code&gt;方法中。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.38170347003154576&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDELdgnZC2EVRmh8HYBrPD7va6icTXPB2jvm3vqhYL3lia5u8Ef7Vv8aYUeXw6P3tGfD3E8kicicQqcDrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码中会先调用&lt;code&gt;BeanPostProcessor&lt;/code&gt;的&lt;code&gt;postProcessBeforeInitialization&lt;/code&gt;方法，而&lt;code&gt;PostConstruct&lt;/code&gt;是通过&lt;code&gt;InitDestroyAnnotationBeanPostProcessor&lt;/code&gt;实现的，它就是一个&lt;code&gt;BeanPostProcessor&lt;/code&gt;，所以&lt;code&gt;PostConstruct&lt;/code&gt;先执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而&lt;code&gt;invokeInitMethods&lt;/code&gt;方法中的代码：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6951566951566952&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDELdgnZC2EVRmh8HYBrPD7vrKtF1W5HmRXGyFA0vYzJ670YBd406aNiatdmWxLAAhfeDdo2iadtryKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1404&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;决定了先调用&lt;code&gt;InitializingBean&lt;/code&gt;，再调用&lt;code&gt;init-method&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以得出结论，他们的调用顺序是：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.1775362318840579&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDELdgnZC2EVRmh8HYBrPD7vcSlRricX9ziagqZUUuFl6YrT4YyUFgOSxYEveRGLUyhuHuHoBeAVvFbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;552&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;三 自定义自己的Scope&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道&lt;code&gt;spring&lt;/code&gt;默认支持的&lt;code&gt;Scope&lt;/code&gt;只有两种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;singleton 单例，每次从spring容器中获取到的bean都是同一个对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;prototype 多例，每次从spring容器中获取到的bean都是不同的对象。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;spring web&lt;/code&gt;又对&lt;code&gt;Scope&lt;/code&gt;进行了扩展，增加了：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;RequestScope 同一次请求从spring容器中获取到的bean都是同一个对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SessionScope 同一个会话从spring容器中获取到的bean都是同一个对象。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即便如此，有些场景还是无法满足我们的要求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，我们想在同一个线程中从spring容器获取到的bean都是同一个对象，该怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就需要自定义&lt;code&gt;Scope&lt;/code&gt;了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步实现&lt;code&gt;Scope&lt;/code&gt;接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalScope&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Scope&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private &lt;/span&gt; &lt;span&gt;static &lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal THREAD_LOCAL_SCOPE = &lt;span&gt;new&lt;/span&gt; ThreadLocal();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(String name, ObjectFactory&amp;lt;?&amp;gt; objectFactory)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Object value = THREAD_LOCAL_SCOPE.get();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (value != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; value;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        Object object = objectFactory.getObject();&lt;br/&gt;        THREAD_LOCAL_SCOPE.set(object);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; object;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;(String name)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        THREAD_LOCAL_SCOPE.remove();&lt;br/&gt;        &lt;span&gt;return &lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;registerDestructionCallback&lt;/span&gt;&lt;span&gt;(String name, Runnable callback)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;resolveContextualObject&lt;/span&gt;&lt;span&gt;(String key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return &lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getConversationId&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return &lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步将新定义的&lt;code&gt;Scope&lt;/code&gt;注入到spring容器中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalBeanFactoryPostProcessor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BeanFactoryPostProcessor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;postProcessBeanFactory&lt;/span&gt;&lt;span&gt;(ConfigurableListableBeanFactory beanFactory)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        beanFactory.registerScope(&lt;span&gt;&quot;threadLocalScope&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; ThreadLocalScope());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三步使用新定义的&lt;code&gt;Scope&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Scope&lt;/span&gt;(&lt;span&gt;&quot;threadLocalScope&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;四 别说FactoryBean没用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说起&lt;code&gt;FactoryBean&lt;/code&gt;就不得不提&lt;code&gt;BeanFactory&lt;/code&gt;，因为面试官老喜欢问它们的区别。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;BeanFactory：spring容器的顶级接口，管理bean的工厂。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;FactoryBean：并非普通的工厂bean，它隐藏了实例化一些复杂Bean的细节，给上层应用带来了便利。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你看过spring源码，会发现它有70多个地方在用FactoryBean接口。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0769230769230769&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDELdgnZC2EVRmh8HYBrPD7vTVYWc3BZ64373MkUZRhVDe8w0uA6s9k7RSwl5siabkvMVRVa4ycpKMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1014&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这张图足以说明该接口的重要性，请勿忽略它好吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;特别提一句：&lt;code&gt;mybatis&lt;/code&gt;的&lt;code&gt;SqlSessionFactory&lt;/code&gt;对象就是通过&lt;code&gt;SqlSessionFactoryBean&lt;/code&gt;类创建的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们一起定义自己的&lt;code&gt;FactoryBean&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyFactoryBean&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;FactoryBean&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;getObject&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        String data1 = buildData1();&lt;br/&gt;        String data2 = buildData2();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; buildData3(data1, data2);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; String &lt;span&gt;buildData1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return &lt;/span&gt; &lt;span&gt;&quot;data1&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; String &lt;span&gt;buildData2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return &lt;/span&gt; &lt;span&gt;&quot;data2&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; String &lt;span&gt;buildData3&lt;/span&gt;&lt;span&gt;(String data1, String data2)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; data1 + data2;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; Class&amp;lt;?&amp;gt; getObjectType() {&lt;br/&gt;        &lt;span&gt;return &lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取&lt;code&gt;FactoryBean&lt;/code&gt;实例对象：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyFactoryBeanService&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BeanFactoryAware&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; BeanFactory beanFactory;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setBeanFactory&lt;/span&gt;&lt;span&gt;(BeanFactory beanFactory)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.beanFactory = beanFactory;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Object myFactoryBean = beanFactory.getBean(&lt;span&gt;&quot;myFactoryBean&quot;&lt;/span&gt;);&lt;br/&gt;        System.out.println(myFactoryBean);&lt;br/&gt;        Object myFactoryBean1 = beanFactory.getBean(&lt;span&gt;&quot;&amp;amp;myFactoryBean&quot;&lt;/span&gt;);&lt;br/&gt;        System.out.println(myFactoryBean1);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;getBean(&quot;myFactoryBean&quot;);&lt;/code&gt;获取的是MyFactoryBeanService类中getObject方法返回的对象，&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;getBean(&quot;&amp;amp;myFactoryBean&quot;);&lt;/code&gt;获取的才是MyFactoryBean对象。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;五 轻松自定义类型转换&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring目前支持3中类型转换器：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Converter&amp;lt;S,T&amp;gt;：将 S 类型对象转为 T 类型对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ConverterFactory&amp;lt;S, R&amp;gt;：将 S 类型对象转为 R 类型及子类对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;GenericConverter：它支持多个source和目标类型的转化，同时还提供了source和目标类型的上下文，这个上下文能让你实现基于属性上的注解或信息来进行类型转换。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这3种类型转换器使用的场景不一样，我们以&lt;code&gt;Converter&amp;lt;S,T&amp;gt;&lt;/code&gt;为例。假如：接口中接收参数的实体对象中，有个字段的类型是Date，但是实际传参的是字符串类型：2021-01-03 10:20:15，要如何处理呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步，定义一个实体&lt;code&gt;User&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Long id;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Date registerDate;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步，实现&lt;code&gt;Converter&lt;/code&gt;接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DateConverter&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Converter&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Date&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; SimpleDateFormat simpleDateFormat = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Date &lt;span&gt;convert&lt;/span&gt;&lt;span&gt;(String source)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (source != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;&quot;&quot;&lt;/span&gt;.equals(source)) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                simpleDateFormat.parse(source);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (ParseException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return &lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三步，将新定义的类型转换器注入到spring容器中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WebConfig&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;WebMvcConfigurerAdapter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addFormatters&lt;/span&gt;&lt;span&gt;(FormatterRegistry registry)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        registry.addConverter(&lt;span&gt;new&lt;/span&gt; DateConverter());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第四步，调用接口&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/user&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/save&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;save&lt;/span&gt;&lt;span&gt;(@RequestBody User user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return &lt;/span&gt; &lt;span&gt;&quot;success&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求接口时&lt;code&gt;User&lt;/code&gt;对象中&lt;code&gt;registerDate&lt;/code&gt;字段会被自动转换成&lt;code&gt;Date&lt;/code&gt;类型。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;六 spring mvc拦截器，用过的都说好&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring mvc拦截器根spring拦截器相比，它里面能够获取&lt;code&gt;HttpServletRequest&lt;/code&gt;和&lt;code&gt;HttpServletResponse&lt;/code&gt; 等web对象实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring mvc拦截器的顶层接口是：&lt;code&gt;HandlerInterceptor&lt;/code&gt;，包含三个方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;preHandle 目标方法执行前执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;postHandle 目标方法执行后执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;afterCompletion 请求完成时执行&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了方便我们一般情况会用&lt;span&gt;HandlerInterceptor&lt;/span&gt;接口的实现类&lt;code&gt;HandlerInterceptorAdapter&lt;/code&gt;类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如有权限认证、日志、统计的场景，可以使用该拦截器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步，继承&lt;code&gt;HandlerInterceptorAdapter&lt;/code&gt;类定义拦截器：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AuthInterceptor&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;HandlerInterceptorAdapter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;preHandle&lt;/span&gt;&lt;span&gt;(HttpServletRequest request, HttpServletResponse response, Object handler)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        String requestUrl = request.getRequestURI();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (checkAuth(requestUrl)) {&lt;br/&gt;            &lt;span&gt;return &lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return &lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;checkAuth&lt;/span&gt;&lt;span&gt;(String requestUrl)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===权限校验===&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return &lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步，将该拦截器注册到spring容器：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WebAuthConfig&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;WebMvcConfigurerAdapter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; AuthInterceptor &lt;span&gt;getAuthInterceptor&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return &lt;/span&gt; &lt;span&gt;new&lt;/span&gt; AuthInterceptor();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addInterceptors&lt;/span&gt;&lt;span&gt;(InterceptorRegistry registry)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        registry.addInterceptor(&lt;span&gt;new&lt;/span&gt; AuthInterceptor());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三步，在请求接口时spring mvc通过该拦截器，能够自动拦截该接口，并且校验权限。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该拦截器其实相对来说，比较简单，可以在&lt;code&gt;DispatcherServlet&lt;/code&gt;类的&lt;code&gt;doDispatch&lt;/code&gt;方法中看到调用过程：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7720994475138122&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEUlz2dib4YZFUs4VdbFia35GBcWdl3e9YiaIxTMibCxQGGTbZLE9xsiadddF5QyicxH8ic8dXsMUiaYcJm2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1448&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顺便说一句，这里只讲了spring mvc的拦截器，并&lt;span&gt;没有讲spring的拦截器&lt;/span&gt;，是因为我有点小私心，后面就会知道。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;七 Enable开关真香&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你有没有用过&lt;code&gt;Enable&lt;/code&gt;开头的注解，比如：&lt;code&gt;EnableAsync&lt;/code&gt;、&lt;code&gt;EnableCaching&lt;/code&gt;、&lt;code&gt;EnableAspectJAutoProxy&lt;/code&gt;等，这类注解就像开关一样，只要在&lt;code&gt;@Configuration&lt;/code&gt;定义的配置类上加上这类注解，就能开启相关的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是不是很酷？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们一起实现一个自己的开关：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步，定义一个LogFilter：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LogFilter&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Filter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;(FilterConfig filterConfig)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ServletException &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doFilter&lt;/span&gt;&lt;span&gt;(ServletRequest request, ServletResponse response, FilterChain chain)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException, ServletException &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;记录请求日志&quot;&lt;/span&gt;);&lt;br/&gt;        chain.doFilter(request, response);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;记录响应日志&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;destroy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步，注册LogFilter：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@ConditionalOnWebApplication&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LogFilterWebConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; LogFilter &lt;span&gt;timeFilter&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return &lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LogFilter();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，这里用了&lt;code&gt;@ConditionalOnWebApplication&lt;/code&gt;注解，没有直接使用&lt;code&gt;@Configuration&lt;/code&gt;注解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三步，定义开关&lt;code&gt;@EnableLog&lt;/code&gt;注解：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Target&lt;/span&gt;(ElementType.TYPE)&lt;br/&gt;&lt;span&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;br/&gt;&lt;span&gt;@Documented&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Import&lt;/span&gt;(LogFilterWebConfig&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;EnableLog&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第四步，只需在&lt;code&gt;springboot&lt;/code&gt;启动类加上&lt;code&gt;@EnableLog&lt;/code&gt;注解即可开启LogFilter记录请求和响应日志的功能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;八 RestTemplate拦截器的春天&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用&lt;code&gt;RestTemplate&lt;/code&gt;调用远程接口时，有时需要在&lt;code&gt;header&lt;/code&gt;中传递信息，比如：traceId，source等，便于在查询日志时能够串联一次完整的请求链路，快速定位问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种业务场景就能通过&lt;code&gt;ClientHttpRequestInterceptor&lt;/code&gt;接口实现，具体做法如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步，实现&lt;code&gt;ClientHttpRequestInterceptor&lt;/code&gt;接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RestTemplateInterceptor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ClientHttpRequestInterceptor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ClientHttpResponse &lt;span&gt;intercept&lt;/span&gt;&lt;span&gt;(HttpRequest request, &lt;span&gt;byte&lt;/span&gt;[] body, ClientHttpRequestExecution execution)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        request.getHeaders().set(&lt;span&gt;&quot;traceId&quot;&lt;/span&gt;, MdcUtil.get());&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; execution.execute(request, body);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步，定义配置类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RestTemplateConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; RestTemplate &lt;span&gt;restTemplate&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        RestTemplate restTemplate = &lt;span&gt;new&lt;/span&gt; RestTemplate();&lt;br/&gt;        restTemplate.setInterceptors(Collections.singletonList(restTemplateInterceptor()));&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; restTemplate;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; RestTemplateInterceptor &lt;span&gt;restTemplateInterceptor&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return &lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RestTemplateInterceptor();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中MdcUtil其实是利用&lt;code&gt;MDC&lt;/code&gt;工具在&lt;code&gt;ThreadLocal&lt;/code&gt;中存储和获取traceId&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MdcUtil&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private &lt;/span&gt; &lt;span&gt;static &lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String TRACE_ID = &lt;span&gt;&quot;TRACE_ID&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; MDC.get(TRACE_ID);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(String value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        MDC.put(TRACE_ID, value);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，这个例子中没有演示MdcUtil类的add方法具体调的地方，我们可以在filter中执行接口方法之前，生成traceId，调用MdcUtil类的add方法添加到&lt;code&gt;MDC&lt;/code&gt;中，然后在同一个请求的其他地方就能通过MdcUtil类的get方法获取到该traceId。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;九 统一异常处理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以前我们在开发接口时，如果出现异常，为了给用户一个更友好的提示，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/test&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/add&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;10&lt;/span&gt; / &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;return &lt;/span&gt; &lt;span&gt;&quot;成功&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不做任何处理请求add接口结果直接报错：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.28355957767722473&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDELdgnZC2EVRmh8HYBrPD7vyDdyWt359lfLvZNlJpxdPpHggibXhVFWQwtwRCUUmxA75U8Y2j5Lhrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1326&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;what？用户能直接看到错误信息？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种交互方式给用户的体验非常差，为了解决这个问题，我们通常会在接口中捕获异常：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/add&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String result = &lt;span&gt;&quot;成功&quot;&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;10&lt;/span&gt; / &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            result = &lt;span&gt;&quot;数据异常&quot;&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口改造后，出现异常时会提示：“数据异常”，对用户来说更友好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看起来挺不错的，但是有问题。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果只是一个接口还好，但是如果项目中有成百上千个接口，都要加上异常捕获代码吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是否定的，这时全局异常处理就派上用场了：&lt;code&gt;RestControllerAdvice&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@RestControllerAdvice&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GlobalExceptionHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@ExceptionHandler&lt;/span&gt;(Exception&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;handleException&lt;/span&gt;(&lt;span&gt;Exception&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt; ArithmeticException) {&lt;br/&gt;            &lt;span&gt;return &lt;/span&gt; &lt;span&gt;&quot;数据异常&quot;&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt; Exception) {&lt;br/&gt;            &lt;span&gt;return &lt;/span&gt; &lt;span&gt;&quot;服务器内部异常&quot;&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;retur n&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需在&lt;code&gt;handleException&lt;/code&gt;方法中处理异常情况，业务接口中可以放心使用，不再需要捕获异常（有人统一处理了）。真是爽歪歪。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;十 异步也可以这么优雅&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以前我们在使用异步功能时，通常情况下有三种方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;继承Thread类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实现Runable接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用线程池&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们一起回顾一下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;继承Thread类&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyThread&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===call MyThread===&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; MyThread().start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实现Runable接口&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyWork&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===call MyWork===&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; MyWork()).start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用线程池&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyThreadPool&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private &lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService executorService = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;60&lt;/span&gt;, TimeUnit.SECONDS, &lt;span&gt;new&lt;/span&gt; ArrayBlockingQueue&amp;lt;&amp;gt;(&lt;span&gt;200&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;static &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Work&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;===call work===&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            executorService.submit(&lt;span&gt;new&lt;/span&gt; MyThreadPool.Work());&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            executorService.shutdown();&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这三种实现异步的方法不能说不好，但是spring已经帮我们抽取了一些公共的地方，我们无需再继承&lt;code&gt;Thread&lt;/code&gt;类或实现&lt;code&gt;Runable&lt;/code&gt;接口，它都搞定了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何spring异步功能呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步，springboot项目启动类上加&lt;code&gt;@EnableAsync&lt;/code&gt;注解。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@EnableAsync&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@SpringBootApplication&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Application&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; SpringApplicationBuilder(Application&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;).&lt;span&gt;web&lt;/span&gt;(&lt;span&gt;WebApplicationType&lt;/span&gt;.&lt;span&gt;SERVLET&lt;/span&gt;).&lt;span&gt;run&lt;/span&gt;(&lt;span&gt;args&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步，在需要使用异步的方法上加上&lt;code&gt;@Async&lt;/code&gt;注解：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PersonService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Async&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===add==&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return &lt;/span&gt; &lt;span&gt;&quot;data&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在使用的地方调用一下：personService.get();就拥有了异步功能，是不是很神奇。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下，spring会为我们的异步方法创建一个线程去执行，如果该方法被调用次数非常多的话，需要创建大量的线程，会导致资源浪费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，我们可以定义一个线程池，异步方法将会被自动提交到线程池中执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadPoolConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${thread.pool.corePoolSize:5}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private &lt;/span&gt; &lt;span&gt;int&lt;/span&gt; corePoolSize;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${thread.pool.maxPoolSize:10}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private &lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxPoolSize;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${thread.pool.queueCapacity:200}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private &lt;/span&gt; &lt;span&gt;int&lt;/span&gt; queueCapacity;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${thread.pool.keepAliveSeconds:30}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private &lt;/span&gt; &lt;span&gt;int&lt;/span&gt; keepAliveSeconds;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${thread.pool.threadNamePrefix:ASYNC_}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String threadNamePrefix;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Executor &lt;span&gt;MessageExecutor&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ThreadPoolTaskExecutor executor = &lt;span&gt;new&lt;/span&gt; ThreadPoolTaskExecutor();&lt;br/&gt;        executor.setCorePoolSize(corePoolSize);&lt;br/&gt;        executor.setMaxPoolSize(maxPoolSize);&lt;br/&gt;        executor.setQueueCapacity(queueCapacity);&lt;br/&gt;        executor.setKeepAliveSeconds(keepAliveSeconds);&lt;br/&gt;        executor.setThreadNamePrefix(threadNamePrefix);&lt;br/&gt;        executor.setRejectedExecutionHandler(&lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor.CallerRunsPolicy());&lt;br/&gt;        executor.initialize();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; executor;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring异步的核心方法：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDELdgnZC2EVRmh8HYBrPD7vI9zxV1qWZZu91ls2pflUSwaNmOUckkqDogaAEEKU8IMMqvHjH92phg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1470&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据返回值不同，处理情况也不太一样，具体分为如下情况：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.34124629080118696&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDELdgnZC2EVRmh8HYBrPD7veNnUBO858MkbFZIFrlicTVvHyv9eQVP3mRPBNeswWNr9eMEWqmPHoEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1348&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;十一 听说缓存好用，没想到这么好用&lt;/span&gt;&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring cache架构图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7011494252873564&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDELdgnZC2EVRmh8HYBrPD7vdmj5ViapicuZVXEMicNXwCo2tYL38As3kgjg6YibpibhUocY4BZVOIdm9lg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;870&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它目前支持多种缓存：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.31690140845070425&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDELdgnZC2EVRmh8HYBrPD7vYvgErCXEn63wnQDSYgm9YEBbqK0Y2VB0JuvJDJtVab7icibQX0MSic1Vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1420&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在这里以&lt;code&gt;caffeine&lt;/code&gt;为例，它是&lt;code&gt;spring&lt;/code&gt;官方推荐的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步，引入&lt;code&gt;caffeine&lt;/code&gt;的相关jar包&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;spring-boot-starter-cache&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;com.github.ben-manes.caffeine&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;caffeine&amp;lt;/artifactId&amp;gt;&lt;br/&gt;    &amp;lt;version&amp;gt;&lt;span&gt;2.6&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步，配置&lt;code&gt;CacheManager&lt;/code&gt;，开启&lt;code&gt;EnableCaching&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@EnableCaching&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CacheConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; CacheManager &lt;span&gt;cacheManager&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        CaffeineCacheManager cacheManager = &lt;span&gt;new&lt;/span&gt; CaffeineCacheManager();&lt;br/&gt;        &lt;span&gt;//Caffeine配置&lt;/span&gt;&lt;br/&gt;        Caffeine&amp;lt;Object, Object&amp;gt; caffeine = Caffeine.newBuilder()&lt;br/&gt;                &lt;span&gt;//最后一次写入后经过固定时间过期&lt;/span&gt;&lt;br/&gt;                .expireAfterWrite(&lt;span&gt;10&lt;/span&gt;, TimeUnit.SECONDS)&lt;br/&gt;                &lt;span&gt;//缓存的最大条数&lt;/span&gt;&lt;br/&gt;                .maximumSize(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;        cacheManager.setCaffeine(caffeine);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; cacheManager;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三步，使用&lt;code&gt;Cacheable&lt;/code&gt;注解获取数据&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CategoryService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;br/&gt;   &lt;span&gt;//category是缓存名称,#type是具体的key，可支持el表达式&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;@Cacheable&lt;/span&gt;(value = &lt;span&gt;&quot;category&quot;&lt;/span&gt;, key = &lt;span&gt;&quot;#type&quot;&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; CategoryModel &lt;span&gt;getCategory&lt;/span&gt;&lt;span&gt;(Integer type)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       &lt;span&gt;return&lt;/span&gt; getCategoryByType(type);&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;private&lt;/span&gt; CategoryModel &lt;span&gt;getCategoryByType&lt;/span&gt;&lt;span&gt;(Integer type)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       System.out.println(&lt;span&gt;&quot;根据不同的type:&quot;&lt;/span&gt; + type + &lt;span&gt;&quot;获取不同的分类数据&quot;&lt;/span&gt;);&lt;br/&gt;       CategoryModel categoryModel = &lt;span&gt;new&lt;/span&gt; CategoryModel();&lt;br/&gt;       categoryModel.setId(&lt;span&gt;1L&lt;/span&gt;);&lt;br/&gt;       categoryModel.setParentId(&lt;span&gt;0L&lt;/span&gt;);&lt;br/&gt;       categoryModel.setName(&lt;span&gt;&quot;电器&quot;&lt;/span&gt;);&lt;br/&gt;       categoryModel.setLevel(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;       &lt;span&gt;return&lt;/span&gt; categoryModel;&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用categoryService.getCategory()方法时，先从&lt;code&gt;caffine&lt;/code&gt;缓存中获取数据，如果能够获取到数据则直接返回该数据，不会进入方法体。如果不能获取到数据，则直接方法体中的代码获取到数据，然后放到&lt;code&gt;caffine&lt;/code&gt;缓存中。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;唠唠家常&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring中不错的功能其实还有很多，比如：BeanPostProcessor,BeanFactoryPostProcessor,AOP,动态数据源，ImportSelector等等。我原本打算一篇文章写全的，但是有两件事情改变了我的注意：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;有个大佬原本打算转载我文章的，却因为篇幅太长一直没有保存成功。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最近经常加班，真的没多少时间写文章，晚上还要带娃，喂奶，换尿布，其实挺累的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;END&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;推荐好文&lt;/h4&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;amp;mid=2247498557&amp;amp;idx=2&amp;amp;sn=84902d7030e174e152615d8fae3755cc&amp;amp;chksm=ebd5c411dca24d07446a4f22772cd12d2cc1143b62eb922a14500ae981cd57fb850ef74ca257&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;强大，10k+点赞的 SpringBoot 后台管理系统竟然出了详细教程！&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MTI4MjI0MQ==&amp;amp;mid=2247497288&amp;amp;idx=2&amp;amp;sn=65d7111a19e920df1e9416959594b2f4&amp;amp;chksm=fc799be6cb0e12f0b58479f8b031bc5ae79efdca1880ff9b19f0a107c3a88c37b9596dc73203&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;分享一套基于SpringBoot和Vue的企业级中后台开源项目，代码很规范！&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MTI4MjI0MQ==&amp;amp;mid=2247497522&amp;amp;idx=2&amp;amp;sn=c5b4e596be4ac7d7f293e7e2f0ea0769&amp;amp;chksm=fc799a9ccb0e138a64a2671f31b8d4be1b3c061a288f7b0d1d4af02a60c45a72231446b91e00&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;能挣钱的，开源 SpringBoot 商城系统，功能超全，超漂亮！&lt;/a&gt;&lt;/p&gt;&lt;/pre&gt;&lt;pre&gt;&lt;p&gt;&lt;img data-type=&quot;jpeg&quot; data-ratio=&quot;0.3648148148148148&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufRcZPYBUx7WxAoIjibsF645yGLZqfGCEn9x73bnkBLibx6TAGMpmMyib0aXeRHZsJoHBmwVQ6YIVGtw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>482b234da9abf1fef8ec8834b246b3d3</guid>
<title>我的 2020 年阅读书单</title>
<link>https://toutiao.io/k/e83kg1a</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;把2020年读过的书单简单整理下分个类，把一些值得推荐的书列出来（技术书籍除外），给大家作个参考。其中有些书目，特别想推荐大家的，在之前的推文也都单独成文。&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;为什么都是不列技术书，反而都是一堆科外书？一个简单的理由：随着年龄的增长，我们需要求助于技术外的东西来安身立命。另外，由于读这篇文章的你所从事的领域不同，我去罗列技术书的局限性就比较大。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;现在回过头来看，很多书只对书名有个印象，但书中的内容都有些模糊了。不过也没关系，人脑不可能记住所有东西，留一个索引在脑海里，需要的时候，你会找到它的。&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;传记类：&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《硅谷钢铁侠：埃隆·马斯克的冒险人生》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《一往无前》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《我曾走在崩溃的边缘：俞敏洪亲述新东方创业发展之路》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《岁月凶猛》&lt;span&gt;（ 冯仑“商业三部曲”收官之作，前两本《野蛮生长》《理想丰满》）&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;社科类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《裂变式创业：无边界组织的失控实践》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《第二曲线创新》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《重来：更为简单有效的商业思维》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《重来2：更为简单高效的工作方式》&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;认知探索类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《好好学习：个人知识管理精进指南》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《一年顶十年》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《好好思考》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《洞见》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《能力陷阱》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《你要如何衡量你的人生（舒适阅读版）》&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;我在微信读书里，建了一个认识提升的书单，目前收藏量已经近1500人，看来大家还都是比较关注这块的。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;产品经营类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《俞军产品方法论》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《决胜B端：产品经理升级之路》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《SaaS创业路线图：to B产品、营销、运营方法论及实战案例解读》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《客户成功：持续复购和利润陡增的基石》&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;子女教育类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《阅读手册：成就孩子一生的阅读培养法》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《我用阅读教育孩子》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《养育男孩》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《养育女孩》&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不再沿用之前的方式一一列出，今年仅仅罗列20几本，不太推荐给你读的书目不在此列，以免形成对你的干扰。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;祝你开卷有益。&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;你的认可，才是对我最大的鼓励&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d2cec96b9fe50e783c8bbc5df5f5d512</guid>
<title>VirtualAPP 源码解析：Native Hook 技术</title>
<link>https://toutiao.io/k/ryt03gi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;h2&gt;前言&lt;/h2&gt;&lt;p&gt;本篇文章主要介绍VirtualAPP使用的Native Hook技术，不是很深入，因为涉及很多C++，ELF和指令集相关的知识点，很多知识还没有融会贯通，目前只是停留在名词的概念上。后续理解了在进行补充。&lt;/p&gt;&lt;h2&gt;应用背景&lt;/h2&gt;&lt;p&gt;VirtualAPP中使用了Native Hook技术，主要用于虚拟APP的文件访问重定向。这句话怎么理解和为什么这么做呢，我们先回顾一下VirtualAPP的大致原理。在VirtualAPP中启动一个虚拟APP,大致分为如下几部：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;VirtualAPP通过虚拟服务端启动APP B(虚拟APP)&lt;/li&gt;&lt;li&gt; 虚拟服务端通过Provider创建APP B对应的进程，同时替换Intent数据指向代理组件&lt;/li&gt;&lt;li&gt; APP B进程启动，同时将系统服务代理对象，通过动态代理的方式全部替换，指向虚拟服务端&lt;/li&gt;&lt;li&gt; APP B进程 收到intent数据，将intent中数据解析，重新替换为目标组件。从而实现狸猫换太子。&lt;/li&gt;&lt;/ol&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-79c34a2e94389fe3b26f8de79df456cd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;870&quot; data-rawheight=&quot;460&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-79c34a2e94389fe3b26f8de79df456cd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;870&quot; data-rawheight=&quot;460&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-79c34a2e94389fe3b26f8de79df456cd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-79c34a2e94389fe3b26f8de79df456cd_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在上述步骤我们可以看出，虚拟APP是VirtaulAPP的一个子进程。可想而知我们在虚拟app中进行文件存储或者sp操作时，最终的存储路径也是在VirtaulAPP的data目录下，这样就会带来一个问题。如果允许多个app就会可能出现文件访问冲突，同时也没有做到APP间隔离的目的。而VirtualAPP就是通过Native Hook技术解决了该问题。每个APP都有自己各自的文件存储路径。&lt;/p&gt;&lt;h2&gt;源码分析&lt;/h2&gt;&lt;p&gt;下面我们来简单了解下他是如何实现的，关键方法是VClientImpl的startIOUniformer方法，可以看出进行了存储路径映射，如在子进程当我们访问&lt;/p&gt;&lt;p&gt;/data/data/&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//com.xxx/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;com.xxx/&lt;/span&gt;&lt;span class=&quot;invisible&quot;/&gt;&lt;/a&gt;目录时会直接映射到io.virtualapp/virtual/data/user/0/&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//com.xxx&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;com.xxx&lt;/span&gt;&lt;span class=&quot;invisible&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;NativeEngine.redirectDirectory(&quot;/sys/class/net/wlan0/address&quot;, wifiMacAddressFile);
NativeEngine.redirectDirectory(&quot;/sys/class/net/eth0/address&quot;, wifiMacAddressFile);
NativeEngine.redirectDirectory(&quot;/sys/class/net/wifi/address&quot;, wifiMacAddressFile);

NativeEngine.redirectDirectory(&quot;/data/data/&quot; + info.packageName, info.dataDir);
NativeEngine.redirectDirectory(&quot;/data/user/0/&quot; + info.packageName, info.dataDir);
if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.N) {
    NativeEngine.redirectDirectory(&quot;/data/user_de/0/&quot; + info.packageName, info.dataDir);
}
String libPath = VEnvironment.getAppLibDirectory(info.packageName).getAbsolutePath();
String userLibPath = new File(VEnvironment.getUserSystemDirectory(userId), info.packageName + &quot;/lib&quot;).getAbsolutePath();
NativeEngine.redirectDirectory(userLibPath, libPath);
NativeEngine.redirectDirectory(&quot;/data/data/&quot; + info.packageName + &quot;/lib/&quot;, libPath);
NativeEngine.redirectDirectory(&quot;/data/user/0/&quot; + info.packageName + &quot;/lib/&quot;, libPath);  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该方法最终会调用IOUniformer.cpp的startUniformer方法&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;void IOUniformer::startUniformer(const char *so_path, int api_level, int preview_api_level) {

void *handle = dlopen(&quot;libc.so&quot;, RTLD_NOW);
if (handle) {
    HOOK_SYMBOL(handle, faccessat);
    HOOK_SYMBOL(handle, __openat);
    HOOK_SYMBOL(handle, fchmodat);
    HOOK_SYMBOL(handle, fchownat);
    HOOK_SYMBOL(handle, renameat);
    HOOK_SYMBOL(handle, fstatat64);
    HOOK_SYMBOL(handle, __statfs);
    HOOK_SYMBOL(handle, __statfs64);
    HOOK_SYMBOL(handle, mkdirat);
    HOOK_SYMBOL(handle, mknodat);
    HOOK_SYMBOL(handle, truncate);
    HOOK_SYMBOL(handle, linkat);
    HOOK_SYMBOL(handle, readlinkat);
    HOOK_SYMBOL(handle, unlinkat);
    HOOK_SYMBOL(handle, symlinkat);
    HOOK_SYMBOL(handle, utimensat);
    HOOK_SYMBOL(handle, __getcwd);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们知道android系统是基于Linux内核，文件读写操作也是间接的通过&lt;b&gt;库函数&lt;/b&gt;进行&lt;b&gt;系统调用&lt;/b&gt;，如我们在应用开发中使用的inputStream与outputStream进行文件读写最终也是调用libc.so库函数提供的方法。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-af6ab061854f8cba1aca0dd21788f9f5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;311&quot; data-rawheight=&quot;251&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;311&quot; data-rawheight=&quot;251&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-af6ab061854f8cba1aca0dd21788f9f5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;br/&gt;所以需要做到就是将libc库函数的方法进行Hook,将输入参数替换为我们的虚拟app路径，该过程即为native Hook。还有一个疑问点是我们怎么知道要hook哪些函数呢，只能通过查看libc的源码，当然源码也是公开的，可以直接查看如下地址。&lt;br/&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.androidos.net.cn/android/9.0.0_r8/xref/bionic/libc/bionic&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;androidos.net.cn/androi&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;d/9.0.0_r8/xref/bionic/libc/bionic&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;br/&gt;以faccessat方法为例，我们可以看到方法参数有个pathname我们需要将改方法参数替换掉，然后重新调用系统方法。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C&quot;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;___faccessat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;faccessat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dirfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pathname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// &quot;The mode specifies the accessibility check(s) to be performed,
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;c1&quot;&gt;// and is either the value F_OK, or a mask consisting of the
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;c1&quot;&gt;// bitwise OR of one or more of R_OK, W_OK, and X_OK.&quot;
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F_OK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_OK&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;W_OK&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X_OK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_OK&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;W_OK&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X_OK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;errno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EINVAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;br/&gt;具体实现&lt;/h2&gt;&lt;p&gt;&lt;br/&gt;经过上述步骤我们知道了，需要对libc链接库的方法进行hook,但是如何做到呢，这就不得不提Native Hook的具体实现了，Native Hook的实现方式有两种一个是&lt;b&gt;PLT Hook &lt;/b&gt;与 &lt;b&gt;Inline Hook，&lt;/b&gt;实现原理涉及so动态链接过程与ELF文件格式，汇编指令等，这块大家可以百度一下。而罗迪使用的是一个第三方开源项目&lt;b&gt;Cydia Substrate(&lt;/b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.cydiasubstrate.com/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;cydiasubstrate.com/&lt;/span&gt;&lt;span class=&quot;invisible&quot;/&gt;&lt;/a&gt;&lt;b&gt;)，&lt;/b&gt;该项目即是inline Hook的一种具体实现。爱奇艺开源的xHook则是PLT Hook方案的具体实现。与PLT Hook方案比较,inline Hook实用场景更广泛，能力更强大。而VirualAPP通过灵活的运用宏定义，Hook一个方法只需要两个步骤：&lt;br/&gt;&lt;br/&gt;1. Hook调用&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt; &lt;span class=&quot;n&quot;&gt;HOOK_SYMBOL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;faccessat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;br/&gt; 2. 定义替换的方法&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// int faccessat(int dirfd, const char *pathname, int mode, int flags);
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;n&quot;&gt;HOOK_DEF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;faccessat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dirfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pathname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;redirect_path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;relocate_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pathname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;syscall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__NR_faccessat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dirfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redirect_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;br/&gt;下面我们分析一下 HOOK_SYMBOL与HOOK_DEF宏展开过程&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#define HOOK_SYMBOL(handle, func) hook_function(handle, #func, (void*) new_##func, (void**) &amp;amp;orig_##func)
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#define HOOK_DEF(ret, func, ...) \
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;  static ret (*orig_##func)(__VA_ARGS__); \
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;  static ret new_##func(__VA_ARGS__)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;br/&gt;在编译期间会进行宏替换，HOOK_SYMBOL(handle, faccessat)最终替换为如下格式 ;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;n&quot;&gt;hook_function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;faccessat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_faccessat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;orig_faccessat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;br/&gt;HOOK_DEF最终会替换为如下格式：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;orig_faccessat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dirfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pathname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;new_faccessat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;faccessat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dirfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pathname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;redirect_path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;relocate_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pathname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;syscall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__NR_faccessat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dirfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redirect_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;br/&gt;可以看出通过宏替换，我们定义了一个函数指针，和一个newfaccessat的替换函数，最终调用hook_function方法实现Hook,hook_function内部调用&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.cydiasubstrate.com/api/c/MSHookFunction/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MSHookFunction&lt;/a&gt;函数，该函数即为Cydia Substrate提供的能力。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hook_function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;symbol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;old_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dlsym&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;symbol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;MSHookFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;old_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;相信大家对Native Hook在整体上有了初步的认识，学习Native Hook不能一蹴而就而是个缓慢的过程。后续文章为大家分享MSHookFunction的具体实现原理&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;  &lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>