<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>93e0bf10112e619a7cef478f25e43856</guid>
<title>左耳朵耗子：我做系统架构的一些原则</title>
<link>https://toutiao.io/k/9oljc6o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;作者&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;左耳朵耗子&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原文地址：&lt;/span&gt;&lt;span&gt;https://coolshell.cn/articles/21672.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;工作 20 多年了，这 20 来年看到了很多公司的很多的系统架构，也看到了很多问题，在跟这些公司进行交流和讨论的时候，包括进行实施和方案比较的时候，因为相关的经历越来越多，所以，逐渐形成了自己的逻辑和方法论。今天，想写下这篇文章，把我的这些个人的经验和想法总结下来，希望能够让更多的人可以参考和借鉴，并能够做出更好的架构来。另外，我的这些思维方式和原则都针对于现有市面上众多不合理的架构和方案，所以，也算是一种“纠正”……（注意，这篇文章所说的这些架构上的原则，一般适用于相对比较复杂的业务，如果只是一些简单和访问量不大的应用，那么你可能会得出相反的结论）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目录&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;原则一：关注于真正的收益而不是技术本身&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;对于软件架构来说，我觉得第一重要的是架构的收益，如果不说收益，只是为了技术而技术，而没有任何意义。对于技术收益来说，我觉得下面这几个收益是非常重要的：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;是否可以降低技术门槛加快整个团队的开发流程&lt;/span&gt;。能够加快整个团队的工程流程，快速发布，是软件工程一直在解决的问题，所以，系统架构需要能够进行并行开发，并行上线和并行运维，而不会让某个团队成为瓶颈点。（注：就算拖累团队的原因是组织构架，也不妨碍我们的系统架构设计）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;是否可以让整个系统可以运行的更稳定&lt;/span&gt;。要让整个系统可以运行的更为的稳定，提升整个系统的 SLA，就需要对有计划和无计划的停机做相应的解决方案（参看《关于高可用的架构》）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;是否可以通过简化和自动化降低成本&lt;/span&gt;。最高优化的成本是人力成本，人的成本除了慢，还有经常不断的 human error。如果不能降低人力成本，反而需要更多的人，那么这个架构设计一定是失败的。除此之外，是时间成本，资金成本。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;如果一个系统架构不能在上面三个事上起到作用，那就没有意义了。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;原则二：以应用服务和 API 为视角，而不是以资源和技术为视角&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;国内很多公司都会有很多分工，基本上都会分成运维和开发，运维又会分成基础运维和应用运维，开发则会分成基础核心开发和业务开发。不同的分工会导致完全不同的视角和出发点。比如，基础运维和开发的同学更多的只是关注资源的利用率和性能，而应用运维和业务开发则更多关注的是应用和服务上的东西。这两者本来相关无事，但是因为分布式架构的演进，导致有一些系统已经说不清楚是基础层的还是应用层的了，比如像服务治理上的东西，里面即有底层基础技术，也需要业务的同学来配合，包括 k8s 也样，里面即有底层的如网络这样的技术，也有需要业务配合的 readniess和 liveness 这样的健康检查，以及业务应用需要 configMap 等等 ……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些东西都让我感觉到所谓 DevOps，其实就是因为很多技术和组件已经分不清是 Dev 还是 Ops 的了，所以，需要合并Dev和Ops。而且，整个组织和架构的优化，已经不能通过调优单一分工或是单一组件能够有很大提升的了。其需要有一种自顶向下的，整体规划，统一设计的方式，才能做到整体的提升（可以试想一下城市交通的优化，当城市规模到一定程度的时候，整体的性能你是无法通过优化几条路或是几条街区来完成的，你需要对整个城市做整体的功能体的规划才可能达到整体效率的提升）。而为了做到整体的提升，需要所有的人都要有一个统一的视角和目标，这几年来，我觉得这个目标就是——&lt;span&gt;要站在服务和 对外API的视角来看问题，而不是技术和底层的角度。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;原则三：选择最主流和成熟的技术&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;技术选型是一件很重要的事，技术一旦选错，那会导致整个架构需要做调整，而对架构的调整重来都不是一件简单的事，我在过去几年内，当系统越来越复杂时让用户把他们的  PHP，Python, .NET，或 Node.js 的架构完全都迁移到 Java + Go 的架构上来。这个过程还是非常痛苦的，但是你没有办法，当你的系统越来越复杂，越来越大时，你就再也不能在一些玩具技术上玩了，你需要的工业级的技术。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;尽可能的使用更为成熟更为工业化的技术栈，而不是自己熟悉的技术栈&lt;/span&gt;。所谓工业化的技术栈，你可以看看大多数公司使用的技术栈，比如：互联网，金融，电信……等等 ，大公司会有更多的技术投入，也需要更大规模的生产，所以，他们使用的技术通常来说都是比较工业化的。在技术选型上，千万不要被——“你看某个公司也在用这个技术”，或是一些在论坛上看到的一些程序员吐槽的主论来决定自己的技术，还是看看主流大多数公司实际在用的技术栈，会更靠谱一些。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;选择全球流行的技术，而不是中国流行的技术&lt;/span&gt;。技术这个东西是一个全球化的东西，不是一个局域化的事。所以，一定要选国际化的会更好。另外，千万不要被某些公司的“特别案例”骗过去了，那怕这个案例很性感，关键还是要看解决问题的思路和采用的技术是否具有普世性。只有普世性的技术有更强的生命力。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;尽可能的使用红利大的主流技术，而不要自己发明轮子，更不要魔改&lt;/span&gt;。我见过好些个公司魔改开源软件，比如有个公司同魔改mesos，最后改着改着发现自己发明另一个 kubernetes。我还见过很多公司或技术团队喜欢自己发明自己的专用轮子，最后都会被主流开源软件所取代。完全没有必要。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;绝大多数情况下，如无特殊要求，选 Java基本是不会错的&lt;/span&gt;。一方面，这是因为 Java 的业务开发的生产力是非常好的，而且有 Spring 框架保障，代码很难写烂，另外，Java 的社区太成熟了，你需要的各种架构和技术都很容易做到。这种运行在JVM上的语言有太多太多的好处了。我见过很多使用 node.js + mongodb 或是 php/python/.NET 技术栈的公司，最终都会走向 Java。在 Java 的技术栈上，你的架构风险和架构的成本（无论是人力成本，时间成本和资金成本）从长期来说都是最优的&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在我见过的公司中，好些公司的架构都被技术负责人个人的喜好、擅长和个人经验给绑架了，完全不是从一个客观的角度来进行技术选型。其实，从 0 到 1 的阶段，你用什么样的技术都行，如果你做一个简单的应用，没有事务处理没有复杂的交易流程，比如一些论坛、社交之类的应用，你用任何语言都行。但是如果有一天你的系统变复杂了，需要处理交易了，量也上来了，你的开发团队也变大了，你会发现你只有一个选择，就是 Java。想想京东从.NET 到 Java，淘宝从 PHP 到 Java……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不重新发明轮子，不魔改，不是因为自己技术不能，而是因为，这个世界早已不是自己干所有事的年代了，这个时代是要想尽方法跟整个产业，整个技术社区融合和合作，这样才会有最大的收益。那些试图因为某个特例需要自成一套的玩法，短期没问题，但长期来说，我都不看好。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;原则四：完备性会比性能更重要&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;我发现好些公司的架构师做架构的时候，首要考虑的是架构的性能是否能够撑得住多大多大的流量，而不是考虑系统的完备性和扩展性。所以，我已经多次见过这样的案例了，一开始直接使用 MongoDB 这样的非关系型数据库，或是把数据直接放在 Redis 里，而直接放弃关系型数据库的数据完备性的模型，而在后来需要在数据上进行关系查询的时候，发现 NoSQL 的数据库在 Join 上都表现的太差，然后就开始各种飞线，为了不做 Join 就开始冗余数据，然而自己又维护不好冗余数据后带来的数据一致性的问题，导致数据上的各种错乱丢失。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，我给如下的一些如下的架构原则：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;使用最科学严谨的技术模型为主，并以不严谨的模型作为补充&lt;/span&gt;。对于上面那个案例来说，就是——永远使用完备支持 ACID 的关系型数据库，然后用 NoSQL 作补充，而不是完全放弃关系型数据库。这里的原则就是所谓的“先紧后松”，一开始紧了，你可以慢慢松，但是开始松了，以后你就再也紧不过来了。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;性能上的东西，总是有很多解的&lt;/span&gt;。我这么多年的经历告诉我，性能上的事，总是有解的，手段也是最多的，这个比起架构的完备性和扩展性来说真的不必太过担心。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;原则五：制定并遵循符从标准、规范和最佳实践&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;这个原则是非常重要的，因为只有符从了标准，你的架构才能够有更好的扩展性。比如：我经常性的见到很多公司的系统既没有符从业界标准，也没有形成自己公司的标准，感觉就像一群乌合之众一样。最典型的例子就是 HTTP 调用的状态返回码。业内给你的标准是 200表示成功，3xx 跳转，4xx 表示调用端出错，5xx 表示服务端出错，我实在是不明白为什么无论成功和失败大家都喜欢返回 200，然后在 body 里指出是否error（前两年我在微信公众号里看到一个有一定名气的互联网老兵推荐使用无论正确还是出错都返回 200 的做法，我在后台再三确认后，我发现这样的架构师真是害人不浅）。这样做最大的问题是——监控系统将在一种低效的状态下工作。监控系统需要把所有的网络请求包打开后才知道是否是错误，而且完全不知道是调用端出错还是服务端出错，于是一些像重试或熔断这样的控制系统完全不知道怎么搞（如果是 4xx错是没有重试或熔断的意义的，只有 5xx 才有意义）。有时候，我会有种越活越退步的感觉，错误码设计这种最基本最基础的东西为什么会没有？并且会随着大家乱来？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还有，我还见过一些公司，他们整个组织没有一个统一的用户 ID 的设计，各个系统之间同步用户的数据是通过用户的身份证 ID，是的，就是现实世界的身份证 ID，包括在网关上设置的用户白名单居然也是用身份证 ID。我对这个公司的内的用户隐私管理有很大的担忧。一个企业，一个组织，如果没有标准和规范，一定是要出各种乱子的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面，我罗列一些你需要注意的标准和规范（包括但不限于）：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;服务间调用的协议标准和规范&lt;/span&gt;。这其中包括 Restful API路径, HTTP 方法、状态码、标准头、自定义头等，返回数据 JSon Scheme……等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;一些命名的标准和规范&lt;/span&gt;。这其中包括如：用户 ID，服务名、标签名、状态名、错误码、消息、数据库……等等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;日志和监控的规范&lt;/span&gt;。这其中包括：日志格式，监控数据，采样要求，报警……等等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;配置上的规范&lt;/span&gt;。这其中包括：操作系统配置、中间件配置，软件包……等等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;中间件使用的规范&lt;/span&gt;。数据库，缓存、消息队列……等等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;软件和开发库版本统一&lt;/span&gt;。整个组织架构内，软件或开发库的版本最好每年都升一次级，然后在各团队内统一。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;这里重要说两个事：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Restful API 的规范，我觉得是非常重要的，这里给两个我觉得写得最好的参考：Paypal 和 Microsoft 。Restful API 有一个标准和规范最大的好处就是监视可以很容易地做各种统计分析，控制系统可以很容器的做流量编排和调度。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;另一个是服务调用链追踪。对于服务调用链追踪来说，基本上都是参考于 Google Dapper 这篇论文，目前有很多的实现，最严格的实现是 Zipkin，这也是 Spring Cloud Sleuth 的底层实现。Zipkin 贴近 Google Dapper 论文的好处在于——无状态，快速地把 Span 发出来，不消耗服务应用侧的内存和 CPU。这意味着，监控系统宁可自己死了也不能干扰实际应用。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;原则六：重视架构扩展性和可运维性&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;我见过很多架构，技术人员只考虑当下，但从来不考虑系统的未来扩展性和可运维性。所谓的管生不管养。如果你生下来的孩子胳膊少腿，严重畸形，那么未来是很难玩的。因为架构不是和软件不是写好就完的，是需要不断修改不断维护的，80%的软件成本都是在维护上。所以，如何让你的架构有更好的扩展性，可以更容易地运维，这个是比较重要的。所谓的扩展性，意味着，我可以很容易地加更多的功能，或是加入更多的系统，而所谓可运维，就是说我可以对线上的系统做任意的变更。扩展性要求的是有标准规范且不耦合的业务架构，可运维性要求的则是可控的能力，也就是一组各式各样的控制系统。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;通过服务编排架构来降低服务音的耦合&lt;/span&gt;。比如：通过一个业务流程的专用服务，或是像 Workflow，Event Driven Architecture ， Broker，Gateway，Service Discovery 等这类的的中间件来降低服务间的依赖关系。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;通过服务发现或服务网关来降低服务依赖所带来的运维复杂度&lt;/span&gt;。服务发现可以很好的降低相关依赖服务的运，维复杂度，让你可以很轻松的上线或下线服务，或是进行服务伸缩。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;一定要使用各种软件设计的原则&lt;/span&gt;。比如：像SOLID这样的原则（参看《一些软件设计的原则》），IoC/DIP，SOA 或 Spring Cloud 等 架构的最佳实践（参看《SteveY对Amazon和Google平台的吐槽》中的 Service Interface 的那几条军规），分布式系统架构的相关实践（参看：《分布式系统的事务处理》，或微软件的 《Cloud Design Patterns》）……等等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;原则七：对控制逻辑进行全面收口&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;所有的程序都会有两种逻辑，一种是业务逻辑，一种是控制逻辑，业务逻辑就是完成业务的逻辑，控制逻辑是辅助，比如你用多线程，还是用分布式，是用数据库还是用文件，如何配置、部署，运维、监控，事务控制，服务发现，弹性伸缩，灰度发布，高并发，等等，等等 ……这些都是控制逻辑，跟业务逻辑没有一毛钱关系。控制逻辑的技术深度会通常会比业务逻辑要深一些，门槛也会要高一些，所以，最好要专业的程序员来负责控制逻辑的开发，统一规划统一管理，进行收口。这其中包括：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;流量收口&lt;/span&gt;。包括南北向和东西向的流量的调度，主要通过流量网关。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;服务治理收口&lt;/span&gt;。包括：服务发现、健康检查，配置管理、事务、事件、重试、熔断、限流……主要通过开发框架 SDK – 如：Spring Cloud，或服务网格Service Mesh等技术。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;监控数据收口&lt;/span&gt;。包括：日志、指标、调用链……主要通过一些标准主流的探针，再加上后台的数据清洗和数据存储来完成，最好是使用无侵入式的技术。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;资源调度有应用部署的收口&lt;/span&gt;。包括：计算、网络和存储的收口，主要是通过容器化的方案，如k8s来完成。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;中间件的收口&lt;/span&gt;。包括：数据库，消息，缓存，服务发现，网关……等等。这类的收口方式一般要在企业内部统一建立一个共享的云化的中间件资源池。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;对此，这里的原则是：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;你要选择容器进行业务逻辑和控制逻辑分离的技术&lt;/span&gt;。这里，Java 的 JVM+字节码注入+AOP 式的Spring 开发框架，会带给你太多的优势。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;你要选择可以享受“前人种树，后人乘凉”的有技术红利的技术&lt;/span&gt;。如：有庞大社区而且相互兼容的技术，如：Java, Docker,  Ansible，HTTP，Telegraf/Collectd……&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;中间件你要使用可以 支持HA集群和多租户的技术&lt;/span&gt;。这里基本上所有的主流中间件都会支持 HA 集群方式的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;原则八：不要迁就老旧系统的技术债务&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;我发现很多公司都很非常大的技术债务，这些债务具体表现如下：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;使用老旧的技术&lt;/span&gt;。比如，使用HTTP1.0， Java 1.6，Websphere，ESB，基于 socket的通讯协议，过时的模型……等等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;不合理的设计&lt;/span&gt;。比如，在 gateway 中写大量的业务逻辑，单体架构，数据和业务逻辑深度耦合，错误的系统架构（把缓存当数据库，用消息队列同步数据）……等等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;span&gt;缺少配套设施&lt;/span&gt;。比如，没有自动化测试，没有好的软件文档，没有质量好的代码，没有标准和规范……等等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;来找我寻求技术帮助的人都有各种各样的问题。我都会对他们苦口婆心地说同样的一句话——“&lt;span&gt;如果你是来找我 case-by-case 解决问题，我毫无兴趣，因为，你们千万不要寄希望能够很简单的把一辆夏利车改成一辆跑车，或是把一栋地基没打好的歪楼搞正。以前欠下的技术债，都得要还，没打好的地基要重新打，没建配套设施都要建。这些基础设施如果不按照正确科学的方式建立的话，你是不可能有一个好的的系统……&lt;/span&gt;”，一开始，他们都会对我说，没问题，我们就是要还债，但是，最后发现要还的债真我，就开始现原现了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;他们开始为自己的“欠的技术债”找各种合理化的理由——他们会给你解释各种各样的历史原因。谈着谈着，让我有一种感觉——他们希望得到一种什么都不改什么都不付出的方式就可以进步的心态，他们宁可让新的技术 low 下来迁就于这些技术债，把新的技术滥用地乱七八糟的。有一个公司，他们的系统架构和技术选型基本都搞错了，使用错误的模型构建系统，导致整个系统的性能非常之差，也才几千万条数据，但他们想的不是还债，不是把地基和配套设施建好，而且要把楼修的更高，上更多的系统——他们觉得更有的系统很好，问题是他们没一个大数据平台，所以要建大数据平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我见过很多很多公司，包括大如 BAT 这样的公司，都会在原来的技术债上进行更多的建设，然后，技术债越来越大，利息越来越大，最终成为一个高利贷，再也还不了（我在《开发团队的效率》一文中讲过一个 WatchDog 的架构模式，一个系统烂了，不是去改这个系统，而是在旁边建一个系统来看着它，我很难理解为什么会有这样的逻辑，也许是为了要解决更多的就业……）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里有几个原则和方法我是非常坚持的，分享给大家：&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;原则九：不要依赖自己的经验，要依赖于数据和学习&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;有好些人来找我跟我说他们的技术问题，然后希望我能够给他们一个答案。我说，我需要了解一下你现有系统的情况，也就是需要先做个诊断，我只有得到这些数据后，我才可能明白真正的原因是什么 ，我才可能给你做出一个比较好的技术方案。我个人觉得这是一种对对方负责的方法，因为技术手段太多了，所有的技术手段都有适应的场景，并且有各种 trade-off，所以，只有调研完后才能做出决定。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，如果有一天你在做技术决定的时候，开始凭自己以往的经验，那么你就已经不可能再成长了。人都是不可能通过不断重复过去而进步的，人的进步从来都是通过学习自己不知道的东西。所以，千万不要依赖于自己的经验做决定。做任何决定之前，最好花上一点时间，上网查一下相关的资料，技术博客，文章，论文等 ，同时，也看看各各公司，或是各个开源软件他们是怎么做的？然后，比较多种方案的 Pros/Cons，最终形成自己的决定，这样，才可能做出一个更好的决定。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;原则十：千万要小心 X – Y  问题&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;对于 X-Y 问题，也就是说，用户为了解决 X问题，他觉得用 Y 可以解，于是问我 Y 怎么搞，结果搞到最后，发现原来要解决的 X 问题，这个时候最好的解决方案不是 Y，而是 Z。这种 X-Y 问题真是相当之多，见的太多太多了。所以，每次用户来找我的时候，我都要不断地追问什么是 X 问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如，一个用户问我来建大数据平台的事，结果经过一番追问，我才明白他们的问题是因为现有的系统处理数据的太慢，所以，他们觉得应该用大数据平台来解决，但在了解完数据量后，我发现这个数据量也就千万级别，完全没有必要建大数据平台，于是对现有系统做了些性能优化，换了几个算法就好了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，还有个客户来找我评估的一个技术架构的决定，从理论上来说，好像这个架构在用户的这个场景下非常不错。但是，这个场景和这个架构是我职业生涯从来没有见过的。于是，我开始追问这个为什么会是这么一个场景？当我追问的时候，我发现用户都感到这个场景的各种不合理。最后引起了大家非常深刻的研论，最终用户把那个场景修正后，而架构就突然就变成了一个常见且成熟的的模型……&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;原则十一：激进胜于保守，创新与实用并不冲突&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;我对技术的态度是比较激进的，但是，所谓的激进并不是瞎搞，也不是见新技术就上，而是积极拥抱会改变未来的新技术，如：Docker/Go，我就非常快地跟进，但是像区块链或是 Rust 这样的，我就不是很积极。因为，其并没有命中我认为的技术趋势的几个特征（参看《Go,Docker 和新技术 》）。当然，我也尊重保守的决定，这里面没有对和错。但是，我个人觉得对技术激进的态度比起保守来说有太多的好处了。一方面来说，对于用户来说，很大程度上来说，新技术通常都表面有很好的竞争力，而且我见太多这样成功的公司都在积极拥抱新的技术的，而保守的通常来说都越来越不好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有一些人会跟我说，我们是实用主义，我们不需要创新，能解决当下的问题就好，所以，我们不需要新技术，更有的技术用好就行了。这类的公司，他们的技术设计第一天就在负债，虽然可以解决当下问题，但是马上就会出现新的问题，然后他们会疲于解决各种问题。最后呢，最后还是会走到新的技术上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里的逻辑很简单 —— &lt;span&gt;进步永远来自于探索，探索是要付出代价的，但是收益更大&lt;/span&gt;。对我而言，不敢冒险才是最大的冒险，不敢犯错才是最大的错误，害怕失去会让你失去的更多…&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;加入读者群，请在公众号后台回复：读者群&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;往期推荐：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;资料获取&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 识别并关注下方公众号；&lt;br/&gt;2. 在下面公众号后台回复关键字「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;设计模式&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」即可下载。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIxMzEzMjM5NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/nhlGsolibOWF3auwD2unWLZHOt6TeCJ1iboL4Po7ickwKsibk7WgicbkOxG7wibMw8ZsSMQtDpR9D3OsF2RKibxKN00Xg/0?wx_fmt=png&quot; data-nickname=&quot;技术琐话&quot; data-alias=&quot;TheoryPractice&quot; data-signature=&quot;最干货的java+分布式技术公众号，兼及研发管理。本号专家阵容：蚂蚁金服右军、NETSTARS CTO陈斌、江苏百瑞赢李伟山、前蚂蚁金服高级技术专家张翔、美团高级技术专家杨彪等。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;br/&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bf7d9985820a1129513cf57db6d376cc</guid>
<title>如何做好“防御性编码”？</title>
<link>https://toutiao.io/k/sbezmqa</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;article data-clipboard-cangjie=&quot;[&amp;quot;root&amp;quot;,{},[&amp;quot;h1&amp;quot;,{&amp;quot;spacing&amp;quot;:{&amp;quot;before&amp;quot;:14.666666666666668,&amp;quot;after&amp;quot;:14.666666666666668,&amp;quot;line&amp;quot;:0.8529411764705882}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:true,&amp;quot;sz&amp;quot;:20,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;防御性编码的意义&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;类似于“防御性驾驶”对驾驶安全的重要性，防御性编码 目的概括起来就一条：将代码质量问题消灭于萌芽。要做到“防御性编码”，就要求我们充分认识到代码质量的严肃性，也就是“一旦你觉得这个地方可能出问题，那基本它就会（在某个时刻）出问题”。当然，实际情况比这个更严峻。由于大家的编码经验和风格差异，导致大家的意识边界是大小不一的，那些潜伏在意识边界之外的“危险”更加隐蔽和不可琢磨。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;firstLine&amp;quot;:32}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;在意识层面上，我们当然要摒弃“想当然”和“差不多”的错误思想，严肃评估这些问题发生的可能性，认真对待这些风险。但如若话题止步于此，那其实还是缺乏执行层面的指导意义的，激不起半点“涟漪”的。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;这个文章目的也更多是关注到“实操层面”的引导。&amp;quot;]]],[&amp;quot;h1&amp;quot;,{&amp;quot;ind&amp;quot;:{},&amp;quot;spacing&amp;quot;:{&amp;quot;before&amp;quot;:14.666666666666668,&amp;quot;after&amp;quot;:14.666666666666668,&amp;quot;line&amp;quot;:0.8529411764705882}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:true,&amp;quot;sz&amp;quot;:20,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;如何防御性编码？&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;以下需关注的具体方面更多来自于我的习惯和观察，并且统一用伪代码作问题示例。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;highlight&amp;quot;:&amp;quot;#92D04F&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;欢迎大家把自己的“防御性编码心得”在评论区分享出来，我再做统一收编汇总。&amp;quot;]]],[&amp;quot;h2&amp;quot;,{&amp;quot;spacing&amp;quot;:{&amp;quot;before&amp;quot;:14.666666666666668,&amp;quot;after&amp;quot;:14.666666666666668,&amp;quot;line&amp;quot;:0.8529411764705882}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:true,&amp;quot;sz&amp;quot;:16,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;并发冲突问题&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;这个问题在实际项目中，被错误地忽视的比例相当高。它的外在表现形式五花八门，但关键点是：“当你的代码被并发调用时，它会怎么表现？” &amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;我们心里要有个运行时的世界观，代码运行的Context是这样的：多线程 -&amp;gt;多进程 -&amp;gt; 多机器 -&amp;gt; 多集群。我们编码时，要充分考虑代码在上述世界观多点并发的可能性，及相应的潜在后果。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;举几个具体的问题例子)：&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false,&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;siop7plewxp&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:false,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;SCIR_ECIR_SREC&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;bullet&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;●&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;存在共享变量 或者 数据。（不限于堆内存，也可能是缓存、DB、文件等）&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;例子1：&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(85, 85, 85)&amp;quot;,&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;有线程 A 和线程 B 两个线程，需要更新「同一条」数据，会发生这样的场景：&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:32},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(85, 85, 85)&amp;quot;,&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;1. 线程 A 更新数据库（X = 1）&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:32},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(85, 85, 85)&amp;quot;,&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;2. 线程 B 更新数据库（X = 2）&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:32},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(85, 85, 85)&amp;quot;,&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;3. 线程 B 更新缓存（X = 2）&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:32},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(85, 85, 85)&amp;quot;,&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;4. 线程 A 更新缓存（X = 1）&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(85, 85, 85)&amp;quot;,&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;最终 X 的值在缓存中是 1，在数据库中是 2，发生不一致。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(85, 85, 85)&amp;quot;,&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(85, 85, 85)&amp;quot;,&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;例子2：&amp;quot;]]],[&amp;quot;code&amp;quot;,{&amp;quot;syntax&amp;quot;:&amp;quot;plaintext&amp;quot;,&amp;quot;theme&amp;quot;:&amp;quot;default&amp;quot;,&amp;quot;height&amp;quot;:null,&amp;quot;id&amp;quot;:&amp;quot;hzx0hn&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;// 某个 Spring singleton Bean &#x27;aService&#x27; 存在一个调用来源标记，记录调用来源是HSF还是HTTP。\n// 先 记录来源标记。\naService.setSource(source);\n// 再结合source执行其他逻辑。例如将上面记录的source 和 其他参数 插入数据库.\naService.doSomethings(params);&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;如果这个代码被 HSF和 HTTP 同时调用就会发生问题。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;例子3 （20220418更新）:&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;在一个系统中，有两个价格类型 small 和 large，业务逻辑要求 small &amp;lt;= large，且 small 和 large 有2个入口可以分别修改。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;目前方案是：对要改变的small或large，增加上面大小关系校验，不通过则拦截，例如 改动small的入口上，校验改后的small &amp;lt;= 系统里的large，不通过则不允许修改。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;假如，最新需求要求：修改large的入口继续拦截，但修改small的入口不再拦截，而是发现如果改后small &amp;gt; 系统的large，则将 系统large = 改后的small+0.1，让 约束关系继续成立。 这种改法有问题吗？&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;答案：这种改法会有问题。即 small这个价格类型存有两个链路同时修改，也是一种并发冲突问题。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;举个具体例子：&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:32},&amp;quot;blockquote&amp;quot;:false,&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;rtco849h1na&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:false,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;EREC_EREC_EREC&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;bullet&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;❏&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;初始时，系统的small = 2; large = 2;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:32},&amp;quot;blockquote&amp;quot;:false,&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;rtco849h1na&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:false,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;isChecked&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;EREC_EREC_EREC&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;bullet&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;❏&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false,&amp;quot;extraData&amp;quot;:{}}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;修改large 链路1：准备将 large 改为 3，检查规则 3(改后large ) &amp;gt;= 2(系统small) 通过。准备写入新的large (3)。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:32},&amp;quot;blockquote&amp;quot;:false,&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;rtco849h1na&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:false,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;isChecked&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;EREC_EREC_EREC&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;bullet&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;❏&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false,&amp;quot;extraData&amp;quot;:{}}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;修改small 链路2：准备降 small 改为 4, 发现  4（改后small）&amp;gt; 2(系统large) 不符合规则，则 准备 自动修改 large = 4（改后small）+ 0.1 = 4.1。准备写入 改后small = 4，自动改后 large = 4.1；&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:32},&amp;quot;blockquote&amp;quot;:false,&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;rtco849h1na&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:false,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;isChecked&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;EREC_EREC_EREC&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;bullet&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;❏&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false,&amp;quot;extraData&amp;quot;:{}}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;如果 链路2 最终先完成写入，链路1再完成写入。则 链路2写入的 large=4.1 会被链路1 写入的large=3 覆盖。最终系统 large =3，而 系统small = 4；破坏了最初的small &amp;lt;= large 的约束。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false,&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;qzl631dokq&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:false,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;SCIR_ECIR_SREC&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;bullet&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;●&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;未考虑集群并发&amp;quot;]]],[&amp;quot;code&amp;quot;,{&amp;quot;syntax&amp;quot;:&amp;quot;plaintext&amp;quot;,&amp;quot;theme&amp;quot;:&amp;quot;default&amp;quot;,&amp;quot;height&amp;quot;:null,&amp;quot;id&amp;quot;:&amp;quot;nk5fpx&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;// 在短信发送服务中，控制对用户的发送频率\ntimestamp = rateLimitService.getMsgTimestamp(userId);\nif( timestamp == null ){\n\trateLimitService.putMsgTimestamp(userId, now);\n  sendMsg(msg);\n}else if( timestamp - now &amp;gt; 1 hour ){\n\trateLimitService.putMsgTimestamp(userId, now);\n  sendMsg(msg);\n}&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;这个例子在单机环境执行时没有问题，但线上集群多节点的话，那发送频率的控制就不对了。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0,&amp;quot;firstLine&amp;quot;:32},&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false,&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;siop7plewxp&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:false,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;SCIR_ECIR_SREC&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;bullet&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;●&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false,&amp;quot;extraData&amp;quot;:{},&amp;quot;isChecked&amp;quot;:false}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;非原子操作问题。&amp;quot;]]],[&amp;quot;code&amp;quot;,{&amp;quot;syntax&amp;quot;:&amp;quot;plaintext&amp;quot;,&amp;quot;theme&amp;quot;:&amp;quot;default&amp;quot;,&amp;quot;height&amp;quot;:null,&amp;quot;id&amp;quot;:&amp;quot;s95ieo&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;// 先查询是否存在目标记录\nresultList = dbRepo.list(query);\n// 有结果就更新，没有就插入\nif( resultList.size() &amp;gt; 0 ){\n\tdbRepo.update(xxxx);\n} else {\n\tdbRepo.insert(xxxx);\n}&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;如果这个代码被多个request 同时执行也会发生问题。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;nh8m7cnbrte&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:false,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;SCIR_ECIR_SREC&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;bullet&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;●&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;错误的发生并发&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;单个任务周期性的触发，本来不会有并发问题。但因单次执行时间变长，导致先后两次执行时间出现重叠。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;h2&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;spacing&amp;quot;:{&amp;quot;before&amp;quot;:14.666666666666668,&amp;quot;after&amp;quot;:14.666666666666668,&amp;quot;line&amp;quot;:0.8529411764705882}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:true,&amp;quot;sz&amp;quot;:16,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;事务问题&amp;quot;]]],[&amp;quot;p&amp;quot;,{},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;对于 先A再B后C的这类组合操作，要仔细考虑保障一致性的必要性，做好是否做事务保障的评估。&amp;quot;]]],[&amp;quot;p&amp;quot;,{},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;事务即要求：对一组的operation combo，要保障好执行顺序，保障好context的一致性，保障好结果的一致性。&amp;quot;]]],[&amp;quot;p&amp;quot;,{},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;nh8m7cnbrte&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:false,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;SCIR_ECIR_SREC&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;bullet&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;●&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false},&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;数据库事务。 发生概率不高，大多会主动预防。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;这个问题发生概率倒不高，也比较容易解决。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;但要注意，事务执行耗时不要太久，以及避免死锁问题发生。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;nh8m7cnbrte&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:false,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;isChecked&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;SCIR_ECIR_SREC&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;bullet&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;●&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false,&amp;quot;extraData&amp;quot;:{}}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;上下文一致性问题。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;以上传并处理Excel文件为例，假如实现分为 2 步：&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;1. 前端调用后端API，上传文件到Server的某个临时目录。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;2. 前端 在上传完成时，调用后端另一个API，通知 后端处理此文件。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;这个例子在集群环境中就会出现概率性成功或失败的情况，集群节点数量越多，失败概率越高。这是因为 前端的前后两次请求调用到了不同节点上，执行上下文出现了不一致。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;nh8m7cnbrte&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:false,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;isChecked&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;SCIR_ECIR_SREC&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;bullet&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;●&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false,&amp;quot;extraData&amp;quot;:{}}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;顺序一致性问题。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;常见的，例如对于 ECS运行状态的时序消息，如果下游消费者不是顺序消费，而是并行消费，就可能导致最终记录的状态 与实际不符。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;h2&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false,&amp;quot;spacing&amp;quot;:{&amp;quot;before&amp;quot;:14.666666666666668,&amp;quot;after&amp;quot;:14.666666666666668,&amp;quot;line&amp;quot;:0.8529411764705882}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:true,&amp;quot;sz&amp;quot;:16,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;分布式锁问题&amp;quot;]]],[&amp;quot;p&amp;quot;,{},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;分布式锁日常也经常用到，在使用细节上存在一些容易忽略的盲点。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;z9u8dgw1h8n&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:false,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;isChecked&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;SCIR_ECIR_SREC&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;bullet&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;●&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false,&amp;quot;extraData&amp;quot;:{}}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;获取锁&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;1. 是 阻塞式等待锁，还是 等不到锁重试，还是等不到锁直接返回。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;   这个层面主要考量点，这个调用链路对时间和成功率要求是什么。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;   例如，上游是用户操作，那肯定不能阻塞在等锁那里太久；&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;2. 锁的key设计很关键。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;   合理设计lock key，能够降低锁碰撞的概率。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;   例如，你的lock 是加在一个BU层面上，还是加到某个人身上，那冲突概率显然差别很大。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;3. 对于 持久锁，在循环执行业务逻辑时，要做好锁的状态检查。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;    RLock lock = redisson.getLock(lock);&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;    lock.lock(-1L, TimeUnit.MINUTES);&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;    // 获取到锁就持久占有，避免反复切换&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;    while( !isStopped ){&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;         if( lock.isHeldByCurrentThread() ){&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;              // do some work&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;         }else{&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;              // try to acquire lock again. &amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;         }&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;         SleepUtil.sleep(loopInterval, TimeUnit.MINUTES);&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;    }&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;4. 能用本地锁 不用全局锁。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;z9u8dgw1h8n&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:false,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;isChecked&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;SCIR_ECIR_SREC&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;bullet&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;●&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false,&amp;quot;extraData&amp;quot;:{}}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;锁超时&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;1.  合理设置锁的TTL，结合自己业务场景做取舍&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;    例如，加锁之后执行大量数据的batch计算的场景。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;    如果锁TTL太长，那计算被异常中断（如机器重启）时，这个长TTL内是无法被其他节点/线程获取到执行权限的；但如果TTL设置太短，那可能还没等执行完成，锁就被意外抢走了。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;2. 注意watchDog机制&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;    像Redisson之类的会有锁的watchdog，超过设置或默认的时间，锁就被偷偷释放了。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;z9u8dgw1h8n&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:false,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;isChecked&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;SCIR_ECIR_SREC&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;bullet&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;●&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false,&amp;quot;extraData&amp;quot;:{}}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;释放锁&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;1. 非必要情况下，避免强行释放锁，要检查锁的持有人是否是自己。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;2. 对于没有TTL的锁，要考虑极端情况下（进程被强制杀死、机器重启）的锁状态管理。否则意外一旦出现，锁就永远丢失了。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;h2&amp;quot;,{&amp;quot;blockquote&amp;quot;:false,&amp;quot;spacing&amp;quot;:{&amp;quot;before&amp;quot;:14.666666666666668,&amp;quot;after&amp;quot;:14.666666666666668,&amp;quot;line&amp;quot;:0.8529411764705882}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:true,&amp;quot;sz&amp;quot;:16,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;缓存问题&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;93039d4leum&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:false,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;SCIR_ECIR_SREC&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;bullet&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;●&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false},&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;缓存穿透问题&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(33, 37, 41)&amp;quot;,&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;缓存和数据库都没有的数据，但被大量请求，导致DB压力过大。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(33, 37, 41)&amp;quot;,&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;常见的解决方式：对空值也进行缓存，但TTL设置相对较短。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(33, 37, 41)&amp;quot;,&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;93039d4leum&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:false,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;isChecked&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;SCIR_ECIR_SREC&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;bullet&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;●&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false,&amp;quot;extraData&amp;quot;:{}},&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;缓存击穿问题&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;一般是缓存的热点key发生过期失效，此时大量请求透过缓存 击中DB，导致DB压力过大。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;常见解决方式：缓存查询miss时，设置个互斥锁，只允许一个request真实请求DB和重写缓存，避免大量请求涌入。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;93039d4leum&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:false,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;isChecked&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;SCIR_ECIR_SREC&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;bullet&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;●&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false,&amp;quot;extraData&amp;quot;:{}},&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;缓存雪崩问题&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(33, 37, 41)&amp;quot;,&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;缓存中的大量数据在较短的时间段内集中过期。一般发生在流量一波波来，缓存创建时间和TTL很接近。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(33, 37, 41)&amp;quot;,&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;常见解决方案：在TTL设置上不是一刀切，而是在一个合理范围内随机浮动，避免缓存集中失效。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(33, 37, 41)&amp;quot;,&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;93039d4leum&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:false,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;isChecked&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;SCIR_ECIR_SREC&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;bullet&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;●&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false,&amp;quot;extraData&amp;quot;:{}},&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;缓存的一致性&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;一般情况下，一致性要求不会非常严格。但如果需要强一致性保障时，要考虑缓存和DB之间的数据强一致性。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;一种可能的方案：只在写DB时才写缓存，读DB操作不写缓存。DB和缓存的写操作要加锁，避免并发问题。具体流程如下：&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;当写DB请求发生时：&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;1. 删除 缓存。此时读操作缓存会miss，读取到DB中的老值。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;2. 写入DB。此时读操作缓存会miss，读取到DB中的新值。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;3. 写入缓存。此时读操作缓存会 hit，读取到缓存中的新值（与DB新值一致）。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;需要注意的是：&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;1. 缓存针对数据库所有的数据记录，可能导致缓存空间占用高，实际利用率却不高。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;2. 如果某个缓存key 是热点，或者 流量比较大，尽管缓存“删除-重写入”间隔短，依然可能会引发 缓存击穿问题。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;3. 如果缓存写入失败，需要有相应的补偿机制再写入，且需关注 补偿写入与其他正常写入的冲突和时序问题。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;93039d4leum&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:false,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;isChecked&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;SCIR_ECIR_SREC&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;bullet&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;●&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false,&amp;quot;extraData&amp;quot;:{}},&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;缓存命中率&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;这个本身不是问题，但命中率低说明缓存的设计或使用存在问题，需要重新设计。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;93039d4leum&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:false,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;isChecked&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;SCIR_ECIR_SREC&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;bullet&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;●&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false,&amp;quot;extraData&amp;quot;:{}},&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;热点key问题&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;如果特定缓存节点CPU使用率远高于其他节点，说明可能存在热点key。这个时候需要合理对缓存key做拆分，将流量进一步打散。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;h2&amp;quot;,{&amp;quot;spacing&amp;quot;:{&amp;quot;before&amp;quot;:14.666666666666668,&amp;quot;after&amp;quot;:14.666666666666668,&amp;quot;line&amp;quot;:0.8529411764705882}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:true,&amp;quot;sz&amp;quot;:16,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;失败处理问题&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;这类问题虽属于低级问题，但往往比较隐蔽。在异常发生时，选择相应处理action时，我们要头脑非常清醒。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:false,&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;se5f0xka8n&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:false,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;SCIR_ECIR_SREC&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;bullet&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;●&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false},&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;失败处理&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:true,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;可能的处理方式：&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:true,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;1. &amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(77, 77, 77)&amp;quot;,&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;failover。失败立即重试。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:true,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;2. failback。记录失败，后置处理。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:true,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;3. failfast。直接失败，返回异常。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:true,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;4. failsafe。忽略失败，继续流程。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:true,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:true,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;这里不在于选择那种处理方式，而是要&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:true,&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;“头脑清醒”&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;的结合自己场景需求做出选择。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:false,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:false,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;pwer32ngn6&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:false,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;SCIR_ECIR_SREC&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{&amp;quot;sz&amp;quot;:11},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;bullet&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;●&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;注意默认值&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:false,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;一些情况下，我们会初始化时设定一些默认值、默认状态等，对于这些情况要充分考虑异常发生时是否存在风险。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:true,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;例如，在最开始时，代码里配置了当时的开城信息，但这个状态并没有跟业务操作流程打通，也就是没有办法做到及时更新。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:true,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;那随着时间发展，开发了新的城市，那就可能产生问题。&amp;quot;]]],[&amp;quot;p&amp;quot;,{},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;h2&amp;quot;,{&amp;quot;spacing&amp;quot;:{&amp;quot;before&amp;quot;:14.666666666666668,&amp;quot;after&amp;quot;:14.666666666666668,&amp;quot;line&amp;quot;:0.8529411764705882}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:true,&amp;quot;sz&amp;quot;:16,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;switch配置问题&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;8019pv7xjue&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:false,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;SCIR_ECIR_SREC&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;bullet&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;●&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false},&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;分批推送的时间间隔&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;switch发布时，不同批次会有时间间隔，大部分场景下都可以容忍这个时间间隔。但个别情况下，可能引发诸如数据不一致等问题。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;再使用switch时需要对这个问题做提前考虑，若不能容忍这种情况，那需要更换其他方案。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;8019pv7xjue&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:false,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;isChecked&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;SCIR_ECIR_SREC&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;bullet&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;●&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false,&amp;quot;extraData&amp;quot;:{}},&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;内存值与持久值&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;switch的逻辑是这样：&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;1. switch会默认记录代码中的默认值。此时并不是 &amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:true,&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;持久值&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;2. 当在代码中修改默认值时，switch平台也会显示代码默认值。此时也并不是&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:true,&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot; 持久值&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;3. 只有在switch平台修改值并推送成功，swith平台会保存&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:true,&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;持久值&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;4. switch保存&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:true,&amp;quot;sz&amp;quot;:11,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;持久值&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;之后，不管代码修改默认值还是去掉 @AppSwitch 配置，持久值都是存在的。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;如果你看到switch平台上展示了开关值，以为已经持久化，然后在代码里就把默认值删掉，此时也可能导致故障。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false,&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;5j7igzlufm5&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:false,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;SCIR_ECIR_SREC&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;bullet&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;●&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;代码重构注意事项（20220420更新）&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;做代码结构重构时，如果没有指定switch的namespace，会导致你推送过的持久化开关失效，进而引发严重的线上故障。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]],[&amp;quot;img&amp;quot;,{&amp;quot;id&amp;quot;:&amp;quot;pul8ud&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;image.png&amp;quot;,&amp;quot;size&amp;quot;:175426,&amp;quot;width&amp;quot;:866,&amp;quot;height&amp;quot;:171.8308300395257,&amp;quot;rotation&amp;quot;:0,&amp;quot;src&amp;quot;:&amp;quot;/oss/getResourceRedirectUrl?fileId=neweditor%2F336103ad-1ac1-4757-b0c0-ec25f96104cc.png&amp;amp;expire=3600000&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:false,&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;2fu1oxx5e3o&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:false,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;SCIR_ECIR_SREC&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;bullet&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;●&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;合理使用，避免滥用&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;switch 提供了简单易用的配置化能力，但不要把应该正常编码要考虑和处理的问题，丢到switch上做开关。否则，最后开关一大堆，维护越发困难，就隐藏了风险。&amp;quot;]]],[&amp;quot;p&amp;quot;,{},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;h2&amp;quot;,{&amp;quot;spacing&amp;quot;:{&amp;quot;before&amp;quot;:14.666666666666668,&amp;quot;after&amp;quot;:14.666666666666668,&amp;quot;line&amp;quot;:0.8529411764705882}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:true,&amp;quot;sz&amp;quot;:16,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;重大风险评估和处置&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;针对一个需求开发，我们需要评估风险及我们的承受能力。主要目的是 预防重大故障的发生，而不是要预防所有Bug。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;关于风险处置，也没有一个固定的标准。我建议是结合业务场景，评估风险概率和潜在问题的严重程度，最后来制定相应的解决方案。例如，如果发现有资损风险，那要采取一切手段把漏洞堵上；但如果只是小概率的漏掉钉钉通知，那增加相应的告警即可。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;我们如何评估 重大风险呢？我建议分这么几个环节做评估：&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:true,&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;y9p19qq3oni&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:true,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;DEC_LEN_LROM_P&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;decimal&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;%1.&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false},&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;梳理 关键的业务流。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:true,&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;y9p19qq3oni&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:true,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;isChecked&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;DEC_LEN_LROM_P&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;decimal&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;%1.&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false,&amp;quot;extraData&amp;quot;:{}},&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;梳理 每个业务流的关键环节。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:true,&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;y9p19qq3oni&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:true,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;isChecked&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;DEC_LEN_LROM_P&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;decimal&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;%1.&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false,&amp;quot;extraData&amp;quot;:{}},&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;梳理 每个关键环节的关键逻辑 和 关键上下游。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:true,&amp;quot;list&amp;quot;:{&amp;quot;listId&amp;quot;:&amp;quot;y9p19qq3oni&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;isOrdered&amp;quot;:true,&amp;quot;isTaskList&amp;quot;:false,&amp;quot;isChecked&amp;quot;:false,&amp;quot;listStyleType&amp;quot;:&amp;quot;DEC_LEN_LROM_P&amp;quot;,&amp;quot;symbolStyle&amp;quot;:{},&amp;quot;listStyle&amp;quot;:{&amp;quot;format&amp;quot;:&amp;quot;decimal&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;%1.&amp;quot;,&amp;quot;align&amp;quot;:&amp;quot;left&amp;quot;},&amp;quot;hideSymbol&amp;quot;:false,&amp;quot;extraData&amp;quot;:{}},&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;结合自己场景，假定 关键逻辑 和 关键上下游 出现极端问题。例如 网络挂掉、机器重启、高并发来临、缓存挂掉等。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:false,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:false,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;这里需要强调一点，并非所有模块都需要假定非常极端的情况，要结合自己实际业务要求、历史风险等 来综合判断。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:false,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:false,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;再举个例子：&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:true,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;假设，有一个用户资金转账系统，用户可以通过App进行跨行转账操作。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:true,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;那这个系统就要考虑到 转账超时、转账失败等场景。同时还要考虑 转账超时 或 失败时，是fail-fast 好，还是 fail-over好？&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:true,&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;此外，还需要考虑到 App端的用户交互设计，假如遭遇网络中断或超时，且用户看不到任何问题提示，那用户很可能再次发起转账尝试，最后转了两笔的钱。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;这个评估过程看上去有点冗长，但其实对于了解自己系统和需求细节的人来讲，应该是很容易做到的。如果做不到那就只能加强细节的理解和学习了。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;blockquote&amp;quot;:false},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;h1&amp;quot;,{&amp;quot;blockquote&amp;quot;:false,&amp;quot;spacing&amp;quot;:{&amp;quot;before&amp;quot;:14.666666666666668,&amp;quot;after&amp;quot;:14.666666666666668,&amp;quot;line&amp;quot;:0.8529411764705882}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:true,&amp;quot;sz&amp;quot;:20,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;最后&amp;quot;]]],[&amp;quot;p&amp;quot;,{},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;以研发同学为中心，向内看：需持续提升防御性编码的意识和实操能力；向外看：外部环境需要尽可能提供与之匹配的环境。&amp;quot;]]],[&amp;quot;p&amp;quot;,{},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;例如，在面临有紧急DeadLine的需求时，防御性编码的执行完整度就会受到一定影响。&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;再次欢迎大家把自己的心得留言。&amp;quot;]]]]&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.625&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naKE9M6VKchc68TFRxkXA01j9Zz5PbNicPp85IgibcDeppOuvRZm1yVyN9GceA5GIfV4ggHDIxaGovkw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;一  防御性编码的意义&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;类似于“防御性驾驶”对驾驶安全的重要性，防御性编码目的概括起来就一条：将代码质量问题消灭于萌芽。要做到“防御性编码”，就要求我们充分认识到代码质量的严肃性，也就是“一旦你觉得这个地方可能出问题，那基本它就会（在某个时刻）出问题”。当然，实际情况比这个更严峻。由于大家的编码经验和风格差异，导致大家的意识边界是大小不一的，那些潜伏在意识边界之外的“危险”更加隐蔽和不可琢磨。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在意识层面上，我们当然要摒弃“想当然”和“差不多”的思想，严肃评估这些问题发生的可能性，认真对待这些风险。但如若话题止步于此，那其实还是缺乏执行层面的指导意义的，激不起半点“涟漪”的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个文章目的也更多是关注到“实操层面”的引导。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;二  如何防御性编码？&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;以下需关注的具体方面更多来自于我的习惯和观察，并且统一用伪代码作问题示例。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;欢迎大家把自己的“防御性编码心得”在评论区分享出来。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;1  并发冲突问题&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;这个问题在实际项目中，被错误地忽视的比例相当高。它的外在表现形式五花八门，但关键点是：“当你的代码被并发调用时，它会怎么表现？” &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们心里要有个运行时的世界观，代码运行的Context是这样的：多线程 -&amp;gt; 多进程 -&amp;gt; 多机器 -&amp;gt; 多集群。我们编码时，要充分考虑代码在上述世界观多点并发的可能性，及相应的潜在后果。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;举几个具体的问题例子)：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;存在共享变量 或者 数据。（不限于堆内存，也可能是缓存、DB、文件等）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;例子1：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;有线程 A 和线程 B 两个线程，需要更新「同一条」数据，会发生这样的场景：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1. 线程 A 更新数据库（X = 1）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. 线程 B 更新数据库（X = 2）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3. 线程 B 更新缓存（X = 2）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4. 线程 A 更新缓存（X = 1）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最终 X 的值在缓存中是 1，在数据库中是 2，发生不一致。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;例子2：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// 某个 Spring singleton Bean &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;aService&#x27;&lt;/span&gt; 存在一个调用来源标记，记录调用来源是HSF还是HTTP。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// 先 记录来源标记。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aService.setSource(&lt;span class=&quot;code-snippet__built_in&quot;&gt;source&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// 再结合&lt;span class=&quot;code-snippet__built_in&quot;&gt;source&lt;/span&gt;执行其他逻辑。例如将上面记录的&lt;span class=&quot;code-snippet__built_in&quot;&gt;source&lt;/span&gt; 和 其他参数 插入数据库.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aService.doSomethings(params);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;如果这个代码被 HSF和 HTTP 同时调用就会发生问题。&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;例子3 :&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre&gt;&lt;blockquote&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;在一个系统中，有两个价格类型 small 和 large，业务逻辑要求 small &amp;lt;= large，且 small 和 large 有2个入口可以分别修改。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;目前方案是：对要改变的small或large，增加上面大小关系校验，不通过则拦截，例如 改动small的入口上，校验改后的small &amp;lt;= 系统里的large，不通过则不允许修改。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;假如，最新需求要求：修改large的入口继续拦截，但修改small的入口不再拦截，而是发现如果改后small &amp;gt; 系统的large，则将 系统large = 改后的small+0.1，让 约束关系继续成立。 这种改法有问题吗？&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;答案：这种改法会有问题。即 small这个价格类型存有两个链路同时修改，也是一种并发冲突问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;举个具体例子：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;初始时，系统的small = 2; large = 2;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;修改large 链路1：准备将 large 改为 3，检查规则 3(改后large ) &amp;gt;= 2(系统small) 通过。准备写入新的large (3)。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;修改small 链路2：准备降 small 改为 4, 发现  4（改后small）&amp;gt; 2(系统large) 不符合规则，则 准备 自动修改 large = 4（改后small）+ 0.1 = 4.1。准备写入 改后small = 4，自动改后 large = 4.1；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果 链路2 最终先完成写入，链路1再完成写入。则 链路2写入的 large=4.1 会被链路1 写入的large=3 覆盖。最终系统 large =3，而 系统small = 4；破坏了最初的small &amp;lt;= large 的约束。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;timestamp = rateLimitService.getMsgTimestamp(userId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;( timestamp == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; ){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  rateLimitService.putMsgTimestamp(userId, now);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  sendMsg(msg);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;( timestamp - now &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; hour ){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  rateLimitService.putMsgTimestamp(userId, now);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  sendMsg(msg);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;这个例子在单机环境执行时没有问题，但线上集群多节点的话，那发送频率的控制就不对了。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;resultList = dbRepo.&lt;span class=&quot;code-snippet__built_in&quot;&gt;list&lt;/span&gt;(query);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;( resultList.size() &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; ){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  dbRepo.update(xxxx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  dbRepo.insert(xxxx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre&gt;&lt;blockquote&gt;&lt;pre&gt;&lt;article data-clipboard-cangjie=&quot;[&amp;quot;root&amp;quot;,{},[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;这个例子在单机环境执行时没有问题，但线上集群多节点的话，那发送频率的控制就不对了。&amp;quot;]]]]&quot;&gt;&lt;p&gt;&lt;span&gt;如果这个代码被多个request 同时执行也会发生问题。&lt;/span&gt;&lt;/p&gt;&lt;/article&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;pre&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;blockquote&gt;&lt;pre&gt;&lt;article data-clipboard-cangjie=&quot;[&amp;quot;root&amp;quot;,{},[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;这个例子在单机环境执行时没有问题，但线上集群多节点的话，那发送频率的控制就不对了。&amp;quot;]]]]&quot;&gt;&lt;section&gt;&lt;span&gt;单个任务周期性的触发，本来不会有并发问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但因单次执行时间变长，导致先后两次执行时间出现重叠&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;/article&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;2  事务问题&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;对于先A再B后C的这类组合操作，要仔细考虑保障一致性的必要性，做好是否做事务保障的评估。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;事务即要求：对一组的operation combo，要保障好执行顺序，保障好context的一致性，保障好结果的一致性。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre&gt;&lt;pre&gt;&lt;blockquote&gt;&lt;pre&gt;&lt;article data-clipboard-cangjie=&quot;[&amp;quot;root&amp;quot;,{},[&amp;quot;p&amp;quot;,{&amp;quot;ind&amp;quot;:{&amp;quot;left&amp;quot;:0},&amp;quot;blockquote&amp;quot;:true},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;这个例子在单机环境执行时没有问题，但线上集群多节点的话，那发送频率的控制就不对了。&amp;quot;]]]]&quot;&gt;&lt;section&gt;&lt;span&gt;这个问题发生概率倒不高，也比较容易解决。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但要注意，事务执行耗时不要太久，以及避免死锁问题发生。&lt;/span&gt;&lt;/section&gt;&lt;/article&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre&gt;&lt;pre&gt;&lt;blockquote&gt;&lt;section&gt;以上传并处理Excel文件为例，假如实现分为 2 步：&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;1. 前端调用后端API，上传文件到Server的某个临时目录。&lt;/section&gt;&lt;section&gt;2. 前端 在上传完成时，调用后端另一个API，通知 后端处理此文件。&lt;/section&gt;&lt;/blockquote&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;pre&gt;&lt;pre&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这个例子在集群环境中就会出现概率性成功或失败的情况，集群节点数量越多，失败概率越高。这是因为 前端的前后两次请求调用到了不同节点上，执行上下文出现了不一致。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre&gt;&lt;pre&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;常见的，例如对于 ECS运行状态的时序消息，如果下游消费者不是顺序消费，而是并行消费，就可能导致最终记录的状态 与实际不符。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;3  分布式锁问题&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;分布式锁日常也经常用到，在使用细节上存在一些容易忽略的盲点。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;1. 是阻塞式等待锁，还是等不到锁重试，还是等不到锁直接返回。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个层面主要考量点，这个调用链路对时间和成功率要求是什么。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;例如，上游是用户操作，那肯定不能阻塞在等锁那里太久；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. 锁的key设计很关键。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;合理设计lock key，能够降低锁碰撞的概率。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;例如，你的lock 是加在一个BU层面上，还是加到某个人身上，那冲突概率显然差别很大。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3. 对于 持久锁，在循环执行业务逻辑时，要做好锁的状态检查。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;    RLock lock = redisson.getLock(lock);&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;    lock.lock(-1L, TimeUnit.MINUTES);&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;    // 获取到锁就持久占有，避免反复切换&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;    while( !isStopped ){&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;         if( lock.isHeldByCurrentThread() ){&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;              // do some work&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;         }else{&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;              // try to acquire lock again. &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;         }&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;         SleepUtil.sleep(loopInterval, TimeUnit.MINUTES);&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4. 能用本地锁 不用全局锁。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;1. &lt;/span&gt;&lt;span&gt;合理设置锁的TTL，结合自己业务场景做取舍&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;例如，加锁之后执行大量数据的batch计算的场景。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果锁TTL太长，那计算被异常中断（如机器重启）时，这个长TTL内是无法被其他节点/线程获取到执行权限的；但如果TTL设置太短，那可能还没等执行完成，锁就被意外抢走了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. 注意watchDog机制&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;像Redisson之类的会有锁的watchdog，超过设置或默认的时间，锁就被偷偷释放了。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;1. 非必要情况下，避免强行释放锁，要检查锁的持有人是否是自己。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. 对于没有TTL的锁，要考虑极端情况下（进程被强制杀死、机器重启）的锁状态管理。否则意外一旦出现，锁就永远丢失了。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;4  缓存问题&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;缓存和数据库都没有的数据，但被大量请求，导致DB压力过大。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;常见的解决方式：对空值也进行缓存，但TTL设置相对较短。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;一般是缓存的热点key发生过期失效，此时大量请求透过缓存 击中DB，导致DB压力过大。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;常见解决方式：缓存查询miss时，设置个互斥锁，只允许一个request真实请求DB和重写缓存，避免大量请求涌入。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;缓存中的大量数据在较短的时间段内集中过期。一般发生在流量一波波来，缓存创建时间和TTL很接近。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;常见解决方案：在TTL设置上不是一刀切，而是在一个合理范围内随机浮动，避免缓存集中失效。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;一般情况下，一致性要求不会非常严格。但如果需要强一致性保障时，要考虑缓存和DB之间的数据强一致性。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一种可能的方案：只在写DB时才写缓存，读DB操作不写缓存。DB和缓存的写操作要加锁，避免并发问题。具体流程如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当写DB请求发生时：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1. 删除 缓存。此时读操作缓存会miss，读取到DB中的老值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. 写入DB。此时读操作缓存会miss，读取到DB中的新值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3. 写入缓存。此时读操作缓存会 hit，读取到缓存中的新值（与DB新值一致）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;需要注意的是：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1. 缓存针对数据库所有的数据记录，可能导致缓存空间占用高，实际利用率却不高。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. 如果某个缓存key 是热点，或者 流量比较大，尽管缓存“删除-重写入”间隔短，依然可能会引发 缓存击穿问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3. 如果缓存写入失败，需要有相应的补偿机制再写入，且需关注 补偿写入与其他正常写入的冲突和时序问题。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;这个本身不是问题，但命中率低说明缓存的设计或使用存在问题，需要重新设计。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;如果特定缓存节点CPU使用率远高于其他节点，说明可能存在热点key。这个时候需要合理对缓存key做拆分，将流量进一步打散。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;5  失败处理问题&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;这类问题虽属于低级问题，但往往比较隐蔽。在异常发生时，选择相应处理action时，我们要头脑非常清醒。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;可能的处理方式：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1. failover。失败立即重试。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. failback。记录失败，后置处理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3. failfast。直接失败，返回异常。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4. failsafe。忽略失败，继续流程。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;这里不在于选择那种处理方式，而是要“头脑清醒”的结合自己场景需求做出选择。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一些情况下，我们会初始化时设定一些默认值、默认状态等，对于这些情况要充分考虑异常发生时是否存在风险。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;例如，在最开始时，代码里配置了当时的开城信息，但这个状态并没有跟业务操作流程打通，也就是没有办法做到及时更新。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那随着时间发展，开发了新的城市，那就可能产生问题。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;6  switch配置问题&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;switch发布时，不同批次会有时间间隔，大部分场景下都可以容忍这个时间间隔。但个别情况下，可能引发诸如数据不一致等问题。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;再使用switch时需要对这个问题做提前考虑，若不能容忍这种情况，那需要更换其他方案。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;switch的逻辑是这样：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1. switch会默认记录代码中的默认值。此时并不是 持久值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. 当在代码中修改默认值时，switch平台也会显示代码默认值。此时也并不是 持久值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3. 只有在switch平台修改值并推送成功，swith平台会保存持久值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4. switch保存持久值之后，不管代码修改默认值还是去掉 @AppSwitch 配置，持久值都是存在的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你看到switch平台上展示了开关值，以为已经持久化，然后在代码里就把默认值删掉，此时也可能导致故障。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;做代码结构重构时，如果没有指定switch的namespace，会导致你推送过的持久化开关失效，进而引发严重的线上故障。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;关于应用级服务发现与接口级服务发现的区别和 dubbo 生态的解决方案，本文中不多赘述，可以参考刘军前辈写的文章文章《Dubbo 迈出云原生重要一步 应用级服务发现解析》&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;简单来说，应用级服务发现需要开发者关心接口之外还要关心应用名，注册中心的冗余信息较少；接口级服务发现开发者只需要引入接口名，但注册中心的冗余信息较多。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.20240782543265612&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1329&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIOT5YoNtRibsibZIBISoVolAkwicMujFAy34vicoZp9xweiazsCNqJ1d3fh03GdxblPeGAOibBdQavD2yw/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;switch 提供了简单易用的配置化能力，但不要把应该正常编码要考虑和处理的问题，丢到switch上做开关。否则，最后开关一大堆，维护越发困难，就隐藏了风险。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;7  重大风险评估和处置&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;针对一个需求开发，我们需要评估风险及我们的承受能力。主要目的是 预防重大故障的发生，而不是要预防所有Bug。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;关于风险处置，也没有一个固定的标准。我建议是结合业务场景，评估风险概率和潜在问题的严重程度，最后来制定相应的解决方案。例如，如果发现有资损风险，那要采取一切手段把漏洞堵上；但如果只是小概率的漏掉钉钉通知，那增加相应的告警即可。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们如何评估 重大风险呢？我建议分这么几个环节做评估：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;1、梳理 关键的业务流。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、梳理 每个业务流的关键环节。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3、梳理 每个关键环节的关键逻辑 和 关键上下游。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4、结合自己场景，假定 关键逻辑 和 关键上下游 出现极端问题。例如 网络挂掉、机器重启、高并发来临、缓存挂掉等。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里需要强调一点，并非所有模块都需要假定非常极端的情况，要结合自己实际业务要求、历史风险等 来综合判断。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;再举个例子：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;假设，有一个用户资金转账系统，用户可以通过App进行跨行转账操作。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那这个系统就要考虑到 转账超时、转账失败等场景。同时还要考虑 转账超时 或 失败时，是fail-fast 好，还是 fail-over好？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;此外，还需要考虑到 App端的用户交互设计，假如遭遇网络中断或超时，且用户看不到任何问题提示，那用户很可能再次发起转账尝试，最后转了两笔的钱。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个评估过程看上去有点冗长，但其实对于了解自己系统和需求细节的人来讲，应该是很容易做到的。如果做不到那就只能加强细节的理解和学习了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;三  最后&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;以研发同学为中心，向内看：需持续提升防御性编码的意识和实操能力；向外看：外部环境需要尽可能提供与之匹配的环境。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;例如，在面临有紧急DeadLine的需求时，防御性编码的执行完整度就会受到一定影响。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;再次欢迎大家把自己的心得留言。&lt;/span&gt;&lt;/section&gt;&lt;/article&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2 data-spm-anchor-id=&quot;a2c6h.21258778.0.i0.5ec6610cXG2Esh&quot;&gt;&lt;strong&gt;&lt;span&gt;Dubbo 3.0 服务治理最佳实践&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;点击阅读原文查看详情&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>01b89a8ab61a7d97935082a5e60b3f33</guid>
<title>GitHub的4个神技，同桌直呼666</title>
<link>https://toutiao.io/k/oaoov9m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;神技一：高级搜索&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有过这样的经验：想搜索一个差不多的项目改改自己用，结果搜索框输入后出来一堆，无从下手。遇到这种情况我都是闭上眼睛，先自己想好怎样从中选择，最终我想到自己想要的是日期比较新、最好是团队而不是个人维护(持续性会好一些)、语言和框架和自己的技术更贴合。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.41984056687333926&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8T8BL2SnFicxmTJNxCbk45qJq38jjbxXqbpIjtpstpfCM31DMdiabNkb0YeDIsk7WJ4sBxbsUiaxXeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1129&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;大佬们通常会根据想好的要求输入一串神秘代码，比如上图。直接定位想要的结果。其实这是利用了GitHub的高级搜索功能提供的搜索限定符。其实完全不需要记忆，直接利用高级搜索的可视化表单即可。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4559548978153629&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8T8BL2SnFicxmTJNxCbk45qpEnJ3ajVScttnEFayel0gkwkFaezqIBwdZVjH0K45EAFlrLjjAuDIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1419&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但这个界面展示的搜索条件有限，官方文档中罗列了诸如按上次更新时间搜索、仓库内容搜索等都可以直接用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;神技二：定位文件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我之前也在GitHub的某个项目中查找文件，由于没有下载到本地，所以要找某个文件，就一级一级的点击目录，发现位置错了，还要返回去重新找。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.40823211875843457&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8T8BL2SnFicxmTJNxCbk45quX34AM69j4R4ic172ibp6ia1nnfYT9A3MYicy22tBGYjx9Dib15bu589jTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1482&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于Java这种层层嵌套的项目来说实在是太麻烦了。其实，我们只需要按下T键，就可以实时对文件进行搜索了&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5329489291598023&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8T8BL2SnFicxmTJNxCbk45qZB438MC71BgMqVFWxtUR9PqkkNzXSenJkTOkicibicOvf06Zwnf53qc5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1214&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在查看某个具体文件时，按L键，可以直接定位某一行：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8T8BL2SnFicxmTJNxCbk45qOuib46Pxvg9iayNSm01k2oElFibiaBcUzwYUpPMeE7atOs1hSviajywSdJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;点击行号还可以快速复制或者生成永久链接：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0154905335628228&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8T8BL2SnFicxmTJNxCbk45qw5CfD45sC4mCtWvYZXPTLezia15k5iajCPric7vGcxkALh0yPc48squRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;581&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;按B键还可以快速查看该文件的改动记录：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6937269372693727&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8T8BL2SnFicxmTJNxCbk45qH12ndC6aJJ37vjbjVYEybG8If4zJJs8nJvZznialOpIQiabfNKo4kyOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1084&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;神技三：在线编辑器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果想阅读完整的代码，我们往往需要将代码下载到本地，用本机编辑器来打开。其实大可不必。只要在项目上按.键（句号键），GitHub会自动按照一个VsCode的插件，我们可以获取本地编辑器一样的体验：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5447154471544715&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8T8BL2SnFicxmTJNxCbk45qPG5gdqC6cFgFx13xGmib0hSt3hrYno5A8sdsk8DnqWdU0Rib2xeib0ltQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1230&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;神技四：在线运行&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;让我们在项目地址前加上gitpod.io前缀：&lt;/p&gt;&lt;p&gt;https://gitpod.io/github.com/xiexiaojing/yuna&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.522&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8T8BL2SnFicxmTJNxCbk45q0VPo9EGFjUTgVeZE3SlVcOLvdTtggkSdzOQBHTLMOv3DiaBhjUbzzWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;项目自动的下载文件编译运行了。甚至可以一键构建docker镜像：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8651685393258427&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8T8BL2SnFicxmTJNxCbk45qsFo7gkDiam8HdpjCicq9AEPfpdzBYKsPJ1QBJ5dPGIP8mrU3Ae1ia6xAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;712&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;编程一生&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;因为公众号平台更改了推送规则，如果不想错过内容，记得读完点一下“在看”，加个“星标”，这样每次新文章推送才会第一时间出现在你的订阅列表里。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;想知道自己错过了哪些更新，可参考我不定期更新的《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247487380&amp;amp;idx=2&amp;amp;sn=4e71d679e2c22f9c5af4ea3abc667b76&amp;amp;chksm=fafde53acd8a6c2c9d2fb5eb83de5e5a2e3f244a57fa275394d9d61a0cdfa154290fe7a21fe8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;系列文章分类汇总&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;em&gt;&lt;strong&gt;系列文章分类汇总&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt;》。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5af1a238efffd23ff6eba16fd238cf75</guid>
<title>每周一书：《超越智商：为什么聪明人也会做蠢事》</title>
<link>https://toutiao.io/k/1c669n3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;我爱程序员&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;developerWorks&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;我们的产品：《码农周刊》 http://manong.io/ 、《开发者头条》 http://toutiao.io/&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ba7f30d66b33da42280eb63e20228702</guid>
<title>【工程化】探索webpack5中的Module Federation</title>
<link>https://toutiao.io/k/17ms496</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Module Federation 是 webpack5 中振奋人心的新特性，也是号称能改变 JavaScript 架构游戏规则的功能。接下来让我们慢慢揭开 Module Federation 的神秘面纱&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.11&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/betIP9fVPicOcnc3XANblb8WOkibusib0VaxGjm7wsZsDKvne0Vs3sP47HApicewXon2U5g0zMvGjzM6qkC21vtaWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;模块共享的方案对比&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;场景：目前拥有项目 A 和项目 B，我们发现它们存在一定的共性，比如公共 UI 组件、utils 等。那我们如何同享这些公共信息呢？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;简单粗暴-CV大法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接将项目 A 的组件，copy 到项目 B 中，这样的方式有时候是比较快的，但也存在维护性极低的问题，后续两个项目都各自维护一套&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;抽象成 npm&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以将一些公共的模块抽象成 npm，每个项目都去安装该 npm 包，从而达到共享的目的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是 npm 包的方式存在以下问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;编译与构建：一些公共的工具库，框架以及 UI 库存在重复构建，造成性能低下&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;版本更新：需要各个项目都去升级。“发布 -&amp;gt; 通知 -&amp;gt; 更新” 的方式是比较低效率的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7193229901269393&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/betIP9fVPicOcnc3XANblb8WOkibusib0Vao7ajLK8IkicdzR0TVcfkc8GGPH2vIezmkWNOxENMDB9vgjbDgpc2X6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;709&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;CDN + webpack externals&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跟 npm 类似，只不过将其上传到 CDN，通过结合 webpack externals 进行加载，除了上面提到的问题，还有 externals 没有按需加载&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;git submodule&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其还是会存在重复构建的问题，而且还会一定的上手成本&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相关的命令：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;git submodule add &amp;lt;子模块repository&amp;gt;&lt;path&gt;: 添加子模块&lt;/path&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;git submodule update --recursive --remote ：拉取所有子模块的更新&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7006711409395974&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/betIP9fVPicOcnc3XANblb8WOkibusib0VagaPuupELJH3QypTfyl8rs8cS7DQbdQVpXFMTSoI4VAFeDvSa9O1bow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;745&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Module Federation 是什么？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方文档解释其动机如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;多个独立的构建可以组成一个应用程序，这些独立的构建之间不应该存在依赖关系，因此可以单独开发和部署它们。这通常被称作微前端，但不仅仅限于此&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Module federation 使 JavaScript 应用得以从另一个 JavaScript 应用中动态地加载代码，这就解决了我们上面提到的模块共享的问题&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它不仅仅是微前端，而且场景粒度可以更加细，一般微前端更多的是应用级别，但它更偏向模块级别的共享&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Module Federation 配置&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实战之前，我们了解一下 Module Federation 的配置项&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先是两个基础角色的约定：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Host。消费模块的一方&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Remote。提供模块的一方&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;每个应用都既可以作为 host，也可以作为 remote&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4263888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/betIP9fVPicOcnc3XANblb8WOkibusib0Va6pdOAIysmLPC4GM6RgAatCLVdtbaibfRlB5LQTDHribERr4zNGUsLhfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Module Federation 配置项如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;name: 必须且唯一&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;filename: 若没有提供 filename，那么构建生成的文件名与容器名称同名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;remotes: 可选，作为引用方最关键的配置项，用于声明需要引用的远程资源包的名称与模块名称，作为 Host 时，去消费哪些 Remote&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;exposes: 可选，表示作为 Remote 时，export 哪些属性被消费&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;library: 可选,定义了 remote 应用如何将输出内容暴露给 host 应用。配置项的值是一个对象，如 { type: &#x27;xxx&#x27;, name: &#x27;xxx&#x27;}&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;shared，可选,指示 remote 应用的输出内容和 host 应用可以共用哪些依赖。shared 要想生效，则 host 应用和 remote 应用的 shared 配置的依赖要一致&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Singleton: 是否开启单例模式。默认值为 false，开启后remote 应用组件和 host 应用共享的依赖只加载一次，而且是两者中版本比较高的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;requiredVersion：指定共享依赖的版本，默认值为当前应用的依赖版本&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;eager：共享依赖在打包过程中是否被分离为 async chunk。设置为 true， 共享依赖会打包到 main、remoteEntry，不会被分离，因此当设置为true时共享依赖是没有意义的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.511049723756906&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/betIP9fVPicOcnc3XANblb8WOkibusib0VaBAUricdhOtKk2n7g0G81t3lwK4aq2GlnFzwcRfiaO20sGLJEb87LpI8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;724&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实战演示&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们用 Github 中 &lt;span&gt;Module Federation Examples&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;进行演示。这里包含了基础的用法、高级用法以及和一些框架的结合实践&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注：该仓库使用 lerna 维护。所以你需要安装 lerna&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install lerna -g&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 lerna bootstrap 安装依赖&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;简单示例&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来看 basic-host-remote 目录下有两个独立的 project，分别为 app1 和 app2。其中 app2 中实现了一个 Button 组件，现在 app1 要用这个 Button 组件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; React &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; Button = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;App 2 Button&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; Button;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;app2 暴露组件&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，app2 的角色就是 Remote，核心 webpack 配置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; { ModuleFederationPlugin } = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;webpack&#x27;&lt;/span&gt;).container;&lt;br/&gt;&lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;  &lt;br/&gt;  plugins: [&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; ModuleFederationPlugin({&lt;br/&gt;      &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;app2&#x27;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;library&lt;/span&gt;: { &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;var&#x27;&lt;/span&gt;, &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;app2&#x27;&lt;/span&gt; },&lt;br/&gt;      &lt;span&gt;filename&lt;/span&gt;: &lt;span&gt;&#x27;remoteEntry.js&#x27;&lt;/span&gt;, &lt;span&gt;// 生成的文件名&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;exposes&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&#x27;./Button&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;./src/Button&#x27;&lt;/span&gt;, &lt;span&gt;// Export Button 组件&lt;/span&gt;&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;// 共享 react 和 react-dom&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;shared&lt;/span&gt;: { &lt;span&gt;react&lt;/span&gt;: { &lt;span&gt;singleton&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt; }, &lt;span&gt;&#x27;react-dom&#x27;&lt;/span&gt;: { &lt;span&gt;singleton&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt; } },&lt;br/&gt;    }),&lt;br/&gt;  ],&lt;br/&gt;&lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;app1 消费组件&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，app1 的角色是 Host，webpack 核心配置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; { ModuleFederationPlugin } = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;webpack&#x27;&lt;/span&gt;).container;&lt;br/&gt;&lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;//http://localhost:3002/remoteEntry.js&lt;/span&gt;&lt;br/&gt;  plugins: [&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; ModuleFederationPlugin({&lt;br/&gt;      &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;app1&#x27;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;remotes&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;// http://localhost:3002/remoteEntry.js&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 上面配置生成的模块文件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;app2&lt;/span&gt;: &lt;span&gt;`app2@&lt;span&gt;${getRemoteEntryUrl(&lt;span&gt;3002&lt;/span&gt;)}&lt;/span&gt;`&lt;/span&gt;,&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;// 共享模块&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;shared&lt;/span&gt;: { &lt;span&gt;react&lt;/span&gt;: { &lt;span&gt;singleton&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt; }, &lt;span&gt;&#x27;react-dom&#x27;&lt;/span&gt;: { &lt;span&gt;singleton&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt; } },&lt;br/&gt;    }),&lt;br/&gt;  ],&lt;br/&gt;&lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;模块使用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; RemoteButton = React.lazy(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;(&lt;span&gt;&#x27;app2/Button&#x27;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; App = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; (&lt;br/&gt;  &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;Basic Host-Remote&lt;span&gt;&amp;lt;/&lt;span&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;h2&lt;/span&gt;&amp;gt;&lt;/span&gt;App 1&lt;span&gt;&amp;lt;/&lt;span&gt;h2&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;React.Suspense&lt;/span&gt; &lt;span&gt;fallback&lt;/span&gt;=&lt;span&gt;&quot;Loading Button&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;RemoteButton&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;React.Suspense&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; App;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;效果&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40441176470588236&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/betIP9fVPicOcnc3XANblb8WOkibusib0VaIJzs8YFVrPLWydpvP7FCWf0LK5lfdaJ0f8cGR4iaQhSavYmJ7kYQ86A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;408&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且可以看到 react 和 react-dom 也是加载了一次：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5934579439252337&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/betIP9fVPicOcnc3XANblb8WOkibusib0Va94icUrn39IMnZTmiaUJPGej1TLToudiaEsaAU172hqcUibbYrJhrpwb6AQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;642&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;高级示例-动态加载远程模块&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如初始化的时候，不加载远程的模块，在一定的交互之后再去加载远程模块，该怎么实现呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本示例在 advanced-api/dynamic-remotes 中可以找到&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例中有三个 project，app1/app2/app3。app1 是 Host，消费 app2 和 app3 提供的组件，而且点击相应按钮的时候才去加载对应的远程模块。另外 app2 和 app3 都用到了 moment.js&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32296296296296295&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/betIP9fVPicOcnc3XANblb8WOkibusib0VapDdMp4vh439QSiblwcQwwViaNCzaHkOe4nyvXVhzbtV1E5vntjNVu0rA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;675&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;app2 和 app3 暴露模块&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两个 project 的配置是相似的，都是暴露了 Widget 组件，而且都同享了 react 和 react-dom，以及 moment.js。这里可以留意的是，假如不声明 requiredVersion，就会使用它能找到的当前大版本中最高的 version&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; deps = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;./package.json&#x27;&lt;/span&gt;).dependencies;&lt;br/&gt;&lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;new&lt;/span&gt; ModuleFederationPlugin({&lt;br/&gt;  &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;app3&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;library&lt;/span&gt;: { &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;var&#x27;&lt;/span&gt;, &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;app3&#x27;&lt;/span&gt; },&lt;br/&gt;  &lt;span&gt;filename&lt;/span&gt;: &lt;span&gt;&#x27;remoteEntry.js&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;exposes&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&#x27;./Widget&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;./src/Widget&#x27;&lt;/span&gt;,&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;// adds react as shared module&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// version is inferred from package.json&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// there is no version check for the required version&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// so it will always use the higher version found&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;shared&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;react&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;requiredVersion&lt;/span&gt;: deps.react,&lt;br/&gt;      &lt;span&gt;import&lt;/span&gt;: &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;, &lt;span&gt;// the &quot;react&quot; package will be used a provided and fallback module&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;shareKey&lt;/span&gt;: &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;, &lt;span&gt;// under this name the shared module will be placed in the share scope&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;shareScope&lt;/span&gt;: &lt;span&gt;&#x27;default&#x27;&lt;/span&gt;, &lt;span&gt;// share scope with this name will be used&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;singleton&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;// only a single version of the shared module is allowed&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;&#x27;react-dom&#x27;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;requiredVersion&lt;/span&gt;: deps[&lt;span&gt;&#x27;react-dom&#x27;&lt;/span&gt;],&lt;br/&gt;      &lt;span&gt;singleton&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;// only a single version of the shared module is allowed&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;&lt;span&gt;// adds moment as shared module&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// version is inferred from package.json&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// it will use the highest moment version that is&amp;gt;=2.24and 小于 3&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;moment&lt;/span&gt;: deps.moment,&lt;br/&gt;  },&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;app1 消费模块&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;app1 作为 Host，这里都是常规配置，不再赘述&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要来看它负责动态加载的代码，在点击相应的按钮的时候，会触发 &lt;code&gt;useFederatedComponent&lt;/code&gt; 方法，入参中 remoteUrl 为远程地址，scope 为对应应用名称，module 为指定的模块。其中 &lt;code&gt;useDynamicScript&lt;/code&gt; 负责加载的远程 JavaScript 脚本，加载完成之后，通过 &lt;code&gt;loadComponent&lt;/code&gt; 方法动态加载组件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; useFederatedComponent = &lt;span&gt;(&lt;span&gt;remoteUrl, scope, &lt;span&gt;module&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; key = &lt;span&gt;`&lt;span&gt;${remoteUrl}&lt;/span&gt;-&lt;span&gt;${scope}&lt;/span&gt;-&lt;span&gt;${&lt;span&gt;module&lt;/span&gt;}&lt;/span&gt;`&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; [Component, setComponent] = React.useState(&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { ready, errorLoading } = useDynamicScript(remoteUrl);&lt;br/&gt;  React.useEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (Component) setComponent(&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;// Only recalculate when key changes&lt;/span&gt;&lt;br/&gt;  }, [key]);&lt;br/&gt;&lt;br/&gt;  React.useEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (ready &amp;amp;&amp;amp; !Component) {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; Comp = React.lazy(loadComponent(scope, &lt;span&gt;module&lt;/span&gt;));&lt;br/&gt;      componentCache.set(key, Comp);&lt;br/&gt;      setComponent(Comp);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// key includes all dependencies (scope/module)&lt;/span&gt;&lt;br/&gt;  }, [Component, ready, key]);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; { errorLoading, Component };&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来重点看下 &lt;code&gt;loadComponent&lt;/code&gt;，其中 &lt;code&gt;__webpack_init_sharing__ &lt;/code&gt;，进行了初始化共享作用域，用提供的已知此构建和所有远程的模块填充它。然后获得远程容器 container，支持 get  和 init 方法。init 是一个兼容 async 的方法，调用时，只含有一个参数：共享作用域对象(shared scope object)——&lt;code&gt;__webpack_share_scopes__.default&lt;/code&gt;。最后调用容器的 &lt;code&gt;get&lt;/code&gt; 方法，获取到对应的模块&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;loadComponent&lt;/span&gt;(&lt;span&gt;scope, module&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; () =&amp;gt; {&lt;br/&gt;    &lt;span&gt;// Initializes the share scope. This fills it with known provided modules from this build and all remotes&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 初始化共享作用域（shared scope）用提供的已知此构建和所有远程的模块填充它&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;await&lt;/span&gt; __webpack_init_sharing__(&lt;span&gt;&#x27;default&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; container = &lt;span&gt;window&lt;/span&gt;[scope]; &lt;span&gt;// or get the container somewhere else&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 初始化容器 它可能提供共享模块&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;await&lt;/span&gt; container.init(__webpack_share_scopes__.default);&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; factory = &lt;span&gt;await&lt;/span&gt; &lt;span&gt;window&lt;/span&gt;[scope].get(&lt;span&gt;module&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; Module = factory();&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Module;&lt;br/&gt;  };&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;效果演示&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;点击不同的按钮，加载不同的组件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;moment.js 在首次加载后不用再重新加载&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以通过动态加载的方式，提供一个共享模块的不同版本，从而实现 A/B 测试&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49582947173308617&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/betIP9fVPicOcnc3XANblb8WOkibusib0VaURpKiarPeGV7J6m68Pq1X492V7oQZhXt2q9BdianwxicQHNiamH0xkysVg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1079&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Module Federation 的问题&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;谈了这么多 Module Federation 的优点，我们来看看它有哪些缺点&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、 对环境要求略高，需要使用 webpack5，旧项目改造成本大&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、 拆分粒度需要权衡,虽然能做到依赖共享，但是被共享的 lib 不能做 tree-shaking，也就是说如果共享了一个 lodash，那么整个 lodash 库都会被打包到 shared-chunk 中&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、 Webpack 为了支持加载 remote 模块对 runtime 做了大量改造，在运行时要做的事情也因此陡然增加，可能会对我们页面的运行时性能造成负面影响&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、 运行时共享也是一把双刃剑，如何去做版本控制以及控制共享模块的影响是需要去考虑的问题&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于问题1，未来应该会慢慢变好。问题2 感觉还好，场景应该不会特别多，而且相比于共享模块，不重复编译的优点来讲，相对可以接受。问题3，感受不大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题4，算是比较头疼的一件事，比如几个项目，都需要版本 react/react-dom/antd 的版本一致，假如版本更新的话，怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用 Module Federation 的能力，将一些核心的依赖例如 react、react-dom、antd，使用一个 remote 服务维护，然后每个项目分别引用这个服务导出的 library。我们只需要维护这个 remote 服务上依赖的版本，就能保证每个项目核心依赖的版本是一致的，而且升级的时候，也不用每个项目自己升级，大大提升了效率&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 Module Federation，我们可以在一个应用中动态加载并执行另一个应用的代码，且与技术栈无关，并且能够共享模块，从而减小编译时间以及降低包体积&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但在使用 Module Federation 的时候也需要权衡模块拆分的粒度以及做好版本的控制&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;深入探索Webpack5之Module Federation的“奇淫技巧”&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;官网 Module Federation&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;浅析 Webpack Module Federation 在 React.js 中的实践&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Module Federation Examples: &lt;em&gt;https://github.com/module-federation/module-federation-examples&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;深入探索Webpack5之Module Federation的“奇淫技巧”: &lt;em&gt;https://juejin.cn/post/6938975818659921957&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;官网 Module Federation: &lt;em&gt;https://webpack.docschina.org/concepts/module-federation/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;浅析 Webpack Module Federation 在 React.js 中的实践: &lt;em&gt;https://juejin.cn/post/7012990703714172964&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>