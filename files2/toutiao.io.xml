<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>0cfa9673d650e06a9de39aa16d51ecd1</guid>
<title>AI场景存储优化：云知声超算平台基于 JuiceFS 的存储实践</title>
<link>https://toutiao.io/k/1ih3vod</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post_content markdown&quot;&gt;&lt;blockquote&gt;&lt;p&gt;本文作者介绍：
吕冬冬，云知声超算平台架构师，负责云知声大规模分布式机器学习平台架构设计与新功能演进，负责深度学习算法应用优化与 AI 模型加速。研究领域包括大规模集群调度、高性能计算、分布式文件存储、分布式缓存等。云原生开源社区爱好者。&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 id=&quot;01-背景&quot;&gt;01 背景&lt;/h1&gt;&lt;p&gt;云知声是一家专注于语音及语言处理的技术公司。Atlas 超级计算平台是云知声的计算底层基础架构，为云知声在 AI 各个领域（如语音、自然语言处理、视觉等）的模型迭代提供训练加速等基础计算能力。Atlas 平台深度学习算力超过 57 PFLOPS（5.7 亿亿次／秒，是的你没有看错，是亿亿次图片），深度学习算力是衡量一个 AI 平台计算性能的核心指标。除了满足公司内部的业务需求，平台也为外部企业和院校机构提供定制化计算服务。&lt;/p&gt;&lt;p/&gt;&lt;small class=&quot;d-flex justify-content-center&quot;&gt;云知声 Atlas 平台架构图&lt;/small&gt;&lt;p&gt;本文主要分享云知声 Atlas 超算平台（以下简称 Atlas）的存储建设历程以及基于 JuiceFS 建设高效存储的实践。&lt;/p&gt;&lt;h1 id=&quot;02-存储建设历程&quot;&gt;02 存储建设历程&lt;/h1&gt;&lt;p&gt;一个性能卓越的超算平台，不仅需要充足的算力支持，也离不开高效的存储系统。结合 Atlas 上的任务特点和类型，高效存储系统应具备几个特点，如：满足多种类型的结构化与非结构化数据存储需求、兼容 POSIX 接口、海量小文件场景下具有较好的性能等。&lt;/p&gt;&lt;p&gt;在最早期进行 Atlas 超算平台建设的时候，我们尝试部署过 CephFS，开源版的 CephFS 在存储规模达到几千万小文件的时候，开始出现较为严重的性能问题，用户在操作文件时会遇到卡顿甚至在高 IO 的场景下整套存储系统会直接卡死，用户体验不太好。&lt;/p&gt;&lt;p&gt;后期，我们转到了 HPC 领域使用较为广泛的 Lustre 分布式文件存储系统， 构建了多套不同规模的 Lustre 集群，作为平台核心的存储系统，生产环境上目前主要有 40G 以太网与 100G InfiniBand 类型的集群，Lustre 分布式存储支持着用户在 Atlas 超算集群中进行数据处理、模型训练、源码编译与调试、数据归档等一系列数据操作。但是受限于 Lustre 在高并发请求下的性能瓶颈，无法满足对带宽与 IOPS 要求较高的场景需求。因此我们采用 Alluxio + Fluid 进行 IO 加速，分布式缓存给我们带来了 AI 模型训练速度上的提升以及存储系统总带宽的下降。&lt;/p&gt;&lt;p&gt;但是以上方案依然不是我们认为的最终方案，因此我们也在探索新的存储系统。&lt;strong&gt;在我们的场景上对这个新存储系统的核心需求是&lt;/strong&gt;：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;运维要足够简单：存储研发人员要能够较快的上手，运维人员后期的扩容、故障处理足够简单。Lustre 提供了 &lt;a href=&quot;https://whamcloud.github.io/Online-Help/docs/IML_Help_TOC.html&quot;&gt;IML&lt;/a&gt; 一系列的自动化部署与监控工具，在运维方面较为方便。但是由于 Lustre 的软件代码是在内核上运行，如果出现故障，问题定位就显得不那么直观，需要从内核消息这边定位，大部分操作涉及重启操作系统；&lt;/li&gt;&lt;li&gt;数据可靠性：数据是 AI 公司宝贵的资产，算法工程师在存储上的数据要足够稳定与安全。Lustre 目前不支持文件系统级的冗余，只能通过硬件的 RAID 来抵御硬盘故障；&lt;/li&gt;&lt;li&gt;客户端多级缓存功能：构建大规模数据存储系统（PB 量级以上）为了考虑成本数据大部分会存储在 HDD 上，为了自动区分冷热数据，并充分利用我们 GPU 服务器的接近 TB 级的内存与大量的独立 SSD 盘，我们希望具备客户端多级自动缓存功能 ，以应对高密集 I/O 的读写场景；&lt;/li&gt;&lt;li&gt;社区活跃度：社区活跃度也是我们考虑的因素，活跃的社区在功能版本的迭代与 bug 的解决方面能有更快的响应。&lt;/li&gt;&lt;/ul&gt;&lt;h1 id=&quot;03-初识-juicefs&quot;&gt;03 初识 JuiceFS&lt;/h1&gt;&lt;p&gt;云知声团队在 2021 年初了解到了 JuiceFS，并跟 Juicedata 团队进行了早期的方案对接、PoC 测试，目前 JuiceFS 已经上线到生产环境，我们也参与到 JuiceFS 开源社区的建设中。&lt;/p&gt;&lt;h2 id=&quot;juicefs-的架构与优势&quot;&gt;JuiceFS 的架构与优势&lt;/h2&gt;&lt;p&gt;JuiceFS 整体的架构由元数据引擎、对象存储集群以及 JuiceFS 客户端组成，其中元数据引擎与对象存储提供了多种方案供用户选择。通过 JuiceFS 存储的数据将持久化到对象存储（如 Amazon S3）中，相应的元数据可以根据场景和需求持久化到 Redis、MySQL、SQLite 以及 TiKV 等各种数据库引擎中。&lt;/p&gt;&lt;p/&gt;&lt;small class=&quot;d-flex justify-content-center&quot;&gt;JuiceFS 架构图&lt;/small&gt;&lt;p&gt;不管是元数据引擎还是对象存储都有很多成熟的方案可以选择，如果是在公有云上使用通常也有全托管的服务开箱即用。JuiceFS 的元数据自动备份、回收站等特性一定程度上保障了数据的可靠性，避免一些意外情况导致数据丢失，当然如果是自己运维元数据引擎和对象存储依然需要做好数据备份。JuiceFS 的本地缓存特性可以自动将频繁访问的数据缓存到内存以及磁盘中，同时也会对文件的元数据进行 &lt;a href=&quot;https://juicefs.com/docs/zh/community/cache_management&quot;&gt;缓存&lt;/a&gt;。&lt;/p&gt;&lt;h2 id=&quot;poc-测试&quot;&gt;PoC 测试&lt;/h2&gt;&lt;p&gt;PoC 测试我们主要是在小规模环境上做可行性验证，关注的点是产品特性、运维方式、与上游调度、业务框架对接是否可行等。&lt;/p&gt;&lt;p&gt;PoC 测试环境我们搭建了一个单节点的 Redis + 3 节点的 Ceph 对象存储集群，在环境搭建方面因为 Redis 跟 Ceph 都比较成熟，部署运维方案可以参考的资料也比较全，而 JuiceFS 客户端能够以较为简单的方式对接元数据引擎跟对象存储。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;业务的适配方面，JuiceFS 完全兼容 POSIX 协议，我们上层的业务可以无缝切换与对接，业务使用无感，JuiceFS 也支持以 CSI Driver 这种云原生的方式调度，与我们整个平台的技术栈契合。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在性能测试方面，我们在测试环境进行了文字识别模型的训练，实验环境为：模型采用服务器版中文识别模型 backbone 为 ResNet-18，数据整体总量是 98G 采用 LMDB 格式存储，在 6 张 NVIDIA Tesla V100 进行了三组实验，分别是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;直接在 Lustre 读&lt;/li&gt;&lt;li&gt;在带有 200G 内存缓存的 JuiceFS 读&lt;/li&gt;&lt;li&gt;在带有 960G SSD 缓存的 JuiceFS 上读&lt;/li&gt;&lt;/ul&gt;&lt;p/&gt;&lt;small class=&quot;d-flex justify-content-center&quot;&gt;耗时对比&lt;/small&gt;&lt;p&gt;JuiceFS 客户端拥有多级缓存功能，因而在性能测试中，&lt;strong&gt;在数据读方面有较大性能提升，相比 Lustre 性能有1倍以上的提升&lt;/strong&gt;，这与我们的业务特点比较契合。&lt;/p&gt;&lt;p&gt;综合考虑运维方式、业务契合度以及性能表现，我们决定将 JuiceFS 带上生产。&lt;/p&gt;&lt;h1 id=&quot;04-juicefs-在-atlas-的使用场景与收益&quot;&gt;04 JuiceFS 在 Atlas 的使用场景与收益&lt;/h1&gt;&lt;p&gt;JuiceFS 客户端多级缓存目前主要应用在我们的&lt;strong&gt;文字识别、语音降噪以及语音识别场景。由于 AI 模型训练的数据读取特点是读多写少，我们充分利用 JuiceFS 客户端的缓存带来 IO 读取的加速收益。&lt;/strong&gt;&lt;/p&gt;&lt;h2 id=&quot;收益一-加速-ai模型训练&quot;&gt;收益一：加速 AI模型训练&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1）语音降噪测试&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;降噪场景模型的测试中使用的是散文件，每个数据都是 wav 格式的小于 100k 的语音小文件，在降噪场景我们测试了数据 dataload 阶段的 I/O 数据，JuiceFS 客户端节点的内存缓存为 512G，在 500h 规模的数据下、以 40 的 batch size 进行测试。&lt;/p&gt;&lt;p/&gt;&lt;small class=&quot;d-flex justify-content-center&quot;&gt;Lustre vs. JuiceFS 每秒处理数据量对比&lt;/small&gt;&lt;p&gt;从测试结果来看，单从数据读取效率上，在 wav 小文件方面，&lt;strong&gt;JuiceFS 为 6.45 it/s，而 Lustre 为 5.15 it/s，性能提升25%。JuiceFS 有效加速了我们端到端的模型训练，整体缩短了模型的产出时间。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）文字识别场景&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在文字识别场景中，模型为 CRNN backbone 为 MobileNet v2 ，测试环境如下：&lt;/p&gt;&lt;p&gt;| 模型 | CRNN backbone 为 MobileNet v2 |
| 深度学习框架 | PyTorch |
| 数据规模 | 3*32*320 的图像生成的 50G LMDB 数据 |
| 数据类型 | LMDB |
| GPU Server | 6 * NVIDIA Tesla V100 / 512G MEM / 56 CPU Cores |
| 缓存 | 200G 的内存缓存 |
| Batch size | 6*400 |&lt;/p&gt;&lt;p/&gt;&lt;small class=&quot;d-flex justify-content-center&quot;&gt;Lustre vs. JuiceFS 每个 batch 耗时对比&lt;/small&gt;&lt;p&gt;在这个测试中，主要做了 JuiceFS 跟 Lustre 的速度对比，&lt;strong&gt;从实验的结果来看从 Lustre 读每个 batch 耗时 1.5s，从 JuiceFS 读每个 batch 耗时为 1.1s，提升36%。从模型收敛的时间来看，从 Lustre 的 96 小时下降到 JuiceFS 的 86 小时，使用 JuiceFS 能够将 CRNN 模型的产出时间缩短 10 小时。&lt;/strong&gt;&lt;/p&gt;&lt;h2 id=&quot;收益二-加速-ai模型开发&quot;&gt;收益二：加速 AI模型开发&lt;/h2&gt;&lt;p/&gt;&lt;small class=&quot;d-flex justify-content-center&quot;&gt;模型开发示意图&lt;/small&gt;&lt;p&gt;在算法工程师将 AI 模型训练任务正式提交到超算集群之前，其模型需要经过大量的调试，我们为用户提供了调试环境，Dev Node 跟 Atlas 正式训练集群一样都是使用相同的存储，开发节点与训练节点都挂载 JuiceFS 客户端，因此在开发机的修改能够无缝迁移到 Atlas 训练集群。&lt;/p&gt;&lt;p&gt;用户在开发机上可以灵活地选择开发环境，既可以在宿主机搭配 Anaconda 进行远程调试，也可以使用容器的方式运行开发环境。用户的调试模型大部分是 PyTorch 跟 TensorFlow 类型的框架，我们发现在调试的时候需要频繁地 import Python 包，例如 numpy、torch 等，这种包都是大量的小文件组成的，基于旧的存储系统，用户 import 包的耗时需要几秒或者几十秒。算法人员反馈模型调试的效率比较低。&lt;strong&gt;作为统一开发环境，伴随着大量的安装包导入、代码编译、日志读写、样本下载，这要求调试机既能有较高的吞吐量，又能快速处理大量小文件。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通过引入 JuiceFS，我们在开发机上挂载了 JuiceFS 客户端，客户端挂载时候使用元数据缓存以及数据读缓存机制。在元数据缓存方面，当 JuiceFS 客户端使用 open() 操作打开一个文件的时候，其文件属性（attribute）就会自动缓存在客户端内存中，只要缓存未失效则随后执行的 getattr() 跟 open() 操作都会从内存缓存中立即返回结果。在执行 read() 操作的时候文件的 chunk 和 slice 信息也会自动缓存在客户端内存。数据缓存方面我们使用内存作为缓存介质，采用该方式用户调试的 Python 包在经过第一次 import 之后会全部缓存在内存上，第二次调试的时候，直接从内存缓存读取文件。&lt;strong&gt;相比之前的方式，整体速度有 2-4 倍的提速 ，极大地提高了用户的调试效率，用户的体验也更加好。&lt;/strong&gt;&lt;/p&gt;&lt;h1 id=&quot;05-juicefs-在-atlas-的使用方式&quot;&gt;05 JuiceFS 在 Atlas 的使用方式&lt;/h1&gt;&lt;p&gt;在数据的存放管理方式上，我们采用兼容现有分布式存储系统的管理方式，JuiceFS 集群的节点也都是对接 LDAP，每个节点会通过 LDAP 的客户端与 LDAP Server 集群进行交互认证。&lt;/p&gt;&lt;p&gt;超算平台上的每个组归属于不同的目录，每个目录下是各自组内或者部门内的成员，不同组之间的目录是不可见的。目录的权限是基于 Linux 的权限管控机制。用户在 Atlas 集群提交训练任务的时候，集群的任务提交工具会自动读取系统上用户的 UID 与 GID 信息然后将其注入用户提交的任务 Pod 的 securityContext 字段，则 Atlas 集群上运行的容器 Pod 内所有容器的进程运行的 UID 与存储系统上的信息一致，保证权限不越界。&lt;/p&gt;&lt;p/&gt;&lt;small class=&quot;d-flex justify-content-center&quot;&gt;存储权限认证架构图&lt;/small&gt;&lt;p&gt;在数据的访问方式上，云知声目前有 2 种使用方式：
1. 一种是通过计算节点的 HostPath 访问数据；
2. 另一种是更加云原生的方式，通过结合 Fluid + JuiceFS 对利用 JuiceFS 客户端为 Atlas 的应用提供数据的访问与加速。&lt;/p&gt;&lt;p&gt;1）HostPath Volume&lt;/p&gt;&lt;p/&gt;&lt;small class=&quot;d-flex justify-content-center&quot;&gt;HostPath Volume 数据读取示意图&lt;/small&gt;&lt;p&gt;第 1 种还是沿用之前的访问分布式文件存储系统的方式，通过 Kubernetes HostPath 的方式直接访问本地的存储系统客户端，我们在所有的 CPU 与 GPU 计算节点都部署了 JuiceFS 的客户端，用户提交计算任务的时候需要指定 Kubernetes volume 为 HostPath 的方式，将 JuiceFS 的目录映射。这种方式的缓存管理就比较裸，在用户侧是无法对缓存进行管理的。&lt;/p&gt;&lt;p&gt;2） Fluid + JuiceFS&lt;/p&gt;&lt;p&gt;第 2 种方式是结合 Fluid + JuiceFS 的方式，关于如何使用的具体方式可以参考&lt;a href=&quot;https://juicefs.com/blog/cn/posts/fluid-with-juicefs/&quot;&gt;我们之前的文章&lt;/a&gt; ，这里仅对架构做个简单的说明。&lt;/p&gt;&lt;p/&gt;&lt;small class=&quot;d-flex justify-content-center&quot;&gt;基于 Fluid 数据读取示意图&lt;/small&gt;&lt;p&gt;Fluid 会启动 JuiceFS 相关的组件包括 FUSE 跟 Worker pod，其中 FUSE Pod 提供了 JuiceFS 客户端的缓存能力，Worker Pod 则实现了对缓存生命周期的管理，Atlas 平台的 AI 离线训练任务通过与 FUSE Pod 客户端交互，进行 AI 训练数据的读取，通过 Fluid 提供的缓存调度能力以及数据集的可观测性，平台的用户可以通过亲和调度将缓存部署在特定的计算节点上，同时用户能够直观的看到缓存的使用情况（例如缓存数据集的大小、缓存的百分比、缓存的容量等）。&lt;/p&gt;&lt;h1 id=&quot;06-juicefs-存储生产环境建设&quot;&gt;06 JuiceFS 存储生产环境建设&lt;/h1&gt;&lt;h2 id=&quot;元数据引擎&quot;&gt;元数据引擎&lt;/h2&gt;&lt;p&gt;目前我们生产环境的元数据引擎采用 Redis，Redis 节点的系统盘做了 RAID1，同时 Redis 持久化的数据会定期同步到另一台备份节点上。Redis 的数据持久化我们采用 AOF + RDB 的方案，每秒进行一次数据持久化，相关配置如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;appendonly yes 
appendfsync everysec 
aof-load-truncated yes
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于我们节点采用的是 100G InifiBand，IB 的 &lt;a href=&quot;https://www.mellanox.com/products/infiniband-drivers/linux/mlnx_ofed&quot;&gt;网卡驱动&lt;/a&gt; 需要用户根据自己的操作系统版本下载对应的 ISO。目前我们的节点是采用 Kernel 5.4 的版本，由于 IB 驱动跟操作系统还有 Kernel 版本有较强的耦合性，当我们 Kernel 升级到 5.4 版本，驱动需要重新编译安装，驱动版本 MLNX_OFED_LINUX-5.5-1.0.3.2-rhel7.6-x86_64.iso 注意 GCC 的版本一定要是 GCC 9 的才行，否则编译过程会出现各种莫名其妙的问题。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# 安装 gcc9 
yum --enablerepo=extras install centos-release-scl-rh 
yum install devtoolset-9-gcc scl enable devtoolset-9 bash 
# 进行 IB 驱动编译 
mount /dev/sr0 ib 
./mlnx_add_kernel_support.sh -m /root/ib -k (kernel 版本)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;对象存储&quot;&gt;对象存储&lt;/h2&gt;&lt;p&gt;对象存储采用自建的 Ceph 集群，Ceph 集群采用 Cephadm 进行部署，目前生产环境用的是 Octopus 版本。Cephadm 是随着 Ceph 新版本 v15.2.0（Octopus）发布的安装工具，并且不支持 Ceph 的旧版本，Cephadm 不依赖于外部配置工具，如 Ansible、 Rook 和 Salt，它通过 SSH 将管理器守护进程连接到主机来实现这一点。管理器守护进程可以添加、删除和更新 Ceph 容器。&lt;/p&gt;&lt;p&gt;通过 Cephadm 引导一个单节点的集群，Cephadm 会在执行 bootstrap 引导的节点部署 mgr 跟 mon 服务，当添加其他节点的时候，会自动在其中一台部署 mgr 管理节点，目前我们生产采用 2 个管理节点 3 个监控节点。&lt;/p&gt;&lt;p&gt;在 Ceph 调优方面我们借鉴了社区其他用户分享的方案，感谢携程的工程师在我们调优过程中提供的帮助 （&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg4NTU0MzEyMg==&amp;amp;mid=2247495811&amp;amp;idx=2&amp;amp;sn=475c9f9cb910f05f9eb93a8de1033e4a&amp;amp;scene=21#wechat_redirect&quot;&gt;点击此处查看&lt;/a&gt;），主要做了以下实践：&lt;/p&gt;&lt;p&gt;服务器层面（&lt;a href=&quot;https://docs.ceph.com/en/latest/start/hardware-recommendations&quot;&gt;参考&lt;/a&gt;）：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;42Cores 256GB 24*18T HDD&lt;/li&gt;&lt;li&gt;系统盘: 2* 960G SAS SSD&lt;/li&gt;&lt;li&gt;BlueStore&lt;/li&gt;&lt;li&gt;关闭 NUMA&lt;/li&gt;&lt;li&gt;升级 kernel: 5.4.146 开启 io_uring&lt;/li&gt;&lt;li&gt;Kernel pid max，修改 /proc/sys/kernel/pid_max&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Ceph 配置方面：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Ceph RADOS：直接调用 librados 接口，不走 S3 协议&lt;/li&gt;&lt;li&gt;Bucket shard&lt;/li&gt;&lt;li&gt;关闭 pg 的自动调整功能&lt;/li&gt;&lt;li&gt;OSD 日志存储（采用 bluestore，建议裸容量配比—— block : block.db : block.wal = 100:1:1，后两者建议采用 SSD 或 NVMe SSD）&lt;/li&gt;&lt;li&gt;3 副本&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;juicefs-客户端&quot;&gt;JuiceFS 客户端&lt;/h2&gt;&lt;p&gt;我们环境中 JuiceFS 对接的对象存储是 Ceph RADOS，JuiceFS 采用 librados 与 Ceph 进行交互，因此需要重新编译 JuiceFS 客户端，建议 librados 的版本要跟 Ceph 的对应，例如在我们的环境 Ceph 版本是 Octopus（v15.2.*），librados 的版本建议为 v15.2.*，CentOS 自带的 librados 版本比较低，因此我们可以在官网自己下载对应的包，我们的环境上只需要下载 librados2-15.2.10-0.el7.x86_64.rpm 和 librados-devel-15.2.10-0.el7.x86_64.rpm。然后运行如下命令安装：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;yum localinstall -y librad*
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装 librados 后即可编译 JuiceFS 客户端了（推荐 Go 1.17+ 、GCC 5.4+）：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;make juicefs.ceph
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编译完 JuiceFS 即可创建文件系统并在计算节点进行 JuiceFS 客户端的挂载了。目前 JuiceFS 在我们的生产环境使用还是有一大部分是直接通过 Kubernetes 的 HostPath 进行挂载，因此我们在各个 GPU、CPU 节点中都挂载了 JuiceFS 客户端，并通过 systemctl 管理 JuiceFS 的挂载进程，实现开机自动挂载与故障的恢复。&lt;/p&gt;&lt;h1 id=&quot;07-未来展望与规划&quot;&gt;07 未来展望与规划&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;最后归纳下 Lustre 与 JuiceFS 的特点与适用场景&lt;/strong&gt;，企业可以根据自身的业务场景、运维能力以及存储规模做出相应的选择。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Lustre 作为老牌 HPC 领域的存储系统，为许多全球最大的超算系统提供动力，具有多年的生产环境经验。其具有符合 POSIX 标准、支持各种高性能低时延的网络，允许 RDMA 访问的优点，适用于传统 HPC 领域的高性能计算，但是在云原生场景的适配上还不够完善，目前只能采用 HostPath Volume 对接，而且其软件运行在 Linux 内核之上，对运维人员要求更高；&lt;/li&gt;&lt;li&gt;JuiceFS 是一款云原生领域的分布式存储系统产品，提供了 CSI Driver 以及 Fluid 等方式使用能够更好地与 Kubernetes 进行结合。在运维部署方面为用户提供了更多灵活的选择，用户既可以选择在云上也可以选择私有化部署，在存储扩容运维方面较为简单。完全兼容 POSIX 标准使得深度学习的应用可以无缝迁移，但是由于后端对象存储的特点其在随机写方面会有较高的延迟，在只读的场景可以使用客户端的多级缓存进行加速较为符合我们的业务特点。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Atlas 平台未来与 JuiceFS 相关的规划是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;元数据引擎升级：TiKV 适合在 1 亿以上文件数量（最多可以支撑到百亿级文件），对性能以及数据安全都有较高要求的场景，目前我们已经完成了 TiKV 的内部测试也在积极跟进社区的进展，后续要将元数据引擎迁移到 TiKV。&lt;/li&gt;&lt;li&gt;基于目录（项目）的文件配额：开源版本目前还不支持基于目录的配额，目前我们每个部门是归属在 JuiceFS 的不同的目录下，需要对目录的配额做限制。JuiceFS 社区版已经在规划实现这个特性，会在 v1.0.0 之后的版本正式发布。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;感谢 JuiceFS 开源社区在云知声 Atlas 计算平台高效存储建设的过程中提供的技术支持，云知声也在积极地进行内部测试，争取后续将开发的功能以及改进回馈到开源社区。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>357b8e00abe61e39f52bd4ca8d7b3581</guid>
<title>看完这篇还不会搞「策略模式」算我输. . .</title>
<link>https://toutiao.io/k/d9ai32f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;strong&gt;&lt;em&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.66875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z85sZvtmju1ITB5pCPeoYmFdq6lZbhyLjhIuTWmibJgueIjLALCFUqAjV8GRcibQsUwicMnsIWp5iaMg8NBczeLPfQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;首先简单讨论几个问题：&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;设计模式就是为了重用代码？基本是的，同时也方便扩展维护&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;策略模式就是一堆if...else...？是的&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;策略模式通常和什么模式搞基？最直观模版模式。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;最初原型：&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;红包&quot;&lt;/span&gt;.&lt;span class=&quot;code-snippet__keyword&quot;&gt;equals&lt;/span&gt;(grantType)){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;会员&quot;&lt;/span&gt;.&lt;span class=&quot;code-snippet__keyword&quot;&gt;equals&lt;/span&gt;(grantType)){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;这么写有问题吗？我个人觉得没有任何问题，但确实新增判断分支时需要改这块代码逻辑，不易维护扩展，而且每个条件分支没什么依赖，却被耦合在一起，使用switch...case...类似。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;不建议使用map&amp;lt;type,Bean&amp;gt;:&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;我为什么不建议使用map将处理类型和处理bean收集起来？假设使用map进行收集，那么你需要初始化组装这个map，如下：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Map&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;, Bean&amp;gt; map = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;, Bean&amp;gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;8&lt;/span&gt;){{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    put(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;红包&quot;&lt;/span&gt;,getBean());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    put(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;会员&quot;&lt;/span&gt;,getBean());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;按类型进行收集，然后用的时候再根据类型获取对应的bean。显然这里put操作需要维护，所以不建议使用这种方式。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;不建议使用applicationContext去getBean：&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;还有具体的处理类的名字当作一种类型，通过这个beanName来获取bean，如下：&lt;em&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;applicationContext&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.getBean&lt;/span&gt;(&quot;红包&quot;,&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;ICouponService&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.class&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;需要根据beanName来获取bean，beanName需要作为参数传进来，先不说beanName和业务类型名字大相径庭，传beanName就有点诡异。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;个人愚见：&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;使用接口定义规范&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ICouponService&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;canDiscount&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String couponStrArr)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;discount&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(CouponContext couponContext)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;getMinusAmount&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; userid)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;    2.最常见的模式：模版模式&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;AbstractCouponService&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ICouponService&lt;/span&gt;&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;discount&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(CouponContext couponContext)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        couponContext.finalAmount = couponContext.totalAmount - getMinusAmount(couponContext.getUid());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;    3.if判断应该在策略类里&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Service&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;RedPacketCouponServiceImpl&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;AbstractCouponService&lt;/span&gt;&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    String grantType = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;红包优惠&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;canDiscount&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String couponStrArr)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; couponStrArr.contains(grantType);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;getMinusAmount&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; uid)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;100&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Service&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;VipCouponServiceImpl&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;AbstractCouponService&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    String grantType = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;会员优惠&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;canDiscount&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String couponStrArr)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; couponStrArr.contains(grantType);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;discount&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(CouponContext couponContext)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        couponContext.finalAmount = couponContext.finalAmount * getMinusAmount(couponContext.getUid()) / &lt;span class=&quot;code-snippet__number&quot;&gt;100&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;getMinusAmount&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; uid)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;80&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;    4.支持哪些策略应该动态配置，这里使用apollo&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@RestController&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@RequestMapping(&lt;span class=&quot;code-snippet__meta-string&quot;&gt;&quot;/coupon&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;CouponController&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Value(&lt;span class=&quot;code-snippet__meta-string&quot;&gt;&quot;&lt;span class=&quot;code-snippet__subst&quot;&gt;${coupon.strarr:}&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    String couponStrArr;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}    &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;    5.使用List收集所有策略&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@&lt;span class=&quot;code-snippet__keyword&quot;&gt;Autowired&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;private List&amp;lt;ICouponService&amp;gt; couponServiceList;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@&lt;span class=&quot;code-snippet__keyword&quot;&gt;GetMapping&lt;/span&gt;(&quot;&lt;span class=&quot;code-snippet__keyword&quot;&gt;cacl&lt;/span&gt;&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public ResultInfo caclCoupon(int totalAmount){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;CouponContext&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;couponContext&lt;/span&gt; = &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;CouponContext&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.builder&lt;/span&gt;()&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.totalAmount&lt;/span&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;totalAmount&lt;/span&gt;)&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.build&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;couponServiceList&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.stream&lt;/span&gt;()&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.filter&lt;/span&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;e-&lt;/span&gt;&amp;gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.canDiscount&lt;/span&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;couponStrArr&lt;/span&gt;))&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.forEach&lt;/span&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;e-&lt;/span&gt;&amp;gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.discount&lt;/span&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;couponContext&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;ResultInfo&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.success&lt;/span&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;couponContext&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;本文从实际应用出发，抽象出简化版的优惠扣减模型，采用模版模式&amp;amp;策略模式完成。策略模式本质就是if...else...，开发应用也不该被设计模式所束缚，策略多了自然就会使用策略模式了。同意作者请点在看，觉得有用请点个赞。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5226390685640362&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z85sZvtmju2ZMvElmjsA4IjbhwMTv9HFQHMSCWvDnX6DtgEiaVYia6ZlZL9jPGvBDIyIDK5tAP1oZGlJxDhFYSYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;773&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1733a6f416dc871a7b3de7e82122a005</guid>
<title>RocketMQ的原理和实战</title>
<link>https://toutiao.io/k/grrdmf6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body blogpost-body-html&quot;&gt;
&lt;ol class=&quot;list-paddingleft-2&quot;&gt;
&lt;li&gt;
&lt;p&gt;搭建环境&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;helloworld&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我也不例外，直接搞起来。&lt;/p&gt;
&lt;h1 class=&quot;eye-protector-processed&quot;&gt;一、RocketMQ的安装&lt;/h1&gt;
&lt;h2 class=&quot;eye-protector-processed&quot;&gt;1、文档&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;官方网站&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;http://rocketmq.apache.org&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GitHub&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;https://github.com/apache/rocketmq&lt;/p&gt;
&lt;h2 class=&quot;eye-protector-processed&quot;&gt;2、下载&lt;/h2&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;wget https://mirror.bit.edu.cn/apache/rocketmq/4.7.0/rocketmq-all-4.7.0-bin-release.zip
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们是基于Centos8来的，面向官方文档学习，所以下载地址自然也是官方的。&lt;/p&gt;
&lt;p&gt;去官方网站找合适的版本进行下载，目前我这里最新的是4.7.0版本。&lt;/p&gt;
&lt;p&gt;http://rocketmq.apache.org/dowloading/releases/&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages medium-zoom-image&quot; title=&quot;RocketMQ入门到入土（一）新手也能看懂的原理和实战！&quot; src=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/06/java0-1593308598.png&quot; alt=&quot;RocketMQ入门到入土（一）新手也能看懂的原理和实战！&quot; data-original=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/06/java0-1593308598.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.7.0/rocketmq-all-4.7.0-bin-release.zip&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages medium-zoom-image&quot; title=&quot;RocketMQ入门到入土（一）新手也能看懂的原理和实战！&quot; src=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/06/java5-1593308598.png&quot; alt=&quot;RocketMQ入门到入土（一）新手也能看懂的原理和实战！&quot; data-original=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/06/java5-1593308598.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2 class=&quot;eye-protector-processed&quot;&gt;3、准备工作&lt;/h2&gt;
&lt;h3 class=&quot;eye-protector-processed&quot;&gt;3.1、解压&lt;/h3&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;unzip rocketmq-all-4.7.0-bin-release.zip
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 class=&quot;eye-protector-processed&quot;&gt;3.2、安装jdk&lt;/h3&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;sudo yum install java-1.8.0-openjdk-devel
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 class=&quot;eye-protector-processed&quot;&gt;4、启动&lt;/h2&gt;
&lt;h3 class=&quot;eye-protector-processed&quot;&gt;4.1、启动namesrv&lt;/h3&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;cd rocketmq-all-4.7.0-bin-release/bin
./mqnamesrv
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 class=&quot;eye-protector-processed&quot;&gt;4.2、启动broker&lt;/h3&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;cd rocketmq-all-4.7.0-bin-release/bin
./mqbroker -n localhost:9876
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常见错误以及解决方案：&lt;/p&gt;
&lt;p&gt;常见错误：启动broker失败 &lt;code class=&quot;eye-protector-processed&quot;&gt;Cannot allocate memory&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;[root@node-113b bin]# ./mqbroker -n localhost:9876
Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x00000005c0000000, 8589934592, 0) failed
; error=&#x27;Cannot allocate memory&#x27; (errno=12)#
# There is insufficient memory for the Java Runtime Environment to continue.
# Native memory allocation (mmap) failed to map 8589934592 bytes for committing reserved memory.
# An error report file with more information is saved as:
# /usr/local/rocketmq/bin/hs_err_pid1997.log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;是由于默认内存分配的太大了，超出了本机内存，直接OOM了。&lt;/p&gt;
&lt;p&gt;修改bin/目录下的如下两个脚本&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;runbroker.sh
runserver.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这两个脚本里都搜索&lt;code class=&quot;eye-protector-processed&quot;&gt;-server -Xms&lt;/code&gt;，将其内存分配小点，自己玩的话512MB就足够了，够够的了！&lt;/p&gt;
&lt;h3 class=&quot;eye-protector-processed&quot;&gt;4.3、启动成功标识&lt;/h3&gt;
&lt;p&gt;namesrv启动成功标识：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages medium-zoom-image&quot; title=&quot;RocketMQ入门到入土（一）新手也能看懂的原理和实战！&quot; src=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/06/java7-1593308598.png&quot; alt=&quot;RocketMQ入门到入土（一）新手也能看懂的原理和实战！&quot; data-original=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/06/java7-1593308598.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;broker启动成功标识：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages medium-zoom-image&quot; title=&quot;RocketMQ入门到入土（一）新手也能看懂的原理和实战！&quot; src=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/06/java2-1593308598.png&quot; alt=&quot;RocketMQ入门到入土（一）新手也能看懂的原理和实战！&quot; data-original=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/06/java2-1593308598.png&quot;/&gt;&lt;/p&gt;
&lt;h1 class=&quot;eye-protector-processed&quot;&gt;二、RocketMQ控制台的安装&lt;/h1&gt;
&lt;p&gt;控制台目前获取方式有如下两种：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot;&gt;
&lt;li&gt;
&lt;p&gt;第三方网站去下载现成的，比如csdn等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;官方源码包自己编译而成，官方没有现成的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们这里当然采取官方方式。&lt;/p&gt;
&lt;h2 class=&quot;eye-protector-processed&quot;&gt;1、官方文档&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;github仓库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;https://github.com/apache/rocketmq-externals&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中文指南&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;https://github.com/apache/rocketmq-externals/blob/master/rocketmq-console/doc/1_0_0/UserGuide_CN.md&lt;/p&gt;
&lt;h2 class=&quot;eye-protector-processed&quot;&gt;2、下载源码&lt;/h2&gt;
&lt;p&gt;https://github.com/apache/rocketmq-externals/tree/release-rocketmq-console-1.0.0&lt;/p&gt;
&lt;h2 class=&quot;eye-protector-processed&quot;&gt;3、修改配置（可选）&lt;/h2&gt;
&lt;p&gt;我们下载完解压后的文件目录如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2022.cnblogs.com/blog/420532/202206/420532-20220618094036965-975680575.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改&lt;code class=&quot;eye-protector-processed&quot;&gt;rocketmq-console/src/main/resources/application.properties&lt;/code&gt;文件的&lt;code class=&quot;eye-protector-processed&quot;&gt;server.port&lt;/code&gt;就欧了。默认8080。&lt;/p&gt;
&lt;h2 class=&quot;eye-protector-processed&quot;&gt;4、编译打包&lt;/h2&gt;
&lt;p&gt;进入&lt;code class=&quot;eye-protector-processed&quot;&gt;rocketmq-console&lt;/code&gt;，然后用maven进行编译打包， 如果没有mvn， 安装它： yum install maven ，然后：&lt;/p&gt;
&lt;pre class=&quot;language-bash highlighter-hljs&quot;&gt;&lt;code&gt;mvn clean package -DskipTests&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打包完会在target下生成我们spring boot的jar程序，直接&lt;code class=&quot;eye-protector-processed&quot;&gt;java -jar&lt;/code&gt;启动完事。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages medium-zoom-image&quot; title=&quot;RocketMQ入门到入土（一）新手也能看懂的原理和实战！&quot; src=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/06/java5-1593308598-1.png&quot; alt=&quot;RocketMQ入门到入土（一）新手也能看懂的原理和实战！&quot; data-original=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/06/java5-1593308598-1.png&quot;/&gt;&lt;/p&gt;
&lt;h2 class=&quot;eye-protector-processed&quot;&gt;5、启动控制台&lt;/h2&gt;
&lt;p&gt;将编译打包好的springboot程序扔到服务器上，执行如下命令进行启动&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;java -jar rocketmq-console-ng-1.0.1.jar --rocketmq.config.namesrvAddr=127.0.0.1:9876
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote class=&quot;eye-protector-processed&quot;&gt;
&lt;p&gt;如果想后台启动就nohup &amp;amp;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;访问一下看看效果：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages medium-zoom-image&quot; title=&quot;RocketMQ入门到入土（一）新手也能看懂的原理和实战！&quot; src=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/06/java4-1593308598.png&quot; alt=&quot;RocketMQ入门到入土（一）新手也能看懂的原理和实战！&quot; data-original=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/06/java4-1593308598.png&quot;/&gt;&lt;/p&gt;
&lt;h1 class=&quot;eye-protector-processed&quot;&gt;三、测试&lt;/h1&gt;
&lt;blockquote class=&quot;eye-protector-processed&quot;&gt;
&lt;p&gt;rocketmq给我们提供了测试工具和测试类，可以在安装完很方便的进行测试。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 class=&quot;eye-protector-processed&quot;&gt;0、准备工作&lt;/h2&gt;
&lt;p&gt;rocketmq给我们提供的默认测试工具在bin目录下，叫&lt;code class=&quot;eye-protector-processed&quot;&gt;tools.sh&lt;/code&gt;。我们测试前需要配置这个脚本，为他指定namesrv地址才可以，否则测试发送/消费消息的时候会出现如下错误 &lt;strong&gt;connect to null failed&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;22:49:02.470 [main] DEBUG i.n.u.i.l.InternalLoggerFactory - Using SLF4J as the default logging framework
RocketMQLog:WARN No appenders could be found for logger (io.netty.util.internal.PlatformDependent0).
RocketMQLog:WARN Please initialize the logger system properly.
java.lang.IllegalStateException: org.apache.rocketmq.remoting.exception.RemotingConnectException: connect to null failed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置如下：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;vim tools.sh
# 在export JAVA_HOME上面添加如下这段代码
export NAMESRV_ADDR=localhost:9876
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 class=&quot;eye-protector-processed&quot;&gt;1、发送消息&lt;/h2&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;./tools.sh org.apache.rocketmq.example.quickstart.Producer&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote class=&quot;eye-protector-processed&quot;&gt;
&lt;p&gt;成功的话会看到哗哗哗的日志，因为这个类会发送1000条消息到TopicTest这个Topic下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 class=&quot;eye-protector-processed&quot;&gt;2、消费消息&lt;/h2&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;./tools.sh org.apache.rocketmq.example.quickstart.Consumer&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote class=&quot;eye-protector-processed&quot;&gt;
&lt;p&gt;成功的话会看到哗哗哗的日志，因为这个类会消费TopicTest下的全部消息。刚发送的1000条都会被消费掉。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 class=&quot;eye-protector-processed&quot;&gt;3、控制台&lt;/h2&gt;
&lt;p&gt;发送成功后我们自然也能来到管控台去看消息和消费情况等等等信息&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages medium-zoom-image&quot; title=&quot;RocketMQ入门到入土（一）新手也能看懂的原理和实战！&quot; src=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/06/java1-1593308598.png&quot; alt=&quot;RocketMQ入门到入土（一）新手也能看懂的原理和实战！&quot; data-original=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/06/java1-1593308598.png&quot;/&gt;&lt;/p&gt;
&lt;h1 class=&quot;eye-protector-processed&quot;&gt;四、架构图以及角色&lt;/h1&gt;
&lt;h2 class=&quot;eye-protector-processed&quot;&gt;1、架构图&lt;/h2&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages medium-zoom-image&quot; title=&quot;RocketMQ入门到入土（一）新手也能看懂的原理和实战！&quot; src=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/06/java4-1593308598-1.png&quot; alt=&quot;RocketMQ入门到入土（一）新手也能看懂的原理和实战！&quot; data-original=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/06/java4-1593308598-1.png&quot;/&gt;&lt;/p&gt;
&lt;h2 class=&quot;eye-protector-processed&quot;&gt;2、角色&lt;/h2&gt;
&lt;h3 class=&quot;eye-protector-processed&quot;&gt;2.1、Broker&lt;/h3&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;
&lt;li&gt;
&lt;p&gt;理解成RocketMQ本身&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;broker主要用于producer和consumer接收和发送消息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;broker会定时向nameserver提交自己的信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;是消息中间件的消息存储、转发服务器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个Broker节点，在启动时，都会遍历NameServer列表，与每个NameServer建立长连接，注册自己的信息，之后定时上报&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 class=&quot;eye-protector-processed&quot;&gt;2.2、Nameserver&lt;/h3&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;
&lt;li&gt;
&lt;p&gt;理解成zookeeper的效果，只是他没用zk，而是自己写了个nameserver来替代zk&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;底层由netty实现，提供了路由管理、服务注册、服务发现的功能，是一个无状态节点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nameserver是服务发现者，集群中各个角色（producer、broker、consumer等）都需要定时向nameserver上报自己的状态，以便互相发现彼此，超时不上报的话，nameserver会把它从列表中剔除&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nameserver可以部署多个，当多个nameserver存在的时候，其他角色同时向他们上报信息，以保证高可用，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NameServer集群间互不通信，没有主备的概念&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nameserver内存式存储，nameserver中的broker、topic等信息默认不会持久化，所以他是无状态节点&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 class=&quot;eye-protector-processed&quot;&gt;2.3、Producer&lt;/h3&gt;

&lt;h3 class=&quot;eye-protector-processed&quot;&gt;2.4、Consumer&lt;/h3&gt;

&lt;h2 class=&quot;eye-protector-processed&quot;&gt;3、核心流程&lt;/h2&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;
&lt;li&gt;
&lt;p&gt;Broker都注册到Nameserver上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Producer发消息的时候会从Nameserver上获取发消息的topic信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Producer向提供服务的所有master建立长连接，且定时向master发送心跳&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Consumer通过NameServer集群获得Topic的路由信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Consumer会与所有的Master和所有的Slave都建立连接进行监听新消息&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 class=&quot;eye-protector-processed&quot;&gt;五、核心概念&lt;/h1&gt;
&lt;h2 class=&quot;eye-protector-processed&quot;&gt;1、Message&lt;/h2&gt;
&lt;p&gt;消息载体。Message发送或者消费的时候必须指定Topic。Message有一个可选的Tag项用于过滤消息，还可以添加额外的键值对。&lt;/p&gt;
&lt;h2 class=&quot;eye-protector-processed&quot;&gt;2、topic&lt;/h2&gt;
&lt;p&gt;消息的逻辑分类，发消息之前必须要指定一个topic才能发，就是将这条消息发送到这个topic上。消费消息的时候指定这个topic进行消费。就是逻辑分类。&lt;/p&gt;
&lt;h2 class=&quot;eye-protector-processed&quot;&gt;3、queue&lt;/h2&gt;
&lt;p&gt;1个Topic会被分为N个Queue，数量是可配置的。message本身其实是存储到queue上的，消费者消费的也是queue上的消息。多说一嘴，比如1个topic4个queue，有5个Consumer都在消费这个topic，那么会有一个consumer浪费掉了，因为负载均衡策略，每个consumer消费1个queue，5&amp;gt;4，溢出1个，这个会不工作。&lt;/p&gt;
&lt;h2 class=&quot;eye-protector-processed&quot;&gt;4、Tag&lt;/h2&gt;
&lt;p&gt;Tag 是 Topic 的进一步细分，顾名思义，标签。每个发送的时候消息都能打tag，消费的时候可以根据tag进行过滤，选择性消费。&lt;/p&gt;
&lt;h2 class=&quot;eye-protector-processed&quot;&gt;5、Message Model&lt;/h2&gt;
&lt;p&gt;消息模型：集群（Clustering）和广播（Broadcasting）&lt;/p&gt;
&lt;h2 class=&quot;eye-protector-processed&quot;&gt;6、Message Order&lt;/h2&gt;
&lt;p&gt;消息顺序：顺序（Orderly）和并发（Concurrently）&lt;/p&gt;
&lt;h2 class=&quot;eye-protector-processed&quot;&gt;7、Producer Group&lt;/h2&gt;
&lt;p&gt;消息生产者组&lt;/p&gt;
&lt;h2 class=&quot;eye-protector-processed&quot;&gt;8、Consumer Group&lt;/h2&gt;
&lt;p&gt;消息消费者组&lt;/p&gt;
&lt;h1 class=&quot;eye-protector-processed&quot;&gt;六、ACK&lt;/h1&gt;
&lt;p&gt;首先要明确一点：&lt;strong&gt;ACK机制是发生在Consumer端的，不是在Producer端的&lt;/strong&gt;。也就是说Consumer消费完消息后要进行ACK确认，如果未确认则代表是消费失败，这时候Broker会进行重试策略（仅集群模式会重试）。ACK的意思就是：Consumer说：ok，我消费成功了。这条消息给我标记成已消费吧。&lt;/p&gt;
&lt;h1 class=&quot;eye-protector-processed&quot;&gt;七、消费模式&lt;/h1&gt;
&lt;h2 class=&quot;eye-protector-processed&quot;&gt;1、集群模式（Clustering）&lt;/h2&gt;
&lt;h3 class=&quot;eye-protector-processed&quot;&gt;1.1、图解&lt;/h3&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages medium-zoom-image&quot; title=&quot;RocketMQ入门到入土（一）新手也能看懂的原理和实战！&quot; src=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/06/java0-1593308598-1.png&quot; alt=&quot;RocketMQ入门到入土（一）新手也能看懂的原理和实战！&quot; data-original=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/06/java0-1593308598-1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3 class=&quot;eye-protector-processed&quot;&gt;1.2、特点&lt;/h3&gt;

&lt;h2 class=&quot;eye-protector-processed&quot;&gt;2、广播模式（Broadcasting）&lt;/h2&gt;
&lt;h3 class=&quot;eye-protector-processed&quot;&gt;2.1、图解&lt;/h3&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages medium-zoom-image&quot; title=&quot;RocketMQ入门到入土（一）新手也能看懂的原理和实战！&quot; src=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/06/java2-1593308599.png&quot; alt=&quot;RocketMQ入门到入土（一）新手也能看懂的原理和实战！&quot; data-original=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/06/java2-1593308599.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3 class=&quot;eye-protector-processed&quot;&gt;2.2、特点&lt;/h3&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;
&lt;li&gt;
&lt;p&gt;消费进度由consumer维护&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保证每个消费者都消费一次消息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消费失败的消息不会重投&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 class=&quot;eye-protector-processed&quot;&gt;八、Java API&lt;/h1&gt;
&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;pom如下&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.rocketmq&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;rocketmq-client&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;4.7.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 class=&quot;eye-protector-processed&quot;&gt;1、Producer&lt;/h2&gt;
&lt;blockquote class=&quot;eye-protector-processed&quot;&gt;
&lt;p&gt;发消息肯定要必备如下几个条件：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;
&lt;li&gt;
&lt;p&gt;指定生产组名（不能用默认的，会报错）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置namesrv地址（必须）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定topic name（必须）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定tag/key（可选）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;验证消息是否发送成功：消息发送完后可以启动消费者进行消费，也可以去管控台上看消息是否存在。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 class=&quot;eye-protector-processed&quot;&gt;1.1、send（同步）&lt;/h3&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;public class Producer {
    public static void main(String[] args) throws Exception {
        // 指定生产组名为my-producer
        DefaultMQProducer producer = new DefaultMQProducer(&quot;my-producer&quot;);
        // 配置namesrv地址
        producer.setNamesrvAddr(&quot;124.57.180.156:9876&quot;);
        // 启动Producer
        producer.start();
        // 创建消息对象，topic为：myTopic001，消息内容为：hello world
        Message msg = new Message(&quot;myTopic001&quot;, &quot;hello world&quot;.getBytes());
        // 发送消息到mq，同步的
        SendResult result = producer.send(msg);
        System.out.println(&quot;发送消息成功！result is : &quot; + result);
        // 关闭Producer
        producer.shutdown();
        System.out.println(&quot;生产者 shutdown！&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;发送消息成功！result is : SendResult [sendStatus=SEND_OK, msgId=A9FE854140F418B4AAC26F7973910000, offsetMsgId=7B39B49D00002A9F00000000000589BE, messageQueue=MessageQueue [topic=myTopic001, brokerName=broker-a, queueId=0], queueOffset=7]
生产者 shutdown！
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 class=&quot;eye-protector-processed&quot;&gt;1.2、send（批量）&lt;/h3&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;public class ProducerMultiMsg {
    public static void main(String[] args) throws Exception {
        // 指定生产组名为my-producer
        DefaultMQProducer producer = new DefaultMQProducer(&quot;my-producer&quot;);
        // 配置namesrv地址
        producer.setNamesrvAddr(&quot;124.57.180.156:9876&quot;);
        // 启动Producer
        producer.start();

        String topic = &quot;myTopic001&quot;;
        // 创建消息对象，topic为：myTopic001，消息内容为：hello world1/2/3
        Message msg1 = new Message(topic, &quot;hello world1&quot;.getBytes());
        Message msg2 = new Message(topic, &quot;hello world2&quot;.getBytes());
        Message msg3 = new Message(topic, &quot;hello world3&quot;.getBytes());
        // 创建消息对象的集合，用于批量发送
        List&amp;lt;Message&amp;gt; msgs = new ArrayList&amp;lt;&amp;gt;();
        msgs.add(msg1);
        msgs.add(msg2);
        msgs.add(msg3);
        // 批量发送的api的也是send()，只是他的重载方法支持List&amp;lt;Message&amp;gt;，同样是同步发送。
        SendResult result = producer.send(msgs);
        System.out.println(&quot;发送消息成功！result is : &quot; + result);
        // 关闭Producer
        producer.shutdown();
        System.out.println(&quot;生产者 shutdown！&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;cnb-code-toolbar&quot;&gt;&lt;span class=&quot;cnb-code-toolbar-item&quot;&gt;JAVA&lt;span class=&quot;cnb-code-toolbar-item&quot;&gt; 复制&lt;span class=&quot;cnb-code-toolbar-item&quot;&gt; 全屏&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;发送消息成功！result is : SendResult [sendStatus=SEND_OK, msgId=A9FE854139C418B4AAC26F7D13770000,A9FE854139C418B4AAC26F7D13770001,A9FE854139C418B4AAC26F7D13770002, offsetMsgId=7B39B49D00002A9F0000000000058A62,7B39B49D00002A9F0000000000058B07,7B39B49D00002A9F0000000000058BAC, messageQueue=MessageQueue [topic=myTopic001, brokerName=broker-a, queueId=0], queueOffset=8]
生产者 shutdown！
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote class=&quot;eye-protector-processed&quot;&gt;
&lt;p&gt;从结果中可以看到只有一个msgId，所以可以发现虽然是三条消息对象，但是却只发送了一次，大大节省了client与server的开销。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;错误情况：&lt;/p&gt;
&lt;p&gt;批量发送的topic必须是同一个，如果message对象指定不同的topic，那么批量发送的时候会报错：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;Exception in thread &quot;main&quot; org.apache.rocketmq.client.exception.MQClientException: Failed to initiate the MessageBatch
For more information, please visit the url, http://rocketmq.apache.org/docs/faq/
    at org.apache.rocketmq.client.producer.DefaultMQProducer.batch(DefaultMQProducer.java:950)
    at org.apache.rocketmq.client.producer.DefaultMQProducer.send(DefaultMQProducer.java:898)
    at com.chentongwei.mq.rocketmq.ProducerMultiMsg.main(ProducerMultiMsg.java:29)
Caused by: java.lang.UnsupportedOperationException: The topic of the messages in one batch should be the same
    at org.apache.rocketmq.common.message.MessageBatch.generateFromList(MessageBatch.java:58)
    at org.apache.rocketmq.client.producer.DefaultMQProducer.batch(DefaultMQProducer.java:942)
    ... 2 more
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 class=&quot;eye-protector-processed&quot;&gt;1.3、sendCallBack（异步）&lt;/h3&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;public class ProducerASync {
    public static void main(String[] args) throws Exception {
       // 指定生产组名为my-producer
        DefaultMQProducer producer = new DefaultMQProducer(&quot;my-producer&quot;);
        // 配置namesrv地址
        producer.setNamesrvAddr(&quot;124.57.180.156:9876&quot;);
        // 启动Producer
        producer.start();

        // 创建消息对象，topic为：myTopic001，消息内容为：hello world async
        Message msg = new Message(&quot;myTopic001&quot;, &quot;hello world async&quot;.getBytes());
        // 进行异步发送，通过SendCallback接口来得知发送的结果
        producer.send(msg, new SendCallback() {
            // 发送成功的回调接口
            @Override
            public void onSuccess(SendResult sendResult) {
                System.out.println(&quot;发送消息成功！result is : &quot; + sendResult);
            }
            // 发送失败的回调接口
            @Override
            public void onException(Throwable throwable) {
                throwable.printStackTrace();
                System.out.println(&quot;发送消息失败！result is : &quot; + throwable.getMessage());
            }
        });

        producer.shutdown();
        System.out.println(&quot;生产者 shutdown！&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;生产者 shutdown！
java.lang.IllegalStateException: org.apache.rocketmq.remoting.exception.RemotingConnectException: connect to [124.57.180.156:9876] failed
    at org.apache.rocketmq.client.impl.factory.MQClientInstance.updateTopicRouteInfoFromNameServer(MQClientInstance.java:681)
    at org.apache.rocketmq.client.impl.factory.MQClientInstance.updateTopicRouteInfoFromNameServer(MQClientInstance.java:511)
    at org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.tryToFindTopicPublishInfo(DefaultMQProducerImpl.java:692)
    at org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.sendDefaultImpl(DefaultMQProducerImpl.java:556)
    at org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.access$300(DefaultMQProducerImpl.java:97)
    at org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl$4.run(DefaultMQProducerImpl.java:510)
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
    at java.util.concurrent.FutureTask.run(FutureTask.java:266)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
Caused by: org.apache.rocketmq.remoting.exception.RemotingConnectException: connect to [124.57.180.156:9876] failed
    at org.apache.rocketmq.remoting.netty.NettyRemotingClient.getAndCreateNameserverChannel(NettyRemotingClient.java:441)
    at org.apache.rocketmq.remoting.netty.NettyRemotingClient.getAndCreateChannel(NettyRemotingClient.java:396)
    at org.apache.rocketmq.remoting.netty.NettyRemotingClient.invokeSync(NettyRemotingClient.java:365)
    at org.apache.rocketmq.client.impl.MQClientAPIImpl.getTopicRouteInfoFromNameServer(MQClientAPIImpl.java:1371)
    at org.apache.rocketmq.client.impl.MQClientAPIImpl.getTopicRouteInfoFromNameServer(MQClientAPIImpl.java:1361)
    at org.apache.rocketmq.client.impl.factory.MQClientInstance.updateTopicRouteInfoFromNameServer(MQClientInstance.java:624)
    ... 10 more
发送消息失败！result is : org.apache.rocketmq.remoting.exception.RemotingConnectException: connect to [124.57.180.156:9876] failed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为啥报错了？很简单，他是异步的，从结果就能看出来，由于是异步的，我还没发送到mq呢，你就先给我shutdown了。肯定不行，所以我们在shutdown前面sleep 1s在看效果&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;public class ProducerASync {
    public static void main(String[] args) throws Exception {
       // 指定生产组名为my-producer
        DefaultMQProducer producer = new DefaultMQProducer(&quot;my-producer&quot;);
        // 配置namesrv地址
        producer.setNamesrvAddr(&quot;124.57.180.156:9876&quot;);
        // 启动Producer
        producer.start();

        // 创建消息对象，topic为：myTopic001，消息内容为：hello world async
        Message msg = new Message(&quot;myTopic001&quot;, &quot;hello world async&quot;.getBytes());
        // 进行异步发送，通过SendCallback接口来得知发送的结果
        producer.send(msg, new SendCallback() {
            // 发送成功的回调接口
            @Override
            public void onSuccess(SendResult sendResult) {
                System.out.println(&quot;发送消息成功！result is : &quot; + sendResult);
            }
            // 发送失败的回调接口
            @Override
            public void onException(Throwable throwable) {
                throwable.printStackTrace();
                System.out.println(&quot;发送消息失败！result is : &quot; + throwable.getMessage());
            }
        });

        Thread.sleep(1000);

        producer.shutdown();
        System.out.println(&quot;生产者 shutdown！&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;发送消息成功！result is : SendResult [sendStatus=SEND_OK, msgId=A9FE854106E418B4AAC26F8719B20000, offsetMsgId=7B39B49D00002A9F0000000000058CFC, messageQueue=MessageQueue [topic=myTopic001, brokerName=broker-a, queueId=1], queueOffset=2]
生产者 shutdown！
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 class=&quot;eye-protector-processed&quot;&gt;1.4、sendOneway&lt;/h3&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;public class ProducerOneWay {
    public static void main(String[] args) throws Exception {
        // 指定生产组名为my-producer
        DefaultMQProducer producer = new DefaultMQProducer(&quot;my-producer&quot;);
        // 配置namesrv地址
        producer.setNamesrvAddr(&quot;124.57.180.156:9876&quot;);
        // 启动Producer
        producer.start();

        // 创建消息对象，topic为：myTopic001，消息内容为：hello world oneway
        Message msg = new Message(&quot;myTopic001&quot;, &quot;hello world oneway&quot;.getBytes());
        // 效率最高，因为oneway不关心是否发送成功，我就投递一下我就不管了。所以返回是void
        producer.sendOneway(msg);
        System.out.println(&quot;投递消息成功！，注意这里是投递成功，而不是发送消息成功哦！因为我sendOneway也不知道到底成没成功，我没返回值的。&quot;);
        producer.shutdown();
        System.out.println(&quot;生产者 shutdown！&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;投递消息成功！，注意这里是投递成功，而不是发送消息成功哦！因为我sendOneway也不知道到底成没成功，我没返回值的。
生产者 shutdown！
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 class=&quot;eye-protector-processed&quot;&gt;1.5、效率对比&lt;/h3&gt;
&lt;p&gt;sendOneway &amp;gt; sendCallBack &amp;gt; send批量 &amp;gt; send单条&lt;/p&gt;
&lt;p&gt;很容易理解，sendOneway不求结果，我就负责投递，我不管你失败还是成功，相当于中转站，来了我就扔出去，我不进行任何其他处理。所以最快。&lt;/p&gt;
&lt;p&gt;而sendCallBack是异步发送肯定比同步的效率高。&lt;/p&gt;
&lt;p&gt;send批量和send单条的效率也是分情况的，如果只有1条msg要发，那还搞毛批量，直接send单条完事。&lt;/p&gt;
&lt;h2 class=&quot;eye-protector-processed&quot;&gt;2、Consumer&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;每个consumer只能关注一个topic。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;发消息肯定要必备如下几个条件：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;
&lt;li&gt;
&lt;p&gt;指定消费组名（不能用默认的，会报错）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置namesrv地址（必须）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定topic name（必须）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定tag/key（可选）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 class=&quot;eye-protector-processed&quot;&gt;2.1、CLUSTERING&lt;/h3&gt;
&lt;p&gt;集群模式，默认。&lt;/p&gt;
&lt;p&gt;比如启动五个Consumer，Producer生产一条消息后，Broker会选择五个Consumer中的其中一个进行消费这条消息，所以他属于点对点消费模式。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;public class Consumer {
    public static void main(String[] args) throws Exception {
        // 指定消费组名为my-consumer
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;my-consumer&quot;);
        // 配置namesrv地址
        consumer.setNamesrvAddr(&quot;124.57.180.156:9876&quot;);
        // 订阅topic：myTopic001 下的全部消息（因为是*，*指定的是tag标签，代表全部消息，不进行任何过滤）
        consumer.subscribe(&quot;myTopic001&quot;, &quot;*&quot;);
        // 注册监听器，进行消息消息。
        consumer.registerMessageListener(new MessageListenerConcurrently() {
            @Override
            public ConsumeConcurrentlyStatus consumeMessage(List&amp;lt;MessageExt&amp;gt; msgs, ConsumeConcurrentlyContext consumeConcurrentlyContext) {
                for (MessageExt msg : msgs) {
                    String str = new String(msg.getBody());
                    // 输出消息内容
                    System.out.println(str);
                }
                // 默认情况下，这条消息只会被一个consumer消费，这叫点对点消费模式。也就是集群模式。
                // ack确认
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            }
        });
        // 启动消费者
        consumer.start();
        System.out.println(&quot;Consumer start&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 class=&quot;eye-protector-processed&quot;&gt;2.2、BROADCASTING&lt;/h3&gt;
&lt;p&gt;广播模式。&lt;/p&gt;
&lt;p&gt;比如启动五个Consumer，Producer生产一条消息后，Broker会把这条消息广播到五个Consumer中，这五个Consumer分别消费一次，每个都消费一次。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;// 代码里只需要添加如下这句话即可：
consumer.setMessageModel(MessageModel.BROADCASTING); 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 class=&quot;eye-protector-processed&quot;&gt;2.3、两种模式对比&lt;/h3&gt;

&lt;h2 class=&quot;eye-protector-processed&quot;&gt;3、TAG&amp;amp;&amp;amp;KEY&lt;/h2&gt;
&lt;blockquote class=&quot;eye-protector-processed&quot;&gt;
&lt;p&gt;发送/消费 消息的时候可以指定tag/key来进行过滤消息，支持通配符。*代表消费此topic下的全部消息，不进行过滤。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看下&lt;code class=&quot;eye-protector-processed&quot;&gt;org.apache.rocketmq.common.message.Message&lt;/code&gt;源码可以发现发消息的时候可以指定tag和keys：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;public Message(String topic, String tags, String keys, byte[] body) {
    this(topic, tags, keys, 0, body, true);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;public class ProducerTagsKeys {
    public static void main(String[] args) throws Exception {
        // 指定生产组名为my-producer
        DefaultMQProducer producer = new DefaultMQProducer(&quot;my-producer&quot;);
        // 配置namesrv地址
        producer.setNamesrvAddr(&quot;124.57.180.156:9876&quot;);
        // 启动Producer
        producer.start();
        // 创建消息对象，topic为：myTopic001，消息内容为：hello world，且tags为：test-tags，keys为test-keys
        Message msg = new Message(&quot;myTopic001&quot;, &quot;test-tags&quot;, &quot;test-keys&quot;, &quot;hello world&quot;.getBytes());
        // 发送消息到mq，同步的
        SendResult result = producer.send(msg);
        System.out.println(&quot;发送消息成功！result is : &quot; + result);
        // 关闭Producer
        producer.shutdown();
        System.out.println(&quot;生产者 shutdown！&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;发送消息成功！result is : SendResult [sendStatus=SEND_OK, msgId=A9FE854149DC18B4AAC26FA4B7200000, offsetMsgId=7B39B49D00002A9F0000000000058DA6, messageQueue=MessageQueue [topic=myTopic001, brokerName=broker-a, queueId=3], queueOffset=3]
生产者 shutdown！
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看管控台，可以发现tags和keys已经生效了：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages medium-zoom-image&quot; title=&quot;RocketMQ入门到入土（一）新手也能看懂的原理和实战！&quot; src=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/06/java1-1593308599.png&quot; alt=&quot;RocketMQ入门到入土（一）新手也能看懂的原理和实战！&quot; data-original=&quot;https://www.javazhiyin.com/wp-content/uploads/2020/06/java1-1593308599.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;消费的时候如果指定*那就是此topic下的全部消息，我们可以指定前缀通配符，比如：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;// 这样就只会消费myTopic001下的tag为test-*开头的消息。
consumer.subscribe(&quot;myTopic001&quot;, &quot;test-*&quot;);

// 代表订阅Topic为myTopic001下的tag为TagA或TagB的所有消息
consumer.subscribe(&quot;myTopic001&quot;, &quot;TagA||TagB&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还支持SQL表达式过滤，不是很常用。不BB了。&lt;/p&gt;
&lt;h2 class=&quot;eye-protector-processed&quot;&gt;4、常见错误&lt;/h2&gt;
&lt;h3 class=&quot;eye-protector-processed&quot;&gt;4.1、sendDefaultImpl call timeout&lt;/h3&gt;
&lt;h4 class=&quot;eye-protector-processed&quot;&gt;4.1.1、异常&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;Exception in thread &quot;main&quot; org.apache.rocketmq.remoting.exception.RemotingTooMuchRequestException: sendDefaultImpl call timeout
    at org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.sendDefaultImpl(DefaultMQProducerImpl.java:666)
    at org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.send(DefaultMQProducerImpl.java:1342)
    at org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.send(DefaultMQProducerImpl.java:1288)
    at org.apache.rocketmq.client.producer.DefaultMQProducer.send(DefaultMQProducer.java:324)
    at com.chentongwei.mq.rocketmq.Producer.main(Producer.java:18)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 class=&quot;eye-protector-processed&quot;&gt;4.1.2、解决&lt;/h4&gt;
&lt;p&gt;1.如果你是云服务器，首先检查安全组是否允许9876这个端口访问，是否开启了防火墙，如果开启了的话是否将9876映射了出去。&lt;/p&gt;
&lt;p&gt;2.修改配置文件&lt;code class=&quot;eye-protector-processed&quot;&gt;broker.conf&lt;/code&gt;，加上：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;brokerIP1=我用的是阿里云服务器，这里是我的公网IP
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动namesrv和broker的时候加上本机IP（我用的是阿里云服务器，这里是我的公网IP）：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;./bin/mqnamesrv -n IP:9876
./bin/mqbroker -n IP:9876 -c conf/broker.conf&lt;/code&gt;&lt;/pre&gt;
&lt;h3 class=&quot;eye-protector-processed&quot;&gt;4.2、No route info of this topic&lt;/h3&gt;
&lt;h4 class=&quot;eye-protector-processed&quot;&gt;4.2.1、异常&lt;/h4&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;Exception in thread &quot;main&quot; org.apache.rocketmq.client.exception.MQClientException: No route info of this topic: myTopic001
See http://rocketmq.apache.org/docs/faq/ for further details.
    at org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.sendDefaultImpl(DefaultMQProducerImpl.java:684)
    at org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.send(DefaultMQProducerImpl.java:1342)
    at org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.send(DefaultMQProducerImpl.java:1288)
    at org.apache.rocketmq.client.producer.DefaultMQProducer.send(DefaultMQProducer.java:324)
    at com.chentongwei.mq.rocketmq.Producer.main(Producer.java:18)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 class=&quot;eye-protector-processed&quot;&gt;4.2.2、解决&lt;/h4&gt;
&lt;p&gt;很明显发送成功了，不再是刚才的超时了，但是告诉我们没有这个topic。那不能每次都手动创建呀，所以启动broker的时候可以指定参数让broker为我们自动创建。如下&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums eye-protector-processed highlighter-hljs&quot;&gt;&lt;code&gt;./bin/mqbroker -n IP:9876 -c conf/broker.conf autoCreateTopicEnable=true&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a0f32e5f4934fb09ac2e87b452766453</guid>
<title>如何写出好代码 — 防御式编程指南</title>
<link>https://toutiao.io/k/mmvrn8n</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;来源 | OSCHINA 社区&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;作者 | &lt;/span&gt;&lt;/span&gt;&lt;span&gt;云智慧AIOps社区&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原文链接：https://my.oschina.net/yunzhihui/blog/5547812&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;在日常工作当中，大家是否有这种感觉：“好” 代码和 “差” 代码，都可以实现产品的需求。但是不同的人写出的代码，在效率、质量、可维护性、可扩展性、可读性等方面千差万别。想法、构思、架构设计得再好，写出来的代码三天两头踩坑，这是纸上谈兵。因此软件的健壮性是衡量一名工程师水平的重要标准。如何提升软件的健壮性？合理的顶层设计、完备的测试必不可少，但终其根本是提升代码质量。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;防御式编程是一种安全编码的思维方式。它被看做是减少或消除墨菲定律的一种手段。在程序员奉为圭臬的著作《Code Complete》（代码大全）里，详细介绍了防御式编程。同时国内外有很多大厂把防御式编程作为质量建设的手段之一。本文将介绍防御式编程以及实际场景中如何应用防御式编程。&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;墨菲定律&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;如果有两种或两种以上的方式去做某件事情，而其中一种选择方式将导致灾难，则必定有人会做出这种选择。这是一种偏悲观的思想，认为所有可能出问题的坏情况都会发生。那么在抱有该想法去做设计时，就需要对最坏情况做出预测并采取相对应的措施。同时让使用人员不需要进行复杂的思考，通过直觉即可使用某个系统，即所谓的防呆设计。如 3.5 寸的软盘设计，就设计成只有一种情况可以插入进去。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4081081081081081&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRK9ia1Sia4ZpQ0t0JG5k8pcY4KkmOpkYRRHRkFXZPicorvCicGfCCotUDcNAT7LpT439GVlvM1yib6NbGvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1480&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;什么是防御式编程？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;防御式编程，其核心思想是 &lt;strong&gt;子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误数据。简单来说，就是怀疑一切，认为自身代码之外的环境都是不可信的，在这种情况下，考虑代码该怎么写。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;防御式编程和防御式驾驶&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;防御式编程，这一概念来自防御式驾驶。在防御式驾驶中要建立这样一种思维，那就是你永远也不能确定另一位司机将要做什么。这样才能确保在其他人做出危险动作时你也不会受到伤害。你要承担起保护自己的责任，哪怕是其他司机犯的错误。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;举个实际的场景，以一次 SQL 查询为例：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Class Main {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; Connection con = = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;Student&amp;gt; &lt;span class=&quot;code-snippet__title&quot;&gt;doQuery&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String name&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Statement stmt = conn.createStatement();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ResultSet rs = stmt.executeQuery(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;SELECT id, grade, name, gender FROM students WHERE name=&quot;&lt;/span&gt; + name);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        List&amp;lt;Student&amp;gt; studentList = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt;(rs.next()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; id = rs.getLong(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; grade = rs.getLong(&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            String name = rs.getString(&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            String gender = convertGender(rs.getInt(&lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Student student = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Student(id, grade, name, gender);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            studentList.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(student);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; studentList;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; String &lt;span class=&quot;code-snippet__title&quot;&gt;convertGender&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; gender&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;switch&lt;/span&gt;(gender) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; : &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;male&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; : &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;female&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上述代码比较简单，看上去也实现了我们想要的需求：查询符合名字的所有学生。但是有经验的开发同学，就能够发现不少问题，比如：是否正常建立了数据库连接？数据库的返回值有没有做校验？以上的这些问题总结下来，我们可以得出防御式编程的关键原则。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;边界防御：检查所有的外部输入&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;在防御式编程的理念中，所有的外部输入都是不可信的，需要校验是否在可允许的范围内。这里需要检查的项包括，空指针、数组越界、不合法入参等。特别是当我们在写一个公共方法时，不确定这个方法会在未来某个时刻，被某个外部系统调用，做好输入检查既能保护自身程序运行的健壮性，又可以让外部系统放心调用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在上面的这个 case 中有一个明显的传参漏洞，入参 name 有可能会被外部用户使用 SQL 注入攻击，如输入 name = &quot;zhangsan or 1 = 1&quot;，就可以获取所有 students 信息，显然这个是不符合我们要求的入参。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外这个外部输入不光包括传入参数，还包括任何从方法外部获取到的数据，包括数据库查询到的数据等。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;异常处理：在正确性和健壮性之间做好取舍&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;正确性和健壮性往往是相互矛盾的，当我们检查出错误数据后，还需要决定如何处理它。防御性编程不会掩盖错误，也不会隐藏 bug。这需要在健壮性和正确性之间做权衡。在对异常低容忍度的场景，比如火箭发射系统或医疗系统，正确性要优于健壮性；在电商等消费场景中，要优先考虑健壮性，毕竟选择商品不成功，重新刷新一下就好了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在上述 case 中，如果数据库连接失败，比较好的做法是重试或者返回错误码，而不是直接让程序退出。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;应检尽检：没有完全可靠的外部环境&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;我们在 coding 时，会有很多外部方法的调用和交互，要对所有的外部调用保持警惕。这些 API 或者三方类库也是人写的，人写的就意味着可能有 bug。一种好的思路是尽可能地按照自身逻辑，对外部调用做检查和异常处理（exception handle）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在上述 case 中，存在两个地方的问题：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;1、调用数据库并没有检查是否成功；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、调用完数据库并没有手动释放资源，这很有可能造成内存泄漏。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;显示约束：简单直接的代码风格&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;在防御式编程中，我们提倡使用 “最笨” 的方式写代码，尽量少的使用一些语法糖或者隐性规约。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如很多面试题中都会碰到的 &quot;a++ = b++&quot;，是防御式编程当中不提倡的，不如写成 &quot;a = b; a++; b++&quot;，虽然代码多了两行，但是意义清晰，且容易理解。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外一种情况是使用显示约束。比如：多用 const final static，避免使用 select *，字段名前加上表名。在上述的 case 中，&quot;SELECT id, grade, name, gender FROM students WHERE name=&quot; 里的 name 应该加上表名: students.name，因为 name 是 mysql 中的关键字。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;减少依赖：write once, run anywhere&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&quot;write once, run anywhere&quot; 是 Sun 公司用来展示 Java 程序设计语言的跨平台特性的口号，这本身就是一种防御式编程的理念体现，即在代码中减少对环境的依赖，确保外界环境改变了，程序依然可以正常运行。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在我们的项目中，比较典型的就是国产化问题。国产化问题经常涉及到数据库的适配，那么在做程序设计时，我们就需要考虑到业务逻辑和底层数据调用的解耦。再举一个例子，&quot;i++ != j++&quot; 在不同的编译器中执行结果是不同的，这种也是我们需要避免的。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;傻瓜式注释&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;代码是给系统看的，注释是给人看的。要想代码具有比较好的可阅读性，应该把自己当作傻子去添加注释。（这个和 clean code 的理念不同，clean code 提倡代码即注释，个人认为这是一种理想化的情境）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但注释并不是写废话，好的注释应该出现在：复杂的业务逻辑、非常规的写法、可能有坑的地方、临时解决方案、项目当中核心的类或者方法。写注释是一个优秀工程师必备的技能，大家可以参考下很多优秀项目上的注释写法。&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;契约式编程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;契约式编程（Contract Programming），顾名思义，在设计阶段就已经确定好每个方法的边界，包括每个方法的参数、返回值，以及它们的类型和所有可能的值。这个术语最早由伯特兰・迈耶于 1986 年提出。他设计了 Eiffel 程式语言来实现这种程式设计方法，在《物件导向软体建构》（Object-Oriented Software Construction）一书中，又提出两个后继版本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;契约式编程强调了三个概念，即前置条件，后置条件和不变式。这几个概念实际上是脱胎于 Eiffel 语言的一些特性的，不熟悉 Eiffel 的同学会觉得有点晦涩难懂。&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;前置条件：期望所有调用它的客户模块都保证一定的进入条件，比如非 NULL、非 0 等要求；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;后置条件：保证退出时给出特定的属性，比如程序退出时会释放数据库连接；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不变式：在进入时假定，并在退出时保持一些特定的属性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;契约式编程是比防御式编程更加乐观的一种编程思路，强调约定和断言，具体想了解契约式编程的同学，可以移步：https://www.eiffel.com/values/design-by-contract/introduction/&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;避免过度设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;过度的防御式编程，也会带来新的问题：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先是预防不可能会发生的错误，如上面的 case 所示，对于数据库返回的结果，采用 rs.next () 即可判断是否有值，而不需要对 rs 进行非 null 判断；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其次，过多的防御式代码，会导致整体程序显得臃肿、难以维护，代码里充斥着大量的判断和非业务代码；同时，程序的性能也会受此影响；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;然后，当代码中有非常多的异常捕捉和处理时，可能会导致异常被吞掉，没有正常地报出来。&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;防御式编程是一种安全的编程思想，本质上是要求开发人员对代码和线上环境报以辩证的态度和敬畏之心。它通过以下途径，从而来提升系统健壮性：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;作为一名优秀的开发者，不能将希望完全寄托于测试，测试驱动开发，而是在设计、开发阶段，对系统的异常和边界有充分的认知和考量，这是防御式编程带给我们的思考。&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;附录：防御式编程 checkList&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;一般事宜&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;子程序是否保护自己免遭有害输入数据的破坏？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;你用断言来说明编程假定吗？其中包括了前条件和后条件吗？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;断言是否只是用来说明从不应该发生的情况？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;你是否在架构或高层设计中规定了一组特定的错误处理技术？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;你是否在架构或高层设计中规定了是让错误处理更倾向于健壮性还是正确性？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;你是否建立了隔栏来遏制错误可能造成的破坏？是否减少了其他需要关注错误处理的代码的数量？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码中用到辅助调试的代码了吗？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果需要启用或禁用添加的辅助助手的话，是否无需大动干戈？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在防御式编程时映入的代码量是否适宜–既不过多，也不过少？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在开发阶段是否采用了进攻式编程来使错误难以被忽视？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;异常&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;你在项目中定义了一套标准化的异常处理方案吗？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;是否考虑过异常之外的其他替代方案？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果可能的话，是否在局部处理了错误而不是把它当成一个异常抛到外部？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码中是否避免了在构造函数和析构函数中抛出异常？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;所有的异常是否都与抛出它们的子程序处于同一抽象层次上？6). 每个异常是否都包含了关于异常发生的所有背景信息？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码中是否没有使用空的 catch 语句？(或者如果使用空的 catch 语句确实很合适，那么明确说明了吗？)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;安全事宜&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最终产品代码中对错误的处理方式要比 “垃圾进，垃圾出” 复杂的多。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;防御式编程技术可以让错误更容易发现、更容易修改，并减少错误对产品代码的破坏。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;断言可以帮助人尽早发现错误，尤其是在大型系统和高可靠性的系统中，以及快速变化的代码中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;关于如何处理错误输入的决策是一项关键的错误处理决策，也是一项关键的高层设计决策。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;异常提供了一种与代码正常流程角度不同的错误处理手段。如果留心使用异常，它可以成为程序员们知识工具箱中的一项有益补充，同时也应该在异常和其他错误处理手段之间进行权衡比较。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;针对产品代码的限制并不适用于开发中的软件。你可以利用这一优势在开发中添加有助于更快地排查错误的代码。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;作者简介&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;云智慧架构部，长期致力于智能运维领域工程架构的建设和发展，打造高性能、高可用、高易用的运维工程框架，提升公司技术水位线。&lt;/span&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86032&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span data-brushtype=&quot;text&quot;&gt;END&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86032&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如何看待开源社区中的SIG组织模式？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;64&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UibM134tIsO1j5yqHyNhh9arj090oAL7zGhRJRq6cFqFOlDZMleLl4pw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp wxw_wechannel_card_not_horizontal&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAxXUpw7AnZAAAAAstQy6ubaLX4KHWvLEZgBPEmYMQSEM1VouDzNPgMIv_aYQpH4oRkedOMQ1ojhfT&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7Ym3K77SEULgkiadGLUjVsDkaR40LEtCnsUgQxN5Uo9KKoMsBzUGoXEMj2594uE8micDUbYy0aVUk7mPPWSb1Y0vV0XmPfYhMoicLMQ&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SZ&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdXpXVzpkwG6JEUNubo19srI85CyaicA79eVWbA7icqiaeB97hMPmCT1eibB7P21RIV1frk&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/TTQibyKjrickxaZ7LG0fWYjKslHKkuycfC5r2ibT51J7x6QsFbfHfl2uQ/0&quot; data-username=&quot;v2_060000231003b20faec8c5e08a1bcbd1c806e434b077b18cbd3cef6a3a95a1814d2dc66ee22d@finder&quot; data-nickname=&quot;OSC开源社区&quot; data-desc=&quot;如何用SIG来组织一个庞大的开源社区？【单口开源】第五期~#开源 #社区 #SIG #组织 #开发 @微信时刻 &quot; data-nonceid=&quot;9267866976706511110&quot; data-type=&quot;video&quot; data-width=&quot;1080&quot; data-height=&quot;1920&quot;/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里有最新开源资讯、软件更新、技术干货等内容&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;点这里 ↓↓↓ 记得 关注✔ 标星⭐ 哦~&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5NzM0MjcyMQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRKibFSaFOxzVguEFp6FiaPYUpGzFgCDzntuS0V3Z7aWqgs8a2aVAiaGNticiapKQczicXqW5HicAGTrIXphbA/0?wx_fmt=png&quot; data-nickname=&quot;OSC开源社区&quot; data-alias=&quot;oschina2013&quot; data-signature=&quot;开源中国，为开发者服务&quot; data-from=&quot;2&quot; has-insert-preloading=&quot;1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d9ef489e7e5f4341778aee99604f2a22</guid>
<title>Go中的一些优化笔记，简单而不简单</title>
<link>https://toutiao.io/k/wt1dn17</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天小土给大家带来一篇关于 Golang 项目中最简单的优化的文章。原文见 &lt;span&gt;Golang: simple optimization notes&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们这里简单聊一下优化本身，然后我们直接从实际的示例开始。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么要优化呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你资源占有较高的话会需要很大的成本，虽然现在服务器资源也不是很贵，但是你还是需要针对的做一些优化工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外每个优化应该建立在一个&lt;strong&gt;benchmark&lt;/strong&gt;的基础上，需要体现它给我们带来多大的收益。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面主要从slice、string、struct、function、map、interface、channel、pointer等方面罗列了一些常见的优化点。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数组和slice优化篇&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;提前为slice分配内存&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽量使用第三个参数：&lt;code&gt; make([]T, 0, len)&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你事先不知道确切的数量并且slice是临时的，你可以设置得大一些，只要slice在运行时不会增长。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;不要忘记使用“copy”&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们尽量不要在复制时使用 append，例如，在合并两个或多个slice时。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;正确地使用迭代&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们有一个包含很多元素或比较大的元素的slice，我们会尝试使用“for”或 range 单个元素。通过这种方法，可以避免不必要的复制。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;学会复用slice&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们需要对传入的slice进行某种操作并返回结果，我们可以直接return，但已经修改了。这样我们就可以避免了新的内存分配。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;不要留下未使用的slice&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们需要从slice中切下一小块并仅使用它，其实主要部分也会保留下来。可以使用copy产生一个新的slice，而旧的对象让GC回收。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;string-字符串优化篇&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;正确地进行拼接&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果拼接字符串可以在一个语句中完成，那么可以使用“+”，如果需要在循环中执行此操作，那么可以使用&lt;code&gt;string.Builder&lt;/code&gt;。通过“Grow”也可以预先指定&lt;code&gt;builder&lt;/code&gt;的大小。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;使用转换优化&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于字符串是由字节组成的，因此有时这两种类型之间的转换可以避免内存分配。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;使用池化技术&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以池化字符串，从而帮助编译器只存储一次相同的字符串。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;避免内存分配&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用map来替代复合键，我们也可以使用&lt;code&gt;[]byte&lt;/code&gt;。尽量不要使用&lt;code&gt;fmt&lt;/code&gt;包，因为它的所有函数都使用了反射。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;struct-结构体优化篇&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;避免复制大的struct&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们理解的小&lt;code&gt;struct&lt;/code&gt;，是指不超过 4 个字段的&lt;code&gt;struct&lt;/code&gt;，不超过一个&lt;em&gt;机器字&lt;/em&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;标准的copy案例&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;转换成interface&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接收和发送到channel&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;替换map中的item&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;向slice添加元素&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;迭代（range）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;避免通过指针来访问struct中的字段&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解引用是比较昂贵的，我们可以尽量少做，尤其是在循环中。我们也会失去使用快速寄存器的能力。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;使用小型的struct&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这项工作由编译器优化的，这意味着它的工作量很小。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;通过内存对齐来减小struct大小&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以对齐struct（根据字段的大小，以正确的顺序排列），从而可以减小struct本身的大小。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;func-函数优化篇&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;使用内联函数或自己内联&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们尽量编写一些可供编译器内联的小函数——它很快，但自己从函数中嵌入代码则更快。&lt;strong&gt;对于热路径&lt;/strong&gt;函数尤其如此。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;什么情况下不会被内联？&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;recovery 函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;select&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类型声明&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;defer&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;goroutine&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;for-range&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;明智地选择你的函数参数&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们尽量使用“小”参数，因为它们的拷贝会被特别优化。我们也尝试在拷贝和GC的负载的与增长堆栈之间保持平衡。避免使用大量的参数——让你的程序使用超快速的寄存器（寄存器的数量是有限的）&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;声明一个命名好的return结果&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这似乎比在函数体中声明这些变量更高效。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;保存函数中间的结果&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;帮助编译器优化你的代码，保存中间结果，然后会有更多的选择来优化你的代码。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;谨慎使用“defer”&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽量不要使用 &lt;code&gt;defer&lt;/code&gt;，或者至少 &lt;strong&gt;不要在循环中使用&lt;code&gt;defer&lt;/code&gt;&lt;/strong&gt; 。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;为“hot path”提供便利&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;避免在这些地方分配内存，尤其是短期对象。首先要检查的的就是最常见的分支（if，switch）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里 &lt;span&gt;hot path在Go源码中&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;也出现多次，根据&lt;span&gt;在 sync.Once 的上下文中，“hot path”是什么意思？&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;中的回答，这里翻译为热路径是非常频繁执行的指令序列。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;map优化篇&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;提前分配内存&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一切都和其他地方一样。初始化map时，指定其大小。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;使用空结构作为值&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;struct{}&lt;/code&gt;什么都不是，因此例如对信号值使用这种方法是非常有益的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;清空map&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;map只能增长，不能缩小。我们需要控制这一点——完全而明确地重置map。因为删除其所有元素无济于事。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;尽量不要在键和值中使用指针&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 map 不包含指针，那么 GC 就不会在它上面浪费宝贵的时间。而且要知道字符串也是指针——使用&lt;code&gt;[]byte&lt;/code&gt;而不是字符串作为键。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;减少更改的次数&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，我们不想使用指针，但我们可以使用 map 和 slice 的复合体，并将键存储在 map 中，将可以不受限制地更改的值存储在slice中。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;interface优化篇&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;计算内存分配&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请记住，要给一个接口赋值，你首先需要将其拷贝到某处，然后粘贴一个指针。关键字是拷贝。事实证明，装箱和拆箱的成本将近似于结构体的大小和一次分配。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;选择最佳的类型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在某些情况下，装箱/拆箱期间不会进行内存分配。例如，比较小的和布尔值的变量和常量、具有一个简单字段的struct、指针（包括&lt;em&gt;map、chan、func&lt;/em&gt;）&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;避免内存分配&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与其他地方一样，我们尽量避免不必要的内存分配。例如，将一个接口分配给一个接口，而不是装箱两次。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;仅在需要时使用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;避免在小型、频繁调用的函数的参数和结果中使用接口。我们不需要额外的包装和拆包。减少使用接口方法调用的频率，哪怕只是因为它可以防止内联。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;指针、chan、BCE(Bounds Check Elimination-边界检查) 优化篇&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;避免不必要的解引用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尤其是在循环中，因为事实证明它太昂贵了。解引用是我们不想以牺牲自己为代价执行的一系列必要操作。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;channel使用效率是低效的&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用channel会比其他同步方法慢。另外，select 中的 case 越多，我们的程序就越慢。但是&lt;em&gt;select、case + default&lt;/em&gt;是优化过了的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;尽量避免不必要的边界检查&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也很昂贵，我们应该尽一切可能避免它。例如，一次检查（获取）最大slice索引比多次检查更正确。最好是立即尝试获得极端的选项。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这篇文章中，我们看到了一些相同的优化规则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;帮助编译器做出正确的决定。在编译时分配内存，使用中间结果，并尽量保持代码的可读性。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要忘记使用内置的分析和trace跟踪工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后小土也祝你在优化的路上做到尽善尽美。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Golang: simple optimization notes: &lt;em&gt;https://medium.com/scum-gazeta/golang-simple-optimization-notes-70bc64673980&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;hot path在Go源码中: &lt;em&gt;https://cs.opensource.google/search?q=%22hot%20path%22&amp;amp;ss=go%2Fgo&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;在 sync.Once 的上下文中，“hot path”是什么意思？: &lt;em&gt;https://stackoverflow.com/questions/59174176/what-does-hot-path-mean-in-the-context-of-sync-once&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>