<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>a5afef0e5e116e62ce23a40d1f2d831a</guid>
<title>掌门 MySQL 数据库规约落地及优化实战</title>
<link>https://toutiao.io/k/s8xgae9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;MySQL 数据库承载了掌门绝大部分核心业务的数据存储，因此 MySQL 数据库的稳定运行至关重要。DBA 团队一直致力于保障数&lt;/span&gt;&lt;span&gt;&lt;span&gt;据库环境的平稳运&lt;/span&gt;&lt;span&gt;行，编写有掌门 MySQL 数据库规范文档，也提供有掌门数据库查询上线运维平台。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;规范虽然很全面，但是如果不了解数据库原理，不知道规范带来的效率提升，开发人员并不一定会严格遵守，规范也就失去了意义。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本篇文章旨在从数据库原理出发，从三个角度（建表、索引、SQL 语句）进行深入分析，在了解数据库底层原理的基础上，理解数据库规范、以及数据库优化方法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一、建表&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果把 MySQL 数据库实例看作是一个图书馆，数据表就可以看作一本本的书。书名如同表名，概述用途，需要取的易懂且有意义；书本内容过多会选择分册发行，数据表也可以选择分表或者分区。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;开发人员需要根据实际的业务场景、数据量大小设计不同的表，来满足业务需求。关系型数据库的数据字段后续更改代价较高，因此需要在前期设计阶段就需要考虑用途并设计合理的表结构。优秀的表结构设计，是数据库优化中非常重要的一环。数据表设计需要遵循以下规范要求：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.字符集&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;规范：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据库表字符集统一设置为 utf8mb4 ，排序规则为 utf8mb4_general_ci 。由于 DBA 已统一按照字符集 utf8mb4 ，排序规则 utf8mb4_general 创建数据库，因此表和字段的字符集可以不再额外设置，保持默认与数据库配置相同即可。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;解析：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.当字符集或者排序规则不一致时，会导致表无法关联查询&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. 如果进行字符转换，会导致索引失效，而且也会额外消耗数据库性能&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3. 统一的字符集和排序规则设置，能减少不必要的字符集问题&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.主键ID&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;规范：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;必须创建无符号（ unsigned ）自增（ auto_increment ）整形（ int 或 bigint ）主键 ID 字段&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;解析：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1. 自增主键非常适合 MySQL 数据库聚簇索引数据结构&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.Int 类型长度为 4 字节，bigint 为 8 字节，数据长度较小，较小的字符类型可减少主键长度（后续在索引章节详解）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3. 无符号相比默认有符号数据量存储可大一倍，无符号 int 类型可存放 42 亿行数据，足够掌门一般应用所需&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;id int unsigned not null auto_increment &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;ID主键’,&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;primary key(id),&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3.必含列&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;规范：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;必须包含 deleted ，create_time ，update_time 数据列&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;解析：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1. 掌门数据系统禁止物理删除，应采用逻辑删除方式，并且在代码层维护标记 deleted 字段&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. create_time 取记录创建时间，update_time 取记录更新时间，并由数据库自动维护&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3. 创建 create_time，update_time 列索引，以便进行查询&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4. 按此规范设计的表，极大的方便BI部门进行增量数据同步，减少同步任务的数据量&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;deleted tinyint not null DEFAULT 0 &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;是否删除 0 未删除 1 删除 默认是0’,&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;create_time timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;&lt;/span&gt;记录创建时间，默认当前时间’,&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;update_time &lt;span&gt;timestamp&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span&gt;ON&lt;/span&gt; &lt;span&gt;UPDATE&lt;/span&gt; &lt;span&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;记录更新时间，默认当前时间’,&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;index idx_create_time(create_time),&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;index idx_update_time(update_time),&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4.大字段&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;规范：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;尽量不要使用 blog 和 text 等大字段&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;解析：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1. 存储时：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;实际数据存储在外部存储中，数据列上只存储大字段指针，指向外部存储。大字段在存储时需花费额外 IO 存储实际数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. 查询时：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果列中包含 blog 和 text 列，查询时尽量不要查询该列，不要使用 select * 查询数据&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;查询大字段时需要通过指针找到外部存储，然后再读取字段内容。需要花费额外 IO 读取实际数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;读取的大字段数据只能存放在磁盘中进行后续操作，效率低下。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;5.行长度，页长度&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;规范：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;MySQL 定义行长度不能超过 64KB（不包含 blog ， text 类型）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;页长度默认为 16KB（由参数 innodb_page_size 定义）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;解析：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1. 所有列长度总定义不能超过 64KB ，超过后将无法添加新列&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. 当行长度增加，会导致单个页存放的数据行数减少，检索数据需要消耗更多磁盘 IO&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;286&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;备注：&lt;/span&gt;基于以上行长度和页长度的定义，也许有小伙伴会有疑问，如果表真的存放了 64KB 数据，那岂不是一行数据会占用四个数据页，一个数据页中只能存放一行数据（或一行数据的一部分）。那么此时 MySQL 的 B+ 树的数据存储结构就退变为线性了，这是 MySQL 设计中绝对不允许的！！！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;      按照 MySQL 的 B+ 树设计，一个数据页中至少要存放两行数据，否则 B+ 树会从树状结构退化为线性结构。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;      因此当行存储的实际数据过大，在页中存放不下时，MySQL 在存储这行记录的时候，会将较大的数据列的数据存放在外部存储页中，数据页只保存指向外部存储页的指针。此时如果存储读取这个大的数据列，会额外消耗更多的 IO&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;6.字段类型&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;规范：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;根据字段存储内容定义适当的字段类型&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;解析：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1. 时间类型使用 date 、datetime 或者 timestamp ，不要使用 varchar 或者 int&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. ID 类型尽量使用 tinyint、smallint、int、bigint，不要使用 varchar&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3. 定长字符串尽量使用 char，不要使用 varchar（注意 char 最大定义为 255 ）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4. 字段尽量设置为非空（ not null ），并设置 default 属性&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;5. varchar 类型按需定义长度，不要定义过长。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;5.1. 字段过长会导致索引长度过长，超过一定长度只能创建前缀索引，而前缀索引不能走到索引覆盖&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5.2. 数据读取到内存中是按照定义长度存放，过长的定义会占用更多内存空间&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;7.字段长度&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;规范：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不同字段类型占用的数据存储空间不同，应尽量控制字段在满足业务场景可用的前提下，长度越短越好&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;解析：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.如果字段可以为空，则需要 1 个字节存放字段是否为空标识&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.如果字段为 varchar 变长类型，当定义小于 255 字节时，需要 1 字节存放字段长度；当定义超过 255 字节时，需要 2 字节存放字段长度&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3.常见字段类型的长度（以下字段长度均为不为空时的字段长度）&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;3.1 tinyint 1 字节；smallint 2 字节；int 4 字节；bigint 8 字节；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.2 date 3 字节；datetime 8 字节；timestamp 4 字节；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.3 字符类型括号中定义的数字为字符数，即 varchar(32) 可以存放 32 个数字或者汉字&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.4 字符类型长度跟字符集有关（其中 utf8 占用 3 字节，utf8mb4 占用 4 字节）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    varchar(10) 类型（utf8mb4）字节数： 10*4B+1B=41B&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    varchar(100)  类型（utf8mb4）字节数：100*4B+2B=402B&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    char(10) 类型（utf8mb4）字节数：10*4B=40B&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;二、索引&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上文中把数据表比作是一本本的书，那么索引就是好比书本的目录。如果想要快速从书本中提取某项内容，那么查找目录必定是最快捷的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;MySQL 的索引是一把双刃剑，一方面能大幅提高查询速度，但同时索引也需要额外的存储，并且索引的维护是有代价的，每一行数据的增删改都需要维护索引信息，因此索引并不是多多益善，而应该按需创建合理的索引。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.索引目的&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;建立索引的目的是为了减少扫描范围，提高查询速度。通过索引快速锁定数据范围，返回需要结果。一般情况下，如果单次扫描行数超过数据表总行数的一定比例（预估 10% 左右，官方并没有提供一个确定的数值），查询可能会放弃索引走全表扫描。因此必须要控制查询的数据范围，这也是我一直强调的，如果不能限制数据查询范围，那么所有的优化都是徒劳的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于数据增删改都会额外维护索引信息，索引过多会降低数据表的 DML 速度，因此只在经常查询并且选择性高的列上创建索引。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.索引原理&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过索引(目录)方式，快速提取(查找)需要的记录。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;MySQL 数据存放在磁盘上，索引结构为 B+ 树，索引即通过 B+ 树实现快速的从磁盘中读取所需要的数据（后面章节会详细介绍 B+ 树结构）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;生活中随处可见索引的例子，如火车站的车次表、图书的目录、字典的查找等。它们的原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，来提高检索效率。数据库索引也是类似的原理&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3.索引长度&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;索引的长度决定不仅决定了索引占用的数据空间大小，也会影响查找数据的 IO 次数。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在同等数据量下，索引长度过长会导致单个数据页存放的索引条目数减少，索引高度增加，磁盘 IO 增加，并且索引占用空间增大。所以应该在满足要求的前提下，尽量减少索引长度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;175&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;索引的长度限制及计算方式如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;  1.索引最大长度为 767 字节，若索引长度超过 767 字节将无法创建（可考虑创建前缀索引）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;  2.索引长度与字段定义长度基本相同，前缀索引长度与定义的前缀长度有关&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;  3.变长类型如 varchar，额外需要 2 个字节存放索引长度&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;  4.如果字段可以为空，额外需要 1 个字节存放为空标识&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;  &lt;span&gt;5.索引长度 = 字段长度 + 是否为空(+1) + 是否变长(+2)&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;可通过执行 explain 查看执行计划，key 字段记录查询走哪个索引，key_len 记录所走索引的长度信息&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;mysql&amp;gt; &lt;span&gt;explain&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; t1 &lt;span&gt;where&lt;/span&gt; &lt;span&gt;name&lt;/span&gt; &lt;span&gt;like&lt;/span&gt; &lt;span&gt;&#x27;张三%&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;+&lt;span&gt;----+-------------+-------+-------+---------------+----------+---------+------+------+-----------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows | Extra                 |&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;+&lt;span&gt;----+-------------+-------+-------+---------------+----------+---------+------+------+-----------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;|  1 | SIMPLE      | t1    | range | uni_name      | uni_name | 43      | NULL |    1 | Using index condition |&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;+&lt;span&gt;----+-------------+-------+-------+---------------+----------+---------+------+------+-----------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;1 row in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.05&lt;/span&gt; sec)&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;mysql&amp;gt; &lt;span&gt;show&lt;/span&gt; &lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; t1;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;| Table | &lt;span&gt;Create&lt;/span&gt; &lt;span&gt;Table&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;10&lt;/span&gt;| t1    | &lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;`t1`&lt;/span&gt; (&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;  &lt;span&gt;`id`&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;  &lt;span&gt;`name`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;  &lt;span&gt;`age`&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;  &lt;span&gt;`cnts`&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;&#x27;1&#x27;&lt;/span&gt;,&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;  &lt;span&gt;`a1`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;  &lt;span&gt;`a2`&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;  &lt;span&gt;`a3`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;32&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;  &lt;span&gt;`a4`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;32&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;&#x27;&#x27;&lt;/span&gt;,&lt;br/&gt;&lt;span&gt;19&lt;/span&gt;  &lt;span&gt;`a5`&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;&#x27;1&#x27;&lt;/span&gt;,&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;  &lt;span&gt;UNIQUE&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt; &lt;span&gt;`uni_name`&lt;/span&gt; (&lt;span&gt;`name`&lt;/span&gt;),&lt;br/&gt;&lt;span&gt;21&lt;/span&gt;  &lt;span&gt;KEY&lt;/span&gt; &lt;span&gt;`idx_a2`&lt;/span&gt; (&lt;span&gt;`a2`&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;22&lt;/span&gt;) &lt;span&gt;ENGINE&lt;/span&gt;=&lt;span&gt;InnoDB&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;CHARSET&lt;/span&gt;=utf8mb4 |&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如上表中，name 字段索引 uni_name 的 key_len 长度为 43 ，具体长度是按照以下方式计算规则：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;索引长度 = 字段长度 + 是否为空(+1) + 是否变长(+2)&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如 name 字段 varchar(10)  可以为空，字符集为 utf8mb4 ，则索引长度为：  &lt;span&gt;10*4B+1B+2B=43B&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而 a2 字段 int 可以为空，索引长度为：&lt;span&gt;4B+1B=5B&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4.聚集索引和非聚集索引&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;聚集索引&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一个表只能有一个聚集索引，如果有主键列，则主键列为聚集索引；如果没有主键，有非空唯一列，则以第一个非空唯一列为聚集索引；否则数据库选择内部隐藏 6 字节的 ROWID 作为聚集索引。&lt;span&gt;数据表的数据按照主键的顺序存放，因此对于 MySQL 顺序写入场景下，创建无意义的自增 ID 是最合适的&lt;/span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;聚簇索&lt;/span&gt;&lt;span&gt;引：物理存储按照聚集索引列排序，聚集索引叶子节点 data 中存放完整行数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;非聚集索引&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一个表可以有多个非聚集索引，创建聚集索引只为提高查询效率。通过非聚集索引查找的是聚集索引指针信息，还需要通过&lt;span&gt;回表&lt;/span&gt;方式查找具体的数据。所谓回表，是指通过普通索引获取到的聚集索引指针信息，再在聚集索引中执行一次 B+ 树查找，获取到最终的行数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;非聚簇索引：&lt;/span&gt;&lt;span&gt;非聚集索引列是逻辑排序，与实际数据的物理存储顺序不同。非聚集索引叶子节点 data 中存放聚集索引信息。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;5.磁盘 IO 和预读&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;MySQL 的数据都是存储在磁盘上的，磁盘的查找方式是怎样的？查询速度怎样呢？如何才能快速的从磁盘中拿到所需要的数据。在介绍 B+ 树之前，我们先了解一下磁盘 IO 和预读机制。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分：&lt;/span&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;168&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;1.寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在 5ms 以下；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘 7200 转，表示每分钟能转 7200 次，也就是说 1 秒钟能转 120 次，旋转延迟就是 1/120/2 = 4.17ms；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3.传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;那么访问一次磁盘的时间，即一次磁盘 IO 的时间约等于 5+4.17 ≈ 9ms 左右，听起来还挺不错的，但要知道一台 500 -MIPS 的机器每秒可以执行 5 亿条指令，因为指令依靠的是电的性质，换句话说执行一次 IO 的时间可以执行 40 万条指令，数据库动辄十万百万乃至千万级数据，每次 9 毫秒的时间，显然是个灾难。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;考虑到磁盘 IO 是非常高昂的操作，计算机操作系统做了一些优化，当一次 IO 时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内。局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次 IO 读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为 4k 或 8k ，也就是我们读取一页内的数据时候，实际上才发生了一次 IO，这个理论对于索引的数据结构设计非常有帮助。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;6.B+树&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;了解完操作系统的磁盘 IO 和预读机制，我们知道磁盘 IO 是十分耗时的操作，并且一次 IO 拿到的并不是单条数据，而是预读到的操作系统 page 大小的数据（ 4k或者8k ）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而 MySQL 数据库的 page 大小默认为 16k ，即一次 IO 预读 16k 的数据到数据库的 buffer pool 中。然后在内存中对数据进行过滤，内存中的数据过滤非常快，与磁盘 IO 时间相比时间可忽略不计。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么好了，如何降低磁盘 IO 是数据库设计优化的重点。而 B+ 树就是为了降低磁盘 IO ，提高数据库查询效率而生。&lt;/span&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;41&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;备注：索引树的高度跟磁盘 IO 次数呈正相关，可简单理解为索引树高度即是磁盘 IO 次数。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;谈到 B+ 树这个概念前，我们可以稍微了解一下二叉树、平衡二叉树、红黑树，B 树，这些树都有不同的数据结构，应用于不同的数据场景。MySQL 数据库选择 B+ 树作为数据存储结构，那么相比其他树，B+ 树有何优势呢？&lt;/span&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;224&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;备注：B+ 树是在 B 树上优化衍生而来，本章节我们主要谈谈 B+ 树与 B 树的区别及优势&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.B 树的非叶子节点会存放数据，导致一个页存放的索引数较少，索引树较高&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  B+ 树的非叶子节点不会存放数据，只存放键值，一个页可以存放更多索引，索引树较矮&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.B 树的查找可能会在非叶子节点命中，查找不稳定&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  B+ 树的查找必须到叶子节点才会命中，查找十分稳定&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.B 树的范围遍历效率非常低&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  B+ 树的叶子节点中存放有双向指针构成一种链表结构，范围查询效率非常高效。而数据库的范围查询十分常见&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;因此 B+ 树更加适合作为 MySQL 数据库的数据存储结构，下图是一个 B+ 树的结构图&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.37083333333333335&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ib0u8RcCc5ROW5BgQLLmxZff0HRNvkytNl2q4GJQgYj7zkLkYIf59qX9uFYDyXc7UqcQj77T7ruYl4C9icxBxA2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;78&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;备注：在 MySQL 的 B+ 树结构中，聚簇索引和非聚簇索引存储稍有差异&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;聚簇索引的 data 部分，存储的是具体的行数据&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;非聚簇索引的 data 部分，存储的是主键 ID 信息&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;7.索引高度&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;既然磁盘 IO 是最影响性能的操作，那么优化的目的就是为了减少磁盘 IO 。而索引高度与磁盘 IO 是息息相关的，按照 MySQL 的索引设计，索引的高度就决定了磁盘 IO 的次数。那关于索引的高度，我们需要了解以下其计算规则&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5589798087141339&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ib0u8RcCc5ROW5BgQLLmxZff0HRNvkytNzUo68A5t144D18UpbichHnmqc42uRhlBmxID7wq4GyZZM5WhL5VCFyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;941&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;8.索引存储条目数&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;很多参考文档都会告诉你，索引的高度一般都在 3-4 层，但到底是 3 层还是 4 层呢？3 层索引和 4 层索引又能存放多少索引量，很多文档又会含糊描述的不清楚。此处我们根据实际例子，来看以下具体的索引能存储多少索引量&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;195&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;假设：表平均行长度为 300B，主键索引列 ID 为 int 类型&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;           普通索引列 name 为 varchar(20) 类型非空 (utf8mb4)&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;           普通索引列 info 为 varchar(150) 类型可以为空 (utf8mb4)&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;分别了解主键索引和普通索引在不同类型下的最大能存储条目数&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;           &lt;/span&gt;&lt;span&gt;主键索引的叶子节点中存放具体行数据；普通索引的叶子节点中存放主键信息&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;备注：索引存储中除索引信息外，还会用 4B 存储页号，6B 存储其他数据&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;主键索引 ID（int），索引长度 4B&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;每个非叶子节点可存放 key 个数为 M1=16KB/(4B+4B+6B)≈1170&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;每个叶子节点可存放 key 个数为 M2=16KB/(300B+4B+6B) ≈52&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;则 3 层索引最终能存放最大条目数为：L=1170*1170*52 ≈7118W&lt;br/&gt;&lt;span&gt;4  &lt;/span&gt;4 层索引最终能存放最大条目数为：L=1170*1170*1170*52 ≈832亿   &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;普通索引 name（varchar(20)），非空，索引长度 20*4B+2B&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;每个非叶子节点可存放 key 个数为 M1=16KB/(20*4B+2B+4B+6B)≈178&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;每个叶子节点可存放 key 个数为 M2=16KB/(4B+20*4B+2B+4B+6B) ≈170&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;则 3 层索引最终能存放最大条目数为：L= 178*178*170 ≈538W&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;  4 层索引最终能存放最大条目数为：L= 178*178*178*170 ≈9.58亿 &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;普通索引 info（varchar(150)），可为空，索引长度 150*4B+2B+1B&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;每个非叶子节点可存放 key 个数为 M1=16KB/(150*4B+2B+1B+4B+6B)≈26&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;每个叶子节点可存放 key 个数为 M2=16KB/(150*4B+2B+1B+4B+6B+4B) ≈26&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;则 3 层索引最终能存放最大条目数为：L= 26*26*26 ≈17576&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;  4 层索引最终能存放最大条目数为：L= 26*26*26*26 ≈456976&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;  5 层索引最终能存放最大条目数为：L= 26*26*26*26*26 ≈1188W&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以发现当索引长度增加时，会导致每个 page 页存放的索引数减少，索引高度增加。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;特别是 char/varchar 类型，索引长度会因为 utf8mb4 字符集原因导致索引长度急剧增长，因此需要严格控制字段和索引长度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;9.索引优化&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;针对索引的优化，主要在于选择合适的列创建最优的索引，删除无效或者重复索引：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.列的选择性越高，越适合创建索引。列的选择性计算 count(distinct coumn_name)/count(0)&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.选择性低的列上不要添加索引，如 bu，type，status，state，deleted 等列，索引列可能会导致查询效率下降&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3.通过 Show index from table_name，查看表上的索引信息，cardinality 越大选择性越高&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4.前缀索引。如果索引列太长，可考虑创建前缀索引 index idx_name(column_name(pre_len))  &lt;/span&gt;&lt;span&gt;达到 pre_len 的条数，如果达到总条数的 80%  即可     &lt;/span&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;14&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;span&gt;备注：前缀索引无法走索引覆盖&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;如 lessons 表的 les_uid 字段，定义为&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;`les_uid` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;但是其实该字段存放的时 uuid 信息，长度为固定的 32 位，该字段如需创建索引，则可考虑前缀索引，指定前缀长度为 32&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;index idx_les_uid(les_uid(32)), &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;5.组合索引。多列查询条件一起出现，可创建组合索引。并将经常查询列放前面，选择性高的放前面&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如 index(A,B,C) 相当于建了 index(A,B,C)，index(A,B)，index(A) 三个索引&lt;/span&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;45&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;span&gt;备注：组合索引的列数不宜过多，一般 2-3 列即可。列过多很难用到后面的列，且会增加索引长度。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;如经常查询需要查询学生在某一个时间范围的上课信息，可创建基于 stu_id 和 les_start_time 的组合索引&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;index idx_stu_id_start_time(stu_id,les_start_time)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;6.索引覆盖。当需要查询的列都在索引中，通过扫描索引即可获取所有信息。不需要回表操作，效率较高&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;mysql&amp;gt; &lt;span&gt;explain&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;) &lt;span&gt;from&lt;/span&gt; students &lt;span&gt;where&lt;/span&gt; stu_city=&lt;span&gt;&#x27;上海市&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;+&lt;span&gt;----+-------------+----------+------+---------------+--------------+---------+-------+------+--------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;| id | select_type | table    | type | possible_keys | key          | key_len | ref   | rows | Extra                    |&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;+&lt;span&gt;----+-------------+----------+------+---------------+--------------+---------+-------+------+--------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;|  1 | SIMPLE      | students | ref  | idx_stu_city  | idx_stu_city | 767     | const | 2664 | Using where; Using index |&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;+&lt;span&gt;----+-------------+----------+------+---------------+--------------+---------+-------+------+--------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;1 row in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.06&lt;/span&gt; sec)&lt;br/&gt;&lt;span&gt;8&lt;/span&gt;该查询统计行数信息，而 stu_city 列有索引，查询只需要使用 idx_stu_city 扫描即可取得 &lt;span&gt;count &lt;/span&gt;结果，无需回表取其他列数据。&lt;br/&gt;&lt;span&gt;9&lt;/span&gt;extra 列的 &lt;span&gt;using&lt;/span&gt; &lt;span&gt;index &lt;/span&gt;表明查询走索引覆盖&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;7.索引合并。在 MySQL 5.0 之前，一个表最多只能使用一个索引，从MySQL 5.1 开始引入索引合并（index_merge）技术优化，对同一个表可以使用多个索引分别进行条件扫描，然后将各自的结果进行合并（intersect/union）。&lt;/span&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;140&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;span&gt;备注：如果单列索引创建的不合理，比如在 bu、state、status 等列上创建单列索引，当 index_merge 使用到这些列做索引扫描合并，那么查询效率会非常低，需要关注！！！产生这种问题的主要原因是在选择性低的列上创建了索引，选择性低的列不适合创建索引，可能会降低查询效率！！！&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;index_merge之using union:&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;mysql&amp;gt; &lt;span&gt;explain&lt;/span&gt; &lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; lessons&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; stu_id=&lt;span&gt;116401&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;&lt;span&gt;or&lt;/span&gt; sel_id=&lt;span&gt;1113&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;+&lt;span&gt;----+-------------+---------+-------------+----------------------------------------------------------------------------------------+-----------------------------------+---------+------+------+-------------------------------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;| id | select_type | table   | type        | possible_keys                                                                          | key                               | key_len | ref  | rows | Extra                                                       |&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;+&lt;span&gt;----+-------------+---------+-------------+----------------------------------------------------------------------------------------+-----------------------------------+---------+------+------+-------------------------------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;|  1 | SIMPLE      | lessons | index_merge | lessons_stu_id,idx_stuid_lessub,IDX_LES_TYPE_STU_ID,stu_id_pay_type,idx_lessons_sel_id | lessons_stu_id,idx_lessons_sel_id | 4,5     | NULL | 1467 | Using union(lessons_stu_id,idx_lessons_sel_id); Using where |&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;+&lt;span&gt;----+-------------+---------+-------------+----------------------------------------------------------------------------------------+-----------------------------------+---------+------+------+-------------------------------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;1 row in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.09&lt;/span&gt; sec)&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;查询使用 &lt;span&gt;or &lt;/span&gt;连接多个条件，查询分别使用 stu_id 和 sel_id 列索引进行扫描，并将扫描结果进行取并集(&lt;span&gt;union&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;index_merge之&lt;span&gt;using&lt;/span&gt; &lt;span&gt;intersect&lt;/span&gt;:&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;mysql&amp;gt; &lt;span&gt;explain&lt;/span&gt; &lt;br/&gt;&lt;span&gt;17&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; lessons&lt;br/&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; stu_id=&lt;span&gt;116401&lt;/span&gt;&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;and&lt;/span&gt; sel_id=&lt;span&gt;1113&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;21&lt;/span&gt;+&lt;span&gt;----+-------------+---------+-------------+----------------------------------------------------------------------------------------+-----------------------------------+---------+------+------+------------------------------------------------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;22&lt;/span&gt;| id | select_type | table   | type        | possible_keys                                                                          | key                               | key_len | ref  | rows | Extra                                                                        |&lt;br/&gt;&lt;span&gt;23&lt;/span&gt;+&lt;span&gt;----+-------------+---------+-------------+----------------------------------------------------------------------------------------+-----------------------------------+---------+------+------+------------------------------------------------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;24&lt;/span&gt;|  1 | SIMPLE      | lessons | index_merge | lessons_stu_id,idx_stuid_lessub,IDX_LES_TYPE_STU_ID,stu_id_pay_type,idx_lessons_sel_id | lessons_stu_id,idx_lessons_sel_id | 4,5     | NULL |    1 | Using intersect(lessons_stu_id,idx_lessons_sel_id); Using where; Using index |&lt;br/&gt;&lt;span&gt;25&lt;/span&gt;+&lt;span&gt;----+-------------+---------+-------------+----------------------------------------------------------------------------------------+-----------------------------------+---------+------+------+------------------------------------------------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;26&lt;/span&gt;1 row in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.07&lt;/span&gt; sec)&lt;br/&gt;&lt;span&gt;27&lt;/span&gt;查询使用 &lt;span&gt;and &lt;/span&gt;连接多个条件，查询分别使用 stu_id 和 sel_id 列索引进行扫描，并将扫描结果进行取交集(&lt;span&gt;intersect&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;8.重复索引。重复的索引会需要更多的存储更见和维护代价，可考虑删除重复索引。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如索引 index(A) 和 index(A,B) 是重复的，重复的索引需要更多的存储空间和维护代价，可考虑删除 index(A)。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;三、SQL语句&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;前面提到的建表和索引都是数据库优化中的基础，是非常关键的优化点，只有把基础打好，才能在此基础上做更深层次的优化。而 SQL 优化则是上层建筑，是查询的最终表现，通过 SQL 语句的执行计划、扫描行数、查询时间也能直观的反映出查询语句是否优秀。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;SQL 语句的不同写法，对于底层数据的检索方式有着非常大的差异，也会影响查询方式和最终的数据结果。SQL 优化是在不改变结果的前提下，优化语句，降低扫描数据范围，达到缩短查询时间和扫描行数的目的。如果查询逻辑不合理，无法通过改写 SQL 达到优化的目的，那么则需要考虑调整查询逻辑。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.执行计划&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;SQL 语句的执行顺序真实的记录了解释器会如何一步步的执行语句，了解执行计划对于我们分析 SQL 语句，优化语句有非常大的作用&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们可以通过 &lt;span&gt;explain + SQL &lt;/span&gt;可以查看语句的执行计划。但是执行计划包含的内容太多，如果详细描述，又能整一篇文章了。因此本文只对我们比较关心的地方做重点叙述，简洁而又核心~&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Id：id 列数字越大越先执行，数字一样则从上而下执行&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Type：依次从好到差：system，const，eq_ref，ref，fulltext，ref_or_null，index_merge，unique_subquery，index_subquery，range，index，ALL，除了 all 之外，其他的 type 都可以使用到索引，如果 type 为 all 就需要关注并优化 SQL 了。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Key：查询真正使用到的索引，select_type 为 index_merge 时，这里可能出现两个以上的索引，其他的 select_type 这里只会出现一个&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Key_len：处理查询的索引长度，前文中已经介绍过 key_len 的计算规则。ICP 特性使用的索引不会计入&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Rows：这里是执行计划中估算的扫描行数，不是精确值&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Extra：如果你想要优化你的查询，那就要注意 extra 辅助信息中的 using filesort 和 using temporary ，这两项非常消耗性能，需要注意。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.表关联&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;MySQL 数据表关联采用 Nested-Loop 方式，又名嵌套循环，是 MySQL 中最重要的表关联方式。在 Mysql 8.0 之前，也是仅有的一种表关联方式。想要优化查询语句，对于表关联方式必须要十分清楚。MySQL 在 Nested-Loop Join 的基础上，优化出 Block Nested-Loop Join 关联，两者比较类似。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.1.Nested-Loop Join&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一个简单的嵌套循环联接 (NLJ) 算法一次从循环中的第一个表读取一行，将每一行传递到一个嵌套循环，该循环处理联接中的下一个表。只要还有需要连接的表，这个过程就会重复多次。&lt;span&gt;由于 NLJ 算法每次从外层循环传递一行数据到内存循环，因此循环会重复很多次。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.9439655172413793&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ib0u8RcCc5ROW5BgQLLmxZff0HRNvkytN0Y1fFMFLe8bias41Y6FeTM2FpBO7ic6FiaSJl61LJV9tzO75f6IZAAVrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;464&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一个简单的 BLJ 算法执行过程如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;each&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; t1 matching range {&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;    &lt;span&gt;for&lt;/span&gt; &lt;span&gt;each&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; t2 matching reference key {&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; &lt;span&gt;each&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; t3 {&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;              &lt;span&gt;if&lt;/span&gt; row satisfies &lt;span&gt;join&lt;/span&gt; conditions, send &lt;span&gt;to&lt;/span&gt; client&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;         }&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.2.Block Nested-Loop Join&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;块嵌套循环 (BNL) 连接算法使用缓冲在外部循环中读取的行，以减少必须读取内部循环中的表的次数，（其中 join_buffer_size 参数决定每次读取并放入缓存中的数据量）。例如，如果将 10 行读入一个缓冲区并将该缓冲区传递给下一个内部循环，则可以将内部循环中读取的每一行与缓冲区中的所有 10 行进行比较。&lt;span&gt;这可以将必须读取内部表的次数减少一个数量级。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7742718446601942&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ib0u8RcCc5ROW5BgQLLmxZff0HRNvkytNJUNicPeQ1xThHFWs1XtcIJuFRz6a2APMvtISOhd17RfjNIicNicAjBkAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;824&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一个 BNL 算法执行过程如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;each&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; t1 matching range {&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;for&lt;/span&gt; &lt;span&gt;each&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; t2 matching reference key {&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;        store used columns from t1, t2 &lt;span&gt;in&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; buffer&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; buffer &lt;span&gt;is&lt;/span&gt; full {&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;           &lt;span&gt;for&lt;/span&gt; &lt;span&gt;each&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; t3 {&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;               &lt;span&gt;for&lt;/span&gt; &lt;span&gt;each&lt;/span&gt; t1, t2 combination &lt;span&gt;in&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; buffer {&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;                  &lt;span&gt;if&lt;/span&gt; row satisfies &lt;span&gt;join&lt;/span&gt; conditions, send &lt;span&gt;to&lt;/span&gt; client&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;               }&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;             }&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;            &lt;span&gt;empty&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; buffer&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;     }&lt;br/&gt;&lt;span&gt;13&lt;/span&gt; }&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; buffer &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;empty&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; &lt;span&gt;each&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; t3 {&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;       &lt;span&gt;for&lt;/span&gt; &lt;span&gt;each&lt;/span&gt; t1, t2 combination &lt;span&gt;in&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; buffer {&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;           &lt;span&gt;if&lt;/span&gt; row satisfies &lt;span&gt;join&lt;/span&gt; conditions, send &lt;span&gt;to&lt;/span&gt; client&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;       }&lt;br/&gt;&lt;span&gt;19&lt;/span&gt;   }&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.3.总结&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;不管是 NLJ 或者是优化后的 BNL 算法，都是从驱动表中筛选数据，与被驱动表进行匹配，有以下特性：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;MySQL 优化器会自动选择小表作为驱动表，以减少循环的次数。但并不会只以表大小作为唯一选择依据&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最好不要干涉数据库的驱动表选择，让 MySQL 优化器自动选择最合适的表作为驱动表&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;查询会首先通过查询条件，过滤驱动表上的数据记录，筛选满足要求的结果放入缓存中。驱动表上需尽量通过索引扫描降低数据量。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;被驱动表的关联字段上，需要有索引，否则每一次关联，被驱动表都要全表扫描，效率非常低。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;被驱动表的字段类型、字符集、排序方式需和驱动表保持一致，否则无法直接关联&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;使用外关联时，只有基准表才能被选择为驱动表&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如 A LEFT JOIN B ON A.KEY=B.KEY ,则只有 A 表才能被选择为驱动表，B 表不能作为驱动表&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3.SQL 优化&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;SQL 优化的方式方法很多，此处罗列一些比较重要，容易出现问题的优化点：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;尽量避免全表扫描，应考虑在 where 和 order by 涉及的列上建立索引&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;被驱动表的关联字段需要创建索引，否则被驱动表会走全表扫描&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;索引遵循最左前缀匹配原则，like 写法只能将 % 放在右边，如 name like ‘掌门学员%’；若 % 放在左边会导致索引失效&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;应尽量避免在 where 子句中使用 != ， &amp;lt;&amp;gt; ，not in 操作符，会导致索引失效&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;应尽量避免在 where 子句中使用 or 来连接条件，可尝试拆分为 union/union all&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可考虑使用 join/left join 关联查询，替代子查询、in/not in 的写法，尽量不要用子查询&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果 in 的内容是连续的，可使用 between…and 或者 &amp;gt;….&amp;lt; 替代，改走范围扫描&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不要在查询字段上使用函数或者表达式，会导致索引失效，可在参数字段上做函数或表达式运算&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;查询时需根据字段定义类型进行传参 ，若参数类型与字段定义类型不一致，会导致索引失效&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不要使用 select *  写法，只查询需要的列&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不要在数据库中使用变量 + 分组排序方式构造排序字段，MySQL 需要基于全量数据做排序分组，效率很低&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通过 limit 方式分页会导致后续分页越来越慢，可取前一次分页的最大 ID 作为下一页参数输入，进行分页&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不要通过 order by rand() 方式取随机数，效率极低。如果需要取随机数，可以先用随机数方法取得一个整数，然后根据 id&amp;gt;= 该整数即可。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;禁止不必要的排序，排序操作极耗资源，不要轻易分组排序&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不要在程序中使用 using index 强制索引写法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4.SQL 优化示例&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;枯燥的知识点，哪有举个例子来的更清晰易懂，本章节我们用具体的例子讲述 SQL 优化的方法跟技巧。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4.1.使用 union/union all 替换 or 写法&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;MySQL 的 or 写法，会导致查询索引失效，而更换为 union/union all 写法，虽然代码长度会增加，但是查询效率会有很大的提升&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;mysql&amp;gt; &lt;span&gt;explain&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; students&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; students.created_at&amp;gt;=&lt;span&gt;&#x27;2021-05-01&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;or&lt;/span&gt; students.referrer_user_id&amp;gt;&lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;+&lt;span&gt;----+-------------+----------+------+----------------------------+------+---------+------+----------+-------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;| id | select_type | table    | type | possible_keys              | key  | key_len | ref  | rows     | Extra       |&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;+&lt;span&gt;----+-------------+----------+------+----------------------------+------+---------+------+----------+-------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;|  1 | SIMPLE      | students | ALL  | created_at,idx_ref_user_id | NULL | NULL    | NULL | 52833786 | Using where |&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;+&lt;span&gt;----+-------------+----------+------+----------------------------+------+---------+------+----------+-------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;1 row in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.06&lt;/span&gt; sec)&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;说明：students 表的 created_at 和 referrer_user_id 列都有索引，但是由于查询使用 &lt;span&gt;or &lt;/span&gt;连接，导致无法走索引扫描&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;&lt;span&gt;type &lt;/span&gt;为 all 说明查询走全表扫描，该查询 &lt;span&gt;10&lt;/span&gt;&lt;span&gt;min &lt;/span&gt;仍然无法查询出结果&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;优化：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用 union/union all 写法代替 or。鉴于 or 的关联记录可能存在重复，使用 union 写法，在外层对结果进行 count&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;mysql&amp;gt; &lt;span&gt;explain&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;(&lt;span&gt;select&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; students&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; students.created_at&amp;gt;=&lt;span&gt;&#x27;2021-05-01&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;&lt;span&gt;union&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; students&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; students.referrer_user_id&amp;gt;&lt;span&gt;0&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; t;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;+&lt;span&gt;------+--------------+------------+-------+-----------------+-----------------+---------+------+---------+--------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;| id   | select_type  | table      | type  | possible_keys   | key             | key_len | ref  | rows    | Extra                    |&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;+&lt;span&gt;------+--------------+------------+-------+-----------------+-----------------+---------+------+---------+--------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;|    1 | PRIMARY      | &amp;lt;derived2&amp;gt; | ALL   | NULL            | NULL            | NULL    | NULL | 7638172 | NULL                     |&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;|    2 | DERIVED      | students   | range | created_at      | created_at      | 6       | NULL | 2085176 | Using where; Using index |&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;|    3 | UNION        | students   | range | idx_ref_user_id | idx_ref_user_id | 4       | NULL | 5552996 | Using where; Using index |&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;| NULL | UNION RESULT | &amp;lt;union2,3&amp;gt; | ALL   | NULL            | NULL            | NULL    | NULL | NULL    | Using temporary          |&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;+&lt;span&gt;------+--------------+------------+-------+-----------------+-----------------+---------+------+---------+--------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;19&lt;/span&gt;4 rows in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.24&lt;/span&gt; sec)&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;说明：改用 unio 后两个子查询中都能走各自对应的索引，并且因为是查询 &lt;span&gt;ID &lt;/span&gt;信息，查询走覆盖索引 &lt;span&gt;using&lt;/span&gt; &lt;span&gt;index&lt;/span&gt;，效率很高，该查询最终耗时 &lt;span&gt;11.64&lt;/span&gt;s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4.2.使用 join 关联替换子查询、in、exists 写法&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;子查询的写法虽然看起来直观清晰，但是子查询是一个独立的查询，不能参与到驱动表的数据过滤，而且子查询的结果数据会被放到临时表中存放，然后与驱动表进行关联，效率非常低。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在 Mysql 的写法中，非常不建议子查询写法，而应该尽量用 join 方式替换子查询写法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;mysql&amp;gt; &lt;span&gt;explain&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;sum&lt;/span&gt;(t.money)&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; students&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;&lt;span&gt;join&lt;/span&gt; &lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;(&lt;span&gt;select&lt;/span&gt; payments.stu_id,payments.money&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; payments&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; payments.is_paid=&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;  &lt;span&gt;and&lt;/span&gt; payments.is_canceled=&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;and&lt;/span&gt; payments.money&amp;gt;&lt;span&gt;0&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; t &lt;span&gt;on&lt;/span&gt; students.id=t.stu_id&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;where&lt;/span&gt; students.created_at&amp;gt;=&lt;span&gt;&#x27;2021-05-01&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;      &lt;span&gt;and&lt;/span&gt; students.created_at&amp;lt; &lt;span&gt;&#x27;2021-06-01&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;+&lt;span&gt;----+-------------+------------+--------+-----------------------------------+---------+---------+----------+---------+-------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;| id | select_type | table      | type   | possible_keys                     | key     | key_len | ref      | rows    | Extra       |&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;+&lt;span&gt;----+-------------+------------+--------+-----------------------------------+---------+---------+----------+---------+-------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;|  1 | PRIMARY     | &amp;lt;derived2&amp;gt; | ALL    | NULL                              | NULL    | NULL    | NULL     | 2805183 | NULL        |&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;|  1 | PRIMARY     | students   | eq_ref | PRIMARY,created_at                | PRIMARY | 4       | t.stu_id |       1 | Using where |&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;|  2 | DERIVED     | payments   | ALL    | IDX_MONEY_STU_ID,IDX_MONEY_SEL_ID | NULL    | NULL    | NULL     | 5610366 | Using where |&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;+&lt;span&gt;----+-------------+------------+--------+-----------------------------------+---------+---------+----------+---------+-------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;19&lt;/span&gt;3 rows in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.09&lt;/span&gt; sec)&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;说明：payments 表使用单独的子查询，&lt;span&gt;type &lt;/span&gt;为 ALL 需要扫描整个 payments 表记录，将返回的结果存放在临时表，然后与 students 表进行匹配。查询耗时 &lt;span&gt;22&lt;/span&gt;s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;优化：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不使用子查询，直接使用 join 进行多表关联，并将查询条件写入到 where 中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;mysql&amp;gt; &lt;span&gt;explain&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;sum&lt;/span&gt;(payments.money)&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; students&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;&lt;span&gt;join&lt;/span&gt; payments &lt;span&gt;on&lt;/span&gt; students.id=payments.stu_id&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; payments.is_paid=&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;and&lt;/span&gt; payments.is_canceled=&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;and&lt;/span&gt; payments.money&amp;gt;&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;and&lt;/span&gt; students.created_at&amp;gt;=&lt;span&gt;&#x27;2021-05-01&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;and&lt;/span&gt; students.created_at&amp;lt; &lt;span&gt;&#x27;2021-06-01&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;+&lt;span&gt;----+-------------+----------+-------+---------------------------------------------------+-----------------+---------+-------------------+---------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;| id | select_type | table    | type  | possible_keys                                     | key             | key_len | ref               | rows    | Extra                              |&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;+&lt;span&gt;----+-------------+----------+-------+---------------------------------------------------+-----------------+---------+-------------------+---------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;|  1 | SIMPLE      | students | range | PRIMARY,created_at                                | created_at      | 6       | NULL              | 1983818 | Using where; Using index           |&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;|  1 | SIMPLE      | payments | ref   | payments_stu_id,IDX_MONEY_STU_ID,IDX_MONEY_SEL_ID | payments_stu_id | 4       | forge.students.id |       1 | Using index condition; Using where |&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;+&lt;span&gt;----+-------------+----------+-------+---------------------------------------------------+-----------------+---------+-------------------+---------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;2 rows in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.26&lt;/span&gt; sec)&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;说明：不使用子查询，改为 &lt;span&gt;join &lt;/span&gt;写法后。查询首先根据 students.created_at 走索引扫描，然后根据查询的结果与 payments 表的 stu_id 进行关联。查询耗时 &lt;span&gt;1.85&lt;/span&gt;s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4.3.使用 join/left join 替代 in/exists、not in/not exists 写法&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;join 写法相当于做等值匹配，可以直接替代大部分场景的 exits 和 in 的写法&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;left join/right join 外关联的写法会以驱动表为母表，被驱动表只包含匹配的数据，配合在 where 条件中添加条件筛选，可用来替代 not exist 和 not in 写法&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;mysql&amp;gt; &lt;span&gt;explain&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; u.id &lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;users&lt;/span&gt; u &lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; u.updated_at &amp;gt; &lt;span&gt;&#x27;2021-05-20 12:00:00&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;&lt;span&gt;and&lt;/span&gt; u.id &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;(&lt;span&gt;select&lt;/span&gt; a.user_id &lt;span&gt;from&lt;/span&gt; users_account_number a);&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;+&lt;span&gt;----+--------------------+-------+-----------------+----------------+----------------+---------+------+--------+--------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;| id | select_type        | table | type            | possible_keys  | key            | key_len | ref  | rows   | Extra                    |&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;+&lt;span&gt;----+--------------------+-------+-----------------+----------------+----------------+---------+------+--------+--------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;|  1 | PRIMARY            | u     | range           | idx_uptime     | idx_uptime     | 6       | NULL | 103664 | Using where; Using index |&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;|  2 | DEPENDENT SUBQUERY | a     | unique_subquery | user_id_unique | user_id_unique | 4       | func |      1 | Using index              |&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;+&lt;span&gt;----+--------------------+-------+-----------------+----------------+----------------+---------+------+--------+--------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;2 rows in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.06&lt;/span&gt; sec)&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;说明：查询是统计 &lt;span&gt;users &lt;/span&gt;表创建时间大于 &lt;span&gt;&#x27;2021-05-20 12:00:00&#x27;&lt;/span&gt;，且不在 users_account_number 表中的用户 &lt;span&gt;ID&lt;/span&gt;&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;请注意 &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;2 &lt;/span&gt;的 select_typ 类型为 DEPENDENT SUBQUERY，表示外层 &lt;span&gt;select &lt;/span&gt;结果需要依赖于子查询的结果。效率会非常差&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;优化：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;直接用 join/left join 的写法替代，效率将会有大幅提升&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;mysql&amp;gt; &lt;span&gt;explain&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; u.id &lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;users&lt;/span&gt; u &lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;&lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; users_account_number a &lt;span&gt;on&lt;/span&gt; u.id=a.user_id&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; u.updated_at &amp;gt; &lt;span&gt;&#x27;2021-05-20 12:00:00&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;&lt;span&gt;and&lt;/span&gt; a.user_id &lt;span&gt;is&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;+&lt;span&gt;----+-------------+-------+--------+----------------+----------------+---------+--------------+--------+--------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;| id | select_type | table | type   | possible_keys  | key            | key_len | ref          | rows   | Extra                                |&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;+&lt;span&gt;----+-------------+-------+--------+----------------+----------------+---------+--------------+--------+--------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;|  1 | SIMPLE      | u     | range  | idx_uptime     | idx_uptime     | 6       | NULL         | 105958 | Using where; Using index             |&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;|  1 | SIMPLE      | a     | eq_ref | user_id_unique | user_id_unique | 4       | zm-user.u.id |      1 | Using where; Not exists; Using index |&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;+&lt;span&gt;----+-------------+-------+--------+----------------+----------------+---------+--------------+--------+--------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;2 rows in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.07&lt;/span&gt; sec)&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;说明：查询 select_type 都变为 simple ，并且查询先基于 updated_at 做索引过滤，然后与 users_account_number 进行匹配，效率非常高&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4.4.根据字段类型合理传参&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在 MySQL 中，如果参数类型与字段定义类型不一致，会导致查询无法走到索引，这点需要关注。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;mysql&amp;gt; &lt;span&gt;explain&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;    -&amp;gt; &lt;span&gt;select&lt;/span&gt; *&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;users&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; mobile=&lt;span&gt;13999999999&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;+&lt;span&gt;----+-------------+-------+------+---------------------+------+---------+------+----------+-------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;| id | select_type | table | type | possible_keys       | key  | key_len | ref  | rows     | Extra       |&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;+&lt;span&gt;----+-------------+-------+------+---------------------+------+---------+------+----------+-------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;|  1 | SIMPLE      | users | ALL  | users_mobile_unique | NULL | NULL    | NULL | 83319185 | Using where |&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;+&lt;span&gt;----+-------------+-------+------+---------------------+------+---------+------+----------+-------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;1 row in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.08&lt;/span&gt; sec)&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;说明：&lt;span&gt;users &lt;/span&gt;表的 mobile 字段是 &lt;span&gt;varchar &lt;/span&gt;类型，并且创建有索引，但是输入参数是整形，导致查询无法走索引扫描，&lt;span&gt;type &lt;/span&gt;为 ALL 全表扫描。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;优化：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;根据字段类型进行合理的传参，如果 mobile 为 varchar 类型，则在参数上添加引号&#x27;&#x27;标识为字符类型&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;mysql&amp;gt; &lt;span&gt;explain&lt;/span&gt; &lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;    -&amp;gt; &lt;span&gt;select&lt;/span&gt; *&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;users&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; mobile=&lt;span&gt;&#x27;13999999999&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;+&lt;span&gt;----+-------------+-------+-------+---------------------+---------------------+---------+-------+------+-------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;| id | select_type | table | type  | possible_keys       | key                 | key_len | ref   | rows | Extra |&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;+&lt;span&gt;----+-------------+-------+-------+---------------------+---------------------+---------+-------+------+-------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;|  1 | SIMPLE      | users | const | users_mobile_unique | users_mobile_unique | 62      | const |    1 | NULL  |&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;+&lt;span&gt;----+-------------+-------+-------+---------------------+---------------------+---------+-------+------+-------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;1 row in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.07&lt;/span&gt; sec)&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;说明：mobile 字段为 &lt;span&gt;varchar &lt;/span&gt;类型，因此在参数上使用‘’标识为字符类型，查询走到 mobile 列的唯一索引，效率非常高。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4.5.不要在查询字段上使用函数或表达式&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果在查询字段上使用函数或者表达式，MySQL 会首先对查询字段做函数运算，如果原本是准备基于该字段做索引匹配，函数运算会导致索引失效&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;mysql&amp;gt; &lt;span&gt;explain&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; students&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;&lt;span&gt;join&lt;/span&gt; students_seller &lt;span&gt;on&lt;/span&gt; students.id=students_seller.student_id&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; &lt;span&gt;date&lt;/span&gt;(students.created_at)=&lt;span&gt;&#x27;2021-05-05&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; students_seller.state=&lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;+&lt;span&gt;----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+----------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;| id | select_type | table           | type  | possible_keys                | key        | key_len | ref               | rows     | Extra                              |&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;+&lt;span&gt;----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+----------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;|  1 | SIMPLE      | students        | index | PRIMARY                      | created_at | 6       | NULL              | 52853797 | Using where; Using index           |&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;|  1 | SIMPLE      | students_seller | ref   | student_id,idx_stu_sel_state | student_id | 5       | forge.students.id |        1 | Using index condition; Using where |&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;+&lt;span&gt;----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+----------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;2 rows in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.09&lt;/span&gt; sec)&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;说明：由于在 students.created_at 字段上使用&lt;span&gt; date &lt;/span&gt;函数，导致无法通过 created_at 列匹配满足时间要求的数据，通过 &lt;span&gt;rows &lt;/span&gt;列可以看到是全表扫描 &lt;span&gt;5285&lt;/span&gt;w 数据量。&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;或许有人会疑问既然是全表扫描，为什么 &lt;span&gt;type &lt;/span&gt;是 &lt;span&gt;index &lt;/span&gt;而不是 ALL。这是因为 students 表只用到 created_at 和 &lt;span&gt;id &lt;/span&gt;列，这两列是直接包含在索引中的，查询是走的覆盖索引。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;优化：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不要在查询字段上使用函数，如果需要使用函数，那么函数可以用在参数列上&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;mysql&amp;gt; &lt;span&gt;explain&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; students&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;&lt;span&gt;join&lt;/span&gt; students_seller &lt;span&gt;on&lt;/span&gt; students.id=students_seller.student_id&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; students.created_at&amp;gt;=&lt;span&gt;&#x27;2021-05-05 00:00:00&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;and&lt;/span&gt; students.created_at&amp;lt;=&lt;span&gt;&#x27;2021-05-05 23:59:59&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; students_seller.state=&lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;+&lt;span&gt;----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+--------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;| id | select_type | table           | type  | possible_keys                | key        | key_len | ref               | rows   | Extra                              |&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;+&lt;span&gt;----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+--------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;|  1 | SIMPLE      | students        | range | PRIMARY,created_at           | created_at | 6       | NULL              | 134092 | Using where; Using index           |&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;|  1 | SIMPLE      | students_seller | ref   | student_id,idx_stu_sel_state | student_id | 5       | forge.students.id |      1 | Using index condition; Using where |&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;+&lt;span&gt;----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+--------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;2 rows in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.09&lt;/span&gt; sec)&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;说明：由于是查询注册时间为 &lt;span&gt;2021-05-05 &lt;/span&gt;日的学生，那么可以替代为使用 created_at&amp;gt;= ... &lt;span&gt;and&lt;/span&gt; &amp;lt;= 的写法&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;优化后查询根据 students.created_at 走索引范围查询，匹配行数 &lt;span&gt;rows &lt;/span&gt;为 &lt;span&gt;134092 &lt;/span&gt;条，然后与 students_seller 表关联，效率非常高。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4.6.防止分页过大导致查询越来越慢，可使用id优化&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在程序开发中，经常会对大量的返回结果进行分页返回展示，但是当分的页数过大，后续的分页查询会越来越慢，例如 limit 100 和limit 1000000,100 的查询效率差别很大。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;mysql&amp;gt; &lt;span&gt;explain&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; students.id,students.user_id,students_seller.seller_id,students.stu_city&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; students&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;&lt;span&gt;join&lt;/span&gt; students_seller &lt;span&gt;on&lt;/span&gt; students.id=students_seller.student_id&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; students.created_at&amp;gt;=&lt;span&gt;&#x27;2021-01-01&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; students_seller.state=&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;-- limit 1000000,100;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;+&lt;span&gt;----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+----------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;| id | select_type | table           | type  | possible_keys                | key        | key_len | ref               | rows     | Extra                              |&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;+&lt;span&gt;----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+----------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;|  1 | SIMPLE      | students        | range | PRIMARY,created_at           | created_at | 6       | NULL              | 23541528 | Using index condition              |&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;|  1 | SIMPLE      | students_seller | ref   | student_id,idx_stu_sel_state | student_id | 5       | forge.students.id |        1 | Using index condition; Using where |&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;+&lt;span&gt;----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+----------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;2 rows in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.43&lt;/span&gt; sec)&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;说明：虽然 &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;100 &lt;/span&gt;和&lt;span&gt;limit&lt;/span&gt; &lt;span&gt;1000000&lt;/span&gt;,&lt;span&gt;100 &lt;/span&gt;的解释计划相同，但是执行时间差异非常大。&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;&lt;span&gt;limit&lt;/span&gt; m,n 中的 m 数越大，则查询越慢。&lt;span&gt;limit&lt;/span&gt; &lt;span&gt;100 &lt;/span&gt;的执行时间 &lt;span&gt;0.05&lt;/span&gt;s；&lt;span&gt;limit&lt;/span&gt; &lt;span&gt;1000000&lt;/span&gt;,&lt;span&gt;100 &lt;/span&gt;的执行时间 &lt;span&gt;35&lt;/span&gt;s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;优化：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;MySQL 更适合于精确查询，如果满足条件的结果很多，是不合理的，应该通过范围限制使得满足条件的结果足够小，最终结果应该控制在 1000 条、100 条甚至 10 条以内。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是如果一定要对大量结果数据分页，那么可以考虑根据 ID 进行适当的范围限制&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;mysql&amp;gt; &lt;span&gt;explain&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; students.id,students.user_id,students_seller.seller_id,students.stu_city&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; students&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;&lt;span&gt;join&lt;/span&gt; students_seller &lt;span&gt;on&lt;/span&gt; students.id=students_seller.student_id&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; students.created_at&amp;gt;=&lt;span&gt;&#x27;2021-01-01&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; students_seller.state=&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; students.id&amp;gt;&lt;span&gt;54978976&lt;/span&gt; &lt;span&gt;-- 取上一次分页的最大ID&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;&lt;span&gt;limit&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;+&lt;span&gt;----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+----------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;| id | select_type | table           | type  | possible_keys                | key        | key_len | ref               | rows     | Extra                              |&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;+&lt;span&gt;----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+----------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;|  1 | SIMPLE      | students        | range | PRIMARY,created_at           | PRIMARY    | 4       | NULL              | 26431416 | Using where                        |&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;|  1 | SIMPLE      | students_seller | ref   | student_id,idx_stu_sel_state | student_id | 5       | forge.students.id |        1 | Using index condition; Using where |&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;+&lt;span&gt;----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+----------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;2 rows in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.09&lt;/span&gt; sec)&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;说明：例如假设第 &lt;span&gt;10000 &lt;/span&gt;页取到的 &lt;span&gt;100 &lt;/span&gt;行数据中最大的 students.ID 为 &lt;span&gt;54978976&lt;/span&gt;，现在需要取得第 &lt;span&gt;10001 &lt;/span&gt;页的 &lt;span&gt;100 &lt;/span&gt;行数据&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;那么可以添加 students.id&amp;gt;&lt;span&gt;54978976&lt;/span&gt;,然后取 &lt;span&gt;100 &lt;/span&gt;行数据，此方法取得的即为第 &lt;span&gt;10001 &lt;/span&gt;页的数据。&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;     通过 &lt;span&gt;id &lt;/span&gt;字段的范围限制，比简单的 &lt;span&gt;limit&lt;/span&gt; m,n 更加高效，即使是大的数据分页也不会导致效率变低。该方法执行时间稳定为 &lt;span&gt;0.05&lt;/span&gt;s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4.7. where + order by + limit 查询陷阱&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在程序设计中，经常需要用到 where+order by+limit 写法获取满足条件的、排序后的 N 条数据结果。这种写法本身并没有问题，但是在实际使用中，这条语句却常常引起严重的性能问题，需要我们重点关注。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;mysql&amp;gt; &lt;span&gt;explain&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; students.id,students.user_id,students_seller.seller_id,students.stu_city&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; students&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;&lt;span&gt;join&lt;/span&gt; students_seller &lt;span&gt;on&lt;/span&gt; students.id=students_seller.student_id&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; students.created_at&amp;gt;=&lt;span&gt;&#x27;2021-04-05&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; students.created_at&amp;lt;=&lt;span&gt;&#x27;2021-04-05 23:59:59&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; students_seller.state=&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; students.updated_at &lt;span&gt;desc&lt;/span&gt; &lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;&lt;span&gt;limit&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;+&lt;span&gt;----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+-------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;| id | select_type | table           | type  | possible_keys                | key        | key_len | ref               | rows  | Extra                              |&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;+&lt;span&gt;----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+-------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;|  1 | SIMPLE      | students        | index | PRIMARY,created_at           | updated_at | 6       | NULL              | 28608 | Using where                        |&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;|  1 | SIMPLE      | students_seller | ref   | student_id,idx_stu_sel_state | student_id | 5       | forge.students.id |     1 | Using index condition; Using where |&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;+&lt;span&gt;----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+-------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;2 rows in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.08&lt;/span&gt; sec)&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;说明：查询是想取得学生注册时间在 &lt;span&gt;2021-04-05 &lt;/span&gt;的，并且 state=&lt;span&gt;0 &lt;/span&gt;的，按照更新时间取得最近 &lt;span&gt;100 &lt;/span&gt;条学生记录。&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;请注意解释计划中得 &lt;span&gt;key &lt;/span&gt;为 updated_at 字段，我们明明是对 created_at 字段做范围限制，为啥 MySQL 选择走 updated_at 列索引？&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;敲黑板咯，拿出小本本~&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当查询语句中包含 where+order by+limit 时&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于 MySQL 优化器会认为排序 order by 是非常耗时的操作，如果能在一开始就将结果做排序返回，那是最好的。而且 limit 100 会让优化器认为这 100 条记录是很容易满足的，此时优化器会走如下执行计划：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.由于 students.updated_at 字段本身就有索引（已排序），按照 updated_at 字段每次取 100 条结果，然后走 where 匹配，将满足的结果返回&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.重复以上操作，直到有 100 条结果满足要求，循环结束&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3.如果查询按照 students.updated_at 排序的数据经过 where 条件过滤后能快速满足 100 条结果输出，那么查询或许会非常快&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;4.但如果一致没有取到满足 where 条件的 100 条结果，会一直循环操作直至遍历 students 整个表！那这个代价是非常恐怖的&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;优化：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以有很多办法避免以上执行计划与预想不一致的情况，本文列举两种办法：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;方法1. &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;order by 的字段调整为与查询条件中的字段一致，但是可能造成结果并非原始期望结果，需要沟通业务部门是否能接受该 SQL 改造。（最优）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;方法2.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; 将内部查询使用括号包裹，强制其作为一个先导执行的子查询，然后对子查询的最终结果集进行排序返回。由于子查询中会存放所有满足条件的结果，并且进行文件排序，如果满足条件的结果非常大，该方法会消耗较多资源效率较低。（亦可）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;优化方案1：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;mysql&amp;gt; &lt;span&gt;explain&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; students.id,students.user_id,students_seller.seller_id,students.stu_city&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; students&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;&lt;span&gt;join&lt;/span&gt; students_seller &lt;span&gt;on&lt;/span&gt; students.id=students_seller.student_id&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; students.created_at&amp;gt;=&lt;span&gt;&#x27;2021-04-05&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; students.created_at&amp;lt;=&lt;span&gt;&#x27;2021-04-05 23:59:59&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; students_seller.state=&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; students.created_at &lt;span&gt;desc&lt;/span&gt; &lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;&lt;span&gt;limit&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;+&lt;span&gt;----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+--------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;| id | select_type | table           | type  | possible_keys                | key        | key_len | ref               | rows   | Extra                              |&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;+&lt;span&gt;----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+--------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;|  1 | SIMPLE      | students        | range | PRIMARY,created_at           | created_at | 6       | NULL              | 184782 | Using index condition              |&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;|  1 | SIMPLE      | students_seller | ref   | student_id,idx_stu_sel_state | student_id | 5       | forge.students.id |      1 | Using index condition; Using where |&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;+&lt;span&gt;----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+--------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;2 rows in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.09&lt;/span&gt; sec)&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;说明：排序字段修改为与查询字段一致即 students.created_at，由于索引查询本身就是排序的，不必再额外排序，效率非常高。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;优化方案2：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;mysql&amp;gt; &lt;span&gt;explain&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; t.*&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;(&lt;span&gt;select&lt;/span&gt; students.id,students.user_id,students_seller.seller_id,students.stu_city,students.updated_at&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; students&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;&lt;span&gt;join&lt;/span&gt; students_seller &lt;span&gt;on&lt;/span&gt; students.id=students_seller.student_id&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; students.created_at&amp;gt;=&lt;span&gt;&#x27;2021-04-05&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; students.created_at&amp;lt;=&lt;span&gt;&#x27;2021-04-05 23:59:59&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; students_seller.state=&lt;span&gt;0&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; t&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; t.updated_at &lt;span&gt;desc&lt;/span&gt; &lt;br/&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;limit&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;+&lt;span&gt;----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+--------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;| id | select_type | table           | type  | possible_keys                | key        | key_len | ref               | rows   | Extra                              |&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;+&lt;span&gt;----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+--------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;|  1 | PRIMARY     | &amp;lt;derived2&amp;gt;      | ALL   | NULL                         | NULL       | NULL    | NULL              | 184782 | Using filesort                     |&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;|  2 | DERIVED     | students        | range | PRIMARY,created_at           | created_at | 6       | NULL              | 184782 | Using index condition              |&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;|  2 | DERIVED     | students_seller | ref   | student_id,idx_stu_sel_state | student_id | 5       | forge.students.id |      1 | Using index condition; Using where |&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;+&lt;span&gt;----+-------------+-----------------+-------+------------------------------+------------+---------+-------------------+--------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;19&lt;/span&gt;3 rows in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.08&lt;/span&gt; sec)&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;说明：查询根据 created_at 字段检索满足条件的记录构建为子查询。外层查询结果对子查询进行排序然后取得 &lt;span&gt;100 &lt;/span&gt;条记录。&lt;br/&gt;&lt;span&gt;21&lt;/span&gt;此方法不会改变原始业务逻辑，如果满足条件结果集较小，效率很高；但是如果满足条件的中间结果集非常大，则查询效率也会较差&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;5.掌门慢SQL优化示例&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上文中讲到的优化办法和优化示例，各位掌门人如能融会贯通，SQL 水平必定能更上一层楼。掌门生产环境中的 SQL 为满足业务功能，可能会关联较多的数据表，写的十分复杂，但是再复杂的查询，也是一个个的 Nested-Loop 关联。按照上述方法改写也能有优化效果，下面就是对掌门线上慢 SQL 的优化示例：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;SQL1：数据仓库中优课 BU 的查询服务&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;mysql&amp;gt; &lt;span&gt;EXPLAIN&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;count&lt;/span&gt;( &lt;span&gt;0&lt;/span&gt; ) &lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;    &lt;span&gt;`uke_hours`&lt;/span&gt;.uke_retire_record rr&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;    &lt;span&gt;JOIN&lt;/span&gt; &lt;span&gt;`uke_hours`&lt;/span&gt;.uke_apply_refund_info ari &lt;span&gt;ON&lt;/span&gt; rr.apply_refund_id = ari.id&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;    &lt;span&gt;JOIN&lt;/span&gt; &lt;span&gt;`uke`&lt;/span&gt;.uke_student stu &lt;span&gt;ON&lt;/span&gt; rr.user_id = stu.user_id&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; &lt;span&gt;`forge`&lt;/span&gt;.students students &lt;span&gt;ON&lt;/span&gt; students.user_id = ari.stu_user_Id&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;JOIN&lt;/span&gt; &lt;span&gt;`zm-user`&lt;/span&gt;.users &lt;span&gt;users&lt;/span&gt; &lt;span&gt;ON&lt;/span&gt; rr.user_id = users.id&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; &lt;span&gt;`forge`&lt;/span&gt;.sellers se &lt;span&gt;ON&lt;/span&gt; se.user_id = rr.handel_user&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;JOIN&lt;/span&gt; (&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;    &lt;span&gt;SELECT&lt;/span&gt;&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;        ard.apply_refund_id &lt;br/&gt;&lt;span&gt;13&lt;/span&gt;    &lt;span&gt;FROM&lt;/span&gt;&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;        &lt;span&gt;`uke_hours`&lt;/span&gt;.uke_apply_refund_detail ard,&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;        &lt;span&gt;`uke`&lt;/span&gt;.uke_class c &lt;br/&gt;&lt;span&gt;16&lt;/span&gt;    &lt;span&gt;WHERE&lt;/span&gt;&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;        ard.prod_id = c.prod_id &lt;br/&gt;&lt;span&gt;18&lt;/span&gt;        &lt;span&gt;AND&lt;/span&gt; c.is_deleted = &lt;span&gt;0&lt;/span&gt; &lt;br/&gt;&lt;span&gt;19&lt;/span&gt;    &lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt;&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;        ard.apply_refund_id &lt;br/&gt;&lt;span&gt;21&lt;/span&gt;    ) ard &lt;span&gt;ON&lt;/span&gt; rr.apply_refund_id = ard.apply_refund_id &lt;br/&gt;&lt;span&gt;22&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt;&lt;br/&gt;&lt;span&gt;23&lt;/span&gt;    rr.is_new_data = &lt;span&gt;1&lt;/span&gt; &lt;br/&gt;&lt;span&gt;24&lt;/span&gt;    &lt;span&gt;AND&lt;/span&gt; (&lt;br/&gt;&lt;span&gt;25&lt;/span&gt;        rr.cc_id &lt;span&gt;IN&lt;/span&gt; ( &lt;span&gt;1071853472&lt;/span&gt; ) &lt;br/&gt;&lt;span&gt;26&lt;/span&gt;        &lt;span&gt;OR&lt;/span&gt; rr.cr_id &lt;span&gt;IN&lt;/span&gt; ( &lt;span&gt;1071853472&lt;/span&gt; ) &lt;br/&gt;&lt;span&gt;27&lt;/span&gt;    &lt;span&gt;OR&lt;/span&gt; rr.team_user_id &lt;span&gt;IN&lt;/span&gt; ( &lt;span&gt;1071853472&lt;/span&gt; ) &lt;br/&gt;&lt;span&gt;28&lt;/span&gt;    &lt;span&gt;OR&lt;/span&gt; rr.apply_user_id &lt;span&gt;IN&lt;/span&gt; ( &lt;span&gt;1071853472&lt;/span&gt; ));&lt;br/&gt;&lt;span&gt;29&lt;/span&gt;+&lt;span&gt;----+-------------+------------+--------+-----------------------------------------------------------------------+-----------------------------+---------+---------------------------+--------+---------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;30&lt;/span&gt;| id | select_type | table      | type   | possible_keys                                                         | key                         | key_len | ref                       | rows   | Extra                           |&lt;br/&gt;&lt;span&gt;31&lt;/span&gt;+&lt;span&gt;----+-------------+------------+--------+-----------------------------------------------------------------------+-----------------------------+---------+---------------------------+--------+---------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;32&lt;/span&gt;|  1 | PRIMARY     | &amp;lt;derived2&amp;gt; | ALL    | NULL                                                                  | NULL                        | NULL    | NULL                      | 145787 | NULL                            |&lt;br/&gt;&lt;span&gt;33&lt;/span&gt;|  1 | PRIMARY     | rr         | ref    | idx_apply_refund_id,idx_user_id,idx_apply_user_id,idx_cc_id,idx_cr_id | idx_apply_refund_id         | 8       | ard.apply_refund_id       |      1 | Using where                     |&lt;br/&gt;&lt;span&gt;34&lt;/span&gt;|  1 | PRIMARY     | ari        | eq_ref | PRIMARY                                                               | PRIMARY                     | 8       | ard.apply_refund_id       |      1 | Using where                     |&lt;br/&gt;&lt;span&gt;35&lt;/span&gt;|  1 | PRIMARY     | se         | eq_ref | sellers_user_id                                                       | sellers_user_id             | 4       | uke_hours.rr.handel_user  |      1 | Using where; Using index        |&lt;br/&gt;&lt;span&gt;36&lt;/span&gt;|  1 | PRIMARY     | stu        | ref    | idx_userId_isDeleted_unique                                           | idx_userId_isDeleted_unique | 8       | uke_hours.rr.user_id      |      1 | Using index                     |&lt;br/&gt;&lt;span&gt;37&lt;/span&gt;|  1 | PRIMARY     | students   | eq_ref | user_id                                                               | user_id                     | 4       | uke_hours.ari.stu_user_id |      1 | Using where; Using index        |&lt;br/&gt;&lt;span&gt;38&lt;/span&gt;|  1 | PRIMARY     | users      | eq_ref | PRIMARY                                                               | PRIMARY                     | 4       | uke_hours.rr.user_id      |      1 | Using where; Using index        |&lt;br/&gt;&lt;span&gt;39&lt;/span&gt;|  2 | DERIVED     | ard        | ALL    | idx_apply_refund_id,idx_prod_id                                       | NULL                        | NULL    | NULL                      | 145787 | Using temporary; Using filesort |&lt;br/&gt;&lt;span&gt;40&lt;/span&gt;|  2 | DERIVED     | c          | ref    | idx_prod_version                                                      | idx_prod_version            | 130     | uke_hours.ard.prod_id     |      1 | Using where                     |&lt;br/&gt;&lt;span&gt;41&lt;/span&gt;+&lt;span&gt;----+-------------+------------+--------+-----------------------------------------------------------------------+-----------------------------+---------+---------------------------+--------+---------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;42&lt;/span&gt;9 rows in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.12&lt;/span&gt; sec),实际执行时间 &lt;span&gt;1.267&lt;/span&gt;s&lt;br/&gt;&lt;span&gt;43&lt;/span&gt;说明：该查询问题有二。&lt;br/&gt;&lt;span&gt;44&lt;/span&gt;其一，查询中用到子查询，&lt;span&gt;id&lt;/span&gt;=&lt;span&gt;2 &lt;/span&gt;的 derived 子查询走 &lt;span&gt;type&lt;/span&gt;=all 得全表扫描，且因为 &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by &lt;/span&gt;语句需要走文件排序操作&lt;br/&gt;&lt;span&gt;45&lt;/span&gt;其二，查询条件使用到 &lt;span&gt;or &lt;/span&gt;条件，并且由于 &lt;span&gt;or &lt;/span&gt;的列太多,查询无法使用索引.只能基于 &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;2 &lt;/span&gt;中子查询结果驱动整个查询&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;优化：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.想办法用 join 方式将子查询部分改写，不要用子查询。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.or 条件中不应该传入 cc_id、cr_id、team_user_id、apply_user_id 多种筛选条件，而应该根据实际传参精确匹配列&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3.可以将 or 条件改写为 union 写法&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;mysql&amp;gt; &lt;span&gt;EXPLAIN&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;count&lt;/span&gt;( &lt;span&gt;0&lt;/span&gt; ) &lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;    &lt;span&gt;`uke_hours`&lt;/span&gt;.uke_retire_record rr&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;    &lt;span&gt;JOIN&lt;/span&gt; &lt;span&gt;`uke_hours`&lt;/span&gt;.uke_apply_refund_info ari &lt;span&gt;ON&lt;/span&gt; rr.apply_refund_id = ari.id&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;    &lt;span&gt;JOIN&lt;/span&gt; &lt;span&gt;`uke`&lt;/span&gt;.uke_student stu &lt;span&gt;ON&lt;/span&gt; rr.user_id = stu.user_id&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; &lt;span&gt;`forge`&lt;/span&gt;.students students &lt;span&gt;ON&lt;/span&gt; students.user_id = ari.stu_user_Id&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;JOIN&lt;/span&gt; &lt;span&gt;`zm-user`&lt;/span&gt;.users &lt;span&gt;users&lt;/span&gt; &lt;span&gt;ON&lt;/span&gt; rr.user_id = users.id&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; &lt;span&gt;`forge`&lt;/span&gt;.sellers se &lt;span&gt;ON&lt;/span&gt; se.user_id = rr.handel_user&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;JOIN&lt;/span&gt; &lt;span&gt;`uke_hours`&lt;/span&gt;.uke_apply_refund_detail ard &lt;span&gt;on&lt;/span&gt; rr.apply_refund_id = ard.apply_refund_id&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;    &lt;span&gt;join&lt;/span&gt; &lt;span&gt;`uke`&lt;/span&gt;.uke_class c  &lt;span&gt;on&lt;/span&gt; ard.prod_id = c.prod_id&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;       &lt;span&gt;AND&lt;/span&gt; c.is_deleted = &lt;span&gt;0&lt;/span&gt; &lt;br/&gt;&lt;span&gt;13&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt;&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;    rr.is_new_data = &lt;span&gt;1&lt;/span&gt; &lt;br/&gt;&lt;span&gt;15&lt;/span&gt;    &lt;span&gt;AND&lt;/span&gt; (&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;        rr.cc_id &lt;span&gt;IN&lt;/span&gt; ( &lt;span&gt;1071853472&lt;/span&gt; ) &lt;br/&gt;&lt;span&gt;17&lt;/span&gt;        &lt;span&gt;OR&lt;/span&gt; rr.cr_id &lt;span&gt;IN&lt;/span&gt; ( &lt;span&gt;1071853472&lt;/span&gt; ) );&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;+&lt;span&gt;----+-------------+----------+-------------+-----------------------------------------------------+-----------------------------+---------+------------------------------+------+-----------------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;19&lt;/span&gt;| id | select_type | table    | type        | possible_keys                                       | key                         | key_len | ref                          | rows | Extra                                         |&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;+&lt;span&gt;----+-------------+----------+-------------+-----------------------------------------------------+-----------------------------+---------+------------------------------+------+-----------------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;21&lt;/span&gt;|  1 | SIMPLE      | rr       | index_merge | idx_apply_refund_id,idx_user_id,idx_cc_id,idx_cr_id | idx_cc_id,idx_cr_id         | 9,9     | NULL                         |    2 | Using union(idx_cc_id,idx_cr_id); Using where |&lt;br/&gt;&lt;span&gt;22&lt;/span&gt;|  1 | SIMPLE      | ari      | eq_ref      | PRIMARY                                             | PRIMARY                     | 8       | uke_hours.rr.apply_refund_id |    1 | Using where                                   |&lt;br/&gt;&lt;span&gt;23&lt;/span&gt;|  1 | SIMPLE      | se       | eq_ref      | sellers_user_id                                     | sellers_user_id             | 4       | uke_hours.rr.handel_user     |    1 | Using where; Using index                      |&lt;br/&gt;&lt;span&gt;24&lt;/span&gt;|  1 | SIMPLE      | ard      | ref         | idx_apply_refund_id,idx_prod_id                     | idx_apply_refund_id         | 8       | uke_hours.rr.apply_refund_id |    1 | NULL                                          |&lt;br/&gt;&lt;span&gt;25&lt;/span&gt;|  1 | SIMPLE      | c        | ref         | idx_prod_version                                    | idx_prod_version            | 130     | uke_hours.ard.prod_id        |    1 | Using where                                   |&lt;br/&gt;&lt;span&gt;26&lt;/span&gt;|  1 | SIMPLE      | users    | eq_ref      | PRIMARY                                             | PRIMARY                     | 4       | uke_hours.rr.user_id         |    1 | Using where; Using index                      |&lt;br/&gt;&lt;span&gt;27&lt;/span&gt;|  1 | SIMPLE      | stu      | ref         | idx_userId_isDeleted_unique                         | idx_userId_isDeleted_unique | 8       | uke_hours.rr.user_id         |    1 | Using index                                   |&lt;br/&gt;&lt;span&gt;28&lt;/span&gt;|  1 | SIMPLE      | students | eq_ref      | user_id                                             | user_id                     | 4       | uke_hours.ari.stu_user_id    |    1 | Using where; Using index                      |&lt;br/&gt;&lt;span&gt;29&lt;/span&gt;+&lt;span&gt;----+-------------+----------+-------------+-----------------------------------------------------+-----------------------------+---------+------------------------------+------+-----------------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;30&lt;/span&gt;8 rows in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.08&lt;/span&gt; sec),实际执行时间 &lt;span&gt;0.033&lt;/span&gt;s&lt;br/&gt;&lt;span&gt;31&lt;/span&gt;说明：改写后 &lt;span&gt;where &lt;/span&gt;查询中只保留 cc_id 和 cr_id ，由于都是 &lt;span&gt;in &lt;/span&gt;的等值查询，且列上均有索引条件，查询可以使用 index_merge 的优化特性，扫描行数为 &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;32&lt;/span&gt;&lt;br/&gt;&lt;span&gt;33&lt;/span&gt;并且查询将子查询写法替换为 &lt;span&gt;join &lt;/span&gt;，使得原本子查询中的全表扫描，变为普通的表关联，查询效率得到极大提升。优化效率 &lt;span&gt;38 &lt;/span&gt;倍&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;SQL2：market_audit 数据库的查询服务&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;mysql&amp;gt; &lt;span&gt;EXPLAIN&lt;/span&gt; &lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;    ss.id,&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;    ss.user_id userId,&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;    ss.scan_state scanCode,&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;    ss.bu,&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;    ss.source &lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;    t_screenshot ss&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; t_screenshot_analyze sa &lt;span&gt;ON&lt;/span&gt; ss.id = sa.screenshot_id &lt;br/&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt;&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;    ss.audit_state = &lt;span&gt;0&lt;/span&gt; &lt;br/&gt;&lt;span&gt;13&lt;/span&gt;    &lt;span&gt;AND&lt;/span&gt; ss.re_upload_time &lt;span&gt;IS&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;br/&gt;&lt;span&gt;14&lt;/span&gt;    &lt;span&gt;AND&lt;/span&gt; ss.bu &lt;span&gt;IN&lt;/span&gt; ( &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;11&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt; ) &lt;br/&gt;&lt;span&gt;15&lt;/span&gt;    &lt;span&gt;AND&lt;/span&gt; ((&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;            ss.re_apply_time &lt;span&gt;IS&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;br/&gt;&lt;span&gt;17&lt;/span&gt;            &lt;span&gt;AND&lt;/span&gt; ss.re_apply_time &amp;gt;= &lt;span&gt;&#x27;2021-05-14 11:30:00.145&#x27;&lt;/span&gt; &lt;br/&gt;&lt;span&gt;18&lt;/span&gt;            &lt;span&gt;AND&lt;/span&gt; ss.re_apply_time &amp;lt;= &lt;span&gt;&#x27;2021-05-21 10:30:00.145&#x27;&lt;/span&gt; ) &lt;br/&gt;&lt;span&gt;19&lt;/span&gt;            &lt;span&gt;OR&lt;/span&gt; ( ss.re_apply_time &lt;span&gt;IS&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;br/&gt;&lt;span&gt;20&lt;/span&gt;            &lt;span&gt;AND&lt;/span&gt; ss.upload_time &amp;gt;= &lt;span&gt;&#x27;2021-05-14 11:30:00.145&#x27;&lt;/span&gt; &lt;br/&gt;&lt;span&gt;21&lt;/span&gt;            &lt;span&gt;AND&lt;/span&gt; ss.upload_time &amp;lt;= &lt;span&gt;&#x27;2021-05-21 10:30:00.145&#x27;&lt;/span&gt; &lt;br/&gt;&lt;span&gt;22&lt;/span&gt;        )) &lt;br/&gt;&lt;span&gt;23&lt;/span&gt;    &lt;span&gt;AND&lt;/span&gt; (&lt;br/&gt;&lt;span&gt;24&lt;/span&gt;    sa.poster_tag != &lt;span&gt;2&lt;/span&gt; &lt;br/&gt;&lt;span&gt;25&lt;/span&gt;    &lt;span&gt;OR&lt;/span&gt; sa.poster_tag &lt;span&gt;IS&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;26&lt;/span&gt;+&lt;span&gt;----+-------------+-------+--------+------------------------------------------------------+--------------------+---------+--------------------+---------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;27&lt;/span&gt;| id | select_type | table | type   | possible_keys                                        | key                | key_len | ref                | rows    | Extra                              |&lt;br/&gt;&lt;span&gt;28&lt;/span&gt;+&lt;span&gt;----+-------------+-------+--------+------------------------------------------------------+--------------------+---------+--------------------+---------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;29&lt;/span&gt;|  1 | SIMPLE      | ss    | ref    | idx_create_time,idx_re_upload_time,idx_re_apply_time | idx_re_upload_time | 6       | const              | 1393993 | Using index condition; Using where |&lt;br/&gt;&lt;span&gt;30&lt;/span&gt;|  1 | SIMPLE      | sa    | eq_ref | PRIMARY                                              | PRIMARY            | 8       | market_audit.ss.id |       1 | Using where                        |&lt;br/&gt;&lt;span&gt;31&lt;/span&gt;+&lt;span&gt;----+-------------+-------+--------+------------------------------------------------------+--------------------+---------+--------------------+---------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;32&lt;/span&gt;2 rows in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.07&lt;/span&gt; sec)&lt;br/&gt;&lt;span&gt;33&lt;/span&gt;说明：看解释计划似乎查询是走到 &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;ref &lt;/span&gt;的非唯一索引扫描，实则查询只能根据 ss.re_upload_time &lt;span&gt;IS&lt;/span&gt; &lt;span&gt;NULL &lt;/span&gt;这一个条件做简单的非空过滤&lt;br/&gt;&lt;span&gt;34&lt;/span&gt;按照表数据的组成，无异于全表扫描。该查询执行时间 &lt;span&gt;4.87&lt;/span&gt;s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;优化：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;查询中条件基本都无筛选性可言。可以用作筛选条件的就是 re_apply_time 和 upload_time ，但是这个条件在查询中使用 or 连接&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;需要用 union 代替 or 的写法，使查询能分别走到 re_apply_time 和 upload_time 列的索引。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;mysql&amp;gt; &lt;span&gt;EXPLAIN&lt;/span&gt; &lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;    ss.id,&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;    ss.user_id userId,&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;    ss.scan_state scanCode,&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;    ss.bu,&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;    ss.source &lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;    t_screenshot ss&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; t_screenshot_analyze sa &lt;span&gt;ON&lt;/span&gt; ss.id = sa.screenshot_id &lt;br/&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt;&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;    ss.audit_state = &lt;span&gt;0&lt;/span&gt; &lt;br/&gt;&lt;span&gt;13&lt;/span&gt;    &lt;span&gt;AND&lt;/span&gt; ss.re_upload_time &lt;span&gt;IS&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;br/&gt;&lt;span&gt;14&lt;/span&gt;    &lt;span&gt;AND&lt;/span&gt; ss.bu &lt;span&gt;IN&lt;/span&gt; ( &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;11&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt; ) &lt;br/&gt;&lt;span&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;    &lt;span&gt;AND&lt;/span&gt; ss.re_apply_time &lt;span&gt;IS&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;br/&gt;&lt;span&gt;17&lt;/span&gt;            &lt;span&gt;AND&lt;/span&gt; ss.re_apply_time &amp;gt;= &lt;span&gt;&#x27;2021-05-14 11:30:00.145&#x27;&lt;/span&gt; &lt;br/&gt;&lt;span&gt;18&lt;/span&gt;            &lt;span&gt;AND&lt;/span&gt; ss.re_apply_time &amp;lt;= &lt;span&gt;&#x27;2021-05-21 10:30:00.145&#x27;&lt;/span&gt; &lt;br/&gt;&lt;span&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;    &lt;span&gt;AND&lt;/span&gt; (&lt;br/&gt;&lt;span&gt;21&lt;/span&gt;    sa.poster_tag != &lt;span&gt;2&lt;/span&gt; &lt;br/&gt;&lt;span&gt;22&lt;/span&gt;    &lt;span&gt;OR&lt;/span&gt; sa.poster_tag &lt;span&gt;IS&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;)   &lt;br/&gt;&lt;span&gt;23&lt;/span&gt;&lt;span&gt;union&lt;/span&gt;&lt;br/&gt;&lt;span&gt;24&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;&lt;br/&gt;&lt;span&gt;25&lt;/span&gt;    ss.id,&lt;br/&gt;&lt;span&gt;26&lt;/span&gt;    ss.user_id userId,&lt;br/&gt;&lt;span&gt;27&lt;/span&gt;    ss.scan_state scanCode,&lt;br/&gt;&lt;span&gt;28&lt;/span&gt;    ss.bu,&lt;br/&gt;&lt;span&gt;29&lt;/span&gt;    ss.source &lt;br/&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;br/&gt;&lt;span&gt;31&lt;/span&gt;    t_screenshot ss&lt;br/&gt;&lt;span&gt;32&lt;/span&gt;    &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; t_screenshot_analyze sa &lt;span&gt;ON&lt;/span&gt; ss.id = sa.screenshot_id &lt;br/&gt;&lt;span&gt;33&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt;&lt;br/&gt;&lt;span&gt;34&lt;/span&gt;    ss.audit_state = &lt;span&gt;0&lt;/span&gt; &lt;br/&gt;&lt;span&gt;35&lt;/span&gt;    &lt;span&gt;AND&lt;/span&gt; ss.re_upload_time &lt;span&gt;IS&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;br/&gt;&lt;span&gt;36&lt;/span&gt;    &lt;span&gt;AND&lt;/span&gt; ss.bu &lt;span&gt;IN&lt;/span&gt; ( &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;11&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt; )&lt;br/&gt;&lt;span&gt;37&lt;/span&gt;&lt;br/&gt;&lt;span&gt;38&lt;/span&gt;    &lt;span&gt;AND&lt;/span&gt; ss.re_apply_time &lt;span&gt;IS&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;br/&gt;&lt;span&gt;39&lt;/span&gt;            &lt;span&gt;AND&lt;/span&gt; ss.upload_time &amp;gt;= &lt;span&gt;&#x27;2021-05-14 11:30:00.145&#x27;&lt;/span&gt; &lt;br/&gt;&lt;span&gt;40&lt;/span&gt;            &lt;span&gt;AND&lt;/span&gt; ss.upload_time &amp;lt;= &lt;span&gt;&#x27;2021-05-21 10:30:00.145&#x27;&lt;/span&gt; &lt;br/&gt;&lt;span&gt;41&lt;/span&gt;    &lt;span&gt;AND&lt;/span&gt; (&lt;br/&gt;&lt;span&gt;42&lt;/span&gt;    sa.poster_tag != &lt;span&gt;2&lt;/span&gt; &lt;br/&gt;&lt;span&gt;43&lt;/span&gt;    &lt;span&gt;OR&lt;/span&gt; sa.poster_tag &lt;span&gt;IS&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;44&lt;/span&gt;+&lt;span&gt;------+--------------+------------+--------+------------------------------------------------------+-------------------+---------+--------------------+--------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;45&lt;/span&gt;| id   | select_type  | table      | type   | possible_keys                                        | key               | key_len | ref                | rows   | Extra                              |&lt;br/&gt;&lt;span&gt;46&lt;/span&gt;+&lt;span&gt;------+--------------+------------+--------+------------------------------------------------------+-------------------+---------+--------------------+--------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;47&lt;/span&gt;|    1 | PRIMARY      | ss         | range  | idx_re_upload_time,idx_re_apply_time                 | idx_re_apply_time | 6       | NULL               |    137 | Using index condition; Using where |&lt;br/&gt;&lt;span&gt;48&lt;/span&gt;|    1 | PRIMARY      | sa         | eq_ref | PRIMARY                                              | PRIMARY           | 8       | market_audit.ss.id |      1 | Using where                        |&lt;br/&gt;&lt;span&gt;49&lt;/span&gt;|    2 | UNION        | ss         | range  | idx_create_time,idx_re_upload_time,idx_re_apply_time | idx_create_time   | 5       | NULL               | 178928 | Using index condition; Using where |&lt;br/&gt;&lt;span&gt;50&lt;/span&gt;|    2 | UNION        | sa         | eq_ref | PRIMARY                                              | PRIMARY           | 8       | market_audit.ss.id |      1 | Using where                        |&lt;br/&gt;&lt;span&gt;51&lt;/span&gt;| NULL | UNION RESULT | &amp;lt;union1,2&amp;gt; | ALL    | NULL                                                 | NULL              | NULL    | NULL               | NULL   | Using temporary                    |&lt;br/&gt;&lt;span&gt;52&lt;/span&gt;+&lt;span&gt;------+--------------+------------+--------+------------------------------------------------------+-------------------+---------+--------------------+--------+------------------------------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;53&lt;/span&gt;5 rows in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.20&lt;/span&gt; sec)&lt;br/&gt;&lt;span&gt;54&lt;/span&gt;说明：将 &lt;span&gt;or &lt;/span&gt;连接的条件改为 &lt;span&gt;union &lt;/span&gt;连接，改写后语句长度增加一倍。&lt;br/&gt;&lt;span&gt;55&lt;/span&gt;但是注意到 &lt;span&gt;union &lt;/span&gt;连接的两个子查询，都能根据对应的输入参数（upload_time 和 re_apply_time ），进行索引 &lt;span&gt;range &lt;/span&gt;扫描。&lt;br/&gt;&lt;span&gt;56&lt;/span&gt;基于索引范围的扫描，效率提升很多。该查询执行时间为 &lt;span&gt;0.245&lt;/span&gt;s，优化效率提升 &lt;span&gt;20 &lt;/span&gt;倍&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;SQL3: forge 数据库的分页取数&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;mysql&amp;gt; &lt;span&gt;explain&lt;/span&gt; &lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;  ss.student_id &lt;span&gt;as&lt;/span&gt; studentId,&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;  ss.pre_seller_id &lt;span&gt;as&lt;/span&gt; preSellerId,&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;  ss.state &lt;span&gt;as&lt;/span&gt; state&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;  students_seller ss &lt;span&gt;force&lt;/span&gt; &lt;span&gt;index&lt;/span&gt;(PRIMARY)&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;  ss.bu = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;  &lt;span&gt;and&lt;/span&gt; ss.seller_id &lt;span&gt;is&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;  ss.id &lt;span&gt;asc&lt;/span&gt;&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;&lt;span&gt;limit&lt;/span&gt;&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;  &lt;span&gt;115000&lt;/span&gt;, &lt;span&gt;5000&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;+&lt;span&gt;----+-------------+-------+-------+---------------+---------+---------+------+--------+-------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;| id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows   | Extra       |&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;+&lt;span&gt;----+-------------+-------+-------+---------------+---------+---------+------+--------+-------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;|  1 | SIMPLE      | ss    | index | NULL          | PRIMARY | 4       | NULL | 120000 | Using where |&lt;br/&gt;&lt;span&gt;19&lt;/span&gt;+&lt;span&gt;----+-------------+-------+-------+---------------+---------+---------+------+--------+-------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;1 row in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.05&lt;/span&gt; sec)&lt;br/&gt;&lt;span&gt;21&lt;/span&gt;说明：这条 &lt;span&gt;SQL &lt;/span&gt;的逻辑很简单，就是按照 bu=&lt;span&gt;0 &lt;/span&gt;和 seller_id &lt;span&gt;is&lt;/span&gt; &lt;span&gt;null &lt;/span&gt;作为条件，取得 students_seller 表所有满足条件的记录。&lt;br/&gt;&lt;span&gt;22&lt;/span&gt;由于满足要求的记录较多，该查询可能会循环执行几百次。从慢 &lt;span&gt;SQL &lt;/span&gt;记录中可以看到 &lt;span&gt;2021-05-21 &lt;/span&gt;日该查询执行了 &lt;span&gt;721 &lt;/span&gt;次，总执行时长 &lt;span&gt;11670&lt;/span&gt;s，总扫描行数 &lt;span&gt;363 &lt;/span&gt;亿行，返回 &lt;span&gt;360 &lt;/span&gt;万行&lt;br/&gt;&lt;span&gt;23&lt;/span&gt;注意：&lt;span&gt;limit &lt;/span&gt;这种写法，解析行数会随着 &lt;span&gt;limit&lt;/span&gt; m,n 后的 m 数增加导致解析行数持续增加，查询变慢。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;优化：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;针对这种循环取数，数据量很大的情况，需要根据 ID&amp;gt;last_max_id 的方式取数&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;如：上一次循环取到的students_seller表的最大id为102378346&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;mysql&amp;gt; &lt;span&gt;explain&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;    -&amp;gt; &lt;span&gt;select&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;  ss.student_id &lt;span&gt;as&lt;/span&gt; studentId,&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;  ss.pre_seller_id &lt;span&gt;as&lt;/span&gt; preSellerId,&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;  ss.state &lt;span&gt;as&lt;/span&gt; state&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;  students_seller ss &lt;span&gt;force&lt;/span&gt; &lt;span&gt;index&lt;/span&gt;(primary)&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;  ss.bu = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;  &lt;span&gt;and&lt;/span&gt; ss.seller_id &lt;span&gt;is&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;    &lt;span&gt;and&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&amp;gt;=&lt;span&gt;102378346&lt;/span&gt;&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; ss.id &lt;span&gt;asc&lt;/span&gt;&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;limit&lt;/span&gt; &lt;span&gt;5000&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;+&lt;span&gt;----+-------------+-------+-------+---------------+---------+---------+------+----------+-------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;| id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows     | Extra       |&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;+&lt;span&gt;----+-------------+-------+-------+---------------+---------+---------+------+----------+-------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;|  1 | SIMPLE      | ss    | range | PRIMARY       | PRIMARY | 4       | NULL | 45237438 | Using where |&lt;br/&gt;&lt;span&gt;19&lt;/span&gt;+&lt;span&gt;----+-------------+-------+-------+---------------+---------+---------+------+----------+-------------+&lt;/span&gt;&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;1 row in &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.07&lt;/span&gt; sec)&lt;br/&gt;&lt;span&gt;21&lt;/span&gt;说明：按照 &lt;span&gt;id &lt;/span&gt;范围限制后，每次查询时间均非常快速，效率很高。&lt;br/&gt;&lt;span&gt;22&lt;/span&gt;按此方式优化后，每次查询时间稳定为 &lt;span&gt;0.15&lt;/span&gt;s，全部扫描 &lt;span&gt;721 &lt;/span&gt;次，总执行时长为 &lt;span&gt;108.15&lt;/span&gt;s,效率提升 &lt;span&gt;108 &lt;/span&gt;倍&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;结束语&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;MySQL 数据库博大精深，只有理解数据库底层原理，才能更好的做好优化工作。因此本文在介绍优化相关的规则和方法时，也会引申介绍相关数据库原理，也是希望帮助大家更好的理解并运用这些优化方法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;MySQL 是一个 OLTP 数据库，基于事务的增删改效率很高，基于索引的单值查询也非常快，MySQL 本身也非常适合这种短而快的数据操作或查询。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是多表数据关联查询、查询返回大量数据结果，基于大量数据的统计或者排序操作，并不是 MySQL 数据库所擅长的。&lt;strong&gt;倘若不能减少数据扫描范围，那任何查询优化都是空谈&lt;/strong&gt;。如果是这类 OLAP 数据需求，可以考虑一下其他架构设计，不能完全依赖 MySQL 数据库。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;----------  END  ----------&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;加入掌门&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section&gt;&lt;span&gt;掌门在招职位有研发总监（ 音视频/运维方向 ）、研发工程师/架构师（ &lt;/span&gt;&lt;code&gt;&lt;span&gt;Web&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 前端/ &lt;/span&gt;&lt;code&gt;&lt;span&gt;Java&lt;/span&gt;&lt;/code&gt;&lt;span&gt; / &lt;/span&gt;&lt;code&gt;&lt;span&gt;iOS&lt;/span&gt;&lt;/code&gt;&lt;span&gt; / 安卓 ）、测试工程师（ 功能/自动化/性能 ）、&lt;/span&gt;&lt;code&gt;&lt;span&gt;DBA&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 、大数据工程师、算法工程师（ &lt;/span&gt;&lt;code&gt;&lt;span&gt;OCR&lt;/span&gt;&lt;/code&gt;&lt;span&gt; /用户画像/推荐 ）、&lt;/span&gt;&lt;code&gt;&lt;span&gt;K8s&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 架构师、运维工程师、产品经理、安全工程师、网络工程师。欢迎加入掌门教育大家庭，一起畅谈技术，分享交流。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;投递信箱：zeying.shi@zhangmen.com 施老师。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Jpd97tSMqvnTJac4NoDicVZNk3icduJlOiahU3qgict0PQeFicgd2coPUdqDmCgymEWYX09BqiaJRlgbNhc6ZCcD8icfA/640?wx_fmt=jpeg&quot;/&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Jpd97tSMqvnTJac4NoDicVZNk3icduJlOia6WJh3hjKblib98Ma6hGBmDorwiaSbNAic8Qj6aTz0dlaibLxwCs15PREmA/640?wx_fmt=jpeg&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;往期好文&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NTgxNDM0Nw==&amp;amp;mid=2247486005&amp;amp;idx=1&amp;amp;sn=7c13e82356d48531f15eeceee812504c&amp;amp;chksm=fbcfd691ccb85f878d6fa9198bb63f3e621a738742ff3cafc82443b2094ffdad69643f5acd8d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;INFRA-JOY微服务治理验证工程实践分享&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NTgxNDM0Nw==&amp;amp;mid=2247485968&amp;amp;idx=1&amp;amp;sn=9613c5c9f360935d524600f51f8ff460&amp;amp;chksm=fbcfd6b4ccb85fa2b41de1b1519fe5edac69a17de0f8e43a91b57b007fd10bdf8c7e14c6d84c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;掌门持续交付流水线大规模实践&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NTgxNDM0Nw==&amp;amp;mid=2247485939&amp;amp;idx=1&amp;amp;sn=8e86b2c5ad163bf4464e56e70736ca46&amp;amp;chksm=fbcfd557ccb85c4168f51d12657bf6fbcdca5da5b4b93cef835145bcf391dfe7aa5ac6b7a4ae&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;绘本阅读总结&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b901d67e3517960ba8bb8331f708c0fa</guid>
<title>这可能是最容易理解的 Go Mutex 源码剖析</title>
<link>https://toutiao.io/k/p77raxg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;Hi，大家好，我是 haohongfan。&lt;/p&gt;

&lt;p&gt;上一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s/dbdP_Jz9OHCuLO1ffOmCNg&quot;&gt;《一文完全掌握 Go math/rand》&lt;/a&gt;，我们知道 math/rand 的 global rand 有一个全局锁，我的文章里面有一句话：“修复方案: 就是把 rrRand 换成了 globalRand, 在线上高并发场景下, 发现全局锁影响并不大.”， 有同学私聊我“他们遇到线上服务的锁竞争特别激烈”。确实我这句话说的并不严谨。但是也让我有了一个思考：到底多高的 QPS 才能让 Mutex 产生强烈的锁竞争 ？&lt;/p&gt;

&lt;p&gt;到底加锁的代码会不会产生线上问题？ 到底该不该使用锁来实现这个功能？线上的问题是不是由于使用了锁造成的？针对这些问题，本文就从源码角度剖析 Go Mutex, 揭开 Mutex 的迷雾。&lt;/p&gt;

&lt;h2&gt;源码分析&lt;/h2&gt;

&lt;p&gt;Go mutex 源码只有短短的 228 行，但是却包含了很多的状态转变在里面，很不容易看懂，具体可以参见下面的流程图。Mutex 的实现主要借助了 CAS 指令 + 自旋 + 信号量来实现，具体代码我就不再每一行做分析了，有兴趣的可以根据下面流程图配合源码阅读一番。&lt;/p&gt;

&lt;h3&gt;Lock&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3415d8d24334dddae482cf5d986f2f6%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;Unlock&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f95dbc06af2a456095b7053cbb4c406d%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;Unlock&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;一些例子&lt;/h2&gt;

&lt;h4&gt;1. 一个 goroutine 加锁解锁过程&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00f9606fb7c54584b9f1ba5d0195b47f%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;加锁加锁&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;2. 没有加锁，直接解锁问题&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c8b952622354103af1d8578a892dedc%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;没有加锁直接解锁&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;3. 两个 Goroutine，互相加锁解锁&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02d63030eb6444328aa8fa09584823d6%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;互相加锁解锁&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;4. 三个 Goroutine 等待加锁过程&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab2b3696e89e4fd9b8a70a9d43afa1fd%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;三个 goroutine 等待加锁&quot;/&gt;&lt;/p&gt;

&lt;p&gt;整篇源码其实涉及比较难以理解的就是 Mutex 状态（mutexLocked，mutexWoken，mutexStarving，mutexWaiterShift） 与 Goroutine 之间的状态（starving，awoke）改变， 我们下面将逐一说明。&lt;/p&gt;

&lt;h3&gt;什么是 Goroutine 排队?&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8daefccd01704582ab7d99ba098b05b0%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;排队&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果 Mutex 已经被一个 Goroutine 获取了锁, 其它等待中的 Goroutine 们只能一直等待。那么等这个锁释放后，等待中的 Goroutine 中哪一个会优先获取 Mutex 呢?&lt;/p&gt;

&lt;p&gt;正常情况下, 当一个 Goroutine 获取到锁后, 其他的 Goroutine 开始进入自旋转(为了持有CPU) 或者进入沉睡阻塞状态(等待信号量唤醒). 但是这里存在一个问题, 新请求的 Goroutine 进入自旋时是仍然拥有 CPU 的, 所以比等待信号量唤醒的 Goroutine 更容易获取锁. 用官方话说就是，新请求锁的 Goroutine具有优势，它正在CPU上执行，而且可能有好几个，所以刚刚唤醒的 Goroutine 有很大可能在锁竞争中失败. &lt;/p&gt;

&lt;p&gt;于是如果一个 Goroutine 被唤醒过后, 仍然没有拿到锁, 那么该 Goroutine 会放在等待队列的最前面. 并且那些等待超过 1 ms 的 Goroutine 还没有获取到锁，该 Goroutine 就会进入饥饿状态。该 Goroutine 是饥饿状态并且 Mutex 是 Locked 状态时，才有可能给 Mutex 设置成饥饿状态. &lt;/p&gt;

&lt;p&gt;获取到锁的 Goroutine Unlock, 将 Mutex 的 Locked 状态解除, 发出来解锁信号, 等待的 Goroutine 开始竞争该信号. 如果发现当前 Mutex 是饥饿状态, 直接将唤醒信号发给第一个等待的 Goroutine&lt;/p&gt;

&lt;p&gt;这就是所谓的 Goroutine 排队&lt;/p&gt;

&lt;h3&gt;排队功能是如何实现的&lt;/h3&gt;

&lt;p&gt;我们知道在正常状态下，所有等待锁的 Goroutine 按照 FIFO 顺序等待，在 Mutex 饥饿状态下，会直接把释放锁信号发给等待队列中的第一个Goroutine。排队功能主要是通过 runtime_SemacquireMutex, runtime_Semrelease 来实现的. &lt;/p&gt;

&lt;h4&gt;1. runtime_SemacquireMutex -- 入队&lt;/h4&gt;

&lt;p&gt;当 Mutex 被其他 Goroutine 持有时，新来的 Goroutine 将会被 runtime_SemacquireMutex 阻塞。阻塞会分为2种情况:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Goroutine 第一次被阻塞：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当 Goroutine 第一次尝试获取锁时，由于当前锁可能不能被锁定，于是有可能进入下面逻辑&lt;/p&gt;

&lt;pre lang=&quot;go&quot;&gt;&lt;code&gt;queueLifo := waitStartTime != 0
if waitStartTime == 0 {
    waitStartTime = runtime_nanotime()
}
runtime_SemacquireMutex(&amp;amp;m.sema, queueLifo, 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于 waitStartTime 等于 0，runtime_SemacquireMutex 的 queueLifo 等于 false, 于是该 Goroutine 放入到队列的尾部。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Goroutine 被唤醒过，但是没加锁成功，再次被阻塞&lt;/strong&gt;
由于 Goroutine 被唤醒过，waitStartTime 不等于 0，runtime_SemacquireMutex 的 queueLifo 等于 true, 于是该 Goroutine 放入到队列的头部。&lt;/p&gt;

&lt;h4&gt;2. runtime_Semrelease -- 出队&lt;/h4&gt;

&lt;p&gt;当某个 Goroutine 释放锁时，调用 Unlock，这里同样存在两种情况：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当前 mutex 不是饥饿状态&lt;/strong&gt;&lt;/p&gt;

&lt;pre lang=&quot;go&quot;&gt;&lt;code&gt;if new&amp;amp;mutexStarving == 0 {
    old := new
    for {
        if old&amp;gt;&amp;gt;mutexWaiterShift == 0 || old&amp;amp;(mutexLocked|mutexWoken|mutexStarving) != 0 {
            return
        }
        // Grab the right to wake someone.
        new = (old - 1&amp;lt;&amp;lt;mutexWaiterShift) | mutexWoken
        if atomic.CompareAndSwapInt32(&amp;amp;m.state, old, new) {
            runtime_Semrelease(&amp;amp;m.sema, false, 1)
            return
        }
        old = m.state
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unlock 时 Mutex 的 Locked 状态被去掉。当发现当前 Mutex 不是饥饿状态，设置 runtime_Semrelease 的 handoff 参数是 false, 于是唤醒其中一个 Goroutine。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当前 mutex 已经是饥饿状态&lt;/strong&gt;&lt;/p&gt;

&lt;pre lang=&quot;go&quot;&gt;&lt;code&gt;} else {
    // Starving mode: handoff mutex ownership to the next waiter, and yield
    // our time slice so that the next waiter can start to run immediately.
    // Note: mutexLocked is not set, the waiter will set it after wakeup.
    // But mutex is still considered locked if mutexStarving is set,
    // so new coming goroutines won&#x27;t acquire it.
    runtime_Semrelease(&amp;amp;m.sema, true, 1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样 Unlock 时 Mutex 的 Locked 状态被去掉。由于当前 Mutex 是饥饿状态，于是设置 runtime_Semrelease 的 handoff 参数是 true, 于是让等待队列头部的第一个 Goroutine 获得锁。&lt;/p&gt;

&lt;h3&gt;Goroutine 的排队 与 mutex 中记录的 Waiters 之间的关系?&lt;/h3&gt;

&lt;p&gt;通过上面的分析，我们知道 Goroutine 的排队是通过 runtime_SemacquireMutex 来实现的。Mutex.state 记录了目前通过 runtime_SemacquireMutex 排队的 Goroutine 的数量&lt;/p&gt;

&lt;h3&gt;Goroutine 的饥饿与 Mutex 饥饿之间的关系？&lt;/h3&gt;

&lt;p&gt;Goroutine 的状态跟 Mutex 的是息息相关的。只有在 Goroutine 是饥饿状态下，才有可能给 Mutex 设置成饥饿状态。在 Mutex 是饥饿状态时，才有可能让饥饿的 Goroutine 优先获取到锁。不过需要注意的是，触发 Mutex 饥饿的 Goroutine 并不一定获取锁，有可能被其他的饥饿的 Goroutine 截胡。&lt;/p&gt;

&lt;h3&gt;Goroutine 能够加锁成功的情况&lt;/h3&gt;

&lt;p&gt;Mutex 没有被 Goroutine 占用 Mutex.state = 0, 这种情况下一定能获取到锁. 例如: 第一个 Goroutine 获取到锁
还有一种情况 Goroutine有可能加锁成功:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当前 Mutex 不是饥饿状态, 也不是 Locked 状态, 尝试 CAS 加锁时, Mutex 的值还没有被其他 Goroutine 改变, 当前 Goroutine 才能加锁成功.&lt;/li&gt;
&lt;li&gt;某个 Goroutine 刚好被唤醒后, 重新获取 Mutex, 这个时候 Mutex 处于饥饿状态. 因为这个时候只唤醒了饥饿的 Goroutine, 其他的 Goroutine 都在排队中, 没有其他 Goroutine 来竞争 Mutex, 所以能直接加锁成功
## Mutex 锁竞争的相关问题
### 探测锁竞争&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;日常开发中锁竞争的问题还是能经常遇到的，我们如何去发现锁竞争呢？其实还是需要靠 pprof 来人肉来分析。&lt;/p&gt;

&lt;p&gt;《一次错误使用 go-cache 导致出现的线上问题》就是我真是遇到的一次线上问题，表象就是接口大量超时，打开pprof 发现大量 Goroutine 都集中 Lock 上。这个真实场景的具体的分析过程，有兴趣的可以阅读一下。
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/275e9bd9ed124885813ec12719693898%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;mutex 竞争&quot;/&gt;
简单总结一下：
压测或者流量高的时候发现系统不正常，打开 pprof 发现 goroutine 指标在飙升，并且大量 Goroutine 都阻塞在 Mutex  的 Lock 上，这个基本就可以确定是锁竞争。&lt;/p&gt;

&lt;p&gt;pprof 里面是有个 pprof/mutex 指标，不过该指标默认是关闭的，而且并没有太多资料有介绍这个指标如何来分析 Mutex。有知道这个指标怎么用的大佬，欢迎留言。&lt;/p&gt;

&lt;h3&gt;mutex 锁的瓶颈&lt;/h3&gt;

&lt;p&gt;现在模拟业务开发中的某接口，平均耗时 10 ms, 在 32C 物理机上压测。CentOS Linux release 7.3.1611 (Core),  go1.15.8 
压测代码如下：&lt;/p&gt;

&lt;pre lang=&quot;go&quot;&gt;&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;sync&quot;
    &quot;time&quot;

    _ &quot;net/http/pprof&quot;
)

var mux sync.Mutex

func testMutex(w http.ResponseWriter, r *http.Request) {
    mux.Lock()
    time.Sleep(10 * time.Millisecond)
    mux.Unlock()
}

func main() {
    go func() {
        log.Println(http.ListenAndServe(&quot;:6060&quot;, nil))
    }()

    http.HandleFunc(&quot;/test/mutex&quot;, testMutex)
    if err := http.ListenAndServe(&quot;:8000&quot;, nil); err != nil {
        fmt.Println(&quot;start http server fail:&quot;, err)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc33b994b9e741559c200eca50a54479%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;moni_mutex.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90f4cee534664df88b25819f551d0322%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;yaceresult.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这个例子写的比较极端了，全局共享一个 Mutex。经过压测发现在 100 qps 时，Mutex 没啥竞争，在 150 QPS 时竞争就开始变的激烈了。&lt;/p&gt;

&lt;p&gt;当然我们写业务代码并不会这么写，但是可以通过这个例子发现 Mutex 在 QPS 很低的时候，锁竞争就会很激烈。需要说明的一点：这个压测是数值没啥具体的意义，不同的机器上表现肯定还会不一样。&lt;/p&gt;

&lt;p&gt;这个例子告诉我们几点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;写业务时不能全局使用同一个 Mutex&lt;/li&gt;
&lt;li&gt;尽量避免使用 Mutex，如果非使用不可，尽量多声明一些 Mutex，采用取模分片的方式去使用其中一个 Mutex
## 日常使用注意点&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;1. Lock/Unlock 成对出现&lt;/h4&gt;

&lt;p&gt;我们日常开发中使用 Mutex 一定要记得：先 Lock 再 Unlock。&lt;/p&gt;

&lt;p&gt;特别要注意的是：没有 Lock 就去 Unlock。当然这个 case 一般情况下我们都不会这么写。不过有些变种的写法我们要尤其注意，例如&lt;/p&gt;

&lt;pre lang=&quot;go&quot;&gt;&lt;code&gt;var mu sync.Mutex

func release() {
    mu.Lock()
    fmt.Println(&quot;lock1 success&quot;)
    time.Sleep(10 * time.Second)

    mu.Lock()
    fmt.Println(&quot;lock2 success&quot;)
}

func main() {
    go release()

    time.Sleep(time.Second)
    mu.Unlock()
    fmt.Println(&quot;unlock success&quot;)
    for {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre lang=&quot;go&quot;&gt;&lt;code&gt;release lock1 success
main unlock success
release lock2 success
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们看到 release goroutine 的锁竟然被 main goroutine 给释放了，同时 release goroutine 又能重新获取到锁。&lt;/p&gt;

&lt;p&gt;这段代码可能你想不到有啥问题，其实这个问题蛮严重的，想象一下你的代码中，本来是要加锁给用户加积分的，但是竟然被别的 goroutine 给解锁了，导致积分没有增加成功，同时解锁的时候还别的 Goroutine 的锁给 Unlock 了，互相加锁解锁，导致莫名其妙的问题。&lt;/p&gt;

&lt;p&gt;所以一般情况下，要在本 Goroutine 中完成 Mutex 的 Lock&amp;amp;Unlock，千万不要将要加锁和解锁分到两个 Goroutine 中进行。如果你确实需要这么做，请抽支烟冷静一下，你真的是否需要这么做。&lt;/p&gt;

&lt;h4&gt;2. Mutex 千万不能被复制&lt;/h4&gt;

&lt;p&gt;我之前发过的&lt;a href=&quot;https://mp.weixin.qq.com/s/OYGVR0d-fq1hgOvrdsUnYA&quot;&gt;《当 Go struct 遇上 Mutex》&lt;/a&gt;里面详细分析了不能被复制的原因，以及如何 Mutex 的最佳使用方式，建议没看过的同学去看一遍。我们还是举个例子说下为啥不能被复制，以及如何用源码进行分析&lt;/p&gt;

&lt;pre lang=&quot;go&quot;&gt;&lt;code&gt;type Person struct {
    mux sync.Mutex
}

func Reduce(p1 Person) {
    fmt.Println(&quot;step...&quot;, )
    p1.mux.Lock()
    fmt.Println(p1)
    defer p1.mux.Unlock()
    fmt.Println(&quot;over...&quot;)
}

func main() {
    var p Person
    p.mux.Lock()
    go Reduce(p)
    p.mux.Unlock()
    fmt.Println(111)
    for {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;问题分析：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;main Goroutine 已经给 p.mux 加了锁 , 这个时候 p.mux  的 state 的值是 mutexLocked。&lt;/li&gt;
&lt;li&gt;然后将 p.mux 复制给了 Reduce Goroutine。这个时候被复制的 p1.mux 的 state 的值也是 mutexLocked。&lt;/li&gt;
&lt;li&gt;main Goroutine 虽然已经解锁了, 但是 Reduce Goroutine 跟 main Goroutine 的 mutex 已经不是同一个 mutex 了, 所以 Reduce Goroutine 就会加锁失败, 产生死锁，关键是编译器还发现不了这个 Deadlock.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;关于为什么编译器不能发现这个死锁，可以看我的博客&lt;a href=&quot;https://www.haohongfan.com/post/2019-07-11-deadlock-detector/&quot;&gt;《一次 Golang Deadlock 的讨论》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;至此 Go Mutex 的源码剖析全部完毕了，有什么想跟我交流的可以再评论区留言。&lt;/p&gt;

&lt;p&gt;欢迎关注我的公众号：&lt;strong&gt;HHFCodeRv&lt;/strong&gt; 随时关注我的最新文章&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/debc8fa6003949d7a16dd1425c0be235%7Etplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;1122.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b0a48517f02d1d956b4bce4b5e3a9d91</guid>
<title>进程、线程与协程傻傻分不清？一文带你吃透</title>
<link>https://toutiao.io/k/cs2cbes</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欢迎来到操作系统系列，依然采用图解 + 大白话的形式来讲解，让小白也能看懂，帮助大家快速科普入门&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇开始介绍进程、线程、协程，相信很多小白们对这几个概念理解的不清晰，这里全部给你们安排的明明白白，我们开始进入正文吧&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;内容大纲&lt;/span&gt;&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0562770562770563&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nwLc3LZ02UEmTL1MQn3es1VicXzOtUCkvZsHVVhyhE7xHn4syibcxmShF0ql3VV5AicdsZAaJ1XwScPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;693&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小故事&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小明（&lt;span&gt;操作系统&lt;/span&gt;）创办了一家互联网小公司，因为准备同时开发A与B两个软件，所以小明请了两个开发团队来做这件事情，分别是小王开发团队与小李开发团队，可是公司特别小，只有一个房间（&lt;span&gt;C P U&lt;/span&gt;），而且房间（&lt;span&gt;C P U&lt;/span&gt;）只能容纳一个开发团队，为了能两个软件开发不被耽误，小明（&lt;span&gt;操作系统&lt;/span&gt;）决定，上午小王团队开发，下午小李团队开发（&lt;span&gt;这个过程称为调度&lt;/span&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小李（&lt;span&gt;进程&lt;/span&gt;）与小王（&lt;span&gt;进程&lt;/span&gt;）身为团队负责人，他们要操心的事情比较多，需要对软件进行分析整理，做架构设计，最后再把任务细化分配给团队的每个开发人员（&lt;span&gt;线程&lt;/span&gt;），在团队交换房间的时候，还需要把整个软件开发进度记录下来，方便下次接着开发，相比开发人员就轻松多了，每个人只负责一小块，需要记录的也只有一小块。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这个小故事，大伙也看出来了，一个进程管理着多个线程，就像团队负责人（&lt;span&gt;进程&lt;/span&gt;）管理着多个开发人员（&lt;span&gt;线程&lt;/span&gt;）一样。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;进程&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是进程&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你打开网易云音乐会产生一个&lt;span&gt;进程&lt;/span&gt; ，你打开QQ会产生一个&lt;span&gt;进程&lt;/span&gt; ，你电脑上运行的程序都是&lt;span&gt;进程&lt;/span&gt; ，&lt;span&gt;进程&lt;/span&gt;就是这么简单暴力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们思考一个问题，有一个进程读取硬盘里的文件，这个文件特别大，需要读取很长时间，如果 &lt;span&gt;C P U&lt;/span&gt; 一直傻傻的等硬盘返回数据，那 &lt;span&gt;C P U&lt;/span&gt; 的利用率是非常低的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就像烧开水，你会傻傻等水烧开吗？很明显，这段时间完全可以去做其他的事情（比如玩玩赛博朋克2077），水烧开了再过来把水倒入水杯中，这样不香吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;C P U&lt;/span&gt; 也是一样，它发现 &lt;span&gt;进程&lt;/span&gt; 在读取硬盘文件，不需要阻塞等待硬盘返回数据，直接去执行其他&lt;span&gt;进程&lt;/span&gt; ，当硬盘返回数据时，&lt;span&gt;C P U&lt;/span&gt; 会收到 中断 的信号，于是 &lt;span&gt;C P U&lt;/span&gt; 再回到之前的 &lt;span&gt;进程&lt;/span&gt; 继续运行&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5876288659793815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nwLc3LZ02UEmTL1MQn3es1VncNvz2yvCLznMthEibVrtSXQicsu8JpD63S8W7WbLxIvRGvgWJhianZGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;679&quot;/&gt;这种多程序 &lt;span&gt;交替执行&lt;/span&gt; 的方式，就是 &lt;span&gt;C P U&lt;/span&gt; 管理多进程初步思想。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能会有人问了， &lt;span&gt;交替执行&lt;/span&gt;会不会很慢，这个不用担心，因为 &lt;span&gt;C P U&lt;/span&gt; 的执行速度与切换速度非常的快，可能就是几十或几百毫秒，超出了人类的感知，一秒钟内可能就交替运行了多个进程，所以给我们产生 &lt;span&gt;并行&lt;/span&gt; 的错觉，其实这叫&lt;span&gt;并发。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单核 &lt;span&gt;多进程交替执行&lt;/span&gt; 就是&lt;span&gt;并发&lt;/span&gt;，多进程在多核运行就是&lt;span&gt;并行。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;进程的控制结构&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创造任何东西的时候，都要先有形，才有物，你造房子、造汽车或造其他东西，都要有设计图（&lt;span&gt;结构&lt;/span&gt;），再根据设计图来创造， &lt;span&gt;进程&lt;/span&gt;也不例外，它也有属于自己的设计图，那就是 &lt;span&gt;进程控制块（process control block，PCB）&lt;/span&gt;，后面就简称 &lt;span&gt;P C B &lt;/span&gt;好了&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;P C B的结构信息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;P C B&lt;/span&gt;是&lt;span&gt; 进程 &lt;/span&gt;存在的唯一标识，这意味一个&lt;span&gt; 进程 &lt;/span&gt;一定会有对应的PCB，&lt;span&gt;进程&lt;/span&gt;消失，&lt;span&gt;P C B&lt;/span&gt;也会随之消失&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;进程描述信息&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;进程唯一的标记符，类似唯一id&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户标识符，进程归属的用户，用户标识符主要为共享和保护服务&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;进程控制和管理信息&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;进程当前状态，比如运行、就绪、阻塞等，作为处理机分配调度的依据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;进程优先级，描述进程抢占处理机的优先级，优先级高的进程可以优先获得处理机&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;资源分配清单&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用于说明有关内存地址空间或虚拟地址空间的状况，所打开文件的列表和所使用的输入/输出设备信息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;CPU 相关信息&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;指 &lt;span&gt;C P U&lt;/span&gt; 中各寄存器值，当进程被切换时，&lt;span&gt;C P U&lt;/span&gt;状态信息都必须保存在相应的 &lt;span&gt;P C B &lt;/span&gt; 中，以便进程重新执行时，能再从断点继续执行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;P C B组成的队列&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;P C B&lt;/span&gt;通过链表的方式进行组织，把具有相同状态的进程链在一起，组成各种队列&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将所有处于就绪状态的 &lt;span&gt;进程&lt;/span&gt; 链在一起，称为&lt;span&gt;就绪队列&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;把所有因等待某事件而处于等待状态的 &lt;span&gt;进程&lt;/span&gt; 链在一起就组成各种&lt;span&gt;阻塞队列&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8421926910299004&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nwLc3LZ02UEmTL1MQn3es1V7ckD4FnoFIIzK3lE48iaCMkXfibl1b6A0aV68XbdoVcGYgtetun9cOEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;602&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;进程的状态&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过观察，我们发现进程执行的过程遵循这样的 &lt;span&gt;运行-暂停-运行&lt;/span&gt; 规律，虽然看起来十分简单，但是它的背后涉及到了进程状态的转换&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;进程三态&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进程的执行期间，至少具备三种基本状态，即运行态、就绪态、阻塞态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7376425855513308&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nwLc3LZ02UEmTL1MQn3es1VW5BsJTpsiaqyC1qYRukU6fYHFKdtuJPd8Y1zx6nzClpruN4n7QJlAmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;526&quot;/&gt;上图状态的意义&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;运行态（Runing）：时刻进程占用 C P U&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;就绪态（Ready）：可运行，但因为其他进程正在运行而暂停停止&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;阻塞状态（Blocked）：该进程等待某个事件（比如IO读取）停止运行，这时，即使给它CPU控制权，它也无法运行&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图状态转换流程&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;C P U  调度绪态进程执行，进入运行状态，时间片使用完了，回到就绪态，等待 C P U 调度&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;C P U  调度绪态进程执行，进入运行状态，执行IO请求，进入阻塞态，IO请求完成，CPU收到 中断 信号，进入就绪态，等待 C P U 调度&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;进程五态&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在三态基础上，做一次细化，出现了另外两个基本状态，创建态和结束态。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.44823232323232326&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nwLc3LZ02UEmTL1MQn3es1VgKMmHhbZrcLJibwLBibkXIQ6SysNtFC6YuO3jNHiaptIqSNZOo1DCG8zA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;792&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图状态的意义&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;创建态（new）：进程正在被创建&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;就绪态（Ready）：可运行，但因为其他进程正在运行而暂停停止&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;运行态（Runing）：时刻进程占用 C P U&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;结束态（Exit）：进程正在从系统中消失时的状态&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;阻塞状态（Blocked）：该进程等待某个事件（比如IO读取）停止运行，这时，即使给它CPU控制权，它也无法运行&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;状态的变迁&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;NULL =&amp;gt; 创建态（new）：一个新进程被创建时的第一个状态&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;创建态（new） =&amp;gt; 就绪态（Ready）：当进程创建完成，进入就绪态&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;就绪态（Ready）=&amp;gt;  运行态（Runing）：C P U 从就绪队列选择进程执行，进入运行态&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;运行态（Runing）=&amp;gt; 结束态（Exit）：当进程已经运行完成或出错时，进入结束状&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;运行态（Runing） =&amp;gt; 就绪态（Ready）：分配给进程的时间片使用完，进入就绪态&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;运行态（Runing） =&amp;gt; 阻塞状态（Blocked）：进程执行等待事件，进入阻塞态&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;阻塞状态（Blocked） =&amp;gt; 就绪态（Ready）：进程事件完成，C P U 收到 中断 信号 ，进入就绪态&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;进程七态&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实进程还有一种状态叫&lt;span&gt;挂起态&lt;/span&gt;，挂起态代表该进程不会占用内存空间，它会被换出到硬盘空间保存，当需要使用它的时候，会被换入，加载到内存，挂起态可以分为下面两种&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合上述的两种挂起态，就组成了进程七态&lt;img data-ratio=&quot;0.5228174603174603&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nwLc3LZ02UEmTL1MQn3es1VZpC6PE8jw7oCAmxcWU46RaplLuGGxpfXa73sZq9szPrnKnFB8sKTZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1008&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图我们发现，创建态、就绪态、运行态，阻塞挂起态、阻塞态都可以转入&lt;span&gt;挂起态&lt;/span&gt;，这时问题就产生了，什么情况会转入&lt;span&gt; 挂起态 &lt;/span&gt;，什么情况又会从&lt;span&gt; 挂起态 &lt;/span&gt;转入到&lt;span&gt; 非挂起态（就绪态与阻塞态）&lt;/span&gt;， 操作系统会根据当前资源状况和性能要求、进程的优先级来进行挂起与激活操作，没有固定的说法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;进程的上下文切换&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;C P U&lt;/span&gt;把一个进程切换到另一个进程运行的过程，称为&lt;span&gt;进程上下文切换。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;在说进程上下文切换之前，先来聊聊 C P U 上下文切换&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;C P U上下文&lt;/span&gt; 是指 &lt;span&gt;C P U 寄存器 &lt;/span&gt;和 &lt;span&gt;程序计数器&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;C P U 寄存器 &lt;/span&gt;是 &lt;span&gt;C P U&lt;/span&gt; 内置的容量小，速度极快的缓存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;程序计数器&lt;/span&gt;是用来存储 是 &lt;span&gt;C P U&lt;/span&gt; 正在执行的指令位置或即将执行的下一条指令位置&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;C P U 上下文切换&lt;/span&gt; 就很好理解了，就是把前一个任务的 &lt;span&gt;C P U上下文&lt;/span&gt;  保存起来，然后在加载当前任务的 &lt;span&gt;C P U上下文&lt;/span&gt;，最后再跳转到 &lt;span&gt;程序计数器&lt;/span&gt; 所指的新位置，运行任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面说到所谓的「任务」，主要包含进程、线程和中断。所以，可以根据任务的不同，把 CPU 上下文切换分成：&lt;span&gt;进程上下文切换、线程上下文切换和中断上下文切换。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;进程的上下文是怎么切换的&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先进程是由内核管理与调度的，所以&lt;span&gt; 进程上下文切换&lt;/span&gt; 发生在内核态，&lt;span&gt;进程上下文切换&lt;/span&gt;的内容包含&lt;span&gt;用户空间资源（虚拟内存、栈、全局变量等）与内核空间资源（内核堆栈、寄存器等）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在做上下文切换的时候，会把前一个&lt;span&gt; 进程 &lt;/span&gt;的上下文保存到它的&lt;span&gt; P C B &lt;/span&gt;中，然后加载当前&lt;span&gt; 进程 &lt;/span&gt;的 &lt;span&gt; P C B &lt;/span&gt;上下文到 &lt;span&gt;C P U &lt;/span&gt;中，使得&lt;span&gt; 进程 &lt;/span&gt;继续执行&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48830409356725146&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nwLc3LZ02UEmTL1MQn3es1VJVnSGbOnkg6SnCzaUxgvCrfkjRxNdQEAD6CZZiaTkX3e8COPOtnxsrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;684&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发生进程上下文切换的场景&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，切换到其它正在等待 CPU 的进程运行&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;线程&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是线程&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在早期操作系统都是以&lt;span&gt; 进程 &lt;/span&gt;为独立运行的基本单位，直到后面，计算机科学家又提出了更小的能独立运行的基本单位，它就是&lt;span&gt;线程&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在现代操作系统，&lt;span&gt;进程是最小的资源分配单位，线程是最小的运行单位，一个进程下面能有一个或多个线程，每个线程都有独立一套的寄存器和栈，这样可以确保线程的控制流是相对独立的。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8981636060100167&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nwLc3LZ02UEmTL1MQn3es1V5oIJCl0mP6MAmHldRaYj9BmLddIIWmO6LA09C9FCwcIiczCl3K1Xhog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;599&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程带来的好处有以下几点&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt; 一个进程中可以同时存在多个线程&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;让进程具备多任务并行处理能力&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;同进程下的各个线程之间可以共享进程资源 （同进程内的多线程通信十分简单高效）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;更轻量与高效&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程带来的坏处有以下几点&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;因为进程资源共享，所以会产生资源竞争，需要通过锁机制来协同&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当进程中的一个线程奔溃时，会导致其所属进程的所有线程奔溃（一般游戏的用户设计不会采用多线程方式）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;线程与进程的对比&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;进程是最小的资源（包括内存、打开的文件等）分配单位，线程是最小的运行单位&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系（和进程大同小异）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程的创建、终止时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，所以线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们（线程管理的资源较少）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;线程比进程不管是时间效率，还是空间效率都要高&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;线程的上下文切换&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4886535552193646&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nwLc3LZ02UEmTL1MQn3es1VRWTqYBUgYQgrkhu3c7ZVFYPnOxdkah4zaSe3Bbk6E3x5ibd8BSpSgGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;661&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当进程只有一个线程时，可以认为进程等于线程，线程上下文的切换分两种情况&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;不同进程的线程，切换的过程就跟进程上下文切换一样&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以线程的上下文切换相比进程，开销要小很多&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;线程的模型&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在说线程模式之前，先介绍3个概念&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;内核线程：在内核空间就实现的线程，由内核管理&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;用户线程：在用户空间实现的线程，不归内核管理，是由用户态通过线程库完成线程的管理（用户态是指线程或进程在用户空间运行）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;轻量级进程：在内核中来支持用户线程（用户线程与内核线程的中间层，内核线程的高度抽象）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;内核线程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为内核线程是由内核空间管理，所以它的&lt;span&gt; 结构线程控制块（Thread Control Block, TCB）&lt;/span&gt;  在内核空间，操作系统对&lt;span&gt; T C B&lt;/span&gt; 是可见的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核线程&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6234567901234568&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nwLc3LZ02UEmTL1MQn3es1V3teHXZlRoAl63IibKgAUL6anNZZyau73Jcb31xnYeK0icMpibrffHfTfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;648&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核线程有什么优点&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;内核线程的由内核空间管理，线程的创建、销毁、调度等，都不用你操心，全自动化，属于智能型&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;内核线程能利用cpu多核的特性，实现并行执行（因为由内核管理，非常智能）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;内核线程阻塞，不会影响其他内核线程（因为由内核管理，非常智能）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核线程有什么缺点&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;因为是内核管理，所以内核线程的大部分操作都涉及到内核态，即需要从用户态切换到内核态，开销较大&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;因为内核资源有限，所以无法大量创建内核线程&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;用户线程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为&lt;span&gt; 用户线程&lt;/span&gt; 在&lt;span&gt;用户空间&lt;/span&gt;，是由&lt;span&gt; 用户态 &lt;/span&gt;通过线程库来管理，所以它的&lt;span&gt; 结构线程控制块（Thread Control Block, TCB）&lt;/span&gt; 也是在线程库里面，对于操作系统而言是看不到 &lt;span&gt;T C B&lt;/span&gt; 的，它只能看到整个进程的&lt;span&gt; P C B（内核无法管理用户线程，也感知不到用户线程）&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5865834633385335&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nwLc3LZ02UEmTL1MQn3es1VQh5OZiauXzUfJtC64VTBLq69uria2DUN7Em9AZ5FDuEdYqGH5wyoFrnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;641&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户线程有什么优点&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;因为用户线程创建、销毁、调度等都不走内核态，直接在用户态进行操作，所以速度特别快&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;不依赖内核，可用于不支持线程技术的操作系统&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;可以大量创建用户线程，不消耗内核资源&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户线程有什么缺点&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;用户线程创建、销毁、调度等需要自己实现相应线程库&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;用户线程阻塞会导致整个进程内的其他用户线程阻塞（整个进程阻塞），因为内核感知不到用户线程，所以无法去调度其他用户线程&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;无法利用cpu多核特性，还是因为内核感知不到用户线程&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;轻量级进程（Light-weight process，LWP）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;轻量级进程（Light-weight process，LWP）&lt;/span&gt;可以理解成&lt;span&gt;内核线程的高级抽象&lt;/span&gt;，一个&lt;span&gt; 进程 &lt;/span&gt;可以有一个或多个&lt;span&gt;L W P &lt;/span&gt;，因为每个 &lt;span&gt;L W P&lt;/span&gt; 与 &lt;span&gt;内核线程&lt;/span&gt; 一对一映射，所以 &lt;span&gt;L W P&lt;/span&gt; 都是由一个 &lt;span&gt;内核线程&lt;/span&gt; 支持（&lt;span&gt;用户线程关联L W P，即成为内核支持的用户线程）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在大多数系统中，&lt;span&gt;L W P&lt;/span&gt;与 &lt;span&gt;普通进程&lt;/span&gt; 的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息。一般来说，一个&lt;span&gt;进程 &lt;/span&gt;代表程序的一个实例，而 &lt;span&gt;L W P&lt;/span&gt; 代表程序的&lt;span&gt;执行线程&lt;/span&gt;，因为一个&lt;span&gt; 执行线程 &lt;/span&gt;不像进程那样需要那么多状态信息，所以 &lt;span&gt;L W P&lt;/span&gt; 也不带有这样的信息。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一对一模型（内核级线程模型）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;L W P就是一对一模型&lt;/span&gt;，即&lt;span&gt; 进程 &lt;/span&gt;只需要创建使用&lt;span&gt;L W P&lt;/span&gt; ，因为一个 &lt;span&gt;L W P &lt;/span&gt;由一个&lt;span&gt; 内核线 &lt;/span&gt;程支持，所以最终是内核管理线程，可以调度到其他处理器上（再简单点解释，直接使用&lt;span&gt;内核线程&lt;/span&gt;）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6355421686746988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nwLc3LZ02UEmTL1MQn3es1VXTNrkDDt8xcqgemQqw3aL3rsGgt85WNYFxyPmCzF0XrO4hFj4obHnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;664&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一对一模型（1:1）的优缺点就不多说了，上面介绍内核线程的时候已经说过了，但是值得一提的是，jvm采用该模型实现线程，所以在Java中启动一个线程需要谨慎&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一对多模型（用户级线程模型）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一对多模型&lt;/span&gt;，即多个用&lt;span&gt; 户级线程 &lt;/span&gt;对用到同一个 &lt;span&gt;L W P&lt;/span&gt; 上实现，因为是用户态通过用户空间的线程库对线程管理，所以&lt;span&gt;速度特别快，不会涉及到用户态与内核态的转换&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8652037617554859&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nwLc3LZ02UEmTL1MQn3es1VBjuibTV21VSoIHLfsYicJJJiaFlBnibe4dKwrtPekfYiaQUblLoJ50G0OQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;638&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一对多模型（n:1）的优点缺点体现在用户级线程上面，用户线程的优缺点前面说过，这里不做概述，值得一提的是 Python 中的协程就是通过该模型实现。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;多对多模型（两级线程模型）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;多对多模型是集各家所长诞生的产物，它充分吸收前两种线程模型的优点且尽量避免它们的缺点。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先它区别于&lt;span&gt;多对一模型&lt;/span&gt;，&lt;span&gt;多对多模型进程&lt;/span&gt;内的&lt;span&gt; 多用户线程 可以绑定不同的内核线程 ，这点与 一对一模型 类似，其次又区别于一对一模型，进程内的 多用户线程 与 内核线程 不是一对一绑定，而是动态绑定，当某个 内核线程 因绑定的 用户线程 执行阻塞操作，让出 C P U 时，绑定该 内核线程 的其他 用户线程 可以解绑，重新绑定到其他 内核线程 继续运行。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以多对多模型（m:n），即不是多对一模型完全靠自己实现的线程库调度，也不是一对一模型完全靠操作系统调度，而是一个中间态系统（负责自身调度与操作系统调度的协同工作），最后提一句Go语言使用的是多对多模型，这也是其高并发的原因，它的线程模型与Java中的ForkJoinPool非常类似。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.774468085106383&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nwLc3LZ02UEmTL1MQn3es1VIiaPYL1hgwm54HdruE0XgWiaX2ewgRDAaIrTlWZF0cWjzg6q1JvPzK9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;705&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多对多模型优点&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;兼具多对一模型的轻量&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;由于对应了多个内核线程，则一个用户线程阻塞时，其他用户线程仍然可以执行&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;由于对应了多个内核线程，则可以实现较完整的调度、优先级等；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多对多模型缺点&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;实现复杂（因为这种模型的高度复杂性，操作系统内核开发者一般不会使用，所以更多时候是作为第三方库的形式出现）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;调度&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;调度原则&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;CPU 利用率&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;运行程序发生了I/O 事件的请求，因此阻塞，导致进程在等待硬盘的数据返回。这样的过程，势必会造成 C P U 突然的空闲。所以为了提高 C P U 利用率，发生等待事件使 C P U 空闲的情况下，调度程序需要从就绪队列中选择一个进程来运行。（&lt;span&gt;PS：调度程序应确保 C P U 一直保持匆忙的状态，可提高 C P U 的利用率）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;系统吞吐量&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;程序执行某个任务花费的时间会比较长，如果这个程序一直占用着 C P U，会造成系统吞吐量的降低。所以要提高系统的吞吐率，调度程序要权衡长任务和短任务进程的运行完成数量。（&lt;span&gt;吞吐量表示的是单位时间内 C P U 完成进程的数量，长作业的进程会占用较长的 C P U 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;周转时间&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从进程开始到结束的过程中，实际上是包含两个时间，分别是进程运行时间和进程等待时间，这两个时间总和就称为周转时间。进程的周转时间越小越好，如果进程的等待时间很长，而运行时间很短，那周转时间就很长，调度程序应该避免这种情况发生。（&lt;span&gt;周转时间是进程运行和阻塞时间总和，一个进程的周转时间越小越好）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;等待时间&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;处于就绪队列的进程，也不能等太久，希望这个等待的时间越短越好，因为可以使进程更快的在 C P U 中执行。所以就绪队列中，进程的等待时间，也是调度程序所需要考虑的原则（&lt;span&gt;这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待时间越长，用户越不满意）。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;响应时间&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对于鼠标、键盘这种交互式比较强的应用，我们当然希望它的响应时间越快越好，否则就会影响用户体验了。所以，对于交互式比较强的应用，响应时间也是调度程序需要考虑的原则（&lt;span&gt; 用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准）。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总之就是 要快！&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;调度算法&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不同的算法适用不同的场景，下面介绍几个单核中常见的调度算法&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;先来先服务算法（First Come First Severd, FCFS）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;先来先服务算法&lt;/span&gt;简称&lt;span&gt; F C F S&lt;/span&gt;，顾名思义，谁先来，谁先被&lt;span&gt; C P U &lt;/span&gt;执行，后到的就乖乖排队等待，十分简单的算法，&lt;span&gt;C P U&lt;/span&gt;每次调度 &lt;span&gt;就绪队列&lt;/span&gt; 的第一个进程，直到进程退出或阻塞，&lt;span&gt;才会把该进程入队到队尾&lt;/span&gt;，然后接着继续调度第一个进程，依此类推。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5652797704447633&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nwLc3LZ02UEmTL1MQn3es1V1czfuFPuhVsq88Kfc4lWVAn6PMNwJxicYpj4PPxhUqxwX8MqYplfAEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;697&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;F C F S&lt;/span&gt;算法看似很公平，但是当一个长作业先运行了，后面的短作业等待的时间就会很长，所以不利于短作业，会降低&lt;span&gt;系统吞吐量&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;F C F S&lt;/span&gt;对长作业有利，适用于 &lt;span&gt;C P U 繁忙型作业的系统&lt;/span&gt;，而不适用于 &lt;span&gt;I/O 繁忙型作业的系统。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最短作业优先算法（Shortest Job First, SJF）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样也是顾名思义，它会优先选择&lt;span&gt;运行时间最短的进程&lt;/span&gt;，有助于提高&lt;span&gt;系统吞吐量&lt;/span&gt;。但是对&lt;span&gt;长作业不利&lt;/span&gt;，所以很容易造成一种极端现象。比如，一个 &lt;span&gt;长作业 &lt;/span&gt;在就绪队列等待运行，而这个就绪队列有&lt;span&gt;非常多的短作业&lt;/span&gt;，最终使得 &lt;span&gt;长作业 &lt;/span&gt;不断的往后推，&lt;span&gt;周转时间变长，致使长作业长期不会被运行（适用于 I/O 繁忙型作业的系统）。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2529182879377432&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nwLc3LZ02UEmTL1MQn3es1VxlGXEf0ySveCickfI3NUrxyACmXBK5X6XZwjLacNgicmQoibXsR5Q5nBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;771&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;高响应比优先算法 （Highest Response Ratio Next, HRRN）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为前面的&lt;span&gt;「先进先出算法」和「最短作业优先算法」&lt;/span&gt;都没有很好的权衡短作业和长作业，所以&lt;span&gt;高响应比优先算法主要是权衡了短作业和长作业。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次进行进程调度时，先计算&lt;span&gt;「响应比优先权」&lt;/span&gt;，然后把&lt;span&gt;「响应比优先权」&lt;/span&gt;最高的进程投入运行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3704819277108434&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nwLc3LZ02UEmTL1MQn3es1V6oDc6k2alNFjJSwk8ibNibNOeUu5Q5gHjK4jULPmp30tzHyKCiaprQUibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;664&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的公式，可以发现：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果两个进程的&lt;span&gt;「等待时间」&lt;/span&gt;相同时，&lt;span&gt;「要求的服务时间」&lt;/span&gt;越短，&lt;span&gt;「优先权」&lt;/span&gt;就越高，这样短作业的进程容易被选中运行（&lt;span&gt;如果等待时间较短，进程的运行时间越短，优先权就会越高 =&amp;gt;  等待时间较短的短作业进程）&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果两个进程&lt;span&gt;「要求的服务时间」&lt;/span&gt;相同时，&lt;span&gt;「等待时间」&lt;/span&gt;越长，&lt;span&gt;「优先权」&lt;/span&gt;就越高，这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会（&lt;span&gt;如果要求服务时间比较长，进程的等待时间越长，优先权就会越高 =&amp;gt; 等待时间较长的长作业进程）&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;时间片轮转（Round Robin, RR）算法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;时间片轮转是最古老、最简单、最公平且使用最广的算法，给每个进程分配相同时间片&lt;span&gt;（Quantum）&lt;/span&gt;，允许进程在该时间段中运行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2692867540029112&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nwLc3LZ02UEmTL1MQn3es1VOTnBlLbibWGGg22XXynNqCNClVtzE3hNGqVW8rL0R1Tp9Wg7z0sncmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;687&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果时间片用完，进程还在运行，将会把此进程放入就绪队列，并继续调度另外一个进程，依此类推&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果该进程在时间片结束前阻塞或结束，则调度另外一个进程&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;进程时间片用完，需要被重新分配时间片&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;需要注意的是，如果时间片设置的太短，会导致CPU上下文切换态频繁，太长又可能引起对短作业进程的响应时间变长，所以时间片设为 20ms~50ms 通常是一个比较合理的折中值&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最高优先级（Highest Priority First，HPF）算法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面的&lt;span&gt;「时间片轮转算法」&lt;/span&gt;让所有的进程同等重要，不偏袒谁，大家的运行时间都一样。但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，希望调度程序能从就绪队列中选择&lt;span&gt;最高优先级的进程运行&lt;/span&gt;，这就是&lt;span&gt;最高优先级（Highest Priority First，HPF）算法。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进程的优先级可以分为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;静态优先级：创建进程时候，已经确定优先级，整个运行时间优先级都不会变化&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;动态优先级：根据进程的动态变化调整优先级，比如进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则提高优先级。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有两种处理优先级高的方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但是依然有缺点，可能会导致低优先级的进程永远不会运行。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;多级反馈队列（Multilevel Feedback Queue）算法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; 多级反馈队列（Multilevel Feedback Queue）算法 &lt;/span&gt;是基于&lt;span&gt;「时间片轮转算法」和「最高优先级算法」&lt;/span&gt;演进而来，如同它的名字一样，根据优先级分组成多个队列，在算法中涉及两个概念：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;「多级」表示有多个队列，每个队列优先级从高到低，优先级越高的队列拥有的时间片越短&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;「反馈」 表示有新的进程进入优先级高的队列时，停止当前运行进程，去运行优先级高的队列&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7296296296296296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nwLc3LZ02UEmTL1MQn3es1VbvHLMNuQgr5zP9yOGPpF06ffY8LxeWNkJWSLqiaJ8DfEcZ0ibsOoDJEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;810&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作流程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;多个队列，赋予每个队列不同的优先级，每个队列优先级从高到低，同时优先级越高时间片越短&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;新进的 进程 会被放入 第一级队列 尾部，按先来先服务的原则排队等待被调度，如果第一级队列时间片用完，还有进程没有执行，把第一级队列剩余的进程 放入 第二级队列的尾部，依此类推&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当优先级高队列为空，正在运行低优先级队列的进程时，有新进程 进入 高优先级队列，这时立即停止当前运行进程，把当前进程放入 原队列 尾部，转而去 运行 高优先级队列的进程。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，&lt;span&gt;很好的兼顾了长短作业，同时有较好的响应时间。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5723fbf8b17e3f6431c96bffda8dd0b6</guid>
<title>高性能万亿级消息吞吐 Pulsar 设计原理</title>
<link>https://toutiao.io/k/q8zmevp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;高性能万亿级消息吞吐Pulsar设计原理&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、MQ 基本介绍&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1 核心概念&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Topic：消息主题，一级消息类型，生产者向其发送消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生产者：也称为消息发布者，负责生产并发送消息至 Topic。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费者：也称为消息订阅者，负责从 Topic 接收并消费消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息：生产者向 Topic 发送并最终传送给消费者的数据和（可选）属性的组合。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息属性：生产者可以为消息定义的属性，包含 Message Key 和 Tag。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Group：一类生产者或消费者，这类生产者或消费者通常生产或消费同一类消息，且消息发布或订阅的逻辑一致。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2 消息类型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;普通消息：消息队列 RocketMQ 版中无特性的消息，区别于有特性的定时/延时消息、顺序消息和事务消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务消息：实现类似 X/Open XA 的分布事务功能，以达到事务最终一致性状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;定时和延时消息：允许消息生产者对指定消息进行定时（延时）投递，最长支持 40 天。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;顺序消息：允许消息消费者按照消息发送的顺序对消息进行消费。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3 MQ应用场景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;交易系统&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;红包秒杀&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关闭未支付订单&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户信息注册&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在线抽奖设计&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;任务系统设计&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;跨私网数据交换&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;跨区域数据同步&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异步解耦&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;削峰填谷&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分布式事务消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;大数据分析&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分布式模缓存同步&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异地多活&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异步通知&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;........&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.4 MQ消息模型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.15051020408163265&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWGhegoX9q2KDZcIxtrNQX3ouUxPKbMY605Ey6G1lHicazxNVqkL2f0sA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;392&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.33433734939759036&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWFdia1rpA9FRhbhxPdAF4zAic4FaX0jYOzGibry3FlibQokiaZkoyS58gQ7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;332&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2557603686635945&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWB0al497ic32IRdQLsAjbr5ToI4L9SrWQ0IbLcjje7z4ApFsHFrC7bPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;434&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.40425531914893614&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWREQibG9nEI0xGKPEEKdCIyPwpseMUnFUHiawnK2XlibntjUEuXhictFprw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;423&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4033018867924528&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWlWk65yWQs5icWLuhbyRBe1PLL91nU4Oq1BtR8ptEyKlK2Sico9dSP4icA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;424&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3472222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWSmEs2ic0egnDYwhAicnOHzBFXFYHgAiaiaicxAz5DZ9KUfVJBDhKHGSuBeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;576&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.5 MQ产品发展路线&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3562753036437247&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWp8ib9LstburbOJ3glTdbX80L2XBmoJNn8HicLhZuyCyRHXCicnmr5Eojg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;741&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.6 MQ应用场景选型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4421168687982359&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWRhkIKSITYC7N7QYVQjKyTBGpCSaibdlyjjSqhQ8xDh1LzuIMYbJ30lQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.7 MQ云原生场景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6374695863746959&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWfhicPz3aR1QAdejY77xfribp0DfhSibvhbqIYOjdC6jZWDqh5yCicMNkAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1644&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.8 Pulsar  MQ&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 是一个用于服务器到服务器的消息系统，具有多租户、高性能等优势。Pulsar 最初由 &lt;strong&gt;Yahoo&lt;/strong&gt;开发，目前由 &lt;strong&gt;Apache&lt;/strong&gt; 软件基金会管理。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.8.1 &lt;strong&gt;Pulsar 集群包含&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一组 Broker（服务发布 - 订阅流量）&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Pulsar Broker 是负责接收和交付消息的组件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;Bookie（消息存储）&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Bookie 则是为最终消费前的消息提供持久存储的 Apache BookKeeper 服务器。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;一个负责整体协调和配置管理的 Apache ZooKeeper&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7722222222222223&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoW4apjsI79pkZSVC3uCPSp2J4NPL1IjIE5LL8tops0E9w6F80ksOFoag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1440&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.8.2 &lt;strong&gt;Pulsar 的关键特性如下：&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Pulsar 的单个实例原生支持多个集群，可&lt;strong&gt;跨机房&lt;/strong&gt;在集群间无缝地完成消息复制。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;极低的发布延迟和端到端延迟。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;可无缝扩展到超过一&lt;strong&gt;百万个 topic&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;支持多种topic 订阅模式（独占订阅、共享订阅、故障转移订阅）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过 Apache BookKeeper 提供的&lt;strong&gt;持久化消息存储机制&lt;/strong&gt;保证消息传递 。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;由轻量级的 &lt;strong&gt;serverless&lt;/strong&gt; 计算框架 &lt;strong&gt;Pulsar Functions&lt;/strong&gt; 实现流原生的数据处理。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;基于 &lt;strong&gt;Pulsar Functions&lt;/strong&gt; 的 &lt;strong&gt;serverless connector&lt;/strong&gt; 框架 &lt;strong&gt;Pulsar IO&lt;/strong&gt;使得数据更易移入、移出 Apache Pulsar。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;分层式存储&lt;/strong&gt;可在数据陈旧时，将数据从&lt;strong&gt;热存储卸载到冷/长期存储&lt;/strong&gt;（如S3、GCS）中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.8.3 pulsar 云原⽣架构&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 能够无缝扩容、延迟低、吞吐高，支持多租户和跨地域复制。最重要的是，Pulsar 存储、计算分离的架构能够完美解决 Kafka 扩缩容的问题。Pulsar producer 把消息发送给 broker，broker 通过 bookie client 写到第二层的存储 BookKeeper 上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6575052854122622&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWibbLAiauTibGCn1LOXmyv60nRBxMtaYaEr5HghSorHEAMs7dCDnTSRPjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;946&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0900735294117647&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWl38YOOJhTXEIzoAicJLib61M05Bib5Qr0xuiboVtibbu60cwPtWGyC7ibXibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;544&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5352112676056338&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWIKibncU01mNWqSOOGd3p3WdPql6FLibAMQL7ZI7vUTMD4ZIPtLwv373g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1278&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;水平扩容：能够无缝扩容到成百上千个节点。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;高吞吐：已经在 Yahoo! 的生产环境中经受了考验，支持每秒数百万条消息的发布 - 订阅（Pub-Sub）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;低延迟：在大规模的消息量下依然能够保持低延迟（小于 5 ms）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;持久化机制：Pulsar 的持久化机制构建在 Apache BookKeeper 上，实现了读写分离。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;读写分离：BookKeeper 的读写分离 IO 模型极大发挥了磁盘顺序写性能，对机械硬盘相对比较友好，单台 bookie 节点支撑的 topic 数不受限制。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、消息系统概述&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 Product 分块发送&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当启用分块(chunking) 时(&lt;code&gt;chunkingEnabled=true&lt;/code&gt;) ，如果消息大小大于允许的最大发布有效载荷大小，则 producer 将原始消息分割成分块的消息，并将它们与块状的元数据一起单独和按顺序发布到 broker&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;处理一个 producer 和一个订阅 consumer 的分块消息&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示，当生产者向主题发送一批大的分块消息和普通的非分块消息时。假设生产者发送的消息为 M1，M1 有三个分块 M1-C1，M1-C2 和 M1-C3。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个 broker 在其管理的ledger里面保存所有的三个块消息，然后以相同的顺序分发给消费者（独占/灾备模式）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;消费者将在内存缓存所有的块消息，直到收到所有的消息块&lt;/strong&gt;。&lt;strong&gt;将这些消息合并成为原始的消息M1&lt;/strong&gt;，发送给处理进程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2582025677603424&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWichwiabso6sbdsShhPUiaTTga7Vvb9Td905ccaakK0NBvPP8eqdg87SUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;701&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;多个生产者和一个生产者处理块消息&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下所示，生产者1发布的消息 M1，M1 由 M1-C1, M1-C2 和 M1-C3 三个块组成。生产者2发布的消息 M2，M2 由 M2-C1, M2-C2 和 M2-C3 三个块组成。&lt;strong&gt;这些特定消息的所有分块是顺序排列的&lt;/strong&gt;，&lt;strong&gt;但是其在 ledger 里面可能不是连续的。这种方式会给消费者带来一定的内存负担。&lt;strong&gt;因为消费者会为&lt;/strong&gt;每个大消息在内存开辟一块缓冲区&lt;/strong&gt;，以便将所有的块消息合并为原始的大消息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4356005788712012&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWJgf3INzAc74zd7Q0s6ticJJHs3J6ZvJn0a4qZdgCBzfyLL7JYkVF3zA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;691&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 Topic结构&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;topic的名称为符合良好结构的URL&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{persistent（持久）|non-persistent(非持久)}://tenant(租户)/namespace（命令空间）/topic（主题）&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;持久与非持久&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对于持久化的主题，所有的消息都会被持久化的保存到磁盘当中(如果 broker 不是单机模式，消息会被持久化到多块磁盘)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主题默认持久化类型，非持久需要指定。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非持久化的主题的数据不会被保存到磁盘里面。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;租户&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实例中的主题租户，对于Pulsar中的多租户至关重要，并且分布在集群中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;命名空间&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将相关联的 topic 作为一个组来管理，是管理 Topic 的基本单元。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;大多数对 topic 的管理都是对&lt;strong&gt;命名空间&lt;/strong&gt;的一项配置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个租户里面可以有一个或者多个命名空间。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3 消息保留和过期&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar broker默认如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;立即删除消费者已确认的&lt;em&gt;所有&lt;/em&gt;消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;以消息backlog的形式，&lt;strong&gt;持久保存&lt;/strong&gt;所有的未被确认消息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar有两个特性，让你可以覆盖上面的默认行为。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;消息&lt;strong&gt;保留&lt;/strong&gt;使您能够存储消费者已确认的消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息&lt;strong&gt;到期&lt;/strong&gt;允许为尚未确认的消息设置生存时间（TTL）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;所有消息保留和过期都在[命名空间]中管理级别。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;下图说明了这两种概念：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5455059355568117&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWTEN9lVUlhDtLIIENVK3VAMePicM01zu0bL39rlvkuYezptzHWc76wvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1769&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;图中上面的是消息存留&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;存留规则会被&lt;strong&gt;用于某namespace下所有的topic&lt;/strong&gt;，指明哪些消息会被持久存储，即使已经被确认过。没有被&lt;strong&gt;留存规则&lt;/strong&gt;覆盖的消息将会被删除。&lt;strong&gt;如果没有保留策略&lt;/strong&gt;，所有已确认的消息都将被删除&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;图中下面的是消息过期&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;有些消息即使还没有被确认，也被删除掉了。因为根据设置在namespace上的TTL，他们已经过期了。（例如，TTL为5分钟，过了十分钟消息还没被确认）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4 消息去重&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息去重保证了一条消息只能在 Pulsar 服务端被&lt;strong&gt;持久化&lt;/strong&gt;一次。消息去重是一个 Pulsar 可选的特性，它能够阻止不必要的消息重复，它保证了即使消息被消费了多次，也只会被保存一次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图展示了开启和关闭消息去重的场景：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8177014531043593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWjBfEC4Atl3xCmxrvLUqbssSTeZMxia2RIWEcibK20Via3CtXLovaV5YvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1514&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;最上面的场景中，消息去重被关闭。Producer发布消息1到一个topic，消息到达broker后，被&lt;strong&gt;持久化&lt;/strong&gt;到BookKeeper。然后producer又发送了消息1（可能因为某些重试逻辑），然后消息被接收后又持久化在BookKeeper，这意味着消息重复发生了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在第二个场景中，producer发送了消息1，消息被broker接收然后持久化，和第一个场景是一样的。当producer再次发送消息时，broker知道已经收到个消息1，所以不会再持久化消息1.&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4.1 生产者幂等&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一种可用的消息重复数据消除方法是确保每条消息&lt;em&gt;&lt;strong&gt;只生成一次***。这种方法通常称为&lt;/strong&gt;生产者幂等&lt;/em&gt;*。这种方式的缺点是，把消息去重的工作推给了应用去做。在 Pulsar 中，消息去重是在 &lt;strong&gt;broker&lt;/strong&gt;上处理的，用户不需要去修改客户端的代码。相反，你只需要通过修改配置就可以实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;命名空间级别启用去重&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ bin/pulsar-admin namespaces &lt;span&gt;set&lt;/span&gt;-deduplication \&lt;br/&gt;  public/default \&lt;br/&gt;  --&lt;span&gt;enable&lt;/span&gt; &lt;span&gt;# or just -e&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;在命名空间级别禁用去重&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ bin/pulsar-admin namespaces &lt;span&gt;set&lt;/span&gt;-deduplication \&lt;br/&gt;  public/default \&lt;br/&gt;  --&lt;span&gt;disable&lt;/span&gt; &lt;span&gt;# or just -d&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.5 消息延迟传递&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;延时消息功能允许你能够过一段时间才能消费到这条消息，而不是消息发布后，就马上可以消费到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示，说明了延时消息的实现机制：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.40312876052948254&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWUia7OP8sf6mWgV7XrMJ7ysoLTOXGFIF1fWXwg2wRstT5lDLwLHnX6oQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;831&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Broker 保存消息是不经过任何检查的。当消费者消费一条消息时，如果这条消息是延时消息，那么这条消息会被加入到&lt;code&gt;DelayedDeliveryTracker&lt;/code&gt;当中。订阅检查机制会从&lt;code&gt;DelayedDeliveryTracker&lt;/code&gt;获取到超时的消息，并交付给消费者。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3、消息系统架构设计&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;单个 Pulsar 集群&lt;/strong&gt;由以下三部分组成：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个或者多个 broker 负责处理和负载均衡 producer 发出的消息，并将这些消息分派给 consumer；将消息存储在 BookKeeper 实例中（又称 bookies）；Broker 依赖 ZooKeeper 集群处理特定的任务等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;包含一个或多个 bookie 的 BookKeeper 集群负责消息的&lt;strong&gt;持久化存储&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个Zookeeper集群，用来处理多个Pulsar集群之间的协调任务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 Pulsar 集群&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图为一个 &lt;strong&gt;Pulsar 集群&lt;/strong&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6613039796782387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWclERUmwtkqEd05WleqQBX8Yia7ECxuBE2Bqq18dInRYpDXIS2jA0l3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1181&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1.1 集群&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 集群由N个Pulsar 实例组成，包含了&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个或者多个Pulsar &lt;strong&gt;brokers&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个ZooKeeper协调器，用于集群级别的配置和协调&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一组BookKeeper的Bookies用于消息的&lt;strong&gt;持久化存储&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;集群间可以通过&lt;strong&gt;异地复制&lt;/strong&gt;进行消息同步&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1.2 元数据存储&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 使用 &lt;strong&gt;Zookeeper&lt;/strong&gt; 存储元数据, 集群配置和协调信息。包含了：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;配置与仲裁存储&lt;/strong&gt;: 存储租户，命名域和其他需要全局一致的配置项&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个集群有自己独立的&lt;strong&gt;ZooKeeper&lt;/strong&gt;保存集群内部配置和协调信息，例如归属信息，broker负载报告，BookKeeper ledger信息（这个是BookKeeper本身所依赖的）等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1.3  brokers持久化存储&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;bookies特征适合Pulsar的应用场景&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为按条目复制的顺序数据提供了非常高效的存储。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;保证了多系统挂掉时ledgers的读取一致性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供不同的Bookies之间均匀的IO分布的特性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Bookies被设计成可以承载数千的并发读写的ledgers&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用多个磁盘设备，一个用于日志，另一个用于存储，这样Bookies可以将读操作的影响和对于写操作的延迟分隔开&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5913410770855333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWatlMiaaAXr9bGJRmZTSAdLfX7rDE2HXHQPTvHny3uD7dlXcnypTmKcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;947&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 Pulsar服务发现机制&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;客户端&lt;/strong&gt;能够使用单个 URL 与整个 Pulsar 实例进行通信。Pulsar内部提供了服务发现的机制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面这张图展示了Pulsar服务发现机制：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1021159153633855&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoW3BXQJNZdq1qXR4pialn3ib73XLexXdVGqHyVCyolRx6FQjN28icvsJSKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1087&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4、高吞吐量设计&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1 分区主题提升高吞吐&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;普通主题仅仅保存单个 broker中，&lt;strong&gt;这限制了主题的最大吞吐量&lt;/strong&gt;。&lt;strong&gt;分区主题是一种特殊类型的主题，由多个代理处理&lt;/strong&gt;，因此允许更高的吞吐量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;分区主题&lt;/strong&gt;实际是通过在&lt;strong&gt;底层拥有 N 个内部主题来实现&lt;/strong&gt;，这个 N 的数量就是等于分区的数量。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当向分区的topic发送消息，每条消息被路由到其中一个broker。Pulsar自动处理跨broker的分区分布。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.3972194637537239&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWEyzFu1MLfibIyMPh5DE5aGibvWSSmDPz7CeHticO4fCPuts9qhXMkbb8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1007&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图：Topic1主题有五个分区（P0到P4）被分成三个代理。因为分区多于broker数量，其中有两个broker要处理两个分区。第三个broker则只处理一个（分区的分布是Pulsar自动处理的）。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;这个topic的消息被广播给两个consumer。&lt;/p&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;发送模式&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;RoundRobinPartition&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;strong&gt;如果消息没有指定 key&lt;/strong&gt;，为了达到最大吞吐量，消息会以 round-robin 方式被路由所有分区。请注意round-robin并不是作用于每条单独的消息，而是作用于延迟处理的批次边界，以确保批处理有效。如果为消息指定了key，发往分区的消息会被分区生产者根据 key 做 hash，然后分散到对应的分区上。这是默认的模式。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;SinglePartition&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;strong&gt;如果消息没有指定 key&lt;/strong&gt;，生产者将会随机选择一个分区，并发送所有消息。&lt;strong&gt;如果为消息指定了key&lt;/strong&gt;，发往分区的消息会被分区生产者根据 key 做 hash，然后分散到对应的分区上。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;CustomPartition&lt;/code&gt;&lt;/td&gt;&lt;td&gt;使用自定义消息路由，可以定制消息如何进入特定的分区。可以使用 Java client 或实现MessageRouter 接口来实现自定义的路由模式。&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;分区topic和普通topic，对于订阅模式如何工作，没有任何不同&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;订阅模式&lt;/strong&gt;确定消息应传递给哪个消费者&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;路由模式&lt;/strong&gt;决定消息应该发送到哪个内部主题&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;备注：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;路由和订阅模式可以分开制定。吞吐能力的要求，决定了分区/路由的方式。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;分区只决定生产者的消息到消费者处理及确认消息过程中发生的事情。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;非持久性消息&lt;/strong&gt;传递通常比持久性消息传递快，因为&lt;strong&gt;代理不会持久化消息&lt;/strong&gt;，一旦消息传递到连接的代理，就会立即将ack发送回生产者。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5、跨机房复制&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 支持在不同的地理位置生产和消费消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，应用程序在某一地区或市场中发布数据，但需要在其他地区或市场处理和消费数据。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.1 跨域复制是怎样工作的&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 在不同集群之间跨地域复制的过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4922425952045134&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWDpLe34WNBheEicbYwzhAU5TUvFiaH19VxXvwFxxHWVpOfxstjq34Fp3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;709&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在这个图中，每当P1、P2和P3生产者将消息分别发布到Cluster-A、Cluster-B和Cluster-C集群上的T1主题时，这些消息会立即在集群之间复制。一旦消息被复制，C1和C2消费者就可以从各自的集群中使用这些消息。如果没有地理复制，C1和C2使用者将无法使用P3生产者发布的消息&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在Pulsar中基于每个租户启用&lt;strong&gt;地理复制&lt;/strong&gt;， 跨域复制是在命名空间级别管理的&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.2 本地存储和转发&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当消息发送到 Pulsar 的主题中，消息&lt;strong&gt;首先会被存储在本地的集群&lt;/strong&gt;，然后&lt;strong&gt;再被异步转发到远程集群&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在正常情况下，消息会被立即复制，并同时分发给本地的消费者。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;应用程序可以在任何集群中创建生产者和消费者，可在 Pulsar 实例中的任意一个集群生产消息和消费消息。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;订阅不仅可本地集群订阅，启用&lt;strong&gt;复制订阅&lt;/strong&gt;后在集群之间传输。&lt;strong&gt;一旦启用订阅复制，你能够保持同步的订阅状态。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;主题能够异步的跨多个地域进行复制。如果发生故障，消费者能够在其他的集群从这个失败的点重新消费消息。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图： &lt;strong&gt;T1&lt;/strong&gt;主题在&lt;strong&gt;Cluster-A&lt;/strong&gt;、&lt;strong&gt;Cluster-B&lt;/strong&gt;和&lt;strong&gt;Cluster-C&lt;/strong&gt;三个集群之间复制。这三个集群中的任何一个集群生成的所有消息都交付给其他集群中的所有订阅。在这种情况下，&lt;strong&gt;C1&lt;/strong&gt;和&lt;strong&gt;C2&lt;/strong&gt;消费者接收&lt;strong&gt;P1&lt;/strong&gt;、&lt;strong&gt;P2&lt;/strong&gt;和&lt;strong&gt;P3&lt;/strong&gt;生产者发布的所有消息。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.3 主题跨域复制&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命名空间级别创建了跨域复制，任何生产者或者消费者在这个命名空间创建的主题都会被复制到所有的集群中。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.3.1 选择性复制&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认消息被复制到命名空间配置的&lt;strong&gt;所有集群&lt;/strong&gt; ，可以通过为&lt;strong&gt;消息指定需要复制的目标集群列表&lt;/strong&gt;，来选择性地复制数据到目标集群&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构建&lt;strong&gt;Message&lt;/strong&gt;对象可以使用&lt;code&gt;setReplicationClusters&lt;/code&gt; 方法来指定目标集群:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//限制复制集群&lt;/span&gt;&lt;br/&gt;List&amp;lt;String&amp;gt; restrictReplicationTo = Arrays.asList(&lt;br/&gt;        &lt;span&gt;&quot;us-west&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;us-east&quot;&lt;/span&gt;&lt;br/&gt;);&lt;br/&gt;&lt;span&gt;//生产者&lt;/span&gt;&lt;br/&gt;Producer producer = client.newProducer()&lt;br/&gt;        .topic(&lt;span&gt;&quot;some-topic&quot;&lt;/span&gt;)&lt;br/&gt;        .create();&lt;br/&gt;&lt;span&gt;//发送消息&lt;/span&gt;&lt;br/&gt;producer.newMessage()&lt;br/&gt;        .value(&lt;span&gt;&quot;my-payload&quot;&lt;/span&gt;.getBytes())&lt;br/&gt;        .setReplicationClusters(restrictReplicationTo)&lt;br/&gt;        .send();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.4 复制订阅&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 支持&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;复制订阅关系&lt;/strong&gt;，所以能够在不到1秒的时间内，在不同集群间保持订阅状态的同步。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;主题的上下文信息&lt;/strong&gt;也能在跨多个物理地域间进行异步复制。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果发生故障，消费者重启后能够在其他的集群从这个消费失败的点开始消费。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.4.1 启用复制订阅&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认禁用复制订阅，创建使用者时可启动。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//创建消费者&lt;/span&gt;&lt;br/&gt;Consumer&amp;lt;String&amp;gt; consumer = client.newConsumer(Schema.STRING)&lt;br/&gt;            .topic(&lt;span&gt;&quot;my-topic&quot;&lt;/span&gt;)&lt;span&gt;//主题&lt;/span&gt;&lt;br/&gt;            .subscriptionName(&lt;span&gt;&quot;my-subscription&quot;&lt;/span&gt;)&lt;span&gt;//订阅名&lt;/span&gt;&lt;br/&gt;            .replicateSubscriptionState(&lt;span&gt;true&lt;/span&gt;)&lt;span&gt;//启用复制订阅&lt;/span&gt;&lt;br/&gt;            .subscribe();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6、多租户&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 的多租户能力按照设计可满足下列需求：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;确保严苛的 SLA 可顺利满足&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;保证不同租户之间的隔离&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;针对资源利用率强制实施配额&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供每租户和系统级的安全性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;确保低成本运维以及尽可能简单的管理&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Apache Pulsar 通过下列方式满足了上述需求：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过为每个租户进行身份验证、授权和 ACL（访问控制列表）获得所需安全性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为每个租户强制实施&lt;strong&gt;存储配额&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;以策略的方式定义所有隔离机制，策略可在运行过程中更改，借此降低运维成本并简化管理工作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.1 命名空间&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;命名空间是租户内部逻辑上的命名术语&lt;/strong&gt;。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;例如，包含多个应用程序的租户可以为每个应用程序创建单独的命名空间。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Namespace使得程序可以&lt;strong&gt;以层级的方式创建和管理主题&lt;/strong&gt; Topic 为&lt;code&gt;my-tenant/app1&lt;/code&gt; ，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;它的namespace是&lt;code&gt;app1&lt;/code&gt;这个应用，对应的租户是 &lt;code&gt;my-tenant&lt;/code&gt;，可以在namespace下创建任意数量的topic&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 从设计之初就可以支持多租户。因此&lt;strong&gt;主题可按照与多租户有关的两个资源进行组织&lt;/strong&gt;：资产（Property）和名称空间（Namespace）。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;资产&lt;/strong&gt;代表系统中的&lt;strong&gt;租户&lt;/strong&gt;，&lt;strong&gt;租户&lt;/strong&gt;可以在自己的资产内&lt;strong&gt;配置多个名称空间&lt;/strong&gt;，每个&lt;strong&gt;名称空间&lt;/strong&gt;可包含&lt;strong&gt;任意数量个主题&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;名称空间&lt;/strong&gt;是 Pulsar 中每个租户&lt;strong&gt;最基本的管理单位&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可针对名称空间设置 ACL&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调整副本数目设置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;管理跨集群的消息数据多地域复制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;控制消息的过期&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;.....&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**如下图：**一个 Pulsar 部署中包含了三个相互独立的租户&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.51875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoW1UE41Q9mtp4nN8rYWdmUHK3CvpiaXibLRaZlewyhdl3TkSgv9W6yRUQQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.2 订阅&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;订阅是命名好的配置规则，指导消息如何投递给消费者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图：Pulsar4种订阅模型关系&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7336561743341404&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWeQ2wlgT9dJibNpZMjicjtCKPnACvAV6S3lfrCxPCLIp7hYV2S1skMxCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1652&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;消费者如使用传统的”&lt;strong&gt;发布-订阅消息&lt;/strong&gt;“，可以&lt;strong&gt;为每个消费者&lt;/strong&gt;指定一个特定的订阅名称， 这就是&lt;strong&gt;独占模式&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;消费者实现”&lt;strong&gt;消息队列&lt;/strong&gt;“的效果，则&lt;strong&gt;多个消费者会拥有相同的订阅名称&lt;/strong&gt;(如&lt;strong&gt;灾备模式，共享模式&lt;/strong&gt;，&lt;strong&gt;key共享模式&lt;/strong&gt;)。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.2.1 &lt;strong&gt;独占模式&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只允许单个使用者附加到订阅。如果多个使用者使用相同的订阅订阅订阅主题，则会发生错误。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在下图中，仅允许使用者A-0使用消息&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34543391945547364&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoW86xpR0Tgebg5ADeotzIUQ1eaSl1zzSFqIibERzxRIGYhfKla7jcmCSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1763&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.2.2 Failover（灾备）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;故障转移模式下，多个消费者可以附加到同一订阅，主消费者消费非分区主题或者分区主题中的每个分区的消息，当主消费者断开连接时，所有（未确认和后续的）消息都会传递给队列中的下一个消费者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在下图中，Consumer-B-0是主Consumer，而Consumer-B-1是在Consumer-B-0断开连接时接收消息的下一个Consumer。&lt;img data-ratio=&quot;0.3811684628474192&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWfQrG3JsOGBfHJicVl43nRSe2fzk7SmDXTv5DBDjBMetWRy6XnJOfPag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1763&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;备注：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;分区主题&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Broker按照&lt;strong&gt;消费者优先级&lt;/strong&gt;和&lt;strong&gt;消费者名称词汇表顺序&lt;/strong&gt;对消费者进行排序。然后将主题均匀的分配给优先级最高的消费者。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;非分区主题&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;broker 会根据消费者订阅非分区主题的顺序选择消费者。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.2.3 Shared（共享）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;strong&gt;共享&lt;/strong&gt;或&lt;strong&gt;循环模式&lt;/strong&gt;下，多个使用者可以附加到同一订阅。消息通过&lt;strong&gt;round robin轮询机制&lt;/strong&gt;分发给不同的消费者，&lt;strong&gt;并且每个消息仅会被分发给一个消费者&lt;/strong&gt;。当消费者断开连接，所有被发送给他，但没有被确认的消息将被重新安排，分发给其它存活的消费者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在下图中，Consumer-C-1和Consumer-C-2可以订阅主题，Consumer-C-3和其他也可以订阅。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.417607223476298&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWD6dKJlicLfdCLaicSAycZYDBwKWVvreGzYzwnnia1FDXrbmUsxsj4PYicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1772&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;共享模式的限制，不保证消息顺序，不能在共享模式下使用累积确认。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.2.4 Key_Shared（键共享）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;strong&gt;键共享模式&lt;/strong&gt;下，多个使用者可以附加到同一订阅。消息以分发方式在消费者之间传递，并且具有相同密钥或相同排序密钥的消息只传递给一个消费者。无论消息被重新传递多少次，它都被传递给同一个消费者。当用户连接或断开连接时，将导致服务用户更改消息的某些键。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4330175913396482&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWfvXLwmZxB0bIeHM154oU5NAia8g8PeeiaW6GTuqtNXNTwMJnJtZkzyVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1478&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;键共享模式的限制，需要为消息指定键 或 orderingKey。不能在键共享模式下使用累积确认。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;可以在 &lt;code&gt;broker.config&lt;/code&gt; 中禁用 Key_Shared 模式。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.3 Pulsar 实现多租户的机制&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**核心手段为：**限制，为不同的租户设置权利范围 ，例如：身份验证和授权实现安全隔离，通过流控制、限流调节和存储配额实现共享物理资源的隔离，以及 通过 放置策略实现物理资源的隔离&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;安全性&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;授权是在资产层面上管理，权限是在命名空间的层面上管理，也就是在资产内部管理。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;身份验证和授权实现了租户间的隔离，租户无法访问自己无权访问的主题或执行无权限的操作。通过插接式（Pluggable）的身份验证和授权机制实现的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;隔离&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;隔离满足安全方面的需求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多租户应用程序还需要满足 SLA 的要求，为此 Pulsar 还针对健壮性和性能进行了隔离。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;例如：将某租户隔离在提供服务的某个 Broker 子网内部，并使用 BookKeeper bookie 实现存储隔离。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;例如：&lt;strong&gt;磁盘配额&lt;/strong&gt;、&lt;strong&gt;流控制&lt;/strong&gt;、&lt;strong&gt;限流调节&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;软隔离&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;硬隔离&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7、层级存储&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar的面向segment的架构允许主题积压增长非常大，有效地没有限制。然而，随着时间的推移，这可能会变得昂贵，有一个降低消耗的办法，那就是使用分层存储（&lt;strong&gt;Tiered Storage&lt;/strong&gt;） 通过分层存储，在 backlog 中的旧消息可以从 BookKeeper 转移到更廉价的存储中，不出其他问题，客户端将仍然可以访问 backlog。&lt;img data-ratio=&quot;0.627927927927928&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWNtQWgwlXe4EHVT5OwRbnT9JN8NeugflzQleSdXTCzkwG8icY2PqavWw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1110&quot;/&gt;默认情况下写入到 BookKeeper 的数据会复制三个物理机副本。但是，一旦一个 segment 被BookKeep 封存（sealed），该 segment 就变得不可改变，此时就可以复制到长期存储中去了。长期存储可以达到节省存储费用的目的。通过使用 &lt;strong&gt;Reed-Solomon error correction&lt;/strong&gt;机制，还可减少物理备份数量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 当前支持 S3, Google Cloud Storage (GCS) 和文件系统来做长期存储&lt;strong&gt;long term store&lt;/strong&gt;可以通过 REST API 或者命令行接口，将数据卸载（Offloading）到长期存储中。用户传入他们想要保留在 BookKeeper 上的 topic 数据总量，Broker 将复制所有 backlog 数据到长期存储。在 BookKeeper 上的原始数据将会被删除（延迟可配，默认4小时）。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2e0c195f8dda7459b465b7f1f41fe3f5</guid>
<title>高并发、高性能、高可用系统设计经验</title>
<link>https://toutiao.io/k/ybiw04u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;知识分享，以技会友。大家好，我是Tom哥。阅读本文大约需要 15 分钟。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;软件开发通常会提到一个名词 “三高”，即高并发、高性能、高可用。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;具体的指标定义，如：高并发方面要求QPS 大于 10万；高性能方面要求请求延迟小于 100 ms；高可用方面要高于 99.99%。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;接下来，我们重点来介绍这 三高&lt;/code&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;高并发&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们使用 QPS（Queries Per Second，每秒查询率）来衡量系统承载能力。&lt;/span&gt;&lt;strong&gt;架构策略有哪些？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、负载均衡&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;正所谓双拳难敌四手，高并发撑场面的首选方案就是集群化部署，一台服务器承载的QPS有限，多台服务器叠加效果就不一样了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如何将流量转发到服务器集群，这里面就要用到负载均衡，比如：LVS 和 Nginx。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;常用的负载算法有轮询法、随机法、源地址哈希法、加权轮询法、加权随机法、最小连接数法等&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;业务实战：对于千万级流量的秒杀业务，一台LVS扛不住流量洪峰，通常需要 10 台左右，其上面用DDNS（Dynamic DNS）做域名解析负载均衡。搭配高性能网卡，单台LVS能够提供百万以上并发能力。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;注意， LVS 负责网络四层协议转发，无法按 HTTP 协议中的请求路径做负载均衡，所以还需要 Nginx&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、池化技术&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;复用单个连接无法承载高并发，如果每次请求都新建连接、关闭连接，考虑到TCP的三次握手、四次挥手，有时间开销浪费。池化技术的核心是资源的“预分配”和“循环使用”，常用的池化技术有线程池、进程池、对象池、内存池、连接池、协程池。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;连接池的几个重要参数：最小连接数、空闲连接数、最大连接数&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Linux 内核中是以&lt;strong&gt;进程&lt;/strong&gt;为单元来调度资源的，线程也是轻量级进程。所以说，进程、线程都是由内核来创建并调度。协程是由应用程序创建出来的任务执行单元，比如 Go 语言中的协程“goroutine”。&lt;strong&gt;协程本身是运行在线程上，由应用程序自己调度，它是比线程更轻量的执行单元。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 Go 语言中，一个协程初始内存空间是 2KB（Linux 下线程栈大小默认是 8MB），相比线程和进程来说要小很多。协程的创建和销毁完全是在用户态执行的，不涉及用户态和内核态的切换。另外，协程完全由应用程序在用户态下调用，不涉及内核态的上下文切换。协程切换时由于不需要处理线程状态，需要保存的上下文也很少，速度很快。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Go语言中协程池的实现方法有两种：抢占式和调度式。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;抢占式协程池，所有任务存放到一个共享的 channel 中，多个协程同时去消费 channel 中的任务，存在锁竞争。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;调度式协程池，每个协程都有自己的 channel，每个协程只消费自己的 channel。下发任务的时候，采用负载均衡算法选择合适的协程来执行任务。比如选择排队中任务最少的协程，或者简单轮询。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、流量漏斗&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;上面讲的是正向方式提升系统QPS，我们也可以逆向思维，做减法，拦截非法请求，将核心能力留给正常业务！&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;互联网高并发流量并不都是纯净的，也有很多恶意流量（比如黑客攻击、恶意爬虫、黄牛、秒杀器等），我们需要设计流量拦截器，将那些非法的、无资格的、优先级低的流量过滤掉，减轻系统的并发压力。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;拦截器分层：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;网关和 WAF（Web Application Firewall，Web 应用防火墙）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;采用封禁攻击者来源 IP、拒绝带有非法参数的请求、按来源 IP 限流、按用户 ID 限流等方法&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;风控分析。借助大数据能力分析订单等历史业务数据，对同ip多个账号下单、或者下单后支付时间过快等行为有效识别，并给账号打标记，提供给业务团队使用。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;下游的每个tomcat实例应用本地内存缓存化，将一些库存存储在本地一份，做前置校验。当然，为了尽量保持数据的一致性，有定时任务，从 Redis 中定时拉取最新的库存数据，并更新到本地内存缓存中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;高性能&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;性能直接影响用户的感官体验，访问一个系统，如果超过5秒没有响应，绝大数用户会选择离开。&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么有哪些因素会影响系统的性能呢？&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;用户网络环境&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;请求/响应的数据包大小&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;业务系统 CPU、内存、磁盘等性能&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;业务链路的长度&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;下游系统的性能&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;算法实现是否高效&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;当然，随着并发数的提升，系统压力增大，平均请求延迟也会增大。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、高性能缓存&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对一些热点数据每次都从 DB 中读取，会给 DB 带来较大的压力，导致性能大幅下降。所以，我们需要用缓存来提升热点数据的访问性能，比如将活动信息数据在浏览器的缓存中保存一段时间。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;缓存根据性能由高到低分为：寄存器、L1缓存、L2缓存、L3缓存、本地内存、分布式缓存&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上层的寄存器、L1 缓存、L2 缓存是位于 CPU 核内的高速缓存，访问延迟通常在 10 纳秒以下。L3 缓存是位于 CPU 核外部但在芯片内部的共享高速缓存，访问延迟通常在十纳秒左右。高速缓存具有成本高、容量小的特点，容量最大的 L3 缓存通常也只有几十MB。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本地内存是计算机内的主存储器，相比 CPU 芯片内部的高速缓存，内存的成本要低很多，容量通常是 GB 级别，访问延迟通常在几十到几百纳秒。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;内存和高速缓存都属于掉电易失的存储器，如果机器断电了，这类存储器中的数据就丢失了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;特别说明：在使用缓存时，要注意缓存穿透、缓存雪崩、缓存热点问题、缓存数据一致性问题。当然为了提升整体性能通常会采用多级缓存组合方案（浏览器缓存+服务端本地内存缓存+服务端网络内存缓存）&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、日志优化，避免IO瓶颈&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当系统处理大量磁盘 IO 操作的时候，由于 CPU 和内存的速度远高于磁盘，可能导致 CPU 耗费太多时间等待磁盘返回处理的结果。对于这部分 CPU 在 IO 上的开销，我们称为 “iowait”。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在IO中断过程中，如果此时有其他任务线程可调度，系统会直接调度其他线程，这样 CPU 就相应显示为 Usr 或 Sys；但是如果此时系统较空闲，无其他任务可以调度，CPU 就会显示为 iowait（实际上与 idle 无本质区别）。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;磁盘有个性能指标：IOPS，即每秒读写次数，性能较好的固态硬盘，IOPS 大概在 3 万左右。对于秒杀系统，如果单节点QPS在10万，每次请求产生3条日志，那么日志的写入QPS在 30W/s，磁盘根本扛不住。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Linux 有一种特殊的文件系统：tmpfs（临时文件系统），它是一种基于内存的文件系统，由操作系统管理。当我们写磁盘的时候实际是写到内存中，当日志文件达到我们的设置阈值，操作系统会将日志写到磁盘中，并将tmpfs中的日志文件删除。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;这种批量化、顺序写，大大提升了磁盘的吞吐性能！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;高可用&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;高可用指标是指用来衡量一个系统可用性有多高。&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;MTBF（Mean Time Between Failure），系统可用时长&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;MTTR（Mean Time To Repair），系统从故障后到恢复正常所耗费的时间&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;SLA（Service-Level Agreement），服务等级协议，用于评估服务可用性等级。计算公式是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;MTBF/(MTBF+MTTR)&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;一般我们所说的可用性高于 99.99%，是指 SLA 高于 99.99%。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;技术架构，高可用有哪些策略？&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;多云架构、异地多活、异地备份&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;主备切换，如redis缓存、mysql数据库，主备节点会实时数据同步、备份。如果主节点不可用，自动切换到备用节点&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;微服务，无状态化架构，业务集群化部署，有心跳检测，能最短时间检测到不可用的服务。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过熔断、限流，解决流量过载问题，提供过载保护&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;重视web安全，解决攻击和XSS问题&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、主备切换，缩减故障时间&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当系统出现故障时，首要任务不是立马查找原因，考虑到故障的复杂样，定位排查要花些时间，等问题修复好，SLA也降了好几个档。有没有更快的方式解决这个问题？&lt;strong&gt;那就是故障转移。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当发现故障节点的时候，不是尝试修复它，而是立即把它隔离，同时将流量转移到正常节点上。这样通过故障转移，不仅减少了 MTTR 提升了 SLA，还为修复故障节点赢得了足够的时间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;主备切换大致分为三步：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一步故障自动侦测（Auto-detect），采用健康检查、心跳等技术手段自动侦测故障节点；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二步自动转移（FailOver），当侦测到故障节点后，采用摘除流量、脱离集群等方式隔离故障节点，将流量转移到正常节点；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第三步自动恢复（FailBack），当故障节点恢复正常后，自动将其加入集群中，确保集群资源与故障前一致。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、熔断，提供过载保护&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所谓过载保护，是指负载超过系统的承载能力时，系统会自动采取保护措施，确保自身不被压垮。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;熔断就是在系统濒临崩溃的时候，立即中断服务，从而保障系统稳定避免崩溃。它类似于电器中的“保险丝”，当电流过大的时候，“保险丝”会先被烧掉，断开电流，以免电路过热烧毁电器引起火灾。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;例子：熔断触发条件往往跟系统节点的承载能力和服务质量有关，比如 CPU 的使用率超过 90%，请求错误率超过 5%，请求延迟超过 500ms， 它们中的任意一个满足条件就会出现熔断。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、限流，提供过载保护&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;限流的原理跟熔断有点类似，都是通过判断某个条件来确定是否执行某个策略。但是又有所区别，熔断触发过载保护，该节点会暂停服务，直到恢复。限流，则是只处理自己能力范围之内的请求，超量的请求会被限流。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;限流算法主要有：计数器限流、滑动窗口限流、令牌桶限流、漏桶限流。网上的资料很多，这里就不多赘述。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4、降级&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;比如电商大促，业务在峰值时刻，系统抵挡不住全部的流量时，系统的负载、CPU 的使用率都超过了预警水位，可以对一些&lt;strong&gt;非核心的功能进行降级&lt;/strong&gt;，降低系统压力，比如把&lt;/span&gt;&lt;code&gt;&lt;span&gt;商品评价&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;成交记录&lt;/span&gt;&lt;/code&gt;&lt;span&gt;等功能临时关掉。&lt;/span&gt;&lt;code&gt;&lt;span&gt;弃车保帅&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，&lt;strong&gt;保证 创建订单、支付 等核心功能的正常使用&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然不同业务、不同公司处理方式也各不相同，需要结合实际场景，和业务方一块讨论，最后达成一个统一认可的降级方案。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;总结下来：降级是通过暂时关闭某些非核心服务或者组件从而保护核心系统的可用性。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>