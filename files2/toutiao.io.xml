<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>98fc339401f7041c58866c5a9d90ea30</guid>
<title>代码评审的三怕</title>
<link>https://toutiao.io/k/6vqtaxt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left&quot; aria-describedby=&quot;js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUzNjAxODg4MQ==&amp;amp;action=getalbum&amp;amp;album_id=2042396491880677377#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;2042396491880677377&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#职场经验&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;2个&lt;span class=&quot;weui-hidden_abs&quot;&gt;内容&lt;/span&gt;&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;评审代码的流程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;我自己总结的评审代码的流程，仅供参考：&lt;br/&gt;&lt;/section&gt;&lt;p&gt;1&amp;gt;&lt;span&gt;确认代码的修改范围&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;2&amp;gt;梳理修改的部分的处理流程，之前没有流程图，需要先画流程图&lt;/p&gt;&lt;p&gt;3&amp;gt;进行逻辑正确性评审&lt;/p&gt;&lt;p&gt;4&amp;gt;对照代码规范和评审checklist进行规范性评审&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;三怕&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;一怕依赖版本更新&lt;/p&gt;&lt;p&gt;二怕检查出来的问题太多&lt;/p&gt;&lt;p&gt;三怕随手优化&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;依赖版本更新&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;依赖版本更新又分为两种，一种是二方库更新，另外一种是三方库更新。名词解释下：&lt;/p&gt;&lt;p&gt;一方库：本工程内部子项目模块依赖的库(jar包)；&lt;/p&gt;&lt;p&gt;二方库：公司内部发布到中央仓库，可供公司内部其他应用依赖的库(jar包)；&lt;/p&gt;&lt;p&gt;三方库：公司之外的开源库(jar包)。&lt;/p&gt;&lt;p&gt;二方库更新，一般来说，由于是公司内部的，有任何变更需要涉及方更新时都会通知，实际的改动量不会特别多。这时候升级前需要做版本比对，确认所有的修改处，尤其要注意：&lt;span&gt;枚举&lt;/span&gt;&lt;span&gt;值&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;顺序&lt;/span&gt;&lt;span&gt;、方法的顺序是否有变换；&lt;/span&gt;&lt;span&gt;方法是否有重载&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;之前发生过由于在枚举值中间添加了新的枚举造成的故障。这和序列化和反序列化的实现有关。我之前的文章《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484928&amp;amp;idx=1&amp;amp;sn=dc3ce3b2f4c76cb712d384843e241cc8&amp;amp;chksm=fafdecaecd8a65b83f622d170c5ebd328c7b8071a935a19c768e9ebe8632db20588f0fb6d9f2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;JAVA数据处理的常用技术&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;JAVA数据处理的常用技术&lt;/a&gt;》里有提到&lt;span&gt;protostuff&lt;/span&gt;这样的序列化方式之所以更省空间，是因为把原本的方法名比如thisIsMethod1做了编号，比如标记为1，代码这是第一个方法。而不是原本的名字。如果升级版本，比如&lt;span&gt;this&lt;/span&gt;&lt;span&gt;Is&lt;/span&gt;&lt;span&gt;Method1&lt;/span&gt;和&lt;span&gt;this&lt;/span&gt;&lt;span&gt;Is&lt;/span&gt;&lt;span&gt;Method2之间加了一个thisIsNew&lt;span&gt;Method&lt;/span&gt;。原本编号为:1,:2的实际上变成了:1,:3,:2。而序列化版本号没有同步更新，解析时会认为是:1,:2,:3，这时候会造成解析错误。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;如果觉得上面我说的不够清楚，可以这么来理解：有压缩功能的二进制算法都是有代价的，代价就是需要遵循一定规则，升级很可能会打破这个规则，造成错误。&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span/&gt;三方库更新，通常由于漏洞会被要求升级，比如fastjson。对这类问题，首先明确这个jar引入解决的问题，针对这些功能做回归；第二，一个团队有多个应用的话，非核心应用先升级；第三，跟随策略，对于重要的服务，先等其他团队升级线上运行一段时间没有发现问题再升级；第四，尽量拉长灰度周期，避免小概率逻辑暂时没有验证到。&lt;/p&gt;&lt;p&gt;从上面二方库和三方库的升级方法来看，二者的升级都需要不小的工作量，作为代码评审的人要对结果负责。所以工作不仅是评审代码，还要确保上面需要的工作都做到位了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;检查出来的问题太多&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;很多编程人员可能都有这样的感受：在第一遍进行编码的时候，每一步会考虑的很周全细致。但是编写完成后一旦涉及到修改，可能就会改不全。最冤枉的是原来的代码本来问题也不大，只是风格不符合代码评审人员的习惯。结果评审人员非要编码人员改了，结果没改全出现了问题。虽然有一些手段进行规避，比如单元测试。但是修改的代价还是很高。&lt;/section&gt;&lt;section&gt;我在进行代码评审的时候，第一件事是确认代码编写人员的修改范围，看看这个修改范围我之前有没有对逻辑做细致的梳理。如果没有梳理过，那我先梳理一遍，照着梳理的内容进行评审。代码风格的问题我会给出建议，但不会为此卡着不允许合入。毕竟为了避免程序出现逻辑问题，我每次把别人的代码打回去，下次提交我要照着梳理的逻辑整体全部重新评审一遍，避免疏漏。&lt;/section&gt;&lt;section&gt;实际工作中概率统计：&lt;/section&gt;&lt;section&gt;一个流程任务的执行。如果被检查出来的错误太多，说明有两点都做的不好：1&amp;gt;流程本身就有漏洞，没有标准化；2&amp;gt;执行者无脑或者缺脑的在执行。这样，检查人员要无限制的去做兜底。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;对于写代码来说，如果代码写的漏洞百出，那说明方案评审阶段很多事情就没有理顺；写代码的人考虑问题也不够全面甚至没有仔细思考就动手写了。最可怕的是评审出来问题后，评审人让写代码者改什么，写代码者就是无脑照办。评审人很可能由于使用脑补细节有疏漏，造成问题。&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;随手优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485756&amp;amp;idx=1&amp;amp;sn=36600cc4a62d3366b8fa1796a1077061&amp;amp;chksm=fafde392cd8a6a84fc1219260710860c528f0e1cd29e6ac4662eab170de732aa862a23e13687&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;避免线上故障的10条建议&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;避免线上故障的10条建议&lt;/a&gt;》和《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485646&amp;amp;idx=1&amp;amp;sn=865d300bd03db4ea45f5ed743a6cbb60&amp;amp;chksm=fafde260cd8a6b7686cbfd5464401d5a834398a78d56926d2856672aab3fa60d99406412d99e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;设计开发中要避免的两个坑和一种可借鉴的设计思想&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;设计开发中要避免的两个坑和一种可借鉴的设计思想&lt;/a&gt;》里我都有详细说明过，随手优化可能会带来的灾难。但是最近写代码才发现这件事情我自己也没做好。&lt;/p&gt;&lt;p&gt;最近我提交了一次代码，被认真负责的同事加了评论打回了。第一条在一个地方给我打了个问号。这个地方我的修改是：在一个方法里，一个代码片段和下面的代码片段中间有2个空行。&lt;span&gt;”&lt;/span&gt;因为我看着极为不爽就随手去掉了一个多余的空行。我看着打回的代码，本来是想解释一下，后来我仔细想了一下：&lt;/p&gt;&lt;p&gt;1&amp;gt;多一个空行完全不影响运行，也不会增加很多理解成本，本身必要性不大&lt;/p&gt;&lt;p&gt;2&amp;gt;我改了一个空行测试验证过吗？就算是理论上完全不影响生产，不经过测试的修改是不对的。&lt;/p&gt;&lt;p&gt;所以我默默的放下骄傲，还原了随手优化的代码。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;后记&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;细节决定成败。&lt;/section&gt;&lt;section&gt;刚毕业的时候，我们几个应届生一起做项目，做的都不是什么核心功能。就是C/S模式的客户端交互界面。我和旁边一个女孩相比。我做了7个界面，她做了1个。并且我的界面都比她的复杂。最后我做完了，她还没有做完，她延期了好久。最终领导说她做的好，我当时是非常不服气的。后来我想明白了：就像99%的时间会花在线上只有1%几率出现的问题一样。多囫囵吞枣的做事情并不多花多少时间，而想把质量提高一些，做的更好一些，却是更难的事。&lt;/section&gt;&lt;section&gt;平时买东西也一样，质量高出一些，做工精巧一些，价钱多出好几个数量级；小时候考试也一样，从班里倒数第一进步到中等水平并不难，但是从第二名进步到第一名要的功夫就大多了；普通饭馆里凉菜十几元到几十元一盘，用了刀工的大厨做的那价钱会翻10倍甚至更高，一个道理。&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.81&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlibItcxskcYK64YlQUr4gOxauvx0hzuU2Ppax79vLfUIk4iaBtrGHCQ83CiaRo4PjMTMkibO6lzFZhVZQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>791b53bf78dc4e9b26bfe5bb49e97038</guid>
<title>LeetCode 通关：连刷十四题，回溯算法完全攻略</title>
<link>https://toutiao.io/k/lrmbo5p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;刷题路线：https://github.com/youngyangyang04/leetcode-master&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是被算法题虐到泪流满面的老三，只能靠发发文章给自己打气！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一节，我们来看看回溯算法。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0159453302961277&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdEBIWkuU13StdgDqqwE4icwX3hLo3pEibHY8Hw6roecmslCGCosxd4wDnNrib3KbQllSA6EosvFa4AQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;878&quot;/&gt;&lt;figcaption&gt;回溯算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;回溯算法理论基础&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是回溯&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在二叉树的路径问题里，其实我们已经接触到了回溯这种算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如我们在查找二叉树所有路径的时候，查找完一个路径之后，还需要回退，接着找下一个路径。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8913738019169329&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdEBIWkuU13StdgDqqwE4icwolvrSM86SvkJ9T4jGYtK5u7ofLF3SK6fZcODJuSEscsfPUc2e9oqhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;313&quot;/&gt;&lt;figcaption&gt;二叉树所有路径&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回溯其实可以说是我们熟悉的DFS，本质上是一种&lt;code&gt;暴力穷举&lt;/code&gt;算法，把所有的可能都列举出来，所以回溯并不高效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个可能比较抽象，我们举一个例子吧，[1,2,3]三个数可以构成多少种组合呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的办法就是把所有结果都穷举出来，那怎么穷举呢？可以第一位选1，第二位从[2,3]里选2，第三位从[3]里选3；第二个组合可以第一位选2……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们把这个选择抽象成一棵树，初步有个印象，这是全排列的问题，后面会刷到。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5632823365785814&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdEBIWkuU13StdgDqqwE4icweLJtN0whXicicp6KvwHIqdarGAOetVFzKVwku0qHdmPEbgvDnZsalhiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;719&quot;/&gt;&lt;figcaption&gt;抽象树&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;回溯算法模板&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回溯算法，可以看作一个树的遍历过程，建议可以去看一下N叉树的遍历，和这个非常类似。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;递归有三要素，类似的，回溯同样需要关注三要素：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回溯算法中函数返回值一般为void。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回溯方法的参数得结合实际问题，但是一般需要一个类似栈的结构来存储每个路径（结果），因为我们一次递归结束之后，节点要回溯到上一个位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回溯方法伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;backtrack&lt;/span&gt;&lt;span&gt;(参数)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和递归一样，回溯同样也要有结束条件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么时候达到了终止条件，从树的角度来讲，一般来说搜到叶子节点了，对回溯而言，就是找到了满足条件的一个结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以回溯函数终止条件伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (终止条件) {&lt;br/&gt;    存放结果;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回溯法一般是在一个序列里做选择，序列的大小构成了树的宽度，递归的深度构成的树的深度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回溯函数遍历过程伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {&lt;br/&gt;    处理节点;&lt;br/&gt;    backtracking(路径，选择列表); &lt;span&gt;// 递归&lt;/span&gt;&lt;br/&gt;    回溯，撤销处理结果&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;for循环就是遍历序列，可以理解一个节点有多少个孩子，这个for循环就执行多少次。可以理解为横向的遍历。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;backtrack就是自己调用自己，可以理解为纵向的遍历。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5188141391106044&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdEBIWkuU13StdgDqqwE4icwD0KCADgtaZtB1Q8Rys7gXu1WVBZaE8efMJUibZ8SU0KzAaTWfPDJlPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;877&quot;/&gt;&lt;figcaption&gt;回溯算法模板&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时递归之后，我们还要撤销之前做的选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以回溯算法模板框架如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;backtrack&lt;/span&gt;&lt;span&gt;(参数)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (终止条件) {&lt;br/&gt;        存放结果;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {&lt;br/&gt;        处理节点;&lt;br/&gt;        backtrack(路径，选择列表); &lt;span&gt;// 递归&lt;/span&gt;&lt;br/&gt;        回溯，撤销处理结果&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;回溯能解决哪些问题&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回溯法，一般可以解决如下几种问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;组合问题：N个数里面按一定规则找出k个数的集合&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;切割问题：一个字符串按一定规则有几种切割方式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子集问题：一个N个数的集合里有多少符合条件的子集&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;排列问题：N个数按一定规则全排列，有几种排列方式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;棋盘问题：N皇后，解数独等等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能到这对回溯还比较迷茫，没有关系，回溯是比较套路化的一种算法，多做几道题就明白了。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;组合问题&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;LeetCode77. 组合&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：77. 组合 (https://leetcode-cn.com/problems/combinations/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给定两个整数 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt;，返回范围 &lt;code&gt;[1, n]&lt;/code&gt; 中所有可能的 &lt;code&gt;k&lt;/code&gt; 个数的组合你可以按 &lt;strong&gt;任何顺序&lt;/strong&gt; 返回答案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入：n = 4, k = 2&lt;br/&gt;输出：&lt;br/&gt;[&lt;br/&gt;  [2,4],&lt;br/&gt;  [3,4],&lt;br/&gt;  [2,3],&lt;br/&gt;  [1,2],&lt;br/&gt;  [1,3],&lt;br/&gt;  [1,4],&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入：n = 1, k = 1&lt;br/&gt;输出：[[1]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡 思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题是回溯算法的经典题目。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看一下这道题的抽象树形结构：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4399243140964995&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdEBIWkuU13StdgDqqwE4icwxlY00BibG39HTXsyYXqFibswZfU8nKqYWWWx7FwzjOVLsEuOsibjEzyQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1057&quot;/&gt;&lt;figcaption&gt;组合抽象树结构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照我们的回溯模板，看看这道题应该怎么写：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先方法里是一定要区间的数据，[start，n]。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计数的k也不可缺少。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后的结果集合result，还有每条路径的结果path，可以定义全局变量，来提升可读性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么时候终止，就是什么时候到叶子节点了呢？结果parh的大小等于k，说明到了叶子节点，一次递归结束。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在单层逻辑里面，我们要做两件事：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;遍历序列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;递归，遍历节点&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.44859038142620233&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdEBIWkuU13StdgDqqwE4icwsqq9WB1kjgT6tOBda27xztRna3Qib9Adj1OyQJsgXo9o8hiaYDa20W3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1206&quot;/&gt;&lt;figcaption&gt;组合单层逻辑&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;🖊 代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//结果集合&lt;/span&gt;&lt;br/&gt;    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result;&lt;br/&gt;    &lt;span&gt;//符合条件的结果&lt;/span&gt;&lt;br/&gt;    LinkedList&amp;lt;Integer&amp;gt; path;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combine(&lt;span&gt;int&lt;/span&gt; n, &lt;span&gt;int&lt;/span&gt; k) {&lt;br/&gt;        result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        path = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;        backstack(n, k, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//回溯&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;backstack&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; n, &lt;span&gt;int&lt;/span&gt; k, &lt;span&gt;int&lt;/span&gt; start)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//结束条件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (path.size() == k) {&lt;br/&gt;            result.add(&lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;(path));&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = start; i &amp;lt;= n; i++) {&lt;br/&gt;            path.addLast(i);&lt;br/&gt;            &lt;span&gt;//递归&lt;/span&gt;&lt;br/&gt;            backstack(n, k, i + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;//回溯,撤销已经处理的节点&lt;/span&gt;&lt;br/&gt;            path.removeLast();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;⚡ 剪枝优化&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回溯中，提高性能的一大妙招就是剪枝。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;剪枝见名知义，就是在把我们的树的一些树枝给它剪掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如&lt;code&gt;n = 4，k = 4&lt;/code&gt;，&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.660431654676259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdEBIWkuU13StdgDqqwE4icww3l2d4I7qlFcdpmrjPUeicns0Nncg26xZ8QlOVueNRn40UJFMI4MePQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;695&quot;/&gt;&lt;figcaption&gt;剪枝优化&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到，有些路径，其实一定是不满足我们的要求，如果我们把这些不可能的路径&lt;code&gt;剪断&lt;/code&gt;，那我们不就可以少遍历一些节点吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们看看这道题怎么来剪这个枝：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索&lt;/strong&gt;。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;已经选择的元素个数：path.size();&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;还需要的元素个数为: k - path.size();&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;所以起始位置 : n - (k - path.size()) + 1之后的肯定不符合要求&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以优化之后的代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;//结果集合&lt;/span&gt;&lt;br/&gt;    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result;&lt;br/&gt;    &lt;span&gt;//符合条件的结果&lt;/span&gt;&lt;br/&gt;    LinkedList&amp;lt;Integer&amp;gt; path;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combine(&lt;span&gt;int&lt;/span&gt; n, &lt;span&gt;int&lt;/span&gt; k) {&lt;br/&gt;        result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        path = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;        backstack(n, k, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//回溯&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;backstack&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; n, &lt;span&gt;int&lt;/span&gt; k, &lt;span&gt;int&lt;/span&gt; start)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//结束条件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (path.size() == k) {&lt;br/&gt;            result.add(&lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;(path));&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = start; i &amp;lt;= n-(k-path.size())+&lt;span&gt;1&lt;/span&gt;; i++) {&lt;br/&gt;            path.addLast(i);&lt;br/&gt;            &lt;span&gt;//递归&lt;/span&gt;&lt;br/&gt;            backstack(n, k, i + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;//回溯,撤销已经处理的节点&lt;/span&gt;&lt;br/&gt;            path.removeLast();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;LeetCode216. 组合总和 III&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：77. 组合 (https://leetcode-cn.com/problems/combinations/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;找出所有相加之和为 &lt;em&gt;&lt;strong&gt;n&lt;/strong&gt;&lt;/em&gt; 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入: k = 3, n = 7&lt;br/&gt;输出: [[1,2,4]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入: k = 3, n = 9&lt;br/&gt;输出: [[1,2,6], [1,3,5], [2,3,4]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡 思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先把这道题抽象成树：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5041825095057034&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdEBIWkuU13StdgDqqwE4icweKxPzuTAibwMNLjHns3Jj6nS4tLxwwaOX4A7SUyCC0MvMLMTk3L3BuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1315&quot;/&gt;&lt;figcaption&gt;抽象树&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着套模板。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到叶子节点（path大小等于k）终止。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参数稍微有变化，序列是固定的，这里的n是目标和；需要一个参数pathSum来记录路径上的数总和，我们直接全局变量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;逻辑差别不大，回溯的时候需要把pathSum也回溯一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;🖊 代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;//结果集合&lt;/span&gt;&lt;br/&gt;    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result;&lt;br/&gt;    &lt;span&gt;//结果&lt;/span&gt;&lt;br/&gt;    LinkedList&amp;lt;Integer&amp;gt; path;&lt;br/&gt;    &lt;span&gt;//结果综合&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; pathSum;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum3(&lt;span&gt;int&lt;/span&gt; k, &lt;span&gt;int&lt;/span&gt; n) {&lt;br/&gt;        result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        path = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;        backtrack(n, k, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;//回溯&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;backtrack&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; n, &lt;span&gt;int&lt;/span&gt; k, &lt;span&gt;int&lt;/span&gt; start)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//结束&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (path.size() == k) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (pathSum == n) {&lt;br/&gt;                result.add(&lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;(path));&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//遍历序列&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = start; i &amp;lt;= &lt;span&gt;9&lt;/span&gt;; i++) {&lt;br/&gt;            path.push(i);&lt;br/&gt;            pathSum += i;&lt;br/&gt;            &lt;span&gt;//递归&lt;/span&gt;&lt;br/&gt;            backtrack(n, k, i + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;//回溯，撤销操作&lt;/span&gt;&lt;br/&gt;            pathSum -= path.pop();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;⚡ 剪枝优化&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样也可以进行剪枝优化，也很好想，如果pathNum&amp;gt;n ，那就没必要再遍历了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;//结果集合&lt;/span&gt;&lt;br/&gt;    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result;&lt;br/&gt;    &lt;span&gt;//结果&lt;/span&gt;&lt;br/&gt;    LinkedList&amp;lt;Integer&amp;gt; path;&lt;br/&gt;    &lt;span&gt;//结果综合&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; pathSum;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum3(&lt;span&gt;int&lt;/span&gt; k, &lt;span&gt;int&lt;/span&gt; n) {&lt;br/&gt;        result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        path = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;        backtrack(n, k, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;//回溯&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;backtrack&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; n, &lt;span&gt;int&lt;/span&gt; k, &lt;span&gt;int&lt;/span&gt; start)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//剪枝优化&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (pathSum &amp;gt; n) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//结束&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (path.size() == k) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (pathSum == n) {&lt;br/&gt;                result.add(&lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;(path));&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//遍历序列&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = start; i &amp;lt;= &lt;span&gt;9&lt;/span&gt;; i++) {&lt;br/&gt;            path.push(i);&lt;br/&gt;            pathSum += i;&lt;br/&gt;            &lt;span&gt;//递归&lt;/span&gt;&lt;br/&gt;            backtrack(n, k, i + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;//回溯，撤销操作&lt;/span&gt;&lt;br/&gt;            pathSum -= path.pop();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;LeetCode39. 组合总和&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：39. 组合总和 (https://leetcode-cn.com/problems/combination-sum/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是唯一的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于给定的输入，保证和为 target 的唯一组合数少于 150 个。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 1：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入: candidates = [2,3,6,7], target = 7&lt;br/&gt;输出: [[7],[2,2,3]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 2：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入: candidates = [2,3,5], target = 8&lt;br/&gt;输出: [[2,2,2,2],[2,3,3],[3,5]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 3：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入: candidates = [2], target = 1&lt;br/&gt;输出: []&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 4：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入: candidates = [1], target = 1&lt;br/&gt;输出: [[1]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 5：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入: candidates = [1], target = 2&lt;br/&gt;输出: [[1,1]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提示：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;1 &amp;lt;= candidates.length &amp;lt;= 30&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;1 &amp;lt;= candidates[i] &amp;lt;= 200&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;candidate 中的每个元素都是独一无二的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;1 &amp;lt;= target &amp;lt;= 500&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡 思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题和我们上面的有什么区别呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它没有数量要求，可以无限重复，但是有总和的限制。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5177133655394525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdEBIWkuU13StdgDqqwE4icw8Re6CHhYAFPNPx41cSvUexqAf6w5kicw29ZKlIaP6gmX3zNEUloVOFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1242&quot;/&gt;&lt;figcaption&gt;组合总和&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有两个关键点：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看看如何通过回溯三要素来carry：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参数里需要&lt;code&gt;start&lt;/code&gt;标明起点，为什么呢？因为要求组合不重复，所以需要限制下次搜索的起点，是基于本次选择，这样就不会选到本次选择同层左边的数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题没有限制数的个数，所以我们要根据&lt;code&gt;pathSum&amp;gt;target&lt;/code&gt;（当前组合不满足）和&lt;code&gt;pathSum==target&lt;/code&gt;（当前组合满足）来终止递归。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单层仍然从start开始，搜索 candidates。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;🖊 代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;//结果结合&lt;/span&gt;&lt;br/&gt;    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result;&lt;br/&gt;    &lt;span&gt;//结果路径&lt;/span&gt;&lt;br/&gt;    LinkedList&amp;lt;Integer&amp;gt; path;&lt;br/&gt;    &lt;span&gt;//结果路径值的和&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; pathSum;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum(&lt;span&gt;int&lt;/span&gt;[] candidates, &lt;span&gt;int&lt;/span&gt; target) {&lt;br/&gt;        result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        path = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;        pathSum = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        backtrack(candidates, target, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;backtrack&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] candidates, &lt;span&gt;int&lt;/span&gt; target, &lt;span&gt;int&lt;/span&gt; start)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//终止条件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (pathSum &amp;gt; target) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (pathSum == target) {&lt;br/&gt;            result.add(&lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;(path));&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = start; i &amp;lt; candidates.length; i++) {&lt;br/&gt;            pathSum += candidates[i];&lt;br/&gt;            path.push(candidates[i]);&lt;br/&gt;            &lt;span&gt;//注意，i不用加1，表示当前数可以重复读取&lt;/span&gt;&lt;br/&gt;            backtrack(candidates, target, i);&lt;br/&gt;            &lt;span&gt;//回溯&lt;/span&gt;&lt;br/&gt;            pathSum -= path.pop();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;⚡ 剪枝优化&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又到了剪枝优化时间，在本层循环，如果发现下一层的pathSum（本层pathSum+candidates[i]）,那么就可以结束本层循环，注意要先把candidates拍一下序。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//结果结合&lt;/span&gt;&lt;br/&gt;    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result;&lt;br/&gt;    &lt;span&gt;//结果路径&lt;/span&gt;&lt;br/&gt;    LinkedList&amp;lt;Integer&amp;gt; path;&lt;br/&gt;    &lt;span&gt;//结果路径值的和&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; pathSum;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum(&lt;span&gt;int&lt;/span&gt;[] candidates, &lt;span&gt;int&lt;/span&gt; target) {&lt;br/&gt;        result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        path = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;        pathSum = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;//剪枝优化，先排序&lt;/span&gt;&lt;br/&gt;        Arrays.sort(candidates);&lt;br/&gt;        backtrack(candidates, target, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;backtrack&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] candidates, &lt;span&gt;int&lt;/span&gt; target, &lt;span&gt;int&lt;/span&gt; start)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//终止条件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (pathSum &amp;gt; target) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (pathSum == target) {&lt;br/&gt;            result.add(&lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;(path));&lt;br/&gt;        }&lt;br/&gt;       &lt;span&gt;//剪枝优化，判断循环之后的pathSum是否会超过target&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = start; i &amp;lt; candidates.length &amp;amp;&amp;amp; pathSum + candidates[i] &amp;lt;= target; i++) {&lt;br/&gt;            pathSum += candidates[i];&lt;br/&gt;            path.push(candidates[i]);&lt;br/&gt;            &lt;span&gt;//注意，i不用加1，表示当前数可以重复读取&lt;/span&gt;&lt;br/&gt;            backtrack(candidates, target, i);&lt;br/&gt;            &lt;span&gt;//回溯&lt;/span&gt;&lt;br/&gt;            pathSum -= path.pop();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;LeetCode40. 组合总和 II&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：40. 组合总和 II (https://leetcode-cn.com/problems/combination-sum-ii/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;candidates 中的每个数字在每个组合中只能使用一次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：解集不能包含重复的组合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 1:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入: candidates = [10,1,2,7,6,1,5], target = 8,&lt;br/&gt;输出:&lt;br/&gt;[&lt;br/&gt;[1,1,6],&lt;br/&gt;[1,2,5],&lt;br/&gt;[1,7],&lt;br/&gt;[2,6]&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 2:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入: candidates = [2,5,2,1,2], target = 5,&lt;br/&gt;输出:&lt;br/&gt;[&lt;br/&gt;[1,2,2],&lt;br/&gt;[5]&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提示:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;1 &amp;lt;= candidates.length &amp;lt;= 100&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;1 &amp;lt;= candidates[i] &amp;lt;= 50&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;1 &amp;lt;= target &amp;lt;= 30&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡 思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题和上一道题有啥区别呢？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;candidates&lt;/code&gt;里每个数字在每个组合里只能使用一次&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;candidates&lt;/code&gt;里的元素是有重复的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这道题的关键在于：&lt;strong&gt;集合（数组candidates）有重复元素，但还不能有重复的组合&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于这个去重，有什么思路呢？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;利用&lt;code&gt;HashSet&lt;/code&gt;的特性去重，但是容易超时&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;还有一种办法，先把数组排序[1,3,1] --&amp;gt;  [1,1,3]，我们比较一下相邻的元素，重复的就跳过&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们把模拟树画一下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5949263502454992&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdEBIWkuU13StdgDqqwE4icwUoGbmufpSoopfGvrngP7icsfWhtsbdvsiauUysuj7rj2Yf4iblRYiclwAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1222&quot;/&gt;&lt;figcaption&gt;模拟树&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三要素走起：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和上一道基本一致。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;终止条件&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;pathSum&amp;gt;target和pathSum==target。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们这次直接剪枝，提前判断下次pathSum是否大于target，所以pathSum&amp;gt;target可以省略&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;🖊 代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;//结果集合&lt;/span&gt;&lt;br/&gt;    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result;&lt;br/&gt;    &lt;span&gt;//结果路径&lt;/span&gt;&lt;br/&gt;    LinkedList&amp;lt;Integer&amp;gt; path;&lt;br/&gt;    &lt;span&gt;//结果路径值总和&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; pathSum;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum2(&lt;span&gt;int&lt;/span&gt;[] candidates, &lt;span&gt;int&lt;/span&gt; target) {&lt;br/&gt;        &lt;span&gt;//排序condidates，去重前提&lt;/span&gt;&lt;br/&gt;        Arrays.sort(candidates);&lt;br/&gt;        &lt;span&gt;//初始化相关变量&lt;/span&gt;&lt;br/&gt;        result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        path = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;        pathSum = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        backtrack(candidates, target, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;backtrack&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] candidates, &lt;span&gt;int&lt;/span&gt; target, &lt;span&gt;int&lt;/span&gt; start)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//终止条件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (pathSum == target) {&lt;br/&gt;            result.add(&lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;(path));&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//剪枝操作&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = start; i &amp;lt; candidates.length &amp;amp;&amp;amp; candidates[i] + pathSum &amp;lt;= target; i++) {&lt;br/&gt;            &lt;span&gt;//同一层使用过的元素跳过&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (i &amp;gt; start &amp;amp;&amp;amp; candidates[i] == candidates[i - &lt;span&gt;1&lt;/span&gt;]) {&lt;br/&gt;                &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            pathSum += candidates[i];&lt;br/&gt;            path.push(candidates[i]);&lt;br/&gt;            &lt;span&gt;//每个数字在每个组合中只能用一次，所以i++&lt;/span&gt;&lt;br/&gt;            backtrack(candidates, target, i + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;//回溯&lt;/span&gt;&lt;br/&gt;            pathSum -= path.pop();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;LeetCode17. 电话号码的字母组合&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：17. 电话号码的字母组合(https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.905811623246493&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdEBIWkuU13StdgDqqwE4icwD5QZFYxm8mwsRnIo6tIFuDQAAkDyS4HI0iaQ7DtthtVGQuZMHvuJ7CA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;499&quot;/&gt;&lt;figcaption&gt;17&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 1：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入：digits = &lt;span&gt;&quot;23&quot;&lt;/span&gt;&lt;br/&gt;输出：[&lt;span&gt;&quot;ad&quot;&lt;/span&gt;,&lt;span&gt;&quot;ae&quot;&lt;/span&gt;,&lt;span&gt;&quot;af&quot;&lt;/span&gt;,&lt;span&gt;&quot;bd&quot;&lt;/span&gt;,&lt;span&gt;&quot;be&quot;&lt;/span&gt;,&lt;span&gt;&quot;bf&quot;&lt;/span&gt;,&lt;span&gt;&quot;cd&quot;&lt;/span&gt;,&lt;span&gt;&quot;ce&quot;&lt;/span&gt;,&lt;span&gt;&quot;cf&quot;&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 2：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入：digits = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;输出：[]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 3：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入：digits = &lt;span&gt;&quot;2&quot;&lt;/span&gt;&lt;br/&gt;输出：[&lt;span&gt;&quot;a&quot;&lt;/span&gt;,&lt;span&gt;&quot;b&quot;&lt;/span&gt;,&lt;span&gt;&quot;c&quot;&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提示：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;0 &amp;lt;= digits.length &amp;lt;= 4&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;digits[i] 是范围 [&#x27;2&#x27;, &#x27;9&#x27;] 的一个数字。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡 思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实扒开表皮，这道题和&lt;code&gt;77.组合&lt;/code&gt;本质上是一样。只不过序列和组合个数没有明确给出。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;序列是什么：digits 映射成的字母序列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;组合个数：digits的大小&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先画抽象树：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3796583850931677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdEBIWkuU13StdgDqqwE4icwiaGCk6fFJ5H1hHTwBqusrZ2zNvjhsTpf1UqfEwczKlsuNqnN39tEOicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1288&quot;/&gt;&lt;figcaption&gt;电话号码的字母组合&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;🖊 代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//结果集合&lt;/span&gt;&lt;br/&gt;    List&amp;lt;String&amp;gt; result;&lt;br/&gt;    &lt;span&gt;//结果&lt;/span&gt;&lt;br/&gt;    StringBuilder path;&lt;br/&gt;    &lt;span&gt;//每个路径个数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; pathNum;&lt;br/&gt;    &lt;span&gt;//映射数组，0，1空出来，方便直接映射&lt;/span&gt;&lt;br/&gt;    String[] numsMap = {&lt;span&gt;&quot; &quot;&lt;/span&gt;, &lt;span&gt;&quot; &quot;&lt;/span&gt;, &lt;span&gt;&quot;abc&quot;&lt;/span&gt;, &lt;span&gt;&quot;def&quot;&lt;/span&gt;, &lt;span&gt;&quot;ghi&quot;&lt;/span&gt;, &lt;span&gt;&quot;jkl&quot;&lt;/span&gt;, &lt;span&gt;&quot;mno&quot;&lt;/span&gt;, &lt;span&gt;&quot;pqrs&quot;&lt;/span&gt;, &lt;span&gt;&quot;tuv&quot;&lt;/span&gt;, &lt;span&gt;&quot;wxyz&quot;&lt;/span&gt;};&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt; &lt;span&gt;letterCombinations&lt;/span&gt;&lt;span&gt;(String digits)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (digits == &lt;span&gt;null&lt;/span&gt; || digits.length() == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;        }&lt;br/&gt;        path = &lt;span&gt;new&lt;/span&gt; StringBuilder();&lt;br/&gt;        pathNum = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        backtrack(digits, pathNum);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;backtrack&lt;/span&gt;&lt;span&gt;(String digits, &lt;span&gt;int&lt;/span&gt; pathNum)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (pathNum == digits.length()) {&lt;br/&gt;            result.add(path.toString());&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//获取映射字母&lt;/span&gt;&lt;br/&gt;        String letters = numsMap[digits.charAt(pathNum) - &lt;span&gt;&#x27;0&#x27;&lt;/span&gt;];&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; letters.length(); i++) {&lt;br/&gt;            path.append(letters.charAt(i));&lt;br/&gt;            &lt;span&gt;//注意，pathNum+1,要处理下一层&lt;/span&gt;&lt;br/&gt;            backtrack(digits, pathNum + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;//回溯&lt;/span&gt;&lt;br/&gt;            path.deleteCharAt(path.length() - &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分割问题&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;LeetCode131. 分割回文串&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：131. 分割回文串 (https://leetcode-cn.com/problems/palindrome-partitioning/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回文串 是正着读和反着读都一样的字符串。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 1：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入：s = &lt;span&gt;&quot;aab&quot;&lt;/span&gt;&lt;br/&gt;输出：[[&lt;span&gt;&quot;a&quot;&lt;/span&gt;,&lt;span&gt;&quot;a&quot;&lt;/span&gt;,&lt;span&gt;&quot;b&quot;&lt;/span&gt;],[&lt;span&gt;&quot;aa&quot;&lt;/span&gt;,&lt;span&gt;&quot;b&quot;&lt;/span&gt;]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 2：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入：s = &lt;span&gt;&quot;a&quot;&lt;/span&gt;&lt;br/&gt;输出：[[&lt;span&gt;&quot;a&quot;&lt;/span&gt;]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提示：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;1 &amp;lt;= s.length &amp;lt;= 16&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;s 仅由小写英文字母组成&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡 思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们写了一些组合问题，现在又是一类新的问题——&lt;code&gt;分割&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但其实，分割问题，也类似组合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如对于字符串abcdef：[1]&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中在选组第三个.....。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中在切割第三段…….&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先画一下抽象树：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.568724279835391&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdEBIWkuU13StdgDqqwE4icw28PK8HjXef8YTa608AicT4picwK4HvaZ38YZECXvJoDaHDTqaX8k8zjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1215&quot;/&gt;&lt;figcaption&gt;分割回文串抽象树&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回溯三要素：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要一个start来标记下一轮递归遍历的起始位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果start已经超过字符串的长度，那么说明我们path中的组合是回文串。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单层逻辑和之前的逻辑大体类似，不过需要判断一下字符串是否是回文串，这个比较简单。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;🖊 代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;     List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; result;&lt;br/&gt;    LinkedList&amp;lt;String&amp;gt; path;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; partition(String s) {&lt;br/&gt;        result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        path = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;        backtrack(s, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;backtrack&lt;/span&gt;&lt;span&gt;(String s, &lt;span&gt;int&lt;/span&gt; start)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//结束条件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (start &amp;gt;= s.length()) {&lt;br/&gt;            result.add(&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(path));&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = start; i &amp;lt; s.length(); i++) {&lt;br/&gt;            &lt;span&gt;//如果是回文串&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (isPalidrome(s, start, i)) {&lt;br/&gt;                String r = s.substring(start, i+&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;                path.addLast(r);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//起始位置后移&lt;/span&gt;&lt;br/&gt;            backtrack(s, i + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;//回溯&lt;/span&gt;&lt;br/&gt;            path.removeLast();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//判断是否回文串&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isPalidrome&lt;/span&gt;&lt;span&gt;(String s, &lt;span&gt;int&lt;/span&gt; start, &lt;span&gt;int&lt;/span&gt; end)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = start, j = end; i &amp;lt; j; i++, j--) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (s.charAt(i) != s.charAt(j)) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;LeetCode93. 复原 IP 地址&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：93. 复原 IP 地址 (https://leetcode-cn.com/problems/restore-ip-addresses/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 s 获得的 有效 IP 地址 。你可以按任何顺序返回答案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 &#x27;.&#x27; 分隔。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&quot;0.1.2.201&quot; 和 &quot;192.168.1.1&quot; 是 有效 IP 地址，但是 &quot;0.011.255.245&quot;、&quot;192.168.1.312&quot; 和 &quot;192.168@1.1&quot; 是 无效 IP 地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 1：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入：s = &lt;span&gt;&quot;25525511135&quot;&lt;/span&gt;&lt;br/&gt;输出：[&lt;span&gt;&quot;255.255.11.135&quot;&lt;/span&gt;,&lt;span&gt;&quot;255.255.111.35&quot;&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 2：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入：s = &lt;span&gt;&quot;0000&quot;&lt;/span&gt;&lt;br/&gt;输出：[&lt;span&gt;&quot;0.0.0.0&quot;&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 3：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入：s = &lt;span&gt;&quot;1111&quot;&lt;/span&gt;&lt;br/&gt;输出：[&lt;span&gt;&quot;1.1.1.1&quot;&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 4：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入：s = &lt;span&gt;&quot;010010&quot;&lt;/span&gt;&lt;br/&gt;输出：[&lt;span&gt;&quot;0.10.0.10&quot;&lt;/span&gt;,&lt;span&gt;&quot;0.100.1.0&quot;&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 5：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入：s = &lt;span&gt;&quot;101023&quot;&lt;/span&gt;&lt;br/&gt;输出：[&lt;span&gt;&quot;1.0.10.23&quot;&lt;/span&gt;,&lt;span&gt;&quot;1.0.102.3&quot;&lt;/span&gt;,&lt;span&gt;&quot;10.1.0.23&quot;&lt;/span&gt;,&lt;span&gt;&quot;10.10.2.3&quot;&lt;/span&gt;,&lt;span&gt;&quot;101.0.2.3&quot;&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提示：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;0 &amp;lt;= s.length &amp;lt;= 3000&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;s 仅由数字组成&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡 思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题是不是和上一道题类似啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先把抽象树画一下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5656178050652341&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdEBIWkuU13StdgDqqwE4icwC19Lic4Yh7d5oGjpWRcxlGqR52PYk6tX6kzuT8oUibqXEUmOVLq0lpuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1303&quot;/&gt;&lt;figcaption&gt;复原ip地址抽象树&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分支比较多，偷懒省去了一些分支。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接上回溯三要素：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为ip为四段构成，所以我们需要一个参数来记录段数，这里用的是剩余的段数&lt;code&gt;residue&lt;/code&gt;；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分割问题，需要标记&lt;code&gt;start&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;终止条件是切割到了终点；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这道题又有段数的要求，所以还要加入段数的判断。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单层里面，除了回溯之类，我们还要判断当前段是否满足构成ip的要求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;🖊 代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    List&amp;lt;String&amp;gt; res = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    Deque&amp;lt;String&amp;gt; path = &lt;span&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;(&lt;span&gt;4&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; len;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt; &lt;span&gt;restoreIpAddresses&lt;/span&gt;&lt;span&gt;(String s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        len = s.length();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (len &amp;gt; &lt;span&gt;12&lt;/span&gt; || len &amp;lt; &lt;span&gt;4&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; res;&lt;br/&gt;        backtrack(s, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; res;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; s 字符串&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; start 起始位置&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; residue 剩余段数&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;backtrack&lt;/span&gt;&lt;span&gt;(String s, &lt;span&gt;int&lt;/span&gt; start, &lt;span&gt;int&lt;/span&gt; residue)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//符合要求&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//字符已经用完，而且为四段&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (start == len &amp;amp;&amp;amp; residue == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            res.add(String.join(&lt;span&gt;&quot;.&quot;&lt;/span&gt;, path));&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = start; i &amp;lt; start + &lt;span&gt;3&lt;/span&gt;; i++) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (i &amp;gt;= len) &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;//减枝&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (residue * &lt;span&gt;3&lt;/span&gt; &amp;lt; len - i) &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;//只有符合要求的才加入&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (isIpSegment(s, start, i)) {&lt;br/&gt;                String currentIpSegment = s.substring(start, i + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;                path.addLast(currentIpSegment);&lt;br/&gt;                backtrack(s, i + &lt;span&gt;1&lt;/span&gt;, residue - &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;//回溯&lt;/span&gt;&lt;br/&gt;                path.removeLast();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//判断字串是否符合ip要求&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isIpSegment&lt;/span&gt;&lt;span&gt;(String s, &lt;span&gt;int&lt;/span&gt; left, &lt;span&gt;int&lt;/span&gt; right)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//首位0情况&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (right - left + &lt;span&gt;1&lt;/span&gt; &amp;gt; &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; s.charAt(left) == &lt;span&gt;&#x27;0&#x27;&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;//判断对应数字是否满足范围&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; num = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = left; i &amp;lt;= right; i++) {&lt;br/&gt;            num = num * &lt;span&gt;10&lt;/span&gt; + s.charAt(i) - &lt;span&gt;&#x27;0&#x27;&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; num &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; num &amp;lt;= &lt;span&gt;255&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;子集问题&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;LeetCode78. 子集&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：78. 子集 (https://leetcode-cn.com/problems/subsets/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 1：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入：nums = [1,2,3]&lt;br/&gt;输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 2：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入：nums = [0]&lt;br/&gt;输出：[[],[0]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提示：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;1 &amp;lt;= nums.length &amp;lt;= 10&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-10 &amp;lt;= nums[i] &amp;lt;= 10&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;nums 中的所有元素 互不相同&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡 思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这和我们前面做的 &lt;code&gt;77.组合&lt;/code&gt;也是类似得。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先画抽象树结构：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5043616177636796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdEBIWkuU13StdgDqqwE4icwCMRkaompib8vqoDfBPDPiakrOkvuMgkpYSib1NibMKYyt7sFdEoAYiboIXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1261&quot;/&gt;&lt;figcaption&gt;子集&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是回溯三要素：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;组合不重复，所以&lt;code&gt;start&lt;/code&gt;标记起点&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把数组所有元素用完，就终止递归，也就是start走到了最后一个位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就一点需要注意，需要收集所有得组合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;🖊 代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    LinkedList&amp;lt;Integer&amp;gt; path = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsets(&lt;span&gt;int&lt;/span&gt;[] nums) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (nums == &lt;span&gt;null&lt;/span&gt; || nums.length == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;        }&lt;br/&gt;        backstrck(nums, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;backstrck&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] nums, &lt;span&gt;int&lt;/span&gt; start)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//放在最上面，否则漏掉本次&lt;/span&gt;&lt;br/&gt;        result.add(&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(path));&lt;br/&gt;        &lt;span&gt;//终止条件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (start &amp;gt;=nums.length) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = start; i &amp;lt;nums.length; i++) {&lt;br/&gt;            path.addLast(nums[i]);&lt;br/&gt;            backstrck(nums, i + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;//回溯&lt;/span&gt;&lt;br/&gt;            path.removeLast();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;LeetCode90. 子集 II&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：90. 子集 II (https://leetcode-cn.com/problems/subsets-ii/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 1：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入：nums = [1,2,2]&lt;br/&gt;输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 2：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入：nums = [0]&lt;br/&gt;输出：[[],[0]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提示：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;1 &amp;lt;= nums.length &amp;lt;= 10&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-10 &amp;lt;= nums[i] &amp;lt;= 10&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡 思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和上一道题有一点不一样，&lt;code&gt;nums&lt;/code&gt;里面有重复的元素，而要保持组合的惟一，我们得想一个去重的办法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面的&lt;code&gt;40. 组合总和 II&lt;/code&gt; 还记得吗？那道题里序列里同样有重复的元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们是怎么去重的呢？先排序数组，相邻元素重复就跳过。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4976190476190476&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdEBIWkuU13StdgDqqwE4icwle5fxftSicvvYAtL4EGnibm2r1h8rhhPeE54BHt56kKtpWfpJ6jdJpbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1260&quot;/&gt;&lt;figcaption&gt;子集II抽象树&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;🖊 代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    LinkedList&amp;lt;Integer&amp;gt; path = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsetsWithDup(&lt;span&gt;int&lt;/span&gt;[] nums) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (nums == &lt;span&gt;null&lt;/span&gt; || nums.length == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            result.add(&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;());&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//先排序数组&lt;/span&gt;&lt;br/&gt;        Arrays.sort(nums);&lt;br/&gt;        backtrack(nums, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;backtrack&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] nums, &lt;span&gt;int&lt;/span&gt; start)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        result.add(&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(path));&lt;br/&gt;        &lt;span&gt;//终止条件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (start &amp;gt;= nums.length) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = start; i &amp;lt; nums.length; i++) {&lt;br/&gt;            &lt;span&gt;//先判断是否重复&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (i &amp;gt; start &amp;amp;&amp;amp; nums[i] == nums[i - &lt;span&gt;1&lt;/span&gt;]) {&lt;br/&gt;                &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            path.addLast(nums[i]);&lt;br/&gt;            backtrack(nums, i + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;//回溯&lt;/span&gt;&lt;br/&gt;            path.removeLast();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;LeetCode491. 递增子序列&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：491. 递增子序列 (https://leetcode-cn.com/problems/increasing-subsequences/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 1：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入：nums = [4,6,7,7]&lt;br/&gt;输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 2：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入：nums = [4,4,3,2,1]&lt;br/&gt;输出：[[4,4]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提示：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;1 &amp;lt;= nums.length &amp;lt;= 15&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-100 &amp;lt;= nums[i] &amp;lt;= 100&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡 思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题乍一看，递增？直接套&lt;code&gt;90.子集II&lt;/code&gt;，当然，肯定是不行的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意啊，我们这个整数数组是不能改变次序的，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以上面我们用排序的方式去重在这里用不上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要用一个结构来保存每一层用过的元素，来给它去重。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以选择用map来存储用过的元素，来给每一层的循环去重。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4004647560030984&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdEBIWkuU13StdgDqqwE4icwKOq07TRwB5Zobsic5uWclZSCIW9OPYvCKmXCRhXjTP51hGfThFdCxXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1291&quot;/&gt;&lt;figcaption&gt;递增子序列-抽象树&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回溯三要素：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;组合不重复，需要start。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;遍历完nums。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;去重&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用map存储一层里用过的元素，选择元素之前，判断元素是否用过。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;递增&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个元素和队尾元素比一下，判断是否满足递增的要求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;🖊 代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    LinkedList&amp;lt;Integer&amp;gt; path = &lt;span&gt;new&lt;/span&gt; LinkedList();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; findSubsequences(&lt;span&gt;int&lt;/span&gt;[] nums) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (nums == &lt;span&gt;null&lt;/span&gt; || nums.length == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            result.add(&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;());&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;        }&lt;br/&gt;        backtrack(nums, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;backtrack&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] nums, &lt;span&gt;int&lt;/span&gt; start)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//使用map辅助去重&lt;/span&gt;&lt;br/&gt;        Map&amp;lt;Integer, Integer&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (path.size() &amp;gt; &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;            result.add(&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(path));&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (start &amp;gt;= nums.length) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = start; i &amp;lt; nums.length; i++) {&lt;br/&gt;            &lt;span&gt;//判断当前元素序列是否递增&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (!path.isEmpty() &amp;amp;&amp;amp; path.getLast() &amp;gt; nums[i]) {&lt;br/&gt;                &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//本层循环元素已经用过，去重&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (map.containsKey(nums[i])) {&lt;br/&gt;                &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            path.addLast(nums[i]);&lt;br/&gt;            map.put(nums[i], i);&lt;br/&gt;            backtrack(nums, i + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;            path.removeLast();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;排列问题&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;LeetCode46. 全排列&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：46. 全排列 (https://leetcode-cn.com/problems/permutations/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 1：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入：nums = [1,2,3]&lt;br/&gt;输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 2：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入：nums = [0,1]&lt;br/&gt;输出：[[0,1],[1,0]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 3：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入：nums = [1]&lt;br/&gt;输出：[[1]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提示：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;1 &amp;lt;= nums.length &amp;lt;= 6&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-10 &amp;lt;= nums[i] &amp;lt;= 10&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;nums 中的所有整数 互不相同&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡 思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里注意，我们在每一层去重。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们之前用过两种方法去重：&lt;code&gt;排序去重&lt;/code&gt;、&lt;code&gt;map去重&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这用一个新的办法，用一个boolean数组&lt;code&gt;used&lt;/code&gt;标记元素是否被用过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先画抽象树：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5169628432956381&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdEBIWkuU13StdgDqqwE4icw6QcBLKYIVCRN34ickqW8AiaFkFs1huwFwpribVFrD8FfTGrtbaqn2X7uw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1238&quot;/&gt;&lt;figcaption&gt;全排列&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回溯三部曲：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;path中取到了等于集合得数量.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意啊，因为这里要从头开始搜索，所以就不用start了；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们去重用的used数组直接定义全局变量；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要根据used数组判断当前元素是否用过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;🖊 代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    LinkedList&amp;lt;Integer&amp;gt; path = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;boolean&lt;/span&gt;[] used;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permute(&lt;span&gt;int&lt;/span&gt;[] nums) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (nums == &lt;span&gt;null&lt;/span&gt; || nums.length == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            result.add(path);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;        }&lt;br/&gt;        used = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;[nums.length];&lt;br/&gt;        backtrack(nums);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;backtrack&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] nums)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (path.size() == nums.length) {&lt;br/&gt;            result.add(&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(path));&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; nums.length; i++) {&lt;br/&gt;            &lt;span&gt;//去重判断&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (used[i]) {&lt;br/&gt;                &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//标记用过&lt;/span&gt;&lt;br/&gt;            used[i] = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            path.addLast(nums[i]);&lt;br/&gt;            backtrack(nums);&lt;br/&gt;            &lt;span&gt;//回溯&lt;/span&gt;&lt;br/&gt;            used[i] = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            path.removeLast();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;LeetCode47. 全排列 II&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：47. 全排列 II (https://leetcode-cn.com/problems/permutations-ii/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 1：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入：nums = [1,1,2]&lt;br/&gt;输出：&lt;br/&gt;[[1,1,2],&lt;br/&gt; [1,2,1],&lt;br/&gt; [2,1,1]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 2：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入：nums = [1,2,3]&lt;br/&gt;输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提示：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;1 &amp;lt;= nums.length &amp;lt;= 8&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-10 &amp;lt;= nums[i] &amp;lt;= 10&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡 思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题在上一道题的基础上：&lt;code&gt;给定一个可包含重复数字的序列 nums&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又到了我们喜闻乐见的去重时间，这个去重是单层的去重。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次我们可以使用排序，相邻元素比较的方式去重。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先画抽象树：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5195121951219512&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdEBIWkuU13StdgDqqwE4icwwUK1LYBy74ONicv30tk5iabED4gZfb4Sn7eFZu2yvoYCg5lwYIy84o0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1230&quot;/&gt;&lt;figcaption&gt;全排列II&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;🖊 代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;     List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    LinkedList&amp;lt;Integer&amp;gt; path = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;boolean&lt;/span&gt;[] used;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permuteUnique(&lt;span&gt;int&lt;/span&gt;[] nums) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (nums == &lt;span&gt;null&lt;/span&gt; || nums.length == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            result.add(path);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//排序无序集合&lt;/span&gt;&lt;br/&gt;        Arrays.sort(nums);&lt;br/&gt;        used = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;[nums.length];&lt;br/&gt;        backtrack(nums);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;backtrack&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] nums)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (path.size() == nums.length) {&lt;br/&gt;            result.add(&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(path));&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; nums.length; i++) {&lt;br/&gt;            &lt;span&gt;//判断元素本层是否用过&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (i &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; nums[i] == nums[i - &lt;span&gt;1&lt;/span&gt;] &amp;amp;&amp;amp; used[i - &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;false&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//判断元素本枝干是否用过&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (used[i]) {&lt;br/&gt;                &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//开始处理&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;//标记同一个枝干用过&lt;/span&gt;&lt;br/&gt;            used[i] = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            path.addLast(nums[i]);&lt;br/&gt;            backtrack(nums);&lt;br/&gt;            &lt;span&gt;//回溯&lt;/span&gt;&lt;br/&gt;            path.removeLast();&lt;br/&gt;            used[i] = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;棋盘问题&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;LeetCode51. N 皇后&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：51. N 皇后 (https://leetcode-cn.com/problems/n-queens/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：困难&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 &#x27;Q&#x27; 和 &#x27;.&#x27; 分别代表了皇后和空位。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.44598337950138506&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWdEBIWkuU13StdgDqqwE4icwROna54qvwakmWo0WxoXQe2VZnqlLQgoVBNNe3erN2ial8EPj7SJ6hZw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;722&quot;/&gt;&lt;figcaption&gt;N皇后&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入：n = 4&lt;br/&gt;输出：[[&lt;span&gt;&quot;.Q..&quot;&lt;/span&gt;,&lt;span&gt;&quot;...Q&quot;&lt;/span&gt;,&lt;span&gt;&quot;Q...&quot;&lt;/span&gt;,&lt;span&gt;&quot;..Q.&quot;&lt;/span&gt;],[&lt;span&gt;&quot;..Q.&quot;&lt;/span&gt;,&lt;span&gt;&quot;Q...&quot;&lt;/span&gt;,&lt;span&gt;&quot;...Q&quot;&lt;/span&gt;,&lt;span&gt;&quot;.Q..&quot;&lt;/span&gt;]]&lt;br/&gt;解释：如上图所示，4 皇后问题存在两个不同的解法。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;输入：n = 1&lt;br/&gt;输出：[[&lt;span&gt;&quot;Q&quot;&lt;/span&gt;]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;1 &amp;lt;= n &amp;lt;= 9&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡 思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先看一下，每个组合又什么限制呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;搜索皇后的位置，同样可以抽象成一棵树。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6504854368932039&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdEBIWkuU13StdgDqqwE4icwgkibrpJkLXoEA2RBm1REibyQN9bs30CkpY1kIM9HiaAkaiavlV8ia4VPHLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1133&quot;/&gt;&lt;figcaption&gt;N皇后&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;矩阵的高就是树的高度，矩阵的宽就是每一个节点的宽度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们拿皇后的约束条件来剪枝，只要能搜索到树的叶子节点，那么就说明找到和合适的位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回溯三要素上吧！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要一个二维数组表示棋盘；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参数n记录棋盘大小；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用row记录遍历到棋盘的第几层；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到了最底的一层，说明找到合适的皇后的位置；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要判断当前选择是否符合N皇后约束条件；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三个条件，行不用管，因为我们是一行一行往下的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需要判断左上角斜方向，列方向，右上角斜方向。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6513994910941476&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdEBIWkuU13StdgDqqwE4icwTDD89hLeMr6HDHMEFc8BNYaRITfP5cLfJZUg62ZpL3JnbxJhNnjDIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;786&quot;/&gt;&lt;figcaption&gt;判断N皇后条件&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;🖊 代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;     List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; solveNQueens(&lt;span&gt;int&lt;/span&gt; n) {&lt;br/&gt;        &lt;span&gt;//棋盘&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;char&lt;/span&gt;[][] board = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[n][n];&lt;br/&gt;        &lt;span&gt;//初始化棋盘&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;char&lt;/span&gt;[] c : board) {&lt;br/&gt;            Arrays.fill(c, &lt;span&gt;&#x27;.&#x27;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        backtrack(board, n, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;backtrack&lt;/span&gt;&lt;span&gt;(&lt;span&gt;char&lt;/span&gt;[][] board, &lt;span&gt;int&lt;/span&gt; n, &lt;span&gt;int&lt;/span&gt; row)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//终止条件，到底了&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (row == n) {&lt;br/&gt;            result.add(arrayToList(board));&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; col = &lt;span&gt;0&lt;/span&gt;; col &amp;lt; n; col++) {&lt;br/&gt;            &lt;span&gt;//判断是否符合N皇后要求&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (!isValid(board, n, row, col)) &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;//开始操作&lt;/span&gt;&lt;br/&gt;            board[row][col] = &lt;span&gt;&#x27;Q&#x27;&lt;/span&gt;;&lt;br/&gt;            backtrack(board, n, row + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;//回溯&lt;/span&gt;&lt;br/&gt;            board[row][col] = &lt;span&gt;&#x27;.&#x27;&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//判断当前位置是否满足N皇后要求&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isValid&lt;/span&gt;&lt;span&gt;(&lt;span&gt;char&lt;/span&gt;[][] board, &lt;span&gt;int&lt;/span&gt; n, &lt;span&gt;int&lt;/span&gt; row, &lt;span&gt;int&lt;/span&gt; col)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//行不用判断，每层只有一个&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//col列判断&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; k = &lt;span&gt;0&lt;/span&gt;; k &amp;lt; n; k++) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (board[k][col] == &lt;span&gt;&#x27;Q&#x27;&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//检查主对角线（45度）&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = row - &lt;span&gt;1&lt;/span&gt;, j = col - &lt;span&gt;1&lt;/span&gt;; i &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; j &amp;gt;= &lt;span&gt;0&lt;/span&gt;; i--, j--) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (board[i][j] == &lt;span&gt;&#x27;Q&#x27;&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//检查副对角线（135度）&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = row - &lt;span&gt;1&lt;/span&gt;, j = col + &lt;span&gt;1&lt;/span&gt;; i &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; j &amp;lt;= n - &lt;span&gt;1&lt;/span&gt;; i--, j++) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (board[i][j] == &lt;span&gt;&#x27;Q&#x27;&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//将棋盘数组转换为字符串列表&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt; &lt;span&gt;arrayToList&lt;/span&gt;&lt;span&gt;(&lt;span&gt;char&lt;/span&gt;[][] board)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;String&amp;gt; path = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;char&lt;/span&gt;[] c : board) {&lt;br/&gt;            path.add(String.valueOf(c));&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; path;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;LeetCode 37. 解数独&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：37. 解数独(https://leetcode-cn.com/problems/sudoku-solver/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：困难&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编写一个程序，通过填充空格来解决数独问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数独的解法需 遵循如下规则：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数字 1-9 在每一行只能出现一次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数字 1-9 在每一列只能出现一次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数独部分空格内已填入了数字，空白格用 &#x27;.&#x27; 表示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdEBIWkuU13StdgDqqwE4icwY0yLsicofBhyeuBuCmecN9EF5hwGdnduibhDsOkI1U7kxobJiaZM36thw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;250&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;输入：board = [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],
[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],
[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],
[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],
[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],
[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],
[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]&lt;/p&gt;&lt;p&gt;输出：[[&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;1&quot;,&quot;2&quot;],
[&quot;6&quot;,&quot;7&quot;,&quot;2&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;],
[&quot;1&quot;,&quot;9&quot;,&quot;8&quot;,&quot;3&quot;,&quot;4&quot;,&quot;2&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;],
[&quot;8&quot;,&quot;5&quot;,&quot;9&quot;,&quot;7&quot;,&quot;6&quot;,&quot;1&quot;,&quot;4&quot;,&quot;2&quot;,&quot;3&quot;],
[&quot;4&quot;,&quot;2&quot;,&quot;6&quot;,&quot;8&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;9&quot;,&quot;1&quot;],
[&quot;7&quot;,&quot;1&quot;,&quot;3&quot;,&quot;9&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;5&quot;,&quot;6&quot;],
[&quot;9&quot;,&quot;6&quot;,&quot;1&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;],
[&quot;2&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;6&quot;,&quot;3&quot;,&quot;5&quot;],
[&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;2&quot;,&quot;8&quot;,&quot;6&quot;,&quot;1&quot;,&quot;7&quot;,&quot;9&quot;]]&lt;/p&gt;&lt;p&gt;解释：输入的数独如上图所示，唯一有效的解决方案如下所示：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdEBIWkuU13StdgDqqwE4icwpKSMhPGUsLggUmvaEKZc4WKsOPILnwsMDP4xS1EUD7KyCtJYvUYdHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;250&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提示：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;board.length == 9&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;board[i].length == 9&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;board[i][j] 是一位数字或者 &#x27;.&#x27;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;题目数据 保证 输入数独仅有一个解&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡 思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题可以说是N皇后问题的plu版本了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题矩阵的长度和宽度都比N皇后更长更宽。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且判断重复也更难：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先大概画一棵抽象树：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.547085201793722&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdEBIWkuU13StdgDqqwE4icws5j1PJRibtsa0S9tPqTlI333Nb6LjPu9D7trvgiaSvib6IQ3Ug8TRwnug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;figcaption&gt;数独抽象树&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个图画起来太麻烦了，差不多就那个意思，接下来我们三部曲走起[1]。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为解数独找到一个符合的条件就返回，所以返回值用boolean类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以不用终止条件，因为&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要一个两个循环套着的递归，一个循环棋盘的行，一个循环棋盘的列，递归遍历这个位置放9个数字的可能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;🖊 代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;solveSudoku&lt;/span&gt;&lt;span&gt;(&lt;span&gt;char&lt;/span&gt;[][] board)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        backtrack(board);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;backtrack&lt;/span&gt;&lt;span&gt;(&lt;span&gt;char&lt;/span&gt;[][] board)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//遍历行&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; row = &lt;span&gt;0&lt;/span&gt;; row &amp;lt; board.length; row++) {&lt;br/&gt;            &lt;span&gt;//遍历列&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; col = &lt;span&gt;0&lt;/span&gt;; col &amp;lt; board[&lt;span&gt;0&lt;/span&gt;].length; col++) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (board[row][col] != &lt;span&gt;&#x27;.&#x27;&lt;/span&gt;) &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;//尝试1-9&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;char&lt;/span&gt; k = &lt;span&gt;&#x27;1&#x27;&lt;/span&gt;; k &amp;lt;= &lt;span&gt;&#x27;9&#x27;&lt;/span&gt;; k++) {&lt;br/&gt;                    &lt;span&gt;//不满足，跳过&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (!isValid(board, row, col, k)) &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;                    &lt;span&gt;//满足要求操作&lt;/span&gt;&lt;br/&gt;                    board[row][col] = k;&lt;br/&gt;                    &lt;span&gt;//找到一组，立即返回&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (backtrack(board)) {&lt;br/&gt;                        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;                    }&lt;br/&gt;                    &lt;span&gt;//回溯，撤销填入&lt;/span&gt;&lt;br/&gt;                    board[row][col] = &lt;span&gt;&#x27;.&#x27;&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;//9个数试完了，不行，返回false&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//判断是否符合数独要求&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isValid&lt;/span&gt;&lt;span&gt;(&lt;span&gt;char&lt;/span&gt;[][] board, &lt;span&gt;int&lt;/span&gt; row, &lt;span&gt;int&lt;/span&gt; col, &lt;span&gt;char&lt;/span&gt; val)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//判断行是否重复&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;9&lt;/span&gt;; i++) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (board[row][i] == val) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//判断列是否重复&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;9&lt;/span&gt;; j++) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (board[j][col] == val) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//判断小9宫格是否重复&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; startRow = (row / &lt;span&gt;3&lt;/span&gt;) * &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; startCol = (col / &lt;span&gt;3&lt;/span&gt;) * &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = startRow; i &amp;lt; startRow + &lt;span&gt;3&lt;/span&gt;; i++) {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = startCol; j &amp;lt; startCol + &lt;span&gt;3&lt;/span&gt;; j++) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (board[i][j] == val) {&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着顺口溜总结：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.72&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdEBIWkuU13StdgDqqwE4icwvYRd9KpwWj3vXEeqLPgvBWMzpzVDhOX8k8wktzBAM3pt41icBM5hO9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;650&quot;/&gt;&lt;figcaption&gt;总结&lt;/figcaption&gt;&lt;/figure&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;简单的事情重复做，重复的事情认真做，认真的事情有创造性地做。&lt;/p&gt;&lt;p&gt;&lt;code&gt;点赞&lt;/code&gt;、&lt;code&gt;关注&lt;/code&gt;、&lt;code&gt;收藏&lt;/code&gt;一键三连，鼓励我继续输出精彩博文！&lt;/p&gt;&lt;/blockquote&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[1]. https://github.com/youngyangyang04/leetcode-master&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;[2]. https://labuladong.gitbook.io&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;[3]. https://leetcode-cn.com/problems/restore-ip-addresses/solution/hui-su-suan-fa-hua-tu-fen-xi-jian-zhi-tiao-jian-by/&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODE5ODM0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeFt08hV3N1706WTzfhoTNoXm5LXRV0XibppmeNR4zSNMa3QOJJ7ib4O21P5yohibwuD26Tp9ETWZAqA/0?wx_fmt=png&quot; data-nickname=&quot;三分恶&quot; data-alias=&quot;Fighter3FullStack&quot; data-signature=&quot;一个全栈开发。分享Java后端、Web前端、计算机基础知识。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.46524064171123&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWe5pYXdPIhvzGPvSJFMmpic7B3iaybof4cMXsJ5glJ2sXvgSvyiaWVPw2hVUP6e1yDeIR8hR3HMbgX5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2244&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-recommend-type=&quot;list-title&quot; data-mpa-template=&quot;t&quot; data-recommend-tid=&quot;7&quot; data-mid=&quot;&quot; data-from=&quot;yb-recommend&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;往期推荐&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;7&quot; data-recommend-article-id=&quot;2247486836_1&quot; data-recommend-article-time=&quot;1626365912&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWdkFHwTZ52CGtmPON2vpU1iagQj7zKJa4blSPkV6hCIGrrwMcqIHAINaohXl9GvKPYgXosuEzlu7EQ/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;刷算法，这些api不可不知！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247486836&amp;amp;idx=1&amp;amp;sn=b0a6b713fa3d1419cd55d7660a670ac7&amp;amp;chksm=c0cce5d1f7bb6cc7ab673e2b7cd627b6e19fd59faad5504aedbf971dda123a72e663f180c051#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247486836&amp;amp;idx=1&amp;amp;sn=b0a6b713fa3d1419cd55d7660a670ac7&amp;amp;chksm=c0cce5d1f7bb6cc7ab673e2b7cd627b6e19fd59faad5504aedbf971dda123a72e663f180c051&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;刷算法，这些api不可不知！&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;7&quot; data-recommend-article-id=&quot;2247486924_1&quot; data-recommend-article-time=&quot;1627241592&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWe4GicKVz2z1Cs2GePCSHgw6MbTsvVXYEwsa9w9db4EBULoEJ1kqDUJOI0OnM8EzicrUMpaywb9BZRA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;LeetCode通关：听说链表是门槛，这就抬脚跨门而入&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247486924&amp;amp;idx=1&amp;amp;sn=d1c54987e2b3de7156942ed6193f0424&amp;amp;chksm=c0cce569f7bb6c7f1b33a620af470db2a3d915e4c58aea95284c950707eefdaf1d6ff185ffae#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247486924&amp;amp;idx=1&amp;amp;sn=d1c54987e2b3de7156942ed6193f0424&amp;amp;chksm=c0cce569f7bb6c7f1b33a620af470db2a3d915e4c58aea95284c950707eefdaf1d6ff185ffae&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;LeetCode通关：听说链表是门槛，这就抬脚跨门而入&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;7&quot; data-recommend-article-id=&quot;2247487018_1&quot; data-recommend-article-time=&quot;1628002219&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWczrI8OicHfRgQJ1HEXncB5fT1CjnzHDSZaHKhzEfTo2ibuoXRjzhN7hZAjPCIXRBKLc1OI4g1KxDMg/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;LeetCode通关：求次数有妙招，位运算三连&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247487018&amp;amp;idx=1&amp;amp;sn=114e38973e267a826373ea88da1acb9f&amp;amp;chksm=c0cce68ff7bb6f99c5307fd20beb708c21c8ac77bd7446f07f1d28e69450cc3a05e32b7febee#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247487018&amp;amp;idx=1&amp;amp;sn=114e38973e267a826373ea88da1acb9f&amp;amp;chksm=c0cce68ff7bb6f99c5307fd20beb708c21c8ac77bd7446f07f1d28e69450cc3a05e32b7febee&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;LeetCode通关：求次数有妙招，位运算三连&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;7&quot; data-recommend-article-id=&quot;2247487265_1&quot; data-recommend-article-time=&quot;1628344028&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWc4p9vRxzlOXvvpv5jErCaDxFeqWXebkRd9USFr49l04cHBBtT3QboguibAkrmfuXJEMccNJTelagw/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;LeetCode通关：数组十七连，真是不简单&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247487265&amp;amp;idx=1&amp;amp;sn=c8827a0010e265b0138f9cae8100677e&amp;amp;chksm=c0cce784f7bb6e92548f74624007f2e2cf807413742784d1ac2622da0a9b3c034ec0374367df#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247487265&amp;amp;idx=1&amp;amp;sn=c8827a0010e265b0138f9cae8100677e&amp;amp;chksm=c0cce784f7bb6e92548f74624007f2e2cf807413742784d1ac2622da0a9b3c034ec0374367df&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;LeetCode通关：数组十七连，真是不简单&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;7&quot; data-recommend-article-id=&quot;2247487326_1&quot; data-recommend-article-time=&quot;1628694357&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWe9icA5cics89HaOibaYYVM41XIVDhaWtJKxsiaicgDX5ialTJOhpDOuwh9ibqIZXj579LgxDTF7Dhwq6gPQ/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;LeetCode通关：哈希表六连，这个还真有点简单&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247487326&amp;amp;idx=1&amp;amp;sn=b0176cbeea3ac5545187f4e1c4a8625d&amp;amp;chksm=c0cce7fbf7bb6eedaefc17ada8aa04a585b1b7a26021e18ffa42ca804744b5a878a448a73573#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247487326&amp;amp;idx=1&amp;amp;sn=b0176cbeea3ac5545187f4e1c4a8625d&amp;amp;chksm=c0cce7fbf7bb6eedaefc17ada8aa04a585b1b7a26021e18ffa42ca804744b5a878a448a73573&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;LeetCode通关：哈希表六连，这个还真有点简单&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;7&quot; data-recommend-article-id=&quot;2247487407_1&quot; data-recommend-article-time=&quot;1629438806&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWdFPI3gX8EpCBVJq2rdatkOs0gCKMKiaueHT9xrkNe35VRKeEb6ZFK93fWP7fiakyMN7yLxOv9s1ibqw/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;LeetCode通关：栈和队列六连，匹配问题有绝招&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247487407&amp;amp;idx=1&amp;amp;sn=6fb7a9cdacd52137e9111ab94f26f886&amp;amp;chksm=c0cce70af7bb6e1c1b0a9ca0174477de1d46e47d43f7bc2144f81a3ef10aa368994c3275223a#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247487407&amp;amp;idx=1&amp;amp;sn=6fb7a9cdacd52137e9111ab94f26f886&amp;amp;chksm=c0cce70af7bb6e1c1b0a9ca0174477de1d46e47d43f7bc2144f81a3ef10aa368994c3275223a&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;LeetCode通关：栈和队列六连，匹配问题有绝招&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;7&quot; data-recommend-article-id=&quot;2247487745_1&quot; data-recommend-article-time=&quot;1630634861&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaopROFrCWpYEmfF9G730wOWguhDQTlETYl1aiaTviaoQJVQ3x7e02iaTAg/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;LeetCode通关：连刷三十九道二叉树，刷疯了！四万字长文搞定二叉树，建议收藏！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247487745&amp;amp;idx=1&amp;amp;sn=59253166e2a9aa69e633e3155e9fa98c&amp;amp;chksm=c0ccf9a4f7bb70b2023e575b72a9d3e110819817c93a79944e3b2119d993e9fedc3a01594d81#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247487745&amp;amp;idx=1&amp;amp;sn=59253166e2a9aa69e633e3155e9fa98c&amp;amp;chksm=c0ccf9a4f7bb70b2023e575b72a9d3e110819817c93a79944e3b2119d993e9fedc3a01594d81&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;LeetCode通关：连刷三十九道二叉树，刷疯了！四万字长文搞定二叉树，建议收藏！&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1b9914e21ffb5f88a78f43c17fe4bc57</guid>
<title>实现 LFU 缓存机制</title>
<link>https://toutiao.io/k/dpr059r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;前言&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言即废话。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上次介绍实现 LRU 缓存机制的时候还是在上次的时候。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次介绍下 LFU 缓存机制。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;LFU&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;LFU&lt;/code&gt;, Least Frequently Used，即最不经常使用，当容量不足时，优先淘汰最不频繁使用的数据。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;核心方法&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要记录存储以下几项&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;每个 &lt;code&gt;key&lt;/code&gt; 对应的 value&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个 &lt;code&gt;key&lt;/code&gt; 对应的访问频率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个频率大小对应的 &lt;code&gt;key&lt;/code&gt; 列表，且保持有序，当频率相同时优先淘汰最早加入的元素&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当前最小的访问频率 &lt;code&gt;minFreq&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;key-value&lt;/code&gt; 、&lt;code&gt;key-freq&lt;/code&gt; 、&lt;code&gt;freq-keylist&lt;/code&gt; 使用时间复杂度 O(1) 的哈希表存储&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;keylist&lt;/code&gt; 使用 LinkedHashSet 存储&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;1、get (key)&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当对某个 &lt;code&gt;key&lt;/code&gt; 进行访问时&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果存在，则将 &lt;code&gt;key-freq&lt;/code&gt; 对应的频率 &lt;code&gt;+1&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 &lt;code&gt;key&lt;/code&gt; 从 &lt;code&gt;freq-keylist&lt;/code&gt; 对应原频率中移除，加入到 &lt;code&gt;freq + 1&lt;/code&gt; 的 keylist 中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果需要，更新最小频率 &lt;code&gt;minFreq&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2、put (key, value)&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当添加一个元素时&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果 &lt;code&gt;key&lt;/code&gt; 存在，则覆盖 &lt;code&gt;value&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将 &lt;code&gt;key-freq&lt;/code&gt; 对应的频率 &lt;code&gt;+1&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 &lt;code&gt;key&lt;/code&gt; 从 &lt;code&gt;freq-keylist&lt;/code&gt; 对应原频率中移除，加入到 &lt;code&gt;freq + 1&lt;/code&gt; 的 keylist 中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果需要，更新最小频率 &lt;code&gt;minFreq&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;如果 &lt;code&gt;key&lt;/code&gt; 不存在&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;添加至 &lt;code&gt;key-value&lt;/code&gt; 中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置 &lt;code&gt;key-freq&lt;/code&gt; 对应的频率为 1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 &lt;code&gt;key&lt;/code&gt; 加入到 freq = 1 的 keylist 中&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;如果容量不足时，则获取 freq = minFreq 的 keylist，并删除加入最久的元素&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从  &lt;code&gt;freq-keylist&lt;/code&gt; 中移除&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从 &lt;code&gt;key-freq&lt;/code&gt; 中移除&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从  &lt;code&gt;key-value&lt;/code&gt; 中移除&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;此次移除并不需要更新 minFreq，因为移除操作一定发生在新加元素场景，minFreq 会被置为 1&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;代码实现&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;class LFUCache {&lt;br/&gt;&lt;br/&gt;    private HashMap&amp;lt;Integer,Integer&amp;gt; kv = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    //每个 key 对应的访问次数&lt;br/&gt;    private HashMap&amp;lt;Integer,Integer&amp;gt; kf = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    //每个访问次数，对应的 key ,可能是多个，要有序，以便删除最旧的数据&lt;br/&gt;    private HashMap&amp;lt;Integer, LinkedHashSet&amp;lt;Integer&amp;gt;&amp;gt; fk = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    private int minFreq;&lt;br/&gt;&lt;br/&gt;    private int capacity;&lt;br/&gt;&lt;br/&gt;    public LFUCache(int capacity) {&lt;br/&gt;        this.capacity = capacity;&lt;br/&gt;        minFreq = 0;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    public int get(int key) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!kv.containsKey(key)) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; -1;&lt;br/&gt;        }&lt;br/&gt;        int val = kv.get(key);&lt;br/&gt;        incrFreq(key);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; val;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    public void put(int key, int value) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (capacity == 0) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (kv.containsKey(key)) {&lt;br/&gt;            kv.put(key, value);&lt;br/&gt;            incrFreq(key);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (kv.size() == capacity) {&lt;br/&gt;            //删除最久未使用的&lt;br/&gt;            LinkedHashSet&amp;lt;Integer&amp;gt; &lt;span&gt;set&lt;/span&gt; = fk.get(minFreq);&lt;br/&gt;            int oldestKey = set.iterator().next();&lt;br/&gt;            set.remove(oldestKey);&lt;br/&gt;            kf.remove(oldestKey);&lt;br/&gt;            kv.remove(oldestKey);&lt;br/&gt;        }&lt;br/&gt;         kv.put(key, value);&lt;br/&gt;         incrFreq(key);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    private void incrFreq(int key) {&lt;br/&gt;        // 增加访问次数&lt;br/&gt;        addAccessTime(key);&lt;br/&gt;        // 访问次数对应 keys 更新&lt;br/&gt;        updateAccessMap(key);&lt;br/&gt;        // 最小访问次数&lt;br/&gt;        updateMinFreq(key);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    private void updateMinFreq(int key) {&lt;br/&gt;        int freq = kf.get(key);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (minFreq == 0) {&lt;br/&gt;            minFreq = freq;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (freq &amp;lt;= minFreq) {&lt;br/&gt;            minFreq = freq;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            LinkedHashSet&amp;lt;Integer&amp;gt; &lt;span&gt;set&lt;/span&gt; = fk.get(minFreq);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;set&lt;/span&gt; == null || set.size() == 0) {&lt;br/&gt;                minFreq = freq;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    private void addAccessTime(int key) {&lt;br/&gt;        int freq = kf.getOrDefault(key, 0) + 1;&lt;br/&gt;        kf.put(key, freq);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    private void updateAccessMap(int key) {&lt;br/&gt;        int freq = kf.get(key);&lt;br/&gt;        removeFkMap(key, freq - 1);&lt;br/&gt;        updateFkMap(key, freq);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    private void removeFkMap(int key, int freq) {&lt;br/&gt;        LinkedHashSet&amp;lt;Integer&amp;gt; f2kSet = fk.get(freq);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (f2kSet == null || f2kSet.size() == 0) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        f2kSet.remove(key);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    private void updateFkMap(int key, int freq) {&lt;br/&gt;        LinkedHashSet&amp;lt;Integer&amp;gt; f2kSet = fk.get(freq);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (f2kSet == null) {&lt;br/&gt;            LinkedHashSet&amp;lt;Integer&amp;gt; &lt;span&gt;set&lt;/span&gt; = new LinkedHashSet&amp;lt;&amp;gt;();&lt;br/&gt;            set.add(key);&lt;br/&gt;            fk.put(freq, &lt;span&gt;set&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            f2kSet.add(key);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LFU 算法也常被用于缓存淘汰的策略，例如在 Redis 缓存淘汰策略中就有 LFU 的方式。相较于 LRU 算法，LFU 算法更复杂，针对以上代码实现中每次操作就需要维护 3 个映射表和最小频率值。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>385654db86af84fcd371ed3d176fd928</guid>
<title>最近面试小心被问 Dubbo 3.0</title>
<link>https://toutiao.io/k/dwx82wq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近不是 Dubbo3.0 正式发布了嘛，我也推了阿里巴巴中间件发的那篇文章，但是私下还是有小伙伴让我用大白话说说和之前版本到底有哪些不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天这篇就来唠唠。对了，最近面试的小伙伴要小心被问这些新的特性或者版本，面试官用来考察你是不是“紧跟潮流”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就像之前我写的 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkxNTE3NjQ3MA==&amp;amp;mid=2247489047&amp;amp;idx=1&amp;amp;sn=ac16366e70fce619409360a972562f28&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Kafka 抛弃 ZooKeeper 一样&lt;/a&gt;，这种热点很容易在当下被问，特别是当候选人对相关知识点说的头头是道时，有能力的面试官会问你新的版本或者特性，一问三不知，很大程度表明你前面哪些说的就是背的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于 Dubbo3 的很多细节我还没深入研究，所以这篇先说说大方向上的东西。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Dubbo3 主基调，云原生&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先&lt;span&gt;什么是云原生&lt;/span&gt; ？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CNCF（云原生计算基金会） 定义如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式API。&lt;br/&gt;这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单说就是服务上云，然后基于云提供的一些容器、服务网格、不可变基础设施来&lt;span&gt;隐藏分布式架构的复杂度，将一些非业务关键技术下沉&lt;/span&gt;，使得复杂的非业务的开发从程序员手中解放出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可能还不是很清晰，我拿&lt;span&gt;应用之间的通信，这个非功能性需求的发展&lt;/span&gt;来举个例子：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在最早期的时候通信是和业务耦合在一起的，由业务开发来编写通信和业务代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来就把这些通信相关的代码抽离出来，成为一个公共组件，这样业务开发们不需要编写和维护通信相关代码，只需要调用这个公共组件即可，公共组件由专门的组件开发人员来负责。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，虽说我们业务程序员不需要开发这些公共组件，但是使用上还是有成本的，我们需要了解公共组件的一些接口特性，并且引入使用它们。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以就想着把这些公共组件再剥离出来，使之不与业务应用所处同一个进程，&lt;span&gt;让它对业务完全透明(当然有些还是需要引入轻sdk的)，这个其实就叫边车代理&lt;/span&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8583333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nE7Ip8C8LdYib4Wic2CfXAKdpjAibsI7tt1Cjx92GdSj8QdfQ0XoCcuQ6RicGXiaFKicHVsrPBQiabgra47w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在原来的车旁边挂个斗，这就是边车啦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由边车来进行透明可靠的通信，并进行路由、限流、容错等等&lt;/span&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4852459016393443&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nE7Ip8C8LdYib4Wic2CfXAKdpd8zBgicMqDIBibAYaiaiaza1ucNVXasvxkXxYrEQK65YfesMdufIfwfLaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;915&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是呢，如果服务多了边车也会贼多，运维人员肯定顶不住分管这么多边车，所以需要把边车代理统一管理，也就是&lt;span&gt;需要有个代理管理器来管理这些边车&lt;/span&gt;，所以就组成了以下这幅图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.84&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nE7Ip8C8LdYib4Wic2CfXAKdp4pSiaaHowIJ67I5fXVc7icxOs6UfibYzchD433xJHEyRfOy048l8jUezA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;400&quot;/&gt;&lt;figcaption&gt;图来自philcalcado.com&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的架构其实就是服务网格 (Service Mesh)，也称之为微服务3.0版本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而以上的服务网格功能由云来提供，类似这样的基础能力下沉到云上，我们平日就开发业务，其他的啥都不用管，应用直接扔到云上，便拥有了以往需要自行编程的超多非功能需求的能力，这就是云原生的目的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，想必你已经明白了什么叫云原生，而 Dubbo3 的口号就是全面拥抱云原生，下一代发展的方向呀，必须得跟上!&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 Dubbo3 主基调就是在不改变之前实践的前提下，遵循云原生的思想，使 Dubbo 能更好的复用云原生所提供的基础能力，抱紧时代的大腿。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们来看看 Dubbo3 做了哪些升级吧。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Dubbo 与容器生命周期对齐&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;有些同学可能对容器、K8S这块不太熟悉，没关系，我就简略讲下，阅读应该没啥障碍。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;云原生的发展离不开近年来容器和容器编排的起飞，K8S公认的容器调度平台一哥，而 Dubbo 想要融入云原生，就必须得支持 K8S 的调度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pod 的生命周期与服务调度相关，Kubernetes 底层基础设施定义了严格的组件生命周期事件(probe)，所以 Dubbo 首先得做到生命周期的对齐。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;Pod 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于 Dubbo 的 SPI 机制，内部实现了多种探针，基于 Dubbo QOS 运维模块的 HTTP 服务，使容器探针能够获取到应用内对应探针的状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大白话说&lt;/span&gt;就是通过实现探针让容器知道 Dubbo 现在是否存活着、是否处于就绪状态，还有启动时的检测等，这几个状态是需要被 K8S 知道的，这样 K8S 才可以跟踪容器不同的状态来管理和编排 Pod。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上的操作，高级点就叫生命周期的对齐咯。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Kubernetes Service&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道 Dubbo 有注册中心，比如用 Zookeeper 来实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是 K8S 自己有一套机制， K8S 为 Pods 提供自己的 IP 地址，并为一组 Pod 提供相同的 DNS 名， 并且可以在它们之间进行负载均衡，所以用户可以不需要额外搭一个注册中心，直接用 K8S 提供的这套服务发现体系即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是通过标准的 Kubernetes Service API 定义来进行服务定义与注册，这样把非功能性需求更加下沉了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Proxyless Mesh&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从前文可知，Dubbo 接入 mesh 会有边车的存在，而 Dubbo 框架自身又有一些服务治理的功能，这部分功能和边车会有所重复。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那不好因为这个把以前实现的那些功能砍了吧？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以就搞了个 Proxyless Mesh，抛弃边车，直接让 Dubbo SDK 与控制面(Control Plane)交互。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，也有提供选择接受边车的部署的轻 SDK 模式。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;应用级服务发现&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前 Dubbo 的实现是&lt;span&gt;接口级别的服务发现&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如你现在有个用户服务，用户服务里面有 100 个接口，那么这 100 个接口都会被记录到注册中心里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设这个用户服务部署了 100 个实例，那么注册中心就有 100*100 个用户服务接口的记录，&lt;span&gt;这还只是一个服务呢&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以成百上千个服务过来，这元数据就会膨胀的夸张，注册中心和客户端的内存压力就很大，所以&lt;span&gt;这样的实现在大规模微服务架构体系下，是有瓶颈的&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以把服务发现从接口级别改为应用级别，这样可以大大降低内存的占用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.33905579399141633&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nE7Ip8C8LdYib4Wic2CfXAKdpRCp0DjPV23W3hx8Wl4AB7jq8kaPtlKoo4faqibZ4EMQn3CVOYd8PPxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;699&quot;/&gt;&lt;figcaption&gt;图来组云原生微服务大会&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图表示接口规模在平均场景和极限场景下，把服务发现粒度从接口改为应用级别，分别有 60% 和 90% 的内存优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且像 Spring Cloud 和 K8s 都是基于应用级别的注册发现，所以想要支持异构连接，就必须支持应用级别分服务发现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 3.0 版本是这样实现的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4096774193548387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nE7Ip8C8LdYib4Wic2CfXAKdpsflBRAqnJD0m0xyW5Wqia3oIpgAftjRCORH1iaGXbEnewYk0aDDpibn6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;图来组云原生微服务大会&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让注册中心只保存应用-实例的关系，接口级别的元数据弄了个元数据中心。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Triple协议&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这个我在想，之后是不是就是 quadra，然后再 penta kill ？哈哈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;言归正传，Dubbo2.0 协议在云原生时代来说，不够通用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.36612903225806454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nE7Ip8C8LdYib4Wic2CfXAKdpibY5HLkysia9XYcB3zaEB9CfvToEsEx2OyoSNNGH6FIvLFZzdnVhNEvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;620&quot;/&gt;&lt;figcaption&gt;2.0协议&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;协议头没有足够的空间容纳Mesh等网关组件(网关需要识别)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要实现，就必须完整的解析协议才能获取到所需要的调用元数据，这样性能不佳。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且生态之间不互通，别人不好解析你自定义的二进制协议，简单来说就是不够通用，其他生态也没有想法来适配一个 RPC 框架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 Dubbo 3.0 选择了 HTTP2 + Protocol Buffer 的形式来实现新的协议——Triple，也基于此丰富了请求模型，除了 Request/Response 模型，还支持 Streaming 和 Bidirectional（双向流式通信），适配了更多的场景。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结一下3.0关键几点&lt;/span&gt;：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;借助SPI实现相关探针，使得生命周期可以被容器感知，即生命周期与容器对齐。&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;接入 Kubernetes Service API，使得注册中心相关功能下沉，而不用额外利用ZK等第三方注册中心。&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;将接口级别的服务发现改成应用级别，解决了大规模微服务架构体系下，元数据膨胀的瓶颈，并对其市面常见的发现级别，便于异构的实现。&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;升级通信协议为Triple，选择了 HTTP2 + Protocol Buffer 的形式，丰富了请求模型。&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;暂时分享到这里啦，大致过了一遍，里面很多细节我还没深入研究，等我之后研究过了再出一篇细节点的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;不过，这篇虽说是粗略过一遍，但是前置知识点还是很多的，比如容器、K8S、HTTP2、Protocol Buffer等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些东西不清楚，估计 get 不到上面 Dubbo3.0 的这些点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且这些东西又不是三两句话能说清的，所以对前置知识点不清晰的小伙伴建议去查查资料，这些还是很重要的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后有时间我会写写相关的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你碰上有水平的面试官，很容易问这类新特性的问题，因为他们是在一直关注着前线的，当然这也不是决定性因素，只是能答出来会比较加分~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;https://dubbo.apache.org/zh/docs/v3.0/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://mp.weixin.qq.com/s/5loawrCyKmN4HhK1lzy0Rw&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://www.cnblogs.com/alisystemsoftware/p/13559704.html&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是yes，从一点点到亿点点，我们下篇见。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkxNTE3NjQ3MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEf5LN3Y4UErfNUkiaMseJPkdXA4xPD6Uicl8EqAJAEKVIKalU19xS41TO3aPmHK5bqbzGTwu3z92Kg/0?wx_fmt=png&quot; data-nickname=&quot;yes的练级攻略&quot; data-alias=&quot;yes_java&quot; data-signature=&quot;用接地气的话来分享一些后端技术或写一些想写的。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>521ac5ff53d3aef1c8060c12859232e3</guid>
<title>3 分钟实现 Spring Boot 集成 RabbitMQ，实现消息队列服务</title>
<link>https://toutiao.io/k/xwhru3a</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left&quot; aria-describedby=&quot;js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxMTY5NDAwOA==&amp;amp;action=getalbum&amp;amp;album_id=1340732282025623553#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;1340732282025623553&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#SpringBoot从小白到专家&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;23个&lt;span class=&quot;weui-hidden_abs&quot;&gt;内容&lt;/span&gt;&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-track=&quot;1&quot;&gt;&lt;span&gt;消息中间件在互联网公司使用的越来越多，主要用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。消息队列实现系统之间的双向解耦，生产者往消息队列中发送消息，消费者从队列中拿取消息并处理，生产者不用关心是谁来消费，消费者不用关心谁在生产消息，从而达到系统解耦的目的，也大大提高了系统的高可用性和高并发能力。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;127&quot;&gt;&lt;span&gt;接下来介绍Spring Boot对RabbitMQ的支持。如何在SpringBoot项目中使用RabbitMQ？&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;129&quot;&gt;&lt;span&gt;Spring Boot提供了spring-bootstarter-amqp组件对消息队列进行支持，使用非常简单，仅需要非常少的配置即可实现完整的消息队列服务。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-track=&quot;2&quot;&gt;&lt;span&gt;一、Spring Boot集成RabbitMQ&lt;/span&gt;&lt;/h1&gt;&lt;p data-track=&quot;3&quot;&gt;&lt;span&gt;Spring Boot提供了spring-boot-starter-amqp组件，只需要简单的配置即可与Spring Boot无缝集成。下面通过示例演示集成RabbitMQ实现消息的接收和发送。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;4&quot;&gt;&lt;span&gt;第一步，配置pom包。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;5&quot;&gt;&lt;span&gt;创建Spring Boot项目并在pom.xml文件中添加spring-bootstarter-amqp等相关组件依赖：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-amqp&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-track=&quot;10&quot;&gt;&lt;span&gt;在上面的示例中，引入Spring Boot自带的amqp组件spring-bootstarter-amqp。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;11&quot;&gt;&lt;span&gt;第二步，修改配置文件。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;12&quot;&gt;&lt;span&gt;修改application.properties配置文件，配置rabbitmq的host地址、端口以及账户信息。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;spring.rabbitmq.host&lt;/span&gt;=&lt;span&gt;10.2&lt;/span&gt;.&lt;span&gt;1.231&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;spring.rabbitmq.port&lt;/span&gt;=&lt;span&gt;5672&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;spring.rabbitmq.username&lt;/span&gt;=zhangweizhong&lt;br/&gt;&lt;br/&gt;&lt;span&gt;spring.rabbitmq.password&lt;/span&gt;=weizhong1988&lt;br/&gt;&lt;br/&gt;&lt;span&gt;spring.rabbitmq.virtualHost&lt;/span&gt;=order&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-track=&quot;18&quot;&gt;&lt;span&gt;在上面的示例中，主要配置RabbitMQ服务的地址。RabbitMQ配置由spring.rabbitmq.*配置属性控制。virtual-host配置项指定RabbitMQ服务创建的虚拟主机，不过这个配置项不是必需的。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;19&quot;&gt;&lt;span&gt;第三步，创建消费者。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;20&quot;&gt;&lt;span&gt;消费者可以消费生产者发送的消息。接下来创建消费者类Consumer，并使用@RabbitListener注解来指定消息的处理方法。示例代码如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;public class Consumer {&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@RabbitHandler&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@RabbitListener&lt;/span&gt;(queuesToDeclare = &lt;span&gt;@Queue&lt;/span&gt;(&lt;span&gt;&quot;rabbitmq_queue&quot;&lt;/span&gt;))&lt;br/&gt;public void process(String message) {&lt;br/&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;.out.println&lt;/span&gt;(&lt;span&gt;&quot;消费者消费消息111=====&quot;&lt;/span&gt; + message);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-track=&quot;31&quot;&gt;&lt;span&gt;在上面的示例中，Consumer消费者通过@RabbitListener注解创建侦听器端点，绑定rabbitmq_queue队列。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;32&quot;&gt;&lt;span&gt;（1）@RabbitListener注解提供了@QueueBinding、@Queue、@Exchange等对象，通过这个组合注解配置交换机、绑定路由并且配置监听功能等。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;33&quot;&gt;&lt;span&gt;（2）@RabbitHandler注解为具体接收的方法。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;34&quot;&gt;&lt;span&gt;第四步，创建生产者。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;35&quot;&gt;&lt;span&gt;生产者用来产生消息并进行发送，需要用到RabbitTemplate类。与之前的RedisTemplate类似，RabbitTemplate是实现发送消息的关键类。示例代码如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class Producer &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; RabbitTemplate rabbitTemplate;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public void produce() &lt;/span&gt;{&lt;br/&gt;String message = &lt;span&gt;new&lt;/span&gt; Date() + &lt;span&gt;&quot;Beijing&quot;&lt;/span&gt;;&lt;br/&gt;System.out.println(&lt;span&gt;&quot;生产者产生消息=====&quot;&lt;/span&gt; + message);&lt;br/&gt;rabbitTemplate.convertAndSend(&lt;span&gt;&quot;rabbitmq_queue&quot;&lt;/span&gt;, message);&lt;br/&gt;}&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-track=&quot;47&quot;&gt;&lt;span&gt;如上面的示例所示，RabbitTemplate提供了 convertAndSend方法发送消息。convertAndSend方法有routingKey和message两个参数：&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;48&quot;&gt;&lt;span&gt;（1）routingKey为要发送的路由地址。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;49&quot;&gt;&lt;span&gt;（2）message为具体的消息内容。发送者和接收者的queuename必须一致，不然无法接收。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;50&quot;&gt;&lt;span&gt;最后，测试验证。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;51&quot;&gt;&lt;span&gt;创建对应的测试类ApplicationTests，验证消息发送和接收是否成功。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@RunWith&lt;/span&gt;(SpringRunner.class)&lt;br/&gt;&lt;span&gt;@SpringBootTest&lt;/span&gt;&lt;br/&gt;public class ApplicationTests {&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;Producer producer;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;public void contextLoads() throws InterruptedException {&lt;br/&gt;&lt;span&gt;producer&lt;/span&gt;&lt;span&gt;.produce&lt;/span&gt;();&lt;br/&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;.sleep&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;*&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-track=&quot;63&quot;&gt;&lt;span&gt;在上面的示例中，首先注入生产者对象，然后调用produce()方法来发送消息。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;64&quot;&gt;&lt;span&gt;最后，单击Run Test或在方法上右击，选择Run &#x27;contextLoads()&#x27;，运行单元测试程序，查看后台输出情况，结果如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.13380281690140844&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/S83FNw8zib5TobmDce5SoxyRLdeps0NFqfOibMBPwrZbHmvibPSiaSHT6esA8XgyEGoUuK45y8Vrg4f3cq9bWsH7WQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;568&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过上面的程序输出日志可以看到，消费者已经收到了生产者发送的消息并进行了处理。这是常用的简单使用示例。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-track=&quot;125&quot;&gt;&lt;span&gt;二、发送和接收实体对象&lt;/span&gt;&lt;/h1&gt;&lt;p data-track=&quot;69&quot;&gt;&lt;span&gt;Spring Boot支持对象的发送和接收，且不需要额外的配置。下面通过一个例子来演示RabbitMQ发送和接收实体对象。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;70&quot;&gt;&lt;span&gt;1. 定义实体类&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;71&quot;&gt;&lt;span&gt;首先，定义发送与接收的对象实体User类，代码如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class User implements Serializable &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; String name;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; String password;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 省略get和set方法&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-track=&quot;77&quot;&gt;&lt;span&gt;在上面的示例中，定义了普通的User实体对象。需要注意的是，实体类对象必须继承Serializable序列化接口，否则会报数据无法序列化的错误。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;78&quot;&gt;&lt;span&gt;2. 定义消费者&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;79&quot;&gt;&lt;span&gt;修改Consumer类，将参数换成User对象。示例代码如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;public class Consumer {&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@RabbitHandler&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@RabbitListener&lt;/span&gt;(queuesToDeclare = &lt;span&gt;@Queue&lt;/span&gt;(&lt;span&gt;&quot;rabbitmq_queue_object&quot;&lt;/span&gt;))&lt;br/&gt;public void process(User user) {&lt;br/&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;.out.println&lt;/span&gt;(&lt;span&gt;&quot;消费者消费消息111user=====name：&quot;&lt;/span&gt; + user.getName()+&lt;span&gt;&quot;,password:&quot;&lt;/span&gt;+user.getPassword());&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-track=&quot;89&quot;&gt;&lt;span&gt;其实，消费者类和消息处理方法和之前的类似，只不过将参数换成了实体对象，监听rabbitmq_queue_object队列。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;90&quot;&gt;&lt;span&gt;3. 定义生产者&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;91&quot;&gt;&lt;span&gt;修改Producer类，定义User实体对象，并通过convertAndSend方法发送对象消息。示例代码如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class Producer &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; RabbitTemplate rabbitTemplate;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public void produce() &lt;/span&gt;{&lt;br/&gt;User user=&lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;user.setName(&lt;span&gt;&quot;weiz&quot;&lt;/span&gt;);&lt;br/&gt;user.setPassword(&lt;span&gt;&quot;123456&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(&lt;span&gt;&quot;生产者生产消息111=====&quot;&lt;/span&gt; + user);&lt;br/&gt;&lt;br/&gt;rabbitTemplate.convertAndSend(&lt;span&gt;&quot;rabbitmq_queue_object&quot;&lt;/span&gt;, user);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-track=&quot;105&quot;&gt;&lt;span&gt;在上面的示例中，还是调用convertAndSend()方法发送实体对象。convertAndSend()方法支持String、Integer、Object等基础的数据类型。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;106&quot;&gt;&lt;span&gt;4. 验证测试&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;107&quot;&gt;&lt;span&gt;创建单元测试类，注入生产者对象，然后调用produceObj()方法发送实体对象消息，从而验证消息能否被成功接收。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@RunWith&lt;/span&gt;(SpringRunner.class)&lt;br/&gt;&lt;span&gt;@SpringBootTest&lt;/span&gt;&lt;br/&gt;public class ApplicationTests {&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;Producer producer;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;public void testProduceObj() throws InterruptedException {&lt;br/&gt;&lt;span&gt;producer&lt;/span&gt;&lt;span&gt;.produceObj&lt;/span&gt;();&lt;br/&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;.sleep&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;*&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-track=&quot;121&quot;&gt;&lt;span&gt;最后，单击Run Test或在方法上右击，选择Run &#x27;contextLoads()&#x27;，运行单元测试程序，查看后台输出情况，运行结果如图12-8所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.13028169014084506&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/S83FNw8zib5TobmDce5SoxyRLdeps0NFqibSib6jPaCBxneCv8LhPvluciazShOiaYsWeCfyzjibCZqsNRve5s8hoqiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;568&quot;/&gt;&lt;/p&gt;&lt;p data-track=&quot;124&quot;&gt;&lt;span&gt;通过上面的示例成功实现了RabbitMQ发送和接收实体对象，使得消息的数据结构更加清晰，也更加贴合面向对象的编程思想。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;124&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;推荐阅读：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.0046875&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/dDbQr8u8ibicBtyke0Ybqqmyw6rQYbbf3Vr3dTfyPpzZhwDEyXrSzKkfgGPpmUry2JyNdqIhdbib2VPVTY0kKu3Ow/640?wx_fmt=jpeg&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/S83FNw8zib5SG86QE9nk7pKLJRDP6mAlcah8BXaXlr6SvKqXyEY5dok03zkicgJaFc5E0rlGkbOsA8GDBibxLKfxg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-track=&quot;124&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>