<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e713066e39d860950f7f20b1ee342522</guid>
<title>年轻人，看看 Redisson 分布式锁——可重入锁吧！太重要了</title>
<link>https://toutiao.io/k/5xy8o0x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.42734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibm2sb53lRhwia9fkSREIyu986sXHSFXMtNJACj2eYxTWol2TSsaGjuicbgYK1ldv38a4wgY2w2guj7cOKp4S0uibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h2 data-source-line=&quot;1&quot;&gt;1.引言&lt;br/&gt;&lt;/h2&gt;&lt;p data-source-line=&quot;2&quot;&gt;作为后端开发，对于所谓的线程安全、高并发等一系列名词肯定都不会陌生，相关的一些概念及技术框架是面试中的宠儿，也是工作中解决一些特定场景下的技术问题的银弹。今天我们就来聊聊这些银弹中的其中一枚——分布式锁，更确切的说是分布式锁的其中一种轮子：Redisson 的可重入锁——基于 redis 实现的分布式锁。&lt;/p&gt;&lt;p data-source-line=&quot;4&quot;&gt;俗话说得好：面试造火箭，工作拧螺丝(手动狗头)。分布式锁大家应该也都不陌生，在解决譬如分布式服务下库存超卖等类似的场景下很常见，大家也应该都学习和使用过相关的框架，或者自己实现过类似的分布式锁。但一个完备的分布式锁实现应该考虑哪些问题，如何优雅且全面的实现一个分布式锁，以及这些实现背后的原理，这些可能才是我们需要考虑的。就我而言，自己造不了火箭，但学习一下火箭是怎么造的还是蛮有意思的，说不定哪天螺丝拧多了需要自己造火箭呢。退一步讲，火箭造出来的过程也是一个个螺丝拧出来的嘛。只要屠龙刀在手，一刀 999，现在能杀鸡，将来也能宰牛, skr skr ~&lt;/p&gt;&lt;h2 data-source-line=&quot;5&quot;&gt;2.分布式锁概览&lt;/h2&gt;&lt;h3 data-source-line=&quot;6&quot;&gt;2.1 锁是干嘛的？&lt;/h3&gt;&lt;p data-source-line=&quot;7&quot;&gt;谈到锁，第一印象就是 Java 本身支持的一些加锁，不管是是 synchronized 还是并发包下 Lock 的一些实现如 ReentrantLock，更甚一些无锁机制譬如并发包下的一些原子类如 AtomicInteger，都在不同粒度上保证了线程安全。而所谓的线程实现，归根到底也就是保证共享区或者共享变量的安全而已，而聊到线程安全，立马就能联想到三个特性：&lt;/p&gt;&lt;p data-source-line=&quot;12&quot;&gt;对于 Java 语言本身的一些保证线程安全的实现如 synchronized、Lock、原子类更甚至一些在此基础上的一些线程安全的集合是如何在不同粒度上保证原子性、可见性、有序性的这里就不拆开了，也不是本篇要讨论的。更为重要的，我们回到共享资源这个概念，对于单点下的应用，为什么一提到线程安全就是三大特性，为什么这三个特性可以保证线程安全。我的通俗理解是：&lt;/p&gt;&lt;ul data-source-line=&quot;14&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;对于共享资源的加锁或者修改(原子类)是原子的，不可拆分的，那么加锁或者修改本身就要么成功要么失败，不会有中间过程的误判&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;而可见性是保证共享资源对所有线程可见，这个也没什么好解释的，只有对共享资源的任何修改都可感知，才不会在不同线程下决策不同&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;有序性的前提是多线程，单线程下的指令重排不会改变串行结果，但多线程下的指令重排下对共享区域的修改会相互干扰，所以保证多线程的有序性也是必须的&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-source-line=&quot;18&quot;&gt;加锁是手段，保证共享资源的安全才是目的，单点下 Java 是通过原子性、可见性、有序性来实现的。&lt;/p&gt;&lt;h3 data-source-line=&quot;19&quot;&gt;2.2 分布式锁需要考虑什么？&lt;/h3&gt;&lt;p data-source-line=&quot;20&quot;&gt;前面我们废话了一堆，可以看出来锁的目的：保证共享资源的安全。现在不考虑单点锁还是分布式锁：我们考虑两个问题：&lt;/p&gt;&lt;p data-source-line=&quot;25&quot;&gt;对于第一个问题，在单点情况下，我们可以共享资源是一个实例变量或者是一段对资源进行操作的代码，这些资源在不同线程下共享，而这里的线程都是在一个 JVM 进程中。那么如果是分布式系统呢？举个例子：某个商品的总库存、某个优惠券批次的总数量，这些是共享资源吗？当然是，只是这里共享这些资源的对象从一个 JVM 进程下的多个线程变成了多个服务节点下的多个 JVM 进程下的多个线程而已。下面通过两张图我们可以对比一下：&lt;/p&gt;&lt;p data-source-line=&quot;27&quot;&gt;1.单进程下共享资源&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5230998509687034&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibm2sb53lRhwAHjz5QwpZnuKtD6LuLlUVdlEpdQ8kyibbtLW5RuS0m5AHgBl3qzS7Pq0htWQtaichMFymzYnGx7QA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;671&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;31&quot;&gt;2.分布式系统下共享资源&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5793901156677181&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibm2sb53lRhwAHjz5QwpZnuKtD6LuLlUVQicN8Ad20VvkdibdA1K7DMBd2ym1OFz38xxTTGtCLlJTEpldx6qV7ibZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;951&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;35&quot;&gt;可以看出来，在单个 JVM 进程中，共享资源只是在同一进程下的不同线程共享，不管共享资源是实例变量、代码段、或者数据库的资源，所以我们可以通过单点下的原子性、有序性、可见性来保证共享资源的安全。&lt;/p&gt;&lt;p data-source-line=&quot;37&quot;&gt;而在分布式系统下，共享资源的范围就扩大到了多台机器下的多个进程中的多个线程中。那么再看一下第二个问题，在分布式系统下原子性、有序性、可见性还管用吗？或者说这三个特性在分布式系统下还有用吗？我的理解是：这三个特性是依然存在的，只是针对的对象和范围发生了变化。在单点情况下，任何共享资源都共存于同一个 JVM 进程中，共享资源状态同步的范围也只是在线程的工作内存和主内存之间而已，或者说共享资源的最终状态在主内存，而其变化状态发生在单点下的多线程的各自工作内存中，这三个特性所在的容器也只是单个 JVM 进程而已。而分布式系统下，共享资源的状态同步范围扩大了多台机器各自的进程(更细致一点是各个进程中不同的线程之间)，共享资源的最终状态最终一定要依赖于 JVM 进程外的第三方，比如数据库、任意形式的服务器等等，而共享资源的状态变化发生在多个进程下的多个线程，因此分布式下的共享资源的安全保证，不仅仅是在线程之间，也在进程之间。&lt;/p&gt;&lt;h3 data-source-line=&quot;38&quot;&gt;2.3 分布式锁要提供的最基础的能力&lt;/h3&gt;&lt;p data-source-line=&quot;39&quot;&gt;当然，前面一段理解可能有点过于冗繁，也可以说：分布式系统下整个服务集群是一个大容器，状态的同步范围在集群服务所有的线程之间，只是这些线程的交互不再只是通过单机的缓存一致性协议(如 MESI 协议等)，而是扩大到了端到端的通信即网络交互，而共享资源的直接宿主也在第三方譬如其他服务、数据库等。那这时候这三个特性的范围如果也相应的扩大到集群线程之间，那共享资源的安全自然也是能够保证的。当然，这么说可能不太严谨，因为我也没在相关的资料上看到过有人在分布式系统之间使用原子性、有序性、可见性来说明分布式系统的多线程安全，这是只是借鉴思想，大家如果感觉名词不够专业，轻喷。&lt;/p&gt;&lt;p data-source-line=&quot;41&quot;&gt;前面简单讨论了分布式系统下的共享资源以及保证线程安全的三个特性，我们考虑一下如何才能在分布式系统这个大容器下保证这三个特性，或者说如何在分布式系统下加锁？首先，锁的共享范围必然是要和要保护的资源一致的，在单点下共享资源就在单个 JVM 进程中，那么锁依靠 JVM 中的一些手段也就足够了，比如 synchronized、Lock、原子类(当然这个是无锁的)等。而在分布式系统下，锁的生存范围必然是和集群节点平级的，要不然各个节点各自用自己的锁，大家对于对方的锁根本不认识也无法交流那岂不是乱掉了。所以分布式锁必须独立于各个节点之外，比如借助 redis、zookeeper 等实现，当然，本篇我们讨论的是 redis 的分布式锁，但我认为前面的思想是通用的，哪怕不用 redis、zookeeper 也可以实现，只是实现方式、效率等方面有所差异。即分布式锁最起码要实现进程间共享(这里的共享是指在不同进程间是一套，而不是说可以同时持有)，并且能够保证共享资源的原子性、有序性、可见性。&lt;/p&gt;&lt;p data-source-line=&quot;43&quot;&gt;这里多说一点，由于分布式锁宿主在 JVM 进程之间，各个进程加锁以及同步是通过端到端的进程通信，那么此时分布式系统下的可见性、有序性是自然满足的。首先可见性很好理解，因为共享资源的获取本身就是服务与服务间的通信，可见性的粒度也应该在服务，只要共享资源发生改变，任何一个服务都可以查询到(不要说事务什么的，我觉得这里共享资源的状态同步应该是在事务的上层来看)。而有序性也是在分布式锁的前提下，不同服务之间对于共享资源的变更也变成了时间上是串行的，那么也自然满足的，当然这里会有性能的牺牲。那么原子性呢？我理解这里的原子性是靠分布式锁的获取等来保证的，只要加锁、释放等是原子的，那么锁所保护的资源(或操作)对于同级的操作就是一个原子的。&lt;/p&gt;&lt;h3 data-source-line=&quot;45&quot;&gt;2.4 分布式锁还要考虑什么？&lt;/h3&gt;&lt;p data-source-line=&quot;46&quot;&gt;前面讨论了分布式锁怎么保证共享资源的安全，但是由于分布式锁宿主在譬如 redis、zookeeper 等中间件中，加锁、释放、锁续期等也是在进程与 redis 之间通信，那么就引出了一些单点加锁不存在的问题：那就是服务如果宕机了怎么办？或者加锁是有时间的，如果时间过了持有锁的任务还没有完成怎么办？这时候看起来就像下图可能出现的情况&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5704607046070461&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibm2sb53lRhwAHjz5QwpZnuKtD6LuLlUVyDWsUIHeaSgOE78zFymgbuclzziaelXJticA14wpgZkdOUaRbVvIgaRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;738&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;50&quot;&gt;出现这些问题的原因是虽然我们将分布式系统和锁的宿主看作一个大的通信系统，但其却是离散的，离散的节点自身可能存活、死亡等，在单个离散节点不存在时，其持有的锁却可能仍在另外一个离散节点存在(这里指的是依靠 redis 实现的分布式锁)，那么对于其他节点来说锁也就永远无法获取了。反过来，如果持有锁的离散的服务节点对于共享资源的操作还没有完成，Redis 由于锁的时间到期而释放锁，那么其他的服务节点就可以获取到本不该获取的锁了，这时候共享资源必然是不安全的。而这些在单个进程中的锁不会存在，因为单进程下的锁、线程、资源都在一个容器即 JVM 进程中，JVM 进程死掉的话这些也就一起死掉了，自然也不会存在之前说的问题。可见，分布式锁不仅要维护共享资源的安全，还要维护锁自身在不同进程下的安全问题。&lt;/p&gt;&lt;h2 data-source-line=&quot;51&quot;&gt;3. redis 分布式锁的一种实现—— Redisson 的可重入锁&lt;/h2&gt;&lt;h3 data-source-line=&quot;52&quot;&gt;3.1 如何使用 Redisson 的分布式锁&lt;/h3&gt;&lt;p data-source-line=&quot;53&quot;&gt;写到这里，我觉得前面的文字铺垫的太多了，代码和图片太少了，但对我个人而言我觉得会使用分布式锁没有什么太大的意义，所以我前面还是坚持写了一些冗繁的废话。那么，我们先看一下如何最简单的使用 Redisson 的分布式锁吧，毕竟 Talk is cheap,show me the code !&lt;/p&gt;&lt;pre data-source-line=&quot;54&quot;&gt;&lt;code&gt;&lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; RedissonClient redisson;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String LOCK_PREFIX = &lt;span&gt;&quot;my:lock:&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;redis/lock/{seq}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;(@PathVariable String seq)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    RLock lock = redisson.getLock(LOCK_PREFIX + seq);&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; lockSuccess = lock.tryLock(&lt;span&gt;5&lt;/span&gt;, TimeUnit.SECONDS);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (lockSuccess) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;get lock success&quot;&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;get lock fail&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        TimeUnit.SECONDS.sleep(&lt;span&gt;15&lt;/span&gt;);&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;        e.printStackTrace();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; seq + &lt;span&gt;&quot; mission dead&quot;&lt;/span&gt;;&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        lock.unlock();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; seq + &lt;span&gt;&quot; mission completed&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; RedissonClient &lt;span&gt;redissonClient&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Config config = &lt;span&gt;new&lt;/span&gt; Config();&lt;br/&gt;    &lt;span&gt;// &lt;span&gt;单点模式&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    config.useSingleServer()&lt;br/&gt;            .setAddress(&lt;span&gt;&quot;redis://127.0.0.1:6379&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;// &lt;span&gt;集群模式&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;/*config.useClusterServers()&lt;br/&gt;            .addNodeAddress(&quot;redis://127.0.0.1:7000&quot;)&lt;br/&gt;            .addNodeAddress(&quot;redis://127.0.0.1:7001&quot;)&lt;br/&gt;            .addNodeAddress(&quot;redis://127.0.0.1:7002&quot;)&lt;br/&gt;            .addNodeAddress(&quot;redis://127.0.0.1:7003&quot;)&lt;br/&gt;            .addNodeAddress(&quot;redis://127.0.0.1:7004&quot;)&lt;br/&gt;            .addNodeAddress(&quot;redis://127.0.0.1:7005&quot;);*/&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Redisson.create(config);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;99&quot;&gt;Redisson 实现的分布式锁的使用就是这么简单，这个也没什么好说的，我们公司的不少服务应该也都有过使用，就我接触到的有兑换券、优惠券等。下面我们就基于这段简单的代码来理解一下 Redisson 的分布式锁是如何实现的。&lt;/p&gt;&lt;h3 data-source-line=&quot;100&quot;&gt;3.1 RedissonClient：同 redis 通信的组件&lt;/h3&gt;&lt;pre data-source-line=&quot;101&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Redisson&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;RedissonClient&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; {&lt;br/&gt;        RedissonObjectFactory.warmUp();&lt;br/&gt;        RedissonReference.warmUp();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; QueueTransferService queueTransferService = &lt;span&gt;new&lt;/span&gt; QueueTransferService();&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; EvictionScheduler evictionScheduler;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ConnectionManager connectionManager;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ConcurrentMap&amp;lt;Class&amp;lt;?&amp;gt;, Class&amp;lt;?&amp;gt;&amp;gt; liveObjectClassCache = PlatformDependent.newConcurrentHashMap();&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Config config;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SemaphorePubSub semaphorePubSub = &lt;span&gt;new&lt;/span&gt; SemaphorePubSub();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ConcurrentMap&amp;lt;String, ResponseEntry&amp;gt; responses = PlatformDependent.newConcurrentHashMap();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;Redisson&lt;/span&gt;&lt;span&gt;(Config config)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.config = config;&lt;br/&gt;        Config configCopy = &lt;span&gt;new&lt;/span&gt; Config(config);&lt;br/&gt;&lt;br/&gt;        connectionManager = ConfigSupport.createConnectionManager(configCopy);&lt;br/&gt;        evictionScheduler = &lt;span&gt;new&lt;/span&gt; EvictionScheduler(connectionManager.getCommandExecutor());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; EvictionScheduler &lt;span&gt;getEvictionScheduler&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; evictionScheduler;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; CommandExecutor &lt;span&gt;getCommandExecutor&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; connectionManager.getCommandExecutor();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ConnectionManager &lt;span&gt;getConnectionManager&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; connectionManager;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Create sync/async Redisson instance with default config&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; Redisson instance&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; RedissonClient &lt;span&gt;create&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Config config = &lt;span&gt;new&lt;/span&gt; Config();&lt;br/&gt;        config.useSingleServer()&lt;br/&gt;        .setTimeout(&lt;span&gt;1000000&lt;/span&gt;)&lt;br/&gt;        .setAddress(&lt;span&gt;&quot;redis://127.0.0.1:6379&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;//        config.useMasterSlaveConnection().setMasterAddress(&quot;127.0.0.1:6379&quot;).addSlaveAddress(&quot;127.0.0.1:6389&quot;).addSlaveAddress(&quot;127.0.0.1:6399&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//        config.useSentinelConnection().setMasterName(&quot;mymaster&quot;).addSentinelAddress(&quot;127.0.0.1:26389&quot;, &quot;127.0.0.1:26379&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//        config.useClusterServers().addNodeAddress(&quot;127.0.0.1:7000&quot;);&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; create(config);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Create sync/async Redisson instance with provided config&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; config for Redisson&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; Redisson instance&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; RedissonClient &lt;span&gt;create&lt;/span&gt;&lt;span&gt;(Config config)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Redisson redisson = &lt;span&gt;new&lt;/span&gt; Redisson(config);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (config.isReferenceEnabled()) {&lt;br/&gt;            redisson.enableRedissonReferenceSupport();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; redisson;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; RLock &lt;span&gt;getLock&lt;/span&gt;&lt;span&gt;(String name)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RedissonLock(connectionManager.getCommandExecutor(), name);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// &lt;span&gt;省略巴拉巴拉&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;177&quot;&gt;不得不说，这段代码复制粘贴的是有点臭长啊，毕竟 CV 工程师，哈哈。总结起来就是一句话：Redisson 类是 RedissonClient 的实现，封装了一些配置、同 redis 的连接管理、一些定时任务、发布订阅组件等，另外提供一些获取 Redisson 基于 Redis 实现的分布式锁、分布式集合、分布式信号量等接口方法，比如我们的分布式锁-可重入锁。&lt;/p&gt;&lt;pre data-source-line=&quot;178&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; RLock &lt;span&gt;getLock&lt;/span&gt;&lt;span&gt;(String name)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RedissonLock(connectionManager.getCommandExecutor(), name);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;183&quot;&gt;而这里实际上我们获取到的只是 Redisson 封装好的对分布式锁的抽象的对象而已，并不是真正的就执行加锁操作了。而加锁、释放锁等就是基于 Redisson 的锁接口 RLock 来做的，而本文讨论的可重入锁则 RedissonLock 是其中一种实现。&lt;/p&gt;&lt;h3 data-source-line=&quot;184&quot;&gt;3.2 RedissonLock 是如何加锁的&lt;/h3&gt;&lt;p data-source-line=&quot;185&quot;&gt;下面我们就以 demo 的代码为入口看一下 RedissonLock 是如何加锁的:&lt;/p&gt;&lt;pre data-source-line=&quot;186&quot;&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;tryLock&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; waitTime, TimeUnit unit)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; tryLock(waitTime, -&lt;span&gt;1&lt;/span&gt;, unit);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;192&quot;&gt;通过 demo 中使用的 tryLock(long waitTime, TimeUnit unit) 我们可以看出来，真正调用的是下面这个方法：&lt;/p&gt;&lt;pre data-source-line=&quot;193&quot;&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;tryLock&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; waitTime, &lt;span&gt;long&lt;/span&gt; leaseTime, TimeUnit unit)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; time = unit.toMillis(waitTime);&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; current = System.currentTimeMillis();&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; threadId = Thread.currentThread().getId();&lt;br/&gt;    Long ttl = tryAcquire(waitTime, leaseTime, unit, threadId);&lt;br/&gt;    &lt;span&gt;// &lt;span&gt;加锁成功&lt;/span&gt; &lt;span&gt;返回&lt;/span&gt;null &lt;span&gt;否则返回的是该锁将要过期的剩余时间&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// lock acquired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (ttl == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    time -= System.currentTimeMillis() - current;&lt;br/&gt;    &lt;span&gt;// &lt;span&gt;未获取到锁，且第一次尝试获取锁花费时间超过了预设等待时间，则获取锁失败，不再等待&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (time &amp;lt;= &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        acquireFailed(waitTime, unit, threadId);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    current = System.currentTimeMillis();&lt;br/&gt;    RFuture&amp;lt;RedissonLockEntry&amp;gt; subscribeFuture = subscribe(threadId);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!subscribeFuture.await(time, TimeUnit.MILLISECONDS)) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!subscribeFuture.cancel(&lt;span&gt;false&lt;/span&gt;)) {&lt;br/&gt;            subscribeFuture.onComplete((res, e) -&amp;gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (e == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    unsubscribe(subscribeFuture, threadId);&lt;br/&gt;                }&lt;br/&gt;            });&lt;br/&gt;        }&lt;br/&gt;        acquireFailed(waitTime, unit, threadId);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        time -= System.currentTimeMillis() - current;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (time &amp;lt;= &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            acquireFailed(waitTime, unit, threadId);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    &lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;long&lt;/span&gt; currentTime = System.currentTimeMillis();&lt;br/&gt;            ttl = tryAcquire(waitTime, leaseTime, unit, threadId);&lt;br/&gt;            &lt;span&gt;// lock acquired&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (ttl == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            time -= System.currentTimeMillis() - currentTime;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (time &amp;lt;= &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                acquireFailed(waitTime, unit, threadId);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;// waiting for message&lt;/span&gt;&lt;br/&gt;            currentTime = System.currentTimeMillis();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (ttl &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; ttl &amp;lt; time) {&lt;br/&gt;                subscribeFuture.getNow().getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                subscribeFuture.getNow().getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            time -= System.currentTimeMillis() - currentTime;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (time &amp;lt;= &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                acquireFailed(waitTime, unit, threadId);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        unsubscribe(subscribeFuture, threadId);&lt;br/&gt;    }&lt;br/&gt;&lt;span&gt;//        return get(tryLockAsync(waitTime, leaseTime, unit));&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;268&quot;&gt;而关于这段代码呢，我们先忽略其他逻辑，重点看这一行：&lt;/p&gt;&lt;pre data-source-line=&quot;269&quot;&gt;&lt;code&gt;Long ttl = tryAcquire(leaseTime, unit, threadId);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;272&quot;&gt;这一行第一次尝试加锁，接着往下看：&lt;/p&gt;&lt;pre data-source-line=&quot;273&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; Long &lt;span&gt;tryAcquire&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; leaseTime, TimeUnit unit, &lt;span&gt;long&lt;/span&gt; threadId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; get(tryAcquireAsync(leaseTime, unit, threadId));&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;RFuture&amp;lt;Long&amp;gt; &lt;span&gt;tryAcquireAsync&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; waitTime, &lt;span&gt;long&lt;/span&gt; leaseTime, TimeUnit unit, &lt;span&gt;long&lt;/span&gt; threadId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// &lt;span&gt;如果自己设置了锁释放时间，则获取锁后直接返回，且不会设置定时刷新的逻辑（上层方法没有设置定时任务），则获取到锁后超过设定的事件后自动释放&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// &lt;span&gt;或者在设定时间内手动调用释放锁&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (leaseTime != -&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);&lt;br/&gt;    }&lt;br/&gt;    RFuture&amp;lt;Long&amp;gt; ttlRemainingFuture = tryLockInnerAsync(waitTime, internalLockLeaseTime,&lt;br/&gt;                                                            TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);&lt;br/&gt;    ttlRemainingFuture.onComplete((ttlRemaining, e) -&amp;gt; {&lt;br/&gt;        &lt;span&gt;// &lt;span&gt;未获取到锁&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// &lt;span&gt;获取到锁，开启自动延期锁的定时任务&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// lock acquired&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (ttlRemaining == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            scheduleExpirationRenewal(threadId);&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; ttlRemainingFuture;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;301&quot;&gt;可以看出来对于 leaseTime != -1 的判断会走两种方式：真正的加锁是通过 tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand&amp;lt;T&amp;gt; command) 这个方法来做的，而当 leaseTime != -1 时，直接返回加锁结果了，而当 leaseTime = -1 时，在返回加锁结果之前，会监听加锁的结果：如果加锁成功了还会开启一个自动延期锁的定时任务。而这个 leaseTime 指的就是加锁成功后锁的默认持有时间。当我们不指定 leaseTime 时，默认的锁持有时间是 30 秒(这个时间叫作看门狗 - lockWatchdogTimeout),并且每 10 秒(30/3)去确认一下锁的状态：如果锁仍未被释放，则重新设置锁的过期时间为 30 秒（当然，持有锁的服务宕机后在 30 秒后锁会自动释放，这个我们后面再说）。而当我们指定 leaseTime 时，我们可以看出来前面的代码不会走到定时续期锁的逻辑，这时表示：成功获取到锁后，在 leaseTime 后，如果锁仍没有被服务主动释放，锁将自动过期，而不会管持有锁的线程有没有完成对应的操作，相当于在持有所得服务执行了比较耗时的任务且未完成时，这时锁已经被释放，这时候自然也是不安全的。上面两段代码的流程如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5356842989084802&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibm2sb53lRhwAHjz5QwpZnuKtD6LuLlUVuD5ibv9FZhTaRzZXKMkjf2DXwSXAVof9NOxRtEx7a1FoZyItuCVHnGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1191&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;308&quot;&gt;从前面的流程图我们可以看出，RedissonLock.tryLock(long waitTime, long leaseTime, TimeUnit unit) 是对于 waitTime, leaseTime 入参会产生不同的行为，这也是 RedissonLock 尝试加锁相对最完整的一个链路，其他方法譬如我们直接使用的 tryLock(long waitTime, TimeUnit unit) 也只是复用了其中一个逻辑分支。&lt;/p&gt;&lt;h3 data-source-line=&quot;310&quot;&gt;3.3 RedissonLock分布式锁的数据结构与加锁原理&lt;/h3&gt;&lt;p data-source-line=&quot;311&quot;&gt;前面一小节我们看到了 RedissonLock 完整的加锁链路，那么分布式锁在 Redis 是如何实现的呢？怎么判断加锁失败以及锁的剩余时间呢？现在我们就来看看这个。&lt;/p&gt;&lt;pre data-source-line=&quot;312&quot;&gt;&lt;code&gt; &lt;span&gt;if&lt;/span&gt; (leaseTime != -&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);&lt;br/&gt;    }&lt;br/&gt;    RFuture&amp;lt;Long&amp;gt; ttlRemainingFuture = tryLockInnerAsync(waitTime, internalLockLeaseTime,&lt;br/&gt;                                                            TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);&lt;br/&gt;&lt;span&gt;// &lt;span&gt;巴拉巴拉&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;321&quot;&gt;通过前面的代码我们可以看出来真正执行加锁以及返回加锁结果是调用了下面的方法:&lt;/p&gt;&lt;pre data-source-line=&quot;322&quot;&gt;&lt;code&gt;&amp;lt;T&amp;gt; &lt;span&gt;RFuture&amp;lt;T&amp;gt; &lt;span&gt;tryLockInnerAsync&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; waitTime, &lt;span&gt;long&lt;/span&gt; leaseTime, TimeUnit unit, &lt;span&gt;long&lt;/span&gt; threadId, RedisStrictCommand&amp;lt;T&amp;gt; command)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        internalLockLeaseTime = unit.toMillis(leaseTime);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// &lt;span&gt;锁不存在，加锁成功，设置&lt;/span&gt;hash&lt;span&gt;数据结构锁&lt;/span&gt;: &lt;span&gt;锁名&lt;/span&gt; -&amp;gt; &lt;span&gt;加锁线程&lt;/span&gt;:id -&amp;gt; &lt;span&gt;加锁次数&lt;/span&gt;(1)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// &lt;span&gt;锁存在且是本线程的锁&lt;/span&gt; &lt;span&gt;加锁次数增加：锁名&lt;/span&gt; -&amp;gt; &lt;span&gt;加锁线程&lt;/span&gt;:id -&amp;gt; &lt;span&gt;加锁次数&lt;/span&gt;+1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// &lt;span&gt;锁存在且不是本线程的锁&lt;/span&gt; &lt;span&gt;加锁失败&lt;/span&gt; &lt;span&gt;返回锁剩余过期时间&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; evalWriteAsync(getName(), LongCodec.INSTANCE, command,&lt;br/&gt;            &lt;span&gt;&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;return nil; &quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;end; &quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;return nil; &quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;end; &quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;&lt;/span&gt;,&lt;br/&gt;            Collections.singletonList(getName()), internalLockLeaseTime, getLockName(threadId));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;344&quot;&gt;到了这里，我们才能看到 RedissonLock 的加锁(仅仅指执行加锁这一动作)以及锁在 Redis 中的数据结构的庐山真面目:可以看出来上面是执行了一段 lua 脚本，这段 lua 脚 本是会涉及到多个判断以及数据修改的，这个时候就可以回到我们说的关于加锁的原子性问题了。先不看这段加锁的逻辑，只考虑加锁过程涉及到多个判断以及操作时，那么那些动作必须是原子的，要么同时成功要么同时失败，而 RedissonLock 实现加锁过程的原子性就是借助了 lua 脚本(锁延期等也会使用 lua 脚本)。那么我们看一下这段 lua 脚本的含义吧：结合注释，Redisson 实现的可重入锁的数据结构使用了 Redis中 的 hash 对象数据类型来实现，其在 Redis 中大概长这个样子：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3293591654247392&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibm2sb53lRhwAHjz5QwpZnuKtD6LuLlUVj826qRia9Ioj7LvVe6mebPhfSJ0XJRicibrlEnnbs7byWIux8XtmjSdLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;671&quot;/&gt;&lt;/p&gt;&lt;pre data-source-line=&quot;350&quot;&gt;&lt;code&gt;&lt;span&gt;从上面这张图我们可以看出来 Redisson 的分布式锁在 Redis 中的 hash 数据结构：&lt;/span&gt;&lt;span&gt;{锁名}&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;{uuid:threadId}&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;{count}&lt;/span&gt;&lt;span&gt;，另外对于已经存在的健值对初始化过期时间为 30 秒。结合前面的加锁流程图，我们就可以看出来 Redisson 分布式锁是如何实现加锁的原子性，以下操作是一个原子操作：&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-source-line=&quot;351&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;某一个节点下的线程加锁首先判断该线程对于的 hash 键是否存在&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;若不存在(锁未被持有)，则将锁的键设置为线程 id 对应的唯一标识，值为 1 (第一次加锁),返回空表示加锁成功&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;锁存在且对应的是本线程，说明之前加锁的线程为同一个，则将 hash 值 1 (加锁次数，可重入)，另外将该锁对应的存活时间重新设置，返回空表示加锁成功&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;锁存在但键对应的不是当前线程，说明持有锁的是其他线程，返回锁剩余的过期时间表示加锁失败&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-source-line=&quot;356&quot;&gt;到这里，Redisson 的分布式锁加锁的流程以及锁在 Redis 中的数据结构已经清楚了，这时候我们可以对比一下 Java 自身实现的可重入锁 ReentrantLock。对于 ReentrantLock，甚至更多的线程安全组件如 Semaphore、CountDownLatch 等，其底层的实现都依赖于 AQS(AbstractQueuedSynchronizer),而 AQS 本身是一个队列，队列中的节点 Node 同样也是封装了线程的对象，只是 AQS 是本地单节点的，Redis 却是分布式的可以被任何 JVM 共享。另外 AQS 中还封装了一个 int 类型的状态变量 state：&lt;/p&gt;&lt;pre data-source-line=&quot;357&quot;&gt;&lt;code&gt; &lt;span&gt;/**&lt;br/&gt; * The synchronization state.&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; state;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;363&quot;&gt;当涉及到具体的实现时，state 有不同的含义，对 ReentrantLock 来说 state 就是可重入锁的加锁次数，对 Semaphore 来说 state 就是信号量，对 CountDownLatch 来说就是计数量。可以看出来, Java 的 AQS 一些抽象和 Redisson 实现的分布式锁是可以类比的，比如 thread 标识对应的封装，加锁次数等。只是 AQS 的实现原子操作一般是基于原子类的 CAS，而 Redisson 实现原子操作是基于 Redis 的 lua 脚本。另外 AQS 实现队列节点状态同步是基于队列本身可以遍历的特性以及节点中的几种状态(这里不再赘述)，而 Redisson 不同线程之间阻塞同步是基于发布订阅(后面会提到)。可以得出：本地锁和分布式锁很多概念和思想是相似的，甚至其数据结构以及目标都是可类比的，只是分布式锁对本地锁的对象、范围、通信方式基于服务之间通信进行了实现。关于 AQS 的原理这里不再展开，大家可以参考 JDK 的源码。&lt;/p&gt;&lt;h3 data-source-line=&quot;364&quot;&gt;3.3 锁的自动续期&lt;/h3&gt;&lt;p data-source-line=&quot;365&quot;&gt;前面我们从 Redisson 加锁为入口，分析了加锁的整体流程并详细看了加锁时的细节以及数据结构，现在我们看一下 Redisson 分布式锁是如何自动续期的。前面我们已经提到了当第一次加锁成功时会开启自动续期的定时任务，对于的代码入口即为:&lt;/p&gt;&lt;pre data-source-line=&quot;366&quot;&gt;&lt;code&gt;    &lt;span&gt;// &lt;span&gt;获取到锁，开启自动延期锁的定时任务&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// lock acquired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (ttlRemaining == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        scheduleExpirationRenewal(threadId);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;373&quot;&gt;继续往下看，进入如下代码:&lt;/p&gt;&lt;pre data-source-line=&quot;374&quot;&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;scheduleExpirationRenewal&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; threadId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ExpirationEntry entry = &lt;span&gt;new&lt;/span&gt; ExpirationEntry();&lt;br/&gt;    ExpirationEntry oldEntry = EXPIRATION_RENEWAL_MAP.putIfAbsent(getEntryName(), entry);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (oldEntry != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;// &lt;span&gt;表示不是第一次加锁&lt;/span&gt; &lt;span&gt;则加锁次数加&lt;/span&gt; 1 &lt;span&gt;不会再开启续期锁&lt;/span&gt; &lt;span&gt;因为第一次加锁时调用&lt;/span&gt; scheduleExpirationRenewal(long threadId) &lt;span&gt;会进入&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// else &lt;span&gt;会开启&lt;/span&gt; renewExpiration()&lt;/span&gt;&lt;br/&gt;        oldEntry.addThreadId(threadId);&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// &lt;span&gt;在加锁时第一次调用&lt;/span&gt; &lt;span&gt;开启自动续期&lt;/span&gt;(&lt;span&gt;定时重设锁的过期时间&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;        entry.addThreadId(threadId);&lt;br/&gt;        renewExpiration();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;389&quot;&gt;ExpirationEntry 封装了定时任务对应的线程对象，结合注释这一段也不必展开，我们继续往下看真正开启续期的方法 renewExpiration()：&lt;/p&gt;&lt;pre data-source-line=&quot;390&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;renewExpiration&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ExpirationEntry ee = EXPIRATION_RENEWAL_MAP.get(getEntryName());&lt;br/&gt;    &lt;span&gt;// &lt;span&gt;锁已经不存在了直接返回&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (ee == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    Timeout task = commandExecutor.getConnectionManager().newTimeout(&lt;span&gt;new&lt;/span&gt; TimerTask() {&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;(Timeout timeout)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;            ExpirationEntry ent = EXPIRATION_RENEWAL_MAP.get(getEntryName());&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (ent == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            Long threadId = ent.getFirstThreadId();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (threadId == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;br/&gt;            RFuture&amp;lt;Boolean&amp;gt; future = renewExpirationAsync(threadId);&lt;br/&gt;            &lt;span&gt;// &lt;span&gt;这里监听续期&lt;/span&gt; &lt;span&gt;成功后递归调用&lt;/span&gt;(&lt;span&gt;十秒后再次重复&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;            future.onComplete((res, e) -&amp;gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    log.error(&lt;span&gt;&quot;Can&#x27;t update lock &quot;&lt;/span&gt; + getName() + &lt;span&gt;&quot; expiration&quot;&lt;/span&gt;, e);&lt;br/&gt;                    EXPIRATION_RENEWAL_MAP.remove(getEntryName());&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;                &lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (res) {&lt;br/&gt;                    &lt;span&gt;// reschedule itself&lt;/span&gt;&lt;br/&gt;                    renewExpiration();&lt;br/&gt;                }&lt;br/&gt;            });&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 10 &lt;span&gt;秒续期一次&lt;/span&gt;(&lt;span&gt;如果还持有锁&lt;/span&gt;)  30000/3&lt;/span&gt;&lt;br/&gt;    }, internalLockLeaseTime / &lt;span&gt;3&lt;/span&gt;, TimeUnit.MILLISECONDS);&lt;br/&gt;    &lt;br/&gt;    ee.setTimeout(task);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;431&quot;&gt;可以看出来锁自动续期的流程为：&lt;/p&gt;&lt;ol data-source-line=&quot;432&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;若锁已经不存在了(比如手动释放了锁)，直接返回&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;若锁仍存在，调用 Redis 异步设置锁的过期时间 renewExpirationAsync(threadId),同时监听续期结果&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;若续期成功，则递归调用 renewExpiration()，否则异常返回&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;以上过程每 10 秒重复一次 (internalLockLeaseTime / 3)&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;437&quot;&gt;然后我们看一下调用 Redis 对锁进行续期的过程:&lt;/p&gt;&lt;pre data-source-line=&quot;438&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; RFuture&amp;lt;Boolean&amp;gt; &lt;span&gt;renewExpirationAsync&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; threadId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// &lt;span&gt;当前线程持有的锁还存在&lt;/span&gt; &lt;span&gt;重新设置锁的过期时间&lt;/span&gt;(&lt;span&gt;默认&lt;/span&gt; 30 &lt;span&gt;秒&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// &lt;span&gt;否则失败&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,&lt;br/&gt;            &lt;span&gt;&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;return 1; &quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;end; &quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;return 0;&quot;&lt;/span&gt;,&lt;br/&gt;            Collections.singletonList(getName()),&lt;br/&gt;            internalLockLeaseTime, getLockName(threadId));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;452&quot;&gt;这里同样使用 lua 脚本来执行了一段原子操作:&lt;/p&gt;&lt;h3 data-source-line=&quot;455&quot;&gt;3.4 锁的手动释放&lt;/h3&gt;&lt;p data-source-line=&quot;456&quot;&gt;至此，Redisson 的加锁、自动续期我们已经讨论过了，现在看一下锁的手动释放， 其入口为:&lt;/p&gt;&lt;pre data-source-line=&quot;458&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;unlock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        get(unlockAsync(Thread.currentThread().getId()));&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (RedisException e) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e.getCause() &lt;span&gt;instanceof&lt;/span&gt; IllegalMonitorStateException) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; (IllegalMonitorStateException)e.getCause();&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; e;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;472&quot;&gt;接着看底层实现 unlockAsync(final long threadId):&lt;/p&gt;&lt;pre data-source-line=&quot;473&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; RFuture&amp;lt;Void&amp;gt; &lt;span&gt;unlockAsync&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; threadId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    RPromise&amp;lt;Void&amp;gt; result = &lt;span&gt;new&lt;/span&gt; RedissonPromise&amp;lt;Void&amp;gt;();&lt;br/&gt;    &lt;span&gt;// &lt;span&gt;释放锁&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    RFuture&amp;lt;Boolean&amp;gt; future = unlockInnerAsync(threadId);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// &lt;span&gt;监听释放锁结果&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    future.onComplete((opStatus, e) -&amp;gt; {&lt;br/&gt;        &lt;span&gt;// &lt;span&gt;取消自动续期&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;        cancelExpirationRenewal(threadId);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            result.tryFailure(e);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (opStatus == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            IllegalMonitorStateException cause = &lt;span&gt;new&lt;/span&gt; IllegalMonitorStateException(&lt;span&gt;&quot;attempt to unlock lock, not locked by current thread by node id: &quot;&lt;/span&gt;&lt;br/&gt;                    + id + &lt;span&gt;&quot; thread-id: &quot;&lt;/span&gt; + threadId);&lt;br/&gt;            result.tryFailure(cause);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        result.trySuccess(&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;502&quot;&gt;可以看出来，释放锁会执行以下操作：&lt;/p&gt;&lt;ul data-source-line=&quot;503&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;调用 Redis 释放锁&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;监听释放锁结果，取消自动续期&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-source-line=&quot;506&quot;&gt;然后看一下真正释放锁的操作:&lt;/p&gt;&lt;pre data-source-line=&quot;507&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; RFuture&amp;lt;Boolean&amp;gt; &lt;span&gt;unlockInnerAsync&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; threadId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// &lt;span&gt;若锁不存在&lt;/span&gt; &lt;span&gt;返回&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// &lt;span&gt;若锁存在&lt;/span&gt; &lt;span&gt;加锁次数&lt;/span&gt; -1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// &lt;span&gt;若加锁次数仍不等于&lt;/span&gt; 0 (&lt;span&gt;可重入&lt;/span&gt;)&lt;span&gt;，重新设置锁的过期时间，返回&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// &lt;span&gt;若加锁次数减为&lt;/span&gt; 0&lt;span&gt;，删除锁，同步发布释放锁事件，返回&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,&lt;br/&gt;            &lt;span&gt;&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[3]) == 0) then &quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;return nil;&quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;end; &quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;local counter = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[3], -1); &quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;if (counter &amp;gt; 0) then &quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]); &quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;return 0; &quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;else &quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;redis.call(&#x27;del&#x27;, KEYS[1]); &quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); &quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;return 1; &quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;end; &quot;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&quot;return nil;&quot;&lt;/span&gt;,&lt;br/&gt;            Arrays.asList(getName(), getChannelName()), LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;530&quot;&gt;上面这段 lua 脚本的含义基本与注释一致，这里不再赘述。至此，锁会被原子性的释放。&lt;/p&gt;&lt;h3 data-source-line=&quot;531&quot;&gt;3.5 加锁等待&lt;/h3&gt;&lt;p data-source-line=&quot;532&quot;&gt;讨论了加锁成功、锁自动续期、锁释放后，我们再来看一下加锁等待。前面加锁的代码中，我们可以看到，若制定了加锁的等待时间 waitTime 时，若锁已经被占有，加锁会失败并返回锁剩余的过期时间，然后循环尝试加锁，对应以下代码:&lt;/p&gt;&lt;pre data-source-line=&quot;533&quot;&gt;&lt;code&gt;    current = System.currentTimeMillis();&lt;br/&gt;    RFuture&amp;lt;RedissonLockEntry&amp;gt; subscribeFuture = subscribe(threadId);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!subscribeFuture.await(time, TimeUnit.MILLISECONDS)) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!subscribeFuture.cancel(&lt;span&gt;false&lt;/span&gt;)) {&lt;br/&gt;            subscribeFuture.onComplete((res, e) -&amp;gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (e == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    unsubscribe(subscribeFuture, threadId);&lt;br/&gt;                }&lt;br/&gt;            });&lt;br/&gt;        }&lt;br/&gt;        acquireFailed(waitTime, unit, threadId);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        time -= System.currentTimeMillis() - current;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (time &amp;lt;= &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            acquireFailed(waitTime, unit, threadId);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// &lt;span&gt;等待锁释放&lt;/span&gt; &lt;span&gt;循环获取锁&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;long&lt;/span&gt; currentTime = System.currentTimeMillis();&lt;br/&gt;            ttl = tryAcquire(waitTime, leaseTime, unit, threadId);&lt;br/&gt;            &lt;span&gt;// lock acquired&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (ttl == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            time -= System.currentTimeMillis() - currentTime;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (time &amp;lt;= &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                acquireFailed(waitTime, unit, threadId);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;// waiting for message&lt;/span&gt;&lt;br/&gt;            currentTime = System.currentTimeMillis();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (ttl &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; ttl &amp;lt; time) {&lt;br/&gt;                subscribeFuture.getNow().getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                subscribeFuture.getNow().getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            time -= System.currentTimeMillis() - currentTime;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (time &amp;lt;= &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                acquireFailed(waitTime, unit, threadId);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        unsubscribe(subscribeFuture, threadId);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;588&quot;&gt;在上面的 while 循环中，我们可以看出来，每次循环都会调用&lt;/p&gt;&lt;pre data-source-line=&quot;589&quot;&gt;&lt;code&gt;ttl = tryAcquire(waitTime, leaseTime, unit, threadId);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;592&quot;&gt;这里就回到了我们之前分析的加锁流程，不再赘述。整个加锁等待流程如下：&lt;/p&gt;&lt;h2 data-source-line=&quot;596&quot;&gt;4.总结&lt;/h2&gt;&lt;p data-source-line=&quot;597&quot;&gt;至此，Redisson 基于 Redis 实现的分布式锁的可重入锁 RedissonLock 的大致原理就分析完了。我们分析了分布式系统下保证共享资源安全的一些必要特性，然后针对 Redisson 实现的可重入锁的加锁、自动续期、锁释放、锁等待的代码进行了分析，整个过程有所简略，只关注了整体流程。更为细节的内容如如何和 Redis 进行通信、配置管理覆盖、发布订阅如何实现，感兴趣的话大家可以自己探索一下。&lt;/p&gt;&lt;p&gt;&lt;span&gt;全文完&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下文章您可能也会感兴趣：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们正在招聘 Java 工程师，欢迎有兴趣的同学投递简历到 rd-hr@xingren.com 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.505&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibm2sb53lRhwia9fkSREIyu986sXHSFXMtdZtXL8ICRwXBp0vGVW5sDE8J3yH8dYTCNlMA7PQgiamuiaVZicanWdUSQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ecb8e3e8d31a43f168fe99c5132d2950</guid>
<title>Redis 专题：万字长文详解持久化原理</title>
<link>https://toutiao.io/k/9d3bawg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;本文将从以下几个方面介绍Redis持久化机制：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7928286852589641&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mZx0iasykflulslx70UrnEhGNOnSiboSiaN0InU2jwryvdyGHhgCicjiaAx5aib6Ifclicu8tQ5MezhhrhfNNxLAfwvaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1004&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI0NTE4NDg0NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/mZx0iasykfltUJKaqQlD7oMJoZCwokhwjfJiblpUeuQY6Auvt8vPtFJRWmC1HUfNP2V2UYIVDnkzvSic8NnQy6EcQ/0?wx_fmt=png&quot; data-nickname=&quot;码路印记&quot; data-alias=&quot;&quot; data-signature=&quot;It&#x27;s what you do right now that makes difference!&quot;/&gt;&lt;/section&gt;&lt;h2&gt;写在前面&lt;br/&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;本文从整体上详细介绍Redis的两种持久化方式，包含工作原理、持久化流程及实践策略，以及背后的一些理论知识。上一篇文章仅介绍了RDB持久化，但是Redis持久化是一个整体，单独介绍不成体系，故重新整理。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Redis是一个内存数据库，所有的数据将保存在内存中，这与传统的MySQL、Oracle、SqlServer等关系型数据库直接把数据保存到硬盘相比，Redis的读写效率非常高。但是保存在内存中也有一个很大的缺陷，一旦断电或者宕机，内存数据库中的内容将会全部丢失。为了弥补这一缺陷，Redis提供了把内存数据持久化到硬盘文件，以及通过备份文件来恢复数据的功能，即Redis持久化机制。&lt;/p&gt;&lt;p&gt;Redis支持两种方式的持久化：RDB快照和AOF。&lt;/p&gt;&lt;h2&gt;RDB持久化&lt;/h2&gt;&lt;p&gt;RDB快照用官方的话来说：RDB持久化方案是按照指定时间间隔对你的数据集生成的时间点快照（point-to-time snapshot）。它以紧缩的二进制文件保存Redis数据库某一时刻所有数据对象的内存快照，可用于Redis的数据备份、转移与恢复。到目前为止，仍是官方的默认支持方案。&lt;/p&gt;&lt;h3&gt;RDB工作原理&lt;/h3&gt;&lt;p&gt;既然说RDB是Redis中数据集的时间点快照，那我们先简单了解一下Redis内的数据对象在内存中是如何存储与组织的。&lt;/p&gt;&lt;p&gt;默认情况下，Redis中有16个数据库，编号从0-15，每个Redis数据库使用一个&lt;code&gt;redisDb&lt;/code&gt;对象来表示，&lt;code&gt;redisDb&lt;/code&gt;使用hashtable存储K-V对象。为方便理解，我以其中一个db为例绘制Redis内部数据的存储结构示意图。&lt;img data-ratio=&quot;0.6056701030927835&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mZx0iasykflulslx70UrnEhGNOnSiboSiaN37kL3DbCqN3cmqGeeWNeic3v9ibo2xxLMH5yJDiaR0fuicgIW7vR79am6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1552&quot;/&gt;时间点快照也就是某一时刻Redis内每个DB中每个数据对象的状态，&lt;strong&gt;先假设在这一时刻所有的数据对象不再改变&lt;/strong&gt;，我们就可以按照上图中的数据结构关系，把这些数据对象依次读取出来并写入到文件中，以此实现Redis的持久化。然后，当Redis重启时按照规则读取这个文件中的内容，再写入到Redis内存即可恢复至持久化时的状态。&lt;/p&gt;&lt;p&gt;当然，这个前提是我们上面的假设成立，否则面对一个时刻变化的数据集，我们无从下手。我们知道Redis中客户端命令处理是单线程模型，如果把持久化作为一个命令处理，那数据集肯定是处于静止状态。另外，操作系统提供的fork()函数创建的子进程可获得与父进程一致的内存数据，相当于获取了内存数据副本；fork完成后，父进程该干嘛干嘛，持久化状态的工作交给子进程就行了。&lt;/p&gt;&lt;p&gt;很显然，第一种情况不可取，持久化备份会导致短时间内Redis服务不可用，这对于高HA的系统来讲是无法容忍的。所以，第二种方式是RDB持久化的主要实践方式。由于fork子进程后，父进程数据一直在变化，子进程并不与父进程同步，RDB持久化必然无法保证实时性；RDB持久化完成后发生断电或宕机，会导致部分数据丢失；备份频率决定了丢失数据量的大小，提高备份频率，意味着fork过程消耗较多的CPU资源，也会导致较大的磁盘I/O。&lt;/p&gt;&lt;h3&gt;持久化流程&lt;/h3&gt;&lt;p&gt;在Redis内完成RDB持久化的方法有rdbSave和rdbSaveBackground两个函数方法（源码文件rdb.c中），先简单说下两者差别：&lt;/p&gt;&lt;p&gt;RDB持久化的触发必然离不开以上两个方法，触发的方式分为手动和自动。手动触发容易理解，是指我们通过Redis客户端人为的对Redis服务端发起持久化备份指令，然后Redis服务端开始执行持久化流程，这里的指令有save和bgsave。自动触发是Redis根据自身运行要求，在满足预设条件时自动触发的持久化流程，自动触发的场景有如下几个（摘自这篇文章）：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;serverCron中&lt;code&gt;save m n&lt;/code&gt;配置规则自动触发；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;从节点全量复制时，主节点发送rdb文件给从节点完成复制操作，主节点会触发bgsave；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;执行&lt;code&gt;debug reload&lt;/code&gt;命令重新加载redis时；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;默认情况下（未开启AOF）执行shutdown命令时，自动执行bgsave；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;结合源码及参考文章，我整理了RDB持久化流程来帮助大家有个整体的了解，然后再从一些细节进行说明。&lt;img data-ratio=&quot;0.5621468926553672&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mZx0iasykflulslx70UrnEhGNOnSiboSiaNbuAIDUjr3xia6mdyOibr4o55oWB4xJ7fTkWXaURqRWGwG0Kibl4gv6ZBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1416&quot;/&gt;从上图可以知道：&lt;/p&gt;&lt;p&gt;自动触发流程是一个完整的链路，涵盖了rdbSaveBackground、rdbSave等，接下来我以serverCron为例分析一下整个流程。&lt;/p&gt;&lt;h4&gt;save规则及检查&lt;/h4&gt;&lt;p&gt;serverCron是Redis内的一个周期性函数，每隔100毫秒执行一次，它的其中一项工作就是：根据配置文件中save规则来判断当前需要进行自动持久化流程，如果满足条件则尝试开始持久化。了解一下这部分的实现。&lt;/p&gt;&lt;p&gt;在&lt;code&gt;redisServer&lt;/code&gt;中有几个与RDB持久化有关的字段，我从代码中摘出来，中英文对照着看下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;struct redisServer {&lt;br/&gt;    /* 省略其他字段 */ &lt;br/&gt;    /* RDB persistence */&lt;br/&gt;    long long dirty;                /* Changes to DB from the last save&lt;br/&gt;                                     * 上次持久化后修改key的次数 */&lt;br/&gt;    struct saveparam *saveparams;   /* Save points array for RDB，&lt;br/&gt;                                     * 对应配置文件多个save参数 */&lt;br/&gt;    int saveparamslen;              /* Number of saving points，&lt;br/&gt;                                     * save参数的数量 */&lt;br/&gt;    time_t lastsave;                /* Unix time of last successful save &lt;br/&gt;                                     * 上次持久化时间*/&lt;br/&gt;    /* 省略其他字段 */&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;/* 对应redis.conf中的save参数 */&lt;br/&gt;struct saveparam {&lt;br/&gt;    time_t seconds;                    /* 统计时间范围 */   &lt;br/&gt;    int changes;                    /* 数据修改次数 */&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;saveparams&lt;/code&gt;对应&lt;code&gt;redis.conf&lt;/code&gt;下的save规则，save参数是Redis触发自动备份的触发策略，&lt;code&gt;seconds&lt;/code&gt;为统计时间（单位：秒）， &lt;code&gt;changes&lt;/code&gt;为在统计时间内发生写入的次数。&lt;code&gt;save m n&lt;/code&gt;的意思是：m秒内有n条写入就触发一次快照，即备份一次。save参数可以配置多组，满足在不同条件的备份要求。如果需要关闭RDB的自动备份策略，可以使用&lt;code&gt;save &quot;&quot;&lt;/code&gt;。以下为几种配置的说明：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# 表示900秒（15分钟）内至少有1个key的值发生变化，则执行&lt;br/&gt;save 900 1&lt;br/&gt;# 表示300秒（5分钟）内至少有1个key的值发生变化，则执行&lt;br/&gt;save 300 10&lt;br/&gt;# 表示60秒（1分钟）内至少有10000个key的值发生变化，则执行&lt;br/&gt;save 60 10000&lt;br/&gt;# 该配置将会关闭RDB方式的持久化&lt;br/&gt;save &quot;&quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;serverCron&lt;/code&gt;对RDB save规则的检测代码如下所示：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {&lt;br/&gt;    /* 省略其他逻辑 */&lt;br/&gt;&lt;br/&gt;    /* 如果用户请求进行AOF文件重写时，Redis正在执行RDB持久化，Redis会安排在RDB持久化完成后执行AOF文件重写，&lt;br/&gt;     * 如果aof_rewrite_scheduled为true，说明需要执行用户的请求 */&lt;br/&gt;    /* Check if a background saving or AOF rewrite in progress terminated. */&lt;br/&gt;    if (hasActiveChildProcess() || ldbPendingChildren())&lt;br/&gt;    {&lt;br/&gt;        run_with_period(1000) receiveChildInfo();&lt;br/&gt;        checkChildrenDone();&lt;br/&gt;    } else {&lt;br/&gt;        /* 后台无 saving/rewrite 子进程才会进行，逐个检查每个save规则*/&lt;br/&gt;        for (j = 0; j &amp;lt; server.saveparamslen; j++) {&lt;br/&gt;            struct saveparam *sp = server.saveparams+j;&lt;br/&gt;&lt;br/&gt;            /* 检查规则有几个：满足修改次数，满足统计周期，达到重试时间间隔或者上次持久化完成*/&lt;br/&gt;            if (server.dirty &amp;gt;= sp-&amp;gt;changes &lt;br/&gt;                &amp;amp;&amp;amp; server.unixtime-server.lastsave &amp;gt; sp-&amp;gt;seconds &lt;br/&gt;                &amp;amp;&amp;amp;(server.unixtime-server.lastbgsave_try &amp;gt; CONFIG_BGSAVE_RETRY_DELAY || server.lastbgsave_status == C_OK))&lt;br/&gt;            {&lt;br/&gt;                serverLog(LL_NOTICE,&quot;%d changes in %d seconds. Saving...&quot;, sp-&amp;gt;changes, (int)sp-&amp;gt;seconds);&lt;br/&gt;                rdbSaveInfo rsi, *rsiptr;&lt;br/&gt;                rsiptr = rdbPopulateSaveInfo(&amp;amp;rsi);&lt;br/&gt;                /* 执行bgsave过程 */&lt;br/&gt;                rdbSaveBackground(server.rdb_filename,rsiptr);&lt;br/&gt;                break;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        /* 省略：Trigger an AOF rewrite if needed. */&lt;br/&gt;    }&lt;br/&gt;    /* 省略其他逻辑 */&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果没有后台的RDB持久化或AOF重写进程，serverCron会根据以上配置及状态判断是否需要执行持久化操作，判断依据就是看lastsave、dirty是否满足saveparams数组中的其中一个条件。如果有一个条件匹配，则调用rdbSaveBackground方法，执行异步持久化流程。&lt;/p&gt;&lt;h4&gt;rdbSaveBackground&lt;/h4&gt;&lt;p&gt;rdbSaveBackground是RDB持久化的辅助性方法，主要工作是fork子进程，然后根据调用方（父进程或者子进程）不同，有两种不同的执行逻辑。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;int rdbSaveBackground(char *filename, rdbSaveInfo *rsi) {&lt;br/&gt;    pid_t childpid;&lt;br/&gt;&lt;br/&gt;    if (hasActiveChildProcess()) return C_ERR;&lt;br/&gt;&lt;br/&gt;    server.dirty_before_bgsave = server.dirty;&lt;br/&gt;    server.lastbgsave_try = time(NULL);&lt;br/&gt;&lt;br/&gt;    // fork子进程&lt;br/&gt;    if ((childpid = redisFork(CHILD_TYPE_RDB)) == 0) {&lt;br/&gt;        int retval;&lt;br/&gt;&lt;br/&gt;        /* Child 子进程：修改进程标题 */&lt;br/&gt;        redisSetProcTitle(&quot;redis-rdb-bgsave&quot;);&lt;br/&gt;        redisSetCpuAffinity(server.bgsave_cpulist);&lt;br/&gt;        // 执行rdb持久化&lt;br/&gt;        retval = rdbSave(filename,rsi);&lt;br/&gt;        if (retval == C_OK) {&lt;br/&gt;            sendChildCOWInfo(CHILD_TYPE_RDB, 1, &quot;RDB&quot;);&lt;br/&gt;        }&lt;br/&gt;        // 持久化完成后，退出子进程&lt;br/&gt;        exitFromChild((retval == C_OK) ? 0 : 1);&lt;br/&gt;    } else {&lt;br/&gt;        /* Parent 父进程：记录fork子进程的时间等信息*/&lt;br/&gt;        if (childpid == -1) {&lt;br/&gt;            server.lastbgsave_status = C_ERR;&lt;br/&gt;            serverLog(LL_WARNING,&quot;Can&#x27;t save in background: fork: %s&quot;,&lt;br/&gt;                strerror(errno));&lt;br/&gt;            return C_ERR;&lt;br/&gt;        }&lt;br/&gt;        serverLog(LL_NOTICE,&quot;Background saving started by pid %ld&quot;,(long) childpid);&lt;br/&gt;        // 记录子进程开始的时间、类型等。&lt;br/&gt;        server.rdb_save_time_start = time(NULL);&lt;br/&gt;        server.rdb_child_type = RDB_CHILD_TYPE_DISK;&lt;br/&gt;        return C_OK;&lt;br/&gt;    }&lt;br/&gt;    return C_OK; /* unreached */&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;rdbSave是真正执行持久化的方法，它在执行时存在大量的I/O、计算操作，耗时、CPU占用较大，在Redis的单线程模型中持久化过程会持续占用线程资源，进而导致Redis无法提供其他服务。为了解决这一问题Redis在rdbSaveBackground中fork出子进程，由子进程完成持久化工作，避免了占用父进程过多的资源。&lt;/p&gt;&lt;p&gt;需要注意的是，如果父进程内存占用过大，fork过程会比较耗时，在这个过程中父进程无法对外提供服务；另外，需要综合考虑计算机内存使用量，fork子进程后会占用双倍的内存资源，需要确保内存够用。通过info stats命令查看latest_fork_usec选项，可以获取最近一个fork以操作的耗时。&lt;/p&gt;&lt;h4&gt;rdbSave&lt;/h4&gt;&lt;p&gt;Redis的rdbSave函数是真正进行RDB持久化的函数，流程、细节贼多，整体流程可以总结为：创建并打开临时文件、Redis内存数据写入临时文件、临时文件写入磁盘、临时文件重命名为正式RDB文件、更新持久化状态信息（dirty、lastsave）。其中“Redis内存数据写入临时文件”最为核心和复杂，写入过程直接体现了RDB文件的文件格式，本着一图胜千言的理念，我按照源码流程绘制了下图。&lt;img data-ratio=&quot;0.7005420054200542&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mZx0iasykflulslx70UrnEhGNOnSiboSiaNUnibibxZ4lX6GED6fJtgegxOjfjqHs8J1MF7Fg7y379I2EHicmCh4dJQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1476&quot;/&gt;补充说明一下，上图右下角“遍历当前数据库的键值对并写入”这个环节会根据不同类型的Redis数据类型及底层数据结构采用不同的格式写入到RDB文件中，不再展开了。我觉得大家对整个过程有个直观的理解就好，这对于我们理解Redis内部的运作机制大有裨益。&lt;/p&gt;&lt;h3&gt;AOF持久化&lt;/h3&gt;&lt;p&gt;上一节我们知道RDB是一种时间点（point-to-time）快照，适合数据备份及灾难恢复，由于工作原理的“先天性缺陷”无法保证实时性持久化，这对于缓存丢失零容忍的系统来说是个硬伤，于是就有了AOF。&lt;/p&gt;&lt;h3&gt;AOF工作原理&lt;/h3&gt;&lt;p&gt;AOF是Append Only File的缩写，它是Redis的完全持久化策略，从1.1版本开始支持；这里的file存储的是引起Redis数据修改的命令集合（比如：set/hset/del等），这些集合按照Redis Server的处理顺序追加到文件中。当重启Redis时，Redis就可以从头读取AOF中的指令并重放，进而恢复关闭前的数据状态。&lt;/p&gt;&lt;p&gt;AOF持久化默认是关闭的，修改redis.conf以下信息并重启，即可开启AOF持久化功能。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# no-关闭，yes-开启，默认no&lt;br/&gt;appendonly yes&lt;br/&gt;appendfilename appendonly.aof&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;AOF本质是为了持久化，持久化对象是Redis内每一个key的状态，持久化的目的是为了在Reids发生故障重启后能够恢复至重启前或故障前的状态。相比于RDB，AOF采取的策略是按照执行顺序持久化每一条能够引起Redis中对象状态变更的命令，命令是有序的、有选择的。把aof文件转移至任何一台Redis Server，从头到尾按序重放这些命令即可恢复如初。举个例子：&lt;/p&gt;&lt;p&gt;首先执行指令&lt;code&gt;set number 0&lt;/code&gt;，然后随机调用&lt;code&gt;incr number&lt;/code&gt;、&lt;code&gt;get number&lt;/code&gt; 各5次，最后再执行一次&lt;code&gt;get number&lt;/code&gt; ，我们得到的结果肯定是5。&lt;/p&gt;&lt;p&gt;因为在这个过程中，能够引起&lt;code&gt;number&lt;/code&gt;状态变更的只有&lt;code&gt;set/incr&lt;/code&gt;类型的指令，并且它们执行的先后顺序是已知的，无论执行多少次&lt;code&gt;get&lt;/code&gt;都不会影响&lt;code&gt;number&lt;/code&gt;的状态。所以，保留所有&lt;code&gt;set/incr&lt;/code&gt;命令并持久化至aof文件即可。按照aof的设计原理，aof文件中的内容应该是这样的（这里是假设，实际为RESP协议）：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;set number 0&lt;br/&gt;incr number&lt;br/&gt;incr number&lt;br/&gt;incr number&lt;br/&gt;incr number&lt;br/&gt;incr number&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最本质的原理用“命令重放”四个字就可以概括。但是，考虑实际生产环境的复杂性及操作系统等方面的限制，Redis所要考虑的工作要比这个例子复杂的多：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Redis Server启动后，aof文件一直在追加命令，文件会越来越大。文件越大，Redis重启后恢复耗时越久；文件太大，转移工作就越难；不加管理，可能撑爆硬盘。很显然，需要在合适的时机对文件进行精简。例子中的5条incr指令很明显的可以替换为为一条&lt;code&gt;set&lt;/code&gt;命令，存在很大的压缩空间。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;众所周知，文件I/O是操作系统性能的短板，为了提高效率，文件系统设计了一套复杂的缓存机制，Redis操作命令的追加操作只是把数据写入了缓冲区（aof_buf），从缓冲区到写入物理文件在性能与安全之间权衡会有不同的选择。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;文件压缩即意味着重写，重写时即可依据已有的aof文件做命令整合，也可以先根据当前Redis内数据的状态做快照，再把存储快照过程中的新增的命令做追加。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;aof备份后的文件是为了恢复数据，结合aof文件的格式、完整性等因素，Redis也要设计一套完整的方案做支持。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;持久化流程&lt;/h3&gt;&lt;p&gt;从流程上来看，AOF的工作原理可以概括为几个步骤：命令追加（append）、文件写入与同步（fsync）、文件重写（rewrite）、重启加载（load），接下来依次了解每个步骤的细节及背后的设计哲学。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.29559748427672955&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mZx0iasykflulslx70UrnEhGNOnSiboSiaNecXianRonpcH7Bic5EibfMleGNa8T1icAPkI49BI3CdcEgrWT2M9xBDtWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1590&quot;/&gt;&lt;/p&gt;&lt;h4&gt;命令追加&lt;/h4&gt;&lt;p&gt;当 AOF 持久化功能处于打开状态时，Redis 在执行完一个写命令之后，会以协议格式(也就是RESP，即 Redis 客户端和服务器交互的通信协议 )把被执行的写命令追加到 Redis 服务端维护的 AOF 缓冲区末尾。对AOF文件只有单线程的追加操作，没有seek等复杂的操作，即使断电或宕机也不存在文件损坏风险。另外，使用文本协议好处多多：&lt;/p&gt;&lt;p&gt;AOF缓冲区类型为Redis自主设计的数据结构&lt;code&gt;sds&lt;/code&gt;，Redis会根据命令的类型采用不同的方法（&lt;code&gt;catAppendOnlyGenericCommand&lt;/code&gt;、&lt;code&gt;catAppendOnlyExpireAtCommand&lt;/code&gt;等）对命令内容进行处理，最后写入缓冲区。&lt;/p&gt;&lt;p&gt;需要注意的是：如果命令追加时正在进行AOF重写，这些命令还会追加到重写缓冲区（&lt;code&gt;aof_rewrite_buffer&lt;/code&gt;）。&lt;/p&gt;&lt;h4&gt;文件写入与同步&lt;/h4&gt;&lt;p&gt;AOF文件的写入与同步离不开操作系统的支持，开始介绍之前，我们需要补充一下Linux I/O缓冲区相关知识。硬盘I/O性能较差，文件读写速度远远比不上CPU的处理速度，如果每次文件写入都等待数据写入硬盘，会整体拉低操作系统的性能。为了解决这个问题，操作系统提供了延迟写（delayed write）机制来提高硬盘的I/O性能。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.8907563025210085&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mZx0iasykflulslx70UrnEhGNOnSiboSiaNyg5YRicibcuxiadnQrOC6FQKicBrWSAVJR3HLqMsn3mibZ2pXtdXKtc5FLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;595&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;传统的UNIX实现在内核中设有缓冲区高速缓存或页面高速缓存，大多数磁盘I/O都通过缓冲进行。当将数据写入文件时，内核通常先将该数据复制到其中一个缓冲区中，如果该缓冲区尚未写满，则并不将其排入输出队列，而是等待其写满或者当内核需要重用该缓冲区以便存放其他磁盘块数据时， 再将该缓冲排入到输出队列，然后待其到达队首时，才进行实际的I/O操作。这种输出方式就被称为延迟写。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;延迟写减少了磁盘读写次数，但是却降低了文件内容的更新速度，使得欲写到文件中的数据在一段时间内并没有写到磁盘上。当系统发生故障时，这种延迟可能造成文件更新内容的丢失。为了保证磁盘上实际文件系统与缓冲区高速缓存中内容的一致性，UNIX系统提供了sync、fsync和fdatasync三个函数为强制写入硬盘提供支持。&lt;/p&gt;&lt;p&gt;Redis每次事件轮训结束前（&lt;code&gt;beforeSleep&lt;/code&gt;）都会调用函数&lt;code&gt;flushAppendOnlyFile&lt;/code&gt;，&lt;code&gt;flushAppendOnlyFile&lt;/code&gt;会把AOF缓冲区（&lt;code&gt;aof_buf&lt;/code&gt;）中的数据写入内核缓冲区，并且根据&lt;code&gt;appendfsync&lt;/code&gt;配置来决定采用何种策略把内核缓冲区中的数据写入磁盘，即调用&lt;code&gt;fsync()&lt;/code&gt;。该配置有三个可选项&lt;code&gt;always&lt;/code&gt;、&lt;code&gt;no&lt;/code&gt;、&lt;code&gt;everysec&lt;/code&gt;，具体说明如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;always：每次都调用&lt;code&gt;fsync()&lt;/code&gt;，是安全性最高、性能最差的一种策略。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;no：不会调用&lt;code&gt;fsync()&lt;/code&gt;。性能最好，安全性最差。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;everysec：仅在满足同步条件时调用&lt;code&gt;fsync()&lt;/code&gt;。这是官方建议的同步策略，也是默认配置，做到兼顾性能和数据安全性，理论上只有在系统突然宕机的情况下丢失1秒的数据。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意：上面介绍的策略受配置项&lt;code&gt;no-appendfsync-on-rewrite&lt;/code&gt;的影响，它的作用是告知Redis：AOF文件重写期间是否禁止调用fsync()，默认是no。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如果&lt;code&gt;appendfsync&lt;/code&gt;设置为&lt;code&gt;always&lt;/code&gt;或&lt;code&gt;everysec&lt;/code&gt;，后台正在进行的&lt;code&gt;BGSAVE&lt;/code&gt;或者&lt;code&gt;BGREWRITEAOF&lt;/code&gt;消耗过多的磁盘I/O，在某些Linux系统配置下，Redis对fsync()的调用可能阻塞很长时间。然而这个问题还没有修复，因为即使是在不同的线程中执行&lt;code&gt;fsync()&lt;/code&gt;，同步写入操作也会被阻塞。&lt;/p&gt;&lt;p&gt;为了缓解此问题，可以使用该选项，以防止在进行&lt;code&gt;BGSAVE&lt;/code&gt;或&lt;code&gt;BGREWRITEAOF&lt;/code&gt;时在主进程中调用fsync(）。&lt;/p&gt;&lt;h4&gt;文件重写&lt;/h4&gt;&lt;p&gt;如前面提到的，Redis长时间运行，命令不断写入AOF，文件会越来越大，不加控制可能影响宿主机的安全。&lt;/p&gt;&lt;p&gt;为了解决AOF文件体积问题，Redis引入了AOF文件重写功能，它会根据Redis内数据对象的最新状态生成新的AOF文件，新旧文件对应的数据状态一致，但是新文件会具有较小的体积。重写既减少了AOF文件对磁盘空间的占用，又可以提高Redis重启时数据恢复的速度。还是下面这个例子，旧文件中的6条命令等同于新文件中的1条命令，压缩效果显而易见。&lt;img data-ratio=&quot;0.4364937388193202&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mZx0iasykflulslx70UrnEhGNOnSiboSiaNiaDSVCGjia9Xl1ICWhU2ZKFlA4e8FucKAUBPsPvNkNt6lCjmbjwibgpnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1118&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;我们说，AOF文件太大时会触发AOF文件重写，那到底是多大呢？有哪些情况会触发重写操作呢？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;与RDB方式一样，AOF文件重写既可以手动触发，也会自动触发。手动触发直接调用&lt;code&gt;bgrewriteaof&lt;/code&gt;命令，如果当时无子进程执行会立刻执行，否则安排在子进程结束后执行。自动触发由Redis的周期性方法&lt;code&gt;serverCron&lt;/code&gt;检查在满足一定条件时触发。先了解两个配置项：&lt;/p&gt;&lt;p&gt;Redis启动时把&lt;code&gt;aof_base_size&lt;/code&gt;初始化为当时aof文件的大小，Redis运行过程中，当AOF文件重写操作完成时，会对其进行更新；&lt;code&gt;aof_current_size&lt;/code&gt;为&lt;code&gt;serverCron&lt;/code&gt;执行时AOF文件的实时大小。当满足以下两个条件时，AOF文件重写就会触发：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;增长比例：(aof_current_size - aof_base_size) / aof_base_size &amp;gt; auto-aof-rewrite-percentage&lt;br/&gt;文件大小：aof_current_size &amp;gt; auto-aof-rewrite-min-size&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;手动触发与自动触发的代码如下，同样在周期性方法&lt;code&gt;serverCron&lt;/code&gt;中：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {&lt;br/&gt;    /* 省略其他逻辑 */&lt;br/&gt;&lt;br/&gt;    /* 如果用户请求进行AOF文件重写时，Redis正在执行RDB持久化，Redis会安排在RDB持久化完成后执行AOF文件重写，&lt;br/&gt;     * 如果aof_rewrite_scheduled为true，说明需要执行用户的请求 */&lt;br/&gt;    if (!hasActiveChildProcess() &amp;amp;&amp;amp;&lt;br/&gt;        server.aof_rewrite_scheduled)&lt;br/&gt;    {&lt;br/&gt;        rewriteAppendOnlyFileBackground();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    /* Check if a background saving or AOF rewrite in progress terminated. */&lt;br/&gt;    if (hasActiveChildProcess() || ldbPendingChildren())&lt;br/&gt;    {&lt;br/&gt;        run_with_period(1000) receiveChildInfo();&lt;br/&gt;        checkChildrenDone();&lt;br/&gt;    } else {&lt;br/&gt;        /* 省略rdb持久化条件检查 */&lt;br/&gt;&lt;br/&gt;        /* AOF重写条件检查：aof开启、无子进程运行、增长百分比已设置、当前文件大小超过阈值 */&lt;br/&gt;        if (server.aof_state == AOF_ON &amp;amp;&amp;amp;&lt;br/&gt;            !hasActiveChildProcess() &amp;amp;&amp;amp;&lt;br/&gt;            server.aof_rewrite_perc &amp;amp;&amp;amp;&lt;br/&gt;            server.aof_current_size &amp;gt; server.aof_rewrite_min_size)&lt;br/&gt;        {&lt;br/&gt;            long long base = server.aof_rewrite_base_size ?&lt;br/&gt;                server.aof_rewrite_base_size : 1;&lt;br/&gt;            /* 计算增长百分比 */&lt;br/&gt;            long long growth = (server.aof_current_size*100/base) - 100;&lt;br/&gt;            if (growth &amp;gt;= server.aof_rewrite_perc) {&lt;br/&gt;                serverLog(LL_NOTICE,&quot;Starting automatic rewriting of AOF on %lld%% growth&quot;,growth);&lt;br/&gt;                rewriteAppendOnlyFileBackground();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    /**/&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;AOF文件重写的流程是什么？听说Redis支持混合持久化，对AOF文件重写有什么影响？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从4.0版本开始，Redis在AOF模式中引入了混合持久化方案，即：纯AOF方式、RDB+AOF方式，这一策略由配置参数&lt;code&gt;aof-use-rdb-preamble&lt;/code&gt;（使用RDB作为AOF文件的前半段）控制，默认关闭(no)，设置为yes可开启。所以，在AOF重写过程中文件的写入会有两种不同的方式。当&lt;code&gt;aof-use-rdb-preamble&lt;/code&gt;的值是：&lt;/p&gt;&lt;p&gt;结合源码（6.0版本，源码太多这里不贴出，可参考&lt;code&gt;aof.c&lt;/code&gt;）及参考资料，绘制AOF重写（BGREWRITEAOF）流程图：&lt;img data-ratio=&quot;0.9808429118773946&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mZx0iasykflulslx70UrnEhGNOnSiboSiaNZ1ibhZ9nKX5qXwdCFasxjyTWtWVLiaMvQEJQedGvJE9qkxoLYAZ6cLKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1566&quot;/&gt;结合上图，总结一下AOF文件重写的流程：&lt;/p&gt;&lt;h2&gt;数据加载&lt;/h2&gt;&lt;p&gt;Redis启动后通过&lt;code&gt;loadDataFromDisk&lt;/code&gt;函数执行数据加载工作。这里需要注意，虽然持久化方式可以选择AOF、RDB或者两者兼用，但是数据加载时必须做出选择，两种方式各自加载一遍就乱套了。&lt;/p&gt;&lt;p&gt;理论上，AOF持久化比RDB具有更好的实时性，当开启了AOF持久化方式，Redis在数据加载时优先考虑AOF方式。而且，Redis 4.0版本后AOF支持了混合持久化，加载AOF文件需要考虑版本兼容性。Redis数据加载流程如下图所示：&lt;img data-ratio=&quot;1.2099125364431487&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mZx0iasykflulslx70UrnEhGNOnSiboSiaNMKiaEfib0iath26aKqQDX6Z9oAYGzWDK5nSD1hkzphsSvvtYJSsaLXHxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1372&quot;/&gt;在AOF方式下，开启混合持久化机制生成的文件是“RDB头+AOF尾”，未开启时生成的文件全部为AOF格式。考虑两种文件格式的兼容性，如果Redis发现AOF文件为RDB头，会使用RDB数据加载的方法读取并恢复前半部分；然后再使用AOF方式读取并恢复后半部分。由于AOF格式存储的数据为RESP协议命令，Redis采用伪客户端执行命令的方式来恢复数据。&lt;/p&gt;&lt;p&gt;如果在AOF命令追加过程中发生宕机，由于延迟写的技术特点，AOF的RESP命令可能不完整（被截断）。遇到这种情况时，Redis会按照配置项&lt;code&gt;aof-load-truncated&lt;/code&gt;执行不同的处理策略。这个配置是告诉Redis启动时读取aof文件，如果发现文件被截断（不完整）时该如何处理：&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;Redis提供了两种持久化的选择：RDB支持以特定的时间间隔为数据集生成时间点快照；AOF把Redis Server收到的每条写指令持久化到日志中，待Redis重启时通过重放命令恢复数据。日志格式为RESP协议，对日志文件只做append操作，无损坏风险。并且当AOF文件过大时可以自动重写压缩文件。&lt;/p&gt;&lt;p&gt;当然，如果你不需要对数据进行持久化，也可以禁用Redis的持久化功能，但是大多数情况并非如此。实际上，我们是有可能同时使用RDB和AOF两种方式的，最重要的就是我们要理解两者的区别，以便合理使用。&lt;/p&gt;&lt;h3&gt;RDB vs AOF&lt;/h3&gt;&lt;h4&gt;RDB优点&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;RDB是一个紧凑压缩的二进制文件，代表Redis在某一个时间点上的数据快照，非常适合用于备份、全量复制等场景。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;RDB对灾难恢复、数据迁移非常友好，RDB文件可以转移至任何需要的地方并重新加载。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;RDB是Redis数据的内存快照，数据恢复速度较快，相比于AOF的命令重放有着更高的性能。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;RDB缺点&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;RDB方式无法做到实时或秒级持久化。因为持久化过程是通过fork子进程后由子进程完成的，子进程的内存只是在fork操作那一时刻父进程的数据快照，而fork操作后父进程持续对外服务，内部数据时刻变更，子进程的数据不再更新，两者始终存在差异，所以无法做到实时性。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;RDB持久化过程中的fork操作，会导致内存占用加倍，而且父进程数据越多，fork过程越长。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Redis请求高并发可能会频繁命中save规则，导致fork操作及持久化备份的频率不可控；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;RDB文件有文件格式要求，不同版本的Redis会对文件格式进行调整，存在老版本无法兼容新版本的问题。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;AOF优点&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;AOF持久化有更好的实时性，我们可以选择三种不同的方式（appendfsync）：no、every second、always，every second作为默认的策略具有最好的性能，极端情况下可能会丢失一秒的数据。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;AOF文件只有append操作，无复杂的seek等文件操作，没有损坏风险。即使最后写入数据被截断，也很容易使用&lt;code&gt;redis-check-aof&lt;/code&gt;工具修复；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;当AOF文件变大时，Redis可在后台自动重写。重写过程中旧文件会持续写入，重写完成后新文件将变得更小，并且重写过程中的增量命令也会append到新文件。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;AOF文件以已于理解与解析的方式包含了对Redis中数据的所有操作命令。即使不小心错误的清除了所有数据，只要没有对AOF文件重写，我们就可以通过移除最后一条命令找回所有数据。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;AOF已经支持混合持久化，文件大小可以有效控制，并提高了数据加载时的效率。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;AOF缺点&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;对于相同的数据集合，AOF文件通常会比RDB文件大；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在特定的fsync策略下，AOF会比RDB略慢。一般来讲，fsync_every_second的性能仍然很高，fsync_no的性能与RDB相当。但是在巨大的写压力下，RDB更能提供最大的低延时保障。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在AOF上，Redis曾经遇到一些几乎不可能在RDB上遇到的罕见bug。一些特殊的指令（如BRPOPLPUSH）导致重新加载的数据与持久化之前不一致，Redis官方曾经在相同的条件下进行测试，但是无法复现问题。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;使用建议&lt;/h3&gt;&lt;p&gt;对RDB和AOF两种持久化方式的工作原理、执行流程及优缺点了解后，我们来思考下，实际场景中应该怎么权衡利弊，合理的使用两种持久化方式。如果仅仅是使用Redis作为缓存工具，所有数据可以根据持久化数据库进行重建，则可关闭持久化功能，做好预热、缓存穿透、击穿、雪崩之类的防护工作即可。&lt;/p&gt;&lt;p&gt;一般情况下，Redis会承担更多的工作，如分布式锁、排行榜、注册中心等，持久化功能在灾难恢复、数据迁移方面将发挥较大的作用。建议遵循几个原则：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;不要把Redis作为数据库，所有数据尽可能可由应用服务自动重建。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用4.0以上版本Redis，使用AOF+RDB混合持久化功能。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;合理规划Redis最大占用内存，防止AOF重写或save过程中资源不足。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;避免单机部署多实例。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;生产环境多为集群化部署，可在slave开启持久化能力，让master更好的对外提供写服务。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;备份文件应自动上传至异地机房或云存储，做好灾难备份。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;关于fork()&lt;/h3&gt;&lt;p&gt;通过上面的分析，我们都知道RDB的快照、AOF的重写都需要fork，这是一个重量级操作，会对Redis造成阻塞。因此为了不影响Redis主进程响应，我们需要尽可能降低阻塞。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;降低fork的频率，比如可以手动来触发RDB生成快照、与AOF重写；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;控制Redis最大使用内存，防止fork耗时过长；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用更高性能的硬件；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;合理配置Linux的内存分配策略，避免因为物理内存不足导致fork失败。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI0NTE4NDg0NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/mZx0iasykfltUJKaqQlD7oMJoZCwokhwjfJiblpUeuQY6Auvt8vPtFJRWmC1HUfNP2V2UYIVDnkzvSic8NnQy6EcQ/0?wx_fmt=png&quot; data-nickname=&quot;码路印记&quot; data-alias=&quot;&quot; data-signature=&quot;一个后端技术码农的技术笔记，专注互联网后端技术领域，涉及分布式系统、系统架构、微服务、数据库、缓存、搜索、消息队列等话题，欢迎交流！&quot;/&gt;&lt;/section&gt;&lt;h1&gt;参考文献&lt;/h1&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;《一文看懂Redis的持久化原理》 https://juejin.im/post/5b70dfcf518825610f1f5c16&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;《redis 持久化详解,RDB和AOF是什么？他们优缺点是什么？运行流程是什么？》 http://www.chenxm.cc/article/38.html&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;《几率大的Redis面试题（含答案）》 https://blog.csdn.net/Butterfly_resting/article/details/89668661&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;《史上最全Redis面试题(含答案):哨兵+复制+事务+集群+持久化等》https://blog.csdn.net/qq_41699100/article/details/86102235&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;《Redis持久化机制》https://juejin.im/post/5d8587c65188253a4835306b&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;《Reids Persistence》 https://redis.io/topics/persistence。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;《Redis RDB Persistence Details》https://programming.vip/docs/redis-rdb-persistence-details.html&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bf5174f4981b7304b0edd3216e9887ae</guid>
<title>ByxContainer：轻量级 IOC 容器</title>
<link>https://toutiao.io/k/gqu86o1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;ByxContainer是一个用Java编写的轻量级IOC容器，具有以下特性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用JSON格式的配置文件&lt;/li&gt;
&lt;li&gt;支持构造函数注入、静态工厂注入、实例工厂注入、属性注入、setter注入、条件注入&lt;/li&gt;
&lt;li&gt;组件的延迟加载和单例组件&lt;/li&gt;
&lt;li&gt;根据id注册、获取容器中的组件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/byx2000/ByxContainer&quot;&gt;https://github.com/byx2000/ByxContainer&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;配置文件&lt;/h2&gt;

&lt;p&gt;ByxContainer使用JSON作为配置文件的格式。你可以将配置文件命名为任何名字，放在任何你喜欢的路径下。&lt;/p&gt;

&lt;p&gt;ByxContainer配置文件的基本框架如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &quot;typeAlias&quot;:
    {
        // 配置components中使用的类型别名
    },
    &quot;components&quot;:
    {
        // 定义容器中的所有组件
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;|键|类型|说明|是否必须|
|-|-|-|-|
|&lt;code&gt;typeAlias&lt;/code&gt;|对象|&lt;code&gt;components&lt;/code&gt;中使用的类型别名|否|
|&lt;code&gt;components&lt;/code&gt;|对象|定义容器中的所有组件|是|&lt;/p&gt;

&lt;p&gt;关于类型别名的使用，请参考&lt;a href=&quot;#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;组件&lt;/h2&gt;

&lt;p&gt;ByxContainer使用组件来管理系统中的所有对象。组件代表了系统中的一个对象，并封装了该对象的创建过程。每个组件都有一个唯一的key，当我们向ByxContainer注册一个组件时，需要为组件指定一个唯一的key，同时还要定义组件的创建过程和依赖关系。&lt;/p&gt;

&lt;p&gt;ByxContainer的所有组件都定义在&lt;code&gt;components&lt;/code&gt;中。组件以键值对的形式写在&lt;code&gt;components&lt;/code&gt;对象中，键就是组件的id，值就是组件的定义。&lt;/p&gt;

&lt;p&gt;有很多种方式来定义组件，详见下文。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &quot;components&quot;:
    {
        &quot;c1&quot;: ... // 组件c1的定义
        &quot;c2&quot;: ... // 组件c2的定义
        &quot;c3&quot;: ... // 组件c3的定义
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;加载与使用ByxContainer&lt;/h2&gt;

&lt;p&gt;在应用程序的初始化代码中，按照以下方式加载配置文件，并初始化容器：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;InputStream inputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(&quot;配置文件路径&quot;);
ContainerFactory factory = new JsonContainerFactory(inputStream);
Container container = factory.create();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;容器初始化完成后，需要使用注册组件时的id来获取某个特定组件：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;// 获取id为c1的组件
SomeType c1 = container.getComponent(&quot;c1&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;组件的创建方式&lt;/h2&gt;

&lt;p&gt;在ByxContainer中，支持以下四种组件创建方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;常数&lt;/li&gt;
&lt;li&gt;构造函数(constructor)&lt;/li&gt;
&lt;li&gt;静态工厂(static factory)&lt;/li&gt;
&lt;li&gt;实例工厂(instance factor)
### 常数
ByxContainer支持JSON中的所有基本类型常数，包括整数、浮点数、字符串、布尔、null，它们在Java中对应的类型分别是：&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;double&lt;/code&gt;、&lt;code&gt;String&lt;/code&gt;、&lt;code&gt;boolean&lt;/code&gt;、&lt;code&gt;null&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre lang=&quot;json&quot;&gt;&lt;code&gt;{
    &quot;components&quot;:
    {
        &quot;intValue&quot;: 123,
        &quot;doubleValue&quot;: 3.14,
        &quot;stringValue&quot;: &quot;hello&quot;,
        &quot;trueValue&quot;: true,
        &quot;falseValue&quot;: false,
        &quot;nullValue&quot;: null
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上配置声明了几种不同类型的常数组件。&lt;/p&gt;

&lt;h3&gt;构造函数&lt;/h3&gt;

&lt;p&gt;配置构造函数创建方式时，需要指定全限定类名，如果要传递参数则指定参数数组。&lt;/p&gt;

&lt;p&gt;|键|类型|说明|是否必须|
|-|-|-|-|
|&lt;code&gt;class&lt;/code&gt;|字符串|全限定类名|是|
|&lt;code&gt;parameter&lt;/code&gt;|数组|构造函数参数|否|&lt;/p&gt;

&lt;pre lang=&quot;json&quot;&gt;&lt;code&gt;{
    &quot;components&quot;:
    {
        &quot;a1&quot;:
        {
            &quot;class&quot;: &quot;byx.test.A&quot;
        },
        &quot;a2&quot;:
        {
            &quot;class&quot;: &quot;byx.test.A&quot;,
            &quot;parameters&quot;: [&quot;hello&quot;, 123]
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上配置等价于以下Java代码：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;A a1 = new A();
A a2 = new A(&quot;hello&quot;, 123);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：&lt;code&gt;parameters&lt;/code&gt;数组中的元素既可以是常数，也可以嵌套其它组件的定义：&lt;/p&gt;

&lt;pre lang=&quot;json&quot;&gt;&lt;code&gt;{
    &quot;components&quot;:
    {
        &quot;a3&quot;:
        {
            &quot;class&quot;: &quot;byx.test.A&quot;,
            &quot;parameters&quot;: 
            [
                &quot;hello&quot;, 
                123, 
                {&quot;class&quot;: &quot;byx.test.B&quot;}
            ]
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上配置等价于以下Java代码：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;A a3 = new A(&quot;hello&quot;, 123, new B());
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;静态工厂&lt;/h3&gt;

&lt;p&gt;配置静态工厂创建方式时，需要指定工厂类的类名和工厂函数名，如果要传递参数则指定参数数组。&lt;/p&gt;

&lt;p&gt;|键|类型|说明|是否必须|
|-|-|-|-|
|&lt;code&gt;factory&lt;/code&gt;|字符串|工厂类全限定类名|是|
|&lt;code&gt;method&lt;/code&gt;|字符串|工厂类静态方法名|是|
|&lt;code&gt;parameter&lt;/code&gt;|数组|方法参数|否|&lt;/p&gt;

&lt;pre lang=&quot;json&quot;&gt;&lt;code&gt;{
    &quot;components&quot;:
    {
        &quot;a1&quot;:
        {
            &quot;factory&quot;: &quot;byx.test.Factory&quot;,
            &quot;method&quot;: &quot;createDefault&quot;
        },
        &quot;a2&quot;:
        {
            &quot;factory&quot;: &quot;byx.test.Factory&quot;,
            &quot;method&quot;: &quot;create&quot;,
            &quot;parameters&quot;: [&quot;hello&quot;, 123]
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上配置等价于以下Java代码：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;A a1 = Factory.createDefault();
A a2 = Factory.create(&quot;hello&quot;, 123);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;实例工厂&lt;/h3&gt;

&lt;p&gt;配置实例工厂创建方式时，需要指定实例组件和工厂函数名，如果要传递参数则指定参数数组。&lt;/p&gt;

&lt;p&gt;|键|类型|说明|是否必须|
|-|-|-|-|
|&lt;code&gt;instance&lt;/code&gt;|对象或基本类型|实例组件定义|是|
|&lt;code&gt;method&lt;/code&gt;|字符串|实例工厂方法名|是|
|&lt;code&gt;parameter&lt;/code&gt;|数组|方法参数|否|&lt;/p&gt;

&lt;pre lang=&quot;json&quot;&gt;&lt;code&gt;{
    &quot;components&quot;:
    {
        &quot;a1&quot;:
        {
            &quot;instance&quot;: {&quot;class&quot;: &quot;byx.test.B&quot;},
            &quot;method&quot;: &quot;createDefault&quot;
        },
        &quot;a2&quot;:
        {
            &quot;instance&quot;: {&quot;class&quot;: &quot;byx.test.B&quot;},
            &quot;method&quot;: &quot;create&quot;,
            &quot;parameters&quot;: [&quot;hello&quot;, 123]
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上配置等价于以下Java代码：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;A a1 = new B().createDefault();
A a2 = new B().create(&quot;hello&quot;, 123);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;组件的依赖声明&lt;/h2&gt;

&lt;p&gt;声明完组件的创建方式后，还可继续声明组件的依赖。ByxContainer支持以下两种依赖声明方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;属性设置&lt;/li&gt;
&lt;li&gt;setter方法
### 属性设置
ByxContainer支持在组件创建完成之后对组件的属性进行设置。这里的属性等同于JavaBean的Property。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;|键|类型|说明|是否必须|
|-|-|-|-|
|&lt;code&gt;properties&lt;/code&gt;|对象|(属性名, 属性值)键值对|否|&lt;/p&gt;

&lt;pre lang=&quot;json&quot;&gt;&lt;code&gt;{
    &quot;components&quot;:
    {
        &quot;a&quot;: 
        {
            &quot;class&quot;: &quot;byx.test.A&quot;,
            &quot;properties&quot;:
            {
                &quot;id&quot;: 1001,
                &quot;name&quot;: &quot;byx&quot;,
                &quot;score&quot;: 97.5
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上配置等价于以下Java代码：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;A a = new A();
a.setId(1001);
a.setName(&quot;byx&quot;);
a.setScore(97.5);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：&lt;code&gt;properties&lt;/code&gt;中的属性值既可以是常数，也可以嵌套其它组件的定义：&lt;/p&gt;

&lt;pre lang=&quot;json&quot;&gt;&lt;code&gt;{
    &quot;components&quot;:
    {
        &quot;a&quot;: 
        {
            &quot;class&quot;: &quot;byx.test.A&quot;,
            &quot;properties&quot;:
            {
                &quot;id&quot;: 1001,
                &quot;b&quot;: {&quot;class&quot;: &quot;byx.test.B&quot;}
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上配置等价于以下Java代码：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;A a = new A();
a.setId(1001);
a.setB(new B());
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;setter方法&lt;/h3&gt;

&lt;p&gt;ByxContainer支持在组件创建完成之后调用组件的setter方法，并传递参数。&lt;/p&gt;

&lt;p&gt;|键|类型|说明|是否必须|
|-|-|-|-|
|&lt;code&gt;setters&lt;/code&gt;|对象|(setter方法名, 方法参数)键值对|否|&lt;/p&gt;

&lt;pre lang=&quot;json&quot;&gt;&lt;code&gt;{
    &quot;components&quot;:
    {
        &quot;a&quot;: 
        {
            &quot;class&quot;: &quot;byx.test.A&quot;,
            &quot;setters&quot;:
            {
                &quot;setId&quot;: [1001],
                &quot;setNameAndScore&quot;: [&quot;byx&quot;, 97.5]
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上配置等价于以下Java代码：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;A a = new A();
a.setId(1001);
a.setNameAndScore(&quot;byx&quot;, 97.5);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;其它组件定义&lt;/h2&gt;

&lt;p&gt;ByxContainer还支持以下特殊组件定义：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;集合组件&lt;/li&gt;
&lt;li&gt;引用组件&lt;/li&gt;
&lt;li&gt;条件组件
### 集合组件
ByxContainer支持&lt;code&gt;List&lt;/code&gt;、&lt;code&gt;Set&lt;/code&gt;和&lt;code&gt;Map&lt;/code&gt;这三种集合组件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面是这三种集合组件的定义：&lt;/p&gt;

&lt;pre lang=&quot;json&quot;&gt;&lt;code&gt;{
    &quot;components&quot;:
    {
        &quot;c1&quot;: {&quot;list&quot;: [1, 2, 3]},
        &quot;c2&quot;: {&quot;set&quot;: [4, 5, 6]},
        &quot;c3&quot;: 
        {
            &quot;map&quot;:
            {
                &quot;k1&quot;: 100,
                &quot;k2&quot;: 200,
                &quot;k3&quot;: 300
            }
        },
        &quot;c4&quot;:
        {
            &quot;map&quot;:
            [
                {&quot;key&quot;: 400, &quot;value&quot;: &quot;v1&quot;},
                {&quot;key&quot;: 500, &quot;value&quot;: &quot;v2&quot;},
                {&quot;key&quot;: 600, &quot;value&quot;: &quot;v3&quot;}
            ]
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上配置等价于以下Java代码：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;List&amp;lt;Object&amp;gt; c1 = List.of(1, 2, 3);
Set&amp;lt;Object&amp;gt; c2 = Set.of(4, 5, 6);
Map&amp;lt;Object&amp;gt; c3 = Map.of(&quot;k1&quot;, 100, &quot;k2&quot;, 200, &quot;k3&quot;, 300);
Map&amp;lt;Object&amp;gt; c4 = Map.of(400, &quot;v1&quot;, 500, &quot;v2&quot;, 600, &quot;v3&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;集合组件的元素既可以是常数，也可以嵌套其它组件的定义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c3&lt;/code&gt;和&lt;code&gt;c4&lt;/code&gt;是&lt;code&gt;Map&lt;/code&gt;组件的两种不同定义方式。第一种只支持&lt;code&gt;String&lt;/code&gt;类型的key，第二种支持任意数据类型的key
### 引用组件
ByxContainer既支持对全局组件的引用，也支持对局部组件的引用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;|键|类型|说明|是否必须|
|-|-|-|-|
|&lt;code&gt;ref&lt;/code&gt;|字符串|引用的组件key|是|&lt;/p&gt;

&lt;pre lang=&quot;json&quot;&gt;&lt;code&gt;{
    &quot;components&quot;:
    {
        &quot;a1&quot;: {&quot;class&quot;: &quot;byx.test.A&quot;},
        &quot;a2&quot;: {&quot;ref&quot;: &quot;a1&quot;}
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上配置等价于以下Java代码：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;A a1 = new A();
A a2 = a1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：关于局部组件，请参考&lt;a href=&quot;#%E5%B1%80%E9%83%A8%E7%BB%84%E4%BB%B6&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;h3&gt;条件组件&lt;/h3&gt;

&lt;p&gt;ByxContainer支持根据不同条件产生不同的组件定义。&lt;/p&gt;

&lt;p&gt;|键|类型|说明|是否必须|
|-|-|-|-|
|&lt;code&gt;if&lt;/code&gt;|对象或基本类型|作为条件的组件定义|是|
|&lt;code&gt;then&lt;/code&gt;|对象或基本类型|条件为真时产生的组件|是|
|&lt;code&gt;else&lt;/code&gt;|对象或基本类型|条件为假时产生的组件|是|&lt;/p&gt;

&lt;pre lang=&quot;json&quot;&gt;&lt;code&gt;{
    &quot;components&quot;:
    {
        &quot;flag&quot;: true,
        &quot;c&quot;:
        {
            &quot;if&quot;: {&quot;ref&quot;: &quot;flag&quot;},
            &quot;then&quot;: {&quot;class&quot;: &quot;com.byx.A&quot;},
            &quot;else&quot;: {&quot;class&quot;: &quot;com.byx.B&quot;}
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上配置等价于以下Java代码：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;boolean flag = true;
Object c;
if (flag)
    c = new A();
else
    c = new B();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：当&lt;code&gt;if&lt;/code&gt;设置成一个组件定义时，容器将把该组件创建的对象解释成&lt;code&gt;boolean&lt;/code&gt;值，如果该组件创建的对象不是&lt;code&gt;boolean&lt;/code&gt;类型，则当成&lt;code&gt;false&lt;/code&gt;处理。&lt;/p&gt;

&lt;h2&gt;高级特性&lt;/h2&gt;

&lt;p&gt;ByxContainer还支持以下高级特性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;局部组件&lt;/li&gt;
&lt;li&gt;单例组件&lt;/li&gt;
&lt;li&gt;自定义组件&lt;/li&gt;
&lt;li&gt;自定义转换器&lt;/li&gt;
&lt;li&gt;类型别名
### 局部组件
有时候，某些组件的创建过程中需要用到其它的组件，如下面这个例子：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;A a = new A(&quot;hello&quot;, &quot;123&quot;, new B());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以按照如下方式来配置：&lt;/p&gt;

&lt;pre lang=&quot;json&quot;&gt;&lt;code&gt;{
    &quot;components&quot;:
    {
        &quot;msg&quot;: &quot;hello&quot;,
        &quot;val&quot;: 123,
        &quot;b&quot;: {&quot;class&quot;: &quot;byx.test.B&quot;},
        &quot;a&quot;:
        {
            &quot;class&quot;: &quot;byx.test.A&quot;,
            &quot;parameters&quot;: [{&quot;ref&quot;: &quot;msg&quot;}, {&quot;ref&quot;: &quot;val&quot;}, {&quot;ref&quot;: &quot;b&quot;}]
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;A&lt;/code&gt;的构造函数中传递的三个参数分别属于三个不同的组件，但是这三个组件仅仅用于构建&lt;code&gt;A&lt;/code&gt;对象，我们不希望这些临时组件占用容器中的一个key。当然，可以使用一种“就地初始化”的写法：&lt;/p&gt;

&lt;pre lang=&quot;json&quot;&gt;&lt;code&gt;{
    &quot;components&quot;:
    {
        &quot;a&quot;:
        {
            &quot;class&quot;: &quot;byx.test.A&quot;,
            &quot;parameters&quot;: 
            [
                &quot;hello&quot;, 
                123, 
                {&quot;class&quot;: &quot;byx.test.B&quot;}
            ]
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种写法可以隐藏临时组件，但是当组件创建过程比较复杂的时候，这种写法会形成深层次的嵌套结构，导致可读性变差。而且，这种写法也不能很好地应对某个临时组件被多次使用的情况，例如：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;B b = new B();
A a = new A(b, b);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上问题可以使用ByxContainer提供的局部组件来解决：&lt;/p&gt;

&lt;pre lang=&quot;json&quot;&gt;&lt;code&gt;{
    &quot;components&quot;:
    {
        &quot;a&quot;:
        {
            &quot;class&quot;: &quot;byx.test.A&quot;,
            &quot;parameters&quot;: [{&quot;ref&quot;: &quot;msg&quot;}, {&quot;ref&quot;: &quot;val&quot;}, {&quot;ref&quot;: &quot;b&quot;}],
            &quot;locals&quot;:
            {
                &quot;msg&quot;: &quot;hello&quot;,
                &quot;val&quot;: 123,
                &quot;b&quot;: {&quot;class&quot;: &quot;byx.test.B&quot;}
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;a&lt;/code&gt;组件定义的内部有一个&lt;code&gt;locals&lt;/code&gt;块，里面包含了属于&lt;code&gt;a&lt;/code&gt;的局部组件定义，这些局部组件不会占用容器的全局key，它只能在组件&lt;code&gt;a&lt;/code&gt;的作用域内被引用。如果局部组件的key与全局组件的key相同，则局部组件将会覆盖全局组件。&lt;/p&gt;

&lt;h3&gt;单例组件&lt;/h3&gt;

&lt;p&gt;在默认情况下，ByxContainer中的所有组件都是单例的，这意味着组件最多只会被创建一次。当你多次获取同一个组件时，所得到的是同一个对象实例：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;Object c1 = container.getComponent(&quot;c1&quot;);
Object c2 = container.getComponent(&quot;c2&quot;);
// c1与c2指向同一个对象
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想要改变这个默认行为，只需要在组件定义中加入如下配置：&lt;/p&gt;

&lt;pre lang=&quot;json&quot;&gt;&lt;code&gt;&quot;singleton&quot;: false
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;自定义组件&lt;/h3&gt;

&lt;p&gt;ByxContainer支持用户定义自己的组件，并在配置文件中使用。&lt;/p&gt;

&lt;p&gt;用户可以通过实现&lt;code&gt;byx.container.component.Component&lt;/code&gt;接口来创建自己的组件：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public interface Component
{
    Object create();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Component&lt;/code&gt;接口中的&lt;code&gt;create&lt;/code&gt;方法封装了对象创建的细节：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class MyComponent implements Component
{
    private final String msg;
    private final int val;

    public MyComponent()
    {
        MyComponent(&quot;hello&quot;, 123);
    }

    public MyComponent(String msg, int val)
    {
        this.msg = msg;
        this.val = val;
    }

    @Override
    public Object create()
    {
        return new A(msg, val);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在配置文件中使用自定义组件，需要指定自定义组件的全限定类名，如果想传递构造函数参数，则需指定参数列表。&lt;/p&gt;

&lt;p&gt;|键|类型|说明|是否必须|
|-|-|-|-|
|&lt;code&gt;custom&lt;/code&gt;|字符串|自定义组件的全限定类名|是|
|&lt;code&gt;parameters&lt;/code&gt;|数组|传递给自定义组件的构造函数参数|否|&lt;/p&gt;

&lt;pre lang=&quot;json&quot;&gt;&lt;code&gt;{
    &quot;components&quot;:
    {
        &quot;a1&quot;:
        {
            &quot;custom&quot;: &quot;byx.test.MyComponent&quot;
        },
        &quot;a2&quot;:
        {
            &quot;custom&quot;: &quot;byx.test.MyComponent&quot;,
            &quot;parameters&quot;: [&quot;hi&quot;, 456]
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上配置等价于以下Java代码：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;A a1 = new MyComponent().create();
A a2 = new MyComponent(&quot;hi&quot;, 456).create();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;自定义转换器&lt;/h3&gt;

&lt;p&gt;ByxContainer支持对组件创建出来的对象进行进一步转换。用户需要通过实现&lt;code&gt;byx.container.component.Mapper&lt;/code&gt;接口来创建自定义转换器：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public interface Mapper
{
    Object map(Object obj);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Mapper&lt;/code&gt;接口中的&lt;code&gt;map&lt;/code&gt;方法封装了对组件创建结果的处理：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class MyMapper implements Mapper
{
    private final int val;

    public MyMapper()
    {
        MyMapper(1);
    }

    public MyMapper(int val)
    {
        this.val = val;
    }

    @Override
    public Object map(Object obj)
    {
        if (obj instanceof Integer)
            return ((int) obj) + val;
        return obj;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在配置文件中使用自定义转换器，需要在组件定义中指定&lt;code&gt;mapper&lt;/code&gt;属性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当&lt;code&gt;mapper&lt;/code&gt;属性为字符串时，该字符串表示自定义&lt;code&gt;mapper&lt;/code&gt;的全限定类名，同时用默认构造函数来创建该&lt;code&gt;mapper&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;mapper&lt;/code&gt;属性为对象时，对象中必须包含&lt;code&gt;class&lt;/code&gt;和&lt;code&gt;parameters&lt;/code&gt;属性，其中&lt;code&gt;class&lt;/code&gt;表示&lt;code&gt;mapper&lt;/code&gt;的全限定类名，&lt;code&gt;parameters&lt;/code&gt;表示创建&lt;code&gt;mapper&lt;/code&gt;时向构造函数传递的参数&lt;/li&gt;
&lt;/ul&gt;

&lt;pre lang=&quot;json&quot;&gt;&lt;code&gt;{
    &quot;components&quot;:
    {
        &quot;c1&quot;:
        {
            &quot;class&quot;: &quot;java.lang.Integer&quot;,
            &quot;parameters&quot;: [123],
            &quot;mapper&quot;: &quot;byx.test.MyMapper&quot;
        },
        &quot;c1&quot;:
        {
            &quot;class&quot;: &quot;java.lang.Integer&quot;,
            &quot;parameters&quot;: [123],
            &quot;mapper&quot;:
            {
                &quot;class&quot;: &quot;byx.test.MyMapper&quot;,
                &quot;parameters&quot;: [100]
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上配置等价于以下Java代码：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;int c1 = (int) new MyMapper().map(container.getComponent(&quot;c1&quot;));
int c2 = (int) new MyMapper(100).map(container.getComponent(&quot;c2&quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;类型别名&lt;/h3&gt;

&lt;p&gt;为了避免键入大量冗长的全限定类名，ByxContainer提供了类型别名功能，只需在容器定义最外层添加&lt;code&gt;typeAlias&lt;/code&gt;配置：&lt;/p&gt;

&lt;pre lang=&quot;json&quot;&gt;&lt;code&gt;{
    &quot;typeAlias&quot;:
    {
        &quot;A&quot;: &quot;byx.test.A&quot;,
        &quot;B&quot;: &quot;byx.test.B&quot;
    },
    &quot;components&quot;:
    {
        &quot;a&quot;:
        {
            &quot;class&quot;: &quot;A&quot;,
            &quot;parameters&quot;: [&quot;hello&quot;, 123]
        },
        &quot;b&quot;:
        {
            &quot;class&quot;: &quot;B&quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上配置等价于以下Java代码：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;A a = new A(&quot;hello&quot;, 123);
B b = new B();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：&lt;code&gt;components&lt;/code&gt;中所有出现类名的地方都可以使用&lt;code&gt;typeAlias&lt;/code&gt;中定义的别名，包括&lt;code&gt;class&lt;/code&gt;、&lt;code&gt;factory&lt;/code&gt;、&lt;code&gt;custom&lt;/code&gt;等等。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b6c91bd9be2867daf9d6a2cf6b79e0db</guid>
<title>​微服务 CI/CD 实践：GitOps 完整设计与实现</title>
<link>https://toutiao.io/k/ch5kfo9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;感谢这安静的环境，没有它们我是无法完成这篇文章的。&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/U1oibTqyKuTMxj8LBHpNLlPRlIUQibX2VjGU3PK6gkwyLKpxlpcWpzHw8BFFKOcTiaTeLT9h5NmWOVg3pEIz6XzLA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单应用与环境&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.33530405405405406&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTMxj8LBHpNLlPRlIUQibX2VjwUCXoRkd9skoRpTIEbqFfXyur16iaMJ6ibYHFEwbHf0LZxnXowNJmLCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1184&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多应用与环境&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3227739726027397&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTMxj8LBHpNLlPRlIUQibX2VjUia4lkVsf8vLB1Xz2w5NmEY2bxeMPQSzw1bJzEDZZ8XEGOuiaOlwyt0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1168&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;CI持续集成&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先准备一个代码库：https://github.com/DevOpsCICDCourse/microservicescicd/blob/main/microservice-demo-service-master.zip&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5756013745704467&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTMxj8LBHpNLlPRlIUQibX2Vjm8aScdib5KyI4Fxnfx6aRWpBrouuneycV3r82iaicnmUtLfo8MW4RRCDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1164&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来梳理一下CI流水线的步骤：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4444444444444444&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTMxj8LBHpNLlPRlIUQibX2Vjps094A5IO20HI3hxarAlzs9MS0biaejzId7M3dTS1T9KSqApOWZzfyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1143&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;由于此次实现的代码仓库类型为单一存储库，即一个存储库存放多个服务模块代码，每个子目录为一个服务模块。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;首先，我们的持续集成流水线需要能够正确获取，当前的commit是哪个服务的代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;确定好服务，然后下载该服务的代码，进行编译打包、单元测试、代码扫描和构建镜像等步骤。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何获取commit的服务信息？这里我们使用GitLab WebHook功能和Jenkins 的job 构建触发器对接来实现。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.41191489361702127&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTMxj8LBHpNLlPRlIUQibX2Vj86XGBlOaqB8uPYephfPC8p9OqbBDsqrXOT2e3bYvkBxR2KBxJEfrwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1175&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;span&gt;工作流程是：&lt;/span&gt;&lt;span&gt;当我在Gitlab提交了代码，会通过GitLab webhook 触发Jenkins Scheduler 作业， 会将此次提交代码所产生的hook data数据信息以POST的方式传给Jenkins Job。&lt;/span&gt;&lt;span&gt;此时Jenkins job可以编写使用Generic Hook插件获取此次POST请求传输过来的请求体Body信息。&lt;/span&gt;&lt;span&gt;是一段JSON数据， 该job运行后编写Pipeline 解析JSON中的数据拿到所变更的服务模块信息。&lt;/span&gt;&lt;span&gt;最后触发对应服务的CI作业进行构建。&lt;/span&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;CI-Scheduler 作业&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此作业只需要开启webhook， 配置触发token（唯一性）。生成hookurl：http://jenkins.idevops.site/generic-webhook-trigger/invoke?token=microservicecicd-scheduler-CI&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.48125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTMxj8LBHpNLlPRlIUQibX2Vjk21QCa5SZYhAY5wPicaOEVYQqTw9t8fXrhVKtryeOYEHBRia7ibAp50bQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.19746376811594202&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTMxj8LBHpNLlPRlIUQibX2VjAUVo4IcFP4jTGtJTtWmuzOzvTda8e8OOhghMvT8GtwuGoht7gZnX0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1104&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Jenkinsfile&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;pipeline {&lt;br/&gt; agent any &lt;br/&gt;&lt;br/&gt; stages{&lt;br/&gt;&lt;br/&gt;  stage(&lt;span&gt;&quot;GetData&quot;&lt;/span&gt;){&lt;br/&gt;   steps{&lt;br/&gt;    script {&lt;br/&gt;     &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;span&gt;${webHookData}&lt;/span&gt;&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;     data = readJSON  text: &lt;span&gt;&quot;&lt;span&gt;${webHookData}&lt;/span&gt;&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;     println(data)&lt;br/&gt;&lt;br/&gt;     env.branchName = data.ref - &lt;span&gt;&quot;refs/heads/&quot;&lt;/span&gt;&lt;br/&gt;     env.commitId = data.checkout_sha&lt;br/&gt;     env.projectId = data.project_id&lt;br/&gt;     commits = data[&lt;span&gt;&quot;commits&quot;&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;     println(&lt;span&gt;&quot;&lt;span&gt;${env.branchName}&lt;/span&gt;&quot;&lt;/span&gt;)&lt;br/&gt;     println(&lt;span&gt;&quot;&lt;span&gt;${env.commitID}&lt;/span&gt;&quot;&lt;/span&gt;)&lt;br/&gt;     println(&lt;span&gt;&quot;&lt;span&gt;${env.projectId}&lt;/span&gt;&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;     //env.moduleName = &lt;span&gt;&quot;service01&quot;&lt;/span&gt;&lt;br/&gt;     changeServices = []&lt;br/&gt;                    &lt;span&gt;for&lt;/span&gt;(commit &lt;span&gt;in&lt;/span&gt; commits) {&lt;br/&gt;                        println(commit.id)&lt;br/&gt;&lt;br/&gt;                        //added&lt;br/&gt;                        &lt;span&gt;for&lt;/span&gt; (add &lt;span&gt;in&lt;/span&gt; commit.added) {&lt;br/&gt;                            s = add.split(&lt;span&gt;&quot;/&quot;&lt;/span&gt;) as List&lt;br/&gt;                            &lt;span&gt;if&lt;/span&gt; (s.size() &amp;gt; 1){&lt;br/&gt;                                &lt;span&gt;if&lt;/span&gt; (changeServices.indexOf(s[0]) == -1){&lt;br/&gt;                                    changeServices.add(s[0])&lt;br/&gt;                                }&lt;br/&gt;                            }&lt;br/&gt;                        }&lt;br/&gt;&lt;br/&gt;                        //modified&lt;br/&gt;                        &lt;span&gt;for&lt;/span&gt; (m &lt;span&gt;in&lt;/span&gt; commit.modified) {&lt;br/&gt;                            s = m.split(&lt;span&gt;&quot;/&quot;&lt;/span&gt;) as List&lt;br/&gt;                            // println s&lt;br/&gt;                            // println s.size()&lt;br/&gt;                            // println s[0]&lt;br/&gt;                            &lt;span&gt;if&lt;/span&gt; (s.size() &amp;gt; 1){&lt;br/&gt;                                // println changeServices.indexOf(s[0])&lt;br/&gt;                                &lt;span&gt;if&lt;/span&gt; (changeServices.indexOf(s[0]) == -1){&lt;br/&gt;                                    changeServices.add(s[0])&lt;br/&gt;                                }&lt;br/&gt;                            }&lt;br/&gt;                        }&lt;br/&gt;&lt;br/&gt;                        //removed&lt;br/&gt;                        &lt;span&gt;for&lt;/span&gt; (r &lt;span&gt;in&lt;/span&gt; commit.removed) {&lt;br/&gt;                            s = r.split(&lt;span&gt;&quot;/&quot;&lt;/span&gt;) as List&lt;br/&gt;                            println s&lt;br/&gt;                            &lt;span&gt;if&lt;/span&gt; (s.size() &amp;gt; 1){&lt;br/&gt;                                &lt;span&gt;if&lt;/span&gt; (changeServices.indexOf(s[0]) == -1){&lt;br/&gt;                                    changeServices.add(s[0])&lt;br/&gt;                                }&lt;br/&gt;                            }&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;&lt;br/&gt;                    println(changeServices)&lt;br/&gt;                    //currentBuild.description = &lt;span&gt;&quot; Trigger by  &lt;span&gt;${eventType}&lt;/span&gt; &lt;span&gt;${changeServices}&lt;/span&gt; &lt;br/&gt;    }&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  stage(&#x27;DefineService&#x27;) {&lt;br/&gt;            steps {&lt;br/&gt;                script{&lt;br/&gt;                    println(changeServices)&lt;br/&gt;                    //服务构建顺序控制&lt;br/&gt;                    services = [&#x27;service02&#x27;, &#x27;service01&#x27;]&lt;br/&gt;                    for (service in services){&lt;br/&gt;                        if (changeServices.indexOf(service) != -1){&lt;br/&gt;                            jobName = &#x27;microservicecicd-&#x27;+service+&#x27;-service-CI&#x27;&lt;br/&gt;                            build job: jobName, wait: false,  parameters: [string(name: &#x27;branchName&#x27;, value: &quot;&lt;/span&gt;&lt;span&gt;${env.branchName}&lt;/span&gt;&lt;span&gt;&quot; ),&lt;br/&gt;                                                                           string(name: &#x27;commitId&#x27;,   value: &quot;&lt;/span&gt;&lt;span&gt;${env.commitId}&lt;/span&gt;&lt;span&gt;&quot; ), &lt;br/&gt;                                                                           string(name: &#x27;projectId&#x27;,  value: &quot;&lt;/span&gt;&lt;span&gt;${env.projectId}&lt;/span&gt;&lt;span&gt;&quot; )]&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;GitLab 配置WebHook&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开启webhook，配置hookurl：http://jenkins.idevops.site/generic-webhook-trigger/invoke?token=microservicecicd-scheduler-CI&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4046875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTMxj8LBHpNLlPRlIUQibX2VjO2twiaOuAxkM1xXNz2vY0RvjibB9HWEYMNz3OLJPt88SEeBtWRd6Y7FQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;CI流水线-CI作业&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个微服务创建一个CI作业，具有三个字符串参数：分支名称、commitID、项目ID。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2748375116063138&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTMxj8LBHpNLlPRlIUQibX2Vjy6SCny2Aw5MJsdVfmziaMlzvfup8ZSbjAF4om6ibSqoOjoURSVLVekEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1077&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Jenkinsfile&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String branchName = &lt;span&gt;&quot;&lt;span&gt;${env.branchName}&lt;/span&gt;&quot;&lt;/span&gt;&lt;br/&gt;String moduleName = &lt;span&gt;&quot;&lt;span&gt;${JOB_NAME}&lt;/span&gt;&quot;&lt;/span&gt;.split(&lt;span&gt;&quot;/&quot;&lt;/span&gt;)[1].split(&lt;span&gt;&quot;-&quot;&lt;/span&gt;)[1]&lt;br/&gt;String srcUrl = &lt;span&gt;&quot;http://gitlab.idevops.site/microservicecicd/microservicecicd-demo-service.git&quot;&lt;/span&gt;&lt;br/&gt;String commitId = &lt;span&gt;&quot;&lt;span&gt;${env.commitId}&lt;/span&gt;&quot;&lt;/span&gt;&lt;br/&gt;String projectId = &lt;span&gt;&quot;&lt;span&gt;${env.projectId}&lt;/span&gt;&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;pipeline {&lt;br/&gt;    agent { node { label &lt;span&gt;&quot;build&quot;&lt;/span&gt; } }&lt;br/&gt;&lt;br/&gt;    stages {&lt;br/&gt;        stage(&lt;span&gt;&#x27;GetCode&#x27;&lt;/span&gt;) {&lt;br/&gt;            steps {&lt;br/&gt;                script {&lt;br/&gt;                    checkout([&lt;span&gt;$class&lt;/span&gt;: &lt;span&gt;&#x27;GitSCM&#x27;&lt;/span&gt;, &lt;br/&gt;                            branches: [[name: &lt;span&gt;&quot;&lt;span&gt;${branchName}&lt;/span&gt;&quot;&lt;/span&gt;]], &lt;br/&gt;                            doGenerateSubmoduleConfigurations: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;                            extensions: [[&lt;span&gt;$class&lt;/span&gt;: &lt;span&gt;&#x27;SparseCheckoutPaths&#x27;&lt;/span&gt;, &lt;br/&gt;                                        sparseCheckoutPaths: [[path: &lt;span&gt;&quot;&lt;span&gt;${moduleName}&lt;/span&gt;&quot;&lt;/span&gt;],[path: &lt;span&gt;&#x27;Dockerfile&#x27;&lt;/span&gt;]]]], &lt;br/&gt;                            submoduleCfg: [], &lt;br/&gt;                            userRemoteConfigs: [[credentialsId: &lt;span&gt;&#x27;gitlab-admin-user&#x27;&lt;/span&gt;,&lt;br/&gt;                                                url: &lt;span&gt;&quot;&lt;span&gt;${srcUrl}&lt;/span&gt;&quot;&lt;/span&gt;]]])&lt;br/&gt;                }&lt;br/&gt;                &lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        stage(&lt;span&gt;&quot;Build&amp;amp;Test&quot;&lt;/span&gt;){&lt;br/&gt;            steps{&lt;br/&gt;                script{&lt;br/&gt;                    &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;Build...........&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                    sh &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;br/&gt;                    cd &lt;span&gt;${moduleName}&lt;/span&gt; &lt;br/&gt;                    mvn clean package&lt;br/&gt;&lt;br/&gt;                    &quot;&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            post {&lt;br/&gt;                always {&lt;br/&gt;                    junit &lt;span&gt;&quot;&lt;span&gt;${moduleName}&lt;/span&gt;/target/surefire-reports/*.xml&quot;&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        stage(&lt;span&gt;&quot;SonarScan&quot;&lt;/span&gt;){&lt;br/&gt;            steps{&lt;br/&gt;                script{&lt;br/&gt;&lt;br/&gt;                    def sonarDate = sh returnStdout: &lt;span&gt;true&lt;/span&gt;, script: &lt;span&gt;&#x27;date  +%Y%m%d%H%M%S&#x27;&lt;/span&gt;&lt;br/&gt;                    sonarDate = sonarDate - &lt;span&gt;&quot;\n&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                    withCredentials([string(credentialsId: &lt;span&gt;&#x27;sonar-admin-user&#x27;&lt;/span&gt;, variable: &lt;span&gt;&#x27;sonartoken&#x27;&lt;/span&gt;),&lt;br/&gt;                                    string(credentialsId: &lt;span&gt;&#x27;gitlab-user-token&#x27;&lt;/span&gt;, variable: &lt;span&gt;&#x27;gitlabtoken&#x27;&lt;/span&gt;)]) {&lt;br/&gt;                        // some block&lt;br/&gt;                        sh &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;br/&gt;                        cd &lt;span&gt;${moduleName}&lt;/span&gt; &lt;br/&gt;                        sonar-scanner \&lt;br/&gt;                        -Dsonar.projectKey=&lt;span&gt;${JOB_NAME}&lt;/span&gt; \&lt;br/&gt;                        -Dsonar.projectName=&lt;span&gt;${JOB_NAME}&lt;/span&gt; \&lt;br/&gt;                        -Dsonar.projectVersion=&lt;span&gt;${sonarDate}&lt;/span&gt; \&lt;br/&gt;                        -Dsonar.ws.timeout=30 \&lt;br/&gt;                        -Dsonar.projectDescription=&quot;&lt;/span&gt;xxxxxxx&lt;span&gt;&quot; \&lt;br/&gt;                        -Dsonar.links.homepage=http://www.baidu.com \&lt;br/&gt;                        -Dsonar.sources=src \&lt;br/&gt;                        -Dsonar.sourceEncoding=UTF-8 \&lt;br/&gt;                        -Dsonar.java.binaries=target/classes \&lt;br/&gt;                        -Dsonar.java.test.binaries=target/test-classes \&lt;br/&gt;                        -Dsonar.java.surefire.report=target/surefire-reports \&lt;br/&gt;                        -Dsonar.host.url=&quot;&lt;/span&gt;http://sonar.idevops.site&lt;span&gt;&quot; \&lt;br/&gt;                        -Dsonar.login=&lt;span&gt;${sonartoken}&lt;/span&gt; \&lt;br/&gt;                        -Dsonar.gitlab.commit_sha=&lt;span&gt;${commitId}&lt;/span&gt; \&lt;br/&gt;                        -Dsonar.gitlab.ref_name=&lt;span&gt;${branchName}&lt;/span&gt; \&lt;br/&gt;                        -Dsonar.gitlab.project_id=&lt;span&gt;${projectId}&lt;/span&gt; \&lt;br/&gt;                        -Dsonar.dynamicAnalysis=reuseReports \&lt;br/&gt;                        -Dsonar.gitlab.failure_notification_mode=commit-status \&lt;br/&gt;                        -Dsonar.gitlab.url=http://gitlab.idevops.site \&lt;br/&gt;                        -Dsonar.gitlab.user_token=&lt;span&gt;${gitlabtoken}&lt;/span&gt; \&lt;br/&gt;                        -Dsonar.gitlab.api_version=v4&lt;br/&gt;&lt;br/&gt;                        &quot;&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                    }&lt;br/&gt; &lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        stage(&lt;span&gt;&quot;BuildImage&quot;&lt;/span&gt;){&lt;br/&gt;            steps{&lt;br/&gt;                script{&lt;br/&gt;&lt;br/&gt;                     withCredentials([usernamePassword(credentialsId: &lt;span&gt;&#x27;aliyun-registry-admin&#x27;&lt;/span&gt;, passwordVariable: &lt;span&gt;&#x27;password&#x27;&lt;/span&gt;, usernameVariable: &lt;span&gt;&#x27;username&#x27;&lt;/span&gt;)]) {&lt;br/&gt;                &lt;br/&gt;                         env.nowDate = sh  returnStdout: &lt;span&gt;true&lt;/span&gt;, script: &lt;span&gt;&#x27;date  +%Y%m%d%H%M%S&#x27;&lt;/span&gt;&lt;br/&gt;                         env.nowDate = env.nowDate - &lt;span&gt;&quot;\n&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                         env.releaseVersion = &lt;span&gt;&quot;&lt;span&gt;${env.branchName}&lt;/span&gt;&quot;&lt;/span&gt;&lt;br/&gt;                         env.imageTag = &lt;span&gt;&quot;&lt;span&gt;${releaseVersion}&lt;/span&gt;-&lt;span&gt;${nowDate}&lt;/span&gt;-&lt;span&gt;${commitId}&lt;/span&gt;&quot;&lt;/span&gt;&lt;br/&gt;                         env.dockerImage = &lt;span&gt;&quot;registry.cn-beijing.aliyuncs.com/microservicecicd/microservicecicd-&lt;span&gt;${moduleName}&lt;/span&gt;-service:&lt;span&gt;${env.imageTag}&lt;/span&gt;&quot;&lt;/span&gt;&lt;br/&gt;                         env.jarName = &lt;span&gt;&quot;&lt;span&gt;${moduleName}&lt;/span&gt;-&lt;span&gt;${branchName}&lt;/span&gt;-&lt;span&gt;${commitId}&lt;/span&gt;&quot;&lt;/span&gt;&lt;br/&gt;                         sh &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;br/&gt;                             docker login -u &lt;span&gt;${username}&lt;/span&gt; -p &lt;span&gt;${password}&lt;/span&gt;  registry.cn-beijing.aliyuncs.com&lt;br/&gt;                             cd &lt;span&gt;${moduleName}&lt;/span&gt; &amp;amp;&amp;amp; docker build -t &lt;span&gt;${dockerImage}&lt;/span&gt; -f ../Dockerfile --build-arg SERVICE_NAME=&lt;span&gt;${jarName}&lt;/span&gt; .&lt;br/&gt;                             sleep 1&lt;br/&gt;                             docker push &lt;span&gt;${dockerImage}&lt;/span&gt;&lt;br/&gt;                             sleep 1&lt;br/&gt;                             docker rmi &lt;span&gt;${dockerImage}&lt;/span&gt;&lt;br/&gt;                          &quot;&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;                    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;GitOps-CI扩展部分&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在原始CI作业的步骤基础上，增加了一个更新环境的步骤。GitOps实践会将当前的基础环境部署文件存放到一个Git仓库中。我们的CI作业在完成镜像上传后，同时更新环境部署文件中的镜像标签信息。（所以我们需要先获取该环境文件并更新上传）&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6131386861313869&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTMxj8LBHpNLlPRlIUQibX2VjI4llLaSFibeMHPdDhEYopIRfvQPNcTLfJSnCJS2LpHewKmhMlgw3utw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1233&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;stage(&lt;span&gt;&quot;PushFile&quot;&lt;/span&gt;){&lt;br/&gt;          // when {&lt;br/&gt;          //   expression { &lt;span&gt;&quot;&lt;span&gt;${env.branchName}&lt;/span&gt;&quot;&lt;/span&gt;.contains(&lt;span&gt;&quot;RELEASE-&quot;&lt;/span&gt;) }&lt;br/&gt;          // }&lt;br/&gt;          steps{&lt;br/&gt;            script{&lt;br/&gt;              &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;&lt;span&gt;${env.branchName}&lt;/span&gt;&quot;&lt;/span&gt;.contains(&lt;span&gt;&quot;RELEASE-&quot;&lt;/span&gt;)){&lt;br/&gt;                println(&lt;span&gt;&quot;branchName = branchName&quot;&lt;/span&gt;)&lt;br/&gt;                env.branchName = &lt;span&gt;&quot;master&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;              } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                env.branchName = &lt;span&gt;&quot;feature&quot;&lt;/span&gt;&lt;br/&gt;              }&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; 3; i++) {&lt;br/&gt;                    //下载版本库文件 &lt;br/&gt;                    response = GetRepoFile(40,&lt;span&gt;&quot;&lt;span&gt;${moduleName}&lt;/span&gt;%2fvalues.yaml&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;span&gt;${env.branchName}&lt;/span&gt;&quot;&lt;/span&gt;)&lt;br/&gt;                    //println(response)&lt;br/&gt;                    &lt;br/&gt;                    //替换文件中内容&lt;br/&gt;                    yamlData = readYaml text: &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;span&gt;${response}&lt;/span&gt;&quot;&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                    println(yamlData.image.version)&lt;br/&gt;                    println(yamlData.image.commit)&lt;br/&gt;                    yamlData.image.version = &lt;span&gt;&quot;&lt;span&gt;${releaseVersion}&lt;/span&gt;-&lt;span&gt;${env.nowDate}&lt;/span&gt;&quot;&lt;/span&gt;&lt;br/&gt;                    yamlData.image.commit  = &lt;span&gt;&quot;&lt;span&gt;${commitId}&lt;/span&gt;&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                    println(yamlData.toString())&lt;br/&gt;&lt;br/&gt;                    sh &lt;span&gt;&quot;rm -fr test.yaml&quot;&lt;/span&gt;&lt;br/&gt;                    writeYaml charset: &lt;span&gt;&#x27;UTF-8&#x27;&lt;/span&gt;, data: yamlData, file: &lt;span&gt;&#x27;test.yaml&#x27;&lt;/span&gt;&lt;br/&gt;                    newYaml = sh returnStdout: &lt;span&gt;true&lt;/span&gt;, script: &lt;span&gt;&#x27;cat test.yaml&#x27;&lt;/span&gt;&lt;br/&gt;                    &lt;br/&gt;                    println(newYaml)&lt;br/&gt;                    //更新gitlab文件内容&lt;br/&gt;                    base64Content = newYaml.bytes.encodeBase64().toString()&lt;br/&gt;&lt;br/&gt;                    // 会有并行问题，同时更新报错&lt;br/&gt;                    try {&lt;br/&gt;                      UpdateRepoFile(40,&lt;span&gt;&quot;&lt;span&gt;${moduleName}&lt;/span&gt;%2fvalues.yaml&quot;&lt;/span&gt;,base64Content, &lt;span&gt;&quot;&lt;span&gt;${env.branchName}&lt;/span&gt;&quot;&lt;/span&gt;)&lt;br/&gt;                      &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                    } catch(e){&lt;br/&gt;                      sh &lt;span&gt;&quot;sleep 2&quot;&lt;/span&gt;&lt;br/&gt;                      &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;        &lt;br/&gt; //封装HTTP请求&lt;br/&gt;def HttpReq(reqType,reqUrl,reqBody){&lt;br/&gt;    def gitServer = &lt;span&gt;&quot;http://gitlab.idevops.site/api/v4&quot;&lt;/span&gt;&lt;br/&gt;    withCredentials([string(credentialsId: &lt;span&gt;&#x27;gitlab-token&#x27;&lt;/span&gt;, variable: &lt;span&gt;&#x27;gitlabToken&#x27;&lt;/span&gt;)]) {&lt;br/&gt;      result = httpRequest customHeaders: [[maskValue: &lt;span&gt;true&lt;/span&gt;, name: &lt;span&gt;&#x27;PRIVATE-TOKEN&#x27;&lt;/span&gt;, value: &lt;span&gt;&quot;&lt;span&gt;${gitlabToken}&lt;/span&gt;&quot;&lt;/span&gt;]], &lt;br/&gt;                httpMode: reqType, &lt;br/&gt;                contentType: &lt;span&gt;&quot;APPLICATION_JSON&quot;&lt;/span&gt;,&lt;br/&gt;                consoleLogResponseBody: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;                ignoreSslErrors: &lt;span&gt;true&lt;/span&gt;, &lt;br/&gt;                requestBody: reqBody,&lt;br/&gt;                url: &lt;span&gt;&quot;&lt;span&gt;${gitServer}&lt;/span&gt;/&lt;span&gt;${reqUrl}&lt;/span&gt;&quot;&lt;/span&gt;&lt;br/&gt;                //quiet: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;//获取文件内容&lt;br/&gt;def GetRepoFile(projectId,filePath,branchName){&lt;br/&gt;    apiUrl = &lt;span&gt;&quot;projects/&lt;span&gt;${projectId}&lt;/span&gt;/repository/files/&lt;span&gt;${filePath}&lt;/span&gt;/raw?ref=&lt;span&gt;${branchName}&lt;/span&gt;&quot;&lt;/span&gt;&lt;br/&gt;    response = HttpReq(&lt;span&gt;&#x27;GET&#x27;&lt;/span&gt;,apiUrl,&lt;span&gt;&#x27;&#x27;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; response.content&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;//更新文件内容&lt;br/&gt;def UpdateRepoFile(projectId,filePath,fileContent, branchName){&lt;br/&gt;    apiUrl = &lt;span&gt;&quot;projects/&lt;span&gt;${projectId}&lt;/span&gt;/repository/files/&lt;span&gt;${filePath}&lt;/span&gt;&quot;&lt;/span&gt;&lt;br/&gt;    reqBody = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;&quot;{&quot;&lt;/span&gt;branch&lt;span&gt;&quot;: &quot;&lt;/span&gt;&lt;span&gt;${branchName}&lt;/span&gt;&lt;span&gt;&quot;,&quot;&lt;/span&gt;encoding&lt;span&gt;&quot;:&quot;&lt;/span&gt;base64&lt;span&gt;&quot;, &quot;&lt;/span&gt;content&lt;span&gt;&quot;: &quot;&lt;/span&gt;&lt;span&gt;${fileContent}&lt;/span&gt;&lt;span&gt;&quot;, &quot;&lt;/span&gt;commit_message&lt;span&gt;&quot;: &quot;&lt;/span&gt;update a new file&lt;span&gt;&quot;}&quot;&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;    response = HttpReq(&lt;span&gt;&#x27;PUT&#x27;&lt;/span&gt;,apiUrl,reqBody)&lt;br/&gt;    println(response)&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;images&lt;/figcaption&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6112&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTMxj8LBHpNLlPRlIUQibX2VjRnL6szhc1ehFgXiaZrOD9WibO2oic2yueE7yfHEoQECW1HAYs6xfC2YuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1250&quot;/&gt;&lt;/p&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;GitOps-CD部分&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5561403508771929&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTMxj8LBHpNLlPRlIUQibX2VjMy02eSX2SqtsTASnEx1BF8ryTO7UlqSN7GdIbCe8RSFBOkQf2v8y5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1140&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;CD-Scheduler作业&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此作业其实也是接收GitLab的webhook请求， 与CI-scheduler作业类似。不同的是这个CD-scheduler作业是用来接收环境仓库的代码变更。开启webhook， 配置触发token。生成hookurl：http://jenkins.idevops.site/generic-webhook-trigger/invoke?token=microservicecicd-scheduler-CD&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTMxj8LBHpNLlPRlIUQibX2VjERP0GrGEDA1xgbUHn5v6uN6HEFl6tiaHduSTXicca8R6QOK94OEl9INQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2139364303178484&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTMxj8LBHpNLlPRlIUQibX2VjRCxAYlVNbiaLeNbj2TDmYW2kP0XBW0XnMCc0ygFq0m2lTafVoiajHsLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;818&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Jenkinsfile&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;pipeline {&lt;br/&gt;    agent any&lt;br/&gt;&lt;br/&gt;    stages {&lt;br/&gt;        stage(&lt;span&gt;&#x27;GetCommitService&#x27;&lt;/span&gt;) {&lt;br/&gt;            steps {&lt;br/&gt;                script{&lt;br/&gt;                    &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&#x27;Hello World&#x27;&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;span&gt;${WebHookData}&lt;/span&gt;&quot;&lt;/span&gt;&lt;br/&gt;                    &lt;br/&gt;                    // Git Info&lt;br/&gt;                    webhookdata = readJSON text: &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;span&gt;${WebHookData}&lt;/span&gt;&quot;&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;                    eventType = webhookdata[&lt;span&gt;&quot;object_kind&quot;&lt;/span&gt;]&lt;br/&gt;                    commits = webhookdata[&lt;span&gt;&quot;commits&quot;&lt;/span&gt;]&lt;br/&gt;                    branchName = webhookdata[&lt;span&gt;&quot;ref&quot;&lt;/span&gt;] - &lt;span&gt;&quot;refs/heads/&quot;&lt;/span&gt;&lt;br/&gt;                    projectID = webhookdata[&lt;span&gt;&quot;project_id&quot;&lt;/span&gt;]&lt;br/&gt;                    commitID = webhookdata[&lt;span&gt;&quot;checkout_sha&quot;&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;                    changeServices = []&lt;br/&gt;                    &lt;span&gt;for&lt;/span&gt;(commit &lt;span&gt;in&lt;/span&gt; commits) {&lt;br/&gt;                        println(commit.id)&lt;br/&gt;&lt;br/&gt;                        //added&lt;br/&gt;                        &lt;span&gt;for&lt;/span&gt; (add &lt;span&gt;in&lt;/span&gt; commit.added) {&lt;br/&gt;                            s = add.split(&lt;span&gt;&quot;/&quot;&lt;/span&gt;) as List&lt;br/&gt;                            &lt;span&gt;if&lt;/span&gt; (s.size() &amp;gt; 1){&lt;br/&gt;                                &lt;span&gt;if&lt;/span&gt; (changeServices.indexOf(s[0]) == -1){&lt;br/&gt;                                    changeServices.add(s[0])&lt;br/&gt;                                }&lt;br/&gt;                            }&lt;br/&gt;                        }&lt;br/&gt;&lt;br/&gt;                        //modified&lt;br/&gt;                        &lt;span&gt;for&lt;/span&gt; (m &lt;span&gt;in&lt;/span&gt; commit.modified) {&lt;br/&gt;                            s = m.split(&lt;span&gt;&quot;/&quot;&lt;/span&gt;) as List&lt;br/&gt;                            // println s&lt;br/&gt;                            // println s.size()&lt;br/&gt;                            // println s[0]&lt;br/&gt;                            &lt;span&gt;if&lt;/span&gt; (s.size() &amp;gt; 1){&lt;br/&gt;                                // println changeServices.indexOf(s[0])&lt;br/&gt;                                &lt;span&gt;if&lt;/span&gt; (changeServices.indexOf(s[0]) == -1){&lt;br/&gt;                                    changeServices.add(s[0])&lt;br/&gt;                                }&lt;br/&gt;                            }&lt;br/&gt;                        }&lt;br/&gt;&lt;br/&gt;                        //removed&lt;br/&gt;                        &lt;span&gt;for&lt;/span&gt; (r &lt;span&gt;in&lt;/span&gt; commit.removed) {&lt;br/&gt;                            s = r.split(&lt;span&gt;&quot;/&quot;&lt;/span&gt;) as List&lt;br/&gt;                            println s&lt;br/&gt;                            &lt;span&gt;if&lt;/span&gt; (s.size() &amp;gt; 1){&lt;br/&gt;                                &lt;span&gt;if&lt;/span&gt; (changeServices.indexOf(s[0]) == -1){&lt;br/&gt;                                    changeServices.add(s[0])&lt;br/&gt;                                }&lt;br/&gt;                            }&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;&lt;br/&gt;                    println(changeServices)&lt;br/&gt;                    currentBuild.description = &lt;span&gt;&quot; Trigger by  &lt;span&gt;${eventType}&lt;/span&gt; &lt;span&gt;${changeServices}&lt;/span&gt; &quot;&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        stage(&lt;span&gt;&#x27;DefineService&#x27;&lt;/span&gt;) {&lt;br/&gt;            steps {&lt;br/&gt;                script{&lt;br/&gt;                    println(changeServices)&lt;br/&gt;                    //服务构建顺序控制&lt;br/&gt;                    services = [&lt;span&gt;&#x27;service02&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;service01&#x27;&lt;/span&gt;]&lt;br/&gt;                    &lt;span&gt;for&lt;/span&gt; (service &lt;span&gt;in&lt;/span&gt; services){&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (changeServices.indexOf(service) != -1){&lt;br/&gt;                            jobName = &lt;span&gt;&#x27;microservicecicd-&#x27;&lt;/span&gt;+service+&lt;span&gt;&#x27;-service-CD&#x27;&lt;/span&gt;&lt;br/&gt;                            build job: jobName, &lt;span&gt;wait&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;,  parameters: [string(name: &lt;span&gt;&#x27;branchName&#x27;&lt;/span&gt;, value: &lt;span&gt;&quot;&lt;span&gt;${branchName}&lt;/span&gt;&quot;&lt;/span&gt; )]&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;环境库配置webhook&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开启webhook，配置hookurl：http://jenkins.idevops.site/generic-webhook-trigger/invoke?token=microservicecicd-scheduler-CD&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTMxj8LBHpNLlPRlIUQibX2VjV3luGRYBTXgN4aRc0LEOgy592gbXicVDrib0W1HCfeRJIxuibWicB01heg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;CD流水线-CD作业&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.29228100607111884&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTMxj8LBHpNLlPRlIUQibX2VjAdFia7ianrHwNFhryndhc3Gsuhg1VDfX9ff6C10icpTPVUic0kBuQTNtqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1153&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Jenkinsfile&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String serviceName =&lt;span&gt;&quot;&lt;span&gt;${JOB_NAME}&lt;/span&gt;&quot;&lt;/span&gt;.split(&lt;span&gt;&quot;-&quot;&lt;/span&gt;)[1]&lt;br/&gt;String nameSpace = &lt;span&gt;&quot;&lt;span&gt;${JOB_NAME}&lt;/span&gt;&quot;&lt;/span&gt;.split(&lt;span&gt;&quot;-&quot;&lt;/span&gt;)[0].split(&lt;span&gt;&quot;/&quot;&lt;/span&gt;)[-1]&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;//pipeline&lt;br/&gt;pipeline{&lt;br/&gt;    agent { node { label &lt;span&gt;&quot;k8s&quot;&lt;/span&gt;}}&lt;br/&gt;    &lt;br/&gt;    stages{&lt;br/&gt;&lt;br/&gt;       stage(&lt;span&gt;&quot;GetCode&quot;&lt;/span&gt;){&lt;br/&gt;            steps{&lt;br/&gt;                script{&lt;br/&gt;                    println(&lt;span&gt;&quot;&lt;span&gt;${branchName}&lt;/span&gt;&quot;&lt;/span&gt;)&lt;br/&gt;                    println(&lt;span&gt;&quot;&lt;span&gt;${env.branchName}&lt;/span&gt;&quot;&lt;/span&gt;.contains(&lt;span&gt;&quot;RELEASE-&quot;&lt;/span&gt;))&lt;br/&gt;                    println &lt;span&gt;&quot;获取代码&quot;&lt;/span&gt;&lt;br/&gt;                    checkout([&lt;span&gt;$class&lt;/span&gt;: &lt;span&gt;&#x27;GitSCM&#x27;&lt;/span&gt;, branches: [[name: &lt;span&gt;&quot;&lt;span&gt;${env.branchName}&lt;/span&gt;&quot;&lt;/span&gt;]], &lt;br/&gt;                                      doGenerateSubmoduleConfigurations: &lt;span&gt;false&lt;/span&gt;, &lt;br/&gt;                                      extensions: [[&lt;span&gt;$class&lt;/span&gt;: &lt;span&gt;&#x27;SparseCheckoutPaths&#x27;&lt;/span&gt;, &lt;br/&gt;                                                    sparseCheckoutPaths: [[path: &lt;span&gt;&quot;&lt;span&gt;${serviceName}&lt;/span&gt;&quot;&lt;/span&gt;]]]], &lt;br/&gt;                                      submoduleCfg: [], &lt;br/&gt;                                      userRemoteConfigs: [[credentialsId: &lt;span&gt;&#x27;gitlab-admin-user&#x27;&lt;/span&gt;, url: &lt;span&gt;&quot;http://gitlab.idevops.site/microservicecicd/microservicecicd-env.git&quot;&lt;/span&gt;]]])&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        stage(&lt;span&gt;&quot;HelmDeploy&quot;&lt;/span&gt;){&lt;br/&gt;            steps{&lt;br/&gt;                script{&lt;br/&gt;                  sh &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;br/&gt;                      kubectl create ns &quot;&lt;/span&gt;&lt;span&gt;${nameSpace}&lt;/span&gt;-uat&lt;span&gt;&quot;  || echo false&lt;br/&gt;&lt;br/&gt;                      helm install &quot;&lt;/span&gt;&lt;span&gt;${serviceName}&lt;/span&gt;&lt;span&gt;&quot; --namespace &quot;&lt;/span&gt;&lt;span&gt;${nameSpace}&lt;/span&gt;-uat&lt;span&gt;&quot; ./&quot;&lt;/span&gt;&lt;span&gt;${serviceName}&lt;/span&gt;&lt;span&gt;&quot; ||  helm upgrade &quot;&lt;/span&gt;&lt;span&gt;${serviceName}&lt;/span&gt;&lt;span&gt;&quot; --namespace &quot;&lt;/span&gt;&lt;span&gt;${nameSpace}&lt;/span&gt;-uat&lt;span&gt;&quot; ./&quot;&lt;/span&gt;&lt;span&gt;${serviceName}&lt;/span&gt;&lt;span&gt;&quot;&lt;br/&gt;&lt;br/&gt;                      helm list --namespace &quot;&lt;/span&gt;&lt;span&gt;${nameSpace}&lt;/span&gt;-uat&lt;span&gt;&quot;&lt;br/&gt;                      helm history &quot;&lt;/span&gt;&lt;span&gt;${serviceName}&lt;/span&gt;&lt;span&gt;&quot; --namespace &quot;&lt;/span&gt;&lt;span&gt;${nameSpace}&lt;/span&gt;-uat&lt;span&gt;&quot;&lt;br/&gt;&lt;br/&gt;                  &quot;&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b231ff0ed7ce3a560cfa5f08bc1866c7</guid>
<title>刘德华在现场吗？虚拟制片时代的到来</title>
<link>https://toutiao.io/k/j3n0nwd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;今年春晚，刘德华在现场吗？&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5609375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/9891Oh7RGKxEh66tKf8CPK5mHrefY5pVARnh07MgoR7tJWELLlTIS8qnzbwicNfCt45HDdPxtNH8ewloUTlpIMA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;等&lt;strong&gt;文末再回答&lt;/strong&gt;这一问题~&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;先分享下，我最近看到的法国数字艺术家Fabien Barrau使用无人机摄影制作的一系列被称为《未来的新闻》的照片。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.249074074074074&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9891Oh7RGKxEh66tKf8CPK5mHrefY5pVMVtIKgEuic6vqy9Hbc3nY4BHNXxPsuhZ0aIatFC5TBHZPBWdZJ0Jxibw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;纽约贫瘠之地的帝国大厦&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.25&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9891Oh7RGKxEh66tKf8CPK5mHrefY5pV1Aw4icwpIap1ica0cPfZoYIgADsXUEia8HcQapmnYLJnl84Snm7HyBHVQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;海平面上升侵蚀了自由女神像&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.25&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9891Oh7RGKxEh66tKf8CPK5mHrefY5pVNP74B1FmS2ShoHN8d89Uku8ttJ3Z2icShRHO4CfQ5GzLnYDQqvsHmaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;巴黎成为沙漠&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;作者通过&lt;/span&gt;&lt;span&gt;&lt;strong&gt;合成的图片&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;表达了气候变化后可能会出现毁坏的建筑。建筑选取了巴黎，罗马，纽约和伦敦等地的著名地标建筑。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;让我想起了大学时自学过的&lt;strong&gt;Matte Painting&lt;/strong&gt;技术&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;（当时特定买了&lt;span&gt;Wacom&lt;/span&gt;手绘板）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Matte Painting是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;遮罩绘景&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9891Oh7RGKxEh66tKf8CPK5mHrefY5pVAF282QuOMmrFWMMBsUy1T0OoJBq8zvkt7kyETon8Vn2Ju3a07AfojQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用photoshop，在一张主场景照片上进行抠图、调整细节、合成其他素材，从而创造出新的场景。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9891Oh7RGKxEh66tKf8CPK5mHrefY5pVdaf9V0icPTyztCicc380W1WQmPmYmjpyHZDQzr87mPca9wG6zaQsmeOA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Matte Painting&lt;/strong&gt;，指通过绘画手段创造影片中所需的场景，场景一般是实景搭建太过昂贵，或很难拍摄到，是一种数字特效技术。一般是由绘景师后期制作而成，使用虚拟外景代替&lt;/span&gt;&lt;span&gt;&lt;strong&gt;绿幕&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;部分。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;早期的Matte Painting是&lt;strong&gt;在电影拍摄&lt;/strong&gt;中，导演们让画家把他们想要的场景画在玻璃上，然后放在镜头前，通过光学手段，遮挡掉他们不想要的场景。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5572687224669604&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/9891Oh7RGKxEh66tKf8CPK5mHrefY5pVRdDoc4TQ5wd1GkRGkgJaejOCj8B3B8UboKQqHBhAFnq3vc37Ot46NA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;454&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在影片拍摄现场，明星们在&lt;/span&gt;&lt;span&gt;&lt;strong&gt;绿幕&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;中蹦来蹦去，导演也只能靠脑补最终画面。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.43333333333333335&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/9891Oh7RGKxEh66tKf8CPK5mHrefY5pV2P9jtib0MdjoMeeZibb1nicVN25suWicjL7ib01UN4KmLyEQhcDZzwH6nLQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.48125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9891Oh7RGKxEh66tKf8CPK5mHrefY5pVvjicOqMrw8T9hfMf33Pof6GAUtxeC0LW0VfKCpvjxeFGtshsQyl58Hg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了制作最终的影视效果，&lt;span&gt;有大量的工作耗费在抠图、修复、矫正上。&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;近些年，伴随着深度学习的发展，有很多新技术可以完成Matte Painting，门槛也进一步被降。&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;自动抠图&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;Background Matting: &lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span&gt;The World is Your Green Screen&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.19375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9891Oh7RGKxEh66tKf8CPK5mHrefY5pVLMm3iaWyxrp9hTPLJ5YP4rqMDpOXM4apNGXNiccS7tWzlqpH1Qsd8AnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;IEEE CVPR 2020的一篇论文，同时作者开源了出来。在Nvidia RTX 2080 TI GPU上实现了4K 30fps 和 HD 60fps 的&lt;/span&gt;&lt;strong&gt;&lt;span&gt;实时抠图&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;即使你不会 ps 抠图，AI仍可以帮你更换图片中的背景。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;AI除了扣实景照片之外，还可以完成漫画的抠图：&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9891Oh7RGKxEh66tKf8CPK5mHrefY5pVcu2Ht6a6yoIZARVpa8epKxibm6U1nEZbompsYOGBV9ChsxMC3YbpYdg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.7625&quot; data-w=&quot;720&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;漫画字幕自动抠图&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对漫画翻译人员来说，往往需要去除原有漫画的对话框和背景文字，并将其替换为读者翻译的语言。工作量非常大，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;通过自动抠图技术，大大提高了工作效率。&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6186046511627907&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9891Oh7RGKxEh66tKf8CPK5mHrefY5pVKwnibibpwCZMcqrPiclUibGEdPb9QB4fpuGRTHd9icKVNI9JFTfu1BzyRmw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;有了自动抠图，是不是就可以告别绿幕了？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;虚拟制片，所见即所得&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Virtual Production&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;还有更为高级的，&lt;strong&gt;Unreal Engine&lt;/strong&gt;提出了虚拟制片的技术解决方案，连抠图都不需要了：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.43333333333333335&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/9891Oh7RGKxEh66tKf8CPK5mHrefY5pV9ibg54OcHVWIkzHU3KvTvFadWlZcb5cxaib1RThg8ibqbPoswLJIELjgA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;例如上图，运用虚幻制片技术，《曼达洛人》在拍摄时，导演不仅能在拍摄现场实时观看最终的合成画面，还能随时更换场景。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;由LED曲面屏搭建而成的拍摄现场，真实与虚构完全融为一体，所拍即所得。&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.47962962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9891Oh7RGKxEh66tKf8CPK5mHrefY5pVDxfzmxGn7YRoZajwB8uFuhiaDO10TOk19ZdiaF1OELGBoJvmn1UEDCNg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;到这里答案也差不多揭晓了，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;虽然春晚刘德华这一段具体是怎么拍摄的官方并没有技术揭秘，不过大体就是这么回事~~~ 你们说呢？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5186440677966102&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9891Oh7RGKxEh66tKf8CPK5mHrefY5pVwiczSfWicPcta96GSCS5d2MIqKPsVsN7J6EZu0nTIBiaS90ib2r7pRn7JA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;590&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;本文所涉及的技术资料&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;欢迎加入XR社群交流~&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.317837837837838&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pMDHibpHlCGaFRvMPzSJWakM9WTSB9BxDDpeqz2lpOBXzftjCyScL2Xu9e8AZMOl0GqLYLwTF3liaiaGgK6yLJJHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;925&quot; data-backw=&quot;578&quot; data-backh=&quot;762&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>