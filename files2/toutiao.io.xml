<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e60777b142eec18354303e68f8de28e6</guid>
<title>浅谈软件设计</title>
<link>https://toutiao.io/k/tvv5595</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-body&quot; itemprop=&quot;articleBody&quot;&gt;

      
      

      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;/&gt;前言&lt;/h2&gt;&lt;p&gt;软件设计中，什么最重要？能让软件灵活、低成本修改的前提下，又能尽可能减少变化带来的风险。&lt;/p&gt;
&lt;p&gt;如何能达到这个目的呢？有如下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能不修改原有代码就不修改，变化的功能完全通过新增代码来解决。(&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://weread.qq.com/web/reader/480322f072021a3248038c8k98f3284021498f137082c2e&quot;&gt;OCP原则&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;必须修改原有代码时，尽量把代码的变化限制在足够小的范围内。（正交性）&lt;ul&gt;
&lt;li&gt;模块/类/方法的职责单一化，边界划分时将可能联动的变化隔离 (&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://weread.qq.com/web/reader/480322f072021a3248038c8k1f032c402131f0e3dad99f3&quot;&gt;SRP原则&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;对代码进行抽象，抽象的东西更具普适性，更容易在变化中做到不变。并且抽象的部分不要依赖于具体的部分（&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://weread.qq.com/web/reader/480322f072021a3248038c8k37632cd021737693cfc7149&quot;&gt;DIP原则&lt;/a&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;正交性：源于&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://book.douban.com/subject/1152111/&quot;&gt;《程序员修炼之道》&lt;/a&gt;，是一个核心指导原则。是指当某个模块有修改、变化时，对周边其它模块不造成任何影响。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;设计原则&quot;&gt;&lt;a href=&quot;#设计原则&quot; class=&quot;headerlink&quot; title=&quot;设计原则&quot;/&gt;设计原则&lt;/h2&gt;&lt;h3 id=&quot;OCP-SRP-DIP&quot;&gt;&lt;a href=&quot;#OCP-SRP-DIP&quot; class=&quot;headerlink&quot; title=&quot;OCP/SRP/DIP&quot;/&gt;OCP/SRP/DIP&lt;/h3&gt;&lt;p&gt;根据上面这些推导，就能看出来设计原则也是为了满足目的而总结出来的经验。虽然在&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://weread.qq.com/web/reader/480322f072021a3248038c8kc81322c012c81e728d9d180&quot;&gt;《架构整洁之道》&lt;/a&gt;中提炼了SOLID五种设计原则，但根据上面的推论，可以看出来OCP/SRP/DIP是更加核心的设计原则。&lt;/p&gt;
&lt;p&gt;如果从逻辑上来讲，OCP应该跟正交性属于同一个层次。&lt;/p&gt;
&lt;p&gt;OCP在设计模式中的使用也是非常常用的指导原则，比如&lt;code&gt;观察者模式&lt;/code&gt;、&lt;code&gt;职责链&lt;/code&gt;、&lt;code&gt;装饰器模式&lt;/code&gt;等，都是OCP原则的使用。&lt;/p&gt;
&lt;p&gt;OCP也是可大可小的原则，在越大的系统上，OCP越重要。比如互联网，核心层是非常稳定，扩展性非常强，要发布新的网站完全是不需要修改互联网底层。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;互联网的这个例子，来自&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://time.geekbang.org/column/intro/313&quot;&gt;软件设计之美&lt;/a&gt;，非常具有启发性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;针对OCP原则，在&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://time.geekbang.org/column/article/176075&quot;&gt;《设计模式之美》&lt;/a&gt;中提了一个有趣的问题：修改代码就意味着违背开闭原则吗？&lt;/p&gt;
&lt;p&gt;其实不一定。比如实现某个需求时，如果在某个类中扩展了一个接口，那么对接口来说是满足OCP，但对类来说是不满足的(对模块和类层次来说也一样)。所以是否满足OCP不能简单一概而论。专栏中给出了这样的结论：&lt;strong&gt;尽量让修改操作更集中、更少，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;LSP-ISP&quot;&gt;&lt;a href=&quot;#LSP-ISP&quot; class=&quot;headerlink&quot; title=&quot;LSP/ISP&quot;/&gt;LSP/ISP&lt;/h3&gt;&lt;p&gt;那SOLID中剩余的LSP及ISP原则是有什么用处呢？&lt;/p&gt;
&lt;p&gt;LSP(里氏替换原则)从定义上来说：任何基类可以出现的地方，子类都可以替换它。&lt;/p&gt;
&lt;p&gt;子类可以完全替换父类，这个约束可以产生什么样的结果呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子类只能去扩展基类，而不能隐藏或者覆盖基类行为。这其实是对OCP的实践。&lt;/li&gt;
&lt;li&gt;抽象层确定下来的行为，具体类不能改变它，只能适应它；也就是实现要依赖于抽象，而非具体。这其实是对DIP的实践。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以本质上LSP是在满足DIP和OCP的原则下推导出的一个具体原则。&lt;/p&gt;
&lt;p&gt;ISP(接口隔离原则)从定义上来说：不应强迫使用者依赖于它们不用的方法。ISP有如下作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源码层面的变化隔离，可以一定程度上提升源码编译速度。&lt;/li&gt;
&lt;li&gt;对更高层次模块来说，可以防止不必要依赖变化时，都需要重新编译、布署。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ISP与SRP一定程度上有些相似性，但并不一样。ISP更侧重于接口的设计，思考角度也是略不同的。&lt;/p&gt;
&lt;p&gt;ISP迫使我们在接口的维度上来思考，使我们站在行为的角度上来思考。行为是更加复杂易变的，实体会更加稳定。那么基于行为进行职责划分与隔离，就更容易封装变化。&lt;/p&gt;
&lt;h3 id=&quot;其它原则&quot;&gt;&lt;a href=&quot;#其它原则&quot; class=&quot;headerlink&quot; title=&quot;其它原则&quot;/&gt;其它原则&lt;/h3&gt;&lt;p&gt;除SOLID原则外，还有一些比较有名的指导原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;针对接口编程：本质也是将代码分层，接口设计即抽象层的设计，也即DIP的实践。&lt;/li&gt;
&lt;li&gt;KISS：使代码保持简洁。注意，如果问题很复杂，此时解决方案复杂的话，也可以认为是满足KISS原则的。&lt;/li&gt;
&lt;li&gt;YAGNI：不要做过度设计。不要提前写用不到的代码，但预留扩展性是必要的。&lt;/li&gt;
&lt;li&gt;DRY：完全重复的代码不一定违反DRY，不完全一样的代码也可能违反了DRY。详情可以参考：&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://time.geekbang.org/column/article/179607&quot;&gt;重复的代码就一定违背DRY吗？如何提高代码的复用性？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;LOD：不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。 详解参考：&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://time.geekbang.org/column/article/179615&quot;&gt;如何用迪米特法则（LOD）实现“高内聚、松耦合”？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;KISS&lt;/code&gt;、&lt;code&gt;LOD&lt;/code&gt;、&lt;code&gt;YAGNI&lt;/code&gt;等原则的一些详细说明，&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://time.geekbang.org/column/intro/250&quot;&gt;《设计模式之美》&lt;/a&gt; 对这块的详细介绍是很值得看一下的&lt;br/&gt;&lt;code&gt;DRY&lt;/code&gt;原则，在《程序员修炼之道》中有更全面的说明，DRY不止指代码层面的重复，还包括意图等方面的重复&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;/&gt;设计模式&lt;/h2&gt;&lt;p&gt;面向对象开发中，代码中遍布着对象。那么面向对象开发中对象及对象关系的处理就是非常重要的。GoF总结的设计模式，也可以围绕对象的关系/行为来理解。&lt;/p&gt;
&lt;p&gt;对象的处理，可以划分为如下三种关系/行为：&lt;/p&gt;

&lt;p&gt;站在这个角度来理解设计模式是更容易理解的。但我们需要先考虑的是，为什么会存在这些设计模式。要研究这个问题，还是需要基于具体场景来看&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;比较简单的单例、观察者模式，以及使用场景比较受限的解释器，还有仅为了内存优化而存在的FlyWeight模式并没有涉及&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;对象的创建&quot;&gt;&lt;a href=&quot;#对象的创建&quot; class=&quot;headerlink&quot; title=&quot;对象的创建&quot;/&gt;对象的创建&lt;/h3&gt;&lt;p&gt;直接创建一个类会有什么问题呢？可能会违反DIP原则，导致抽象类依赖于具体类。&lt;/p&gt;
&lt;p&gt;如何解决这个问题呢？在抽象层中不做具体的创建，只保留基类中对象的引用。只要想办法给引用赋值即可，一种办法是在外部创建好后再传进来(即依赖注入)。如果在对象中存在继承关系，还有一种办法就是在子类中创建。&lt;/p&gt;
&lt;p&gt;在子类中创建的方式就是**&lt;code&gt;工厂模式&lt;/code&gt;**，具体实现上就是抽象类提供&lt;code&gt;create&lt;/code&gt;接口返回具体的对象，子类重载该接口返回具体对象。&lt;/p&gt;
&lt;p&gt;有批量对象需要创建，对象之间存在约束：某些类型的对象只能同时使用。为了满足该约束，需要封装创建者，并将创建者也进一步分层为抽象类及具体类，就是**&lt;code&gt;抽象工厂模式&lt;/code&gt;**&lt;/p&gt;
&lt;p&gt;有批量对象要创建，这些对象创建完之后还需要做进一步拼装/组合等操作，同样需要封装创建者并进行设计分层，将拼装/组合的差异放在具体创建者子类中，就是**&lt;code&gt;创建者模式&lt;/code&gt;**&lt;/p&gt;
&lt;p&gt;如果要对已有对象(包含状态)进行复制，就是**&lt;code&gt;原型模式&lt;/code&gt;**&lt;/p&gt;
&lt;p&gt;创建型的设计模式，都在遵循&lt;strong&gt;封装变化&lt;/strong&gt;、&lt;strong&gt;对接口编程&lt;/strong&gt;这些根本原则。&lt;/p&gt;
&lt;h3 id=&quot;对象间的关系&quot;&gt;&lt;a href=&quot;#对象间的关系&quot; class=&quot;headerlink&quot; title=&quot;对象间的关系&quot;/&gt;对象间的关系&lt;/h3&gt;&lt;p&gt;对象与对象之间有多少种关系呢？&lt;/p&gt;

&lt;p&gt;在什么场景下，可以很好的利用对象关系的处理达到设计的目的呢？&lt;/p&gt;
&lt;h4 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;/&gt;继承&lt;/h4&gt;&lt;p&gt;继承重要的作用就是将代码进行分层，分为抽象层与具体层，并且尽量保持抽象层的稳定。（虽然代码复用也是其中一个功能，但并不推荐）&lt;/p&gt;
&lt;p&gt;遇到问题需要对类进行分层时，要满足&lt;code&gt;DIP&lt;/code&gt;原则的约束，针对这种约束沉淀出来的方案，自然就可以做到具体层可以随意变化，不影响抽象层，抽象层做一些调整时，具体层也可能完全不受影响。这就是**&lt;code&gt;桥接模式&lt;/code&gt;**&lt;/p&gt;
&lt;h4 id=&quot;包装&quot;&gt;&lt;a href=&quot;#包装&quot; class=&quot;headerlink&quot; title=&quot;包装&quot;/&gt;包装&lt;/h4&gt;&lt;p&gt;如果目前已有一个对象，我们希望对其进行扩展或修改时，但又希望满足OCP原则，那如何做呢？（还一种情况，就是原始对象无法修改）&lt;/p&gt;
&lt;p&gt;有个办法就是通过一个Wrapper类，来将原有对象包装起来，并用Wrapper来替换原始对象的使用，以此来达到修改原始对象的功能。&lt;/p&gt;
&lt;p&gt;要改变原始类的接口名称时，在Wrapper的新接口中调用原始接口，就是**&lt;code&gt;适配器模式&lt;/code&gt;**&lt;/p&gt;
&lt;p&gt;要扩展原始类的功能时，Wrapper与目标类设计为同样类型的对象。在Wrapper中抽象接口实现时，除了调用目标对象的接口，还补充了自己的逻辑。就是**&lt;code&gt;装饰器模式&lt;/code&gt;**&lt;/p&gt;
&lt;p&gt;修改原始类的行为时，Wrapper与目标类设计为同样类型的对象。在Wrapper中抽象接口实现时，可以按自己的预期来调整新的行为。就是**&lt;code&gt;代理模式&lt;/code&gt;**&lt;/p&gt;
&lt;p&gt;如果对象结构间有一种递归性，比如大图案是由小图案组合而成的，并且可以不断递归组合。此时Wrapper与目标类设计为同样的类型对象，并且Wrapper中可以存储多个目标类型对象。Wrapper的接口实现上，会迭代调用内部目标对象的接口。这就是**&lt;code&gt;组合模式&lt;/code&gt;**&lt;/p&gt;
&lt;p&gt;如果要扩大被包装目标的范围，比如是多个对象，或者某个模块，要对他们的接口进行调整，就可以产生**&lt;code&gt;外观模式&lt;/code&gt;**&lt;/p&gt;
&lt;h3 id=&quot;对象的行为&quot;&gt;&lt;a href=&quot;#对象的行为&quot; class=&quot;headerlink&quot; title=&quot;对象的行为&quot;/&gt;对象的行为&lt;/h3&gt;&lt;p&gt;站在对象的行为上来考虑时，可以更多的从他们的时机和行为上来分析。&lt;/p&gt;
&lt;p&gt;如果有一系列操作需要执行，可以将这些操作封装为同一种类型的对象，然后在抽象层可以按序执行它们，就是**&lt;code&gt;Command模式&lt;/code&gt;**&lt;/p&gt;
&lt;p&gt;如果有一个数据或事件，需要交给多个对象处理或执行。可以将这些处理对象封装为同一类型对象，数据/事件在这个对象链条上进行传递，就是**&lt;code&gt;职责链模式&lt;/code&gt;**&lt;/p&gt;
&lt;p&gt;如果系统中存在不同的状态，并且这些状态可以随着系统执行不断改变其中的状态时，就可以将这些状态封装为同一类型对象，核心执行逻辑可以不关心使用的具体对象，这就是**&lt;code&gt;状态模式&lt;/code&gt;**&lt;/p&gt;
&lt;p&gt;如果系统中存在不同的状态，并且在不同场景会使用不同对象时，就可以将这些状态封装为同一类型对象，要使用不同策略，仅需要将策略对象设置给该系统，这就是**&lt;code&gt;策略模式&lt;/code&gt;**&lt;/p&gt;
&lt;p&gt;如果某容器内有多个元素，想在不了解容器内部实现的情况下枚举其中的内部元素，就可以通过提供统一访问协议，容器来实现该协议以达到遍历的目的。这就是**&lt;code&gt;迭代器模式&lt;/code&gt;**&lt;/p&gt;
&lt;p&gt;如果某个对象有存取需求，并且不想暴露内部实现，就可以让该对象提供导出/导入状态的接口，在外部来存取相应数据。这就是**&lt;code&gt;备忘录模式&lt;/code&gt;**&lt;/p&gt;
&lt;p&gt;如果在完成某件任务时，有统一的执行流程，不同场景下的差异仅在于细节上的差异，就可以在抽象层实现流程和通用的执行细节，具体差异部分通过子类重写保留的接口来实现。这就是**&lt;code&gt;模板模式&lt;/code&gt;**&lt;/p&gt;
&lt;p&gt;如果想在不同场景对容器元素进行遍历操作并得到不同结果，并且要处理的元素类型比较固定，但处理的操作可能易变时，就可以让元素对象提供一个访问接口，然后把要处理的操作封装为&lt;code&gt;访问者对象&lt;/code&gt;，访问者对象中可以对不同元素进行不同处理。这样就可以更好的满足OCP原则，这就是&lt;strong&gt;访问者模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一组对象之间相互调用的关系比较复杂，形成了网状的结构时，通过增加一个中间交互对象的方式，来将各对象之间相互的引用解耦开，就是**&lt;code&gt;中介者模式&lt;/code&gt;**&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在行为类模式中，状态模式跟策略模式是很像的，从类图上来看也是一致的。但两个模式处理的问题场景是不同的。&lt;br/&gt;比如登录问题很适合用状态模式，登录过程分为几个状态，这几个状态在开始登录后，会自动切换其中的状态，一种状态切为另一种状态可能会执行不同的操作，该系统给外界的反馈可能也会有差异。&lt;br/&gt;一个软件是试用模式还是正式模式，就可以比较适合使用策略模式，比如试用版本时某些功能的调用受限。如果用户付了费，可以直接将另外一个策略替换当前策略。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中&lt;code&gt;Command模式&lt;/code&gt;、&lt;code&gt;职责链模式&lt;/code&gt;、&lt;code&gt;状态模式&lt;/code&gt;、&lt;code&gt;策略模式&lt;/code&gt;在类结构上是比较相似的，可以用简单语言来描述的其中差异：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当一系列对象有统一行为接口，在抽象层可以按序执行它们，就是&lt;code&gt;Command模式&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当一系列对象有统一行为接口，并且数据或事件会沿着这一系列对象传递时，就是&lt;code&gt;职责链模式&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当一系列对象有统一行为接口，在不同时机会切换不同的对象，就是&lt;code&gt;状态模式&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当一系列对象有统一行为接口，在不同的场景使用不同的对象，就是&lt;code&gt;策略模式&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;/&gt;结语&lt;/h2&gt;&lt;p&gt;现在再回过头来看，设计模式是什么呢？设计模式其实是针对场景总结出的设计经验。&lt;/p&gt;
&lt;p&gt;学习设计模式最重要的是什么？&lt;strong&gt;透彻理解设计原则是最重要的&lt;/strong&gt;。如果熟练掌握了设计原则，即使从来不知道设计模式，仍然能在开发过程中自然而然的用上设计模式。&lt;/p&gt;
&lt;p&gt;当然并不是说设计模式没有价值，首先是它可以给我们一些指导和演示，告诉我们在某些场景下比较优秀的设计是什么样的。其次它是一种沟通语言，可以在不同的开发之间方便的传达设计思路。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;/&gt;参考资料&lt;/h2&gt;

      
    &lt;/div&gt;
    
    
    

    

    

    

    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1e771d66b30b69920cfe7ebcaaaa7f66</guid>
<title>JVM 简明笔记（四）：垃圾回收</title>
<link>https://toutiao.io/k/rqqp79j</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body cnblogs-markdown&quot;&gt;
&lt;h2 id=&quot;1-垃圾回收相关算法&quot;&gt;1 垃圾回收相关算法&lt;/h2&gt;
&lt;p&gt;垃圾回收器首先要做的就是，判断一个对象是存活状态还是死亡状态，死亡的对象将会被标识为垃圾数据并等待收集器进行清除。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判断一个对象是否为死亡状态的常用算法有两个：&lt;strong&gt;引用计数器算法&lt;/strong&gt; 、&lt;strong&gt;可达性分析算法&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;垃圾回收的常见算法有以下几个：&lt;strong&gt;标记-清除算法&lt;/strong&gt;、&lt;strong&gt;标记-复制算法&lt;/strong&gt;、标记-整理算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;11-引用计数算法（reference-counting）&quot;&gt;1.1 引用计数算法（Reference Counting）&lt;/h3&gt;
&lt;p&gt;在创建对象时关联一个与之相对应的计数器，当此对象被使用时加 1，相反销毁时 -1。当此计数器为 0 时，则表示此对象未使用，可以被垃圾收集器回收。&lt;/p&gt;
&lt;p&gt;引用计数算法的优缺点很明显，其优点是垃圾回收比较及时，实时性比较高，只要对象计数器为 0，则可以直接进行回收操作；而缺点是无法解决循环引用的问题。&lt;/p&gt;
&lt;p&gt;循环引用示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class RCTest {
    static class Test {
        public Test object = null;
    }

    public static void main(String[] args) {
        Test object1 = new Test();
        Test object2 = new Test();

        object1.object = object2;
        object2.object = object1;

        object1 = null;
        object2 = null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;12-可达性分析算法（reachability-analysis）&quot;&gt;1.2 可达性分析算法（Reachability Analysis）&lt;/h3&gt;
&lt;p&gt;指从对象的起点（GC Roots）开始向下搜索，如果对象到 GC Roots 没有任何引用链相连时，也就是说此对象到 GC Roots 不可达时，则表示此对象可以被垃圾回收器所回收。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282178/202111/1282178-20211102223223121-1409263742.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Java语言中，可作为GC Roots的对象包括下面几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈帧中的局部变量表中的 reference 引用所引用的对象&lt;/li&gt;
&lt;li&gt;方法区中 static 静态引用的对象&lt;/li&gt;
&lt;li&gt;方法区中 final 常量引用的对象&lt;/li&gt;
&lt;li&gt;本地方法栈中 JNI（即Native方法） 引用的对象&lt;/li&gt;
&lt;li&gt;Java虚拟机内部的引用，如基本数据类型对应的 Class 对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError） 等，还有系统类加载器&lt;/li&gt;
&lt;li&gt;所有被同步锁持有的对象，比如被 synchronized 持有的对象&lt;/li&gt;
&lt;li&gt;反映Java虚拟机内部情况的 JMXBean、 JVMTI 中注册的回调、 本地代码缓存等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;finalize()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当使用可达性分析判断一个对象不可达时，并不会直接标识这个对象为死亡状态，而是先将它标记为“待死亡”状态再进行一次校验。&lt;/p&gt;
&lt;p&gt;校验的内容就是此对象是否重写了 finalize() 方法，如果该对象重写了 finalize() 方法，那么这个对象将会被存入到 F-Queue 队列中，等待 JVM 的 Finalizer 线程去执行重写的 finalize() 方法，在这个方法中如果此对象将自己赋值给某个类变量时，则表示此对象已经被引用了。因此不能被标识为死亡状态，其他情况则会被标识为死亡状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四种引用类型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;强引用(Strong Reference)：强引用是使用最普遍的引用。如果一个对象具有强引用，即便发生OOM那垃圾回收器绝不会回收它。&lt;/li&gt;
&lt;li&gt;软引用(Soft Reference)：如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。&lt;/li&gt;
&lt;li&gt;弱引用(Weak Reference)：用来描述那些非必须对象， 但是它的强度比软引用更弱一些， 被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作， 无论当前内存是否足够， 都会回收掉只 被弱引用关联的对象。 在JDK 1.2版之后提供了 WeakReference 类来实现弱引用。 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。&lt;/li&gt;
&lt;li&gt;虚引用(Phantom Reference)：如果一个对象仅持有虚引用，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用必须和引用队列 （ReferenceQueue）联合使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;13-标记-清除算法（mark-sweep）&quot;&gt;1.3 标记-清除算法（Mark-Sweep）&lt;/h3&gt;
&lt;p&gt;标记-清除算法属于最早的垃圾回收算法，它是由标记阶段和清除阶段构成的。标记阶段会给所有的存活对象做上标记，而清除阶段会把没有被标记的死亡对象进行回收。而标记的判断方法就是前面讲的引用计数算法和可达性分析算法。&lt;/p&gt;
&lt;p&gt;问题： 产生内存空间的碎片化，标记-清除算法执行完成之后会产生大量的不连续内存，这样当程序需要分配一个大对象时，因为没有足够的连续内存而导致需要提前触发一次垃圾回收动作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282178/202111/1282178-20211102223247469-1036729945.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;14-标记-复制算法（mark-copy）&quot;&gt;1.4 标记-复制算法（Mark-Copy）&lt;/h3&gt;
&lt;p&gt;将内存分为大小相同的两块区域，每次只使用其中的一块区域，这样在进行垃圾回收时就可以直接将存活的东西复制到新的内存上，然后再把另一块内存全部清理掉。&lt;/p&gt;
&lt;p&gt;问题：内存的可用率大幅降低：虽然可以解决内存碎片的问题，但因为需要将内存分为大小相同的两块内存，那么内存的实际可用量其实只有原来的一半。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282178/202111/1282178-20211102223312535-1085587882.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;15-标记-整理算法（mark-compact）&quot;&gt;1.5 标记-整理算法（Mark-Compact）&lt;/h3&gt;
&lt;p&gt;由两个阶段组成的：标记阶段和整理阶段。标记阶段和标记-清除算法的标记阶段一样，整理阶段不是直接对内存进行清除，而是把所有存活的对象移动到内存的一端，然后把另一端的所有死亡对象全部清除。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282178/202111/1282178-20211102223327855-1391934624.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-垃圾回收器&quot;&gt;2 垃圾回收器&lt;/h2&gt;
&lt;p&gt;HotSpot 中常使用的垃圾收集器主要包括 7 个：Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS 和 G1（Garbage First）收集器。&lt;/p&gt;
&lt;h3 id=&quot;21-分代收集理论&quot;&gt;2.1 分代收集理论&lt;/h3&gt;
&lt;p&gt;收集器应该将 Java 堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数） 分配到不同的区域之中存储。&lt;/p&gt;
&lt;p&gt;在 Java 堆划分出不同的区域之后，垃圾收集器可以每次只回收其中某一个或者某些部分的区域，所以有了 Minor GC 、Major GC、Full GC 这样的回收类型的划分；也能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了“标记-复制算法”“标记-清除算 法”“标记-整理算法”等针对性的垃圾收集算法。&lt;/p&gt;
&lt;h3 id=&quot;22-垃圾收集器分类&quot;&gt;2.2 垃圾收集器分类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;串行回收器（Serial）：串行垃圾回收是为单线程环境设计且只使用一个线程进行垃圾回收，会暂停所有的用户线程，不适合交互性强的服务器环境&lt;/li&gt;
&lt;li&gt;并行回收器（Parallel）：多个垃圾收集器线程并行工作，同样会暂停用户线程，适用于科学计算、大数据后台处理等多交互场景&lt;/li&gt;
&lt;li&gt;并发回收器（CMS）：用户线程和垃圾回收线程同时执行，不一定是并行的，可能是交替执行，可能一边垃圾回收，一边运行应用线程，不需要停顿用户线程，互联网应用程序中经常使用，适用对响应时间有要求的场景&lt;/li&gt;
&lt;li&gt;G1回收器：G1垃圾回收器将堆内存分割成不同的区域然后并发地对其进行垃圾回收&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282178/202111/1282178-20211102223341910-1501531031.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;串行回收器：Serial、Serial Old&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并行回收器：ParNew、Parallel Scavenge、Parallel Old&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并发回收器：CMS&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新生代垃圾收集器：Serial 、 ParNew 、Parallel Scavenge&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;老年代垃圾收集器：Serial Old 、 Parallel Old 、CMS&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;整堆收集器：G1、ZGC、Shenandoah&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特殊：Epsilon 不进行垃圾回收&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;组合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Serial + Serial Old&lt;/li&gt;
&lt;li&gt;Serial + CMS&lt;/li&gt;
&lt;li&gt;ParNew  + Serial Old&lt;/li&gt;
&lt;li&gt;ParNew + CMS&lt;/li&gt;
&lt;li&gt;Parallel Scavenge + Serial Old&lt;/li&gt;
&lt;li&gt;Parallel Scavenge + Parallel Old&lt;/li&gt;
&lt;li&gt;G1&lt;/li&gt;
&lt;li&gt;ZGC&lt;/li&gt;
&lt;li&gt;Epsilon&lt;/li&gt;
&lt;li&gt;Shenandoah&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中： Serial Old 作为 CMS 出现 Concurrent Mode Failure 失败的后备预案&lt;/p&gt;
&lt;p&gt;JDK8  废弃：Serial + CMS、ParNew + Serial Old&lt;/p&gt;
&lt;p&gt;JDK8  默认：Parallel Scavenge + ParallelOld&lt;/p&gt;
&lt;p&gt;JDK9  移除：Serial + CMS、ParNew + Serial Old&lt;/p&gt;
&lt;p&gt;JDK9  默认：G1&lt;/p&gt;
&lt;p&gt;JDK11 新增：Epsilon （实验）&lt;/p&gt;
&lt;p&gt;JDK11 新增：ZGC （实验）&lt;/p&gt;
&lt;p&gt;JDK12 新增：Shenandoah（实验）&lt;/p&gt;
&lt;p&gt;JDK13 更新：ZGC 支持的最大堆大小从 4TB 增加到 16TB&lt;/p&gt;
&lt;p&gt;JDK14 更新：ZGC 支持在 Windows 上作为实验功能&lt;/p&gt;
&lt;p&gt;JDK14 弃用：Parallel Scavenge + Parallel Old&lt;/p&gt;
&lt;p&gt;JDK14 移除：CMS&lt;/p&gt;
&lt;p&gt;JDK15 正式：ZGC 不再标记为实验功能可以在生产环境中使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GC性能指标&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;吞吐量：即CPU用于运行用户代码的时间与CPU总消耗时间的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )）。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%&lt;/li&gt;
&lt;li&gt;暂停时间：执行垃圾回收时，程序的工作线程被暂停的时间&lt;/li&gt;
&lt;li&gt;内存占用：Java 堆所占内存的大小&lt;/li&gt;
&lt;li&gt;收集频率：垃圾收集的频次&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;23-serial-收集器&quot;&gt;2.3 Serial 收集器&lt;/h3&gt;
&lt;p&gt;单线程收集器，“单线程”的意义不仅仅说明它只会使用一个CPU或一个收集线程去完成垃圾收集工作；更重要的是它在垃圾收集的时候，必须暂停其他工作线程（Stop The World），直到垃圾收集完毕；&lt;/p&gt;
&lt;p&gt;对于单CPU环境来说，由于Serial收集器没有线程间的交互，专心做垃圾收集自然可以做获得最高的垃圾收集效率&lt;/p&gt;
&lt;p&gt;使用方式：&lt;code&gt;-XX:+UseSerialGC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282178/202111/1282178-20211102223400142-619633914.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（图源自《深入理解Java虚拟机（第2版）》）&lt;/p&gt;
&lt;h3 id=&quot;24-parnew-收集器&quot;&gt;2.4 ParNew 收集器&lt;/h3&gt;
&lt;p&gt;ParNew 收集器实质上是 Serial 收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为包括 Serial 收集器可用的所有控制参数、 收集算法、 Stop The World、 对象分配规则、 回收策略等都与 Serial 收集器完全一致。&lt;/p&gt;
&lt;p&gt;ParNew 收集器在单 CPU 服务器上的垃圾收集效率绝对不会比 Serial 收集器高；但是在多 CPU 服务器上，效果会明显比 Serial 好。&lt;/p&gt;
&lt;p&gt;使用方式：&lt;code&gt;-XX:+UseParNewGC&lt;/code&gt;&lt;br/&gt;
设置线程数：  &lt;code&gt;XX:ParllGCThreads&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282178/202111/1282178-20211102223414220-2001281962.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（图源自《深入理解Java虚拟机（第2版）》）&lt;/p&gt;
&lt;h3 id=&quot;25-parallel-scavenge-收集器&quot;&gt;2.5 Parallel Scavenge 收集器&lt;/h3&gt;
&lt;p&gt;和 ParNew 收集器类似，是一个新生代收集器。使用&lt;strong&gt;复制算法&lt;/strong&gt;的并行多线程收集器。Parallel Scavenge 是 Java1.8 默认的收集器，特点是并行的多线程回收，以吞吐量（Throughput）优先。适合后台运算，交互不多的任务，如批量处理，订单处理，科学计算等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Parallel Scavenge 收集器的目标是达到一个可控制的吞吐量&lt;/li&gt;
&lt;li&gt;自适应调节策略：自动指定年轻代、Eden、Suvisor区的比例&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用方式：&lt;code&gt;-XX:+UseParallelGC&lt;/code&gt;&lt;br/&gt;
分别是控制最大垃圾收集停顿时间： &lt;code&gt;-XX:MaxGCPauseMillis&lt;/code&gt;&lt;br/&gt;
吞吐量大小 &lt;code&gt;-XX:GCTimeRatio&lt;/code&gt;&lt;br/&gt;
设置年轻代线程数 &lt;code&gt;XX:ParllGCThreads&lt;/code&gt;&lt;br/&gt;
自适应调节年轻代、Eden、Suvisor区的比例 &lt;code&gt;-XX:+UseAdaptiveSizePolicy&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;26-serial-old-收集器&quot;&gt;2.6 Serial Old 收集器&lt;/h3&gt;
&lt;p&gt;Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用&lt;strong&gt;标记-整理算法&lt;/strong&gt;。 这个收集器的主要意义也是供客户端模式下的 HotSpot 虚拟机使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 JDK1.5 及之前，与 Parallel Scavenge 收集器搭配使用（JDK1.6 后有 Parallel Old 收集器可搭配）&lt;/li&gt;
&lt;li&gt;作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用方式：&lt;code&gt;-XX:+UseSerialGC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;另外：Parallel Scavenge 收集器架构中本身有 PS MarkSweep 收集器来进行老年代收集，并非直接调用 Serial Old 收集器，但 PS MarkSweep 收集器与 Serial Old 的实现几乎是一样的，所以在官方的许多资料中都是直接以 Serial Old 代替 PS MarkSweep 进行讲解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282178/202111/1282178-20211102223533708-1369903352.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（图源自《深入理解Java虚拟机（第2版）》）&lt;/p&gt;
&lt;h3 id=&quot;27-parallel-old-收集器&quot;&gt;2.7 Parallel Old 收集器&lt;/h3&gt;
&lt;p&gt;Parallel Old 是 Parallel Scavenge 收集器的老年代版本，支持多线程并发收集，基于&lt;strong&gt;标记-整理算法&lt;/strong&gt;实现。&lt;/p&gt;
&lt;p&gt;JDK1.6 及之后用来代替老年代的 Serial Old 收集器；（在此之前，如果新生代选择了 Parallel Scavenge 收集器，老年代除了 Serial Old（PS MarkSweep） 收集器以外别无选择，其他表现良好的老年代收集器，如 CMS 无法与它配合工作。）&lt;/p&gt;
&lt;p&gt;在Server模式，多CPU的情况下；在注重吞吐量以及CPU资源敏感的场景，就有了 Parallel Scavenge 加 Parallel Old 收集器的应用组合；&lt;/p&gt;
&lt;p&gt;使用方式：&lt;code&gt;-XX:+UseParallelOldGC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282178/202111/1282178-20211102223547027-880883714.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（图源自《深入理解Java虚拟机（第2版）》）&lt;/p&gt;
&lt;h3 id=&quot;28-cms-收集器&quot;&gt;2.8 CMS 收集器&lt;/h3&gt;
&lt;p&gt;CMS（concurrent mark sweep）是以获取最短垃圾收集停顿时间为目标的收集器，CMS 收集器的关注点尽可能缩短垃圾收集时用户线程的停顿时间，停顿时间越短就越适合与用户交互的程序验，CMS 收集器使用的算法是&lt;strong&gt;标记-清除算法&lt;/strong&gt;实现的；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CMS垃圾收集过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）初始标记（Initial-Mark）阶段：这个阶段程序所有的工作线程都将会因为 Stop-the-Wold 机制而出现短暂的的暂停，这个阶段的主要任务标记处 GC Roots 能够关联到的对象。一旦标记完成后就恢复之前被暂停的的所有应用。 由于直接关联对象比较小，所以这里的操作速度非常快。&lt;/p&gt;
&lt;p&gt;2）并发标记（Concurrent-Mark）阶段：从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长，但是不需要暂停用户线程，用户线程可以与垃圾回收器一起运行。&lt;/p&gt;
&lt;p&gt;3）重新标记（Remark）阶段：由于并发标记阶段，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间因为用户继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常比初始标记阶段长一些，但也远比并发标记阶段时间短。&lt;/p&gt;
&lt;p&gt;4）并发清除（Concurrent-Sweep）阶段： 此阶段清理删除掉标记判断已经死亡的对象，并释放内存空间。由于不需要移动存活对象，所以这个阶段可以与用户线程同时并发运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282178/202111/1282178-20211102223611730-1711741369.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（图源自《深入理解Java虚拟机（第2版）》）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并发可达性分析与三色标记（Tri-color Marking）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能够进行分析。 垃圾回收器的工作流程大体如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;标记出哪些对象是存活的，哪些是垃圾（可回收）；&lt;/li&gt;
&lt;li&gt;进行回收（清除/复制/整理），如果有移动过对象（复制/整理），还需要更新引用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;三色标记（Tri-color Marking）作为工具来辅助推导，把遍历对象图过程中遇到的对象，按照“是否访问过”这个条件标记成以下三种颜色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;白色：尚未访问过。&lt;/li&gt;
&lt;li&gt;黑色：本对象已访问过，而且本对象引用到的其他对象 也全部访问过了。&lt;/li&gt;
&lt;li&gt;灰色：本对象已访问过，但是本对象引用到的其他对象尚未全部访问完。全部访问后，会转换为黑色。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282178/202111/1282178-20211102223628311-2091727231.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设现在有白、灰、黑三个集合（表示当前对象的颜色），其遍历访问过程为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始时，所有对象都在 【白色集合】中；&lt;/li&gt;
&lt;li&gt;将GC Roots 直接引用到的对象 挪到 【灰色集合】中；&lt;/li&gt;
&lt;li&gt;从灰色集合中获取对象：
&lt;ul&gt;
&lt;li&gt;将本对象 引用到的 其他对象 全部挪到 【灰色集合】中&lt;/li&gt;
&lt;li&gt;将本对象 挪到 【黑色集合】里面&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重复步骤3，直至【灰色集合】为空时结束&lt;/li&gt;
&lt;li&gt;结束后，仍在【白色集合】的对象即为 GC Roots 不可达，可以进行回收&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当 Stop The World 时，对象间的引用是不会发生变化的，可以轻松完成标记。 而当需要支持并发标记时，即标记期间应用线程还在继续跑，对象间的引用可能发生变化，多标和漏标的情况就有可能发生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多标-浮动垃圾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设已经遍历到E（变为灰色了），此时应用执行了 &lt;code&gt;objD.fieldE = null&lt;/code&gt; ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282178/202111/1282178-20211102223638608-11492966.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此刻之后，对象E/F/G是“应该”被回收的。然而因为 E 已经变为灰色了，其仍会被当作存活对象继续遍历下去。最终的结果是：这部分对象仍会被标记为存活，即本轮GC不会回收这部分内存。&lt;/p&gt;
&lt;p&gt;这部分本应该回收但是没    有回收到的内存，被称之为“浮动垃圾”。浮动垃圾并不会影响应用程序的正确性，只是需要等到下一轮垃圾回收中才被清除。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;漏标&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设GC线程已经遍历到E（变为灰色了），此时应用线程先执行了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var G = objE.fieldG;
objE.fieldG = null; // 灰色E 断开引用 白色G
objD.fieldG = G; // 黑色D 引用 白色G
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282178/202111/1282178-20211102223652024-600222376.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时切回 GC 线程继续跑，因为 E 已经没有对 G 的引用了，所以不会将 G 放到灰色集合；尽管因为 D 重新引用了 G，但因为D已经是黑色了，不会再重新做遍历处理。&lt;/p&gt;
&lt;p&gt;最终导致的结果是：G 会一直停留在白色集合中，最后被当作垃圾进行清除。这直接影响到了应用程序的正确性，是不可接受的。&lt;/p&gt;
&lt;p&gt;漏标只有同时满足以下两个条件时才会发生：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;灰色对象断开了白色对象的引用：即灰色对象原来成员变量的引用发生了变化&lt;/li&gt;
&lt;li&gt;黑色对象重新引用了该白色对象：即黑色对象成员变量增加了新的引用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从代码的角度看：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var G = objE.fieldG;   // 1. 读取对象 E 的成员变量 fieldG 的引用值（对象 G）
objE.fieldG = null;    // 2. 对象 E 往其成员变量 fieldG 写入 null 值
objD.fieldG = G;       // 3. 对象 D 往其成员变量 fieldG 写入 对象G
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只要在上面这三步中的任意一步将对象 G 记录起来，然后作为灰色对象再进行遍历即可。&lt;br/&gt;
比如放到一个特定的集合，等初始的 GC Roots 遍历完（并发标记），该集合的对象遍历即可（重新标记）。&lt;/p&gt;
&lt;p&gt;重新标记是需要 STW 的，因为应用程序一直在跑的话，该集合可能会一直增加新的对象，导致永远都跑不完。当然，并发标记期间也可以将该集合中的大部分先跑了，从而缩短重新标记STW的时间，这个是优化问题了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CMS收集器三个缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CMS 收集器对 CPU 资源非常敏感。CMS 默认启动的回收线程数是 &lt;code&gt;(处理器核心数量 + 3) / 4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;CMS 收集器无法处理浮动垃圾，可能出现 Concurrent Mode Failure 失败而导致另一次 Full GC 的产生&lt;/li&gt;
&lt;li&gt;空间碎片：CMS是一款基于标记-清除算法实现的收集器，所有会有空间碎片的现象
&lt;ul&gt;
&lt;li&gt;开关参数 &lt;code&gt;-XX:+UseCMS-CompactAtFullCollection&lt;/code&gt; （默认是开启的，JDK 9开始废弃），用于在 CMS 收集器不得不进行 Full GC 时开启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，是无法并发的&lt;/li&gt;
&lt;li&gt;另外一个参数 &lt;code&gt;-XX:CMSFullGCsBeforeCompaction&lt;/code&gt;（JDK 9开始废弃），这个参数的作用是要求 CMS 收集器在执行过若干次（数量由参数值决定） 不整理空间的 Full GC 之后，下一次进入 Full GC 前会先进行碎片整理（默认值为0，表 示每次进入Full GC时都进行碎片整理）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;29--g1-收集器&quot;&gt;2.9  G1 收集器&lt;/h3&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;Garbage First是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282178/202111/1282178-20211102223721614-679593556.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;G1 把内存划分为多个独立的区域 Region&lt;/li&gt;
&lt;li&gt;G1 仍然保留分代思想，保留了新生代和老年代，但他们不再是物理隔离，而是一部分Region的集合&lt;/li&gt;
&lt;li&gt;G1 能够充分利用多CPU、多核环境硬件优势，尽量缩短 STW 的时间&lt;/li&gt;
&lt;li&gt;G1 整体整体采用标记整理算法，局部是采用复制算法，不会产生内存碎片&lt;/li&gt;
&lt;li&gt;G1 的停顿可预测，能够明确指定在一个时间段内，消耗在垃圾收集上的时间不超过设置时间&lt;/li&gt;
&lt;li&gt;G1 跟踪各个Region里面垃圾的价值大小，会维护一个优先列表，每次根据允许的时间来回收价值最大的区域，从而保证在有限事件内高效的收集垃圾&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Region区域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;G1 不再坚持固定大小以及固定数量的分代区域划分，而是把连续的 Java 堆划分为多个独立区域（Region），每一个 Region 都可以根据需要扮演新生代的 Eden 空间、 Survivor 空间、老年代空间。&lt;/p&gt;
&lt;p&gt;① 使用G1收集器时，它将整个 Java 堆划分成约2048个大小相同的独立 Region 块，每个 Region 块大小根据堆空间的实际大小而定，为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。&lt;br/&gt;
② 虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region (不需要连续)的集合。通过Region的动态分配方式实现逻辑上的连续。&lt;br/&gt;
③ G1垃圾收集器还增加了一种新的内存区域，叫做 Humongous 内存区域。主要用于存储大对象，如果超过 1.5 个 Region，就放到 H 区。一般被视为老年代。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;G1 GC过程&lt;/strong&gt;&lt;br/&gt;
G1 提供了两种 GC 模式，Young GC 和 Mixed GC，两种均是完全 Stop The World 的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Young GC：选定所有年轻代里的 Region，通过控制年轻代的 Region 个数，即年轻代内存大小，来控制 Young GC 的时间开销。&lt;/li&gt;
&lt;li&gt;Mixed GC：选定所有年轻代里的 Region，外加根据 global concurrent marking 统计得出收集收益高的若干老年代 Region。在用户指定的开销目标范围内尽可能选择收益高的老年代 Region。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;初始标记（Initial Mark，STW）：和 CMS 一样只标记 GC Roots 直接关联的对象&lt;br/&gt;
并发标记（Concurrent Mark）：进行 GC Roots Traceing 过程&lt;br/&gt;
最终标记（Remark，STW）：修正并发标记期间，因程序运行导致发生变化的那一部分对象&lt;br/&gt;
筛选回收（Cleanup，STW）：根据时间来进行价值最大化收集&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282178/202111/1282178-20211102223732984-1488529164.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（图源自《深入理解Java虚拟机（第2版）》）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;G1 Young GC&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行 YoungGC 前：堆分为大约2000个区域。最小大小为 1Mb，最大大小为 32Mb。蓝色区域保存老年代对象，绿色区域保存年轻对象。&lt;/li&gt;
&lt;li&gt;执行 YoungGC 时：将存活的对象（即复制或移动）到一个或多个幸存者区域。如果满足老化阈值，则某些对象将被提升到老年代区域。&lt;/li&gt;
&lt;li&gt;执行 YoungGC 后：最近升级的对象以深蓝色显示。幸存者区域为绿色。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282178/202111/1282178-20211102223753503-2005955969.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282178/202111/1282178-20211102223802758-459684496.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282178/202111/1282178-20211102223811369-1655336037.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;堆是单个内存空间，分为多个区域。&lt;/li&gt;
&lt;li&gt;年轻代内存由一组非连续区域组成。&lt;/li&gt;
&lt;li&gt;年轻一代的垃圾收集器或年轻的 GC 出现 STW 。将停止所有应用程序线程以进行操作。&lt;/li&gt;
&lt;li&gt;年轻的 GC 使用多个线程并行完成。&lt;/li&gt;
&lt;li&gt;将活动对象复制到新的幸存者或老年代的地区。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;G1 Mix GC&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始标记阶段（Initial Marking，STW）：存活的对象的初始标记背负在年轻的垃圾收集器上。在日志中，此标记为 GC pause (young)(inital-mark) 。&lt;/li&gt;
&lt;li&gt;并发标记阶段（Concurrent Marking）：如果找到空白区域（如“ X”所示），则在 Remark 阶段将其立即删除。另外，计算确定活跃度的信息。&lt;/li&gt;
&lt;li&gt;最终标记阶段（Remark，STW）：空区域将被删除并回收。现在可以计算所有区域的区域活跃度。&lt;/li&gt;
&lt;li&gt;筛选回收阶段/复制清理阶段（Copying/Cleanup，STW）： G1选择“活度”最低的区域，这些区域可以被最快地收集。然后与年轻的GC同时收集这些区域。这在日志中表示为[GC pause (mixed)] 。因此，年轻代和老年代都是同时收集的。&lt;/li&gt;
&lt;li&gt;筛选回收阶段-(复制/清理)阶段之后：选定的区域已被收集并压缩为图中所示的深蓝色区域和深绿色区域。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282178/202111/1282178-20211102223826451-1497812212.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282178/202111/1282178-20211102223933876-636201427.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282178/202111/1282178-20211102223941852-395806501.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282178/202111/1282178-20211102223955389-1660295970.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282178/202111/1282178-20211102224004236-656444845.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并发标记阶段
&lt;ul&gt;
&lt;li&gt;活动信息是在应用程序运行时同时计算的。&lt;/li&gt;
&lt;li&gt;该活动信息标识在疏散暂停期间最适合回收的区域。&lt;/li&gt;
&lt;li&gt;像 CMS 中没有清扫阶段。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最终标记阶段
&lt;ul&gt;
&lt;li&gt;使用开始快照（SATB）算法，该算法比 CMS 使用的算法快得多。&lt;/li&gt;
&lt;li&gt;完全回收空区域。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;筛选回收阶段
&lt;ul&gt;
&lt;li&gt;同时回收年轻一代和老一代。&lt;/li&gt;
&lt;li&gt;老年代地区是根据其活跃度来选择的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;210-zgc、epsilon、shenandoah&quot;&gt;2.10 ZGC、Epsilon、Shenandoah&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Epsilon&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JDK11 新增的GC，一个处理内存分配但不实现任何实际内存回收机制的GC，一旦可用的Java堆耗尽，JVM将关闭。如果有 &lt;code&gt;System.gc()&lt;/code&gt; 调用，实际上什么也不会发生， 因为没有内存回收，这个实现可能会警告用户尝试强制GC是徒劳。&lt;/p&gt;
&lt;p&gt;使用方式：&lt;code&gt;-XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;用途：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性能测试（它可以帮助过滤掉 GC 引起的性能假象）&lt;/li&gt;
&lt;li&gt;内存压力测试（例如知道测试用例应该分配不超过 1GB 的内存，我们可以使用 &lt;code&gt;-XX:+UnlockExperimentalVMOptions –XX:+UseEpsilonGC -Xmx1g&lt;/code&gt;，如果程序有问题则程序会崩溃）&lt;/li&gt;
&lt;li&gt;非常短的 JOB 任务（GC 清理可能会让时间更长）&lt;/li&gt;
&lt;li&gt;VM 接口测试&lt;/li&gt;
&lt;li&gt;Last-drop 延迟&amp;amp;吞吐改进&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;ZGC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ZGC的设计目标是：支持 TB 级内存容量，暂停时间低（&amp;lt;10ms），对整个程序吞吐量的影响小于15%。 将来还可以扩展实现机制，以支持不少令人兴奋的功能，例如多层堆（即热对象置于 DRAM 和冷对象置于 NVMe 闪存），或压缩堆。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JDK11 新增：ZGC （实验） &lt;code&gt;-XX:+UnlockExperimentalVMOptions -XX:+UseZGC&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;JDK13 更新：ZGC 支持的最大堆大小从 4TB 增加到 16TB&lt;/li&gt;
&lt;li&gt;JDK14 更新：ZGC 支持在 Windows 上作为实验功能&lt;/li&gt;
&lt;li&gt;JDK15 正式：ZGC 不再标记为实验功能可以在生产环境中使用 &lt;code&gt;-XX:+UseZGC&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Shenandoah&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JDK12 新增的GC，低暂停时间垃圾收集器（实验性）Shenandoah的暂停时间与堆大小无关，这意味着无论堆是200MB还是200GB，都将具有相同的一致暂停时间。它的 evacuation 阶段工作能通过与正在运行中 Java 工作线程同时进行（即并发，concurrent），从而减少 GC 的停顿时间。&lt;/p&gt;
&lt;p&gt;使用方法： &lt;code&gt;-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;某些 JDK 会在 build 时通过 &lt;code&gt;--with-jvm-features=-shenandoahgc&lt;/code&gt; 来禁用 Shenandoah。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;内容为之前学习笔记整理，如果有问题请指正！（引用图片已标记来源）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>279246eb94136a4f8e867458dbfd7dca</guid>
<title>Java 17 新功能介绍</title>
<link>https://toutiao.io/k/zsach85</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;post-content&quot; id=&quot;article-container&quot;&gt;&lt;p&gt;&lt;img src=&quot;/img/bilibili-loading.gif&quot; data-lazy-src=&quot;https://img.wdbyte.com/img/21/11veo8wiv.jpg?x-oss-process=style/1000px&quot; alt=&quot;JDK 发布历程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java 17&lt;/strong&gt; 在 2021 年 9 月 14 日正式发布，Java 17 是一个长期支持（LTS）版本，这次更新共带来 14 个新功能。&lt;/p&gt;
&lt;p&gt;OpenJDK Java 17 下载：&lt;a target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot; href=&quot;https://jdk.java.net/archive/&quot;&gt;https://jdk.java.net/archive/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;OpenJDK Java 17 文档：&lt;a target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot; href=&quot;https://openjdk.java.net/projects/jdk/17/&quot;&gt;https://openjdk.java.net/projects/jdk/17/&lt;/a&gt;&lt;/p&gt;
&lt;span id=&quot;more&quot;/&gt;


&lt;blockquote&gt;
&lt;p&gt; 此文章属于&lt;a href=&quot;https://www.wdbyte.com/java-feature&quot;&gt; Java 新特性教程&lt;/a&gt; 系列，会介绍 Java 每个版本的新功能，可以点击浏览。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-JEP-306：-恢复始终严格的浮点语义&quot;&gt;&lt;a href=&quot;#1-JEP-306：-恢复始终严格的浮点语义&quot; class=&quot;headerlink&quot; title=&quot;1. JEP 306： 恢复始终严格的浮点语义&quot;/&gt;1. JEP 306： 恢复始终严格的浮点语义&lt;/h2&gt;&lt;p&gt;既然是恢复严格的浮点语义，那么说明在某个时间点之前，是始终严格的浮点语义的。其实在 Java SE 1.2 之前，所有的浮点计算都是严格的，但是以当初的情况来看，过于严格的浮点计算在当初流行的 x86 架构和 x87 浮点协议处理器上运行，需要大量的额外的指令开销，所以在 Java SE 1.2 开始，需要手动使用关键字 &lt;strong&gt;strictfp&lt;/strong&gt;（strict float point） 才能启用严格的浮点计算。&lt;/p&gt;
&lt;p&gt;但是在 2021 年的今天，硬件早已发生巨变，当初的问题已经不存在了，所以从 Java 17 开始，恢复了始终严格的浮点语义这一特性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扩展&lt;/strong&gt;：&lt;em&gt;&lt;strong&gt;strictfp&lt;/strong&gt;&lt;/em&gt; 是 Java 中的一个关键字，大多数人可能没有注意过它，它可以用在类、接口或者方法上，被 strictfp 修饰的部分中的 float 和 double 表达式会进行严格浮点计算。&lt;/p&gt;
&lt;p&gt;下面是一个示例，其中的 &lt;code&gt;testStrictfp()&lt;/code&gt; 被 &lt;code&gt;strictfp&lt;/code&gt; 修饰。&lt;/p&gt;
&lt;pre class=&quot;language-java&quot; data-language=&quot;java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;com&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;wdbyte&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Main&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token function&quot;&gt;testStrictfp&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;strictfp&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;testStrictfp&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;float&lt;/span&gt; aFloat &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0.6666666666666666666f&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;double&lt;/span&gt; aDouble &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0.88888888888888888d&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;double&lt;/span&gt; sum &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; aFloat &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; aDouble&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;sum: &quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; sum&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;2-JEP-356：增强的伪随机数生成器&quot;&gt;&lt;a href=&quot;#2-JEP-356：增强的伪随机数生成器&quot; class=&quot;headerlink&quot; title=&quot;2. JEP 356：增强的伪随机数生成器&quot;/&gt;2. JEP 356：增强的伪随机数生成器&lt;/h2&gt;&lt;p&gt;为伪随机数生成器 RPNG（pseudorandom number generator）增加了新的接口类型和实现，让在代码中使用各种 PRNG 算法变得容易许多。&lt;/p&gt;
&lt;p&gt;这次增加了 &lt;code&gt;RandomGenerator&lt;/code&gt; 接口，为所有的 PRNG 算法提供统一的 API，并且可以获取不同类型的 PRNG 对象流。同时也提供了一个新类 &lt;code&gt;RandomGeneratorFactory&lt;/code&gt; 用于构造各种 &lt;code&gt;RandomGenerator&lt;/code&gt; 实例，在 &lt;code&gt;RandomGeneratorFactory&lt;/code&gt; 中使用 &lt;code&gt;ServiceLoader.provider&lt;/code&gt; 来加载各种 PRNG 实现。&lt;/p&gt;
&lt;p&gt;下面是一个使用示例：随便选择一个 PRNG 算法生成 5 个 10 以内的随机数。&lt;/p&gt;
&lt;pre class=&quot;language-java&quot; data-language=&quot;java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;com&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;wdbyte&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;java17&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;util&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;util&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;random&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;RandomGenerator&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;util&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;random&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;RandomGeneratorFactory&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;util&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;stream&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Stream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;/**
 * @author niulang
 */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; JEP356 &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;RandomGeneratorFactory&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;RandomGenerator&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; l128X256MixRandom &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;RandomGeneratorFactory&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;L128X256MixRandom&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;// 使用时间戳作为随机数种子&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;RandomGenerator&lt;/span&gt; randomGenerator &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; l128X256MixRandom&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;randomGenerator&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;nextInt&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到输出：&lt;/p&gt;
&lt;pre class=&quot;language-shell&quot; data-language=&quot;shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;7
3
4
4
6&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你也可以遍历出所有的 PRNG 算法。&lt;/p&gt;
&lt;pre class=&quot;language-java&quot; data-language=&quot;java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token class-name&quot;&gt;RandomGeneratorFactory&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;factory &lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;factory&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;:&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; factory&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到输出：&lt;/p&gt;
&lt;pre class=&quot;language-shell&quot; data-language=&quot;shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;LXM:L32X64MixRandom
LXM:L128X128MixRandom
LXM:L64X128MixRandom
Legacy:SecureRandom
LXM:L128X1024MixRandom
LXM:L64X128StarStarRandom
Xoshiro:Xoshiro256PlusPlus
LXM:L64X256MixRandom
Legacy:Random
Xoroshiro:Xoroshiro128PlusPlus
LXM:L128X256MixRandom
Legacy:SplittableRandom
LXM:L64X1024MixRandom&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到 &lt;code&gt;Legacy:Random&lt;/code&gt; 也在其中，新的 API 兼容了老的 &lt;code&gt;Random&lt;/code&gt; 方式，所以你也可以使用新的 API 调用 &lt;code&gt;Random&lt;/code&gt; 类生成随机数。&lt;/p&gt;
&lt;pre class=&quot;language-java&quot; data-language=&quot;java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 使用 Random&lt;/span&gt;
&lt;span class=&quot;token class-name&quot;&gt;RandomGeneratorFactory&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;RandomGenerator&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; l128X256MixRandom &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;RandomGeneratorFactory&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Random&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 使用时间戳作为随机数种子&lt;/span&gt;
&lt;span class=&quot;token class-name&quot;&gt;RandomGenerator&lt;/span&gt; randomGenerator &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; l128X256MixRandom&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;randomGenerator&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;nextInt&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;扩展阅读：&lt;a target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot; href=&quot;https://openjdk.java.net/jeps/356&quot;&gt;增强的伪随机数生成器&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;3-JEP-382：使用新的-macOS-渲染库&quot;&gt;&lt;a href=&quot;#3-JEP-382：使用新的-macOS-渲染库&quot; class=&quot;headerlink&quot; title=&quot;3. JEP 382：使用新的 macOS 渲染库&quot;/&gt;3. JEP 382：使用新的 macOS 渲染库&lt;/h2&gt;&lt;p&gt;macOS 为了提高图形的渲染性能，在 2018 年 9 月抛弃了之前的 OpenGL 渲染库 ，而使用了 Apple Metal 进行代替。Java 17 这次更新开始支持 Apple Metal，不过对于 API 没有任何改变，这一些都是内部修改。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;扩展阅读：&lt;a target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot; href=&quot;https://developer.apple.com/documentation/macos-release-notes/macos-mojave-10_14-release-notes?preferredLanguage=occ#3035786&quot;&gt;macOS Mojave 10.14 Release Notes&lt;/a&gt;，&lt;a target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot; href=&quot;https://developer.apple.com/metal/&quot;&gt;Apple Metal&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;4-JEP-391：支持-macOS-AArch64-架构&quot;&gt;&lt;a href=&quot;#4-JEP-391：支持-macOS-AArch64-架构&quot; class=&quot;headerlink&quot; title=&quot;4. JEP 391：支持 macOS/AArch64 架构&quot;/&gt;4. JEP 391：支持 macOS/AArch64 架构&lt;/h2&gt;&lt;p&gt;起因是 Apple 在 2020 年 6 月的 WWDC 演讲中宣布，将开启一项长期的将 Macintosh 计算机系列从 x64 过度到 AArch64 的长期计划，因此需要尽快的让 JDK 支持 macOS/AArch64 。&lt;/p&gt;
&lt;p&gt;Linux 上的 AArch64 支持以及在 Java 16 时已经支持，可以查看之前的文章了解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;扩展：&lt;a href=&quot;https://www.wdbyte.com/java/java-16/&quot;&gt;Java 16 新功能介绍 - JEP 386&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;5-JEP-398：删除已弃用的-Applet-API&quot;&gt;&lt;a href=&quot;#5-JEP-398：删除已弃用的-Applet-API&quot; class=&quot;headerlink&quot; title=&quot;5. JEP 398：删除已弃用的 Applet API&quot;/&gt;5. JEP 398：删除已弃用的 Applet API&lt;/h2&gt;&lt;p&gt;Applet 是使用 Java 编写的可以嵌入到 HTML 中的小应用程序，嵌入方式是通过普通的 HTML 标记语法，由于早已过时，几乎没有场景在使用了。&lt;/p&gt;
&lt;p&gt;示例：嵌入 Hello.class&lt;/p&gt;
&lt;pre class=&quot;language-html&quot; data-language=&quot;html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;applet&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;Hello.class&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;200&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;200&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;applet&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Applet API 在 Java 9 时已经标记了废弃，现在 Java 17 中将彻底删除。&lt;/p&gt;
&lt;h2 id=&quot;6-JEP-403：更强的-JDK-内部封装&quot;&gt;&lt;a href=&quot;#6-JEP-403：更强的-JDK-内部封装&quot; class=&quot;headerlink&quot; title=&quot;6. JEP 403：更强的 JDK 内部封装&quot;/&gt;6. JEP 403：更强的 JDK 内部封装&lt;/h2&gt;&lt;p&gt;如 Java 16 的 JEP 396 中描述的一样，为了提高 JDK 的安全性，使 &lt;code&gt;--illegal-access&lt;/code&gt; 选项的默认模式从允许更改为拒绝。通过此更改，JDK 的内部包和 API（&lt;a target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot; href=&quot;https://openjdk.java.net/jeps/260#Description&quot;&gt;关键内部 API&lt;/a&gt; 除外）将不再默认打开。&lt;/p&gt;
&lt;p&gt;但是在 Java 17 中，除了 &lt;code&gt;sun.misc.Unsafe&lt;/code&gt; ，使用 &lt;code&gt;--illegal-access&lt;/code&gt; 命令也不能打开 JDK 内部的强封装模式了，除了 &lt;code&gt;sun.misc.Unsafe&lt;/code&gt; API .&lt;/p&gt;
&lt;p&gt;在 Java 17 中使用 &lt;code&gt;--illegal-access&lt;/code&gt; 选项将会得到一个命令已经移除的警告。&lt;/p&gt;
&lt;pre class=&quot;language-shell&quot; data-language=&quot;shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;➜  bin ./java -version
openjdk version &quot;17&quot; 2021-09-14
OpenJDK Runtime Environment (build 17+35-2724)
OpenJDK 64-Bit Server VM (build 17+35-2724, mixed mode, sharing)
➜  bin ./java --illegal-access=warn
OpenJDK 64-Bit Server VM warning: Ignoring option --illegal-access=warn; support was removed in 17.0&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;扩展阅读：&lt;a target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot; href=&quot;https://openjdk.java.net/jeps/403&quot;&gt;JEP 403：更强的 JDK 内部封装&lt;/a&gt;，&lt;a href=&quot;https://www.wdbyte.com/java/java-16/&quot;&gt;Java 16 新功能介绍&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;7-JEP-406：switch-的类型匹配（预览）&quot;&gt;&lt;a href=&quot;#7-JEP-406：switch-的类型匹配（预览）&quot; class=&quot;headerlink&quot; title=&quot;7. JEP 406：switch 的类型匹配（预览）&quot;/&gt;7. JEP 406：switch 的类型匹配（预览）&lt;/h2&gt;&lt;p&gt;如 &lt;code&gt;instanceof&lt;/code&gt; 一样，为 &lt;code&gt;switch&lt;/code&gt; 也增加了类型匹配自动转换功能。&lt;/p&gt;
&lt;p&gt;在之前，使用 &lt;code&gt;instanceof&lt;/code&gt; 需要如下操作：&lt;/p&gt;
&lt;pre class=&quot;language-java&quot; data-language=&quot;java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;obj &lt;span class=&quot;token keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; s &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; obj&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;token comment&quot;&gt;// grr...&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多余的类型强制转换，而现在：&lt;/p&gt;
&lt;pre class=&quot;language-java&quot; data-language=&quot;java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;obj &lt;span class=&quot;token keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; s&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// Let pattern matching do the work!&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;switch&lt;/code&gt; 也可以使用类似的方式了。&lt;/p&gt;
&lt;pre class=&quot;language-java&quot; data-language=&quot;java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;formatterPatternSwitch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; o&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;o&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Integer&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;int %d&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Long&lt;/span&gt; l    &lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;long %d&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; l&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Double&lt;/span&gt; d  &lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;double %f&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; d&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; s  &lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;String %s&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; s&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt;        &lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt; o&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于 &lt;code&gt;null&lt;/code&gt; 值的判断也有了新的方式。&lt;/p&gt;
&lt;pre class=&quot;language-java&quot; data-language=&quot;java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// Java 17 之前&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;testFooBar&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; s&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;s &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;oops!&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Foo&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Bar&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Great&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt;           &lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Ok&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// Java 17&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;testFooBar&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; s&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;         &lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Oops&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Foo&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Bar&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Great&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt;           &lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Ok&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;扩展阅读： &lt;a target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot; href=&quot;https://openjdk.java.net/jeps/406&quot;&gt;JEP 406：switch 的类型匹配（预览）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;8-JEP-407：移除-RMI-Activation&quot;&gt;&lt;a href=&quot;#8-JEP-407：移除-RMI-Activation&quot; class=&quot;headerlink&quot; title=&quot;8. JEP 407：移除 RMI Activation&quot;/&gt;8. JEP 407：移除 RMI Activation&lt;/h2&gt;&lt;p&gt;移除了在 JEP 385 中被标记废除的 RMI（Remote Method Invocation）Activation，但是 RMI 其他部分不会受影响。&lt;/p&gt;
&lt;p&gt;RMI Activation 在 Java 15 中的 JEP 385 已经被标记为过时废弃，至今没有收到不良反馈，因此决定在 Java 17 中正式移除。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;扩展阅读： &lt;a target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot; href=&quot;https://openjdk.java.net/jeps/407&quot;&gt;JEP 407：移除 RMI Activation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;9-JEP-409：密封类（Sealed-Classes）&quot;&gt;&lt;a href=&quot;#9-JEP-409：密封类（Sealed-Classes）&quot; class=&quot;headerlink&quot; title=&quot;9. JEP 409：密封类（Sealed Classes）&quot;/&gt;9. JEP 409：密封类（Sealed Classes）&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Sealed Classes&lt;/strong&gt; 在 Java 15 中的 JEP 360 中提出，在 Java 16 中的 JEP 397  再次预览，现在 Java 17 中成为正式的功能，相比 Java 16 并没有功能变化，这里不再重复介绍，想了解的可以参考之前文章。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;扩展阅读：&lt;a href=&quot;https://www.wdbyte.com/java/java-16/&quot;&gt;Java 16 新功能介绍&lt;/a&gt;，&lt;a target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot; href=&quot;https://openjdk.java.net/jeps/409&quot;&gt;JEP 409: Sealed Classes&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;10-JEP-401：移除实验性的-AOT-和-JIT-编译器&quot;&gt;&lt;a href=&quot;#10-JEP-401：移除实验性的-AOT-和-JIT-编译器&quot; class=&quot;headerlink&quot; title=&quot;10. JEP 401：移除实验性的 AOT 和 JIT 编译器&quot;/&gt;10. JEP 401：移除实验性的 AOT 和 JIT 编译器&lt;/h2&gt;&lt;p&gt;在 Java 9 的 JEP 295 中，引入了实验性的提前编译  jaotc 工具，但是这个特性自从引入依赖用处都不太大，而且需要大量的维护工作，所以在 Java 17 中决定删除这个特性。&lt;/p&gt;
&lt;p&gt;主要移除了三个 JDK 模块：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;jdk.aot - jaotc 工具。&lt;/li&gt;
&lt;li&gt;Jdk.internal.vm.compiler - Graal 编译器。&lt;/li&gt;
&lt;li&gt;jdk.internal.vm.compiler.management&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同时也移除了部分与 AOT 编译相关的 HotSpot 代码：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;src/hotspot/share/aot&lt;/code&gt; — dumps and loads AOT code&lt;/li&gt;
&lt;li&gt;Additional code guarded by &lt;code&gt;#if INCLUDE_AOT&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;11-JEP-411：弃用-Security-Manager&quot;&gt;&lt;a href=&quot;#11-JEP-411：弃用-Security-Manager&quot; class=&quot;headerlink&quot; title=&quot;11. JEP 411：弃用  Security Manager&quot;/&gt;11. JEP 411：弃用  Security Manager&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Security Manager&lt;/strong&gt; 在 JDK 1.0 时就已经引入，但是它一直都不是保护服务端以及客户端 Java 代码的主要手段，为了 Java 的继续发展，决定弃用  Security Manager，在不久的未来进行删除。&lt;/p&gt;
&lt;pre class=&quot;language-java&quot; data-language=&quot;java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@Deprecated&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;since&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;17&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; forRemoval&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SecurityManager&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;12-JEP-412：外部函数和内存-API-（孵化）&quot;&gt;&lt;a href=&quot;#12-JEP-412：外部函数和内存-API-（孵化）&quot; class=&quot;headerlink&quot; title=&quot;12. JEP 412：外部函数和内存 API （孵化）&quot;/&gt;12. JEP 412：外部函数和内存 API （孵化）&lt;/h2&gt;&lt;p&gt;新的 API 允许 Java 开发者与 JVM 之外的代码和数据进行交互，通过调用外部函数，可以在不使用 JNI 的情况下调用本地库。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这是一个孵化功能；需要添加&lt;code&gt;--add-modules jdk.incubator.foreign&lt;/code&gt;来编译和运行 Java 代码。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;历史&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java 14 &lt;a target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot; href=&quot;https://openjdk.java.net/jeps/370&quot;&gt;JEP 370&lt;/a&gt;引入了外部内存访问 API（孵化器）。&lt;/li&gt;
&lt;li&gt;Java 15 &lt;a target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot; href=&quot;https://openjdk.java.net/jeps/383&quot;&gt;JEP 383&lt;/a&gt;引入了外部内存访问 API（第二孵化器）。&lt;/li&gt;
&lt;li&gt;Java 16 &lt;a target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot; href=&quot;https://openjdk.java.net/jeps/389&quot;&gt;JEP 389&lt;/a&gt;引入了外部链接器 API（孵化器）。&lt;/li&gt;
&lt;li&gt;Java 16 &lt;a target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot; href=&quot;https://openjdk.java.net/jeps/393&quot;&gt;JEP 393&lt;/a&gt;引入了外部内存访问 API（第三孵化器）。&lt;/li&gt;
&lt;li&gt;Java 17 &lt;a target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot; href=&quot;https://openjdk.java.net/jeps/412&quot;&gt;JEP 412&lt;/a&gt;引入了外部函数和内存 API（孵化器）。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;扩展阅读：&lt;a target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot; href=&quot;https://openjdk.java.net/jeps/412&quot;&gt;JEP 412：外部函数和内存 API （孵化）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;13-JEP-414：Vector-API（二次孵化）&quot;&gt;&lt;a href=&quot;#13-JEP-414：Vector-API（二次孵化）&quot; class=&quot;headerlink&quot; title=&quot;13. JEP 414：Vector API（二次孵化）&quot;/&gt;13. JEP 414：Vector API（二次孵化）&lt;/h2&gt;&lt;p&gt;在 Java 16 中引入一个新的 API 来进行向量计算，它可以在运行时可靠的编译为支持的 CPU 架构，从而实现更优的计算能力。&lt;/p&gt;
&lt;p&gt;现在 Java 17 中改进了 Vector API 性能，增强了例如对字符的操作、字节向量与布尔数组之间的相互转换等功能。&lt;/p&gt;
&lt;h2 id=&quot;14-JEP-415：指定上下文的反序列化过滤器&quot;&gt;&lt;a href=&quot;#14-JEP-415：指定上下文的反序列化过滤器&quot; class=&quot;headerlink&quot; title=&quot;14. JEP 415：指定上下文的反序列化过滤器&quot;/&gt;14. JEP 415：指定上下文的反序列化过滤器&lt;/h2&gt;&lt;p&gt;Java 中的序列化一直都是非常重要的功能，如果没有序列化功能，Java 可能都不会占据开发语言的主导地位，序列化让远程处理变得容易和透明，同时也促进了 Java EE 的成功。&lt;/p&gt;
&lt;p&gt;但是 Java 序列化的问题也很多，它几乎会犯下所有的可以想象的错误，为开发者带来持续的维护工作。但是要说明的是序列化的概念是没有错的，把对象转换为可以在 JVM 之间自由传输，并且可以在另一端重新构建的能力是完全合理的想法，问题在于 Java 中的序列化设计存在风险，以至于爆出过很多和序列化相关的漏洞。&lt;/p&gt;
&lt;p&gt;反序列化危险的一个原因是，有时候我们不好验证将要进行反序列化的内容是否存在风险，而传入的数据流可以自由引用对象，很有可能这个数据流就是攻击者精心构造的恶意代码。&lt;/p&gt;
&lt;p&gt;所以，JEP 415 允许在反序列化时，通过一个过滤配置，来告知本次反序列化允许或者禁止操作的类，反序列化时碰到被禁止的类，则会反序列化失败。&lt;/p&gt;
&lt;h3 id=&quot;14-1-反序列化示例&quot;&gt;&lt;a href=&quot;#14-1-反序列化示例&quot; class=&quot;headerlink&quot; title=&quot;14.1. 反序列化示例&quot;/&gt;14.1. 反序列化示例&lt;/h3&gt;&lt;p&gt;假设 Dog 类中的 Poc 是恶意构造的类，但是正常反序列化是可以成功的。&lt;/p&gt;
&lt;pre class=&quot;language-java&quot; data-language=&quot;java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;com&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;wdbyte&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;java17&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ByteArrayInputStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ByteArrayOutputStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;IOException&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ObjectInputStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ObjectOutputStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Serializable&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;/**
 * @author niulang
 */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; JEP415 &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;IOException&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ClassNotFoundException&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;Dog&lt;/span&gt; dog &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Dog&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;哈士奇&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        dog&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setPoc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Poc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;// 序列化 - 对象转字节数组&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;ByteArrayOutputStream&lt;/span&gt; byteArrayOutputStream &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ByteArrayOutputStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ObjectOutputStream&lt;/span&gt; objectOutputStream &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ObjectOutputStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;byteArrayOutputStream&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            objectOutputStream&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;writeObject&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;dog&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; bytes &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; byteArrayOutputStream&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toByteArray&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;// 反序列化 - 字节数组转对象&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;ByteArrayInputStream&lt;/span&gt; byteArrayInputStream &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ByteArrayInputStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;bytes&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;ObjectInputStream&lt;/span&gt; objectInputStream &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ObjectInputStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;byteArrayInputStream&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; object &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; objectInputStream&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;readObject&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Dog&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Serializable&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Poc&lt;/span&gt; poc&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Dog&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Dog{&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;name=&#x27;&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; name &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#x27;\&#x27;&#x27;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#x27;}&#x27;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// get...set...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Poc&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Serializable&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre class=&quot;language-none&quot;&gt;&lt;code class=&quot;language-none&quot;&gt;Dog{name=&#x27;哈士奇&#x27;}&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;14-2-反序列化过滤器&quot;&gt;&lt;a href=&quot;#14-2-反序列化过滤器&quot; class=&quot;headerlink&quot; title=&quot;14.2. 反序列化过滤器&quot;/&gt;14.2. 反序列化过滤器&lt;/h3&gt;&lt;p&gt;在 Java 17 中可以自定义反序列化过滤器，拦截不允许的类。&lt;/p&gt;
&lt;pre class=&quot;language-java&quot; data-language=&quot;java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;com&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;wdbyte&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;java17&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ByteArrayInputStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ByteArrayOutputStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;IOException&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ObjectInputFilter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ObjectInputStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ObjectOutputStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Serializable&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;/**
 * @author niulang
 */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; JEP415 &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;IOException&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ClassNotFoundException&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;Dog&lt;/span&gt; dog &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Dog&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;哈士奇&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        dog&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setPoc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Poc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;// 序列化 - 对象转字节数组&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;ByteArrayOutputStream&lt;/span&gt; byteArrayOutputStream &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ByteArrayOutputStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ObjectOutputStream&lt;/span&gt; objectOutputStream &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ObjectOutputStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;byteArrayOutputStream&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            objectOutputStream&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;writeObject&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;dog&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; bytes &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; byteArrayOutputStream&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toByteArray&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;// 反序列化 - 字节数组转对象&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;ByteArrayInputStream&lt;/span&gt; byteArrayInputStream &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ByteArrayInputStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;bytes&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;ObjectInputStream&lt;/span&gt; objectInputStream &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ObjectInputStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;byteArrayInputStream&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;// 允许 com.wdbyte.java17.Dog 类，允许 java.base 中的所有类，拒绝其他任何类&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;ObjectInputFilter&lt;/span&gt; filter &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ObjectInputFilter&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Config&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createFilter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
                        &lt;span class=&quot;token string&quot;&gt;&quot;com.wdbyte.java17.Dog;java.base/*;!*&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        objectInputStream&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setObjectInputFilter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;filter&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; object &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; objectInputStream&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;readObject&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Dog&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Serializable&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Poc&lt;/span&gt; poc&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Dog&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Dog{&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;name=&#x27;&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; name &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#x27;\&#x27;&#x27;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#x27;}&#x27;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// get...set...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Poc&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Serializable&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时反序列化会得到异常。&lt;/p&gt;
&lt;pre class=&quot;language-shell&quot; data-language=&quot;shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;Exception in thread &quot;main&quot; java.io.InvalidClassException: filter status: REJECTED
at java.base/java.io.ObjectInputStream.filterCheck(ObjectInputStream.java:1412)
at java.base/java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:2053)
at java.base/java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1907)
....&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;扩展阅读：&lt;a target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot; href=&quot;https://openjdk.java.net/jeps/415&quot;&gt;JEP 415：指定上下文的反序列化过滤器&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;/&gt;参考&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot; href=&quot;https://openjdk.java.net/projects/jdk/17/&quot;&gt;https://openjdk.java.net/projects/jdk/17/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot; href=&quot;https://docs.oracle.com/en/java/javase/17/&quot;&gt;https://docs.oracle.com/en/java/javase/17/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/article&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6a42a68892dd53d1f5ce0bae194e32e5</guid>
<title>高并发系统建设经验总结</title>
<link>https://toutiao.io/k/zcql3fl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502257907&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：listenzhang，腾讯 PCG 后台开发工程师&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;早期从事运单系统的开发和维护工作，从最早的日均百万单，到日均千万单，业务的快速发展再加上外卖业务的特点是，业务量集中在午高峰和晚高峰两个高峰期，所以高峰期并发请求量也是水涨船高，每天都要面对高并发的挑战。拿运单系统来举例，日常午高峰核心查询服务的 QPS 在 20 万以上，Redis 集群的 QPS 更是在百万级，数据库 QPS 也在 10 万级以上，TPS 在 2 万以上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这么大的流量下，主要的工作也是以围绕如何建设系统的稳定性和提升容量展开，下面主要从基础设施、数据库、架构、应用、规范这几方面谈谈如何建设高并发的系统。以下都是我个人这几年的一些经验总结，架构没有银弹，因此也称不上是最佳实践，&lt;strong&gt;仅供参考&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基础设施&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分层架构中，最底层的就是基础设施。基础设置一般来说包含了物理服务器、IDC、部署方式等等。就像一个金字塔，基础设施就是金字塔的底座，只有底座稳定了，上层才能稳定。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281515&quot; data-ratio=&quot;0.7694704049844237&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GFGJTBibkQSE6UtK1pVFm8XbT9Kp7EolJic6sqRzyUiccaFGmHJfhs0vTw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;642&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;异地多活&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多活可以分为同城多活、异地多活等等，实现方式也有多种，比如阿里使用的单元化方案，饿了么使用的是多中心的方案，关于多活的实现可以参考：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32009822&quot; data-linktype=&quot;2&quot;&gt;饿了么多活实现分享&lt;/a&gt;。当时做多活的主要出发点是保证系统的高可用性，避免单 IDC 的单点故障问题，同时由于每个机房的流量都变成了总流量的 1/N，也变相提升了系统容量，在高并发的场景下可以抗更多的流量。下图是活的整体架构，来源于上面多活实现的分享文章中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281518&quot; data-ratio=&quot;0.6073684210526316&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8G2d95FyjbeTw9oHNUleu5HyTYqOm0jJI45vdueg2ziabrAFlKFjbkLxQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;950&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据库&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库是整个系统最重要的组成部分之一，在高并发的场景下很大一部分工作是围绕数据库展开的，主要需要解决的问题是如何提升数据库容量。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;读写分离&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;互联网的大部分业务特点是读多写少，因此使用读写分离架构可以有效降低数据库的负载，提升系统容量和稳定性。核心思路是由主库承担写流量，从库承担读流量，且在读写分离架构中一般都是 1 主多从的配置，通过多个从库来分担高并发的查询流量。比如现在有 1 万 QPS 的以及 1K 的 TPS，假设在 1 主 5 从的配置下，主库只承担 1K 的 TPS，每个从库承担 2K 的 QPS，这种量级对 DB 来说是完全可接受的，相比读写分离改造前，DB 的压力明显小了许多。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281516&quot; data-ratio=&quot;0.47295423023578365&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GwZ22RbyBXKLiclsCpwbkvibWpjcOUF5m9BlhefYevibgIAkaj5teXp80g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;721&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种模式的好处是简单，几乎没有代码改造成本或只有少量的代码改造成本，只需要配置数据库主从即可。缺点也是同样明显的：&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;主从延迟&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL 默认的主从复制是异步的，如果在主库插入数据后马上去从库查询，可能会发生查不到的情况。正常情况下主从复制会存在毫秒级的延迟，在 DB 负载较高的情况下可能存在秒级延迟甚至更久，但即使是毫秒级的延迟，对于实时性要求较高的业务来说也是不可忽视的。所以在一些关键的查询场景，我们会将查询请求绑定到主库来避免主从延迟的问题。关于主从延迟的优化网上也有不少的文章分享，这里就不再赘述。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;从库的数量是有限的&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个主库能挂载的从库数量是很有限的，没办法做到无限的水平扩展。从库越多，虽然理论上能承受的 QPS 就越高，但是从库过多会导致主库主从复制 IO 压力更大，造成更高的延迟，从而影响业务，所以一般来说只会在主库后挂载有限的几个从库。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;无法解决 TPS 高的问题&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从库虽然能解决 QPS 高的问题，但没办法解决 TPS 高的问题，所有的写请求只有主库能处理，一旦 TPS 过高，DB 依然有宕机的风险。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分库分表&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当读写分离不能满足业务需要时，就需要考虑使用分库分表模式了。当确定要对数据库做优化时，应该优先考虑使用读写分离的模式，只有在读写分离的模式已经没办法承受业务的流量时，我们才考虑分库分表的模式。分库分表模式的最终效果是把单库单表变成多库多表，如下图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281517&quot; data-ratio=&quot;0.45271317829457364&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GU80ogQl4l5AaB6Xp5q0wW7boZyWyh7etTPe7YNNcYKuhWfWt9O7FSQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;645&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先来说下分表，分表可以分为垂直拆分和水平拆分。垂直拆分就是按业务维度拆，假设原来有张订单表有 100 个字段，可以按不同的业务纬度拆成多张表，比如用户信息一张表，支付信息一张表等等，这样每张表的字段相对来说都不会特别多。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281514&quot; data-ratio=&quot;0.7862232779097387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8Gs4qjdLibPRywsIDlueAJT1IBU0CW7OXsXNnBvYbRWjaicocicsDyNsWAw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;421&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;水平拆分是把一张表拆分成 N 张表，比如把 1 张订单表，拆成 512 张订单子表。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281520&quot; data-ratio=&quot;0.9524940617577197&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GXtZH8iaJnXYhG2KA0xcqQEhtDS2L9C221wneD1TrJNDEy3uTfsXgjow/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;421&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实践中可以只做水平拆分或垂直拆分，也可以同时做水平及垂直拆分。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281519&quot; data-ratio=&quot;0.9303944315545244&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GdFveSZJNlKH4iaeJWEsIOVh860UpzqjQOBGlkZiceHYJYRS9tcRbWNBA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;431&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说完了分表，那分库是什么呢？分库就是把原来都在一个 DB 实例中的表，按一定的规则拆分到 N 个 DB 实例中，每个 DB 实例都会有一个 master，相当于是多 mater 的架构，同时为了保证高可用性，每个 master 至少要有 1 个 slave，来保证 master 宕机时 slave 能及时顶上，同时也能保证数据不丢失。拆分完后每个 DB 实例中只会有部分表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于是多 master 的架构，分库分表除了包含读写分离模式的所有优点外，还可以解决读写分离架构中无法解决的 TPS 过高的问题，同时分库分表理论上是可以无限横向扩展的，也解决了读写分离架构下从库数量有限的问题。当然在实际的工程实践中一般需要提前预估好容量，因为数据库是有状态的，如果发现容量不足再扩容是非常麻烦的，应该尽量避免。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分库分表的模式下可以通过不启用查询从库的方式来避免主从延迟的问题，也就是说读写都在主库，因为在分库后，每个 master 上的流量只占总流量的 1/N，大部分情况下能扛住业务的流量，从库只作为 master 的备份，在主库宕机时执行主从切换顶替 master 提供服务使用。说完了好处，再来说说分库分表会带来的问题，主要有以下几点：&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;改造成本高&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分库分表一般需要中间件的支持，常见的模式有两种：客户端模式和代理模式。客户端模式会通过在服务上引用 client 包的方式来实现分库分表的逻辑，比较有代表的是开源的 sharding JDBC。代理模式是指所有的服务不是直接连接 MySQL，而是通过连接代理，代理再连接到 MySQL 的方式，代理需要实现 MySQL 相关的协议。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281521&quot; data-ratio=&quot;0.833641404805915&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GKZuDXZs3R8cvl8cBIGVS1FjU9ibCDmDUOr7QhtCrPmTU0MgEkbb4aRA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;541&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两种模式各有优劣势，代理模式相对来说会更复杂，但是因为多了一层代理，在代理这层能做更多的事情，也比较方便升级，而且通过代理连接数据库，也能保证数据库的连接数稳定。使用客户端模式好处是相对来说实现比较简单，无中间代理，理论上性能也会更好，但是在升级的时候需要业务方改造代码，因此升级会比代理模式更困难。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;事务问题&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在业务中我们会使用事务来处理多个数据库操作，通过事务的 4 个特性——一致性、原子性、持久性、隔离性来保证业务流程的正确性。在分库分表后，会将一张表拆分成 N 张子表，这 N 张子表可能又在不同的 DB 实例中，因此虽然逻辑上看起来还是一张表，但其实已经不在一个 DB 实例中了，这就造成了无法使用事务的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最常见的就是在批量操作中，在分库分表前我们可以同时把对多个订单的操作放在一个事务中，但在分库分表后就不能这么干了，因为不同的订单可能属于不同用户，假设我们按用户来分库分表，那么不同用户的订单表位于不同的 DB 实例中，多个 DB 实例显然没办法使用一个事务来处理，这就需要借助一些其他的手段来解决这个问题。在分库分表后应该要尽量避免这种跨 DB 实例的操作，如果一定要这么使用，优先考虑使用补偿等方式保证数据最终一致性，如果一定要强一致性，常用的方案是通过分布式事务的方式。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;无法支持多维度查询&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分库分表一般只能按 1-2 个纬度来分，这个维度就是所谓的&lt;code&gt;sharding key&lt;/code&gt;。常用的维度有用户、商户等维度，如果按用户的维度来分表，最简单的实现方式就是按用户 ID 来取模定位到在哪个分库哪个分表，这也就意味着之后所有的读写请求都必须带上用户 ID，但在实际业务中不可避免的会存在多个维度的查询，不一定所有的查询都会有用户 ID，这就需要我们对系统进行改造。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281523&quot; data-ratio=&quot;0.4780763790664781&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GXILzicO8GXSic32fZiaphicftlAS8WEGoQ0kbD3HFbqcECfAWqQFKL5C1Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;707&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了能在分库分表后也支持多维度查询，常用的解决方案有两种，第一种是引入一张索引表，这张索引表是没有分库分表的，还是以按用户 ID 分库分表为例，索引表上记录各种维度与用户 ID 之间的映射关系，请求需要先通过其他维度查询索引表得到用户 ID，再通过用户 ID 查询分库分表后的表。这样，一来需要多一次 IO，二来索引表由于是没有分库分表的，很容易成为系统瓶颈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二种方案是通过引入&lt;code&gt;NoSQL&lt;/code&gt;的方式，比较常见的组合是&lt;code&gt;ES+MySQL&lt;/code&gt;，或者&lt;code&gt;HBase+MySQL&lt;/code&gt;的组合等，这种方案本质上还是通过 NoSQL 来充当第一种方案中的索引表的角色，但是相对于直接使用索引表来说，&lt;code&gt;NoSQL&lt;/code&gt;具有更好的水平扩展性和伸缩性，只要设计得当，一般不容易成为系统的瓶颈。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据迁移&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分库分表一般是需要进行数据迁移的，通过数据迁移将原有的单表数据迁移到分库分表后的库表中。数据迁移的方案常见的有两种，第一种是停机迁移，顾名思义，这种方式简单粗暴，好处是能一步到位，迁移周期短，且能保证数据一致性，坏处是对业务有损，某些关键业务可能无法接受几分钟或更久的停机迁移带来的业务损失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外一种方案是双写，这主要是针对新增的增量数据，存量数据可以直接进行数据同步，关于如何进行双写迁移网上已经有很多分享了，这里也就不赘述，核心思想是同时写老库和新库。双写的好处是对业务的影响小，但也更复杂，迁移周期更长，容易出现数据不一致问题，需要有完整的数据一致性保证方案支持。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读写分离模式和分库分表模式推荐优先使用读写分离模式，只有在不满业务需求的情况才才考虑使用分库分表模式。原因是分库分表模式虽然能显著提升数据库的容量，但会增加系统复杂性，而且由于只能支持少数的几个维度读写，从某种意义上来说对业务系统也是一种限制，因此在设计分库分表方案的时候需要结合具体业务场景，更全面的考虑。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;架构&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发系统建设中，架构同样也是非常重要的，这里分享缓存、消息队列、资源隔离等等模式的一些经验。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;缓存&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发的系统架构中缓存是最有效的利器，可以说没有之一。缓存的最大作用是可以提升系统性能，保护后端存储不被大流量打垮，增加系统的伸缩性。缓存的概念最早来源于 CPU 中，为了提高 CPU 的处理速度，引入了 L1、L2、L3 三级高速缓存来加速访问，现在系统中使用的缓存也是借鉴了 CPU 中缓存的做法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存是个非常大的话题，可以单独写一本书也毫不夸张，在这里总结一下我个人在运单系统设计和实现缓存的时候遇到的一些问题和解决方案。缓存主要分为本地缓存和分布式缓存，本地缓存如&lt;code&gt;Guava Cache&lt;/code&gt;、&lt;code&gt;EHCache&lt;/code&gt;等，分布式缓存如&lt;code&gt;Redis&lt;/code&gt;、&lt;code&gt;Memcached&lt;/code&gt;等，在运单系统中使用的主要以分布式缓存为主。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何保证缓存与数据库的数据一致性&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先是如何保证缓存与数据库的数据一致性问题，基本在使用缓存的时候都会遇到这个问题，同时这也是个高频的面试题。在我负责的运单系统中使用缓存这个问题就更突出了，首先运单是会频繁更新的，并且运单系统对数据一致性的要求是非常高的，基本不太能接受数据不一致，所以不能简单的通过设置一个过期时间的方式来失效缓存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于缓存读写的模式推荐阅读耗子叔的文章：&lt;a href=&quot;https://coolshell.cn/articles/17416.html&quot; data-linktype=&quot;2&quot;&gt;缓存更新的套路&lt;/a&gt;，里面总结了几种常用的读写缓存的套路，我在运单系统中的缓存读写模式也是参考了文章中的&lt;code&gt;Write through&lt;/code&gt;模式，通过伪代码的方式大概是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;lock(运单ID) {&lt;br/&gt; //...&lt;br/&gt; &lt;br/&gt;    // 删除缓存&lt;br/&gt;   deleteCache();&lt;br/&gt;    // 更新DB&lt;br/&gt;   updateDB();&lt;br/&gt;    // 重建缓存&lt;br/&gt;   reloadCache()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然是&lt;code&gt;Write through&lt;/code&gt;模式，那对缓存的更新就是在写请求中进行的。首先为了防止并发问题，写请求都需要加分布式锁，锁的粒度是以运单 ID 为 key，在执行完业务逻辑后，先删除缓存，再更新 DB，最后再重建缓存，这些操作都是同步进行的，在读请求中先查询缓存，如果缓存命中则直接返回，如果缓存不命中则查询 DB，然后直接返回，也就是说在读请求中不会操作缓存，这种方式把缓存操作都收敛在写请求中，且写请求是加锁的，有效防止了读写并发导致的写入脏缓存数据的问题。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;缓存数据结构的设计&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存要避免大 key 和热 key 的问题。举个例子，如果使用&lt;code&gt;redis&lt;/code&gt;中的&lt;code&gt;hash&lt;/code&gt;数据结构，那就比普通字符串类型的 key 更容易有大 key 和热 key 问题，所以如果不是非要使用&lt;code&gt;hash&lt;/code&gt;的某些特定操作，可以考虑把&lt;code&gt;hash&lt;/code&gt;拆散成一个一个单独的 key/value 对，使用普通的&lt;code&gt;string&lt;/code&gt;类型的 key 存储，这样可以防止&lt;code&gt;hash&lt;/code&gt;元素过多造成的大 key 问题，同时也可以避免单&lt;code&gt;hash key&lt;/code&gt;过热的问题。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;读写性能&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于读写性能主要有两点需要考虑，首先是写性能，影响写性能的主要因素是 key/value 的数据大小，比较简单的场景可以使用&lt;code&gt;JSON&lt;/code&gt;的序列化方式存储，但是在高并发场景下使用 JSON 不能很好的满足性能要求，而且也比较占存储空间，比较常见的替代方案有&lt;code&gt;protobuf&lt;/code&gt;、&lt;code&gt;thrift&lt;/code&gt;等等，关于这些序列化/反序列化方案网上也有一些性能对比，参考&lt;a href=&quot;https://code.google.com/p/thrift-protobuf-compare/wiki/Benchmarking&quot; data-linktype=&quot;2&quot;&gt;thrift-protobuf-compare - Benchmarking.wiki&lt;/a&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281522&quot; data-ratio=&quot;0.6240928882438317&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GXe7a51sUnkazZCZFWBuytJ7EdiajFds9yIysF2Vibet4ZLZPPt9VXxUw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;689&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读性能的主要影响因素是每次读取的数据包的大小。在实践中推荐使用&lt;code&gt;redis pipeline&lt;/code&gt;+批量操作的方式，比如说如果是字符串类型的 key，那就是&lt;code&gt;pipeline+mget&lt;/code&gt;的方式，假设一次&lt;code&gt;mget&lt;/code&gt;10 个 key，100 个&lt;code&gt;mget&lt;/code&gt;为一批 pipeline，那一次网络 IO 就可以查询 1000 个缓存 key，当然这里具体一批的数量要看缓存 key 的数据包大小，没有统一的值。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;适当冗余&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;适当冗余的意思是说我们在设计对外的业务查询接口的时候，可以适当的做一些冗余。这个经验是来自于当时我们在设计运单系统对外查询接口的时候，为了追求通用性，将接口的返回值设计成一个大对象，把运单上的所有字段都放在了这个大对象里面直接对外暴露了，这样的好处是不需要针对不同的查询方开发不同的接口了，反正字段就在接口里了，要什么就自己取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么做一开始是没问题的，但到我们需要对查询接口增加缓存的时候发现，由于所有业务方都通过这一个接口查询运单数据，我们没办法知道他们的业务场景，也就不知道他们对接口数据一致性的要求是怎么样的，比如能否接受短暂的数据一致性，而且我们也不知道他们具体使用了接口中的哪些字段，接口中有些字段是不会变的，有些字段是会频繁变更的，针对不同的更新频率其实可以采用不同的缓存设计方案，但很可惜，因为我们设计接口的时候过于追求通用性，在做缓存优化的时候就非常麻烦，只能按最坏的情况打算，也就是所有业务方都对数据一致性要求很高来设计方案，导致最后的方案在数据一致性这块花了大量的精力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们一开始设计对外查询接口的时候能做一些适当的冗余，区分不同的业务场景，虽然这样势必会造成有些接口的功能是类似的，但在加缓存的时候就能有的放矢，针对不同的业务场景设计不同的方案，比如关键的流程要注重数据一种的保证，而非关键场景则允许数据短暂的不一致来降低缓存实现的成本。同时在接口中最好也能将会更新的字段和不会更新的字段做一定的区分，这样在设计缓存方案的时候，针对不会更新的字段，可以设置一个较长的过期时间，而会更新的字段，则只能设置较短的过期时间，并且需要做好缓存更新的方案设计来保证数据一致性。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消息队列&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发系统的架构中，消息队列（MQ）是必不可少的，当大流量来临时，我们通过消息队列的异步处理和削峰填谷的特性来增加系统的伸缩性，防止大流量打垮系统，此外，使用消息队列还能使系统间达到充分解耦的目的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281524&quot; data-ratio=&quot;0.18876755070202808&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GRH2o1UFatv6MOyvM2OR99L7mrWUdOnGF35JG9ZOW5UR0uz9t6999uQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;641&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息队列的核心模型由生产者（Producer）、消费者（Consumer）和消息中间件（Broker）组成。目前业界常用的开源解决方案有&lt;code&gt;ActiveMQ&lt;/code&gt;、&lt;code&gt;RabbitMQ&lt;/code&gt;、&lt;code&gt;Kafka&lt;/code&gt;、&lt;code&gt;RocketMQ&lt;/code&gt;和近年比较火的&lt;code&gt;Pulsar&lt;/code&gt;，关于各种消息中间件的对比可以参考文章：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/401416746&quot; data-linktype=&quot;2&quot;&gt;消息队列背后的设计思想&lt;/a&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用消息队列后，可以将原本同步处理的请求，改为通过消费 MQ 消息异步消费，这样可以减少系统处理的压力，增加系统吞吐量，关于如何使用消息队列有许多的分享的文章，这里我的经验是在考虑使用消息队列时要结合具体的业务场景来决定是否引入消息队列，因为使用消息队列后其实是增加了系统的复杂性的，原来通过一个同步请求就能搞定的事情，需要引入额外的依赖，并且消费消息是异步的，异步天生要比同步更复杂，还需要额外考虑消息乱序、延迟、丢失等问题，如何解决这些问题又是一个很大话题，天下没有免费的午餐，做任何架构设计是一个取舍的过程，需要仔细考虑得失后再做决定。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;服务治理&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务治理是个很大的话题，可以单独拿出来说，在这里我也把它归到架构中。服务治理的定义是&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;一般指独立于业务逻辑之外，给系统提供一些可靠运行的系统保障措施。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的保障措施包括服务的注册发现、可观测性（监控）、限流、超时、熔断等等，在微服务架构中一般通过服务治理框架来完成服务治理，开源的解决方案包括&lt;code&gt;Spring Cloud&lt;/code&gt;、&lt;code&gt;Dubbo&lt;/code&gt;等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发的系统中，服务治理是非常重要的一块内容，相比于缓存、数据库这些大块的内容，服务治理更多的是细节，比如对接口的超时设置到底是 1 秒还是 3 秒，怎么样做监控等等，有句话叫细节决定成败，有时候就是因为一个接口的超时设置不合理而导致大面积故障的事情，我曾经也是见识过的，特别是在高并发的系统中，一定要注意这些细节。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281528&quot; data-ratio=&quot;1.0740740740740742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GAjSWhLd7S1Q7kXVdzIiaDfjTtiaiaO5U86NNET4QDvycdbic9NhldFllVA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;432&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;超时&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于超时的原则是：&lt;strong&gt;一切皆有超时&lt;/strong&gt;。不管是 RPC 调用、Redis 操作、消费消息/发送消息、DB 操作等等，都要有超时。之前就遇到过依赖了外部组件，但是没有设置合理的超时，当外部依赖出现故障时，把服务所有的线程全部阻塞导致资源耗尽，无法响应外部请求，从而引发故障，这些都是“血”的教训。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了要设置超时，还要设置合理的超时也同样重要，像上面提到的故障即使设置了超时，但是超时太久的话依然会因为外部依赖故障而把服务拖垮。如何设置一个合理的超时是很有讲究的，可以从是否关键业务场景、是否强依赖等方面去考虑，没有什么通用的规则，需要结合具体的业务场景来看。比如在一些 C 端展示接口中，设置 1 秒的超时似乎没什么问题，但在一些对性能非常敏感的场景下 1 秒可能就太久了，总之，需要结合具体的业务场景去设置，但无论怎么样，原则还是那句话：一切皆有超时。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;监控&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;监控就是系统的眼睛，没有监控的系统就像一个黑盒，从外部完全不知道里面的运行情况，我们就无法管理和运维这个系统。所以，监控系统是非常重要的。系统的可观测性主要包含三个部分——&lt;code&gt;logging&lt;/code&gt;、&lt;code&gt;tracing&lt;/code&gt;、&lt;code&gt;metrics&lt;/code&gt;。主要是使用的自研的监控系统，不得不说真的是非常的好用，具体的介绍可以参考：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4NzU0MDIzOQ==&amp;amp;mid=2247494222&amp;amp;idx=1&amp;amp;sn=143a8ad9e4da4bdf9e7a6c4c738e3bf2&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;饿了么 EMonitor 演进史&lt;/a&gt;。在建设高并发系统时，我们一定要有完善的监控体系，包括系统层面的监控（CPU、内存、网络等）、应用层面的监控（JVM、性能等）、业务层面的监控（各种业务曲线等）等，除了监控还要有完善的报警，因为不可能有人 24 小时盯着监控，一旦有什么风险一定要报警出来，及时介入，防范风险于未然。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;熔断&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在微服务框架中一般都会内置熔断的特性，熔断的目的是为了在下游服务出故障时保护自身服务。熔断的实现一般会有一个断路器（&lt;code&gt;Crit Breaker&lt;/code&gt;），断路器会根据接口成功率/次数等规则来判断是否触发熔断，断路器会控制熔断的状态在关闭-打开-半打开中流转。熔断的恢复会通过时间窗口的机制，先经历半打开状态，如果成功率达到阈值则关闭熔断状态。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281525&quot; data-ratio=&quot;0.5315682281059063&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GYpEJA8eeICicFoveyBgicNAvhqFJ4v3OIFWW3ayWricJ4rIuRoqRpujZA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;491&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有什么特殊需求的话在业务系统中一般是不需要针对熔断做什么的，框架会自动打开和关闭熔断开关。可能需要注意的点是要避免&lt;strong&gt;无效的熔断&lt;/strong&gt;，什么是无效的熔断呢？在以前碰到过一个故障，是服务的提供方在一些正常的业务校验中抛出了不合理的异常（比如系统异常），导致接口熔断影响正常业务。所以我们在接口中抛出异常或者返回异常码的时候一定要区分业务和系统异常，一般来说业务异常是不需要熔断的，如果是业务异常而抛出了系统异常，会导致被熔断，正常的业务流程就会受到影响。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;降级&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;降级不是一种具体的技术，更像是一种架构设计的方法论，是一种丢卒保帅的策略，核心思想就是在异常的情况下限制自身的一些能力，来保证核心功能的可用性。降级的实现方式有许多，比如通过配置、开关、限流等等方式。降级分为主动降级和被动降级。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281526&quot; data-ratio=&quot;0.30182599355531686&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GsicHLficml1ohkvzqfuPPnX6BJ4oGj8zex5whz80XJFyucAxRXIV1VicQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;931&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在电商系统大促的时候会把一些非核心的功能暂时关闭，来保证核心功能的稳定性，或者当下游服务出现故障且短时间内无法恢复时，为了保证自身服务的稳定性而把下游服务降级，这些都是主动降级。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;被动降级指的是，比如调用了下游一个接口，但是接口超时了，这个时候为了让业务流程能继续执行下去，一般会选择在代码中&lt;code&gt;catch&lt;/code&gt;异常，打印一条错误日志，然后继续执行业务逻辑，这种降级是被动的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发的系统中做好降级是非常重要的。举个例子来说，当请求量很大的时候难免有超时，如果每次超时业务流程都中断了，那么会大大影响正常业务，合理的做法是我们应该仔细区分强弱依赖，对于弱依赖采用被动降级的降级方式，而对于强依赖是不能进行降级的。降级与熔断类似，也是对自身服务的保护，避免当外部依赖故障时拖垮自身服务，所以，我们要做好充分的降级预案。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;限流&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于限流的文章和介绍网上也有许多，具体的技术实现可以参考网上文章。关于限流我个人的经验是在设置限流前一定要通过压测等方式充分做好系统容量的预估，不要拍脑袋，限流一般来说是有损用户体验的，应该作为一种兜底手段，而不是常规手段。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;资源隔离&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;资源隔离有各种类型，物理层面的服务器资源、中间件资源，代码层面的线程池、连接池，这些都可以做隔离。这里介绍的资源隔离主要是应用部署层面的，比如&lt;code&gt;Set化&lt;/code&gt;等等。上文提到的异地多活也算是 Set 化的一种。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;负责运单系统的期间也做过一些类似的资源隔离上的优化。背景是当时出遇到过一个线上故障，原因是某服务部署的服务器都在一个集群，没有按流量划分各自单独的集群，导致关键业务和非关键业务流量互相影响而导致的故障。因此，在这个故障后我也是决定对服务器做按集群隔离部署，隔离的维度主要是按业务场景区分，分为关键集群、次关键集群和非关键集群三类，这样能避免关键和非关键业务互相影响。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281527&quot; data-ratio=&quot;0.6150537634408603&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8G384ia8MLb0EGqA8c1Rg0icYHG0EsnyatZJsPBEbFf7K1Zkv8tKaqic17A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;930&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在架构方面，我个人也不是专业的架构师，也是一直在学习相关技术和方法论，上面介绍的很多技术和架构设计模式都是在工作中边学习边实践。如果说非要总结一点经验心得的话，我觉得是注重细节。个人认为架构不止高大上的方法论，技术细节也是同样重要的，正所谓细节决定成败，有时候忘记设置一个小小的超时，可能导致整个系统的崩溃。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;应用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发的系统中，在应用层面能做的优化也是非常多的，这部分主要分享关于补偿、幂等、异步化、预热等这几方面的优化。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;补偿&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在微服务架构下，会按各业务领域拆分不同的服务，服务与服务之前通过 RPC 请求或 MQ 消息的方式来交互，在分布式环境下必然会存在调用失败的情况，特别是在高并发的系统中，由于服务器负载更高，发生失败的概率会更大，因此补偿就更为重要。常用的补偿模式有两种：&lt;strong&gt;定时任务模式&lt;/strong&gt;或者&lt;strong&gt;消息队列模式&lt;/strong&gt;。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;定时任务模式&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定时任务补偿的模式一般是需要配合数据库的，补偿时会起一个定时任务，定时任务执行的时候会扫描数据库中是否有需要补偿的数据，如果有则执行补偿逻辑，这种方案的好处是由于数据都持久化在数据库中了，相对来说比较稳定，不容易出问题，不足的地方是因为依赖了数据库，在数据量较大的时候，会对数据库造成一定的压力，而且定时任务是周期性执行的，因此一般补偿会有一定的延迟。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消息队列模式&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息队列补偿的模式一般会使用消息队列中延迟消息的特性。如果处理失败，则发送一个延迟消息，延迟 N 分钟/秒/小时后再重试，这种方案的好处是比较轻量级，除了 MQ 外没有外部依赖，实现也比较简单，相对来说也更实时，不足的地方是由于没有持久化到数据库中，有丢失数据的风险，不够稳定。因此，我个人的经验是在关键链路的补偿中使用定时任务的模式，非关键链路中的补偿可以使用消息队列的模式。除此之外，在补偿的时候还有一个特别重要的点就是&lt;strong&gt;幂等性&lt;/strong&gt;设计。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;幂等&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幂等操作的特点是&lt;strong&gt;其任意多次执行所产生的影响均与一次执行的影响相同&lt;/strong&gt;，体现在业务上就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为发起多次而产生副作用。在分布式系统中发生系统错误是在所难免的，当发生错误时，会使用重试、补偿等手段来提高容错性，在高并发的系统中发生系统错误的概率就更高了，所以这时候接口幂等就非常重要了，可以防止多次请求而引起的副作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幂等的实现需要通过一个唯一的业务 ID 或者 Token 来实现，一般的流程是先在 DB 或者缓存中查询唯一的业务 ID 或者 token 是否存在，且状态是否为已处理，如果是则表示是重复请求，那么我们需要幂等处理，即不做任何操作，直接返回即可。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281530&quot; data-ratio=&quot;1.3897435897435897&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GJgo1ASUttJBdm8PvTJicZnXQMIu6ySA3xunXdiciccdnMRKOr8m1NuamQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;390&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在做幂等性设计的时候需要注意的是并不是所有的场景都要做幂等，比如用户重复转账、提现等等，因为幂等会让外部系统的感知是调用成功了，并没有阻塞后续流程，但其实我们系统内部是没有做任何操作的，类似上面提到的场景，会让用户误以为操作已成功。所以说要仔细区分需要幂等的业务场景和不能幂等的业务场景，对于不能幂等的业务场景还是需要抛出业务异常或者返回特定的异常码来阻塞后续流程，防止引发业务问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;异步化&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文提到的消息队列也是一种异步化，除了依赖外部中间件，在应用内我们也可以通过线程池、协程的方式做异步化。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281531&quot; data-ratio=&quot;0.3767186067827681&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GNWwHecYicpVCzuib24yFIlHm1gibzza2Br61a92BKqx1xDloYEUhObBeg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1091&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于线程池的实现原理，拿 Java 中线程池的模型来举例，核心是通过任务队列和复用线程的方式相配合来实现的，网上关于这些分享的文章也很多。在使用线程池或者协程等类似技术的时候，我个人的经验是有以下两点是需要特别注意的：&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;关键业务场景需要配合补偿&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，不管是线程池也好，协程也好，都是基于内存的，如果服务器意外宕机或者重启，内存中的数据是会丢失的，而且线程池在资源不足的时候也会拒绝任务，所以在一些关键的业务场景中如果使用了线程池等类似的技术，需要配合补偿一块使用，避免内存中数据丢失造成的业务影响。在我维护的运单系统中有一个关键的业务场景是入单，简单来说就是接收上游请求，在系统中生成运单，这是整个物流履约流量的入口，是特别关键的一个业务场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为生成运单的整个流程比较长，依赖外部接口有 10 几个，所以当时为了追求高性能和吞吐率，设计成了异步的模式，也就是在线程池中处理，同时为了防止数据丢失，也做了完善的补偿措施，这几年时间入单这块基本没有出过问题，并且由于采用了异步的设计，性能非常好，那我们具体是怎么做的呢。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281533&quot; data-ratio=&quot;0.46837763519706693&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GibBVInyiaBswYhUo6Msm57yo9cPCpGUtFm9Fn3ywAuICkebUN1Q0ymDQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1091&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总的流程是在接收到上游的请求后，第一步是将所有的请求参数落库，这一步是非常关键的，如果这一步失败，那整个请求就失败了。在成功落库后，封装一个 Task 提交到线程池中，然后直接对上游返回成功。后续的所有处理都是在线程池中进行的，此外，还有一个定时任务会定时补偿，补偿的数据源就是在第一步中落库的数据，每一条落库的记录会有一个 flag 字段来表示处理状态，如果发现是未处理或者处理失败，则通过定时任务再触发补偿逻辑，补偿成功后再将 flag 字段更新为处理成功。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;做好监控&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在微服务中像 RPC 接口调用、MQ 消息消费，包括中间件、基础设施等的监控，这些基本都会针对性的做完善的监控，但是类似像线程池一般是没有现成监控的，需要使用方自行实现上报打点监控，这点很容易被遗漏。我们知道线程池的实现是会有内存队列的，而我们也一般会对内存队列设置一个最大值，如果超出了最大值可能会丢弃任务，这时候如果没有监控是发现不了类似的问题的，所以，使用线程池一定要做好监控。那么线程池有哪些可以监控的指标呢，按我的经验来说，一般会上报线程池的&lt;strong&gt;活跃线程数&lt;/strong&gt;以及&lt;strong&gt;工作队列的任务个数&lt;/strong&gt;，这两个指标我认为是最重要的，其他的指标就见仁见智了，可以结合具体业务场景来选择性上报。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;预热&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Warm Up。当系统长期处于低水位的情况下，流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过&quot;冷启动&quot;，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考网上的定义，说白了，就是如果服务一直在低水位，这时候突然来一波高并发的流量，可能会一下子把系统打垮。系统的预热一般有 JVM 预热、缓存预热、DB 预热等，通过预热的方式让系统先“热”起来，为高并发流量的到来做好准备。预热实际应用的场景有很多，比如在电商的大促到来前，我们可以把一些热点的商品提前加载到缓存中，防止大流量冲击 DB，再比如 Java 服务由于 JVM 的动态类加载机制，可以在启动后对服务做一波压测，把类提前加载到内存中，同时还有可以提前触发 JIT 编译、Code cache 等等好处。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一种预热的思路是利用业务的特性做一些&lt;strong&gt;预加载&lt;/strong&gt;，比如我们在维护运单系统的时候做过这样一个优化，在一个正常的外卖业务流程中是用户下单后到用户交易系统生成订单，然后经历支付-&amp;gt;商家接单-&amp;gt;请求配送这样一个流程，所以说从用户下单到请求配送这之间有秒级到分钟级的时间差，我们可以通过感知用户下单的动作，利用这时间差来提前加载一些数据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281529&quot; data-ratio=&quot;0.4008559201141227&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GQAmMkP7x9zuuem1j0meLE33TpwxPiaMK46RI5uqKSMRlS6so0T5l79Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;701&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样在实际请求到来的时候只需要到缓存中获取即可，这对于一些比较耗时的操作提升是非常大的，之前我们利用这种方式能提升接口性能 50%以上。当然有个点需要注意的就是如果对于一些可能会变更的数据，可能就不适合预热，因为预热后数据存在缓存中，后面就不会再去请求接口了，这样会导致数据不一致，这是需要特别注意的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在做高并发系统设计的时候我们总是会特别关注架构、基础设施等等，这些的确非常重要，但其实在应用层面能做的优化也是非常多的，而且成本会比架构、基础设施的架构优化低很多。很多时候在应用层面做的优化需要结合具体的业务场景，利用特定的业务场景去做出合理的设计，比如缓存、异步化，我们就需要思考哪些业务场景能缓存，能异步化，哪些就是需要同步或者查询 DB，一定要结合业务才能做出更好的设计和优化。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;规范&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是关于建设高并发系统经验分享的最后一个部分了，但我认为规范的重要性一点都不比基础设施、架构、数据库、应用低，可能还比这些都更重要。根据二八定律，在软件的整个生命周期中，我们花了 20%时间创造了系统，但要花 80%的时间来维护系统，这也让我想起来一句话，有人说代码主要是给人读的，顺便给机器运行，其实都是体现了可维护性的重要性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们使用了高大上的架构、做了各种优化之后，系统确实有了一个比较好的设计，但问题是怎么在后续的维护过程中防止架构腐化呢，这时候就需要规范了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;规范包括代码规范、变更规范、设计规范等等，当然这里我不会介绍如何去设计这些规范，我更想说的是我们一定要重视规范，只有在有了规范之后，系统的可维护性才能有保证。根据破窗理论，通过各种规范我们尽量不让系统有第一扇破窗产生。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说了这么多关于设计、优化的方法，最后想再分享两点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一点就是有句著名的话——“&lt;strong&gt;过早优化是万恶之源&lt;/strong&gt;”，个人非常认同，我做的所有这些设计和优化，都是在系统遇到实际的问题或瓶颈的时候才做的，切忌不要脱离实际场景过早优化，不然很可能做无用功甚至得不偿失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二点是在设计的时候要遵循&lt;strong&gt;KISS 原则&lt;/strong&gt;，也就是 Keep it simple, stupid。简单意味着维护性更高，更不容易出问题，正所谓大道至简，或许就是这个道理。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281532&quot; data-ratio=&quot;0.5663461538461538&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GlCLQhILGwhoOKIBpuodToef1jbGspTfHTkuGsOXBzibyIdqnOax1EUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1040&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上这些都是我在工作期间维护高并发系统的一些经验总结，鉴于篇幅和个人技术水平原因，可能有些部分没有介绍的特别详细和深入，算是抛砖引玉吧。如果有什么说的不对的地方也欢迎指出，同时也欢迎交流和探讨。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;欢迎在视频号参与 1024程序员节 话题活动&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502281477&quot; data-galleryid=&quot;&quot; data-ratio=&quot;5.052&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvaudn5eaH1DhtibTzdpZk6eXKSfOGA4ibdcYJIeGE7dC59nMBV9XoqwNGO6hwibJ1iaVia0My6o3YDxmvjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>79528914c55048800ea6bee60b84266a</guid>
<title>回归现实：Go Leader 对 1.18 泛型的期望</title>
<link>https://toutiao.io/k/833y93c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是煎鱼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前段时间根据 Go 泛型的最新动态，我写了一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;amp;mid=2247492667&amp;amp;idx=1&amp;amp;sn=a2ce6a7db7365831b6e6f651aa5bbaa0&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;出泛型后 API 怎么办？Go 开发者要注意了&lt;/a&gt;》文章，引发了不少小伙伴的热议。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 核心开发团队的现任 Leader
@Russ Cox 在 golang-dev 中正式发表《expectations for generics in Go 1.18》对 Go 泛型给出了 “期待”，其实大家&lt;strong&gt;可以认为是后续泛型的配套迭代计划&lt;/strong&gt;了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100009145&quot; data-ratio=&quot;0.12937062937062938&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4huRY4YpWHDFZxDkQTibpYPz7HfHTy14sMojGSDZBhhaDEoribdoH61MPKpAwGhRZYfCMQiavvTuscWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2288&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不出现严重的问题，Go 1.18 将会包括对泛型的支持，并且这次泛型的支持将会是有史以来最大的一次语言变化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对以下几点有顾虑：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，煎鱼带大家一起了解 Russ Cox 发表的 Go 泛型进程，知悉官方一手消息。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;最佳实践&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 团队表示不知道使用泛型的最佳实践是什么，所以给出的官方文档将无法就何时使用泛型和何时不使用泛型给出精确、明确的答案，只可以给出粗略的指导。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此处可以参考《Effective Go》的最初版本，是在不间断地写了一整年的 Go 代码后，才正式输出的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100009146&quot; data-ratio=&quot;0.5098039215686274&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4huRY4YpWHDFZxDkQTibpYPzLbgCIicyUXWFU68PKhanWXHpics1OE8351VvwISiaD1X9KGMgjMKbiarJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2856&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照现有的计划，官方只会提供关于如何使用泛型的文档，暂时无法提供任何关于风格、最佳实践的规定性文档。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在提供的标准库上，先是已经通过提案的 maps 和 slices库会先放到 golang.org/x/exp 中作为实验，不会保证向后兼容。待成熟后，再推广到标准库中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100009144&quot; data-ratio=&quot;0.44825072886297374&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4huRY4YpWHDFZxDkQTibpYPzqwQ6xk01k06LrSY0O2ZwaHCMofRl7kaBYY5kDoNqD1wbCs3ibQq0H1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2744&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以明确，Go 泛型出来后，社区就会陆续开始百花齐放，接着有官方输出推荐方法了，历史是如此的相似。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;生产经验&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前 Go 团队没有关于泛型的生产经验，因此会在文档中给出明确提示，让大家在生产中使用泛型的时候应该适当谨慎。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;泛型出来后，会陆续涉及到大量的重写工作，但是由于现在处于中间阶段。正在重写的 Go 1.18 工具链去同时适配泛型、非泛型代码是需要时间和经验的，有一定的风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此泛型出来后，可能会出现一些意想不到的问题，仅在生产发现（教训）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;兼容性承诺&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go1.18 会和其他 Go1.x 版本一样，保证向后兼容的承诺：不会破坏用 Go 1.18 构建的代码，包括使用泛型的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是最坏的情况，如果发现 Go 1.18 的语义有一些致命的问题，并需要改变它们（例如：在Go 1.19 中）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将会使用 go.mod 文件的 go 行来确定该模块中的源文件是期待 Go 1.18 还是 Go 1.19+ 语义，以此实现版本控制。但目前来看，不需要这样做。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也建议急于使用 Go 泛型的开源库作者，做好泛型和非泛型版本代表的支持和隔离，这样对用户会更加的友好。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以明确的是，Go 泛型的整体推进方案，在这篇文章中均已说明。Go 官方团队也与许多第三方工具的作者进行沟通。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三方工具可能不会在 Go 1.18 发布时就完全支持泛型，这会由各作者自行根据自己的时间表来更新。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;煎鱼猜测推进节奏就是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;支持泛型语法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;观察。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;推进标准/工具库。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;逐步替换。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修 BUG。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;观察、优化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生产可用。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大概需要 2~3 个 Go 版本，需要 1~2 年，Go 泛型的各类配套组件就会基本完善，可用，转为持续优化了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;你对 Go 官方的推进计划此怎么看呢&lt;/strong&gt;，欢迎在评论区留言和交流！&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100009142&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4huRY4YpWHDFZxDkQTibpYPz4tR7J9psianEP0bglu39w2VOrhNxx76v2Q0THrB3stmS9HB39ABvhwQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;344&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注煎鱼，吸取他的知识 👆&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.07106598984771574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/486RHs1WbcgGib6o96dHbvGUGGwPicd8wusUGH1cXR29tM4bO0lNzialzkQhvU6m5ZUdaKibmcF2OQayjMe9Bia6iaXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;394&quot; data-fileid=&quot;100009143&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你好，我是煎鱼，&lt;span&gt;出版过 Go 畅销书《Go 语言编程之旅》，再到获得 GOP（Go 领域最有观点专家）荣誉，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;amp;mid=2247483854&amp;amp;idx=1&amp;amp;sn=ec422fbf4d846975f2930ddeb5e81373&amp;amp;chksm=f9041493ce739d85a4b987eece14da627206cdad798f645cc770868312e4a22b6df24804f186&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;点击蓝字查看我的出书之路&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;点击蓝字查看我的出书之路&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;日常分享高质量文章，输出 Go 面试、工作经验、架构设计，&lt;span&gt;加微信拉读者交流群，和大家交流！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot; aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_title&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p role=&quot;option&quot; aria-labelledby=&quot;js_a11y_reward_qr_word js_a11y_comma js_a11y_reward_qr_title js_a11y_reward_qr_money&quot; aria-describedby=&quot;js_a11y_reward_qr_tips &quot; class=&quot;reward_tips&quot; id=&quot;js_a11y_reward_qr_word&quot;&gt;来一个反馈！&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img alt=&quot;赞赏二维码&quot; class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_tips&quot; class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>