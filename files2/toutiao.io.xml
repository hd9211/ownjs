<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1e722b2e2cde649971f90a11b76fdb36</guid>
<title>如何改变 Docker 的数据目录</title>
<link>https://toutiao.io/k/etee1wd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;container app-preview post-body&quot;&gt;
  &lt;div class=&quot;preview&quot;&gt;&lt;p&gt;在 Linux 系统中 Docker 默认的数据目录为 &lt;code&gt;/var/lib/docker&lt;/code&gt;, 如果系统磁盘空间
不够大我们需要给它移个位置&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;停止 docker &lt;code&gt;systemctl stop docker&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建一个新的目录并把数据同步过去&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir /srv/docker
rsync -aqxP /var/lib/docker/ /srv/docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是新安装就不需要移数据了&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改配置文件 &lt;code&gt;/etc/docker/daemon.json&lt;/code&gt;, 把数据目录添加进去&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &quot;data-root&quot;: &quot;/srv/docker&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动系统 &lt;code&gt;systemctl start docker&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
  &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9e3b5fcd949db09481b3985fc75e5d41</guid>
<title>引入 Gateway 网关，这些坑一定要学会避开</title>
<link>https://toutiao.io/k/60gr6a8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring cloud gateway是替代zuul的网关产品，基于Spring 5、Spring boot 2.0以上、Reactor, 提供任意的路由匹配和断言、过滤功能。上一篇文章谈了一下&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;amp;mid=2247502520&amp;amp;idx=1&amp;amp;sn=927f28ffcf5ad86ae56e0714b75e68a8&amp;amp;chksm=ebd5f594dca27c82d64a02d6ab07a75b007fdd6d42cbab539c8d317dfd70513a2c75e91bcaf5&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Gateway网关使用不规范，同事加班泪两行~&lt;/a&gt;，这篇文章将会侧重于其他的几个需要注意的地方。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;网关实现&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里介绍编码方式实现&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;HystrixObservableCommand.&lt;span&gt;Setter &lt;span&gt;getSetter&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        HystrixCommandGroupKey groupKey = HystrixCommandGroupKey.Factory.asKey(&lt;span&gt;&quot;group-accept&quot;&lt;/span&gt;);&lt;br/&gt;        HystrixObservableCommand.Setter setter = HystrixObservableCommand.Setter.withGroupKey(groupKey);&lt;br/&gt;        HystrixCommandKey commandKey = HystrixCommandKey.Factory.asKey(&lt;span&gt;&quot;command-accept&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        setter.andCommandKey(commandKey);&lt;br/&gt;&lt;br/&gt;        HystrixCommandProperties.Setter proertiesSetter = HystrixCommandProperties.Setter();&lt;br/&gt;        proertiesSetter&lt;br/&gt;                &lt;span&gt;/* *&lt;br/&gt;                 * 线程策略配置&lt;br/&gt;                 */&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;//设置线程模式 缺省 1000ms&lt;/span&gt;&lt;br/&gt;                .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD)&lt;br/&gt;                &lt;span&gt;//执行是否启用超时时间 缺省 true&lt;/span&gt;&lt;br/&gt;                .withExecutionTimeoutEnabled(&lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;//使用线程隔离时，是否对命令执行超时的线程调用中断 缺省false&lt;/span&gt;&lt;br/&gt;                .withExecutionIsolationThreadInterruptOnFutureCancel(&lt;span&gt;false&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;//执行超时的时候是否要它中断 缺省 true&lt;/span&gt;&lt;br/&gt;                .withExecutionIsolationThreadInterruptOnTimeout(&lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;//执行的超时时间 缺省 1000ms&lt;/span&gt;&lt;br/&gt;                .withExecutionTimeoutInMilliseconds(&lt;span&gt;2000&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;/* *&lt;br/&gt;                 * 熔断策略&lt;br/&gt;                 */&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;//是否开启溶断 缺省 true&lt;/span&gt;&lt;br/&gt;                .withCircuitBreakerEnabled(&lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;// 是否允许熔断器忽略错误,默认false, 不开启 ；&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// true，断路器强制进入“关闭”状态，它会接收所有请求。&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 如果forceOpen属性为true，该属性不生效&lt;/span&gt;&lt;br/&gt;                .withCircuitBreakerForceClosed(&lt;span&gt;false&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;// 是否强制开启熔断器阻断所有请求, 默认为false&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 为true时，所有请求都将被拒绝，直接到fallback.&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 如果该属性设置为true，断路器将强制进入“打开”状态，&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 它会拒绝所有请求。该属性优于forceClosed属性&lt;/span&gt;&lt;br/&gt;                .withCircuitBreakerForceOpen(&lt;span&gt;false&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;// 用来设置当断路器打开之后的休眠时间窗。&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 休眠时间窗结束之后，会将断路器设置为“半开”状态，尝试熔断的请求命令，&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 如果依然请求错误就将断路器继续设置为“打开”状态，如果成功，就设置为“关闭”状态&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 熔断器默认工作时间,默认:5000豪秒.&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 熔断器中断请求10秒后会进入半打开状态,放部分流量过去重试.&lt;/span&gt;&lt;br/&gt;                .withCircuitBreakerSleepWindowInMilliseconds(&lt;span&gt;5000&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;// 熔断器在整个统计时间内是否开启的阀值.&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 在metricsRollingStatisticalWindowInMilliseconds（默认10s）内默认至少请求10次，&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 熔断器才发挥起作用,9次熔断器都不起作用。&lt;/span&gt;&lt;br/&gt;                .withCircuitBreakerRequestVolumeThreshold(&lt;span&gt;100&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;// 该属性用来设置断路器打开的错误百分比条件。默认值为50.&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 表示在滚动时间窗中，在请求值超过requestVolumeThreshold阈值的前提下，&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 如果错误请求数百分比超过50，就把断路器设置为“打开”状态，否则就设置为“关闭”状态&lt;/span&gt;&lt;br/&gt;                .withCircuitBreakerErrorThresholdPercentage(&lt;span&gt;50&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        setter.andCommandPropertiesDefaults(proertiesSetter);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; setter;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; RouteLocator &lt;span&gt;customRouteLocator&lt;/span&gt;&lt;span&gt;(RouteLocatorBuilder builder)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; RouteLocatorBuilder.Builder routes = builder.routes();&lt;br/&gt; RouteLocatorBuilder.Builder serviceProvider = routes&lt;br/&gt;  .route(&lt;span&gt;&quot;accept&quot;&lt;/span&gt;,&lt;br/&gt;   r -&amp;gt; r.method(HttpMethod.GET)&lt;br/&gt;    .and()&lt;br/&gt;    .path(&lt;span&gt;&quot;/gateway-accept/**&quot;&lt;/span&gt;)&lt;br/&gt;    .and()&lt;br/&gt;    .header(HttpHeaders.CONTENT_TYPE, &lt;span&gt;&quot;application/json;charset=UTF-8&quot;&lt;/span&gt;)&lt;br/&gt;    .filters(f -&amp;gt; {&lt;br/&gt;     f.rewritePath(&lt;span&gt;&quot;/gateway-accept/(?&amp;lt;path&amp;gt;.*)&quot;&lt;/span&gt;, &lt;span&gt;&quot;/${path}&quot;&lt;/span&gt;);&lt;br/&gt;     f.requestRateLimiter(&lt;br/&gt;      config -&amp;gt; config.setKeyResolver(&lt;span&gt;new&lt;/span&gt; GenericAccessResolver())&lt;br/&gt;       .setRateLimiter(redisRateLimiter()));&lt;br/&gt;     f.hystrix(config -&amp;gt; config.setName(&lt;span&gt;&quot;accept&quot;&lt;/span&gt;)&lt;br/&gt;      .setFallbackUri(&lt;span&gt;&quot;forward:/gateway-fallback&quot;&lt;/span&gt;)&lt;br/&gt;      .setSetter(getSetter()));&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; f;&lt;br/&gt;    })&lt;br/&gt;    .uri(&lt;span&gt;&quot;http://localhost:8888&quot;&lt;/span&gt;)&lt;br/&gt;     );&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; serviceProvider.build();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的代码中，主要做了3件事情：&lt;strong&gt;限流、熔断策略及降级方法配置&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;限流&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;redis:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;database:&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;host:&lt;/span&gt; &lt;span&gt;127.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;6379&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;password:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;timeout:&lt;/span&gt; &lt;span&gt;1500&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;lettuce:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;pool:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;max-active:&lt;/span&gt; &lt;span&gt;300&lt;/span&gt; &lt;span&gt;#连接池最大连接数（使用负值表示没有限制）&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;max-idle:&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;    &lt;span&gt;#连接池中的最大空闲连接&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;min-idle:&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;     &lt;span&gt;#连接池中的最小空闲连接&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;max-wait:&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;    &lt;span&gt;#连接池最大阻塞等待时间（使用负值表示没有限制）&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@description&lt;/span&gt;: 按照访问地址进行限流(也可以安装其他条件进行限流)，具体可以看exchange.getRequest()的方法和属性&lt;br/&gt; **/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GenericAccessResolver&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;KeyResolver&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Mono&amp;lt;String&amp;gt; &lt;span&gt;resolve&lt;/span&gt;&lt;span&gt;(ServerWebExchange exchange)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Mono.just(exchange.getRequest().getPath().value());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;RedisRateLimiter &lt;span&gt;redisRateLimiter&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//1000,1500对应replenishRate、burstCapacity&lt;/span&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RedisRateLimiter(&lt;span&gt;1000&lt;/span&gt;, &lt;span&gt;1500&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; RouteLocator &lt;span&gt;customRouteLocator&lt;/span&gt;&lt;span&gt;(RouteLocatorBuilder builder)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    RouteLocatorBuilder.Builder routes = builder.routes();&lt;br/&gt;    RouteLocatorBuilder.Builder serviceProvider = routes&lt;br/&gt;        .route(&lt;span&gt;&quot;accept&quot;&lt;/span&gt;,&lt;br/&gt;               r -&amp;gt; r.method(HttpMethod.GET)&lt;br/&gt;               .and()&lt;br/&gt;               .path(&lt;span&gt;&quot;/gateway-accept/**&quot;&lt;/span&gt;)&lt;br/&gt;               .and()&lt;br/&gt;               .header(HttpHeaders.CONTENT_TYPE, &lt;span&gt;&quot;application/json;charset=UTF-8&quot;&lt;/span&gt;)&lt;br/&gt;               &lt;span&gt;//.and()&lt;/span&gt;&lt;br/&gt;               &lt;span&gt;//.readBody(String.class, readBody -&amp;gt; true)&lt;/span&gt;&lt;br/&gt;               .filters(f -&amp;gt; {&lt;br/&gt;                   f.rewritePath(&lt;span&gt;&quot;/gateway-accept/(?&amp;lt;path&amp;gt;.*)&quot;&lt;/span&gt;, &lt;span&gt;&quot;/${path}&quot;&lt;/span&gt;);&lt;br/&gt;                   f.requestRateLimiter(config -&amp;gt; config.setKeyResolver(&lt;span&gt;new&lt;/span&gt; GenericAccessResolver()).setRateLimiter(redisRateLimiter()));                                   &lt;br/&gt;                   &lt;span&gt;return&lt;/span&gt; f;&lt;br/&gt;               })&lt;br/&gt;               .uri(&lt;span&gt;&quot;http://localhost:8888&quot;&lt;/span&gt;)&lt;br/&gt;              );&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; serviceProvider.build();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;测试&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4900924702774108&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufpdqVia7dZRZayVkxWySlQmJxC5gonS2LnNd8J3cGibK2sh7PiarmcqrVntc8c2fzLj17fb39n7zplQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;757&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6684073107049608&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufpdqVia7dZRZayVkxWySlQmXkiaicYictricPXRj4cyYcibfYtsu323ymib115GbxJPExEn4UEb9NFHWSVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;766&quot;/&gt;&lt;/p&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;其他&lt;/p&gt;&lt;p&gt;如果有多个路由，使用不同的限流策略，可以自定义KeyResolver和RedisRateLimiter， 在路由定义时加入&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//基于ip限流&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;OtherAccessResolver&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;KeyResolver&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Mono&amp;lt;String&amp;gt; &lt;span&gt;resolve&lt;/span&gt;&lt;span&gt;(ServerWebExchange exchange)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Mono.just(exchange.getRequest().getRemoteAddress().getHostName());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;RedisRateLimiter &lt;span&gt;otherRedisRateLimiter&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//1000,1500对应replenishRate、burstCapacity&lt;/span&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RedisRateLimiter(&lt;span&gt;100&lt;/span&gt;, &lt;span&gt;500&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; RouteLocator &lt;span&gt;customRouteLocator&lt;/span&gt;&lt;span&gt;(RouteLocatorBuilder builder)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; RouteLocatorBuilder.Builder routes = builder.routes();&lt;br/&gt; RouteLocatorBuilder.Builder serviceProvider = routes&lt;br/&gt;  .route(&lt;span&gt;&quot;accept&quot;&lt;/span&gt;,&lt;br/&gt;   r -&amp;gt; r.method(HttpMethod.GET)&lt;br/&gt;    .and()&lt;br/&gt;    .path(&lt;span&gt;&quot;/gateway-accept/**&quot;&lt;/span&gt;)&lt;br/&gt;    .and()&lt;br/&gt;    .header(HttpHeaders.CONTENT_TYPE, &lt;span&gt;&quot;application/json;charset=UTF-8&quot;&lt;/span&gt;)&lt;br/&gt;    .filters(f -&amp;gt; {&lt;br/&gt;     f.rewritePath(&lt;span&gt;&quot;/gateway-accept/(?&amp;lt;path&amp;gt;.*)&quot;&lt;/span&gt;, &lt;span&gt;&quot;/${path}&quot;&lt;/span&gt;);&lt;br/&gt;     f.requestRateLimiter(&lt;br/&gt;      config -&amp;gt; config.setKeyResolver(&lt;span&gt;new&lt;/span&gt; GenericAccessResolver())&lt;br/&gt;       .setRateLimiter(redisRateLimiter()));&lt;br/&gt;     f.hystrix(config -&amp;gt; config.setName(&lt;span&gt;&quot;accept&quot;&lt;/span&gt;)&lt;br/&gt;      .setFallbackUri(&lt;span&gt;&quot;forward:/gateway-fallback&quot;&lt;/span&gt;)&lt;br/&gt;      .setSetter(getSetter()));&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; f;&lt;br/&gt;    })&lt;br/&gt;    .uri(&lt;span&gt;&quot;http://localhost:8888&quot;&lt;/span&gt;))&lt;br/&gt;        .route(&lt;span&gt;&quot;sign&quot;&lt;/span&gt;,&lt;br/&gt;   r -&amp;gt; r.method(HttpMethod.POST)&lt;br/&gt;    .and()&lt;br/&gt;    .path(&lt;span&gt;&quot;/gateway-sign/**&quot;&lt;/span&gt;)&lt;br/&gt;    .and()&lt;br/&gt;    .header(HttpHeaders.CONTENT_TYPE, &lt;span&gt;&quot;application/json;charset=UTF-8&quot;&lt;/span&gt;)&lt;br/&gt;    .filters(f -&amp;gt; {&lt;br/&gt;     f.rewritePath(&lt;span&gt;&quot;/gateway-sign/(?&amp;lt;path&amp;gt;.*)&quot;&lt;/span&gt;, &lt;span&gt;&quot;/${path}&quot;&lt;/span&gt;);&lt;br/&gt;     f.requestRateLimiter(&lt;br/&gt;      config -&amp;gt; config.setKeyResolver(&lt;span&gt;new&lt;/span&gt; OtherAccessResolver())&lt;br/&gt;       .setRateLimiter(otherRedisRateLimiter()));&lt;br/&gt;     f.hystrix(config -&amp;gt; config.setName(&lt;span&gt;&quot;sign&quot;&lt;/span&gt;)&lt;br/&gt;      .setFallbackUri(&lt;span&gt;&quot;forward:/gateway-fallback&quot;&lt;/span&gt;)&lt;br/&gt;      .setSetter(getSetter()));&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; f;&lt;br/&gt;    })&lt;br/&gt;    .uri(&lt;span&gt;&quot;http://localhost:7777&quot;&lt;/span&gt;)&lt;br/&gt;     );&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; serviceProvider.build();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;熔断策略&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;熔断策略主要是线程配置和熔断配置，上面已经说明很清楚了。在上篇文章中，为了解决网关调用后台服务&lt;strong&gt;Connection prematurely closed BEFORE response&lt;/strong&gt;的问题，要设置后台服务线程的空闲时间和网关线程池线程的空闲时间，并让网关线程池线程的空闲时间小于后台服务的空闲时间&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;配置方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;cloud:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;gateway:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;httpclient:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;pool:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;max-connections:&lt;/span&gt; &lt;span&gt;500&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;max-idle-time:&lt;/span&gt; &lt;span&gt;10000&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;编码实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;翻阅Spring Cloud Gateway英文资料，知道路由提供一个&lt;strong&gt;metadata&lt;/strong&gt;方法，可以设置路由的元数据(https://docs.spring.io/spring-cloud-gateway/docs/2.2.6.RELEASE/reference/html/#route-metadata-configuration)，这些元数据在&lt;strong&gt;RouteMetadataUtils&lt;/strong&gt;中定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; org.springframework.cloud.gateway.support;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RouteMetadataUtils&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String RESPONSE_TIMEOUT_ATTR = &lt;span&gt;&quot;response-timeout&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String CONNECT_TIMEOUT_ATTR = &lt;span&gt;&quot;connect-timeout&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;RouteMetadataUtils&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; AssertionError(&lt;span&gt;&quot;Must not instantiate utility class.&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中没有我要的线程数量（max-connection）和空闲时间（max-idle-time）的设置，没有关系，自己加上去：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; RouteLocator &lt;span&gt;customRouteLocator&lt;/span&gt;&lt;span&gt;(RouteLocatorBuilder builder)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        RouteLocatorBuilder.Builder routes = builder.routes();&lt;br/&gt;        RouteLocatorBuilder.Builder serviceProvider = routes&lt;br/&gt;           .route(&lt;span&gt;&quot;accept&quot;&lt;/span&gt;,&lt;br/&gt;               r -&amp;gt; r.method(HttpMethod.GET)&lt;br/&gt;                     .and()&lt;br/&gt;                     .path(&lt;span&gt;&quot;/gateway-accept/**&quot;&lt;/span&gt;)&lt;br/&gt;                     .and()&lt;br/&gt;                     .header(HttpHeaders.CONTENT_TYPE, &lt;span&gt;&quot;application/json;charset=UTF-8&quot;&lt;/span&gt;)&lt;br/&gt;                     .filters(f -&amp;gt; {&lt;br/&gt;                          f.rewritePath(&lt;span&gt;&quot;/gateway-accept/(?&amp;lt;path&amp;gt;.*)&quot;&lt;/span&gt;, &lt;span&gt;&quot;/${path}&quot;&lt;/span&gt;);&lt;br/&gt;                          f.requestRateLimiter(&lt;br/&gt;                             config -&amp;gt; config.setKeyResolver(&lt;span&gt;new&lt;/span&gt; GenericAccessResolver())&lt;br/&gt;                                           .setRateLimiter(redisRateLimiter()));&lt;br/&gt;                          f.hystrix(config -&amp;gt; config.setName(&lt;span&gt;&quot;accept&quot;&lt;/span&gt;)&lt;br/&gt;                                      .setFallbackUri(&lt;span&gt;&quot;forward:/gateway-fallback&quot;&lt;/span&gt;)&lt;br/&gt;                                      .setSetter(getSetter()));&lt;br/&gt;                                &lt;span&gt;return&lt;/span&gt; f;&lt;br/&gt;                          })&lt;br/&gt;                     .uri(&lt;span&gt;&quot;http://localhost:8888&quot;&lt;/span&gt;)&lt;br/&gt;                     .metadata(&lt;span&gt;&quot;max-idle-time&quot;&lt;/span&gt;, &lt;span&gt;10000&lt;/span&gt;)  &lt;span&gt;//网关调用后台线程空闲时间设置&lt;/span&gt;&lt;br/&gt;                     .metadata(&lt;span&gt;&quot;max-connections&quot;&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;)  &lt;span&gt;//网关调用后台服务线程数量设置&lt;/span&gt;&lt;br/&gt;          );&lt;br/&gt;&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; serviceProvider.build();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试果然和yml配置一样有效果。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;降级方法&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;降级方法本身没有什么特别，有一个问题需要注意，调用降级方法也是使用线程池的，缺省在&lt;strong&gt;HystrixThreadPoolProperties&lt;/strong&gt;中定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HystrixThreadPoolProperties&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* defaults */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; default_coreSize = &lt;span&gt;10&lt;/span&gt;;            &lt;span&gt;// core size of thread pool&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; default_maximumSize = &lt;span&gt;10&lt;/span&gt;;         &lt;span&gt;// maximum size of thread pool&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; default_keepAliveTimeMinutes = &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;// minutes to keep a thread alive&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; default_maxQueueSize = -&lt;span&gt;1&lt;/span&gt;;        &lt;span&gt;// size of queue (this can&#x27;t be dynamically changed so we use &#x27;queueSizeRejectionThreshold&#x27; to artificially limit and reject)&lt;/span&gt;&lt;br/&gt;                                                 &lt;span&gt;// -1 turns it off and makes us use SynchronousQueue&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;错误&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果上面的限流设置比较大，比如1000，最大突发2000，网关调用后台服务发生熔断降级， 熔断后降级的方法调用太频繁，10个线程不够用，会导致以下500错误：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;2021-02-01 14:29:45.076 ERROR 64868 --- [ioEventLoop-5-1] a.w.r.e.AbstractErrorWebExceptionHandler : [a0ed6911-18982]  500 Server Error &lt;span&gt;for&lt;/span&gt; HTTP GET &lt;span&gt;&quot;/gateway-accept/test&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;com.netflix.hystrix.exception.HystrixRuntimeException: &lt;span&gt;command&lt;/span&gt;-accept fallback execution rejected.&lt;br/&gt; at com.netflix.hystrix.AbstractCommand.handleFallbackRejectionByEmittingError(AbstractCommand.java:1043) ~[hystrix-core-1.5.18.jar:1.5.18]&lt;br/&gt; Suppressed: reactor.core.publisher.FluxOnAssembly&lt;span&gt;$OnAssemblyException&lt;/span&gt;: &lt;br/&gt;Error has been observed at the following site(s):&lt;br/&gt; |_ checkpoint ⇢ org.springframework.cloud.gateway.filter.WeightCalculatorWebFilter [DefaultWebFilterChain]&lt;br/&gt; |_ checkpoint ⇢ HTTP GET &lt;span&gt;&quot;/gateway-accept/test&quot;&lt;/span&gt; [ExceptionHandlingWebHandler]&lt;br/&gt;com.netflix.hystrix.exception.HystrixRuntimeException: &lt;span&gt;command&lt;/span&gt;-accept fallback execution rejected.&lt;br/&gt; at com.netflix.hystrix.AbstractCommand.handleFallbackRejectionByEmittingError(AbstractCommand.java:1043) ~[hystrix-core-1.5.18.jar:1.5.18]&lt;br/&gt; Suppressed: reactor.core.publisher.FluxOnAssembly&lt;span&gt;$OnAssemblyException&lt;/span&gt;: &lt;br/&gt;Error has been observed at the following site(s):&lt;br/&gt; |_ checkpoint ⇢ org.springframework.cloud.gateway.filter.WeightCalculatorWebFilter [DefaultWebFilterChain]&lt;br/&gt; |_ checkpoint ⇢ HTTP GET &lt;span&gt;&quot;/gateway-accept/test&quot;&lt;/span&gt; [ExceptionHandlingWebHandler]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;配置方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以要在yml中设置合适的调用降级方法的线程池, 合理的配置能够杜绝网关500错误的发生。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;hystrix:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;threadpool:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;group-accept:&lt;/span&gt;  &lt;span&gt;#代码里面设置的HystrixCommandGroupKey.Factory.asKey(&quot;group-accept&quot;)&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;coreSize:&lt;/span&gt; &lt;span&gt;50&lt;/span&gt; &lt;span&gt;#并发执行的最大线程数，默认10&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;maxQueueSize:&lt;/span&gt; &lt;span&gt;1500&lt;/span&gt; &lt;span&gt;#BlockingQueue的最大队列数&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;#即使maxQueueSize没有达到，达到queueSizeRejectionThreshold该值后，请求也会被拒绝&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;queueSizeRejectionThreshold:&lt;/span&gt; &lt;span&gt;1400&lt;/span&gt; &lt;br/&gt;                                        &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;网关异常截获&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的异常后，没有捕获异常直接返回前端500错误，一般情况下需要返回一个统一接口，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@ToString&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@EqualsAndHashCode&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Accessors&lt;/span&gt;(chain = &lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Result&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Serializable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer code;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String message;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; T data;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String sign;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String SUCCESS = &lt;span&gt;&quot;成功&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String FAILURE = &lt;span&gt;&quot;失败&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Result&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; code, String message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.code = code;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.message = message;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Result&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; code, String message, T data)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.code = code;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.message = message;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.data = data;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Result&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; code, String message, T data, String sign)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.code = code;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.message = message;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.data = data;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.sign = sign;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Result&amp;lt;Object&amp;gt; &lt;span&gt;success&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Result&amp;lt;Object&amp;gt;(&lt;span&gt;200&lt;/span&gt;, SUCCESS);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Result&amp;lt;Object&amp;gt; &lt;span&gt;success&lt;/span&gt;&lt;span&gt;(Object data)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Result&amp;lt;Object&amp;gt;(&lt;span&gt;200&lt;/span&gt;, SUCCESS, data);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Result&amp;lt;Object&amp;gt; &lt;span&gt;success&lt;/span&gt;&lt;span&gt;(Object data, String sign)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Result&amp;lt;Object&amp;gt;(&lt;span&gt;200&lt;/span&gt;, SUCCESS, data, sign);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Result&amp;lt;Object&amp;gt; &lt;span&gt;failure&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Result&amp;lt;Object&amp;gt;(&lt;span&gt;400&lt;/span&gt;, FAILURE);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Result&amp;lt;Object&amp;gt; &lt;span&gt;failure&lt;/span&gt;&lt;span&gt;(Object data)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Result&amp;lt;Object&amp;gt;(&lt;span&gt;400&lt;/span&gt;, FAILURE, data);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Result&amp;lt;Object&amp;gt; &lt;span&gt;failure&lt;/span&gt;&lt;span&gt;(Object data, String sign)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Result&amp;lt;Object&amp;gt;(&lt;span&gt;400&lt;/span&gt;, FAILURE, data, sign);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建&lt;strong&gt;GlobalExceptionConfiguration&lt;/strong&gt; 实现&lt;strong&gt;ErrorWebExceptionHandler&lt;/strong&gt;（这一段是来者网友提供的）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@Order&lt;/span&gt;(-&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@RequiredArgsConstructor&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GlobalExceptionConfiguration&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ErrorWebExceptionHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ObjectMapper objectMapper;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Mono&amp;lt;Void&amp;gt; &lt;span&gt;handle&lt;/span&gt;&lt;span&gt;(ServerWebExchange exchange, Throwable ex)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ServerHttpResponse response = exchange.getResponse();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (response.isCommitted()) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; Mono.error(ex);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        response.getHeaders().setContentType(MediaType.APPLICATION_JSON_UTF8);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (ex &lt;span&gt;instanceof&lt;/span&gt; ResponseStatusException) {&lt;br/&gt;            response.setStatusCode(((ResponseStatusException) ex).getStatus());&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; response&lt;br/&gt;                .writeWith(Mono.fromSupplier(() -&amp;gt; {&lt;br/&gt;                    DataBufferFactory bufferFactory = response.bufferFactory();&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;return&lt;/span&gt; bufferFactory.wrap(objectMapper.writeValueAsBytes(Result.failure(ex.getMessage())));&lt;br/&gt;                    } &lt;span&gt;catch&lt;/span&gt; (JsonProcessingException e) {&lt;br/&gt;                        log.warn(&lt;span&gt;&quot;Error writing response&quot;&lt;/span&gt;, ex);&lt;br/&gt;                        &lt;span&gt;return&lt;/span&gt; bufferFactory.wrap(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;]);&lt;br/&gt;                    }&lt;br/&gt;                }));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，就会把网关异常统一包装在接口中返回：如：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2794348508634223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufpdqVia7dZRZayVkxWySlQmkEibAg17CENpcvq31vviadlDK1pzW00Rby0g0qKrmHZAic9T0ARicW4IuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;637&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后台日志已经没有之前的错误日志了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;编码实现，没找到&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于&lt;strong&gt;Spring Cloud Gateway&lt;/strong&gt; 中的 &lt;strong&gt;Hystrix&lt;/strong&gt;采用的是&lt;strong&gt;HystrixObservableCommand.Setter&lt;/strong&gt;, 没有采用 &lt;strong&gt;HystrixCommand.Setter&lt;/strong&gt;， 在 &lt;strong&gt;HystrixCommand.Setter&lt;/strong&gt;中是可以编码实现线程池配置的, 但是在&lt;strong&gt;HystrixObservableCommand.Setter&lt;/strong&gt;没有提供：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Setter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; HystrixCommandGroupKey groupKey;&lt;br/&gt;        &lt;span&gt;protected&lt;/span&gt; HystrixCommandKey commandKey;&lt;br/&gt;        &lt;span&gt;protected&lt;/span&gt; HystrixThreadPoolKey threadPoolKey;  &lt;span&gt;//有属性但是没有set方法&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;protected&lt;/span&gt; HystrixCommandProperties.Setter commandPropertiesDefaults;&lt;br/&gt;        &lt;span&gt;protected&lt;/span&gt; HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults; &lt;span&gt;//有属性没有set方法&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;Setter&lt;/span&gt;&lt;span&gt;(HystrixCommandGroupKey groupKey)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.groupKey = groupKey;&lt;br/&gt;            &lt;span&gt;// default to using SEMAPHORE for ObservableCommand&lt;/span&gt;&lt;br/&gt;            commandPropertiesDefaults = setDefaults(HystrixCommandProperties.Setter());&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Setter &lt;span&gt;withGroupKey&lt;/span&gt;&lt;span&gt;(HystrixCommandGroupKey groupKey)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Setter(groupKey);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Setter &lt;span&gt;andCommandKey&lt;/span&gt;&lt;span&gt;(HystrixCommandKey commandKey)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.commandKey = commandKey;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Setter &lt;span&gt;andCommandPropertiesDefaults&lt;/span&gt;&lt;span&gt;(HystrixCommandProperties.Setter commandPropertiesDefaults)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.commandPropertiesDefaults = setDefaults(commandPropertiesDefaults);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; HystrixCommandProperties.&lt;span&gt;Setter &lt;span&gt;setDefaults&lt;/span&gt;&lt;span&gt;(HystrixCommandProperties.Setter commandPropertiesDefaults)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (commandPropertiesDefaults.getExecutionIsolationStrategy() == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;// default to using SEMAPHORE for ObservableCommand if the user didn&#x27;t set it&lt;/span&gt;&lt;br/&gt;                commandPropertiesDefaults.withExecutionIsolationStrategy(ExecutionIsolationStrategy.SEMAPHORE);&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; commandPropertiesDefaults;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于本人水平有限，没有找到&lt;strong&gt;Setter&lt;/strong&gt;中设置&lt;strong&gt;HystrixThreadPoolKey&lt;/strong&gt;和&lt;strong&gt;HystrixThreadPoolProperties.Setter&lt;/strong&gt;的方法，所以只能在yml中配置。有知道的同学告诉我一声，不胜感激。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在&lt;strong&gt;Spring Cloud Gateway&lt;/strong&gt;网关的配置中，需要综合考虑限流大小、网关调用后台连接池设置大小、后台服务的连接池以及空闲时间，包括网关调用降级方法的线程池配置，都需要在压测中调整到一个合理的配置，才能发挥最大的功效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本人水平有限，跟深入的研究还在继续，如果文章有表达错误或者不周，请大家指正，谢谢！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b9d9a0dbad49a21f9cf9af9e4609d48a</guid>
<title>日常开发之重构</title>
<link>https://toutiao.io/k/zxi5ajb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为开发人员，应该让重构贯穿于你的开发日常的每一刻。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么这么说？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;重构是为了改善软件的设计、结构和实现，同时保留其现有的功能。重构的潜在优势包括提高代码的可读性和降低复杂度。这些都可以提高源代码的可维护性，并创建一个更简单、更干净或更有表现力的内部架构或对象模型，从而提高程序的可扩展性。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因我觉得有两方便，一个是客观的因素，随着技术的不断更新迭代，语言的特性也在更新（朝着更高效便捷的方向）。另一个则是人为因素，不同的人由于开发水平的不同写出来的代码也各尽不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在一个团队中你除了要写自己的代码，而且还要接手别人的代码，作为一个leader更要去给别人做code review。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，重构是如此的必要，而且悄无声息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，最近在看到一段代码后，立刻让我产生重构的冲动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;旧代码如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先定义两个常量，对象和数组&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const data = {&lt;br/&gt;  Angular: 3,&lt;br/&gt;  React: 1,&lt;br/&gt;  Vue: 2,&lt;br/&gt;  Next: 1,&lt;br/&gt;  HTML: 2,&lt;br/&gt;  Other: 3&lt;br/&gt;};&lt;br/&gt;const colors = [&lt;br/&gt;  &lt;span&gt;&#x27;#d17a29&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&#x27;#da9554&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&#x27;#e3af7f&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&#x27;#edcaa9&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&#x27;#f6e4d4&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&#x27;#204e77&#x27;&lt;/span&gt;&lt;br/&gt;];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用for操作，取出以上对象的key和value和数组元素组成新的数组&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; sortable = [];&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; index = 0;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; temp &lt;span&gt;in&lt;/span&gt; data) {&lt;br/&gt;  sortable.push([temp, data[temp], colors[index] ? colors[index] : &lt;span&gt;&#x27;#D3D3D3&#x27;&lt;/span&gt;]);&lt;br/&gt;  index++;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;sortable.sort(&lt;span&gt;function&lt;/span&gt;(a, b) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; b[1] - a[1];&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[&lt;br/&gt;  [&lt;span&gt;&#x27;Angular&#x27;&lt;/span&gt;, 3, &lt;span&gt;&#x27;#d17a29&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;Other&#x27;&lt;/span&gt;, 3, &lt;span&gt;&#x27;#204e77&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;Vue&#x27;&lt;/span&gt;, 2, &lt;span&gt;&#x27;#e3af7f&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;HTML&#x27;&lt;/span&gt;, 2, &lt;span&gt;&#x27;#f6e4d4&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;React&#x27;&lt;/span&gt;, 1, &lt;span&gt;&#x27;#da9554&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;Next&#x27;&lt;/span&gt;, 1, &lt;span&gt;&#x27;#edcaa9&#x27;&lt;/span&gt;]&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从逻辑实现上没有任何问题。但总感觉哪里不对，是不是有更高效的实现方式呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;重构后的代码&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也许是写代码的惯性使然，立马想到使用&lt;code&gt;Map&lt;/code&gt;方法可以将数据返回你想要的格式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是对象数据格式好像不支持Map方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们得先将对象转化成数组&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const newOutput = Object.entries(data);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们将得到以下格式的数组&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[&lt;br/&gt;  [&lt;span&gt;&#x27;Angular&#x27;&lt;/span&gt;, 3],&lt;br/&gt;  [&lt;span&gt;&#x27;React&#x27;&lt;/span&gt;, 1],&lt;br/&gt;  [&lt;span&gt;&#x27;Vue&#x27;&lt;/span&gt;, 2],&lt;br/&gt;  [&lt;span&gt;&#x27;Next&#x27;&lt;/span&gt;, 1],&lt;br/&gt;  [&lt;span&gt;&#x27;HTML&#x27;&lt;/span&gt;, 2],&lt;br/&gt;  [&lt;span&gt;&#x27;Other&#x27;&lt;/span&gt;, 3]&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是不是和最终想要的结果有点类似了，数组的元素中还差了一个&lt;code&gt;color&lt;/code&gt;的值，以及最终需要将它们排序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着我们根据索引将&lt;code&gt;color&lt;/code&gt;的值添加到以上输出结果中&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const newOutput = Object.entries(data)&lt;br/&gt;.map(&lt;br/&gt;  ([title, amount], index) =&amp;gt; [&lt;br/&gt;    title,&lt;br/&gt;    amount,&lt;br/&gt;    colors[index] || &lt;span&gt;&quot;#fff&quot;&lt;/span&gt;]&lt;br/&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里或者使用数组解构更容易理解一点&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const newOutput = Object.entries(data)&lt;br/&gt;  .map((item, index) =&amp;gt; [&lt;br/&gt;    ...item,&lt;br/&gt;    colors[index] || &lt;span&gt;&#x27;#fff&#x27;&lt;/span&gt;]&lt;br/&gt;  )&lt;br/&gt;  .sort((a, b) =&amp;gt; b[1] - a[1]);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在取不到值的时候我们给添加了一个默认的颜色值&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[&lt;br/&gt;  [&lt;span&gt;&#x27;Angular&#x27;&lt;/span&gt;, 3, &lt;span&gt;&#x27;#d17a29&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;React&#x27;&lt;/span&gt;, 1, &lt;span&gt;&#x27;#da9554&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;Vue&#x27;&lt;/span&gt;, 2, &lt;span&gt;&#x27;#e3af7f&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;Next&#x27;&lt;/span&gt;, 1, &lt;span&gt;&#x27;#edcaa9&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;HTML&#x27;&lt;/span&gt;, 2, &lt;span&gt;&#x27;#f6e4d4&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;Other&#x27;&lt;/span&gt;, 3, &lt;span&gt;&#x27;#204e77&#x27;&lt;/span&gt;]&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后只剩下一步，我们需要按第二项给数组排序，很容易就想到用&lt;code&gt;sort&lt;/code&gt;方法&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const newOutput = Object.entries(data)&lt;br/&gt;  .map(&lt;br/&gt;    ([title, amount], index) =&amp;gt; [&lt;br/&gt;      title,&lt;br/&gt;      amount,&lt;br/&gt;      colors[index] || &lt;span&gt;&quot;#fff&quot;&lt;/span&gt;]&lt;br/&gt;  )&lt;br/&gt;  .sort((a, b) =&amp;gt; b[1] - a[1])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上代码输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[&lt;br/&gt;  [&lt;span&gt;&#x27;Angular&#x27;&lt;/span&gt;, 3, &lt;span&gt;&#x27;#d17a29&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;Other&#x27;&lt;/span&gt;, 3, &lt;span&gt;&#x27;#204e77&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;Vue&#x27;&lt;/span&gt;, 2, &lt;span&gt;&#x27;#e3af7f&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;HTML&#x27;&lt;/span&gt;, 2, &lt;span&gt;&#x27;#f6e4d4&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;React&#x27;&lt;/span&gt;, 1, &lt;span&gt;&#x27;#da9554&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;&#x27;Next&#x27;&lt;/span&gt;, 1, &lt;span&gt;&#x27;#edcaa9&#x27;&lt;/span&gt;]&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没有问题，两种不同的代码都得到了最终的结果。但是重构后的代码量明显比之前的少了很多，而且结构更严谨。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写代码的过程中要学会举一反三，及时拥抱语言的新特性能给我们带来更好的编程体验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另：以上代码在 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4NTU1OTMwMQ==&amp;amp;mid=2650300918&amp;amp;idx=2&amp;amp;sn=1a56aab9baaea8de8780f14c76ea53bb&amp;amp;chksm=87dad09cb0ad598a8462e00caed136e8712cefc92de648617f5e97905734210ca4a48dc291a7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;【利好工具】JavaScript及时运行调试工具&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;【利好工具】JavaScript及时运行调试工具&lt;/a&gt;中运行更佳&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ed535a58b5ffa34bcf4b83d69889558c</guid>
<title>开源了！从 0 到 1 实现 “合成大西瓜”</title>
<link>https://toutiao.io/k/jpidpq7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;blockquote&gt;&lt;p&gt;转自：shymean&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.shymean.com/article/%25E4%25BD%25BF%25E7%2594%25A8cocos%25E5%25AE%259E%25E7%258E%25B0%25E4%25B8%2580%25E4%25B8%25AA%25E5%2590%2588%25E6%2588%2590%25E5%25A4%25A7%25E8%25A5%25BF%25E7%2593%259C&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;www.shymean.com/article/使用cocos实现一个合成大西瓜&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近微博上曝出了很多瓜，&quot;合成大西瓜&quot;这个游戏也很火热，玩了一阵还挺有意思的。研究了一下原理，发现目前流传的版本都是魔改编译后的版本，代码经过压缩不具备可读性，因此决定自己照着实现一个。&lt;/p&gt;
&lt;p&gt;本项目主要用作 cocos creator 练手使用，所有美术素材和音频材料均来源于 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.wesane.com/game/654/%25E6%2584%259F%25E8%25B0%25A2%25E5%258E%259F%25E4%25BD%259C%25E8%2580%2585%25EF%25BC%258C%25E5%2590%2591%25E6%25AF%258F%25E4%25B8%2580%25E4%25BD%258D%25E6%25B8%25B8%25E6%2588%258F%25E5%25BC%2580%25E5%258F%2591%25E8%2580%2585%25E8%2587%25B4%25E6%2595%25AC%25EF%25BC%2581&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;www.wesane.com/game/654/感谢原作者，向每一位游戏开发者致敬！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文所有代码及素材都放在 Github上：
&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tangxiangmin/cocos-big-watermelon&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/tangxiangmin&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;/cocos-big-watermelon&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;也可以通过在线预览地址体验：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//web-game-9gh6nrus14fec37e-1252170212.tcloudbaseapp.com/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;web-game-9gh6nrus14fec37e-1252170212.tcloudbaseapp.com&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;微信无法点击外链，请给我们公号发送&lt;code&gt;大西瓜&lt;/code&gt;获取入口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;游戏逻辑&lt;/h2&gt;
&lt;p&gt;整个游戏逻辑比较简单，结合了俄罗斯方块与消除游戏的核心玩法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在生成一个水果&lt;/li&gt;
&lt;li&gt;点击屏幕，水果移动到对应x轴位置并自由下落&lt;/li&gt;
&lt;li&gt;每个水果会与其他水果发生碰撞,两个相同的水果碰撞时会发生合并，升级成更高一级的水果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;水果共有 11 种类型，&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-af092ce0e39a0cd1daac917899f92f40_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;167&quot; data-rawheight=&quot;272&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;167&quot; data-rawheight=&quot;272&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-af092ce0e39a0cd1daac917899f92f40_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;游戏目标是合成最高级的水果：大西瓜！当堆积的水果超过顶部红线时则游戏结束整理出需要实现的核心逻辑&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生成水果&lt;/li&gt;
&lt;li&gt;水果下落与碰撞&lt;/li&gt;
&lt;li&gt;水果消除动画效果及升级逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;预备工作&lt;/h2&gt;
&lt;h3&gt;cocos creator基本概念&lt;/h3&gt;
&lt;p&gt;整个项目使用cocos creator v2.4.3实现，建议初次了解的同学可以先过一下官方文档，本文不会过多介绍creator的使用（主要是我也不太熟练hah）官方文档链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//docs.cocos.com/creator/2.3/manual/zh/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;docs.cocos.com/creator/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;2.3/manual/zh/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;游戏素材&lt;/h3&gt;
&lt;p&gt;首先需要准备美术资源，本位所有美术素材和音频材料均来源于 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.wesane.com/game/654/%25E3%2580%2582%25E9%25A6%2596%25E5%2585%2588%25E8%25AE%25BF%25E9%2597%25AE%25E6%25B8%25B8%25E6%2588%258F%25E7%25BD%2591%25E7%25AB%2599%25EF%25BC%258C%25E6%2589%2593%25E5%25BC%2580network%25E9%259D%25A2%25E6%259D%25BF%25EF%25BC%258C%25E5%258F%25AF%25E4%25BB%25A5%25E7%259C%258B%25E8%25A7%2581%25E6%25B8%25B8%25E6%2588%258F%25E4%25BE%259D%25E8%25B5%2596%25E7%259A%2584%25E6%2589%2580%25E6%259C%2589%25E7%25BE%258E%25E6%259C%25AF%25E8%25B5%2584%25E6%25BA%2590%25EF%25BC%258C%25E6%2588%2591%25E4%25BB%25AC%25E4%25B8%258B%25E8%25BD%25BD%25E8%2587%25AA%25E5%25B7%25B1%25E6%2589%2580%25E9%259C%2580%25E7%259A%2584%25E6%2596%2587%25E4%25BB%25B6%25E5%258D%25B3%25E5%258F%25AF%25E3%2580%2582&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;www.wesane.com/game/654/。首先访问游戏网站，打开network面板，可以看见游戏依赖的所有美术资源，我们下载自己所需的文件即可。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-54261bc3c8eabd9df31fb4abfa5caae1_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;369&quot; data-rawheight=&quot;422&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;369&quot; data-rawheight=&quot;422&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-54261bc3c8eabd9df31fb4abfa5caae1_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;所需的图片资源包括&lt;/p&gt;

&lt;p&gt;音频文件同理，可以在Filter栏选择&lt;code&gt;.mp3&lt;/code&gt;后缀的请求快速筛选对应资源。&lt;/p&gt;

&lt;h2&gt;创建游戏场景和背景&lt;/h2&gt;
&lt;p&gt;打开cocos creator，新建一个项目（也可以直接导入从github下载的项目源码）。然后记得将刚才下载的素材资源拖拽到右下角的资源管理器中。&lt;/p&gt;
&lt;h3&gt;创建scene和背景节点&lt;/h3&gt;
&lt;p&gt;项目初始化之后，在左下角资源管理器新建一个游戏&lt;code&gt;Scene&lt;/code&gt;，取名game作为游戏主场景。&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d22b03c75695f2f4ff26cef647ef35af_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;682&quot; data-rawheight=&quot;432&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-d22b03c75695f2f4ff26cef647ef35af_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;682&quot; data-rawheight=&quot;432&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-d22b03c75695f2f4ff26cef647ef35af_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-d22b03c75695f2f4ff26cef647ef35af_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;创建完毕后就可以在资源管理器的assets中看见刚才创建的名为game的scene。选择game场景，在左上角的层级管理器中可以看见场景的Canvas画布根节点，cocos默认画布是横屏的&lt;code&gt;960*640&lt;/code&gt;，可以选择根节点然后再右侧属性检查器中调整宽高为&lt;code&gt;640*960&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b8b4f6b0481dc54b0fd351fb0f062bc3_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;790&quot; data-rawheight=&quot;446&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-b8b4f6b0481dc54b0fd351fb0f062bc3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;790&quot; data-rawheight=&quot;446&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-b8b4f6b0481dc54b0fd351fb0f062bc3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b8b4f6b0481dc54b0fd351fb0f062bc3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;接下来创建背景层，我们在Canvas节点下面新建一个background节点，由于整个背景是纯色&lt;code&gt;#FBE79D&lt;/code&gt;的，因此使用一个单色Sprite填充即可&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-eb27589df928de712d64d969973c9409_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;493&quot; data-rawheight=&quot;629&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-eb27589df928de712d64d969973c9409_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;493&quot; data-rawheight=&quot;629&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-eb27589df928de712d64d969973c9409_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-eb27589df928de712d64d969973c9409_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;同样将background节点宽高调整为整个画布的大小，由于默认锚点均为&lt;code&gt;0.5*0.5&lt;/code&gt;，此时整个画布会被完全填充。现在整个游戏场景大概是这个样子的&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-206d49eb39bab4ead3ca73afec4b4546_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;657&quot; data-rawheight=&quot;654&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-206d49eb39bab4ead3ca73afec4b4546_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;657&quot; data-rawheight=&quot;654&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-206d49eb39bab4ead3ca73afec4b4546_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-206d49eb39bab4ead3ca73afec4b4546_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;接下来设计游戏的逻辑脚本部分&lt;/p&gt;
&lt;h3&gt;场景脚本组件&lt;/h3&gt;
&lt;p&gt;在assets目录下新建一个js脚本，按照惯例命令成&lt;code&gt;Game.js&lt;/code&gt;，creator会生成一个带基础&lt;code&gt;cc.Class&lt;/code&gt;的模板文件&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-574fd07cc35023c61fd1255267d72046_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;657&quot; data-rawheight=&quot;298&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-574fd07cc35023c61fd1255267d72046_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;657&quot; data-rawheight=&quot;298&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-574fd07cc35023c61fd1255267d72046_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-574fd07cc35023c61fd1255267d72046_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;先将脚本组件与节点关联起来，选择Canvas根节点，在右侧属性检查器中添加组件，然后选择刚才创建的这个&lt;code&gt;Game&lt;/code&gt;组件&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-17c711ddd9e6508bfa6cb19a98bd8ff4_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;513&quot; data-rawheight=&quot;205&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-17c711ddd9e6508bfa6cb19a98bd8ff4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;513&quot; data-rawheight=&quot;205&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-17c711ddd9e6508bfa6cb19a98bd8ff4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-17c711ddd9e6508bfa6cb19a98bd8ff4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后编写具体的代码逻辑，打开Game.js文件（建议使用vscode或者webstrom打开整个项目的根目录进行编辑）里面的初始代码大概长这样&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Game.js  
cc.Class({  
    extends: cc.Component,  

    properties: {  

    },  
    onLoad(){  

    },  
    start(){ }  
})  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们需要在这里维护整个游戏的逻辑，后面逐步添加代码内容。&lt;/p&gt;
&lt;h2&gt;创建水果&lt;/h2&gt;
&lt;p&gt;水果是整个游戏的核心元素，在游戏中被频繁创建和销毁。&lt;/p&gt;
&lt;h3&gt;生成单个水果预制资源&lt;/h3&gt;
&lt;p&gt;这种动态创建的节点可以通过预制资源&lt;code&gt;Prefab&lt;/code&gt;来控制，制作prefab最简单的方式就是将资源从资源管理器拖动到场景编辑器中，然后再将层级管理器中的节点拖回资源管理器。这里以等级最低的水果“葡萄”为例&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-68f4fa1c432c2b8f49aeb1dd25706337_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;657&quot; data-rawheight=&quot;728&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-68f4fa1c432c2b8f49aeb1dd25706337_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;657&quot; data-rawheight=&quot;728&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-68f4fa1c432c2b8f49aeb1dd25706337_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-68f4fa1c432c2b8f49aeb1dd25706337_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-13c46bbeb602b67cb7d37f4fefe6b7eb_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;421&quot; data-rawheight=&quot;729&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-13c46bbeb602b67cb7d37f4fefe6b7eb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;421&quot; data-rawheight=&quot;729&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-13c46bbeb602b67cb7d37f4fefe6b7eb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-13c46bbeb602b67cb7d37f4fefe6b7eb_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后将层级管理器中的节点删除，这样我们就得到了一个fruit的预制资源，在脚本组件中，就可以使用代码通过预制资源动态生成节点了。修改&lt;code&gt;Game.js&lt;/code&gt;，添加一个属性&lt;code&gt;fruitPrefab&lt;/code&gt;，其类型为&lt;code&gt;cc.Prefab&lt;/code&gt;，&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Game.js  
properties: {  
    fruitPrefab: {  
        default: null,  
        type: cc.Prefab  
    },  
}  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;回到creator，。选择Canvas节点，可以在属性检查器中的&lt;code&gt;Game&lt;/code&gt;组件栏目看见和修改该属性了。我们将刚才制作的prefab资源从资源管理器拖动到这里，在初始化的时候，有cocos负责初始化对应的属性数据&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-76d9eedb8531dde55af3f73581d83ed5_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;986&quot; data-rawheight=&quot;138&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-76d9eedb8531dde55af3f73581d83ed5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;986&quot; data-rawheight=&quot;138&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-76d9eedb8531dde55af3f73581d83ed5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-76d9eedb8531dde55af3f73581d83ed5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;创建单个水果&lt;/h3&gt;
&lt;p&gt;回到Game.js，开始编写真正的逻辑：创建一个葡萄&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Game.js  
onLoad(){  
    let fruit = cc.instantiate(this.fruitPrefab);  
    fruit.setPosition(cc.v2(0, 400));  

    this.node.addChild(fruit);  
}    &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;预览模式下就可以看见屏幕正上方有一个葡萄了&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-63f4b86f15467d0157dc7cc8e0969e1f_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;875&quot; data-rawheight=&quot;245&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-63f4b86f15467d0157dc7cc8e0969e1f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;875&quot; data-rawheight=&quot;245&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-63f4b86f15467d0157dc7cc8e0969e1f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-63f4b86f15467d0157dc7cc8e0969e1f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;nice，非常好的开始！&lt;/p&gt;
&lt;p&gt;此外，由于水果还包含一些特定的逻辑，我们可以向它添加一个&lt;code&gt;Fruit&lt;/code&gt;脚本组件，虽然目前看起来还没有什么用创建Fruit脚本组件与上面创建Game组件类似，然后选择刚才制作的prefab重新编辑，关联上Fruit用户脚本组件即可。&lt;/p&gt;
&lt;h3&gt;动态维护多种水果&lt;/h3&gt;
&lt;p&gt;整个游戏共11种水果（当然也可以添加或者改成其他的东西），如果每种水果都像上面去手动生成预制资源然后分别初始化，那也太繁琐了，我们需要解决动态渲染多种水果的方式。我们需要获得每种水果的贴图信息，然后在实例化水果时选择对应贴图即可，最简单的方式就是维护一个配置表，每行的数据字段包括&lt;code&gt;id&lt;/code&gt;和&lt;code&gt;iconSF&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;const FruitItem = cc.Class({  
    name: &#x27;FruitItem&#x27;,  
    properties: {  
        id: 0, // 水果的类型  
        iconSF: cc.SpriteFrame // 贴图资源  
    }  
});  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后为&lt;code&gt;Game&lt;/code&gt;脚本组件新增一个&lt;code&gt;fruits&lt;/code&gt;属性，用于保存每种水果的配置信息，其类型是数组，数组内元素类型为刚才创建的&lt;code&gt;FruitItem&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Game.js  
properties: {  
    fruits: {  
        default: [],  
        type: FruitItem  
    },  
}  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;回到编辑器，这时候可以发现Game组件的属性下面多了一个&lt;code&gt;Fruits&lt;/code&gt;属性，将其长度修改为11，然后依次编写每个水果的id，同时将其贴图资源从资源编辑器贴过来（体力活）&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b84b59c50108a3b137ac43841b9f158d_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;593&quot; data-rawheight=&quot;641&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-b84b59c50108a3b137ac43841b9f158d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;593&quot; data-rawheight=&quot;641&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-b84b59c50108a3b137ac43841b9f158d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b84b59c50108a3b137ac43841b9f158d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样我们只需要传入想要制作的水果id，就可以获取到对应的配置信息，并动态修改贴图了这种初始化的逻辑应该由水果自己维护，因此放在刚才创建的&lt;code&gt;Fruit&lt;/code&gt;组件中，我们暴露一个init接口出来&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Fruit.js  
properties: {  
    id: 0,  
},  
// 实例放在可以在其他组件中调用  
init(data) {  
    this.id = data.id  
    // 根据传入的参数修改贴图资源  
    const sp = this.node.getComponent(cc.Sprite)  
    sp.spriteFrame = data.iconSF  
},  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后修改一下上面的初始化水果的代码&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Game.js  
createOneFruit(num) {  
    let fruit = cc.instantiate(this.fruitPrefab);  
    // 获取到配置信息  
    const config = this.fruits[num - 1]  

    // 获取到节点的Fruit组件并调用实例方法  
    fruit.getComponent(&#x27;Fruit&#x27;).init({  
        id: config.id,  
        iconSF: config.iconSF  
    });  
}  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样就可以愉快的创建各种水果了&lt;/p&gt;
&lt;h3&gt;监听点击事件&lt;/h3&gt;
&lt;p&gt;cocos提供了各种事件监听，前端和客户端同学一定不会陌生。整个游戏会在点击屏幕时创建一个水果，这只要监听一下全局点击事件即可，这个逻辑同样放在&lt;code&gt;Game&lt;/code&gt;脚本组件中&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;onLoad() {  
    // 监听点击事件  
    this.node.on(cc.Node.EventType.TOUCH_START, this.onTouchStart, this)  
},  
onTouchStart(){  
    this.createOneFruit(1) // 生成水果  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;实际游戏中还需要处理随机生成水果、上一个水果在点击的x轴下落等细节逻辑，这里不再赘述。&lt;/p&gt;
&lt;h2&gt;物理系统：自由落体与刚体碰撞&lt;/h2&gt;
&lt;p&gt;上面处理了水果创建的逻辑，在整个游戏中，水果是可以产生下落及弹性碰撞等物理效果的，利用cocos内置的物理引擎，可以很方便的实现对cocos引擎不熟悉的同学可以先看看这个官方demo，里面展示的比较详细（起码比文档要更容易理解）&lt;/p&gt;
&lt;h3&gt;开启物理引擎与碰撞检测&lt;/h3&gt;
&lt;p&gt;首先是开启物理引擎，以及设置重力大小&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;const instance = cc.director.getPhysicsManager()  
instance.enabled = true  
// instance.debugDrawFlags = 4  
instance.gravity = cc.v2(0, -960);  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后需要开启碰撞检测，默认是关闭的&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;const collisionManager = cc.director.getCollisionManager();  
collisionManager.enabled = true  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后设置四周的墙壁用于碰撞，这样水果就不会无限制往下面掉落了&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 设置四周的碰撞区域  
let width = this.node.width;  
let height = this.node.height;  

let node = new cc.Node();  

let body = node.addComponent(cc.RigidBody);  
body.type = cc.RigidBodyType.Static;  

const _addBound = (node, x, y, width, height) =&amp;gt; {  
    let collider = node.addComponent(cc.PhysicsBoxCollider);  
    collider.offset.x = x;  
    collider.offset.y = y;  
    collider.size.width = width;  
    collider.size.height = height;  
}  

_addBound(node, 0, -height / 2, width, 1);  
_addBound(node, 0, height / 2, width, 1);  
_addBound(node, -width / 2, 0, 1, height);  
_addBound(node, width / 2, 0, 1, height);  

node.parent = this.node;    &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在我们就开启了游戏世界的物理引擎，然后还需要配置需要受引擎影响的节点，也就是我们的水果。&lt;/p&gt;
&lt;h3&gt;水果刚体组件与碰撞组件&lt;/h3&gt;
&lt;p&gt;回到creator，找到我们的水果prefab，然后添加物理组件首先是Rigid Body（刚体）组件&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a2d6630e86ecc458459362e7d85e1dae_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;988&quot; data-rawheight=&quot;636&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-a2d6630e86ecc458459362e7d85e1dae_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;988&quot; data-rawheight=&quot;636&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-a2d6630e86ecc458459362e7d85e1dae_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-a2d6630e86ecc458459362e7d85e1dae_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后是物理碰撞组件，因为我们的水果全是圆形的，都选择PhysicsCircleCollider组件就可以了,如果有个香蕉之类不规则多边形边的话，工作量就会增加不少~&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b4b6851403e3499cb1ef7f59f03c77fb_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;986&quot; data-rawheight=&quot;331&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-b4b6851403e3499cb1ef7f59f03c77fb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;986&quot; data-rawheight=&quot;331&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-b4b6851403e3499cb1ef7f59f03c77fb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b4b6851403e3499cb1ef7f59f03c77fb_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;接下来可以看看整体效果，（记得把刚才的点击事件加上，然后控制一下随机生成水果类型）&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-51ca2e5fe51b31f5f6ef46f6f2840e85_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;482&quot; data-rawheight=&quot;855&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-51ca2e5fe51b31f5f6ef46f6f2840e85_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;482&quot; data-rawheight=&quot;855&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-51ca2e5fe51b31f5f6ef46f6f2840e85_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-51ca2e5fe51b31f5f6ef46f6f2840e85_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;完美！！&lt;/p&gt;
&lt;h3&gt;水果碰撞回调&lt;/h3&gt;
&lt;p&gt;添加完成之后，还需要开启刚体组件的碰撞属性&lt;code&gt;Enabled Contact Listener&lt;/code&gt;，这样可以接收到碰撞之后的回调&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6e2e9bf1151c7cb61522a2a63c0e9a70_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;492&quot; data-rawheight=&quot;814&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-6e2e9bf1151c7cb61522a2a63c0e9a70_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;492&quot; data-rawheight=&quot;814&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-6e2e9bf1151c7cb61522a2a63c0e9a70_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-6e2e9bf1151c7cb61522a2a63c0e9a70_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个碰撞回调同样写在Fruit脚本组件里面，&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Fruit.js  
onBeginContact(contact, self, other) {  
    // 检测到是两个相同水果的碰撞  
    if (self.node &amp;amp;&amp;amp; other.node) {  
        const s = self.node.getComponent(&#x27;Fruit&#x27;)  
        const o = other.node.getComponent(&#x27;Fruit&#x27;)  
        if (s &amp;amp;&amp;amp; o &amp;amp;&amp;amp; s.id === o.id) {  
            self.node.emit(&#x27;sameContact&#x27;, {self, other});  
        }  
    }  
},  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了保证Fruit组件功能的单一性，在两个相同水果发生碰撞时，我们通过事件通知&lt;code&gt;Game.js&lt;/code&gt;，这样可以在初始化水果的时候注册&lt;code&gt;sameContact&lt;/code&gt;自定义事件的处理方法&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Game.js  
createOneFruit(num) {  
    let fruit = cc.instantiate(this.fruitPrefab);  
    // ...其他初始化逻辑  
     fruit.on(&#x27;sameContact&#x27;, ({self, other}) =&amp;gt; {  
        // 两个node都会触发，临时处理，看看有没有其他方法只展示一次的  
        other.node.off(&#x27;sameContact&#x27;)   
        // 处理水果合并的逻辑，下面再处理  
        this.onSameFruitContact({self, other})  
     })  
}   &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样当水果发生碰撞时，我们就能够监听并处理消除升级逻辑了。&lt;/p&gt;
&lt;h2&gt;消除水果动画&lt;/h2&gt;
&lt;h3&gt;无动画版本&lt;/h3&gt;
&lt;p&gt;简单的消除逻辑就是将两个节点删除，然后在原水果位置生成高一级的水果即可，没有任何动画效果&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;self.node.removeFromParent(false)  
other.node.removeFromParent(false)  

const {x, y} = other.node // 获取合并的水果位置  
const id = other.getComponent(&#x27;Fruit&#x27;).id  

const nextId = id + 1  
const newFruit = this.createFruitOnPos(x, y, nextId) // 在指定位置生成新的水果  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虽然看起来有点奇怪，但的确可以以玩了！&lt;/p&gt;
&lt;h3&gt;分析动画&lt;/h3&gt;
&lt;p&gt;打开源站，通过Performance面板分析一下动画效果（这里就不录gif了）&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-dd7fe3e16ac7e0b5ffaf44f0b46135dc_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;592&quot; data-rawheight=&quot;838&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-dd7fe3e16ac7e0b5ffaf44f0b46135dc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;592&quot; data-rawheight=&quot;838&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-dd7fe3e16ac7e0b5ffaf44f0b46135dc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-dd7fe3e16ac7e0b5ffaf44f0b46135dc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看见合成的时候动画效果包括&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;碰撞水果向原水果中心移动&lt;/li&gt;
&lt;li&gt;果粒爆炸的粒子效果&lt;/li&gt;
&lt;li&gt;水珠爆炸的粒子效果&lt;/li&gt;
&lt;li&gt;一滩果汁的缩放动画&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外还有爆炸声和水声的音效&lt;/p&gt;
&lt;h3&gt;管理爆炸素材资源&lt;/h3&gt;
&lt;p&gt;由于整个动画涉及到的素材较多，每种水果均包含3种颜色不同的贴图，与上面FruitItem类似，我们也采用prefab加动态资源的做法来管理对应素材和动画逻辑。首先定义一个&lt;code&gt;JuiceItem&lt;/code&gt;，保存单种水果爆炸需要的素材&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Game.js  
const JuiceItem = cc.Class({  
    name: &#x27;JuiceItem&#x27;,  
    properties: {  
        particle: cc.SpriteFrame, // 果粒  
        circle: cc.SpriteFrame, // 水珠  
        slash: cc.SpriteFrame, // 果汁  
    }  
});   &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后为Game组件新增一个&lt;code&gt;juices&lt;/code&gt;属性&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Game.js  
properties: {  
    juices: {  
        default: [],  
        type: JuiceItem  
    },  
    juicePrefab: {  
        default: null,  
        type: cc.Prefab  
    },  
}  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来又是卖劳力的时候了，将贴图资源都拖放到&lt;code&gt;juices&lt;/code&gt;属性下&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-35c2bc41fb00267a456472c7d40efeb8_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;740&quot; data-rawheight=&quot;831&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-35c2bc41fb00267a456472c7d40efeb8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;740&quot; data-rawheight=&quot;831&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-35c2bc41fb00267a456472c7d40efeb8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-35c2bc41fb00267a456472c7d40efeb8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后新增一个空的预制资源，主要是为了挂载脚本组件，也就是下面的&lt;code&gt;Juice&lt;/code&gt;脚本，然后记得将该预制资源挂载到Game的&lt;code&gt;juicePrefab&lt;/code&gt;上。最后，新建&lt;code&gt;Juice&lt;/code&gt;组件，用来实现爆炸的动画逻辑，同样需要暴露init接口&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Juice.js  
cc.Class({  
    extends: cc.Component,  

    properties: {  
        particle: {  
            default: null,  
            type: cc.SpriteFrame  
        },  
        circle: {  
            default: null,  
            type: cc.SpriteFrame  
        },  
        slash: {  
            default: null,  
            type: cc.SpriteFrame  
        }  
    },  
    // 同样暴露一个init接口  
    init(data) {  
        this.particle = data.particle  
        this.circle = data.particle  
        this.slash = data.slash  
    },  
    // 动画效果  
    showJuice(){  

    }  
}  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样，在合并的时候，我们初始化一个Juice节点，同时展示爆炸效果即可&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Game.js  
let juice = cc.instantiate(this.juicePrefab);  
this.node.addChild(juice);  

const config = this.juices[id - 1]  
const instance = juice.getComponent(&#x27;Juice&#x27;)  
instance.init(config)  
instance.showJuice(pos, n) // 对应的爆炸逻辑   &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;爆炸粒子动画&lt;/h3&gt;
&lt;p&gt;关于粒子动画，网上能查到不少资料，如果感兴趣，也可以移步我之前整理的前端常见动画实现原理。粒子动画的主要的实现思路为：初始化N个粒子，控制他们的速度大小、方向和生命周期，然后控制每个粒子按照对应的参数执行动画，所有粒子汇集在一起的效果就组成了粒子动画。话虽如此，要把动画效果调好还是挺麻烦的，需要控制各种随机参数。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;showJuice(pos, width) {  
    // 果粒  
    for (let i = 0; i &amp;lt; 10; ++i) {  
        const node = new cc.Node(&#x27;Sprite&#x27;);  
        const sp = node.addComponent(cc.Sprite);  
        sp.spriteFrame = this.particle;  
        node.parent = this.node;  
        // ... 一堆随机的参数  

        node.position = pos;  
        node.runAction(  
            cc.sequence(  
                // ...各种action对应的动画逻辑  
                cc.callFunc(function () {  
                    // 动画结束后消除粒子  
                    node.active = false  
                }, this))  
        )  
    }  

    // 水珠  
    for (let f = 0; f &amp;lt; 20; f++) {  
        // 同果粒，使用的spriteFrame切换成 this.circle  
    }  
      
    // 果汁只有一张贴图，使用this.slash，展示常规的action缩放和透明动画即可  
},   &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;源项目的代码中使用&lt;code&gt;createFruitL&lt;/code&gt;这个方法来处理爆炸动画，虽然经过了代码压缩，但依稀能看出对应的动画参数逻辑，如果不想调整动画参数，可以借鉴一下&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fd9c57a1c9414707cf85b543541134d0_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;935&quot; data-rawheight=&quot;439&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-fd9c57a1c9414707cf85b543541134d0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;935&quot; data-rawheight=&quot;439&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-fd9c57a1c9414707cf85b543541134d0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-fd9c57a1c9414707cf85b543541134d0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样，就完成了爆炸效果的展示，大概类似于这样，虽然有点丑&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5e6e356fdd77b6b4c81a8b44c39a7bf4_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;290&quot; data-rawheight=&quot;248&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;290&quot; data-rawheight=&quot;248&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-5e6e356fdd77b6b4c81a8b44c39a7bf4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;音效&lt;/h3&gt;
&lt;p&gt;通过&lt;code&gt;cc.audioEngine&lt;/code&gt;直接播放&lt;code&gt;AudioClip&lt;/code&gt;资源来实现音效在Game组件下新增两个类型为AudioClip的资源，方便脚本组件访问&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;properties: {  
    boomAudio: {  
        default: null,  
        type: cc.AudioClip  
    },  
    waterAudio: {  
        default: null,  
        type: cc.AudioClip  
    }  
}  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;同上，在属性检查器中将两个音频资源从资源管理器拖动到Game组件的属性下方&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;onSameFruitContact(){  
    cc.audioEngine.play(this.boomAudio, false, 1);  
    cc.audioEngine.play(this.waterAudio, false, 1);  
}   &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样就可以在碰撞的时候听到声音了。&lt;/p&gt;
&lt;h2&gt;构建打包&lt;/h2&gt;
&lt;p&gt;完成整个游戏的开发之后，可以选择构建发布，打包成web-mobile版本，然后部署在服务器上，就可以给其他人快乐地玩耍了
&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6a428c9ea7a8e157b12e90079d134bdc_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1495&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-6a428c9ea7a8e157b12e90079d134bdc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1495&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-6a428c9ea7a8e157b12e90079d134bdc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-6a428c9ea7a8e157b12e90079d134bdc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;不知不就就写到了最后，貌似！！已经大工告成了！！虽然还有很多细节没有实现，比如添加得分、合成西瓜之后的撒花等功能，感兴趣的同学可以自己克隆去尝试修改一下。本文所有代码及素材都放在github上面了，也可以通过在线预览地址体验完成这个游戏花了这周六下午 + 一个晚上的时间，由于对 cocos creator 并不是很熟悉，因此花了一些时间去看文档、查资料，甚至去B站上看了点教学视频。不过收获的成就感与满足感还是很大的，也算是正儿八经写了点游戏。最后，尤其要感谢我媳妇，帮忙测试及提新需求。不说了，我还得再去加一个点击水果直接消除的功能！&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;微信无法点击游戏链接，请给我们公号发送&lt;code&gt;大西瓜&lt;/code&gt;获取入口
&lt;code&gt;开源前哨&lt;/code&gt; 日常分享热门、有趣和实用的开源项目。参与维护 10万+ Star 的开源技术资源库，包括：Python、Java、C/C++、Go、JS、CSS、Node.js、PHP、.NET 等。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9bef7ef50c7ed1f0adb3b550cf5790ba</guid>
<title>Doris SQL 原理解析</title>
<link>https://toutiao.io/k/vn9hzv2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                                    


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;7&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;文|汪细勖&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;小米云平台工程师、负责小米Apache Doris项目的开发和运维、专注于OLAP计算引擎的SQL解析和优化&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt; &lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;85927&quot;&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;导读&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section hm_fix=&quot;363.58984375:362.09375&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;本文主要介绍了&lt;/span&gt;&lt;span&gt;Doris SQL&lt;/span&gt;&lt;span&gt;解析的原理。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;重点讲述了生成单机逻辑计划，生成分布式逻辑计划，生成分布式物理计划的过程。对应于代码实现是&lt;/span&gt;&lt;span&gt;Analyze&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;SinglePlan&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;DistributedPlan&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Schedule&lt;/span&gt;&lt;span&gt;四个部分。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Analyze&lt;/span&gt;&lt;span&gt;负责对&lt;/span&gt;&lt;span&gt;AST&lt;/span&gt;&lt;span&gt;进行前期的一些处理，&lt;/span&gt;&lt;span&gt;SinglePlan&lt;/span&gt;&lt;span&gt;根据&lt;/span&gt;&lt;span&gt;AST&lt;/span&gt;&lt;span&gt;进行优化生成单机查询计划，&lt;/span&gt;&lt;span&gt;DistributedPlan&lt;/span&gt;&lt;span&gt;将单机的查询计划拆成分布式的查询计划，&lt;/span&gt;&lt;span&gt;Schedule&lt;/span&gt;&lt;span&gt;阶段负责决定查询计划下发到哪些机器上执行。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;由于&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;类型有很多，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;本文侧重介绍查询&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;的解析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;，从算法原理和代码实现上深入讲解了&lt;/span&gt;&lt;span&gt;Doris&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;解析原理。&lt;/span&gt;&lt;/span&gt;&lt;strong/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;1. &lt;span&gt;Doris简介&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;Doris&lt;/span&gt;&lt;span&gt;是基于&lt;/span&gt;&lt;span&gt;MPP&lt;/span&gt;&lt;span&gt;架构的交互式&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;数据仓库，主要用于解决近实时的报表和多维分析。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Doris&lt;/span&gt;&lt;span&gt;分成两部分&lt;/span&gt;&lt;span&gt;FE&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;BE&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;FE &lt;/span&gt;&lt;span&gt;负责存储以及维护集群元数据、接收、解析、查询、设计规划整体查询流程，&lt;/span&gt;&lt;span&gt;BE &lt;/span&gt;&lt;span&gt;负责数据存储和具体的实施过程。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt; Doris &lt;/span&gt;&lt;span&gt;的存储引擎中，用户数据被水平划分为若干个数据分片（&lt;/span&gt;&lt;span&gt;Tablet&lt;/span&gt;&lt;span&gt;，也称作数据分桶）。每个&lt;/span&gt;&lt;span&gt; Tablet &lt;/span&gt;&lt;span&gt;包含若干数据行。多个&lt;/span&gt;&lt;span&gt; Tablet &lt;/span&gt;&lt;span&gt;在逻辑上归属于不同的分区&lt;/span&gt;&lt;span&gt;Partition&lt;/span&gt;&lt;span&gt;。一个&lt;/span&gt;&lt;span&gt; Tablet &lt;/span&gt;&lt;span&gt;只属于一个&lt;/span&gt;&lt;span&gt; Partition&lt;/span&gt;&lt;span&gt;。而一个&lt;/span&gt;&lt;span&gt; Partition &lt;/span&gt;&lt;span&gt;包含若干个&lt;/span&gt;&lt;span&gt; Tablet&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;Tablet &lt;/span&gt;&lt;span&gt;是数据移动、复制等操作的最小物理存储单元。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Doris广泛应用于小米的各条业务线上，为小米金融，手机，AIOT，游戏等各大部门提供数据计算支持&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;2. SQL解析&lt;span&gt;简介&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;SQL解析在这篇文章中指的是&lt;strong&gt;将一条sql语句经过一系列的解析最后生成一个完整的物理执行计划的过程。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;这个过程包括以下四个步骤：词法分析，语法分析，生成逻辑计划，生成物理计划&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如图1所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.41328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eGOhXuI8cBb6abNrueRI08LWfuztINW2PL7rnDoXQw9NoguUVGe39WdfOZ2MJm29dO7Gviaic8iaib0Rxh65OE6sibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;图 1 SQL解析的流程&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.1 词法分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;词法分析主要负责将字符串形式的sql识别成一个个token，为语法分析做准备。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;select ......  from ...... where ....... group by ..... order by ......&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;SQL 的 Token 可以分为如下几类：&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;￮ 关键字（select、from、where）&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;￮ 操作符（+、-、&amp;gt;=）&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;￮ 开闭合标志（(、CASE）&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;￮ 占位符（?）&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;￮ 注释&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;￮ 空格&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;......&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.2 语法分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;语法分析主要负责根据语法规则，将词法分析生成的token转成抽象语法树（Abstract Syntax Tree），如图2所示。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.43828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eGOhXuI8cBb6abNrueRI08LWfuztINW2UZKJMrRZX0QrQ9nXsKuUqxZ2Rq5IoAGwUtRTzC1F7hMTE5kma93Fzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;图 2 抽象语法树示例&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.3 逻辑计划&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;逻辑计划负责将抽象语法树转成代数关系。代数关系是一棵算子树，每个节点代表一种对数据的计算方式，整棵树代表了数据的计算方式以及流动方向，如图3所示。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.5584642233856894&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;573&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eGOhXuI8cBb6abNrueRI08LWfuztINW2AczfBJlyOXV80lahECPBBr89JBibEAmHTryIUia8R6AOiah2YjOFWYJSg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;图3 关系代数示例&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.4 物理计划&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;物理计划是在逻辑计划的基础上，根据机器的分布，数据的分布，决定去哪些机器上执行哪些计算操作。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Doris系统的SQL解析也是采用这些步骤，只不过根据Doris系统结构的特点和数据的存储方式，进行了细化和优化，最大化发挥机器的计算能力。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;3. 设计目标&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Doris SQL解析架构的设计有以下目标：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最大化计算的并行性&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最小化数据的网络传输&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最大化减少需要扫描的数据&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;4. 总体架构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Doris SQL解析具体包括了五个步骤：词法分析，语法分析，生成单机逻辑计划，生成分布式逻辑计划，生成物理执行计划。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具体代码实现上包含以下五个步骤：Parse, Analyze, SinglePlan, DistributedPlan, Schedule。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.5577981651376147&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eGOhXuI8cBb6abNrueRI08LWfuztINW2PpWKdK5mk6Sxob6fBsxvGY3ngX2LMnF2MmgNqfWo0MVcSXkP9eWBnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1090&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;图4 系统总体架构图&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如图4所示，Parse阶段本文不详细讲，Analyze负责对AST进行前期的一些处理，SinglePlan根据AST进行优化生成单机查询计划，DistributedPlan将单机的查询计划拆成分布式的查询计划，Schedule阶段负责决定查询计划下发到哪些机器上执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;由于SQL类型有很多，本文侧重介绍查询SQL的解析。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图5展示了一个简单的查询SQL在Doris的解析实现。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.24453125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eGOhXuI8cBb6abNrueRI08LWfuztINW2KI0Yfgpwm5Rwe0s9hqMG8hnCTGeGlvz07TmBCLlcEAwkCU0FoDzERA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图 5 查询sql在Doris中的解析过程&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;5. Parse阶段&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;词法分析采用jflex技术，语法分析采用java cup parser技术，最后生成抽象语法树（Abstract Syntax Tree）AST，这些都是现有的、成熟的技术，在这里不进行详细介绍。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;AST是一种树状结构，代表着一条SQL。不同类型的查询select, insert, show, set, alter table, create table等经过Parse阶段后生成不同的数据结构（SelectStmt, InsertStmt, ShowStmt, SetStmt, AlterStmt, AlterTableStmt, CreateTableStmt等），但他们都继承自Statement，并根据自己的语法规则进行一些特定的处理。例如：对于select类型的sql， Parse之后生成了SelectStmt结构。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;SelectStmt结构包含了SelectList，FromClause，WhereClause，GroupByClause，SortInfo等结构。这些结构又包含了更基础的一些数据结构，如WhereClause包含了BetweenPredicate（between表达式）, BinaryPredicate（二元表达式）， CompoundPredicate（and or组合表达式）, InPredicate（in表达式）等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;AST中所有结构都是由基本结构表达式Expr通过多种组合而成，如图6所示。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/eGOhXuI8cBb6abNrueRI08LWfuztINW2qXtfUBfheEV33u97KibJm00uxrlJ3QkHBPPH0IQUjYYLhxamtgUEwlA/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;71.00346020761246&quot; data-cropy2=&quot;717.5086505190311&quot; data-ratio=&quot;0.5990740740740741&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/Re4KW51oYRoHK7pBNJEF7urPf1iaYLM5j6FK8E7PlciazoIVrFxRm56tnsAwglZFDDlc4icl3AJfI7ecZGSwibByjw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;图 6 Doris中抽象语法树AST的实现&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;6. Analyze阶段&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;抽象语法树是由StatementBase这个抽象类表示。这个抽象类包含一个最重要的成员函数analyze()，用来执行Analyze阶段要做的事。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不同类型的查询select, insert, show, set, alter table, create table等经过Parse阶段后生成不同的数据结构（SelectStmt, InsertStmt, ShowStmt, SetStmt, AlterStmt, AlterTableStmt, CreateTableStmt等），这些数据结构继承自StatementBase，并实现analyze()函数，对特定类型的SQL进行特定的Analyze。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如：select类型的查询，会转成对select sql的子语句SelectList, FromClause, GroupByClause, HavingClause, WhereClause, SortInfo等的analyze()。然后这些子语句再各自对自己的子结构进行进一步的analyze()，通过层层迭代，把各种类型的sql的各种情景都分析完毕。例如：WhereClause进一步分析其包含的BetweenPredicate（between表达式）, BinaryPredicate（二元表达式）， CompoundPredicate（and or组合表达式）, InPredicate（in表达式）等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;对于查询类型的SQL，包含以下几项重要工作：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;· 元信息的识别和解析：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;识别和解析sql中涉及的 Cluster, Database, Table, Column 等元信息，确定需要对哪个集群的哪个数据库的哪些表的哪些列进行计算。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;· SQL 的合法性检查：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;窗口函数不能 DISTINCT，投影列是否有歧义，where语句中不能含有grouping操作等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;· SQL 简单重写：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;比如将 select * 扩展成 select 所有列，count distinct转成bitmap或者hll函数等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;· 函数处理：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;检查sql中包含的函数和系统定义的函数是否一致，包括参数类型，参数个数等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;· Table 和 Column 的别名处理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;· 类型检查和转换：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;例如二元表达式两边的类型不一致时，需要对其中一个类型进行转换（BIGINT 和 DECIMAL 比较，BIGINT 类型需要 Cast 成 DECIMAL）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;对AST 进行analyze后，会再进行一次rewrite操作，进行精简或者是转成统一的处理方式。&lt;/span&gt;&lt;span&gt;目前rewrite的算法是基于规则的方式，针对AST的树状结构，自底向上，应用每一条规则进行重写。如果重写后，AST有变化，则再次进行analyze和rewrite，直到AST无变化为止。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如：常量表达式的化简：1 + 1 + 1 重写成 3，1 &amp;gt; 2 重写成 Flase 等。将一些语句转成统一的处理方式，比如将 where in, where exists 重写成 semi join, where not in, where not exists 重写成 anti join。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;7. 生成单机逻辑Plan阶段&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这部分工作主要是根据AST抽象语法树生成代数关系，也就是俗称的算子数。树上的每个节点都是一个算子，代表着一种操作。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;如图7所示，ScanNode代表着对一个表的扫描操作，将一个表的数据读出来。HashJoinNode代表着join操作，小表在内存中构建哈希表，遍历大表找到连接键相同的值。Project表示投影操作，代表着最后需要输出的列，图7表示只用输出citycode这一列。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5023510971786834&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eGOhXuI8cBb6abNrueRI08LWfuztINW2zmNKGshyEkfd658bjjibna6Ts6oGhvtcuzArjGpGrkzeE7dAiajzhcLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1276&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图7 单机逻辑计划示例&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如果不进行优化，生成的关系代数下发到存储中执行的代价非常高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于查询：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;select a.siteid, a.pv from table1 a join table2 b on a.siteid = b.siteid where a.citycode=122216 and b.username=&quot;test&quot; order by a.pv limit 10&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;未优化的关系代数，如图8所示，需要将所有列读出来进行一系列的计算，在最后选择输出siteid, pv两列，大量无用的列数据浪费了计算资源。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Doris在生成代数关系时，进行了大量的优化，将投影列和查询条件尽可能放到扫描操作时执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;2.22&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eGOhXuI8cBb6abNrueRI08LWfuztINW2auRbjRzT0uxGBSAXMJJNeATDCTraKsOL354uvq4bUDVTibxFibJCibVibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图8 未优化的关系代数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;具体来说这个阶段主要做了如下几项工作：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;· Slot 物化：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;指确定一个表达式对应的列需要 Scan 和计算，比如聚合节点的聚合函数表达式和 Group By 表达式需要进行物化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;· 投影下推：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;BE 在 Scan 时只会 Scan 必须读取的列。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;· 谓词下推：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;在满足语义正确的前提下将过滤条件尽可能下推到 Scan 节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;· 分区，分桶裁剪：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;根据过滤条件中的信息，确定需要扫描哪些分区，哪些桶的tablet。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;· Join Reorder：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;对于 Inner Join, Doris 会根据行数调整表的顺序，将大表放在前面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;· Sort + Limit 优化成 TopN：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;对于order by limit语句会转换成TopN的操作节点，方便统一处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;· MaterializedView 选择：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;会根据查询需要的列，过滤，排序和 Join 的列，行数，列数等因素选择最佳的物化视图。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图9展示了优化的示例，Doris是在生成关系代数的过程中优化，边生成边优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.26875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eGOhXuI8cBb6abNrueRI08LWfuztINW22TQibGGdSmibQGCMIfwDnYficwSuxgXl9FLrwm7r3bEYE8SicicF1LwQZ8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 9 单机查询计划优化的过程&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;8. 生成分布式Plan阶段&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;有了单机的PlanNode树之后，就需要进一步根据分布式环境，拆成分布式PlanFragment树（PlanFragment用来表示独立的执行单元），毕竟一个表的数据分散地存储在多台主机上，完全可以让一些计算并行起来。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;这个步骤的主要目标是最大化并行度和数据本地化。主要方法是将能够并行执行的节点拆分出去单独建立一个PlanFragment，用ExchangeNode代替被拆分出去的节点，用来接收数据。拆分出去的节点增加一个DataSinkNode，用来将计算之后的数据传送到ExchangeNode中，做进一步的处理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这一步采用递归的方法，自底向上，遍历整个PlanNode树，然后给树上的每个叶子节点创建一个PlanFragment，如果碰到父节点，则考虑将其中能够并行执行的子节点拆分出去，父节点和保留下来的子节点组成一个parent PlanFragment。拆分出去的子节点增加一个父节点DataSinkNode组成一个child PlanFragment，child PlanFragment指向parent PlanFragment。这样就确定了数据的流动方向。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于查询操作来说，join操作是最常见的一种操作。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Doris目前支持4种join算法：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;broadcast join，hash partition join，colocate join，bucket shuffle join。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;broadcast join：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;将小表发送到大表所在的每台机器，然后进行hash join操作。当一个表扫描出的数据量较少时，计算broadcast join的cost，通过计算比较hash partition的cost，来选择cost最小的方式。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;hash partition join：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;当两张表扫描出的数据都很大时，一般采用hash partition join。它遍历表中的所有数据，计算key的哈希值，然后对集群数取模，选到哪台机器，就将数据发送到这台机器进行hash join操作。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;colocate join：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;两个表在创建的时候就指定了数据分布保持一致，那么当两个表的join key与分桶的key一致时，就会采用colocate join算法。由于两个表的数据分布是一样的，那么hash join操作就相当于在本地，不涉及到数据的传输，极大提高查询性能。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;bucket shuffle join：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;当join key是分桶key，并且只涉及到一个分区时，就会优先采用bucket shuffle join算法。由于分桶本身就代表了数据的一种切分方式，所以可以利用这一特点，只需将右表对左表的分桶数hash取模，这样只需网络传输一份右表数据，极大减少了数据的网络传输，如图10所示。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.0683371298405466&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eGOhXuI8cBb6abNrueRI08LWfuztINW2tUCXJQbb5IA9MkbT5FpdYcxjEghV1LGrk3Eq15zicHBWQibVP6bA1G6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;878&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 10 bucket shuffle join示例&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;如图11展示了带有HashJoinNode的单机逻辑计划创建分布式逻辑计划的核心流程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;· 对PlanNode，自底向上创建PlanFragment。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;· 如果是ScanNode，则直接创建一个PlanFragment，PlanFragment的RootPlanNode是这个ScanNode。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;· 如果是HashJoinNode，则首先计算下broadcastCost，为选择boracast join还是hash partition join提供参考。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;· 根据不同的条件判断选择哪种Join算法&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;· 如果使用colocate join，由于join操作都在本地，就不需要拆分。设置HashJoinNode的左子节点为leftFragment的RootPlanNode，右子节点为rightFragment的RootPlanNode，与leftFragment共用一个PlanFragment，删除掉rightFragment。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;· 如果使用bucket shuffle join，需要将右表的数据发送给左表。所以先创建了一个ExchangeNode，设置HashJoinNode的左子节点为leftFragment的RootPlanNode，右子节点为这个ExchangeNode，与leftFragment共用一个PlanFragment，并且指定rightFragment数据发送的目的地为这个ExchangeNode。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;· 如果使用broadcast join，需要将右表的数据发送给左表。所以先创建了一个ExchangeNode，设置HashJoinNode的左子节点为leftFragment的RootPlanNode，右子节点为这个ExchangeNode，与leftFragment共用一个PlanFragment，并且指定rightFragment数据发送的目的地为这个ExchangeNode。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;· &lt;/span&gt;如果使用hash partition join，左表和右边的数据都要切分，需要将左右节点都拆分出去，分别创建left ExchangeNode, right ExchangeNode，HashJoinNode指定左右节点为left ExchangeNode和 right ExchangeNode。单独创建一个PlanFragment，指定RootPlanNode为这个HashJoinNode。最后指定leftFragment, rightFragment的数据发送目的地为left ExchangeNode, right ExchangeNode。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.90234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eGOhXuI8cBb6abNrueRI08LWfuztINW2eEdW4JibvoPDFOZRPczPWl7LV9O4rICsfh9SZs3BA7iaxV56RuYBXd0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 11 HashJoinNode创建分布式逻辑计划核心流程&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;图12是两个表的join操作转换成PlanFragment树之后的示例，一共生成了3个PlanFragment。最终数据的输出通过ResultSinkNode节点。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.99921875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eGOhXuI8cBb6abNrueRI08LWfuztINW28h3cagVpjib1pnWlKQznw0G1qej16sZiaMtEHqrWMBt8FXHiaYym7mxNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 12 从单机计划到分布式计划&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;9. Schedule阶段&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这一步是根据分布式逻辑计划，创建分布式物理计划。主要解决以下问题：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;哪个 BE 执行哪个 PlanFragment&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;每个 Tablet 选择哪个副本去查询&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如何进行多实例并发&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;图13展示了创建分布式物理计划的核心流程：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;a. prepare阶段：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;给每个PlanFragment创建一个FragmentExecParams结构，用来表示PlanFragment执行时所需的所有参数；如果一个PlanFragment包含有DataSinkNode，则找到数据发送的目的PlanFragment，然后指定目的PlanFragment的FragmentExecParams的输入为该PlanFragment的FragmentExecParams。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;b. computeScanRangeAssignment阶段：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;针对不同类型的join进行不同的处理。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;computeScanRangeAssignmentByColocate：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;针对colocate join进行处理，由于join的两个表桶中的数据分布都是一样的，他们是基于桶的join操作，所以在这里是确定每个桶选择哪个host。在给host分配桶时，尽量保证每个host分配到的桶基本平均。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;computeScanRangeAssignmentByBucket：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;针对bucket shuffle join进行处理，也只是基于桶的操作，所以在这里是确定每个桶选择哪个host。在给host分配桶时，同样需要尽量保证每个host分配到的桶基本平均。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;computeScanRangeAssignmentByScheduler：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;针对其他类型的join进行处理。确定每个scanNode读取tablet哪个副本。一个scanNode会读取多个tablet，每个tablet有多个副本。为了使scan操作尽可能分散到多台机器上执行，提高并发性能，减少IO压力，Doris采用了Round-Robin算法，使tablet的扫描尽可能地分散到多台机器上去。例如100个tablet需要扫描，每个tablet 3个副本，一共10台机器，在分配时，保障每台机器扫描10个tablet。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;c. computeFragmentExecParams阶段：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;这个阶段解决PlanFragment下发到哪个BE上执行，以及如何处理实例并发问题。确定了每个tablet的扫描地址之后，就可以以地址为维度，将FragmentExecParams生成多个实例，也就是FragmentExecParams中包含的地址有多个，就生成多个实例FInstanceExecParam。如果设置了并发度，那么一个地址的执行实例再进一步的拆成多个FInstanceExecParam。针对bucket shuffle join和colocate join会有一些特殊处理，但是基本思想一样。FInstanceExecParam创建完成后，会分配一个唯一的ID，方便追踪信息。如果FragmentExecParams中包含有ExchangeNode，需要计算有多少senders，以便知道需要接受多少个发送方的数据。最后FragmentExecParams确定destinations，并把目的地址填充上去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;d. create result receiver阶段：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;result receiver是查询完成后，最终数据需要输出的地方。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;e. to thrift阶段：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;根据所有PlanFragment的FInstanceExecParam创建rpc请求，然后下发到BE端执行。这样一个完整的SQL解析过程完成了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.78359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eGOhXuI8cBb6abNrueRI08LWfuztINW2Uxjm6pbCgXiaR9GFJXECYiaSUkzCBHZl5U91R9VJuuj1ptRcia5a0nSJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 13 创建分布式物理计划核心流程&lt;/span&gt; &lt;/p&gt;&lt;section&gt;&lt;span&gt;如图14所示是一个简单示例，图中的PlanFrament包含了一个ScanNode，ScanNode扫描3个tablet，每个tablet有2副本，集群假设有2台host。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;computeScanRangeAssignment阶段确定了需要扫描replica 1,3,5,8,10,12，其中replica 1,3,5位于host1上，replica 8,10,12位于host2上。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果全局并发度设置为1时，则创建2个实例FInstanceExecParam，下发到host1和host2上去执行，如果如果全局并发度设置为3，这个host1上创建3个实例FInstanceExecParam，host2上创建3个实例FInstanceExecParam，每个实例扫描一个replica，相当于发起6个rpc请求。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5046875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eGOhXuI8cBb6abNrueRI08LWfuztINW2B29vBth7cGn3DWnp0nxmbib1EkbHyehpkbDupR8iafWJ68DyicxibMBk3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 14 生成物理计划的过程&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;10. 总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文首先简单介绍了Doris，然后介绍SQL解析的通用流程：词法分析，语法分析，生成逻辑计划，生成物理计划，接着从总体上介绍了Doris在SQL解析这块的总体架构，最后详细讲解了Parse，Analyze，SinglePlan，DistributedPlan，Schedule等5个过程，从算法原理和代码实现上进行了深入的讲解。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Doris遵守了SQL解析的常用方法，但根据底层存储架构，以及分布式的特点，在SQL解析这块进行了大量的优化，实现了最大并行度和最小化网络传输，给SQL执行层面减少很多负担。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section label=&quot;Copyright © 2016 playhudong All Rights Reserved.&quot; donone=&quot;shifuMouseDownPayStyle(&#x27;shifu_t_050&#x27;)&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;往期文章&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/Re4KW51oYRoa0xX2NyxJHPKF0dDoiczRdDXRTy3Jp713bcQlzwjRk5fCibptpLXhcicwrlTxUBabbHyibLhaP7M0sw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>