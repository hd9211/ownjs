<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ecaa187a114f6fd99e6851bcd31c79a9</guid>
<title>有了这款运维自动化神器，可以抛弃 Ansible 了</title>
<link>https://toutiao.io/k/d139zzl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;span&gt;△点击上方“&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Python猫&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;”关注 ，回复“&lt;/span&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;”领取电子书&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5820568927789934&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LLRiaS9YfFTOMxUibn1y4x16tmFKvia0O6Wm3aSVibvTT02x5NKGQxmPV1ezLcOluTz5iavAQ44BvibFxichCAlZTqEicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;914&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;文末赠书&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作者：九净&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来源：NetDevOps加油站&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天开始一个新的大坑，绝对是巨坑了，给大家安利一款网络运维自动化工具Nornir（北欧神话里的命运女神三姐妹的名字）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提起运维自动化的工具，扛把子目前还是ansible。究其原因还是高度的封装，良好的生态，基于这两个大杀器，简单写个yaml文件就可以编排出一个符合我们预期的自动化场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，看过我文章的小伙伴都知道，我对ansible是爱恨交加，大爱无言，就此掠过，我就说说“恨”：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;国产网络设备的适配之路，难于上青天，说多了都是泪，国产的除了华为官方支持，其他的我真是见不到了。基于ssh采集设备信息时没大问题，但是配置起来，那就是几乎不敢用，因为网络配置回显提示不断在变化，low level的调用，无法加以分情况的判断。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;性能问题，逻辑设计过于复杂，层层的调用等各种原因导致其性能不佳，主要体现在并发不行，执行效率略低，大家对之诟病不少。如果网络设备多点，就得多弄几台服务器了。也有人提出ansible可以调优，但是对于大多数用户来说，过于复杂。性能问题也主要针对一个中大型的网络环境，其实几台设备，无所谓效率，for循环就可以了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;它想简化或者弱化编程语言的内容，倡导低代码开发，但是在一些复杂场景，个人觉得适得其反，循环判断等的使用，让人感觉犬牙交错，不如if else while for等简单快捷易读。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ansible是基于Python开发的，我感觉是有点矛盾的，有时候刻意的弱化Python，某些情况下debug及其麻烦，如果能用pycharm debug一个脚本该多好；有时候又宣称是Python开发的，可以二次开发，自己写一些module，但是这个过程又是debug麻烦，且封装的过于高深，用户自己开发的时候，我觉得门槛过高。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不一一列举了，再写，这篇文章又偏了，可以改成细数ansible在略微复杂的网络中运维自动化的N种罪状。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Nornir简介&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回归主题，介于以上种种，作为一个懂点Python的网络工程师，我们有没有一个更好的工具呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是有的，开题就告诉了大家，我们今天的主角闪亮登场——Nornir！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nornir是一个用python编写的自动化框架，主要是针对网络运维自动化，只要你懂一点点Python，就可以非常方便的使用nornir了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于Nornir允许用户使用纯Python代码，所以我们可以使用与其他Python代码相同的方法对其进行故障排除和调试，这就解决了那些低代码的自动化工具的调试和排障困难的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nornir自比是自动化界的Flask，侧面反映它的强大与灵活。（笔者是一个django的死忠粉，手动狗头）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;flask是一个Python的web开发框架，flask没有限制过多的接口，所以用户可以基于恰到好处的接口，基于自己的方式构建一个功能强大的web网站。nornir也是同样的事情，它无外乎实现了几种核心的功能，比如管理好资产、变量，内置一些与设备的常见的连接方式，自动关联并批量执行、支持插件这些自动化框架最基本的功能，你可以写自己的各种插件，实现任何你想实现的功能，而且是基于Python的，想想就让人很兴奋，再也不用去看那些过于复杂的playbook或者类似的配置文件了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说了这么多，我们来看看nornir的runbook长什么样子吧。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; nornir &lt;span&gt;import&lt;/span&gt; InitNornir&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; nornir_utils.plugins.functions &lt;span&gt;import&lt;/span&gt; print_result&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; nornir_napalm.plugins.tasks &lt;span&gt;import&lt;/span&gt; napalm_get&lt;br/&gt;&lt;br/&gt;nr = InitNornir(&lt;br/&gt;    config_file=&lt;span&gt;&quot;nornir.yaml&quot;&lt;/span&gt;, dry_run=&lt;span&gt;True&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;results = nr.run(&lt;br/&gt;    task=napalm_get, getters=[&lt;span&gt;&quot;facts&quot;&lt;/span&gt;, &lt;span&gt;&quot;interfaces&quot;&lt;/span&gt;]&lt;br/&gt;)&lt;br/&gt;print_result(results)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上是一个简单的官方示例，通过一个官方的内置插件nornir_napalm（其实需要单独安装，并不在本体里），集成了napalm（这又是一个我要吐槽的工具包，功能甚少，缺乏高层构建，改天再写写文章）。通过napalm获取了端口和基本的fact信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从代码上来看，清晰易读，加载了nornir的yaml配置文件，获取设备的清单及其他变量分组等等，然后全部设备批量执行信息获取，输出结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个代码，核心逻辑实际只有1行，获取信息，比ansible的，我觉得要简单好多，对于一个稍微懂点Python的网工而言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于绝大多数的使用，nornir不需要用户知道过多的python知识，什么并发、异步、写log、回调，统统都走开，你只需要会最基本的Python技能即可，知晓基本的&lt;strong&gt;数据类型、定义变量、循环、判断、函数的定义与使用&lt;/strong&gt;，基本就足够了。Noinir也是这样主张的，Python其实是一门易上手的语言，但是任务编程语言的精通都是需要时间和精力的。但是幸运的是，作为网络工程师，我们只是想写一些脚本，实现自动化，并不是要成为一位master。所以Nornir认为我们掌握基本的Python知识即可。（对于绝大多数网络运维工程师，我觉得这个是适用的，有意精通此道的，仍需不断努力精进）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说实话，作为一名NetDevOps工程师，多进程、多线程、协程等等这些我在日常中几乎没有使用过，包括我也从来没写过这方面的内容，因为我认为这块对于一个网络运维工程师来说，过于深奥，使用起来坑很多，其实是过于简单的使用并发推配置，我都是坚决反对的，无知者无畏，对于生产中的网络配置，我从来都是怀揣着一颗敬畏之心。我也推荐大家使用一些自动化框架或者其他工具实现并发，同时如果是推送配置，一定要慎重，可以的话尽量设计的是有检查机制或者可以终止的，防止手抖了后没有后悔的机会，不行连并发都别用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Nornir的安装、版本及插件说明&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方是建议大家使用虚拟环境安装的，我也建议大家使用虚拟环境安装，因为它里面的很多版本管理的比较精细，不建议放到我们的系统或者自己常用的Python环境中去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它支持3.6.2及以上的Python版本，这点我表示很赞，就不该给python2活路，赶紧演进。我建议大家使用3.7、3.8的版本。之前也讲过，我们用的Python都是最基础的Python知识，所以脚本的版本兼容会比较好一些。笔者使用的是3.8.3的版本，究竟原因，是因为我懒，装了一个anaconda。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本系列讲的是基于Nornir3.0.0这个版本，同时解释一下，网上关于Nornir的讲解本来就少（基本都是国外的），大多数是基于2.4和2.5的版本，3.0版本今年才发布（2020年），发生了一些变化，导致了一些配置文件的不兼容，所以大家不管是看我的还是其他人的视频或者文章也好，一定要留意版本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老规矩，&lt;code&gt;pip install nornir&lt;/code&gt;即可安装&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; pip install nornir&lt;/span&gt;&lt;br/&gt;Collecting nornir&lt;br/&gt;  Downloading nornir-3.0.0-py3-none-any.whl (28 kB)&lt;br/&gt;Requirement already satisfied: typing_extensions&amp;lt;4.0,&amp;gt;=3.7 in /home/dbarroso/.virtualenvs/tmp-nornir/lib/python3.8/site-packages (from nornir) (3.7.4.2)&lt;br/&gt;Requirement already satisfied: mypy_extensions&amp;lt;0.5.0,&amp;gt;=0.4.1 in /home/dbarroso/.virtualenvs/tmp-nornir/lib/python3.8/site-packages (from nornir) (0.4.3)&lt;br/&gt;Collecting ruamel.yaml&amp;lt;0.17,&amp;gt;=0.16&lt;br/&gt;  Using cached ruamel.yaml-0.16.10-py2.py3-none-any.whl (111 kB)&lt;br/&gt;Collecting ruamel.yaml.clib&amp;gt;=0.1.2; platform_python_implementation == &quot;CPython&quot; and python_version &amp;lt; &quot;3.9&quot;&lt;br/&gt;  Using cached ruamel.yaml.clib-0.2.0-cp38-cp38-manylinux1_x86_64.whl (578 kB)&lt;br/&gt;Installing collected packages: colorama, ruamel.yaml.clib, ruamel.yaml, nornir&lt;br/&gt;Successfully installed nornir-3.0.0 ruamel.yaml-0.16.10 ruamel.yaml.clib-0.2.0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装之后，可以打开ipython试试，没报错即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ python&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; nornir &lt;span&gt;import&lt;/span&gt; InitNornir&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于插件，我们也得唠唠，2.4 2.5的时候，很多东西都是内置的，但是3.0版本发生了很大的变化，官方把一些插件，分拆了出去，nornir变得更加纯粹了。比如以前的时候nornir支持netmiko和napalm等，现在统统分拆出去了，创建了新工具包，比如nornir_napalm就是nornir的一个对napalm封装，同样的也有nornir_netmiko，很多很多工具包都被这样分解出去了。有点像flask，它只提供最基础的web开发框架，如果想实现一些admin后台或者表单相关的，需要安装对应的flask工具包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nornir的官方网站是https://nornir.tech/ 在https://nornir.tech/nornir/plugins/ 我们可以看到官方的插件list，插件list分成几种：任务类的、连接类的、资源管理类的、进程管理、函数功能等等，比如netmiko就是一个任务类和连接类的插件包&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.3020565552699228&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y7BXgWR9x8bxI4XYcviaZnUdoOVvv3iaWsIF9exq9iaPAkBGIvFGoZ6SS1wRiaVNvmHm4l7xEQQZojmTicDBbFr9dXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;778&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个都会连接到github上，非常棒的是nornir_netmiko的作者就是netmiko的作者。所以回归到我们之前说的第一个问题，国产化问题，ansible的大难题（开源版本至少是这样的，不知道有没有收费的隐藏资源），在nornir面前就不再是问题了，因为netmiko对国产设备支持的还是比较好的，目前ruijieos都支持了，撒花！所以nornir可以非常方便的对国产设备进行批量操作，包含配置下发。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个简单的Nornir runbook&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;讲了这么多，我们赶紧来简简单单看看nornir是如何简单的开发出一个runbook的吧。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Nornir的文件组织架构及基本配置&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个nornir的runbook，类似ansible的，也有配置和设备清单及playbook的类似概念。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9463722397476341&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y7BXgWR9x8bxI4XYcviaZnUdoOVvv3iaWssibgN9LQyGYSK4XFGQTULPjibL7TMXVibo9iaO1KWia2WXqmsm2a2HlqGtA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;317&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是一个nornir的文件结构。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;配置文件 config.yaml&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先看看它的配置文件,nornir的配置文件使用的是可读性和书写便利性比较好的yaml文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们打开config.yaml文件，当然你也可以改成其他名称。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;---&lt;/span&gt;&lt;br/&gt;&lt;span&gt;inventory:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;plugin:&lt;/span&gt; &lt;span&gt;SimpleInventory&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;options:&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;host_file:&lt;/span&gt; &lt;span&gt;&quot;inventory/hosts.yaml&quot;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;group_file:&lt;/span&gt; &lt;span&gt;&quot;inventory/groups.yaml&quot;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;defaults_file:&lt;/span&gt; &lt;span&gt;&quot;inventory/defaults.yaml&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;runner:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;plugin:&lt;/span&gt; &lt;span&gt;threaded&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;options:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;num_workers:&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从配置上来看，我们也可以看出它的两个主要功能：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;指定加载资产的方式和路径&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;指定运行的方式，比如默认的线程及并发量&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;资产清单相关配置&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;plugin: SimpleInventory，我们就用默认的即可，它的意思是用SimpleInventory这个插件来加载清单。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以重写这个插件来对接我们的CMDB或者是csv文件都可以，只要按标准格式返回资产数据即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认它有几个重要的参数就是资产相关的文件的path。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;资产清单相关配置，一般放到inventory的文件夹内，内含三个文件：&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;host.yaml&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设备清单，字典的方式梳理所有设备，key值为设备名称，value值是个字典，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设备的属性分为三个大部分：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;设备基本信息：包含设备的IP或者hostname，用户名密码，连接的端口，设备的platform，这些参数都可以无缝对接netmiko和napalm。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;所属组groups，list形式，每个组都有很多属性，比如接入交换机有些基本的配置，类似的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;参数data，字典格式，用户可以根据需求自己定义，比如定义一个role后续筛选，或者自己的一些配置预定义等等&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6822107081174439&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y7BXgWR9x8bxI4XYcviaZnUdoOVvv3iaWs6icjUQH04pT8RkMvOdkdgqso5RnMyhICwUibmLDKeGiaVr1dpQiaUyntpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;579&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;groups.yaml&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设备会划拨给一些组，组里会有一些公用的属性，这个后续我们再详细分解&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;default.yaml&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;全局默认的一些参数，按下不表，后续章节我们再详细分解&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这三个最最核心的我觉得是hosts，资产清单是最最核心的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;初始化对象，尝试打印出资产清单&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过引入InitNornir初始化一个Nornir对象&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; nornir &lt;span&gt;import&lt;/span&gt; InitNornir&lt;br/&gt;nr = InitNornir(&lt;br/&gt;    config_file=&lt;span&gt;&quot;nornir.yaml&quot;&lt;/span&gt;&lt;br/&gt;    )&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们就可以直接打印出我们的设备清单了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# list hosts&lt;/span&gt;&lt;br/&gt;print(nr.inventory.hosts)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;{&#x27;dev01&#x27;: Host: dev01, &#x27;dev02&#x27;: Host: dev02, &#x27;dev03&#x27;: Host: dev03}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它返回的是一个字典，key是设备名称，value是一个复杂的nornir内置的host对象，可以获取yaml文件内的一切，甚至更多。后续我也会尝试讲解一下Nornir的内置的一些重要的基本类。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;给每台设备一个自定义task运行&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多自动化框架的逻辑，基本就是有设备清单，然后在设备清单中做出筛选（默认全部），然后每台设备去执行自己的task。nornir也是这个逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们已经有了资产清单，我们想给每个设备安排一个任务，该怎么处理呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以自己定义一个灵活的task，它的写法如下。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; nornir &lt;span&gt;import&lt;/span&gt; InitNornir&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; nornir_utils.plugins.functions &lt;span&gt;import&lt;/span&gt; print_result&lt;br/&gt;&lt;br/&gt;devices = InitNornir(&lt;br/&gt;    config_file=&lt;span&gt;&quot;nornir.yaml&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;hi&lt;/span&gt;&lt;span&gt;(task)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    words = &lt;span&gt;f&quot;Hi!I&#x27;m a network device. My name is &lt;span&gt;{task.host.name}&lt;/span&gt;&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; words&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;results = devices.run(task=hi,name=&lt;span&gt;&#x27;A task for saying hi!&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;print_result(results)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;自定义函数|task&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重点是hi这个函数，它的第一个参数是task，这个地方可以简单理解成一个任务的上下文。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后续是我们自己定义的参数，第一个，我们写的简单点，默认就让每台设备介绍一下自己。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每台设备都可以从task中取出自己的name，如上task.host.name&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们把想要返回的打印到屏幕上的return即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际过程中，我们可以写成每个设备执行自己的业务逻辑，比如信息采集、配置推送、起关端口等等，这个逻辑内部的很多都是可以受我们控制的，比如基本设备信息都可以从task中获取，然后调用netmiko或者ncclient等等，当然netmiko都有官方的插件包。这样就非常灵活了，我们简单写几个代码，借助netmiko批量配置就非常简单，后续也会展开介绍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nornir的灵活有一部分就体现在task里，可以非常灵活的定制自己的业务逻辑。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;批量执行自定义的task&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个重点来了，devices.run，devices就是我们初始化的Nornir对象，早期版本及官方版本会使用nr作为代替，类似pd代替pandas，有一些博主的视频代码里会写成筛选出来的设备，比如路由就写routers作为Nornir对象的变量名，这样可读性更好，有点所有设备执行任务的感觉。这个run有几个重要参数，我们今天初步介绍，最重要的是task，就是我们要调用哪个函数，这个时候我们传入自己定义函数（本例是hi），name是打印的时候显示的会比较好的而设计的，不写也没事。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;漂亮的打印出来&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们调用官方的插件包nornir_utils，这个需要pip安装。引入print_result，直接打印返回的结果即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看看效果&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4220472440944882&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y7BXgWR9x8bxI4XYcviaZnUdoOVvv3iaWsYWWcVbbUB8dx05vFVUc1b86fzbh1vdAOiaIhz3DPV1lyvm7WN9tbznw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;635&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常仿Ansible，有木有，每台设备并发执行，结果统统显示出来。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;小结与脑洞大开&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是一个Nornir的最最基础的使用方式了，在定义好hosts文件之后，我们可以写自己的task函数，可以写的很简单，也可以写的很复杂，开个脑洞，比如基于netmiko或者paramiko，配置备份，传到指定FTP，或者git仓库，作为一个版本备份及管理的脚本；中间的设备可以不停的筛选，同时根据返回的信息不停的判断，从而执行一些复杂场景，比如一些应急场景，或者涉及到多台设备的联动配置等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再奉上一段代码，我们后续也会深入讲解，基于官方netmiko插件包写的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对设备进行一个批量执行，我们之前也讲过很多netmiko的例子，这个官方的插件包与Nornir无缝对接，我们不用再去构建连接，Nornir自动帮我们创建连接&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; nornir &lt;span&gt;import&lt;/span&gt; InitNornir&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; nornir_utils.plugins.functions &lt;span&gt;import&lt;/span&gt; print_result&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; nornir_netmiko &lt;span&gt;import&lt;/span&gt; netmiko_send_command&lt;br/&gt;&lt;br/&gt;nr = InitNornir(&lt;br/&gt;    config_file=&lt;span&gt;&quot;nornir.yaml&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;show_cmds&lt;/span&gt;&lt;span&gt;(task)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    cmds = task.host.data[&lt;span&gt;&#x27;cmds&#x27;&lt;/span&gt;]&lt;br/&gt;    outputs = []&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; cmd &lt;span&gt;in&lt;/span&gt; cmds:&lt;br/&gt;        outputs.append(task.run(netmiko_send_command,command_string=cmd))&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; outputs&lt;br/&gt;results = nr.run(task=show_cmds)&lt;br/&gt;print_result(results)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码也比较简单，我们就是获取了设备里配置的data中的cmds命令行列表，然后执行了官方插件的netmiko_send_command命令，传入了cmd命令，并将结果放入outputs返回，这中间可以做的实际非常多，我们可以用textfsm解析归档，可以show run 备份，可以下发配置，看看结果，每台设备执行的情况我们都可以一目了然。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个设备是一台华为的ce系列交换机（模拟器），我们都知道，netmiko对国产化设备支持目前是比较好的，我们通过这种方式，对华为华三的配置都可以实现，ansible支持的网络设备实在有限，且和设备软件版本有一定关联，但是基于netmiko，我们使用ssh加命令行即可，目前为止，在一个中大型或者是不单纯的网络环境中，我个人习惯称之超融合网络，命令行辅之以其他方式，有能力的上层封装统一，能力暂时不足或者没特殊想法的单纯命令行一梭子到底即可，这是我认为的，&lt;strong&gt;目前&lt;/strong&gt;NetDevOps的最佳实现。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6198473282442748&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y7BXgWR9x8bxI4XYcviaZnUdoOVvv3iaWseID7EkJx3uO9qaN0dXgI9WInwKEkOwKz3WcBjZCCWK6PM3oJxV2dQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;655&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在国外，NetDevOps的使用比较广泛的还有napalm、netbox，Nornir与之都可以很方便对接，它也是有一定生态的，同时也可以非常方便的自己写插件扩展，或者硬编码连接方式到task中非常暴力的执行命令等等。nornir的核心代码据说5000+，我看了看，真的是非常简单，但是考虑的很周全灵活，灵活我们讲了，简单的设计，还有一个非常好的结果就是执行效率高，在中大型网络环境中，真的是可以秒杀ansible，大家如果写过ansible，也应该深有体会，我们就是想执行一个show version，结果要等很长时间处理一堆东西，返回的巨慢，但是nornir就非常赞，很快就完成与设备的交互返回结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时之前也说过，它是pure python写的，所以我们可以非常灵活的定制很多内容。这其实是一把双刃剑，根据使用者能力和脑洞，用好了可以帮我们解决很多问题，但是python本身就对使用者的Python有了一定要求，无法像ansible那样去低代码开发，所以Nornir的目标用户还是NetDevOps工程师多一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好吧，今天的分享就到这里结束了，后续有机会也与大家继续分享，毕竟这也是一个大坑。关于Nornir的相关博文非常少，中文的应该是没，也不成体系，本系列后续会不断给大家分享一些nornir的分析与讲解，希望在国内网工界引入这个非常棒的网络运维自动化框架，网络人专属的“ansible”，喷完了ansible，又碰瓷ansible，手动狗头！&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.8095238095238095&quot; data-type=&quot;svg&quot; data-w=&quot;21&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/lpHDr05YrIRQgT2sib9SWGE99gWsPW7x8FP6LoMYvgkmO9jSQjFqfcMVBUsiaSKickqickc7k2Kwah52tbzMnA316k2WA88rXLAX/640?wx_fmt=svg&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.4074074074074074&quot; data-type=&quot;svg&quot; data-w=&quot;27&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/ibKHP1TZZeXLuZkD53jFWzc8iauhHlerlWDib9Dgm1JiaSF9LB4RGxxD4cSFrUoIeI4fvic7VPGpKGv8AqCJgcUeqLoOAXBW6kKov/640?wx_fmt=svg&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;送书活动&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2185501066098081&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTOMxUibn1y4x16tmFKvia0O6WTSXVDxF5MX4UpLNJSpybT3RFBhWia7r7jVj6C0czDEsK9xIJMAHforQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;938&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;新一期的赠书活动，感谢北京大学出版社赞助。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1、内容全面:借助5大 Python工具库,实现数据分析从获取到建模全流程覆&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、贴合实际:不空讲 Python语法,清晰简明地介绍如何用Python来处理、分析数据&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3、热点案例:覆盖6大热点应用领域,可直接参考研发,实现数据变现&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;赠书规则&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;赠书本数&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：本次共包邮送书 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;本&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;参与方式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;：在&lt;strong&gt;Python猫&lt;/strong&gt;读者群抽奖，&lt;strong&gt;仅限群友&lt;/strong&gt;参与。后台发“&lt;/span&gt;&lt;span&gt;交流群&lt;/span&gt;&lt;span&gt;”，获取入群方式。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;开奖时间&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：2021年5月30日18:00&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;section&gt;&lt;mpcps frameborder=&quot;0&quot; class=&quot;js_editor_cps&quot; data-datakey=&quot;1622033712513_0.7636753855311949&quot; data-uid=&quot;1622033712515&quot; data-type=&quot;1&quot; data-product=&quot;&quot; data-templateid=&quot;list&quot; data-pid=&quot;29122980&quot; data-categoryid=&quot;3&quot; data-appuin=&quot;3084391334&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.45454545454545453&quot; data-w=&quot;22&quot; title=&quot;音符&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/cZV2hRpuAPiaJQXWGyC9wrUzIicibgXayrgibTYarT3A1yzttbtaO0JlV21wMqroGYT3QtPq2C7HMYsvicSB2p7dTBg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Python猫技术交流群开放啦！&lt;/span&gt;&lt;/strong&gt;群里既有国内一二线大厂在职员工，也有国内外高校在读学生，既有十多年码龄的编程老鸟，也有中小学刚刚入门的新人，学习氛围良好！想入群的同学，请在公号内回复『&lt;strong&gt;&lt;span&gt;交流群&lt;/span&gt;&lt;/strong&gt;』，获取猫哥的微信&lt;span&gt;（谢绝广告党，非诚勿扰！）&lt;/span&gt;~&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;还不过瘾？试试它们&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▲&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247492392&amp;amp;idx=1&amp;amp;sn=b0c7f15697c043eaf043730a0f9639cb&amp;amp;chksm=fa5ba4adcd2c2dbbf47059091d6a535bab4b14a7265bc9014a646780f556c2618f2c780472b4&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;坚持原创很难，但我不会放弃！&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▲&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247485430&amp;amp;idx=1&amp;amp;sn=f27591dfb2fc4a30a411f370182cd5ef&amp;amp;chksm=fa584073cd2fc965c812ed3a697f0302c422fbc8f66acbcabec186eb291374dc7af6e05ac85b&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Python 的缩进是不是反人类的设计？&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▲&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247488237&amp;amp;idx=1&amp;amp;sn=cf0c6860c751934f531b4dd460ba9780&amp;amp;chksm=fa585568cd2fdc7edcd3dfc1025401f0cbe16af1d56421518fece3dc450756eab641a841af67&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;冗长的 Python 代码，如何重构？&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▲&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247486931&amp;amp;idx=1&amp;amp;sn=93fff422b7b8b9f06019ef0562ed4d84&amp;amp;chksm=fa584a56cd2fc340220656d88a1da5554367786e8d375ec4fce74197c32995264fc0984a42fd&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;耗时两年，我终于出了一本电子书！&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▲&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247491934&amp;amp;idx=1&amp;amp;sn=880cb94ca57f37f3994202e9519b54d8&amp;amp;chksm=fa5ba6dbcd2c2fcda8b378b67eba0b71a18d7ab010d31420b43cd4e0169be39e6ec9582c48de&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Python 性能测试工具 Locust 极简入门&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▲&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247484794&amp;amp;idx=1&amp;amp;sn=53fae7b1274734a299e1e81b110c7e1c&amp;amp;chksm=fa5842ffcd2fcbe9b641f62b5212fda821f31258df58607c85ccd7f0d260074e3a58b1a756b4&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;由浅入深：Python 中如何实现自动导入缺失的库？&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如果你觉得本文有帮助&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;请慷慨&lt;/span&gt;&lt;span&gt;分享&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;和&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;点赞&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;，感谢啦&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>438941fdf751e46aebd839656ffe093d</guid>
<title>JVM 进阶之路（十三）：类加载过程</title>
<link>https://toutiao.io/k/exb3tei</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODE5ODM0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeFt08hV3N1706WTzfhoTNoXm5LXRV0XibppmeNR4zSNMa3QOJJ7ib4O21P5yohibwuD26Tp9ETWZAqA/0?wx_fmt=png&quot; data-nickname=&quot;三分恶&quot; data-alias=&quot;Fighter3FullStack&quot; data-signature=&quot;一个全栈开发。分享Java后端、Web前端、计算机基础知识。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过前面的学习，我们了解了Class文件的结构，在Class文件中描述的各类信息，最终都需要加载到虚拟机中之后才能被运行和使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们开始学习JVM的类加载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个类从被加载到虚拟机内存中开始，到从内存中卸载，整个生命周期需要经过七个阶段：加载 （Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）、使用（Using）和卸载（Unloading），其中验证、准备、解析三个部分统称为连接（Linking）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.39303482587064675&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfTeSZ3GWTEI2Aq4yTahy8cFba2pnScwnfXmhhhp84bNK9fWw8UwD8IAOnWOZIjicuvs5WWMpqEdUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;804&quot;/&gt;&lt;figcaption&gt;类的生命周期&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《Java虚拟机规范》 严格规定了有且只有六种情况必须立即对类进行“初始化”：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;1）遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2）使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3）当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;5）当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;6）当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这六种场景中的行为称为对一个类型进行主动引用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们来详细学习Java虚拟机中类加载的全过程，即加载、验证、准备、解析和初始化。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、加载&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加载是JVM加载的起点，具体什么时候开始加载，《Java虚拟机规范》中并没有进行强制约束，可以交给虚拟机的具体实现来自由把握。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在加载过程，JVM要做三件事情：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.5132450331125828&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfTeSZ3GWTEI2Aq4yTahy8cNjgPgic0MibcRqHc4g2kfEtJ8nnRf0ge3ZKapQLhaZkFpSpxtiacGoOibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;302&quot;/&gt;&lt;figcaption&gt;加载&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;1）通过一个类的全限定名来获取定义此类的二进制字节流。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区中的数据存储格式完全由虚拟机实现自行定义，《Java虚拟机规范》未规定此区域的具体数据结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象， 这个对象将作为程序访问方法区中的类型数据的外部接口。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;方法区在JDK不同版本的具体实现就不再详细说了。在JDK1.8中，类型数据存储在元空间中。&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、验证&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节码验证和符号引用验证。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.20724094881398253&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfTeSZ3GWTEI2Aq4yTahy8cBuDTWyVsn0QUI8w3J5q6khuUlpUibe0HrJYicwicgibDJpHrE4WVLEHCicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;801&quot;/&gt;&lt;figcaption&gt;验证阶段&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。需要验证魔数、版本号、常量池常量类型是否支持、指向常量的索引值等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求，包括类是否有父类、父类是否继承了final修饰的类、非抽象类是否实现了父类定义的方法、类是否与父类有矛盾等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;符号引用验证主要验证类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3、准备&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;准备阶段是给静态变量分配内存并设置类变量初始值的阶段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JDK 7及之前，这些变量的内存在方法区（永久代）中分配，在JDK 8及之后，静态变量则会随着Class对象一起存放在Java堆中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7387820512820513&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfTeSZ3GWTEI2Aq4yTahy8c5DNVIuTicia7d6akzQ7WQQX45JD6gIoKZbUFe6ys84DXMySAdQiaXoVfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;624&quot;/&gt;&lt;figcaption&gt;准备&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4、解析&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46687211093990755&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfTeSZ3GWTEI2Aq4yTahy8cs6smUScMl9iaOM9ZTibjMr8z6T5iarSTLeic2mmdicicykCuFOEp95FVXNog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;649&quot;/&gt;&lt;figcaption&gt;解析过程&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5、初始化&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类的初始化阶段是类加载过程的最后一个步骤，在这个阶段，会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;准备阶段，变量被赋的是系统要求的零值，在初始化阶段，赋的是代码里编写的值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4349315068493151&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfTeSZ3GWTEI2Aq4yTahy8cibTSXPVDMwDnSuSRkNdUYicpkhEWqIsvOCG0aZjVibyTYXp3vBGeKmVCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;584&quot;/&gt;&lt;figcaption&gt;初始化阶段&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，基本的类加载过程已经了解完了，接下来，我们将学习负责完成加载阶段的类加载器。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;big&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;【1】：《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODE5ODM0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeFt08hV3N1706WTzfhoTNoXm5LXRV0XibppmeNR4zSNMa3QOJJ7ib4O21P5yohibwuD26Tp9ETWZAqA/0?wx_fmt=png&quot; data-nickname=&quot;三分恶&quot; data-alias=&quot;Fighter3FullStack&quot; data-signature=&quot;一个全栈开发。分享Java后端、Web前端、计算机基础知识。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;204&quot; data-backw=&quot;558&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBLml8yqRnW8SzBIzu9h5RZaLdMfqqUt3mXMbX3bO0nu0FyfqotEfYm56F1xTqoqsmrQn3icGJ6Dw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b12f03c05c032dd1380989221a0634cf</guid>
<title>细谈 Go 变量的内存分布</title>
<link>https://toutiao.io/k/u9wqg6f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content has_line_number&quot;&gt;
          &lt;p&gt;我们程序中的变量大多被分配在内存的两个区域：&lt;code&gt;statck&lt;/code&gt;和&lt;code&gt;heap&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;stack和heap&quot;&gt;&lt;a href=&quot;#stack和heap&quot; class=&quot;headerlink&quot; title=&quot;stack和heap&quot;/&gt;&lt;code&gt;stack&lt;/code&gt;和&lt;code&gt;heap&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;首先让我们一起来回顾一下进程的内存分配：&lt;br/&gt;我们写的程序代码跑起来后，会是一个进程；OS会给我们的进程分配内存；内存结构大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/stack_heap/mem_total.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OS给一个进程分配的内存空间大致可以分为：&lt;code&gt;代码区&lt;/code&gt;、&lt;code&gt;全局数据区&lt;/code&gt;、&lt;code&gt;栈(stack)&lt;/code&gt;、&lt;code&gt;堆(heap)&lt;/code&gt;、&lt;code&gt;环境变量区域&lt;/code&gt;以及中间空白的&lt;code&gt;缓冲区&lt;/code&gt;六个部分。其中，数据的增长路径除&lt;code&gt;栈(stack)&lt;/code&gt;是由高到低之外，其余的均是由低到高(可看图中数据箭头)。&lt;/p&gt;
&lt;p&gt;我们思考一下，为什么&lt;code&gt;栈(stack)区&lt;/code&gt;这么特殊和其他区域路径相反？还有，进程内存中&lt;code&gt;stack&lt;/code&gt;和&lt;code&gt;heap&lt;/code&gt;和数据结构中的&lt;code&gt;stack&lt;/code&gt;和&lt;code&gt;heap&lt;/code&gt;名字都相同，是有什么联系吗？请带着问题往下看：&lt;/p&gt;
&lt;h3 id=&quot;进程内存中的stack和heap&quot;&gt;&lt;a href=&quot;#进程内存中的stack和heap&quot; class=&quot;headerlink&quot; title=&quot;进程内存中的stack和heap&quot;/&gt;进程内存中的&lt;code&gt;stack&lt;/code&gt;和&lt;code&gt;heap&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;stack&lt;/code&gt; : 是由程序侧通过&lt;code&gt;系统调用&lt;/code&gt;向操作系统申请的，由操作系统管理和释放，不需要程序员手动管理；一般用于存放线程和函数中产生的临时变量。这块区域的数据使用速度较快，不用手动管理，省心省力。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;heap&lt;/code&gt;：是由程序侧通过&lt;code&gt;系统调用&lt;/code&gt;向操作系统申请的，但是需要程序员自行管理的内存区域，因为此区域的定位是&lt;code&gt;global variable&lt;/code&gt;，用于存放全局的变量(虽然很多编程语言中不这么利用)； 程序员需要手动或者通过GC及时free或者delete此内存区域中的数据，但是也要注意：如果频繁的进行删除和添加，会导致内存碎片。&lt;/p&gt;
&lt;h3 id=&quot;数据结构stack和heap&quot;&gt;&lt;a href=&quot;#数据结构stack和heap&quot; class=&quot;headerlink&quot; title=&quot;数据结构stack和heap&quot;/&gt;数据结构&lt;code&gt;stack&lt;/code&gt;和&lt;code&gt;heap&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;我们再来看看数据结构中的&lt;code&gt;stack&lt;/code&gt;和&lt;code&gt;heap&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;stack&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;/img/stack_heap/stack.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;后进先出LIFO的数据结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Heap&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;/img/stack_heap/heap.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;堆的定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完全二叉树&lt;/li&gt;
&lt;li&gt;每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根节点是最大数的叫做“大顶堆”，根节点是最小数的叫做“小顶堆”。&lt;/p&gt;
&lt;p&gt;堆&lt;code&gt;heap&lt;/code&gt;这种数据结构经常利用在“如何快速定位并获取到Top N最热门的xxx”，通常的做法如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/stack_heap/heap1.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;内存中的”stack和heap“与数据结构中的”stack和heap“的联系&quot;&gt;&lt;a href=&quot;#内存中的”stack和heap“与数据结构中的”stack和heap“的联系&quot; class=&quot;headerlink&quot; title=&quot;内存中的”stack和heap“与数据结构中的”stack和heap“的联系&quot;/&gt;内存中的”&lt;code&gt;stack&lt;/code&gt;和&lt;code&gt;heap&lt;/code&gt;“与数据结构中的”&lt;code&gt;stack&lt;/code&gt;和&lt;code&gt;heap&lt;/code&gt;“的联系&lt;/h3&gt;&lt;p&gt;一句话总结：进程内存中的&lt;code&gt;栈区(stack)&lt;/code&gt;使用的数据结构就是&lt;code&gt;stack&lt;/code&gt;，内存中的&lt;code&gt;heap&lt;/code&gt;和数据结构中的&lt;code&gt;heap&lt;/code&gt;则毫无关系。&lt;/p&gt;
&lt;p&gt;看如下C代码：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;; &lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   ret = add(a, b);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;, ret);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   reuturn &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sum = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   sum = x + y;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sum;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;以上代码在栈区中的数据是这样的：&lt;br/&gt;&lt;img src=&quot;/img/stack_heap/stack1.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还及得上文中提到的：“进程内存中只有&lt;code&gt;栈区(stack)&lt;/code&gt;数据是由高位向低位增长的，其余的均为由低位向高位增长吗？”&lt;/p&gt;
&lt;p&gt;栈区用的数据结构是栈，函数变量的销毁和返回顺序用逆恰好符合stack先进后出的特点，我觉得这是&lt;code&gt;栈区(stack)&lt;/code&gt;逆序增长很重要的一点。&lt;/p&gt;
&lt;p&gt;但是，最根本的原因还是在于：历史遗留问题。请看下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/stack_heap/stack2.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;在当初那个内存空间及其短缺的年代，你认为左图还是右图更适合“缓冲区”？因为&lt;code&gt;stack&lt;/code&gt;区域和&lt;code&gt;heap&lt;/code&gt;区域大小都是动态分配的，都有“不确定性”，很显然，左图发生&lt;code&gt;堆栈重叠&lt;/code&gt;更小，且更适合内存的充分利用。&lt;/p&gt;
&lt;h2 id=&quot;Go变量的位置&quot;&gt;&lt;a href=&quot;#Go变量的位置&quot; class=&quot;headerlink&quot; title=&quot;Go变量的位置&quot;/&gt;Go变量的位置&lt;/h2&gt;&lt;p&gt;我们在写C、PHP、Java的时候，可以很容易的知道，所写的变量所在的位置：带&lt;code&gt;new&lt;/code&gt;、&lt;code&gt;malloc&lt;/code&gt;等字段的，那一定是在堆上分配了，至于后续GC怎么处理，有没有引用继续关联，堆有没与释放，程序是否存在内存泄露…这都是后续处理的问题了；变量的存储位置是妥妥的堆上了。但是，在用Go的时候要注意，&lt;code&gt;new&lt;/code&gt;、&lt;code&gt;make&lt;/code&gt;等等关键字都不好使，Go变量的位置不是由写程序的程序员来决定的，而是Go自行处理；所以可能你的变量是&lt;code&gt;new&lt;/code&gt;出来的，但是，最终也不一定分配到堆上，很可能是分配在栈上。&lt;/p&gt;
&lt;p&gt;Go把变量的位置在哪儿这件事对程序员“隐藏”了，Go自行处理；因为Go认为：变量的存储位置，会对程序的性能有一定影响，而Go是计划打造对性能有极致要求的程序，因而自己管了。&lt;br/&gt;Go是这么管的：&lt;br/&gt;首先，栈&lt;code&gt;stack&lt;/code&gt;上的效率肯定是比堆要高的，这算是常识；Go在编译期会对每一个函数变量做判断，如果不能够判断此函数中的变量在返回之后是否仍被引用到，就给把变量扔堆&lt;code&gt;heap&lt;/code&gt;上，否则，就扔栈&lt;code&gt;stack&lt;/code&gt;上。但是注意：如果变量非常大，还是会扔到堆&lt;code&gt;heap&lt;/code&gt;上。&lt;/p&gt;
&lt;h3 id=&quot;逃逸分析&quot;&gt;&lt;a href=&quot;#逃逸分析&quot; class=&quot;headerlink&quot; title=&quot;逃逸分析&quot;/&gt;逃逸分析&lt;/h3&gt;&lt;p&gt;我们是否有办法知道我们写的Go程序中变量的位置呢？&lt;br/&gt;答案是有的，Go向开发者提供了变量逃逸分析的工具 &lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;go&lt;/span&gt; build -gcflags &lt;span class=&quot;string&quot;&gt;&#x27;-m -l&#x27;&lt;/span&gt; main.&lt;span class=&quot;keyword&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// 这里的main.go也可以是某个具体的二进制应用程序&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;下面对如下代码进行逃逸分析：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; (&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    a:= &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    b := &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    ret := add(a, b)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    fmt.Println(ret)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(x,y &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;span class=&quot;title&quot;&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    sum := x + y&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sum&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;分析结果:&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;./main.&lt;span class=&quot;keyword&quot;&gt;go&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;: main ... argument does not escape&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;./main.&lt;span class=&quot;keyword&quot;&gt;go&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;: ret escapes to heap&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;


        &lt;/div&gt;
      &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>71e6d2017e6f274670ae49e2797d9801</guid>
<title>RabbitMQ 的 6 种工作模式</title>
<link>https://toutiao.io/k/w8a1cdp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h3&gt;1、RabbitMQ的 6 种工作模式&lt;/h3&gt;&lt;p&gt;先以 java 应用程序的方式连接 RabbitMQ ，后期再考虑与 Spring Boot 整合工作。&lt;/p&gt;&lt;p&gt;生产者和消费者、RabbitMQ 可以不用位于同一个主机，一个应用程序即可以生产者，也可以是消费者。&lt;/p&gt;&lt;p&gt;&lt;span&gt;交换器类型&lt;/span&gt;&lt;/p&gt;&lt;p&gt;direct：根据路由键匹配队列发送消息。&lt;br/&gt;topic：根据路由键匹配队列，可以全匹配和模糊匹配。&lt;br/&gt;headers：&lt;br/&gt;fanout：消息广播。&lt;/p&gt;&lt;p&gt;&lt;span&gt;pom文件&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;com.rabbitmq&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;amqp-client&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span&gt;5.12.0&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;h4&gt;1.1、工作队列模式（Work queues）&lt;/h4&gt;&lt;p&gt;竞争者的消费模式。&lt;/p&gt;&lt;p&gt;&lt;span&gt;流程图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.33433734939759036&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dsdicfViaRhptNAS0JTwCWZL9iacUaG7FHyrjxnG59iajONwQ3GwpzITSPSvG7Y5Mrk0kHCKHCSCn6UKOtS2ZKtocA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;332&quot;/&gt;&lt;/p&gt;&lt;p&gt;这里虽然交换器是空的，但是 RabbitMQ 有一个默认的交换器，如果不设置则会发送到默认的交换器上去。&lt;/p&gt;&lt;p&gt;&lt;span&gt;特点&lt;/span&gt;&lt;/p&gt;&lt;p&gt;如果存在多个消费者，那么 mq 将会以轮询的方式发送消息，并且消息只能被消费一次。&lt;/p&gt;&lt;p&gt;&lt;span&gt;代码演示&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;生产者&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Producer&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; TEST_QUEUE &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;test_queue&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;[]&lt;/span&gt;&lt;span&gt; args&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Exception&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;//        创建一个连接工厂&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;ConnectionFactory&lt;/span&gt;&lt;span&gt; connectionFactory &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;ConnectionFactory&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;//        设置连接属性&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        connectionFactory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setHost&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;localhost&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        connectionFactory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setUsername&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;XX&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        connectionFactory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setPassword&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;CC$&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt; connection &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; connectionFactory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newConnection&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;             &lt;/span&gt;&lt;span&gt;Channel&lt;/span&gt;&lt;span&gt; channel &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; connection&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;createChannel&lt;/span&gt;&lt;span&gt;())&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;//            声明队列&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            channel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;queueDeclare&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;TEST_QUEUE&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; message &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;Hello World!&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;//            发送消息&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            channel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;basicPublish&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; TEST_QUEUE&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;MessageProperties&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;PERSISTENT_TEXT_PLAIN&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; message&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getBytes&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;StandardCharsets&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;UTF_8&lt;/span&gt;&lt;span&gt;));&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot; [x] Sent &#x27;&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; message &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;&#x27;&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;解释一下以上部分方法的参数作用：&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【队列名称】&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【是否持久化，如果为&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;，则&lt;/span&gt;&lt;span&gt; mq &lt;/span&gt;&lt;span&gt;重启后，消息队列还在。】&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【是否是排他队列，如果一个队列被声明为排他队列，该队列仅对首次申明它的连接可见，并在连接断开时自动删除。这里需要注意三点：&lt;/span&gt;&lt;span&gt;1.&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;排他队列是基于连接可见的，同一连接的不同信道是可以同时访问同一连接创建的排他队列；&lt;/span&gt;&lt;span&gt;2.&lt;/span&gt;&lt;span&gt;“首次”，如果一个连接已经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同；&lt;/span&gt;&lt;span&gt;3.&lt;/span&gt;&lt;span&gt;即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除的，这种队列适用于一个客户端发送读取消息的应用场景。】&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【自动删除，如果该队列没有任何订阅的消费者的话，该队列会被自动删除。这种队列适用于临时队列。】&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【附加参数】&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Queue&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;DeclareOk&lt;/span&gt;&lt;span&gt; queueDeclare&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; queue&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; durable&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; exclusive&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; autoDelete&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;Map&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; arguments&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【交换器名称】&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【路由键】&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【当&lt;/span&gt;&lt;span&gt;mandatory&lt;/span&gt;&lt;span&gt;标志位设置为&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;时，如果&lt;/span&gt;&lt;span&gt;exchange&lt;/span&gt;&lt;span&gt;根据自身类型和消息&lt;/span&gt;&lt;span&gt;routeKey&lt;/span&gt;&lt;span&gt;无法找到一个符合条件的&lt;/span&gt;&lt;span&gt;queue&lt;/span&gt;&lt;span&gt;，那么会调用&lt;/span&gt;&lt;span&gt;basic&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;方法将消息返回给生产者（&lt;/span&gt;&lt;span&gt;Basic&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Content&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;Header&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Content&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;Body&lt;/span&gt;&lt;span&gt;）；当&lt;/span&gt;&lt;span&gt;mandatory&lt;/span&gt;&lt;span&gt;设置为&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;时，出现上述情形&lt;/span&gt;&lt;span&gt;broker&lt;/span&gt;&lt;span&gt;会直接将消息扔掉。默认是&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;】&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【当&lt;/span&gt;&lt;span&gt;immediate&lt;/span&gt;&lt;span&gt;标志位设置为&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;时，如果&lt;/span&gt;&lt;span&gt;exchange&lt;/span&gt;&lt;span&gt;在将消息路由到&lt;/span&gt;&lt;span&gt;queue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;)时发现对于的&lt;/span&gt;&lt;span&gt;queue&lt;/span&gt;&lt;span&gt;上么有消费者，那么这条消息不会放入队列中。当与消息&lt;/span&gt;&lt;span&gt;routeKey&lt;/span&gt;&lt;span&gt;关联的所有&lt;/span&gt;&lt;span&gt;queue&lt;/span&gt;&lt;span&gt;（一个或者多个）都没有消费者时，该消息会通过&lt;/span&gt;&lt;span&gt;basic&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;方法返还给生产者。默认是&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;】&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【消息的附加属性】&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; basicPublish&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; exchange&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; routingKey&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; mandatory&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; immediate&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;BasicProperties&lt;/span&gt;&lt;span&gt; props&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[]&lt;/span&gt;&lt;span&gt; body&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;设置消息的持久化，&lt;/span&gt;&lt;span&gt;deliveryMode &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;为不持久，&lt;/span&gt;&lt;span&gt;deliveryMode &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;为持久，&lt;/span&gt;&lt;span&gt;mq&lt;/span&gt;&lt;span&gt;重启后消息不会丢失。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;BasicProperties&lt;/span&gt;&lt;span&gt; PERSISTENT_TEXT_PLAIN &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;BasicProperties&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;text/plain&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;消费者&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Consumer&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; TEST_QUEUE &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;test_queue&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;[]&lt;/span&gt;&lt;span&gt; args&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Exception&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;ConnectionFactory&lt;/span&gt;&lt;span&gt; factory &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;ConnectionFactory&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        factory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setHost&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;localhost&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        factory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setUsername&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;XXX&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        factory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setPassword&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;XXX$&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt; connection &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; factory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newConnection&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;Channel&lt;/span&gt;&lt;span&gt; channel &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; connection&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;createChannel&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;//        确保该队列存在&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        channel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;queueDeclare&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;TEST_QUEUE&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot; [*] Waiting for messages. To exit press CTRL+C&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;//        消费端能接收的消息数&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        channel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;basicQos&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;DeliverCallback&lt;/span&gt;&lt;span&gt; deliverCallback &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;consumerTag&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; delivery&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; message &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;delivery&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getBody&lt;/span&gt;&lt;span&gt;(),&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;StandardCharsets&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;UTF_8&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot; [x] Received &#x27;&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; message &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;&#x27;&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;                &lt;/span&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;sleep&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;InterruptedException&lt;/span&gt;&lt;span&gt; e&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;                e&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;printStackTrace&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;                &lt;/span&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot; [x] Done&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;// 手动消息应答&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;                channel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;basicAck&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;delivery&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getEnvelope&lt;/span&gt;&lt;span&gt;().&lt;/span&gt;&lt;span&gt;getDeliveryTag&lt;/span&gt;&lt;span&gt;(),&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        channel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;basicConsume&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;TEST_QUEUE&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; deliverCallback&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; consumerTag &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{});&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;ack 机制：&lt;/p&gt;&lt;p&gt;RabbitMQ 分手动 ack 和自动 ack，如果设置为自动 ack，那么 mq 在发送消息后会立即删除消息，如果消费者消费消息出现异常则消息不会重新发送，因为消息已经被删除了，同时如果消费者被异常终止，则消费者所接收到未处理的消息则会丢失。而手动 ack 则会等待 ack 确认之后才会删除消息，如果 channel 被关闭，或者 Connection 被关闭，或者 TCP 连接丢失，则消息会进行重新排队。&lt;/p&gt;&lt;p&gt;方法参数作用：&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【消息内容限制，单位是字节】&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【接收&lt;/span&gt;&lt;span&gt;mq&lt;/span&gt;&lt;span&gt;的消息数量限制。假设有两个消费者，一个定义当前参数未设置为&lt;/span&gt;&lt;span&gt; A&lt;/span&gt;&lt;span&gt;，一个设置&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;为&lt;/span&gt;&lt;span&gt; B&lt;/span&gt;&lt;span&gt;，当生产者发送&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;条消息给消费者时，&lt;/span&gt;&lt;span&gt;B &lt;/span&gt;&lt;span&gt;轮询接收到了&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;条消息后将停止消息接收，直到轮询时&lt;/span&gt;&lt;span&gt; B &lt;/span&gt;&lt;span&gt;可再次接收消息时再次接收】&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【是否将当前设置应用于整个&lt;/span&gt;&lt;span&gt; channel &lt;/span&gt;&lt;span&gt;而不是每个消费者】&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; basicQos&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; prefetchSize&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; prefetchCount&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;basicQos 配合 autoAck = false&lt;code&gt;channel.basicConsume(TEST_QUEUE, false, deliverCallback, consumerTag -&amp;gt; {});&lt;/code&gt;使用。如果不将 autoAck 设置为 false，那么 basicQos 的设置是无效的，因为 mq 不会查看消费者未确认的消息数，它只会不停的发送消息给消费者。&lt;/p&gt;&lt;h4&gt;1.2、发布订阅模式（Publish/Subscribe）&lt;/h4&gt;&lt;p&gt;RabbitMQ 消息传递的核心是生产者从不将消息直接发送到队列中，实际上生产者根本不知道是否将消息传递到其他队列中。生产者只能将消息发送到交换机。&lt;/p&gt;&lt;p&gt;一次向多个消费者发送消息。&lt;/p&gt;&lt;h5&gt;1.2.1、流程图&lt;/h5&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.48632218844984804&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dsdicfViaRhptNAS0JTwCWZL9iacUaG7FHyayag16ZTSSYbHjEj1P6FIUpfhib6qkxpZwbSXrVj79m2Jdvdvr5Nk7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;329&quot;/&gt;&lt;/p&gt;&lt;h5&gt;1.2.2、特点&lt;/h5&gt;&lt;p&gt;向多个消费者发送消息&lt;/p&gt;&lt;p&gt;如果交换机上没有队列绑定，则发送消息后消息会丢失。&lt;/p&gt;&lt;p&gt;fanout 交换器对于 routingKey 的值将会忽略。&lt;/p&gt;&lt;h5&gt;1.2.3、代码演示&lt;/h5&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Producer&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; EXCHANGE_NAME &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;[]&lt;/span&gt;&lt;span&gt; args&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Exception&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;//        创建一个连接工厂&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;ConnectionFactory&lt;/span&gt;&lt;span&gt; connectionFactory &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;ConnectionFactory&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;//        设置连接属性&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        connectionFactory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setHost&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;localhost&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        connectionFactory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setUsername&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;XX&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        connectionFactory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setPassword&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;CC$&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt; connection &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; connectionFactory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newConnection&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;             &lt;/span&gt;&lt;span&gt;Channel&lt;/span&gt;&lt;span&gt; channel &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; connection&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;createChannel&lt;/span&gt;&lt;span&gt;())&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;//            声明交换机&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            channel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;exchangeDeclare&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;EXCHANGE_NAME&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;fanout&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; message &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;send message 3&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            channel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;basicPublish&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;EXCHANGE_NAME&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; message&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getBytes&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;StandardCharsets&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;UTF_8&lt;/span&gt;&lt;span&gt;));&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot; [x] Sent &#x27;&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; message &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;&#x27;&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Consumer&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; EXCHANGE_NAME &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;[]&lt;/span&gt;&lt;span&gt; args&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Exception&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;ConnectionFactory&lt;/span&gt;&lt;span&gt; factory &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;ConnectionFactory&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        factory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setHost&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;localhost&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        factory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setUsername&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;cc&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        factory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setPassword&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;cc$&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt; connection &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; factory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newConnection&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;Channel&lt;/span&gt;&lt;span&gt; channel &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; connection&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;createChannel&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;//        确保该交换器存在&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        channel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;exchangeDeclare&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;EXCHANGE_NAME&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;fanout&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;//        获取一个非持久、排他的、自动删除的随时队列&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; queueName &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; channel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;queueDeclare&lt;/span&gt;&lt;span&gt;().&lt;/span&gt;&lt;span&gt;getQueue&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;//        队列绑定交换机&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        channel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;queueBind&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;queueName&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; EXCHANGE_NAME&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot; [*] Waiting for messages. To exit press CTRL+C&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;DeliverCallback&lt;/span&gt;&lt;span&gt; deliverCallback &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;consumerTag&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; delivery&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; message &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;delivery&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getBody&lt;/span&gt;&lt;span&gt;(),&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;StandardCharsets&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;UTF_8&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot; [x] Received &#x27;&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; message &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;&#x27;&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        channel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;basicConsume&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;queueName&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; deliverCallback&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; consumerTag &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;});&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;我们先启动 Producer 然后再启动 Consumer 发现消费者那边没有接收到消息，说明在没有队列监听的时候，消息是丢失了。&lt;/p&gt;&lt;p&gt;如果我们将队列修改成这个 &lt;code&gt;channel.queueDeclare(QUEUE_NAME,false,false,false,null);&lt;/code&gt;，然后启动两个相同的消费者发现，消息是存在竞争机制的，因为消息被轮询发给了不同的消费者。&lt;/p&gt;&lt;h4&gt;1.3、路由模式（Routing）&lt;/h4&gt;&lt;h5&gt;1.3.1、流程图&lt;/h5&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.40425531914893614&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dsdicfViaRhptNAS0JTwCWZL9iacUaG7FHyt7C6wAOb2c5qAzOgBWlkicK1GHyHialueqX0GHibDiaZmaOWpeZqwzN4nw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;423&quot;/&gt;&lt;/p&gt;&lt;h5&gt;1.3.2、特点&lt;/h5&gt;&lt;p&gt;根据路由键匹配发送消息到队列。&lt;/p&gt;&lt;p&gt;一个路由键可以绑定多个队列，一个队列也可以绑定多个路由键。&lt;/p&gt;&lt;h5&gt;1.3.3、代码演示&lt;/h5&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Producer&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; EXCHANGE_NAME &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;direct_log&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;[]&lt;/span&gt;&lt;span&gt; args&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Exception&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;//        创建一个连接工厂&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;ConnectionFactory&lt;/span&gt;&lt;span&gt; connectionFactory &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;ConnectionFactory&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;//        设置连接属性&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        connectionFactory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setHost&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;localhost&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        connectionFactory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setUsername&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;cc&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        connectionFactory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setPassword&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;cc$&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt; connection &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; connectionFactory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newConnection&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;             &lt;/span&gt;&lt;span&gt;Channel&lt;/span&gt;&lt;span&gt; channel &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; connection&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;createChannel&lt;/span&gt;&lt;span&gt;())&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;//            声明交换机&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            channel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;exchangeDeclare&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;EXCHANGE_NAME&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;BuiltinExchangeType&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;DIRECT&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; message &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;send message 4-error&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            channel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;basicPublish&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;EXCHANGE_NAME&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;error&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; message&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getBytes&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;StandardCharsets&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;UTF_8&lt;/span&gt;&lt;span&gt;));&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot; [x] Sent &#x27;&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; message &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;&#x27;&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Consumer&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; EXCHANGE_NAME &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;direct_log&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;[]&lt;/span&gt;&lt;span&gt; args&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Exception&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;ConnectionFactory&lt;/span&gt;&lt;span&gt; factory &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;ConnectionFactory&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        factory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setHost&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;localhost&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        factory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setUsername&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;cc&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        factory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setPassword&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;cc$&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt; connection &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; factory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newConnection&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;Channel&lt;/span&gt;&lt;span&gt; channel &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; connection&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;createChannel&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;//        确保该交换器存在&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        channel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;exchangeDeclare&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;EXCHANGE_NAME&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;BuiltinExchangeType&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;DIRECT&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;//        获取一个非持久、排他的、自动删除的随时队列&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; queueName &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; channel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;queueDeclare&lt;/span&gt;&lt;span&gt;().&lt;/span&gt;&lt;span&gt;getQueue&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;//        队列绑定交换机&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        channel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;queueBind&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;queueName&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; EXCHANGE_NAME&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;error&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot; [*] Waiting for messages. To exit press CTRL+C&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;DeliverCallback&lt;/span&gt;&lt;span&gt; deliverCallback &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;consumerTag&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; delivery&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; message &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;delivery&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getBody&lt;/span&gt;&lt;span&gt;(),&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;StandardCharsets&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;UTF_8&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot; [x] Received &#x27;&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; message &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;&#x27;&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        channel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;basicConsume&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;queueName&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; deliverCallback&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; consumerTag &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;});&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;更改消费者的队列绑定的路由键，启动不同的客户端，然后更改生产者的路由键发送多条消息可以看到生产者发送到了相匹配路由键的队列中去了。同时如果在交换机中不存在绑定队列，则消息会丢失。&lt;/p&gt;&lt;h4&gt;1.4、通配符模式（Topics）&lt;/h4&gt;&lt;h5&gt;1.4.1、流程图&lt;/h5&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4033018867924528&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dsdicfViaRhptNAS0JTwCWZL9iacUaG7FHyQ0oHoHCNZJVScP9LwiaUQPHORNLzM73LhIyMDlSyhYTQwgasZ0Fa0OA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;424&quot;/&gt;&lt;/p&gt;&lt;h5&gt;1.4.2、特点&lt;/h5&gt;&lt;p&gt;&lt;code&gt;*&lt;/code&gt; 可以匹配一个单词，&lt;code&gt;#&lt;/code&gt; 匹配多个单词，路由键以 “.” 分割，比如 test.log 的路由键可以进入 &lt;code&gt;*.log&lt;/code&gt; 的队列，test.log.user 可以进入 &lt;code&gt;test.#&lt;/code&gt; 的队列而匹配不了 &lt;code&gt;test.*&lt;/code&gt;的队列。&lt;/p&gt;&lt;p&gt;如果不填 &lt;code&gt;*、#&lt;/code&gt;那么就和 direct 交换器一样了。&lt;/p&gt;&lt;p&gt;注意是消费者的路由键绑定模糊匹配的key。&lt;/p&gt;&lt;h5&gt;1.4.3、代码演示&lt;/h5&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Producer&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; EXCHANGE_NAME &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;topic_log&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;[]&lt;/span&gt;&lt;span&gt; args&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Exception&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;//        创建一个连接工厂&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;ConnectionFactory&lt;/span&gt;&lt;span&gt; connectionFactory &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;ConnectionFactory&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;//        设置连接属性&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        connectionFactory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setHost&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;localhost&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        connectionFactory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setUsername&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;rr&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        connectionFactory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setPassword&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;rr$&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt; connection &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; connectionFactory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newConnection&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;             &lt;/span&gt;&lt;span&gt;Channel&lt;/span&gt;&lt;span&gt; channel &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; connection&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;createChannel&lt;/span&gt;&lt;span&gt;())&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;//            声明交换机&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            channel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;exchangeDeclare&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;EXCHANGE_NAME&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;BuiltinExchangeType&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;TOPIC&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; message &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;send message 5-error&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            channel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;basicPublish&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;EXCHANGE_NAME&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;test.error.log&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; message&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getBytes&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;StandardCharsets&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;UTF_8&lt;/span&gt;&lt;span&gt;));&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot; [x] Sent &#x27;&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; message &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;&#x27;&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Consumer&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; EXCHANGE_NAME &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;topic_log&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;[]&lt;/span&gt;&lt;span&gt; args&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Exception&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;ConnectionFactory&lt;/span&gt;&lt;span&gt; factory &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;ConnectionFactory&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        factory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setHost&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;localhost&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        factory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setUsername&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;ff&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        factory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setPassword&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;ff$&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt; connection &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; factory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newConnection&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;Channel&lt;/span&gt;&lt;span&gt; channel &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; connection&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;createChannel&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;//        确保该交换器存在&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        channel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;exchangeDeclare&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;EXCHANGE_NAME&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;BuiltinExchangeType&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;TOPIC&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;//        获取一个非持久、排他的、自动删除的随时队列&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; queueName &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; channel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;queueDeclare&lt;/span&gt;&lt;span&gt;().&lt;/span&gt;&lt;span&gt;getQueue&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;//        队列绑定交换机&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        channel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;queueBind&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;queueName&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; EXCHANGE_NAME&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;test.*.log&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot; [*] Waiting for messages. To exit press CTRL+C&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;DeliverCallback&lt;/span&gt;&lt;span&gt; deliverCallback &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;consumerTag&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; delivery&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; message &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;delivery&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getBody&lt;/span&gt;&lt;span&gt;(),&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;StandardCharsets&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;UTF_8&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot; [x] Received &#x27;&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; message &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;&#x27;&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        channel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;basicConsume&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;queueName&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; deliverCallback&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; consumerTag &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;});&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;以上与 direct 的区别是只将交换器类型换成了 topic，并且消费者的路由键加了一个模糊匹配的规则。&lt;/p&gt;&lt;h3&gt;2、模式总结&lt;/h3&gt;&lt;p&gt;几种工作模式差不多就是对应几种交换器，并且如果一个队列里面存在多个消费者，那么都会有竞争消费的情况。交换器的匹配功能分别为广播、全匹配路由键与模糊匹配路由键。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;更多内容请查看 https://www.nblogs.cn/doc/rabbitmq/&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ac3fd580fdcd311232f5542e6c76faa7</guid>
<title>闲鱼是如何利用 RxJava 提升异步编程能力的</title>
<link>https://toutiao.io/k/269bwr7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;RxJava是Java对于反应式编程的一个实现框架，是一个基于事件的、提供实现强大且优雅的异步调用程序的代码库。18年以来，由淘宝技术部发起的应用架构升级项目，希望通过反应式架构、全异步化的改造，提升系统整体性能和机器资源利用率，减少网络延时，资源的重复使用，并为业务快速创新提供敏捷的架构支撑。在闲鱼的基础链路诸如商品批量更新、订单批量查询等，都利用了RxJava的异步编程能力。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过，RxJava是入门容易精通难，一不小心遍地坑。今天来一起看下RxJava的使用方式、基本原理、注意事项。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;开始之前&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;让我们先看下，使用RxJava之前，我们曾经写过的回调代码存在的痛点。&lt;br/&gt;当我们的应用需要处理用户事件、异步调用时，随着流式事件的复杂性和处理逻辑的复杂性的增加，代码的实现难度将爆炸式增长。比如我们有时需要处理多个事件流的组合、处理事件流的异常或超时、在事件流结束后做清理工作等，如果需要我们从零实现，势必要小心翼翼地处理回调、监听、并发等很多棘手问题。&lt;br/&gt;还有一个被称作“回调地狱”的问题，描述的是代码的不可读性。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;Code 1.1&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-backh=&quot;221&quot; data-backw=&quot;316&quot; data-ratio=&quot;0.7028301886792453&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/DUwiayJ0Mj1Hl3iaKGOZc4wsWQhUoByP2nZFLlBehQe5jjmIjlreET4pHP1iaokSKby0MK4KhTcBB0Qa3OnNcsSew/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;848&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;以上js代码有两个明显槽点：1.由于传入的层层回调方法，代码结尾出现一大堆的 }) ；2. 代码书写的顺序与代码执行的顺序相反：后面出现回调函数会先于之前行的代码先执行。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而如果使用了RxJava，我们处理回调、异常等将得心应手。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引入RxJava&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;假设现在要异步地获得一个用户列表，然后将结果进行处理，比如展示到ui或者写到缓存，我们使用RxJava后代码如下：&lt;br/&gt;Code 2.1&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span&gt;Observable&amp;lt;&lt;span&gt;Object&lt;/span&gt;&amp;gt; observable = Observable.create(&lt;span&gt;new&lt;/span&gt; ObservableOnSubscribe&amp;lt;&lt;span&gt;Object&lt;/span&gt;&amp;gt;() {&lt;br/&gt;    @Override&lt;br/&gt;    &lt;span&gt;public void subscribe&lt;span&gt;(@NotNull ObservableEmitter&amp;lt;Object&amp;gt; emitter)&lt;/span&gt; throws Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.out.println&lt;/span&gt;(&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;.currentThread&lt;/span&gt;()&lt;span&gt;.getName&lt;/span&gt;() + &quot;&lt;span&gt;----TestRx&lt;/span&gt;&lt;span&gt;.subscribe&lt;/span&gt;&quot;);&lt;br/&gt;        List&lt;span&gt;&amp;lt;UserDo&amp;gt;&lt;/span&gt; result = userService.getAllUser();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (UserDo st : result) {emitter.onNext(st);}&lt;br/&gt;    }&lt;br/&gt;});&lt;br/&gt;Observable&amp;lt;String&amp;gt; &lt;span&gt;map&lt;/span&gt; = observable.&lt;span&gt;map&lt;/span&gt;(s -&amp;gt; s.toString());&lt;br/&gt;&lt;span&gt;// 创建订阅关系&lt;/span&gt;&lt;br/&gt;&lt;span&gt;map&lt;/span&gt;.subscribe(o -&amp;gt; System.out.println(Thread.currentThread().getName() + &lt;span&gt;&quot;----sub1 = &quot;&lt;/span&gt; + o)&lt;span&gt;/*更新到ui*/&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;map&lt;/span&gt;.subscribe(o -&amp;gt; System.out.println(Thread.currentThread().getName() + &lt;span&gt;&quot;----sub2 = &quot;&lt;/span&gt; + o)&lt;span&gt;/*写缓存*/&lt;/span&gt;,&lt;br/&gt;                     e-&amp;gt; System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;e = &quot;&lt;/span&gt; + e)),&lt;br/&gt;                     ()-&amp;gt;System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;finish&quot;&lt;/span&gt;)));&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;userService.getAllUser()是一个普通的同步方法，但是我们把它包到了一个Observable中，当有结果返回时，将user逐个发送至监听者。第一个监听者更新ui，第二个监听者写到缓存。并且当上游发生异常时，进行打印；在事件流结束时，打印finish。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外还可以很方便的配置上游超时时间、调用线程池、fallback结果等，是不是非常强大。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;需要注意的是，RxJava代码就像上面例子中看起来很容易上手，可读性也很强，但是如果理解不充分，很容易出现意想不到的bug：初学者可能会认为，上面的代码中，一个user列表返回后，每个元素会被异步地发送给两个下游的观察者，这两个观察者在各自的线程内打印结果。但事实却不是这样：userService.getAllUser()会被调用两次(每当建立订阅关系时方法getAllUser()都会被重新调用)，而user列表被查询出后，会&lt;strong&gt;同步&lt;/strong&gt;的发送给两个观察者，观察者也是&lt;strong&gt;同步&lt;/strong&gt;地打印出每个元素。即sub1 = user1，sub1 = user2，sub1 = user3，sub2 = user1，sub2 = user2，sub2 = user3。&lt;br/&gt;可见，如果没有其他配置，RxJava&lt;strong&gt;默认是同步阻塞&lt;/strong&gt;的！！！那么，我们如何使用它的异步非阻塞能力呢，我们接着往下看。&lt;br/&gt;Code 2.2&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span&gt;Observable&lt;br/&gt;    .fromCallable(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; -&amp;gt;&lt;/span&gt; {&lt;br/&gt;         &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.out.println&lt;/span&gt;(&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;.currentThread&lt;/span&gt;()&lt;span&gt;.getName&lt;/span&gt;() + &quot;&lt;span&gt;----observable&lt;/span&gt; &lt;span&gt;fromCallable&lt;/span&gt;&quot;);&lt;br/&gt;         Thread.sleep(&lt;span&gt;1000&lt;/span&gt;); &lt;span&gt;//  imitate expensive computation&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;event&quot;&lt;/span&gt;;&lt;br/&gt;     })&lt;br/&gt;    &lt;span&gt;.subscribeOn&lt;/span&gt;(&lt;span&gt;Schedulers&lt;/span&gt;&lt;span&gt;.io&lt;/span&gt;())&lt;br/&gt;    &lt;span&gt;.observeOn&lt;/span&gt;(&lt;span&gt;Schedulers&lt;/span&gt;&lt;span&gt;.single&lt;/span&gt;())&lt;br/&gt;    .&lt;span&gt;map&lt;/span&gt;(i-&amp;gt;{&lt;br/&gt;        &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.out.println&lt;/span&gt;(&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;.currentThread&lt;/span&gt;()&lt;span&gt;.getName&lt;/span&gt;() + &quot;&lt;span&gt;----observable&lt;/span&gt; &lt;span&gt;map&lt;/span&gt;&quot;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; i;&lt;br/&gt;    })&lt;br/&gt;    &lt;span&gt;.observeOn&lt;/span&gt;(&lt;span&gt;Schedulers&lt;/span&gt;&lt;span&gt;.newThread&lt;/span&gt;())&lt;br/&gt;    .subscribe(str -&amp;gt; System.&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread().getName() + &lt;span&gt;&quot;----inputStr=&quot;&lt;/span&gt; + str));&lt;br/&gt;&lt;br/&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;.out.println&lt;/span&gt;(&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;.currentThread&lt;/span&gt;()&lt;span&gt;.getName&lt;/span&gt;() + &quot;&lt;span&gt;----end&lt;/span&gt;&quot;);&lt;br/&gt;&lt;br/&gt;Thread.sleep(&lt;span&gt;2000&lt;/span&gt;); &lt;span&gt;// &amp;lt;--- wait for the flow to finish. In RxJava the default Schedulers run on daemon threads&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们用Observable.fromCallable()代替code2.1中最底层的Observable.create方法，来创建了一个Observable(即被观察者)。fromCallable方法创建的是一个lazy的Observable，只有当有人监听它时，传入的代码才被执行。(关于这一点，我们后面会讲，这里只是为了展示有很多种创建Observable的方式）。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;然后通过subscribeOn(Schedulers.io())指定了被观察者执行的线程池。observeOn(Schedulers.single())指定了下游观察者(map方法实际也是一个观察者)执行的线程池。map方法如同很多流式编程api一样，将上游的每个元素转化成另一个元素。最后又通过observeOn(Schedulers.newThread())制定了当前下游的观察者，即最后的subscribe中传入的观察者(lambda方式)执行的线程池。&lt;br/&gt;上面的代码执行后，通过打印的线程名可以看出，被观察者、map、观察者均是不同的线程，并且，主线程最后的&quot;end&quot;会先执行，也就是实现了异步非阻塞。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;使用方式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;本文不是RxJava的接口文档，不会详细介绍每个api，只是简单讲下一些常见或者特殊api，进一步阐述RxJava的能力。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;基本组件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;RxJava的核心原理其实非常简单。可类比观察者模式。&lt;strong&gt;Observable&lt;/strong&gt;是被观察者，作为数据源产生数据。&lt;strong&gt;Observer&lt;/strong&gt;是观察者，消费上游的数据源。&lt;br/&gt;每个Observable可注册多个Observer。但是默认情况下，每当有注册发生时，Observable的生产方法subscribe都会被调用。如果想只生产一次，可以调用Observable.cached方法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;被观察者Observable还有多个变体，如Single、Flowable。Single代表只产生一个元素的数据源。Flowable是支持背压的数据源。通过背压设计，下游监听者可以向上游反馈信息，可以达到控制发送速率的功能。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Observable和Observer是通过装饰器模式层层包装达到从而串联起来。转换API如map等，会创建一个新的ObservableMap（基层自Observable），包装原始的Observable作为source，而在真正执行时，先做转换操作，再发给下游的观察者。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Scheduler&lt;/strong&gt;是RxJava为多线程执行提供的支持类，它将可以将生产者或者消费者的执行逻辑包装成一个Worker，提交到框架提供的公共线程池中，如Schedulers.io()、Schedulers.newThread()等。便于理解，可以将Schedulers类比做线程池，Worker类比做线程池中的线程。可以通过Observable.subscribeOn和Observable.observeOn分别制定被观察者和观察者执行的线程，来达到异步非阻塞。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;RxJava核心架构图如下：&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-backh=&quot;118&quot; data-backw=&quot;314&quot; data-ratio=&quot;0.3739946380697051&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1Hl3iaKGOZc4wsWQhUoByP2niaxb8oJzWZ4YD4o7siaZ7OJnPLiagmLbudMynXtXhYfgHu1DEtmiaSrzJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;746&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;转换API&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;map：见Code 2.2，一对一转换，如同很多流式编程api一样，将上游的每个元素转化成另一个元素&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;flatMap：一对多转换，将上游的每个元素转化成0到多个元素。类比Java8：Stream.flatMap内返回的是stream，Observerable.flatMap内返回的是Observerable。注意，本方法非常强大，很多api底层都是基于此方法。并且由于flatMap返回的多个Observerable是相互独立的，可以基于这个特点，实现并发。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;组合API&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img data-backh=&quot;160&quot; data-backw=&quot;316&quot; data-ratio=&quot;0.509009009009009&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1Hl3iaKGOZc4wsWQhUoByP2nMOaTMfqfPV4mxS6vF8dwmQFOS03WwV5UMPorwfGpZMUTCWzibPtQlQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;444&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;code 3.1&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;//第一个流每1秒输出一个偶数&lt;/span&gt;&lt;br/&gt;Observable&amp;lt;Long&amp;gt; even = Observable.interval(&lt;span&gt;1000&lt;/span&gt;, TimeUnit.MILLISECONDS).&lt;span&gt;map&lt;/span&gt;(i -&amp;gt; i * &lt;span&gt;2L&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;//第二个流每3秒输出一个奇数&lt;/span&gt;&lt;br/&gt;Observable&amp;lt;Long&amp;gt; odd = Observable.interval(&lt;span&gt;3000&lt;/span&gt;, TimeUnit.MILLISECONDS).&lt;span&gt;map&lt;/span&gt;(i -&amp;gt; i * &lt;span&gt;2L&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;//zip也可以传入多个流，这里只传入了两个&lt;/span&gt;&lt;br/&gt;Observable.zip(even, odd, &lt;span&gt;&lt;span&gt;(e, o)&lt;/span&gt; -&amp;gt;&lt;/span&gt; e + &lt;span&gt;&quot;,&quot;&lt;/span&gt; + o).forEach(x -&amp;gt; {&lt;br/&gt;    System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;observer = &quot;&lt;/span&gt; + x);&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;/* 输出如下，可以看到，当某个流有元素到来时，会等待其他所有流都有元素到达时，才会合并处理然后发给下游&lt;br/&gt;&lt;span&gt;observer&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;observer&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;observer&lt;/span&gt; = &lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;observer&lt;/span&gt; = &lt;span&gt;6&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;&lt;br/&gt;...&lt;br/&gt;*/&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;代码code 3.1看起来没什么问题，两个流并发执行，最后用zip等待他们的结果。但是却隐藏了一个很重要的问题：RxJava默认是同步、阻塞的！！当我们想去仿照上面的方式并发发送多个请求，最后用zip监听所有结果时，很容易发先一个诡异的现象, code 3.2的代码中，ob2的代码总是在ob1执行之后才会执行，并不是我们预期的两个请求并发执行。而打印出来的线程名也可以看到，两个Single是在同一个线程中顺序执行的！&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;code 3.2&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;// Single是只返回一个元素的Observable的实现类&lt;/span&gt;&lt;br/&gt;Single&amp;lt;String&amp;gt; ob1 = Single.fromCallable(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; -&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.out.println&lt;/span&gt;(&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;.currentThread&lt;/span&gt;()&lt;span&gt;.getName&lt;/span&gt;() + &quot;&lt;span&gt;----observable&lt;/span&gt; 1&quot;);&lt;br/&gt;        &lt;span&gt;TimeUnit&lt;/span&gt;&lt;span&gt;.SECONDS.sleep&lt;/span&gt;(3);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;userService&lt;/span&gt;&lt;span&gt;.queryById&lt;/span&gt;(1)&lt;span&gt;.getName&lt;/span&gt;();&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;Single&amp;lt;String&amp;gt; ob2 = Single.fromCallable(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; -&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.out.println&lt;/span&gt;(&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;.currentThread&lt;/span&gt;()&lt;span&gt;.getName&lt;/span&gt;() + &quot;&lt;span&gt;----observable&lt;/span&gt; 2&quot;);&lt;br/&gt;        &lt;span&gt;TimeUnit&lt;/span&gt;&lt;span&gt;.SECONDS.sleep&lt;/span&gt;(1);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;userService&lt;/span&gt;&lt;span&gt;.queryById&lt;/span&gt;(1)&lt;span&gt;.getName&lt;/span&gt;();&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;&lt;span&gt;String&lt;/span&gt; s =  Single.zip(ob1, ob2, &lt;br/&gt;                       (e, o) -&amp;gt; {System.&lt;span&gt;out&lt;/span&gt;.println(e + &lt;span&gt;&quot;++++&quot;&lt;/span&gt; + o);&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那为什么code 3.1的两个流能够并发执行呢？阅读源码可以发现zip的实现其实就是先订阅第一个流，再订阅第二个流，那么默认当然是顺序执行。但是通过Observable.interval创建的流，默认会被提交到 Schedulers.computation()提供的线程池中。关于线程池，本文后面会讲解。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;创建API&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;code 3.3&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;// 返回的子类是ObservableCreate&lt;/span&gt;&lt;br/&gt;Observable&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; observable = Observable.create(&lt;span&gt;new&lt;/span&gt; ObservableOnSubscribe&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt;() {&lt;br/&gt;    @Override&lt;br/&gt;    &lt;span&gt;public void subscribe&lt;span&gt;(ObservableEmitter&amp;lt;String&amp;gt; emitter)&lt;/span&gt; throws Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;emitter&lt;/span&gt;.onNext(&lt;span&gt;&quot;event&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;emitter&lt;/span&gt;.onNext(&lt;span&gt;&quot;event2&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;emitter&lt;/span&gt;&lt;span&gt;.onComplete&lt;/span&gt;();&lt;br/&gt;    }&lt;br/&gt;});&lt;br/&gt;&lt;span&gt;// 订阅observable&lt;/span&gt;&lt;br/&gt;observable.subscribe(&lt;span&gt;new&lt;/span&gt; Observer&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt;() {&lt;br/&gt;    @Override&lt;br/&gt;    &lt;span&gt;public void onSubscribe&lt;span&gt;(Disposable d)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.out.println&lt;/span&gt;(&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;.currentThread&lt;/span&gt;()&lt;span&gt;.getName&lt;/span&gt;() + &quot; ,&lt;span&gt;TestRx&lt;/span&gt;&lt;span&gt;.onSubscribe&lt;/span&gt;&quot;);&lt;br/&gt;    }&lt;br/&gt;    @Override&lt;br/&gt;    &lt;span&gt;public void onNext&lt;span&gt;(String s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread().getName() + &lt;span&gt;&quot; ,s = &quot;&lt;/span&gt; + s);&lt;br/&gt;    }&lt;br/&gt;    @Override&lt;br/&gt;    &lt;span&gt;public void onError&lt;span&gt;(Throwable e)&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;    @Override&lt;br/&gt;    &lt;span&gt;public void onComplete&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.out.println&lt;/span&gt;(&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;.currentThread&lt;/span&gt;()&lt;span&gt;.getName&lt;/span&gt;() + &quot; ,&lt;span&gt;TestRx&lt;/span&gt;&lt;span&gt;.onComplete&lt;/span&gt;&quot;);&lt;br/&gt;    }&lt;br/&gt;});&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;just ：Observable.just(&quot;e1&quot;,&quot;e2&quot;); 简单的创建一个Observable，发出指定的n个元素。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;interval：code 3.1已给出示例，创建一个按一定间隔不断产生元素的Observable，默认执行在Schedulers.comutation()提供的线程池中&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;defer：产生一个延迟创建的Observable。有点绕：Observable.create等创建出来的被观察者虽然是延迟执行的，只有有人订阅的时候才会真正开始生成数据。但是创建Observable的方法却是立即执行的。而 Observable.defer方法会在有人订阅的时候才开始创建Observable。如代码Code3.4&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public String myFun&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;String&lt;/span&gt; now = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;().toString();&lt;br/&gt;    System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;myFun = &quot;&lt;/span&gt; + now);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; now;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public void testDefer&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 该代码会立即执行myFun()&lt;/span&gt;&lt;br/&gt;    Observable&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; ob1 = Observable.just(myFun());&lt;br/&gt;    &lt;span&gt;// 该代码会在产生订阅时，才会调用myFun(), 可类比Java8的Supplier接口&lt;/span&gt;&lt;br/&gt;    Observable&amp;lt;String&amp;gt; ob2 = Observable.defer(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; -&amp;gt;&lt;/span&gt; Observable.just(myFun()) ); &lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;基本原理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;RxJava的代码，就是观察者模式+装饰器模式的体现。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Observable.create&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;见代码code 3.3，create方法接收一个ObserverableOnSubscribe接口对象，我们定义了了发送元素的代码，create方法返回一个ObserverableCreate类型对象(继承自Observerable抽象类)。跟进create方法原码，直接返回new出来的ObserverableCreate，它包装了一个source对象，即传入的ObserverableOnSubscribe。&lt;br/&gt;code4.1&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;Observable&amp;lt;T&amp;gt; create(&lt;span&gt;ObservableOnSubscribe&amp;lt;T&amp;gt; source&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        ObjectHelper.requireNonNull(&lt;span&gt;source&lt;/span&gt;, &lt;span&gt;&quot;source is null&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//onAssembly默认直接返回ObservableCreate&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; RxJavaPlugins.onAssembly(new ObservableCreate&amp;lt;T&amp;gt;(&lt;span&gt;source&lt;/span&gt;)); &lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Create方法就这么简单，只需要记住它返回了一个包装了source的Observerble。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4.2 Observerable.subscribe(observer)&lt;br/&gt;看下code3.3中创建订阅关系时(observalbe.subscribe)发生了什么：&lt;br/&gt;code4.2&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;public final void subscribe&lt;span&gt;(Observer&amp;lt;? super T&amp;gt; observer)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;ObjectHelper&lt;/span&gt;.requireNonNull(observer, &lt;span&gt;&quot;observer is null&quot;&lt;/span&gt;);&lt;br/&gt;     &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;         &lt;span&gt;observer&lt;/span&gt; = RxJavaPlugins.&lt;span&gt;on&lt;/span&gt;Subscribe(this, observer);&lt;br/&gt;         &lt;span&gt;ObjectHelper&lt;/span&gt;.requireNonNull(observer, &lt;span&gt;&quot;Plugin returned null Observer&quot;&lt;/span&gt;);&lt;br/&gt;         subscribeActual(observer);&lt;br/&gt;     } &lt;span&gt;catch&lt;/span&gt; (NullPointerException e) {... } &lt;span&gt;catch&lt;/span&gt; (Throwable e) {... }&lt;br/&gt; }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Observable是一个抽象类，定义了subscribe这个final方法，最终会调用subscribeActual(observer)；而subscribeActual是由子类实现的方法，自然我们需要看ObserverableCreate实现的该方法。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;code4.3&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;//ObserverableCreate实现的subscribeActual方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;protected void subscribeActual&lt;span&gt;(Observer&amp;lt;? super T&amp;gt; observer)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    CreateEmitter&lt;span&gt;&amp;lt;T&amp;gt;&lt;/span&gt; parent = new CreateEmitter&lt;span&gt;&amp;lt;T&amp;gt;&lt;/span&gt;(observer);&lt;br/&gt;    &lt;span&gt;observer&lt;/span&gt;&lt;span&gt;.onSubscribe&lt;/span&gt;(&lt;span&gt;parent&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        source.subscribe(&lt;span&gt;parent&lt;/span&gt;); &lt;span&gt;//source是ObservableOnSubscribe，即我们写的生产元素的代码&lt;/span&gt;&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Throwable ex) {...}&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.将观察者observer包装到一个CreateEmitter里。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.调用observer的onSubscribe方法，传入这个emitter。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3.调用source(即生产代码接口)的subscribe方法，传入这个emitter。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第二步中，直接调用了我们写的消费者的onSubscribe方法，很好理解，即创建订阅关系的回调方法。&lt;br/&gt;重点在第三步，source.subscribe(parent); 这个parent是包装了observer的emitter。还记得source就是我们写的发送事件的代码。其中手动调用了emitter.onNext()来发送数据。那么我们CreateEmitter.onNext()做了什么&lt;br/&gt;code4.4&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public void onNext&lt;span&gt;(T t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (t == &lt;span&gt;null&lt;/span&gt;) {...}&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!isDisposed()) { observer.onNext(t); }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;!isDisposed()判断若订阅关系还没取消，则调用observer.onNext(t);这个observer就是我们写的消费者，code 3.3中我们重写了它的onNext方法来print接收到的元素。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;以上就是RxJava最基本的原理，其实逻辑很简单，就是在创建订阅关系的时候，直接调用生产逻辑代码，然后再生产逻辑的onNext中，调用了观察者observer.onNext。时序图如下。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-backh=&quot;167&quot; data-backw=&quot;314&quot; data-ratio=&quot;0.5294906166219839&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1Hl3iaKGOZc4wsWQhUoByP2n683fv2UPWnicqAVwwuOKnGtjzoGU3o2NuYvLlncpOqEAWVnVo7kxUJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;746&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;显然，最基本的原理，完全解耦了和异步回调、多线程的关系。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Observable.map&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;通过最简答的map方法，看下转换api做了什么。&lt;br/&gt;如Code2.1中，调用map方法，传入一个转换函数，可以一对一地将上游的元素转换成另一种类型的元素。&lt;br/&gt;code4.5&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &amp;lt;R&amp;gt; &lt;span&gt;Observable&amp;lt;R&amp;gt; map&lt;span&gt;(Function&amp;lt;? super T, ? extends R&amp;gt; mapper)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;ObjectHelper&lt;/span&gt;.requireNonNull(mapper, &lt;span&gt;&quot;mapper is null&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; RxJavaPlugins.onAssembly(&lt;span&gt;new&lt;/span&gt; ObservableMap&amp;lt;T, R&amp;gt;(&lt;span&gt;this&lt;/span&gt;, mapper));&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;code4.5是Observable定义的final的map方法，可见map方法将this(即原始的observer)和转换函数mapper包装到一个ObservableMap中(ObservableMap也继承Observable)，然后返回这个ObservableMap（onAssembly默认什么都不做）。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于ObservableMap也是一个Observable，所以他的subscribe方法会在创建订阅者时被层层调用到，subscribe是Observable定义的final方法，最终会调用到他实现的subscribeAcutal方法。&lt;br/&gt;code4.6&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;//ObservableMap的subscribeActual&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public void subscribeActual&lt;span&gt;(Observer&amp;lt;? super U&amp;gt; t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    source.subscribe(&lt;span&gt;new&lt;/span&gt; MapObserver&amp;lt;T, U&amp;gt;(t, &lt;span&gt;function))&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以看到ObservableMap的subscribeActual中，将原始的观察者t和变换函数function包装到了一个新的观察者MapObserver中，并将它订阅到被观察者source上。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们知道，发送数据的时候，观察者的onNext会被调用，所以看下MapObserver的onNext方法。&lt;br/&gt;code4.7&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span&gt;@Override&lt;br/&gt;&lt;span&gt;public void onNext&lt;span&gt;(T t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;done&lt;/span&gt;) {&lt;span&gt;return&lt;/span&gt;; }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;source&lt;/span&gt;Mode != NONE) { actual.onNext(null);&lt;span&gt;return&lt;/span&gt;;}&lt;br/&gt;    &lt;span&gt;U&lt;/span&gt; v;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;v&lt;/span&gt; = ObjectHelper.requireN&lt;span&gt;on&lt;/span&gt;Null(mapper.apply(t), &lt;span&gt;&quot;The mapper function returned a null value.&quot;&lt;/span&gt;);&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Throwable ex) {...}&lt;br/&gt;    &lt;span&gt;actual&lt;/span&gt;&lt;span&gt;.onNext&lt;/span&gt;(&lt;span&gt;v&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;code4.7中可以看到mapper.apply(t)将变换函数mapper施加到每个元素t上，变换后得到v，最后调用actual.onNext(v)将v发送给下游观察者actual(actual为code4.6中创建MapObserver时传入的t)。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;总结一下例如map之类的变换api的原理：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.map方法返回一个ObservableMap，包装了原始的观察者t和变换函数function&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.ObservableMap继承自AbstractObservableWithUpstream(它继承自Observable)&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3.订阅发生时，observable的final方法subscribe()会调用实现类的subscribeActual&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4.ObservableMap.subscribeActual中创建MapObserver（包装了原observer），订阅到原Observable&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;5.发送数据onNext被调用时，先apply变换操作，再调用原observer的onNext，即传给下游观察者&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;线程调度&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;代码Code 2.2中给出了线程调度的示例。subscribeOn(Schedulers.io())指定了被观察者执行的线程池。observeOn(Schedulers.single())指定了下游观察者执行的线程池。经过了上面的学习，很自然的能够明白，原理还是通过装饰器模式，将Observable和Observer层层包装，丢到线程池里执行。我们以observeOn()为例，见code4.8。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public final Observable&amp;lt;T&amp;gt; observeOn&lt;span&gt;(Scheduler scheduler, boolean delayError, int bufferSize)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;ObjectHelper&lt;/span&gt;.requireNonNull(scheduler, &lt;span&gt;&quot;scheduler is null&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;ObjectHelper&lt;/span&gt;.verifyPositive(bufferSize, &lt;span&gt;&quot;bufferSize&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;//observeOn(Scheduler) 返回ObservableObserveOn（继承自Observable）&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; RxJavaPlugins.onAssembly(&lt;span&gt;new&lt;/span&gt; ObservableObserveOn&amp;lt;T&amp;gt;(&lt;span&gt;this&lt;/span&gt;, scheduler, delayError, bufferSize));&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Observable的subscribe方法最终会调用到ObservableObserveOn.subscribeActual方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;protected void subscribeActual&lt;span&gt;(Observer&amp;lt;? super T&amp;gt; observer)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (scheduler &lt;span&gt;instanceof&lt;/span&gt; TrampolineScheduler) {&lt;br/&gt;        &lt;span&gt;source&lt;/span&gt;&lt;span&gt;.subscribe&lt;/span&gt;(&lt;span&gt;observer&lt;/span&gt;);&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        Scheduler.Worker w = scheduler.createWorker();&lt;br/&gt;        //创建一个ObserveOnObserver包装了原观察者、worker，把它订阅到&lt;span&gt;source&lt;/span&gt;(原observable)&lt;br/&gt;        source.subscribe(&lt;span&gt;new&lt;/span&gt; ObserveOnObserver&amp;lt;T&amp;gt;(observer, w, delayError, bufferSize));&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.observeOn(Scheduler) 返回ObservableObserveOn&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.ObservableObserveOn继承自Observable&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3.所以subscribe方法最终会调用到ObservableObserveOn重写的subscribeActual方法&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4.subscribeActual返回一个ObserveOnObserver(是一个Observer)包装了真实的observer和worker&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;根据Observer的逻辑，发送数据时onNext方法会被调用，所以要看下ObserveOnObserver的onNext方法：&lt;br/&gt;code4.9&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public void onNext&lt;span&gt;(T t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;done&lt;/span&gt;) { &lt;span&gt;return&lt;/span&gt;; }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;source&lt;/span&gt;Mode != QueueDisposable.ASYNC) { queue.offer(t);}&lt;br/&gt;    schedule();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;void schedule&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (getAndIncrement() == 0) {&lt;br/&gt;        worker.schedule(&lt;span&gt;this&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;是ObserveOnObserver，他同样实现了Runable&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public void run&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (outputFused) {&lt;br/&gt;        drainFused();&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        drainNormal(); &lt;span&gt;//最终会调用actual.onNext(v) , 即调用被封装的下游观察者，v是emmiter&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.最终生产者代码中调用onNext时，会调用schedule方法&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.schedule方法中，会提交自身(ObserveOnObserver)到线程池&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3.而run方法会调用onNext(emmiter)&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可见，RxJava线程调度的机制就是通过observeOn(Scheduler)将发送元素的代码onNext(emmiter)提交到线程池里执行。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;使用注意&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;最后，给出几个我们在开发中总结的注意事项，避免大家踩坑。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;适用场景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;并不是所有的IO操作、异步回调都需要使用RxJava来解决，比如如果我们只是一两个RPC服务的调用组合，或者每个请求都是独立的处理逻辑，那么引入RxJava并不会带来多大的收益。下面给出几个最佳的适用场景。&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;处理UI事件&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;异步响应和处理IO结果&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;事件或数据 是由无法控制的生产者推送过来的&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;组合接收到的事件&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;下面给一个闲鱼商品批量补数据的使用场景：&lt;br/&gt;&lt;strong&gt;背景：&lt;/strong&gt;算法推荐了用户的一些商品，目前只有基础信息，需要调用多个业务接口，补充用户和商品的附加业务信息，如用户头像、商品视频连接、商品首图等。并且根据商品的类型不同，填充不同的垂直业务信息。&lt;br/&gt;&lt;strong&gt;难点：&lt;/strong&gt;1. 多个接口存在前后依赖甚至交叉依赖；2. 每个接口都有可能超时或者报错，继而影响后续逻辑；3.根据不同的依赖接口特点，需要单独控制超时和fallback。整个接口也需要设置整体的超时和fallback。&lt;br/&gt;&lt;strong&gt;方案：&lt;/strong&gt;如果只是多个接口独立的异步查询，那么完全可以使用CompletableFuture。但基于它对组合、超时、fallback支持不友好，并不适用于此场景。我们最终采用RxJava来实现。下面是大致的代码逻辑。代码中的HsfInvoker是阿里内部将普通HSF接口转为Rx接口的工具类，默认运行到单独的线程池中，所以能实现并发调用。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-backh=&quot;278&quot; data-backw=&quot;314&quot; data-ratio=&quot;0.8787878787878788&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/DUwiayJ0Mj1Hl3iaKGOZc4wsWQhUoByP2nG7icFutLxjhrbNZkqANHsxN0qialahoNPRVbic65QtgzLZdoAPU61qD2g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1089&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;可以看到，通过引入RxJava，对于超时控制、兜底策略、请求回调、结果组合都能更方便的支持。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Scheduler线程池&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;RxJava2 内置多个 Scheduler 的实现，但是我们建议使用Schedulers.from(executor)指定线程池，这样可以避免使用框架提供的默认公共线程池，防止单个长尾任务block其他线程执行，或者创建了过多的线程导致OOM。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;CompletableFuture&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;当我们的逻辑比较简单，只想异步调用一两个RPC服务的时，完全可以考虑使用Java8提供的CompletableFuture实现，它相较于Future是异步执行的，也可以实现简单的组合逻辑。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;并发&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;单个Observable始终是顺序执行的，不允许并发地调用onNext()。&lt;br/&gt;code5.1&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;Observable&lt;/span&gt;&lt;span&gt;.create&lt;/span&gt;(&lt;span&gt;emitter-&lt;/span&gt;&amp;gt;{&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;&lt;span&gt;()&lt;/span&gt;-&amp;gt;&lt;/span&gt;emitter.onNext(&lt;span&gt;&quot;a1&quot;&lt;/span&gt;)).start();&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;&lt;span&gt;()&lt;/span&gt;-&amp;gt;&lt;/span&gt;emitter.onNext(&lt;span&gt;&quot;a2&quot;&lt;/span&gt;)).start();&lt;br/&gt;})&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是，每个Observable可以独立的并发执行。&lt;br/&gt;code5.2&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span&gt;Observable ob1 = Observable.create(e-&amp;gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;&lt;span&gt;()&lt;/span&gt;-&amp;gt;&lt;/span&gt;e.onNext(&lt;span&gt;&quot;a1&quot;&lt;/span&gt;)).start());&lt;br/&gt;Observable ob2 = Observable.create(e-&amp;gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;&lt;span&gt;()&lt;/span&gt;-&amp;gt;&lt;/span&gt;e.onNext(&lt;span&gt;&quot;a2&quot;&lt;/span&gt;)).start());&lt;br/&gt;&lt;span&gt;Observable&lt;/span&gt; ob3 = Observable.merge(ob1,ob2);&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;ob3中组合了ob1和ob2两个流，每个流是独立的。（这里需要注意，这两个流能并发执行，还有一个条件是他们的发送代码运行在不同线程，就如果code3.1和code3.2中的示例一样，虽然两个流是独立的，但是如果不提交到不同的线程中，还是顺序执行的）。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;背压&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;在 RxJava 2.x 中，只有 Flowable 类型支持背压。当然，Observable 能解决的问题，对于 Flowable 也都能解决。但是，其为了支持背压而新增的额外逻辑导致 Flowable 运行性能要比 Observable 慢得多，因此，只有在需要处理背压场景时，才建议使用 Flowable。如果能够确定上下游在同一个线程中工作，或者上下游工作在不同的线程中，而下游处理数据的速度高于上游发射数据的速度，则不会产生背压问题，就没有必要使用Flowable。关于Flowable的使用，由于篇幅原因，就不在本文阐述。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;超时&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;强烈建议设置异步调用的超时时间，用timeout和onErrorReturn方法设置超时的兜底逻辑，否则这个请求将一直占用一个Observable线程，当大量请求到来时，也会导致OOM。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;结语&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;目前，闲鱼的多个业务场景都采用RxJava做异步化，大大降低了开发同学的异步开发成本。同时在多请求响应组合、并发处理都有很好的性能表现。自带的超时逻辑和兜底策略，在批量业务数据处理中能保证可靠性，是用户流畅体验的强力支撑。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;4.13570487483531&quot; data-type=&quot;png&quot; data-w=&quot;759&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1GLZDqvPfwuIUEJjtdPx4lYwPx0p9E4T3D1f164CCr18n4ms26HtWsUVrsLf8Szwb4Us8MuhOCe3g/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>