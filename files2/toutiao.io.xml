<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3a5bb0dc784364dc433a994fd767ef9b</guid>
<title>Go 面试官问我如何实现面向对象？</title>
<link>https://toutiao.io/k/mshzps1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是煎鱼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在大家初识 Go 语言时，总会拿其他语言的基本特性来类比 Go 语言，说白了就是老知识和新知识产生关联，实现更高的学习效率。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.56&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4grz5IlIjYicic3SYiaLsMnN6mpuiaR5dBJdz3KciaQFl9rCb2WfC3YtgTkwwug1eASGWynEvdCWTElYrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最常见的类比，就是 “Go 语言如何实现面向对象？”，进一步展开就是 Go 语言如何实现面向对象特性中的继承。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这不仅在学习中才用到类比，在业内的 Go 面试中也有非常多的面试官喜欢问：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5536912751677853&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4grz5IlIjYicic3SYiaLsMnN6mXFjBmZPGHkEQ5PfG3b8Wo9qiaF8vlUYOaUKHF5ibwyC0UzXotAFbZnLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1192&quot;/&gt;&lt;figcaption&gt;来自读者微信群&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在今天这篇文章中，煎鱼带大家具体展开了解这块的知识。一起愉快地开始吸鱼之路。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是面向对象&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在了解 Go 语言是不是面向对象（简称：OOP） 之前，我们必须先知道 OOP 是啥，得先给他 “下定义”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据 Wikipedia 的定义，我们梳理出 OOP 的几个基本认知：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;面向对象编程（OOP）是一种基于 &quot;对象&quot; 概念的编程范式，它可以包含数据和代码：数据以字段的形式存在（通常称为属性或属性），代码以程序的形式存在（通常称为方法）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对象自己的程序可以访问并经常修改自己的数据字段。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对象经常被定义为类的一个实例。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对象利用属性和方法的私有/受保护/公共可见性，对象的内部状态受到保护，不受外界影响（被封装）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于这几个基本认知进行一步延伸出，面向对象的三大基本特性：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此对面向对象的基本概念讲解结束，想更进一步了解的可自行网上冲浪。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Go 是面向对象的语言吗&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“Go 语言是否一门面向对象的语言？”，这是一个日经话题。官方 FAQ 给出的答复是：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.30542452830188677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4grz5IlIjYicic3SYiaLsMnN6mXMc53XnzyJqVzibGX7uYWQ2fMzHqXb4hwBsgRB0k1oWdvr5oLicTBB8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1696&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是的，也不是。原因是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Go 有类型和方法，并且允许面向对象的编程风格，但没有类型层次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Go 中的 &quot;接口 &quot;概念提供了一种不同的方法，我们认为这种方法易于使用，而且在某些方面更加通用。还有一些方法可以将类型嵌入到其他类型中，以提供类似的东西，但不等同于子类。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Go 中的方法比 C++ 或 Java 中的方法更通用：它们可以为任何类型的数据定义，甚至是内置类型，如普通的、&quot;未装箱的 &quot;整数。它们并不局限于结构（类）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Go 由于缺乏类型层次，Go 中的 &quot;对象 &quot;比 C++ 或 Java 等语言更轻巧。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Go 实现面向对象编程&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;封装&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面向对象中的 “封装” 指的是可以隐藏对象的内部属性和实现细节，仅对外提供公开接口调用，这样子用户就不需要关注你内部是怎么实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 语言中的属性访问权限，通过首字母大小写来控制：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首字母大写，代表是公共的、可被外部访问的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;首字母小写，代表是私有的，不可以被外部访问。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言的例子如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Animal &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; name &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewAnimal&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; *&lt;span&gt;Animal&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &amp;amp;Animal{}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(p *Animal)&lt;/span&gt; &lt;span&gt;SetName&lt;/span&gt;&lt;span&gt;(name &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; p.name = name&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(p *Animal)&lt;/span&gt; &lt;span&gt;GetName&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; p.name&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上述例子中，我们声明了一个结构体 &lt;code&gt;Animal&lt;/code&gt;，其属性 &lt;code&gt;name&lt;/code&gt; 为小写。没法通过外部方法，在配套上存在 Setter 和 Getter 的方法，用于统一的访问和设置控制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以此实现在 Go 语言中的基本封装。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;继承&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面向对象中的 “继承” 指的是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4795180722891566&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4grz5IlIjYicic3SYiaLsMnN6mL1Ug1FbYNv5NCqjm9fias3KPmdjomETPeNclGWJrBHS2mg5dibkPlRQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;415&quot;/&gt;&lt;figcaption&gt;图来自网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从实际的例子来看，就是动物是一个大父类，下面又能细分为 “食草动物”、“食肉动物”，这两者会包含 “动物” 这个父类的基本定义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 语言中，是没有类似 &lt;code&gt;extends&lt;/code&gt; 关键字的这种继承的方式，在语言设计上采取的是组合的方式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Animal &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Name &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Cat &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Animal&lt;br/&gt; FeatureA &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Dog &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Animal&lt;br/&gt; FeatureB &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上述例子中，我们声明了 &lt;code&gt;Cat&lt;/code&gt; 和 &lt;code&gt;Dog&lt;/code&gt; 结构体，其在内部匿名组合了 &lt;code&gt;Animal&lt;/code&gt; 结构体。因此 &lt;code&gt;Cat&lt;/code&gt; 和 &lt;code&gt;Dog&lt;/code&gt; 的实例都可以调用 &lt;code&gt;Animal&lt;/code&gt; 结构体的方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; p := NewAnimal()&lt;br/&gt; p.SetName(&lt;span&gt;&quot;煎鱼，记得点赞~&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; dog := Dog{Animal: *p}&lt;br/&gt; fmt.Println(dog.GetName())&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时 &lt;code&gt;Cat&lt;/code&gt; 和 &lt;code&gt;Dog&lt;/code&gt; 的实例可以拥有自己的方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(dog *Dog)&lt;/span&gt; &lt;span&gt;HelloWorld&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;脑子进煎鱼了&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(cat *Cat)&lt;/span&gt; &lt;span&gt;HelloWorld&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;煎鱼进脑子了&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述例子能够正常包含调用 &lt;code&gt;Animal&lt;/code&gt; 的相关属性和方法，也能够拥有自己的独立属性和方法，在 Go 语言中达到了类似继承的效果。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;多态&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面向对象中的 “多态” 指的同一个行为具有多种不同表现形式或形态的能力，具体是指一个类实例（对象）的相同方法在不同情形有不同表现形式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多态也使得不同内部结构的对象可以共享相同的外部接口，也就是都是一套外部模板，内部实际是什么，只要符合规格就可以。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 语言中，多态是通过接口来实现的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; AnimalSounder &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; MakeDNA()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;MakeSomeDNA&lt;/span&gt;&lt;span&gt;(animalSounder AnimalSounder)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; animalSounder.MakeDNA()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上述例子中，我们声明了一个接口类型 &lt;code&gt;AnimalSounder&lt;/code&gt;，配套一个 &lt;code&gt;MakeSomeDNA&lt;/code&gt; 方法，其接受 &lt;code&gt;AnimalSounder&lt;/code&gt; 接口类型作为入参。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此在 Go 语言中。只要配套的 &lt;code&gt;Cat&lt;/code&gt; 和 &lt;code&gt;Dog&lt;/code&gt; 的实例也实现了 &lt;code&gt;MakeSomeDNA&lt;/code&gt; 方法，那么我们就可以认为他是 &lt;code&gt;AnimalSounder&lt;/code&gt; 接口类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; AnimalSounder &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; MakeDNA()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;MakeSomeDNA&lt;/span&gt;&lt;span&gt;(animalSounder AnimalSounder)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; animalSounder.MakeDNA()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Cat)&lt;/span&gt; &lt;span&gt;MakeDNA&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;煎鱼是煎鱼&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Dog)&lt;/span&gt; &lt;span&gt;MakeDNA&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;煎鱼其实不是煎鱼&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; MakeSomeDNA(&amp;amp;Cat{})&lt;br/&gt; MakeSomeDNA(&amp;amp;Dog{})&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 &lt;code&gt;Cat&lt;/code&gt; 和 &lt;code&gt;Dog&lt;/code&gt; 的实例实现了 &lt;code&gt;AnimalSounder&lt;/code&gt; 接口类型的约束后，就意味着满足了条件，他们在 Go 语言中就是一个东西。能够作为入参传入 &lt;code&gt;MakeSomeDNA&lt;/code&gt; 方法中，再根据不同的实例实现多态行为。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过今天这篇文章，我们基本了解了面向对象的定义和 Go 官方对面向对象这一件事的看法，同时针对面向对象的三大特性：“封装、继承、多态” 在 Go 语言中的实现方法就进行了一一讲解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在日常工作中，基本了解这些概念就可以了。若是面试，可以针对三大特性：“封装、继承、多态” 和 五大原则 “单一职责原则（SRP）、开放封闭原则（OCP）、里氏替换原则（LSP）、依赖倒置原则（DIP）、接口隔离原则（ISP）” 进行深入理解和说明。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在说明后针对上述提到的概念。再在 Go 语言中讲解其具体的实现和利用到的基本原理，互相结合讲解，就能得到一个不错的效果了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;参考&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Is Go an Object Oriented language?&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面向对象的三大基本特征，五大基本原则&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Go 面向对象编程（译）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0e2ec5beb9d95cf397da7dd07c75edcd</guid>
<title>分块传输就不能跨域？`chunked` 编码影响 `CORS` 跨域的问题排查</title>
<link>https://toutiao.io/k/9qh9d09</link>
<content:encoded>&lt;div&gt;&lt;html lang=&quot;zh-CN&quot; class=&quot;loading&quot;&gt;
&lt;head&gt;&lt;meta name=&quot;generator&quot; content=&quot;Hexo 3.9.0&quot;/&gt;
    &lt;meta charset=&quot;UTF-8&quot;/&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;/&gt;
    &lt;title&gt;分块传输就不能跨域? `chunked` 编码影响 `CORS` 跨域的问题排查 - IO10|PangJian&#x27;s Blog&lt;/title&gt;
    &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;/&gt;
    &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot;/&gt;
    &lt;meta name=&quot;google&quot; content=&quot;notranslate&quot;/&gt;
    &lt;meta name=&quot;keywords&quot; content=&quot;pangjian IO10 sirius,&quot;/&gt; 
    &lt;meta name=&quot;description&quot; content=&quot;简约 是复杂的最终形式,在日常开发中我们经常遇到需要进行跨域的情况，虽然跨域的方案有非常多，但是最推荐的方法还是 CORS。服务器在Http 返回头中增加 CORS 的返回信息，就可以轻松的进行跨域。&amp;#10;&amp;#10;问题现象  有一个,&quot;/&gt; 
    &lt;meta name=&quot;author&quot; content=&quot;Pang Jian&quot;/&gt; 
     
     
    
    
    
    
    
    
    
    
    
&lt;/head&gt;
&lt;/html&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>12c38aacf830b9a2e5e35c1bc633006e</guid>
<title>Android 进程通讯机制之 Binder（信使）架构以及内存映射详解</title>
<link>https://toutiao.io/k/fa6qc29</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;220&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;Android系统是基于Linux改造而来的，进程系统也是一脉相承，而进程&lt;br/&gt;其实就是程序的具体实现。当程序第一次启动，&lt;br/&gt;Android会启动一个Linux进程（具体由Zygote fork出来）以及一个主线程，&lt;br/&gt;默认的情况下，所有组件都将运行在该进程内。&lt;br/&gt;同一个应用由系统分配一个独立的账户，&lt;br/&gt;该应用的产生的所有进程，都会是这同一个账户，每个进程都是相互独立的。&lt;/section&gt;&lt;section&gt;&lt;em&gt;&lt;span&gt;那提起多进程，往往想到的是进程间的怎么交流信息的？那就有了今天这篇文章:Binder详解&lt;/span&gt;&lt;/em&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;一.Binder是什么？&lt;/h2&gt;&lt;h4&gt;Binder我也称之为信使（鸽子）&lt;/h4&gt;&lt;p&gt;Binder是安卓中实现IPC（进程间通信的）常用手段，四大组件之间的跨进程通信也是利用Binder实现的，Binder是学习四大组件工作原理的的一个重要基础，是Android提供的一套进程间相互通信框架。用来多进程间发送消息，同步和共享内存。已有的进程间通信方式有一下几种：&lt;br/&gt;1、Files 文件系统（包括内存映射）&lt;br/&gt;2、Sockets&lt;br/&gt;3、Pipes 管道&lt;br/&gt;4、共享内存&lt;br/&gt;5、Intents, ContentProviders, Messenger&lt;br/&gt;6、Binder&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.683068017366136&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kyDL16ViavhH2RE6xZhB0V26jhZ15lDybIRQs5xzBNPGic56pzV5YpwN9ibMNKSb56yjdicewhprje3yFMtAVDV20Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;691&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;Android系统中的Binder框架图如下：&lt;/h4&gt;&lt;p&gt;1、Binder是Android提供的一套进程间通信框架。&lt;br/&gt;2、系统服务ActivityManagerService，ServiceManager等都是在单独进程中的，使用binder和应用进行通信。&lt;br/&gt;3、Binder就像信使鸽子一样传递信息&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6291666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/kyDL16ViavhH2RE6xZhB0V26jhZ15lDybmPsiafcHtLm0Sr9uga73sbK0VZcOfzbpxnmicDn3QJrBhKjDzHObdWCg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;二.Binder架构&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;Binder通信采用C/S架构&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8089080459770115&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kyDL16ViavhH2RE6xZhB0V26jhZ15lDybuN8XxMTEfcpPvXgQtn4yQicaE0vCAlAYDE6SUiau7KPNt3D9tZGeJibrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;696&quot;/&gt;&lt;/p&gt;&lt;p&gt;从组件视角来说，包含Client、Server、ServiceManager以及Binder驱动，其中ServiceManager用于管理系统中的各种服务。如上图所示Binder在Framework层和Native层分别有对应的客户端（Client）、服务（Server）的和服务管理器（Service Manager）。同时在Kernel层（内核空间）有Binder的驱动设备。&lt;/p&gt;&lt;p&gt;这四个角色的作用分别是：&lt;/p&gt;&lt;p&gt;① Client进程：使用服务的进程。&lt;/p&gt;&lt;p&gt;② Server进程：提供服务的进程。&lt;/p&gt;&lt;p&gt;③ ServiceManager进程：ServiceManager的作用是将字符形式的Binder名字转化成Client中对该Binder的引用，使得Client能够通过Binder名字获得对Server中Binder实体的引用。&lt;/p&gt;&lt;p&gt;④ Binder驱动：驱动负责进程之间Binder通信的建立，Binder在进程之间的传递，Binder引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。&lt;/p&gt;&lt;h4&gt;Binder运行机制&lt;/h4&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6083333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/kyDL16ViavhH2RE6xZhB0V26jhZ15lDybrxEwAjqxkueGpmibshOrHRzjia153DFibeOKxlH2nTvd3mdrLnZZf45Dg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p&gt;① Binder驱动为跨进程通信做准备：通过调用mmap()系统函数实现内存映射。在Binder驱动中创建一块接收缓存区。同时将内核缓存区地址和Server端中用户空间一块地址同时都映射到该接收缓存区中。这时候就创建了虚拟区间和映射的关系。&lt;/p&gt;&lt;p&gt;② Client进程将数据发送到Server进程。Client进程通过调用copy_from_user()发送数据拷贝到内核中（Binder驱动）的缓存区中，此时Client发起请求的线程会被挂起。由于在①中构建了映射关系，此时相当于也将数据发送到了Server端的用户空间中。之后Binder驱动通知Server端进程执行解包。&lt;/p&gt;&lt;p&gt;③ Server进程根据Client进程发送来的数据，调用目标方法。收到Binder驱动通知后，Server进程对数据进行解包，并调用相关方法处理。&lt;/p&gt;&lt;p&gt;④ Server进程将目标方法处理结果返回给Client进程。将处理结果放回自己的共享空间（即①中映射的Binder驱动缓存区中）。Binder驱动通知Client进程获取返回结果，此时②中被挂起的线程会被重新唤醒。Client进程通过系统调用copy_to_user(),从内核缓存区拷贝Server进程返回的结果。&lt;/p&gt;&lt;h2&gt;三.Binder机制 在Android中的具体实现原理&lt;/h2&gt;&lt;h4&gt;注册服务&lt;/h4&gt;&lt;p&gt;Server进程 通过Binder驱动 向 Service Manager进程 注册服务&lt;br/&gt;注册服务后，Binder驱动持有 Server进程创建的Binder实体&lt;/p&gt;&lt;pre&gt;&lt;code&gt;   &lt;span&gt;Binder&lt;/span&gt; binder &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Stub&lt;/span&gt;();&lt;br/&gt;    &lt;span&gt;// 步骤1：创建Binder对象 -&amp;gt;&amp;gt;分析1&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 步骤2：创建 IInterface 接口类 的匿名类&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 创建前，需要预先定义 继承了IInterface 接口的接口 --&amp;gt;分析3&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;IInterface&lt;/span&gt; plus &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;IPlus&lt;/span&gt;(){&lt;br/&gt;&lt;br/&gt;          &lt;span&gt;// 确定Client进程需要调用的方法&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt; b) {&lt;br/&gt;               &lt;span&gt;return&lt;/span&gt; a&lt;span&gt;+&lt;/span&gt;b;&lt;br/&gt;         }&lt;br/&gt;&lt;br/&gt;          &lt;span&gt;// 实现IInterface接口中唯一的方法&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;public&lt;/span&gt; &lt;span&gt;IBinder&lt;/span&gt; asBinder（）{ &lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; ;&lt;br/&gt;           }&lt;br/&gt;};&lt;br/&gt;          &lt;span&gt;// 步骤3&lt;/span&gt;&lt;br/&gt;          binder.&lt;span&gt;attachInterface&lt;/span&gt;(plus，&lt;span&gt;&quot;add two int&quot;&lt;/span&gt;);&lt;br/&gt;         &lt;span&gt;// 1. 将（add two int，plus）作为（key,value）对存入到Binder对象中的一个Map&amp;lt;String,IInterface&amp;gt;对象中&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;// 2. 之后，Binder对象 可根据add two int通过queryLocalIInterface（）获得对应IInterface对象（即plus）的引用，可依靠该引用完成对请求方法的调用&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 分析完毕，跳出&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;--&lt;/span&gt; 分析&lt;span&gt;1&lt;/span&gt;：&lt;span&gt;Stub&lt;/span&gt;类 &lt;span&gt;--&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Stub&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Binder&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 继承自Binder类 -&amp;gt;&amp;gt;分析2&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;          &lt;span&gt;// 复写onTransact（）&lt;/span&gt;&lt;br/&gt;          @Override&lt;br/&gt;          &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;onTransact&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; code, &lt;span&gt;Parcel&lt;/span&gt; data, &lt;span&gt;Parcel&lt;/span&gt; reply, &lt;span&gt;int&lt;/span&gt; flags){&lt;br/&gt;          &lt;span&gt;// 具体逻辑等到步骤3再具体讲解，此处先跳过&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;switch&lt;/span&gt; (code) { &lt;br/&gt;                &lt;span&gt;case&lt;/span&gt; &lt;span&gt;Stub&lt;/span&gt;.add：{ &lt;br/&gt;&lt;br/&gt;                       data.&lt;span&gt;enforceInterface&lt;/span&gt;(&lt;span&gt;&quot;add two int&quot;&lt;/span&gt;); &lt;br/&gt;&lt;br/&gt;                       &lt;span&gt;int&lt;/span&gt;  arg0  &lt;span&gt;=&lt;/span&gt; data.&lt;span&gt;readInt&lt;/span&gt;();&lt;br/&gt;                       &lt;span&gt;int&lt;/span&gt;  arg1  &lt;span&gt;=&lt;/span&gt; data.&lt;span&gt;readInt&lt;/span&gt;();&lt;br/&gt;&lt;br/&gt;                       &lt;span&gt;int&lt;/span&gt;  result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;queryLocalIInterface&lt;/span&gt;(&lt;span&gt;&quot;add two int&quot;&lt;/span&gt;) .&lt;span&gt;add&lt;/span&gt;( arg0,  arg1); &lt;br/&gt;&lt;br/&gt;                        reply.&lt;span&gt;writeInt&lt;/span&gt;(result); &lt;br/&gt;&lt;br/&gt;                        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;; &lt;br/&gt;                  }&lt;br/&gt;           } &lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;.&lt;span&gt;onTransact&lt;/span&gt;(code, data, reply, flags); &lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 回到上面的步骤1，继续看步骤2&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;--&lt;/span&gt; 分析&lt;span&gt;2&lt;/span&gt;：&lt;span&gt;Binder&lt;/span&gt; 类 &lt;span&gt;--&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Binder&lt;/span&gt; implement &lt;span&gt;IBinder&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// Binder机制在Android中的实现主要依靠的是Binder类，其实现了IBinder接口&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// IBinder接口：定义了远程操作对象的基本接口，代表了一种跨进程传输的能力&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 系统会为每个实现了IBinder接口的对象提供跨进程传输能力&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 即Binder类对象具备了跨进程传输的能力&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;void&lt;/span&gt; &lt;span&gt;attachInterface&lt;/span&gt;(&lt;span&gt;IInterface&lt;/span&gt; plus, &lt;span&gt;String&lt;/span&gt; descriptor)；&lt;br/&gt;        &lt;span&gt;// 作用：&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;// 1. 将（descriptor，plus）作为（key,value）对存入到Binder对象中的一个Map&amp;lt;String,IInterface&amp;gt;对象中&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;// 2. 之后，Binder对象 可根据descriptor通过queryLocalIInterface（）获得对应IInterface对象（即plus）的引用，可依靠该引用完成对请求方法的调用&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;IInterface&lt;/span&gt; &lt;span&gt;queryLocalInterface&lt;/span&gt;(&lt;span&gt;Stringdescriptor&lt;/span&gt;) ；&lt;br/&gt;        &lt;span&gt;// 作用：根据 参数 descriptor 查找相应的IInterface对象（即plus引用）&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;onTransact&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; code, &lt;span&gt;Parcel&lt;/span&gt; data, &lt;span&gt;Parcel&lt;/span&gt; reply, &lt;span&gt;int&lt;/span&gt; flags)；&lt;br/&gt;        &lt;span&gt;// 定义：继承自IBinder接口的&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 作用：执行Client进程所请求的目标方法（子类需要复写）&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 参数说明：&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// code：Client进程请求方法标识符。即Server进程根据该标识确定所请求的目标方法&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// data：目标方法的参数。（Client进程传进来的，此处就是整数a和b）&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// reply：目标方法执行后的结果（返回给Client进程）&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;// 注：运行在Server进程的Binder线程池中；当Client进程发起远程请求时，远程请求会要求系统底层执行回调该方法&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BinderProxy&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IBinder&lt;/span&gt; {&lt;br/&gt;         &lt;span&gt;// 即Server进程创建的Binder对象的代理对象类&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;// 该类属于Binder的内部类&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 回到分析1原处&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;--&lt;/span&gt; 分析&lt;span&gt;3&lt;/span&gt;：&lt;span&gt;IInterface&lt;/span&gt;接口实现类 &lt;span&gt;--&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;获取服务&lt;/h4&gt;&lt;p&gt;Client进程 使用 某个 service前，须 通过Binder驱动 向 ServiceManager进程 获取相应的Service信息，Client进程与 Server进程已经建立了连接&lt;/p&gt;&lt;h4&gt;使用服务&lt;/h4&gt;&lt;p&gt;Client进程 根据获取到的 Service信息（Binder代理对象），通过Binder驱动 建立与 该Service所在Server进程通信的链路，并开始使用服务&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Client进程 将参数（整数a和b）发送到Server进程&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Server进程 根据Client进程要求调用 目标方法（即加法函数）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Server进程 将目标方法的结果（即加法后的结果）返回给Client进程&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;四.Binder与内存映射mmap&lt;/h2&gt;&lt;p&gt;Binder IPC 是基于内存映射（mmap）来实现的，但是 mmap() 通常是用在有物理介质的文件系统上的。&lt;/p&gt;&lt;p&gt;进程中的用户区域是不能直接和物理设备打交道的，如果想要把磁盘上的数据读取到进程的用户区域，需要两次拷贝（磁盘–&amp;gt;内核空间–&amp;gt;用户空间）；通常在这种场景下 mmap() 就能发挥作用，通过在物理介质和用户空间之间建立映射，减少数据的拷贝次数，用内存读写取代I/O读写，提高文件读取效率。&lt;/p&gt;&lt;p&gt;而 Binder 并不存在物理介质，因此 Binder 驱动使用 mmap() 并不是为了在物理介质和用户空间之间建立映射，而是用来在内核空间创建数据接收的缓存空间。&lt;/p&gt;&lt;p&gt;一次完整的 Binder IPC 通信过程通常是这样：&lt;/p&gt;&lt;p&gt;首先 Binder 驱动在内核空间创建一个数据接收缓存区；&lt;/p&gt;&lt;p&gt;接着在内核空间开辟一块内核缓存区，建立内核缓存区和内核中数据接收缓存区之间的映射关系，以及内核中数据接收缓存区和接收进程用户空间地址的映射关系；&lt;br/&gt;发送方进程通过系统调用 copyfromuser() 将数据 copy 到内核中的内核缓存区，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7206521739130435&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/kyDL16ViavhH2RE6xZhB0V26jhZ15lDybTIEjicLqc0jBKYMZD7fGuuibUMYWK227vBTOp7ib4lkLq4iarcHk41151A/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;920&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;1&quot; data-url=&quot;http://mp.weixin.qq.com/s?__biz=Mzk0NDE3MjM1Ng==&amp;amp;mid=2247483792&amp;amp;idx=1&amp;amp;sn=4115b60764cc4a7f8891a2d44e4d39ca&amp;amp;chksm=c329fdbbf45e74ada7f9e29072b68f49e52572f9e4a2ce568fde0abc94a947a92ef430d3084a#rd&quot; data-author-name=&quot;Android开发编程&quot; data-content-utf8-length=&quot;4&quot; data-source-title=&quot;Android 之app启动优化和优雅过渡动画全面解析&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;启动优化&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;blockquote_info js_blockquote_source&quot; data-json=&quot;%7B%22type%22%3A%22inner%22%2C%22source%22%3A%22biz%22%2C%22digest%22%3A%22%3Cp%3E%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%3C%2Fp%3E%22%2C%22digestLen%22%3A4%2C%22text%22%3A%22%22%2C%22article%22%3A%7B%22title%22%3A%22Android%20%E4%B9%8Bapp%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E5%92%8C%E4%BC%98%E9%9B%85%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90%22%2C%22url%22%3A%22http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzk0NDE3MjM1Ng%3D%3D%26mid%3D2247483792%26idx%3D1%26sn%3D4115b60764cc4a7f8891a2d44e4d39ca%26chksm%3Dc329fdbbf45e74ada7f9e29072b68f49e52572f9e4a2ce568fde0abc94a947a92ef430d3084a%23rd%22%2C%22nickname%22%3A%22Android%E5%BC%80%E5%8F%91%E7%BC%96%E7%A8%8B%22%2C%22authorName%22%3A%22Android%E5%BC%80%E5%8F%91%E7%BC%96%E7%A8%8B%22%7D%2C%22hasReportOverSize%22%3Afalse%2C%22editorReportData%22%3A%5B%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2278%22%2C%22len%22%3A1%7D%5D%7D&quot;&gt;&lt;span class=&quot;blockquote_biz&quot;&gt;Android开发编程，公众号：Android开发编程&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzk0NDE3MjM1Ng==&amp;amp;mid=2247483792&amp;amp;idx=1&amp;amp;sn=4115b60764cc4a7f8891a2d44e4d39ca&amp;amp;chksm=c329fdbbf45e74ada7f9e29072b68f49e52572f9e4a2ce568fde0abc94a947a92ef430d3084a#rd&quot; class=&quot;blockquote_article&quot;&gt;Android 之app启动优化和优雅过渡动画全面解析&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzk0NDE3MjM1Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/kyDL16ViavhFRZkgpibUGGz2NIiaBUpj7NeBSJASje1M1ZhVvpDIGibicMUeCiad3ptsJLaLUjhrVYs5bGZWuenY6UaQ/0?wx_fmt=png&quot; data-nickname=&quot;Android开发编程&quot; data-alias=&quot;&quot; data-signature=&quot;一个有10多年经验开发的android、java、前端等语言的老程序员，在这里一起聊聊技术，一起聊聊生活、一起聊聊中年危机的生存之道，一起进步一起加油，感兴趣的欢迎订阅；不定时的更新。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kyDL16ViavhH2RE6xZhB0V26jhZ15lDybtd3xtxUvJOwOkNhk24g2tg5lfbH6dtBUMIAJJ8iaYMBs1OaIM4icubCg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;如需帮助发信息，谢谢&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2147bb846bac27d08e72967276992bf4</guid>
<title>绝了，没想到一个 source map 居然涉及到那么多知识盲区</title>
<link>https://toutiao.io/k/r2fvvia</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section class=&quot;mp_profile_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUyNDYxNDAyMg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/tibUxowsg9P0jU3sXRrE0spgTBkNtT0g3FjkyXRv9cSTJ2hYz6SNEBSiaQt0jxmOicXXBljcVR9GtyC00TvoptZfA/0?wx_fmt=png&quot; data-nickname=&quot;前端真好玩&quot; data-alias=&quot;frontendcento&quot; data-signature=&quot;关注恺哥，前端进阶不再是难事。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;Source map 想必大家都不陌生。线上的代码多是压缩后的，如果线上有报错却只能调试那个代码多半是个噩梦。因此我们需要有一个桥梁帮助我们搭建起源代码及压缩后代码的联系，source map 就是起了这个作用。&lt;/p&gt;&lt;p&gt;以下是 MDN 对于 source map 的解释：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;调试原始源代码会比浏览器下载的转换后的代码更加容易。 &lt;span&gt;source map&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt; 是从已转换的代码映射到原始源的文件，使浏览器能够重构原始源并在调试器中显示重建的原始源。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;但是不知道各位读者有没有对 source map 的原理产生过疑问？笔者列出了四个疑问，不知道各位是不是也存在过这样的问题：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.44538258575197887&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tibUxowsg9P2PkjvZPqibNOnnd9iaJygNpPPb2icIWe1Xia6X3xqlWEKjabicutFg8WFNibicVuGkuzg4BNoWtvP8HzmMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1895&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;Source map 四问&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;接下来的内容会逐步为读者解答这四问。&lt;/p&gt;&lt;h2&gt;source map 文件是否影响网页性能&lt;/h2&gt;&lt;p&gt;这个答案肯定是不会影响，否则构建相关的优化就肯定会涉及到对于 source map 的处理了，毕竟 source map 文件也不小。&lt;/p&gt;&lt;p&gt;其实 source map 只有在打开 dev tools 的情况下才会开始下载，相信大部分用户都不会去打开这个面板，所以这也就不是问题了。&lt;/p&gt;&lt;p&gt;这时可能会有读者想说：哎，但是我好像从来没有在 Network 里看到 source map 文件的加载呀？其实这只是浏览器隐藏了而已，如果大家使用抓包工具的话就能发现在打开 dev tools 的时候开始下载 source map 了。&lt;/p&gt;&lt;h2&gt;source map 存在标准嘛？&lt;/h2&gt;&lt;p&gt;source map 是存在一个标准的，为 Google 及 Mozilla 的工程师制定，&lt;span&gt;文档地址&lt;sup&gt;[2]&lt;/sup&gt;&lt;/span&gt;。正是因为存在这份标准，各个打包器及浏览器才能生成及使用 source map，否则就乱套了。&lt;/p&gt;&lt;p&gt;各个打包器基本都基于&lt;span&gt;该库&lt;sup&gt;[3]&lt;/sup&gt;&lt;/span&gt;来生成 source map，当然也存在一些魔改的方案，但是标准都是统一的。&lt;/p&gt;&lt;p&gt;通过上面的库生成出来的 source map 格式大致如下，大家也可以对比各个打包器的产物，格式及内容大部分都是一致的：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;json&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  version&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  file&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;min.js&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  names&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;bar&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;baz&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;n&quot;&lt;/span&gt;&lt;span&gt;],&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  sources&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;one.js&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;two.js&quot;&lt;/span&gt;&lt;span&gt;],&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  sourceRoot&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;http://example.com/www/js/&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  mappings&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;CAAC,IAAI,IAAM,SAAUA,GAClB,OAAOC,IAAID;CCDb,IAAI,IAAM,SAAUE,GAClB,OAAOA&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;接下来笔者介绍下重要字段的作用：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;version：顾名思义，指代了版本号，目前 source map 标准的版本为 3，也就是说这份 source map 使用的是第三版标准产出的&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;file：编译后的文件名&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;names：一个优化用的字段，后续会在 mappings 中用到&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;sources：多个源文件名&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;mappings：这是最重要的内容，表示了源代码及编译后代码的关系，但是先略过这块，下文中会详细解释&lt;/span&gt;&lt;/p&gt;&lt;p&gt;另外大部分应用都是由 webpack 来打包的，可能有些读者会发现 webpack 的 source map 产出的字段于上面的略微有些不一致。&lt;/p&gt;&lt;p&gt;这是因为 webpack 魔改了一些东西，但是底下还是基于这个库实现的，只是变动了一些不涉及核心的字段，&lt;span&gt;具体代码&lt;sup&gt;[4]&lt;/sup&gt;&lt;/span&gt;。&lt;/p&gt;&lt;h2&gt;浏览器怎么知道源文件和 source map 的关系？&lt;/h2&gt;&lt;p&gt;这里我们以 webpack 做个实验，通过 webpack5 对于以下代码进行打包：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;// index.js&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt; a &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;console&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;当我们开启 source map 选项以后，产物应该为两个文件，分别为 &lt;code&gt;bundle.js&lt;/code&gt; 以及 &lt;code&gt;bundle.js.map&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;查看 &lt;code&gt;bundle.js&lt;/code&gt; 文件以后我们会发现代码中存在这一一段注释：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;console&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;//# sourceMappingURL=bundle.js.map&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;code&gt;sourceMappingURL&lt;/code&gt; 就是标记了该文件的 source map 地址。&lt;/p&gt;&lt;p&gt;当然除此之外还有别的方式，通过查阅 &lt;span&gt;MDN 文档&lt;sup&gt;[5]&lt;/sup&gt;&lt;/span&gt; 发现还可以通过 response header 的 &lt;code&gt;SourceMap: &amp;lt;url&amp;gt;&lt;/code&gt; 字段来表明。&lt;/p&gt;&lt;h2&gt;source map 是如何对应到源代码的？&lt;/h2&gt;&lt;p&gt;这是 source map 最核心的功能，也是最涉及知识盲区的一块内容。&lt;/p&gt;&lt;p&gt;大家应该还记得上文中没介绍的 &lt;code&gt;mapping&lt;/code&gt; 字段吧，接下来我们就来详细了解这个字段的用处。&lt;/p&gt;&lt;p&gt;我们还是以刚才打包的文件为例，来看看产出的 source map 长啥样（去掉了无关紧要的）：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;json&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  sources&lt;/span&gt;&lt;span&gt;:[&lt;/span&gt;&lt;span&gt;&quot;webpack://webpack-source-demo/./src/index.js&quot;&lt;/span&gt;&lt;span&gt;],&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  names&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&#x27;console&#x27;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&#x27;log&#x27;&lt;/span&gt;&lt;span&gt;],&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  mappings&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&#x27;AACAA,QAAQC,IADE&#x27;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;首先 &lt;code&gt;mappings&lt;/code&gt; 的内容其实是 Base64 VLQ 的编码表示。&lt;/p&gt;&lt;p&gt;内容由三部分组成，分别为：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;英文，表示源码及压缩代码的位置关联&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;逗号，分隔一行代码中的内容。比如说 &lt;code&gt;console.log(a)&lt;/code&gt; 就由 &lt;code&gt;console&lt;/code&gt; 、&lt;code&gt;log&lt;/code&gt; 及 &lt;code&gt;a&lt;/code&gt; 三部分组成，所以存在两个逗号。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;分号，代表换行&lt;/span&gt;&lt;/p&gt;&lt;p&gt;逗号和分号想必大家没啥疑问，但是对于这几个英文内容应该会很困惑。&lt;/p&gt;&lt;p&gt;其实这就是一种压缩数字内容的编码方式，毕竟源代码可能很庞大，用数字表示行数及列数的话 source map 文件将也会很庞大，因此选用 Base 64 来代表数字用以减少文件体积。&lt;/p&gt;&lt;p&gt;比如说 &lt;code&gt;A&lt;/code&gt; 代表了数字 0，&lt;code&gt;C&lt;/code&gt; 代表了数字 1 等等，有兴趣的读者可以通过&lt;span&gt;该网站&lt;sup&gt;[6]&lt;/sup&gt;&lt;/span&gt;了解映射关系。&lt;/p&gt;&lt;p&gt;了解了这层编码的映射关系，我们再来聊聊这一串串英文到底代表了什么。&lt;/p&gt;&lt;p&gt;其实这每串英文中的字母都代表了一个位置：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;压缩代码的第几列&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;哪个源代码文件，毕竟可以多个文件打包成一个，对应 &lt;code&gt;sources&lt;/code&gt; 字段&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;源代码第几行&lt;/span&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;源代码第几列&lt;/span&gt;&lt;span&gt;&lt;span&gt;5.&lt;/span&gt;&lt;code&gt;names&lt;/code&gt; 字段里的索引&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这时读者可能有个疑惑，为啥没有压缩代码的第几行表示？这是因为压缩后的代码就一行，所以只需要表示第几列就行了。&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;更新：有读者询问 Base64 表达的数字是有上限的，如果需要表示的数字很大的话该怎么办。实际上除了每个分号中的第一串英文是用来表示代码的第几行第几列的绝对位置之外，后面的都是相对于之前的位置来做加减法的。&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;了解完以上知识以后，我们就来根据上文的内容解析下 &lt;code&gt;AACAA&lt;/code&gt; 的具体含义吧，通过&lt;span&gt;该网站&lt;sup&gt;[7]&lt;/sup&gt;&lt;/span&gt;我们可以知道 &lt;code&gt;AACAA&lt;/code&gt; 对应了 &lt;code&gt;[0,0,1,0,0]&lt;/code&gt;，这里需要注意的是数字都从 0 开始，笔者表述的时候会自动加一，毕竟代码第零行听起来怪怪的。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;压缩代码的第一列&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;第一个源代码文件，也就是 &lt;code&gt;index.js&lt;/code&gt; 文件了&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;源代码第二行了&lt;/span&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;源代码的第一列&lt;/span&gt;&lt;span&gt;&lt;span&gt;5.&lt;/span&gt;&lt;code&gt;names&lt;/code&gt; 数组中的第一个索引，也就是 &lt;code&gt;console&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;通过以上的解析，我们就能知道 &lt;code&gt;console&lt;/code&gt; 在源代码及压缩文件中的具体位置了。&lt;/p&gt;&lt;p&gt;但是为什么 source map 会知道编译后的代码具体在什么位置呢？这里就要用到 AST 了。让我们打开&lt;span&gt;网站&lt;sup&gt;[8]&lt;/sup&gt;&lt;/span&gt;输入 &lt;code&gt;console.log(a)&lt;/code&gt; 后观察右边的内容，你应该会发现如图所示的数据：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.36261261261261263&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tibUxowsg9P2PkjvZPqibNOnnd9iaJygNpPBxqr1HzE42AqolTFRp4SMtg9Ra8ICw8rjo0lAh3oiaS4Jfkiauuic4z7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;888&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;image-20210516214636867&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;因为 source map 是由 AST 产出的，所以我们能用上 AST 中的这个数据。&lt;/p&gt;&lt;h2&gt;source map 的应用&lt;/h2&gt;&lt;p&gt;一般来说 source map 的应用都是在监控系统中，开发者构建完应用后，通过插件将源代码及 source map 上传至平台中。一旦客户端上报错误后，我们就可以通过&lt;span&gt;该库&lt;sup&gt;[9]&lt;/sup&gt;&lt;/span&gt;来还原源代码的报错位置（具体 API 看文档即可），方便开发者快速定位线上问题。&lt;/p&gt;&lt;h2&gt;最后&lt;/h2&gt;&lt;p&gt;source map 是我们日常中经常用到的东西，但是直到学习这块内容的时候才知道居然涉及到了那么多的知识盲区。&lt;/p&gt;&lt;p&gt;大家如果有什么疑问欢迎在评论区交流。&lt;/p&gt;&lt;h4&gt;引用链接&lt;/h4&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; source map: &lt;em&gt;https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[2]&lt;/code&gt; 文档地址: &lt;em&gt;https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[3]&lt;/code&gt; 该库: &lt;em&gt;https://github.com/mozilla/source-map&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[4]&lt;/code&gt; 具体代码: &lt;em&gt;https://github.com/webpack/webpack-sources/blob/master/lib/SourceMapSource.js&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[5]&lt;/code&gt; MDN 文档: &lt;em&gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/SourceMap&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[6]&lt;/code&gt; 该网站: &lt;em&gt;https://www.murzwin.com/base64vlq.html&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[7]&lt;/code&gt; 该网站: &lt;em&gt;https://www.murzwin.com/base64vlq.html&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[8]&lt;/code&gt; 网站: &lt;em&gt;https://astexplorer.net/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[9]&lt;/code&gt; 该库: &lt;em&gt;https://github.com/mozilla/source-map&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;如果觉得不错，素质三连、或者点个「&lt;span&gt;赞&lt;/span&gt;」、「&lt;span&gt;在看&lt;/span&gt;」都是对笔者莫大的支持，谢谢各位大佬啦~&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我的付费社区「前端怎么玩」&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里你能获得些什么？&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我学习的路径，平时看到的好文章、想法、资料、新技术都会整理好分享出来，帮助你更快成长，开阔眼界，拓宽技术栈。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你的疑问，工作上、技术、职业等等无限次提问，不方便暴露隐私还可以匿名提问，我能回答的肯定会聊聊我的想法。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不定期的线上学习活动组织，打卡分享。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;一月一期的高质量分享及答疑，包括简历修改、模拟面试等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一个高质量的微信群。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5114285714285715&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tibUxowsg9P1WiahnAfMqmn3T80giciaGib1WS4huqnXAhfliaiahmq2sPqelbOJNyuR3FpdTiaBogSPlqoq1H1BforFFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1400&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>20f9ea0e2f562d21276f5f392baeb331</guid>
<title>对话阿里副总裁叶军：你们误会 TO B 了，钉钉的底层逻辑</title>
<link>https://toutiao.io/k/shuynwm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>