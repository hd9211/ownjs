<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>34f5d544750e794f0bc96c53e8ed9983</guid>
<title>汤楚熙：美团实时数仓架构演进与建设实践</title>
<link>https://toutiao.io/k/ctkg4cp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-backh=&quot;156&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;561&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;156&quot; data-fileid=&quot;100072321&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2777777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPjicBGnN2Sv2xfMf0eh07fxe53FSEJr7ogaf9QJMSV0iboV8bKNibavEhvl3VqpqOQVXI1r4kwgIhLjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPjdrlkyhHH3BZDV05IvhuKOic0so28M9B0cD8Hqia6HMpWBZhzfsTqP48RHZwSfonCSA3OtgJoM212A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-bottom: -10px; margin-left: -8px; max-width: 100%; width: 18px; height: 18px; border-top: 8px solid rgb(54, 65, 173); border-left: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;br data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;/&gt;&lt;/section&gt;&lt;section data-bgopacity=&quot;50%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot; data-style=&quot;max-width: 100%; width: 543.333px; background: rgb(247, 247, 247); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;分享嘉宾：汤楚熙 美团&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;编辑整理：李瑶 DataFun&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;出品平台：DataFunTalk&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;max-width: 100%; width: 18px; height: 18px; border-bottom: 8px solid rgb(54, 65, 173); border-right: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;导读：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;大家好，我叫汤楚熙，来自美团数据平台中心的计算平台团队，当前主要工作内容是实时数仓平台的研发。&lt;/span&gt;&lt;span&gt;今天和大家分享一下实时数据在美团的典型应用场景，实时数仓建设中的挑战和解决方案，包括一些关键的设计细节。主要介绍以下几方面内容：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;建设背景&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;首先，来介绍一下美团实时数据的典型应用场景以及建设过程遇到的一些问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;实时数据在美团的典型应用场景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBYFqejv3H9cOFUiaYZMMtWHlQIFU2ZNicMOHo0Ir7xFmoHEvlZPE1t8icg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;美团作为本地生活领域的头部公司，在内部孵化了许多独立业务，可以看到有大家所熟悉的美团外卖、酒店、美团优选等，这些业务通过实时数据来支撑其内部各种各样的数据应用场景，比如BI、算法、骑手调度等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBUZBnjRrm4hw0O5g2e6zS26FpavVq3eMN4N0Zu10MTTiaw18TIQl2C3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们对业务场景做了一个简单的分类：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;指标监控：比如有实时大盘，用来即时反馈业务当日运转的健康度等场景；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;实时特征：比如搜索、广告CTR预估、骑手调度等，对算法特征数据新鲜度要求较高的场景；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;事件处理：比如一些风控类、运营活动发券等事件驱动型场景；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据对账：比如&lt;/span&gt;&lt;span&gt;金融的支付业务，支付部门与业务部门各自独立，当业务部门的支付单据与支付部门不一致时，会造成资损，这时数据的实时对账就非常关键。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBltMbWY2ZMQeDxvVmvlkUbEBbmibAml51DKUby922H1AnDu1UU2Y32RA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图可以看到，截至目前，实时计算平台所支撑的实时数据处理场景的整体规模，&lt;/span&gt;&lt;span&gt;说明实时数据在美团已经影响到了业务的方方面面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQB0uzg3I8AelZ5NWuGWj9aphsyvuhaHIgLcnk6bXZibDJC4gPicLwcfyuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实时计算平台从成立以来，经历了上图中的几个关键发展阶段。&lt;/span&gt;&lt;span&gt;平台正式成立于2014年，我们引入Storm和Spark Streaming作为美团的第一代实时计算引擎，并且发布了第一版作业托管平台。接下来在2017年，平台正式引进了Flink，并开始初步探索以Flink SQL为主的实时数仓开发方式。并于2019年，正式将Flink SQL作为主要编程接口暴露给业务，将以任务为中心的开发模式，升级为以数据为中心的开发模式。当前，计算平台紧跟业界发展潮流，将工作内容都聚焦在数仓增量化生产、流批语义统一、统一实时离线数仓建模方式等几个方向上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 实时数仓建设过程中的问题及痛点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBGQLyjJ6tk2ItdkURNXZKD5wcZAQhjBxoVFhnN18Qcy6oHP8wFZQARA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在正式开始介绍数仓平台的建设实践之前，先来回顾下平台初期所遇到的问题。&lt;/span&gt;&lt;span&gt;实时数据开始建设之初，是没有离&lt;/span&gt;&lt;span&gt;线数仓那样成熟的建设方法论的，而且也没有离线数仓领域那样成熟的开发工具，所以带来了以下几点问题&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;首先就是高昂的开发运维成本，每次计算框架的升级，业务都需要学习一遍计算框架的API。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码本地开发，再去线上调试，本地的case难以覆盖线上的数据问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务各自的数据协议不统一，相互之间进行数据交换，沟通协作的成本也是比较高昂的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数仓的建设方式没有统一规范，导致数据的冗余和重复建设，给后期的资源治理带来了非常大的麻烦。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBvM4Pjq9dOW3mX6JKWKtEefZNS8GJ7EqUH5dulF3cZ0iaQZdhoAW2MFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上面的问题出发，我们制定了平台的建设路线。&lt;/span&gt;&lt;span&gt;主要集中在两个层面，&lt;/span&gt;&lt;span&gt;首先是降低业务的开发运维门槛，让实时数仓开发可以像离线数仓开发那样简单高效。&lt;/span&gt;&lt;span&gt;比如我们提供了标准的ETL作业模板，web集成开发环境，并且扩展了SQL的能力，使业务可以尽量以符合其认知的形式去进行代码开发。&lt;/span&gt;&lt;span&gt;还有数仓建设中业务最关心的数据质量问题，我们也提供了相应的配套工具，帮助业务以尽可能低的成本将可靠的数据交付应用方。&lt;/span&gt;&lt;span&gt;可用性在离线数仓建设过程中可能大多体现在数据是否按时就绪，那么实时数仓对数据的时延要求更高，所以可用性的保障也非常关键。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面提到的都是在开发运维效率方面我们所做的一些建设规划，在大数据领域，一个&lt;/span&gt;&lt;span&gt;底层算子性能的小小改进，都会使执行效率成倍的放大，所以我们也会花费一些精力在底层算子的优化上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;两横三纵，其中&lt;/span&gt;&lt;span&gt;两横包括&lt;/span&gt;&lt;span&gt;开发迭代效率，面向人的优化，重点在于对工作流。&lt;/span&gt;&lt;span&gt;三纵包括&lt;/span&gt;&lt;span&gt;能做（&lt;/span&gt;&lt;span&gt;看得见、摸得着的问题）、&lt;/span&gt;&lt;span&gt;做好和&lt;/span&gt;&lt;span&gt;最优化。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;平台架构设计&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;接下来开始着重介绍我们是如何解决上面所提到的问题的。&lt;/span&gt;&lt;span/&gt;&lt;span&gt;首先从整体上来介绍下平台解决上面问题的思路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQB98QiaZpChXWSFTYzbS2nRYAxb3sWicmzfxFnmsxJPXL7cEJ13kRdIibUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图是平台整体架构。&lt;/span&gt;&lt;span&gt;从下向上来看，存储、计&lt;/span&gt;&lt;span&gt;算、调度加上日志服务构成了我们的基础服务层。&lt;/span&gt;&lt;span&gt;基础服务层之上是平台对业务提供的一些中间件。&lt;/span&gt;&lt;span&gt;上层是平台抽象出的一些可自行组合的微服务集合，比如作业模板服务、&lt;/span&gt;&lt;span&gt;UDF&lt;/span&gt;&lt;span&gt;托管服务、元数据服务、指标采集监控、数据质量管理等，这些服务业务可以按自身的场景需要来在自己的业务内部自行组合，也可以直接使用平台包装好的大而全的集成开发平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQB4HY4vx39LcKJPn4eNW2DAdGw3bkicP69ve7H8xVnSs3wYNQcGaCYuwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图展示了平台基础服务中最关键的计算服务的选型过程。&lt;/span&gt;&lt;span&gt;实时数仓场景的最根本业务诉求是数据的时效性，这里的时效性通常指的是秒级的延迟，所以这里Flink和Storm胜出。&lt;/span&gt;&lt;span&gt;其次是数据的正确性，Flink是这里唯一能够保证Exectly-Once计算语义的框架，所以Flink要优于storm。&lt;/span&gt;&lt;span&gt;之后我们有做了benchmark测试，通过实验证明了，在绝大多数场景下Flink任务的吞吐要优于Storm，而且Flink还提供了更加成熟的SQL编程接口，&lt;/span&gt;&lt;span&gt;所以我们最终确认选择Flink作为实时数仓的核心计算框架。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBaWbN38PIibEQB6ubYWibEejXRlvYgXnm52IwRMXs6fyEdENhBIE4Nhpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解决了计算框架的问题，接下来我们要从上层概念入手，让熟悉离线数仓开发的同学能够更快的上手实时数仓的开发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从下向上看，我们先统一了离线和实时数仓的数据模型，无论是&lt;/span&gt;&lt;span&gt;HiveT&lt;/span&gt;&lt;span&gt;able&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Kafka&lt;/span&gt;&lt;span&gt;Topic&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;span&gt;的一个域，在上层暴露给业务的都是一张&lt;/span&gt;&lt;span&gt;Table&lt;/span&gt;&lt;span&gt;，这样业务没有过多认知上的负担了，可以在不同开发场景的概念之间轻松切换。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上向下看，我们又统一了编程接口，使用SQL作为数仓开发的首选，这样实时和离线数仓的ETL逻辑甚至可以完全共用一套，对开发效率上也有显著的提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBgVSWYyNU8mM1d2LhfUIuZrlaccT4TLLngd9wOxn2r2DW1nicicdFcRvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有同学可能会问，实时和离线场景的计算语义不完全相同，实时计算场景需要包含大量跟时态相关的语法，比如window，interval等，离线场景上没有，那么怎么统一呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;的确如此，所以我们独立出一套SQL服务，短期用户也可以在SQL中加入HINT提升或者是直接提供一些参数，来告诉我们这是什么离线还是实时场景的ETL，未来我们会自动根据业务的输入、输出表的存储类型，ETL的模式，自动判断使用哪种类型的执行模式更有效。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;跟社区如果对不齐怎么办：&lt;/span&gt;&lt;span&gt;先对内解问题，如果效果真的不错，可以推回社区，如果社区有更好的方案，我们可以判断是否能够&lt;/span&gt;&lt;span&gt;merge&lt;/span&gt;&lt;span&gt;进来，如果不行，说明我们的架构设计本身就是有问题的。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;平台建设实践&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 实时数仓开发解决方案&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBneF2W9VxhscZ6DEaWnny3PeCM8POTNvllHQ4DsiatwQjQR9ibPx586lg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们对数仓平台的定位是：集需求准备、开发测试、发布和运维监控能力的一站式实时数仓生产解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面简单来介绍一下用户在平台上的工作流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在需求准备阶段，用户可以结合业务需求先来检索是否有满足需求的数据模&lt;/span&gt;&lt;span&gt;型，如果没有找到，那么可以选择从源头开始接入，或者新建模型。模型接入或创建好之后，进入&lt;/span&gt;&lt;span&gt;ETL&lt;/span&gt;&lt;span&gt;开发阶段，开发过程可能会伴随着一些简单的任务调试，这些工作也全部都可以在平台上完成。在开发完成准备上线之前，用户可以创建一条发布流水线，这块内容后面还有详细的介绍，待流水线执行通过后，就可以正式发布作业了，作业上线后，平台会自动收集作业的运行时指标，用来监控作业的运行状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBp5Mumbhu569BCsOKajL31De9oB7CLzib58sGzEV1mPOE2rqZ4yG7Inw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面介绍下，平台是如何规范业务的数仓接入流程的。&lt;/span&gt;&lt;span&gt;从上图（左）&lt;/span&gt;&lt;span&gt;大家可以看到，跟离线数仓的入仓流程相比，在没有数仓平台前，实时数仓的入参过程突出了一个乱字，而这样会带来如下问题：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数&lt;/span&gt;&lt;span&gt;据建设过程没有规范，后面接手的同学不知道从何入手。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;接着上面的问题，如果后面同学按照自己的理解，重新接入一遍数据，长此以往，会造成大量的冗余数据，造成烟囱林立，资源浪费，后面还&lt;/span&gt;&lt;span&gt;需要花大量的时间治理。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数仓接入这个动作本身是没有过多业务逻辑的，是可以标准化和系统化的，这样重复机械的工作内容，会造成人力资源的浪费。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQB88KCrrpm37m535yQ9ZbicE1NMtvE8sNQYzxjJY3x4uvA47G6sfFwoQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;面对上述问题，数仓平台提供了一套完整的实时数仓接入方案。&lt;/span&gt;&lt;span&gt;明确的帮用户生成&lt;/span&gt;&lt;span&gt;ODS&lt;/span&gt;&lt;span&gt;层，这样同项目成员之间的合作，有了共同的规范和约束，不会再有因信息未对齐而造成的数据重复接入。&lt;/span&gt;&lt;span&gt;我们不光帮助用户规范了入仓的流程，还提供了一系列数据正确性、作业稳定性的保障机制，使业务同学可以将精力集中在数仓的建设上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBvIQ1OCelPys7JeKECarpg3YZcb1I47fB43V6nvUNlCNhaghCJNFfDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在规范化业务数仓接入流程的方案设计过程中，有个小小的挑战，那就是我们的数据源并不仅仅来自MySQL binlog和nginx日志，还有大量业务自行通过SDK上报的日志，这些日志的格式难以从整体上进行抽象，而且不同业务因为服务场景不同，数据的序列化方式也难以统一，所以我们抽象出一个Adapter模块，专门用来解决这个问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;P&lt;span&gt;arser&lt;/span&gt;&lt;span&gt;用来适配业务自定义消息格式，&lt;/span&gt;&lt;span&gt;Formatter&lt;/span&gt;&lt;span&gt;将用来监控作业稳定性和数据正确性的元数据信息融入到消息中，最后按照业务场景的实际诉求，允许业务根据自身场景定义序列化方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBiaBtOvNsHeZA481jLn7UzEsm5sJLNGcXJuhtFHKPNNPFAMHtYXT9e0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面介绍了平台在数据入仓阶段如何提升开发效率。&lt;/span&gt;&lt;span&gt;接下来介绍如何帮助业务更低门槛的进行实时数据的开发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;平台上线之初是基于&lt;/span&gt;&lt;span&gt;Flink1.&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;实现的模板任务，在当时来看，他们的能力并不成熟，一些在离线场景比如&lt;/span&gt;&lt;span&gt;SparkSQL&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;HiveSQL&lt;/span&gt;&lt;span&gt;都支持的语法，在&lt;/span&gt;&lt;span&gt;Flink&lt;/span&gt;&lt;span&gt;上支持的并不好。&lt;/span&gt;&lt;span&gt;所以我们决定先由平台自行根据业务需求对语法进行扩展。&lt;/span&gt;&lt;span&gt;比如t&lt;/span&gt;&lt;span&gt;able&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;UDF&lt;/span&gt;&lt;span&gt;的声明，还有insert into&lt;/span&gt;&lt;span&gt;等语法的支持。&lt;/span&gt;&lt;span&gt;当然这并不是全部。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBGsYT3LRI7PkSXdGoVsj4AeRa91oHTc0V8qpFbNBLuc90cwHEgbCLVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们不仅仅在&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;语法层面进行了改进，&lt;/span&gt;&lt;span&gt;还对作业模板进行了增强。像&lt;/span&gt;&lt;span&gt;watermark&lt;/span&gt;&lt;span&gt;提取对业务时间格式有一些要求，&lt;/span&gt;&lt;span&gt;这种业务场景强相关的逻辑并不适合直接写死在我们的模板程序代码中。&lt;/span&gt;&lt;span&gt;所以我们在作业模板中加入了几个切面，可以由业务自行上传代码来扩充这部分能力。&lt;/span&gt;&lt;span&gt;比如我们会在&lt;/span&gt;&lt;span&gt;Source&lt;/span&gt;&lt;span&gt;注册之后，提供一个切面，引入用户代码，进行日期格式转换，再执行&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;官方虽然已经提供了计算列，我们也调研了相关能力，但是我们认为除非有一个数量级的开发效率优化效果，否则我们没必要一定&lt;/span&gt;&lt;span&gt;follow&lt;/span&gt;&lt;span&gt;官方的语法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBwOuETjKDeaBYib0If5Bvy6iczgCk8omeU2uQ0I2eZEBg9BmQhw0DrDWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经&lt;/span&gt;&lt;span&gt;过对模板的升级改造，可以看到平台能够支持的&lt;/span&gt;&lt;span&gt;ETL&lt;/span&gt;&lt;span&gt;模式已经非常丰富了，后面我们也会继续迭代，目标是可以覆盖&lt;/span&gt;&lt;span&gt;95%&lt;/span&gt;&lt;span&gt;以上的实时&lt;/span&gt;&lt;span&gt;ETL&lt;/span&gt;&lt;span&gt;场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBjNMjAURAQpcYyrQWNcxj1tlLQ4Tr6Fke0icTMnlQPb9ymZqNh6nTBjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;UDF是一种扩展SQL表意能力的重要功能，在没有平台的时候，用户UDF都是散布在各自的代码仓库中的，这样一些较通用的UDF，不能被其他业务直接使用，业务在代码中执行一些有安全风险的行为，平台也无法有效管控。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以我们建设了一套&lt;/span&gt;&lt;span&gt;UDF&lt;/span&gt;&lt;span&gt;托管服务，帮助业务集中托管&lt;/span&gt;&lt;span&gt;UDF&lt;/span&gt;&lt;span&gt;代码，可以编译打包时，进行提前检查、并暴露安全风险，而且通用&lt;/span&gt;&lt;span&gt;UDF&lt;/span&gt;&lt;span&gt;可以在业务之间共享，也能够帮助业务提升开发效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBAIZ160SJIQjjicC9Eibs6zlYoQlMWveRaiaz6VRM6M8LcSBpoaewAFPicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面的内容，主要是如何解决开发效率的问题，下&lt;/span&gt;&lt;span&gt;部分内容的重点是，如何保证业务的数据质量。&lt;/span&gt;&lt;span&gt;可能在场的各位同学，有后台开发的相关经验，大家可能都了解&lt;/span&gt;&lt;span&gt;Devops&lt;/span&gt;&lt;span&gt;方法论的核心目标，是保证迭代效率和工程质量。&lt;/span&gt;&lt;span&gt;实时数据开发其实与后台服务开发过程有相似的地方，作业发布后，数据就会立即生效，&lt;/span&gt;&lt;span&gt;并作用于线上，所以我们也需要一套流程，来保证我们每次实时任务发布的数据质量不用影响到我们的数据服务质量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们设计了一套数仓发布的&lt;/span&gt;&lt;span&gt;Pipeline&lt;/span&gt;&lt;span&gt;，在每次任务迭代上线过程都会执行一次&lt;/span&gt;&lt;span&gt;Pipeline&lt;/span&gt;&lt;span&gt;过程，&lt;/span&gt;&lt;span&gt;TestCase&lt;/span&gt;&lt;span&gt;就类似于单测用例，理论上所有&lt;/span&gt;&lt;span&gt;TestCase&lt;/span&gt;&lt;span&gt;都通过才可以发布作业。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Pipeline服务是通过一个异步任务调度框架来实现的，每个Worker内会启动一个Flink的MiniCluster进程，执行后会将结果存入DB并在前端打印执行结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBfz5pZlAyAB3MsjTdZicicjQjzSQQHQ1cibIGd7RANicq2INkicwb7DDVn0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于数据质量，业务还有一项非常关心的事项，也就是数据的时延。时延一方面可以说明业务交付的数据是否符合应用方的预期，另一方面也方便业务自己去排查问题，确定作业的性能瓶颈点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Flink&lt;/span&gt;&lt;span&gt;官方提供了一个用来计算延迟情况的机制，&lt;/span&gt;&lt;span&gt;Latency Marker&lt;/span&gt;&lt;span&gt;，这个东西近似于&lt;/span&gt;&lt;span&gt;Watermark&lt;/span&gt;&lt;span&gt;，是一类与业务数据无关的，由框架周期性产生的消息，我们要做的是根据业务的流量和业务延迟时间精度的要求，控制这类消息的发送频率和发送量，&lt;/span&gt;&lt;span&gt;并支持跨任务传递&lt;/span&gt;&lt;span&gt;Marker&lt;/span&gt;&lt;span&gt;。因为平台收口了数仓接入层，所以这也使我们获取到真正的端到端延迟成为可能，&lt;/span&gt;&lt;span&gt;我们会通过&lt;/span&gt;&lt;span&gt;emitter&lt;/span&gt;&lt;span&gt;向下游发送特殊的消息协议，并且下游任务的&lt;/span&gt;&lt;span&gt;Reciver&lt;/span&gt;&lt;span&gt;会对这类消息做特殊判断，在发送和接受数据时都会将指标上报到&lt;/span&gt;&lt;span&gt;Raptor&lt;/span&gt;&lt;span&gt;，即美团内部的一个业务指标监控，并最终提供给业务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBOPQP4lGiaWIM7etaHsiaicaznYjOKRLdS2ic0otEEsuPbcCwlwVIWgucNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面我们分别介绍了平台是如何提升开发效率和保证业务的数据质量的，主要解决的是数仓开发者的问&lt;/span&gt;&lt;span&gt;题。&lt;/span&gt;&lt;span&gt;平台还有一类用户是数仓架构师，他们不仅仅要参与数仓的建设，还需要对数仓的建设情况做整体性把控。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以前大家都是通过wiki的形式来进行数仓的规范和约束。数仓平台提出了一个项目空间的概念，每个项目空间都可以由架构师定义符合自身业务场景的一些约束项，比如架构师可以定义数仓的主题、分层规范，表、字段的命名规则，同项目空间下的实体都必须遵守负责人做定义的规范。&lt;/span&gt;&lt;span&gt;这样可以在开发之前就保证数仓的建设质量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 算子性能优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面来分享下我们在flink算子层面所做的一些优化工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBsib9hIGK6FWianKfdhLpibIlYTf7KhcQ1tSzj3XYNHZQak2CeDh8SFdXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先实时数仓有很大一部分计算场景是用来做扩维的，也就是流表关联。流数据来自kafka，表数据通常是借助redis、hbase等分布式kv存储，当流量小的时候，每一条流数据都请求一次外存，发起一次网络io，也没有多大影响。但是像基础流量等业务，每天几百上千亿条消息，都去单独请求外存，压力可想而知。所以平台为用户准备了本地缓存机制，通过一个多级缓存的架构，来缓解超大流量下外存访问的IO的压力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBAY2Z54cKqOjGDQmSRcJibxVA85Sia23apphkRaaicoWzxb2JKm7MXicDEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数仓&lt;/span&gt;&lt;span&gt;ETL&lt;/span&gt;&lt;span&gt;会包含大量聚合、关联和排序等逻辑，在有界数据处理的时候，我们对算子行为能够做出较准确的判断。&lt;/span&gt;&lt;span&gt;但是在无界数据处理的情况下，像关联、聚合等逻辑为了保证数据的正确性，会在更新一条记录的同时产生一条回撤消息，用来修复下游已经受到影响的数据，所以实际向下游传递的消息量可能会翻倍。而当涉及到多层算子嵌套，比如聚合嵌套关联，那么消息量还会继续膨胀。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了解决这个问题，我们研究了框架的源码，并分析了业务数据的特征，发现实际上大多数情况消息在极短的时间内会被频繁更新多次，这也就意味着我们可以将多次请求合并成一次请求，来减少状态更新的次数，从而减少向下游发送的消息量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBeuh9E26WdjtRQqPLxgP1qeGTt6ibpxydfeSKXwWBuMG3icf1hiaHCeMhg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图是一个&lt;/span&gt;&lt;span&gt;Join&lt;/span&gt;&lt;span&gt;算子的&lt;/span&gt;&lt;span&gt;优化案例，在分析了原理后，&lt;/span&gt;&lt;span&gt;我们认为可以分三个阶段来对算子进行优化：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;首先在输入阶段，可以对输入的消息做预处理，如果发现同key数据紧跟一条回撤事件，我们这两条消息可以同时消除，而保留最新的一条消息；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;接下来在计算阶段，因为双流关联需要缓存左右流各自的状态，这样我们可以将短时间同&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;对状态的访问，合并成一次，减少状态访问次数；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最后在事件下发阶段，可以判断消息之间的关系，重复记录直接可被直接消除。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 建设成果展示&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBs4diaNcHdWBcSlVorf9jOzzlan7QcgVMmRw7RfBORhIIbjEtLsz8a4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先是我们的Web IDE，左面是菜单栏，可以用来管理项目空间，右面是一个web编辑器，用来开发ETL脚本，编辑器下还提供了控制台，用来查看调试日志和对比调试结果，还有语法错误提示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBeOmVm0x2IXh98nicBibbv3c0pIHD9TOq3orVL2Sqe6YOhFx721SRwDXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图是我们的逻辑模型管理模块，在此我们可以编辑自己的模型信息，查看血缘，资源占用量，数仓相关的业务属性等元数据，来辅助业务更好地进行数仓建模。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBROVS5khzLInia3S8YkT6bMIdxoovquk1HU6a0LC8CXVwMt51FicLajcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后展示的是运维中心，所有的作业运行状况，运行指标，操作日志都可以通过这个平台来管理。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;04&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;未来计划&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBFrJatQcJlib3YQDHc9FSSns7LL5NqPxqXibKYaPtb0gUmkUac2oHJkwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从前面的分享大家可能会看出，平台前期的大部分精力都集中在解决业务实时数仓建设流程方面的问题上。&lt;/span&gt;&lt;span&gt;随着数仓平台在业务上的逐渐推广，以及业务的深度使用，问题更多的出现在框架的&lt;/span&gt;&lt;span&gt;runtime&lt;/span&gt;&lt;span&gt;层面，比如超大作业的调度成功率和时长问题，&lt;/span&gt;&lt;span&gt;超大数据量作业的状态访问性能问题。&lt;/span&gt;&lt;span&gt;希望通过流批一套语义、一套执行层、一套存储，来彻底解决开发运维的成本问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，&lt;/span&gt;&lt;span&gt;随着实时数据扩展至一些ToC业务场景，这些应用有着非常高的可用性要求，所以在这个方向上我们也要继续攻关下去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后就是终极问题，资源和性能比的问题，也就是在确定性的条件下，用最少的资源做最多的事情。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBDafUPSRtF5CoibhFle6iaIj2b4EhZZia3Gc4rOKcxicyRN54tibkSo21gYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是我们平台当前在建设的一个重点项目——数仓增量化生产，为达成真正的流批一体做一些前置性的技术储备和路径探索。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;今天的分享就到这里，谢谢大家。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;在文末分享、点赞、在看，给个3连击呗~&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分享嘉宾：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;289&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPjdrlkyhHH3BZDV05IvhuKOLmiagvjMPlliaqSQNYsx5T6c3b9RgSj29egrVabhnl5n6Av9MqAGUhibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;电子书下载&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;389&quot; data-backw=&quot;578&quot; data-fileid=&quot;100072355&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6733909702209414&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPjicBGnN2Sv2xfMf0eh07fxem4LZeMGOo8FKqdlPdbTWZtXDDHYfNS78E3QkgUh68DMRia11ayJcyOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1041&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;《大数据典藏版合集》&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;电子书目录如上，感兴趣的小伙伴，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;欢迎识别二维码&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，添加小助手微信，回复&lt;/span&gt;&lt;strong&gt;&lt;span&gt;『大数据典藏版合集』&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，即可下载。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;146&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;145&quot; data-fileid=&quot;100072351&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9927007299270073&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;274&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lAStFsJ0Pm0T9eZG6MS4grBiaJAPvOxCotLBIwWiceTLXicvMa6pq5s7ZmCgDFrQQnlWEvhAG1iaKkicXymMicpeVWFA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;关于我们：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;DataFun：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;专注于大数据、人工智能技术应用的分享与交流。发起于2017年，在北京、上海、深圳、杭州等城市举办超过100+线下和100+线上沙龙、论坛及峰会，已邀请近1000位专家和学者参与分享。其公众号 DataFunTalk 累计生产原创文章500+，百万+阅读，12万+精准粉丝。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU1NTMyOTI4Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgiaIKm4YqA09u83TvzKbfsabjfX1TLzaXLAK9MWmC4qI6cuTBJnxygZLZPU49O8g6j8QI9264NMqQ/0?wx_fmt=png&quot; data-nickname=&quot;DataFunTalk&quot; data-alias=&quot;datafuntalk&quot; data-signature=&quot;专注于大数据、人工智能技术应用的分享与交流。致力于成就百万数据科学家。定期组织技术分享直播，并整理大数据、推荐/搜索算法、广告算法、NLP 自然语言处理算法、智能风控、自动驾驶、机器学习/深度学习等技术应用文章。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;🧐&lt;strong&gt;分享、点赞、在看&lt;/strong&gt;，给个&lt;strong&gt;3连击&lt;/strong&gt;呗！&lt;strong&gt;👇&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>49b88dce795696cbfa44fb0b7013a6fb</guid>
<title>宣布Kubernetes策略管理白皮书</title>
<link>https://toutiao.io/k/m17h97v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;285&quot; data-backw=&quot;540&quot; data-ratio=&quot;0.5277777777777778&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJykl78gSWLQ2BgZksNPibndNocPwMVzKNtDfsfv3SOwcYJM1Ypwib7uPlyXjMLMCnxwYxkBHhgvFJNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;540&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：Jim Bugwadia&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CNCF Kubernetes 安全 SIG 和策略工作组（WG）刚刚发布了&lt;span&gt;Kubernetes 策略管理白皮书&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;，以帮助社区了解使用策略管理 Kubernetes 配置的最佳实践。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该白皮书旨在提供一个清晰的理解为什么 Kubernetes 策略管理对 Kubernetes 集群和工作负载的安全和自动化是重要的。它还描述了 Kubernetes 策略可以帮助解决哪些问题，以及如何实现 Kubernetes 策略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“策略可以简化开发人员、操作人员、安全工程师和合规官员对 Kubernetes 配置和安全控制的管理。在云原生环境中，除了应用运行时安全外，在连续交付流水线和准入控制中执行策略有助于将安全性向左转移，加强软件供应链安全。本白皮书代表了社区的努力，在阐明 Kubernetes 集群操作、安全、持续遵从性和管理策略的作用方面迈出了重要的一步。”CNCF Kubernetes 策略工作组 Aradhna Chetal 说。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该白皮书介绍了跨云原生生命周期的基于策略的操作的新指导，并讨论了 Kubernetes 策略管理的参考架构，提供了所需的每个组件的描述。该白皮书还讨论了策略如何映射到其他安全领域，如威胁建模、保证和遵从性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kubernetes 安全 SIG 安全专注于提高 Kubernetes 项目跨所有组件的安全性。如果你对参与安全 SIG 感兴趣，请查看&lt;span&gt;宪章&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;以获得更多信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kubernetes 工作组的组织是为了解决跨 SIG 的特定主题。&lt;span&gt;Kubernetes 策略工作组&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;专注于 Kubernetes 的策略实现、架构和最佳实践。如果你对推进 Kubernetes 策略管理感兴趣，请加入&lt;span&gt;即将召开的会议&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;或在&lt;span&gt;Slack 频道&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;上向小组发送消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kubernetes 策略管理文白皮书可以在&lt;span&gt;GitHub&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;上找到。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Kubernetes 策略管理白皮书: &lt;em&gt;https://github.com/kubernetes/sig-security/blob/main/sig-security-docs/papers/policy/CNCF_Kubernetes_Policy_Management_WhitePaper_v1.pdf&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;宪章: &lt;em&gt;https://github.com/kubernetes/community/blob/master/sig-security/charter.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;Kubernetes 策略工作组: &lt;em&gt;https://github.com/kubernetes/community/tree/master/wg-policy&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;即将召开的会议: &lt;em&gt;https://github.com/kubernetes/community/tree/master/wg-policy#meetings&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;Slack 频道: &lt;em&gt;https://kubernetes.slack.com/messages/wg-policy&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;GitHub: &lt;em&gt;https://github.com/kubernetes/sig-security/tree/main/sig-security-docs/papers/policy&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击【阅读原文】阅读网站原文。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;161&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;161&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJyjIvCTT9MHACYHrhxPr4WTsLl4cia1yECXm3kibDvzgdhicxAibuG9mokxesEs2e3wxL9sj1ApfdOKCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CNCF概况（幻灯片）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-copyright=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;161&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;161&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJxyapkOjiazruKNQ7DZ6t8TSh0QSYM4DlI86xnXiayciayIgBUaG8q8lFZ3FsibPJiaeCqAahrKicB220aA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;301&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;扫描二维码联系我们！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;CNCF (Cloud Native Computing Foundation)成立于2015年12月，隶属于Linux  Foundation，是非营利性组织。 &lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;&lt;strong&gt;&lt;em&gt;CNCF&lt;/em&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;（&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;&lt;strong&gt;&lt;em&gt;云原生计算基金会&lt;/em&gt;&lt;/strong&gt;）致力于培育和维护一个厂商中立的开源生态系统，来推广云原生技术。我们通过将最前沿的模式民主化，让这些创新为大众所用。请长按以下二维码进行关注。&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJyq2qDvc7MWGZxI4RSwuQcDYF9lD2fuOvw9rvdXWTxODu56IibWa0R8mibibhqExqurr6168Wjf2VstQ/640?wx_fmt=png&quot; data-copyright=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;165&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;165&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/GpkQxibjhkJxKPX3Ywf6bvZic6ibE8EzomstVhFq0ua8p8KI8PdVve5Q6YwRzHYQ4j63hKakYPcbqAdDoRHrgcFLg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>26130370a415c0b19e3a55c1ad8f5936</guid>
<title>『每周译Go』Golang 在大规模流处理场景下的最小化内存使用</title>
<link>https://toutiao.io/k/1asw7xf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为公司平台团队的一员，我接触了很多文件处理的场景，比如管理一个通用文件上传中心服务，处理邮件附件，处理和导出大文件。在过去，这项工作要容易得多，因为我们可以完全支配整个服务器。我们可以写入一个文件让它持久化在服务器磁盘上，尽管这个作业所需的资源是非常多的。而现在，你的代码库是在更小的处理单元上发布的，比如 pods 。它的资源是虚拟分配的，并且在许多情况下是有限的，所以你需要知道如何有效地使用它们。实现优雅的处理和解决 OOM 退出问题也许对于那些已经熟悉自由地使用内存的人来说是一个大麻烦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我看来，&lt;code&gt;Reader&lt;/code&gt; 和 &lt;code&gt;Writer&lt;/code&gt; 是 Golang 最重要的部分。它给 goroutine 和并发处理提供了重要支持，是 Go 编程模型精简且具有良好性能的关键。因此，为了更进一步掌握 Go 编程语言，你应该能够优雅地操作 go buffers 和 goroutines。在本文中，我将讨论在文件上传到云存储引擎之前，处理从卫星客户端的文件流到中央文件上传器时遇到的问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h4&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;Multipart 文件转发&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.4595436&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbCyXP3z23wev93ayibMU82aoibhxSxYyhTMesew1jdNn8iaDN7icQt1HJJZ22hvydSYfdRfQ6wbEcEPVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;964&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Golang，如果你搜索任何类似 &lt;code&gt;reader&lt;/code&gt; 操作，你应该得到过下面这些内容：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;r := strings.NewReader(&lt;span&gt;&quot;Go is a general-purpose language designed with systems &lt;br/&gt;programming in mind.&quot;&lt;/span&gt;)&lt;br/&gt;b, err := ioutil.ReadAll(r)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;   log.Fatal(err)&lt;br/&gt;}&lt;br/&gt;// Playing with your loaded bytes&lt;br/&gt;fmt.Printf(&lt;span&gt;&quot;%s&quot;&lt;/span&gt;, b)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在你的代码中看到这样的东西是很常见的，因为在互联网上的许多实践都使用了这种方法。自从我第一次使用 &lt;code&gt;Reader&lt;/code&gt;，我也确实习惯了这样用。但是，如果你过度使用它，可能会对内存使用造成很大的损耗，这将极大地影响你可以处理的数据量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;典型场景当你读取的数据是已经预定义好格式的，这意味着在你读取它之后，还必须将它传递给另一个数据处理器再返回你的工作。你可能会使用的一种选择是 &lt;code&gt;io.Copy&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;r := strings.NewReader(&lt;span&gt;&quot;some io.Reader stream to be read\n&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; _, err := io.Copy(os.Stdout, r); err != nil {&lt;br/&gt;  log.Fatal(err)&lt;br/&gt;}&lt;br/&gt;// The data have been copied from Reader r to Stdout&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Copy&lt;/code&gt; 是一种非常方便的操作，因为在将数据写入另一个文本进程之前，我们不需要读取数据。然而要小心的是这可能会导致你落入一个不想踏入的陷阱。官方文件中写道:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;从 src 复制副本到 dst，直到在 src 上到达 EOF 或发生错误。它返回复制的字节数和复制时遇到的第一个错误(如果有的话)。— Go 官方文档&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在文件离线处理时，你可以打开一个带缓冲的 &lt;code&gt;writer&lt;/code&gt; 然后完全复制 &lt;code&gt;reader&lt;/code&gt; 中内容，并且不用担心任何其他影响。然而，&lt;code&gt;Copy&lt;/code&gt; 操作将持续地将数据复制到 &lt;code&gt;Writer&lt;/code&gt;，直到 &lt;code&gt;Reader&lt;/code&gt; 读完数据。但这是一个无法控制的过程，如果你处理 &lt;code&gt;writer&lt;/code&gt; 中数据的速度不能与复制操作一样快，那么它将很快耗尽你的缓冲区资源。此外，选择丢弃或者撤销缓冲区分配也是一件很难考虑的事情。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;buf := new(bytes.Buffer)&lt;br/&gt;writer := multipart.NewWriter(buf)&lt;br/&gt;defer writer.Close()&lt;br/&gt;part, err := writer.CreateFormFile(&lt;span&gt;&quot;file&quot;&lt;/span&gt;, &lt;span&gt;&quot;textFile.txt&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;}&lt;br/&gt;file, err := os.Open(name)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;}&lt;br/&gt;defer file.Close()&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; _, err = io.Copy(part, file); err != nil {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;}&lt;br/&gt;http.Post(url, writer.FormDataContentType(), buf)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里 &lt;code&gt;io.Pipe&lt;/code&gt; 就出现来解决这类问题。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;r, w := io.Pipe()&lt;br/&gt;go &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;   fmt.Fprint(w, &lt;span&gt;&quot;some io.Reader stream to be read\n&quot;&lt;/span&gt;)&lt;br/&gt;   w.Close()&lt;br/&gt;}()&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; _, err := io.Copy(os.Stdout, r); err != nil {&lt;br/&gt;   log.Fatal(err)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Pipe&lt;/code&gt; 提供一对 &lt;code&gt;writer&lt;/code&gt; 和 &lt;code&gt;reader&lt;/code&gt;，并且读写操作都是同步的。利用内部缓冲机制，直到之前写入的数据被完全消耗掉才能写到一个新的 &lt;code&gt;writer&lt;/code&gt; 数据快。这样你就可以完全控制如何读取和写入数据。现在，数据吞吐量取决于处理器读取文本的方式，以及 &lt;code&gt;writer&lt;/code&gt; 更新数据的速度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我用它来做我的微服务文件转发器，实际工作效果非常好。能够以最小的内存使用量来复制和传输数据。有着 &lt;code&gt;Pipe&lt;/code&gt; 提供的写阻塞功能 ，&lt;code&gt;Pipe&lt;/code&gt; 和 &lt;code&gt;Copy&lt;/code&gt; 就形成了一个完美的组合。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;r, w := io.Pipe()&lt;br/&gt;m := multipart.NewWriter(w)&lt;br/&gt;go &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;   defer w.Close()&lt;br/&gt;   defer m.Close()&lt;br/&gt;   part, err := m.CreateFormFile(&lt;span&gt;&quot;file&quot;&lt;/span&gt;, &lt;span&gt;&quot;textFile.txt&quot;&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   file, err := os.Open(name)&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   defer file.Close()&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; _, err = io.Copy(part, file); err != nil {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;}()&lt;br/&gt;http.Post(url, m.FormDataContentType(), r)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在文件到达文件上传服务的最终目的地之前，这实际上就是我们的文件在各个服务之间传输的方式。文件流可以通过 &lt;code&gt;os.Open()&lt;/code&gt; 在本地加载，也可以通过 &lt;code&gt;multipart reader&lt;/code&gt; 从其他请求中加载。&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;预取和补偿文件流&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.4595436&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbCyXP3z23wev93ayibMU82aoibhxSxYyhTMesew1jdNn8iaDN7icQt1HJJZ22hvydSYfdRfQ6wbEcEPVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;964&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们的中央文件上传服务中，我们使用云引擎进行存储，它的 API 接受一个提供文件原始数据的 &lt;code&gt;reader&lt;/code&gt;。除此之外，我们还需要识别上传的内容类型，以确定是否将其删除，还是将其分类到可用的 bucket 中。但是，读取操作是不可逆的，我们必须找到一种方法，为类型检测器读取最小长度的嗅探字节，同时也需要为后一个过程保留原始数据流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个可行的解决方案是使用 &lt;code&gt;io.TeeReader&lt;/code&gt;，它会将从 reader 读取的数据写入另一个 &lt;code&gt;writer&lt;/code&gt; 中。&lt;code&gt;TeeReader&lt;/code&gt; 最常见的用例是将一个流克隆成一个新的流，在保持流不被破坏的情况下为 &lt;code&gt;reader&lt;/code&gt; 提供服务。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;var r io.Reader = strings.NewReader(&lt;span&gt;&quot;some io.Reader stream to be read\n&quot;&lt;/span&gt;)&lt;br/&gt;var buf = bytes.NewBufferString(&lt;span&gt;&quot;&quot;&lt;/span&gt;)&lt;br/&gt;r = io.TeeReader(r, buf)&lt;br/&gt;// Everything &lt;span&gt;read&lt;/span&gt; from r will be copied to buf.&lt;br/&gt;_, _ = io.ReadAtLeast(r, mimeType, 512)&lt;br/&gt;// Continue to copy the stream to write it to buf, to use buf &lt;span&gt;in&lt;/span&gt; the following operation&lt;br/&gt;io.Copy(io.Discard, r)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但问题是，如果在将其传递给 GCP 文件处理程序之前同步运行它，它最终还是会将所有数据复制到准备好的缓冲区。一个可行的方法是再次使用 &lt;code&gt;Pipe&lt;/code&gt; 来操作它，达到无本地缓存效果。但另一个问题是，&lt;code&gt;TeeReader&lt;/code&gt; 要求在完成读取过程之前必须完成写入过程，而 &lt;code&gt;Pipe&lt;/code&gt;则相反。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以最后我们设计了一个定制化的预取 &lt;code&gt;reader&lt;/code&gt;，专门用来处理这种情况。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package services&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;   &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; prefetchReader struct {&lt;br/&gt;   reader   io.Reader&lt;br/&gt;   prefetch []byte&lt;br/&gt;   size     int&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func newPrefetchReader(reader io.Reader, prefetch []byte) *prefetchReader {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &amp;amp;prefetchReader{&lt;br/&gt;      reader:   reader,&lt;br/&gt;      prefetch: prefetch,&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (r *prefetchReader) Read(p []byte) (n int, err error) {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; len(p) == 0 {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; 0, fmt.Errorf(&lt;span&gt;&quot;empty buffer&quot;&lt;/span&gt;)&lt;br/&gt;   }&lt;br/&gt;   defer &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;      r.size += n&lt;br/&gt;   }()&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; len(r.prefetch) &amp;gt; 0 {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; len(p) &amp;gt;= len(r.prefetch) {&lt;br/&gt;         copy(p, r.prefetch)&lt;br/&gt;         n := len(r.prefetch)&lt;br/&gt;         r.prefetch = nil&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; n, nil&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;         copy(p, r.prefetch[:len(p)])&lt;br/&gt;         r.prefetch = r.prefetch[len(p):]&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; len(p), nil&lt;br/&gt;      }&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; r.reader.Read(p)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用这个 &lt;code&gt;reader&lt;/code&gt;，你可以预取一些嗅探字节以进行处理，然后使用补偿字节创建一个新的嵌套 &lt;code&gt;reader&lt;/code&gt; 用于后面的操作。&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4595436&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbCyXP3z23wev93ayibMU82aoibhxSxYyhTMesew1jdNn8iaDN7icQt1HJJZ22hvydSYfdRfQ6wbEcEPVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;964&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是我在工作中遇到的问题。操作这些 &lt;code&gt;readers&lt;/code&gt; 和 &lt;code&gt;writers&lt;/code&gt; 是非常麻烦的，但还是非常值得一试，因为这其中包含了很多乐趣。我希望你能学习到一种处理与它们相关的各种问题的方法，并能有一个更好的 Go 使用体验。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>01294f40a65a3a3fd1c3bf514dd45dba</guid>
<title>如何为 Node.js 的 require 函数添加钩子？</title>
<link>https://toutiao.io/k/ek9h644</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境。早期的 Node.js 采用的是 CommonJS 模块规范，从 Node v13.2.0 版本开始正式支持 ES Modules 特性。直到 v15.3.0 版本 ES Modules 特性才稳定下来并与 NPM 生态相兼容。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.425&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V3epBBUPEBgGEiaFCSsoCiaicYmVP3cZALeIKK0ZJiatiabC4ibDxibibFpLiaWafyyaDtqgLzV6Sj0JszFX5Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（图片来源：https://nodejs.org/api/esm.html）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文将介绍 Node.js 中 &lt;code&gt;require&lt;/code&gt; 函数的工作流程、如何让 Node.js 直接执行 ts 文件及如何正确地劫持 Node.js 的 &lt;code&gt;require&lt;/code&gt; 函数，从而实现钩子的功能。接下来，我们先来介绍 &lt;code&gt;require&lt;/code&gt; 函数。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;require 函数&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Node.js 应用由模块组成，每个文件就是一个模块。对于 CommonJS 模块规范来说，我们通过 &lt;code&gt;require&lt;/code&gt; 函数来导入模块。那么当我们使用 &lt;code&gt;require&lt;/code&gt; 函数来导入模块的时候，该函数内部发生了什么？这里我们通过调用堆栈来了解一下 &lt;code&gt;require&lt;/code&gt; 的过程：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.42109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V3epBBUPEBgGEiaFCSsoCiaicYDVeVGge17icGmXMGYlGkcMQ4kWK0fkiaMxVcSVrDIsSdelscEKDgutzg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由上图可知，在使用 &lt;code&gt;require&lt;/code&gt; 导入模块时，会调用 &lt;code&gt;Module&lt;/code&gt; 对象的 &lt;code&gt;load&lt;/code&gt; 方法来加载模块，该方法的实现如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// lib/internal/modules/cjs/loader.js&lt;/span&gt;&lt;br/&gt;Module.prototype.load = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;filename&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.filename = filename;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.paths = Module._nodeModulePaths(path.dirname(filename));&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; extension = findLongestRegisteredExtension(filename);&lt;br/&gt;&lt;br/&gt;  Module._extensions[extension](&lt;span&gt;this&lt;/span&gt;, filename);&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.loaded = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：本文所引用 Node.js 源码所对应的版本是 &lt;strong&gt;v16.13.1&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以上代码中，重要的两个步骤是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;步骤一：根据文件名找出扩展名；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;步骤二：通过解析后的扩展名，在 &lt;code&gt;Module._extensions&lt;/code&gt; 对象中查找匹配的加载器。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;在 Node.js 中内置了 3 种不同的加载器，用于加载 &lt;/span&gt;&lt;code&gt;node&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;json&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;js&lt;/code&gt;&lt;span&gt; 文件。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;strong&gt;node 文件加载器&lt;/strong&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// lib/internal/modules/cjs/loader.js&lt;/span&gt;&lt;br/&gt;Module._extensions[&lt;span&gt;&#x27;.node&#x27;&lt;/span&gt;] = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;module, filename&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; process.dlopen(&lt;span&gt;module&lt;/span&gt;, path.toNamespacedPath(filename));&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;json 文件加载器&lt;/strong&gt;&lt;strong/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// lib/internal/modules/cjs/loader.js&lt;/span&gt;&lt;br/&gt;Module._extensions[&lt;span&gt;&#x27;.json&#x27;&lt;/span&gt;] = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;module, filename&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;const&lt;/span&gt; content = fs.readFileSync(filename, &lt;span&gt;&#x27;utf8&#x27;&lt;/span&gt;);&lt;br/&gt; &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;module&lt;/span&gt;.exports = JSONParse(stripBOM(content));&lt;br/&gt; } &lt;span&gt;catch&lt;/span&gt; (err) {&lt;br/&gt;   err.message = filename + &lt;span&gt;&#x27;: &#x27;&lt;/span&gt; + err.message;&lt;br/&gt;   &lt;span&gt;throw&lt;/span&gt; err;&lt;br/&gt; }&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;js 文件加载器&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// lib/internal/modules/cjs/loader.js&lt;/span&gt;&lt;br/&gt;Module._extensions[&lt;span&gt;&#x27;.js&#x27;&lt;/span&gt;] = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;module, filename&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// If already analyzed the source, then it will be cached.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; cached = cjsParseCache.get(&lt;span&gt;module&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; content;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (cached?.source) {&lt;br/&gt;    content = cached.source;&lt;br/&gt;    cached.source = &lt;span&gt;undefined&lt;/span&gt;;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    content = fs.readFileSync(filename, &lt;span&gt;&#x27;utf8&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;module&lt;/span&gt;._compile(content, filename);&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来分析比较重要的 &lt;strong&gt;js 文件加载器&lt;/strong&gt;。通过观察以上代码，我们可知 &lt;code&gt;js&lt;/code&gt; 加载器的核心处理流程，也可以分为两个步骤：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;步骤一：使用 &lt;code&gt;fs.readFileSync&lt;/code&gt; 方法加载 &lt;code&gt;js&lt;/code&gt; 文件的内容；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;步骤二：使用 &lt;code&gt;module._compile&lt;/code&gt; 方法编译已加载的 &lt;code&gt;js&lt;/code&gt; 代码。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;那么了解以上的知识之后，对我们有什么用处呢？&lt;/span&gt;&lt;span&gt;其实在了解 &lt;/span&gt;&lt;code&gt;require&lt;/code&gt;&lt;span&gt; 函数的工作流程之后，我们就可以扩展 Node.js 的加载器。&lt;/span&gt;&lt;span&gt;比如让 Node.js 能够运行 &lt;/span&gt;&lt;code&gt;ts&lt;/code&gt;&lt;span&gt; 文件。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// register.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; fs = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;fs&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; Module = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;module&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; { transformSync } = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;esbuild&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;Module._extensions[&lt;span&gt;&quot;.ts&quot;&lt;/span&gt;] = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;module, filename&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; content = fs.readFileSync(filename, &lt;span&gt;&quot;utf8&quot;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { code } = transformSync(content, {&lt;br/&gt;    &lt;span&gt;sourcefile&lt;/span&gt;: filename,&lt;br/&gt;    &lt;span&gt;sourcemap&lt;/span&gt;: &lt;span&gt;&quot;both&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;loader&lt;/span&gt;: &lt;span&gt;&quot;ts&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;format&lt;/span&gt;: &lt;span&gt;&quot;cjs&quot;&lt;/span&gt;,&lt;br/&gt;  });&lt;br/&gt;  &lt;span&gt;module&lt;/span&gt;._compile(code, filename);&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以上代码中，我们引入了内置的 &lt;code&gt;module&lt;/code&gt; 模块，然后利用该模块的 &lt;code&gt;_extensions&lt;/code&gt; 对象来注册我们的自定义 ts 加载器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，加载器的本质就是一个函数，在该函数内部我们利用 esbuild 模块提供的 &lt;code&gt;transformSync&lt;/code&gt; API 来实现 &lt;strong&gt;ts -&amp;gt; js&lt;/strong&gt; 代码的转换。当完成代码转换之后，会调用 &lt;code&gt;module._compile&lt;/code&gt; 方法对代码进行编译操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里相信有的小伙伴，也想到了 Webpack 中对应的 loader，想深入学习的话，可以阅读 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;amp;mid=2247494307&amp;amp;idx=1&amp;amp;sn=cdeb4085693db5f1c314a0eb3b9e3485&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;多图详解，一次性搞懂Webpack Loader&lt;/a&gt; 这篇文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;篇幅有限，具体的编译过程，我们就不展开介绍了。下面我们来看一下如何让自定义的 ts 加载器生效。要让 Node.js 能够执行 ts 代码，我们就需要在执行 ts 代码前，先完成自定义 ts 加载器的注册操作。庆幸的是，Node.js 为我们提供了模块的预加载机制：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt; $&lt;/span&gt;&lt;span&gt; node --&lt;span&gt;help&lt;/span&gt; | grep preload&lt;/span&gt;&lt;br/&gt;   -r, --require=... module to preload (option can be repeated)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即利用 &lt;code&gt;-r, --require&lt;/code&gt; 命令行配置项，我们就可以预加载指定的模块。了解完相关知识之后，我们来测试一下自定义 ts 加载器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先创建一个 &lt;code&gt;index.ts&lt;/code&gt; 文件并输入以下内容：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// index.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; add = &lt;span&gt;(&lt;span&gt;a: &lt;span&gt;number&lt;/span&gt;, b: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; a + b;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;add(a, b) = &quot;&lt;/span&gt;, add(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在命令行输入以下命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; node -r ./register.js index.ts&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当以上命令成功运行之后，控制台会输出以下内容：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;add(a, b) =  8&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很明显我们自定义的 ts 文件加载器生效了，这种扩展机制还是值得我们学习的。另外，需要注意的是在 &lt;code&gt;load&lt;/code&gt; 方法中，&lt;code&gt;findLongestRegisteredExtension&lt;/code&gt; 函数会判断文件的扩展名是否已经注册在 &lt;code&gt;Module._extensions&lt;/code&gt; 对象中，若未注册的话，默认会返回 &lt;code&gt;.js&lt;/code&gt; 字符串。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// lib/internal/modules/cjs/loader.js&lt;/span&gt;&lt;br/&gt;Module.prototype.load = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;filename&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.filename = filename;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.paths = Module._nodeModulePaths(path.dirname(filename));&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; extension = findLongestRegisteredExtension(filename);&lt;br/&gt;&lt;br/&gt;  Module._extensions[extension](&lt;span&gt;this&lt;/span&gt;, filename);&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.loaded = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就意味着只要文件中包含有效的 &lt;code&gt;js&lt;/code&gt; 代码，&lt;code&gt;require&lt;/code&gt; 函数就能正常加载它。比如下面的 &lt;strong&gt;a.txt&lt;/strong&gt; 文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;module&lt;/span&gt;.exports = &lt;span&gt;&quot;hello world&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里相信你已经了解 &lt;code&gt;require&lt;/code&gt; 函数是如何加载模块及如何自定义 Node.js 文件加载器。那么让 Node.js 支持加载 &lt;code&gt;ts&lt;/code&gt;、&lt;code&gt;png&lt;/code&gt; 或 &lt;code&gt;css&lt;/code&gt; 等其它类型的文件，有更优雅、更简单的方案么？答案是有的，我们可以使用 pirates 这个第三方库。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;pirates 是什么&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;pirates 这个库让我们可以正确地劫持 Node.js 的 &lt;code&gt;require&lt;/code&gt; 函数。利用这个库，我们就可以很容易扩展 Node.js 加载器的功能。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;pirates 的用法&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以使用 npm 来安装 pirates：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install --save pirates&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在成功安装 pirates 这个库之后，就可以利用该模块导出提供的 &lt;code&gt;addHook&lt;/code&gt; 函数来添加钩子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// register.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; addHook = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;pirates&quot;&lt;/span&gt;).addHook;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; revert = addHook(&lt;br/&gt;  &lt;span&gt;(&lt;span&gt;code, filename&lt;/span&gt;) =&amp;gt;&lt;/span&gt; code.replace(&lt;span&gt;&quot;@@foo&quot;&lt;/span&gt;, &lt;span&gt;&quot;console.log(&#x27;foo&#x27;);&quot;&lt;/span&gt;),&lt;br/&gt;  { &lt;span&gt;exts&lt;/span&gt;: [&lt;span&gt;&quot;.js&quot;&lt;/span&gt;] }&lt;br/&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是调用 &lt;code&gt;addHook&lt;/code&gt; 之后会返回一个 &lt;code&gt;revert&lt;/code&gt; 函数，用于取消对 &lt;code&gt;require&lt;/code&gt; 函数的劫持操作。下面我们来验证一下 pirates 这个库是否能正常工作，首先新建一个 &lt;code&gt;index.js&lt;/code&gt; 文件并输入以下内容：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// index.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;@@foo&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在命令行输入以下命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; node -r ./register.js index.js&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当以上命令成功运行之后，控制台会输出以下内容：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;console.log(&#x27;foo&#x27;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;观察以上结果可知，我们通过 &lt;code&gt;addHook&lt;/code&gt; 函数添加的钩子生效了。是不是觉得挺神奇的，接下来我们来分析一下 pirates 的工作原理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;pirates 是如何工作的&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;pirates 底层是利用 Node.js 内置 &lt;code&gt;module&lt;/code&gt; 模块提供的扩展机制来实现 &lt;code&gt;Hook&lt;/code&gt; 功能。前面我们已经介绍过了，当使用 &lt;code&gt;require&lt;/code&gt; 函数来加载模块时，Node.js 会根据文件的后缀名来匹配对应的加载器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实 pirates 的源码并不会复杂，我们来重点分析 &lt;code&gt;addHook&lt;/code&gt; 函数的核心处理逻辑：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// src/index.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;addHook&lt;/span&gt;(&lt;span&gt;hook, opts = {}&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; reverted = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; loaders = []; &lt;span&gt;// 存放新的loader&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; oldLoaders = []; &lt;span&gt;// 存放旧的loader&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; exts;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; originalJSLoader = Module._extensions[&lt;span&gt;&#x27;.js&#x27;&lt;/span&gt;]; &lt;span&gt;// 原始的JS Loader &lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; matcher = opts.matcher || &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; ignoreNodeModules = opts.ignoreNodeModules !== &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  exts = opts.extensions || opts.exts || opts.extension || opts.ext &lt;br/&gt;    || [&lt;span&gt;&#x27;.js&#x27;&lt;/span&gt;];&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Array&lt;/span&gt;.isArray(exts)) {&lt;br/&gt;    exts = [exts];&lt;br/&gt;  }&lt;br/&gt;  exts.forEach((ext) { &lt;br/&gt;    &lt;span&gt;// ... &lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了提高执行效率，&lt;code&gt;addHook&lt;/code&gt; 函数提供了 &lt;code&gt;matcher&lt;/code&gt; 和 &lt;code&gt;ignoreNodeModules&lt;/code&gt; 配置项来实现文件过滤操作。在获取到 &lt;code&gt;exts&lt;/code&gt; 扩展名列表之后，就会使用新的加载器来替换已有的加载器。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;exts.forEach(&lt;span&gt;(&lt;span&gt;ext&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; ext !== &lt;span&gt;&#x27;string&#x27;&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;TypeError&lt;/span&gt;(&lt;span&gt;`Invalid Extension: &lt;span&gt;${ext}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 获取已注册的loader，若未找到，则默认使用JS Loader&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; oldLoader = Module._extensions[ext] || originalJSLoader;&lt;br/&gt;    oldLoaders[ext] = Module._extensions[ext];&lt;br/&gt;&lt;br/&gt;    loaders[ext] = Module._extensions[ext] = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;newLoader&lt;/span&gt;(&lt;span&gt;&lt;br/&gt;   mod, filename&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;let&lt;/span&gt; compile;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (!reverted) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (shouldCompile(filename, exts, matcher, ignoreNodeModules)) {&lt;br/&gt;          compile = mod._compile;&lt;br/&gt;          mod._compile = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;_compile&lt;/span&gt;(&lt;span&gt;code&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;// 这里需要恢复成原来的_compile函数，否则会出现死循环&lt;/span&gt;&lt;br/&gt;            mod._compile = compile;&lt;br/&gt;            &lt;span&gt;// 在编译前先执行用户自定义的hook函数&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;const&lt;/span&gt; newCode = hook(code, filename);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; newCode !== &lt;span&gt;&#x27;string&#x27;&lt;/span&gt;) {&lt;br/&gt;              &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(HOOK_RETURNED_NOTHING_ERROR_MESSAGE);&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; mod._compile(newCode, filename);&lt;br/&gt;          };&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;&lt;br/&gt;      oldLoader(mod, filename);&lt;br/&gt;    };&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;观察以上代码可知，在 &lt;code&gt;addHook&lt;/code&gt; 函数内部是通过替换 &lt;code&gt;mod._compile&lt;/code&gt; 方法来实现钩子的功能。即在调用原始的 &lt;code&gt;mod._compile&lt;/code&gt; 方法进行编译前，会先调用 &lt;code&gt;hook(code, filename)&lt;/code&gt; 函数来执行用户自定义的 &lt;code&gt;hook&lt;/code&gt; 函数，从而对代码进行处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好的，至此本文的主要内容都介绍完了，在实际工作中，如果你想让 Node.js 直接执行 ts 文件，可以利用 ts-node 或 esbuild-register 这两个库。其中 esbuild-register 这个库内部就是使用了 pirates 提供的 Hook 机制来实现对应的功能。&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bf324c0145bf8fd4ce336df91d09b125</guid>
<title>糟糕程序员的20个坏习惯，你命中几个？</title>
<link>https://toutiao.io/k/9ohal9c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwOTIxNDQ3OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8YRIaicYx5pzj5Cxwick8DamnOgbTJu96QTibKyHEDZt1815yOV1r27oZ6HgoYTEYWYLRz4jIV4iasHgg/0?wx_fmt=png&quot; data-nickname=&quot;dbaplus社群&quot; data-alias=&quot;dbaplus&quot; data-signature=&quot;围绕Database、BigData、AIOps的企业级专业社群。资深大咖、技术干货，每天精品原创文章推送，每周线上技术分享，每月线下技术沙龙，每季度Gdevops&amp;amp;DAMS行业大会.&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86318&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;今天我想和你聊一聊优秀程序员的基本素养。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我想你肯定遇到过这样一类程序员：他们无论是写代码，还是写文档，又或是和别人沟通，都显得特别专业。每次遇到这类人，我都在想，他们到底是怎么做到的？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着工作时间的增长，渐渐地我也总结出一些经验，他们身上都保持着一些看似很微小的优秀习惯，但正是因为这些习惯，体现出了一个优秀程序员的基本素养。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86318&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;糟糕程序员的坏习惯&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;但今天我们来换个角度，来看看一个糟糕程序员有哪些坏习惯？只要我们都能避开这些问题，就可以逐渐向一个优秀程序员靠近。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;1、技术名词拼写不规范&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;无论是个人简历，还是技术文档，我经常看到拼写不规范的技术名词，例如 JAVA、javascript、python、MySql、Hbase、restful。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正确的拼写应该是 Java、JavaScript、Python、MySQL、HBase、RESTful，不要小看这个问题，很多面试官很有可能因为这一点刷掉你的简历。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;2、写文档，中英文混排不规范&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;中文描述使用英文标点符号，英文和数字使用了全角字符，中文与英文、数字之间没有空格等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中很多人会忽视中文和英文、数字之间加一个「空格」，这样排版阅读起来会更舒服。之前我的文章排版，都是遵循了这些细节。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;3、重要逻辑不写注释，或写得很拖沓&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;复杂且重要的逻辑代码，很多程序员不写注释，除了自己能看懂代码逻辑，其他人根本看不懂。或者是注释虽然写了，但写得很拖沓，没有逻辑可言。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;重要的逻辑不止要写注释，还要写得简洁、清晰。如果是一眼就能读懂的简单代码，可以不加注释。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;4、写复杂冗长的函数&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;一个函数几百行，一个文件上千行代码，复杂函数不做拆分，导致代码变得越来越难维护，最后谁也不敢动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基本的设计模式还是要遵守的，例如单一职责，一个函数只做一件事，开闭原则，对扩展开放，对修改关闭。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果函数逻辑确实复杂，也至少要保证主干逻辑足够清晰。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;5、不看官方文档，只看垃圾博客&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;很多人遇到问题不先去看官方文档，而是热衷于去看垃圾博客，这些博客的内容都是互相抄袭，错误百出。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实很多软件官方文档写得已经非常好了，常见问题都能找到答案，认真读一读官方文档，比看垃圾博客强一百倍，要养成看官方文档的好习惯。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;6、宣扬内功无用论&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;有些人天天追求日新月异的开源项目和框架，却不肯花时间去啃一啃底层原理，常见问题虽然可以解决，但遇到稍微深一点的问题就束手无策。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多高大上的架构设计，思路其实都源于底层。想一想，像计算机体系结构、操作系统、网络协议这些东西，经过多少年演进才变为现在的样子，演进过程中遇到的复杂问题比比皆是，理解了解决这些问题的思路，再看上层技术会变得很简单。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;7、乐于炫技&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;有些人天天把「高大上」的技术名词挂在嘴边，生怕别人不知道自己学了什么高深技术，嘴上乐于炫技，但别人一问他细节就会哑口无言。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;8、不接受质疑&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;自己设计的方案，别人提出疑问时只会回怼，而不是理性分析利弊，抱着学习的心态交流。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些人学了点东西就觉得自己很有本事，殊不知只是自己见识太少。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;9、接口协议不规范&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;和别人定 API 协议全靠口头沟通，不给规范的文档说明，甚至到了测试联调时会发现，竟然和协商的还不一样，或者改协议了却不通知对接方，合作体验极差。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;10、遇到问题自己死磕&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;很初级程序员容易犯的问题，遇到问题只会自己死磕，拖到 deadline 也没有产出，领导来问才知道有问题解决不了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有问题及时反馈才是对自己负责，对团队负责。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;11、一说就会，一写就废&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;平时技术方案吹得天花乱坠，一让他写代码就废，典型的眼高手低选手。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;12、表达没有逻辑，不站在对方角度看问题&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;讨论问题不交代背景，上来就说自己的方案，别人听得云里雾里，让你从头描述你又讲不明白。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;学会沟通和表达，是合作的基础。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;13、不主动思考，伸手党&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;遇到问题不去 google，不做思考就向别人提问，喜欢做伸手党。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每个人的时间都很宝贵，大家都更喜欢你带着自己的思考来提问，一来可以规避很多低级问题，二来可以提高交流质量。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;14、经常犯重复的错误&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;出问题后说下次会注意，但下次问题依旧，对自己不负责任，说到底是态度问题。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;15、加功能不考虑扩展性&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;加新功能只关注某一小块业务，不考虑系统整体的扩展性，堆代码行为严重。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要学会分析需求和未来可能发生的变化，设计更通用的解决方案，降低后期开发成本。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;16、接口不自测，出问题不打日志&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;自己开发的接口不自测就和别人联调，出了问题又说没打日志，协作效率极低。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;17、提交代码不规范&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;很多人提交代码不写描述，或者写的是无意义的描述，尤其是修改很少代码时，这种情况会导致回溯问题成本变高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;制定代码提交规范，能让你在每一次提交代码时，不会做太随意的代码修改。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;18、手动修改生产环境数据库&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;直连生产环境数据库修改数据，更有 UPDATE / DELETE SQL 忘写 WEHRE 条件的情况，产生数据事故。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;修改生产环境数据库一定要谨慎再谨慎，建议操作前先找同事 review 代码再操作。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;19、没理清需求就直接写代码&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;很多程序员接到需求后，不怎么思考就开始写代码，需求和自己理解的有偏差，造成无意义返工。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;多花些时间梳理需求，能规避很多不合理的问题。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;20、重要设计不写文档&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;重要的设计没有文档输出，和别人交接系统时只做口头描述，丢失关键信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有时候理解一个设计方案，一个好的文档要比看几百行代码更高效。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86318&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;以上这些不良习惯，你命中几个呢？或者你身边有没有碰到这样的人？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我认为提早规避这些问题，是成为一个优秀程序员必须要做的。这些习惯总结起来大致分为这 4 个方面：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;良好的编程修养&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;谦虚的学习心态&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;良好的沟通和表达&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;注重团队协作&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;优秀程序员的专业技能，我们可能很难在短时间内学会，但这些基本的职业素养，是可以在短期内做到的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;希望你我可以有则改之，无则加勉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你认为还有哪些程序员的坏习惯，欢迎在评论区留言讨论~&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;作者丨Kaito&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;来源丨公众号：水滴与银弹（ID：waterdrop_bullet）&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;dbaplus社群欢迎广大技术人员投稿，投稿邮箱：&lt;/span&gt;&lt;span&gt;editor@dbaplus.cn&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>