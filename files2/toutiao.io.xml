<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>42ca5da9f06444b7c860707ecfd590b5</guid>
<title>纯Docker部署Https服务——以Nextcloud为例</title>
<link>https://toutiao.io/k/v7hy6ct</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section class=&quot;toc-content post tag-linux tag-docker tag-https no-image&quot;&gt;
      &lt;h2 id=&quot;%E8%83%8C%E6%99%AF&quot;&gt;背景&lt;/h2&gt;&lt;p&gt;近期阿里云的廉价学生机小水管到期了，打算把一些服务打包迁移到微软员工不要钱的azure云上。&lt;/p&gt;&lt;p&gt;原先各种服务的部署方式都是直接部署的，换主机需要重新搭建各种环境非常麻烦，也容易遗漏。于是就想跟随潮流把这些服务都上docker，能够做到部署一把梭。&lt;/p&gt;&lt;h2 id=&quot;%E9%9A%BE%E7%82%B9&quot;&gt;难点&lt;/h2&gt;&lt;p&gt;一般的开源组件都会有官方docker镜像，部署起来其实都很方便。大部分对着官方文档改改配置再用docker-compose组合一下参数就能跑起来。比较麻烦的点就是网站要部署成 https 的话需要 SSL 证书。对于个人使用的小网站来说，云厂商的 SSL 证书又实在是比较贵（阿里云上通配符域名大概2000¥/年，单域名也要400¥/年）。&lt;/p&gt;&lt;p&gt;比较经济实惠的做法是使用 &lt;a href=&quot;https://letsencrypt.org/&quot;&gt;Let’s Encrypt&lt;/a&gt; 的免费证书，不过代价就是他需要定时check你对这个域名的所有权。显然，我们肯定不能手动更新，那样简直要疯。一般我们会用 &lt;a href=&quot;https://certbot.eff.org/&quot;&gt;certbot&lt;/a&gt; 来定时进行站点所有权的确认。经常对接站长后台工具的人应该都知道，认证的方式一般有两种：一种是将给定的验证字符串写进 DNS 的 TXT 记录，从而确认你对这个&lt;strong&gt;域名&lt;/strong&gt;的所有权；第二种是将给定的验证字符串写在网站的给定目录下，从而确认你对这个&lt;strong&gt;网站&lt;/strong&gt;的所有权。&lt;/p&gt;&lt;p&gt;理论上最方便的做法是通过一个定时任务，定时调用 DNS 服务商的接口来改 TXT 记录。这样可以做到将 SSL 证书的校验和网站本身的部署分离开，使得校验所有权的逻辑不干扰正常的网站配置。不过尴尬的是 certbot 提供的 &lt;a href=&quot;https://eff-certbot.readthedocs.io/en/stable/using.html#dns-plugins&quot;&gt;DNS插件&lt;/a&gt; 基本都不包含国内的运营商。而考虑到域名在国内解析的性能，我还是不太想把域名切到国外的服务商去。&lt;/p&gt;&lt;p&gt;因此事实上我只能采用 webroot 的方式来认证。这个方式比较万金油，不过缺点就是不支持通配符域名，如果需要同时验证多个子域名，则需要手动添加。同时，传统的 certbot 使用方式中一定还需要在系统中配置一个 crontab 任务来做更新，而我现在则希望将这个 crontab 任务也集成在 docker 中，尽量不要对除 docker 外的逻辑做任何感知。&lt;/p&gt;&lt;h2 id=&quot;%E6%AD%A5%E9%AA%A4&quot;&gt;步骤&lt;/h2&gt;&lt;p&gt;逻辑上讲，步骤大致应当如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;去 DNS 服务商提供的配置后台，将给定域名配置好A记录指向目的主机。&lt;/li&gt;&lt;li&gt;安装 &lt;a href=&quot;https://docs.docker.com/engine/install/ubuntu/&quot;&gt;docker&lt;/a&gt;  &lt;a href=&quot;https://docs.docker.com/compose/install/&quot;&gt;docker-compose&lt;/a&gt; ，并设置好配置文件。&lt;/li&gt;&lt;li&gt;配置并启动 nginx 只开放 http 端口 ，准备 certbot 的认证环境。&lt;/li&gt;&lt;li&gt;启动 certbot 初始化，配合nginx，生成首个私钥和证书链。&lt;/li&gt;&lt;li&gt;利用 certbot 提供的私钥和证书，配置 nginx 的 https 端口。&lt;/li&gt;&lt;li&gt;配置 certbot 的自动 renew ，进行自动验证。&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;%E6%A0%B7%E4%BE%8B&quot;&gt;样例&lt;/h2&gt;&lt;p&gt;下面以在 &lt;code&gt;https://pan.mythsman.com&lt;/code&gt; 下配置 &lt;a href=&quot;https://nextcloud.com/&quot;&gt;nextcloud&lt;/a&gt; 为例。 DNS 配置、docker 和 docker-compose 安装等步骤略过。&lt;/p&gt;&lt;h3 id=&quot;%E5%88%9D%E5%A7%8B%E5%8C%96docker%E9%85%8D%E7%BD%AE&quot;&gt;初始化docker配置&lt;/h3&gt;&lt;p&gt;./docker-compose.yml&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;version: &quot;3.8&quot;
services:
    nginx:
        container_name: nginx
        image: nginx:latest
        restart: always
        volumes:
            - ./nginx/logs:/var/log/nginx
            - ./nginx/conf.d:/etc/nginx/conf.d
            - ./certbot/conf:/etc/nginx/ssl
            - ./certbot/data:/var/www/certbot
        ports:
            - &quot;80:80&quot;
            - &quot;443:443&quot;
        command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;while :;do sleep 24h &amp;amp; wait $${!}; nginx -s reload; done &amp;amp; nginx -g \&quot;daemon off;\&quot;&quot;]

    certbot:
        container_name: certbot
        image: certbot/certbot:latest
        command: certonly --webroot --webroot-path=/var/www/certbot --agree-tos --email mythsman@foxmail.com -d  pan.mythsman.com
        # entrypoint: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;trap exit TERM;while :; do certbot renew --webroot -w /var/www/certbot; sleep 24h &amp;amp; wait $${!}; done;&quot;]
        volumes:
            - ./certbot/conf:/etc/letsencrypt
            - ./certbot/logs:/var/log/letsencrypt
            - ./certbot/data:/var/www/certbot&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;说明：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;./certbot/conf 目录存放的即是 certbot 生成的证书等一大堆文件，因此需要挂载给 nginx 。&lt;/li&gt;&lt;li&gt;./certbot/logs 目录下存放的是证书创建相关的日志。&lt;/li&gt;&lt;li&gt;./certbot/data 目录是 certbot 用来存放校验字符串的，需要通过nginx对外网暴露，因此也需要挂在给 nginx。&lt;/li&gt;&lt;li&gt;./nginx/logs 目录存放的即是 nginx 的相关日志。&lt;/li&gt;&lt;li&gt;./nginx/conf.d 目录存放 nginx 的配置，下面会介绍。&lt;/li&gt;&lt;li&gt;nginx 的 command 指令写了一个小脚本，用来让 nginx 定时自动 reload，方便 certbot 刷新证书后 nginx 能及时更新。&lt;/li&gt;&lt;li&gt;certbot 的 command 指令中需要配置接受邮箱，用来接受一些通知消息，以及需要配置的域名 &lt;code&gt;pan.mythsman.com&lt;/code&gt; 。&lt;/li&gt;&lt;li&gt;certbot 的 entrypoint 指令是用来后续 renew 的，暂时注释掉。&lt;/li&gt;&lt;/ol&gt;&lt;h3 id=&quot;%E5%88%9D%E5%A7%8B%E5%8C%96nginx%E9%85%8D%E7%BD%AE&quot;&gt;初始化nginx配置&lt;/h3&gt;&lt;p&gt;./nginx/conf.d/default.conf&lt;/p&gt;&lt;pre&gt;&lt;code&gt;server {
     listen [::]:80 default_server;
     listen 80 default_server;

     server_name _;

     location ~ /.well-known/acme-challenge {
         allow all;
         root /var/www/certbot;
     }

     location / {
         if ( $host = &quot;pan.mythsman.com&quot; ){
             return 301 https://pan.mythsman.com$request_uri;
         }
         return 444;
     }

}

server {
       listen 443 default_server;
       listen [::]:443 default_server;
       server_name _;
       ssl_reject_handshake on;
       ssl_session_tickets off;
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;说明：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;这里最关键的是 &lt;code&gt;.well-known&lt;/code&gt; 行，用来关联 certbot 的校验文件。&lt;/li&gt;&lt;li&gt;&lt;code&gt;return 444&lt;/code&gt; 是用来拒绝掉一些未知域名的http访问。&lt;/li&gt;&lt;li&gt;&lt;code&gt;ssl_reject_handshake&lt;/code&gt; 是用来拒绝掉一些未知域名的https的访问。&lt;/li&gt;&lt;/ol&gt;&lt;h3 id=&quot;%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6&quot;&gt;生成证书&lt;/h3&gt;&lt;p&gt;执行 &lt;code&gt;docker-compose up -d&lt;/code&gt; ，证书生成成功后会在 &lt;code&gt;./certbot/logs/letsencrypt.log&lt;/code&gt; 打印相关日志:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;2022-03-09 03:41:39,879:DEBUG:certbot._internal.storage:Creating directory /etc/letsencrypt/archive.
2022-03-09 03:41:39,879:DEBUG:certbot._internal.storage:Creating directory /etc/letsencrypt/live.
2022-03-09 03:41:39,879:DEBUG:certbot._internal.storage:Writing README to /etc/letsencrypt/live/README.
2022-03-09 03:41:39,879:DEBUG:certbot._internal.storage:Creating directory /etc/letsencrypt/archive/pan.mythsman.com.
2022-03-09 03:41:39,879:DEBUG:certbot._internal.storage:Creating directory /etc/letsencrypt/live/pan.mythsman.com.
2022-03-09 03:41:39,880:DEBUG:certbot._internal.storage:Writing certificate to /etc/letsencrypt/live/pan.mythsman.com/cert.pem.
2022-03-09 03:41:39,880:DEBUG:certbot._internal.storage:Writing private key to /etc/letsencrypt/live/pan.mythsman.com/privkey.pem.
2022-03-09 03:41:39,880:DEBUG:certbot._internal.storage:Writing chain to /etc/letsencrypt/live/pan.mythsman.com/chain.pem.
2022-03-09 03:41:39,880:DEBUG:certbot._internal.storage:Writing full chain to /etc/letsencrypt/live/pan.mythsman.com/fullchain.pem.
2022-03-09 03:41:39,880:DEBUG:certbot._internal.storage:Writing README to /etc/letsencrypt/live/pan.mythsman.com/README.
2022-03-09 03:41:39,909:DEBUG:certbot._internal.plugins.selection:Requested authenticator webroot and installer &amp;lt;certbot._internal.cli.cli_utils._Default object at 0x7f94027a1370&amp;gt;
2022-03-09 03:41:39,909:DEBUG:certbot._internal.cli:Var authenticator=webroot (set by user).
2022-03-09 03:41:39,909:DEBUG:certbot._internal.cli:Var webroot_path=/var/www/certbot (set by user).
2022-03-09 03:41:39,909:DEBUG:certbot._internal.cli:Var webroot_path=/var/www/certbot (set by user).
2022-03-09 03:41:39,909:DEBUG:certbot._internal.cli:Var webroot_map={&#x27;webroot_path&#x27;} (set by user).
2022-03-09 03:41:39,909:DEBUG:certbot._internal.storage:Writing new config /etc/letsencrypt/renewal/pan.mythsman.com.conf.
2022-03-09 03:41:39,911:DEBUG:certbot._internal.display.obj:Notifying user:
Successfully received certificate.
Certificate is saved at: /etc/letsencrypt/live/pan.mythsman.com/fullchain.pem
Key is saved at:         /etc/letsencrypt/live/pan.mythsman.com/privkey.pem
This certificate expires on 2022-06-07.
These files will be updated when the certificate renews.
2022-03-09 03:41:39,911:DEBUG:certbot._internal.display.obj:Notifying user: NEXT STEPS:
2022-03-09 03:41:39,912:DEBUG:certbot._internal.display.obj:Notifying user: - The certificate will need to be renewed before it expires. Certbot can automatically renew the certificate in the background, but you may need to take steps to enable that functionality. See https://certbot.org/renewal-setup for instructions.
2022-03-09 03:41:39,913:DEBUG:certbot._internal.display.obj:Notifying user: If you like Certbot, please consider supporting our work by:
 * Donating to ISRG / Let&#x27;s Encrypt:   https://letsencrypt.org/donate
 * Donating to EFF:                    https://eff.org/donate-le&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也可以通过 nginx 的访问日志 &lt;code&gt;/nginx/logs/access.log&lt;/code&gt;  查看他在校验的过程中访问了哪些页面:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;3.120.130.29 - - [09/Mar/2022:03:41:36 +0000] &quot;GET /.well-known/acme-challenge/fNVMV-CtDCdq_eAdiaV0rF_J7I-ZW38M7Bo3UqEtOY4 HTTP/1.1&quot; 200 87 &quot;-&quot; &quot;Mozilla/5.0 (compatible; Let&#x27;s Encrypt validation server; +https://www.letsencrypt.org)&quot; &quot;-&quot;
3.19.56.43 - - [09/Mar/2022:03:41:36 +0000] &quot;GET /.well-known/acme-challenge/fNVMV-CtDCdq_eAdiaV0rF_J7I-ZW38M7Bo3UqEtOY4 HTTP/1.1&quot; 200 87 &quot;-&quot; &quot;Mozilla/5.0 (compatible; Let&#x27;s Encrypt validation server; +https://www.letsencrypt.org)&quot; &quot;-&quot;
34.221.255.206 - - [09/Mar/2022:03:41:36 +0000] &quot;GET /.well-known/acme-challenge/fNVMV-CtDCdq_eAdiaV0rF_J7I-ZW38M7Bo3UqEtOY4 HTTP/1.1&quot; 200 87 &quot;-&quot; &quot;Mozilla/5.0 (compatible; Let&#x27;s Encrypt validation server; +https://www.letsencrypt.org)&quot; &quot;-&quot;
64.78.149.164 - - [09/Mar/2022:03:41:36 +0000] &quot;GET /.well-known/acme-challenge/fNVMV-CtDCdq_eAdiaV0rF_J7I-ZW38M7Bo3UqEtOY4 HTTP/1.1&quot; 200 87 &quot;-&quot; &quot;Mozilla/5.0 (compatible; Let&#x27;s Encrypt validation server; +https://www.letsencrypt.org)&quot; &quot;-&quot;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;%E9%85%8D%E7%BD%AE%E7%AB%99%E7%82%B9%E5%AE%B9%E5%99%A8%E5%92%8C%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%96%B0&quot;&gt;配置站点容器和证书更新&lt;/h3&gt;&lt;p&gt;./docker-compose.yml&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;version: &quot;3.8&quot;
services:
    nginx:
        container_name: nginx
        image: nginx:latest
        restart: always
        volumes:
            - ./nginx/logs:/var/log/nginx
            - ./nginx/conf.d:/etc/nginx/conf.d
            - ./certbot/conf:/etc/nginx/ssl
            - ./certbot/data:/var/www/certbot
        ports:
            - &quot;80:80&quot;
            - &quot;443:443&quot;
        command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;while :;do sleep 24h &amp;amp; wait $${!}; nginx -s reload; done &amp;amp; nginx -g \&quot;daemon off;\&quot;&quot;]

    certbot:
        container_name: certbot
        image: certbot/certbot:latest
        # command: certonly --webroot --webroot-path=/var/www/certbot --agree-tos --email mythsman@foxmail.com -d  pan.mythsman.com
        entrypoint: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;trap exit TERM;while :; do certbot renew --webroot -w /var/www/certbot; sleep 24h &amp;amp; wait $${!}; done;&quot;]
        volumes:
            - ./certbot/conf:/etc/letsencrypt
            - ./certbot/logs:/var/log/letsencrypt
            - ./certbot/data:/var/www/certbot
    nextcloud:
        container_name: nextcloud
        image: nextcloud:latest
        volumes:
            - ./nextcloud:/var/www/html
        ports:
            - &quot;8080:80&quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;说明：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;这里将 cerbot 的 command 注释掉，更换了 entrypoint 的启动脚本，用来每天自动更新 cerbot 证书。&lt;/li&gt;&lt;li&gt;新增了 nextcloud 的镜像。&lt;/li&gt;&lt;/ol&gt;&lt;h3 id=&quot;%E9%85%8D%E7%BD%AE%E7%AB%99%E7%82%B9%E7%9A%84nginx&quot;&gt;配置站点的Nginx&lt;/h3&gt;&lt;p&gt;./nginx/conf.d/pan.mythsman.com-ssl.conf&lt;/p&gt;&lt;pre&gt;&lt;code&gt;server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;

    server_name pan.mythsman.com;

    ssl_certificate /etc/nginx/ssl/live/pan.mythsman.com/fullchain.pem;
    ssl_certificate_key /etc/nginx/ssl/live/pan.mythsman.com/privkey.pem;

    ssl_stapling on;
    ssl_stapling_verify on;

    location / {
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header Host $http_host;
        proxy_pass http://172.17.0.1:8080;
    }

    client_max_body_size 10G;

}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;说明：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;proxy_pass 中的 172.17.0.1 为 host 主机在 docker 中访问的 ip，8080端口暴露的即为前文设置的 nextcloud 的服务。&lt;/li&gt;&lt;li&gt;ssl_certificate 和 ssl_certificate_key 配置为前文 certbot 生成的文件。&lt;/li&gt;&lt;li&gt;&lt;code&gt;client_max_body_size 10G;&lt;/code&gt; 配置是增大上传文件的大小限制。&lt;/li&gt;&lt;/ol&gt;&lt;h3 id=&quot;%E9%87%8D%E6%96%B0%E9%83%A8%E7%BD%B2&quot;&gt;重新部署&lt;/h3&gt;&lt;p&gt;执行 &lt;code&gt;docker-compose down&lt;/code&gt; 和  &lt;code&gt;docker-compose up -d&lt;/code&gt; ，重新部署各个服务。部署完成后，可以查看 certbot 的日志：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;2022-03-09 06:27:54,847:DEBUG:certbot._internal.main:certbot version: 1.24.0
2022-03-09 06:27:54,848:DEBUG:certbot._internal.main:Location of certbot entry point: /usr/local/bin/certbot
2022-03-09 06:27:54,848:DEBUG:certbot._internal.main:Arguments: [&#x27;--webroot&#x27;, &#x27;-w&#x27;, &#x27;/var/www/certbot&#x27;]
2022-03-09 06:27:54,848:DEBUG:certbot._internal.main:Discovered plugins: PluginsRegistry(PluginEntryPoint#manual,PluginEntryPoint#null,PluginEntryPoint#standalone,PluginEntryPoint#webroot)
2022-03-09 06:27:54,863:DEBUG:certbot._internal.log:Root logging level set at 30
2022-03-09 06:27:54,865:DEBUG:certbot._internal.display.obj:Notifying user: Processing /etc/letsencrypt/renewal/pan.mythsman.com.conf
2022-03-09 06:27:54,883:DEBUG:certbot._internal.plugins.selection:Requested authenticator webroot and installer &amp;lt;certbot._internal.cli.cli_utils._Default object at 0x7f64a6694f10&amp;gt;
2022-03-09 06:27:54,883:DEBUG:certbot._internal.cli:Var authenticator=webroot (set by user).
2022-03-09 06:27:54,883:DEBUG:certbot._internal.cli:Var webroot_path=/var/www/certbot (set by user).
2022-03-09 06:27:54,883:DEBUG:certbot._internal.cli:Var webroot_map={&#x27;webroot_path&#x27;} (set by user).
2022-03-09 06:27:54,883:DEBUG:certbot._internal.cli:Var webroot_path=/var/www/certbot (set by user).
2022-03-09 06:27:54,907:DEBUG:urllib3.connectionpool:Starting new HTTP connection (1): r3.o.lencr.org:80
2022-03-09 06:27:55,136:DEBUG:urllib3.connectionpool:http://r3.o.lencr.org:80 &quot;POST / HTTP/1.1&quot; 200 503
2022-03-09 06:27:55,137:DEBUG:certbot.ocsp:OCSP response for certificate /etc/letsencrypt/archive/pan.mythsman.com/cert1.pem is signed by the certificate&#x27;s issuer.
2022-03-09 06:27:55,138:DEBUG:certbot.ocsp:OCSP certificate status for /etc/letsencrypt/archive/pan.mythsman.com/cert1.pem is: OCSPCertStatus.GOOD
2022-03-09 06:27:55,141:DEBUG:certbot._internal.display.obj:Notifying user: Certificate not yet due for renewal
2022-03-09 06:27:55,142:DEBUG:certbot._internal.plugins.selection:Requested authenticator webroot and installer None
2022-03-09 06:27:55,142:DEBUG:certbot._internal.display.obj:Notifying user:
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2022-03-09 06:27:55,142:DEBUG:certbot._internal.display.obj:Notifying user: The following certificates are not due for renewal yet:
2022-03-09 06:27:55,142:DEBUG:certbot._internal.display.obj:Notifying user:   /etc/letsencrypt/live/pan.mythsman.com/fullchain.pem expires on 2022-06-07 (skipped)
2022-03-09 06:27:55,142:DEBUG:certbot._internal.display.obj:Notifying user: No renewals were attempted.
2022-03-09 06:27:55,143:DEBUG:certbot._internal.display.obj:Notifying user: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2022-03-09 06:27:55,143:DEBUG:certbot._internal.renewal:no renewal failures&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;没有报错说明流程就是通的，不过由于这个证书是刚申请的，离过期还很远，因此在renew的时候显示不需要更新。如果是想强制更新的话，可以在 certbot 的参数中加 &lt;code&gt;--renew-by-default&lt;/code&gt; 选项。如果想确认证书的过期时间，可以通过 openssl 命令查看：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ openssl x509 -in cert.pem -noout -dates
notBefore=Jan 30 03:00:32 2022 GMT
notAfter=Apr 30 03:00:31 2022 GMT&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时候访问 &lt;code&gt;pan.mythsman.com&lt;/code&gt; 即可发现 https 证书已经OK了。&lt;/p&gt;&lt;h3 id=&quot;nextcloud%E7%9A%84%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE&quot;&gt;Nextcloud的其他配置&lt;/h3&gt;&lt;p&gt;配置好 https 后，nextcloud有时还不认得自己的scheme已经是https了，这里最好需要修改一下配置。&lt;/p&gt;&lt;p&gt;&lt;code&gt;./nextcloud/config/config.php&lt;/code&gt; 新增一行：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&#x27;overwriteprotocol&#x27; =&amp;gt; &#x27;https&#x27;,&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99&quot;&gt;参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.rocworks.at/wordpress/?p=950&quot;&gt;Nginx &amp;amp; Certbot (Letsencrypt) via Docker&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://eff-certbot.readthedocs.io/en/stable/using.html#webroot&quot;&gt;Certbot User Guide&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://community.letsencrypt.org/t/cant-use-webroot-authenticator-needed-for-wildcard-domain/64668&quot;&gt;Can’t use webroot authenticator needed for wildcard domain&lt;/a&gt;&lt;/p&gt;
    &lt;/section&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>87366250472891b6d4394679e08b3bfa</guid>
<title>分库分表，我为什么要用Shardingsphere呢？</title>
<link>https://toutiao.io/k/naz0qrj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1379310344827587&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/XJlI2e4PlFCAo31qnIMbDbZYjZiaoMc13vKFLjK6kut61aP4k8Uxmzic3FzFMtZapG4jlyBmJMg0UOndMMRWaTLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;58&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;em data-mid=&quot;&quot;/&gt;&lt;p data-mid=&quot;&quot;&gt;可以参与抽奖&lt;/p&gt;&lt;em data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/em&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.2&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibl6u6nJ01g9icia42icDbWWvO2ObicnIUHjwQKVp30YzLS8xSInYupoEXAKjYeYDibY50CgKLz6ViaDjTjuRqUqaae0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;参与方式&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.2&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/K8beZoNWDcUm9I6ia4UU97K1XHrQx2PavruEm3xAL2W3Vd7JxrB8PLXtmT5JkwqpC9Dg9hEmtVZkY2hibnlkib0Qg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;关注公众号：35岁程序员那些事，后台回复关键词“参与抽奖”，获取抽奖链接，点击抽奖。 中奖之后，可以联系笔者的微信号或者公众号后台回复关键词“联系笔者”，获取联系方式。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分库分表推荐Spring Cloud Alibaba+Seata+Shardingsphere&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分库分表是高并发系统中从可扩展性全面保障业务稳定性的最佳手段之一，当然它也有很多成熟的开源解决方案，比如Apache-Shardingsphere、Mycat和Zebra等，本小节会简单的分析下分库分表相关的生态领域。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ShardingSphere&lt;/strong&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Apache-Shardingsphere框架整体发展经历了很多阶段，①当当网内部数据库中间件 ②Sharding-JDBC ③Sharding-Sphere ④Apache ShardingSphere。Apache-Shardingsphere拥抱开源社区并开放源码和持续技术建设，目前star 13.1k fork 4.4k，是一款非常优秀开源分布式数据库中间件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;第一阶段：它是当当网内部应用框架ddframe中并从关系型数据库模块dd-rdb中分离出来的数据库水平分片框架，并实现透明化数据库分库分表访问。Sharding-JDBC是继dubbox和elastic-job之后，ddframe系列开源的第3个项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;第二阶段：在众多开源的分布式数据库中间件中，当当网的开源组件Sharding-JDBC是一个非常优秀的技术解决方案，一直以来，Sharding-JDBC定位为轻量级Java框架，在Java的JDBC层提供的额外服务。它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;第三阶段：当应用场景多元化之后，仅通过JDBC 层的嵌入，难于应对更加复杂的业务场景，比如：Java 之外的异构语言、数据库管理端命令行和Consul UI等等。但是基于Proxy去模拟数据库的中间代理层的方案则更加容易支撑相应的应用场景。由于Proxy版本的出现，使得Sharding-JDBC这个名字已经不再适合，但是开源社区无法放弃过去两年多Sharding-JDBC的影响力所带来的用户沉淀。因此，还是保留了“Sharding”这个关键词。而且对于分布式数据库中间件来说，无论是分库分表、柔性事务还是数据治理，“Sharding”是这一切的起源。于是官方的开源社区将原有的Sharding-JDBC与新开发的 Sharding-Proxy 以及正在孵化中的Sharding-Sidecar一起组成了一个生态圈，将其命名为Sharding-Sphere，即 Sharding 生态圈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第四阶段；2018年11月10日，开源分布式数据库中间件生态圈Sharding-Sphere正式进入Apache基金会孵化器，并再次更名为Apache ShardingSphere。2019年4月23日，发布4.0.0-RC1，它是ShardingSphere进入Apache基金会后第一个Release Version。2020年4月16日，Apache基金会董事会宣布Apache ShardingSphere成功晋升为Apache顶级项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Mycat&lt;/strong&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Mycat 是什么？从定义和分类来看，它是一个开源的分布式数据库系统，是一个实现了 MySQL 协议的Server，前端用户可以把它看作是一个数据库代理，用MySQL 客户端工具和命令行访问，而其后端可以用 MySQL 原生（Native）协议与多个 MySQL服务器通信，也可以用 JDBC 协议与大多数主流数据库服务器通信， 其核心功能是分表分库，即将一个大表水平分割为 N 个小表，存储在后端 MySQL 服务器里或者其他数据库里。Mycat发展到目前的版本，已经不是一个单纯的 MySQL代理了，它的后端可以支持 MySQL、SQL Server、 Oracle、DB2、PostgreSQL等主流数据库，也支持 MongoDB这种新型 NoSQL方式的存储，未来它也还会支持更多类型的存储数据库。而在最终用户看来，无论是那种存储方式，在Mycat里，都是一个传统的数据库表，支持标准的 SQL语句进行数据的操作，这样一来，对前端业务系统来说，可以大幅降低开发难度，提升开发速度，在测试阶段，可以将一个表定义为任何一种 Mycat支持的存储方式，比如MySQL的 MyASIM表、内存表、或者MongoDB、LevelDB以及号称是世界上最快的内存数据库 MemSQL 上。试想一下，用户表存放在 MemSQL 上，大量读频率远超过写频率的数据如订单的快照数据存放于 InnoDB 中，一些日志数据存放于 MongoDB 中，而且还能把 Oracle 的表跟 MySQL 的表做关联查询，你是否有一种不能呼吸的感觉？而未来，还能通过 Mycat自动将一些计算分析后的数据植入到Hadoop中，并能用 Mycat+Storm/Spark Stream 引擎做大规模数据分析，看到这里，你大概明白了，Mycat是什么？Mycat就是 BigSQL，Big Data On SQL Database。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Mycat目前star 8.8k fork 3.8k，最新版本是1.6.7.6-release，社区活跃度非常高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt; Zebra&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Zebra是一个基于JDBC API协议上开发出的高可用、高性能的数据库访问层解决方案，是美团点评内部使用的数据库访问层中间件。具有以下的功能点：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;配置&lt;/span&gt;&lt;span&gt;集中管理，动态刷&lt;/span&gt;&lt;span&gt;新；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持读写分离、分库分表；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;丰富的监控信息在&lt;/span&gt;&lt;span&gt;CAT&lt;/span&gt;&lt;span&gt;上展现；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;异步化数据&lt;/span&gt;&lt;span&gt;库请求，多数据源支持。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Zebra 简化了读写分离、分库分表的开发工作，使得业务方在分库分库、读写分离的情况下，依然可以像操作单个库那样去操作，屏蔽底层实现的复杂性，对业务透明。Zebra还提供了从读写分离到分库分表全生命周期的技术支持。Zebra提供的完善的监控体系帮助开发掌控数据库请求的整个链路，快速定位问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Zebra 目前star1.9k fork 583，最新版本是2.9.1，当然最后一次更新是2018年12月17日，社区活跃度不是很高，所以一般从技术选型的角度，优先推荐Apache-Shardingsphere或者Mycat。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;对比以上三种分库分表解决方案&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下表，只是对比了Apache-Shardingsphere和Mycat，因为Zebra技术选型不是很多，在这里就不做横向对比。&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Apache-Shardingsphere&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Mycat&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;工作层面&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;JDBC协议&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Mysql协议/JDBC协议&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;运行方式&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Jar包或者代理客户端&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;独立服务以及代理客户端独立部署&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;开发方式&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;代码/配置改动&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;连接地址（数据源）&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;运维方式&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;无&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;管理独立服务，运维成本高&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;性能&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;高并发、高性能&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;独立服务+网络开销，存在性能损耗风险。&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;功能范围&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;协议范围&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;分布式事务和数据迁移等&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;适用操作&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;OLTP&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;OLTP+OLAP&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持数据库&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;基于JDBC协议的数据库&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;Mysql和其他支持JDBC协议的数据库&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;分布式事务&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持XA和Seata AT模式&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持弱XA，支持XA分布式事务（1.6.5）&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;是否支持自定义sharding路由&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;最大支持sharding路由维度&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;2&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;1&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持语言&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持JDBC协议的开发语言&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;动态调整数据源&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;研发/或者第三方插件支持（Mybatis-Plus）&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;添加新组合配置并重启Mycat&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span/&gt;        &lt;strong&gt;      &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;为什么选择ShardingSphere&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了上述技术优势以外，主要还是ShardingSphere偏主流，比如它支持Seata，后续还会支持Nacos等，这些都和Spring Cloud Alibaba契合度非常高的，所以在选择一个技术之前，不要只看它的技术有多牛，要看是否是主流的技术趋势。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f2714a6e862ac70abccad2990f481e92</guid>
<title>成为更好的开发者！行动起来！</title>
<link>https://toutiao.io/k/bcodelm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7a4cb9de69e680821655c10858b4ed84</guid>
<title>python实现B站UP主自动监控</title>
<link>https://toutiao.io/k/p8i7cpt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.确定小目标&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，确定一下我们想实现的脚本的功能：&lt;/span&gt;&lt;span&gt;给&lt;/span&gt;&lt;span&gt;定一些UP主的ID，我们自动关注这些UP主，并开始监控这些UP主是否有更新视频，如果有则微信进行通知并自动下载这些视频。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;&lt;span&gt;模拟登录&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;既然要实现自动关注功能当然还是要先实现B站的模拟登录啦，这里我们还是借助公众号之前开源的DecryptLogin包，先安装一下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;pip&lt;/span&gt; install DecryptLogin --upgrade&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;然后简单写几行代码就ok啦：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; DecryptLogin &lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; login&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;lg = login.Login()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;infos_return, session = lg.bilibili(mode=&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;scanqr&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.自动关注&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;我们先来抓包看看关注UP主时需要请求的接口吧，简单调试之后发现以下这个链接不管从名字还有从需要携带的参数看都很可疑：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5041567695961995&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZTbkic2pYRqickgglaYr7Z4BX5SMYcKZAHQnzC2BiavZw4WNjsULKAgJkKrcXzp5jBEpxfPJ17pA4Wmibmdqch7Pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1684&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是，我们可以先写个脚本测试一下我们的想法，可以看到请求这个接口需要携带的参数如下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2068230277185501&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZTbkic2pYRqickgglaYr7Z4BX5SMYcKZA3gLg4McKK6xdsoUcOVNTBFC90CuAIzx1tib6RokWLQhmczib41WC5vOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1407&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过测试，必须要携带的参数是这些：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fid: 想要关注的UP主的ID；&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;act: 固定值, 为&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;；&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;re_src: 固定值, 为&lt;span class=&quot;code-snippet__number&quot;&gt;11&lt;/span&gt;；&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;jsonp: 固定值, 为jsonp；&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;csrf: 从登录的cookies中可以拿到。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;代码实现如下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;python&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;&#x27;&#x27;关注某个UP主&#x27;&#x27;&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;follow&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(self, up_id)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    url = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;https://api.bilibili.com/x/relation/modify&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    data = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;fid&#x27;&lt;/span&gt;: up_id,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;act&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;re_src&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;11&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;jsonp&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;jsonp&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;csrf&#x27;&lt;/span&gt;: self.session.cookies.get_dict(domain=&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;.bilibili.com&#x27;&lt;/span&gt;).get(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;bili_jct&#x27;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;&#x27;&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    headers = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;Host&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;api.bilibili.com&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;Origin&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;https://space.bilibili.com&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;Referer&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;f&#x27;https://space.bilibili.com/&lt;span class=&quot;code-snippet__subst&quot;&gt;{up_id}&lt;/span&gt;/&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    response = self.session.post(url, data=data, headers=headers)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    response_json = response.json()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; response_json[&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;code&#x27;&lt;/span&gt;], response_json.get(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;message&#x27;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;测试之后登录客户端看发现确实可以成功关注对应的UP主，于是这部分内容也顺利地完成啦~&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.实时监控&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实时监控其实也很简单，只需要先把目标UP主当前首页的作品信息获取到，然后每隔一段时间对比一次，看看有没有新的作品出现就行啦。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体而言，我们需要先获取到UP主当前首页的作品信息：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;python&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;&#x27;&#x27;获得UP主首页所有视频信息&#x27;&#x27;&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;getupvids&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(self, up_id)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    up_vids, aids = [], []&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    headers = {&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;User-Agent&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.117 Safari/537.36&#x27;&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    params = {&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;keyword&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;&#x27;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;mid&#x27;&lt;/span&gt;: up_id, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;ps&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;30&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;tid&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;pn&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;order&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;pubdate&#x27;&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    response = self.session.get(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;https://api.bilibili.com/x/space/arc/search&#x27;&lt;/span&gt;, headers=headers, params=params)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    response_json = response.json()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; item &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; response_json[&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;data&#x27;&lt;/span&gt;][&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;list&#x27;&lt;/span&gt;][&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;vlist&#x27;&lt;/span&gt;]:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        aids.append(item[&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;aid&#x27;&lt;/span&gt;])&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; aid &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; aids:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        params = {&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;aid&#x27;&lt;/span&gt;: aid}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        response = self.session.get(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;https://api.bilibili.com/x/web-interface/view&#x27;&lt;/span&gt;, headers=headers, params=params)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        response_json = response.json()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        up_vids.append(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;https://www.bilibili.com/video/&#x27;&lt;/span&gt; + response_json[&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;data&#x27;&lt;/span&gt;][&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;bvid&#x27;&lt;/span&gt;])&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; up_vids&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;然后每隔一段时间对比一下就行：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;python&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; up_id &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; self.up_ids:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    self.logging(&lt;span class=&quot;code-snippet__string&quot;&gt;f&#x27;正在检查UP主&lt;span class=&quot;code-snippet__subst&quot;&gt;{ups_recorder[up_id][&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;username&quot;&lt;/span&gt;]}&lt;/span&gt;是否更新了视频...&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    vids = self.getupvids(up_id)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ups_recorder[up_id][&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;updated_vids&#x27;&lt;/span&gt;] = []&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; vid &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; vids:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; vid &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; ups_recorder[up_id][&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;vids&#x27;&lt;/span&gt;]: &lt;span class=&quot;code-snippet__keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ups_recorder[up_id][&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;updated_vids&#x27;&lt;/span&gt;].append(vid)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ups_recorder[up_id][&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;vids&#x27;&lt;/span&gt;].append(vid)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;最后把对比结果打印出来，有更新则进行微信消息推送即可：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;python&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; up_id &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; self.up_ids:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; len(ups_recorder[up_id][&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;updated_vids&#x27;&lt;/span&gt;]) &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        msg = &lt;span class=&quot;code-snippet__string&quot;&gt;f&#x27;你关注的UP主&lt;span class=&quot;code-snippet__subst&quot;&gt;{ups_recorder[up_id][&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;username&quot;&lt;/span&gt;]}&lt;/span&gt;更新啦...&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        self.pushwechat(msg)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        self.logging(msg)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; vid &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; ups_recorder[up_id][&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;updated_vids&#x27;&lt;/span&gt;]:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            os.system(&lt;span class=&quot;code-snippet__string&quot;&gt;f&#x27;videodl -i &lt;span class=&quot;code-snippet__subst&quot;&gt;{vid}&lt;/span&gt; -s &lt;span class=&quot;code-snippet__subst&quot;&gt;{ups_recorder[up_id][&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;username&quot;&lt;/span&gt;]}&lt;/span&gt;&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        msg = &lt;span class=&quot;code-snippet__string&quot;&gt;f&#x27;你关注的UP主&lt;span class=&quot;code-snippet__subst&quot;&gt;{ups_recorder[up_id][&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;username&quot;&lt;/span&gt;]}&lt;/span&gt;暂时没有更新...&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        self.logging(msg)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;span&gt;大功告成啦，完整源代码详见相关文件~&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d85fd58e216dfe0b194bc4ce2cde2121</guid>
<title>Java8中的Stream那么强大，那你知道它的原理是什么吗？</title>
<link>https://toutiao.io/k/msk2uu1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single js_wx_tap_highlight wx_tap_card&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left js_a11y_comma js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUyMzM2ODUwMA==&amp;amp;action=getalbum&amp;amp;album_id=1951643299048423427#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;1951643299048423427&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#Java&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;71个&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100010008&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.19315589353612167&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hs540iaTKoaKPniafc8icFWanFqBKibEfLvQfhFRhRPCnfc1GWp6VLgYPElBmNHacozzFQicgMeIp3bB5UNgjrb5DAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2630&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;作者&lt;/em&gt;&lt;em&gt;：岁月安然&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;elsef.com/2019/09/16/Java8中Stream的原理分析&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。&lt;/section&gt;&lt;section&gt;Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。&lt;/section&gt;&lt;section&gt;Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。&lt;/section&gt;&lt;section&gt;本文会对Stream的实现原理进行剖析。&lt;/section&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Stream的组成与特点&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;code&gt;Stream&lt;/code&gt;（流）是一个来自数据源的元素队列并支持聚合操作：&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;元素是特定类型的对象，形成一个队列。 &lt;code&gt;Java&lt;/code&gt;中的&lt;code&gt;Stream&lt;/code&gt;并_不会_向集合那样存储和管理元素，而是按需计算&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;数据源流的来源可以是集合&lt;code&gt;Collection&lt;/code&gt;、数组&lt;code&gt;Array&lt;/code&gt;、&lt;code&gt;I/O channel&lt;/code&gt;， 产生器&lt;code&gt;generator&lt;/code&gt; 等&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;聚合操作类似&lt;code&gt;SQL&lt;/code&gt;语句一样的操作， 比如&lt;code&gt;filter&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;, &lt;code&gt;find&lt;/code&gt;, &lt;code&gt;match&lt;/code&gt;, &lt;code&gt;sorted&lt;/code&gt;等&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;和以前的&lt;code&gt;Collection&lt;/code&gt;操作不同， Stream操作还有两个基础的特征：&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Pipelining&lt;/code&gt;: 中间操作都会返回流对象本身。这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。这样做可以对操作进行优化， 比如延迟执行(&lt;code&gt;laziness evaluation&lt;/code&gt;)和短路( &lt;code&gt;short-circuiting&lt;/code&gt;)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;内部迭代&lt;/code&gt;：以前对集合遍历都是通过&lt;code&gt;Iterator&lt;/code&gt;或者&lt;code&gt;For-Each&lt;/code&gt;的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 &lt;code&gt;Stream&lt;/code&gt;提供了内部迭代的方式， 通过访问者模式 (&lt;code&gt;Visitor&lt;/code&gt;)实现。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;和迭代器又不同的是，&lt;code&gt;Stream&lt;/code&gt; 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 &lt;code&gt;item&lt;/code&gt; 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。&lt;/section&gt;&lt;section&gt;&lt;code&gt;Stream&lt;/code&gt; 的并行操作依赖于 &lt;code&gt;Java7&lt;/code&gt; 中引入的 &lt;code&gt;Fork/Join&lt;/code&gt; 框架（&lt;code&gt;JSR166y&lt;/code&gt;）来拆分任务和加速处理过程。&lt;code&gt;Java&lt;/code&gt; 的并行 API 演变历程基本如下：&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;1.0-1.4 中的 java.lang.Thread&lt;/section&gt;&lt;section&gt;5.0 中的 java.util.concurrent&lt;/section&gt;&lt;section&gt;6.0 中的 Phasers 等&lt;/section&gt;&lt;section&gt;7.0 中的 Fork/Join 框架&lt;/section&gt;&lt;section&gt;8.0 中的 Lambda&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;code&gt;Stream&lt;/code&gt;具有平行处理能力，处理的过程会分而治之，也就是将一个大任务切分成多个小任务，这表示每个任务都是一个操作：&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;section&gt;List&amp;lt;Integer&amp;gt; numbers = Arrays.asList(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;);&lt;br/&gt;numbers.parallelStream()&lt;br/&gt;       .forEach(out::println); &lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;可以看到一行简单的代码就帮我们实现了并行输出集合中元素的功能，但是由于并行执行的顺序是不可控的所以每次执行的结果不一定相同。&lt;/section&gt;&lt;section&gt;如果非得相同可以使用&lt;code&gt;forEachOrdered&lt;/code&gt;方法执行终止操作：&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;section&gt;List&amp;lt;Integer&amp;gt; numbers = Arrays.asList(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;);&lt;br/&gt;numbers.parallelStream()&lt;br/&gt;       .forEachOrdered(out::println);  &lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;这里有一个疑问，如果结果需要有序，是否和我们的并行执行的初衷相悖？是的，这个场景下明显无需使用并行流，直接用串行流执行即可， 否则性能可能更差，因为最后又强行将所有并行结果进行了排序。&lt;/section&gt;&lt;section&gt;OK，下面我们先介绍一下&lt;code&gt;Stream&lt;/code&gt;接口的相关知识。&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;BaseStream接口&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;code&gt;Stream&lt;/code&gt;的父接口是&lt;code&gt;BaseStream&lt;/code&gt;，后者是所有流实现的顶层接口，定义如下：&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;section&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;BaseStream&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;, &lt;span&gt;S&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BaseStream&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;, &lt;span&gt;S&lt;/span&gt;&amp;gt;&amp;gt;&lt;br/&gt;        &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AutoCloseable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;Iterator&amp;lt;T&amp;gt; &lt;span&gt;iterator&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;Spliterator&amp;lt;T&amp;gt; &lt;span&gt;spliterator&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isParallel&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;S &lt;span&gt;sequential&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;S &lt;span&gt;parallel&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;S &lt;span&gt;unordered&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;S &lt;span&gt;onClose&lt;/span&gt;&lt;span&gt;(Runnable closeHandler)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;其中，&lt;code&gt;T&lt;/code&gt;为流中元素的类型，&lt;code&gt;S&lt;/code&gt;为一个&lt;code&gt;BaseStream&lt;/code&gt;的实现类，它里面的元素也是&lt;code&gt;T&lt;/code&gt;并且&lt;code&gt;S&lt;/code&gt;同样是自己：&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;S extends BaseStream&amp;lt;T, S&amp;gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;是不是有点晕？&lt;/section&gt;&lt;section&gt;其实很好理解，我们看一下接口中对&lt;code&gt;S&lt;/code&gt;的使用就知道了：如&lt;code&gt;sequential()&lt;/code&gt;、&lt;code&gt;parallel()&lt;/code&gt;这两个方法，它们都返回了&lt;code&gt;S&lt;/code&gt;实例，也就是说它们分别支持对当前流进行&lt;code&gt;串行&lt;/code&gt;或者&lt;code&gt;并行&lt;/code&gt;的操作，并返回「改变」后的流对象。&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;如果是&lt;code&gt;并行&lt;/code&gt;一定涉及到对当前流的拆分，即将一个流拆分成多个子流，子流肯定和父流的类型是一致的。子流可以继续拆分子流，一直拆分下去…&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;也就是说这里的&lt;code&gt;S&lt;/code&gt;是&lt;code&gt;BaseStream&lt;/code&gt;的一个实现类，它同样是一个流，比如&lt;code&gt;Stream&lt;/code&gt;、&lt;code&gt;IntStream&lt;/code&gt;、&lt;code&gt;LongStream&lt;/code&gt;等。&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Stream接口&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;再来看一下&lt;code&gt;Stream&lt;/code&gt;的接口声明：&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;section&gt;public interface Stream&amp;lt;T&amp;gt; extends BaseStream&amp;lt;T, Stream&amp;lt;T&amp;gt;&amp;gt; &lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;参考上面的解释这里不难理解：即&lt;code&gt;Stream&amp;lt;T&amp;gt;&lt;/code&gt;可以继续拆分为&lt;code&gt;Stream&amp;lt;T&amp;gt;&lt;/code&gt;，我们可以通过它的一些方法来证实：&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;section&gt;&lt;span&gt;Stream&amp;lt;T&amp;gt; &lt;span&gt;filter&lt;/span&gt;&lt;span&gt;(Predicate&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt; predicate)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&amp;lt;R&amp;gt; &lt;span&gt;Stream&amp;lt;R&amp;gt; &lt;span&gt;map&lt;/span&gt;&lt;span&gt;(Function&amp;lt;? &lt;span&gt;super&lt;/span&gt; T, ? extends R&amp;gt; mapper)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&amp;lt;R&amp;gt; &lt;span&gt;Stream&amp;lt;R&amp;gt; &lt;span&gt;flatMap&lt;/span&gt;&lt;span&gt;(Function&amp;lt;? &lt;span&gt;super&lt;/span&gt; T, ? extends Stream&amp;lt;? extends R&amp;gt;&amp;gt; mapper)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;Stream&amp;lt;T&amp;gt; &lt;span&gt;sorted&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;Stream&amp;lt;T&amp;gt; &lt;span&gt;peek&lt;/span&gt;&lt;span&gt;(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt; action)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;Stream&amp;lt;T&amp;gt; &lt;span&gt;limit&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; maxSize)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;Stream&amp;lt;T&amp;gt; &lt;span&gt;skip&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; n)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;...&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;这些都是操作流的&lt;code&gt;中间操作&lt;/code&gt;，它们的返回结果必须是流对象本身。&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;关闭流操作&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;BaseStream 实现了 &lt;code&gt;AutoCloseable&lt;/code&gt; 接口，也就是 &lt;code&gt;close()&lt;/code&gt; 方法会在流关闭时被调用。同时，&lt;code&gt;BaseStream&lt;/code&gt; 中还给我们提供了&lt;code&gt;onClose()&lt;/code&gt;方法：&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;section&gt;&lt;span&gt;/** * Returns an equivalent stream with an additional close handler. Close * handlers are run when the {&lt;span&gt;@link&lt;/span&gt; #close()} method * is called on the stream, and are executed in the order they were * added. All close handlers are run, even if earlier close handlers throw * exceptions. If any close handler throws an exception, the first * exception thrown will be relayed to the caller of {&lt;span&gt;@code&lt;/span&gt; close()}, with * any remaining exceptions added to that exception as suppressed exceptions * (unless one of the remaining exceptions is the same exception as the * first exception, since an exception cannot suppress itself.) May * return itself. * * &amp;lt;p&amp;gt;This is an &amp;lt;a href=&quot;package-summary.html#StreamOps&quot;&amp;gt;intermediate * operation&amp;lt;/a&amp;gt;. * * &lt;span&gt;@param&lt;/span&gt; closeHandler A task to execute when the stream is closed * &lt;span&gt;@return&lt;/span&gt; a stream with a handler that is run if the stream is closed */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;S &lt;span&gt;onClose&lt;/span&gt;&lt;span&gt;(Runnable closeHandler)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;当&lt;code&gt;AutoCloseable&lt;/code&gt;的&lt;code&gt;close()&lt;/code&gt;接口被调用的时候会触发调用流对象的&lt;code&gt;onClose()&lt;/code&gt;方法，但有几点需要注意：&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;onClose()&lt;/code&gt; 方法会返回流对象本身，也就是说可以对改对象进行多次调用&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果调用了多个&lt;code&gt;onClose()&lt;/code&gt; 方法，它会按照调用的顺序触发，但是如果某个方法有异常则只会向上抛出第一个异常&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;前一个 &lt;code&gt;onClose()&lt;/code&gt; 方法抛出了异常不会影响后续 &lt;code&gt;onClose()&lt;/code&gt; 方法的使用&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果多个 &lt;code&gt;onClose()&lt;/code&gt; 方法都抛出异常，只展示第一个异常的堆栈，而其他异常会被压缩，只展示部分信息&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;并行流和串行流&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;code&gt;BaseStream&lt;/code&gt;接口中分别提供了&lt;code&gt;并行流&lt;/code&gt;和&lt;code&gt;串行流&lt;/code&gt;两个方法，&lt;code&gt;这两个方法可以任意调用若干次，也可以混合调用，但最终只会以最后一次方法调用的返回结果为准&lt;/code&gt;。&lt;/section&gt;&lt;section&gt;参考&lt;code&gt;parallel()&lt;/code&gt;方法的说明：&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;Returns an equivalent stream that is parallel. May return&lt;/section&gt;&lt;section&gt;itself, either because the stream was already parallel, or because&lt;/section&gt;&lt;section&gt;the underlying stream state was modified to be parallel.&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;所以多次调用同样的方法并不会生成新的流，而是直接复用当前的流对象。&lt;/section&gt;&lt;section&gt;下面的例子里以最后一次调用&lt;code&gt;parallel()&lt;/code&gt;为准，最终是并行地计算&lt;code&gt;sum&lt;/code&gt;：&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;section&gt;stream.parallel()&lt;br/&gt;   .filter(...)&lt;br/&gt;   .sequential()&lt;br/&gt;   .map(...)&lt;br/&gt;   .parallel()&lt;br/&gt;   .sum();&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ParallelStream背后的男人：ForkJoinPool&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;ForkJoin框架是从JDK7中新特性，它同ThreadPoolExecutor一样，也实现了Executor和ExecutorService 接口。它使用了一个「无限队列」来保存需要执行的任务，而线程的数量则是通过构造函数传入， &lt;span&gt;如果没有向构造函数中传入希望的线程数量，那么当前计算机可用的CPU数量会被设置为线程数量作为默认值&lt;/span&gt;。&lt;/section&gt;&lt;section&gt;ForkJoinPool主要用来使用分治法(Divide-and-Conquer Algorithm) 来解决问题，典型的应用比如_快速排序算法_。这里的要点在于，ForkJoinPool需要使用相对少的线程来处理大量的任务。比如要对1000万个数据进行排序，那么会将这个任务分割成&lt;code&gt;两个500 万的排序任务&lt;/code&gt;和&lt;code&gt;一个针对这两组500万数据的合并任务&lt;/code&gt;。&lt;/section&gt;&lt;section&gt;以此类推，对于500万的数据也会做出同样的分割处理，到最后会设置一个阈值来规定当数据规模到多少时，停止这样的分割处理。比如，当元素的数量小于10时，会停止分割，转而使用插入排序对它们进行排序。那么到最后，所有的任务加起来会有大概2000000+个。&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;问题的关键在于，对于一个任务而言，只有当它所有的子任务完成之后，它才能够被执行，想象一下归并排序的过程。&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;所以当使用ThreadPoolExecutor时，使用分治法会存在问题，因为ThreadPoolExecutor中的线程无法向 任务队列中再添加一个任务并且在等待该任务完成之后再继续执行。而&lt;code&gt;使用ForkJoinPool时，就能够让其中的线程创建新的任务，并挂起当前的任务，此时线程就能够从队列中选择子任务执行&lt;/code&gt;。&lt;/section&gt;&lt;section&gt;那么使用ThreadPoolExecutor或者ForkJoinPool，会有什么性能的差异呢？&lt;/section&gt;&lt;section&gt;首先，使用ForkJoinPool能够使用数量有限的线程来完成非常多的具有「父子关系」的任务，比如使用4个线程来完成超过200万个任务。使用ThreadPoolExecutor 时，是不可能完成的，因为ThreadPoolExecutor中的Thread无法选择优先执行子任务，需要完成200万个具有父子关系的任务时，也需要200万个线程，显然这是不可行的。&lt;/section&gt;&lt;section&gt;Work Stealing原理：&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;每个工作线程都有自己的工作队列WorkQueue；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这是一个双端队列dequeue，它是线程私有的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ForkJoinTask中fork的子任务，将放入运行该任务的工作线程的队头，工作线程将以LIFO的顺序来处理工作队列中的任务，即堆栈的方式；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为了最大化地利用CPU，空闲的线程将从其它线程的队列中「窃取」任务来执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;但是是从工作队列的尾部窃取任务，以减少和队列所属线程之间的竞争；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;双端队列的操作：push()/pop()仅在其所有者工作线程中调用，poll()是由其它线程窃取任务时调用的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当只剩下最后一个任务时，还是会存在竞争，是通过CAS来实现的；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;用ForkJoinPool的眼光来看ParallelStream&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;Java 8为ForkJoinPool添加了一个通用线程池，这个线程池用来处理那些没有被显式提交到任何线程池的任务。它是ForkJoinPool类型上的一个静态元素，它拥有的默认线程数量等于运行计算机上的CPU数量。当调用Arrays 类上添加的新方法时，自动并行化就会发生。比如用来排序一个数组的并行快速排序，用来对一个数组中的元素进行并行遍历。自动并行化也被运用在Java 8新添加的Stream API中。&lt;/section&gt;&lt;section&gt;比如下面的代码用来遍历列表中的元素并执行需要的操作：&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;section&gt;List&amp;lt;UserInfo&amp;gt; userInfoList =&lt;br/&gt;        DaoContainers.getUserInfoDAO().queryAllByList(&lt;span&gt;new&lt;/span&gt; UserInfoModel());&lt;br/&gt;userInfoList.parallelStream().forEach(RedisUserApi::setUserIdUserInfo);&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;对于列表中的元素的操作都会以并行的方式执行。&lt;code&gt;forEach&lt;/code&gt;方法会为每个元素的计算操作创建一个任务，该任务会被前文中提到的&lt;code&gt;ForkJoinPool&lt;/code&gt;中的commonPool处理。以上的并行计算逻辑当然也可以使用&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;完成，但是就代码的可读性和代码量而言，使用&lt;code&gt;ForkJoinPool&lt;/code&gt;明显更胜一筹。&lt;/section&gt;&lt;section&gt;对于&lt;code&gt;ForkJoinPool&lt;/code&gt;通用线程池的线程数量，通常使用默认值就可以了，即运行时计算机的处理器数量。也可以通过设置系统属性：&lt;code&gt;-Djava.util.concurrent .ForkJoinPool.common.parallelism=N&lt;/code&gt; （N为线程数量）,来调整&lt;code&gt;ForkJoinPool&lt;/code&gt;的线程数量。&lt;/section&gt;&lt;section&gt;值得注意的是，当前执行的线程也会被用来执行任务，所以最终的线程个数为&lt;code&gt;N+1&lt;/code&gt;，1就是当前的&lt;code&gt;主线程&lt;/code&gt;。&lt;/section&gt;&lt;section&gt;这里就有一个问题，如果你在并行流的执行计算使用了_阻塞操作_，如I/O，那么很可能会导致一些问题：&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String &lt;span&gt;query&lt;/span&gt;&lt;span&gt;(String question)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  List&amp;lt;String&amp;gt; engines = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;();&lt;br/&gt;  engines.add(&lt;span&gt;&quot;http://www.google.com/?q=&quot;&lt;/span&gt;);&lt;br/&gt;  engines.add(&lt;span&gt;&quot;http://duckduckgo.com/?q=&quot;&lt;/span&gt;);&lt;br/&gt;  engines.add(&lt;span&gt;&quot;http://www.bing.com/search?q=&quot;&lt;/span&gt;);&lt;br/&gt;   &lt;br/&gt;  &lt;span&gt;// get element as soon as it is available&lt;/span&gt;&lt;br/&gt;  Optional&amp;lt;String&amp;gt; result = engines.stream().parallel().map((base) - {&lt;br/&gt;    String url = base + question;&lt;br/&gt;    &lt;span&gt;// open connection and fetch the result&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; WS.url(url).get();&lt;br/&gt;  }).findAny();&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; result.get();&lt;br/&gt;}&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;这个例子很典型，让我们来分析一下：&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;这个并行流计算操作将由主线程和JVM默认的&lt;code&gt;ForkJoinPool.commonPool()&lt;/code&gt;来共同执行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;map&lt;/code&gt;中是一个阻塞方法，需要通过访问&lt;code&gt;HTTP&lt;/code&gt;接口并得到它的&lt;code&gt;response&lt;/code&gt;，所以任何一个worker线程在执行到这里的时候都会阻塞并等待结果。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;所以当此时再其他地方通过并行流方式调用计算方法的时候，将会受到此处阻塞等待的方法的影响。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;目前的&lt;code&gt;ForkJoinPool&lt;/code&gt;的实现并未考虑补偿等待那些阻塞在等待新生成的线程的工作worker线程，所以最终&lt;code&gt;ForkJoinPool.commonPool()&lt;/code&gt;中的线程将备用光并且阻塞等待。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;正如我们上面那个列子的情况分析得知，lambda的执行并不是瞬间完成的,所有使用parallel streams的程序都有可能成为阻塞程序的源头， 并且在执行过程中程序中的其他部分将无法访问这些workers，这意味着任何依赖parallel streams的程序在什么别的东西占用着common ForkJoinPool时将会变得不可预知并且暗藏危机。&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;小结：&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当需要处理递归分治算法时，考虑使用ForkJoinPool。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;仔细设置不再进行任务划分的阈值，这个阈值对性能有影响。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Java 8中的一些特性会使用到ForkJoinPool中的通用线程池。在某些场合下，需要调整该线程池的默认的线程数量&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;lambda应该尽量避免副作用，也就是说，避免突变基于堆的状态以及任何IO&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;lambda应该互不干扰，也就是说避免修改数据源（因为这可能带来线程安全的问题）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;避免访问在流操作生命周期内可能会改变的状态&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;并行流的性能&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;并行流框架的性能受以下因素影响：&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;数据大小：数据够大，每个管道处理时间够长，并行才有意义；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;源数据结构：每个管道操作都是基于初始数据源，通常是集合，将不同的集合数据源分割会有一定消耗；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;装箱：处理基本类型比装箱类型要快；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;核的数量：默认情况下，核数量越多，底层fork/join线程池启动线程就越多；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;单元处理开销：花在流中每个元素身上的时间越长，并行操作带来的性能提升越明显；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;源数据结构分为以下3组：&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;性能好：&lt;code&gt;ArrayList&lt;/code&gt;、数组或&lt;code&gt;IntStream.range&lt;/code&gt;(数据支持随机读取，能轻易地被任意分割)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;性能一般：&lt;code&gt;HashSet&lt;/code&gt;、&lt;code&gt;TreeSet&lt;/code&gt;(数据不易公平地分解，大部分也是可以的)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;性能差：&lt;code&gt;LinkedList&lt;/code&gt;(需要遍历链表，难以对半分解)、&lt;code&gt;Stream.iterate&lt;/code&gt;和&lt;code&gt;BufferedReader.lines&lt;/code&gt;(长度未知，难以分解)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;注意：下面几个部分节选自：Streams 的幕后原理，顺便感谢一下作者_Brian Goetz_，写的太通透了。推荐：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;amp;mid=2247500900&amp;amp;idx=1&amp;amp;sn=5d3f5cc5f47b8eb9dbba59307e7d412d&amp;amp;chksm=ebd5fb48dca2725e8911ddce5dd1279409acea1a503d452ef2574f9cd561c93d4331d4b5d88d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;拥抱 Java 8 并行流吧，让执行速度飞起！&lt;/a&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;NQ模型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;要确定并行性是否会带来提速，需要考虑的最后两个因素是：可用的数据量和针对每个数据元素执行的计算量。&lt;/section&gt;&lt;section&gt;在我们最初的并行分解描述中，我们采用的概念是拆分来源，直到分段足够小，以致解决该分段上的问题的顺序方法更高效。分段大小必须依赖于所解决的问题，确切的讲，取决于每个元素完成的工作量。例如，计算一个字符串的长度涉及的工作比计算字符串的 &lt;code&gt;SHA-1&lt;/code&gt; 哈希值要少得多。为每个元素完成的工作越多，“大到足够利用并行性” 的阈值就越低。类似地，拥有的数据越多， 拆分的分段就越多，而不会与 “太小” 阈值发生冲突。&lt;/section&gt;&lt;section&gt;一个简单但有用的并行性能模型是 &lt;code&gt;NQ&lt;/code&gt; 模型，其中 &lt;code&gt;N&lt;/code&gt; 是数据元素数量，&lt;code&gt;Q&lt;/code&gt; 是为每个元素执行的工作量。乘积 &lt;code&gt;N*Q&lt;/code&gt; 越大，就越有可能获得并行提速。对于具有很小的 &lt;code&gt;Q&lt;/code&gt; 的问题，比如对数字求和，您通常可能希望看到 &lt;code&gt;N &amp;gt; 10,000&lt;/code&gt; 以获得提速；随着 &lt;code&gt;Q&lt;/code&gt; 增加，获得提速所需的数据大小将会减小。&lt;/section&gt;&lt;section&gt;并行化的许多阻碍（比如拆分成本、组合成本或遇到顺序敏感性）都可以通过 &lt;code&gt;Q&lt;/code&gt; 更高的操作来缓解。尽管拆分某个 &lt;code&gt;LinkedList&lt;/code&gt; 特征的结果可能很糟糕，但只要拥有足够大的 &lt;code&gt;Q&lt;/code&gt;，仍然可能获得并行提速。&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;遇到顺序&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;遇到顺序指的是来源分发元素的顺序是否对计算至关重要。一些来源（比如基于哈希的集合和映射）没有有意义的遇到顺序。流标志 &lt;code&gt;ORDERED&lt;/code&gt; 描述了流是否有有意义的遇到顺序。JDK 集合的 &lt;code&gt;spliterator&lt;/code&gt; 会根据集合的规范来设置此标志；一些中间操作可能注入 &lt;code&gt;ORDERED&lt;/code&gt; (&lt;code&gt;sorted()&lt;/code&gt;) 或清除它 (&lt;code&gt;unordered()&lt;/code&gt;)。&lt;/section&gt;&lt;section&gt;如果流没有遇到顺序，大部分流操作都必须遵守该顺序。对于顺序执行，会「自动保留遇到顺序」，因为元素会按遇到它们的顺序自然地处理。甚至在并行执行中，许多操作（无状态中间操作和一些终止操作（比如 &lt;code&gt;reduce()&lt;/code&gt;）），遵守遇到顺序不会产生任何实际成本。但对于其他操作（有状态中间操作，其语义与遇到顺序关联的终止操作，比如 &lt;code&gt;findFirst()&lt;/code&gt; 或 &lt;code&gt;forEachOrdered()&lt;/code&gt;）， 在并行执行中遵守遇到顺序的责任可能很重大。如果流有一个已定义的遇到顺序，但该顺序对结果没有意义， 那么可以通过使用 &lt;code&gt;unordered()&lt;/code&gt; 操作删除 &lt;code&gt;ORDERED&lt;/code&gt; 标志，加速包含顺序敏感型操作的管道的顺序执行。&lt;/section&gt;&lt;section&gt;作为对遇到顺序敏感的操作的示例，可以考虑 &lt;code&gt;limit()&lt;/code&gt;，它会在指定大小处截断一个流。在顺序执行中实现 &lt;code&gt;limit()&lt;/code&gt; 很简单：保留一个已看到多少元素的计数器，在这之后丢弃任何元素。但是在并行执行中，实现 &lt;code&gt;limit()&lt;/code&gt; 要复杂得多；您需要保留前 &lt;code&gt;N&lt;/code&gt; 个元素。此要求大大限制了利用并行性的能力；如果输入划分为多个部分，您只有在某个部分之前的所有部分都已完成后，才知道该部分的结果是否将包含在最终结果中。因此，该实现一般会错误地选择不使用所有可用的核心，或者缓存整个试验性结果，直到您达到目标长度。&lt;/section&gt;&lt;section&gt;如果流没有遇到顺序，&lt;code&gt;limit()&lt;/code&gt; 操作可以自由选择任何 &lt;code&gt;N&lt;/code&gt; 个元素，这让执行效率变得高得多。知道元素后可立即将其发往下游， 无需任何缓存，而且线程之间唯一需要执行的协调是发送一个信号来确保未超出目标流长度。&lt;/section&gt;&lt;section&gt;遇到顺序成本的另一个不太常见的示例是排序。如果遇到顺序有意义，那么 &lt;code&gt;sorted()&lt;/code&gt; 操作会实现一种稳定 排序 （相同的元素按照它们进入输入时的相同顺序出现在输出中），而对于无序的流，稳定性（具有成本）不是必需的。 &lt;code&gt;distinct()&lt;/code&gt; 具有类似的情况：如果流有一个遇到顺序，那么对于多个相同的输入元素，&lt;code&gt;distinct()&lt;/code&gt; 必须发出其中的第一个， 而对于无序的流，它可以发出任何元素 — 同样可以获得高效得多的并行实现。&lt;/section&gt;&lt;section&gt;在您使用 &lt;code&gt;collect()&lt;/code&gt; 聚合时会遇到类似的情形。如果在无序流上执行 &lt;code&gt;collect(groupingBy()&lt;/code&gt;) 操作， 与任何键对应的元素都必须按它们在输入中出现的顺序提供给下游收集器。此顺序对应用程序通常没有什么意义，而且任何顺序都没有意义。在这些情况下，可能最好选择一个并发 收集器（比如 &lt;code&gt;groupingByConcurrent()&lt;/code&gt;），它可以忽略遇到顺序， 并让所有线程直接收集到一个共享的并发数据结构中（比如 &lt;code&gt;ConcurrentHashMap&lt;/code&gt;），而不是让每个线程收集到它自己的中间映射中， 然后再合并中间映射（这可能产生很高的成本）。&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么时候该使用并行流&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;谈了这么多，关于并行流&lt;code&gt;parallelStream&lt;/code&gt;的使用注意事项需要格外注意，它并不是解决性能的万金油，相反，如果使用不当会严重影响性能。我会在另外一篇文章里单独谈这个问题。&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;逆锋起笔&lt;/code&gt;是一个专注于程序员圈子的技术平台，你可以收获&lt;code&gt;最新技术动态&lt;/code&gt;、&lt;code&gt;最新内测资格&lt;/code&gt;、&lt;code&gt;BAT等大厂的经验&lt;/code&gt;、&lt;code&gt;精品学习资料&lt;/code&gt;、&lt;code&gt;职业路线&lt;/code&gt;、&lt;code&gt;副业思维&lt;/code&gt;，微信搜索&lt;code&gt;逆锋起笔&lt;/code&gt;关注！&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;References&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;http://movingon.cn/2017/05/02/jdk8-Stream-BaseStream-%E6%BA%90%E7%A0%81%E9%9A%BE%E7%82%B9%E6%B5%85%E6%9E%901/&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;https://www.jianshu.com/p/bd825cb89e00&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;https://jrebel.com/rebellabs/java-parallel-streams-are-bad-for-your-health/&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;https://blog.csdn.net/weixx3/article/details/81266552&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;https://www.ibm.com/developerworks/cn/java/j-java-streams-5-brian-goetz/index.html&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;https://www.ibm.com/developerworks/cn/java/j-java-streams-3-brian-goetz/index.html&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;https://juejin.im/post/5dc5a148f265da4d4f65c191&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;https://stackoverrun.com/cn/q/10341100&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;推荐好文&lt;br/&gt;&lt;/h4&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247494145&amp;amp;idx=2&amp;amp;sn=32bbd28f61522900d0fca0135d4c3a69&amp;amp;chksm=fa3f0b5acd48824c8b0b637aa499dfbb749e97a8cc28ec30887bb77d99628c931a87ede7cc7e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;面试官：Java 反射是什么？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;面试官：Java 反射是什么？&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247495009&amp;amp;idx=1&amp;amp;sn=4687d83dce9a472ced882f4afe082472&amp;amp;chksm=fa3f0c3acd48852cfd9cd8ac3ba853d0006e58d3905e59c167c1d40539d2533f6b127cfa57cf&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Java 17：和遗留 25 年的漏洞 Say Goodbye&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Java 17：和遗留 25 年的漏洞 Say Goodbye&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247494241&amp;amp;idx=2&amp;amp;sn=3e0533abc22b58e6b46e47ca8c1670d7&amp;amp;chksm=fa3f0b3acd48822cbc77de3b9611bc7c01f7b91b3d2c4fd7e9c274bdabf7d2ac72d3c3220af0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Java 框架 Mybatis 插件开发指南，超详细！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Java 框架 Mybatis 插件开发指南，超详细！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247486783&amp;amp;idx=2&amp;amp;sn=e905010e25ae4adeb46949170a00c97f&amp;amp;chksm=fa3cec64cd4b6572ef34bfbbbbdd5016547bb26b376b2605ddccfe0f1082071bd0a479642ea3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;18 个 Java8 处理日期的新花样，肯定没用过！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;18 个 Java8 处理日期的新花样，肯定没用过！&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247493887&amp;amp;idx=2&amp;amp;sn=b839d751774d9953d0ddc71bc2862211&amp;amp;chksm=fa3f09a4cd4880b2d6780cf763e119f07c8f4fce913ad66b97bf0b0f4b5b3d34a102fa9531c3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你还在 new 对象吗？Java8 通用 Builder 了解一下&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;你还在 new 对象吗？Java8 通用 Builder 了解一下&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>