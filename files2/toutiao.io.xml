<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>da084bef30fb2c52045c5ac74166ce8f</guid>
<title>虎年灯笼逗猫棒流苏宠猫玩具，点击链接立即领券购买！</title>
<link>https://toutiao.io/k/9w6tpgk</link>
<content:encoded>&lt;div&gt;&lt;body data-spm=&quot;10720394/n&quot; id=&quot;readabilityBody&quot;&gt;
    
    
    
    
    
    
      
      
    
    
    
    
    
  &lt;/body&gt;
&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dd3b3e681d4b6791d7f56e763dbba2f6</guid>
<title>Spring Kafka的bug导致超时问题</title>
<link>https://toutiao.io/k/eq9tsj2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这是我们团队负责的一个不太核心的服务。之前与外部交互时应外部要求由普通kafka集群改成加密kafka集群。我们是数据生产端。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.20833333333333334&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicwfQ6ibI3fHObwX9RzQHFBSt3qaTuH9dmVOE5MbT9U1PbmDu4EBMrIJDbqgkQHmp68JUBIw2klKqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;576&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;改的过程中并跑上线，60%的请求耗时增加了2倍，也还是在百毫秒的量级可以接受。但是每次重启的第一个请求要5s以上，会超过；运行过程中，一两个月也会有一次超时。因为我们有三次重试，整体没有影响成功率。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上线的时候我们问过网络组，还专门请教过公司专业负责kafka的团队。结论是：第一，这个慢是外部交互方的问题，不是咱们这边可以处理的；第二，参数上也没有什么可以调优的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们团队内部还是不信邪，调了几个参数，加测之后上线了。频繁度降到了现在的一两个月一次超时，但是没有根治。因为本身这个服务不是特别核心，本身外部是允许有一定失败率的，而且现在实际上也没有失败，几年内业务量也是很平稳的：1分钟4笔。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而我上班时间的状态基本上是我站在两个人中间，我目的是想问一个人问题，结果却先要回答另外一个人的问题，这时候还会出现第四个人说别的事。这个优先级排不上。但是心疼开发小哥哥，每一两个月就要处理一下因为这件事引起的告警。虽然实际不影响，告警出来了，我们就要排查核对是否还是这个问题，并且确实通过重试将消息推送出去了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以本次利用周末，希望可以根治这个疑难杂症，减少运维成本。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;思路&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;前期已经明确了这个外部的加密集群建立连接和数据传输速度都慢于之前的普通集群。之所以第一次慢和每一两个月会慢一次都是连接断开重连造成的。之前我们进行过参数调优，调优做的就是因为1分钟4笔请求，线上以最小部署单元3台机器部署，每台机器1分钟预计处理一笔请求。根据这个数据调整了空闲自动断开连接的时间间隔，保证连接不会因为空闲自动断开。线上验证有效，也侧面证实了是连接过程慢引起的超时。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因为建立连接过程慢，这个主要是外部提供的集群就是如此。既然目前并不影响实际发送成功率。人家代表的是大佬，我们也不好太强硬的去推他们解决。所以我的思路有两个：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第一，探索将建立连接与发送数据分离的可行性：程序启动后先将连接建立好再提供服务。如果生产端是这样实现的。那也许还可以进行连接自动探测，如果连接断开则自动重连，不要等发送数据时再发现连接已断开。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第二，其实第一种思路的可行性渺茫，只是需要验证一下自己的想法。一般的这种消息中间件，消费端是这样实现的。但是生产端采用了更简单的方式：读写数据的时候再探测连接是否可用，不可用则重新建立连接。这种用在发送本来就是异步的，对发送延迟本身敏感度也不高的场景。生产端本来就是这种场景，并且通过测试实际上也确实是在发送时建立的第一次连接。kafka生产端原本就是这种设计的可能性极大。如果是这种情况，那就在生产端真正使用异步，给调用方返回“受理成功”，保证调用方不超时。自己再通过接受回调保证实际的成功。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个事情真要做，还有两个隐形需求：&lt;/p&gt;&lt;p&gt;1、因为外部有需求，数据可以偶尔少发，但是不能重复发送。所以不能使用业务级别的数据发送来实现探测功能。重试也要保证上条确实没有收到。&lt;/p&gt;&lt;p&gt;2、改造不能太大，研发成本要小。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;过程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因为我在网上搜到的这方面都是入门级，没有什么解决这个问题的相关资料。所以采用的主要方法是读源码和官方文档。当然，本文的方法是有前提知识储备基础的。就是&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486403&amp;amp;idx=1&amp;amp;sn=9dbbda3df1deeb5f43c8b7f2cdd87b97&amp;amp;chksm=fafde16dcd8a687be735bf315fa50773cd61ac48f47cd1a1304c792bc1fafa31b4a3705dd9a3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《白话TCP/IP原理》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《白话TCP/IP原理》&lt;/a&gt;系列的相关内容。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;步骤一，查询版本特性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们目前用到的kafka客户端版本是&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.kafka&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-kafka&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.5.8.RELEASE&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.kafka&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;kafka-clients&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.5.0&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;spring-kafka对应的官网的大版本是2.5，所以先点开了2.5.17.RELEASE对应的参考文档。看到一句有用信息：&lt;span/&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;123&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;The default consumer and producer factories can now invoke a callback whenever a consumer or producer is created or closed.&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;默认消费者和生产者工厂现在已经可以在生产者和消费者创建和关闭时引发一个回调。耗时的连接建立过程是可以监听的，我们可以通过打日志进行监控。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤二，查源码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.25217391304347825&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8NPJ8mQAQ1q8sXqPQuGrJ4Ha3K1TVibiat2DibURc51ic33R2pcTPXeQSu5SAmQreTP0tML8HiaBu6DFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;805&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先我们看一下类图，看不清楚没有关系。看这里就好：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先发现Producer、Consumer和Sender都是通过KafkaClient（接口），也就是NetworkClient（实现类）进行网络活动的。其次发现NetworkClient是在传输层和应用层之间起了一个缓冲的作用，解耦了各个部件。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;Producer、Consumer和AdminClient主要管理requests；NetworkClient主要管理connection；Selector主要管理sockets channel。这些被管理对象我在之前的网络系列里都讲过。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果不看代码，我站在设计者角度结合类图猜想：生产端实际使用的是KafkaTemplate的send方法，具体的参数都是由DefaultKafkaProducerFactory接收。实际上连接的建立是Producer类进行。而在Producer类依赖于NetworkClient。而实际上进行连接应该在Sender类。Sender是一个Runnable异步线程来做，那实际建立连接的是run方法中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我跟踪源码验证了猜想。NetworkClient里有个initiateConnect的私有方法，是建立连接用的，跟踪它就可以知道调用的地方。跟踪下来，主要入口在NetworkClient的poll方法，注释如下：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     *                must be non-negative. The actual timeout will be the minimum of timeout, request timeout and&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     *                metadata timeout&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     * &lt;span class=&quot;code-snippet__doctag&quot;&gt;@param&lt;/span&gt; now The current time in milliseconds&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     * &lt;span class=&quot;code-snippet__doctag&quot;&gt;@return&lt;/span&gt; The list of responses received&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;ClientResponse&amp;gt; &lt;span class=&quot;code-snippet__title&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; timeout, &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; now)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;人家明确说了是读写时才会调用。证实了思路一不可行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;步骤三，查自身的代码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;按照思路二，进行异步化。本身生产端就应该是异步的，为什么异步没有生效呢？结合KafkaTemplate的send方法源代码和项目中自己写的代码。异步部分大体是这样：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; SettableListenableFuture future = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; SettableListenableFuture();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        future.&lt;span class=&quot;code-snippet__keyword&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;OK&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        future.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        future.addCallback((sendResult) -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;成功&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }, r -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;失败&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;============end==============&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;就是说KafkaTemplate的异步是靠使用SettableListenableFuture实现的，实际上它的set方法会马上触发callback，是同步的。代码是先同步调用set，并且还手动调用了get（这个方法会等待直到返回结果）。所以整体是同步的。或者直接这么看，future实现异步要有一个Callable或者Runnable的线程方法，人家SettableListenableFuture第一行源码就禁用了Callable。这个我看了2.5.17.RELEASE这个更高版本的spring-kafka，实现没有做更改。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;也就是说spring-kafka自身起码在2.5.X版本里异步没有起到作用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;问题清楚了修改也很简单，比如可以加个异步注解将整个发送方法做异步，重试等逻辑也放到这个方法中。给调用方只返回受理成功。具体怎么解决交给开发小哥哥。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;幸亏我上周已经提前规划好周一要休假。否则现在都2点半了明天上班也没精神。主要时间花在异步不生效的问题上。其实排查异步不生效的思路是很简单清晰的。耗时长是因为：第一，不敢相信spring官方实现的，竟然使用异步的代码实际效果没有异步；第二，关于异步我在网上搜索了一下，都是按照项目中配置的那样。官方这样说，大家这样说，我总得考虑是不是自己搞错了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以我反复的验证、反复的debug之后也不敢下结论。仔细研究了源码仍然不敢下结论。直到终于搜索到一篇文章说要实现异步除了要使用addCallback之外还要加异步标签。人间清醒的我，马上意识到文章实际用了两种不同方法实现异步。作者之所以认为这是一个方法的两个部分大概也是发现其实spring-kafka的异步没好使吧。&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>772d677df0be63a20103914914a8ee21</guid>
<title>如何使用 Prometheus 和 Grafana 优雅的实现服务器可视化</title>
<link>https://toutiao.io/k/ypeezzt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Prometheus 简介&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Prometheus 是一个开源监控工具，实现了高维数据模型。Prometheus 有多种数据可视化模式，其中一种是集成 Grafana。Prometheus 以高效的自定义格式将时间序列数据存储在内存和本地磁盘上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Prometheus 有许多客户端可用于轻松监控服务，也可以轻松创建自定义客户端。每台服务器的可靠性都是独立的，仅依赖本地存储。用 Golang 编程语言编写，所有二进制文件都是静态链接的，易于部署。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Prometheus 采用拉取策略而不是推送策略，即 Prometheus 以一定的时间间隔从 exporter 那里拉取数据，而不是 exporter推送数据到 Prometheus。这种方式有其自身的优点和缺点，但我们不讨论这些细节。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Grafana 简介&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Grafana 是一款开源可视化和分析软件，它允许你查询、可视化、提醒和探索您的指标，无论这些指标存储在哪里。Grafana 支持数十种数据库，我们可以创建一个仪表盘来可视化它们全部。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Grafana 还提供报警，直观地定义阀值，并通过 Slack、 PagerDuty 和其他平台获得通知。Grafana 还提供了多种选项来查看我们的数据，从热力图到直方图，从图形到地理地图。Grafana 有大量的可视化选项可以帮助我们更好地理解数据。我正在使用 Ubuntu 18.04，并将显示与其相关的整个配置。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;3&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Prometheus 安装&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41714285714285715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP24RZHuSIxUnft3eGzkVmfpSss4GP3xvyicPP9t9kKZCllCuGGahTiaBfhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ wget https://github.com/prometheus/prometheus/releases/download/v2.21.0/prometheus-2.21.0.linux-amd64.tar.gz&lt;br/&gt;&lt;br/&gt;$ tar -xzf prometheus-2.21.0.linux-amd64.tar.gz&lt;br/&gt;&lt;br/&gt;$ &lt;span&gt;cd&lt;/span&gt; prometheus-2.21.0.linux-amd64/&lt;br/&gt;&lt;br/&gt;$ ./prometheus&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装非常简单，执行这些命令将会让 Prometheus 服务器在端口 9090 中运行。Prometheus 在端口9090上的仪表板如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2757142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP241aE4Ha3IovXDFnfDbqRL7mRAVP3KticyxulHY3hBQ1MAAXZbiamGhicFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如前所述，从 Prometheus 中抓取的指标发生在恒定的时间段内，因此可以在路径 /metrics 中查看它们。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5171428571428571&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP24kFzrGez6AFyw7RjE5ibCRjf9m2HMhibkjhQOsic6bGlXORJjicj4JIwEaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44571428571428573&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP24nzMibL76Ro9J4hQ2l4ibGZIUJKTtbYeWHicrqHWWiaXiayVvYrwHhhrSI6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些指标用于形成具有各种聚合函数的复杂表达式，以我们想要的形式进行可视化，这在 promql 的帮助下基本上是可能的。Prometheus 中的图形可视化非常基本，没有提供太多自定义，因此我们将使用 Grafana。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;4&lt;/span&gt;&lt;/span&gt;&lt;span&gt;节点 Exporter 安装&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5357142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP24icpAI64JDPMq6GQw1YagUQqgvy0WMoKzBzIXLwy0mZ81sRMUk9SUD1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ wget https://github.com/prometheus/node_exporter/releases/download/v1.0.1/node_exporter-1.0.1.linux-amd64.tar.gz&lt;br/&gt;$ tar -xzf node_exporter-1.0.1.linux-amd64.tar.gz&lt;br/&gt;$ &lt;span&gt;cd&lt;/span&gt; node_exporter-1.0.1.linux-amd64/&lt;br/&gt;$ ./node_exporter&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述命令将安装节点 exporter 并在端口 9100 上运行，并且可以从 /metrics 扩展中抓取指标。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我创建了 3 个虚拟机并在所有虚拟机中安装了节点 exporter，以提供更好的可视化效果。所以在安装之后，我们必须告诉 Prometheus 从哪里抓取指标，这可以通过编辑 prometheus.yml 文件来完成。我们只需要在 scrape_configs 中添加一个新作业，指定目标中的 IP 地址和端口。在 prometheus.yml 文件中添加目标并重新启动 Prometheus 服务器后，我们可以在仪表板以及 /targets 路径中看到新目标及其状态。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP24sZIWYlgmHFyTKFje3hvDqA5Wkqb2naicX5PkAt98nUZfWWQUfZmPfGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3242857142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP248CoewibKticMOHCCsNf3Hawq16hsSickuQDzic5MW9HQYslNOcGRm2M3ag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;确保所有目标都已启动，如果没有，请检查是否为该 VM 实例开放了 9100 端口。你还可以查看 Prometheus 从每个 exporter 抓取的时间以及上次抓取的时间。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;5&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Grafana 安装&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5357142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP24RwzzPAyNeAialDEYIYJdVSaQO907FkT8TMNSMuV0twGicyxIpJNfclIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$wget&lt;/span&gt; https://dl.grafana.com/oss/release/grafana-7.1.5.linux-amd64.tar.gz&lt;br/&gt;&lt;span&gt;$tar&lt;/span&gt; -xzf grafana-7.1.5.linux-amd64.tar.gz&lt;br/&gt;&lt;span&gt;$cd&lt;/span&gt; grafana-7.1.5.linux-amd64/&lt;br/&gt;$./bin/grafana-server&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过运行上述命令即可完成安装，Grafana 运行在端口 3000。默认的用户名和密码均为“admin”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们进入仪表板，我们需要添加一个数据源，在我们的例子中是 Prometheus。我们只需要提供 Prometheus URL 并点击保存和测试按钮。如果我们看到一个成功的提示框，说数据源正在工作，那么我们就可以开始了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.51&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP24gXr0aWmWapKkCLMJ2jN9zEMC4l692YvYvmJNKYYbg917ONLf9VkqWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用自定义的查询语句创建自己的仪表板和面板，但这是一项乏味的工作。因此，为了简化我们的工作，其他用户已经创建了一些仪表板，我们可以使用相同的仪表板并根据我们的需要调整表达式。我使用的是 1860 和 405，这些是我们导入仪表板的唯一ID。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.58&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP24vj5gzbaIP3JIzSkwkrRDGH41dia38Jekm5pibiaHLkGfIibzYoS1xHy6Tw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP24u5Bsnmlhu0IiaG4EMMueZRibXicIl4cYt2qAiatXZdlo93IYJQrx947O4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;导入完成后，我们会看到基于其表达式和时间范围的图表。你可以通过将时间范围减少到 5 分钟来深入了解。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48714285714285716&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP244ADAW9ZB4iaYftWKm1cONuficgKXsbL1ibenj2Z4PlFVDd8svNo07vmNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4857142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP24ZdE24lrmYDI14FFKrJbDaZLKBysT236W3FKjWsO1luJIaLCKL9FAwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48428571428571426&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP24uLKib2s8nYgeRFApT4YVUkmiaRyjJJHrFxxS8LeqVcGrltcYl2vicmzuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Grafana 还允许我们查看合并多个 exporter的表单，以便更好地进行比较。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48428571428571426&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP24L8omeTepzneFS0tR2PXqKibyOKrLIjKmltQTJFExtVLGoibxI7NZpibyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4857142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNk9ttoJ09PzDrlAp0mSnP24kjSCVicvT1wGticLthjLKCVTXGBESgEOibZHJBiaDH0EskBqFsnJ1DgwUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在上面的图片中，我们可以看到所有三个节点 exporter 的数据都被可视化了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上总结了 Prometheus 和 Grafana 的基本设置，用来可视化节点指标数据。如果你觉得有帮助，请点赞分享。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;原文链接：https://medium.com/javarevisited/prometheus-grafana-setup-to-visualize-your-servers-924773b83f3f&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>168bdadf506fc987a21410f0baf68a67</guid>
<title>做数据分析已经会Excel了，还要学Python吗？</title>
<link>https://toutiao.io/k/flymy2i</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;markdown-body detail-content&quot;&gt;&amp;#13;
                &amp;#13;
                &lt;p&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/22019429309b210b00c3&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;strong&gt;【以下文章来源于CDA数据分析师 ，作者张俊红】&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;Hello大家好，我是“对比Excel”系列畅销书作者张俊红。&lt;/p&gt;&amp;#13;
&lt;p&gt;今天我给大家做一些关于我个人的分享，希望对大家的成长能够有所帮助。&lt;/p&gt;&amp;#13;
&lt;p&gt;我叫张俊红，目前在一家互联网公司从事数据分析相关的工作。在工作之余，我个人会写一些公众号文章，还会写数据分析相关的书籍，比如说我最近新出的这本对《对比Excel，轻松学习Python报表自动化》，这本书从上市到现在一直都在当当新书榜第一的位置。&lt;/p&gt;&amp;#13;
&lt;h3 id=&quot;h3--&quot;&gt;&lt;a name=&quot;到底什么是数据分析师？数据分析师到底是干什么工作的？&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;到底什么是数据分析师？数据分析师到底是干什么工作的？&lt;/h3&gt;&lt;p&gt;现在看这篇文章的小伙伴大多数应该是数据分析师，相关的从业人员，或者是想入门数据分析行业的人群，大家可能都对数据分析具体是做什么的，或者是一些具体工作内容会有疑问。&lt;/p&gt;&amp;#13;
&lt;p&gt;这里首先需要声明的一点就是，如今不同的行业和公司，大家对数据分析这个职位的称呼可能不太一样。&lt;/p&gt;&amp;#13;
&lt;p&gt;最普遍的就是称数据分析师，有的公司可能会称 BI分析师或者大数据分析师，有的可能叫经营分析师，也有可能叫数据科学家之类的。其实，不管是公司里关于数据职能它叫什么，大家本质上做的事情其实都是差不多的，都是围绕数据去展开的一些分析。&lt;/p&gt;&amp;#13;
&lt;p&gt;作为数据分析师，具体需要做什么样的一些事情，我个人理解的话可能主要是三个方面。&lt;/p&gt;&amp;#13;
&lt;h4 id=&quot;h4-01-&quot;&gt;&lt;a name=&quot;01 通过数据发现问题&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;01 通过数据发现问题&lt;/h4&gt;&lt;p&gt;第一个方面就是，我们主要通过数据发现问题。这可能对于大多数分析师来说相对比较容易。常规通过各种数据比较，跟同行比较。如果某个指标超过某一个界限，我们就认为这个指标背后的业务是有问题的。&lt;/p&gt;&amp;#13;
&lt;p&gt;第一点就是通过数据去发现问题，第二点是要基于发现的问题去分析背后的本质原因是什么。第二点对数据分析师的要求更高一些。&lt;/p&gt;&amp;#13;
&lt;h4 id=&quot;h4-02-&quot;&gt;&lt;a name=&quot;02 基于问题分析本质原因&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;02 基于问题分析本质原因&lt;/h4&gt;&lt;p&gt;在这个环节我们需要去掌握一些常用的分析方法。&lt;/p&gt;&amp;#13;
&lt;p&gt;比如说漏斗分析法，需要根据漏斗分析法去分析到底哪个环节出现了问题；或者去通过分组分析，需要知道具体哪些维度，哪些用户群现在的问题比较大；还需要去掌握贡献度的计算方法，需要知道到底哪个环节贡献比较大，每个环节的贡献度分别是多少，或者说不同的人群的贡献度分别是怎样的。到这里的话，其实我们是从数据层面对整个问题进行了归因。还要更进一步发现说数据归因下面的业务本质原因是什么。&lt;/p&gt;&amp;#13;
&lt;p&gt;这里给大家举个例子。&lt;/p&gt;&amp;#13;
&lt;p&gt;最近发现DAU发生了比较明显的下降。我们通过各种分析方法，最后得出来的数据结论是：因为23岁以下的用户群体发生了比较明显的下降。到这里我们只是发现了数据层面的原因，那么为什么会下降呢？这里就需要去对业务进行了解。&lt;/p&gt;&amp;#13;
&lt;p&gt;进一步发现23岁以下的用户主要是学生群体，可能恰好赶上学校陆续开学，从而影响了这段时间的活跃度。因此导致23岁以下用户群体发生了大幅度的下降。&lt;/p&gt;&amp;#13;
&lt;p&gt;到这里其实我们才是对整个问题有了最本质的归因。数据层面看到是23岁以下的用户发生了下降，最本质的业务原因是由于这部分学生群体开学了，没有时间来活跃了，这个其实是我们要做的。&lt;/p&gt;&amp;#13;
&lt;h4 id=&quot;h4-03-&quot;&gt;&lt;a name=&quot;03 基于现有问题给出策略上的建议&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;03 基于现有问题给出策略上的建议&lt;/h4&gt;&lt;p&gt;这里面之所以用建议，是因为其实作为分析师可能对这个业务是没有决策权的，只有建议权。&lt;/p&gt;&amp;#13;
&lt;p&gt;继续回到上一个例子，发现最近DAU下降了，主要是学生群体的下降。那么有什么办法？是否能够让学生群体在上学的时候也能够活跃呢？或者说如果学生群体在上学时候没法活跃，那么有没有什么办法去看一下其他非学生用户群体的渗透率是什么样子。有没有办法让非学生群体的渗透率变高。&lt;/p&gt;&amp;#13;
&lt;p&gt;针对这些环节，你还缺哪些能力，就可以根据具体的技能点查漏补缺。&lt;/p&gt;&amp;#13;
&lt;h3 id=&quot;h3--excel-python-&quot;&gt;&lt;a name=&quot;会用Excel，真的需要再学Python吗？&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;会用Excel，真的需要再学Python吗？&lt;/h3&gt;&lt;p&gt;很多读者来问我，说我现在已经会Excel了，我还有必要去学Python吗？&lt;/p&gt;&amp;#13;
&lt;p&gt;其实要注意的是，不管是Excel、Python还是SQL，其实都只是数据分析的一个工具而已。分析的本身和你用什么工具其实是没有关系的。用Excel能做数据分析，用Python也能做，用其他工具也可以。所以大家不要觉得说用Python做数据分析，就比用Excel做数据分析高级，其实不太存在这方面的问题。&lt;/p&gt;&amp;#13;
&lt;p&gt;既然这样的话，可能有同学就会问了，既然如此，我是不是只会Excel这一个技能就好了，我就没必要去学Python了。&lt;/p&gt;&amp;#13;
&lt;p&gt;大家如果有在网上去看招聘要求的话，会看到基本上互联网公司招聘都会有一项要求会Python。&lt;/p&gt;&amp;#13;
&lt;p&gt;为什么呢？我个人认为主要有两方面的，一、在有些场景下，， Excel和Python可能都能做这件事情，但是 Python的效率可能会更好一些。第二个原因就是，在特定的场景下，只有 Python能做，但是 Excel是不能做的。&lt;/p&gt;&amp;#13;
&lt;p&gt;基于这两个原因，我们就有必要去学Python。虽然不是100%的工作都是用Python，但万一遇到非Python不可的时候，你也会，这就能让你如虎添翼。&lt;/p&gt;&amp;#13;
&lt;h3 id=&quot;h3--excel-python-&quot;&gt;&lt;a name=&quot;具体工作场景中，使用Excel和Python的不同&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;具体工作场景中，使用Excel和Python的不同&lt;/h3&gt;&lt;p&gt;接下来具体讲讲日常的具体工作内容，再看一下在具体的场景中用Excel和Python有哪些不一样的地方。&lt;/p&gt;&amp;#13;
&lt;h4 id=&quot;h4--&quot;&gt;&lt;a name=&quot;第一点就是数据处理。&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;第一点就是数据处理。&lt;/h4&gt;&lt;p&gt;比如说缺失值处理，重复值处理，加减乘除运算等。Python的一个优势就在于大数据处理， Excel的话可能上限就100多万行。&lt;/p&gt;&amp;#13;
&lt;p&gt;而且虽然上限是100多万行，但处理量级大的数据的话，一般超过20万行， Excel就反应特别慢了。尤其当你在里面嵌套了很多公式时，经常导致 Excel无响应就崩溃退出了。而Python就不存在这个问题。如果数据量级很小， Excel和Python是差不多的，有时可能Excel效率可能还会更好。&lt;/p&gt;&amp;#13;
&lt;p&gt;这是关于在数据处理方面，因为我们做数据分析的第一件事情，可能就是去对这个数据进行各种各样的一个处理，大家根据自己的情况去选择就好了。&lt;/p&gt;&amp;#13;
&lt;h4 id=&quot;h4--&quot;&gt;&lt;a name=&quot;第二点是报表自动化。&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;第二点是报表自动化。&lt;/h4&gt;&lt;p&gt;常见的有日报、周报、月报等。这种报表有一个好处就是格式相对比较固定。只要格式是固定的，我们就可以想想办法去把进行自动化。自动化的话可以用Python写代码，把代码写好了，它运行一次就ok了。在Excel里面的话也是可以的，去写vba，或者用各种公式嵌套。网上就有人专门去比较过，同样的操作，用vba和用Python的效率差异， Python可能要比vba更快一些，也就是效率更高一些。&lt;br/&gt;Python和 vba在写代码的方面，比如要读取一个文件，Python里面可能一行代码就能够读取进来了，在vba里面可能要写好几行代码，而且也不是那么好理解。&amp;#13;
&lt;/p&gt;&lt;p&gt;还有一个最重要的点是Python现在很火。&lt;/p&gt;&amp;#13;
&lt;p&gt;很火就意味着网上会有很多的资料，如果你遇到什么不太懂的地方，去网上搜一搜大概率是能搜得到的。但是vba整个受众还是相对较小的，如果遇到什么相关问题，可能问身边的人发现也没几个人会用。你去网上搜也得不到太多的资料，我们在学的时候都需要去借助网上资料，网上的资料多少就决定了我们学习的效率。&lt;/p&gt;&amp;#13;
&lt;h4 id=&quot;h4--&quot;&gt;&lt;a name=&quot;第三个方面是图表可视化。&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;第三个方面是图表可视化。&lt;/h4&gt;&lt;p&gt;我们就经常需要去做图，需要做的好看。Excel和Python其实都能做出很好看的图表来，只不过Python里面是有很多现成的包，只需要调用一两行代码就能够做出很好看的图表来。Excel里想要做出好看的图表，就要做进行各种设置，这需要耗费很长的时间，这方面效率是不如 Python。&lt;br/&gt;另外遇到一些比较高级的图表。比如说统计里的核密度图或者小提琴图之类的。这些在Python里都有现成的包可用，只需要一行代码就能绘制出小提琴图。在Excel里面，如果想绘制小提琴图基本是不太可能的。&amp;#13;
&lt;/p&gt;&lt;h4 id=&quot;h4--&quot;&gt;&lt;a name=&quot;最后在统计检验或者说统计学方面。&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;最后在统计检验或者说统计学方面。&lt;/h4&gt;&lt;p&gt;A/B测试大家应该都有用到过，其本质上核心内容就是假设检验。&lt;/p&gt;&amp;#13;
&lt;p&gt;如果是做一些比较基础的假设检验的话，在 Excel和Python都是差不多的，比如T测试。Excel里面也是一个公式的问题，在Python里面就一行代码的问题。在这里其实差不多的。&lt;/p&gt;&amp;#13;
&lt;p&gt;但如果想要用一些比较复杂的检验，比如说多重检验。你在Python里面也有现成的包，一行代码就出来结果了。在Excel里需要人工的去实现两两比较，最后达到多重检验的结果。&lt;/p&gt;&amp;#13;
&lt;p&gt;综合一下，其实从数据处理、报表自动化、图表可视化，统计检验这些是分析师日常工作里用到的几个方面。在不同的场景下，Excel和Python各有不同，有的时候可能Excel的效率会更高一些，有的时候可能两者差不多，有的时候可能Python会更好一点。&lt;/p&gt;&amp;#13;
&lt;p&gt;基于以上几点，我们还是有必要去学学Python的。关于工具，没有哪个工具是万能的。&lt;/p&gt;&amp;#13;
&lt;p&gt;作为一个合格的分析师来讲，你需要有自己的工具库。里面有各种各样的工具，你需要去灵活的去组合，在什么样的场景下，用什么样的工具更好。或者说用哪些工具进行组合，效率会更好。大家不要局限在一种工具，一定要去同时掌握多种工具，能在不同工具之间进行自如的切换。&lt;/p&gt;&amp;#13;
&lt;h3 id=&quot;h3--&quot;&gt;&lt;a name=&quot;拿到业务需求时，如何与正确的理论结合？&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;拿到业务需求时，如何与正确的理论结合？&lt;/h3&gt;&lt;p&gt;现在很多同学在网上不管是看书还是看视频，可能会学了很多数据分析的方法论。到了实际的工作过程中，可能又不知道怎么样把具体的理论和具体实践实际的工作内容结合起来，这是一个本质原因。我认为这方面是，我们对这个方法本身没有理解的太透。因此在学一个方法的时候，首先需要知道这个方法本身的内容是什么，它的适用场景是什么。&lt;/p&gt;&amp;#13;
&lt;p&gt;给大家举个例子，比如说图表可视化的选择。&lt;/p&gt;&amp;#13;
&lt;p&gt;现在图的类型是有很多，最基础的柱状图、折线图、闪点图，还有高级一点的桑基图、热力图之类的。&lt;/p&gt;&amp;#13;
&lt;p&gt;图表的类型有很多，如果学了很多图，也学了很多图表的制作，在实际工作的过程中，让你把数据用图表的形式展示出来，该用什么图去展示呢？&lt;/p&gt;&amp;#13;
&lt;p&gt;这时我们首先要对图表进行归类，比如说对趋势进行表达，可以用折线图。如果说要对比大小，对比不同类别间的大小情况，就可以使用柱状图，或者饼图。如果说想要表示不同指标之间的关系，就是相关性问题，就可以用散点图，或者两条线图去表示。&lt;/p&gt;&amp;#13;
&lt;p&gt;首先要对所学过的所有图表进行归类，归类完之后拿到具体的工作内容、工作场景时，要去看数据是什么类型，想要通过数据表达什么样的内容，达到什么样的目的。&lt;/p&gt;&amp;#13;
&lt;p&gt;比如说要表达最近一年销量趋势是上升还是下降，选择折线图或者柱状图就好了。如果说要表达全国不同的GDP 情况，很明显是比大小的问题。就可以用柱状图。不同的省份是不同的柱子，我们就能够看出来不同柱子之间的大小情况。&lt;/p&gt;&amp;#13;
&lt;p&gt;这样的话其实你就会很清晰了，但如果不提前对学到的东西进行归类，就会导致说不知道该怎么选怎么用。&lt;/p&gt;&amp;#13;
&lt;h3 id=&quot;h3--&quot;&gt;&lt;a name=&quot;业务分析能力如何提升？如何学习？&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;业务分析能力如何提升？如何学习？&lt;/h3&gt;&lt;p&gt;前面其实有提到，我们要对业务有足够的了解，需要去寻求数据背后的本质业务原因，这本质都是业务分析的能力。&lt;br/&gt;业务分析可以拆为两块。&amp;#13;
&lt;/p&gt;&lt;h4 id=&quot;h4--&quot;&gt;&lt;a name=&quot;第一块就是业务的理解程度。&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;第一块就是业务的理解程度。&lt;/h4&gt;&lt;p&gt;我们要对所负责的业务，所分析的业务有足够的了解。&lt;/p&gt;&amp;#13;
&lt;p&gt;比如说要分析外卖的准时情况。下了订单之后，外卖能不能准时送到手里。&lt;/p&gt;&amp;#13;
&lt;p&gt;这里你需要对外卖或者整个物流行业有一个很清楚的了解。从开始客户下订单到最终送到客户手里面，需要经历哪些环节。每个环节它各自的耗时情况是什么样子的，有哪些比较容易产生延误的环节。为什么那些环节会产生比较很高的延误概率？对这些有很清楚的了解之后，在分析的时候才知道应该去看哪些数据，分析哪些数据，分析哪些指标。这个是第一个点，我们要对业务足够了解。&lt;/p&gt;&amp;#13;
&lt;h4 id=&quot;h4--&quot;&gt;&lt;a name=&quot;第二点就是分析思维。&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;第二点就是分析思维。&lt;/h4&gt;&lt;p&gt;分析思维本质上就是个人的逻辑思维能力。这其实可能跟是不是分析工作是没有关系的，逻辑思维能力是一个通用的底层能力。只不过是作为分析师，可能对这一项能力要求会比较高一些。因为你会负责一个业务，然后这个业务里面可能会有很多的指标，需要去弄清楚不同指标之间的关系是什么。哪些指标会影响哪些指标，哪些指标的影响是单向的，就只是a影响b。哪些指标是双向影响，会相互影响，a会影响b， b又反过来还会影响a。这些其实都是考验逻辑能力。&lt;/p&gt;&amp;#13;
&lt;p&gt;以上就是我今天的分享了，希望给大家能有一些帮助。&lt;/p&gt;&amp;#13;
&lt;h4 id=&quot;h4-u5F20u4FCAu7EA2u8001u5E08u65B0u4E66&quot;&gt;&lt;a name=&quot;张俊红老师新书&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;张俊红老师新书&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/2201ee6ff70840507388&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;strong&gt;《对比Excel，轻松学习Python报表自动化》&lt;/strong&gt;&lt;br/&gt;张俊红 著&amp;#13;
&lt;/p&gt;&lt;p&gt;&lt;strong&gt;对比Excel系列畅销超15万册&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;零基础系统学Excel/Python数据处理和格式设置&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;人人都能学会的数据分析工具，加薪不加班&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;赠199元配套视频课&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;这本《对比Excel，轻松学习Python 报表自动化》继承了对比学习的特点，全书内容围绕Excel 功能区的各个模块，通过对比Excel 的方式来详细讲解每个模块中对应的Python 代码如何实现，轻松、快速地帮助职场人实现报表自动化，提高工作效率。本书主要分为4 个部分：第1 部分介绍Python 基础知识，让读者对Python 中常用的操作和概念有所了解；第2 部分介绍格式相关的设置方法，包括字体设置、条件格式设置等内容；第3 部分介绍各种类型的函数；第4 部分介绍自动化相关的其他技能，比如自动发送邮件、自动打包等操作。&lt;/p&gt;&amp;#13;
&lt;p&gt;本书适合每天需要做很多报表，希望通过学习报表自动化来提高工作效率的所有读者，包括但不限于分析师、数据运营、财务等人群。&lt;br/&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/2201c87730aabf12d787&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;（京东满100减50，快快扫码抢购吧！）&amp;#13;
&amp;#13;
            &lt;/p&gt;&lt;/div&gt;&amp;#13;
&amp;#13;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8d9095ec53b2aea594e0ca22738d2a4e</guid>
<title>Python 为什么不设计 do-while 循环结构？</title>
<link>https://toutiao.io/k/46pdicq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在某些编程语言中，例如 C/C++、C#、PHP、Java、JavaScript 等等，do-while 是一种基本的循环结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的核心语义是：先执行一遍&lt;strong&gt;循环体代码&lt;/strong&gt;，然后执行一遍&lt;strong&gt;条件语句&lt;/strong&gt;，若条件语句判断为真，则继续执行循环体代码，并再次执行条件语句；直到条件语句判断为假，则跳出循环结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流程图如下（Java 示例）：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1949458483754514&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTPRhXbY7wxaOCLxvWw4kcMmlibMiaH3ae8n04Z4PT50G10ybDImosDk98mC5mlpo9OmSljhHMsNqooQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;277&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 打印小于 20 的数字&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;int&lt;/span&gt; x = &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;         System.out.print(&lt;span&gt;&quot;value of x : &quot;&lt;/span&gt; + x );&lt;br/&gt;         x++;&lt;br/&gt;         System.out.print(&lt;span&gt;&quot;\n&quot;&lt;/span&gt;);&lt;br/&gt;      } &lt;span&gt;while&lt;/span&gt;(x &amp;lt; &lt;span&gt;20&lt;/span&gt;);&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python 并不支持 do-while 结构，“do”并不是一个有效的关键字。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那么，为什么 Python 不提供这种语法结构呢，这种现状的背后有何种设计考量因素呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在回答这个问题之前，让我们再仔细思考一下 do-while 语法可以解决什么问题，看看使用这种结构能带来什么好处？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最显而易见的好处是：do-while 语法保证了会先执行一遍循环体代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的使用场景也许不多，但是，跟普通的 while 循环或者 for 循环语法的“&lt;strong&gt;条件前置&lt;/strong&gt;”思想不同，它体现的是一种“&lt;strong&gt;条件后置&lt;/strong&gt;”的编程逻辑，也是一种控制循环的常见方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它们的关系似乎有点像 C/C++ 这些语言中的&lt;code&gt;i++&lt;/code&gt;与&lt;code&gt;++i&lt;/code&gt;操作的区别，在某些特殊场合中，也许会更为高效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了这一特点，这种结构最大的应用场景其实是在 C/C++ 中特殊的&lt;code&gt;do {...} while (0)&lt;/code&gt; 用法。这在很多开源项目的源码中都能找到踪迹，例如 Linux、Redis 以及 CPython 解释器，等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里面的数字 0 表示布尔值 False，意味着循环只会执行一遍，然后就跳出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的写法是不是很诡异？所谓“循环”，一般就意味着程序体会被反复执行多次，但是，&lt;code&gt;do {...} while (0)&lt;/code&gt; 却偏偏只需要它执行一遍，这初看起来是有点多余啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种写法主要用在宏函数的定义中，可以解决宏代码块的编译问题，使代码按照我们的意图而合理分块。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，&lt;code&gt;do {...} while (0)&lt;/code&gt; 结合 break 使用，还可以实现很优雅的跳转控制效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在下面的示例中，步骤 1、4 和 5 要求必须执行，而步骤 2 取决于步骤 1 的执行结果，步骤 3 则取决于步骤 2 的执行结果。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 执行步骤 1 &lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (条件&lt;span&gt;1&lt;/span&gt;失败) {&lt;br/&gt;    &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 执行步骤 2 &lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (条件&lt;span&gt;2&lt;/span&gt;失败) {&lt;br/&gt;    &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 执行步骤 3 &lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (条件&lt;span&gt;3&lt;/span&gt;失败) {&lt;br/&gt;    &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;} &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// 执行步骤 4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 执行步骤 5&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这种场景中，我们确实只需要按照顺序执行一遍。do-while 结构很清晰，避免造成多层条件嵌套或者设置诸多额外标记的局面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后还有一点，在汇编层面，do-while 比 while 更接近汇编语言的逻辑，可以节省使用指令，在过去的低内存时代，算得上是一种优化写法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析完 do-while 的好处后，让我们回到主题：Python 为什么不需要设计 do-while 循环语法呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，Python 离底层应用编程太远了，就不用考虑汇编指令的优化了，同时，它也不涉及宏的使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于“条件前置”和“条件后置”的区别，其实并没有太大影响，而且，由于 Python 使用简洁优雅的缩进加冒号语法来划分代码块，导致直译过来的 do-while 语法看起来会很怪异（注意，直译的 while 的条件后没有其它内容）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;do:&lt;br/&gt;    &lt;span&gt;pass&lt;/span&gt;&lt;br/&gt;&lt;span&gt;while&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想要引入新的语法特性，必然要遵守既定的风格习惯。其它语言的 do-while 结构直译成 Python 的话，肯定不合适。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上，在 2003 年时，有一个 PEP 提议给 Python 加上 do-while 语法支持：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3933933933933934&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTPRhXbY7wxaOCLxvWw4kcMmsrCLEKicrDXTCJuzIUbyIpnJInCWjibdsGjCBXWGNiavb0ibgQx6Cqfang/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;666&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PEP-315 Enhanced While Loop&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该 PEP 提议增加一个可选的 do 子句，支持将 while 循环扩展成这样子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;do:&lt;br/&gt;    &amp;lt;setup code&amp;gt;&lt;br/&gt;&lt;span&gt;while&lt;/span&gt; &amp;lt;condition&amp;gt;:&lt;br/&gt;    &amp;lt;loop body&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这不是简单地从其它语言翻译成 Python，它的 while 语句后保留了 Python 的缩进用法，并不会造成直译形式的突兀结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加上 while 循环本身已支持的可选的 else 子句，因此，while 完整的语法结构是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;while_stmt : [&lt;span&gt;&quot;do&quot;&lt;/span&gt; &lt;span&gt;&quot;:&quot;&lt;/span&gt; suite]&lt;br/&gt;            &lt;span&gt;&quot;while&quot;&lt;/span&gt; expression &lt;span&gt;&quot;:&quot;&lt;/span&gt; suite&lt;br/&gt;            [&lt;span&gt;&quot;else&quot;&lt;/span&gt; &lt;span&gt;&quot;:&quot;&lt;/span&gt; suite]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（PS.在本系列的下一篇文章，我们将解释为什么 Python 要支持 while-else 语法）&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，在保持原 while 循环语法不变的情况下，PEP-315 提议支持在 while 前面使用一个可选的 do 子句。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;do 子句只会执行一遍，当它里面出现 break 时，则跳出整个 do-while 循环；当 do 子句中出现 continue 时，则跳出 do 子句，进到 while 的条件判断中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了 do 子句后，很容易就能实现 &lt;code&gt;do {...} while (0)&lt;/code&gt; 的跳转控制效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，这个 PEP 遭到了一些核心开发者的反对。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反对的理由是，不需要引入新的关键字和语法，仅使用现有语法就能很好地实现同样的功能：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;while&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;:&lt;br/&gt;    &amp;lt;setup code&amp;gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &amp;lt;condition&amp;gt;:&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;    &amp;lt;loop body&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python 之父 Guido van Rossum 也持反对意见，他的原话是：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5493482309124768&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTPRhXbY7wxaOCLxvWw4kcMmXNIq2ElibXtzp5P9r7EdavwGFZYXNwJ3OAYwrRv7fsFDX80MQZeSia3Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;537&quot;/&gt;&lt;figcaption&gt;Guido的回复&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Please reject the PEP. More variations along these lines won&#x27;t make the
language more elegant or easier to learn. They&#x27;d just save a few hasty
folks some typing while making others who have to read/maintain their code wonder what it means.&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单翻译一下，这种 do-while 语法并不会使 Python 更优雅好用，反而会产生阅读/维护代码的理解负担。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就个人的感觉而言，我也不赞成引入 PEP-315 那种可选的 do-while 语法，虽然它比固定形式的 do-while 结构更为灵活和优雅一点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后稍微总结一下，do-while 作为一种常见的循环结构，在其它语言中有所发挥，它甚至还发展出了&lt;code&gt;do {...} while (0)&lt;/code&gt; 的典型用法，但是，do-while 能够解决的几个问题要么在 Python 中并不存在（宏定义、汇编指令），要么就是已经有更为合适而低成本的实现（跳转控制）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完这篇文章，你是否还有其它补充的内容呢？欢迎交流讨论。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你对 Python 语言设计相关的话题感兴趣，欢迎订阅 Github 上的《Python为什么》系列文章（&lt;span&gt;https://github.com/chinesehuazhou/python-whydo&lt;/span&gt;）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关联阅读：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247486028&amp;amp;idx=1&amp;amp;sn=ca225d5e85c47698db8bc1ff47849ece&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Python 为什么会有个奇怪的“...”对象？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247486176&amp;amp;idx=1&amp;amp;sn=fbef147f64a13d61aafaef1f83d35c7d&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Python 函数为什么会默认返回 None？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247486813&amp;amp;idx=1&amp;amp;sn=2e45a6491ead2a0a1c9fe60d8b864db3&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Python 之父为什么嫌弃 lambda 匿名函数？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247487798&amp;amp;idx=1&amp;amp;sn=df6ca6a046164bd147910bae165c62ab&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;为什么继承 Python 内置类型会出问题？！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247485664&amp;amp;idx=1&amp;amp;sn=0ee98e223efeb5c83641d2ff15e0f79a&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Python 为什么推荐蛇形命名法？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>