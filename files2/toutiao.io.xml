<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e6f0166764d33f18e512c2a1915da834</guid>
<title>Java 代码中，如何监控 MySQL 的 Binlog？</title>
<link>https://toutiao.io/k/dg2ld8v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近在工作中，遇到了这样一个业务场景，我们需要关注一个业务系统数据库中某几张表的数据，当数据发生新增或修改时，将它同步到另一个业务系统数据库中的表中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一提到数据库的同步，估计大家第一时间想到的就是基于&lt;code&gt;binlog&lt;/code&gt;的主从复制了，但是放在我们的场景中，还有几个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一，并不是需要复制所有表的数据，复制对象只有少量的几张表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二，也是比较麻烦的，两个业务系统数据库表结构可能不一致。例如，要同步数据库1的A表中的某些字段到数据库2的B表中，在这一过程中，A表和B表的字段并不是完全相同&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的话，我们只能通过代码的方式，首先获取到数据库1表中数据的变动，再通过手动映射的方式，插入到数据库2的表中。但是，获取变动数据的这一过程，还是离不开&lt;code&gt;binlog&lt;/code&gt;，因此我们就需要在代码中对&lt;code&gt;binlog&lt;/code&gt;进行一下监控。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先说结论，我们最终使用了一个开源工具&lt;code&gt;mysql-binlog-connector-java&lt;/code&gt;，用来监控&lt;code&gt;binlog&lt;/code&gt;变化并获取数据，获取数据后再手动插入到另一个库的表中，基于它来实现了数据的同步。这个工具的git项目地址如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;https://github.com/shyiko/mysql-binlog-connector-java&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在正式开始前，还是先简单介绍一下&lt;code&gt;mysql&lt;/code&gt;的&lt;code&gt;binlog&lt;/code&gt;，&lt;code&gt;binlog&lt;/code&gt;是一个二进制文件，它保存在磁盘中，是用来记录数据库表结构变更、表数据修改的二进制日志。其实除了数据复制外，它还可以实现数据恢复、增量备份等功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动项目前，首先需要确保&lt;code&gt;mysql&lt;/code&gt;服务已经启用了&lt;code&gt;binlog&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;show variables like &#x27;log_bin&#x27;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果为值为&lt;code&gt;OFF&lt;/code&gt;，表示没有启用，那么需要首先启用&lt;code&gt;binlog&lt;/code&gt;，修改配置文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;log_bin=mysql-bin&lt;br/&gt;binlog-format=ROW&lt;br/&gt;server-id=1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对参数做一个简要说明：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在配置文件中加入了&lt;code&gt;log_bin&lt;/code&gt;配置项后，表示启用了&lt;code&gt;binlog&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;binlog-format&lt;/code&gt;是&lt;code&gt;binlog&lt;/code&gt;的日志格式，支持三种类型，分别是&lt;code&gt;STATEMENT&lt;/code&gt;、&lt;code&gt;ROW&lt;/code&gt;、&lt;code&gt;MIXED&lt;/code&gt;，我们在这里使用&lt;code&gt;ROW&lt;/code&gt;模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;server-id&lt;/code&gt;用于标识一个sql语句是从哪一个&lt;code&gt;server&lt;/code&gt;写入的，这里一定要进行设置，否则我们在后面的代码中会无法正常监听到事件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在更改完配置文件后，重启&lt;code&gt;mysql&lt;/code&gt;服务。再次查看是否启用&lt;code&gt;binlog&lt;/code&gt;，返回为&lt;code&gt;ON&lt;/code&gt;，表示已经开启成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java项目中，首先引入&lt;code&gt;maven&lt;/code&gt;坐标：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.github.shyiko&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;mysql-binlog-connector-java&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;0.21.0&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写一段简单的示例，看看它的具体使用方式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    BinaryLogClient client = &lt;span&gt;new&lt;/span&gt; BinaryLogClient(&lt;span&gt;&quot;127.0.0.1&quot;&lt;/span&gt;, &lt;span&gt;3306&lt;/span&gt;, &lt;span&gt;&quot;hydra&quot;&lt;/span&gt;, &lt;span&gt;&quot;123456&quot;&lt;/span&gt;);&lt;br/&gt;    client.setServerId(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    client.registerEventListener(event -&amp;gt; {&lt;br/&gt;        EventData data = event.getData();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (data &lt;span&gt;instanceof&lt;/span&gt; TableMapEventData) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;Table:&quot;&lt;/span&gt;);&lt;br/&gt;            TableMapEventData tableMapEventData = (TableMapEventData) data;&lt;br/&gt;            System.out.println(tableMapEventData.getTableId()+&lt;span&gt;&quot;: [&quot;&lt;/span&gt;+tableMapEventData.getDatabase() + &lt;span&gt;&quot;-&quot;&lt;/span&gt; + tableMapEventData.getTable()+&lt;span&gt;&quot;]&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (data &lt;span&gt;instanceof&lt;/span&gt; UpdateRowsEventData) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;Update:&quot;&lt;/span&gt;);&lt;br/&gt;            System.out.println(data.toString());&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data &lt;span&gt;instanceof&lt;/span&gt; WriteRowsEventData) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;Insert:&quot;&lt;/span&gt;);&lt;br/&gt;            System.out.println(data.toString());&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data &lt;span&gt;instanceof&lt;/span&gt; DeleteRowsEventData) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;Delete:&quot;&lt;/span&gt;);&lt;br/&gt;            System.out.println(data.toString());&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        client.connect();&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;        e.printStackTrace();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，创建一个&lt;code&gt;BinaryLogClient&lt;/code&gt;客户端对象，初始化时需要传入&lt;code&gt;mysql&lt;/code&gt;的连接信息，创建完成后，给客户端注册一个监听器，来实现它对&lt;code&gt;binlog&lt;/code&gt;的监听和解析。在监听器中，我们暂时只对4种类型的事件数据进行了处理，除了&lt;code&gt;WriteRowsEventData&lt;/code&gt;、&lt;code&gt;DeleteRowsEventData&lt;/code&gt;、&lt;code&gt;UpdateRowsEventData&lt;/code&gt;对应增删改操作类型的事件数据外，还有一个&lt;code&gt;TableMapEventData&lt;/code&gt;类型的数据，包含了表的对应关系，在后面的例子中再具体说明。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里，客户端监听到的是数据库级别的所有事件，并且可以监听到表的&lt;code&gt;DML&lt;/code&gt;语句和&lt;code&gt;DDL&lt;/code&gt;语句，所以我们只需要处理我们关心的事件数据就行，否则会收到大量的冗余数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动程序，控制台输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;com.github.shyiko.mysql.binlog.BinaryLogClient openChannelToBinaryLogStream&lt;br/&gt;信息: Connected to 127.0.0.1:3306 at mysql-bin.000002/1046 (sid:2, cid:10)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;连接mysql的&lt;code&gt;binlog&lt;/code&gt;成功，接下来，我们在数据库中插入一条数据，这里操作的数据库名字是&lt;code&gt;tenant&lt;/code&gt;，表是&lt;code&gt;dept&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; dept &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;&quot;人力&quot;&lt;/span&gt;,&lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;span&gt;&quot;1&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，控制台就会打印监听到事件的数据：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Table:&lt;br/&gt;108: [tenant-dept]&lt;br/&gt;Insert:&lt;br/&gt;WriteRowsEventData{tableId=108, includedColumns={0, 1, 2, 3}, rows=[&lt;br/&gt;    [8, 人力, , 1]&lt;br/&gt;]}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们监听到的事件类型数据有两类，第一类是&lt;code&gt;TableMapEventData&lt;/code&gt;，通过它可以获取操作的数据库名称、表名称以及表的&lt;code&gt;id&lt;/code&gt;。之所以我们要监听这个事件，是因为之后监听的实际操作中返回数据中包含了表的&lt;code&gt;id&lt;/code&gt;，而没有表名等信息，所以如果我们想知道具体的操作是在哪一张表的话，就要先维护一个&lt;code&gt;id&lt;/code&gt;与表的对应关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个打印出来的监听事件数据是&lt;code&gt;WriteRowsEventData&lt;/code&gt;，其中记录了&lt;code&gt;insert&lt;/code&gt;语句作用的表，插入涉及到的列，以及实际插入的数据。另外，如果我们只需要对特定的一张或几张表进行处理的话，也可以提前设置表的名单，在这里根据表&lt;code&gt;id&lt;/code&gt;到表名的映射关系，实现数据的过滤，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们再执行一条&lt;code&gt;update&lt;/code&gt;语句：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;update&lt;/span&gt; dept &lt;span&gt;set&lt;/span&gt; tenant_id=&lt;span&gt;3&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;8&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;9&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;控制台输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Table:&lt;br/&gt;108: [tenant-dept]&lt;br/&gt;Update:&lt;br/&gt;UpdateRowsEventData{tableId=108, includedColumnsBeforeUpdate={0, 1, 2, 3}, includedColumns={0, 1, 2, 3}, rows=[&lt;br/&gt;    {before=[8, 人力, , 1], after=[8, 人力, , 3]},&lt;br/&gt;    {before=[9, 人力, , 1], after=[9, 人力, , 3]}&lt;br/&gt;]}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在执行&lt;code&gt;update&lt;/code&gt;语句时，可能会作用于多条数据，因此在实际修改的数据中，可能包含多行记录，这一点体现在上面的&lt;code&gt;rows&lt;/code&gt;中，包含了&lt;code&gt;id&lt;/code&gt;为8和9的两条数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，再执行一条&lt;code&gt;delete&lt;/code&gt;语句：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;delete&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; dept &lt;span&gt;where&lt;/span&gt; tenant_id=&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;控制台打印如下，&lt;code&gt;rows&lt;/code&gt;中同样返回了生效的两条数据：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Table:&lt;br/&gt;108: [tenant-dept]&lt;br/&gt;Delete:&lt;br/&gt;DeleteRowsEventData{tableId=108, includedColumns={0, 1, 2, 3}, rows=[&lt;br/&gt;    [8, 人力, , 3],&lt;br/&gt;    [9, 人力, , 3]&lt;br/&gt;]}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单的使用原理介绍完成后，再回到我们原先的需求上，需要将一张表中新增或修改的数据同步到另一张表中，问题还有一个，就是如何将返回的数据对应到所在的列上。这时应该怎么实现呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以&lt;code&gt;update&lt;/code&gt;操作为例，我们要对提取的数据后进行一下处理，更改上面例子中的方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (data &lt;span&gt;instanceof&lt;/span&gt; UpdateRowsEventData) {&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;Update:&quot;&lt;/span&gt;);&lt;br/&gt;    UpdateRowsEventData updateRowsEventData = (UpdateRowsEventData) data;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;Serializable[], Serializable[]&amp;gt; row : updateRowsEventData.getRows()) {&lt;br/&gt;        List&amp;lt;Serializable&amp;gt; entries = Arrays.asList(row.getValue());&lt;br/&gt;        System.out.println(entries);&lt;br/&gt;        JSONObject dataObject = getDataObject(entries);&lt;br/&gt;        System.out.println(dataObject);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在将&lt;code&gt;data&lt;/code&gt;强制转换为&lt;code&gt;UpdateRowsEventData&lt;/code&gt;后，可以使用&lt;code&gt;getRows&lt;/code&gt;方法获取到更新的行数据，并且能够取到每一列的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后，调用了一个自己实现的&lt;code&gt;getDataObject&lt;/code&gt;方法，用它来实现数据到列的绑定过程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; JSONObject &lt;span&gt;getDataObject&lt;/span&gt;&lt;span&gt;(List message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    JSONObject resultObject = &lt;span&gt;new&lt;/span&gt; JSONObject();&lt;br/&gt;    String format = &lt;span&gt;&quot;{\&quot;id\&quot;:\&quot;0\&quot;,\&quot;dept_name\&quot;:\&quot;1\&quot;,\&quot;comment\&quot;:\&quot;2\&quot;,\&quot;tenant_id\&quot;:\&quot;3\&quot;}&quot;&lt;/span&gt;;&lt;br/&gt;    JSONObject json = JSON.parseObject(format);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (String key : json.keySet()) {&lt;br/&gt;        resultObject.put(key, message.get(json.getInteger(key)));&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; resultObject;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;format&lt;/code&gt;字符串中，提前维护了一个数据库表的字段顺序的字符串，标识了每个字段位于顺序中的第几个位置。通过上面这个函数，能够实现数据到列的填装过程，我们再执行一条&lt;code&gt;update&lt;/code&gt;语句来查看一下结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;update&lt;/span&gt; dept &lt;span&gt;set&lt;/span&gt; tenant_id=&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;comment&lt;/span&gt;=&lt;span&gt;&quot;1&quot;&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;8&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;控制台打印结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Table:&lt;br/&gt;108: [tenant-dept]&lt;br/&gt;Update:&lt;br/&gt;[8, 人力, 1, 3]&lt;br/&gt;{&quot;tenant_id&quot;:3,&quot;dept_name&quot;:&quot;人力&quot;,&quot;comment&quot;:&quot;1&quot;,&quot;id&quot;:8}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，将修改后的这一条记录中的属性填装到了它对应的列中，之后我们再根据具体的业务逻辑，就可以根据字段名取出数据，将数据同步到其他的表了。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9f4415494a3f08475c2db1fa95a390ec</guid>
<title>高并发服务优化篇：从 RPC 预热转发看服务端性能调优</title>
<link>https://toutiao.io/k/vatr36l</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前的文章中，我们详细阐述了RPC的调用过程，分析了其耗时组成，为我们日常性能调优提供了理论支持。有兴趣的可以点击&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA4ODUzMDg5NQ==&amp;amp;mid=2650001443&amp;amp;idx=1&amp;amp;sn=4da4c8636b6334caab71bb1b2f1f0210&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《详解RPC的一次调用过程》&lt;/a&gt;浏览查看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更好的体验和更优的性能，其实RPC悄悄的做了很多工作，本篇就带大家来看下RPC的一些高级特性和其背后的原因。（还是以开源的dubbo和sofa为例来说明）&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Part1&lt;/span&gt;&lt;span/&gt;&lt;span&gt;RPC为了性能做了哪些努力&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;1.1&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Provider分组和直连&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;路由寻址，负载均衡是很好，可以保证流量均匀从而保护服务节点稳定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，我们有的时候其实不希望我们的请求乱跑，最好能打到指定的机器上。比如联调和测试的时候，直连功能就显得很重要了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有经历过多方合作联调时请求到处乱跑的痛，才知道分组和直连的功能对开发是多么的友好。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//以sofa为例&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Extension&lt;/span&gt;(value = &lt;span&gt;&quot;directUrl&quot;&lt;/span&gt;, order = -&lt;span&gt;20000&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@AutoActive&lt;/span&gt;(consumerSide = &lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DirectUrlRouter&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Router&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到直连路由策略的order属性，被赋予了一个极小的值，变成了优先级最高的路由策略，所以只要配置的直连列表，则会优先走配置中的列表地址。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.901481004507405&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xE6oscyT531mOT1VUCvNaycKtasYAUXYXja6IsS4gfYGUddzpicmnXyFBcPZkuuGVtMltpW3TBbU8iaicxxvQtiaHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1553&quot;/&gt;&lt;figcaption&gt;摘自:www.sofastack.tech&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;1.2&lt;/span&gt;&lt;/span&gt;&lt;span&gt;异步调用&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.44&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xE6oscyT531mOT1VUCvNaycKtasYAUXYAibia17ichoNcAibiaZ5ygdaib8nfkA6D4lgz58yfRPxgTt80nqa6cQWUWKA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;825&quot;/&gt;&lt;figcaption&gt;Future异步调用&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步调用对服务性能和并发的支持起到很大的作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般异步调用有Futurn和callback等方式，这里我们说下Future的原理：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用下游之后，先返回一个Future，上游通过Future.get()方法对结果进行获取，如果结果未返回则会让出CPU资源进入等待，直到结果到达或超时后触发回调方法才被唤醒。由于篇幅问题，Future的核心逻辑的相关注释就不放了，之前的消息消费顺序保障的文章中也有叙述，有兴趣的同学可以看下~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;1.3&lt;/span&gt;&lt;/span&gt;&lt;span&gt;本地优先、远程优先&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，我们会遇到消费端和服务端可能都是自己的情况。这个时候，在常规的路由寻址之外，又提供给我们一种调用的可能性，就是直接调用当前服务器上的程序，这样做的好处比较明显，省去了网络传输等时间损耗，效率更高。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;ProviderInfo&amp;gt; localProviderInfo = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;ProviderInfo&amp;gt;();&lt;br/&gt;&lt;span&gt;// 解析IP，看是否和本地一致&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (ProviderInfo providerInfo : providerInfos) { &lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (localhost.equals(providerInfo.getHost())) {&lt;br/&gt;        localProviderInfo.add(providerInfo);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 命中本机的服务端&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (CommonUtils.isNotEmpty(localProviderInfo)) { &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;.doSelect(invocation, localProviderInfo);&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; { &lt;br/&gt;  &lt;span&gt;// 没有命中本机上的服务端&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;.doSelect(invocation, providerInfos);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，也需要看业务和内部服务路由的实际情况，比如在阿里的单元化部署下，需要根据用户ID路由到对应的zone进行处理，如果还是优先本机，那就可能在操作数据库的时候涉及到跨zone调用，比走远程rpc更加耗时。因此这种情况下就需要禁用本机优先策略。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;1.4&lt;/span&gt;&lt;/span&gt;&lt;span&gt;延迟暴露&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，我们的服务需要依赖一些其他内容才可以正常提供服务，比如缓存预热、线程池预热等等，所以，在服务真正就绪之后再注册到配置中心是很有必要的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//服务注册之前，先延迟&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;export&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 根据配置延迟加载&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (providerConfig.getDelay() &amp;gt; &lt;span&gt;0&lt;/span&gt;) { &lt;br/&gt;        Thread thread = factory.newThread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;         &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;             &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                  Thread.sleep(providerConfig.getDelay());&lt;br/&gt;             } &lt;span&gt;catch&lt;/span&gt; (Throwable ignore) { &lt;br/&gt;             }&lt;br/&gt;              &lt;span&gt;//真正的服务注册逻辑&lt;/span&gt;&lt;br/&gt;              doExport();&lt;br/&gt;         }&lt;br/&gt;      });&lt;br/&gt;      thread.start();&lt;br/&gt;   } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;       doExport();&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;1.5&lt;/span&gt;&lt;/span&gt;&lt;span&gt;粘滞连接&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;问：&lt;/em&gt; 我们需要每次都进行路由寻址和负载均衡来确定服务地址么？&lt;br/&gt;&lt;em&gt;答：&lt;/em&gt; 大部分情况是有利的，不过有些特殊的场景，更希望多次请求连接到同一台服务器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，有状态的服务（很多带数据功能的服务都是有状态的，比如很久之前的带登陆session的Tomcat服务、存储集群服务等），其实希望每次请求都连接到相同的服务器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就用到了粘滞连接功能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; ProviderInfo &lt;span&gt;select&lt;/span&gt;&lt;span&gt;(...)&lt;/span&gt;&lt;span&gt;throws&lt;/span&gt; SofaRpcException &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 判断isSticky 粘滞连接配置&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (consumerConfig.isSticky()) {&lt;br/&gt;        &lt;span&gt;//如果最后一次使用的provider不为空，则使用&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (lastProviderInfo != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            ProviderInfo providerInfo = lastProviderInfo;        &lt;br/&gt;            &lt;span&gt;//获取对应连接&lt;/span&gt;&lt;br/&gt;            ClientTransport lastTransport = connectionHolder.getAvailableClientTransport(providerInfo);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (lastTransport != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; lastTransport.isAvailable()) {&lt;br/&gt;               checkAlias(providerInfo, message);&lt;br/&gt;               &lt;span&gt;return&lt;/span&gt; providerInfo;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;1.6&lt;/span&gt;&lt;/span&gt;&lt;span&gt;预热转发&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面扯了那么多，其实，这个才是我们今天想说的重点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;预热转发是针对服务节点的负载均衡来说的。因为在服务刚启动的时候，如果请求过多可能会影响机器性能和正常业务，如果将处于预热期的机器的请求转发到集群内其它机器，过了预热期之后再恢复正常，则可以保证服务节点的性能和服务整体的可用性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这个功能是怎么实现的呢？--带权重的随机负载均衡。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2909441233140655&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xE6oscyT531mOT1VUCvNaycKtasYAUXYFn7xEmIqibRiaJWibS2ARAB9AA5koD7hgBKF7eA0PA3QVSImEGqnQHbyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1038&quot;/&gt;&lt;figcaption&gt;摘自sofastack：权重随机的原理&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;//累加总权重totalWeight，代码忽略。。。&lt;/span&gt;&lt;br/&gt; &lt;br/&gt; &lt;span&gt;//在总权重内随机得到一个值&lt;/span&gt;&lt;br/&gt; &lt;span&gt;int&lt;/span&gt; offset = random.nextInt(totalWeight);&lt;br/&gt; &lt;br/&gt; &lt;span&gt;//确定随机值落在哪个片断上&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; size; i++) {&lt;br/&gt;     offset -= getWeight(providerInfos.get(i));&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; (offset &amp;lt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        providerInfo = providerInfos.get(i);&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;     }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置示例:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;core_proxy_url=weightStarting:0.2,during:60,weightStarted:0.2,address:x.x.x.x,uniqueId:core_unique&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上，预热权重20%，预热持续时长60s。这样，按照上述计算方式，权重小的服务节点被选到的几率就相对小，以此达到权重随机的效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;那么，为什么刚发布的服务需要预热呢？预热可以起到什么作用呢？&lt;/em&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Part2&lt;/span&gt;&lt;span/&gt;&lt;span&gt;什么是JIT优化&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;都说C++快，Java慢，都是高级语言，是什么导致了运行速度的差别呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个涉及到了两种执行方式：&lt;em&gt;解释执行&lt;/em&gt; 和 &lt;em&gt;编译执行&lt;/em&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对于C++直接将代码编译成机器码运行的方式，Java为了实现跨平台、高度抽象等特性，增加了虚拟机层来实现Java代码到机器码的转换，Java程序先是被编译成符合虚拟机规范的.class字节码逐条将字节码翻译成机器码然后执行，所以，速度上就慢一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然，JVM的加入，给Java的运行速度增加了不少损耗，但是好处也很多，除了跨平台，还为我们实现了诸如内存管理、垃圾回收等容器级通用功能，让研发人员可以更加聚焦业务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;不过，Java也是要面子的，我允许自己慢，但我不允许自己慢那么多！&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么办呢？遵循二八原则，是不是可以找寻程序当中的贡献了大部分调用量的核心代码，把这部分编译成机器码，提升其速度，不就把整体的速度提上去了么，JVM也是这么做的~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，JVM兼容了解释执行和编译执行两种方式，也就是我们常说的&lt;em&gt;即时编译&lt;/em&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;前面的问题到这里其实就可以回答了。为什么需要预热转发呢？是为了用小流量对程序进行预热，目的是为了让核心代码进行及时编译，提高峰值运行速率，提升服务响应~&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面让我们详细看下JIT。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;2.1&lt;/span&gt;&lt;/span&gt;&lt;span&gt;即时编译器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了权衡编译时间和执行效率，JVM设置了多种即时编译器：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;C1（Client 编译器）：基于字节码完成部分优化，如方法内联、常量传递，相对于C2，速度快，但性能稍差。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;C2（Server 编译器）：耗时较长的全局优化，如无用代码消除、重排序、循环展开、公共子表达式替代、常量传播等等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Graal（新的JIT编译器）：侧重于性能和语言操作性。在一些负载上提供比传统编译器更好的峰值性能；用 Graal 执行的语言可以互相调用，可以使用来自其他语言的库。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;2.2&lt;/span&gt;&lt;/span&gt;&lt;span&gt;JIT优化触发条件&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们说过，JVM其实是希望找到承担更多调用请求的代码块进行优化，那，怎么来确认哪些代码时优化目标呢？--&lt;em&gt;热点探测&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;基于采样的热点探测&lt;/strong&gt;：&lt;br/&gt;周期采样，检测各线程栈顶方法，经常出现的方法即为热点方法。好处是简单高效，缺点是不精确，容易受线程运行状态的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;基于计数的热点探测&lt;/strong&gt;：&lt;br/&gt; （包括方法调用计数器和回边计数器）每个方法建立计数器，用来统计调用次数。如果该方法执行次数超过阈值，则该方法被认定为热点方法。好处是足够精确。缺点是空间损耗大，且实现较难。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，可以通过如XX:CompileThreshold等参数来修改阈值，不过，没有绝对把握，还是不要动为好。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Part3&lt;/span&gt;&lt;span/&gt;&lt;span&gt;JIT指导代码优化&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;3.1&lt;/span&gt;&lt;/span&gt;&lt;span&gt;方法内联&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么我们在刚写代码的时候，总是被建议不要写很大的方法体？方法内联的JIT优化策略就是其中一个重要的原因。（还有GC友好等原因）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM内的每一次方法调用，都是栈帧在内存中出栈入栈的过程，方法多了性能损耗自然大，所以要进行方法内联，即把方法执行逻辑直接复制到调用方内部，避免方法调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，方法内联是有方法大小限制的，超过了一定大小的方法，没法做内联优化。所以，平常应该注意，尽量避免写很大很冗长的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们来举个栗子实际感受一下~&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.42788461538461536&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xE6oscyT531mOT1VUCvNaycKtasYAUXYf0L5ketJNicskbDhEEoYSNiaMsHD55URY8Gtjt2BPkUY8z01LsV86Gng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1248&quot;/&gt;&lt;figcaption&gt;两种书写风格的大数相加&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，两个字符串型整数相加，都能实现功能，前一种写法，把中间过程全都拆开，罗列在的方法内，整个方法虽然理解起来稍微方便些，但整体显得冗长；第二种方法，把各个条件都囊括在了for循环条件内，三行代码完成整体操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要去评价，我觉得大部分人都会说第二种写的好，但是，第二种的好难道真的局限于优雅么?&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//添加JVM启动参数，用于打印代码执行过程中的编译详情&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//-XX:+PrintCompilation&lt;/span&gt;&lt;br/&gt;String num1 = &lt;span&gt;&quot;12345&quot;&lt;/span&gt;;&lt;br/&gt;String num2 = &lt;span&gt;&quot;23456&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//循环15000次，因为1.8分层编译下,各层阈值不一样，我们取最大阈值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;15001&lt;/span&gt;;i++) {&lt;br/&gt;    rejectionLB1.stringAdd(num1, num2);&lt;br/&gt;    &lt;span&gt;//rejectionLB1.stringAdd2(num1, num2);&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7463087248322148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xE6oscyT531mOT1VUCvNaycKtasYAUXYXEyrT5gdibUxpDafuiauQqIEbcbeZ9962uuV7MaJ4Fp8MS1fjKjGY8VQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;745&quot;/&gt;&lt;figcaption&gt;执行15000次写法1&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（图中编译层次这一列中，3代表C1编译，4代表C2编译）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到，随着代码的执行次数的增加，一些方法，进行了C1编译，如我们的主方法&lt;em&gt;stringAdd&lt;/em&gt;，而少数方法，从C1编译提升到了C2编译，如AbstractStringBuilder::append方法。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8464730290456431&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xE6oscyT531mOT1VUCvNaycKtasYAUXYmNbB0shCXW6u7YLzCcg1IkBKcicObC5F1ane3CxibozknxtXZc5VkH1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;723&quot;/&gt;&lt;figcaption&gt;执行15000次写法2&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到了什么，&lt;em&gt;stringAdd2&lt;/em&gt; 居然在进行到运行后期执行了C2编译，而且很明显，方法二的C2编译的方法，比方法一要多不少。所以，平常写代码该注意些什么，是不是显而易见了。。。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;3.2&lt;/span&gt;&lt;/span&gt;&lt;span&gt;其他优化&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法内联虽然只是一种简单优化，但是，是后续其他优化的基石。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而JVM的分层优化涉及的点非常多&lt;span/&gt;&lt;sup&gt;[1]&lt;/sup&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;局部优化&lt;/strong&gt;：关注局部数据流分析，数组越界检查消除；寄存器优化，优化跳转、循环、异常处理等；代码简化，如公共表达式提取等等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;控制流优化&lt;/strong&gt;：专注于代码重排序、循环缩减、循环展开、异常定位优化等等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;全局优化&lt;/strong&gt;：主要关注冗余消除，如方法调用、锁；逃逸分析；GC和内存分配优化等等等。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Part4&lt;/span&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇从RPC的预热转发功能，引出了其背后的理论依据--JIT优化。阐述了JIT的基本概念，并用一个实例说明了代码编写风格对JIT优化的实际影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JIT相关的优化实现起来非常难，不过其原理和作用对我们普通研发也不是特别难理解，学习JIT优化的目的，在于了解JVM底层的运行逻辑和实现，让我们可以更加信任托管，聚焦业务逻辑，同时在编写代码时，尽量用JVM友好的方式进行，从而达到更好看、更高效的目的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;推荐阅读:&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4ODUzMDg5NQ==&amp;amp;mid=2650001031&amp;amp;idx=1&amp;amp;sn=75b0eea86788b7b59c61875745b38c4c&amp;amp;chksm=882fa427bf582d31e60fcc7dcecec9c2594f0a69a9333524b0d6296a53d9c32118fe8d709e06&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;3. 高并发架构优化：从BAT实际案例看消息中间件的妙用&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4ODUzMDg5NQ==&amp;amp;mid=2650001071&amp;amp;idx=1&amp;amp;sn=fe00cfd25ae6c8595bcc2aef84ed102f&amp;amp;chksm=882fa40fbf582d19be791b763a2ebf0f8d753c1c498a8ae31ee31db1b4984d9e3afeeac4ac5c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;4. 高并发存储优化：细说数据库索引原理及其优化策略&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4ODUzMDg5NQ==&amp;amp;mid=2650001108&amp;amp;idx=1&amp;amp;sn=5c246e6888438575f74147892671c2d1&amp;amp;chksm=882fa474bf582d62a63d7e0d6dddd2655657c64107520b96ab85fe107679eb66e953100999bd&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;5. 高并发存储优化：许是史上最详尽分库分表文章之一&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4ODUzMDg5NQ==&amp;amp;mid=2650001136&amp;amp;idx=1&amp;amp;sn=2585d7dcf8b0e4328fe07eca4e7fe085&amp;amp;chksm=882fa450bf582d468bc4d92389c9ad6f92ffccf7203495ba7ef139a05904b668d1fcf32ad1b2&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;6. 高并发存储优化：数据库索引优化Explain实战&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4ODUzMDg5NQ==&amp;amp;mid=2650001189&amp;amp;idx=1&amp;amp;sn=87606749ae2be031a9171d272fd73819&amp;amp;chksm=882fa585bf582c932863bd0bfb282c3e8d4b3ff975cabbf9a7c13707ca52cc5d8c17e9eb5551&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;7. 高并发存储番外：阿里数据中间件源码不完全解析&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4ODUzMDg5NQ==&amp;amp;mid=2650001219&amp;amp;idx=1&amp;amp;sn=6c41849dbfa9f7078d455014aa8781c0&amp;amp;chksm=882fa5e3bf582cf521e4c6a71b20020eba215af83ba61983f9989db85ed90e9f6944875878b3&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;8. 高并发存储优化：诸多策略，缓存为王&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4ODUzMDg5NQ==&amp;amp;mid=2650001291&amp;amp;idx=1&amp;amp;sn=c8f0f25f975d950fbb1f63a629ca2d6c&amp;amp;chksm=882fa52bbf582c3df852fc303ef5e2ab0d5b104677f2013644e5b73f9442aad8d62f30c51994&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;9. 高并发存储番外：redis套路，一网打尽&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4ODUzMDg5NQ==&amp;amp;mid=2650001404&amp;amp;idx=1&amp;amp;sn=6a2aa3cd274f85d2b5dbb11ab0fe5da8&amp;amp;chksm=882fa55cbf582c4a0d0f15c25a2ccbd1bfdc0b5d48aa10f43f3b320b6fb69e2c6af4dc96a5b5&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;10. 高并发服务优化：浅谈数据库连接池&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4ODUzMDg5NQ==&amp;amp;mid=2650001443&amp;amp;idx=1&amp;amp;sn=4da4c8636b6334caab71bb1b2f1f0210&amp;amp;chksm=882fba83bf583395af9e911527c4b2b378a757e2c4d37618dc5a575768e1039c2ec3edfd003c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;11. 高并发服务优化：详解RPC的一次调用过程&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;JIT 编译器如何优化代码: &lt;em&gt;&quot;https://www.ibm.com/docs/zh/sdk-java-technology/8?topic=compiler-how-jit-optimizes-code&quot;&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f6feae21f25f36dc381a00cc6067ef6b</guid>
<title>离职期员工的信息安全管控实践</title>
<link>https://toutiao.io/k/h6lpu4v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;感激InfoQ的小编约稿，鞭策自己不断写作，郑重感谢黎同学。&lt;/p&gt;&lt;p&gt;InfoQ 文章地址：&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;amp;mid=2651081284&amp;amp;idx=2&amp;amp;sn=71be4f7712f632c3c01ddd8112a46e0e&amp;amp;scene=21#wechat_redirect&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;离职期的程序员注意了，公司会对你做这些管控措施&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;全文约1880字，阅读约5分钟。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;随着“互联网+”逐年深化，各行各业对信息技术依赖日益显著，众多企业的 IT 系统都承载并积累了大量用户数据或个人信息。前些年，企业的信息安全风险主要集中在互联网在线业务攻击导致的数据泄露，而近些年，数据买卖猖獗，利益诱惑巨大，企业内部员工的违法违规导致数据泄露屡增不减，很多大中型企业的信息安全建设，也逐步从攻防对抗的安全防御建设，到日趋重视员工的违法违规安全管控建设。本文针对离职期员工（以下简称“预离职”或“待离职”员工）的信息安全管控策略进行实践总结和经验分享。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一节：预离职员工的工作权限回收&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;员工的工作权限回收特指账号回收、特权回收，包括两种机制：一种是系统自动清理机制，一种是手工工单流程清理机制。前者需要在 HR 系统中明确离职日期，由各 IT 系统与 HR 系统自动完成离职日过期后的账号权限自动清理动作；后者需要预离职员工自己主动发起工单流程，在最后离职日审核前，完成相关账号权限的清理动作。发生上述两类行为时，对其直接上级自动触发离职员工权限审视电子流。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一般的员工工作权限包括日常办公权限和业务工作权限两类，可以参考下表的安全管控策略进行建设。需注意的是，对于大型集团公司，跨公司转岗应等同于离职情况处理；对大中型企业公司，跨部门转岗应等同于离职情况处理，上述两种情况均应按离职策略管控。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6574074074074074&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cicjwWJEiaibIBZhibZwJZ7n9ibTVM8XnGLJfZ8DeGhSTDPQj9zgoGjLOBbSw3UtCReXZiaryU4wxbNlLiae5xKSqKrGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第二节：预离职员工的日常行为监控和预警&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在员工提出正式离职后，应对员工的日常工作行为监控，并对异常行为进行预警。可采取的常规措施包括：追溯离职前的员工异常行为、每日发送行为跟踪报告、高敏操作实时审计、已有安全管控措施升级。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;追溯发起离职日前六个月的异常行为报告，通过邮件将报告发给员工上级领导提醒关注。异常行为报告的内容应包括六个月内触发的异常行为记录，含告警时间、告警类型、告警事件等描述。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每日邮件发送员工行为跟踪报告给员工及其直接上级，员工行为跟踪报告内容可包括办公类信息如办公 IM 日沟通量、日桌面操作时长、日邮件发送量、考勤信息等，也可包括业务操作信息如 IT 运维使用堡垒机记录、开发人员请求代码记录、业务人员访问业务系统记录等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;针对高敏操作进行实时审计，特别是对日常使用含有敏感数据的业务系统的员工，或 IT 运维、开发人员进行数据库访问、查询取数、下载数据、同步数据、源代码等行为。对高敏操作审计要同步到信息安全监控系统中，由信息安全团队或部门安全员进行实时检视，一旦研判为可疑行为应和预离职员工领导第一时间确认是否正常。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;已有安全管控措施升级，是指在不影响员工体验的情况下，可以采取强化升级的安全管控措施增加对员工违法违规的威慑。如已部署屏幕水印 /APP 水印可以水印加深，通讯录查询数量、次数限制、已部署文件 / 磁盘加密措施自动加密笔记本数据类的大文件或高密级文档等。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第三节：预离职员工的继续教育&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在离职期间内，除了采用技术措施加强企业的信息安全管控，还需不断加强员工个人的法律意识，避免存在侥幸心理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;在离职流程中，签署《信息安全和保密承诺书》声明，员工承诺“不记录、不带走、不泄露”各项公司资料和敏感信息，归还或销毁在职期间各类已获得的公司资料或敏感信息。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在离职期间内，完成《安全意识培训课程》和《违法违规案例警示》学习，并通过在线安全教育考试，考试成绩通过邮件发送至本人及其直接上级，若第一次考试不通过，可第二次考试，两次考试均不通过，延迟离职期一个月，直至考试通过。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对部分核心、高级岗位，在离职流程中，签署《竞业协议》文件，保护企业的商业机密。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第四节：预离职员工的工作申请和审批&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在离职期间内，针对一些数据分析、IT 运维、系统开发等岗位员工，为使其能正常完成相关工作，依然需要保留一定的系统权限，这时需要对这些岗位的高敏操作采用“一用一申请，一用一审批”的流程机制，降低员工违规风险。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于核心或机要岗位员工，应规定在职期间的脱密期，一般为六个月，根据企业情况可以给予一定的保密津贴，员工离职前至少提前六个月申请脱密，并强化保密义务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于员工丢失办公机或因各种原因无法归还办公机的情况，应由员工提供公安机关出具的报案证明，方可启动资产报废流程。同时信息安全团队和办公团队应建立办公机互联网上线监控机制，远程定位机制，远程擦除办公机数据机制等技术措施，进一步防范企业的数据泄露风险。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;综上所述，为便于企业对离职员工的信息安全管控，可以形成一份信息安全管控举措清单供读者交流和学习分享，如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.549074074074074&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cicjwWJEiaibIBZhibZwJZ7n9ibTVM8XnGLJffQc0KUVpjhCMGurAo0RREIljDtzkWvNGchdEF2nXOibianWK8FmvVgmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;坚信少却更好，坚定元认知传播，坚持安全美学，拿个主题，讲300秒就够了。&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b5a2aaa1f0f5cd99a44eab22d5c78bb9</guid>
<title>极致简洁的微前端框架：京东 MicroApp 开源了</title>
<link>https://toutiao.io/k/u0girb8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;MicroApp是一款基于类WebComponent进行渲染的微前端框架，不同于目前流行的开源框架，它从组件化的思维实现微前端，旨在降低上手难度、提升工作效率。它是目前市面上接入微前端成本最低的框架，并且提供了JS沙箱、样式隔离、元素隔离、预加载、资源地址补全、插件系统、数据通信等一系列完善的功能。MicroApp与技术栈无关，也不和业务绑定，可以用于任何前端框架和业务。&lt;/p&gt;

&lt;p&gt;本篇文章中我们会从业务背景、实现思路介绍MicroApp，也会详细介绍它的使用方式和技术原理。&lt;/p&gt;

&lt;h2&gt;背景&lt;/h2&gt;

&lt;p&gt;随着这些年互联网的飞速发展，很多企业的web应用在持续迭代中功能越来越复杂，参与的人员、团队不断增多，导致项目出现难以维护的问题，这种情况PC端尤其常见，许多研发团队也在找寻一种高效管理复杂应用的方案，于是微前端被提及的越来越频繁。&lt;/p&gt;

&lt;p&gt;微前端并不是一项新的技术，而是一种架构理念，它将单一的web应用拆解成多个可以独立开发、独立运行、独立部署的小型应用，并将它们整合为一个应用。&lt;/p&gt;

&lt;p&gt;在实际业务中，我们也遇到同样的问题，并且在不同的业务场景下尝试了各种解决方案，如iframe、npm包、微前端框架，并对各种方案的优劣进行了对比。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;iframe&lt;/strong&gt;：在所有微前端方案中，iframe是最稳定的、上手难度最低的，但它有一些无法解决的问题，例如性能低、通信复杂、双滚动条、弹窗无法全局覆盖，它的成长性不高，只适合简单的页面渲染。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;npm包&lt;/strong&gt;：将子应用封装成npm包，通过组件的方式引入，在性能和兼容性上是最优的方案，但却有一个致命的问题就是版本更新，每次版本发布需要通知接入方同步更新，管理非常困难。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;微前端框架&lt;/strong&gt;：流行的微前端框架有single-spa和qiankun，它们将维护成本和功能上达到一种平衡，是目前实现微前端备受推崇的方案。&lt;/p&gt;

&lt;p&gt;由于iframe和npm包存在问题理论上无法解决，在最初我们采用qiankun作为解决方案，qiankun是在single-spa基础上进行了封装，提供了js沙箱、样式隔离、预加载等功能，并且与技术栈无关，可以兼容不同的框架。&lt;/p&gt;

&lt;h4&gt;业务诉求&lt;/h4&gt;

&lt;p&gt;qiankun虽然优秀，但依然无法满足我们的预期。第一个问题是在我们实际使用场景中，每个接入微前端的项目运行已久，且每个项目由不同的人员和团队负责，如何降低对源代码的侵入性，减少代码修改和沟通成本，这是我们非常关心的点，所以我们需要一种比qiankun接入成本更小的方案。第二个问题是在多方应用接入的情况下，沙箱并不能完美规避所有问题，但qiankun处理此类不可预料的问题的能力并不是非常高效。在不停的摸索中，我们找到一种极致简洁的实现思路，它像使用组件一样简单，只修改一点点代码就可以接入微前端，并且还提供插件系统，赋予开发者灵活处理问题的能力。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img10.360buyimg.com/imagetools/jfs/t1/185588/7/15998/82903/60ff795fE93eec56a/3c19ca78dc9ad6c6.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;实现思路&lt;/h2&gt;

&lt;p&gt;微前端分为主应用和子应用，主应用也称为基座应用，是其它应用的容器载体，子应用则是被嵌入方。我们分别从主应用和子应用的角度出发，探寻一种更简洁和有效的接入微前端的方式。&lt;/p&gt;

&lt;h4&gt;关于qinkun和single-spa的思考&lt;/h4&gt;

&lt;p&gt;在single-spa和qiankun中都是通过监听url change事件，在路由变化时匹配到渲染的子应用并进行渲染。这种基于路由监听渲染是single-spa最早实现的，作为出现最早、最有影响力的微前端框架，single-spa被很多框架和公司借鉴，也导致目前实现的微前端的方式大多是基于路由监听。&lt;/p&gt;

&lt;p&gt;同时single-spa要求子应用修改渲染逻辑并暴露出三个方法：bootstrap、mount、unmount，分别对应初始化、渲染和卸载，这也导致子应用需要对入口文件进行修改。这个特点也被qiankun继承下来，并且需要对webpack配置进行一些修改。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img10.360buyimg.com/imagetools/jfs/t1/183473/37/15898/101494/60ff7960Ee4b564fd/4acf30bf050c62d3.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;

&lt;p&gt;基于路由监听的实现方式和对子应用入口文件以及webpack配置的修改是必须的吗？&lt;/p&gt;

&lt;p&gt;其实并不是，微前端的核心在于资源加载与渲染，iframe的渲染方式就是一个典型，只要能够实现一种元素隔离的功能并且路由符合要求，子应用理论上不需要修改代码就可以嵌入另外一个页面渲染，我们试图从这个角度中找到不一样的实现思路。&lt;/p&gt;

&lt;h4&gt;微前端的组件化&lt;/h4&gt;

&lt;p&gt;要想简化微前端的实现步骤，必须摒弃旧的实现思路，探索出不同的道路。&lt;/p&gt;

&lt;p&gt;我们借鉴了WebComponent的思想，以此为基础推出另一种更加组件化的实现方式：类WebComponent + HTML Entry。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img10.360buyimg.com/imagetools/jfs/t1/179435/7/16019/68727/60ff7960Ea784d238/8d4a4c3ec94375fa.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HTML Entry&lt;/strong&gt;：是指设置html作为资源入口，通过加载远程html，解析其DOM结构从而获取js、css等静态资源来实现微前端的渲染，这也是qiankun目前采用的渲染方案。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WebComponent&lt;/strong&gt;：web原生组件，它有两个核心组成部分：CustomElement和ShadowDom。CustomElement用于创建自定义标签，ShadowDom用于创建阴影DOM，阴影DOM具有天然的样式隔离和元素隔离属性。由于WebComponent是原生组件，它可以在任何框架中使用，理论上是实现微前端最优的方案。但WebComponent有一个无法解决的问题 - ShadowDom的兼容性非常不好，一些前端框架在ShadowDom环境下无法正常运行，尤其是react框架。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;类WebComponent&lt;/strong&gt;：就是使用CustomElement结合自定义的ShadowDom实现WebComponent基本一致的功能。&lt;/p&gt;

&lt;p&gt;由于ShadowDom存在的问题，我们采用自定义的样式隔离和元素隔离实现ShadowDom类似的功能，然后将微前端应用封装在一个CustomElement中，从而模拟实现了一个类WebComponent组件，它的使用方式和兼容性与WebComponent一致，同时也避开了ShadowDom的问题。并且由于自定义ShadowDom的隔离特性，Micro App不需要像single-spa和qiankun一样要求子应用修改渲染逻辑并暴露出方法，也不需要修改webpack配置。&lt;/p&gt;

&lt;p&gt;我们通过上述方案封装了一个自定义标签&lt;code&gt;micro-app&lt;/code&gt;，它的渲染机制和功能与WebComponent类似，开发者可以像使用web组件一样接入微前端。它可以兼容任何框架，在使用方式和数据通信上也更加组件化，这显著降低了基座应用的接入成本，并且由于元素隔离的属性，子应用的改动量也大大降低。&lt;/p&gt;

&lt;h2&gt;使用方式&lt;/h2&gt;

&lt;p&gt;接下来我们将分别介绍主应用和子应用的接入方式。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;以react代码举例&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4&gt;主应用&lt;/h4&gt;

&lt;p&gt;每个自定义标签&lt;code&gt;micro-app&lt;/code&gt;渲染后就是一个微前端的子应用，它的使用方式类似于iframe标签。&lt;/p&gt;

&lt;p&gt;我们需要给标签传递三个基础属性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;name：名称&lt;/li&gt;
&lt;li&gt;url：子应用页面地址&lt;/li&gt;
&lt;li&gt;baseurl：baseurl是基座应用分配给子应用的路由前缀&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用方式如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img12.360buyimg.com/imagetools/jfs/t1/186592/6/15122/62192/60ff79e2E7f555e1c/7e1932bb3622f8bc.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;子应用&lt;/h4&gt;

&lt;p&gt;如果子应用只有一个页面，没有路由配置，则不需要做任何修改。&lt;/p&gt;

&lt;p&gt;如果子应用是多页面，只需要修改路由配置，添加路由前缀。&lt;/p&gt;

&lt;p&gt;如下：&lt;/p&gt;

&lt;p&gt;window.&lt;strong&gt;MICRO_APP_BASE_URL&lt;/strong&gt;是由基座应用下发的路由前缀，在非微前端环境下，这个值为undefined&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img11.360buyimg.com/imagetools/jfs/t1/190291/9/14376/90975/60ff79dfEc16a4443/9c49859e3981b598.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;

&lt;p&gt;完成以上配置即可实现微前端的渲染，对源码的改动量很少。当然MicroApp还提供了其它一些能力，如插件系统、数据通信，我们接下来做详细介绍。&lt;/p&gt;

&lt;h2&gt;核心原理&lt;/h2&gt;

&lt;p&gt;MicroApp 的核心功能在CustomElement基础上进行构建，CustomElement用于创建自定义标签，并提供了元素的渲染、卸载、属性修改等钩子函数，我们通过钩子函数获知微应用的渲染时机，并将自定义标签作为容器，微应用的所有元素和样式作用域都无法逃离容器边界，从而形成一个封闭的环境。&lt;/p&gt;

&lt;h4&gt;概念图&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://img10.360buyimg.com/imagetools/jfs/t1/189928/17/15385/191300/60ff7960Eacd45310/9a3c9377ea09778a.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;渲染流程&lt;/h4&gt;

&lt;p&gt;通过自定义元素&lt;code&gt;micro-app&lt;/code&gt;的生命周期函数&lt;code&gt;connectedCallback&lt;/code&gt;监听元素被渲染，加载子应用的html并转换为DOM结构，递归查询所有js和css等静态资源并加载，设置元素隔离，拦截所有动态创建的script、link等标签，提取标签内容。将加载的js经过插件系统处理后放入沙箱中运行，对css资源进行样式隔离，最后将格式化后的元素放入&lt;code&gt;micro-app&lt;/code&gt;中，最终将&lt;code&gt;micro-app&lt;/code&gt;元素渲染为一个微前端的子应用。在渲染的过程中，会执行开发者绑定的生命周期函数，用于进一步操作。&lt;/p&gt;

&lt;h5&gt;流程图&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;https://img10.360buyimg.com/imagetools/jfs/t1/178969/12/16101/641009/60ff7969E1a55f644/0744f4bc7e443921.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;元素隔离&lt;/h4&gt;

&lt;p&gt;元素隔离源于ShadowDom的概念，即ShadowDom中的元素可以和外部的元素重复但不会冲突，ShadowDom只能对自己内部的元素进行操作。&lt;/p&gt;

&lt;p&gt;MicroApp模拟实现了类似的功能，我们拦截了底层原型链上元素的方法，保证子应用只能对自己内部的元素进行操作，每个子应用都有自己的元素作用域。&lt;/p&gt;

&lt;p&gt;元素隔离可以有效的防止子应用对基座应用和其它子应用元素的误操作，常见的场景是多个应用的根元素都使用相同的id，元素隔离可以保证子应用的渲染框架能够正确找到自己的根元素。&lt;/p&gt;

&lt;h5&gt;概念图&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;https://img10.360buyimg.com/imagetools/jfs/t1/190440/38/14742/40459/60ff7960E0a269ce2/882feb29236389ea.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;

&lt;h5&gt;实际效果&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;https://img13.360buyimg.com/imagetools/jfs/t1/180656/17/16071/139072/60ff795cEcee2c409/4099fb9323bd8bbb.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，&lt;code&gt;micro-app&lt;/code&gt;元素内部渲染的就是一个子应用，它还有两个自定义元素 &lt;code&gt;micro-app-head&lt;/code&gt;、&lt;code&gt;micro-app-body&lt;/code&gt;，这两个元素的作用分别对应html中的head和body元素。子应用在原head元素中的内容和一些动态创建并插入head的link、script元素都会移动到&lt;code&gt;micro-app-head&lt;/code&gt;中，在原body元素中的内容和一些动态创建并插入body的元素都会移动到&lt;code&gt;micro-app-body&lt;/code&gt;中。这样可以防止子应用的元素泄漏到全局，在进行元素查询、删除等操作时，只需要在&lt;code&gt;micro-app&lt;/code&gt;内部进行处理，是实现元素隔离的重要基础。&lt;/p&gt;

&lt;p&gt;可以将&lt;code&gt;micro-app&lt;/code&gt;理解为一个内嵌的html页面，它的结构和功能都和html页面类似。&lt;/p&gt;

&lt;h4&gt;插件系统&lt;/h4&gt;

&lt;p&gt;微前端的使用场景非常复杂，即便有沙箱机制也无法避免所有的问题，所以我们提供了一套插件系统用于解决一些无法预知的问题。&lt;/p&gt;

&lt;p&gt;插件可以理解为符合特定规则的对象，对象中提供一个函数用于对资源进行处理，插件通常由开发者自定义。&lt;/p&gt;

&lt;p&gt;插件系统的作用是对传入的静态资源进行初步处理，并依次调用符合条件的插件，将初步处理后的静态资源作为参数传入插件，由插件对资源内容进一步的修改，并将修改后的内容返回。插件系统赋予开发者灵活处理静态资源的能力，对有问题的资源文件进行修改。&lt;/p&gt;

&lt;p&gt;插件系统本身是纯净的，不会对资源内容造成影响，它的作用是统筹各个插件如何执行，当开发者没有设置插件时，则传入和传出的内容是一致的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img10.360buyimg.com/imagetools/jfs/t1/189464/37/15405/123633/60ff7960E2d389171/d06f77e85da8ef1f.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;js沙箱和样式隔离&lt;/h4&gt;

&lt;p&gt;js沙箱通过Proxy代理子应用的全局对象，防止应用之间全局变量的冲突，记录或清空子应用的全局副作用函数，也可以向子应用注入全局变量用于定制化处理。&lt;/p&gt;

&lt;p&gt;样式隔离是指对子应用的link和style元素的css内容进行格式化处理，确保子应用的样式只作用域自身，无法影响外部。&lt;/p&gt;

&lt;p&gt;MicroApp借鉴了qiankun的js沙箱和样式隔离方案，这也是目前应用广泛且成熟的方案。&lt;/p&gt;

&lt;h4&gt;预加载&lt;/h4&gt;

&lt;p&gt;MicroApp 提供了预加载子应用的功能，它是基于requestIdleCallback实现的，预加载不会对基座应用和其它子应用的渲染速度造成影响，它会在浏览器空闲时间加载应用的静态资源，在应用真正被渲染时直接从缓存中获取资源并渲染。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img13.360buyimg.com/imagetools/jfs/t1/178126/21/880/28986/6084d5c9Ee69c5222/0e4e04503a1cfefc.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;资源地址补全&lt;/h4&gt;

&lt;p&gt;微前端中经常出现资源丢失的现象，原因是基座应用将子应用的资源加载到自己的页面渲染，如果子应用的静态资源地址是相对地址，浏览器会以基座应用所在域名地址补全静态资源，从而导致资源丢失。&lt;/p&gt;

&lt;p&gt;资源地址补全就是将子应用静态资源的相对地址补全为绝对地址，保证地址指向正确的资源路径，这种操作类似于webpack在运行时设置publicPath。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img10.360buyimg.com/imagetools/jfs/t1/190332/18/14927/89428/60ff7960E9563d30e/6fc83e4772f5bec9.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;生命周期&lt;/h4&gt;

&lt;p&gt;在微应用渲染时，&lt;code&gt;micro-app&lt;/code&gt;元素在不同渲染阶段会触发相应的生命周期事件，基座应用可以通过监听事件来进行相应的操作。
&lt;img src=&quot;https://img12.360buyimg.com/imagetools/jfs/t1/178142/16/16160/86331/60ff79dfEfbdcc2cf/f9d5b289582e6436.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;

&lt;p&gt;生命周期列表：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;created：当micro-app标签被创建后，加载资源之前执行。&lt;/li&gt;
&lt;li&gt;beforemount：资源加载完成，正式渲染之前执行。&lt;/li&gt;
&lt;li&gt;mounted：子应用已经渲染完成后执行&lt;/li&gt;
&lt;li&gt;unmount：子应用卸载时执行。&lt;/li&gt;
&lt;li&gt;error：当出现破坏性错误，无法继续渲染时执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在卸载时，子应用也会接收到一个卸载的事件，用于执行卸载相关操作。&lt;/p&gt;

&lt;h4&gt;数据通信&lt;/h4&gt;

&lt;p&gt;数据通信是微前端中非常重要的功能，实现数据通信的技术方案很多，优秀的方案可以提升开发效率，减少试错成本。我们也研究了qiankun等微前端框架数据通信的方式，但他们的实现方式并不适合我们，我们尝试直接通过元素属性传递复杂数据的形式实现数据通信。&lt;/p&gt;

&lt;p&gt;对于前端研发人员最熟悉的是组件化的数据交互的方式，而自定义元素micro-app作为类WebComponent，通过组件属性进行数据交互必然是最优的方式。但MicroApp在数据通信中遇到的最大的问题是自定义元素无法支持设置对象类型属性，例如&lt;code&gt;&amp;lt;micro-app data={x: 1}&amp;gt;&amp;lt;/micro-app&amp;gt;&lt;/code&gt; 会转换为 &lt;code&gt;&amp;lt;micro-app data=&#x27;[object Object]&#x27;&amp;gt;&amp;lt;/micro-app&amp;gt;&lt;/code&gt;，想要以组件化形式进行数据通信必须让元素支持对象属性。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，我们重写了&lt;code&gt;micro-app&lt;/code&gt;元素原型链上属性设置的方法，在&lt;code&gt;micro-app&lt;/code&gt;元素设置对象属性时将传递的值保存到数据中心，通过数据中心将值分发给子应用。&lt;/p&gt;

&lt;p&gt;MicroApp中数据是绑定通信的，即每个&lt;code&gt;micro-app&lt;/code&gt;元素只能与自己指向的子应用进行通信，这样每个应用都有着清晰的数据链，可以避免数据的混乱，同时MicroApp也支持全局通信，以便跨应用传递数据。&lt;/p&gt;

&lt;h5&gt;数据通信概念图&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;https://img10.360buyimg.com/imagetools/jfs/t1/184925/3/16087/341849/60ff7961E60a18039/19286bc0f8b7c6b6.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;框架对比&lt;/h2&gt;

&lt;p&gt;为了更直观的感受Micro App和其它框架的区别，我们使用一张图进行对比。
&lt;img src=&quot;https://img10.360buyimg.com/imagetools/jfs/t1/180537/18/16060/254407/60ff795fE5932d7c0/01a7cf1a43b45658.png&quot; alt=&quot;image&quot;/&gt;
从对比图可以看出，目前开源的微前端框架中有的功能 MicroApp都有，并提供了一些它们不具备的功能，比如静态资源地址补全，元素隔离，插件系统等。&lt;/p&gt;

&lt;h2&gt;业务实践&lt;/h2&gt;

&lt;p&gt;MicroApp已经在公司内部多个项目中使用，表现良好，尤其是将一些老项目改造成微前端，在项目不受影响的情况下，即降低接入成本，又可以保证项目平稳运行，减小耦合。&lt;/p&gt;

&lt;h2&gt;为什么开源？&lt;/h2&gt;

&lt;p&gt;当初我们团队打算使用微前端时，调研了市面上实现微前端的框架，可供选择的只有sigle-spa和qiankun。single-spa太过于基础，对原有项目的改造过多，成本太高。剩下的只有qiankun，但因为接入很多老项目，在实际使用中出了很多问题，我们不得不对qiankun的源码进行大量的魔改。在此过程中，我们对微前端的实现方式产生了一些自己的想法，并将这些想法付诸实践，于是有了MicroApp。&lt;/p&gt;

&lt;p&gt;目前像qiankun类似提供完善功能的微前端框架太少了，当接入qiankun失败时，没有其他方案可供选择，这是我们当初经历过的痛。所以我们选择将MicroApp开源，一是因为MicroApp有诸多创新点，可以更简单的接入微前端，功能更加丰富，二是可以让大家多一种选择，没有完美的微前端框架，只有选择多了，才知道哪一个更适合自己。&lt;/p&gt;

&lt;p&gt;如果你对这个项目感兴趣，可以通过加入组织或提pull requests的方式参与共建，非常欢迎与期待你的加入。&lt;/p&gt;

&lt;h2&gt;导航&lt;/h2&gt;

&lt;p&gt;GitHub地址：&lt;a href=&quot;https://github.com/micro-zoe/micro-app&quot;&gt;https://github.com/micro-zoe/micro-app&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;官网地址：&lt;a href=&quot;https://cangdu.org/micro-app&quot;&gt;https://cangdu.org/micro-app&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;特别鸣谢：&lt;a href=&quot;https://qiankun.umijs.org/zh&quot;&gt;qiankun&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8e7dc52701f811815f6ea89c2b0abf47</guid>
<title>脚本获取 TLS/SSL 证书失效日期</title>
<link>https://toutiao.io/k/m7t6q4i</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post&quot;&gt;
&lt;h1 class=&quot;title&quot;&gt;脚本获取TLS/SSL证书失效日期&lt;/h1&gt;
&lt;p&gt;
从 &lt;a href=&quot;https://www.cyberciti.biz/faq/find-check-tls-ssl-certificate-expiry-date-from-linux-unix/&quot;&gt;https://www.cyberciti.biz/faq/find-check-tls-ssl-certificate-expiry-date-from-linux-unix/&lt;/a&gt; 上看到的使用小脚本，记录一下
&lt;/p&gt;

&lt;p&gt;
在 Web 服务器上可以通过 TLS/SSL 来对服务器和浏览器之间的连接进行加密，TLS/SSL 使用 X509 证书来进行加密，当证书失效后浏览器访问该 Web 服务器就会出现错误提示。
通过下面这个脚本能够获取 TLS/SSL 证书的生效日期和失效日期
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-shell&quot;&gt;&lt;span class=&quot;org-keyword&quot;&gt;exec&lt;/span&gt; 2&amp;gt;/dev/null
openssl s_client -servername ${&lt;span class=&quot;org-variable-name&quot;&gt;SERVER_NAME&lt;/span&gt;} -connect ${&lt;span class=&quot;org-variable-name&quot;&gt;SERVER_NAME&lt;/span&gt;}:${&lt;span class=&quot;org-variable-name&quot;&gt;PORT&lt;/span&gt;} | openssl x509 -noout -dates
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-org&quot;&gt;notBefore=Jul  1 01:16:03 2021 GMT
notAfter=Aug  2 01:16:03 2022 GMT
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
openssl 是一款非常好用的 TLS/SSL 诊断工具，这里用到了以下参数：
&lt;/p&gt;

&lt;dl class=&quot;org-dl&quot;&gt;
&lt;dt&gt;s_client&lt;/dt&gt;&lt;dd&gt;将 openssl 作为 TLS/SSL 客户端工具使用&lt;/dd&gt;
&lt;dt&gt;-servername ${SERVER_NAME}&lt;/dt&gt;&lt;dd&gt;设置 TLS 的 SNI(Server Name Indication)扩展，该字段用来解决一个服务器拥有多个域名的情况&lt;/dd&gt;
&lt;dt&gt;-connect \({SERVER_NAME}:\){PORT}&lt;/dt&gt;&lt;dd&gt;指定要连接的TLS/SSL服务器的地址与端口&lt;/dd&gt;
&lt;dt&gt;x509&lt;/dt&gt;&lt;dd&gt;X509证书数据解析工具&lt;/dd&gt;
&lt;dt&gt;-noout&lt;/dt&gt;&lt;dd&gt;不显示证书内容，只显示证书的状态&lt;/dd&gt;
&lt;dt&gt;-dates&lt;/dt&gt;&lt;dd&gt;输出 TLS/SSL 证书的生效日期与实效日期&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;
我们还可以使用 &lt;code&gt;openssl x509&lt;/code&gt; 直接解析 PEM格式的证书文件：
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-shell&quot;&gt;openssl x509 -noout -dates ${&lt;span class=&quot;org-variable-name&quot;&gt;PEM_FILE_PATH&lt;/span&gt;}
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
我们甚至可以直接检查证书是否会在多少秒后失效，从而达到预警的效果：
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-shell&quot;&gt;&lt;span class=&quot;org-keyword&quot;&gt;exec&lt;/span&gt; 2&amp;gt;/dev/null
openssl s_client -servername ${&lt;span class=&quot;org-variable-name&quot;&gt;SERVER_NAME&lt;/span&gt;} -connect ${&lt;span class=&quot;org-variable-name&quot;&gt;SERVER_NAME&lt;/span&gt;}:${&lt;span class=&quot;org-variable-name&quot;&gt;PORT&lt;/span&gt;} | openssl x509 -noout -checkend $((365*24*3600))
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-org&quot;&gt;Certificate will not expire
&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>