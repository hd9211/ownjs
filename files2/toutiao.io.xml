<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ad5745381a9c1b7947750066369392e2</guid>
<title>困在内卷里的工程师 | 码农周刊第 322 期</title>
<link>https://toutiao.io/k/mb7u8g0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;困在内卷里的工程师 | 码农周刊第 322 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第322期（2020-10-21）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=322&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3220&quot; target=&quot;_blank&quot;&gt;薪资翻番如何实现？程序员的涨薪秘诀&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=322&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3220&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_321.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=322&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;实战经验&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;功能强大、配置简单、完全开源。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;第三代 AI 发展的思路是把第一代的知识驱动和第二代的数据驱动结合起来，通过利用知识、数据、算法和算力等 4 个要素，构造更强大的 AI……&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;斯坦福教授、Tcl 语言发明者 John Ousterhout 的著作《A Philosophy of Software Design》，自出版以来，好评如潮。&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;实战经验&lt;/p&gt;
        
        &lt;p&gt;适合新手&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;实用&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;一步步教你&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 448635 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 429587 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 412364 即可&lt;/p&gt;
        
        &lt;p&gt;编程、成长、正能量！&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 381811 即可&lt;/p&gt;
        
        &lt;p&gt;分享Go语言相关内容&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 133906 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=322&amp;amp;aid=20030&amp;amp;url=https%3A%2F%2Fitem.jd.com%2F12972072.html&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/book_322.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;欢迎讨论&lt;/p&gt;
        
        &lt;p&gt;部分适用于百度&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4853a6347779970041aa54b514fb1018</guid>
<title>RTE 2020 实时互联网大会参会指南——今天我们线上见！</title>
<link>https://toutiao.io/k/bd86jqe</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;声网Agora&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;shengwang-agora&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;声网Agora成立于2013年，是全球实时互动云行业开创者。声网Agora为开发者提供简单易用、高度可定制和广泛兼容的API。开发者无需研发或构建底层基础设施，只需调用API即可在应用内构建多种实时音视频互动场景。&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0b58f0d90a09708521367211bef07ce9</guid>
<title>深入了解 ActiveMQ</title>
<link>https://toutiao.io/k/19sjvs1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;认识MQ(Message Queue)&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;什么是消息队列&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.3995037220843674&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jN40XA8Jt3ZMYrDNxocPIFkRtllxDaIBu6RmwOicC1d5ImmKKYJolYPeeropAuYoTrpDQgYSZJAvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;403&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;消息队列&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们先从以下几个维度来认识一下消息队列：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;消息队列：一般我们会简称它为MQ(MessageQueue)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息(Message):传输的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;队列(Queue):队列是一种先进先出的数据结构。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息队列从字面的含义来看就是一个存放消息的容器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息队列可以简单理解为：把要传输的数据放在队列中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;把数据放到消息队列叫做生产者。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从消息队列里边取数据叫做消费者。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;为什么需要消息队列&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用消息队列主要是基于以下三个主要场景：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们分场景来描述下使用消息队列带来的好处&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;解耦&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们有一个用户系统A，用户系统A可以产生一个userId。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，现在有系统B和系统C都需要这个userId去做相关的操作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5014577259475219&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jN40XA8Jt3ZMYrDNxocPIFDGPMrw8725NZOVdLIfLJaomsFfUhwAZBF2uffyIlE0Q5TJatLmjOqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1029&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;解耦前架构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;伪码大致如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java&lt;br/&gt;public class SystemA {&lt;br/&gt;    // 系统B和系统C的依赖&lt;br/&gt;    SystemB systemB = new SystemB();&lt;br/&gt;    SystemC systemC = new SystemC();&lt;br/&gt;    // 系统A独有的数据userId&lt;br/&gt;    private String userId = &lt;span&gt;&quot;activeMq-1234567890&quot;&lt;/span&gt;;&lt;br/&gt;    public void &lt;span&gt;&lt;span&gt;doSomething&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        // 系统B和系统C都需要拿着系统A的userId去操作其他的事&lt;br/&gt;        systemB.SystemBNeed2do(userId);&lt;br/&gt;        systemC.SystemCNeed2do(userId);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「这样类似的业务场景大家是不是很熟悉，大家是不是这样写很合情合理，也很简单。」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;某一天，系统B的负责人告诉系统A的负责人，现在系统B的SystemBNeed2do(String userId)这个接口不再使用了，让系统A别去调它了。&lt;br/&gt;于是，系统A的负责人说&quot;好的，那我就不调用你了。&quot;，于是就把调用系统B接口的代码给删掉了。代码变成这样了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java&lt;br/&gt;public void &lt;span&gt;&lt;span&gt;doSomething&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;  // 系统A不再调用系统B的接口了&lt;br/&gt;  //systemB.SystemBNeed2do(userId);&lt;br/&gt;  systemC.SystemCNeed2do(userId);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于业务需要，系统D说也需要用到系统A的userId，于是代码改成了这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java&lt;br/&gt;public void &lt;span&gt;&lt;span&gt;doSomething&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        // 已经不再需要系统B的依赖了&lt;br/&gt;        //systemB.SystemBNeed2do(userId);&lt;br/&gt;        // 系统C和系统D都需要拿着系统A的userId去操作其他的事&lt;br/&gt;        systemC.SystemCNeed2do(userId);&lt;br/&gt;        systemD.SystemDNeed2do(userId);&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当前系统A、B、C、D系统的交互是这样子的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7065592635212888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jN40XA8Jt3ZMYrDNxocPIF868vlZMtLYs9Vwu8SeZOEPeCrWVibHj3LgfVvjkHg3x4P66uzjc6Vew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;869&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;系统交互&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着业务需求的变化，代码也要一遍一遍的修改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还会存在另外一个问题，调用系统C的时候，如果系统C挂了，系统A还要想办法处理。如果调用系统D时，由于网络延迟，请求超时了，那系统A是反馈fail还是重试？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么怎么去解决这样的现状呢，如何从频繁的修改代码中解脱呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候我们就引入一层消息队列中间件，交互图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5274480712166172&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jN40XA8Jt3ZMYrDNxocPIFUicMG6CURWNLzgXGk5rSGhlGYypagvVGzHfLk2XjjL0JU2wL9YCjSBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1348&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;解耦&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将系统A产生的userId写到消息队列中，系统C和系统D从消息队列中拿数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样有什么好处？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;系统A只负责把数据写到队列中，谁想要或不想要这个数据(消息)，系统A一点都不关心。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;即便现在系统D不想要userId这个数据了，系统B又突然想要userId这个数据了，都跟系统A无关，系统A一点代码都不用改。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统D拿userId不再经过系统A，而是从消息队列里边拿。系统D即便挂了或者请求超时，都跟系统A无关，&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只跟消息队列有关。这样一来，系统A与系统B、C、D都解耦了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;异步&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;系统A做的是主要的业务，而系统B、C、D是非主要的业务。比如系统A处理的是订单下单，而系统B是订单下单成功了，那发送一条短信告诉具体的用户此订单已成功，而系统C和系统D也是处理一些小事而已。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么此时，为了提高用户体验和吞吐量，其实可以异步地调用系统B、C、D的接口。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5387840670859538&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jN40XA8Jt3ZMYrDNxocPIFFKCbZaff0Gt6FMKLeUtpiaffPRp6f1Heoy40O5ic6lrf6Jf7cJKKVOxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;954&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;异步&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;削峰/限流&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来一个场景，现在我们每个月要搞一次大促，大促期间的并发可能会很高的，比如每秒3000个请求。假设我们现在有两台机器处理请求，并且每台机器只能每次处理1000个请求。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7297297297297297&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jN40XA8Jt3ZMYrDNxocPIFoGhm3p1ceAodzKEushicNWsUB5631A0K2bq3ibCqudWzltVENSKy37cA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;703&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;削峰前&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;系统B和系统C根据自己的能够处理的请求数去消息队列中拿数据，这样即便有每秒有8000个请求，那只是把请求放在消息队列中，去拿消息队列的消息由系统自己去控制，这样就不会把整个系统给搞崩。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6457800511508951&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jN40XA8Jt3ZMYrDNxocPIF5HvaKZbg7jLniagq9ElRiaicnNb8jrPGwJ4mdlXibYdEawRbxEMvTBl6mQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;782&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;削峰/限流&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是JMS MQ&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;全称：Java MessageService 中文：Java 消息服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JMS 是 Java 的一套 API 标准，最初的目的是为了使应用程序能够访问现有的MOM 系 统（MOM 是 MessageOriented Middleware 的英文缩写，指的是利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。） 后来被许多现有的 MOM 供应商采用，并实现为MOM 系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见 MOM 系统包括 Apache的 ActiveMQ、阿里巴巴的 RocketMQ、IBM 的 MQSeries、Microsoft
的 MSMQ、BEA 的 RabbitMQ 等。（并非全部的 MOM 系统都遵循JMS 规范）】&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于 JMS 实现的 MOM，又被称为JMSProvider。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;JMS中的一些概念&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「Broker」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息服务器，作为server提供消息核心服务&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「Provider 生产者」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息生产者是由会话创建的一个对象，用于把消息发动到一个目的地&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「Consumer 消费者」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息消费者是由会话创建的一个对象，它用于接收发送到目的地的消息。消息的消费可以采用以下两种方法：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同步消费。通过调用消费者的receive方法从目的地中显式提取消息。receive方法可以一直阻塞到消息到达。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步消费。客户可以为消费者注册一个消息监听器，以定义在消息到达时所采取的动作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「P2P 点对点消息模型」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息生产者生产消息发送到queue 中，然后消息消费者从queue 中取出并且消费消息。消息被消费以后，queue 中不再有存储，所以消息消费者不可能消费到已经被消费的消息。Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费、其它的则不能消费此消息了。当消费者不存在时，消息会一直保存，直到有消费消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「Pub/Sub 发布订阅消息模型」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息生产者（发布）将消息发布到topic 中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到 topic 的消息会被所有订阅者消费。当生产者发布消息，不管是否有消费者。都不会保存消息一定要先有消息的消费者，后有消息的生产者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「P2P vs Pub/Sub」&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5631911532385466&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jN40XA8Jt3ZMYrDNxocPIFlcZPziaQyuSQYTm4NUhlFms3icKtVKyNGrOgpxZXOQsnoA2zLcoZSEfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1266&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;P2P vs Pub/Sub&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「Queue」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;队列存储，常用于点对点消息模型&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认只能由唯一的一个消费者处理。一旦处理消息删除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「Topic」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主题存储，用于订阅/发布消息模型&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主题中的消息，会发送给所有的消费者同时处理。只有在消息可以重复处理的业务场景中可使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「ConnectionFactory」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;连接工厂，jms中用它创建连接&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;连接工厂是客户用来创建连接的对象，例如ActiveMQ提供的ActiveMQConnectionFactory。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「Connection」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JMS Connection封装了客户与JMS提供者之间的一个虚拟的连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「Destination 消息的目的地」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目的地是客户用来指定它生产的消息的目标和它消费的消息的来源的对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;订阅一个主题的消费者只能消费自它订阅之后发布的消息。JMS规范允许客户创建持久订阅，这在一定程度上放松了时间上的相关性要求。持久订阅允许消费者消费它在未处于激活状态时发送的消息。在点对点消息传递域中，目的地被成为队列（queue）；在发布/订阅消息传递域中，目的地被成为主题（topic）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「Session」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JMS Session是生产和消费消息的一个单线程上下文。会话用于创建消息生产者（producer）、消息消费者（consumer）和消息（message）等。会话提供了一个事务性的上下文，在这个上下文中，一组发送和接收被组合到了一个原子操作中。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;消息可靠性机制&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「确认 JMS消息」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有在被确认之后，才认为已经被成功地消费了。消息的成功消费通常包含三个阶段：客户接收消息、客户处理消息和消息被确认。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在事务性会话中，当一个事务被提交的时候，确认自动发生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在非事务性会话中，消息何时被确认取决于创建会话时的应答模式（acknowledgement mode）。该参数有以下三个可选值：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「Session.AUTO_ACKNOWLEDGE」&lt;/strong&gt;。当客户成功的从receive方法返回的时候，或者从MessageListener.onMessage方法成功返回的时候，会话自动确认客户收到的消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「Session.CLIENT_ACKNOWLEDGE」&lt;/strong&gt;。客户通过消息的acknowledge方法确认消息。需要注意的是，在这种模式中，确认是在会话层上进行：确认一个被消费的消息将自动确认所有已被会话消费的消息。例如，如果一个消息消费者消费了10个消息，然后确认第5个消息，那么所有10个消息都被确认。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「Session.DUPS_ACKNOWLEDGE」&lt;/strong&gt;。该选择只是会话迟钝的确认消息的提交。如果JMS Provider失败，那么可能会导致一些重复的消息。如果是重复的消息，那么JMS Provider必须把消息头的JMSRedelivered字段设置为true。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「持久性」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JMS 支持以下两种消息提交模式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「PERSISTENT」&lt;/strong&gt;。指示JMSProvider持久保存消息，以保证消息不会因为JMS Provider的失败而丢失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「NON_PERSISTENT」&lt;/strong&gt;。不要求JMS Provider持久保存消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「优先级」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用消息优先级来指示JMS Provider首先提交紧急的消息。优先级分10个级别，从0（最低）到9（最高）。如果不指定优先级，默认级别是4。&lt;strong&gt;「需要注意的是，JMSProvider并不一定保证按照优先级的顺序提交消息。」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「消息过期」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以设置消息在一定时间后过期，默认是永不过期&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「临时目的地」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过会话上的createTemporaryQueue方法和createTemporaryTopic方法来创建临时目的地。它们的存在时间只限于创建它们的连接所保持的时间。只有创建该临时目的地的连接上的消息消费者才能够从临时目的地中提取消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「持久订阅」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先消息生产者必须使用PERSISTENT提交消息。客户可以通过会话上的createDurableSubscriber方法来创建一个持久订阅，该方法的第一个参数必须是一个topic，第二个参数是订阅的名称。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JMS Provider会存储发布到持久订阅对应的topic上的消息。如果最初创建持久订阅的客户或者任何其它客户使用相同的连接工厂和连接的客户ID、相同的主题和相同的订阅名再次调用会话上的createDurableSubscriber方法，那么该持久订阅就会被激活。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JMS Provider会向客户发送客户处于非激活状态时所发布的消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;持久订阅在某个时刻只能有一个激活的订阅者。持久订阅在创建之后会一直保留，直到应用程序调用会话上的unsubscribe方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「本地事务」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在一个JMS客户端，可以使用本地事务来组合消息的发送和接收。JMS Session接口提供了commit和rollback方法。事务提交意味着生产的所有消息被发送，消费的所有消息被确认；事务回滚意味着生产的所有消息被销毁，消费的所有消息被恢复并重新提交，除非它们已经过期。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务性的会话总是牵涉到事务处理中，commit或rollback方法一旦被调用，一个事务就结束了，而另一个事务被开始。关闭事务性会话将回滚其中的事务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，如果使用请求/回复机制，即发送一个消息，同时希望在同一个事务中等待接收该消息的回复，那么程序将被挂起，因为知道事务提交，发送操作才会真正执行。需要注意的还有一个，消息的生产和消费不能包含在同一个事务中。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ActiveMQ&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;存储&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ActiveMQ支持很多种存储方式，常见的有 KahaDB存储，AMQ存储，JDBC存储，LevelDB存储，Memory
消息存储。我们重点介绍一下KahaDB和JDBC存储方式。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;KahaDB存储&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;KahaDB是默认的持久化策略，所有消息顺序添加到一个日志文件中，同时另外有一个索引文件记录指向这些日志的存储地址，还有一个事务日志用于消息回复操作。是一个专门针对消息持久化的解决方案,它对典型的消息使用模式进行了优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在data/kahadb这个目录下，会生成四个文件，来完成消息持久化 db.data 它是消息的索引文件，本质上是B-Tree（B树），使用B-Tree作为索引指向db-*.log里面存储的消息 db.redo 用来进行消息恢复 *db-.log 存储消息内容。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.19768934531450577&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jN40XA8Jt3ZMYrDNxocPIFMpzRUmBPcsxs4tia4km3bDHCTZ9aMVkks4w4DwP515o3IjjnAACZOdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;779&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;kahadb文件结构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新的数据以APPEND的方式追加到日志文件末尾。属于顺序写入，因此消息存储是比较 快的。默认是32M，达到阀值会自动递增 lock文件 锁，写入当前获得kahadb读写权限的broker ，用于在集群环境下的竞争处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;KahaDB有如下几个特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;日志形式存储消息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息索引以 B-Tree 结构存储，可以快速更新；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;完全支持 JMS 事务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持多种恢复机制kahadb 可以限制每个数据文件的大小。不代表总计数据容量。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置方式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;persistenceAdapter&amp;gt;&lt;br/&gt;    &amp;lt;kahaDB directory=&lt;span&gt;&quot;${activemq.data}/kahadb&quot;&lt;/span&gt;/&amp;gt;&lt;br/&gt;&amp;lt;/persistenceAdapter&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;JDBC 存储&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;支持通过 JDBC 将消息存储到关系数据库，性能上不如文件存储，能通过关系型数据库查询到消息的信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MQ 支持的数据库：Apache Derby、MySQL、PostgreSQL、Oracle、SQLServer、Sybase、Informix、MaxDB。使用JDBC存储需要用到下面三张数据表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「activemq_acks」&lt;/strong&gt;：用于存储订阅关系。如果是持久化Topic，订阅者和服务器的订阅关系在这个表保存。主要的数据库字段如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;container：消息的destination&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sub_dest：如果是使用static集群，这个字段会有集群其他系统的信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;client_id：每个订阅者都必须有一个唯一的客户端id用以区分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sub_name：订阅者名称&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;selector：选择器，可以选择只消费满足条件的消息。条件可以用自定义属性实现，可支持多属性and和or操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;last_acked_id：记录消费过的消息的id。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「activemq_lock」&lt;/strong&gt;：在集群环境中才有用，只有一个Broker可以获得消息，称为Master Broker，其他的只能作为备份等待Master Broker不可用，才可能成为下一个Master Broker。这个表用于记录哪个Broker是当前的Master Broker。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「activemq_msgs」&lt;/strong&gt;：用于存储消息，Queue和Topic都存储在这个表中。主要的数据库字段如下&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;id：自增的数据库主键&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;container：消息的destination&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;msgid_prod：消息发送者客户端的主键&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;msg_seq：是发送消息的顺序，msgid_prod+msg_seq可以组成jms的messageid&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;expiration：消息的过期时间，存储的是从1970-01-01到现在的毫秒数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;msg：消息本体的java序列化对象的二进制数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;priority：优先级，从0-9，数值越大优先级越高&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;xid:topic&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置方式如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;配置数据源 conf/acticvemq.xml 文件：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;bean id=&lt;span&gt;&quot;mysql-ds&quot;&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;&quot;org.apache.commons.dbcp.BasicDataSource&quot;&lt;/span&gt; destroy-method=&lt;span&gt;&quot;close&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;   &amp;lt;property name=&lt;span&gt;&quot;driverClassName&quot;&lt;/span&gt; value=&lt;span&gt;&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt;/&amp;gt;&lt;br/&gt;   &amp;lt;property name=&lt;span&gt;&quot;url&quot;&lt;/span&gt; value=&lt;span&gt;&quot;jdbc:mysql://localhost:3306/activemq?relaxAutoCommit=true&quot;&lt;/span&gt;/&amp;gt;&lt;br/&gt;   &amp;lt;property name=&lt;span&gt;&quot;username&quot;&lt;/span&gt; value=&lt;span&gt;&quot;root&quot;&lt;/span&gt;/&amp;gt;&lt;br/&gt;   &amp;lt;property name=&lt;span&gt;&quot;password&quot;&lt;/span&gt; value=&lt;span&gt;&quot;111111&quot;&lt;/span&gt;/&amp;gt;&lt;br/&gt;   &amp;lt;property name=&lt;span&gt;&quot;maxActive&quot;&lt;/span&gt; value=&lt;span&gt;&quot;200&quot;&lt;/span&gt;/&amp;gt;&lt;br/&gt;   &amp;lt;property name=&lt;span&gt;&quot;poolPreparedStatements&quot;&lt;/span&gt; value=&lt;span&gt;&quot;true&quot;&lt;/span&gt;/&amp;gt;&lt;br/&gt;&amp;lt;/bean&amp;gt;   &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;配置 broke 中的 persistenceAdapter
dataSource 指定持久化数据库的 bean，createTablesOnStartup 是否在启动的时候创建数据表，默认值是 true，这样每次启动都会去创建数据表了，一般是第一次启动的时候设置为 true，之后改成 false。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;persistenceAdapter&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;jdbcPersistenceAdapter&lt;/span&gt; &lt;span&gt;dataSource&lt;/span&gt;=&lt;span&gt;&quot;#mysql-ds&quot;&lt;/span&gt;  &lt;span&gt;createTablesOnStartup&lt;/span&gt;=&lt;span&gt;&quot;false&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;persistenceAdapter&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;协议&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ActiveMQ支持的client-broker通讯协议有：TCP、NIO、UDP、SSL、Http(s)、VM。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Transmission Control Protocol (TCP)&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是默认的Broker配置，TCP的Client监听端口是61616。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在网络传输数据前，必须要序列化数据，消息是通过一个叫wire protocol的来序列化成字节流。默认情况下，ActiveMQ把wire protocol叫做OpenWire，它的目的是促使网络上的效率和数据快速交互。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP连接的URI形式：&lt;code&gt;tcp://hostname:port?key=value&amp;amp;key=value&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP传输的优点：(1)TCP协议传输可靠性高，稳定性强 (2)高效性：字节流方式传递，效率很高 (3)有效性、可用性：应用广泛，支持任何平台&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;New I/O API Protocol（NIO）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NIO协议和TCP协议类似，但NIO更侧重于底层的访问操作。它允许开发人员对同一资源可有更多的client调用和服务端有更多的负载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;适合使用NIO协议的场景：(1)可能有大量的Client去链接到Broker上一般情况下，大量的Client去链接Broker是被操作系统的线程数所限制的。因此，NIO的实现比TCP需要更少的线程去运行，所以建议使用NIO协议
(2)可能对于Broker有一个很迟钝的网络传输NIO比TCP提供更好的性能&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NIO连接的URI形式：&lt;code&gt;nio://hostname:port?key=value&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Transport Connector配置示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;transportConnectors&amp;gt;&lt;br/&gt;  &amp;lt;transportConnector&lt;br/&gt;    name=&lt;span&gt;&quot;nio&quot;&lt;/span&gt;&lt;br/&gt;    uri=&lt;span&gt;&quot;nio://localhost:61618?trace=true&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;&amp;lt;/transportConnectors&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;User Datagram Protocol（UDP)&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;UDP和TCP的区别
(1)TCP是一个原始流的传递协议，意味着数据包是有保证的，换句话说，数据包是不会被复制和丢失的。UDP，另一方面，它是不会保证数据包的传递的
(2)TCP也是一个稳定可靠的数据包传递协议，意味着数据在传递的过程中不会被丢失。这样确保了在发送和接收之间能够可靠的传递。相反，UDP仅仅是一个链接协议，所以它没有可靠性之说&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面可以得出：TCP是被用在稳定可靠的场景中使用的；UDP通常用在快速数据传递和不怕数据丢失的场景中，还有ActiveMQ通过防火墙时，只能用UDP&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;UDP连接的URI形式：&lt;code&gt;udp://hostname:port?key=value&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Transport Connector配置示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;transportConnectors&amp;gt;&lt;br/&gt;    &amp;lt;transportConnector&lt;br/&gt;        name=&lt;span&gt;&quot;udp&quot;&lt;/span&gt;&lt;br/&gt;        uri=&lt;span&gt;&quot;udp://localhost:61618?trace=true&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;&amp;lt;/transportConnectors&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Active MQ的安全机制&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「web控制台安全」&lt;/strong&gt;&lt;br/&gt;修改jetty-realm.properties&lt;br/&gt;&lt;code&gt;# username: password [,rolename ...]（用户名：密码 角色）&lt;/code&gt;&lt;br/&gt;注意：配置需重启ActiveMQ才会生效&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「消息安全机制」&lt;/strong&gt;&lt;br/&gt;修改activemq.xml 在中添加如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;simpleAuthenticationPlugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&amp;lt;&lt;span&gt;users&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;&amp;lt;&lt;span&gt;authenticationUser&lt;/span&gt; &lt;span&gt;username&lt;/span&gt;=&lt;span&gt;&quot;admin&quot;&lt;/span&gt; &lt;span&gt;password&lt;/span&gt;=&lt;span&gt;&quot;admin&quot;&lt;/span&gt; &lt;span&gt;groups&lt;/span&gt;=&lt;span&gt;&quot;admins,publishers,consumers&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;&amp;lt;&lt;span&gt;authenticationUser&lt;/span&gt; &lt;span&gt;username&lt;/span&gt;=&lt;span&gt;&quot;publisher&quot;&lt;/span&gt; &lt;span&gt;password&lt;/span&gt;=&lt;span&gt;&quot;publisher&quot;&lt;/span&gt;  &lt;span&gt;groups&lt;/span&gt;=&lt;span&gt;&quot;publishers,consumers&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;&amp;lt;&lt;span&gt;authenticationUser&lt;/span&gt; &lt;span&gt;username&lt;/span&gt;=&lt;span&gt;&quot;consumer&quot;&lt;/span&gt; &lt;span&gt;password&lt;/span&gt;=&lt;span&gt;&quot;consumer&quot;&lt;/span&gt; &lt;span&gt;groups&lt;/span&gt;=&lt;span&gt;&quot;consumers&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;&amp;lt;&lt;span&gt;authenticationUser&lt;/span&gt; &lt;span&gt;username&lt;/span&gt;=&lt;span&gt;&quot;guest&quot;&lt;/span&gt; &lt;span&gt;password&lt;/span&gt;=&lt;span&gt;&quot;guest&quot;&lt;/span&gt;  &lt;span&gt;groups&lt;/span&gt;=&lt;span&gt;&quot;guests&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&amp;lt;/&lt;span&gt;users&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;simpleAuthenticationPlugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;/&lt;span&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ActiveMQ 使用&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java中使用ActiveMQ只需要引入相关依赖&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.activemq&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;activemq-all&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;5.15.11&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编写生产者&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Sender&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; JMSException &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;// 1. 建立工厂对象，&lt;/span&gt;&lt;br/&gt; ActiveMQConnectionFactory acf = &lt;span&gt;new&lt;/span&gt; ActiveMQConnectionFactory(ActiveMQConnectionFactory.DEFAULT_USER,ActiveMQConnectionFactory.DEFAULT_PASSWORD,&lt;span&gt;&quot;tcp://localhost:61618&quot;&lt;/span&gt;);&lt;br/&gt; &lt;span&gt;//2 从工厂里拿一个连接&lt;/span&gt;&lt;br/&gt; Connection connection = acf.createConnection();&lt;br/&gt; connection.start();&lt;br/&gt; &lt;span&gt;//3 从连接中获取Session(会话)&lt;/span&gt;&lt;br/&gt; Session session = connection.createSession(&lt;span&gt;false&lt;/span&gt;, Session.AUTO_ACKNOWLEDGE);&lt;br/&gt; &lt;span&gt;//4 从会话中获取目的地(Destination)消费者会从这个目的地取消息&lt;/span&gt;&lt;br/&gt; Queue queue = session.createQueue(&lt;span&gt;&quot;mq.test&quot;&lt;/span&gt;);&lt;br/&gt; &lt;span&gt;//5 从会话中创建消息提供者&lt;/span&gt;&lt;br/&gt; MessageProducer producer = session.createProducer(queue);&lt;br/&gt; &lt;span&gt;//6 从会话中创建文本消息(也可以创建其它类型的消息体)&lt;/span&gt;&lt;br/&gt; TextMessage message = session.createTextMessage(&lt;span&gt;&quot;msg: hello world&quot;&lt;/span&gt;);&lt;br/&gt; &lt;span&gt;//7 通过消息提供者发送消息到ActiveMQ&lt;/span&gt;&lt;br/&gt; producer.send(message);&lt;br/&gt; &lt;span&gt;//8 关闭连接&lt;/span&gt;&lt;br/&gt; connection.close();&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编写消费者&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Receiver&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; JMSException &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;// 1. 建立工厂对象，&lt;/span&gt;&lt;br/&gt; ActiveMQConnectionFactory acf = &lt;span&gt;new&lt;/span&gt; ActiveMQConnectionFactory(ActiveMQConnectionFactory.DEFAULT_USER,ActiveMQConnectionFactory.DEFAULT_PASSWORD,&lt;span&gt;&quot;tcp://localhost:61618&quot;&lt;/span&gt;);&lt;br/&gt; &lt;span&gt;//2 从工厂里拿一个连接&lt;/span&gt;&lt;br/&gt; Connection connection = acf.createConnection();&lt;br/&gt; connection.start();&lt;br/&gt; &lt;span&gt;//3 从连接中获取Session(会话)&lt;/span&gt;&lt;br/&gt; Session session = connection.createSession(&lt;span&gt;false&lt;/span&gt;, Session.AUTO_ACKNOWLEDGE);&lt;br/&gt; &lt;span&gt;//4 从会话中获取目的地(Destination)消费者会从这个目的地取消息&lt;/span&gt;&lt;br/&gt; Queue queue = session.createQueue(&lt;span&gt;&quot;mq.test&quot;&lt;/span&gt;);&lt;br/&gt; &lt;span&gt;//5 从会话中创建消息消费者&lt;/span&gt;&lt;br/&gt; MessageConsumer consumer = session.createConsumer(queue);&lt;br/&gt; &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;){&lt;br/&gt;  &lt;span&gt;//6 消费者接收消息&lt;/span&gt;&lt;br/&gt;  Message msg = consumer.receive();&lt;br/&gt;  TextMessage textMessage = (TextMessage) msg;&lt;br/&gt;  System.out.println(&lt;span&gt;&quot;text:&quot;&lt;/span&gt;+textMessage.getText());&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;常用API及特性&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;事务消息&lt;br/&gt;&lt;code&gt;Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);&lt;br/&gt;&lt;/code&gt;提交事务：session.commit();&lt;br/&gt;回滚事务：session.rollback();&lt;br/&gt;开启事务后，只有事务commit成功，消息才会发送到MQ中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;持久化&lt;br/&gt;默认持久化是开启的；&lt;br/&gt;开启非持久化示例代码：&lt;br/&gt;&lt;code&gt;producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置消息优先级&lt;br/&gt;&lt;code&gt;producer.setPriority();&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置消息超时/过期时间&lt;br/&gt;&lt;code&gt;producer.setTimeToLive&lt;/code&gt;&lt;br/&gt;设置了消息超时的消息，消费端在超时后无法在消费到此消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;死信&lt;br/&gt;此类消息会进入到ActiveMQ.DLQ队列且不会自动清除，称为死信，有消息堆积的风险。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;签收模式&lt;br/&gt;签收代表接收端的session已收到消息的一次确认，反馈给broker&lt;br/&gt;如果session带有事务，并且事务成功提交，则消息被自动签收。如果事务回滚，则消息会被再次传送。&lt;br/&gt;&lt;br/&gt;消息事务是在生产者producer到broker或broker到consumer过程中同一个session中发生的，保证几条消息在发送过程中的原子性。在支持事务的session中，producer发送message时在message中带有transactionID。broker收到message后判断是否有transactionID，如果有就把message保存在transaction store中，等待commit或者rollback消息。&lt;br/&gt;&lt;br/&gt; ActiveMQ支持自动签收与手动签收&lt;br/&gt;&lt;strong&gt;「Session.AUTO_ACKNOWLEDGE」&lt;/strong&gt;&lt;br/&gt;当客户端从receiver或onMessage成功返回时，Session自动签收客户端的这条消息的收条。&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;「Session.CLIENT_ACKNOWLEDGE」&lt;/strong&gt;&lt;br/&gt;客户端通过调用消息(Message)的acknowledge方法签收消息。在这种情况下，签收发生在Session层面：签收一个已经消费的消息会自动地签收这个Session所有已消费的收条。&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;「Session.DUPS_OK_ACKNOWLEDGE」&lt;/strong&gt;&lt;br/&gt;Session不必确保对传送消息的签收，这个模式可能会引起消息的重复，但是降低了Session的开销，所以只有客户端能容忍重复的消息，才可使用。&lt;br/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;独占消费者&lt;br/&gt;&lt;code&gt;Queue queue = session.createQueue(&quot;xxoo?consumer.exclusive=true&quot;);&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发送异步消息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ActiveMQConnectionFactory connectionFactory = &lt;span&gt;new&lt;/span&gt; ActiveMQConnectionFactory(&lt;br/&gt;    &lt;span&gt;&quot;admin&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;admin&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;tcp://localhost:61616&quot;&lt;/span&gt;&lt;br/&gt;    );&lt;br/&gt;&lt;span&gt;// 2.获取一个向ActiveMQ的连接&lt;/span&gt;&lt;br/&gt;connectionFactory.setUseAsyncSend(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;ActiveMQConnection connection = (ActiveMQConnection)connectionFactory.createConnection();&lt;br/&gt;connection.setUseAsyncSend(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;消息堆积&lt;br/&gt;producer每发送一个消息，统计一下发送的字节数，当字节数达到ProducerWindowSize值时，需要等待broker的确认，才能继续发送。&lt;br/&gt;brokerUrl中设置: &lt;code&gt;tcp://localhost:61616?jms.producerWindowSize=1048576&lt;/code&gt;&lt;br/&gt;destinationUri中设置: &lt;code&gt;myQueue?producer.windowSize=1048576&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;延迟消息投递&lt;br/&gt;首先在配置文件中开启延迟和调度&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;broker&lt;/span&gt; &lt;span&gt;xmlns&lt;/span&gt;=&lt;span&gt;&quot;http://activemq.apache.org/schema/core&quot;&lt;/span&gt; &lt;span&gt;brokerName&lt;/span&gt;=&lt;span&gt;&quot;localhost&quot;&lt;/span&gt; &lt;span&gt;dataDirectory&lt;/span&gt;=&lt;span&gt;&quot;${activemq.data}&quot;&lt;/span&gt; &lt;span&gt;schedulerSupport&lt;/span&gt;=&lt;span&gt;&quot;true&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;延迟发送示例代码：&lt;br/&gt;&lt;code&gt;message.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY,10*1000);&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ActiveMQConnectionFactory acf = &lt;span&gt;new&lt;/span&gt; ActiveMQConnectionFactory(ActiveMQConnectionFactory.DEFAULT_USER,&lt;br/&gt;  ActiveMQConnectionFactory.DEFAULT_PASSWORD,&lt;br/&gt;  &lt;span&gt;&quot;tcp://localhost:61618&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;//2 从工厂里拿一个连接&lt;/span&gt;&lt;br/&gt;Connection connection = acf.createConnection();&lt;br/&gt;connection.start();&lt;br/&gt;&lt;span&gt;//3 从连接中获取Session(会话)&lt;/span&gt;&lt;br/&gt;Session session = connection.createSession(&lt;span&gt;false&lt;/span&gt;, Session.AUTO_ACKNOWLEDGE);&lt;br/&gt;&lt;span&gt;//4 从会话中获取目的地(Destination)消费者会从这个目的地取消息&lt;/span&gt;&lt;br/&gt;Queue queue = session.createQueue(&lt;span&gt;&quot;mq.test&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;//5 从会话中创建消息消费者&lt;/span&gt;&lt;br/&gt;MessageConsumer consumer = session.createConsumer(queue);&lt;br/&gt;MyListener myListener = &lt;span&gt;new&lt;/span&gt; MyListener();&lt;br/&gt;MessageListener listener = myListener::receiveMessage;&lt;br/&gt;consumer.setMessageListener(listener);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;SpringBoot整合ActiveMQ&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;     &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;br/&gt;     &amp;lt;artifactId&amp;gt;spring-boot-starter-activemq&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;server:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  port:&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  activemq:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    broker-url:&lt;/span&gt; &lt;span&gt;tcp://localhost:61618&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    user:&lt;/span&gt; &lt;span&gt;admin&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    password:&lt;/span&gt; &lt;span&gt;admin&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    pool:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      enabled:&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;#连接池最大连接数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      max-connections:&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;#空闲的连接过期时间，默认为30秒&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      idle-timeout:&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    packages:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      trust-all:&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  jms:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    pub-sub-domain:&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@EnableJms&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ActiveMqConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;// topic模式的ListenerContainer&lt;/span&gt;&lt;br/&gt; &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; JmsListenerContainerFactory&amp;lt;?&amp;gt; jmsListenerContainerTopic(ConnectionFactory activeMQConnectionFactory) {&lt;br/&gt;         DefaultJmsListenerContainerFactory bean = &lt;span&gt;new&lt;/span&gt; DefaultJmsListenerContainerFactory();&lt;br/&gt;         bean.setPubSubDomain(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;         bean.setConnectionFactory(activeMQConnectionFactory);&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; bean;&lt;br/&gt;     }&lt;br/&gt;&lt;span&gt;// queue模式的ListenerContainer&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; JmsListenerContainerFactory&amp;lt;?&amp;gt; jmsListenerContainerQueue(ConnectionFactory activeMQConnectionFactory) {&lt;br/&gt;         DefaultJmsListenerContainerFactory bean = &lt;span&gt;new&lt;/span&gt; DefaultJmsListenerContainerFactory();&lt;br/&gt;         bean.setConnectionFactory(activeMQConnectionFactory);&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; bean;&lt;br/&gt;     }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MqProducerService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt; &lt;span&gt;private&lt;/span&gt; JmsMessagingTemplate jmsMessagingTemplate;&lt;br/&gt;  &lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sendStringQueue&lt;/span&gt;&lt;span&gt;(String destination, String msg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  System.out.println(&lt;span&gt;&quot;send...&quot;&lt;/span&gt;);&lt;br/&gt;  ActiveMQQueue queue = &lt;span&gt;new&lt;/span&gt; ActiveMQQueue(destination);&lt;br/&gt;  jmsMessagingTemplate.afterPropertiesSet();&lt;br/&gt;  ConnectionFactory factory = jmsMessagingTemplate.getConnectionFactory();&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;   Connection connection = factory.createConnection();&lt;br/&gt;   connection.start();&lt;br/&gt;&lt;br/&gt;   Session session = connection.createSession(&lt;span&gt;true&lt;/span&gt;, Session.AUTO_ACKNOWLEDGE);&lt;br/&gt;   Queue queue2 = session.createQueue(destination);&lt;br/&gt;&lt;br/&gt;   MessageProducer producer = session.createProducer(queue2);&lt;br/&gt;&lt;br/&gt;   TextMessage message = session.createTextMessage(&lt;span&gt;&quot;hahaha&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;   producer.send(message);&lt;br/&gt;  } &lt;span&gt;catch&lt;/span&gt; (JMSException e) {&lt;br/&gt;   &lt;span&gt;// TODO Auto-generated catch block&lt;/span&gt;&lt;br/&gt;   e.printStackTrace();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  jmsMessagingTemplate.convertAndSend(queue, msg);&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sendStringQueueList&lt;/span&gt;&lt;span&gt;(String destination, String msg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  System.out.println(&lt;span&gt;&quot;xxooq&quot;&lt;/span&gt;);&lt;br/&gt;  ArrayList&amp;lt;String&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;  list.add(&lt;span&gt;&quot;1&quot;&lt;/span&gt;);&lt;br/&gt;  list.add(&lt;span&gt;&quot;2&quot;&lt;/span&gt;);&lt;br/&gt;  jmsMessagingTemplate.convertAndSend(&lt;span&gt;new&lt;/span&gt; ActiveMQQueue(destination), list);&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@JmsListener&lt;/span&gt;(destination = &lt;span&gt;&quot;user&quot;&lt;/span&gt;,containerFactory = &lt;span&gt;&quot;jmsListenerContainerQueue&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;receiveStringQueue&lt;/span&gt;&lt;span&gt;(String msg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;接收到消息....&quot;&lt;/span&gt; + msg);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@JmsListener&lt;/span&gt;(destination = &lt;span&gt;&quot;ooo&quot;&lt;/span&gt;,containerFactory = &lt;span&gt;&quot;jmsListenerContainerTopic&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;receiveStringTopic&lt;/span&gt;&lt;span&gt;(String msg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;     System.out.println(&lt;span&gt;&quot;接收到消息....&quot;&lt;/span&gt; + msg);&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文详细介绍了为什么需要引入消息队列，JMS、ActiveMQ的基础概念以及常用API，与原生JAVA整合及SpringBoot整合等知识点，可以让大家更好的了解ActiveMQ的使用场景及使用方式。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dae06e4ab74938c4f8de61d66f5ccc7b</guid>
<title>LeetCode 之最长回文串</title>
<link>https://toutiao.io/k/377t0oj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;article fmt article-content&quot; data-id=&quot;1190000037544584&quot; data-license=&quot;cc&quot;&gt;
                                                    &lt;h2&gt;序&lt;/h2&gt;&lt;p&gt;本文主要记录一下leetcode之最长回文串&lt;/p&gt;&lt;h2&gt;题目&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。

在构造过程中，请注意区分大小写。比如 &quot;Aa&quot; 不能当做一个回文字符串。

注意:
假设字符串的长度不会超过 1010。

示例 1:

输入:
&quot;abccccdd&quot;

输出:
7

解释:
我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-palindrome
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;题解&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public int longestPalindrome(String s) {
        Map&amp;lt;Character, Integer&amp;gt; countMap = new HashMap&amp;lt;&amp;gt;();
        for (char c : s.toCharArray()) {
            countMap.put(c, countMap.getOrDefault(c, 0) + 1);
        }
        int result = 0;
        for (Integer value : countMap.values()) {
            if (value % 2 == 0) {
                result = result + value;
            } else {
                result = result + value / 2 * 2;
                if (result % 2 == 0) {
                    result++;
                }
            }
        }
        return result;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;小结&lt;/h2&gt;&lt;p&gt;这里先统计一下每个字符的个数，之后对于偶数个直接累加，对于奇数个先累加偶数部分，最后再判断结果是否是偶数，若是偶数则剩余的一个奇数可以算进去。&lt;/p&gt;&lt;h2&gt;doc&lt;/h2&gt;
                                                &lt;/article&gt;

                                                

                                                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0fb2a4fa69157a0faf2c124ebb978343</guid>
<title>部署到 Kubernetes 时初始化 Cassandra 数据库</title>
<link>https://toutiao.io/k/qy3ursk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;当部署 Cassandra 到 Kubernetes 时，一个常见的需求是对数据库进行初始化，包括创建 key space 和表。本文说明了如何使用 helmfile 和 Bitnami Cassandra helm 图表来实现。&lt;/p&gt;&lt;p&gt;在 Kubernetes 上，Cassandra 初始化脚本需要保存在 config map 中。最简单的做法是创建一个新的 helm 图表来管理这些初始化脚本。在使用 &lt;code&gt;helm create db-config&lt;/code&gt; 命令创建出新的图表之后， 删除 &lt;code&gt;templates&lt;/code&gt; 目录中除了 &lt;code&gt;_helpers.tpl&lt;/code&gt; 之外的全部文件，并且添加名为 &lt;code&gt;configmap.yaml&lt;/code&gt; 的新文件。&lt;/p&gt;&lt;p&gt;在下面的 &lt;code&gt;configmap.yaml&lt;/code&gt; 文件中，每个名值对都是一个 Cassandra CQL 文件。这些初始化脚本会按照文件名的字母顺序来依次执行，因此需要在文件名前加上类似 &lt;code&gt;01-&lt;/code&gt; 这样的前缀来保证执行顺序。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;apiVersion&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; v1&lt;br/&gt;&lt;span&gt;kind&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; ConfigMap&lt;br/&gt;&lt;span&gt;metadata&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; init&lt;span&gt;-&lt;/span&gt;db&lt;br/&gt;  &lt;span&gt;labels&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;{&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; include &quot;db&lt;span&gt;-&lt;/span&gt;config.labels&quot; . &lt;span&gt;|&lt;/span&gt; nindent 4 &lt;span&gt;}&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;01-init.cql&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;&lt;span&gt;&lt;br/&gt;    CREATE KEYSPACE IF NOT EXISTS myapp&lt;br/&gt;      WITH REPLICATION = {&lt;br/&gt;        &#x27;class&#x27;: &#x27;SimpleStrategy&#x27;,&lt;br/&gt;        &#x27;replication_factor&#x27; : 1&lt;br/&gt;      };&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    CREATE TABLE IF NOT EXISTS myapp.sample (&lt;br/&gt;        id int&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        value text&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        PRIMARY KEY(id)&lt;br/&gt;      )&lt;br/&gt;      WITH gc_grace_seconds = 0;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面是创建 Cassandra 部署的 &lt;code&gt;helmfile.yaml&lt;/code&gt; 文件。值 &lt;code&gt;initDBConfigMap&lt;/code&gt; 声明了初始化脚本所在的 config map 的名称。 &lt;code&gt;needs&lt;/code&gt; 用来表明 Cassandra 发行依赖于 &lt;code&gt;db-config&lt;/code&gt; 发行。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;repositories&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; bitnami&lt;br/&gt;  &lt;span&gt;url&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; https&lt;span&gt;:&lt;/span&gt;//charts.bitnami.com/bitnami&lt;br/&gt;&lt;br/&gt;&lt;span&gt;releases&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; cassandra&lt;br/&gt;    &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;{&lt;/span&gt; env &quot;NAMESPACE&quot; &lt;span&gt;|&lt;/span&gt; default &quot;myapp&quot; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;chart&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; bitnami/cassandra&lt;br/&gt;    &lt;span&gt;version&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; 6.0.1&lt;br/&gt;    &lt;span&gt;needs&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;{&lt;/span&gt; env &quot;NAMESPACE&quot; &lt;span&gt;|&lt;/span&gt; default &quot;myapp&quot; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;/db&lt;span&gt;-&lt;/span&gt;config&lt;br/&gt;    &lt;span&gt;values&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;cluster&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;seedCount&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;minimumAvailable&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;replicaCount&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;dbUser&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;user&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; cassandra&lt;br/&gt;          &lt;span&gt;password&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; cassandra&lt;br/&gt;        &lt;span&gt;initDBConfigMap&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; init&lt;span&gt;-&lt;/span&gt;db&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; db&lt;span&gt;-&lt;/span&gt;config&lt;br/&gt;    &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;{&lt;/span&gt; env &quot;NAMESPACE&quot; &lt;span&gt;|&lt;/span&gt; default &quot;myapp&quot; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;chart&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; ./charts/db&lt;span&gt;-&lt;/span&gt;config&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当使用 &lt;code&gt;helmfile apply&lt;/code&gt; 命令来应用该 &lt;code&gt;helmfile.yaml&lt;/code&gt; 文件之后，你应该可以在 Kubernetes中看到 Cassandra 的 statefulset，并且数据库已经被初始化。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>