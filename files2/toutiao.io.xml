<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>01adcab2dbf677f6b5b20faa75e94fb4</guid>
<title>怎么排查 CPU 飙升</title>
<link>https://toutiao.io/k/rq3wyhs</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1&gt;&lt;span&gt;怎么排查CPU飙升&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;线上有些系统，本来跑的好好的，突然有一天就会出现报警，CPU使用率飙升，然后重启之后就好了。例如，多线程操作一个线程不安全的list往往就会出现这种现象。那么怎么定位到具体的代码范围呢？今天笔者就教大家一个小技巧&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;&lt;span&gt;代码准备&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;这次，笔者准备了一个demo代码，大致线程模型是这样的:&lt;img data-ratio=&quot;0.44745222929936307&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7ICuYI5fFbIIaXAlQFQ9tVtn0k5kS3CUIY0mEMwqGaAI4CUEyl68pEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1256&quot;/&gt;&lt;/p&gt;&lt;p&gt;代码下所示:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;public class CpuHighExample {&lt;br/&gt;&lt;br/&gt;    public static void &lt;span&gt;&lt;span&gt;cpuHigh&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        final List&amp;lt;String&amp;gt; list = new LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;        Thread thread1 = new Thread(new &lt;span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;            @Override&lt;br/&gt;            public void &lt;span&gt;&lt;span&gt;run&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;                int count = 1;&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;                    // 构造thread1为消耗很高cpu的线程&lt;br/&gt;                    count = count + 1;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        thread1.setName(&lt;span&gt;&quot;thread1&quot;&lt;/span&gt;);&lt;br/&gt;        Thread thread2 = new Thread(new &lt;span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;            @Override&lt;br/&gt;            public void &lt;span&gt;&lt;span&gt;run&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;                    try {&lt;br/&gt;                        // 构造thread2为消耗很低cpu的线程&lt;br/&gt;                        Thread.sleep(1000);&lt;br/&gt;                    } catch (InterruptedException e) {&lt;br/&gt;                        e.printStackTrace();&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        thread2.setName(&lt;span&gt;&quot;thread2&quot;&lt;/span&gt;);&lt;br/&gt;        thread1.start();&lt;br/&gt;        thread2.start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span/&gt;&lt;span&gt;案例运行&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;这个案例一运行，就听见笔者的电脑风扇起飞了，呼呼作响。直接top一下&lt;img data-ratio=&quot;0.27223230490018147&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7FtpGMeoqxWeUe09Hiaupmk6AB12ux7T8RUsiclic762iaQV8zU1u3789rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1102&quot;/&gt;&lt;/p&gt;&lt;p&gt;果然是java进程，占用最高，CPU 100%了(占用了一个核),而其PID是2717，正是我们跑的例子。那么下一步，我们就需要定位到底是那一个线程在耗CPU&lt;/p&gt;&lt;pre&gt;&lt;code&gt;top -H&lt;br/&gt;Threads toggle&lt;br/&gt;            Starts top with the last remembered ’H’ state reversed.  When this&lt;br/&gt;            toggle  is  On,  all individual threads will be displayed.  Other-&lt;br/&gt;            wise, top displays a summation of all threads &lt;span&gt;in&lt;/span&gt; a process.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如man文档所描述,top -H可以打印出线程信息，我们就top -H一下。&lt;img data-ratio=&quot;0.3611111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7gVWF29FYqvsdgCp0SxRbAHsuYlcGib6Ow25t2iaqoZqSaoKFSNEuIQUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;图中可以看到，占用最高的线程PID是2727,同时线程名是thread1。&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;&lt;span&gt;继续jstack&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;我们知道jstack可以dump出jvm所有线程运行的快照，然后我们就可以通过刚才获取的PID去定位到jstack那个进程。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 注意，这边用top出来的进程号2717,而不是top -H出来的2727&lt;br/&gt;jstack 2717 &amp;gt; 1.txt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于jstack打印出的线程号是以16进制的形式表现的，所以我们对2727的线程号做一次转换,得到aa7。&lt;br/&gt;&lt;img data-ratio=&quot;0.3513203214695752&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7Z1MYNZ7AngNmNOmfdOia7SGcP0W6zPLy29iaibDJjZTX1tp2qTJRibCf1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1742&quot;/&gt;&lt;/p&gt;&lt;p&gt;然后我们在1.txt中搜索2727,这里用的是less然后进去后搜索，而不是用grep。因为这样比较直观的能看出之前和之后的信息。less下&lt;img data-ratio=&quot;0.06093189964157706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7k1icZP2z0uBTfeOhUUcV1YGL8dRA0XFNNqUaWTy4WrqN8dJJOK9Q2tg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1116&quot;/&gt;&lt;img data-ratio=&quot;0.27797202797202797&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7qGiaETjUfibeysR1DjicW6Hu1ib8Gbicy0IBD090xFA9eHoLjsd2OFM2UuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1144&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们找到aa7后，就直接能发现代码一直跑在CpuHighExample.java第19行上面。&lt;img data-ratio=&quot;0.35304990757855825&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7icibozct5NMOfl5X1b5Q9pEYfEF1VCKJfstRQLEEr3m4sum5ntxdeozg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1082&quot;/&gt;&lt;/p&gt;&lt;p&gt;当然了，我们需要多jstack几次，如果每次jstack出来都刚好在这段代码左右，那么基本可以证明，是这段代码导致CPU飙升了。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;CPU突然飙升这个问题，我们很容易通过top -H和jstack找到对应的代码范围，这无疑极大的缩小了我们的定位范围。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.359781121751026&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7x75CliawsSwbWnz6VZu2PrSTxAfA1Bl6MN5VdbWG06xzJzllCqZWPBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1462&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ef81b18c0014dd5ec48bc05db1ae0406</guid>
<title>头条终面：写个消息中间件</title>
<link>https://toutiao.io/k/qjxr0pi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;每个时代，都不会亏待会学习的人。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是 yes。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种设计类问题想必大家都不陌生，面试时或多或少都能碰到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如如何写一个线程池？如何写一个 HashMap ？如何写一个 RPC 框架等等，当然这里的写不是真的叫你用代码写出来，只是说说设计理念，整体架构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个面试题来自于一个读者的字节面试经历，我会从面试技巧和消息中间件的设计两个方面阐述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我觉得重点在于面试技巧，因为它通用。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;两种极端的情况&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大多数同学遇到这种问题会出现两种极端的情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;第一种：一脸懵逼，两眼无神，不知从何说起，万般思绪，都化作一声叹息。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;第二种：夸夸其谈，像是口中架起了一把加特林，哒哒哒哒哒哒哒哒，还冒着蓝火。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6618257261410788&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8vRg6KcHicArndgScR8P2tM1EXUsfiboWR2xLnk41ibBkOVeicy6zGicfrEHwjb6UaC8yiafQT7B5aEyfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;482&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一种不用说了，好一点的面试官可能会引导你，会问一些提示性的问题，一步一步地带你渐入佳境，当然你要是胸中无点滴，那还是没救的，场面就异常地尴尬。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二种会把面试官整蒙了，或许你真的懂很多，很多细节也都清晰，但是你不能一股脑儿的都抛出来，这会显得你抓不住重点。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官也是人&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这点其实很关键，很多把面试官当成一个莫得感情的提问机器人，觉得他无所不能可以完全 get 到你的点，殊不知你引以为傲的细节回答，他可能觉得你在说蛇皮。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;是人就会有感情，就需要交流&lt;/span&gt;，好的面试官会把控整体进度，从拉家常开始，让场子热起来再一步一步的深挖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然也有一些面试官比较弱，这时候就需要你来&lt;span&gt;特意地流出一点空白，来让面试官涂鸦&lt;/span&gt;，让面试官感觉你这人就很舒服，你这波就稳了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然即使面对着把控全场的面试官你也得主动出击，每个人都有自己的擅长点，你需要引导面试官来询问你的长处。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;正确的回答姿势&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正确的回答姿势是 BFS（广度优先搜索） 而不是 DFS （深度优先搜索），什么意思呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是我们需要&lt;span&gt;先从大局上讲出需要设计的东西的重点，然后再等待面试官的继续提问，深挖&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要&lt;span&gt;揣摩面试官的心理&lt;/span&gt;，从他的提问可以看出他想要知道的重点是哪个方向的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如就拿 HashMap 来说，你&lt;span&gt;简单的&lt;/span&gt;把获取、写入、冲突处理、扩容啥的都说了，然后等待面试官接下来的提问，有可能会往线程安全方面深入，也有可能会往扩容方向再挖，比如引出 Redis 的 hash 扩容等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以说给面试官留提问的机会，抓住他的喜好或者说熟知的方向回答，这样如果你答得好，相互之间谈的来，面试官会对你高度认可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且在&lt;span&gt;说各设计要点的时候也要注意停顿，要留机会给面试官插话，让面试官充分参与你的设计&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是拿 HashMap 作为例子，比如你说了获取、写入、冲突之后稍作停顿，这时候大概率面试官还会问还有吗？让面试官有参与感，&lt;span&gt;让他感觉经过他的引导这个设计才逐步地完善&lt;/span&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8vRg6KcHicArndgScR8P2tM8VNMwtxvS6fX4cRvKgYLG1pElOGQMRNz4LibMNlIibJ8khibGA31twvcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然如果不问也没事，你停顿下继续说就行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;让面试成为一场技术交流，这是面试的最高境界&lt;/span&gt;，相信面试完了之后双方都会有意犹未尽的感觉，惺惺相惜就是这么来的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这种场景也不是这么容易碰到的，首先你和面试官得有相同方向的喜好，比如你对 JVM 有很深入的研究，而面试官对存储方面有很深入的研究，JVM 懂的不深，这样就碰不出火花了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以说会有很多人碰到这么个情况：我面这个公司一面挂，另一家公司面面超神，这都是很正常的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然你要是说你全能，那当我没说。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结一下面试技巧&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先要正确的看待面试官，你和面试官是同等的，不要一来就低声下气的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次回答问题需要抓住重点，不要一股脑儿的把你知道的都说了，要留白待面试官提问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要把控面试的节奏，往自己熟知的方向上引。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何写个消息中间件&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来咱们再看看如何写个消息中间件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们需要明确地提出消息中间件的几个重要角色，分别是生产者、消费者、Broker、注册中心。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简述下消息中间件数据流转过程，无非就是生产者生成消息，发送至 Broker，Broker 可以暂缓消息，然后消费者再从 Broker 获取消息，用于消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而注册中心用于服务的发现包括：Broker 的发现、生产者的发现、消费者的发现，当然还包括下线，可以说服务的高可用离不开注册中心。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后开始简述实现要点，可以同通信讲起：各模块的通信可以基于 Netty 然后自定义协议来实现，注册中心可以利用 zookeeper、consul、eureka、nacos 等等，也可以像 RocketMQ 自己实现简单的 namesrv （这一句话就都是关键词）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了考虑扩容和整体的性能，采用分布式的思想，像 Kafka 一样采取分区理念，一个 Topic 分为多个 partition，并且为保证数据可靠性，采取多副本存储，即 Leader 和 follower，根据性能和数据可靠的权衡提供异步和同步的刷盘存储。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且利用选举算法保证 Leader 挂了之后 follower 可以顶上，保证消息队列的高可用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也同样为了提高消息队列的可靠性利用本地文件系统来存储消息，并且采用顺序写的方式来提高性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可根据消息队列的特性利用内存映射、零拷贝进一步的提升性能，还可利用像 Kafka 这种批处理思想提高整体的吞吐。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;至此就差不多了，该说的要点说的都差不多了，面试官心里已经想，这人好像有点东西。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.925&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8vRg6KcHicArndgScR8P2tMiaMzrRQ9o5WGRZnZia5I5cNWbdcjaZUiarZWnZ5OaVialWzukMn0w3KVNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;440&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后可以深挖的点就很多了，比如提到的 Netty，各种注册中心就能问很多，比如各注册中心之间的选型对比等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你还提到了选举算法，所以可能会问 Bully 算法、Raft 算法、ZAB 算法等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你还提到了分区，可能会问这个分区和 RocketMQ 的队列有什么不同啊？具体分区要怎么实现？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后你提到顺序写，可能会问为什么要顺序写啊？你说的内存映射和零拷贝又是什么啊？那你知道 RocketMQ 和 Kafka 用了哪个吗?（这些我都分析过，可以看 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MjEyNTk1Ng==&amp;amp;mid=2247484278&amp;amp;idx=1&amp;amp;sn=952b97c166374ff271a14b4ab2e668e5&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;RocketMQ 和 Kafka 底层存储之那些你不知道的事&lt;/a&gt;）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然还有可能问各种细节，比如消息的写入如何存储、消息的索引如何生成等等，来深挖看你有没有看过消息中间件的源码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以问的还很多，这篇文章我也不可能每个点都延伸开说，&lt;span&gt;这些知识点还是得靠大家日积月累和平日的多加思考&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然日后的文章可以写一写今天提到的一些点，比如 Netty、选举算法啊，多种注册中心对比啊啥的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官想问的是什么&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再回到这个面试题，其实面试官想问的就是大方向上的设计，包括整体的架构、数据的流转和一些特性的把握，&lt;span&gt;所以对于这个问题他想听到的就是那些重点，而不是那些细节。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而继续的深挖取决于你回答这个问题时提出的各个关键词，对于面试官自身而言熟悉的词一抓到，他就已经知道下一步要问你什么了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以&lt;span&gt;在回答面试官的时候不仅要 get 到他的点，还得为之后的回答铺路&lt;/span&gt;，不会说的点不要提，擅长的点多提提。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前我已经提到了，这篇文章的重点其实不在于如何回答写一个消息中间件，而在于面试的技巧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为面试题千千万，而技巧掌握了那么千千万的面试题都适用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我还想提一下关于面试的一些个人看法，我个人是面试驱动学习型选手，我学习的动力就是面试，我享受面试官问我啥我都嘴角一翘微微一笑的那种不羁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是我不提倡那种纯粹背面试题的做法，学习是一个日积月累的过程，就像我每篇文末说的，从一点点到亿点点，又像我每篇开头都会提的，每个时代，都不会亏待会学习的人。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的面试驱动不仅仅是说为了面试而学习，还要以面试场景来学习，什么意思呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;学任何一种东西，都模拟一个面试官在你前面，让他从各种角度向你提问，驱动你全方位的理解一个知识点，这才是我说的面试驱动学习型选手。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以如果你看过我之前的文章会发现我经常会提出为什么呢，然后再作答。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一点要注意，&lt;span&gt;动手能力，这很关键。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Talk is cheap, show me the code。&lt;/p&gt;&lt;section&gt;&lt;mp-qa class=&quot;js_uneditable custom_select_card qa_iframe&quot; data-pluginname=&quot;insertquestion&quot; data-id=&quot;1558924558718599169&quot; data-bizuin=&quot;Mzg2MjEyNTk1Ng==&quot; data-title=&quot;兄弟萌，怎么说？&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>34e6e60802faa7ddfeb293dfba09af6c</guid>
<title>Go-Zero 如何应对海量定时/延迟任务</title>
<link>https://toutiao.io/k/g1xuphe</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;一个系统中存在着大量的调度任务，同时调度任务存在时间的滞后性，而大量的调度任务如果每一个都使用自己的调度器来管理任务的生命周期的话，浪费 cpu 的资源而且很低效。&lt;/p&gt;&lt;p&gt;本文来介绍 &lt;code&gt;go-zero&lt;/code&gt; 中 &lt;span&gt;延迟操作&lt;/span&gt;，它可能让开发者调度多个任务时，&lt;span&gt;只需关注具体的业务执行函数和执行时间「立即或者延迟」&lt;/span&gt;。而 &lt;span&gt;延迟操作&lt;/span&gt;，通常可以采用两个方案：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;Timer&lt;/code&gt;：定时器维护一个优先队列，到时间点执行，然后把需要执行的 task 存储在 map 中&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;collection&lt;/code&gt; 中的 &lt;code&gt;timingWheel&lt;/code&gt; ，维护一个存放任务组的数组，每一个槽都维护一个存储 task 的双向链表。开始执行时，计时器每隔指定时间执行一个槽里面的 tasks。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;方案 2 把维护 task 从 &lt;code&gt;优先队列 O(nlog(n))&lt;/code&gt; 降到 &lt;code&gt;双向链表 O(1)&lt;/code&gt;，而执行 task 也只要轮询一个时间点的 tasks &lt;code&gt;O(N)&lt;/code&gt;，不需要像优先队列，放入和删除元素 &lt;code&gt;O(nlog(n))&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;我们先看看 &lt;code&gt;go-zero&lt;/code&gt; 中自己对 &lt;code&gt;timingWheel&lt;/code&gt; 的使用 ：&lt;/p&gt;&lt;h2&gt;cache 中的 timingWheel&lt;/h2&gt;&lt;p&gt;首先我们先来在 &lt;code&gt;collection&lt;/code&gt; 的 &lt;code&gt;cache&lt;/code&gt; 中关于 &lt;code&gt;timingWheel&lt;/code&gt; 的使用：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;timingWheel&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;NewTimingWheel&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;time&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Second&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;slots&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;k&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;v&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{})&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;key&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;ok&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;k&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;cache&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Del&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;})&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;err&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;cache&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;timingWheel&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;timingWheel&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是 &lt;code&gt;cache&lt;/code&gt; 初始化中也同时初始化 &lt;code&gt;timingWheel&lt;/code&gt; 做 key 的过期处理，参数依次代表：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;interval&lt;/code&gt;：时间划分刻度&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;numSlots&lt;/code&gt;：时间槽&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;execute&lt;/code&gt;：时间点执行函数&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在 &lt;code&gt;cache&lt;/code&gt; 中执行函数则是 &lt;span&gt;删除过期 key&lt;/span&gt;，而这个过期则由 &lt;code&gt;timingWheel&lt;/code&gt; 来控制推进时间。&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来，就通过 &lt;code&gt;cache&lt;/code&gt; 对 &lt;code&gt;timingWheel&lt;/code&gt; 的使用来认识。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;初始化&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 真正做初始化&lt;/span&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;newTimingWheelWithClock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;interval&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Duration&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;numSlots&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;execute&lt;/span&gt; &lt;span&gt;Execute&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;ticker&lt;/span&gt; &lt;span&gt;timex&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Ticker&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;*&lt;/span&gt;&lt;span&gt;TimingWheel&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;tw&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;TimingWheel&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;interval&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;      &lt;span&gt;interval&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;                     &lt;span&gt;// 单个时间格时间间隔&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;ticker&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;        &lt;span&gt;ticker&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;                       &lt;span&gt;// 定时器，做时间推动，以interval为单位推进&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;slots&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;         &lt;span&gt;make&lt;/span&gt;&lt;span&gt;([]&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;List&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;numSlots&lt;/span&gt;&lt;span&gt;),&lt;/span&gt; &lt;span&gt;// 时间轮&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;timers&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;        &lt;span&gt;NewSafeMap&lt;/span&gt;&lt;span&gt;(),&lt;/span&gt;                 &lt;span&gt;// 存储task{key, value}的map [执行execute所需要的参数]&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;tickedPos&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;     &lt;span&gt;numSlots&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;                 &lt;span&gt;// at previous virtual circle&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;execute&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;       &lt;span&gt;execute&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;                      &lt;span&gt;// 执行函数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;numSlots&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;      &lt;span&gt;numSlots&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;                     &lt;span&gt;// 初始化 slots num&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;setChannel&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;    &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;timingEntry&lt;/span&gt;&lt;span&gt;),&lt;/span&gt;       &lt;span&gt;// 以下几个channel是做task传递的&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;moveChannel&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;   &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;baseEntry&lt;/span&gt;&lt;span&gt;),&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;removeChannel&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{}),&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;drainChannel&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;  &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;value&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{})),&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;stopChannel&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;   &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;lang&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;PlaceholderType&lt;/span&gt;&lt;span&gt;),&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 把 slot 中存储的 list 全部准备好&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;initSlots&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 开启异步协程，使用 channel 来做task通信和传递&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;go&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.44309647602541885&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbA2Zb6GjZc0zo2icBRxhOlfZ2W2kCZ7nRZHMbt30icn6zTNbW0fHUXXCElAPH2uAMZTXCysUMru7SCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1731&quot; title=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以上比较直观展示 &lt;code&gt;timingWheel&lt;/code&gt; 的 &lt;span&gt;“时间轮”&lt;/span&gt;，后面会围绕这张图解释其中推进的细节。&lt;/p&gt;&lt;p&gt;&lt;code&gt;go tw.run()&lt;/code&gt; 开一个协程做时间推动：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;TimingWheel&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;select&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// 定时器做时间推动 -&amp;gt; scanAndRunTasks()&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&amp;lt;-&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;ticker&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Chan&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;onTick&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// add task 会往 setChannel 输入task&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;task&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&amp;lt;-&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setChannel&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setTask&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;task&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;...&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看出，在初始化的时候就开始了 &lt;code&gt;timer&lt;/code&gt; 执行，并以&lt;code&gt;internal&lt;/code&gt;时间段转动，然后底层不停的获取来自 &lt;code&gt;slot&lt;/code&gt; 中的 &lt;code&gt;list&lt;/code&gt; 的 task，交给 &lt;code&gt;execute&lt;/code&gt; 执行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5576619273301737&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbA2Zb6GjZc0zo2icBRxhOlfZ7KHxknp0ykgrXOwEz7FLxrxIgAL0bxQw1JFULaLOickPl2MKdd39wcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1266&quot; title=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;Task Operation&lt;/h3&gt;&lt;p&gt;紧接着就是设置 &lt;code&gt;cache key&lt;/code&gt; ：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;c&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Cache&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;Set&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;key&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;value&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{})&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Lock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;_&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;ok&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;value&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;lruCache&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Unlock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;expiry&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;unstableExpiry&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;AroundDuration&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;expire&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;ok&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;timingWheel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;MoveTimer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;expiry&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;timingWheel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;SetTimer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;value&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;expiry&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;先看在 &lt;code&gt;data map&lt;/code&gt; 中有没有存在这个 key&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;存在，则更新 &lt;code&gt;expire&lt;/code&gt; -&amp;gt; &lt;code&gt;MoveTimer()&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第一次设置 key -&amp;gt; &lt;code&gt;SetTimer()&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;所以对于 &lt;code&gt;timingWheel&lt;/code&gt; 的使用上就清晰了，开发者根据需求可以 &lt;code&gt;add&lt;/code&gt; 或是 &lt;code&gt;update&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;同时我们跟源码进去会发现：&lt;code&gt;SetTimer() MoveTimer()&lt;/code&gt; 都是将 task 输送到 channel，由 &lt;code&gt;run()&lt;/code&gt; 中开启的协程不断取出 &lt;code&gt;channel&lt;/code&gt; 的 task 操作。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code&gt;SetTimer() -&amp;gt; setTask()&lt;/code&gt;：&lt;/p&gt;&lt;p&gt;&lt;code&gt;MoveTimer() -&amp;gt; moveTask()&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;由上面的调用链，有一个都会调用的函数：&lt;code&gt;moveTask()&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;TimingWheel&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;moveTask&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;task&lt;/span&gt; &lt;span&gt;baseEntry&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// timers: Map =&amp;gt; 通过key获取 [positionEntry「pos, task」]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;val&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;ok&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;timers&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;timer&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;val&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;positionEntry&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// {delay &amp;lt; interval} =&amp;gt; 延迟时间比一个时间格间隔还小，没有更小的刻度，说明任务应该立即执行&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;delay&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;interval&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;threading&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;GoSafe&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;})&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 如果 &amp;gt; interval，则通过 延迟时间delay 计算其出时间轮中的 new pos, circle&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;pos&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;circle&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getPositionAndCircle&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;delay&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;pos&lt;/span&gt; &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;pos&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;circle&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;circle&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 记录前后的移动offset。为了后面过程重新入队&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;diff&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;pos&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;pos&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;circle&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 转移到下一层，将 circle 转换为 diff 一部分&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;circle&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;circle&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;circle&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 因为是一个数组，要加上 numSlots [也就是相当于要走到下一层]&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;diff&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;numSlots&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;pos&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;pos&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 如果 offset 提前了，此时 task 也还在第一层&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 标记删除老的 task，并重新入队，等待被执行&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;removed&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;newItem&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;timingEntry&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;baseEntry&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;task&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;value&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;     &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;slots&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;pos&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;PushBack&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;newItem&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setTimerPosition&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;pos&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;newItem&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上过程有以下几种情况：&lt;/p&gt;&lt;h3&gt;Execute&lt;/h3&gt;&lt;p&gt;之前在初始化中，&lt;code&gt;run()&lt;/code&gt; 中定时器的不断推进，推进的过程主要就是把 list 中的 task 传给执行的 &lt;code&gt;execute func&lt;/code&gt;。我们从定时器的执行开始看：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 定时器 「每隔 internal 会执行一次」&lt;/span&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;TimingWheel&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;onTick&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 每次执行更新一下当前执行 tick 位置&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;tickedPos&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;tickedPos&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;%&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;numSlots&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 获取此时 tick位置 中的存储task的双向链表&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;l&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;slots&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;tickedPos&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;scanAndRunTasks&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;紧接着是如何去执行 &lt;code&gt;execute&lt;/code&gt;：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;TimingWheel&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;scanAndRunTasks&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;l&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;List&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 存储目前需要执行的task{key, value}  [execute所需要的参数，依次传递给execute执行]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; &lt;span&gt;tasks&lt;/span&gt; &lt;span&gt;[]&lt;/span&gt;&lt;span&gt;timingTask&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; &lt;span&gt;e&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;l&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Front&lt;/span&gt;&lt;span&gt;();&lt;/span&gt; &lt;span&gt;e&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;task&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;timingEntry&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 标记删除，在 scan 中做真正的删除 「删除map的data」&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;removed&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;next&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Next&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;l&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Remove&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;timers&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Del&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;e&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;next&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;circle&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// 当前执行点已经过期，但是同时不在第一层，所以当前层即然已经完成了，就会降到下一层&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;// 但是并没有修改 pos&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;circle&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;e&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Next&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;diff&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// 因为之前已经标注了diff，需要再进入队列&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;next&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Next&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;l&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Remove&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;pos&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;tickedPos&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;diff&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;%&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;numSlots&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;slots&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;pos&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;PushBack&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;task&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setTimerPosition&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;pos&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;task&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;diff&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;e&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;next&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 以上的情况都是不能执行的情况，能够执行的会被加入tasks中&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;tasks&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;tasks&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;timingTask&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;key&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;   &lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;value&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;})&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;next&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Next&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;l&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Remove&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;timers&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Del&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;e&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;next&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// for range tasks，然后把每个 task-&amp;gt;execute 执行即可&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;runTasks&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;tasks&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体的分支情况在注释中说明了，在看的时候可以和前面的 &lt;code&gt;moveTask()&lt;/code&gt; 结合起来，其中 &lt;code&gt;circle&lt;/code&gt; 下降，&lt;code&gt;diff&lt;/code&gt; 的计算是关联两个函数的重点。&lt;/p&gt;&lt;p&gt;至于 &lt;code&gt;diff&lt;/code&gt; 计算就涉及到 &lt;code&gt;pos, circle&lt;/code&gt; 的计算：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// interval: 4min, d: 60min, numSlots: 16, tickedPos = 15&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// step = 15, pos = 14, circle = 0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;TimingWheel&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;getPositionAndCircle&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;d&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Duration&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;pos&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;circle&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;steps&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;d&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;interval&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;pos&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;tickedPos&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;steps&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;%&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;numSlots&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;circle&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;steps&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;numSlots&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;上面的过程可以简化成下面：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;steps&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;d&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;interval&lt;/span&gt;&lt;br/&gt;&lt;span&gt;pos&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;step&lt;/span&gt; &lt;span&gt;%&lt;/span&gt; &lt;span&gt;numSlots&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;circle&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;step&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;numSlots&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;timingWheel&lt;/code&gt; 靠定时器推动，时间前进的同时会取出&lt;span&gt;当前时间格&lt;/span&gt;中 &lt;code&gt;list&lt;/code&gt;「双向链表」的 task，传递到 &lt;code&gt;execute&lt;/code&gt; 中执行。因为是是靠 &lt;code&gt;internal&lt;/code&gt; 固定时间刻度推进，可能就会出现：一个 60s 的 task，&lt;code&gt;internal = 1s&lt;/code&gt;，这样就会空跑 59 次 loop。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;而在扩展时间上，采取 &lt;code&gt;circle&lt;/code&gt; 分层，这样就可以不断复用原有的 &lt;code&gt;numSlots&lt;/code&gt; ，因为定时器在不断 &lt;code&gt;loop&lt;/code&gt;，而执行可以把上层的 &lt;code&gt;slot&lt;/code&gt; 下降到下层，在不断 &lt;code&gt;loop&lt;/code&gt; 中就可以执行到上层的 task。这样的设计可以在不创造额外的数据结构，突破长时间的限制。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;同时在 &lt;code&gt;go-zero&lt;/code&gt; 中还有很多实用的组件工具，用好工具对于提升服务性能和开发效率都有很大的帮助，希望本篇文章能给大家带来一些收获。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;同时欢迎大家使用 &lt;code&gt;go-zero&lt;/code&gt; 并加入我们，项目地址 https://github.com/tal-tech/go-zero&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9966442953020134&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbA2Zb6GjZc0zo2icBRxhOlfZ7h0WKmxYsOuibrQiaxZDz1RqTKufficj5HC11VUYGtwyML4ia4nerr3jMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;596&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>02671c3e32af9c544b521004cf8833be</guid>
<title>研发团队如何使用 OKR</title>
<link>https://toutiao.io/k/8nymt6s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h2&gt;OKR简史&lt;/h2&gt;&lt;p&gt;OKR脱胎于大名鼎鼎的管理大师彼得.德鲁克（Peter Drucker)的MBO，即目标管理框架。这个框架的设计，来源于大家都非常熟悉的一句话：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;如果你想要造一艘船,先不要雇人去收集木头,也不要分配任务,而是去激发他们对海洋的渴望。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;安德鲁.格鲁夫(Andrew Grove)对MBO的理念非常欣赏，率先在Intel实施了这套框架。 在1987~1998年任CEO期间，把MBO作为管理哲学的关键组成部分。Andrew认为，一个成功的MBO系统，需要回答两个问题：&lt;/p&gt;&lt;ol class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;我要去哪儿？ Where do I want to go? (这既是OKR中的Objective，目标)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我得如何调整节奏以确保我能够达到那里？ How will I pace myself to see if I’m getting there? (or Key Results.)”&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;第一个问题的答案，对应这OKR中得Objective， 即目标。 而第二个问题的回答，亦即是设置里程碑，即OKR中的Key Results，关键结果。 Andrew成功把Intel发展为全球微处理器的霸主。 而真正把OKR发扬光大的是Google公司。 Google在创建之初就开始使用OKR，并把它作为公司文化的一部分。 随着它在Google的成功实践， OKR逐步开始风靡全球。 这里有一个很长的使用OKR的知名公司名单， 有大家熟知的LinkedIn，Amazon，Netflix等公司。而在国内也有公司也在用OKR。百度这两年也在从KPI转向OKR。 当然，实施OKR最为成功的，当属今日头条的母公司，也就是字节跳动公司。 2017年张一鸣在源码资本的会议上，讲述了如下观点：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;我们让管理层的OKR对下属员工保持公开，让大家知道你在做什么，为什么在做这个事情，其他部门的人在做什么。OKR的制定过程也不是自上而下的分解，而是大家互相之间自己对齐。看一下上级的OKR，看一下别的部门的OKR，看一下同级的OKR，了解目前公司最重要的任务是什么，这个季度最重要的任务是什么，我做什么能够帮助他们。季度会也是尽量让相关人多参与，并不是一个非常小范围的高管会。我们还会经常举办CEO面对面，在这个会上回答员工提问，让大家了解公司进展。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;“公开”“对齐”“非自下而上”， 这些关键词，对厌倦条条框框的软件工程师而言，无疑是有巨大吸引力的。 关于在公司、部门层面如何制定OKR，不少书籍都有很详细的描述。我比较推荐《OKR：源于英特尔和谷歌的目标管理利器》这本书，把OKR的来龙去脉和制定细节讲的非常具体。 可是，落到研发层面来制定OKR的时候，我们经常碰到的问题是： OKR和KPI有什么不同？既然研发工程师是在完成产品经理的目标，那两者的OKR是不是一样就行？&lt;/p&gt;&lt;h2&gt;成败KPI&lt;/h2&gt;&lt;p&gt;国内大部分公司实施的还是KPI(Key Performance Indicator)，即常说的绩效考核。 KPI着眼于评估当前项目或者活动的成就。 KPI也有不少类别，或者说门派，每个公司根据自己的领域以及管理上的成熟度会选择合适的KPI类别。 举个例子，比如某公司，以前都是线下销售，在线商品展示。 最近打算搞在线购物。 产品经理N负责这个项目的产品，开发人员M参与某个模块，比如收银台模块的开发工作。 针对这个事件，KPI还是比较容易制定的，产品经理可以定义如下KPI：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;2019.4.1日 完成在线购物功能模块上线。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;此后，这KPI被按模块来分解，收银台、账户账务、渠道对接（微信、支付宝）、风控等模块。负责收银台的开发人员M，收到的KPI也比较简单：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;2019.3.20日 完成收银台模块的上线。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;看起来这似乎很完美。一项大工程被分解，任务落实到每个人头上，事事都有人在负责。 但实际执行中，总会有各种意外。&lt;/p&gt;&lt;ol class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;开发人员M是一位牛人，收银台模块对他来说，没有什么难度，加上自己喜欢加班，周末也都在干活。 3月10日左右，就把事情做好了。然后呢？ 如果开发人员B负责的模块碰到困难有延迟，M是否应该出手相助？ 那这一块的KPI，算M的还是算B的？ 领导选择衡量什么指标，员工就死盯着那些指标，如果这些指标并不能为最终目的服务，公司整个方向就会跑偏！&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在渠道对接上，选择微信和支付宝，仅仅是产品经理拍脑门认为这两个应该是主流支付方式。而实际上，这个产品的单笔订单额高，用户群更习惯于通过银行卡来执行大额支付。 开发人员B发现了这个问题，但对接这两个支付方式的任务已经落到KPI了。KPI反应迟钝，难以适应市场变化。如今，市场要求更多的个性化产品，需要灵活直接对接市场才能取胜，以往的KPI体系很容易显得迟滞和笨拙，也容易牵扯过多的注意力在僵硬的目标上，并扼杀员工的贴近现实要求的主创精神。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;KPI是自上而下来制定的，以确保公司、部门或者团队的目标是一致的。 对员工来说，缺乏参与感，更缺乏认同感。 还有一个问题，在制定KPI方面，到底是领导专业，还是员工更专业？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在实施KPI的公司，我们经常听到的一句话是： 过程不重要，我们看重结果。 这导致有些员工为完成KPI不择手段。在使用编码行数来统计工作量的公司，直接复制开源软件代码来充数的，不在少数。这往往和企业愿景背道而驰。过程不到位，结果必然有问题。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;关于KPI的问题，可以列出很多很多。绩效与目标计划管理脱结、和价值导向脱钩，只关注结果，而忽视过程，忽略结果获取的正义性，必然导致目标跑偏。 而OKR要解决的问题，是弥补公司战略和价值观、个人追求和绩效之间的空隙，使得组织的运作沿着正确的轨道前进。&lt;/p&gt;&lt;h2&gt;OKR是什么&lt;/h2&gt;&lt;p&gt;在《OKR：源于英特尔和谷歌的目标管理利器》这本书中，OKR被定义为：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;OKR是一套严密的思考框架和持续的纪律要求，旨在确保员工紧密协作，把精力聚焦在能促进组织可成长的、可衡量的贡献上。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;严密的思考框架： OKR是一套框架，而不仅仅是几个冰冷的指标。执行人员需要不断的思考它的涵义，并严谨、规范地执行；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;持续的纪律要求： 这就需要不断（以双月或者季度为单位）地评估OKR达成情况、总结经验教训，并刷新OKR。 -确保员工紧密协作： OKR必须被设计为最大化协作，并在组织内部对齐。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;精力聚焦： OKR不是任务清单，不能涵盖所有的任务，它的主要目的是用于识别最关键任务的业务目标，让执行者知道做什么和不做什么。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;做出可衡量的贡献： 也就是要求，所有的结果必须是定量的，避免模糊、主观的描述。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;促进组织成长： 判断OKR成功与否的最终标准，还是的用结果说话。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这就是OKR定义的六大要素。 那具体来说，怎么订制目标和关键结果呢？&lt;/p&gt;&lt;h2&gt;目标&lt;/h2&gt;&lt;p&gt;目标是驱动组织朝期望方向前进的定性追求的一种简洁的描述。 主要回答：我们想做什么。 目标设置要求简洁、定性、在给定周期内是可以完成的。 注意，目标是定性的，不是定量的。 从软件项目角度，一般目标的安排分为两种：&lt;/p&gt;&lt;ol class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;新功能或者新项目开发；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;现有功能升级改进。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;对新项目/功能的开发，目标设定一般比较简单，可以参考的目标案例：&lt;/p&gt;&lt;ol class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;完成收银台功能上线；【可以】&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;完成手机端收银台功能上线，支持主流支付渠道。【略好】&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;实现一个简单易用的收银台来提升转化率。 【推荐】&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;目标应该是积极向上，能够鼓舞人的，同时又要强调关注的价值。 在设置目标的时候，不妨不断的询问自己： 做这个事情的目的是什么？ 它和公司的战略是什么关系？ 这问题的回答，有助于制定一个符合公司战略方向的目标。 如上案例，都是要完成收银台功能，第3个目标，明确把要做这个事情的直接目标写起来，这样在确定关键结果，或者其他决策的时候，可以以这个objective作为准则来判断其优先级以及是否有必要。 对于功能改进的，可以参考的目标：&lt;/p&gt;&lt;ol class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;提升收银台的渲染速度；【可以】&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;提升收银台的渲染速度以提升转化率。【推荐】&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;关键结果&lt;/h2&gt;&lt;p&gt;关键结果是对目标达成情况的定量描述。 注意，目标是定性的，而关键结果是定量的。 比如对 实现一个简单易用的收银台来提升转化率 这个目标而言，这里的描述有不少模拟两可的地方，比如 简单易用、提升转化率等。这些元素的定量化，就通过关键结果来描述。 比如针对简单易用，可以通过多种途径来衡量。 一种方法是看客户在这个页面的跳出率，这样对应的KR就是“客户在收银台的页面跳出率低于千分之一”。 或者在这里发起在线求助的客户量，对应KR是”发起在线求助的客户量不超过10位”。 而在提升转换率上，如果没有对比数据，可以简单定义一个转化率目标，如“转化率超过20%”, 如果有对比目标，则相对目标来制定“转化率相对于xxx提升20%”，诸如此类的。 当然，这些指标主要是产品角度来提的。 那除了产品目标外，开发工程师还可以制定那些关键结果？&lt;/p&gt;&lt;ul class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;工程目标&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;xx月xx日完成预定义功能功能上线，无重大故障&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;系统访问量从xxx/天 提升到 xxx/天&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;订单量从xxx/天提升到xxx/天&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;质量目标&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;系统上线无重大线上事故&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Bugs率从xx%减少到 xx%；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Sonarqube Bugs 从 xx 减少到 xxx；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Sonarqube单元测试覆盖率 从xxx 提升到 xxx ;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Sonarqube Bad smell 从 xxx 减少到 xxx&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;xxx接口响应时间从xxx 减少到 xxx；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;xxx接口每秒支持的访问量从 xxx 提升到 xxx ；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;重大Bug不多余X个，普通Bug不多于XX个。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;影响范围&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;客户投诉从xx起/周 降低到 xxx起/周&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;客户满意度从xxx提升到xxx&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;系统日均访问量从xxx提升到xxx&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;性能目标&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;接口响应时间控制在 xx毫秒以内；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;接口相应时间从XX毫秒减低到XX毫秒。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;页面渲染速度从xx毫秒减低到xx毫秒。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;从哪些角度来定义关键结果，需要和产品经理一起协商对产品成功的最重要的因素。 一般来说，每个Objective的KR控制在3~5条左右。 过多的KR会使得目标分散。 接下来的问题是，KR的值应该如何设定？ 比如我们希望提升一个接口的性能，现在这个接口响应时间100ms。从需求情况来看，提升到50ms是可以基本满足需求的， 在技术上做简单的改进即可达到。 技术人员在评估后，认为在现有技术上最多就能提升到40ms的。 产品也认为，40ms是可以接受的，但30ms的话，我们就会领先客户。 那最终KR应该定多少？ 30ms或者更低。 这就涉及到KR设置的一个原则： 要设置一个需要跳起来才能达到的目标，而不仅仅是踮起脚尖就能达到的目标。KR的制定，要激发人的创造力和激情，不断超越自己。 这样，一个典型的研发研发类型的OKR：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Objective： 实现一个简单易用的收银台来提升转化率 &lt;br/&gt;KR1： 客户在收银台的页面跳出率低于千分之一 &lt;br/&gt;KR2：上线后无重大Bug，普通Bug 少于2个&lt;br/&gt;KR3： 页面响应时间控制在30ms以内&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;评估&lt;/h2&gt;&lt;p&gt;OKR的评估周期多长比较合适？ 一般是2个月或者3个月（1季度）。对于迭代快的互联网公司，2个月是比较好的一个选择，和大部分项目发版的周期相符。 每2个月需对上一个周期的OKR进行评估，也就是打分，总结，对下一个周期的OKR做制定。这里重点说OKR的评估。知道怎么评估OKR，就能够更了解如何制定OKR。也即是KR必须是可以评估的。 首先说对KR的评估，一般来说，我们对每一项内容，使用0-1的分数来打分。有几个典型的分值：&lt;/p&gt;&lt;ul class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;1.0 ： 即实现了这个有野心的目标；一般来说，这个目标基本是很难、不可能实现的。 需要通过天才的努力才能搞定的。比如上述的30ms， 不仅仅需要依赖团队的努力，还需要推动其他团队的帮助才能达到。比如，推动基础设施团队把数据库的磁盘全部升级为SSD来提升数据库的访问性能，从而提升接口的性能。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;0.7： 虽然很难，但还是可以达到的。比如上述的40ms，技术同学评估后认为还是有可能达到的目标。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;0.3： 在现有基础上，正常地进行即可达到的目标，比如上述的50ms&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;当然，我们还需要对每个KR设置权重，最后计算出这个objective的分值。 那如何评估Objective的分值区间？&lt;/p&gt;&lt;ol class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;如果你大部分的Objective分值都在0.7以上，那需要考虑目标是不定的太低了？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果大部分Objective分值都在0.3以下，是不对自己过于自信了？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;大部分Objective应该在0.3~0.7之间。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;考核&lt;/h2&gt;&lt;p&gt;再次强调，OKR不是KPI，不作为考核的依据。 它可以作为考核的参考，但不能被列入考核指标，否则会影响OKR的制定。&lt;/p&gt;&lt;p&gt;当然，不是所有的公司都适合引入OKR。一个公司或者团队也不可能引入OKR即可变成谷歌或者今日头条。 它需要全公司范围的支持，需要持之以恒的执行，需要全员对规则的重视和尊重。只有负责人能够亲自参与、能够把只有0.3分的KR在全公司公开，才有可能成功实施OKR。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e8d70511e6dee769862d6f21c77676fb</guid>
<title>Go 1.15 中值得关注的几个变化</title>
<link>https://toutiao.io/k/lipeqlg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-content&quot;&gt;&amp;#13;
&lt;p&gt;&lt;img src=&quot;https://tonybai.com/wp-content/uploads/go-1.15-1.png&quot; alt=&quot;img{512x368}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tip.golang.org/doc/go1.15&quot;&gt;Go 1.15版本&lt;/a&gt;在8月12日就正式发布了，给我的感觉就是发布的挺痛快^_^。这种感觉来自与之前版本发布时间的对比：&lt;a href=&quot;https://tonybai.com/2019/10/27/some-changes-in-go-1-13/&quot;&gt;Go 1.13版本&lt;/a&gt;发布于当年的9月4日，更早的&lt;a href=&quot;https://tonybai.com/2018/11/19/some-changes-in-go-1-11/&quot;&gt;Go 1.11版本&lt;/a&gt;发布于当年的8月25日。&lt;/p&gt;
&lt;p&gt;不过这个时间恰与我家&lt;a href=&quot;https://tonybai.com/2020/07/29/my-second-daughter-was-born/&quot;&gt;二宝出生&lt;/a&gt;和老婆月子时期有重叠，每天照顾孩子团团转的我实在抽不出时间研究Go 1.15的变化:(。如今，我逐渐从照顾二宝的工作中脱离出来^_^，于是“Go x.xx版本值得关注的几个变化”系列将继续下去。关注Go语言的演变对掌握和精通Go语言大有裨益，凡是致力于成为一名高级Gopher的读者都应该密切关注Go的演进。&lt;br/&gt;
截至写稿时，Go 1.15最新版是Go 1.15.2。Go 1.15一如既往的遵循&lt;a href=&quot;https://tip.golang.org/doc/go1compat.html&quot;&gt;Go1兼容性承诺&lt;/a&gt;。&lt;a href=&quot;https://tip.golang.org/ref/spec&quot;&gt;语言规范&lt;/a&gt;方面没有任何变化。可以说这是一个“面子”上变化较小的一个版本，但“里子”的变化还是不少的，在本文中我就和各位读者一起就重要变化逐一了解一下。&lt;/p&gt;
&lt;h3&gt;一. 平台移植性&lt;/h3&gt;
&lt;p&gt;Go 1.15版本不再对darwin/386和darwin/arm两个32位平台提供支持了。Go 1.15及以后版本仅对darwin/amd64和darwin/arm64版本提供支持。并且不再对macOS 10.12版本之前的版本提供支持。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tonybai.com/2020/03/08/some-changes-in-go-1-14/&quot;&gt;Go 1.14版本&lt;/a&gt;中，Go编译器在被传入-race和-msan的情况下，默认会执行&lt;strong&gt;-d=checkptr&lt;/strong&gt;，即对unsafe.Pointer的使用进行&lt;a href=&quot;https://github.com/golang/go/issues/34964&quot;&gt;合法性检查&lt;/a&gt;。&lt;strong&gt;-d=checkptr&lt;/strong&gt;主要检查两项内容：&lt;/p&gt;

&lt;p&gt;但在Go 1.14中，这个检查并不适用于Windows操作系统。Go 1.15中增加了对windows系统的支持。&lt;/p&gt;
&lt;p&gt;对于&lt;a href=&quot;https://riscv.org&quot;&gt;RISC-V&lt;/a&gt;架构，Go社区展现出十分积极的姿态，早在&lt;a href=&quot;https://tonybai.com/2018/11/19/some-changes-in-go-1-11/&quot;&gt;Go 1.11版本&lt;/a&gt;，Go就为RISC-V cpu架构预留了GOARCH值：riscv和riscv64。&lt;a href=&quot;https://tonybai.com/2020/03/08/some-changes-in-go-1-14/&quot;&gt;Go 1.14版本&lt;/a&gt;则为64bit RISC-V提供了在linux上的实验性支持(GOOS=linux, GOARCH=riscv64)。在Go 1.15版本中，Go在GOOS=linux, GOARCH=riscv64的环境下的稳定性和性能得到持续提升，并且已经可以支持goroutine异步抢占式调度了。&lt;/p&gt;
&lt;h3&gt;二. 工具链&lt;/h3&gt;
&lt;h4&gt;1. GOPROXY新增以管道符为分隔符的代理列表值&lt;/h4&gt;
&lt;p&gt;在&lt;a href=&quot;https://tonybai.com/2019/10/27/some-changes-in-go-1-13/&quot;&gt;Go 1.13版本&lt;/a&gt;中，&lt;a href=&quot;https://tonybai.com/2018/11/26/hello-go-module-proxy/&quot;&gt;GOPROXY&lt;/a&gt;支持设置为多个proxy的列表，多个proxy之间采用逗号分隔。Go工具链会按顺序尝试列表中的proxy以获取依赖包数据，但是当有proxy server服务不可达或者是返回的http状态码不是404也不是410时，go会终止数据获取。但是当列表中的proxy server返回其他错误时，Go命令不会向GOPROXY列表中的下一个值所代表的的proxy server发起请求，这种行为模式没能让所有gopher满意，&lt;strong&gt;很多Gopher认为Go工具链应该向后面的proxy server请求，直到所有proxy server都返回失败&lt;/strong&gt;。Go 1.15版本满足了Go社区的需求，新增以管道符“|”为分隔符的代理列表值。如果GOPROXY配置的proxy server列表值以管道符分隔，则无论某个proxy server返回什么错误码，Go命令都会向列表中的下一个proxy server发起新的尝试请求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：Go 1.15版本中GOPROXY环境变量的默认值依旧为&lt;strong&gt;https://proxy.golang.org,direct&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;2. module cache的存储路径可设置&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://tonybai.com/2019/06/03/the-practice-of-upgrading-major-version-under-go-module/&quot;&gt;Go module机制&lt;/a&gt;自打在&lt;a href=&quot;https://tonybai.com/2018/11/19/some-changes-in-go-1-11/&quot;&gt;Go 1.11版本&lt;/a&gt;中以试验特性的方式引入时就将module的本地缓存默认放在了&lt;strong&gt;\$GOPATH/pkg/mod&lt;/strong&gt;下（如果没有显式设置GOPATH，那么默认值将是&lt;strong&gt;~/go&lt;/strong&gt;；如果GOPATH下面配置了多个路径，那么选择第一个路径），一直到Go 1.14版本，这个位置都是无法配置的。&lt;/p&gt;
&lt;p&gt;Go module的引入为去除GOPATH提供了前提，于是module cache的位置也要尽量与GOPATH“脱钩”：Go 1.15提供了GOMODCACHE环境变量用于自定义module cache的存放位置。如果没有显式设置GOMODCACHE，那么module cache的默认存储路径依然是&lt;strong&gt;\$GOPATH/pkg/mod&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;三. 运行时、编译器和链接器&lt;/h3&gt;
&lt;h4&gt;1. panic展现形式变化&lt;/h4&gt;
&lt;p&gt;在Go 1.15之前，如果传给panic的值是bool, complex64, complex128, float32, float64, int, int8, int16, int32, int64, string, uint, uint8, uint16, uint32, uint64, uintptr等原生类型的值，那么panic在触发时会输出具体的值，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// go1.15-examples/runtime/panic.go

package main

func foo() {
    var i uint32 = 17
    panic(i)
}

func main() {
    foo()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用Go 1.14运行上述代码，得到如下结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$go run panic.go
panic: 17

goroutine 1 [running]:
main.foo(...)
    /Users/tonybai/go/src/github.com/bigwhite/experiments/go1.15-examples/runtime/panic.go:5
main.main()
    /Users/tonybai/go/src/github.com/bigwhite/experiments/go1.15-examples/runtime/panic.go:9 +0x39
exit status 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Go 1.15版本亦是如此。但是对于派生于上述原生类型的自定义类型而言，Go 1.14只是输出变量地址：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// go1.15-examples/runtime/panic.go

package main

type myint uint32

func bar() {
    var i myint = 27
    panic(i)
}

func main() {
    bar()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用Go 1.14运行上述代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$go run panic.go
panic: (main.myint) (0x105fca0,0xc00008e000)

goroutine 1 [running]:
main.bar(...)
    /Users/tonybai/go/src/github.com/bigwhite/experiments/go1.15-examples/runtime/panic.go:12
main.main()
    /Users/tonybai/go/src/github.com/bigwhite/experiments/go1.15-examples/runtime/panic.go:17 +0x39
exit status 2

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Go 1.15针对此情况作了展示优化，即便是派生于这些原生类型的自定义类型变量，panic也可以输出其值。使用Go 1.15运行上述代码的结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$go run panic.go
panic: main.myint(27)

goroutine 1 [running]:
main.bar(...)
    /Users/tonybai/go/src/github.com/bigwhite/experiments/go1.15-examples/runtime/panic.go:12
main.main()
    /Users/tonybai/go/src/github.com/bigwhite/experiments/go1.15-examples/runtime/panic.go:17 +0x39
exit status 2

&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;2. 将小整数([0,255])转换为interface类型值时将不会额外分配内存&lt;/h4&gt;
&lt;p&gt;Go 1.15在runtime/iface.go中做了一些优化改动：增加一个名为staticuint64s的数组，预先为[0,255]这256个数分配了内存。然后在convT16、convT32等运行时转换函数中判断要转换的整型值是否小于256(len(staticuint64s))，如果小于，则返回staticuint64s数组中对应的值的地址；否则调用mallocgc分配新内存。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$GOROOT/src/runtime/iface.go

// staticuint64s is used to avoid allocating in convTx for small integer values.
var staticuint64s = [...]uint64{
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
        0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
        0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
        0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,

        ... ...

        0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
        0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,

}

func convT16(val uint16) (x unsafe.Pointer) {
        if val &amp;lt; uint16(len(staticuint64s)) {
                x = unsafe.Pointer(&amp;amp;staticuint64s[val])
                if sys.BigEndian {
                        x = add(x, 6)
                }
        } else {
                x = mallocgc(2, uint16Type, false)
                *(*uint16)(x) = val
        }
        return
}

func convT32(val uint32) (x unsafe.Pointer) {
        if val &amp;lt; uint32(len(staticuint64s)) {
                x = unsafe.Pointer(&amp;amp;staticuint64s[val])
                if sys.BigEndian {
                        x = add(x, 4)
                }
        } else {
                x = mallocgc(4, uint32Type, false)
                *(*uint32)(x) = val
        }
        return
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以用下面例子来验证一下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// go1.15-examples/runtime/tinyint2interface.go

package main

import (
    &quot;math/rand&quot;
)

func convertSmallInteger() interface{} {
    i := rand.Intn(256)
    var j interface{} = i
    return j
}

func main() {
    for i := 0; i &amp;lt; 100000000; i++ {
        convertSmallInteger()
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们分别用go 1.14和go 1.15.2编译这个源文件（注意关闭内联等优化，否则很可能看不出效果）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// go 1.14

go build  -gcflags=&quot;-N -l&quot; -o tinyint2interface-go14 tinyint2interface.go

// go 1.15.2

go build  -gcflags=&quot;-N -l&quot; -o tinyint2interface-go15 tinyint2interface.go

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们使用下面命令输出程序执行时每次GC的信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$env GODEBUG=gctrace=1 ./tinyint2interface-go14
gc 1 @0.025s 0%: 0.009+0.18+0.021 ms clock, 0.079+0.079/0/0.20+0.17 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 8 P
gc 2 @0.047s 0%: 0.003+0.14+0.013 ms clock, 0.031+0.099/0.064/0.037+0.10 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 8 P
gc 3 @0.064s 0%: 0.008+0.20+0.016 ms clock, 0.071+0.071/0.018/0.081+0.13 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 8 P
gc 4 @0.081s 0%: 0.005+0.14+0.013 ms clock, 0.047+0.059/0.023/0.032+0.10 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 8 P
gc 5 @0.098s 0%: 0.005+0.10+0.017 ms clock, 0.042+0.073/0.027/0.080+0.13 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 8 P

... ...

gc 192 @3.264s 0%: 0.003+0.11+0.013 ms clock, 0.024+0.060/0.005/0.035+0.11 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 8 P
gc 193 @3.281s 0%: 0.005+0.13+0.032 ms clock, 0.042+0.075/0.041/0.050+0.25 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 8 P
gc 194 @3.298s 0%: 0.004+0.12+0.013 ms clock, 0.033+0.072/0.030/0.033+0.10 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 8 P
gc 195 @3.315s 0%: 0.003+0.17+0.023 ms clock, 0.029+0.062/0.055/0.024+0.18 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 8 P

$env GODEBUG=gctrace=1 ./tinyint2interface-go15
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们看到和go 1.14编译的程序不断分配内存，不断导致GC相比，go1.15.2没有输出GC信息，间接证实了小整数转interface变量值时不会触发内存分配。&lt;/p&gt;
&lt;h4&gt;3. 加入更现代化的链接器(linker)&lt;/h4&gt;
&lt;p&gt;一个新版的&lt;a href=&quot;https://golang.org/s/better-linker&quot;&gt;现代化linker&lt;/a&gt;正在逐渐加入到Go中，Go 1.15是新版linker的起点。后续若干版本，linker优化会逐步加入进来。在Go 1.15中，对于大型项目，新链接器的性能要提高20%，内存占用减少30%。&lt;/p&gt;
&lt;h4&gt;4. objdump支持输出GNU汇编语法&lt;/h4&gt;
&lt;p&gt;go 1.15为objdump工具增加了-gnu选项，&lt;strong&gt;以在Go汇编的后面，辅助输出GNU汇编，便于对照&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// go 1.14：

$go tool objdump -S tinyint2interface-go15|more
TEXT go.buildid(SB)

  0x1001000             ff20                    JMP 0(AX)
  0x1001002             476f                    OUTSD DS:0(SI), DX
  0x1001004             206275                  ANDB AH, 0x75(DX)
  0x1001007             696c642049443a20        IMULL $0x203a4449, 0x20(SP), BP
... ...

//go 1.15.2：

$go tool objdump  -S -gnu tinyint2interface-go15|more
TEXT go.buildid(SB)

  0x1001000             ff20                    JMP 0(AX)                            // jmpq *(%rax)           

  0x1001002             476f                    OUTSD DS:0(SI), DX                   // rex.RXB outsl %ds:(%rsi),(%dx)
  0x1001004             206275                  ANDB AH, 0x75(DX)                    // and %ah,0x75(%rdx)     

  0x1001007             696c642049443a20        IMULL $0x203a4449, 0x20(SP), BP      // imul $0x203a4449,0x20(%rsp,%riz,2),%ebp

... ...

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;四. 标准库&lt;/h3&gt;
&lt;p&gt;和以往发布的版本一样，标准库有大量小改动，这里挑出几个笔者感兴趣的和大家一起看一下。&lt;/p&gt;
&lt;h4&gt;1. 增加tzdata包&lt;/h4&gt;
&lt;p&gt;Go time包中很多方法依赖时区数据，但不是所有平台上都自带时区数据。Go time包会以下面顺序搜寻时区数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- ZONEINFO环境变量指示的路径中

- 在类Unix系统中一些常见的存放时区数据的路径（zoneinfo_unix.go中的zoneSources数组变量中存放这些常见路径）：

    &quot;/usr/share/zoneinfo/&quot;,
    &quot;/usr/share/lib/zoneinfo/&quot;,
    &quot;/usr/lib/locale/TZ/&quot;

- 如果平台没有，则尝试使用$GOROOT/lib/time/zoneinfo.zip这个随着go发布包一起发布的时区数据。但在应用部署的环境中，很大可能不会进行go安装。

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果go应用找不到时区数据，那么go应用运行将会受到影响，就如下面这个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// go1.15-examples/stdlib/tzdata.go

package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    loc, err := time.LoadLocation(&quot;America/New_York&quot;)
    if err != nil {
        fmt.Println(&quot;LoadLocation error:&quot;, err)
        return
    }
    fmt.Println(&quot;LoadLocation is:&quot;, loc)
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们移除系统的时区数据(比如将/usr/share/zoneinfo改名)和Go安装包自带的zoneinfo.zip(改个名)后，在Go 1.15.2下运行该示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go run tzdata.go
LoadLocation error: unknown time zone America/New_York

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为此，Go 1.15提供了一个将时区数据嵌入到Go应用二进制文件中的方法：&lt;strong&gt;导入time/tzdata包&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// go1.15-examples/stdlib/tzdata.go

package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
    _ &quot;time/tzdata&quot;
)

func main() {
    loc, err := time.LoadLocation(&quot;America/New_York&quot;)
    if err != nil {
        fmt.Println(&quot;LoadLocation error:&quot;, err)
        return
    }
    fmt.Println(&quot;LoadLocation is:&quot;, loc)
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们再用go 1.15.2运行一下上述导入tzdata包的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$go run testtimezone.go
LoadLocation is: America/New_York

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不过由于附带tzdata数据，应用二进制文件的size会增大大约800k，下面是在ubuntu下的实测值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-rwxr-xr-x 1 root root 2.0M Oct 11 02:42 tzdata-withouttzdata*
-rwxr-xr-x 1 root root 2.8M Oct 11 02:42 tzdata-withtzdata*

&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;2. 增加json解码限制&lt;/h4&gt;
&lt;p&gt;json包是日常使用最多的go标准库包之一，在Go 1.15中，go按照json规范的要求，为json的解码增加了一层限制：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// json规范要求

//https://tools.ietf.org/html/rfc7159#section-9

A JSON parser transforms a JSON text into another representation.  A
   JSON parser MUST accept all texts that conform to the JSON grammar.
   A JSON parser MAY accept non-JSON forms or extensions.

   An implementation may set limits on the size of texts that it
   accepts.  An implementation may set limits on the maximum depth of
   nesting.  An implementation may set limits on the range and precision
   of numbers.  An implementation may set limits on the length and
   character contents of strings.

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个限制就是增加了一个对json文本最大缩进深度值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// $GOROOT/src/encoding/json/scanner.go

// This limits the max nesting depth to prevent stack overflow.
// This is permitted by https://tools.ietf.org/html/rfc7159#section-9
const maxNestingDepth = 10000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果一旦传入的json文本数据缩进深度超过maxNestingDepth，那json包就会panic。当然，绝大多数情况下，我们是碰不到缩进10000层的超大json文本的。因此，该limit对于99.9999%的gopher都没啥影响。&lt;/p&gt;
&lt;h4&gt;3. reflect包&lt;/h4&gt;
&lt;p&gt;Go 1.15版本之前reflect包&lt;a href=&quot;https://github.com/golang/go/issues/38521&quot;&gt;存在一处行为不一致的问题&lt;/a&gt;，我们看下面例子(例子来源于https://play.golang.org/p/Jnga2_6Rmdf)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// go1.15-examples/stdlib/reflect.go

package main

import &quot;reflect&quot;

type u struct{}

func (u) M() { println(&quot;M&quot;) }

type t struct {
    u
    u2 u
}

func call(v reflect.Value) {
    defer func() {
        if err := recover(); err != nil {
            println(err.(string))
        }
    }()
    v.Method(0).Call(nil)
}

func main() {
    v := reflect.ValueOf(t{}) // v := t{}
    call(v)                   // v.M()
    call(v.Field(0))          // v.u.M()
    call(v.Field(1))          // v.u2.M()
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们使用Go 1.14版本运行该示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$go run reflect.go
M
M
reflect: reflect.flag.mustBeExported using value obtained using unexported field

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们看到同为类型t中的非导出字段(field)的u和u2(u是以嵌入类型方式称为类型t的字段的)，通过reflect包可以调用字段u的导出方法(如输出中的第二行的M)，却无法调用非导出字段u2的导出方法（如输出中的第三行的panic信息）。&lt;/p&gt;
&lt;p&gt;这种不一致在Go 1.15版本中被修复，我们使用Go 1.15.2运行上述示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$go run reflect.go
M
reflect: reflect.Value.Call using value obtained using unexported field
reflect: reflect.Value.Call using value obtained using unexported field

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们看到reflect无法调用非导出字段u和u2的导出方法了。但是reflect依然可以通过提升到类型t的方法来间接使用u的导出方法，正如运行结果中的第一行输出。&lt;br/&gt;
&lt;strong&gt;这一改动可能会影响到遗留代码中使用reflect调用以类型嵌入形式存在的非导出字段方法的代码&lt;/strong&gt;，如果你的代码中存在这样的问题，可以直接通过提升(promote)到包裹类型(如例子中的t)中的方法（如例子中的call(v)）来替代之前的方式。&lt;/p&gt;
&lt;h3&gt;五. 小结&lt;/h3&gt;
&lt;p&gt;由于Go 1.15删除了一些GC元数据和一些无用的类型元数据，Go 1.15编译出的二进制文件size会减少5%左右。我用一个中等规模的go项目实测了一下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-rwxr-xr-x   1 tonybai  staff    23M 10 10 16:54 yunxind*
-rwxr-xr-x   1 tonybai  staff    24M  9 30 11:20 yunxind-go14*

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;二进制文件size的确有变小，大约4%-5%。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你还没有升级到Go 1.15，那么现在正是时候&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;本文中涉及的代码可以在&lt;a href=&quot;https://github.com/bigwhite/experiments/tree/master/go1.15-examples&quot;&gt;这里&lt;/a&gt;下载。https://github.com/bigwhite/experiments/tree/master/go1.15-examples&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;我的Go技术专栏：“&lt;a href=&quot;https://www.imooc.com/read/87&quot;&gt;改善Go语⾔编程质量的50个有效实践&lt;/a&gt;”上线了，欢迎大家订阅学习！&lt;/p&gt;
&lt;p&gt;我的网课“&lt;a href=&quot;https://coding.imooc.com/class/284.html&quot;&gt;Kubernetes实战：高可用集群搭建、配置、运维与应用&lt;/a&gt;”在慕课网上线了，感谢小伙伴们学习支持！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://51smspush.com/&quot;&gt;我爱发短信&lt;/a&gt;：企业级短信平台定制开发专家 https://51smspush.com/&lt;br/&gt;
smspush : 可部署在企业内部的定制化短信平台，三网覆盖，不惧大并发接入，可定制扩展； 短信内容你来定，不再受约束, 接口丰富，支持长短信，签名可选。&lt;/p&gt;
&lt;p&gt;2020年4月8日，中国三大电信运营商联合发布《5G消息白皮书》，51短信平台也会全新升级到“51商用消息平台”，全面支持5G RCS消息。&lt;/p&gt;
&lt;p&gt;著名云主机服务厂商DigitalOcean发布最新的主机计划，入门级Droplet配置升级为：1 core CPU、1G内存、25G高速SSD，价格5$/月。有使用DigitalOcean需求的朋友，可以打开这个&lt;a href=&quot;https://m.do.co/c/bff6eed92687&quot;&gt;链接地址&lt;/a&gt;：https://m.do.co/c/bff6eed92687 开启你的DO主机之路。&lt;/p&gt;
&lt;p&gt;Gopher Daily(Gopher每日新闻)归档仓库 – https://github.com/bigwhite/gopherdaily&lt;/p&gt;
&lt;p&gt;我的联系方式：&lt;/p&gt;
&lt;p&gt;微博：https://weibo.com/bigwhite20xx&lt;br/&gt;
微信公众号：iamtonybai&lt;br/&gt;
博客：tonybai.com&lt;br/&gt;
github: https://github.com/bigwhite&lt;/p&gt;
&lt;p&gt;微信赞赏：&lt;br/&gt;
&lt;img src=&quot;https://tonybai.com/wp-content/uploads/wechat-zanshang-code-512x512.jpg&quot; alt=&quot;img{512x368}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;商务合作方式：撰稿、出书、培训、在线课程、合伙创业、咨询、广告合作。&lt;/p&gt;
&lt;p&gt;© 2020, &lt;a href=&quot;https://tonybai.com&quot;&gt;bigwhite&lt;/a&gt;. 版权所有. &lt;/p&gt;
&lt;p&gt;Related posts:&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://tonybai.com/2020/03/08/some-changes-in-go-1-14/&quot; rel=&quot;bookmark&quot; title=&quot;Go 1.14中值得关注的几个变化&quot;&gt;Go 1.14中值得关注的几个变化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tonybai.com/2016/02/21/some-changes-in-go-1-6/&quot; rel=&quot;bookmark&quot; title=&quot;Go 1.6中值得关注的几个变化&quot;&gt;Go 1.6中值得关注的几个变化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tonybai.com/2015/03/09/understanding-import-packages/&quot; rel=&quot;bookmark&quot; title=&quot;理解Golang包导入&quot;&gt;理解Golang包导入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tonybai.com/2018/11/26/hello-go-module-proxy/&quot; rel=&quot;bookmark&quot; title=&quot;Hello，Go module proxy&quot;&gt;Hello，Go module proxy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tonybai.com/2015/07/10/some-changes-in-go-1-5/&quot; rel=&quot;bookmark&quot; title=&quot;Go 1.5中值得关注的几个变化&quot;&gt;Go 1.5中值得关注的几个变化&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;&amp;#13;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>