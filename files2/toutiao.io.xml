<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>9690e298037583a31ba522f9ce99862c</guid>
<title>Git 全栈开发使用指南</title>
<link>https://toutiao.io/k/v4gks4h</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;一、Git基础&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.418&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsGnZGkxDd3iaMynLAgW4AmSKP5CkVtMNODbDrKmKpKRKDucsLHPFRJfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;500&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、Git简介&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Git是一种分布式版本控制系统，由Linux之父Linus开发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓分布式版本管理系统，就是在每一台机器上都有一个完整的仓库。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.129848229342327&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsg6aFmxb2ahPaZCBic5bg1icuFDu61RBLicRic94YSP0e4hz6PWKJXfUsVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;593&quot;/&gt;&lt;figcaption&gt;image-20201229212250725&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、Git官网&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Git官网：&lt;span&gt;?&lt;/span&gt;git&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5438175270108043&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsZ7A7Yk2g9Y1CB7W4gj6fPMq1icBmKscmlPalAyKZibmhMFu5nPk9tjwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1666&quot;/&gt;&lt;figcaption&gt;image-20201229212543426&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在官网上可以获取Git的安装软件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，还可以下载《progit》——这是最棒的Git学习资料，而且有中文版本。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3、Git安装&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 &lt;code&gt;https://git-scm.com/downloads&lt;/code&gt;官方下载地址下载对应的操作系统版本一步步安装即可。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5664516129032258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsnNbxY9mTWnicxSOlA93uhMNA2QHXw3vPD6iafBsDXaa7arpAmHZyDudQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1550&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4、Git基本配置&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装完成之后，在任意目录下，右键 &lt;code&gt;Git Bash Here&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.4619883040935673&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsNnrnh2iaOF9s7TbcQDjj7PJ7UgZ5cBLJ4Mzib4ZT5PrmfIicsfBjhtCaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;342&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;全局配置邮箱和用户名（&lt;code&gt;–global&lt;/code&gt;表示全局配置，也可以不配置，每个仓库单独配置）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ git config --global user.name &lt;span&gt;&quot;test&quot;&lt;/span&gt;&lt;br/&gt;$ git config --global user.email &lt;span&gt;test&lt;/span&gt;@qq.com&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5、Git基本概念&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1、Git工作区域&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Git有四个工作区域：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;工作区&lt;/p&gt;&lt;p&gt;简单说工作区就是我们项目的目录。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.31901840490797545&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPslricuQWbNeic1FUKjOnecjLp3icX5LN3ae3Zg1JUXyO4b94X4ibdlrTyeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;815&quot;/&gt;&lt;figcaption&gt;image-20201229220303023&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;仓库区/本地仓库&lt;/p&gt;&lt;p&gt;工作区有一个&lt;code&gt;.git&lt;/code&gt;目录，其实这个不是工作区，是Git的版本库，存储了Git仓库的所有版本信息&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4585365853658537&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsWDa1nl0rOpGIricjNCma1cscsJCl6iaeb12EV6iaCWkB7L0BS004eIcbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;820&quot;/&gt;&lt;figcaption&gt;image-20201229220345268&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5109170305676856&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsSPI4yEHibmamVDLLuGP5srAUc78Elsma8XHzSpVsDAjNf7NyLZjiaVicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;458&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;暂存区&lt;/p&gt;&lt;p&gt;暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。有时候也被称作“索引”，&lt;/p&gt;&lt;p&gt;不过一般说法还是叫暂存区域。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;远程仓库&lt;/p&gt;&lt;p&gt;对于分布式版本管理系统，远程仓库不是必须存在的，但是通常项目都会有远程仓库。例如&lt;code&gt;Github&lt;/code&gt;就是我们非常熟悉的远程仓库。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5057332528666264&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsOTGdFv4Y4ZNRnFYQb9uxZ3a8Xxc7uS9VgWt9Cugibdgp61d8QJLmMng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1657&quot;/&gt;&lt;figcaption&gt;image-20201229221144078&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;基本的Git工作流程如下：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在工作目录修改文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;暂存文件，将文件快照放入暂存区&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提交更新，找到暂存区的文件，将快照永久性存储到到 Git 仓库区（本地）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将本地仓库的变更推送到远程仓库&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上几个区域的关系可以用下图表示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2901023890784983&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPslFN1bZ8pPolGS3aKibZWEZ6kLicmmaMJYgGTjdFp6G9Bka0G1cWA2B8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1172&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2、Git分支&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分支是为了将修改记录的整个流程分开存储，让分开的分支不受其它分支的影响，所以在同一个数据库里可以同时进行多个不同的修改。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8209982788296041&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPs4Gc1QzoUIuEj77xa7uWbxlQ2EIqkVtSuHtuTSGebU9saCHcibNMY8Yw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;581&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Git 为我们自动创建的第一个分支，也叫主分支，一般其它分支开发完成后都要合并到 master&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.4881889763779528&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPscib3R0PACFbvV2R5IjUmByxibpv6nKyUSLZ8tyQosInwU0bXib5KbRUxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;254&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3、Git文件状态&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在git中，文件主要有四种状态：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsibX49DiaZCrCJCqEBRkLMibjBALxBIAHNcqX7RAL8ibdO6dHa5KFRyKzvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;Life Cycle&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;Untracked&lt;/strong&gt;: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过&lt;code&gt;git add&lt;/code&gt; 状态变为&lt;code&gt;Staged&lt;/code&gt;.&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;Unmodify&lt;/strong&gt;（Committed): 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为&lt;code&gt;Modified&lt;/code&gt;. 如果使用&lt;code&gt;git rm&lt;/code&gt;移出版本库, 则成为&lt;code&gt;Untracked&lt;/code&gt;文件&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;Modified&lt;/strong&gt;: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过&lt;code&gt;git add&lt;/code&gt;可进入暂存&lt;code&gt;staged&lt;/code&gt;状态, 使用&lt;code&gt;git checkout&lt;/code&gt; 则丢弃修改过, 返回到&lt;code&gt;unmodify&lt;/code&gt;状态, 这个&lt;code&gt;git checkout&lt;/code&gt;即从库中取出文件, 覆盖当前修改&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;Staged&lt;/strong&gt;: 暂存状态. 执行&lt;code&gt;git commit&lt;/code&gt;则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为&lt;code&gt;Unmodify&lt;/code&gt;状态. 执行&lt;code&gt;git reset HEAD filename&lt;/code&gt;取消暂存, 文件状态为&lt;code&gt;Modified&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;二、Git应用实践&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完上面的Git基础，你可能有一些迷惑，接下来，我们以实际工作中开发的流程来加深对Git的理解吧。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、克隆项目&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过在工作区使用&lt;code&gt;git init&lt;/code&gt;来初始化一个Git仓库，但通常开发中我们不会这样做，因为实际的项目大部分已经进行了部分开发，并进行了版本管理，所以我们首先做的是从远程仓库克隆项目。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我从Gitee（一般开发项目的远程仓库是部署在内网的GitLab） &lt;code&gt;fork&lt;/code&gt;了一个开源项目，将这个项目作为远程仓库的项目：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5059985885673959&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsicT2gyuGaym35WI6iaiaCB2Eia4gIicenaend6qicRualvv8yk7cia9nH8cqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1417&quot;/&gt;&lt;figcaption&gt;image-20201229214855118&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击&lt;code&gt;克隆下载&lt;/code&gt;，可以看到项目的路径，&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;HTTPS&lt;/code&gt;是凭据式的路径，使用此路径，向远程仓库推送代码的时候需要凭据（账号密码）；&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;这种方式向远程仓库提交，会要求账号密码，输入完成之后，Win10操作系统可以选择记住凭据，这样就不用每一次都输入了，Win10操作系统管理凭据 &lt;code&gt;控制面板 → 用户帐户 → 凭据管理器 → Windows凭据&lt;/code&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPs2ptrKYcqr35qEZTuQdD13QzAGIkyRxmHM5gDHP0vpaToQKyssLS3DA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1062&quot;/&gt;&lt;figcaption&gt;image-20201230174621550&lt;/figcaption&gt;&lt;/figure&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;SSH&lt;/code&gt;是秘钥式的路径，向远程仓库推送代码的时候，需要本地的私钥和远程仓库的公钥对应。&lt;/p&gt;&lt;p&gt;SSH配置可以参考 &lt;span&gt;?&lt;/span&gt;Windows配置Github、Gitee共存的Git环境，这里就不详细展开讲解。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我已经进行了公私钥的配置，所以这里选择SSH。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5513513513513514&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsBF0sYbP7DiaIhicPCYn9PJLUO0rP2QmNAlUiciaEDia8Zmia9ocaXEBykgUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;370&quot;/&gt;&lt;figcaption&gt;image-20201229215107233&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;git clone&lt;/code&gt;命令克隆项目&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3076923076923077&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsWlPNJFJp9l8icX2zYbfxDVEQQAwq2XeKNnCibYQc3lcrFH12zcU1BVQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;598&quot;/&gt;&lt;figcaption&gt;image-20201229215845069&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、代码管理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目已经成功克隆，接下来要进行我们的开发了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1、创建分支&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常开发不是在&lt;code&gt;Master&lt;/code&gt;分支上，而是在开发分支上，使用 &lt;code&gt;git branch develop&lt;/code&gt;创建一个新分支：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.21536351165980797&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPswYKH2rUrLVHVib7sMNCabBGw3vZyka3pSia9h4kgCQkRjgVCKLJslSPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;729&quot;/&gt;&lt;figcaption&gt;image-20201229222931344&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过&lt;code&gt;git branch&lt;/code&gt;命令列出所有分支：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.13010590015128592&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsrNY3GY7NFHPvXgEASsTaDmrUJKfo86SQ3T7SqMoRdOsuGKpa9dbibEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;661&quot;/&gt;&lt;figcaption&gt;image-20201229223057016&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到我们新建的分支。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2、切换分支&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;git checkout develop&lt;/code&gt;命令切换到新建的develop分支：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.10510046367851623&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsTBIFhoGakWrqmHZtl6jIwT7zKFfB3iasqZYddFrlz4KweBugCtpEEGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;647&quot;/&gt;&lt;figcaption&gt;image-20201229223325328&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3、添加文件到暂存区&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们再develop分支上进行一些开发操作，我这里对 redeme 进行了一些修改，需要把修改添加到暂存区。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;首先通过 &lt;code&gt;git status&lt;/code&gt;命令查看工作区文件状态&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2621502209131075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsa2xzYicUovHrfVX3vuGiagSDJsqTNf8WtVCpyC1rfsSwWoPy82MeJb9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;679&quot;/&gt;&lt;figcaption&gt;image-20201229223653744&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;接下来使用 &lt;code&gt;git add README.md&lt;/code&gt;命令（可以使用&lt;code&gt;git add .&lt;/code&gt;添加所有修改）将更改添加到暂存区&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2548148148148148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsl5l307O3ZwjEvpE8EQ7XV4Jia6o9PnEKbk10vWDo4DfaV8brDW9ic4tQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;675&quot;/&gt;&lt;figcaption&gt;image-20201229223945199&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到文件已经添加。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4、提交修改到仓库&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来使用&lt;code&gt;git commit -m &quot;😀修改了redeme&quot;&lt;/code&gt;，将修改提交到仓库&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1398176291793313&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsb83XofjTCfLZTE3KcdKIq5QAKM6sSANep0VaEE2icich3o1icevHrFK5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;658&quot;/&gt;&lt;figcaption&gt;image-20201229224319159&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里值得一提的是，我们的提交信息尽量遵循某种规范，例如在提交信息中体现本次提交的类型：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;feat&lt;/strong&gt; ：新功能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;fix&lt;/strong&gt; : bug修复&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;docs&lt;/strong&gt; :文档变更&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;style&lt;/strong&gt; :与样式相关的所有变动&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;refactor&lt;/strong&gt; :既不是bug修复也未添加功能的代码更改&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;test&lt;/strong&gt; :与测试有关所有变动&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;chore&lt;/strong&gt; :改变了构建任务，程序包管理器配置等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;规范而精确的提交信息不仅能帮助我们的同事快速了解我们的提交，也对我们自己的开发和重构有很大的帮助。我喜欢用表情包标注提交类型，这样从远程仓库看提交记录比较好看😄&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5636363636363636&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPs59jEb0mgzRs2CTbhPxejTx4NFFKXc3oqPhiaib9ebzVxXiaUsWx1GNHQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;880&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过&lt;code&gt;git log&lt;/code&gt;命令查看提交历史：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4012820512820513&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsBbc3m37OfaBUd1J9Rp1tibUib7vGVEgMVDTHEaUdIGGyLj26RRMz06WQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;780&quot;/&gt;&lt;figcaption&gt;image-20201229224851871&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5、推送修改到远程仓库&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用&lt;code&gt;git push origin develop&lt;/code&gt;命令将修改推送到远程仓库，在推送之前，通常通过&lt;code&gt;git pull origin develop&lt;/code&gt;（本实例远程仓库不存在develop分支，所以直接推送）命令来拉取远程仓库——这个是为了避免本地版本落后的情况，当然如果冲突你也可以强制提交，只是你的同事会做出什么过激行为不敢保证。😂&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3502673796791444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsKkllwzd8z2BY0TKAwSUJ9p645sBIja9MgRk58m5FcyNFVdUXTElKcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;748&quot;/&gt;&lt;figcaption&gt;image-20201229231704254&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们的远程仓库就可以看到这次提交了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5484922575387123&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPskupyKZ4O4TldqFpFL3PJC4xsaTniah2B4MTn7YQY01yEVhyX21ye7qw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1227&quot;/&gt;&lt;figcaption&gt;image-20201229231807331&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.6、合并分支&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终我们的提交都是要合并到&lt;code&gt;master&lt;/code&gt;分支的，首先切换到&lt;code&gt;master&lt;/code&gt;分支，接着通过命令，&lt;code&gt;git merge develop&lt;/code&gt;命令，将&lt;code&gt;develop&lt;/code&gt;分支合并到&lt;code&gt;master&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.19089574155653452&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsHV8JZzicz1fjgDNBqcezquibHmfREZBf6Uz4egUENBnHqWpOU6dAcqlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;681&quot;/&gt;&lt;figcaption&gt;image-20201229232122731&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们这个分支是没有冲突的，可能在合并的过程中会出现冲突的情况，可以通过 &lt;code&gt;git status&lt;/code&gt; 查看冲突的文件，手动解决冲突。当然，可以借助一些开发工具来完成这个工作，下文再讲。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.7、版本回退&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如说，我们发现这次提交不是我们想要的，可以通过 &lt;code&gt;git reset --hard HEAD^&lt;/code&gt; 回退到上一次提交&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1083969465648855&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsE1C0SGs0hMK4IueSHQnupU8qYZFtbtfEFnHFBq0CMBABwy92QNzS9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;655&quot;/&gt;&lt;figcaption&gt;image-20201229232415498&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.8、打标签&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如我们要发布一个版本，我们通常会给这次提交打一个标签 &lt;code&gt;git tag publish/0.0.1&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2222222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsjS8Dm7bkmlyG0ZjugPOEt4r1IgtMOiahLU0bG1VG8w4pKazunlfBA7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;657&quot;/&gt;&lt;figcaption&gt;image-20201229232931444&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过&lt;code&gt;git tag&lt;/code&gt;命令来查看我们打的标签。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;三、Git常用命令&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面有这样一张图片，基本上日常使用记住这6个命令就可以了，但是要想熟练使用，可能就需要记住更多命令了，这里整理了一些常用的命令。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2901023890784983&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPslFN1bZ8pPolGS3aKibZWEZ6kLicmmaMJYgGTjdFp6G9Bka0G1cWA2B8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1172&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、初始化仓库&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;# 在当前目录新建一个Git代码库&lt;/span&gt;&lt;br/&gt;    $ git init&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 新建一个目录，将其初始化为Git代码库&lt;/span&gt;&lt;br/&gt;    $ git init [project-name]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 下载一个项目和它的整个代码历史&lt;/span&gt;&lt;br/&gt;    $ git &lt;span&gt;clone&lt;/span&gt; [url]&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、配置&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;# 显示当前的Git配置&lt;/span&gt;&lt;br/&gt;    $ git config --list&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 显示 Git 的某一项配置&lt;/span&gt;&lt;br/&gt;    $ git config &amp;lt;key&amp;gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 编辑Git配置文件&lt;/span&gt;&lt;br/&gt;    $ git config -e [--global]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 设置提交代码时的用户信息，选择global即全局配置&lt;/span&gt;&lt;br/&gt;    $ git config [--global] user.name &lt;span&gt;&quot;[name]&quot;&lt;/span&gt;&lt;br/&gt;    $ git config [--global] user.email &lt;span&gt;&quot;[email address]&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3、增加/删除文件&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的增加/删除文件指的是向暂存区增加/删除文件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;# 查看文件状态，查看当前工作区新增、更改或删除的文件&lt;/span&gt;&lt;br/&gt;    $ git status&lt;br/&gt;     &lt;br/&gt;    &lt;span&gt;# 添加指定文件到暂存区，可以添加多个文件，中间以空格隔开&lt;/span&gt;&lt;br/&gt;    $ git add [file1] [file2] ...&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 添加指定目录到暂存区，包括子目录&lt;/span&gt;&lt;br/&gt;    $ git add [dir]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 添加当前目录的所有文件到暂存区&lt;/span&gt;&lt;br/&gt;    $ git add .&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 添加每个变化前，都会要求确认&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# 对于同一个文件的多处变化，可以实现分次提交&lt;/span&gt;&lt;br/&gt;    $ git add -p&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 删除工作区文件，并且将这次删除放入暂存区&lt;/span&gt;&lt;br/&gt;    $ git rm [file1] [file2] ...&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 停止追踪指定文件，但该文件会保留在工作区&lt;/span&gt;&lt;br/&gt;    $ git rm --cached [file]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 改名文件，并且将这个改名放入暂存区&lt;/span&gt;&lt;br/&gt;    $ git mv [file-original] [file-renamed]&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;# 临时保存修改，可跨分支&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# save为可选项&lt;/span&gt;&lt;br/&gt;    $ git stash [save message]&lt;br/&gt;    &lt;span&gt;# 所有保存的记录列表&lt;/span&gt;&lt;br/&gt;    $ git stash list&lt;br/&gt;    &lt;span&gt;# 恢复工作进度到工作区，此命令的stash@{num}是可选项，在多个工作进度中可以选择恢复，不带此项则默认恢复最近的一次进度相当于git stash pop stash@{0}&lt;/span&gt;&lt;br/&gt;    $ git stash pop [stash@{num}]&lt;br/&gt;    &lt;span&gt;# 恢复工作进度到工作区且该工作进度可重复恢复，此命令的stash@{num}是可选项，在多个工作进度中可以选择恢复，不带此项则默认恢复最近的一次进度相当于git stash apply stash@{0}&lt;/span&gt;&lt;br/&gt;    $ git stash apply [stash@{num}]&lt;br/&gt;    &lt;span&gt;# 删除一条保存的工作进度，此命令的stash@{num}是可选项，在多个工作进度中可以选择删除，不带此项则默认删除最近的一次进度相当于git stash drop stash@{0}&lt;/span&gt;&lt;br/&gt;    $ git stash drop stash@{num} &lt;br/&gt;    &lt;span&gt;# 删除所有保存&lt;/span&gt;&lt;br/&gt;    $ git stash clear&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4、代码提交&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;# 提交暂存区到仓库区，如果不加-m，会进入vim编辑器&lt;/span&gt;&lt;br/&gt;    $ git commit -m [message]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 提交暂存区的指定文件到仓库区&lt;/span&gt;&lt;br/&gt;    $ git commit [file1] [file2] ... -m [message]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 提交工作区自上次commit之后的变化，直接到仓库区&lt;/span&gt;&lt;br/&gt;    $ git commit -a&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 提交时显示所有diff信息&lt;/span&gt;&lt;br/&gt;    $ git commit -v&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 使用一次新的commit，替代上一次提交&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# 如果代码没有任何新变化，则用来改写上一次commit的提交信息&lt;/span&gt;&lt;br/&gt;    $ git commit --amend -m [message]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 重做上一次commit，并包括指定文件的新变化&lt;/span&gt;&lt;br/&gt;    $ git commit --amend [file1] [file2] ...&lt;br/&gt;    &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5、分支&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;# 列出所有本地分支&lt;/span&gt;&lt;br/&gt;    $ git branch&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 列出所有远程分支&lt;/span&gt;&lt;br/&gt;    $ git branch -r&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 列出所有本地分支和远程分支&lt;/span&gt;&lt;br/&gt;    $ git branch -a&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 新建一个分支，但依然停留在当前分支&lt;/span&gt;&lt;br/&gt;    $ git branch [branch-name]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 新建一个分支，并切换到该分支&lt;/span&gt;&lt;br/&gt;    $ git checkout -b [branch]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 新建一个分支，指向指定commit&lt;/span&gt;&lt;br/&gt;    $ git branch [branch] [commit]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 新建一个分支，与指定的远程分支建立追踪关系&lt;/span&gt;&lt;br/&gt;    $ git branch --track [branch] [remote-branch]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 切换到指定分支，并更新工作区&lt;/span&gt;&lt;br/&gt;    $ git checkout [branch-name]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 切换到上一个分支&lt;/span&gt;&lt;br/&gt;    $ git checkout -&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 建立追踪关系，在现有分支与指定的远程分支之间&lt;/span&gt;&lt;br/&gt;    $ git branch --&lt;span&gt;set&lt;/span&gt;-upstream [branch] [remote-branch]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 合并指定分支到当前分支&lt;/span&gt;&lt;br/&gt;    $ git merge [branch]&lt;br/&gt;   &lt;br/&gt;    &lt;span&gt;# 查看分支合并状态&lt;/span&gt;&lt;br/&gt;    $  git rerere status&lt;br/&gt;   &lt;br/&gt;    &lt;span&gt;# 显示合并冲突解决方案的当前状态——开始解决前与解决后的样子&lt;/span&gt;&lt;br/&gt;    $  git rerere diff&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 选择一个commit，合并进当前分支&lt;/span&gt;&lt;br/&gt;    $ git cherry-pick [commit]&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;#分支重命名&lt;/span&gt;&lt;br/&gt;    $ git git branch -m [oldName]  [newName]&lt;br/&gt;    &lt;span&gt;# 删除分支&lt;/span&gt;&lt;br/&gt;    $ git branch -d [branch-name]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 删除远程分支&lt;/span&gt;&lt;br/&gt;    $ git push origin --delete [branch-name]&lt;br/&gt;    $ git branch -dr [remote/branch]&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6、标签&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;# 列出所有tag&lt;/span&gt;&lt;br/&gt;    $ git tag&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 新建一个tag在当前commit&lt;/span&gt;&lt;br/&gt;    $ git tag [tag]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 新建一个tag在指定commit&lt;/span&gt;&lt;br/&gt;    $ git tag [tag] [commit]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 删除本地tag&lt;/span&gt;&lt;br/&gt;    $ git tag -d [tag]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 删除远程tag&lt;/span&gt;&lt;br/&gt;    $ git push origin :refs/tags/[tagName]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 查看tag信息&lt;/span&gt;&lt;br/&gt;    $ git show [tag]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 提交指定tag&lt;/span&gt;&lt;br/&gt;    $ git push [remote] [tag]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 提交所有tag&lt;/span&gt;&lt;br/&gt;    $ git push [remote] --tags&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 新建一个分支，指向某个tag&lt;/span&gt;&lt;br/&gt;    $ git checkout -b [branch] [tag]&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7、查看信息&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 显示有变更的文件&lt;/span&gt;&lt;br/&gt;$ git status&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 显示当前分支的版本历史&lt;/span&gt;&lt;br/&gt;$ git &lt;span&gt;log&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 显示commit历史，以及每次commit发生变更的文件&lt;/span&gt;&lt;br/&gt;$ git &lt;span&gt;log&lt;/span&gt; --&lt;span&gt;stat&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 搜索提交历史，根据关键词&lt;/span&gt;&lt;br/&gt;$ git &lt;span&gt;log&lt;/span&gt; -S [keyword]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 显示某个commit之后的所有变动，每个commit占据一行&lt;/span&gt;&lt;br/&gt;$ git &lt;span&gt;log&lt;/span&gt; [tag] HEAD --pretty=format:%s&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件&lt;/span&gt;&lt;br/&gt;$ git &lt;span&gt;log&lt;/span&gt; [tag] HEAD --grep feature&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 显示某个文件的版本历史，包括文件改名&lt;/span&gt;&lt;br/&gt;$ git &lt;span&gt;log&lt;/span&gt; --follow [file]&lt;br/&gt;$ git whatchanged [file]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 显示指定文件相关的每一次diff&lt;/span&gt;&lt;br/&gt;$ git &lt;span&gt;log&lt;/span&gt; -p [file]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 显示过去5次提交&lt;/span&gt;&lt;br/&gt;$ git &lt;span&gt;log&lt;/span&gt; -5 --pretty --oneline&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 显示所有提交过的用户，按提交次数排序&lt;/span&gt;&lt;br/&gt;$ git shortlog -sn&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 显示指定文件是什么人在什么时间修改过&lt;/span&gt;&lt;br/&gt;$ git blame [file]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 显示暂存区和工作区的差异&lt;/span&gt;&lt;br/&gt;$ git diff&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 显示暂存区和上一个commit的差异&lt;/span&gt;&lt;br/&gt;$ git diff --cached [file]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 显示工作区与当前分支最新commit之间的差异&lt;/span&gt;&lt;br/&gt;$ git diff HEAD&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 显示两次提交之间的差异&lt;/span&gt;&lt;br/&gt;$ git diff [first-branch]...[second-branch]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 显示今天你写了多少行代码&lt;/span&gt;&lt;br/&gt;$ git diff --shortstat &lt;span&gt;&quot;@{0 day ago}&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 显示某次提交的元数据和内容变化&lt;/span&gt;&lt;br/&gt;$ git show [commit]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 显示某次提交发生变化的文件&lt;/span&gt;&lt;br/&gt;$ git show --name-only [commit]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 显示某次提交时，某个文件的内容&lt;/span&gt;&lt;br/&gt;$ git show [commit]:[filename]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 显示当前分支的最近几次提交&lt;/span&gt;&lt;br/&gt;$ git reflog&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8、远程同步&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 克隆远程仓库&lt;/span&gt;&lt;br/&gt;$ git &lt;span&gt;clone&lt;/span&gt; [url]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 下载远程仓库的所有变动&lt;/span&gt;&lt;br/&gt;$ git fetch [remote]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 显示所有远程仓库&lt;/span&gt;&lt;br/&gt;$ git remote -v&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 显示某个远程仓库的信息&lt;/span&gt;&lt;br/&gt;$ git remote show [remote]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 增加一个新的远程仓库，并命名&lt;/span&gt;&lt;br/&gt;$ git remote add [shortname] [url]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 取回远程仓库的变化，并与本地分支合并&lt;/span&gt;&lt;br/&gt;$ git pull [remote] [branch]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 拉取远程分支，同时创建本地分支&lt;/span&gt;&lt;br/&gt;$ git fetch [remote] 远程分支名x:本地分支名x&lt;br/&gt;&lt;span&gt;# 拉取远程分支，同时创建本地分支，且切换到该分支&lt;/span&gt;&lt;br/&gt;$ git checkout -b [branch] [origin/远程分支名]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# git pull相当于以下两步&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 1、拉取远程分支&lt;/span&gt;&lt;br/&gt;$ git fetch [remote] [branch]&lt;br/&gt;&lt;span&gt;# 2、合并到当前分支&lt;/span&gt;&lt;br/&gt;git merge [remote/branch]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 上传本地指定分支到远程仓库&lt;/span&gt;&lt;br/&gt;$ git push [remote] [branch]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 强行推送当前分支到远程仓库，即使有冲突&lt;/span&gt;&lt;br/&gt;$ git push [remote] --force&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 推送所有分支到远程仓库&lt;/span&gt;&lt;br/&gt;$ git push [remote] --all&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 更新远程分支列表&lt;/span&gt;&lt;br/&gt;$ git remote update [remote] --prune&lt;br/&gt;$ git remote update [remote] -p&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 删除和远程仓库的关联&lt;/span&gt;&lt;br/&gt;$ git remote rm [remote]&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9、撤销&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 恢复暂存区的指定文件到工作区&lt;/span&gt;&lt;br/&gt;$ git checkout [file]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 恢复某个commit的指定文件到暂存区和工作区&lt;/span&gt;&lt;br/&gt;$ git checkout [commit] [file]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 恢复暂存区的所有文件到工作区&lt;/span&gt;&lt;br/&gt;$ git checkout .&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变&lt;/span&gt;&lt;br/&gt;$ git reset [file]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 重置暂存区与工作区，与上一次commit保持一致&lt;/span&gt;&lt;br/&gt;$ git reset --hard&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变&lt;/span&gt;&lt;br/&gt;$ git reset [commit]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#  回退到上一次提交&lt;/span&gt;&lt;br/&gt;$ git reset --hard HEAD^&lt;br/&gt;&lt;span&gt;# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致&lt;/span&gt;&lt;br/&gt;$ git reset --hard [commit]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 重置当前HEAD为指定commit，但保持暂存区和工作区不变&lt;/span&gt;&lt;br/&gt;$ git reset --keep [commit]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 新建一个commit，用来撤销指定commit&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 后者的所有变化都将被前者抵消，并且应用到当前分支&lt;/span&gt;&lt;br/&gt;$ git revert [commit]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 暂时将未提交的变化移除，稍后再移入&lt;/span&gt;&lt;br/&gt;$ git stash&lt;br/&gt;$ git stash pop&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;四、在开发工具中使用Git&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Git中一些操作例如&lt;code&gt;解决冲突&lt;/code&gt;、&lt;code&gt;分支比较&lt;/code&gt;等等使用图形化的操作可能会更加方便快捷。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TortoiseGit是一款不错的图形化Git工具，是一个不错的选择，下载地址：https://tortoisegit.org/download/&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5429945880938064&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPseJpOnK3BpCqOkhkJJqbVnf5ox0RAibRbPRXBopnzh4MyV9FpwSTgX5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1663&quot;/&gt;&lt;figcaption&gt;image-20201230175941903&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，使用开发工具集成Git，也是一个不错的选择。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、在IDEA中使用Git&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IDEA是当前最好用的Java开发IDE，IDEA默认集成了对Git的支持，只需要配置设置执行程序即可。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1、配置Git&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;File&lt;/code&gt; --&amp;gt; &lt;code&gt;Settings&lt;/code&gt;--&amp;gt; &lt;code&gt;Version Control&lt;/code&gt; --&amp;gt; &lt;code&gt;Git&lt;/code&gt;,修改Git执行路径为自己安装的Git路径。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6578094620868438&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsfhMPL1sviamZmn9mpAXr8ryeFqKp3DtY4GWvyCPzhbtPfabbcWEbQsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1543&quot;/&gt;&lt;figcaption&gt;image-20201226170425899&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4922322158626329&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPs5EsGJGr45K8DIgHugQIvUTtDlkeYX30ibicWOQr4MibTvicZ153nS33IFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1223&quot;/&gt;&lt;figcaption&gt;image-20201226170737431&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2、远程操作&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Idea中可以非常便捷的进行远程仓库相关的操作。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2.1、拉取代码&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过Idea可以直接拉取远程仓库的代码&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;File&lt;/code&gt; --&amp;gt; &lt;code&gt;New&lt;/code&gt; ---&amp;gt; &lt;code&gt;Project From Version Controller&lt;/code&gt; --&amp;gt; &lt;code&gt;Git&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3169456066945607&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPscBLrxxXGnJ2QwSZibYt88TPBhTc14N6fBFn8S7SyPddG5YSNBPlaXmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;956&quot;/&gt;&lt;figcaption&gt;image-20210101122023216&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2864385297845374&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPswbWAFAjrRUx1zVuF7Twl7YhFZviaTOHGWHCj1fcELXX4bEg1icpAavTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;789&quot;/&gt;&lt;figcaption&gt;image-20210101122201172&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样远程仓库的代码就克隆到了本地。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2.2、拉取远程分支&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面我们拉取的是远程仓库主干代码，我们也可以拉取远程分支代码。右下角，点开分支。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1827956989247312&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsfItCDZgTwDk0cMknbtTicspBv8A0jVd9DJzkuW6l4UfJIKic7fZuXDBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;279&quot;/&gt;&lt;figcaption&gt;image-20210101122607056&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到 &lt;code&gt;Remote Branchs&lt;/code&gt;,下面就是远程仓库的分支。点击远程分支，&lt;code&gt;Checkout As&lt;/code&gt;,就可以把远程分支拉到本地了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.637987012987013&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsrde1WvGfMXVYibPMlPbzBusVKbeYZaWS4up3dSdpVhOiaxRHgJhNr2pQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;616&quot;/&gt;&lt;figcaption&gt;image-20210101124703962&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2.3、更新代码&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在提交代码前最好先更新下远程仓库的代码到本地仓库，这样可以减少不必要的冲突，更新update可以直接通过快捷键 &lt;code&gt;Ctrl + T&lt;/code&gt;，也可以通过工具栏上按键来实现:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1801665404996215&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsibfpHrGZXia6val4tIYWXqVPPG4B8lnibTGq7njCk171C7gf8EjiaEOAeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1321&quot;/&gt;&lt;figcaption&gt;image-20210101125000452&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2.4、提交/推送代码&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在IDEA中开发好自己的代码之后如何提交到远程仓库呢？&lt;code&gt;右键项目&lt;/code&gt;--&amp;gt;&lt;code&gt;Git&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8677298311444653&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPskgQZmTvZs5TaBdO6sSrmUHs06AJMIxDKc04VEGRqFlFZHibssSTrQ1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1066&quot;/&gt;&lt;figcaption&gt;image-20210101125217192&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;1.Commit Directory&lt;/strong&gt;：commit代码(将stage区的暂存文件提交到当前分支的本地仓库，并清空stage区)，也可以push代码（把本地仓库的文件同步到远程仓库）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8478444632290786&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsBg4ibfJBSFvMfPoxIyKK1BFTHR2WIQ2ic3zsHSlg3OpAnqX5Wgh5q4ibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1183&quot;/&gt;&lt;figcaption&gt;image-20210101125736901&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Commit对应Git的Commit命令,commit到本地仓库&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Commit and Push也就是Commit和push，我们可以直接在这里commit到本地仓库之后，再push到远程仓库。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在IDEA中，我们会看到文件被标识着不同颜色：红色，绿色，蓝色。它们分别代表什么意思呢？&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;红色：未被版本控制的文件，即未添加到版本控制的文件，例如我们添加到&lt;strong&gt;ignore&lt;/strong&gt;中的文件。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;绿色：新加入版本的文件，即我们新创建的文件，还未提交到远程仓库。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;蓝色：修改过的文件，即远程仓库中已有该文件，我们这次对它进行了修改，但是还未提交。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里再接着看看几个按键的作用：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.33852544132917967&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsFTNvgmnTzujFviaS7SdULmqlF1HxBX7zAfGzL6hAro3uw0RGYo2kCjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;963&quot;/&gt;&lt;figcaption&gt;image-20210101130202600&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2.Add&lt;/strong&gt;：把本地文件从工作目录添加到本地仓库的stage区，对应Git的Add命令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3.Compare with Branch…&lt;/strong&gt;：与远程分支比较。我们提交前可以通过此功能比较下我们工作目录中代码和远程分支代码的异同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4.Show History&lt;/strong&gt;：查看历史修改版本记录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;5.Revert&lt;/strong&gt;：回滚，会将你的本地修改回滚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;6.Repository&lt;/strong&gt;：各种仓库命令。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5936599423631124&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPskWZOSIX50ebvLkspuiapOe2ZMGAh0tG60YJCuMVPAvDZFj3X6ncPia4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;694&quot;/&gt;&lt;figcaption&gt;image-20210101130400728&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3、分支管理&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3.1、新建分支&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击New Branch可以新建分支&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4369287020109689&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPs0IKDIWWz1PAvCZK1yg4GLy1BKCpMMWcHibon89HU0Q1bqoMPlNr2CzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;547&quot;/&gt;&lt;figcaption&gt;image-20210101122733992&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3.2、分支切换/比较/合并/重命名/删除&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Idea中这些功能的使用也常简单，点击分支，点击要操作的分支，就可以看到这些选项&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7368421052631579&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsicaY8EIvicLka2G9FUsXMLLhf1iaQ3W1P7zVDPJ96vZuw2re4DOGNQBqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;912&quot;/&gt;&lt;figcaption&gt;image-20210101123418491&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.4、查看提交历史&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再&lt;code&gt;Version Controller&lt;/code&gt;里&lt;code&gt;log&lt;/code&gt;可以查看提交历史&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4140030441400304&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPssLFahCQI6Lib4kRibv3tkdoWdR1qicw5vQw9Nlmk7ib3NpylibrmXXgBCUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1314&quot;/&gt;&lt;figcaption&gt;image-20210101130638650&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.5、合并（处理冲突）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面我们提了分支合并，可以从本地分支合并，也可以从远程仓库合并，一般两个并行开发的分支合并都是会有冲突，Idea中合并冲突是非常方便的。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在合并过程中发生了冲突，Idea会提示冲突，选择&lt;code&gt;Merge&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9719626168224299&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsIl7Pib77srIXKSJ6lpPZYicgQSz8ra9iape71Kickff4ibYOUiawx6PqUaSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;856&quot;/&gt;&lt;figcaption&gt;image-20210101131209085&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Idea提供了三个分栏，我们可以点击箭头，很方便地处理冲突&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5948002536461636&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsdMF49vR1MkUFWqkp1MGID2CJYmx1MXLbDITkcAChvW1cQzX1mvvHUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1577&quot;/&gt;&lt;figcaption&gt;image-20210101131313411&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果合并时没有处理，也可以在&lt;code&gt;Version Controller&lt;/code&gt;中处理&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.21986754966887417&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsrlWFDftQLjsGQicZYuPMu3WlodVxUznp2anSxHibekh3jyfTb3scickEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;755&quot;/&gt;&lt;figcaption&gt;image-20210101131750519&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、在VS Code中使用Git&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VS Code是当前最流行的前端开发工具，VS Code对Git的支持不是那么强大，但是可以通过插件来增强Git功能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1、基本使用&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.1、基本界面&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的VS Code配置了中文包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击左侧Git标识，可以看到很多的操作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7633832976445396&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPs95u4uBiaJSS9B5vm9QgiczzW3HMUbX318TtVOVowcsELhTDRSgxIXdsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;934&quot;/&gt;&lt;figcaption&gt;image-20210101133222496&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.2、文件状态&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当对文件进行修改后，有三种状态&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5746835443037974&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsnpNITOfrYxISDLNCoFG1oLh7IShtK3pibYwO1K971uGxpN0ZHkc4B7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;395&quot;/&gt;&lt;figcaption&gt;alt&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;M 是 modify 的缩写即该文件存在修改&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;D 是 delete 的缩写即该文件被删除了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;U 是 Update 的缩写即该文件是新添加&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.3、提交代码&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6398601398601399&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPs1EW0DkQ9tecEdnMghmOMTQWdYansrOM8aOr9BlhIRcR0wzCk1wXT7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;572&quot;/&gt;&lt;figcaption&gt;image-20210101134246844&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文件按钮的的意思。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果是新添加的文件，放弃修改就会提示彻底删除文件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果是删除的文件，选择放弃修改就会从仓库中恢复文件 (再也不用担心误删的文件找不到了)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;点击 + 号确认文件的修改就会提到 stash Changes 上 &lt;code&gt;(对应 git add 命令)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7319587628865979&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPskEfkt10ddjsjibGJqaJgUeK5XHKUV1xygpymcph5ibrUzuwLJsUwvStA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;485&quot;/&gt;&lt;figcaption&gt;image-20210101134415788&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;确认了文件之后，在输入框输入这次更新的内容，然后点击打勾就可以保存这一次更新了 &lt;code&gt;(对应 git commit 命令)&lt;/code&gt;如果当前所有的 Changes 都要 commit ，那可以直接输入上传的信息并且打勾就可以快速 commit 了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.4、推送代码&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完成提交以后，vscode 的左下角就会出现上箭头的数字为 1 (上箭头是 push 的更新，下箭头是可以 pull 的更新)
当然如果之前没有 push 过代码的话，这个可能会没有数字显示。这个时候就可以将代码推送到 远程仓库上了 &lt;code&gt;(对应 git push 命令)&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.7307001795332135&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsl8VicHhvkcQkJs28eh3AF4EDvsUic3vlFbz9WbcfH9jmriaIkVEbwib49g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;557&quot;/&gt;&lt;figcaption&gt;image-20210101135322345&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OK，远程仓库就可以看到我们的提交了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.33528980190755686&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsSMXiaKmNSrhBViclUfWChAiansvo6jO8GD27O9hYGjia4Mtata1zHq4OMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1363&quot;/&gt;&lt;figcaption&gt;image-20210101135531641&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.5、拉取代码&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以通过 vscode 左下角的下箭头看到仓库是否可以 拉取，然后点击菜单的 git pull 进行仓库更新 (对应 &lt;code&gt;git pull&lt;/code&gt; 命令)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.43154761904761907&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPs08cetJIXPCCV8x7J2xRgola8Nyw8Nm3peM7Fhf0eAnAAGt0CfiaGfXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;672&quot;/&gt;&lt;br/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.5、分支切换&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;vscode 可以直接在左下角创建分支，也可以切换分支。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6784722222222223&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsIKXMbKjB9vclDzibGeiclXst0cCl1ibnNxKURIicNtopX8Z5bxZsCLo7Tg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1440&quot;/&gt;&lt;figcaption&gt;image-20210101135941565&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;上面的功能满足了基本要求，如果还需要&lt;code&gt;代码比对&lt;/code&gt;，&lt;code&gt;解决冲突&lt;/code&gt;，可以选择插件，目前公认的最好用的插件是GitLens。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2、使用Git插件&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.1、安装GitLens&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打开插件商店，搜索 &lt;code&gt;GitLens&lt;/code&gt;,安装即可。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.49973780807551127&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsfPJ1jZSodPxdYurQaAy3ehWXVbTZsdwY79HhX9peaG6S1ue5S31Ckg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1907&quot;/&gt;&lt;figcaption&gt;image-20210101140524655&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.2、GitLens基本使用&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装完成之后侧边的工具栏会多出一个 git 分支图标，点击就可以查看更详细的信息了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.745583038869258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsJkMcSibPK8u3CunWy6R29XiaiaoooA9kTOHJbXSsibtQ4oGBrA8cAPAexg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;566&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一个折叠面板查看所有提交&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二个折叠面板查看当前打开文件的历史&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三个折叠面板查看分支&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第四个折叠面板查看远程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第五个折叠面板查看stash的文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第六个折叠面板查看标签&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第七个折叠面板可以比较不同的分支标签的文件区别&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时发现，每一行代码都会显示提交人和提交信息&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5202156334231806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsmkHRZjjqWjxrQLKo4oE84y9pbMBqgWt9dJjzEa8pnlG41r0XQT1M1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1113&quot;/&gt;&lt;figcaption&gt;image-20210101142124359&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.3、查看更改&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改文件后，Gitlens 侧边会有颜色块告诉你代码的更新情况：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9106529209621993&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsm3dukXMVou6ARkkvWlOIpxE1q8A7TkpLfhtBNSlqv24BVq6DKUu3ibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;582&quot;/&gt;&lt;figcaption&gt;image-20210101142959836&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在右上角点击&lt;code&gt;查看更改&lt;/code&gt;,可以查看当前文件的更改。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2669172932330827&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPs2Kk8FYzO4uRL5h2hhnNalzibgrWh2s0BvCEXOpgibJicpDygB0wAE7hDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;266&quot;/&gt;&lt;figcaption&gt;image-20210101142700430&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6095487246566383&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPs1ssZFykExvtbWiaqfRFJickKHMBA5uK4mQcJCiaiaOh9pTfibJUaa8pZ3tQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1529&quot;/&gt;&lt;figcaption&gt;image-20210101143105278&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.4、处理冲突&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VScode 内置的 git 会告诉你有冲突的文件，然后通过 Gitlens 可以快速调整冲突。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5159151193633952&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsatYSIEfSe5GvQEHGIqNroQqe6IqjJDlo0xzVwENAVSgb8R17JTNGkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1508&quot;/&gt;&lt;figcaption&gt;image-20210101145429996&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.47978793903247186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeMUNOCN9s1ouvnYvJkibQPsW53Z9QomOq8Kzn6NzPocO0JIoMmTpOwtsHXyWlfcd73YVpiaZPAoZOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1509&quot;/&gt;&lt;figcaption&gt;image-20210101145525530&lt;/figcaption&gt;&lt;/figure&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;big&gt;参考&lt;/big&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【1】：&lt;span&gt;?&lt;/span&gt;Git 从入门到放不下&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【2】：&lt;span&gt;?&lt;/span&gt;常用Git命令整理&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【3】：&lt;span&gt;?&lt;/span&gt;Git分支管理策略&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【4】：&lt;span&gt;?&lt;/span&gt;vue-blog&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【5】：《progit》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【6】：&lt;span&gt;?&lt;/span&gt;Windows配置Github、Gitee共存的Git环境&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【7】：&lt;span&gt;?&lt;/span&gt;VScode 结合git的全面使用流程（上）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【8】：&lt;span&gt;?&lt;/span&gt;VScode 结合git的全面使用流程（下）&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5baa1f9a457f12ac07040f06d02593b7</guid>
<title>一种比特级别的数据交换格式</title>
<link>https://toutiao.io/k/v6zcjxw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body id=&quot;readabilityBody&quot;&gt;
  &lt;div class=&quot;document&quot;&gt;
    
      
      &lt;div class=&quot;documentwrapper&quot;&gt;
        &lt;div class=&quot;bodywrapper&quot;&gt;
          

          &lt;div class=&quot;body&quot; role=&quot;main&quot;&gt;
            
  &lt;div class=&quot;section&quot; id=&quot;the-bit-level-data-interchange-format&quot;&gt;
&lt;h1&gt;一种比特级别的数据交换格式&lt;a class=&quot;headerlink&quot; href=&quot;#the-bit-level-data-interchange-format&quot; title=&quot;永久链接至标题&quot;&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;img alt=&quot;https://img.shields.io/badge/license-BSD3-brightgreen&quot; src=&quot;https://img.shields.io/badge/license-BSD3-brightgreen&quot;/&gt;
&lt;a class=&quot;reference external image-reference&quot; href=&quot;https://github.com/hit9/bitproto/actions?query=workflow%3A%22bitproto+ci%22&quot;&gt;&lt;img alt=&quot;https://github.com/hit9/bitproto/workflows/bitproto%20ci/badge.svg&quot; src=&quot;https://github.com/hit9/bitproto/workflows/bitproto%20ci/badge.svg&quot;/&gt;&lt;/a&gt;
&lt;a class=&quot;reference external image-reference&quot; href=&quot;https://bitproto.readthedocs.io/en/latest/?badge=latest&quot;&gt;&lt;img alt=&quot;https://readthedocs.org/projects/bitproto/badge/?version=latest&quot; src=&quot;https://readthedocs.org/projects/bitproto/badge/?version=latest&quot;/&gt;&lt;/a&gt;
&lt;a class=&quot;reference external image-reference&quot; href=&quot;https://saythanks.io/to/hit9@icloud.com&quot;&gt;&lt;img alt=&quot;https://img.shields.io/badge/Say%20Thanks-!-1EAEDB.svg&quot; src=&quot;https://img.shields.io/badge/Say%20Thanks-!-1EAEDB.svg&quot;/&gt;&lt;/a&gt;
&lt;div class=&quot;section&quot; id=&quot;introduction&quot;&gt;

&lt;p&gt;bitproto 是一种快速的、轻量的、易用的用来序列化结构化数据的比特级别数据交换格式。&lt;/p&gt;
&lt;p&gt;bitproto 的协议描述语法和著名的 &lt;a class=&quot;reference external&quot; href=&quot;https://developers.google.com/protocol-buffers&quot;&gt;protocol buffers&lt;/a&gt; 类似，只不过是比特级别的:&lt;/p&gt;
&lt;div class=&quot;highlight-bitproto notranslate&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span/&gt;&lt;span class=&quot;kd&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;ni&quot;&gt;Data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint3&lt;/span&gt; &lt;span class=&quot;ni&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint3&lt;/span&gt; &lt;span class=&quot;ni&quot;&gt;bit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint5&lt;/span&gt; &lt;span class=&quot;ni&quot;&gt;level&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint4&lt;/span&gt; &lt;span class=&quot;ni&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint11&lt;/span&gt; &lt;span class=&quot;ni&quot;&gt;interchange&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;6&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint6&lt;/span&gt; &lt;span class=&quot;ni&quot;&gt;format&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;7&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 32 bits =&amp;gt; 4B&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上面的 &lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Data&lt;/span&gt;&lt;/code&gt; 是一个消息，它由 7 个字段构成，在编码后会占用 4 个字节。&lt;/p&gt;
&lt;p&gt;这一张图片展示了编码后的字节流中数据字段的分布情况:&lt;/p&gt;
&lt;img alt=&quot;_images/data-encoding-sample.png&quot; class=&quot;align-center&quot; src=&quot;_images/data-encoding-sample.png&quot;/&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;features&quot;&gt;

&lt;ul class=&quot;simple&quot;&gt;
&lt;li&gt;&lt;p&gt;支持比特级别的数据序列化&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;支持协议的 &lt;a class=&quot;reference internal&quot; href=&quot;language.html#language-guide-extensibility&quot;&gt;&lt;span class=&quot;std std-ref&quot;&gt;扩展性&lt;/span&gt;&lt;/a&gt;、向后兼容设计&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl class=&quot;simple&quot;&gt;
&lt;dt&gt;非常容易 &lt;a class=&quot;reference internal&quot; href=&quot;quickstart.html#quickstart&quot;&gt;&lt;span class=&quot;std std-ref&quot;&gt;上手&lt;/span&gt;&lt;/a&gt;:&lt;/dt&gt;&lt;dd&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a class=&quot;reference internal&quot; href=&quot;language.html#language-guide&quot;&gt;&lt;span class=&quot;std std-ref&quot;&gt;协议的语法&lt;/span&gt;&lt;/a&gt; 类似著名的 protobuf.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成的代码具有非常简单的 API&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class=&quot;simple&quot;&gt;
&lt;dt&gt;支持以下编程语言&lt;/dt&gt;&lt;dd&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;极快的编解码性能 (&lt;a class=&quot;reference internal&quot; href=&quot;performance.html#performance-benchmark&quot;&gt;&lt;span class=&quot;std std-ref&quot;&gt;性能压测&lt;/span&gt;&lt;/a&gt;).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;code-example&quot;&gt;
&lt;h2&gt;代码示例&lt;a class=&quot;headerlink&quot; href=&quot;#code-example&quot; title=&quot;永久链接至标题&quot;&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;一个在 C 语言中编码 bitproto 消息的代码示例:&lt;/p&gt;
&lt;div class=&quot;highlight-c notranslate&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span/&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Data&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BYTES_LENGTH_DATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;EncodeData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;下面的是一个解码的例子:&lt;/p&gt;
&lt;div class=&quot;highlight-c notranslate&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span/&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Data&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;DecodeData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;非常简单，不是吗?&lt;/p&gt;
&lt;p&gt;对于 Go 和 Python 语言，bitproto 的编解码的代码也是类似的。你可以前往 &lt;a class=&quot;reference internal&quot; href=&quot;quickstart.html#quickstart&quot;&gt;&lt;span class=&quot;std std-ref&quot;&gt;快速开始的文档&lt;/span&gt;&lt;/a&gt; 获取进一步的引导内容。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;why-bitproto&quot;&gt;
&lt;h2&gt;为什么会有 bitproto ?&lt;a class=&quot;headerlink&quot; href=&quot;#why-bitproto&quot; title=&quot;永久链接至标题&quot;&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;已经有 protobuf 了，为什么要做 bitproto 呢?&lt;/p&gt;
&lt;div class=&quot;section&quot; id=&quot;origin&quot;&gt;

&lt;p&gt;bitproto 最初是我在和微型控制器上的嵌入式程序打交道的时候创作的。在嵌入式的环境中，经常会有许多开发上的约束:&lt;/p&gt;
&lt;ul class=&quot;simple&quot;&gt;
&lt;li&gt;&lt;p&gt;紧凑的通信量&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;受限制的固件大小&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最好不要有动态内存的使用&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Protobuf 天生不是为了嵌入式领域的，它没有开箱即用的纯 C 语言的支持。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;scenario&quot;&gt;

&lt;p&gt;对于以下的场景，是推荐使用 bitproto ，而非 protobuf 的:&lt;/p&gt;

&lt;p&gt;对于其他场景，则推荐考虑 protobuf ，而不是 bitproto .&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;vs-protobuf&quot;&gt;
&lt;h3&gt;和 Protobuf 相比&lt;a class=&quot;headerlink&quot; href=&quot;#vs-protobuf&quot; title=&quot;永久链接至标题&quot;&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;bitproto 和 protobuf 的不同点有:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;bitproto 支持比特级别的数据序列化，类似 C 语言中的 &lt;a class=&quot;reference external&quot; href=&quot;https://en.wikipedia.org/wiki/Bit_field&quot;&gt;bit fields&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;bitproto 不使用任何动态内存。很少有 &lt;a class=&quot;reference external&quot; href=&quot;https://github.com/protocolbuffers/protobuf/blob/master/docs/third_party.md&quot;&gt;protobuf 的 C 语言实现&lt;/a&gt; 支持这点，除了 &lt;a class=&quot;reference external&quot; href=&quot;https://jpa.kapsi.fi/nanopb&quot;&gt;nanopb&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;bitproto 不支持变长数据，所有类型都是定长的.&lt;/p&gt;
&lt;p&gt;bitproto 不会把任何类型信息或者反射信息编码到字节流中。它只编码数据本身，编码后的数据排列就和内存中一样，定长且不带有任何字节缝隙，就像在C 语言中设置 &lt;a class=&quot;reference external&quot; href=&quot;https://stackoverflow.com/a/11772340&quot;&gt;结构体的对齐为 1 字节&lt;/a&gt; 一样。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Protobuf 对于 &lt;a class=&quot;reference external&quot; href=&quot;https://developers.google.com/protocol-buffers/docs/overview#backwards_compatibility&quot;&gt;向后兼容&lt;/a&gt; 的特性支持的很好。对于 bitproto，直到 &lt;a class=&quot;reference internal&quot; href=&quot;changelog.html#version-0-4-0&quot;&gt;&lt;span class=&quot;std std-ref&quot;&gt;v0.4.0&lt;/span&gt;&lt;/a&gt; 这都是其一个主要的缺点。自从这个版本之后，bitproto 通过在编码后的字节流头部新增两个字节的方式实现了 &lt;a class=&quot;reference internal&quot; href=&quot;language.html#language-guide-extensibility&quot;&gt;&lt;span class=&quot;std std-ref&quot;&gt;扩展性&lt;/span&gt;&lt;/a&gt; 的支持，这两个字节存储了相关消息的占用字节数的多少。这个设计打破了 bitproto 传统的编码结构的设计，因为新增了一些对于编码大小的反射信息，因此这个功能被设计为可选的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;shortcomes&quot;&gt;

&lt;p&gt;已知的 bitproto 的缺点如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;bitproto 不支持变长数据类型。 举例来说，一个 &lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;uint37&lt;/span&gt;&lt;/code&gt; 类型的数据永远在编码后占用 37 个比特，即使你赋值它一个诸如 &lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;1&lt;/span&gt;&lt;/code&gt; 这样很小的值。&lt;/p&gt;
&lt;p&gt;这意味着，如果有意义的数据占用类型的占比较小的时候，编码后的数据中会有很多零字节。比如，当一个大小为 &lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;n&lt;/span&gt;&lt;/code&gt; 个字节的类型只被使用了其中一个字节的时候，会有 &lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;n-1&lt;/span&gt;&lt;/code&gt; 个字节会是零字节。&lt;/p&gt;
&lt;p&gt;一般来说，我们并不特别关心这个问题，因为在嵌入式设备上的通信量一般不会有多少字节。这里的协议自身一般要设计地紧凑一些。如果你真的比较关心这个问题，可以考虑使用 &lt;a class=&quot;reference external&quot; href=&quot;https://zlib.net/&quot;&gt;zlib&lt;/a&gt; 类似的压缩机制，在消息编码后进行一次协议压缩。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;bitproto 无法同时提供 &lt;a class=&quot;reference internal&quot; href=&quot;performance.html#performance-optimization-mode&quot;&gt;&lt;span class=&quot;std std-ref&quot;&gt;最佳的性能&lt;/span&gt;&lt;/a&gt; 和 &lt;a class=&quot;reference internal&quot; href=&quot;language.html#language-guide-extensibility&quot;&gt;&lt;span class=&quot;std std-ref&quot;&gt;扩展性能力&lt;/span&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;bitproto 中设计了一种 &lt;a class=&quot;reference internal&quot; href=&quot;performance.html#performance-optimization-mode&quot;&gt;&lt;span class=&quot;std std-ref&quot;&gt;优化模式&lt;/span&gt;&lt;/a&gt; ，这个模式下，编译器会直接生成直白的编解码的语句，以达到更好的编解码性能。因为 bitproto 中所有的类型都是定长的，因此我们可以在代码生成阶段就清楚地知道如何对其进行编解码。压测的结果表明，这个模式带来了巨大的性能提升，不过目前为止我还没有想到一个办法来支持 bitproto 的扩展性功能和这个性能优化模式一起工作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;


          &lt;/div&gt;
          
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;p class=&quot;clearer&quot;/&gt;
  &lt;/div&gt;
    

    

    
  &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b708db62a7d97f5e8761529087efef88</guid>
<title>Redis 集群搭建很 easy</title>
<link>https://toutiao.io/k/m4mw3sc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;h3&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;哨兵模式虽然让读写分离更加高可用，但单台服务器由于本身的内存和CPU瓶颈，对于高并发和大数据业务的应用场景还是远远不能满足；对于这种情况，有点经验的小伙伴会毫不犹豫的想到集群，搞他好几个节点，负载均衡再加上故障转移，岂不美哉。是的，就是这个理，接下来玩玩。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;正文&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;集群&lt;/strong&gt;，相信这个词小伙伴应该听的耳朵起茧子了吧；多搞几台服务器，让请求/命令平均分发到各个服务器，避免单台服务器承载过大压力；对于Redis集群来说，为了实现自动故障转移，还需要在每个主节点上增加一个或多个从节点，当主节点发生故障时，从节点自动补上，实现高可用。&lt;/p&gt;&lt;p&gt;总的来说，Redis集群有以下作用：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;多主节点的实现可以&lt;strong&gt;应对高并发场景&lt;/strong&gt;，并发量增大，节点可以随时扩展满足需求；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;多主节点的实现可以&lt;strong&gt;存储更多的数据&lt;/strong&gt;，因为数据均匀分布到各个节点；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;多主节点搭配多从节点的实现让&lt;strong&gt;高可用更加稳定&lt;/strong&gt;，即当有主节点发生故障时，对应下面的从节点会升级为主节点，正常提供功能；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;老规矩不变，一边实操一边总结，接下来搭建一个3主3从的集群，这是最简单的。&lt;strong&gt;Redis集群中最少需要3个主节点&lt;/strong&gt;，再加上为了实现高可用，每个主节点至少得跟一个从节点，不然一个主节点挂了，找不到完整的数据，整个集群就不能用了；至于为什么会找不到完整的数据，下面会聊到。&lt;/p&gt;&lt;p&gt;接下来要搭建的集群环境如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4256410256410256&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qQ1zuvjsChQGMXn5rDBSaZwDJ9AibYEibtQUlE7QADIW0W9LxKETojVKZicLVYV9VcC0ezFJJOFKeNIxOn1LL3mXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;585&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;p&gt;简要说明：&lt;/p&gt;&lt;p&gt;这里集群方案使用redis-cli自动指定主从关系(小伙伴的主从关系可能会和我这不一样哦)，也可以手动指定；反正思路都一样；&lt;/p&gt;&lt;p&gt;以下演示在同一台机器上，通过端口区分各个节点；在实际开发中，一般都是用不同的服务器。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;案例演示&lt;/span&gt;&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;准备六个节点的配置文件，开启集群相关配置&lt;/strong&gt;；&lt;/p&gt;&lt;p&gt;拷贝最初默认的配置文件，然后进行更改，主要更改以下项：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;port 6370 &lt;span&gt;# 指定Redis节点端口&lt;/span&gt;&lt;br/&gt;pidfile /var/run/redis_6370.pid &lt;span&gt;# 指定对应进程文件&lt;/span&gt;&lt;br/&gt;dbfilename dump6370.rdb &lt;span&gt;# 每个节点的rdb持久化文件&lt;/span&gt;&lt;br/&gt;cluster-enabled yes &lt;span&gt;# 开启集群，这个比较重要&lt;/span&gt;&lt;br/&gt;cluster-config-file nodes-6370.conf &lt;span&gt;#指定每个节点的集群配置文件，这个比较重要&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上配置文件内容在其他节点(6370,6371,6380,6381,6390,6391)都需要进行修改，只是将其中6370改为对应节点的端口即可，目的就是为了不同节点使用不同端口并区分用到的不同文件即可；比如需要修改6371节点的配置文件如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;port 6371 &lt;span&gt;# 指定Redis节点端口&lt;/span&gt;&lt;br/&gt;pidfile /var/run/redis_6371.pid &lt;span&gt;# 指定对应进程文件&lt;/span&gt;&lt;br/&gt;dbfilename dump6371.rdb &lt;span&gt;# 每个节点的rdb持久化文件&lt;/span&gt;&lt;br/&gt;cluster-enabled yes &lt;span&gt;# 开启集群，这个比较重要&lt;/span&gt;&lt;br/&gt;cluster-config-file nodes-6371.conf &lt;span&gt;#指定每个节点的集群配置文件，这个比较重要&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中&lt;strong&gt;cluster-enabled&lt;/strong&gt;和&lt;strong&gt;cluster-config-file&lt;/strong&gt;是集群配置的重点。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;启动六个节点，刚开始各个节点是相互独立的&lt;/strong&gt;；&lt;/p&gt;&lt;p&gt;准备好配置文件之后，就可以使用redis-server指定配置文件启动节点啦，如果节点多，小伙伴可以编写脚本哦；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;./redis-server ZoeCluster/redis6370.conf &lt;span&gt;# 启动6370节点&lt;/span&gt;&lt;br/&gt;./redis-server ZoeCluster/redis6371.conf &lt;span&gt;# 启动6371节点&lt;/span&gt;&lt;br/&gt;./redis-server ZoeCluster/redis6380.conf &lt;span&gt;# 启动6380节点&lt;/span&gt;&lt;br/&gt;./redis-server ZoeCluster/redis6381.conf &lt;span&gt;# 启动6381节点&lt;/span&gt;&lt;br/&gt;./redis-server ZoeCluster/redis6390.conf &lt;span&gt;# 启动6390节点&lt;/span&gt;&lt;br/&gt;./redis-server ZoeCluster/redis6391.conf &lt;span&gt;# 启动6391节点&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启动效果如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.34392523364485983&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qQ1zuvjsChQGMXn5rDBSaZwDJ9AibYEibtCiak9JBXuAmYeRCZWnRYjplIYUC2QGLgo3gxKQgznic7Ps3HBgvZjOpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1070&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;p&gt;这样只是将各个节点启动起来，集群关系还没创建呢，如果不信，可以使用redis-cli连接任意一个节点查看集群信息，如下：&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4627151051625239&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qQ1zuvjsChQGMXn5rDBSaZwDJ9AibYEibtCHAetSrvbMibwMP8VLrBGcTh5HRSPsraIyEuN7V9Z2ictQWLsXEjIk6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;523&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;如上图，cluster-size为0，集群的关键，槽也还没有分配；那接下来肯定是要将各节点的集群关系搞起来；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;建立节点集群关系&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;由于我使用的Redis版本是5.0，直接可以使用&lt;strong&gt;redis-cli&lt;/strong&gt;就可以进行集群搭建，在此版本之前都推荐使用redis-trib.rb进行相关操作，这个是一个Ruby脚本，需要安装相关环境，小伙伴可以下来尝试；&lt;/p&gt;&lt;p&gt;使用命令如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;./redis-cli --cluster create --cluster-replicas 1 127.0.0.1:6370 127.0.0.1:6380 127.0.0.1:6390 127.0.0.1:6371 127.0.0.1:6381 127.0.0.1:6391&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参数简介：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;-- cluster&lt;/strong&gt; : 指定是用于创建集群环境；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;-a&lt;/strong&gt;：密码，即如果有密码，可以通过-a传参，这里没有设置密码；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;--cluster-replicas&lt;/strong&gt;：这里设置为1, 用于配置主节点上的从节点数，1就代表一主一从，2就代表一主二从，依次类推；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;后面的是节点IP:节点端口&lt;/strong&gt;，一般前面的是主节点，后面的是从节点；&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5256241787122208&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qQ1zuvjsChQGMXn5rDBSaZwDJ9AibYEibtCgspickZWrRVMc4dJcdXYibOIYQXSJZicbxkWTkT4lyJj1WWV7KN0szLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;761&quot;/&gt;&lt;br/&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;p&gt;如果同意集群方案，然后就开始进行相关操作，如下：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6461748633879781&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qQ1zuvjsChQGMXn5rDBSaZwDJ9AibYEibtpVGql3GJlhoeXcaqPd7w7c3MyDbBhsU2mUUiaMVsWSwUDJvIh96oHzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;br/&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;p&gt;同样，可以连接到任意一个节点，查看集群情况，如下：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.751937984496124&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qQ1zuvjsChQGMXn5rDBSaZwDJ9AibYEibtNVWeiaUHtXicsOl1JqkLiae6BC9FseMWvjaFZVo4XcdjQ6D8niarFwTOlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;645&quot;/&gt;&lt;br/&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;p&gt;注：关于主从节点之间的主从复制过程就不在这说了，和之前说过的主从复制一样；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;演示访问操作&lt;/strong&gt;；&lt;/p&gt;&lt;p&gt;使用redis-cli连接任意节点写入数据，如果不指定集群连接的话，会写入数据失败，如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.160676532769556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qQ1zuvjsChQGMXn5rDBSaZwDJ9AibYEibtFN8ibRQHzrY5kplcq4am540YgbpeicjRIyLsURiaibjSibiaKuO7q7r9Mic2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;473&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;p&gt;由于集群环境下，数据的存储位置是根据Key来计算而来的(这里牵涉到一致性哈希算法)，使得数据可以均匀分配到各节点上，所以在redis-cli连接的时候需要指定集群模式，如下：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.18149466192170818&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qQ1zuvjsChQGMXn5rDBSaZwDJ9AibYEibtUa2KAzicPLjOUcbzl5GKc0AMHutrJK9VweibVic1gNPuKnoicSkT7XDzMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;562&quot;/&gt;&lt;br/&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;p&gt;如上图所示，指定集群模式之后就可以正常存取了；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;故障演示&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;既然集群环境，肯定少不了要好好测测；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;模拟从节点挂掉&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;找个从节点停掉试试，这里停掉6371节点，根据创建集群信息知道，它的主节点是6390；&lt;/p&gt;&lt;p&gt;主节点显示从节点断开连接，看看它的主节点反应：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.08100929614873838&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qQ1zuvjsChQGMXn5rDBSaZwDJ9AibYEibtTRnjq4pDfMtW003rmMIF22obdYtJKrIa2Yic4Y7CDAp6WCENUdCrHXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;753&quot;/&gt;&lt;br/&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;p&gt;其他集群节点只是将从节点标记为failing状态，即下线状态，如下：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.077733860342556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qQ1zuvjsChQGMXn5rDBSaZwDJ9AibYEibtRNCljcXOAsD7NaDK7yAOiaMvY8fCos0MXujmhxI3xyaPAIovfI9Sgnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;759&quot;/&gt;&lt;br/&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;p&gt;对于存取数据也不受影响，这里就不截图了，小伙伴自行尝试吧；&lt;/p&gt;&lt;p&gt;当故障的从节点6371重新连上时，主节点恢复主从关系，并进行主从复制操作；其他集群节点会清除原来标记的下线状态，将其改为上线；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;模拟主节点挂掉&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;这里就手动将6390这个节点停掉，会有怎样的反应呢？&lt;/p&gt;&lt;p&gt;自身从节点会&lt;strong&gt;每隔一秒检测连接&lt;/strong&gt;，如果超时(默认是15秒)，&lt;strong&gt;会选举从节点做为集群的主节点来提供服务&lt;/strong&gt;，如下图：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6972477064220184&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qQ1zuvjsChQGMXn5rDBSaZwDJ9AibYEibthwcA5LGWC6QPq3SnAVtkWmXyNRvWa5NMGdib6dgHWB5nicy2IawKGoBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;763&quot;/&gt;&lt;br/&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;p&gt;数据存取最终还是不受影响；&lt;/p&gt;&lt;p&gt;对于其他集群节点，将故障节点标记为failing，让新上任的主节点提供服务，如下图：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.1874180865006553&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qQ1zuvjsChQGMXn5rDBSaZwDJ9AibYEibtR2IPDu32D0kqicNic4SojwVialAzyHlQVSQQTrXicr8eGWMk9KMvxGwNOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;763&quot;/&gt;&lt;br/&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;p&gt;存取数据也是不受影响的；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;挂掉的主节点6390如果恢复，那它只能变为6371的从节点啦，并进行相关主从复制操作&lt;/strong&gt;；而集群的其他节点只是将其原有的Fail状态清除，表示可以正常连接；&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Redis集群就是这样简单，只要思路对，就是手工活；小伙伴可以编写脚本自动执行哦；&lt;/p&gt;&lt;p&gt;接下来说说集群数据的存储；&lt;/p&gt;&lt;h4&gt;&lt;span&gt;数据存储简单分析&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;在Redis集群环境中，数据的存储位置是根据对Key的Hash计算进行指定的；Redis集群为了在节点改变时保证数据分布均匀，引入了槽(slot)作为迁移的基本单位，槽解耦了数据和实际节点的关系，使得实际节点数的改变对系统影响较小；&lt;/p&gt;&lt;p&gt;在整个集群中，&lt;strong&gt;槽(slot)总共有16384，会将其均匀分配到集群的主节点上&lt;/strong&gt;，其中每一份槽对应一个存储空间(这里的存储空间可以理解为一个容器，是可以存很多数据的)，以上集群环境的槽分配如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.21913043478260869&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qQ1zuvjsChQGMXn5rDBSaZwDJ9AibYEibt8w357o9Dibic0OcL8E6l9BwT451r6B3xiavvJvpGKJyvBBCM28MqBMibeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1150&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;p&gt;存储数据的过程，如下：&lt;/p&gt;&lt;p&gt;连接6380主节点，执行如下操作：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.15849056603773584&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qQ1zuvjsChQGMXn5rDBSaZwDJ9AibYEibtdp49uOxKxooOrevwZEGzAf8AIO2ryljxMsSI5dG6W0gqMnPszLwSHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;530&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;p&gt;具体过程如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6013289036544851&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qQ1zuvjsChQGMXn5rDBSaZwDJ9AibYEibt7GeUEpmu1ictzxwtTWneNj4k2hFHDODRCjGzyCc9tS5lZYibgibibwdn3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;602&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;简要说明：&lt;/strong&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;客户端发起命令；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;服务器将Key进行CRC16计算，并与总槽位计算出Key需要存储的位置；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;这里模拟的Key为zoe，计算出的槽位为14588，不在6380这个节点上，集群节点会将其重定向到对应槽位的节点上；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;然后找到6371上的14588槽位进行数据存储；（注，这里的6371已经是主节点了，因为上面做过一次故障转移模拟）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;那集群节点是如何知道其他节点的槽范围和其他信息呢？&lt;/p&gt;&lt;p&gt;那是因为各节点之间有通讯，通讯端口是对应的redis端口+10000，比如节点6371的集群通讯端口为16371（如果多台机器，别忘了防火墙放开这个端口哦），可以通过&lt;strong&gt;cluster nodes&lt;/strong&gt;看到，如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2070524412296564&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qQ1zuvjsChQGMXn5rDBSaZwDJ9AibYEibtLFIV1jpvicMDnSpttMg8RtgiatUtMffJvPJKUkQ3Gvg4Q0HlSicJOMEkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1106&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;p&gt;并且将各节点的信息保存在自己对应的集群配置文件中，这个集群文件名是通过配置项&lt;strong&gt;cluster-config-file&lt;/strong&gt;指定的，在集群节点启动时会检查该文件是否存在，如果不存在，会自动创建，如果存在，就加载里面的相关配置信息；里面有哪些信息，随便找个节点的配置文件看一下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2321270962047661&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qQ1zuvjsChQGMXn5rDBSaZwDJ9AibYEibtPj1iaViblBAx8feq4T9htzicHs7ic2GMwwhTMCuddictCDMHvnqSFWpROLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1133&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;p&gt;如上图所示，各节点的配置文件中记录了其他节点的主从关系，分配的槽位，各节点的状态；这样的话，集群关系就算重新启动也还存在。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;集群伸缩(节点增删)演示&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;在实际应用场景中，会根据业务需要，对集群进行伸缩，即节点的增删；业务并发大了加节点进行扩展，  节点需要调整时可能需要进节点删除；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;加节点&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;这里进行节点扩展，加一个6360主节点，6361作为6360的从节点；参照以上集群搭建时配置文件更改，然后将其都启动，如下：&lt;/p&gt;&lt;p&gt;6360节点&lt;/p&gt;&lt;pre&gt;&lt;code&gt;port 6360 &lt;span&gt;# 指定Redis节点端口&lt;/span&gt;&lt;br/&gt;pidfile /var/run/redis_6360.pid &lt;span&gt;# 指定对应进程文件&lt;/span&gt;&lt;br/&gt;dbfilename dump6360.rdb &lt;span&gt;# 每个节点的rdb持久化文件&lt;/span&gt;&lt;br/&gt;cluster-enabled yes &lt;span&gt;# 开启集群，这个比较重要&lt;/span&gt;&lt;br/&gt;cluster-config-file nodes-6360.conf &lt;span&gt;#指定每个节点的集群配置文件，这个比较重要&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;6361节点&lt;/p&gt;&lt;pre&gt;&lt;code&gt;port 6361 &lt;span&gt;# 指定Redis节点端口&lt;/span&gt;&lt;br/&gt;pidfile /var/run/redis_6361.pid &lt;span&gt;# 指定对应进程文件&lt;/span&gt;&lt;br/&gt;dbfilename dump6361.rdb &lt;span&gt;# 每个节点的rdb持久化文件&lt;/span&gt;&lt;br/&gt;cluster-enabled yes &lt;span&gt;# 开启集群，这个比较重要&lt;/span&gt;&lt;br/&gt;cluster-config-file nodes-6361.conf &lt;span&gt;#指定每个节点的集群配置文件，这个比较重要&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;两个节点都启动，然后将6360加入到集群主节点中，执行以下命令：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;./redis-cli --cluster add-node 127.0.0.1:6360 127.0.0.1:6370&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注：其中127.0.0.1:6360是需要加入的新增节点，127.0.0.1:6370是现有集群中的任意一个节点；&lt;/p&gt;&lt;p&gt;可以通过以下命令检测集群状态，如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;./redis-cli --cluster check 127.0.0.1:6370  &lt;span&gt;# 后面的地址是任意的集群节点&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到6360已经加入到集群环境中，但现在还没有从节点和槽分配，所以接下来先将6361作为6360的从节点加入，如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;./redis-cli --cluster add-node --cluster-slave --cluster-master-id eaa814dc56beb0d5edb6a4fbb14f1384e78d4764 127.0.0.1:6361 127.0.0.1:6370 &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参数说明：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;--cluster-slave :  意思就是加入的是从节点；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;--cluster-master-id：后面紧跟主节点的id，这里就是6360的节点id；通过cluster nodes可以查看到节点id；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;127.0.0.1:6361：需要加入的从节点；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;127.0.0.1:6370：现有集群的任意主节点；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;现在还差槽分配了，如果需要直接将16384个槽平均分配到所有节点话，直接执行以下命令即可：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;./redis-cli --cluster rebalance --cluster-threshold 1 --cluster-use-empty-masters 127.0.0.1:6370&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用命令./redis-cli --cluster check 127.0.0.1:6370查看分配结果，如下图，只截了部分：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4025974025974026&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qQ1zuvjsChQGMXn5rDBSaZwDJ9AibYEibtjjPZyy9cgOvia1zukwsEBBsPrl47lwhqTb7LnYKEOfJSSOd1g3Du0EQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;847&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;p&gt;如果不想均匀分配，根据自定义需要进行配置，可以执行以下命令，会提示一步一步配置；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;./redis-cli --cluster reshard 127.0.0.1:6360 &lt;span&gt;#后面是新加入的主节点 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 也可以执行以下指令直接配置想要的数据&lt;/span&gt;&lt;br/&gt;./redis-cli --cluster reshard --cluster-from all --cluster-to 需要分配槽的节点id --cluster-slots 1000 --cluster-yes 127.0.0.1:6370 &lt;span&gt;# 1000 指分配的槽数&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里就不截图演示了，留给小伙伴自己动手操作吧；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;删除节点&lt;/strong&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;先对节点进行分片工作，防止数据丢失，即将指定节点上的槽分配到其他节点；&lt;br/&gt;&lt;code&gt;./redis-cli --cluster reshard 要删除节点ip:port&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;移除节点，推荐先删除从节点，再删除主节点；&lt;/p&gt;&lt;p&gt;&lt;code&gt;./redis-cli --cluster del-node 节点ip:port 节点id&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;&lt;span&gt;集群配置项&lt;/span&gt;&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;cluster-enabled(是否开启集群模式)&lt;/strong&gt;：设置为yes，将该节点开启为集群模式；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;cluster-config-file(设置每个集群节点对应的配置文件名称)&lt;/strong&gt;：文件是自动生成的，不用手动创建；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;cluster-node-timeout(设置超时时间，即集群节点不可用的最大时间，如果超过这个时间就认为该节点不可用)&lt;/strong&gt;：默认为15000(以毫秒为单位)；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;cluster-migration-barrier(配置一个主机最少可用的从机的个数)&lt;/strong&gt;：默认是1,表示一个主机的从机迁移之后，至少得有一个从机可用，否则不进行节点迁移；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;cluster-require-full-coverage(配置集群服务的可用性)&lt;/strong&gt;：默认yes开启，即集群没完全覆盖所有slot，集群就挂了；设置为no，就算槽没有全分配，也能提供服务，需要自己保证槽分配；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;到这集群的搭建就完啦，本来想着写着很简单的，没想到又干了4000字；对于集群，使用有一些限制，比如Keys命令只能针对当前节点，需要针对多节点的情况进行处理；集群中各节点只支持db0数据库，其他数据库不支持等等；所以使用要注意哦，后续抽时间单独整理一篇注意事项吧，篇幅有点长，不继续聊啦；  下篇说说熟悉的缓存穿透、缓存击穿、缓存雪崩吧；&lt;/p&gt;&lt;p&gt;一个被程序搞丑的帅小伙，关注&quot;Code综艺圈&quot;，跟我一起学~~~&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7265826b4cf7232b2813d6ef71363c9b</guid>
<title>etcd：从应用场景到实现原理的全方位解读（修订版）</title>
<link>https://toutiao.io/k/u032bu3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;article-typo&quot; data-v-73a3988a=&quot;&quot;&gt;
&lt;h2 id=&quot;heading0&quot; data-id-_70babbacb6e1=&quot;1&quot;&gt;经典应用场景&lt;/h2&gt;
&lt;p&gt;要问 etcd 是什么？很多人第一反应可能是一个键值存储仓库，却没有重视官方定义的后半句，用于配置共享和服务发现。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A highly-available key value store for shared configuration and service discovery.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实际上，etcd 作为一个受到 ZooKeeper 与 doozer 启发而催生的项目，除了拥有与之类似的功能外，更专注于以下四点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单：基于 HTTP+JSON 的 API 让你用 curl 就可以轻松使用。&lt;/li&gt;
&lt;li&gt;安全：可选 SSL 客户认证机制。&lt;/li&gt;
&lt;li&gt;快速：每个实例每秒支持一千次写操作。&lt;/li&gt;
&lt;li&gt;可信：使用 Raft 算法充分实现了分布式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;随着云计算的不断发展，分布式系统中涉及到的问题越来越受到人们重视。受阿里中间件团队对&lt;a href=&quot;http://jm-blog.aliapp.com/?p=1232&quot; rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot;&gt; ZooKeeper 典型应用场景一览&lt;/a&gt;一文的启发，笔者根据自己的理解也总结了一些 etcd 的经典使用场景。让我们来看看 etcd 这个基于 Raft 强一致性算法的分布式存储仓库能给我们带来哪些帮助。&lt;/p&gt;
&lt;p&gt;值得注意的是，分布式系统中的数据分为控制数据和应用数据。使用 etcd 的场景默认处理的数据都是控制数据，对于应用数据，只推荐数据量很小，但是更新访问频繁的情况。&lt;/p&gt;
&lt;h3 id=&quot;heading1&quot; data-id-_bfaa1f32e9e3=&quot;1&quot;&gt;场景一：服务发现（Service Discovery）&lt;/h3&gt;
&lt;p&gt;服务发现要解决的也是分布式系统中最常见的问题之一，即在同一个分布式集群中的进程或服务，要如何才能找到对方并建立连接。本质上来说，服务发现就是想要了解集群中是否有进程在监听 udp 或 tcp 端口，并且通过名字就可以查找和连接。要解决服务发现的问题，需要有下面三大支柱，缺一不可。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个强一致性、高可用的服务存储目录。基于 Raft 算法的 etcd 天生就是这样一个强一致性高可用的服务存储目录。&lt;/li&gt;
&lt;li&gt;一种注册服务和监控服务健康状态的机制。用户可以在 etcd 中注册服务，并且对注册的服务设置&lt;code&gt;key TTL&lt;/code&gt;，定时保持服务的心跳以达到监控健康状态的效果。&lt;/li&gt;
&lt;li&gt;一种查找和连接服务的机制。通过在 etcd 指定的主题下注册的服务也能在对应的主题下查找到。为了确保连接，我们可以在每个服务机器上都部署一个 Proxy 模式的 etcd，这样就可以确保能访问 etcd 集群的服务都能互相连接。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://static001.infoq.cn/resource/image/1b/7d/1beabef5a1168cdc43766903e65f907d.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 1 服务发现示意图&lt;/p&gt;
&lt;p&gt;下面我们来看服务发现对应的具体场景。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微服务协同工作架构中，服务动态添加。随着 Docker 容器的流行，多种微服务共同协作，构成一个相对功能强大的架构的案例越来越多。透明化的动态添加这些服务的需求也日益强烈。通过服务发现机制，在 etcd 中注册某个服务名字的目录，在该目录下存储可用的服务节点的 IP。在使用服务的过程中，只要从服务目录下查找可用的服务节点去使用即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://static001.infoq.cn/resource/image/e7/d8/e7d6918c1c9b7c9f2829779966ffb5d8.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 2 微服务协同工作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PaaS 平台中应用多实例与实例故障重启透明化。PaaS 平台中的应用一般都有多个实例，通过域名，不仅可以透明的对这多个实例进行访问，而且还可以做到负载均衡。但是应用的某个实例随时都有可能故障重启，这时就需要动态的配置域名解析（路由）中的信息。通过 etcd 的服务发现功能就可以轻松解决这个动态配置的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://static001.infoq.cn/resource/image/ec/68/ecea22c641122ee933e4d1a2f4c6ce68.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 3 云平台多实例透明化&lt;/p&gt;
&lt;h3 id=&quot;heading2&quot; data-id-_609cf3a969c5=&quot;1&quot;&gt;场景二：消息发布与订阅&lt;/h3&gt;
&lt;p&gt;在分布式系统中，最适用的一种组件间通信方式就是消息发布与订阅。即构建一个配置共享中心，数据提供者在这个配置中心发布消息，而消息使用者则订阅他们关心的主题，一旦主题有消息发布，就会实时通知订阅者。通过这种方式可以做到分布式系统配置的集中式管理与动态更新。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用中用到的一些配置信息放到 etcd 上进行集中管理。这类场景的使用方式通常是这样：应用在启动的时候主动从 etcd 获取一次配置信息，同时，在 etcd 节点上注册一个 Watcher 并等待，以后每次配置有更新的时候，etcd 都会实时通知订阅者，以此达到获取最新配置信息的目的。&lt;/li&gt;
&lt;li&gt;分布式搜索服务中，索引的元信息和服务器集群机器的节点状态存放在 etcd 中，供各个客户端订阅使用。使用 etcd 的&lt;code&gt;key TTL&lt;/code&gt;功能可以确保机器状态是实时更新的。&lt;/li&gt;
&lt;li&gt;分布式日志收集系统。这个系统的核心工作是收集分布在不同机器的日志。收集器通常是按照应用（或主题）来分配收集任务单元，因此可以在 etcd 上创建一个以应用（主题）命名的目录 P，并将这个应用（主题相关）的所有机器 ip，以子目录的形式存储到目录 P 上，然后设置一个 etcd 递归的 Watcher，递归式的监控应用（主题）目录下所有信息的变动。这样就实现了机器 IP（消息）变动的时候，能够实时通知到收集器调整任务分配。&lt;/li&gt;
&lt;li&gt;系统中信息需要动态自动获取与人工干预修改信息请求内容的情况。通常是暴露出接口，例如 JMX 接口，来获取一些运行时的信息。引入 etcd 之后，就不用自己实现一套方案了，只要将这些信息存放到指定的 etcd 目录中即可，etcd 的这些目录就可以通过 HTTP 的接口在外部访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://static001.infoq.cn/resource/image/5f/0b/5fb77bf6f5751c45f44cbe9df8ee250b.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 4 消息发布与订阅&lt;/p&gt;
&lt;h3 id=&quot;heading3&quot; data-id-_c71c97b14031=&quot;1&quot;&gt;场景三：负载均衡&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;场景一&lt;/code&gt;中也提到了负载均衡，本文所指的负载均衡均为软负载均衡。分布式系统中，为了保证服务的高可用以及数据的一致性，通常都会把数据和服务部署多份，以此达到对等服务，即使其中的某一个服务失效了，也不影响使用。由此带来的坏处是数据写入性能下降，而好处则是数据访问时的负载均衡。因为每个对等服务节点上都存有完整的数据，所以用户的访问流量就可以分流到不同的机器上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;etcd 本身分布式架构存储的信息访问支持负载均衡。etcd 集群化以后，每个 etcd 的核心节点都可以处理用户的请求。所以，把数据量小但是访问频繁的消息数据直接存储到 etcd 中也是个不错的选择，如业务系统中常用的二级代码表（在表中存储代码，在 etcd 中存储代码所代表的具体含义，业务系统调用查表的过程，就需要查找表中代码的含义）。&lt;/li&gt;
&lt;li&gt;利用 etcd 维护一个负载均衡节点表。etcd 可以监控一个集群中多个节点的状态，当有一个请求发过来后，可以轮询式的把请求转发给存活着的多个状态。类似 KafkaMQ，通过 ZooKeeper 来维护生产者和消费者的负载均衡。同样也可以用 etcd 来做 ZooKeeper 的工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://static001.infoq.cn/resource/image/67/be/6782904921fa103f42f30113fbf0babe.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 5 负载均衡&lt;/p&gt;
&lt;h3 id=&quot;heading4&quot; data-id-_a4f68b44ee9a=&quot;1&quot;&gt;场景四：分布式通知与协调&lt;/h3&gt;
&lt;p&gt;这里说到的分布式通知与协调，与消息发布和订阅有些相似。都用到了 etcd 中的 Watcher 机制，通过注册与异步通知机制，实现分布式环境下不同系统之间的通知与协调，从而对数据变更做到实时处理。实现方式通常是这样：不同系统都在 etcd 上对同一个目录进行注册，同时设置 Watcher 观测该目录的变化（如果对子目录的变化也有需要，可以设置递归模式），当某个系统更新了 etcd 的目录，那么设置了 Watcher 的系统就会收到通知，并作出相应处理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过 etcd 进行低耦合的心跳检测。检测系统和被检测系统通过 etcd 上某个目录关联而非直接关联起来，这样可以大大减少系统的耦合性。&lt;/li&gt;
&lt;li&gt;通过 etcd 完成系统调度。某系统有控制台和推送系统两部分组成，控制台的职责是控制推送系统进行相应的推送工作。管理人员在控制台作的一些操作，实际上是修改了 etcd 上某些目录节点的状态，而 etcd 就把这些变化通知给注册了 Watcher 的推送系统客户端，推送系统再作出相应的推送任务。&lt;/li&gt;
&lt;li&gt;通过 etcd 完成工作汇报。大部分类似的任务分发系统，子任务启动后，到 etcd 来注册一个临时工作目录，并且定时将自己的进度进行汇报（将进度写入到这个临时目录），这样任务管理者就能够实时知道任务进度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://static001.infoq.cn/resource/image/38/97/38bee3d541dd88e6f772e64beab92697.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 6 分布式协同工作&lt;/p&gt;
&lt;h3 id=&quot;heading5&quot; data-id-_b65ea27e3e42=&quot;1&quot;&gt;场景五：分布式锁&lt;/h3&gt;
&lt;p&gt;因为 etcd 使用 Raft 算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，所以很容易实现分布式锁。锁服务有两种使用方式，一是保持独占，二是控制时序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保持独占即所有获取锁的用户最终只有一个可以得到。etcd 为此提供了一套实现分布式锁原子操作 CAS（&lt;code&gt;CompareAndSwap&lt;/code&gt;）的 API。通过设置&lt;code&gt;prevExist&lt;/code&gt;值，可以保证在多个节点同时去创建某个目录时，只有一个成功。而创建成功的用户就可以认为是获得了锁。&lt;/li&gt;
&lt;li&gt;控制时序，即所有想要获得锁的用户都会被安排执行，但是获得锁的顺序也是全局唯一的，同时决定了执行顺序。etcd 为此也提供了一套 API（自动创建有序键），对一个目录建值时指定为&lt;code&gt;POST&lt;/code&gt;动作，这样 etcd 会自动在目录下生成一个当前最大的值为键，存储这个新的值（客户端编号）。同时还可以使用 API 按顺序列出所有当前目录下的键值。此时这些键的值就是客户端的时序，而这些键中存储的值可以是代表客户端的编号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://static001.infoq.cn/resource/image/46/dc/46ff86e2e2c2157bc3f0409845f0e1dc.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 7 分布式锁&lt;/p&gt;
&lt;h3 id=&quot;heading6&quot; data-id-_786c41d1edb6=&quot;1&quot;&gt;场景六：分布式队列&lt;/h3&gt;
&lt;p&gt;分布式队列的常规用法与场景五中所描述的分布式锁的控制时序用法类似，即创建一个先进先出的队列，保证顺序。&lt;/p&gt;
&lt;p&gt;另一种比较有意思的实现是在保证队列达到某个条件时再统一按顺序执行。这种方法的实现可以在 /queue 这个目录中另外建立一个 /queue/condition 节点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;condition 可以表示队列大小。比如一个大的任务需要很多小任务就绪的情况下才能执行，每次有一个小任务就绪，就给这个 condition 数字加 1，直到达到大任务规定的数字，再开始执行队列里的一系列小任务，最终执行大任务。&lt;/li&gt;
&lt;li&gt;condition 可以表示某个任务在不在队列。这个任务可以是所有排序任务的首个执行程序，也可以是拓扑结构中没有依赖的点。通常，必须执行这些任务后才能执行队列中的其他任务。&lt;/li&gt;
&lt;li&gt;condition 还可以表示其它的一类开始执行任务的通知。可以由控制程序指定，当 condition 出现变化时，开始执行队列任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://static001.infoq.cn/resource/image/a0/73/a08ce82fb3bee55d0e31d6e2d062a273.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 8 分布式队列&lt;/p&gt;
&lt;h3 id=&quot;heading7&quot; data-id-_6453e8491990=&quot;1&quot;&gt;场景七：集群监控与 Leader 竞选&lt;/h3&gt;
&lt;p&gt;通过 etcd 来进行监控实现起来非常简单并且实时性强。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前面几个场景已经提到 Watcher 机制，当某个节点消失或有变动时，Watcher 会第一时间发现并告知用户。&lt;/li&gt;
&lt;li&gt;节点可以设置&lt;code&gt;TTL key&lt;/code&gt;，比如每隔 30s 发送一次心跳使代表该机器存活的节点继续存在，否则节点消失。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样就可以第一时间检测到各节点的健康状态，以完成集群的监控要求。&lt;/p&gt;
&lt;p&gt;另外，使用分布式锁，可以完成 Leader 竞选。这种场景通常是一些长时间 CPU 计算或者使用 IO 操作的机器，只需要竞选出的 Leader 计算或处理一次，就可以把结果复制给其他的 Follower。从而避免重复劳动，节省计算资源。&lt;/p&gt;
&lt;p&gt;这个的经典场景是搜索系统中建立全量索引。如果每个机器都进行一遍索引的建立，不但耗时而且建立索引的一致性不能保证。通过在 etcd 的 CAS 机制同时创建一个节点，创建成功的机器作为 Leader，进行索引计算，然后把计算结果分发到其它节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static001.infoq.cn/resource/image/2d/8c/2dc062ceed9f882ab99ff41f1ca7b18c.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 9 Leader 竞选&lt;/p&gt;
&lt;h3 id=&quot;heading8&quot; data-id-_63c0b0fc2d89=&quot;1&quot;&gt;场景八：为什么用 etcd 而不用 ZooKeeper？&lt;/h3&gt;
&lt;p&gt;阅读了&lt;a href=&quot;http://jm-blog.aliapp.com/?p=1232&quot; rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot;&gt;“ZooKeeper 典型应用场景一览”&lt;/a&gt;一文的读者可能会发现，etcd 实现的这些功能，ZooKeeper 都能实现。那么为什么要用 etcd 而非直接使用 ZooKeeper 呢？&lt;/p&gt;
&lt;p&gt;相较之下，ZooKeeper 有如下缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;复杂。ZooKeeper 的部署维护复杂，管理员需要掌握一系列的知识和技能；而 Paxos 强一致性算法也是素来以复杂难懂而闻名于世；另外，ZooKeeper 的使用也比较复杂，需要安装客户端，官方只提供了 Java 和 C 两种语言的接口。&lt;/li&gt;
&lt;li&gt;Java 编写。这里不是对 Java 有偏见，而是 Java 本身就偏向于重型应用，它会引入大量的依赖。而运维人员则普遍希望保持强一致、高可用的机器集群尽可能简单，维护起来也不易出错。&lt;/li&gt;
&lt;li&gt;发展缓慢。Apache 基金会项目特有的&lt;a href=&quot;http://www.infoworld.com/article/2612082/open-source-software/has-apache-lost-its-way-.html&quot; rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot;&gt;“Apache Way”&lt;/a&gt;在开源界饱受争议，其中一大原因就是由于基金会庞大的结构以及松散的管理导致项目发展缓慢。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而 etcd 作为一个后起之秀，其优点也很明显。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;简单。使用 Go 语言编写部署简单；使用 HTTP 作为接口使用简单；使用 Raft 算法保证强一致性让用户易于理解。&lt;/li&gt;
&lt;li&gt;数据持久化。etcd 默认数据一更新就进行持久化。&lt;/li&gt;
&lt;li&gt;安全。etcd 支持 SSL 客户端安全认证。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后，etcd 作为一个年轻的项目，真正告诉迭代和开发中，这既是一个优点，也是一个缺点。优点是它的未来具有无限的可能性，缺点是无法得到大项目长时间使用的检验。然而，目前 CoreOS、Kubernetes 和 CloudFoundry 等知名项目均在生产环境中使用了 etcd，所以总的来说，etcd 值得你去尝试。&lt;/p&gt;
&lt;h2 id=&quot;heading9&quot; data-id-_e3d406434ded=&quot;1&quot;&gt;etcd 实现原理解读&lt;/h2&gt;
&lt;p&gt;上一节中，我们概括了许多 etcd 的经典场景，这一节，我们将从 etcd 的架构开始，深入到源码中解析 etcd。&lt;/p&gt;
&lt;h3 id=&quot;heading10&quot; data-id-_d48784aacabf=&quot;1&quot;&gt;1 架构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://static001.infoq.cn/resource/image/cf/94/cf0851c4bcbd2555d09674e7e2a07394.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 10 etcd 架构图&lt;/p&gt;
&lt;p&gt;从 etcd 的架构图中我们可以看到，etcd 主要分为四个部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP Server： 用于处理用户发送的 API 请求以及其它 etcd 节点的同步与心跳信息请求。&lt;/li&gt;
&lt;li&gt;Store：用于处理 etcd 支持的各类功能的事务，包括数据索引、节点状态变更、监控与反馈、事件处理与执行等等，是 etcd 对用户提供的大多数 API 功能的具体实现。&lt;/li&gt;
&lt;li&gt;Raft：Raft 强一致性算法的具体实现，是 etcd 的核心。&lt;/li&gt;
&lt;li&gt;WAL：Write Ahead Log（预写式日志），是 etcd 的数据存储方式。除了在内存中存有所有数据的状态以及节点的索引以外，etcd 就通过 WAL 进行持久化存储。WAL 中，所有的数据提交前都会事先记录日志。Snapshot 是为了防止数据过多而进行的状态快照；Entry 表示存储的具体日志内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常，一个用户的请求发送过来，会经由 HTTP Server 转发给 Store 进行具体的事务处理，如果涉及到节点的修改，则交给 Raft 模块进行状态的变更、日志的记录，然后再同步给别的 etcd 节点以确认数据提交，最后进行数据的提交，再次同步。&lt;/p&gt;
&lt;h3 id=&quot;heading11&quot; data-id-_f512c848bc02=&quot;1&quot;&gt;2 新版 etcd 重要变更列表&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;获得了 IANA 认证的端口，2379 用于客户端通信，2380 用于节点通信，与原先的（4001 peers / 7001 clients）共用。&lt;/li&gt;
&lt;li&gt;每个节点可监听多个广播地址。监听的地址由原来的一个扩展到多个，用户可以根据需求实现更加复杂的集群环境，如一个是公网 IP，一个是虚拟机（容器）之类的私有 IP。&lt;/li&gt;
&lt;li&gt;etcd 可以代理访问 leader 节点的请求，所以如果你可以访问任何一个 etcd 节点，那么你就可以无视网络的拓扑结构对整个集群进行读写操作。&lt;/li&gt;
&lt;li&gt;etcd 集群和集群中的节点都有了自己独特的 ID。这样就防止出现配置混淆，不是本集群的其他 etcd 节点发来的请求将被屏蔽。&lt;/li&gt;
&lt;li&gt;etcd 集群启动时的配置信息目前变为完全固定，这样有助于用户正确配置和启动。&lt;/li&gt;
&lt;li&gt;运行时节点变化 (Runtime Reconfiguration)。用户不需要重启 etcd 服务即可实现对 etcd 集群结构进行变更。启动后可以动态变更集群配置。&lt;/li&gt;
&lt;li&gt;重新设计和实现了 Raft 算法，使得运行速度更快，更容易理解，包含更多测试代码。&lt;/li&gt;
&lt;li&gt;Raft 日志现在是严格的只能向后追加、预写式日志系统，并且在每条记录中都加入了 CRC 校验码。&lt;/li&gt;
&lt;li&gt;启动时使用的 _etcd/* 关键字不再暴露给用户&lt;/li&gt;
&lt;li&gt;废弃集群自动调整功能的 standby 模式，这个功能使得用户维护集群更困难。&lt;/li&gt;
&lt;li&gt;新增 Proxy 模式，不加入到 etcd 一致性集群中，纯粹进行代理转发。&lt;/li&gt;
&lt;li&gt;ETCD_NAME（-name）参数目前是可选的，不再用于唯一标识一个节点。&lt;/li&gt;
&lt;li&gt;摒弃通过配置文件配置 etcd 属性的方式，你可以用环境变量的方式代替。&lt;/li&gt;
&lt;li&gt;通过自发现方式启动集群必须要提供集群大小，这样有助于用户确定集群实际启动的节点数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;heading12&quot; data-id-_b1f9b82d782d=&quot;1&quot;&gt;3 etcd 概念词汇表&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Raft：etcd 所采用的保证分布式系统强一致性的算法。&lt;/li&gt;
&lt;li&gt;Node：一个 Raft 状态机实例。&lt;/li&gt;
&lt;li&gt;Member： 一个 etcd 实例。它管理着一个 Node，并且可以为客户端请求提供服务。&lt;/li&gt;
&lt;li&gt;Cluster：由多个 Member 构成可以协同工作的 etcd 集群。&lt;/li&gt;
&lt;li&gt;Peer：对同一个 etcd 集群中另外一个 Member 的称呼。&lt;/li&gt;
&lt;li&gt;Client： 向 etcd 集群发送 HTTP 请求的客户端。&lt;/li&gt;
&lt;li&gt;WAL：预写式日志，etcd 用于持久化存储的日志格式。&lt;/li&gt;
&lt;li&gt;snapshot：etcd 防止 WAL 文件过多而设置的快照，存储 etcd 数据状态。&lt;/li&gt;
&lt;li&gt;Proxy：etcd 的一种模式，为 etcd 集群提供反向代理服务。&lt;/li&gt;
&lt;li&gt;Leader：Raft 算法中通过竞选而产生的处理所有数据提交的节点。&lt;/li&gt;
&lt;li&gt;Follower：竞选失败的节点作为 Raft 中的从属节点，为算法提供强一致性保证。&lt;/li&gt;
&lt;li&gt;Candidate：当 Follower 超过一定时间接收不到 Leader 的心跳时转变为 Candidate 开始竞选。&lt;/li&gt;
&lt;li&gt;Term：某个节点成为 Leader 到下一次竞选时间，称为一个 Term。&lt;/li&gt;
&lt;li&gt;Index：数据项编号。Raft 中通过 Term 和 Index 来定位数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;heading13&quot; data-id-_291d097b31b5=&quot;1&quot;&gt;4 集群化应用实践&lt;/h3&gt;
&lt;p&gt;etcd 作为一个高可用键值存储系统，天生就是为集群化而设计的。由于 Raft 算法在做决策时需要多数节点的投票，所以 etcd 一般部署集群推荐奇数个节点，推荐的数量为 3、5 或者 7 个节点构成一个集群。&lt;/p&gt;
&lt;h4 id=&quot;heading14&quot; data-id-_015a2678be32=&quot;1&quot;&gt;4.1 集群启动&lt;/h4&gt;
&lt;p&gt;etcd 有三种集群化启动的配置方案，分别为静态配置启动、etcd 自身服务发现、通过 DNS 进行服务发现。&lt;/p&gt;
&lt;p&gt;通过配置内容的不同，你可以对不同的方式进行选择。值得一提的是，这也是新版 etcd 区别于旧版的一大特性，它摒弃了使用配置文件进行参数配置的做法，转而使用命令行参数或者环境变量的做法来配置参数。&lt;/p&gt;
&lt;h5 id=&quot;heading15&quot; data-id-_82a2ee20a6ff=&quot;1&quot;&gt;4.1.1. 静态配置&lt;/h5&gt;
&lt;p&gt;这种方式比较适用于离线环境，在启动整个集群之前，你就已经预先清楚所要配置的集群大小，以及集群上各节点的地址和端口信息。那么启动时，你就可以通过配置&lt;code&gt;initial-cluster&lt;/code&gt;参数进行 etcd 集群的启动。&lt;/p&gt;
&lt;p&gt;在每个 etcd 机器启动时，配置环境变量或者添加启动参数的方式如下。&lt;/p&gt;

&lt;table class=&quot;hljs-ln&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;ETCD_INITIAL_CLUSTER=&lt;span class=&quot;hljs-string&quot;&gt;&quot;infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380&quot;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;ETCD_INITIAL_CLUSTER_STATE=new&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;

&lt;/tbody&gt;

&lt;/table&gt;
&lt;p&gt;参数方法：&lt;/p&gt;

&lt;table class=&quot;hljs-ln&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;-initial-cluster&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;infra0=http:&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-number&quot;&gt;10.0.&lt;span class=&quot;hljs-number&quot;&gt;1.10:&lt;span class=&quot;hljs-number&quot;&gt;2380,http:&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-number&quot;&gt;10.0.&lt;span class=&quot;hljs-number&quot;&gt;1.11:&lt;span class=&quot;hljs-number&quot;&gt;2380,infra2=http:&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-number&quot;&gt;10.0.&lt;span class=&quot;hljs-number&quot;&gt;1.12:&lt;span class=&quot;hljs-number&quot;&gt;2380 \&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;-initial-cluster-state new&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;

&lt;/tbody&gt;

&lt;/table&gt;
&lt;p&gt;值得注意的是，&lt;code&gt;-initial-cluster&lt;/code&gt;参数中配置的 url 地址必须与各个节点启动时设置的&lt;code&gt;initial-advertise-peer-urls&lt;/code&gt;参数相同。（&lt;code&gt;initial-advertise-peer-urls&lt;/code&gt;参数表示节点监听其他节点同步信号的地址）&lt;/p&gt;
&lt;p&gt;如果你所在的网络环境配置了多个 etcd 集群，为了避免意外发生，最好使用&lt;code&gt;-initial-cluster-token&lt;/code&gt;参数为每个集群单独配置一个 token 认证。这样就可以确保每个集群和集群的成员都拥有独特的 ID。&lt;/p&gt;
&lt;p&gt;综上所述，如果你要配置包含 3 个 etcd 节点的集群，那么你在三个机器上的启动命令分别如下所示。&lt;/p&gt;

&lt;table class=&quot;hljs-ln&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;$ etcd -name infra0 -initial-advertise-peer-urls http:&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-number&quot;&gt;10.0.&lt;span class=&quot;hljs-number&quot;&gt;1.10:&lt;span class=&quot;hljs-number&quot;&gt;2380 \&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;-listen-peer-urls http:&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-number&quot;&gt;10.0.&lt;span class=&quot;hljs-number&quot;&gt;1.10:&lt;span class=&quot;hljs-number&quot;&gt;2380 \&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;-initial-cluster-token etcd-cluster-&lt;span class=&quot;hljs-number&quot;&gt;1 \&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;-initial-cluster infra0=http:&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-number&quot;&gt;10.0.&lt;span class=&quot;hljs-number&quot;&gt;1.10:&lt;span class=&quot;hljs-number&quot;&gt;2380,infra1=http:&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-number&quot;&gt;10.0.&lt;span class=&quot;hljs-number&quot;&gt;1.11:&lt;span class=&quot;hljs-number&quot;&gt;2380,infra2=http:&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-number&quot;&gt;10.0.&lt;span class=&quot;hljs-number&quot;&gt;1.12:&lt;span class=&quot;hljs-number&quot;&gt;2380 \&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;-initial-cluster-state new&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;$ etcd -name infra1 -initial-advertise-peer-urls http:&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-number&quot;&gt;10.0.&lt;span class=&quot;hljs-number&quot;&gt;1.11:&lt;span class=&quot;hljs-number&quot;&gt;2380 \&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;-listen-peer-urls http:&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-number&quot;&gt;10.0.&lt;span class=&quot;hljs-number&quot;&gt;1.11:&lt;span class=&quot;hljs-number&quot;&gt;2380 \&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;-initial-cluster-token etcd-cluster-&lt;span class=&quot;hljs-number&quot;&gt;1 \&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;-initial-cluster infra0=http:&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-number&quot;&gt;10.0.&lt;span class=&quot;hljs-number&quot;&gt;1.10:&lt;span class=&quot;hljs-number&quot;&gt;2380,infra1=http:&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-number&quot;&gt;10.0.&lt;span class=&quot;hljs-number&quot;&gt;1.11:&lt;span class=&quot;hljs-number&quot;&gt;2380,infra2=http:&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-number&quot;&gt;10.0.&lt;span class=&quot;hljs-number&quot;&gt;1.12:&lt;span class=&quot;hljs-number&quot;&gt;2380 \&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;-initial-cluster-state new&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;$ etcd -name infra2 -initial-advertise-peer-urls http:&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-number&quot;&gt;10.0.&lt;span class=&quot;hljs-number&quot;&gt;1.12:&lt;span class=&quot;hljs-number&quot;&gt;2380 \&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;-listen-peer-urls http:&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-number&quot;&gt;10.0.&lt;span class=&quot;hljs-number&quot;&gt;1.12:&lt;span class=&quot;hljs-number&quot;&gt;2380 \&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;-initial-cluster-token etcd-cluster-&lt;span class=&quot;hljs-number&quot;&gt;1 \&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;-initial-cluster infra0=http:&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-number&quot;&gt;10.0.&lt;span class=&quot;hljs-number&quot;&gt;1.10:&lt;span class=&quot;hljs-number&quot;&gt;2380,infra1=http:&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-number&quot;&gt;10.0.&lt;span class=&quot;hljs-number&quot;&gt;1.11:&lt;span class=&quot;hljs-number&quot;&gt;2380,infra2=http:&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-number&quot;&gt;10.0.&lt;span class=&quot;hljs-number&quot;&gt;1.12:&lt;span class=&quot;hljs-number&quot;&gt;2380 \&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;-initial-cluster-state new&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;

&lt;/tbody&gt;

&lt;/table&gt;
&lt;p&gt;在初始化完成后，etcd 还提供动态增、删、改 etcd 集群节点的功能，这个需要用到&lt;code&gt;etcdctl&lt;/code&gt;命令进行操作。&lt;/p&gt;
&lt;h5 id=&quot;heading16&quot; data-id-_dec809e17976=&quot;1&quot;&gt;4.1.2. etcd 自发现模式&lt;/h5&gt;
&lt;p&gt;通过自发现的方式启动 etcd 集群需要事先准备一个 etcd 集群。如果你已经有一个 etcd 集群，首先你可以执行如下命令设定集群的大小，假设为 3.&lt;/p&gt;

&lt;table class=&quot;hljs-ln&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;$ curl -X PUT http:&lt;span class=&quot;hljs-regexp&quot;&gt;//myetcd.local&lt;span class=&quot;hljs-regexp&quot;&gt;/v2/keys&lt;span class=&quot;hljs-regexp&quot;&gt;/discovery/&lt;span class=&quot;hljs-number&quot;&gt;6c007a14875d53d9bf0ef5a6fc0257c817f0fb83&lt;span class=&quot;hljs-regexp&quot;&gt;/_config/size -d value=&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;

&lt;/tbody&gt;

&lt;/table&gt;
&lt;p&gt;然后你要把这个 url 地址&lt;code&gt;http://myetcd.local/v2/keys/discovery/6c007a14875d53d9bf0ef5a6fc0257c817f0fb83&lt;/code&gt;作为&lt;code&gt;-discovery&lt;/code&gt;参数来启动 etcd。节点会自动使用&lt;code&gt;http://myetcd.local/v2/keys/discovery/6c007a14875d53d9bf0ef5a6fc0257c817f0fb83&lt;/code&gt;目录进行 etcd 的注册和发现服务。&lt;/p&gt;
&lt;p&gt;所以最终你在某个机器上启动 etcd 的命令如下。&lt;/p&gt;

&lt;table class=&quot;hljs-ln&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;$ etcd -name infra0 -initial-advertise-peer-urls http:&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-number&quot;&gt;10.0.&lt;span class=&quot;hljs-number&quot;&gt;1.10:&lt;span class=&quot;hljs-number&quot;&gt;2380 \&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;-listen-peer-urls http:&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-number&quot;&gt;10.0.&lt;span class=&quot;hljs-number&quot;&gt;1.10:&lt;span class=&quot;hljs-number&quot;&gt;2380 \&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;-discovery http:&lt;span class=&quot;hljs-regexp&quot;&gt;//myetcd.local&lt;span class=&quot;hljs-regexp&quot;&gt;/v2/keys&lt;span class=&quot;hljs-regexp&quot;&gt;/discovery/&lt;span class=&quot;hljs-number&quot;&gt;6c007a14875d53d9bf0ef5a6fc0257c817f0fb83&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;

&lt;/tbody&gt;

&lt;/table&gt;
&lt;p&gt;如果你本地没有可用的 etcd 集群，etcd 官网提供了一个可以公网访问的 etcd 存储地址。你可以通过如下命令得到 etcd 服务的目录，并把它作为&lt;code&gt;-discovery&lt;/code&gt;参数使用。&lt;/p&gt;

&lt;table class=&quot;hljs-ln&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;$ curl http:&lt;span class=&quot;hljs-regexp&quot;&gt;//discovery.etcd.io/new?size=&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;http:&lt;span class=&quot;hljs-regexp&quot;&gt;//discovery.etcd.io/&lt;span class=&quot;hljs-number&quot;&gt;3e86b59982e49066c5d813af1c2e2579cbf573de&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;

&lt;/tbody&gt;

&lt;/table&gt;
&lt;p&gt;同样的，当你完成了集群的初始化后，这些信息就失去了作用。当你需要增加节点时，需要使用&lt;code&gt;etcdctl&lt;/code&gt;来进行操作。&lt;/p&gt;
&lt;p&gt;为了安全，请务必每次启动新 etcd 集群时，都使用新的 discovery token 进行注册。另外，如果你初始化时启动的节点超过了指定的数量，多余的节点会自动转化为 Proxy 模式的 etcd。&lt;/p&gt;
&lt;h5 id=&quot;heading17&quot; data-id-_1cdb57a888c9=&quot;1&quot;&gt;4.1.3. DNS 自发现模式&lt;/h5&gt;
&lt;p&gt;etcd 还支持使用 DNS SRV 记录进行启动。关于 DNS SRV 记录如何进行服务发现，可以参阅&lt;a href=&quot;http://tools.ietf.org/html/rfc2782&quot; rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot;&gt; RFC2782 &lt;/a&gt;，所以，你要在 DNS 服务器上进行相应的配置。&lt;/p&gt;
&lt;p&gt;(1) 开启 DNS 服务器上 SRV 记录查询，并添加相应的域名记录，使得查询到的结果类似如下。&lt;/p&gt;

&lt;table class=&quot;hljs-ln&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;$ dig +noall +answer SRV _etcd-server._tcp&lt;span class=&quot;hljs-selector-class&quot;&gt;.example&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;_etcd-server._tcp&lt;span class=&quot;hljs-selector-class&quot;&gt;.example&lt;span class=&quot;hljs-selector-class&quot;&gt;.com. &lt;span class=&quot;hljs-number&quot;&gt;300 IN SRV &lt;span class=&quot;hljs-number&quot;&gt;0 &lt;span class=&quot;hljs-number&quot;&gt;0 &lt;span class=&quot;hljs-number&quot;&gt;2380 infra0&lt;span class=&quot;hljs-selector-class&quot;&gt;.example&lt;span class=&quot;hljs-selector-class&quot;&gt;.com.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;_etcd-server._tcp&lt;span class=&quot;hljs-selector-class&quot;&gt;.example&lt;span class=&quot;hljs-selector-class&quot;&gt;.com. &lt;span class=&quot;hljs-number&quot;&gt;300 IN SRV &lt;span class=&quot;hljs-number&quot;&gt;0 &lt;span class=&quot;hljs-number&quot;&gt;0 &lt;span class=&quot;hljs-number&quot;&gt;2380 infra1&lt;span class=&quot;hljs-selector-class&quot;&gt;.example&lt;span class=&quot;hljs-selector-class&quot;&gt;.com.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;_etcd-server._tcp&lt;span class=&quot;hljs-selector-class&quot;&gt;.example&lt;span class=&quot;hljs-selector-class&quot;&gt;.com. &lt;span class=&quot;hljs-number&quot;&gt;300 IN SRV &lt;span class=&quot;hljs-number&quot;&gt;0 &lt;span class=&quot;hljs-number&quot;&gt;0 &lt;span class=&quot;hljs-number&quot;&gt;2380 infra2&lt;span class=&quot;hljs-selector-class&quot;&gt;.example&lt;span class=&quot;hljs-selector-class&quot;&gt;.com.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;

&lt;/tbody&gt;

&lt;/table&gt;
&lt;p&gt;(2) 分别为各个域名配置相关的 A 记录指向 etcd 核心节点对应的机器 IP。使得查询结果类似如下。&lt;/p&gt;

&lt;table class=&quot;hljs-ln&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;$ dig +noall +answer infra0.example.com infra1.example.com infra2.example.com&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;infra0.example.com. &lt;span class=&quot;hljs-number&quot;&gt;300 IN A &lt;span class=&quot;hljs-number&quot;&gt;10.0&lt;span class=&quot;hljs-number&quot;&gt;.1&lt;span class=&quot;hljs-number&quot;&gt;.10&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;infra1.example.com. &lt;span class=&quot;hljs-number&quot;&gt;300 IN A &lt;span class=&quot;hljs-number&quot;&gt;10.0&lt;span class=&quot;hljs-number&quot;&gt;.1&lt;span class=&quot;hljs-number&quot;&gt;.11&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;infra2.example.com. &lt;span class=&quot;hljs-number&quot;&gt;300 IN A &lt;span class=&quot;hljs-number&quot;&gt;10.0&lt;span class=&quot;hljs-number&quot;&gt;.1&lt;span class=&quot;hljs-number&quot;&gt;.12&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;

&lt;/tbody&gt;

&lt;/table&gt;
&lt;p&gt;做好了上述两步 DNS 的配置，就可以使用 DNS 启动 etcd 集群了。配置 DNS 解析的 url 参数为&lt;code&gt;-discovery-srv&lt;/code&gt;，其中某一个节点地启动命令如下。&lt;/p&gt;

&lt;table class=&quot;hljs-ln&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;$ etcd -name infra0 \&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;-&lt;span class=&quot;ruby&quot;&gt;discovery-srv example.com \&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;-&lt;span class=&quot;ruby&quot;&gt;initial-advertise-peer-urls &lt;span class=&quot;hljs-symbol&quot;&gt;http:/&lt;span class=&quot;hljs-regexp&quot;&gt;/infra0.example.com:2380 \&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;-&lt;span class=&quot;ruby&quot;&gt;initial-cluster-token etcd-cluster-1 \&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;-&lt;span class=&quot;ruby&quot;&gt;initial-cluster-state new \&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;-&lt;span class=&quot;ruby&quot;&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;advertise-client-urls http:/&lt;span class=&quot;hljs-regexp&quot;&gt;/infra0.example.com:2379 \&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;-&lt;span class=&quot;ruby&quot;&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;listen-client-urls http:/&lt;span class=&quot;hljs-regexp&quot;&gt;/infra0.example.com:2379 \&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;-&lt;span class=&quot;ruby&quot;&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;listen-peer-urls http:/&lt;span class=&quot;hljs-regexp&quot;&gt;/infra0.example.com:2380&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;

&lt;/tr&gt;

&lt;/tbody&gt;

&lt;/table&gt;
&lt;p&gt;当然，你也可以直接把节点的域名改成 IP 来启动。&lt;/p&gt;
&lt;h4 id=&quot;heading18&quot; data-id-_ca205368e7bd=&quot;1&quot;&gt;4.2 关键部分源码解析&lt;/h4&gt;
&lt;p&gt;etcd 的启动是从主目录下的&lt;code&gt;main.go&lt;/code&gt;开始的，然后进入&lt;code&gt;etcdmain/etcd.go&lt;/code&gt;，载入配置参数。如果被配置为 Proxy 模式，则进入 startProxy 函数，否则进入 startEtcd，开启 etcd 服务模块和 http 请求处理模块。&lt;/p&gt;
&lt;p&gt;在启动 http 监听时，为了保持与集群其他 etcd 机器（peers）保持连接，都采用的&lt;code&gt;transport.NewTimeoutListener&lt;/code&gt;启动方式，这样在超过指定时间没有获得响应时就会出现超时错误。而在监听 client 请求时，采用的是&lt;code&gt;transport.NewKeepAliveListener&lt;/code&gt;，有助于连接的稳定。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;etcdmain/etcd.go&lt;/code&gt;中的 setupCluster 函数可以看到，根据不同 etcd 的参数，启动集群的方法略有不同，但是最终需要的就是一个 IP 与端口构成的字符串。&lt;/p&gt;
&lt;p&gt;在静态配置的启动方式中，集群的所有信息都已经在给出，所以直接解析用逗号隔开的集群 url 信息就好了。&lt;/p&gt;
&lt;p&gt;DNS 发现的方式类似，会预先发送一个 tcp 的 SRV 请求，先查看&lt;code&gt;etcd-server-ssl._tcp.example.com&lt;/code&gt;下是否有集群的域名信息，如果没有找到，则去查看&lt;code&gt;etcd-server._tcp.example.com&lt;/code&gt;。根据找到的域名，解析出对应的 IP 和端口，即集群的 url 信息。&lt;/p&gt;
&lt;p&gt;较为复杂是 etcd 式的自发现启动。首先就用自身单个的 url 构成一个集群，然后在启动的过程中根据参数进入&lt;code&gt;discovery/discovery.go&lt;/code&gt;源码的&lt;code&gt;JoinCluster&lt;/code&gt;函数。因为我们事先是知道启动时使用的 etcd 的 token 地址的，里面包含了集群大小 (size) 信息。在这个过程其实是个不断监测与等待的过程。启动的第一步就是在这个 etcd 的 token 目录下注册自身的信息，然后再监测 token 目录下所有节点的数量，如果数量没有达标，则循环等待。当数量达到要求时，才结束，进入正常的启动过程。&lt;/p&gt;
&lt;p&gt;配置 etcd 过程中通常要用到两种 url 地址容易混淆，一种用于 etcd 集群同步信息并保持连接，通常称为 peer-urls；另外一种用于接收用户端发来的 HTTP 请求，通常称为 client-urls。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;peer-urls&lt;/code&gt;：通常监听的端口为&lt;code&gt;2380&lt;/code&gt;（老版本使用的端口为&lt;code&gt;7001&lt;/code&gt;），包括所有已经在集群中正常工作的所有节点的地址。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;client-urls&lt;/code&gt;：通常监听的端口为&lt;code&gt;2379&lt;/code&gt;（老版本使用的端口为&lt;code&gt;4001&lt;/code&gt;），为适应复杂的网络环境，新版 etcd 监听客户端请求的 url 从原来的 1 个变为现在可配置的多个。这样 etcd 可以配合多块网卡同时监听不同网络下的请求。&lt;/li&gt;

&lt;/ul&gt;
&lt;h4 id=&quot;heading19&quot; data-id-_f39217fd6523=&quot;1&quot;&gt;4.3 运行时节点变更&lt;/h4&gt;
&lt;p&gt;etcd 集群启动完毕后，可以在运行的过程中对集群进行重构，包括核心节点的增加、删除、迁移、替换等。运行时重构使得 etcd 集群无须重启即可改变集群的配置，这也是新版 etcd 区别于旧版包含的新特性。&lt;/p&gt;
&lt;p&gt;只有当集群中多数节点正常的情况下，你才可以进行运行时的配置管理。因为配置更改的信息也会被 etcd 当成一个信息存储和同步，如果集群多数节点损坏，集群就失去了写入数据的能力。所以在配置 etcd 集群数量时，强烈推荐至少配置 3 个核心节点。&lt;/p&gt;
&lt;h5 id=&quot;heading20&quot; data-id-_43e6d3c7ab97=&quot;1&quot;&gt;4.3.1. 节点迁移、替换&lt;/h5&gt;
&lt;p&gt;当你节点所在的机器出现硬件故障，或者节点出现如数据目录损坏等问题，导致节点永久性的不可恢复时，就需要对节点进行迁移或者替换。当一个节点失效以后，必须尽快修复，因为 etcd 集群正常运行的必要条件是集群中多数节点都正常工作。&lt;/p&gt;
&lt;p&gt;迁移一个节点需要进行四步操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;暂停正在运行着的节点程序进程&lt;/li&gt;
&lt;li&gt;把数据目录从现有机器拷贝到新机器&lt;/li&gt;
&lt;li&gt;使用 api 更新 etcd 中对应节点指向机器的 url 记录更新为新机器的 ip&lt;/li&gt;
&lt;li&gt;使用同样的配置项和数据目录，在新的机器上启动 etcd。&lt;/li&gt;

&lt;/ul&gt;
&lt;h5 id=&quot;heading21&quot; data-id-_7611bda5c9da=&quot;1&quot;&gt;4.3.2. 节点增加&lt;/h5&gt;
&lt;p&gt;增加节点可以让 etcd 的高可用性更强。举例来说，如果你有 3 个节点，那么最多允许 1 个节点失效；当你有 5 个节点时，就可以允许有 2 个节点失效。同时，增加节点还可以让 etcd 集群具有更好的读性能。因为 etcd 的节点都是实时同步的，每个节点上都存储了所有的信息，所以增加节点可以从整体上提升读的吞吐量。&lt;/p&gt;
&lt;p&gt;增加一个节点需要进行两步操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在集群中添加这个节点的 url 记录，同时获得集群的信息。&lt;/li&gt;
&lt;li&gt;使用获得的集群信息启动新 etcd 节点。&lt;/li&gt;

&lt;/ul&gt;
&lt;h5 id=&quot;heading22&quot; data-id-_4088fdd97f25=&quot;1&quot;&gt;4.3.3. 节点移除&lt;/h5&gt;
&lt;p&gt;有时你不得不在提高 etcd 的写性能和增加集群高可用性上进行权衡。Leader 节点在提交一个写记录时，会把这个消息同步到每个节点上，当得到多数节点的同意反馈后，才会真正写入数据。所以节点越多，写入性能越差。在节点过多时，你可能需要移除一个或多个。&lt;/p&gt;
&lt;p&gt;移除节点非常简单，只需要一步操作，就是把集群中这个节点的记录删除。然后对应机器上的该节点就会自动停止。&lt;/p&gt;
&lt;h5 id=&quot;heading23&quot; data-id-_94468eeb582c=&quot;1&quot;&gt;4.3.4. 强制性重启集群&lt;/h5&gt;
&lt;p&gt;当集群超过半数的节点都失效时，就需要通过手动的方式，强制性让某个节点以自己为 Leader，利用原有数据启动一个新集群。&lt;/p&gt;
&lt;p&gt;此时你需要进行两步操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;备份原有数据到新机器。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;-force-new-cluster&lt;/code&gt;加备份的数据重新启动节点&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;注意：强制性重启是一个迫不得已的选择，它会破坏一致性协议保证的安全性（如果操作时集群中尚有其它节点在正常工作，就会出错），所以在操作前请务必要保存好数据。&lt;/p&gt;
&lt;h3 id=&quot;heading24&quot; data-id-_41464b0b45d8=&quot;1&quot;&gt;5 Proxy 模式&lt;/h3&gt;
&lt;p&gt;Proxy 模式也是新版 etcd 的一个重要变更，etcd 作为一个反向代理把客户的请求转发给可用的 etcd 集群。这样，你就可以在每一台机器都部署一个 Proxy 模式的 etcd 作为本地服务，如果这些 etcd Proxy 都能正常运行，那么你的服务发现必然是稳定可靠的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static001.infoq.cn/resource/image/fd/0f/fd17db8d2165fb60009b77bd4810410f.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 11 Proxy 模式示意图&lt;/p&gt;
&lt;p&gt;所以 Proxy 并不是直接加入到符合强一致性的 etcd 集群中，也同样的，Proxy 并没有增加集群的可靠性，当然也没有降低集群的写入性能。&lt;/p&gt;
&lt;h4 id=&quot;heading25&quot; data-id-_beb06e8e4252=&quot;1&quot;&gt;5.1 Proxy 取代 Standby 模式的原因&lt;/h4&gt;
&lt;p&gt;那么，为什么要有 Proxy 模式而不是直接增加 etcd 核心节点呢？实际上 etcd 每增加一个核心节点（peer），都会增加 Leader 节点一定程度的包括网络、CPU 和磁盘的负担，因为每次信息的变化都需要进行同步备份。增加 etcd 的核心节点可以让整个集群具有更高的可靠性，但是当数量达到一定程度以后，增加可靠性带来的好处就变得不那么明显，反倒是降低了集群写入同步的性能。因此，增加一个轻量级的 Proxy 模式 etcd 节点是对直接增加 etcd 核心节点的一个有效代替。&lt;/p&gt;
&lt;p&gt;熟悉 0.4.6 这个旧版本 etcd 的用户会发现，Proxy 模式实际上是取代了原先的 Standby 模式。Standby 模式除了转发代理的功能以外，还会在核心节点因为故障导致数量不足的时候，从 Standby 模式转为正常节点模式。而当那个故障的节点恢复时，发现 etcd 的核心节点数量已经达到的预先设置的值，就会转为 Standby 模式。&lt;/p&gt;
&lt;p&gt;但是新版 etcd 中，只会在最初启动 etcd 集群时，发现核心节点的数量已经满足要求时，自动启用 Proxy 模式，反之则并未实现。主要原因如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;etcd 是用来保证高可用的组件，因此它所需要的系统资源（包括内存、硬盘和 CPU 等）都应该得到充分保障以保证高可用。任由集群的自动变换随意地改变核心节点，无法让机器保证性能。所以 etcd 官方鼓励大家在大型集群中为运行 etcd 准备专有机器集群。&lt;/li&gt;
&lt;li&gt;因为 etcd 集群是支持高可用的，部分机器故障并不会导致功能失效。所以机器发生故障时，管理员有充分的时间对机器进行检查和修复。&lt;/li&gt;
&lt;li&gt;自动转换使得 etcd 集群变得复杂，尤其是如今 etcd 支持多种网络环境的监听和交互。在不同网络间进行转换，更容易发生错误，导致集群不稳定。&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;基于上述原因，目前 Proxy 模式有转发代理功能，而不会进行角色转换。&lt;/p&gt;
&lt;h4 id=&quot;heading26&quot; data-id-_c6345a341035=&quot;1&quot;&gt;5.2 关键部分源码解析&lt;/h4&gt;
&lt;p&gt;从代码中可以看到，Proxy 模式的本质就是起一个 HTTP 代理服务器，把客户发到这个服务器的请求转发给别的 etcd 节点。&lt;/p&gt;
&lt;p&gt;etcd 目前支持读写皆可和只读两种模式。默认情况下是读写皆可，就是把读、写两种请求都进行转发。而只读模式只转发读的请求，对所有其他请求返回 501 错误。&lt;/p&gt;
&lt;p&gt;值得注意的是，除了启动过程中因为设置了&lt;code&gt;proxy&lt;/code&gt;参数会作为 Proxy 模式启动。在 etcd 集群化启动时，节点注册自身的时候监测到集群的实际节点数量已经符合要求，那么就会退化为 Proxy 模式。&lt;/p&gt;
&lt;h3 id=&quot;heading27&quot; data-id-_98db346be8d1=&quot;1&quot;&gt;6 数据存储&lt;/h3&gt;
&lt;p&gt;etcd 的存储分为内存存储和持久化（硬盘）存储两部分，内存中的存储除了顺序化的记录下所有用户对节点数据变更的记录外，还会对用户数据进行索引、建堆等方便查询的操作。而持久化则使用预写式日志（WAL：Write Ahead Log）进行记录存储。&lt;/p&gt;
&lt;p&gt;在 WAL 的体系中，所有的数据在提交之前都会进行日志记录。在 etcd 的持久化存储目录中，有两个子目录。一个是 WAL，存储着所有事务的变化记录；另一个则是 snapshot，用于存储某一个时刻 etcd 所有目录的数据。通过 WAL 和 snapshot 相结合的方式，etcd 可以有效的进行数据存储和节点故障恢复等操作。&lt;/p&gt;
&lt;p&gt;既然有了 WAL 实时存储了所有的变更，为什么还需要 snapshot 呢？随着使用量的增加，WAL 存储的数据会暴增，为了防止磁盘很快就爆满，etcd 默认每 10000 条记录做一次 snapshot，经过 snapshot 以后的 WAL 文件就可以删除。而通过 API 可以查询的历史 etcd 操作默认为 1000 条。&lt;/p&gt;
&lt;p&gt;首次启动时，etcd 会把启动的配置信息存储到&lt;code&gt;data-dir&lt;/code&gt;参数指定的数据目录中。配置信息包括本地节点的 ID、集群 ID 和初始时集群信息。用户需要避免 etcd 从一个过期的数据目录中重新启动，因为使用过期的数据目录启动的节点会与集群中的其他节点产生不一致（如：之前已经记录并同意 Leader 节点存储某个信息，重启后又向 Leader 节点申请这个信息）。所以，为了最大化集群的安全性，一旦有任何数据损坏或丢失的可能性，你就应该把这个节点从集群中移除，然后加入一个不带数据目录的新节点。&lt;/p&gt;
&lt;h4 id=&quot;heading28&quot; data-id-_718ba3ca2bb8=&quot;1&quot;&gt;6.1 预写式日志（WAL）&lt;/h4&gt;
&lt;p&gt;WAL（Write Ahead Log）最大的作用是记录了整个数据变化的全部历程。在 etcd 中，所有数据的修改在提交前，都要先写入到 WAL 中。使用 WAL 进行数据的存储使得 etcd 拥有两个重要功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;故障快速恢复： 当你的数据遭到破坏时，就可以通过执行所有 WAL 中记录的修改操作，快速从最原始的数据恢复到数据损坏前的状态。&lt;/li&gt;
&lt;li&gt;数据回滚（undo）/ 重做（redo）：因为所有的修改操作都被记录在 WAL 中，需要回滚或重做，只需要方向或正向执行日志中的操作即可。&lt;/li&gt;

&lt;/ul&gt;
&lt;h4 id=&quot;heading29&quot; data-id-_3babebda5b98=&quot;1&quot;&gt;WAL 与 snapshot 在 etcd 中的命名规则&lt;/h4&gt;
&lt;p&gt;在 etcd 的数据目录中，WAL 文件以&lt;code&gt;$seq-$index.wal&lt;/code&gt;的格式存储。最初始的 WAL 文件是&lt;code&gt;0000000000000000-0000000000000000.wal&lt;/code&gt;，表示是所有 WAL 文件中的第 0 个，初始的 Raft 状态编号为 0。运行一段时间后可能需要进行日志切分，把新的条目放到一个新的 WAL 文件中。&lt;/p&gt;
&lt;p&gt;假设，当集群运行到 Raft 状态为 20 时，需要进行 WAL 文件的切分时，下一份 WAL 文件就会变为&lt;code&gt;0000000000000001-0000000000000021.wal&lt;/code&gt;。如果在 10 次操作后又进行了一次日志切分，那么后一次的 WAL 文件名会变为&lt;code&gt;0000000000000002-0000000000000031.wal&lt;/code&gt;。可以看到&lt;code&gt;-&lt;/code&gt;符号前面的数字是每次切分后自增 1，而&lt;code&gt;-&lt;/code&gt;符号后面的数字则是根据实际存储的 Raft 起始状态来定。&lt;/p&gt;
&lt;p&gt;snapshot 的存储命名则比较容易理解，以&lt;code&gt;$term-$index.wal&lt;/code&gt;格式进行命名存储。term 和 index 就表示存储 snapshot 时数据所在的 raft 节点状态，当前的任期编号以及数据项位置信息。&lt;/p&gt;
&lt;h4 id=&quot;heading30&quot; data-id-_b8848329893c=&quot;1&quot;&gt;6.2 关键部分源码解析&lt;/h4&gt;
&lt;p&gt;从代码逻辑中可以看到，WAL 有两种模式，读模式（read）和数据添加（append）模式，两种模式不能同时成立。一个新创建的 WAL 文件处于 append 模式，并且不会进入到 read 模式。一个本来存在的 WAL 文件被打开的时候必然是 read 模式，并且只有在所有记录都被读完的时候，才能进入 append 模式，进入 append 模式后也不会再进入 read 模式。这样做有助于保证数据的完整与准确。&lt;/p&gt;
&lt;p&gt;集群在进入到&lt;code&gt;etcdserver/server.go&lt;/code&gt;的&lt;code&gt;NewServer&lt;/code&gt;函数准备启动一个 etcd 节点时，会检测是否存在以前的遗留 WAL 数据。&lt;/p&gt;
&lt;p&gt;检测的第一步是查看 snapshot 文件夹下是否有符合规范的文件，若检测到 snapshot 格式是 v0.4 的，则调用函数升级到 v0.5。从 snapshot 中获得集群的配置信息，包括 token、其他节点的信息等等，然后载入 WAL 目录的内容，从小到大进行排序。根据 snapshot 中得到的 term 和 index，找到 WAL 紧接着 snapshot 下一条的记录，然后向后更新，直到所有 WAL 包的 entry 都已经遍历完毕，Entry 记录到 ents 变量中存储在内存里。此时 WAL 就进入 append 模式，为数据项添加进行准备。&lt;/p&gt;
&lt;p&gt;当 WAL 文件中数据项内容过大达到设定值（默认为 10000）时，会进行 WAL 的切分，同时进行 snapshot 操作。这个过程可以在&lt;code&gt;etcdserver/server.go&lt;/code&gt;的&lt;code&gt;snapshot&lt;/code&gt;函数中看到。所以，实际上数据目录中有用的 snapshot 和 WAL 文件各只有一个，默认情况下 etcd 会各保留 5 个历史文件。&lt;/p&gt;
&lt;h3 id=&quot;heading31&quot; data-id-_cde55fa46139=&quot;1&quot;&gt;7 Raft&lt;/h3&gt;
&lt;p&gt;新版 etcd 中，raft 包就是对 Raft 一致性算法的具体实现。关于 Raft 算法的讲解，网上已经有很多文章，有兴趣的读者可以去阅读一下&lt;a href=&quot;https://ramcloud.stanford.edu/raft.pdf&quot; rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot;&gt; Raft 算法论文&lt;/a&gt;非常精彩。本文则不再对 Raft 算法进行详细描述，而是结合 etcd，针对算法中一些关键内容以问答的形式进行讲解。有关 Raft 算法的术语如果不理解，可以参见概念词汇表一节。&lt;/p&gt;
&lt;h4 id=&quot;heading32&quot; data-id-_076e14740b6e=&quot;1&quot;&gt;7.1 Raft 常见问答一览&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Raft 中一个 Term（任期）是什么意思？ Raft 算法中，从时间上，一个任期讲即从一次竞选开始到下一次竞选开始。从功能上讲，如果 Follower 接收不到 Leader 节点的心跳信息，就会结束当前任期，变为 Candidate 发起竞选，有助于 Leader 节点故障时集群的恢复。发起竞选投票时，任期值小的节点不会竞选成功。如果集群不出现故障，那么一个任期将无限延续下去。而投票出现冲突也有可能直接进入下一任再次竞选。&lt;img src=&quot;https://static001.infoq.cn/resource/image/74/e0/740e703fb347a074addb3be1e10d33e0.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 12 Term 示意图&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Raft 状态机是怎样切换的？ Raft 刚开始运行时，节点默认进入 Follower 状态，等待 Leader 发来心跳信息。若等待超时，则状态由 Follower 切换到 Candidate 进入下一轮 term 发起竞选，等到收到集群多数节点的投票时，该节点转变为 Leader。Leader 节点有可能出现网络等故障，导致别的节点发起投票成为新 term 的 Leader，此时原先的老 Leader 节点会切换为 Follower。Candidate 在等待其它节点投票的过程中如果发现别的节点已经竞选成功成为 Leader 了，也会切换为 Follower 节点。&lt;img src=&quot;https://static001.infoq.cn/resource/image/16/3b/167e2a4f72b05a18425e7ab3baf7a03b.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 13 Raft 状态机&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何保证最短时间内竞选出 Leader，防止竞选冲突？ 在 Raft 状态机一图中可以看到，在 Candidate 状态下， 有一个 times out，这里的 times out 时间是个随机值，也就是说，每个机器成为 Candidate 以后，超时发起新一轮竞选的时间是各不相同的，这就会出现一个时间差。在时间差内，如果 Candidate1 收到的竞选信息比自己发起的竞选信息 term 值大（即对方为新一轮 term），并且新一轮想要成为 Leader 的 Candidate2 包含了所有提交的数据，那么 Candidate1 就会投票给 Candidate2。这样就保证了只有很小的概率会出现竞选冲突。&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何防止别的 Candidate 在遗漏部分数据的情况下发起投票成为 Leader？ Raft 竞选的机制中，使用随机值决定超时时间，第一个超时的节点就会提升 term 编号发起新一轮投票，一般情况下别的节点收到竞选通知就会投票。但是，如果发起竞选的节点在上一个 term 中保存的已提交数据不完整，节点就会拒绝投票给它。通过这种机制就可以防止遗漏数据的节点成为 Leader。&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Raft 某个节点宕机后会如何？ 通常情况下，如果是 Follower 节点宕机，如果剩余可用节点数量超过半数，集群可以几乎没有影响的正常工作。如果是 Leader 节点宕机，那么 Follower 就收不到心跳而超时，发起竞选获得投票，成为新一轮 term 的 Leader，继续为集群提供服务。需要注意的是；etcd 目前没有任何机制会自动去变化整个集群总共的节点数量，即如果没有人为的调用 API，etcd 宕机后的节点仍然被计算为总节点数中，任何请求被确认需要获得的投票数都是这个总数的半数以上。&lt;img src=&quot;https://static001.infoq.cn/resource/image/6c/59/6c0d225b6ab0cbb4a89afd4b12de0c59.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 14 节点宕机&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么 Raft 算法在确定可用节点数量时不需要考虑拜占庭将军问题？ 拜占庭问题中提出，允许 n 个节点宕机还能提供正常服务的分布式架构，需要的总节点数量为 3n+1，而 Raft 只需要 2n+1 就可以了。其主要原因在于，拜占庭将军问题中存在数据欺骗的现象，而 etcd 中假设所有的节点都是诚实的。etcd 在竞选前需要告诉别的节点自身的 term 编号以及前一轮 term 最终结束时的 index 值，这些数据都是准确的，其他节点可以根据这些值决定是否投票。另外，etcd 严格限制 Leader 到 Follower 这样的数据流向保证数据一致不会出错。&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户从集群中哪个节点读写数据？ Raft 为了保证数据的强一致性，所有的数据流向都是一个方向，从 Leader 流向 Follower，也就是所有 Follower 的数据必须与 Leader 保持一致，如果不一致会被覆盖。即所有用户更新数据的请求都最先由 Leader 获得，然后存下来通知其他节点也存下来，等到大多数节点反馈时再把数据提交。一个已提交的数据项才是 Raft 真正稳定存储下来的数据项，不再被修改，最后再把提交的数据同步给其他 Follower。因为每个节点都有 Raft 已提交数据准确的备份（最坏的情况也只是已提交数据还未完全同步），所以读的请求任意一个节点都可以处理。&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;etcd 实现的 Raft 算法性能如何？ 单实例节点支持每秒 1000 次数据写入。节点越多，由于数据同步涉及到网络延迟，会根据实际情况越来越慢，而读性能会随之变强，因为每个节点都能处理用户请求。&lt;/p&gt;

&lt;/li&gt;

&lt;/ul&gt;
&lt;h4 id=&quot;heading33&quot; data-id-_48853afd60f6=&quot;1&quot;&gt;7.2 关键部分源码解析&lt;/h4&gt;
&lt;p&gt;在 etcd 代码中，Node 作为 Raft 状态机的具体实现，是整个算法的关键，也是了解算法的入口。&lt;/p&gt;
&lt;p&gt;在 etcd 中，对 Raft 算法的调用如下，你可以在&lt;code&gt;etcdserver/raft.go&lt;/code&gt;中的&lt;code&gt;startNode&lt;/code&gt;找到：&lt;/p&gt;

&lt;table class=&quot;hljs-ln&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;storage := raft.NewMemoryStorage()&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;n := raft.StartNode(&lt;span class=&quot;hljs-number&quot;&gt;0x01, []&lt;span class=&quot;hljs-built_in&quot;&gt;int64{&lt;span class=&quot;hljs-number&quot;&gt;0x02, &lt;span class=&quot;hljs-number&quot;&gt;0x03}, &lt;span class=&quot;hljs-number&quot;&gt;3, &lt;span class=&quot;hljs-number&quot;&gt;1, storage)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;

&lt;/tbody&gt;

&lt;/table&gt;
&lt;p&gt;通过这段代码可以了解到，Raft 在运行过程记录数据和状态都是保存在内存中，而代码中&lt;code&gt;raft.StartNode&lt;/code&gt;启动的 Node 就是 Raft 状态机 Node。启动了一个 Node 节点后，Raft 会做如下事项。&lt;/p&gt;
&lt;p&gt;首先，你需要把从集群的其他机器上收到的信息推送到 Node 节点，你可以在&lt;code&gt;etcdserver/server.go&lt;/code&gt;中的&lt;code&gt;Process&lt;/code&gt;函数看到。&lt;/p&gt;

&lt;table class=&quot;hljs-ln&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;func (s *EtcdServer) &lt;span class=&quot;hljs-constructor&quot;&gt;Process(&lt;span class=&quot;hljs-params&quot;&gt;ctx &lt;span class=&quot;hljs-params&quot;&gt;context.Context, &lt;span class=&quot;hljs-params&quot;&gt;m &lt;span class=&quot;hljs-params&quot;&gt;raftpb.Message) error {&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if m.Type&lt;span class=&quot;hljs-operator&quot;&gt; == raftpb.MsgApp {&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;s.stats.&lt;span class=&quot;hljs-constructor&quot;&gt;RecvAppendReq(&lt;span class=&quot;hljs-params&quot;&gt;types.ID(&lt;span class=&quot;hljs-params&quot;&gt;m.From).&lt;span class=&quot;hljs-constructor&quot;&gt;String(), m.&lt;span class=&quot;hljs-constructor&quot;&gt;Size())&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;}&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;return s.node.&lt;span class=&quot;hljs-constructor&quot;&gt;Step(&lt;span class=&quot;hljs-params&quot;&gt;ctx, &lt;span class=&quot;hljs-params&quot;&gt;m)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;}&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;

&lt;/tbody&gt;

&lt;/table&gt;
&lt;p&gt;在检测发来请求的机器是否是集群中的节点，自身节点是否是 Follower，把发来请求的机器作为 Leader，具体对 Node 节点信息的推送和处理则通过&lt;code&gt;node.Step()&lt;/code&gt;函数实现。&lt;/p&gt;
&lt;p&gt;其次，你需要把日志项存储起来，在你的应用中执行提交的日志项，然后把完成信号发送给集群中的其它节点，再通过&lt;code&gt;node.Ready()&lt;/code&gt;监听等待下一次任务执行。有一点非常重要，你必须确保在你发送完成消息给其他节点之前，你的日志项内容已经确切稳定的存储下来了。&lt;/p&gt;
&lt;p&gt;最后，你需要保持一个心跳信号&lt;code&gt;Tick()&lt;/code&gt;。Raft 有两个很重要的地方用到超时机制：心跳保持和 Leader 竞选。需要用户在其 raft 的 Node 节点上周期性的调用 Tick() 函数，以便为超时机制服务。&lt;/p&gt;
&lt;p&gt;综上所述，整个 raft 节点的状态机循环类似如下所示：&lt;/p&gt;

&lt;table class=&quot;hljs-ln&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;for {&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;select {&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt; case &amp;lt;-s.Ticker:&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;n&lt;span class=&quot;hljs-variable&quot;&gt;.Tick()&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;case rd := &amp;lt;-s&lt;span class=&quot;hljs-variable&quot;&gt;.Node&lt;span class=&quot;hljs-variable&quot;&gt;.Ready():&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;saveToStorage(rd&lt;span class=&quot;hljs-variable&quot;&gt;.State, rd&lt;span class=&quot;hljs-variable&quot;&gt;.Entries)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;send(rd&lt;span class=&quot;hljs-variable&quot;&gt;.Messages)&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;process(rd&lt;span class=&quot;hljs-variable&quot;&gt;.CommittedEntries)&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;s&lt;span class=&quot;hljs-variable&quot;&gt;.Node&lt;span class=&quot;hljs-variable&quot;&gt;.Advance()&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;case &amp;lt;-s&lt;span class=&quot;hljs-variable&quot;&gt;.done:&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;return&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;}&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;}&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;

&lt;/tbody&gt;

&lt;/table&gt;
&lt;p&gt;而这个状态机真实存在的代码位置为&lt;code&gt;etcdserver/server.go&lt;/code&gt;中的&lt;code&gt;run&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;对状态机进行状态变更（如用户数据更新等）则是调用&lt;code&gt;n.Propose(ctx, data)&lt;/code&gt;函数，在存储数据时，会先进行序列化操作。获得大多数其他节点的确认后，数据会被提交，存为已提交状态。&lt;/p&gt;
&lt;p&gt;之前提到 etcd 集群的启动需要借助别的 etcd 集群或者 DNS，而启动完毕后这些&lt;code&gt;外力&lt;/code&gt;就不需要了，etcd 会把自身集群的信息作为状态存储起来。所以要变更自身集群节点数量实际上也需要像用户数据变更那样添加数据条目到 Raft 状态机中。这一切由&lt;code&gt;n.ProposeConfChange(ctx, cc)&lt;/code&gt;实现。当集群配置信息变更的请求同样得到大多数节点的确认反馈后，再进行配置变更的正式操作，代码如下。&lt;/p&gt;

&lt;table class=&quot;hljs-ln&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;var cc raftpb.ConfChange&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;cc.&lt;span class=&quot;hljs-constructor&quot;&gt;Unmarshal(&lt;span class=&quot;hljs-params&quot;&gt;data)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;n.&lt;span class=&quot;hljs-constructor&quot;&gt;ApplyConfChange(&lt;span class=&quot;hljs-params&quot;&gt;cc)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;

&lt;/tr&gt;

&lt;/tbody&gt;

&lt;/table&gt;
&lt;p&gt;注意：一个 ID 唯一性的表示了一个集群，所以为了避免不同 etcd 集群消息混乱，ID 需要确保唯一性，不能重复使用旧的 token 数据作为 ID。&lt;/p&gt;
&lt;h3 id=&quot;heading34&quot; data-id-_31bb4a305454=&quot;1&quot;&gt;8 Store&lt;/h3&gt;
&lt;p&gt;Store 这个模块顾名思义，就像一个商店把 etcd 已经准备好的各项底层支持加工起来，为用户提供五花八门的 API 支持，处理用户的各项请求。要理解 Store，只需要从 etcd 的 API 入手即可。V2参考&lt;a href=&quot;https://github.com/etcd-io/etcd/blob/v3.4.14/Documentation/v2/api.md&quot; target=&quot;_blank&quot;&gt; etcd 的 API 列表&lt;/a&gt;，&lt;a href=&quot;https://github.com/etcd-io/etcd/blob/v3.4.14/Documentation/demo.md&quot; target=&quot;_blank&quot;&gt;V3命令行参考这&lt;/a&gt;， &lt;a href=&quot;https://github.com/etcd-io/etcd/blob/v3.4.14/Documentation/dev-guide/api_grpc_gateway.md&quot; target=&quot;_blank&quot;&gt;v3 HTTP 参考这&lt;/a&gt;。我们可以看到有如下 API 是对 etcd 存储的键值进行的操作，亦即 Store 提供的内容。API 中提到的目录（Directory）和键（Key），上文中也可能称为 etcd 节点（Node）。&lt;/p&gt;
&lt;p&gt;　　对于新版本的 etcd server，默认是停用 V2的 HTTP API的，需要的话，可以加参数：--enable-v2 。以下是基于 V2的实践：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;为 etcd 存储的键赋值 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;curl -s http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:2379/v2/keys/message -XPUT -d value=&quot;Hello world&quot; |jq .&lt;/span&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;node&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;modifiedIndex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;9&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;createdIndex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;9&lt;/span&gt;&lt;span&gt;
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;prevNode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;modifiedIndex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;8&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;createdIndex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;8&lt;/span&gt;&lt;span&gt;
  }
}&lt;/span&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;table class=&quot;hljs-ln&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;反馈的内容含义如下：&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;- action: 刚刚进行的动作名称。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;- &lt;span class=&quot;hljs-type&quot;&gt;node&lt;span class=&quot;hljs-built_in&quot;&gt;.key: 请求的 HTTP 路径。etcd 使用一个类似文件系统的方式来反映键值存储的内容。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;- &lt;span class=&quot;hljs-type&quot;&gt;node.value: 刚刚请求的键所存储的内容。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;- &lt;span class=&quot;hljs-type&quot;&gt;node.createdIndex: etcd 节点每次有变化时都会自增的一个值，除了用户请求外，etcd 内部运行（如启动、集群信息变化等）也会对节点有变动而引起这个值的变化。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;- &lt;span class=&quot;hljs-type&quot;&gt;node.modifiedIndex: 类似 &lt;span class=&quot;hljs-type&quot;&gt;node.createdIndex，能引起 modifiedIndex 变化的操作包括 set, &lt;span class=&quot;hljs-keyword&quot;&gt;delete, &lt;span class=&quot;hljs-keyword&quot;&gt;update, create, compareAndSwap &lt;span class=&quot;hljs-keyword&quot;&gt;and compareAndDelete。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;- 查询 etcd 某个键存储的值&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;curl http://&lt;span class=&quot;hljs-number&quot;&gt;127.0.&lt;span class=&quot;hljs-number&quot;&gt;0.&lt;span class=&quot;hljs-number&quot;&gt;1:&lt;span class=&quot;hljs-number&quot;&gt;2379/v2/keys/message&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改键值：与创建新值几乎相同，但是反馈时会有一个&lt;code&gt;prevNode&lt;/code&gt;值反应了修改前存储的内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;curl -s http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:2379/v2/keys/message -XPUT -d value=&quot;Hello etcd&quot; | jq .&lt;/span&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;node&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello etcd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;modifiedIndex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;12&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;createdIndex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;12&lt;/span&gt;&lt;span&gt;
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;prevNode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello etcd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;modifiedIndex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;11&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;createdIndex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;11&lt;/span&gt;&lt;span&gt;
  }
}&lt;/span&gt;&lt;/pre&gt;
&lt;/div&gt;






&lt;ul&gt;
&lt;li&gt;自动在目录下创建有序键。在对创建的目录使用&lt;code&gt;POST&lt;/code&gt;参数，会自动在该目录下创建一个以 createdIndex 值为键的值，这样就相当于以创建时间先后严格排序了。这个 API 对分布式队列这类场景非常有用。 &lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;curl -s http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:2379/v2/keys/queue -XPOST -d value=Job1 |jq .&lt;br/&gt;&lt;/span&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;create&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;node&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/queue/00000000000000000021&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Job1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;modifiedIndex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;21&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;createdIndex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;21&lt;/span&gt;&lt;span&gt;
  }
}&lt;/span&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;curl -s http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:2379/v2/keys/queue -XPOST -d value=Job1 |jq .&lt;br/&gt;&lt;/span&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;create&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;node&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/queue/00000000000000000022&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Job1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;modifiedIndex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;22&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;createdIndex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;22&lt;/span&gt;&lt;span&gt;
  }
}&lt;/span&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;按顺序列出所有创建的有序键curl -s &lt;span&gt;&#x27;&lt;/span&gt;&lt;span&gt;http://127.0.0.1:2379/v2/keys/queue?recursive=true&amp;amp;sorted=true&lt;/span&gt;&lt;span&gt;&#x27;&lt;/span&gt;&lt;span&gt; |&lt;/span&gt;&lt;span&gt; jq .&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;





&lt;table class=&quot;hljs-ln&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;- 自动化 CAS（Compare-and-Swap）操作：etcd 强一致性最直观的表现就是这个 API，通过设定条件，阻止节点二次创建或修改。即用户的指令被执行当且仅当 CAS 的条件成立。条件有以下几个。 &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt; - prevValue 先前节点的值，如果值与提供的值相同才允许操作。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt; - prevIndex 先前节点的编号，编号与提供的校验编号相同才允许操作。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt; - prevExist 先前节点是否存在。如果存在则不允许操作。这个常常被用于分布式锁的唯一获取。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;假设先进行了如下操作：设定了 foo 的值。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt; &lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;curl -s http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:2379/v2/keys/foo\?prevExist\=false -XPUT -d value=three |jq .&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;errorCode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;105&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Key already exists&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cause&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;28&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt; &lt;/p&gt;

&lt;table class=&quot;hljs-ln&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;就会返回创建失败的错误。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;- 条件删除（Compare-and-Delete）：与 CAS 类似，条件成立后才能删除。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;- 创建目录&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;curl http:&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;span class=&quot;hljs-number&quot;&gt;127.0.&lt;span class=&quot;hljs-number&quot;&gt;0.1:&lt;span class=&quot;hljs-number&quot;&gt;2379&lt;span class=&quot;hljs-regexp&quot;&gt;/v2/keys/dir -XPUT -d dir=true&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;




&lt;table class=&quot;hljs-ln&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;相信看完这么多 API，读者已经对 Store 的工作内容基本了解了。它对 etcd 下存储的数据进行加工，创建出如文件系统般的树状结构供用户快速查询。它有一个&lt;span class=&quot;hljs-code&quot;&gt;`Watcher`用于节点变更的实时反馈，还需要维护一个&lt;span class=&quot;hljs-code&quot;&gt;`WatcherHub`对所有&lt;span class=&quot;hljs-code&quot;&gt;`Watcher`订阅者进行通知的推送。同时，它还维护了一个由定时键构成的小顶堆，快速返回下一个要超时的键。最后，所有这些 API 的请求都以事件的形式存储在事件队列中等待处理。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;





&lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;&lt;span class=&quot;hljs-section&quot;&gt;### 9 总结&lt;/span&gt;&lt;/p&gt;





&lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;通过从应用场景到源码分析的一系列回顾，我们了解到 etcd 并不是一个简单的分布式键值存储系统。它解决了分布式场景中最为常见的一致性问题，为服务发现提供了一个稳定高可用的消息注册仓库，为以微服务协同工作的架构提供了无限的可能。相信在不久的将来，通过 etcd 构建起来的大型系统会越来越多。&lt;/p&gt;





&lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;&lt;span class=&quot;hljs-section&quot;&gt;### 10 作者简介&lt;/span&gt;&lt;/p&gt;





&lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;孙健波，[&lt;span class=&quot;hljs-string&quot;&gt;浙江大学 SEL 实验室硕士研究生](&lt;span class=&quot;hljs-link&quot;&gt;http://www.sel.zju.edu.cn)，目前在云平台团队从事科研和开发工作。浙大团队对 PaaS、Docker、大数据和主流开源云计算技术有深入的研究和二次开发经验，团队现将部分技术文章贡献出来，希望能对读者有所帮助。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;





&lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;&lt;span class=&quot;hljs-section&quot;&gt;### 参考文献&lt;/span&gt;&lt;/p&gt;





&lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;1. &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;https://&lt;span class=&quot;hljs-attr&quot;&gt;github.com/&lt;span class=&quot;hljs-attr&quot;&gt;coreos/&lt;span class=&quot;hljs-attr&quot;&gt;etcd&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;





&lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;2. &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;https://&lt;span class=&quot;hljs-attr&quot;&gt;groups.google.com/&lt;span class=&quot;hljs-attr&quot;&gt;forum/#!&lt;span class=&quot;hljs-attr&quot;&gt;topic/&lt;span class=&quot;hljs-attr&quot;&gt;etcd-dev/&lt;span class=&quot;hljs-attr&quot;&gt;wmndjzBNdZo&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;





&lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;3. &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;http://&lt;span class=&quot;hljs-attr&quot;&gt;jm-blog.aliapp.com/?&lt;span class=&quot;hljs-attr&quot;&gt;p=&lt;span class=&quot;hljs-string&quot;&gt;1232&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;





&lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;4. &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;http://&lt;span class=&quot;hljs-attr&quot;&gt;progrium.com/&lt;span class=&quot;hljs-attr&quot;&gt;blog/&lt;span class=&quot;hljs-attr&quot;&gt;2014/&lt;span class=&quot;hljs-attr&quot;&gt;07/&lt;span class=&quot;hljs-attr&quot;&gt;29/&lt;span class=&quot;hljs-attr&quot;&gt;understanding-modern-service-discovery-with-docker/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;





&lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;5. &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;http://&lt;span class=&quot;hljs-attr&quot;&gt;devo.ps/&lt;span class=&quot;hljs-attr&quot;&gt;blog/&lt;span class=&quot;hljs-attr&quot;&gt;zookeeper-vs-doozer-vs-etcd/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;





&lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;6. &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;http://&lt;span class=&quot;hljs-attr&quot;&gt;jasonwilder.com/&lt;span class=&quot;hljs-attr&quot;&gt;blog/&lt;span class=&quot;hljs-attr&quot;&gt;2014/&lt;span class=&quot;hljs-attr&quot;&gt;02/&lt;span class=&quot;hljs-attr&quot;&gt;04/&lt;span class=&quot;hljs-attr&quot;&gt;service-discovery-in-the-cloud/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;





&lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;7. &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;http://&lt;span class=&quot;hljs-attr&quot;&gt;www.infoworld.com/&lt;span class=&quot;hljs-attr&quot;&gt;article/&lt;span class=&quot;hljs-attr&quot;&gt;2612082/&lt;span class=&quot;hljs-attr&quot;&gt;open-source-software/&lt;span class=&quot;hljs-attr&quot;&gt;has-apache-lost-its-way-.html&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;





&lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;8. &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;http://&lt;span class=&quot;hljs-attr&quot;&gt;en.wikipedia.org/&lt;span class=&quot;hljs-attr&quot;&gt;wiki/&lt;span class=&quot;hljs-attr&quot;&gt;WAL&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;





&lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;9. &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;http://&lt;span class=&quot;hljs-attr&quot;&gt;www.infoq.com/&lt;span class=&quot;hljs-attr&quot;&gt;cn/&lt;span class=&quot;hljs-attr&quot;&gt;articles/&lt;span class=&quot;hljs-attr&quot;&gt;coreos-analyse-etcd&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;





&lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;10. &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;http://&lt;span class=&quot;hljs-attr&quot;&gt;www.activestate.com/&lt;span class=&quot;hljs-attr&quot;&gt;blog/&lt;span class=&quot;hljs-attr&quot;&gt;2014/&lt;span class=&quot;hljs-attr&quot;&gt;05/&lt;span class=&quot;hljs-attr&quot;&gt;service-discovery-solutions&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;





&lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;11. &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;https://&lt;span class=&quot;hljs-attr&quot;&gt;ramcloud.stanford.edu/&lt;span class=&quot;hljs-attr&quot;&gt;raft.pdf&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;





&lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;- - - - - -&lt;/span&gt;&lt;/p&gt;





&lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;感谢 [&lt;span class=&quot;hljs-string&quot;&gt;郭蕾](&lt;span class=&quot;hljs-link&quot;&gt;http://www.infoq.com/cn/author/%E9%83%AD%E8%95%BE) 对本文的策划和审校。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;





&lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt; &lt;/td&gt;





&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;hljs-ln-numbers&quot;&gt; &lt;/td&gt;
&lt;td class=&quot;hljs-ln-code&quot;&gt;
&lt;p class=&quot;hljs-ln-line&quot;&gt;给 InfoQ 中文站投稿或者参与内容翻译工作，请邮件至 [&lt;span class=&quot;hljs-string&quot;&gt;editors@cn.infoq.com](&lt;span class=&quot;hljs-link&quot;&gt;mailto:editors@cn.infoq.com)。也欢迎大家通过新浪微博（[&lt;span class=&quot;hljs-string&quot;&gt;@InfoQ](&lt;span class=&quot;hljs-link&quot;&gt;http://www.weibo.com/infoqchina)）或者腾讯微博（[&lt;span class=&quot;hljs-string&quot;&gt;@InfoQ](&lt;span class=&quot;hljs-link&quot;&gt;http://t.qq.com/infoqchina)）关注我们，并与我们的编辑和其他读者朋友交流。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;





&lt;/td&gt;





&lt;/tr&gt;





&lt;/tbody&gt;





&lt;/table&gt;





&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>415c1f48dc9a345b73b317a631da79a3</guid>
<title>C++ 模板参数：按值传递 vs 按引用传递</title>
<link>https://toutiao.io/k/47y0xnb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;按值传递&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;按引用传递&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;引用不会 Decay&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;传递 const reference&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;传递 nonconst reference&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;传递 universal reference&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;使用 std::ref()和 std::cref()&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;区分指针和数组&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;处理返回值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模板参数声明的推荐&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;std::make_pair()模板参数历史演进&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;按值传递&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大多数人不喜欢将参数设置为按值传递的原因是怕参数拷贝的过程中带来的性能问题，但是不是所有按值传递都会有参数拷贝，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;template&lt;/span&gt;&amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;printV&lt;/span&gt; &lt;span&gt;(T arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; &lt;span&gt;returnString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; s = &lt;span&gt;&quot;hi&quot;&lt;/span&gt;;&lt;br/&gt;printV(s);                         &lt;span&gt;// copy constructor&lt;/span&gt;&lt;br/&gt;printV(&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt;(&lt;span&gt;&quot;hi&quot;&lt;/span&gt;));        &lt;span&gt;// copying usually optimized away (if not, move constructor)&lt;/span&gt;&lt;br/&gt;printV(returnString());           &lt;span&gt;// copying usually optimized away (if not, move constructor)&lt;/span&gt;&lt;br/&gt;printV(&lt;span&gt;std&lt;/span&gt;::move(s));            &lt;span&gt;// move constructor&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们逐一看一下上面的 4 个调用：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一个 : 我们传递了一个 lvalue，这会使用 std::string 的&lt;code&gt;copy constructor&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二和第三个 : 这里传递的是 prvalue(随手创建的临时对象或者函数返回的临时对象)，一般情况下编译器会进行参数传递的优化，不会导致&lt;code&gt;copy constructor&lt;/code&gt; （&lt;strong&gt;这个也是 C++17 的新特性：&lt;span&gt;Mandatory Copy Elision or Passing Unmaterialized Objects&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第四个 : 传递的是 xvalue(一个使用过 std::move 后的对象)，这会调用&lt;code&gt;move constructor&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然上面 4 种情况只有第一种才会调用&lt;code&gt;copy constructor&lt;/code&gt;，但是这种情况才是最常见的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Decay&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;之前的文章介绍过，当模板参数是值传递时，会造成参数 decay:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;丢失 const 和 volatile 属性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;丢失引用类型。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;传递数组时，模板参数会 decay 成指针。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;template&lt;/span&gt;&amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;printV&lt;/span&gt; &lt;span&gt;(T arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; c = &lt;span&gt;&quot;hi&quot;&lt;/span&gt;;&lt;br/&gt;printV(c);         &lt;span&gt;// c decays so that arg has type std::string&lt;/span&gt;&lt;br/&gt;printV(&lt;span&gt;&quot;hi&quot;&lt;/span&gt;);    &lt;span&gt;// decays to pointer so that arg has type char const*&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; arr[&lt;span&gt;4&lt;/span&gt;];&lt;br/&gt;printV(arr);    &lt;span&gt;// decays to pointer so that arg has type char const*&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式有优点也有缺点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;优点：能够统一处理 decay 后的指针，而不必区分是&lt;code&gt;char const*&lt;/code&gt;还是类似&lt;code&gt;const char[13]&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缺点：无法区分传递的是一个数组还是一个指向单一元素的指针，因为 decay 后的类型都是&lt;code&gt;char const*&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;按引用传递&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按引用传递不会拷贝参数，也不会有上面提到的 decay。这看起来很美好，但是有时候也会有问题：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;传递 const reference&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;template&lt;/span&gt;&amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;printR&lt;/span&gt; &lt;span&gt;(&lt;span&gt;const&lt;/span&gt; T&amp;amp; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; &lt;span&gt;returnString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; s = &lt;span&gt;&quot;hi&quot;&lt;/span&gt;;&lt;br/&gt;printR(s);         &lt;span&gt;// no copy&lt;/span&gt;&lt;br/&gt;printR(&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt;(&lt;span&gt;&quot;hi&quot;&lt;/span&gt;));     &lt;span&gt;// no copy&lt;/span&gt;&lt;br/&gt;printR(returnString());       &lt;span&gt;// no copy&lt;/span&gt;&lt;br/&gt;printR(&lt;span&gt;std&lt;/span&gt;::move(s));         &lt;span&gt;// no copy&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是上面的例子，但是当模板参数声明改为&lt;code&gt;const T&amp;amp;&lt;/code&gt;后，所有的调用都不会有拷贝。那么哪里会有问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家都知道，传递引用时，实际传递的是一个地址，那么编译器在编译时不知道调用者会针对这个地址做什么操作。理论上，调用者可以随意改变这个地址指向的值（这里虽然声明为 const，但是仍然有&lt;code&gt;const_cast&lt;/code&gt;可以去除 const）。因此，编译器会假设所有该地址的缓存（通常为寄存器）在该函数调用后都会失效，如果要使用该地址的值，会重新从内存中载入。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;引用不会 Decay&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前文章介绍过，按引用传递不会 decay。因此如果传递的数组，那么推断参数类型时不会 decay 成指针，并且 const 和 volatile 都会被保留。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;template&lt;/span&gt;&amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;printR&lt;/span&gt; &lt;span&gt;(T &lt;span&gt;const&lt;/span&gt;&amp;amp; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; c = &lt;span&gt;&quot;hi&quot;&lt;/span&gt;;&lt;br/&gt;printR(c);         &lt;span&gt;// T deduced as std::string, arg is std::string const&amp;amp;&lt;/span&gt;&lt;br/&gt;printR(&lt;span&gt;&quot;hi&quot;&lt;/span&gt;);      &lt;span&gt;// T deduced as char[3], arg is char const(&amp;amp;)[3]&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; arr[&lt;span&gt;4&lt;/span&gt;];&lt;br/&gt;printR(arr);       &lt;span&gt;// T deduced as int[4], arg is int const(&amp;amp;)[4]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，在 printR 函数内通过 T 声明的变量没有 const 属性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;传递 nonconst reference&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想改变参数的值并且不希望拷贝，那么会使用这种情况。但是这时我们不能绑定 prvalue 和 xvalue 给一个 nonconst reference（这是 c++的一个&lt;span&gt;规则&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;template&lt;/span&gt;&amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;outR&lt;/span&gt; &lt;span&gt;(T&amp;amp; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; &lt;span&gt;returnString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; s = &lt;span&gt;&quot;hi&quot;&lt;/span&gt;;&lt;br/&gt;outR(s);          &lt;span&gt;// OK: T deduced as std::string, arg is std::string&amp;amp;&lt;/span&gt;&lt;br/&gt;outR(&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt;(&lt;span&gt;&quot;hi&quot;&lt;/span&gt;));       &lt;span&gt;// ERROR: not allowed to pass a temporary (prvalue)&lt;/span&gt;&lt;br/&gt;outR(returnString());        &lt;span&gt;// ERROR: not allowed to pass a temporary (prvalue)&lt;/span&gt;&lt;br/&gt;outR(&lt;span&gt;std&lt;/span&gt;::move(s));          &lt;span&gt;// ERROR: not allowed to pass an xvalue&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，这种情况不会发生 decay:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; arr[&lt;span&gt;4&lt;/span&gt;];&lt;br/&gt;outR(arr);          &lt;span&gt;// OK: T deduced as int[4], arg is int(&amp;amp;)[4]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;传递 universal reference&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个也是声明参数为引用的一个重要场景：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;template&lt;/span&gt;&amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;passR&lt;/span&gt; &lt;span&gt;(T&amp;amp;&amp;amp; arg)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;// arg declared as forwarding reference&lt;/span&gt;&lt;br/&gt;...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; s = &lt;span&gt;&quot;hi&quot;&lt;/span&gt;;&lt;br/&gt;passR(s);        &lt;span&gt;// OK: T deduced as std::string&amp;amp; (also the type of arg)&lt;/span&gt;&lt;br/&gt;passR(&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt;(&lt;span&gt;&quot;hi&quot;&lt;/span&gt;));     &lt;span&gt;// OK: T deduced as std::string, arg is std::string&amp;amp;&amp;amp;&lt;/span&gt;&lt;br/&gt;passR(returnString());        &lt;span&gt;// OK: T deduced as std::string, arg is std::string&amp;amp;&amp;amp;&lt;/span&gt;&lt;br/&gt;passR(&lt;span&gt;std&lt;/span&gt;::move(s));       &lt;span&gt;// OK: T deduced as std::string, arg is std::string&amp;amp;&amp;amp;&lt;/span&gt;&lt;br/&gt;passR(arr);          &lt;span&gt;// OK: T deduced as int(&amp;amp;)[4] (also the type of arg)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这里需要额外注意一下，这是 T 隐式被声明为引用的唯一情况：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;passR&lt;/span&gt;&lt;span&gt;(T &amp;amp;&amp;amp;arg)&lt;/span&gt; &lt;/span&gt;{     &lt;span&gt;// arg is a forwarding reference&lt;/span&gt;&lt;br/&gt;  T x;        &lt;span&gt;// for passed lvalues, x is a reference, which requires an initializer&lt;/span&gt;&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;foo(&lt;span&gt;42&lt;/span&gt;);    &lt;span&gt;// OK: T deduced as int&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; i;&lt;br/&gt;foo(i);    &lt;span&gt;// ERROR: T deduced as int&amp;amp;, which makes the declaration of x in passR() invalid&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;使用 std::ref()和 std::cref()&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要用来“喂”reference 给函数模板，后者原本以按值传递的方式接受参数，这往往允许函数模板得以操作 reference 而不需要另写特化版本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;foo&lt;/span&gt; &lt;span&gt;(T val)&lt;/span&gt; &lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;...&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; x;&lt;br/&gt;foo (&lt;span&gt;std&lt;/span&gt;: :ref(x));&lt;br/&gt;foo (&lt;span&gt;std&lt;/span&gt;: :cref(x));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个特性被 C++标准库运用于各个地方，例如:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;make_pair()&lt;/code&gt;用此特性于是能够创建一个 pair&amp;lt;&amp;gt; of references.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;make_tuple()&lt;/code&gt;用此特性于是能够创建一个 tuple&amp;lt;&amp;gt; of references.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Binder&lt;/code&gt;用此特性于是能够绑定(bind) reference.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Thread&lt;/code&gt;用此特性于是能够以 by reference 形式传递实参。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意 std::ref()不是真的将参数变为引用，只是创建了一个 std::reference_wrapper&amp;lt;&amp;gt;对象，该对象引用了原始的变量，然后将 std::reference_wrapper&amp;lt;&amp;gt;传给了参数。&lt;strong&gt;std::reference_wrapper&amp;lt;&amp;gt;支持的一个重要操作是：向原始类型的隐式转换：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;functional&amp;gt; // for std::cref()&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;printString&lt;/span&gt;&lt;span&gt;(&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; &lt;span&gt;const&lt;/span&gt;&amp;amp; s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; s &amp;lt;&amp;lt; &lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;template&lt;/span&gt;&amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;printT&lt;/span&gt; &lt;span&gt;(T arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  printString(arg);     &lt;span&gt;// might convert arg back to std::string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; s = &lt;span&gt;&quot;hello&quot;&lt;/span&gt;;&lt;br/&gt;  printT(s); &lt;span&gt;// print s passed by value&lt;/span&gt;&lt;br/&gt;  printT(&lt;span&gt;std&lt;/span&gt;::cref(s)); &lt;span&gt;// print s passed &quot;as if by reference&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;区分指针和数组&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面说过，按值传递的一个缺点是，无法区分调用参数是数组还是指针，因为数组会 decay 成指针。那如果有需要区分的需求，可以这么写：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;span&gt;typename&lt;/span&gt; T, &lt;span&gt;typename&lt;/span&gt; = &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;enable_if_t&lt;/span&gt;&amp;lt;&lt;span&gt;std&lt;/span&gt;::is_array_v&amp;lt;T&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; foo(T &amp;amp;&amp;amp;arg1, T &amp;amp;&amp;amp;arg2) {&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;std::enable_if&lt;/code&gt;后面会介绍，它的意思是，假如不符合 enable_if 设置的条件，那么该模板会被禁用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实现在基本上也不用原始数组和字符串了，都用 std::string、std::vector、std::array。但是假如写模板的话，这些因素还是需要考虑进去。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;处理返回值&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般在下面情况下，返回值会被声明为引用：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;返回容器或者字符串中的元素(eg. operator[]、front())&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修改类成员变量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;链式调用(operator&amp;lt;&amp;lt;、operator&amp;gt;&amp;gt;、operator=)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是将返回值声明为引用需要格外小心：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;auto&lt;/span&gt; s = &lt;span&gt;std&lt;/span&gt;::make_shared&amp;lt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;whatever&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt;&amp;amp; c = (*s)[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;s.reset();&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; c;     &lt;span&gt;// run-time ERROR&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;确保返回值为值传递&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你确实想将返回值声明为值传递，仅仅声明 T 是不够的：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;forwarding reference 的情况，这个上面讨论过&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;template&lt;/span&gt;&amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;T &lt;span&gt;retR&lt;/span&gt;&lt;span&gt;(T&amp;amp;&amp;amp; p)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; T{...};        &lt;span&gt;// OOPS: returns by reference when called for lvalues&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt;&amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;  &lt;span&gt;// Note: T might become a reference&lt;/span&gt;&lt;br/&gt;&lt;span&gt;T &lt;span&gt;retV&lt;/span&gt;&lt;span&gt;(T p)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; T{...}; &lt;span&gt;// OOPS: returns a reference if T is a reference&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; x;&lt;br/&gt;retV&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;amp;&amp;gt;(x);     &lt;span&gt;// retT() instantiated for T as int&amp;amp;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，有两种方法是安全的：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;std::remove_reference&amp;lt;&amp;gt; :&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt;&amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;typename&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;::remove_reference&amp;lt;T&amp;gt;::&lt;span&gt;type &lt;span&gt;retV&lt;/span&gt;&lt;span&gt;(T p)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; T{...};     &lt;span&gt;// always returns by value&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;template&lt;/span&gt;&amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; &lt;span&gt;retV&lt;/span&gt;&lt;span&gt;(T p)&lt;/span&gt;  &lt;/span&gt;{     &lt;span&gt;// by-value return type deduced by compiler&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; T{...};      &lt;span&gt;// always returns by value&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前文章讨论过 auto 推断类型的规则，会忽略引用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;模板参数声明的推荐&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;按值传递&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数组和字符串会 decay。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;性能问题(可以使用 std::ref 和 std::cref 来避免，但是要小心这么做是有效的)。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;按引用传递&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;性能更好。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要 forwarding references，并且注意此时模板参数为隐式的引用类型。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要对参数是数组和字符串的情况额外关注。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;一般性建议&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应模板参数，一般建议如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;默认情况下，使用按值传递。理由：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;简单，尤其是对于参数是数组和字符串的情况。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于小对象而言，性能也不错。调用者可以使用 std::ref 和 std::cref.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;有如下理由时，使用按引用传递：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;需要函数改变参数的值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要 perfect forwarding。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;拷贝参数的性能不好。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;如果你对自己的程序足够了解，当然可以不遵守上面的建议，但是不要仅凭直觉就对性能做评估。最好的方法是：测试。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;不要将模板参数设计的太通用&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如你的模板函数只想接受 vector，那么完全可以定义成：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;template&lt;/span&gt;&amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;printVector&lt;/span&gt; &lt;span&gt;(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;T&amp;gt;&amp;amp; v)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里就没有必要定义为&lt;code&gt;const T&amp;amp; v&lt;/code&gt;.&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;std::make_pair()模板参数历史演进&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;std::make_pair()&lt;/code&gt;是一个很好演示模板参数机制的例子：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在 C++98 中，&lt;code&gt;make_pair&amp;lt;&amp;gt;()&lt;/code&gt;的参数被设计为按引用传递来避免不必要的拷贝：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;template&lt;/span&gt;&amp;lt;&lt;span&gt;typename&lt;/span&gt; T1, &lt;span&gt;typename&lt;/span&gt; T2&amp;gt;&lt;br/&gt;pair&amp;lt;T1,T2&amp;gt; &lt;span&gt;make_pair&lt;/span&gt; &lt;span&gt;(T1 &lt;span&gt;const&lt;/span&gt;&amp;amp; a, T2 &lt;span&gt;const&lt;/span&gt;&amp;amp; b)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; pair&amp;lt;T1,T2&amp;gt;(a,b);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是当使用存储不同长度的字符串或者数组时，这样做会导致严重的问题。这个问题记录在&lt;span&gt;See C++ library issue 181 [LibIssue181]&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;template&lt;/span&gt;&amp;lt;&lt;span&gt;typename&lt;/span&gt; T1, &lt;span&gt;typename&lt;/span&gt; T2&amp;gt;&lt;br/&gt;pair&amp;lt;T1,T2&amp;gt; &lt;span&gt;make_pair&lt;/span&gt; &lt;span&gt;(T1 a, T2 b)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; pair&amp;lt;T1,T2&amp;gt;(a,b);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;C++11 引入了移动语义，于是定义又改为(真实定义要比这个复杂一些)：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;span&gt;typename&lt;/span&gt; T1, &lt;span&gt;typename&lt;/span&gt; T2&amp;gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;constexpr&lt;/span&gt; pair&amp;lt;&lt;span&gt;typename&lt;/span&gt; decay&amp;lt;T1&amp;gt;::type, &lt;span&gt;typename&lt;/span&gt; decay&amp;lt;T2&amp;gt;::type&amp;gt;&lt;br/&gt;&lt;span&gt;make_pair&lt;/span&gt;&lt;span&gt;(T1 &amp;amp;&amp;amp;a, T2 &amp;amp;&amp;amp;b)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; pair&amp;lt;&lt;span&gt;typename&lt;/span&gt; decay&amp;lt;T1&amp;gt;::type, &lt;span&gt;typename&lt;/span&gt; decay&amp;lt;T2&amp;gt;::type&amp;gt;(&lt;br/&gt;      forward&amp;lt;T1&amp;gt;(a), forward&amp;lt;T2&amp;gt;(b));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标准库中 perfect forward 和 std::decay 是常见的搭配。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(完)&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Mandatory Copy Elision or Passing Unmaterialized Objects: &lt;em&gt;http://www.cplusplus2017.info/c17-guaranted-copy-elision/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;规则: &lt;em&gt;https://stackoverflow.com/questions/1565600/how-come-a-non-const-reference-cannot-bind-to-a-temporary-object&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;See C++ library issue 181 [LibIssue181]: &lt;em&gt;https://cplusplus.github.io/LWG/issue181&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>