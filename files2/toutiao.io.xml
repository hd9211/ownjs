<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>07312fc3dfc3c9b5c65794f1d6580560</guid>
<title>优质网站同好者周刊（第 071 期） | 倾城博客</title>
<link>https://toutiao.io/k/txv870b</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界。此周刊，将汇聚过去一周&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城&lt;/a&gt;所收录的内容，以飨同好；欢迎推荐或自荐（仅限有独立域名的网站，可以是二级域名）。您如果要了解收录要求，请参见&lt;a href=&quot;https://nicelinks.site/about?utm_source=weekly&quot;&gt;关于倾城&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：本周刊&lt;strong&gt;每周五&lt;/strong&gt;生成，首发于个人微信公众号&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI5MDIwMzM2Mg==&amp;amp;action=getalbum&amp;amp;album_id=1530765143352082433&amp;amp;scene=173&amp;amp;from_msgid=2650641087&amp;amp;from_itemidx=1&amp;amp;count=3#wechat_redirect&quot;&gt;晚晴幽草轩&lt;/a&gt;、博客&lt;a href=&quot;https://www.jeffjade.com&quot;&gt;晚晴幽草轩&lt;/a&gt;，以及&lt;a href=&quot;https://forum.lovejade.cn/&quot;&gt;悠然宜想亭&lt;/a&gt;社区；此一键生成脚本基于 &lt;a href=&quot;https://nicelinks.site/post/602d30aad099ff5688618591&quot;&gt;Deno&lt;/a&gt; 编写，并在 Github 开源：&lt;a href=&quot;https://github.com/nicejade/nicelinks-weekly&quot;&gt;nicejade/nicelinks-weekly&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/JavaScript&quot;&gt;&lt;code&gt;JavaScript&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E6%95%99%E7%A8%8B&quot;&gt;&lt;code&gt;教程&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/Web%E5%BC%80%E5%8F%91&quot;&gt;&lt;code&gt;Web开发&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;现代 JavaScript 教程：有关示例和任务的简单但详细的解释包括：闭包、文档和事件，以及面向对象编程等。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/zh.javascript.info.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - 现代 JavaScript 教程&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://zh.javascript.info/&quot;&gt;现代 JavaScript 教程&lt;/a&gt;，以最新的 JavaScript 标准为基准。通过简单但足够详细的内容，为你讲解从基础到高阶的 JavaScript 相关知识。该课程的核心内容，包含 2 部分，涵盖了 JavaScript 编程语言相关知识，以及浏览器行为。此外还有一系列的专题文章。其内容广泛，诸如：JavaScript 基础知识、代码质量、数据类型、函数进阶内容、原型，继承、错误处理、Promise，async/await、网络请求、动画、浏览器中存储数据、Web components、正则表达式等等，读了几篇，如 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://zh.javascript.info/currying-partials&quot;&gt;柯里化（Currying）&lt;/a&gt;，讲解深入浅出，通俗易懂，令人受益良多。无论您是前端入门初学者，还是资深开发，相信这份教程，都会产生积极作用。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62b460783cc95e702564e0d0&quot;&gt;倾城之链 - 现代 JavaScript 教程&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E6%A0%91%E8%8E%93%E6%B4%BE&quot;&gt;&lt;code&gt;树莓派&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%B5%84%E8%AE%AF&quot;&gt;&lt;code&gt;资讯&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%AD%A6%E4%B9%A0&quot;&gt;&lt;code&gt;学习&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：树莓派, raspberry pi, ARM, 单板机, 树莓派论坛&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;树莓派（Raspberry Pi）中文资讯站，提供丰富的树莓派教程和 DIY 资讯。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/shumeipai.nxez.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - 树莓派实验室 | Raspberry Pi 中文资讯站，提供丰富的树莓派使用教程和DIY资讯&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://shumeipai.nxez.com/&quot;&gt;树莓派实验室&lt;/a&gt;，树莓派（Raspberry Pi）中文资讯站，旨在提供丰富的&lt;code&gt;树莓派&lt;/code&gt;教程和 DIY 资讯。您可以在这里看到关于树莓派相关的分享（如相关导航、教程、资源下载等）；当然，您也可以在此分享内容，给予相当数量的树莓派玩家（该站每月有数万的树莓派爱好者访问），对于优质内容，他们会在微信公众号和姊妹站（&lt;a href=&quot;https://nicelinks.site/post/614836c548b293062990b35f&quot;&gt;趣小组&lt;/a&gt; 等）同步推送。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62b346983cc95e702564e0cd&quot;&gt;倾城之链 - 树莓派实验室 | Raspberry Pi 中文资讯站，提供丰富的树莓派使用教程和 DIY 资讯&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/Web%E5%BC%80%E5%8F%91&quot;&gt;&lt;code&gt;Web开发&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E6%A1%86%E6%9E%B6&quot;&gt;&lt;code&gt;框架&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/GraphQL&quot;&gt;&lt;code&gt;GraphQL&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Grow from side project to startup with RedwoodJS. Combines React, GraphQL, and Prisma for a full-stack app framework.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/redwoodjs.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - RedwoodJS: The App Framework for Startups&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;： &lt;a href=&quot;https://nicelinks.site/redirect?url=https://redwoodjs.com/&quot;&gt;RedwoodJS&lt;/a&gt; ，是一个开源的全栈 Web 框架，旨在帮助您从业余项目成长为初创公司。其使命是：帮助更多的初创公司，更快地探索更多的领域。RedwoodJS 制作一个更集成的框架，Redwood 具有端到端的开发工作流程， &lt;a href=&quot;https://nicelinks.site/post/5b1294b5e93ed2618cfac134&quot;&gt;将 React&lt;/a&gt; 、 &lt;a href=&quot;https://nicelinks.site/post/61c9a2d25be6454b4e3d5148&quot;&gt;GraphQL&lt;/a&gt; 、Prisma、 &lt;a href=&quot;https://nicelinks.site/post/6278fdeaac00ce3f9b11a8ef&quot;&gt;TypeScript&lt;/a&gt; 、Jest 和 Storybook 的最佳部分结合在一起。有关完整的灵感和愿景，请参阅 Redwood 的 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://github.com/redwoodjs/redwood/blob/main/README.md&quot;&gt;README.md 文件&lt;/a&gt; 。&lt;/p&gt;&lt;p&gt;选择了世界上最受欢迎的渲染引擎，来支持 Redwood 的 Web 前端。使用 React，您可以选择学习材料、设计系统和训练有素的员工。&lt;/p&gt;&lt;p&gt;随着项目的增长，需要与后端通信的客户端应用程序的数量也会增加。以 GraphQL API 为基础，您可以轻松地生活在多客户端世界中。&lt;/p&gt;&lt;p&gt;可选的 TypeScript 支持为您提供最好的 JavaScript 和最好的类型系统。即使你用 JS 构建你的应用程序，你仍然会得到杀手级的自动完成，因为 Redwood 本身是用 TypeScript 编写的。&lt;/p&gt;&lt;h3 id=&quot;prisma&quot;&gt;&lt;a href=&quot;#prisma&quot; aria-label=&quot;prisma permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;Prisma&lt;/h3&gt;&lt;p&gt;与您的数据库交互从未如此简单。Prisma 极受欢迎的 ORM 允许您更多地关注您的业务逻辑，而不是 SQL 的复杂性。&lt;/p&gt;&lt;h3 id=&quot;jest&quot;&gt;&lt;a href=&quot;#jest&quot; aria-label=&quot;jest permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;Jest&lt;/h3&gt;&lt;p&gt;知道您的关键代码路径已经过良好测试，晚上睡得很好。Redwood 通过“场景”增强了 Jest，使您可以轻松地为给定场景设置数据库，加上 GraphQL 模拟以轻松测试数据流。&lt;/p&gt;&lt;h3 id=&quot;storybook&quot;&gt;&lt;a href=&quot;#storybook&quot; aria-label=&quot;storybook permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;Storybook&lt;/h3&gt;&lt;p&gt;如果您使用 Storybook 单独设计您的组件，您不仅不必与您的框架争吵以查看它处于特定状态，而且您还可以免费构建一个全面的设计参考！&lt;/p&gt;&lt;p&gt;Redwood 应用程序，是一个 React 前端，与一个定制的 GraphQL API 对话。该 API 使用 Prisma 来操作数据库。开箱即可获得与 Jest 紧密集成的测试，与 Pino 的日志，以及与 Storybook 的 UI 组件目录。设置认证（如 Auth0）或 CSS 框架（如 Tailwind CSS）只需在一个命令行中调用。最重要的是，Redwood 的架构允许你部署到无服务器供应商（如 Netlify、Vercel），或传统的服务器和容器供应商（如 AWS、Render），两者之间几乎不需要改变代码。如果您在构建 Web 应用领域，没有足够的经验，Redwood 是非常值得运用起来的框架，它能免去您在各种技术中选择的苦恼。&lt;/p&gt;&lt;p&gt;另外值得一提的是， &lt;a href=&quot;https://nicelinks.site/redirect?url=https://redwoodjs.com/&quot;&gt;RedwoodJS&lt;/a&gt; 是由 Tom Preston-Werner 发起的最新&lt;strong&gt;开源&lt;/strong&gt;项目，他是 &lt;a href=&quot;https://nicelinks.site/post/59ba80d93df6765c75b77911&quot;&gt;GitHub&lt;/a&gt; 的联合创始人， &lt;a href=&quot;https://nicelinks.site/post/5c4c59c1a5957e07a40b3118&quot;&gt;Jekyll&lt;/a&gt; （最早也是最受欢迎的静态站点生成器之一）的创建者，Gravatar（最受欢迎的 avatar service)，语义版本控制规范的作者（为 Node 打包生态系统提供支持），以及 TOML（许多项目使用的一种明显的、最小的配置语言）的发明者。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62b1c13ba00b101b220aa7f1&quot;&gt;倾城之链 - RedwoodJS: The App Framework for Startups&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/JavaScript&quot;&gt;&lt;code&gt;JavaScript&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%BC%96%E7%A8%8B&quot;&gt;&lt;code&gt;编程&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;A practical functional library for JavaScript programmers. 一款实用的 JavaScript 函数式编程库。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/ramda.cn.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Ramda Documentation&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://ramda.cn/&quot;&gt;Ramda&lt;/a&gt;，一款实用的 JavaScript 函数式编程库。它具备以下特性：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Ramda 强调更加&lt;strong&gt;纯粹的函数式&lt;/strong&gt;风格。数据不变性和函数无副作用是其核心设计理念。这可以帮助你使用简洁、优雅的代码来完成工作。&lt;/li&gt;&lt;li&gt;Ramda 函数本身都是自动&lt;code&gt;柯里化&lt;/code&gt;的。这可以让你在只提供部分参数的情况下，轻松地在已有函数的基础上创建新函数。&lt;/li&gt;&lt;li&gt;Ramda 函数参数的排列顺序更便于柯里化。要操作的数据通常在最后面。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;最后两点一起，使得将多个函数构建为简单的函数序列变得非常容易，每个函数对数据进行变换，并将结果传递给下一个函数。Ramda 的设计能很好地支持这种风格的编程。&lt;/p&gt;&lt;h3 id=&quot;ramda-理念&quot;&gt;&lt;a href=&quot;#ramda-%E7%90%86%E5%BF%B5&quot; aria-label=&quot;ramda 理念 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;Ramda 理念&lt;/h3&gt;&lt;p&gt;使用 Ramda 时，应该感觉像使用原生 JavaScript 一样，它是实用且函数式的 JavaScript。Ramda 没有在字符串中引入 lambda 表达式，也没有借用 consed 列表，更不是要移植所有的 Clojure 函数。Ramda 基本的数据结构都是原生 JavaScript 对象，常用的集合是 JavaScript 的数组。&lt;/p&gt;&lt;p&gt;Ramda 还保留了许多其他原生 JavaScript 特性，例如，函数是具有属性的对象。函数式编程，优势主要体现在：&lt;strong&gt;数据不变性&lt;/strong&gt;和&lt;strong&gt;函数无副作用&lt;/strong&gt;两方面。虽然 Ramda 没有对此特别加强，但它在这两方面支持的非常好。最后但同样重要的是，Ramda 追求性能。可靠且快速的实现胜过任何功能纯度的概念。&lt;/p&gt;&lt;p&gt;目前已经存在许多优秀的函数式的库。通常它们作为通用工具包，可以用于多种编程范式。Ramda 的目标更为专注：专门为函数式编程风格而设计，更容易创建函数式 pipeline、且从不改变用户已有数据。&lt;/p&gt;&lt;p&gt;就个人多年编程开发而言，没有更好和更坏的范式。有经验的开发人员，可以看到每种范式的优点，并为给定的问题选择相对更合适的。过程式编程，并不是说你不能使用函数；函数式编程也不会阻止你使用“类”。这些范式，只是以一种随代码增长而有益的方式，来帮助解决问题。关于&lt;strong&gt;函数式编程&lt;/strong&gt;，有参考各种资料，梳理出博文：&lt;a href=&quot;https://forum.lovejade.cn/d/182&quot;&gt;浅谈关于「函数式编程」的理解&lt;/a&gt;；感兴趣的朋友可以了解下，相信当您恰当运行函数式编程思想，可以让您的代码更为优雅，易于阅读、扩展、维护。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62b1b5cba00b101b220aa7ef&quot;&gt;倾城之链 - Ramda Documentation&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/Deno&quot;&gt;&lt;code&gt;Deno&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E6%A1%86%E6%9E%B6&quot;&gt;&lt;code&gt;框架&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/Web%E5%BC%80%E5%8F%91&quot;&gt;&lt;code&gt;Web开发&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Just in time edge rendering, island based interactivity, and no configuration TypeScript support using Deno.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/fresh.deno.dev.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - fresh - The next-gen web framework.&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://fresh.deno.dev/&quot;&gt;Fresh&lt;/a&gt; ，是下一代 Web 框架，基于 &lt;a href=&quot;https://nicelinks.site/post/602d30aad099ff5688618591&quot;&gt;Deno&lt;/a&gt; ，专为速度、可靠性和简单性而构建（在 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://github.com/lucacasonato/fresh&quot;&gt;Github 开源&lt;/a&gt;）。它具备一些突出的特点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;边缘&lt;strong&gt;实时渲染。&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;基于岛屿的客户水合作用&lt;/strong&gt;可实现最大的互动性。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;零运行时开销&lt;/strong&gt;：默认情况下不向客户端发送 JS。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;没有构建步骤&lt;/strong&gt;。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;无需配置&lt;/strong&gt;。&lt;/li&gt;&lt;li&gt;开箱即用的&lt;strong&gt;TypeScript 支持&lt;/strong&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Fresh 采用了久经考验的服务器端渲染设计和客户端的渐进增强。它是一个面向 JavaScript 和 TypeScript 开发人员的全栈现代 Web 框架，旨在&lt;strong&gt;让创建高质量、高性能和个性化的 Web 应用程序变得轻而易举&lt;/strong&gt;。您可以使用它来创建您的主页、博客、大型 Web 应用程序（如 GitHub 或 Twitter）或您能想到的任何其他内容。&lt;/p&gt;&lt;p&gt;Fresh 的核心是&lt;strong&gt;路由框架和模板引擎的组合&lt;/strong&gt;，可在服务器上按需呈现页面。除了在服务器上的这种即时 (JIT) 渲染之外，Fresh 还提供了一个接口，用于在客户端无缝渲染一些组件，以实现最大的交互性。该框架使用 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://preactjs.com/&quot;&gt;Preact&lt;/a&gt; 和 JSX 在服务器和客户端上进行渲染和模板化。&lt;/p&gt;&lt;p&gt;Fresh 也没有构建步骤。你写的代码也直接是在服务器上运行的代码，在客户端上执行的代码。将 TypeScript 或 JSX 转换为纯 JavaScript 的任何必要转换都是在需要时即时完成的。这允许非常快速的迭代循环和非常非常快速的部署。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62b07261a00b101b220aa7ec&quot;&gt;倾城之链 - fresh - The next-gen web framework.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E7%BC%96%E8%BE%91%E5%99%A8&quot;&gt;&lt;code&gt;编辑器&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/Markdown&quot;&gt;&lt;code&gt;Markdown&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%BD%AF%E4%BB%B6&quot;&gt;&lt;code&gt;软件&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：Markdown, Tw93, MiaoYan, MacApp&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;轻灵的 Markdown 笔记本伴你写出妙言~&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/miaoyan.app.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - 妙言 - 轻灵的 Markdown 笔记本&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;： &lt;a href=&quot;https://nicelinks.site/redirect?url=https://miaoyan.app/&quot;&gt;妙言&lt;/a&gt;,⛷ 轻灵的 &lt;a href=&quot;https://nicelinks.site/tags/Markdown&quot;&gt;Markdown&lt;/a&gt; 笔记本伴你写出妙言；根据其主页文档介绍，妙言具有以下功能特征：&lt;/p&gt;&lt;h3 id=&quot;妙&quot;&gt;&lt;a href=&quot;#%E5%A6%99&quot; aria-label=&quot;妙 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;妙&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;纯本地使用，无需联网即可使用，源文件保存；&lt;/li&gt;&lt;li&gt;安全，完全开源 Github，不会上传用户信息；&lt;/li&gt;&lt;li&gt;支持语法高亮、黑暗模式、国际化、演示模式、文档自动排版；&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;美&quot;&gt;&lt;a href=&quot;#%E7%BE%8E&quot; aria-label=&quot;美 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;美&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;极简的设计风格，没有多余的东西；&lt;/li&gt;&lt;li&gt;&lt;code&gt;文件夹&lt;/code&gt; + &lt;code&gt;文件列表&lt;/code&gt; + &lt;code&gt;编辑器&lt;/code&gt;三栏设计，可收起；&lt;/li&gt;&lt;li&gt;中文默认使用霞鹜文楷字体，让文字也很美；&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;快&quot;&gt;&lt;a href=&quot;#%E5%BF%AB&quot; aria-label=&quot;快 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;快&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;使用 &lt;a href=&quot;https://nicelinks.site/post/6232f5ca77e4352be838a308&quot;&gt;Swift5&lt;/a&gt; 开发，原生极致性能；&lt;/li&gt;&lt;li&gt;对多文件做了特别的性能优化，确保不卡顿；&lt;/li&gt;&lt;li&gt;相比当前市面上套壳 Web 的方式轻巧很多；&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;简&quot;&gt;&lt;a href=&quot;#%E7%AE%80&quot; aria-label=&quot;简 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;简&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;操作过程很轻巧，不耽误你的时间；&lt;/li&gt;&lt;li&gt;编辑体验媲美原生代码编辑器；&lt;/li&gt;&lt;li&gt;内置众多快捷键助你快人一步；&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;安装使用&quot;&gt;&lt;a href=&quot;#%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8&quot; aria-label=&quot;安装使用 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;安装使用&lt;/h3&gt;&lt;p&gt;您可从  &lt;a href=&quot;https://nicelinks.site/redirect?url=https://github.com/tw93/MiaoYan/releases&quot;&gt;GitHub Releases&lt;/a&gt;  中下载最新的 MiaoYan.dmg 安装包，双击安装即可。具体使用方式如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;可以在 iCloud 或根目录下创建一个  &lt;code&gt;MiaoYan&lt;/code&gt;  的文件夹，打开妙言的设置，将默认存储地址修改成这个。&lt;/li&gt;&lt;li&gt;点击妙言左上角新增文件夹的图标，创建好自己的文档分类文件夹，就可以开始使用了。&lt;/li&gt;&lt;li&gt;同样假如你不习惯默认的字体，可以在设置中修改成其他的正常字体。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;为什么要做妙言&lt;/strong&gt;？作者在 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://github.com/tw93/MiaoYan&quot;&gt;Github MiaoYan&lt;/a&gt; 写道：之前有尝试过众多的笔记应用，大学时期为知笔记、印象笔记，工作时候用过 Ulysses(无预览)、Quiver(多年不更新)、MWeb(功能复杂)、&lt;a href=&quot;https://nicelinks.site/post/5ccd4213b448cf0a336a8aa3&quot;&gt;Bear&lt;/a&gt;(Markdown 图片等富格式不支持)，种种原因，没有找到一个好用的 Markdown 应用，才有了做妙言的想法。（作者）本职工作为前端开发，会一点 iOS 开发，喜欢折腾，借妙言来玩一下 &lt;a href=&quot;https://nicelinks.site/post/6232f5ca77e4352be838a308&quot;&gt;Swift&lt;/a&gt; 以及 OSX 开发，当做一个很愉快的事情。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62b070a3a00b101b220aa7ea&quot;&gt;倾城之链 - 妙言 - 轻灵的 Markdown 笔记本&lt;/a&gt;&lt;/p&gt;&lt;p&gt;对倾城之链感兴趣的朋友，可通过 Web，小程序，快应用等渠道进行访问(后续将支持更多，如 VsCode 插件，Chrome 扩展等)。您有任何问题，欢迎随时向我们反馈（您可以通过官网反馈渠道，或添加如下客服微信），🤲 。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/%E5%80%BE%E5%9F%8E%E4%B9%8B%E9%93%BE-%E5%BE%AE%E4%BF%A1-mini.jpeg&quot; alt=&quot;倾城之链 - 客服微信&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;本期文末寄语&quot;&gt;&lt;a href=&quot;#%E6%9C%AC%E6%9C%9F%E6%96%87%E6%9C%AB%E5%AF%84%E8%AF%AD&quot; aria-label=&quot;本期文末寄语 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;本期文末寄语&lt;/h2&gt;&lt;p&gt;清夜无尘，月色如银。酒斟时、须满十分。浮名浮利，虚苦劳神。叹隙中驹，石中火，梦中身。&lt;br/&gt;虽抱文章，开口谁亲。且陶陶、乐尽天真。几时归去，作个闲人。对一张琴，一壶酒，一溪云。&lt;br/&gt;── 北宋 · 苏轼《行香子》&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界；在这里，你可以轻松发现、学习、分享更多有用或有趣的事物。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/nicelinks-miniprogram-code.jpeg?imageView2/1/w/250/h/250/interlace/1/ignore-error/1&quot; alt=&quot;小程序码 - 倾城之链&quot;/&gt;&lt;/p&gt;&lt;h3 id=&quot;您可能感兴趣的文章&quot;&gt;&lt;a href=&quot;#%E6%82%A8%E5%8F%AF%E8%83%BD%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E6%96%87%E7%AB%A0&quot; aria-label=&quot;您可能感兴趣的文章 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;您可能感兴趣的文章&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9653104c7c65e9c646c0c399c707a8ef</guid>
<title>快手实时数仓保障体系研发实践</title>
<link>https://toutiao.io/k/juj49do</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;Apache Flink&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;apacheflinkcc&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;Flink 中文社区官微，Flink PMC 维护&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e6254a714d4096eb97244353196a63c0</guid>
<title>5000字解析：实战化场景下的容器安全攻防之道</title>
<link>https://toutiao.io/k/byhhxco</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;/p&gt;&lt;p&gt;在这个数字化转型关键时期，以容器为代表的云原生技术凭借自身的优势，正在逐渐成为核心IT基础设施。云原生已经不再是少部分“创新者”的特权，而是成为了市场主流选择，容器、容器云逐渐成为工作负载的主流形态。&lt;/p&gt;&lt;p&gt;与此相随，云原生大量的新技术，也带来了众多未知的风险敞口，安全防护对象也发生了颠覆性变化，容器正在逐渐成为黑客新的演练场。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132&quot;&gt;&lt;section label=&quot;powered by wxb-style.com&quot;&gt;&lt;section data-id=&quot;86318&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span data-brushtype=&quot;&quot;&gt;容器成为重要的攻击目标&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;在容器时代，安全面临新旧威胁的双重挑战。一方面，那些传统旧的攻击手段依然有效，包括漏洞利用、暴力破解、权限提升等等。另一方面，新的攻击姿势也是层出不穷，例如投毒镜像、容器逃逸、集群API调用等等，让人防不胜防。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;在过去的攻防演练中，就曾发现多起针对容器、集群攻击事件。容器带来新的风险暴露面，给了攻击者众多可乘之机。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;为什么容器会成为黑客重点攻击目标？笔者认为核心原因有以下6个方面：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;容器虽然可以实现更加灵活、更加低成本的软件开发和应用部署，但是对应的容器安全建设却远远滞后于业务发展速度，大量“裸奔”的容器成为了攻击者眼中“香饽饽”。&lt;/p&gt;&lt;p&gt;在容器集群中，只要攻陷一个容器，就可以横向移动到其它容器上，或者逃逸到node节点上进行持久化，控制整个节点。下一步，攻击者还可以通过漏洞利用或者调用API SERVER控制整个集群。&lt;strong&gt;而集群作为集权类系统，一旦失陷，防守方“血条”减少一大截就不可避免了&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;除了应用本身的脆弱性引入的攻击外，集群、容器运行时本身的脆弱性问题也不容忽视。例如攻击者通过k8s、docker未授权访问长驱直入；集群权限配置不当，攻击者可创建高权容器进行逃逸；利用Linux内核cgroups模块（CVE-2022-0492）进行逃逸。&lt;/p&gt;&lt;p&gt;在传统操作模式中，所部署的软件在其运行的主机上更新，而容器则必须在上游的镜像中进行更新，然后重新部署。因此，若镜像或基础镜像存在问题，则将至少影响一个或多个集群。&lt;/p&gt;&lt;p&gt;容器安全防护需要覆盖容器构建、部署、运行整个生命周期，所涉及的环节和流程链路都非常复杂。例如，在构建阶段，可能会遇到的软件供应链攻击，包括基础镜像污染、CI工具攻击、制品库漏洞攻击等。在部署阶段也可能面临针对云原生基础设施平台攻击，包括开源组件编排工具等。在运行时阶段，还可能面临针对云原生应用的攻击，包括SQL注入、漏洞、弱口令等。&lt;/p&gt;&lt;p&gt;容器的生命周期短，动态变化快，超过50%容器从上线到下架的整个生命周期不超过1天。如何在检测到异常入侵事件之后，快速进行安全响应，把损失降到最低成为了一大安全难题。 &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132&quot;&gt;&lt;section label=&quot;powered by wxb-style.com&quot;&gt;&lt;section data-id=&quot;86318&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span data-brushtype=&quot;&quot;&gt;容器缺乏有效的安全手段&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;在传统的安全防护范畴中，组织的“端点、网络、边界”，各个层级相对清晰，但是在云原生环境下这些边界消失了。&lt;/p&gt;&lt;p&gt;近年来，虽然企业组织的安全建设投入大幅度提升，企业组织都部署了基本的防火墙、漏扫、终端安全等常规的安全设备。&lt;/p&gt;&lt;p&gt;但是当容器面临攻击时，传统安全防护手段，无法有效保护容器安全。例如，在IT架构中，如果包含容器、K8S等新型的云原生基础设施时。举个简单的例子，攻击者可以通过多种方式轻松完成一次攻击。一个个小小的漏洞就有可能打穿容器节点，甚至整个集群。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第一步：通过容器应用攻击容器&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;攻击者通过weblogic远程代码执行漏洞（CVE-2021-2382），获取了一个容器的控制权。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二步：通过失陷容器攻击其它容器&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;获取容器控制权后，可通过nmap等网络探测方式发现可访问的容器端口。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第三步：通过容器攻击宿主机&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;若docker、containered等存在容器逃逸漏洞，可利用此漏洞获取宿主机的控制权。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第四步：通过容器攻击集群&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;若K8S存在8080、6443未授权访问，可通过容器访问K8S master api进行恶意调用。&lt;/p&gt;&lt;p&gt;试想，面对这样的攻击，不管是边界防火墙，还是终端的安全产品，都无法完成有效安全防护，也无法隔离容器或杀掉容器内恶意进程，更无法提供行之有效的溯源分析，只能通过下线业务的方式缓解影响，但是这无法从根上解决容器的安全问题。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132&quot;&gt;&lt;section label=&quot;powered by wxb-style.com&quot;&gt;&lt;section data-id=&quot;86318&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span data-brushtype=&quot;&quot;&gt;实战化定制容器安全方案&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;在这样的背景下，青藤基于多年实战化攻防演练的经验，不断升级迭代方案，&lt;strong&gt;正式推出升级版《容器安全实战化解决方案V2.0》&lt;/strong&gt;，感兴趣的读者可扫码领取电子版方案。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr7DvvDzWz0MjbUdcqWyKAjgCia0feCPN6Nfe1K8EJuUjNNJ7tgQOts53ggVFev5wUnAWXzN2PssnaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;182&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;扫码下载《容器安全实战化解决方案V2.0》&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;该方案覆盖了几个核心环节，包括&lt;strong&gt;攻击风险评估、风险收敛整改、攻击行为监控、攻击事件响应、溯源分析报告共五个环节，&lt;/strong&gt;可实现容器全生命周期的主动防御效果。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.26832151300236406&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr7DvvDzWz0MjbUdcqWyKAjgCe83icicdAHdiahPg0slkeHoiaFmleTss60tnhsG1qokzH0wJjmFm2VrTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;846&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;图1：攻防演练5个核心环节&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;第一阶段：容器攻击风险评估&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在攻防演习前期，最重要就是做好攻击风险评估，包括资产梳理、漏洞检查、基线检查、弱口令检查等等。其中最重要就是做好资产梳理。&lt;/p&gt;&lt;p&gt;根据过去攻防实战演练的经验，有不少组织机构对于自己的资产情况把控不够，导致部分资产未能纳入有效监测，形成了防护薄弱点。&lt;/p&gt;&lt;p&gt;攻击队在发起进攻前，会先收集这些薄弱点，并以此为跳板攻入企业关键系统。所以，提前对资产进行评估，收敛对外暴露的攻击面变得尤为重要。&lt;/p&gt;&lt;p&gt;在云原生环境下，防守方在演习前期一定要对容器资产进行清点，&lt;strong&gt;尤其是梳理内网集群&amp;amp;非集群管理的系统资产，并且把资产对应到人。&lt;/strong&gt;最重要的是要对核心业务资产进行深度透视，尤其是靶标系统、集权系统等。&lt;/p&gt;&lt;p&gt;有了上述详细的资产看板之后，在发生入侵事件时，就可以快速反查容器业务应用，协助定位入侵的入口点以及影响范围。例如，在攻击者利用0day/1day漏洞时，防守方可通过应用级别的资产排查，分析现有业务受漏洞影响范围。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4954648526077097&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr7DvvDzWz0MjbUdcqWyKAjg5QeEbvHAn87txUdaDjEGpiabmgXFtelGVY97p1hibicTLn16NmBUN2vvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;882&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;图2：重点关注容器资产类别&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;此外，还需要梳理容器内的应用资产，发现边角系统和废弃资产、发现不合规的资产，为后续系统加固和应急响应做铺垫。这个过程需要重点关注三个方面：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（1）梳理集群与外部系统的边界&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;首先，梳理集群对外暴露服务，如使用主机网络暴露服务，使用nodeport暴露服务。其次，梳理集群内对外访问情况，发现不合规的对外访问行为。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（2）梳理高权、特权容器&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;主要包括Privileged 特权容器、高Capabilities的容器、挂载敏感目录的容器、Root账号的容器、Host模式运行的容器、共享主机namespace的容器 、共享主机设备的容器 、CPU/内存使用不设限的容器等。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（3）发现不合规应用&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;主要是针对容器中的ssh、sudo、ftp、vsftp等资产。&lt;/p&gt;&lt;p&gt;通过资产细粒度清点，还能实现供应链的安全管控。对于企业组织来说，容器制品供应链环节的安全性也非常重要。尤其是随着云原生应用制品越来越多样化，像容器镜像、 helm charts 都是常见的制品格式。&lt;/p&gt;&lt;p&gt;一方面，需要在应用构建阶段保证制品的安全性；另一方面需要在制品入库；分发和部署时刻建立对应的合规检查、访问控制，安全扫描、审计和准入、准出的校验机制，保证制品源头的安全性。&lt;/p&gt;&lt;p&gt;因此，在攻防演习前，要做好软件供应链的资产台账，包括运行的应用、中间件、数据库、安装包、框架语言包（java、go、ruby、nodejs、python、php）等，发现其安装路径、版本信息和配置情况。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5122850122850123&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr7DvvDzWz0MjbUdcqWyKAjgekegpibEnvfvictdFXQkGBKz4YQ22pk3Sg1vk9XdndzDELpJHMyiaQVhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;814&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;图3：青藤蜂巢可细粒度梳理供应链软件成分&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二阶段：容器风险收敛加固&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;在攻防演练中，前期的准备工作包括脆弱性整改、漏洞缓解、靶机加固整改、集权系统监控等。我们可以把这些技术性工作概括为风险收敛与安全加固两个方向。对防守方来说，针对云原生风险收敛加固，可以从梳理系统脆弱性&amp;amp;整改、微隔离加固等方面实现风险收敛与安全加固。&lt;/p&gt;&lt;p&gt;攻防演习前，需要全面排查内网安全隐患，发现并协助整改容器环境的脆弱性存留。通过各种不同的方法修复可能被攻击者利用的漏洞，加强系统安全配置，增加攻击者入侵的难度，提升安全防范水平。它与攻击面收敛、漏洞修复、安全策略优化等工作形成了完整的风险管理闭环。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2759259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jVCRndy8Lr7DvvDzWz0MjbUdcqWyKAjgZCoz4Niaicg8vhH9CgEbZwAvHCpFNXxfPJbe9l6dyJ8iaAicy2tZHN1Avg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;图4：运行时脆弱性评估&amp;amp;整改&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;但是在攻防演练中高强度的攻击下，即便前期做了很好风险收敛加固工作，仍然有可能出现一些0day/1day的高危漏洞，导致被攻破的局面。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;因此，企业组织需要那些具备专业的漏洞研究人员和漏洞应急响应流程的安全厂商，能够在24小时内，提供应急响应方案。一旦演习期间发现有高危漏洞的情报，需要第一时间跟进。青藤拥有非常健全的应急响应团队和完善的响应流程，可以很好应对实战化背景下容器安全应急处置。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.11944444444444445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jVCRndy8Lr7DvvDzWz0MjbUdcqWyKAjgsFaA0iaT1zK1vvmYARQiaSoQ9icRwJ760rbloicFB2NIYJFVtxq6NET3rw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;span&gt;&lt;strong&gt;图5：青藤漏洞应急响应和处置流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在实战化对抗中，可以预见的是攻击者一定会对演习目标系统展开高强度的远程攻击。在不限制攻击路径的前提下，以控制业务系统、获取重要数据为最终目的，全面展开攻击。为此防守方需要在演习前期对重要系统进行微隔离控制，主要包括两个方面工作：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;对外&lt;/strong&gt;，需要梳理容器集群与外部系统的边界，梳理集群对外暴露的服务及集群内对外访问情况，进行合规控制。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;对内&lt;/strong&gt;，需要梳理容器内的重要系统（集群系统、靶标系统）在内网的访问模型，形成访问控制基线。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4327651515151515&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr7DvvDzWz0MjbUdcqWyKAjgrtVPATcoSgzc44sBJibztGiczUXmT2w9VYUxqqCAd6tZ1TnxDl2tdY8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1056&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;图6：重点系统微隔离控制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第三阶段：容器攻击行为监控&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;攻防演练开始之后，红队完全按照攻击者的思维，发起高强度、高水平的网络攻击。因此，对蓝队来说，监控是能够及时发现攻击至关重要的一步。青藤蜂巢能够提供多锚点的检测能力，能够实时、准确地感知入侵事件，发现失陷容器。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39866666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr7DvvDzWz0MjbUdcqWyKAjg0CdAJDvib6JWGibLePoMWibBZ9M4N2U2oDlyQMm6RtZib6z8EtC5lluMoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;图7：覆盖攻击链路的多锚点监控&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;虽然预防性安全技术能够应对已知的基于签名的威胁，但蓝队仍需要网络安全监控来识别更复杂的威胁。&lt;/p&gt;&lt;p&gt;因此，防守方需要利用前期部署的主机、容器攻击监控体系，实时发现攻击行为，并按照攻击告警监控流程进行上报。青藤蜂巢除了能够对已知特征威胁进行检测，也能对恶意行为进行检测，还能进行异常检测。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3972222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr7DvvDzWz0MjbUdcqWyKAjgO04395NMrMLsVMKWyiascntE3jU4VWaqVSfiaSy5tZamsZJG7Y0iabHog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;图8：青藤蜂巢立体入侵监测体系&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;（1）基于已知特征的威胁检测&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;青藤蜂巢可对容器内的文件、代码、脚本等进行已知特征的检测，可实时发现容器中的病毒、挖矿、webshell等已知威胁。以webshell检测为例，青藤雷火根据AI推理发现Webshell中存在的可疑内容，其Webshell检测率超越历史最强水平，高达99.99%，并且整个使用过程无需长期训练，可即插即用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6239396795475967&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr7DvvDzWz0MjbUdcqWyKAjgl1w2ajpbfTI6HyBWSQLS0bZmic7BgTYe3BKCLnYy7xu3hodU8GSyrVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1061&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;图9：已知威胁检测&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;（2）基于恶意行为的检测&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;青藤蜂巢，基于对恶意行为模式的定义，可对容器及编排工具的黑客攻击行为进行实时检测。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;首先，可检测容器内无文件攻击，&lt;/strong&gt;支持发现内存webshell、shellcode和加载动态链接库等多种内存码。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;其次，可检测容器逃逸行为，&lt;/strong&gt;支持发现K8S组件漏洞逃逸、内核漏洞逃逸、容器漏洞逃逸、敏感挂载逃逸等行为。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;最后，可检测K8S API恶意行为，&lt;/strong&gt;支持包括匿名用户登陆、secrets获取、API server可疑操作等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;14988&quot;&gt;&lt;section&gt;&lt;section data-svg-role=&quot;block&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;565&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;376&quot; data-ratio=&quot;1.4066091954022988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr7DvvDzWz0MjbUdcqWyKAjg1z5p6MmHcDRyQ3wYV6DUkROVia2WIomIzRu50R2ckiaV5RHpphQgca2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;696&quot; data-width=&quot;100%&quot;/&gt;&lt;p data-class=&quot;mbImgTitle&quot;&gt;▲ 10-1检测容器内无文件攻击&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;565&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;376&quot; data-ratio=&quot;1.3451776649746192&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr7DvvDzWz0MjbUdcqWyKAjgJGAkwlfGFNA0ibH0llCuU6ickMuTrMgVWib43p3GDyxIVHly0ricicY9TIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;394&quot; data-width=&quot;100%&quot;/&gt;&lt;p data-class=&quot;mbImgTitle&quot;&gt;▲ 10-2检测容器逃逸行为&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;565&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;376&quot; data-ratio=&quot;1.4066091954022988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr7DvvDzWz0MjbUdcqWyKAjg1z5p6MmHcDRyQ3wYV6DUkROVia2WIomIzRu50R2ckiaV5RHpphQgca2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;696&quot; data-width=&quot;100%&quot;/&gt;&lt;p data-class=&quot;mbImgTitle&quot;&gt;▲ 10-3 检测K8S API恶意行为&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-svg-role=&quot;block&quot; data-svg-op=&quot;delete&quot; data-svg-blockname=&quot;描述性文字&quot;&gt;&lt;p&gt;&lt;span&gt;左右滑动查看更多&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;图10：重点恶意行为检测&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（3）基于异常行为的检测&lt;/strong&gt;青藤蜂巢，可对容器内进程、网络等行为进行学习建立模型，从而发现异常入侵。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;针对重要的容器靶机、集群系统进行提前学习，形成稳定的模型&lt;/strong&gt;，一旦发现异常进程启动、异常端口监听、异常网络连接和异常文件操作就立即报警。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5491891891891892&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr7DvvDzWz0MjbUdcqWyKAjg0M04oTj5lrbEASwFRCH3S15QjVH31GwcjhTI4kEIfbHgicDWm9X8kIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;925&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;图11：未知威胁检测&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在检测到⼊侵事件之后，对于失陷容器需要进⾏快速的安全响应，把损失降到最低。青藤蜂巢能够实施不同细粒度的管控措施，在容器层面可以直接隔离、暂停、查杀容器，在容器行为层面可以阻断进程、隔离文件、封禁IP，不允许有问题的工作负载进行访问或被访问。&lt;/p&gt;&lt;p&gt;青藤在收集到攻防过程中新型的入侵姿势等信息之后，会快速响应生成系统规则，通过规则更新的方式增强产品入侵检测能力。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;目前，青藤蜂巢最新的产品功能，已经拥有自定义威胁情报和检测能力。&lt;/strong&gt;例如，用户一线人员发现攻防演习过程中披露的入侵信息，可通过产品&lt;strong&gt;自定义锚点式检测规则和自定义威胁情报，&lt;/strong&gt;增强补充产品入侵检测能力。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;第四阶段：容器攻击事件响应&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;一旦确定了告警的真实性，安全专家要通过主机、容器上的日志以及系统告警等信息，对攻击事件进行调查，并生成《XXX事件调查报告》。最重要2个方面是：做失陷范围排查、攻击过程还原。&lt;/p&gt;&lt;p&gt;通过对被攻击资产的分析与溯源，还原攻击路径与攻击手法，用户不仅能够有效提升攻防演练效果，还可增强常态化安全防御能力，将攻击事件转换为防御势能，避免二次攻击事件的发生。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3314814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jVCRndy8Lr7DvvDzWz0MjbUdcqWyKAjgP1GhTdXeyMWNkT6Unic1j4BLrsdqMpP6ibZgx5DQ2HyBaV0DJ9GIZteQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;图12：攻击过程还原&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;根据现有信息找出一台确认失陷的主机/容器信息，然后以这台失陷主机的数据以及它的互联关系为线索，在用户系统中展开内网溯源，确认是否存在被横向渗透的主机/容器，并循环此过程，逐步找出所有失陷主机/容器，确认攻击影响面及具体的失陷范围，将攻击队彻底清除出内网。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.17037037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jVCRndy8Lr7DvvDzWz0MjbUdcqWyKAjguuT0LRBMKbKGQayBa9oCqTXNibqyicVuDWp6vITjsWglbGyw6Wibon1Iw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;span&gt;&lt;strong&gt;图13：失陷范围排查&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;第五阶段：容器溯源分析报告&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;青藤蜂巢，可通过收集容器相关行为数据，包括API调用行为日志、容器进程事件、容器网络事件、容器文件事件、k8s审计日志事件等等，结合ATT&amp;amp;CK框架模型，通过大数据工具来进行安全威胁分析，确定攻击的影响范围和入侵路径，通过威胁狩猎主动发现内部潜在的其它威胁。&lt;/p&gt;&lt;p&gt;防守方在完成攻击确认到调查、还原的整个流程之后，需要整理出一份防守报告，阐述攻击的真实性、攻击的覆盖范围、攻击者的攻击路径及行为，并将报告提交给组织方。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4848800834202294&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jVCRndy8Lr7DvvDzWz0MjbUdcqWyKAjgw96GeTfWgojA6Lmy5l894KdLYNnL7b4kaPzDvvQtibEAibWlT7NibTLTQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;959&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;图14：形成防守报告&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132&quot;&gt;&lt;section label=&quot;powered by wxb-style.com&quot;&gt;&lt;section data-id=&quot;86318&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span data-brushtype=&quot;&quot;&gt;写在最后&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;正如前文所述，容器已经成为黑客重要的攻击目标，但是目前非常缺乏有效的安全手段。可预见，未来容器、容器集群将成为最重要的IT基础设施。不管是在真实网络实战中，还是在相关的攻防演习中，以容器为代表云原生基础设施都将是攻防双方必争之地。&lt;/p&gt;&lt;p&gt;如果您有关于攻防演练或容器安全方面的任何问题，&lt;strong&gt;欢迎致电400-188-9287转1，或直接扫描下方二维码，领取《容器安全实战化解决方案V2.0》&lt;/strong&gt;。您也可以点击“&lt;strong&gt;阅读原文&lt;/strong&gt;”&lt;strong&gt;免费申请试用&lt;/strong&gt;青藤的容器安全产品~&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jVCRndy8Lr7DvvDzWz0MjbUdcqWyKAjgCia0feCPN6Nfe1K8EJuUjNNJ7tgQOts53ggVFev5wUnAWXzN2PssnaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;182&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/span&gt; 扫码下载《容器安全实战化解决方案V2.0》&lt;/strong&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f8028b4fcba6fdffdceecadd411cf538</guid>
<title>欢迎加入读者圈子，一起交流！</title>
<link>https://toutiao.io/k/92wl596</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎加入读者圈子，一起交流！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;307&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavich3VaNkKeiaAwUhz7TQbQmic4fFsr58X9PAYleYzxqc1K1vZjeBoZDMUsmia0xH67EQYINGRvNOtLmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;圈子剧透&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、600+圈子成员，以中高级程序员为主，更有架构师、CTO坐镇交流；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、1000+优质主题，数十G独家资料，每日分享，精挑细选；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、全年52期专属邮件周报，让你轻松掌握业界资讯、技术干货，提升认知水平；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、全年52本好书共读，让你花最少的时间，获取更好的知识；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;心动不如行动，赶快加入吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ed9aae4c13096fab51c25183807f3fd4</guid>
<title>为什么线程崩溃不会导致 JVM 崩溃</title>
<link>https://toutiao.io/k/smus5nq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;网上看到一个很有意思的美团面试题：为什么线程崩溃崩溃不会导致 JVM 崩溃，这个问题我看了不少回答，但发现都没答到根上，所以决定答一答。相信大家看完肯定会有收获，本文分以下几节来探讨。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;1. 线程崩溃，进程一定会崩溃吗？&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般来说如果线程是因为非法访问内存引起的崩溃，那么进程肯定会崩溃。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么系统要让进程崩溃呢？这主要是因为在进程中，&lt;strong&gt;各个线程的地址空间是共享的&lt;/strong&gt;。既然是共享，那么某个线程对地址的非法访问就会导致内存的不确定性，进而可能会影响到其他线程，这种操作是危险的。操作系统会认为这很可能导致一系列严重的后果，于是干脆让整个进程崩溃。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9715370018975332&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLU8h8QYrHeibbpq0MLf3Ov6lribyJQz7knHBWnFceHjvlj6ZAiciadmsPY7IMjgkdxl8SxSR95wzusl8w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;527&quot; title=&quot;线程共享代码段，数据段，地址空间，文件&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;线程共享代码段，数据段，地址空间，文件&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;非法访问内存有以下几种情况，我们以 C 语言举例来看看：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;针对只读内存写入数据&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;pre&gt;&lt;br/&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt; *s = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;hello world&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    s[&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;] = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;H&#x27;&lt;/span&gt;; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;访问了进程没有权限访问的地址空间（比如内核空间）&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;pre&gt;&lt;br/&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; *p = (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; *)&lt;span class=&quot;code-snippet__number&quot;&gt;0xC0000fff&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   *p = &lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;span/&gt;&lt;/pre&gt;&lt;pre&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;在 32 位虚拟地址空间中，p 指向的是内核空间，显然不具有写入权限，所以上述赋值操作会导致崩溃。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;访问了不存在的内存&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; *a = &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   *a = &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上错误都是访问内存时的错误，所以统一会报 Segment Fault 错误（即段错误），这些都会导致进程崩溃。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;2. 进程是如何崩溃的——信号机制简介&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么线程崩溃后，进程是如何崩溃的呢？&lt;/span&gt;&lt;span&gt;这&lt;/span&gt;&lt;span&gt;背后的机制到底是怎样的&lt;/span&gt;&lt;span&gt;？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;答案是信号。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大家想想要干掉一个正在运行的进程是不是经常用 kill -9 pid 这样的命令，这里的 kill 其实就是给指定 pid 发送终止信号的意思。&lt;/span&gt;&lt;span&gt;其中的 9 就是信号&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实信号有很多类型的，在 Linux 中可以通过 kill -l查看所有可用的信号。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33094812164579607&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLU8h8QYrHeibbpq0MLf3Ov6lEsDjTB5TO65X36LkVIdHbwvaqjRUzR0LjqIRGAV7yYvfP03OjVWWFA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1118&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然了发 kill 信号必须具有一定的权限，否则任意进程都可以通过发信号来终止其他进程，那显然是不合理的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际上 kill 执行的是系统调用，将控制权转移给了内核（操作系统），由内核来给指定的进程发送信号。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么发个信号进程怎么就崩溃了呢，这背后的原理到底是怎样的？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其背后的机制如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CPU 执行正常的进程指令；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;调用 kill 系统调用向进程发送信号；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;进程收到操作系统发的信号，CPU 暂停当前程序运行，并将控制权转交给操作系统&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;调用 kill 系统调用向进程发送信号（假设为 11，即 SIGSEGV，一般非法访问内存报的都是这个错误）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;操作系统根据情况执行相应的信号处理程序（函数），一般执行完信号处理程序逻辑后会让进程退出。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注意上面的第 5 步。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果进程没有注册自己的信号处理函数，那么操作系统会执行默认的信号处理程序（一般最后会让进程退出）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但如果注册了，则会执行自己的信号处理函数。这样的话就给了进程一个垂死挣扎的机会，它收到 kill 信号后，可以调用 exit() 来退出，但也可以使用 sigsetjmp、siglongjmp 这两个函数来恢复进程的执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Signal &lt;span class=&quot;code-snippet__number&quot;&gt;11&lt;/span&gt; catched!&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;signal.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;sigHandler&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; sig)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Signal %d catched!\n&quot;&lt;/span&gt;, sig);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__built_in&quot;&gt;exit&lt;/span&gt;(sig);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  signal(SIGSEGV, sigHandler);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; *p = (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; *)&lt;span class=&quot;code-snippet__number&quot;&gt;0xC0000fff&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  *p = &lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上结果输出：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;Signal&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;11&lt;/span&gt; catched!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如代码所示：注册信号处理函数后，当收到 SIGSEGV 信号后，先执行相关的逻辑再退出。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外当进程接收信号之后也可以不定义自己的信号处理函数，而是选择忽略信号。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;示例如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;signal.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  signal(SIGSEGV, SIG_IGN);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  raise(SIGSEGV);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;正常结束&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也就是说虽然给进程发送了 kill 信号，但如果进程自己定义了信号处理函数或者无视信号就有机会逃出生天。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然了 kill -9 命令例外，不管进程是否定义了信号处理函数，都会马上被干掉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;说到这大家是否想起了一道经典面试题：&lt;strong&gt;如何让正在运行的 Java 工程的优雅停机&lt;/strong&gt;？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过上面的介绍大家不难发现，其实是 JVM 自己定义了信号处理函数。这样，当发送 kill pid 命令（默认会传 15 也就是 SIGTERM）后，JVM 就可以在信号处理函数中执行一些资源清理之后再调用 exit 退出。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种场景显然不能用 kill -9，不然一下把进程干掉了资源就来不及清除了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;3. 为什么线程崩溃不会导致 JVM 进程崩溃？&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在我们再来看看开头这个问题，相信你多少会心中有数。&lt;/span&gt;&lt;span&gt;想&lt;/span&gt;&lt;span&gt;想看，&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt; Java 中有哪些是常见的由于非法访问内存而产生的 Exception 或 error 呢&lt;/span&gt;&lt;span&gt;？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;常见的是大家熟悉的 StackoverflowError 或者 NPE（NullPointerException）。NPE 我们都了解，属于是访问了不存在的内存。&lt;/span&gt;&lt;span&gt;但为什么栈溢出（Stackoverflow）也属于非法访问内存呢&lt;/span&gt;&lt;span&gt;？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这得简单聊一下进程的虚拟空间，也就是前面提到的共享地址空间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现代操作系统为了保护进程之间不受影响，所以使用了虚拟地址空间来隔离进程。进程的寻址都是针对虚拟地址，每个进程的虚拟空间都是一样的，而线程会共用进程的地址空间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以 32 位虚拟空间为例，进程的虚拟空间分布如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2405345211581291&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLU8h8QYrHeibbpq0MLf3Ov6lJbAtmPp0qZckAw8PAoALLG6j3LNYevSwHjrFUV6q0FrSVdDq4NVicQQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;449&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，&lt;span&gt;S&lt;/span&gt;&lt;span&gt;tack&lt;/span&gt;&lt;span&gt;O&lt;/span&gt;&lt;span&gt;verflow&lt;/span&gt; 是怎么发生的呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;进程每调用一个函数，都会分配一个栈桢，然后在栈桢里会分配函数里定义的各种局部变量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设现在调用了一个无限递归的函数，那就会持续分配栈帧。但 stack 的大小是有限的（Linux 中默认为 8 M，可以通过 ulimit -a 查看），如果无限递归很快栈就会分配完了。此时再调用函数试图分配超出栈的大小内存，就会发生段错误，也就是 &lt;span&gt;S&lt;/span&gt;&lt;span&gt;tack&lt;/span&gt;&lt;span&gt;O&lt;/span&gt;&lt;span&gt;verflow&lt;/span&gt;Error。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.94140625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLU8h8QYrHeibbpq0MLf3Ov6lAZlrrAy3ahWYicGHfCkXwjwiaWicfQnfY3F7IP2bXmsRicKD9aupiafuBWQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;好了，现在我们知道了 StackoverflowError 是怎么产生的，那问题来了：既然 StackoverflowError 或者 NPE 都属于非法访问内存， JVM 为什么不会崩溃呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有了上一节的铺垫，相信你不难回答。其实就是因为 JVM 自定义了自己的信号处理函数，拦截了 SIGSEGV 信号，针对这两者不让它们崩溃。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;怎么证明这个推测呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们来看下 JVM 的源码来一探究竟。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;4. OpenJDK 源码解析&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;HotSpot 虚拟机目前使用范围最广的 Java 虚拟机。据 R 大所述， Oracle JDK 与 OpenJDK 里的 JVM 都是 HotSpot VM。从源码层面说，两者基本上是同一个东西。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;OpenJDK 是开源的，所以我们主要研究下 Java 8 的 OpenJDK 即可。地址如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://github.com/AdoptOpenJDK/openjdk-jdk8u&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有兴趣可以下载来看看。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们只要研究 Linux 下的 JVM，为了便于说明也方便大家查阅，我把其中关于信号处理的关键流程整理了下（忽略了其中的次要代码）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5355691056910569&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLU8h8QYrHeibbpq0MLf3Ov6lKUkW94asyrUG3eovoKdtNChwS7WFZeicR5UErAokPK2Ibwhuz3cYsxQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;984&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到，在启动 JVM 的时候，也设置了信号处理函数。收到 SIGSEGV、SIGPIPE 等信号后，最终会调用 JVM_handle_linux_signal 这个自定义信号处理函数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再来看下这个函数的主要逻辑：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;JVM_handle_linux_signal(int sig,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        siginfo_t* info,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        void* ucVoid,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        int abort_if_unrecognized) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  os::ThreadCrashProtection::check_crash_protection(sig, t);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (info != &lt;span class=&quot;code-snippet__keyword&quot;&gt;NULL&lt;/span&gt; &amp;amp;&amp;amp; uc != &lt;span class=&quot;code-snippet__keyword&quot;&gt;NULL&lt;/span&gt; &amp;amp;&amp;amp; thread != &lt;span class=&quot;code-snippet__keyword&quot;&gt;NULL&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    pc = (address) os::Linux::ucontext_get_pc(uc);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (sig == SIGSEGV) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      address addr = ((NativeInstruction*)pc)-&amp;gt;get_stack_bang_address(uc);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (addr &amp;lt; thread-&amp;gt;stack_base() &amp;amp;&amp;amp;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          addr &amp;gt;= thread-&amp;gt;stack_base() - thread-&amp;gt;stack_size()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (thread-&amp;gt;thread_state() == _thread_in_Java) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (sig == SIGSEGV &amp;amp;&amp;amp;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               !MacroAssembler::needs_explicit_null_check((intptr_t)info-&amp;gt;si_addr)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (stub != &lt;span class=&quot;code-snippet__keyword&quot;&gt;NULL&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (thread != &lt;span class=&quot;code-snippet__keyword&quot;&gt;NULL&lt;/span&gt;) thread-&amp;gt;set_saved_exception_pc(pc);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    uc-&amp;gt;uc_mcontext.gregs[REG_PC] = (greg_t)stub;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  VMError err(t, sig, pc, info, ucVoid);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  err.report_and_die();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  ShouldNotReachHere();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;true&lt;/span&gt;; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从以上代码（注意看&lt;span&gt;注释 &lt;/span&gt;1、2、3 部分）我们可以知道以下信息：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;发生 &lt;span&gt;S&lt;/span&gt;&lt;span&gt;tack&lt;/span&gt;&lt;span&gt;O&lt;/span&gt;&lt;span&gt;verflow&lt;/span&gt; 还有空指针错误，确实都发送了 SIGSEGV。只是虚拟机不选择退出，而是自己内部作了额外的处理。其实是恢复了线程的执行，并抛出 StackoverflowError 和 NPE。这就是为什么 JVM 不会崩溃且我们能捕获这两个错误或异常的原因；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果针对 SIGSEGV 等信号，在以上的函数中 JVM 没有做额外的处理，那么最终会走到 report_and_die 这个方法。这个方法主要做的事情是生成 hs_err_pid_xxx.log crash 文件（记录了一些堆栈信息或错误），然后退出。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;至此我相信大家明白了为什么发生了 StackoverflowError 和 NPE 这两个非法访问内存的错误，JVM 却没有崩溃。&lt;/span&gt;&lt;span&gt;原因其实就是虚拟机内部定义了信号处理函数，而在信号处理函数中对这两者做了额外的处理以让 JVM 不崩溃&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另一方面也可以看出，如果 JVM 不对信号做额外的处理，最后会自己退出并产生 crash 文件 hs_err_pid_xxx.log（可以通过 -XX:ErrorFile=/var/log/hs_err.log 这样的方式指定）。这个文件记录了虚拟机崩溃的重要原因。所以也可以说，虚拟机是否崩溃只要看它是否会产生此崩溃日志文件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正常情况下，操作系统为了保证系统安全，所以针对非法内存访问会发送一个 SIGSEGV 信号，而操作系统一般会调用默认的信号处理函数（一般会让相关的进程崩溃）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但如果进程觉得&quot;罪不致死&quot;，那么它也可以选择自定义一个信号处理函数。这样的话它就可以做一些自定义的逻辑，比如记录 crash 信息等有意义的事。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回过头来看为什么虚拟机会针对 StackoverflowError 和 NullPointerException 做额外处理让线程恢复呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对 StackOverflow 其实它采用了一种栈回溯的方法保证线程可以一直执行下去。而捕获空指针错误主要是这个错误实在太普遍了，为了这一个很常见的错误而让 JVM 崩溃那线上的 JVM 要宕机多少次。所以&lt;strong&gt;出于工程健壮性的考虑&lt;/strong&gt;，与其直接让 JVM 崩溃倒不如让线程起死回生，并且将这两个错误/异常抛给用户来处理。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>