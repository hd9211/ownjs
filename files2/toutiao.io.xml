<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f8028b4fcba6fdffdceecadd411cf538</guid>
<title>欢迎加入读者圈子，一起交流！</title>
<link>https://toutiao.io/k/5fkxdkk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎加入读者圈子，一起交流！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;307&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavich3VaNkKeiaAwUhz7TQbQmic4fFsr58X9PAYleYzxqc1K1vZjeBoZDMUsmia0xH67EQYINGRvNOtLmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;圈子剧透&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、600+圈子成员，以中高级程序员为主，更有架构师、CTO坐镇交流；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、1000+优质主题，数十G独家资料，每日分享，精挑细选；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、全年52期专属邮件周报，让你轻松掌握业界资讯、技术干货，提升认知水平；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、全年52本好书共读，让你花最少的时间，获取更好的知识；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;心动不如行动，赶快加入吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3e40612db8263f63026cc75f080194e7</guid>
<title>Go语言如何应对供应链攻击</title>
<link>https://toutiao.io/k/o0h7bt0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;现代软件工程是协作进行的，且基于对开源软件的复用，因此容易受到供应链攻击，即通过破坏软件项目的依赖对其进行攻击。无论采取什么流程或技术措施，每个依赖都不可避免地基于一种信任关系。不过，Go 语言的工具和设计可以帮助我们在各个阶段降低风险。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;strong&gt;所有构建都是“锁定的”（locked）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;任何外部变化（例如某个依赖发布了一个新版本）都不会自动影响 Go 程序的构建。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;与大多数其他包管理器不同，Go module 没有单独的约束关系列表或者一个锁定特定版本的 lock 文件。任意 Go 构建里的每个依赖的版本完全由 main module 的 go.mod 文件确定。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;从 Go 1.16 开始，这种确定性是默认的行为，如果 go.mod 不完整，构建命令（go build, go test, go install, go run, ...）就会失败。唯一能改变 go.mod（从而改变构建）的命令是 go get 和 go mod tidy。这两个命令不是用来自动运行或者在 CI 里运行的，所以对依赖树的改动必须是有意为之，还有机会经过代码审查。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;这对于安全性非常重要，当一个 CI 系统或者在新机器上运行 go build 时，已经 check in 的代码才最终决定哪些东西会被构建。第三方无法影响这一点。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;此外，当使用 go get 添加依赖时，由于使用了最小版本选择（minimal version selection）方法，它会按照依赖的 go.mod 文件中指定的版本添加传递依赖（transitive dependencies），而不是按照最新版本添加。运行 go install example.com/cmd/devtoolx@latest 的时候也一样。在某些生态系统中（比如 NPM），运行这样的安装命令会绕过锁定的版本。而在 Go 里面，虽然它会获取最新版本的 example.com/cmd/devtoolx ，但所有的依赖的版本都是由用户的 go.mod 决定的。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;如果某个 module 遭到破坏，发布了一个恶意的新版本，不会有人受到影响，除非他们明确要更新那个依赖。我们有机会去审查这样的改动，整个生态也有时间去发现这种恶意事件。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;strong&gt;版本内容永远不变&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;确保构建不被第三方影响的另一个关键性质是一个 module 版本的内容是不可变的。否则如果攻击者能在入侵某个依赖以后还能重新上传一个已有的版本，那他就能直接入侵所有依赖它的项目了。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;这时就体现出了 go.sum 文件的作用。go.sum 文件中包含了构建所需的每个依赖的加密哈希值列表。与 go.mod 类似，不完整的 go.sum 会导致错误，而且只有 go get 和 go mod tidy 能够对其进行修改，所以它的任何改动都必将伴随着对依赖的有意改变。其他情况下的构建都保证有一套完整的校验值。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;大多数 lock 文件都有这一特性，但 Go 通过校验数据库（简称 sumdb）更进一步。sumdb 是一个全局的、只允许追加的（append-only）、可以加密验证的 go.sum 条目的列表。当 go get 需要在 go.sum 文件中添加一个条目时，它从 sumdb 中获取该条目，同时获取 sumdb 完整性的加密证明。这不仅确保了某个 module 的每个构建都使用相同的依赖内容，还确保了每个 module 都使用相同的依赖内容。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;sumdb 使得被破坏的依赖，甚至是 Google 运行的 Go 的基础设施，都不可能用篡改过的源代码来攻击某个特定依赖。这就保证了你使用的代码与其他人的代码完全一样，并且已经过审查。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;最后，我最喜欢的 sumdb 特性是：无需由 module 的作者来管理密钥，而且与 Go module 的去中心化特性完美契合。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;strong&gt;VCS 是真实的信息来源&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;大多数项目都是通过使用一些版本控制系统（Version Control System，VCS）来开发的。在其他语言的生态中，这些项目需要上传到指定的软件仓库（package repository，比如 NPM）。这意味着有两个账户可能被入侵：一个是 VCS 主机，另一个是软件仓库，而后者的使用次数更少，更容易被忽视。这也意味着上传到仓库的版本中更容易隐藏恶意代码，尤其是作为上传过程的一个步骤，需要例行修改源码时，比如 minimize 代码。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;Go 不存在软件仓库账户。package 的 import 路径已经包含了 go mod download 所需要的信息，可以直接从 VCS 中获取对应的 module，而 VCS 里保存的 tag 就确定了版本。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;确实有一个东西叫做 Go Module Mirror，但它只是一个代理。module 的作者不需要注册账户，也不需要向代理上传版本。这个代理使用与 go 工具相同的逻辑（事实上，代理运行 go mod download）来获取、缓存一个版本。由于校验数据库确保一个特定的 module 版本只能有一个源码树，每个使用代理的人看到的结果与绕过代理直接从 VCS 获取的结果相同。如果该版本在 VCS 中不再可用，或者内容发生了变化，获取时将直接导致错误，而从代理获取可能仍然有效，这样提高了可用性，并且保护生态系统免受 “left-pad” 问题（“删库跑路”）的影响。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;在客户端运行 VCS 工具会暴露相当大的攻击面。这是另一处 Go Module Mirror 有用的地方：代理上的 go 工具在一个强大的沙盒中运行，并且经过配置，支持所有的 VCS 工具，而默认的配置则只能支持两个主要的 VCS 系统（git 和 Mercurial）。使用代理的人仍然可以获取由其他 VCS 系统所发布的代码，但在大多数客户端环境中，攻击者都无法直接碰到这些代码。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;strong&gt;构建但不执行代码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;Go 的工具链有一个明确的安全设计目标，即获取和构建代码时都不会执行代码，无论代码是否是不受信任的恶意代码。这与大多数其他的生态系统不同，它们很多都原生支持在获取 package 的时候运行代码。在一个依赖被入侵以后，这些 post-install hooks（安装后运行的钩子）可以轻易入侵开发者的机器，进而对 module 作者进行蠕虫攻击。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;不过话说回来，获取代码往往意味着会在不久之后执行它，要么是作为开发者机器上的测试的一部分，要么是作为生产环境的二进制文件的一部分，所以缺乏 post-install hooks 只能延缓攻击。构建的结果里是没有安全边界的：构建所用到的任何 package 都可以定义一个 init 函数。尽管如此，它作为一个降低风险的措施是有意义的，因为你执行的一个二进制文件或测试的一个 package 可能只用了这个 module 的一部分依赖。比如如果你在 macOS 上构建并执行 example.com/cmd/devtoolx，那么针对 Windows 的依赖或 example.com/cmd/othertool 的依赖就不可能危害到你的机器。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;在 Go 中，某个构建没有用到的 module 对安全没有影响。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;strong&gt;A little copying is better than a little dependency&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;在 Go 的生态中，最后一个或许也是最重要的一个应对供应链风险的措施，同时也是最没有技术含量的一个，就是 Go 从文化上拒绝大型的依赖树，宁愿稍微复制一点代码，也不愿增加新的依赖。这可以追溯到 Go 的一句谚语：“A little copying is better than a little dependency”。高质量、可复用的 Go 模块往往有着光荣的“零依赖”标签。如果你只是需要一个库，通常不会面临需要依赖其他几十个 module 的情况。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;丰富的标准库和附加模块（golang.org/x/...）也使“零依赖”成为可能，它们提供了常用的上层基本功能，比如 HTTP、TLS、JSON。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;所有这些意味着只需少量的依赖就可以建立丰富、复杂的应用程序。但无论工具有多好，都不能消除复用代码的风险，所以最有力的应对措施永远都是一个比较小的依赖树。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;👇 点击查看原文&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a01c45fc692e81dcc8e1edb796c7b9bb</guid>
<title>用最简的方式学Vuex</title>
<link>https://toutiao.io/k/xfa0qtk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;冲！！！！！！&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg2NjY2NTcyNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdjaCTEjQdxnaIlEWiaGcw9zNV7AHZGgp5q9U0zPf3cmcIgBRYG1n2ydEBHJGgl8nEA1bKiaj1fibK2EA/0?wx_fmt=png&quot; data-nickname=&quot;前端之神&quot; data-alias=&quot;Sunshine_Lin_God&quot; data-signature=&quot;一位前端小菜鸡，写过100多篇原创文章，全网有5w+个前端朋友，梦想是成为”前端之神“~&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;一、基础&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Vuex是一个专为Vue.js应用程序开发的状态管理模式，采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化，每一个Vuex应用的核心是store（仓库）。为了使用Vuex，首先需要安装该包，执行如下命令完成该安装过程。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install vuex@next --save&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;二、核心概念&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Vuex中核心概念主要有五个：State、Getters、Mutations、Actions、Modules，每一部分都有自己的功用，下面先来看一段简单的代码，该代码中涉及到了这些核心概念，然后在该代码的基础上进一步理解。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// index.js文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; {createStore} &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vuex&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; {moduleA} &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./module/moduleA&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; store = createStore({&lt;br/&gt;    &lt;span&gt;// Vuex允许将store分割成模块（module），每个模块拥有自己的state、mutation、action、getter、甚至是嵌套子模块&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 访问moduleA的状态：store.state.moduleA&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;modules&lt;/span&gt;: {&lt;br/&gt;        moduleA&lt;br/&gt;    }&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// module/moduleA.js文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 对于模块内部的mutation和getter，接收的第一个参数是模块的局部状态对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 对于模块内部的action，局部状态通过context.state暴露出来，根节点状态则为context.rootState&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 对于模块内部的getter，根节点状态会作为第三个参数暴露出来&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 在带命名空间的模块内访问全局内容&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 如果希望使用全局state和getter，rootState和rootGetters会作为第三和第四个参数传入getter，也会通过context对象的属性传入action&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 若需要在全局命名空间内分发action或提交mutation，将{root: true}作为第三个参数传给dispatch或commit即可。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; moduleA = {&lt;br/&gt;    &lt;span&gt;// 默认情况下，模块内部的action、mutation和getter是注册在全局命名空间的，如果希望模块具有更高的封装度和复用性，可以通过添加namespaced:true的方式使其成为带命名空间的模块&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;namespaced&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;state&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;testState1&lt;/span&gt;: &lt;span&gt;&#x27;xxxx&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;testState2&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;a&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;b&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;        },&lt;br/&gt;        &lt;span&gt;testState3&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;// 有的时候需要从store中的state中派生出一些状态，此时可以将该部分抽象出一个函数供多处使用。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Vuex允许在store中定义getter，像计算属性一样，getter的返回值会根据它的依赖被缓存起来，且只有当他的依赖值发生了改变才会被重新计算&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;getters&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;// getter接收state作为其第一个参数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;testGetter1&lt;/span&gt;: &lt;span&gt;&lt;span&gt;state&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; state.testState1 + state.testState3;&lt;br/&gt;        },&lt;br/&gt;        &lt;span&gt;// getter可以接受其他getter作为第二个参数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;testGetter2&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;state, getters&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; getters.testGetter1.length;&lt;br/&gt;        }&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;// 更改Vuex的store中的状态的唯一方法是提交mutation，每个mutation都有一个字符串的事件类型和一个回调函数，该回调函数接收state作为第一个参数，提交的载荷作为第二个参数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 以相应的type调用store.commit方法来触发相应的回调函数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Mutation必须是同步函数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;mutations&lt;/span&gt;: {&lt;br/&gt;        testMutation1(state) {&lt;br/&gt;            &lt;span&gt;// 变更状态&lt;/span&gt;&lt;br/&gt;            state.testState3++;&lt;br/&gt;        },&lt;br/&gt;        &lt;span&gt;// 第二个参数是载荷&lt;/span&gt;&lt;br/&gt;        testMutation2(state, payload) {&lt;br/&gt;            state.testState1 += payload.content;&lt;br/&gt;        }&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;// Action提交的是mutation，而不是直接变更状态&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Action可以包含任意异步操作&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Action函数接受一个与store实例具有相同方法和属性的context对象，因此可以调用context.commit提交一个mutation，或者通过context.state和context.getters来获取state和getters。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Action通过store.dispatch方法触发&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;actions&lt;/span&gt;: {&lt;br/&gt;        testAction1(context) {&lt;br/&gt;            setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;                context.commit(&lt;span&gt;&#x27;testMutation1&#x27;&lt;/span&gt;);&lt;br/&gt;            }, &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;        },&lt;br/&gt;        testAction2({commit}, payload) {&lt;br/&gt;            setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;                commit({&lt;br/&gt;                    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;testMutation2&#x27;&lt;/span&gt;,&lt;br/&gt;                    &lt;span&gt;content&lt;/span&gt;: payload.content&lt;br/&gt;                });&lt;br/&gt;            }, &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;State&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Vuex使用单一状态树保存所有数据，作为唯一数据来源。如上所示代码，其包含了testState1、testState2、testState3，在组件中如何获取这些数据呢？（Vue3.x语法）&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;br/&gt;&amp;lt;h1&amp;gt;组件三&amp;lt;/h1&amp;gt;&lt;br/&gt;&amp;lt;p&amp;gt;{{testState1}}&amp;lt;/p&amp;gt;&lt;br/&gt;&amp;lt;p&amp;gt;{{testState2}}&amp;lt;/p&amp;gt;&lt;br/&gt;&amp;lt;p&amp;gt;{{testState3}}&amp;lt;/p&amp;gt;&lt;br/&gt;&amp;lt;/template&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;script setup&amp;gt;&lt;br/&gt;import {computed} from &#x27;vue&#x27;;&lt;br/&gt;import {useStore} from &#x27;vuex&#x27;;&lt;br/&gt;// 通过useStore函数来访问store，与选项式API&lt;br/&gt;const store = useStore();&lt;br/&gt;&lt;br/&gt;// 从store中读取状态并显示到Vue组件中最简单的办法是将其绑定到计算属性上&lt;br/&gt;// 如果想读取某一模块中的状态值，则需要store.state.模块名.状态名&lt;br/&gt;const testState1 = computed(() =&amp;gt; store.state.moduleA.testState1);&lt;br/&gt;const testState2 = computed(() =&amp;gt; store.state.moduleA.testState2.a + store.state.moduleA.testState2.b);&lt;br/&gt;const testState3 = computed(() =&amp;gt; store.state.moduleA.testState3);&lt;br/&gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;style lang=&quot;less&quot;&amp;gt;&amp;lt;/style&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Getters&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;有的时候需要从store中的state中派生出一些状态，此时可以将该部分抽象出一个函数供多处使用。Vuex允许在store中定义getter，像计算属性一样，getter的返回值会根据它的依赖被缓存起来，且只有当他的依赖值发生了改变才会被重新计算。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;br/&gt;&amp;lt;h1&amp;gt;组件三&amp;lt;/h1&amp;gt;&lt;br/&gt;// ……&lt;br/&gt;&amp;lt;p&amp;gt;{{testGetter1}}&amp;lt;/p&amp;gt;&lt;br/&gt;&amp;lt;p&amp;gt;{{testGetter2}}&amp;lt;/p&amp;gt;&lt;br/&gt;&amp;lt;/template&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;script setup&amp;gt;&lt;br/&gt;import {computed} from &#x27;vue&#x27;;&lt;br/&gt;import {useStore} from &#x27;vuex&#x27;;&lt;br/&gt;// 通过useStore函数来访问store，与选项式API&lt;br/&gt;const store = useStore();&lt;br/&gt;&lt;br/&gt;// ……&lt;br/&gt;&lt;br/&gt;// 在computed函数中访问getter&lt;br/&gt;// 如果访问非模块中的getter，直接store.getters.名称&lt;br/&gt;// 如果访问模块中的getter，通过store.getters[&#x27;getter路径&#x27;]&lt;br/&gt;const testGetter1 = computed(() =&amp;gt; store.getters[&#x27;moduleA/testGetter1&#x27;]);&lt;br/&gt;const testGetter2 = computed(() =&amp;gt; store.getters[&#x27;moduleA/testGetter2&#x27;]);&lt;br/&gt;&lt;br/&gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;style lang=&quot;less&quot;&amp;gt;&amp;lt;/style&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Mutations&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;更改Vuex的store中的状态的唯一方法是提交mutation，每个mutation都有一个字符串的事件类型和一个回调函数，该回调函数接收state作为第一个参数，提交的载荷作为第二个参数。（注意：Mutation必须是同步函数）&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;br/&gt;&amp;lt;h1&amp;gt;组件三&amp;lt;/h1&amp;gt;&lt;br/&gt;// ……&lt;br/&gt;&amp;lt;button @click=&quot;handleMutationsClick&quot;&amp;gt;改变&amp;lt;/button&amp;gt;&lt;br/&gt;&amp;lt;/template&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;script setup&amp;gt;&lt;br/&gt;// ……&lt;br/&gt;&lt;br/&gt;// 与mutations相应的type调用store.commit方法来触发相应的回调函数&lt;br/&gt;const handleMutationsClick = () =&amp;gt; {&lt;br/&gt;    store.commit(&#x27;moduleA/testMutation1&#x27;);&lt;br/&gt;    store.commit(&#x27;moduleA/testMutation2&#x27;, {&lt;br/&gt;        content: &#x27;content&#x27;&lt;br/&gt;    });&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;style lang=&quot;less&quot;&amp;gt;&amp;lt;/style&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Actions&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Actions类似于mutation，但是仍然有一些不同点，一方面其提交的是mutation，而不是直接变更状态；另一方面Action可以包含任意异步操作。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;br/&gt;&amp;lt;h1&amp;gt;组件三&amp;lt;/h1&amp;gt;&lt;br/&gt;// ……&lt;br/&gt;&amp;lt;button @click=&quot;handleActionsClick&quot;&amp;gt;改变Action&amp;lt;/button&amp;gt;&lt;br/&gt;&amp;lt;/template&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;script setup&amp;gt;&lt;br/&gt;// ……&lt;br/&gt;&lt;br/&gt;// Action函数接受一个与store实例具有相同方法和属性的context对象，因此可以调用context.commit提交一个mutation，或者通过context.state和context.getters来获取state和getters。&lt;br/&gt;// Action通过store.dispatch方法触发&lt;br/&gt;const handleActionsClick = () =&amp;gt; {&lt;br/&gt;    store.dispatch(&#x27;moduleA/testAction1&#x27;);&lt;br/&gt;    store.dispatch(&#x27;moduleA/testAction2&#x27;, {&lt;br/&gt;        content: &#x27;test&#x27;&lt;br/&gt;    });&lt;br/&gt;};&lt;br/&gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;style lang=&quot;less&quot;&amp;gt;&amp;lt;/style&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;5&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Modules&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;由于使用单一状态树，应用的所有状态都会集中到一个较大的对象，当应用变的复杂时store会变的很难维护，为了解决该问题，Vuex允许将store分割成模块（module），每个模块拥有自己的state、mutation、action、getter、甚至是嵌套子模块，具体使用可见第二节中开头部分的代码，其中包含了其常见的使用方式。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;三、插件&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 插件基础&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Vuex在实例化store的时候可以接受plugins选项，该选项可以添加一系列的插件，插件就可以帮助我们完成一系列的工作，节省人力和物力，下面我们自定义一个简单的插件并调用该插件。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// plugins/myPlugin.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 插件接收唯一的参数store&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; myPlugin = &lt;span&gt;&lt;span&gt;store&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// store上有一系列的方法，可以用在插件中https://next.vuex.vuejs.org/zh/api/#commit&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 注册一个动态模块用registerModule&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 替换store的根状态用replaceState&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 监听mutation的变化，该处理函数会在每个mutation完成后调用，接收mutation和经过mutation后的状态作为参数&lt;/span&gt;&lt;br/&gt;    store.subscribe(&lt;span&gt;(&lt;span&gt;mutation, state&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(mutation);&lt;br/&gt;    });&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; myPlugin;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// index.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; {createStore} &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vuex&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; myPlugin &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./plugins/myPlugin&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; store = createStore({&lt;br/&gt;    &lt;span&gt;// ……&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 一个数组，包含应用在store上的插件方法，这些插件直接接收store作为唯一参数，可以监听mutation或者提交mutation&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;plugins&lt;/span&gt;: [myPlugin]&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 数据持久化插件&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Vuex的状态存储并不能持久化，只要一刷新页面数据就丢失了，此时可引入vuex-persist插件来解决该问题，其会将状态保存至cookie或者localStorage中。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; {createStore} &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vuex&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; VuexPersistence &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vuex-persist&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; myPlugin &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./plugins/myPlugin&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 利用该插件可实现对store数据的持久化&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; vuexLocal = &lt;span&gt;new&lt;/span&gt; VuexPersistence({&lt;br/&gt;    &lt;span&gt;storage&lt;/span&gt;: &lt;span&gt;window&lt;/span&gt;.localStorage&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; store = createStore({&lt;br/&gt;    &lt;span&gt;// ……&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 一个数组，包含应用在store上的插件方法，这些插件直接接收store作为唯一参数，可以监听mutation或者提交mutation&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;plugins&lt;/span&gt;: [myPlugin, vuexLocal.plugin]&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>449ef624e0b83851b42eb2eef5c27abd</guid>
<title>Apache Doris 在有赞的初步尝试</title>
<link>https://toutiao.io/k/mgymcz6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666667&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/PfMGv3PxR79PE4l6LL8jUWcdBYy5LpgK4iaCKhqM0heACgGpu24ob9CSFe9KthkuyIn9uQCoQJgrObS18psSXyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;点击关注“&lt;span&gt;有赞coder&lt;/span&gt;”&lt;/p&gt;&lt;p&gt;获取更多技术干货哦～&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;作者:&lt;/span&gt;&lt;span&gt;郑生俊&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;有赞OLAP&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;有赞作为一家商家服务公司，OLAP对有赞非常重要，从商家后台的数据看板，再到最近有赞门罗发布会上的有赞贾维斯，都离不开OLAP。&lt;span&gt;具体到技术栈，有赞的MOLAP采用Apache Kylin（&lt;/span&gt;&lt;span&gt;参考文章&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwODE3ODU5MA==&amp;amp;mid=2653082536&amp;amp;idx=1&amp;amp;sn=bfb919943201c2a32174519a58850c89&amp;amp;chksm=80a4ad59b7d3244f13bccc19a2ff4e9b89315ede3d78d0d375c0e404f39dfbb5a4cb324c7ee7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;有赞出品｜升级 Kylin 4 最强攻略！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;有赞出品｜升级 Kylin 4 最强攻略！&lt;/span&gt;&lt;/a&gt;&lt;span&gt;），&lt;/span&gt;&lt;span&gt;ROLAP 采用了ClickHouse&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;参考文章&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxOTY5MDMxNA==&amp;amp;mid=2455762137&amp;amp;idx=1&amp;amp;sn=0b7bd5536bfb0de350e1d12aed677820&amp;amp;chksm=8c6872fcbb1ffbea37ece218a8e7184bc9b09c17ad1f3ebc67a3dc44273d112f00fa6b7834c3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;ClickHouse 在有赞的实践之路&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;ClickHouse 在有赞的实践之路&lt;/span&gt;&lt;/a&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;Apache Kylin在有赞内部已经非常稳定了，支撑了大量的高QPS的场景，并且它的存储计算分离架构能够很好地做到弹性伸缩来应对流量的高峰低谷。而ClickHouse作为ROLAP引擎最主要的问题有两块，一是扩缩容麻烦，二是单机的Join性能差。其中扩缩容的高成本是有赞数据团队在ROLAP最为头疼的问题，比如有赞门罗发布会发布了MA的优惠之后，因为ClickHouse扩容的时效性和复杂度，我们需要提前准备较多的硬件为ClickHouse扩容，以应对有可能的业务剧增。尤其是如果ClickHouse之上又有实时写入的场景、做了数据正交分布时，扩容就难上加难了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;试水Apache Doris&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;为了解决上面的问题，团队也尝试了ClickHouse on Apache Doris，但后来因为一些计划变动没有继续投入。欣慰的是Apache Doris在今年推出了向量化引擎，也在6月15号正式孵化为Apache顶级项目，它的设计上能够解决ClickHouse上述的问题。进而细看了Apache Doris的向量化引擎，基本上借鉴了前辈ClickHouse的做法。既然是站在巨人的肩膀上，我们觉得它应该是能够承载ClickHouse之上的业务。为此我们做了初步的性能测试和与Druid的兼容性测试。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;查询性能：&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;在初步的性能测试过程中，结果还是比较惊喜的，比Druid快很多，也比之前非向量化的版本快很多，有些场景和ClickHouse差不多。查询这块主要分享一下我们最近在2phase aggregate做的优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;背景是我们测试在merge aggregate的过程中，发现第二阶段的聚合比第一阶段的聚合速度慢很多。首先解释一下merge aggregate，对于分布式聚合查询，数据通常都需要在某个算子预聚合后，再汇聚到下一个算子进行merge聚合。但我们从Doris的执行信息看到第二阶段的聚合比第一阶段的聚合慢不少，而测试场景下，二阶段聚合的数据量比第一阶段的聚合少很多，反而二阶段聚合的耗时还更高了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先尝试使用perftools来分析瓶颈点，找到核心的耗时代码：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;144&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.2484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/PfMGv3PxR7ibO6HveicDsKMDSuG06qWvPhQS3B50nowBHKNrSUIKnUIWV9uJKqDibpjdtBH3sKOAVDMibUEpic0zNiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们找到上面代码，看了一下二阶段聚合的大致流程，大概有这么几步：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;反序列化一阶段的聚合结果，得到StringColumn&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将StringColumn，反序列化为对应列的数据类型（double、long、hll 等数据结构）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将对应的数据列（double、long、hll 等数据结构），转换为临时用来聚合的数据类型（AggregateData）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将临时的聚合对象与Hash表中存放的最终结果（也是AggregateData）进行聚合运算&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;销毁3步骤产生的临时聚合对象&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;结合上面的perf采样图，我们可以看到大量的CPU消耗在：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将StringColumn反序列化为对应的数据类型，比如long、int、hll 等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将聚合的输入数据（long、int、hll）等转换为聚合需要的AggregateData，这里就有大量临时 对象/内存 的频繁创建和销毁&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了解决上述第一个问题，尝试了在第一阶段聚合结束之后，直接将结果转换为第二个阶段需要的数据类型。这样第二阶段的数据读取，只需要做对应指针类型的强制类型转换即可，而不需要再从StringColumn反序列化获得。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了解决第二个问题，起初我尝试着分配整个块内存来存放要聚合的临时数据，然后最后释放整块内存，以此减少频繁的内存创建和销毁过程，但收效甚微。这时候我们去看看第一阶段聚合的代码为啥会更快，把原因说的通俗点就是：AggregateData可以直接与Block中的数据（double、long、hll 等数据结构）进行聚合运算，不需要将其转换为聚合的相同数据类型（AggregateData）进行聚合运算即可，这样避免大量 对象/内存 频繁的创建、销毁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;按照上面的思路改完代码之后，我们拿一个测试环境的例子看看性能提升，这是一个涉及到600w+数据读取的查询。查询了多次让磁盘数据进操作系统的cache之后比较RT，查询总耗时优化前810ms，优化后560ms，提升了30%的性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;优化前：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;194&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.33515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/PfMGv3PxR7ibO6HveicDsKMDSuG06qWvPhgNZMrzlmVIvOXUDQGJuiaDY4WROSqUSgxKzbNAGKQevcegRA54l53Kg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;优化后：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;181&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.31328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/PfMGv3PxR7ibO6HveicDsKMDSuG06qWvPhcYOMvMmQK3pOgGSDN5ia5gmNIGVHqcRTDZUk1ia7SZQt4DzBRRfyo0oA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然这个case从整体上看RT提升250ms，看着好像可有可无，但这是在降低了资源消耗的情况下达成，往往就意味着系统能够有更高的吞吐。而且数据量大了、查询更复杂之后会有更大的提升，毕竟Aggregate在OLAP中是一个高频操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从整体查询RT的视角，RT容易会有波动，但算子内MergeTime的指标统计不会，因为MergeTime指标统计的都是针对一个内存中Block的聚合耗时，排除了很多网络、IO的干扰因素。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;优化前：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.0700934579439252&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/PfMGv3PxR7ibO6HveicDsKMDSuG06qWvPhlpOpfsBMziaaQpbCzVZQIRybjImVgp87mKpHpTukhaKHoREibcqMCnEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;428&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;优化后：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.1422018348623852&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/PfMGv3PxR7ibO6HveicDsKMDSuG06qWvPhlWKQvm5fVwaocONgexxlnd91cdLOhXmLOibh1EKgNYS1AAxPajwjkZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;436&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上图可以看到MergeTime也大大降低了（其中 ExecTime 指标的变化可以忽略，因为走了不同的代码逻辑，是包含在MergeTime的统计之中的）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;好在Doris的代码写的挺合理的，所以这个优化涉及到的代码量不多，有兴趣可以参考代码：&lt;/span&gt;&lt;span&gt;https://github.com/apache/doris/pull/10618/files。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;兼容性&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;由于我们第一阶段的目标是将Doris替换Apache Druid，因此我们基于Druid场景做了一些兼容性测试。对于平台型团队而言，一旦上层有较多的业务，要推动底层的技术栈迭代和替换是比较困难的，因为通常业务方也很难抽出时间和我们陪跑做全面的兼容性测试。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此我们在Druid Broker处理完查询之后，将一个查询的SQL、RT记录数等信息发送到Kafka。然后由一个Kafka消费者消费上Druid的请求，做SQL改写，将Druid SQL转换为Doris的查询语句发往Doris进行流量回放。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;一些SQL的基本语法都是相同的，比较大的区别是  builtin 函数。有一些Druid  Function 的函数的参数入参含义、个数，都和Apache Doris有较大不同，这导致SQL改写的过程繁琐一些，但这对于平台型的服务团队通常是不得不做的过程。通过流量回放一来可以知道哪些不兼容的SQL语句要做什么样的调整，二来可以通过模拟线上查询情况的过程中确定哪些性能不符合性能预期、哪些查询是有Bug的，比如Druid时序数据查询中经常使用到的time_round_function计算有误（参考代码：https://github.com/apache/doris/pull/9712/files）。确定了上述的各方面的性能和兼容性没问题后，我们才能更高效地协调业务方做一些改造工作。目前我们已经回放了一部分线上查询，整体的业务改动点还好，性能也有较大提升。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;后续计划&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;至于后续的计划，我们的目标是视资源情况推进Doris在有赞落地，尽量将ClickHouse、Druid的技术栈收敛为Apache Doris，解决前面提到的问题，同时也做技术栈的收敛、迭代。当然这还有一些工作要做，包括兼容性测试、性能测试，确保业务上Doris与ClickHouse、Druid有相当的体验，为此我们也在尝试一些手写SIMD优化关键执行代码，希望最终能够借助Apache Doris解决我们ROLAP的痛点问题。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;‍‍&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ac8cc7c1901f8f4b0ee502db6bb402e1</guid>
<title>[推荐] 吐血整理：一份不可多得的架构师图谱！</title>
<link>https://toutiao.io/k/ptp0ru2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section class=&quot;channels_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAjw8kH8ALjgAAAAstQy6ubaLX4KHWvLEZgBPE2aJARlkOVeeDzNPgMIszdok7Y2sA7EK5cGOVPGVT&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7YmwgiahniaXswqzEIHCJXSxqN7aDrH7kFY7TFxQUQsiaKRXpdeEw1xjekbj9qlTkiciaDibcsiaXc0uvsjKUeuKicS921Cia4gP5ictNfcxLA&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=x5Y29zUxcibB3cuGBzHk7qrmuEZVBUZdsFglyGvCjOIuIjS2Flxr69bOVhsOX2icjoc21khuyK3NQ&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/Q3auHgzwzM5nv7YHhmhvPsGGX04JCIgibK2x2Ru0TOY9HeZTGSIL1KQ/0&quot; data-username=&quot;v2_060000231003b20faec8c5e08a1fc3d5c807ec30b07756771265bc6b6234fb9e05062ae69ab4@finder&quot; data-nickname=&quot;儒猿IT&quot; data-desc=&quot;Dubbo是如何基于动态代理实现RPC调用的？平时大家用Dubbo做开发的时候，一定要了解他底层的原理！#Dubbo #RPC #动态代理 @微信时刻 &quot; data-nonceid=&quot;14306340900658042942&quot; data-type=&quot;video&quot; data-width=&quot;1728&quot; data-height=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; powered-by=&quot;xmyeditor.com&quot;&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;文章来源：https://c1n.cn/J3wve&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;目录&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;“架构师图谱”是一个很宏大的命题，特别是优秀的架构师自身也是“由点到面再到图”，一点点成长积累起来。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;尝试写这篇文章的目的更多的是结合自身的一些架构、研发、管理经验对现阶段做一个复盘总结，所以这里更偏向于后端图谱，依赖于开源技术、云原生或者其他第三方服务。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;这里会重点介绍一些技术栈、设计理念以及适应场景，这些可以作为我们选型时的依据。所谓“架构即决策”，是在一个有约束的盒子中寻求最优解。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;这个有约束的盒子是团队经验、成本、资源、进度、业务所处阶段等编织、掺杂在一起的综合体。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;本质上无优劣，但是存在恰当的架构用在合适的软件系统中，而这些就是决策的结果。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;一个技术图谱：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6188925081433225&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZTyO29KNYEDfTeDicmmH1VlE6kYgtPNWm2DqOm5W7hoAHjxbe9vIhvMwqxeSSrvN8lcd7BYMUUzag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1842&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;本文重点聚焦在微服务和常用的消息队列，包括相关的选型以及一些理论基础。&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;完整的思维导图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZTyO29KNYEDfTeDicmmH1VlAHTcXLJ6ISmhIaz9gNQaKbkr6Nl1wkvYk4YVvcn39kZQQLCpqUcNWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;微服务&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;微服务是一种软件架构风格，它是以专注于单一责任与功能的小型功能区块为基础，利用模块化的方式组合出复杂的大型应用程序，各功能区块使用与语言无关的 API 集相互通信。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;br/&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;微服务架构有别于更为传统的单体服务，可将应用拆分成多个核心功能。每个功能都被称为一项服务，可以单独构建和部署。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;这也体现了可扩展的基本思想：将原本大一统的系统拆成多个小部分，扩展时只修改其中一部分，通过这种方式减少改动范围，降低改动风险。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;微服务架构涵盖了服务的多个方面，包括网关、通信协议、服务注册/发现、可观察性、如何合理的划分等等。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| 理论基础&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;微服务的理论基础主要用来指导微服务架构设计、服务拆分，确定合适的服务粒度和边界。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;在做微服务之前我们首先要想明白我们现有系统面临什么样的问题，为什么需要微服务，随后才是怎么做。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;微服务很多核心理念其实在半个世纪前的一篇文章中就被阐述过了，而且这篇文章中的很多论点在软件开发飞速发展的这半个世纪中竟然一再被验证，这就是康威定律（Conway’s Law）。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在康威的这篇文章中，最有名的一句话就是：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations.&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;中文直译大概的意思就是：设计系统的组织，其产生的设计等同于组织之内、组织之间的沟通结构。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;最初这篇文章只是描述作者自己的发现和总结，后来“人月神话”中，引用这个观点，并将其“吹捧”成现在熟知的“高位定律”。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;其中的一些核心观点可以概括如下：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;组织沟通方式决定系统设计，对于复杂的系统，聊设计就离不开聊人与人的沟通，解决好人与人的沟通问题，才能有一个好的系统设计&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;时间再多一件事情也不可能做的完美，但总有时间做完一件事情，这与架构设计&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;“简单、合适、演化”思维不谋而合&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;线&lt;/span&gt;&lt;span&gt;型系统和线型组织架构间有潜在的异质同态特征，更直白的说，你想要什么样的系统，就搭建什么样的团队，定义好系统的边界和接口，团队内应该是自治的，这样将沟通成本维持在系统内部，每个子系统就会更加内聚&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;大的系统组织总是比小系统更倾向于分解，面对复杂的系统及组织，往往可以采用分而治之&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;但是当我们的业务和组织架构复杂度比较高的时候，很多概念只从技术角度很难去抽象，这就需要我们自上而下，建立起通用语言，让业务人员和研发人员说一样的话，把思考层次从代码细节拉到业务层面。越高层的抽象越稳定，越细节的东西越容易变化。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;通过对不同领域的建模，逐步确定领域范围和业务边界，这也就是领域驱动设计（DDD）。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;DDD 是一种在面向高度复杂的软件系统时，关于如何去建模的方法论，它的关键点是根据系统的复杂程度建立合适的模型，DDD 中的界限上下文也完美匹配了微服务的高内聚、低耦合特性，这也为我们微服务的划分提供了强有力的基础。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;DDD 实施的一般步骤是：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;根据需求划分出初步的领域和限界上下文，以及上下文之间的关系&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;进一步分&lt;/span&gt;&lt;span&gt;析每个上下文内部，识别出哪些是实体，哪些是值对象&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;对实体、值对象进行关联和聚合，划分出聚合的范畴和聚合根&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;为聚合根设计仓储，并思考实体或值对象的创建方式&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;在工程中实践领域模型，并在实践中检验模型的合理性，倒推模型中不足的地方并重构&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;但是 DDD 也不是银弹，特别是在一些新业务场景，本身就充满了很多的不确定性，一次性把边界划清楚并不是一件很容易的事。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;大家在一个进程里，调整起来会相对容易，然后让不同的界限上下文各自演化，等到了一定程度之后再考虑微服务也是一个不错的选择。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| 网关&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;作为微服务的统一入口，也肩负着整个微服务的流量接入、管理、聚合、安全等，从服务分层的角度可以划分为接入网关和业务网关。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;接入网关接入网关提供最基础的流量接入和安全防护能力，侧重于全局，与业务无关。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;域名&amp;amp;DNS：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;作为服务的流量入口，对外通过域名和 DNS 提供服务，国内域名厂商一般都依托于共有云或被共有云厂商收购，用来完善自由的云生态。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;像阿里的万网，腾讯的 DNSPod 等，也有国外的 AWS，GoDaddy 和 Namecheap 等，可以用作 .me 等国内无法托管或备案域名的管理。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;其次也可以借助DNS（HTTPDNS、EDNS）实现跨地域、运营商网络等负载均衡，实现异地多活、就近访问、容灾等。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;负载均衡（LB）：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;主要负责请求的转发代理，按机器负载来分配流量等，对外提供 VIP，这里的负载可以宽泛的理解为系统的压力，可以用 CPU 负载来衡量，也可以用连接数、I/O 使用率、网卡吞吐量等来衡量。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;span&gt;负载均衡器按服务层级来划分，除了前边提到的 DNS，还有集群级别的硬件负载均衡，以及机器级别的软件负载均衡。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;DNS/硬件负载均衡（F5/A10）主要用来应对海量用户的访问，中小量用户使用无疑会增加更多的维护和采购成本。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;软件负载均衡可以选择自研或上云，LVS、Keepalived 主要用于四层（IP+端口）的负载均衡，在四层的基础之上如果要实现应用层（域名/URL/用户会话）等的 7 层负载均衡，可以使用 Nginx、Keepalived 的组合。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;除此之外，网关也负责服务整体的安全防护，SSL，IPV6 等：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;安全防护目的是保护服务数据以及可用性，例如防范常见的 DDOS/CC 网络攻击，反爬虫，自定义访问控制，自研成本往往比较高，可以借助云上一系列的高防、防火墙服务。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;SSL（TLS）用来提供外部 https 访问，https 可以防止数据在传输过程中不被窃取、改变，确保数据的完整性，在支付或者用户登录等敏感数据场景，可以起到一定的保护作用，同时 https 页面对搜索引擎也比较友好。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;IPV6，全球 43 亿 IPV4 地址已经在 2019 年年底耗尽，网信办在 2018 年开始就已经推行各大运营商、CDN 厂商、互联网核心产品支持 IPV6，我们公司之前也是试点之一。&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/span&gt;&lt;span&gt;IPV6 的支持只需要增加一条“AAAA”DNS记录，将域名解析到自持 IPV6 的 IP/VIP 即可。&lt;/span&gt;&lt;span&gt;IPV4 到 IPV6 由于存在兼容性等问题，一定是长期共存的，过渡方案可以采用 IPV6 代理（IPV6 代理转发到 IPV4 服务）或者双栈（同时支持 IPV6 和 IPV4）。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;业务网关：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4760672703751617&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZTyO29KNYEDfTeDicmmH1VlMicyOKTcNTt3yLGqZzHibdK8DziaPsZibuUiaX6CEsy9yGTotN4h0p19niaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1546&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;业务网关作为业务的最上层出口，一般承担起业务接入或者 BFF 的工作，例如基础的路由、鉴权、限流、熔断降级、服务聚合、插件化能力，并可以通过可视化界面管理网关配置。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;可选框架有基于 OpenResty 的 Kong、APISIX 以及其他语言相关的 SpringCloud Gateway、gRPC-Gateway 等等。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;国内开源的 Goku、Kratos、go-zero go 框架，有很多比较有意思的组件实现，我们日常业务上也可以借鉴。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;鉴权：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;鉴权的目的是为了验证用户、请求等的有效性，例如用户身份鉴权（JWT/Oauth2/Cookie），请求鉴权（请求签名、请求加密），鉴权逻辑也花样繁多，大多需要基于业务定制化，通过网关插件能很好的集成进来。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;限流：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;限流是为了做一定的流量控制，防止对系统产生过大压力从而影响整个服务。&lt;/span&gt;&lt;span&gt;可以基于单台机器或整个集群限流，常见的方式有限制总量和限制速率，超过的则排队或丢弃，例如令牌桶（弹性）/漏桶（匀速）算法。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;熔断降级：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;熔断作为服务断路器，当下游的服务因为某种原因突然变得不可用或响应过慢（这里既可以指单次请求也可以指一段时间），上游服务为了保证自己整体服务的可用性，不再继续调用目标服务，直接返回，这样也能对整体链路起到保护作用。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;span&gt;如果目标服务情况好转则恢复调用，同时结合降级策略提升服务的鲁棒性。&lt;/span&gt;&lt;span&gt;常见的有Hystrix/Resilience4J（Hystrix 虽然已停止更新，但现有功能已经能满足大多业务场景）。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;重试：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;大量网络 IO，避免不了会出现因网络抖动，出现连接失败或者超时，重试可以提高请求的最终成功率，削平服务毛刺。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;span&gt;但重试也有可能放大故障，所以可以结合退避策略（backoff）、限制单点重试、限制链路重试这些策略进行优雅的重试，同时也可以采用更加激进的“对冲请求”提前（tp99 时间未响应时）发起重试请求，降低系统时延。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;插件化：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;各个网关集成插件的方式尽不相同，但是目的都是为了集成技术人员编写的一些业务相关的通用能力，例如前边提到的身份鉴权、请求鉴权等等。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;span&gt;另外作为业务网关插件，也可以编写一些基础业务（API 鉴权、请求格式化）逻辑，直接透传请求到服务层，省去很多 BFF 和上下游对接的工作。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;BFF：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Backend For Frontend，可以按照业务逻辑，以串行、并行和分支等结构编排多个服务 API，为服务提供聚合、适配、裁剪（只返回需要的字段）功能，核心是 API 的动态编排以满足日益增长的业务逻辑，降低前端与微服务之间的对接成本。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;span&gt;BFF 并不意味着只能由后端实现，也可以在前端通过 GraphQL 等 API 查询语言实现。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| 协议&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;服务间的通信方式是在采用微服务架构时需要做出一个最基本的决策，统一的协议标准也能大大降低服务的联调和维护成本。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;HTTP REST：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;REST 更确切的讲是指的 API 设计风格，而不是协议标准。&lt;/span&gt;&lt;span&gt;通常基于使用 HTTP，URL，和 JSON 这些现有的广泛流行的协议和标准。&lt;/span&gt;&lt;span&gt;符合 REST 设计风格的 API 称作 RESTful API。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;span&gt;在实际应用中大多实现的是伪 REST API，例如用 POST 请求同时实现资源的增删改，或者为了请求的扩展性，资源的增删改查都使用 POST JSON。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;RPC：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;RPC 协议描绘了客户端与服务端之间的点对点调用流程，包括 stub、通信、RPC 消息协议部分。&lt;/span&gt;&lt;span&gt;可以基于 TCP，也可以基于 http。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;span&gt;在实际应用中，还需要考虑服务的高可用、负载均衡等问题，所以产品级的 RPC 框架除了点对点的 RPC 协议的具体实现外，还应包括服务的发现与注册、提供服务的多台 Server 的负载均衡、服务的高可用等更多的功能。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;span&gt;目前的 RPC 框架大致有两种不同的侧重方向，一种偏重于服务治理（Dubbo、Motan），另一种偏重于跨语言调用（Thrift/GRPC）。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;RPC vs HTTP REST 优点：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;更清晰的 API 定义，例如 gRPC 协议的定义文件 proto，自身就可以作为很好的 API 文档，日常开发中也可以把 proto 文件独立版本库管理，精简目录结构，方便不同的服务引用。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;更好的传输效率，通过序列化和反序列化进一步压缩网络传输数据，不过序列化、反序列化也会有一定的性能损耗，protobuf 可以说很好的兼顾了这两点。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;更合适的容错机制，可以基于实际的业务场景，实现更合适的超时控制与异常重试机制，以应对网络抖动等对服务造成的影响。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;在一些特定场景，例如：OpenAPI、BFF 等，HTTP REST 可以更大程度上降低外部团队的接入成本。并且 RPC 也有调试不便、多语言互通需要对应的 SDK 支持这些问题，各有利弊。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;综合考虑来看，除了一些特定场景，如果我们已经有相对完善的基础设施支撑（RPC 框架、服务治理），RPC 可以为一个更合适的选择。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| 服务注册/发现&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;服务注册主要是通过将微服务的后端机器 IP、端口、地域等信息注册起来，并结合一定的发现机制使客户端的请求能够直连具体的后端机器。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;从实现方式上可以分为服务端模式与客户端模式：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6162109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZTyO29KNYEDfTeDicmmH1Vl1xI9X0VuzhotibBhQMDiapMMhMHrT4ADmtg2hXGlBAq1v1PtibBJFaldg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;服务端模式：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;也可以说是传统模式，通过借助负载均衡器和 DNS 实现，负载均衡器负责健康检查、负载均衡策略，DNS 负责实现访问域名到负载均衡器 IP/VIP 的映射。通过直接暴露域名和端口的方式提供客户端访问。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9443359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZTyO29KNYEDfTeDicmmH1VlhNPoQOria7DXfibibVLomDwRkDSsvC7FSGOuR5sMF0X5FIrsjcSr7AB6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/section&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;客户端模式：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;可以借助注册中心实现，注册中心负责服务的注册与健康检查，客户端通过监听配置变更的方式及时把配置中心维护的配置同步到本地，通过客户端负载均衡策略直接向后端机器发起请求。&lt;/span&gt;&lt;/p&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;从两种模式的实现方式上可以看出：&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;①服务端模式注册与发现都由服务端完成，这样可以使客户端专注在自身的业务实现，但是由于依赖负载均衡器，也就是集中式的 proxy，proxy 需要维护双向连接，也很容易使自己成为系统瓶颈，可用性的高低直接决定了服务质量。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;并且 DNS 缓存机制也会导致故障发生时，迁移并不能及时完成。&lt;/span&gt;&lt;span&gt;当然在服务量少，且负载均衡器有 VIP 的情况下，我们也可以不使用 DNS。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;②客户端模式注册与发现由配置中心和客户端共同完成，通过分布式的方式，可以避免出现 proxy 节点性能瓶颈问题，但是可靠性与性能瓶颈很容器出现在配置中心上，并且客户端的也需要一定的接入成本。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;span&gt;好在开源的已经有很成熟的架构方案与丰富的客户端 SDK，例如 etcd/ZooKeeper/Consul。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Consul 提供开箱即用的功能，etcd 社区和接入易用性方面更优一些，他们之间的一些具体区别：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.41675977653631285&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZTyO29KNYEDfTeDicmmH1VlXQcwY57rGd9ftwXhZMZtp7BpFFmO3dibEqRIH2g95iabPCLbdmrEiapTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;895&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| 配置中心&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;配置中心从使用场景来讲，一类是前边讲到的服务注册、发现和 KV 存储，例如 etcd/ZooKeeper/Consul，在 Kubernetes 场景下也可以通过 ConfigMap/Secret 将配置写入本地文件、环境变量或者共享的 Volume 中。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;这样没有了中心服务的依赖和客户端的接入，可以实现一些老旧服务的无侵入式改造。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;但是作为配置中心，除了基础的配置数据，一些情况下还要开放给非开发人员（测试、运维、产品）使用，完善的控制台、权限管理、Dashbord 的支持，也非常重要，这类可以参考 Nacos（阿里开源）/Apollo（携程开源）。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Nacos 在读写性能上优于 Apollo，但是功能特性（例如权限管理）稍逊于 Apollo。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| 可观察性&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;在控制论中，可观察性是用系统输出到外部的信息来推断系统内部运运行状态的一种度量方式。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;在云原生时代，容器和服务的生命周期是紧密联系在一起的，相较在传统的单体服务运行在物理主机或者虚拟机当中，排查问题的时候显得非常不便，这种复杂性导致了一个定义研发运营效率的 MTTR（平均故障修复时间）指标急剧增加。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;所以这里更强调的是微服务的可观察性，需要提前想好我们要如何观察容器内的服务以及服务之间的拓扑信息、各式指标的搜集等，这些监测能力相当重要。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;span&gt;可观察性三大支柱围绕 Tracing（链路追踪）、Logging（日志）和 Metrics（度量）展开，这三个维度几乎涵盖了应用程序的各种表征行为，开发人员通过收集并查看这三个维度的数据时刻掌握应用程序的运行情况。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;很长一段时间，这三者是独立存在的，随着时间的推移，这三者已经相互关联，相辅相成。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5175925925925926&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1J6IbIcPCLZTyO29KNYEDfTeDicmmH1VlP4Yiciay5XEcu3TqOTibYuEzYCw76Mb6oLoVj1cZAdCibxN2DMiceW2zBrw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;①链路追踪&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;链路追踪为分布式应用的开发者提供了完整的调用链路还原、调用请求量统计、链路拓扑、应用依赖分析等工具，可以帮助开发者快速分析和诊断分布式应用架构下的性能瓶颈，提高微服务时代下的开发诊断效率以及系统的可观察性。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;为了解决不同的分布式系统 API 不兼容的问题，诞生了 OpenTracing 规范，OpenTracing 中的 Trace 可以被认为是由多个 Spacn 组成的 DAG 图。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;[&lt;span&gt;Span A&lt;/span&gt;]  ←←←(the root span)&lt;br/&gt;            |&lt;br/&gt;     +------+------+&lt;br/&gt;     |             |&lt;br/&gt; [&lt;span&gt;Span B&lt;/span&gt;]      [Span C] ←←←(Span C 是 Span A 的孩子节点, ChildOf)&lt;br/&gt;     |             |&lt;br/&gt; [&lt;span&gt;Span D&lt;/span&gt;]      +---+-------+&lt;br/&gt;               |           |&lt;br/&gt;           [&lt;span&gt;Span E&lt;/span&gt;]    [Span F] &amp;gt;&amp;gt;&amp;gt; [Span G] &amp;gt;&amp;gt;&amp;gt; [Span H]&lt;br/&gt;                                       ↑&lt;br/&gt;                                       ↑&lt;br/&gt;                                       ↑&lt;br/&gt;                         (Span G 在 Span F 后被调用, FollowsFrom)&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–&amp;gt; time&lt;br/&gt;&lt;br/&gt; [&lt;span&gt;Span A···················································&lt;/span&gt;]&lt;br/&gt;   [&lt;span&gt;Span B··············································&lt;/span&gt;]&lt;br/&gt;      [&lt;span&gt;Span D··········································&lt;/span&gt;]&lt;br/&gt;    [&lt;span&gt;Span C········································&lt;/span&gt;]&lt;br/&gt;         [&lt;span&gt;Span E·······&lt;/span&gt;]        [Span F··] [Span G··] [Span H··]&lt;br/&gt;&lt;/code&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;OpenTracing 专注在 tracing，除此之外还有包含了 Metrics 的 OpenCensus 标准，以及由 CNCF 推出，融合 OpenTracing 和 OpenCensus 的 OpenTelemetry。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;OpenTelemetry 旨在实现云原生时代可观察性指标（Tracing、Logging、Metrics）的统一收集和处理，同时提供推动这些标准实施的组件和工具。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;OpenTracing 中的佼佼者当属 Jaeger、Zipkin、Skywalking。&lt;/span&gt;&lt;span&gt;他们之间的一些对比：&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8491446345256609&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZTyO29KNYEDfTeDicmmH1VljunIy1K4jNlwSgMKKofAMdvQzkPHiciatnv0tKibgn0O7ibtibrVQAv118w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1286&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Zipkin 开源时间长，社区相对丰富，Jaeger 更加轻量，也是 Istio 推荐方案，SkyWalking 支持部分语言（Java、PHP、Python 等）的无侵入式接入。另外 APM（应用性能）监控的支持也会影响到我们的选型。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;除此之外，面对线上海量请求，如果采用抽样采样策略，那就需要支持一定的流量染色，把我们核心关注的请求（例如链路中发生了错误、部分请求耗时过高等）都进行采样。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;可以通过结合 opentelemetry-collector 以及开箱即用的 tailsamplingprocessor 构建 Pipeline 插件实现。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;②日志&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;服务间的链路日志能否帮助我们判断错误发生的具体位置，这类业务日志主要集中在访问日志/打点日志等等。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;随着大数据的兴起，我们对数据的分析解读能力越来越强，日志作为原始数据则体现出了更大的价值，例如用户的行为分析，反垃圾，舆情分析等等。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;业务日志：这类日志重点在于通过不同级别的日志，及时发现分析系统存在的异常。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;RFC 5424 定义的 8 中日志级别：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Emergency：system is unusable&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Alert：action must be taken immediately&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Critical：critical conditions&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Error：error conditions&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Warning：warning conditions&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Notice：normal but significant condition&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Informational：informational messages&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Debug：debug-level messages&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;在实际使用过程中可能会对日志级别进行简化和调整，一般来讲 Warning 及以上的日志是需要重点关注的，需要做好及时的监控告警，Warning 以下的日志也可以辅助问题的定位。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;日志写入可以选择写入消息队列，也可以选择落地磁盘，将关心的结构化或非结构化日志、业务模块信息（如果是细粒度的微服务，可以选择将日志放同一模块收集），以及级别、时间（who、when、where、how、what）等要素正确的写入正确写入后再收集到日志服务。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;写入消息队列需要考虑消息队列的选型以及做好可用性和积压监控，写入磁盘需要考虑写入性能以及日志的切割清理，例如 Golang 的 zap+rotatelogs 组合。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;日志收集的话，由于 Logstash 资源消耗相对比较大，虚拟机环境中可以使用 Filebeat 来替代，更严苛的线上或容器环境，可以使用 Fluentd/Fluentd Bit。日志最终汇总到 ES 和 Kibana 做展示，通过 Esalert 定制告警策略。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;大数据日志：大数据日志本质上也对应着我们一定的业务场景，但大多是海量日志、高吞吐量场景，所以对海量日志的收集和存储是较大的挑战。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;实现方案我们可以采用高吞吐量的流式中间件，例如 Kafka/Plusar 等，在结合流式处理（Flink）或者批处理（Spark）系统，将数据汇总到 Hadoop 进行分析，这里涉及到的中间件和数据库可参考后续章节。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;③指标&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;指标是有关系统的离散的数据点，这些指标通常表示为计数或度量，并且通常在一段时间内进行汇总或计算。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;一般用来做基础的资源监控和业务监控：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;资源监控：CPU、内存、IO、fd、GC等&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;业务监控：QPS、模调、耗时分布等&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Zabbix 作为老牌的监控系统，适合更复杂的物理机、虚拟机、数据库等更复杂的场景，同时也拥有更丰富的图形化界面。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;但是 Prometheus 作为云原生的代表作，与 Kubernetes、容器等能更好的结合，协同 Grafana 实现可定制化的界面，另外存储基于 TSDB，相比于关系型数据库也有更好的扩展性。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;以 Prometheus 为例，支持的数据类型有：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Counter 只增不减的计数器，例如请求数（http_requests_total）。基于此数据模型，使用 Prometheus 提供的强大 PromQL 表达式能够拓展出更加适合开发观察的指标数据。分钟增量请求：increase(http_requests_total[1m]) 分钟 QPS：rate(http_requests_total[1m])&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Gauge 可增可减的时刻量，例如 Go 语言协程数（go_goroutines） 波动量：delta(go_goroutines[10m])&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Histogram 直方图，不同区间内样本的个数。例如，耗时 50ms-100ms 每分钟请求量，100ms-150ms 每分钟请求量。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Summary 概要，反应百分位值。例如，某 RPC 接口，95% 的请求耗时低于 150ms，99% 的请求耗时低于 200ms。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Prometheus 指标支持 pull 和 push 模式：&lt;/span&gt;&lt;/p&gt;&lt;span&gt;‍&lt;/span&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| Service Mesh&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;我们前边讲的服务发现、熔断降级、安全、流量控制、可观察性等能力。这些通用能力在 Service Mesh 出现之前，由 Lib/Framework 通过一些切面的方式完成，这样就可以在开发层面上很容易地集成到我们的应用服务中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是并没有办法实现跨语言编程，有什么改动后，也需要重新编译重新发布服务。理论上应该有一个专门的层来干这事，于是出现了 Sidecar。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一代 Service Mesh，像 Linkerd，后边又出现了第二代 Service Mesh，Istio，职责分明，分离出处数据面和控制面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是 Sidecar 作为代理层，避免不了性能损耗（CPU 序列化反序列化 UDS），所以 proxyless service mesh 重新被提起，和之前的 「RPC + 服务发现治理」区别是啥？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;感觉这个名词营销味道略重。其实不能简单的 “Proxyless Service Mesh” 理解为 “一个简单的 RPC 框架，暴露了几个超时参数到配置中心来控制”，它重在统一协议、API。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;这样就便于基于统一的协议实现 proxyless mesh 和 proxy mesh 的互通，可以同时满足性能敏感型和快速迭代型的业务场景。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.706766917293233&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZTyO29KNYEDfTeDicmmH1Vlem16fKehBmfsiaGXibQaEjzSLWFfILO7zibar7clwu9YpMdIxrSOdv3Dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;665&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;他们相辅相成，丰富了 service mesh 的形态：&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5882352941176471&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZTyO29KNYEDfTeDicmmH1VlicBqb1pzybKeIba5I4vVE5sW8c38B3jkicHibQff14zyWpiarPh7lYsIog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;850&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;servicemesh 对于微服务基础设施的一种演进，但不代表他已经非常成熟了，相反像迁移成本高，甚至一些可用性设计还不如业务自己做那么灵活。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些现实的问题还摆在面前，我觉得这也是属于技术进化的一种趋势，当一项技术足够成熟的时候，又回衍生出新的复杂度问题，从而又需要发展出新技术解决。&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;消息队列&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;在计算机科学中，消息队列是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;也就是说：消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.328159645232816&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZTyO29KNYEDfTeDicmmH1VlfQqGib5H1WL4dbeFicn5mfnqNW0beAibIF8G8jPI77iaIGS9wjHnnsXS7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;902&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;实际应用场景中，消息队列也经常作为中间件，用于异步解耦、削峰填谷、数据广播、错峰与流控、最终一致性等，在一些核心的大数据分析、交易支付等场景也经常扮演重要角色。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;关于服务解耦，会有很多人质疑，消息队列是否能真正解耦，我的理解是：数据要发生流转，系统之间要有依赖关系。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;例如上游服务直接读写下游存储、中间件进行数据交互，解耦则更侧重于将易于变化的复杂度转移，对下游存储、中间件的依赖，通过消息队列转化为双方的弱接口（消息payload）依赖。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;但如果上游是本身是依赖的下游 API，这种方式就需要考虑有多个下游时，自身复杂度和可用性的变化。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;消息队列的选型主要侧重以下几点：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;HA：自身的高可用性保障，避免消息队列的引入而影响整体服务的可用性&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;高吞吐：在面对海量数据写入能否保持一个相对稳定、高效的数据处理能力&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;功能丰富性：是否支持延迟消息、事务消息、死信队列、优先级队列等&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;消息广播：是否支持将消息广播给消费者组或者一组消费者&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;消息堆积能力：在数据量过大时，是否允许一定消息堆积到broker&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;数据持久性：数据持久化策略的采用，也决定着数据在宕机恢复后是否会丢失数据&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;重复消费：是否支持ack机制，在消费者未正确处理消息时，支持重新消费&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;消息顺序性：针对顺序消费的场景保证数据按写入时间的顺序性&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;这里着重对比一下 Redis、RabbitMQ/RocketMQ、Kafka、Plusar。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| Redis&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Redis 实现消息队列可以通过 List 类型、Pub/Sub、Stream（Redis 5.0）类型来实现，HA 使用多副本或者集群的方式。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;作为消息队列使用起来非常方便，但是也有很多的弊端：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;功能丰富性：只支持普通的消息类型&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;数据持久性：Pub/Sub 只提供缓冲区广播能力，不进行持久化，List/Stream 即使基于 aof 和 rdb 持久化策略，但是并没有事务性保障，在宕机恢复后还是存在丢失数据的可能性&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;消息堆积能力：List 随长度增大，内存不断增长；Pub/Sub 只在缓冲区内堆积，缓冲区满消费者强制下线；Stream 创建时可以指定队列最大长度，写满后剔除旧消息&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;除此之外，List 类型无法支持消息广播，和 Pub/Sub 一样也不支持重复消费。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;结合整体来看 Redis 作为消息队列大多数只应用在数据量小，对丢失数据不敏感的业务场景，适用范围较小，复杂业务并且有一定运维支撑的情况下，可以直接考虑企业级消息中间件。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| RabbitMQ vs Kafka vs RocketMQ&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;这几个可以作为企业级消息中间件的代表，而 RocketMQ 在设计之初就借鉴了很多 RabbitMQ、Kafka 的设计理念，例如：Routing、多副本、顺序写（IO），也广泛应用在淘宝双十一等场景。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;HA：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在 HA 方面他们都是通过副本的方式，区别是 RabbitMQ 是集群级别的副本，Kafka 是多 partiton 和 ISR、选举机制，而 RocketMQ 通过多（master/slave）副本同时保障 NameServer 和 Broker。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;高吞吐：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Kafka 和 RocketMQ 通过直接操作文件系统，相比于 RabbitMQ，顺序写能大幅度提升数据的处理速度。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Kafka 为了进一步提升消息的吞吐量，可以采用客户端缓冲队列的方式批量发送，但也会存在宕机丢失数据的可能性，可以通过设置 batch.size 与 linger.ms 来动态调整，相比于 RocketMQ 更加灵活。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Kafka 的 partition 机制的确会带来性能的提升，但是在 Topic 不断增多的情况下，众多的 partition 及副本也将顺序写逐步退化为随机写，并且扩容时，由于 hash 值的变化，也会涉及到大量 partiton 数据的迁移。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;RocketMQ 采用 commitlog 的方式实现全局写，所以能支持更多的 Topic，扩容也不涉及大量数据的迁移。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;功能丰富性：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Kafka 只有基础的消息类型，RabbitMQ 支持优先级队列，通过 TTL 和死信队列可以实现消息的延迟和重试，但是需要提前创建好对应重试频率的队列。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;例如：1s 重试队列，10s 重试队列，RocketMQ 则内置了 18 个重试频率“1s 5s 10s 30s 1m 2m……”，另外也具有独有的 2PL 事务消息，很好的保障业务逻辑与消息发送的一致性。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;重复消费：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;他们三者都采用 ACK 机制保障了单条消息重复消费的能力，Kafka 通过 offset 和 partition 特殊的 ttl 机制（segment 过期，按文件名顺序清理），能支持通过重置 offset 来回溯历史数据。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;消息顺序性：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;RabbitMQ 和 RocketMQ 可以保证写入同一 topic 的顺序性，但是在多个消费者同时消费的情况下还是会出现乱序的情况。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;在数据量较大的时候，我们也可以通过单个消费者消费，再按照一定的分发策略分配给多个消费者执行，只不过会提升整体复杂度，同时会带来更多的 HA、维护成本考量。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Kafka 可以保障单个 partition 的顺序性，并且每个 partiton 只允许一个消费者来消费（N：1），这就从策略上避免了多消费者的情况，在数据量较大的情况下，可以通过划分更多的 partition 提升数据处理能力。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;综合来讲，RabbitMQ、RocketMQ 使用 Queue 模型，丰富的消息队列功能，更多的应用在业务场景，Kafka 基于 Streaming 模型，结合批处理、流式处理，更多的应用在大数据分析场景。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| Pulsar&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Pulsar 作为 Apache 开源、云原生的消息中间件，诞生之初就引发了很大的关注。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;设计上避免了 Kafka 遇到的功能丰富性、扩容等方面的问题，采用计算、存储分离的架构，broker 层只作为“API 接口层”，存储交给更专业的 bookeeper，由于 broker 层的无状态性，结合 Kubernetes 等非常方便的进行扩容。&lt;/span&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0884086444007859&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1J6IbIcPCLZTyO29KNYEDfTeDicmmH1Vlg8ykiahcOXkPwY7sVe4XTUk6K4NvySdY2AITVPEQ9fEFw85E3c0RgJA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1018&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;并且 Pulsar 支持多个消费模型提升消费者处理能力，例如：exclusive、failover、shared、key-shared 等。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;可以说综合了 Kafka 和其他消息中间件的众多优点：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;HA、高吞吐：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;和 Kafka 类似，通过多 partition 和选举机制功，除此之外，还支持丰富的跨地域复制能力&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;功能丰富性：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;可以支持秒级的延迟消息，以及独特的重试队列和私信队列&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;消息顺序性&lt;/strong&gt;：为了实现 partition 消息的顺序性，和 Kafka 一样，都需要将消息写入到同一 broker，区别是 Kafka 会同时存储消息在该 broker，broker 和 partiton 绑定在一起，而 Pulsar 可以将消息分块（segment）后，更加均匀的分散到 bookeeper 节点上，broker 只需要记录映射关系即可，这样在资源扩容时，可以更加快速便捷&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;像能量守恒定律一样，系统的复杂度往往也是守恒的，实现即高性能又高可用的消息中间件需要的技术复杂性，不会凭空消失，只会从一个地方转移到另一个地方。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;消息队列本质上可以理解为 feature+fs，只不过存储、计算分离架构，将各层间的职责分离，使每一层都能专注在自身领域，以应对海量数据和更加复杂多变的环境，这也是现在新技术发展的一个趋势。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;作为后起之秀，的确可以站在巨人的肩膀上，避免很多设计上的不足，同时引入一些新的架构理念，但是要成功的在其中分一杯羹，同样也要面临用户学习成本高、缺少杀手级应用、如何迁移等等这些现实性的问题。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;不过依靠良好的社区和技术先驱，随着时间的变迁，这些短板也会逐步补齐，真正适应当前时代的技术一定会脱颖而出。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAjw8kH8ALjgAAAAstQy6ubaLX4KHWvLEZgBPE2aJARlkOVeeDzNPgMIszdok7Y2sA7EK5cGOVPGVT&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7YmwgiahniaXswqzEIHCJXSxqN7aDrH7kFY7TFxQUQsiaKRXpdeEw1xjekbj9qlTkiciaDibcsiaXc0uvsjKUeuKicS921Cia4gP5ictNfcxLA&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdWRRHVNKCmVibXvGib0vU50ibFSVgJ3xciaZTJ0licvQCIZKrhlqmHicicD2LiamfHibxeibHtNM&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/Q3auHgzwzM5nv7YHhmhvPsGGX04JCIgibK2x2Ru0TOY9HeZTGSIL1KQ/0&quot; data-username=&quot;v2_060000231003b20faec8c5e08a1fc3d5c807ec30b07756771265bc6b6234fb9e05062ae69ab4@finder&quot; data-nickname=&quot;儒猿IT&quot; data-desc=&quot;Dubbo是如何基于动态代理实现RPC调用的？平时大家用Dubbo做开发的时候，一定要了解他底层的原理！#Dubbo #RPC #动态代理 @微信时刻 &quot; data-nonceid=&quot;14306340900658042942&quot; data-type=&quot;video&quot; data-width=&quot;1728&quot; data-height=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;-------------  END  -------------&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;扫码&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;免费&lt;/span&gt;&lt;span&gt;获取&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;600+页&lt;/span&gt;&lt;span&gt;&lt;strong&gt;石杉老师原创精品文章汇总PDF&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;266&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;267&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZ5icqLlExialiaCQxchGhiayjmvre9iaGxkcEbZ7nouMhzte6DQrdm66ygQWsZLgTquaNdXiaV55v7fiaqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;500&quot;/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot;&gt;&lt;p&gt;&lt;img class=&quot;__bg_gif rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/4Acg4lxHhCmfrJ0pDVibHNTZT9yPjQDtW34fia88kcXic4lkhDKpD2D43m2ZIFmK06HQtTiaFaiawhHfqgh3JJzcFDA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;原创技术文章汇总&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.5096045197740113&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLb1sI49A5HEg8H7tqAfMEhtgy64yFFyq3ibTTZZS36cToFCiaFZWA7ABjpbTkHXlTUDWkvQRTKkQkUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;885&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.19607843137254902&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tyspBV9djfmj4CQpUYhF0Wr0PoVybcdicFSfXGYyxueVI1UMO2GOtrCyYe0PaXwSsdbQCW1iaveicQaRovgrA3eog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;102&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;点个&lt;span data-mid=&quot;&quot;&gt;在看&lt;/span&gt;你最好看&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.19607843137254902&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Zgt3gMUJ2LGbE25ticZVnaXibaNMqN2jHzc7IT1tcmFIktmDib2hsdO9IiaE4r4Cia4iaKWb8jzwWmLWicyZ7Foibhh9oQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;102&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;span&gt;‍‍‍‍‍‍‍‍‍‍‍‍&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>