<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3fbb6d11de8c4031ee549c0bf35c3cff</guid>
<title>2022过虎年新年春节大门立体对联大礼包，点击链接立即领取红包！</title>
<link>https://toutiao.io/k/mfp3pig</link>
<content:encoded>&lt;div&gt;&lt;body data-spm=&quot;10720394/n&quot; id=&quot;readabilityBody&quot;&gt;
    
    
    
    
    
    
      
      
    
    
    
    
    
  &lt;/body&gt;
&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>223efe9fc75695a1ed7b0c2441de2cef</guid>
<title>[推荐] 面渣逆袭：Java并发六十问，图文详解，快来看看你会多少道！</title>
<link>https://toutiao.io/k/4ndh1gd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是老三，&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzkwODE5ODM0Ng==&amp;amp;action=getalbum&amp;amp;album_id=2041709347461709827&amp;amp;scene=173&amp;amp;from_msgid=2247489004&amp;amp;from_itemidx=1&amp;amp;count=3&amp;amp;nolastread=1#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;面渣逆袭&lt;/a&gt; 继续，这节我们来盘一盘另一个面试必问知识点——Java并发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章有点长，四万字，图文详解六十道Java并发面试题。人已经肝麻了，大家可以&lt;strong&gt;点赞&lt;/strong&gt;、&lt;strong&gt;收藏&lt;/strong&gt;慢慢看！扶我起来，我还能肝！&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODE5ODM0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdFLJg0sAOqwHB1mb24icMADUgxm1qZQft5aN3H37NAmQnOvpGB7J9JVHxC6NSiacxbBP1DYdhIAeyA/0?wx_fmt=png&quot; data-nickname=&quot;三分恶&quot; data-alias=&quot;Fighter3FullStack&quot; data-signature=&quot;CSDN博客专家、优质创作者，华为云云享专家；肝过外包、混过国企，目前在一家跨境电商搬砖；写过诗，打过拳，佛系小码农。认真讲技术，随性侃人生，关注我，我们一起走的更远。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基础&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.并行跟并发有什么区别？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从操作系统的角度来看，线程是CPU分配的最小单位。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;并行就是同一时刻，两个线程都在执行。这就要求有两个CPU去分别执行两个线程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;并发就是同一时刻，只有一个执行，但是一个时间段内，两个线程都执行了。并发的实现依赖于CPU切换线程，因为切换的时间特别短，所以基本对于用户是无感知的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS2ibNTT0qBy2tDgPX9pG1xvI8EG1JXpZ4t60qd5cTeLfaX2ph3gdT38g/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;并行和并发&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就好像我们去食堂打饭，并行就是我们在多个窗口排队，几个阿姨同时打菜；并发就是我们挤在一个窗口，阿姨给这个打一勺，又手忙脚乱地给那个打一勺。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSQXibcUjkj72rFyjaHicpxaO7O7QibQGTvC5ZLnuSXwlxBxkuWjQ3cJiaRg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;并行并发和食堂打饭&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.说说什么是进程和线程？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要说线程，必须得先说说进程。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;进程：进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程：线程是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作系统在分配资源时是把资源分配给进程的， 但是 CPU 资源比较特殊，它是被分配到线程的，因为真正要占用CPU运行的是线程，所以也说线程是 CPU分配的基本单位。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如在Java中，当我们启动 main 函数其实就启动了一个JVM进程，而 main 函数在的线程就是这个进程中的一个线程，也称主线程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS74wN2kmXIicVic1QlXH54kkRECFvyjNtTwyvRzHBA35cqcysVibTA2fYw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;程序进程线程关系&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个进程中有多个线程，多个线程共用进程的堆和方法区资源，但是每个线程有自己的程序计数器和栈。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.说说线程有几种创建方式？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java中创建线程主要有三种方式，分别为继承Thread类、实现Runnable接口、实现Callable接口。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS6LVYDqPoWWNxm2p8ibPTjwxiaSDaaLxcHvMg0ib7oWQaxUE5g95CRdjwA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;线程创建三种方式&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;继承Thread类，重写run()方法，调用start()方法启动线程&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 继承Thread类&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyThread&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;This is child thread&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        MyThread thread = &lt;span&gt;new&lt;/span&gt; MyThread();&lt;br/&gt;        thread.start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RunnableTask&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Runnable!&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        RunnableTask task = &lt;span&gt;new&lt;/span&gt; RunnableTask();&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(task).start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面两种都是没有返回值的，但是如果我们需要获取线程的执行结果，该怎么办呢？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实现Callable接口，重写call()方法，这种方式可以通过FutureTask获取任务执行的返回值&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CallerTask&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Callable&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;call&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Hello,i am running!&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//创建异步任务&lt;/span&gt;&lt;br/&gt;        FutureTask&amp;lt;String&amp;gt; task=&lt;span&gt;new&lt;/span&gt; FutureTask&amp;lt;String&amp;gt;(&lt;span&gt;new&lt;/span&gt; CallerTask());&lt;br/&gt;        &lt;span&gt;//启动线程&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(task).start();&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//等待执行完成，并获取返回结果&lt;/span&gt;&lt;br/&gt;            String result=task.get();&lt;br/&gt;            System.out.println(result);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (ExecutionException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.为什么调用start()方法时会执行run()方法，那怎么不直接调用run()方法？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM执行start方法，会先创建一条线程，由创建出来的新线程去执行thread的run方法，这才起到多线程的效果。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSdTd8PGSRoibhE9aky2sXmFyX8CTfkMoXvhBF74VbAlWmkL6cfaGxnnA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;start方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**为什么我们不能直接调用run()方法？**也很清楚， 如果直接调用Thread的run()方法，那么run方法还是运行在主线程中，相当于顺序执行，就起不到多线程的效果。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.线程有哪些常用的调度方法？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSsK0UianSHEombkRSia1P63NxI4kicIwfTEZDFiciaOZiaWvckeAdIrl0v2Lw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;线程常用调度方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程等待与通知&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Object类中有一些函数可以用于线程的等待与通知。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;wait()：当一个线程A调用一个共享变量的 wait()方法时， 线程A会被阻塞挂起， 发生下面几种情况才会返回 ：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（1） 线程A调用了共享对象 notify()或者 notifyAll()方法；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（2）其他线程调用了线程A的 interrupt() 方法，线程A抛出InterruptedException异常返回。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;wait(long timeout) ：这个方法相比 wait() 方法多了一个超时参数，它的不同之处在于，如果线程A调用共享对象的wait(long timeout)方法后，没有在指定的 timeout ms时间内被其它线程唤醒，那么这个方法还是会因为超时而返回。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;wait(long timeout, int nanos)，其内部调用的是 wait(long timout）函数。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面是线程等待的方法，而唤醒线程主要是下面两个方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;notify() : 一个线程A调用共享对象的 notify() 方法后，会唤醒一个在这个共享变量上调用 wait 系列方法后被挂起的线程。一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是随机的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;notifyAll() ：不同于在共享变量上调用 notify() 函数会唤醒被阻塞到该共享变量上的一个线程，notifyAll()方法则会唤醒所有在该共享变量上由于调用 wait 系列方法而被挂起的线程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Thread类也提供了一个方法用于等待的方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;join()：如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才&lt;/p&gt;&lt;p&gt;从thread.join()返回。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程休眠&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;sleep(long millis)  :Thread类中的静态方法，当一个执行中的线程A调用了Thread 的sleep方法后，线程A会暂时让出指定时间的执行权，但是线程A所拥有的监视器资源，比如锁还是持有不让出的。指定的睡眠时间到了后该函数会正常返回，接着参与 CPU 的调度，获取到 CPU 资源后就可以继续运行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;让出优先权&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;yield() ：Thread类中的静态方法，当一个线程调用 yield 方法时，实际就是在暗示线程调度器当前线程请求让出自己的CPU ，但是线程调度器可以无条件忽略这个暗示。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程中断&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;void interrupt() ：中断线程，例如，当线程A运行时，线程B可以调用钱程interrupt() 方法来设置线程的中断标志为true 并立即返回。设置标志仅仅是设置标志, 线程A实际并没有被中断， 会继续往下执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;boolean isInterrupted() 方法：检测当前线程是否被中断。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;boolean interrupted() 方法：检测当前线程是否被中断，与 isInterrupted 不同的是，该方法如果发现当前线程被中断，则会清除中断标志。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6.线程有几种状态？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java中，线程共有六种状态：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;状态&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;NEW&lt;/td&gt;&lt;td&gt;初始状态：线程被创建，但还没有调用start()方法&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;RUNNABLE&lt;/td&gt;&lt;td&gt;运行状态：Java线程将操作系统中的就绪和运行两种状态笼统的称作“运行”&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;BLOCKED&lt;/td&gt;&lt;td&gt;阻塞状态：表示线程阻塞于锁&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;WAITING&lt;/td&gt;&lt;td&gt;等待状态：表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TIME_WAITING&lt;/td&gt;&lt;td&gt;超时等待状态：该状态不同于 WAITIND，它是可以在指定的时间自行返回的&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TERMINATED&lt;/td&gt;&lt;td&gt;终止状态：表示当前线程已经执行完毕&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程在自身的生命周期中， 并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换，Java线程状态变化如图示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTShQkou2XzC8FIN6UXecNN3FTb0MvGugyl0oJ1rUn9WOONtU8iaPt3XJw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Java线程状态变化&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7.什么是线程上下文切换？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用多线程的目的是为了充分利用CPU，但是我们知道，并发其实是一个CPU来应付多个线程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSZzAS4QOe2F12nI4saOBr2lZibrR6zHlhxnEWHIY08LyZhQGibU6ckO9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;线程切换-2020-12-16-2107&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了让用户感觉多个线程是在同时执行的， CPU 资源的分配采用了时间片轮转也就是给每个线程分配一个时间片，线程在时间片内占用 CPU 执行任务。当线程使用完时间片后，就会处于就绪状态并让出 CPU 让其他线程占用，这就是上下文切换。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSbEVPLNk4QgvXZick5kIvibH5uf2L1gbDQZhbG7ibzgHefDQ0UyqlGGAgA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;上下文切换时机&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8.守护线程了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java中的线程分为两类，分别为 daemon 线程（守护线程）和 user 线程（用户线程）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JVM 启动时会调用 main 函数，main函数所在的钱程就是一个用户线程。其实在 JVM 内部同时还启动了很多守护线程， 比如垃圾回收线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么守护线程和用户线程有什么区别呢？区别之一是当最后一个非守护线程束时， JVM会正常退出，而不管当前是否存在守护线程，也就是说守护线程是否结束并不影响 JVM退出。换而言之，只要有一个用户线程还没结束，正常情况下JVM就不会退出。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;9.线程间有哪些通信方式？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSdnNJ9qArkNSUFrBzego4UowztBD355hQYrOjML8icFREsxT0jkLZ2UQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;线程间通信方式&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过Java内置的等待/通知机制（wait()/notify()）实现一个线程修改一个对象的值，而另一个线程感知到了变化，然后进行相应的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;管道输入/输出流主要包括了如下4种具体实现：PipedOutputStream、PipedInputStream、 PipedReader和PipedWriter，前两种面向字节，而后两种面向字符。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;关于多线程，其实很大概率还会出一些笔试题，比如交替打印、银行转账、生产消费模型等等，后面老三会单独出一期来盘点一下常见的多线程笔试题。&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ThreadLocal&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal其实应用场景不是很多，但却是被炸了千百遍的面试老油条，涉及到多线程、数据结构、JVM，可问的点比较多，一定要拿下。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;10.ThreadLocal是什么？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal，也就是线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS7OzNCVicicddtUicSdxR1sqVnbUbK2cggB1Tib0nhhGqWSxbcUKibQ52sxw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;ThreadLocal线程副本&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建了一个ThreadLoca变量localVariable，任何一个线程都能并发访问localVariable。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//创建一个ThreadLocal变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ThreadLocal&amp;lt;String&amp;gt; localVariable = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程可以在任何地方使用localVariable，写入变量。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;localVariable.set(&lt;span&gt;&quot;鄙人三某”);&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程在任何地方读取的都是它写入的变量。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;localVariable.get();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;11.你在工作中用到过ThreadLocal吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有用到过的，用来做用户信息上下文的存储。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的系统应用是一个典型的MVC架构，登录后的用户每次访问接口，都会在请求头中携带一个token，在控制层可以根据这个token，解析出用户的基本信息。那么问题来了，假如在服务层和持久层都要用到用户信息，比如rpc调用、更新用户获取等等，那应该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一种办法是显式定义用户相关的参数，比如账号、用户名……这样一来，我们可能需要大面积地修改代码，多少有点瓜皮，那该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候我们就可以用到ThreadLocal，在控制层拦截请求把用户信息存入ThreadLocal，这样我们在任何一个地方，都可以取出ThreadLocal中存的用户数据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSLxvRaYIsxKVfiaiaARYGuicb8atXdAtVhLt8sSbmLMa4PGuMSsVdCxxbw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;ThreadLoca存放用户上下文&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多其它场景的cookie、session等等数据隔离也都可以通过ThreadLocal去实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们常用的数据库连接池也用到了ThreadLocal：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据库连接池的连接交给ThreadLoca进行管理，保证当前线程的操作都是同一个Connnection。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;12.ThreadLocal怎么实现的呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看一下ThreadLocal的set(T)方法，发现先获取到当前线程，再获取&lt;code&gt;ThreadLocalMap&lt;/code&gt;，然后把元素存到这个map中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(T value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//获取当前线程&lt;/span&gt;&lt;br/&gt;        Thread t = Thread.currentThread();&lt;br/&gt;        &lt;span&gt;//获取ThreadLocalMap&lt;/span&gt;&lt;br/&gt;        ThreadLocalMap map = getMap(t);&lt;br/&gt;        &lt;span&gt;//讲当前元素存入map&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (map != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            map.set(&lt;span&gt;this&lt;/span&gt;, value);&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;            createMap(t, value);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal实现的秘密都在这个&lt;code&gt;ThreadLocalMap&lt;/code&gt;了，可以Thread类中定义了一个类型为&lt;code&gt;ThreadLocal.ThreadLocalMap&lt;/code&gt;的成员变量&lt;code&gt;threadLocals&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;//ThreadLocal.ThreadLocalMap是Thread的属性&lt;/span&gt;&lt;br/&gt;   ThreadLocal.ThreadLocalMap threadLocals = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocalMap既然被称为Map，那么毫无疑问它是&amp;lt;key,value&amp;gt;型的数据结构。我们都知道map的本质是一个个&amp;lt;key,value&amp;gt;形式的节点组成的数组，那ThreadLocalMap的节点是什么样的呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Entry&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;WeakReference&lt;/span&gt;&amp;lt;&lt;span&gt;ThreadLocal&lt;/span&gt;&amp;lt;?&amp;gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;/** The value associated with this ThreadLocal. */&lt;/span&gt;&lt;br/&gt;            Object value;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;//节点类&lt;/span&gt;&lt;br/&gt;            Entry(ThreadLocal&amp;lt;?&amp;gt; k, Object v) {&lt;br/&gt;                &lt;span&gt;//key赋值&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;super&lt;/span&gt;(k);&lt;br/&gt;                &lt;span&gt;//value赋值&lt;/span&gt;&lt;br/&gt;                value = v;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的节点，key可以简单低视作ThreadLocal，value为代码中放入的值，当然实际上key并不是ThreadLocal本身，而是它的一个&lt;strong&gt;弱引用&lt;/strong&gt;，可以看到Entry的key继承了 WeakReference（弱引用），再来看一下key怎么赋值的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;WeakReference&lt;/span&gt;&lt;span&gt;(T referent)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(referent);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;key的赋值，使用的是WeakReference的赋值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSxFgEObg5arqOtcKsnCpibAyuEINwG41poYJtQxiaMowJFv4dhicg6X9tA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;ThreadLoca结构图&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;所以，怎么回答ThreadLocal原理？要答出这几个点：&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Thread类有一个类型为ThreadLocal.ThreadLocalMap的实例变量threadLocals，每个线程都有一个属于自己的ThreadLocalMap。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ThreadLocalMap内部维护着Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal的弱引用，value是ThreadLocal的泛型值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个线程在往ThreadLocal里设置值的时候，都是往自己的ThreadLocalMap里存，读也是以某个ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ThreadLocal本身不存储值，它只是作为一个key来让线程往ThreadLocalMap里存取值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;13.ThreadLocal 内存泄露是怎么回事？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来分析一下使用ThreadLocal时的内存，我们都知道，在JVM中，栈内存线程私有，存储了对象的引用，堆内存线程共享，存储了对象实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以呢，栈中存储了ThreadLocal、Thread的引用，堆中存储了它们的具体实例。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSJOAVnpoBkPjgRy503rPYLiaSGDIqol7Pohf6WQgibNKekuD9Sp4TWJnw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;ThreadLocal内存分配&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocalMap中使用的 key 为 ThreadLocal 的弱引用。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;“弱引用：只要垃圾回收机制一运行，不管JVM的内存空间是否充足，都会回收该对象占用的内存。”&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么现在问题就来了，弱引用很容易被回收，如果ThreadLocal（ThreadLocalMap的Key）被垃圾回收器回收了，但是ThreadLocalMap生命周期和Thread是一样的，它这时候如果不被回收，就会出现这种情况：ThreadLocalMap的key没了，value还在，这就会&lt;strong&gt;造成了内存泄漏问题&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;那怎么解决内存泄漏问题呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很简单，使用完ThreadLocal后，及时调用remove()方法释放内存空间。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ThreadLocal&amp;lt;String&amp;gt; localVariable = &lt;span&gt;new&lt;/span&gt; ThreadLocal();&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    localVariable.set(&lt;span&gt;&quot;鄙人三某”);&lt;br/&gt;    ……&lt;br/&gt;} finally {&lt;br/&gt;    localVariable.remove();&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;那为什么key还要设计成弱引用？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;key设计成弱引用同样是为了防止内存泄漏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如key被设计成强引用，如果ThreadLocal Reference被销毁，此时它指向ThreadLoca的强引用就没有了，但是此时key还强引用指向ThreadLoca，就会导致ThreadLocal不能被回收，这时候就发生了内存泄漏的问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;14.ThreadLocalMap的结构了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocalMap虽然被叫做Map，其实它是没有实现Map接口的，但是结构还是和HashMap比较类似的，主要关注的是两个要素：&lt;code&gt;元素数组&lt;/code&gt;和&lt;code&gt;散列方法&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSgI4lgEHeM9mwORic2rkq4KJ4vsibqs7eezWc6kiarB3LvnxhibaZzUSIDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;ThreadLocalMap结构示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;元素数组&lt;/p&gt;&lt;p&gt;一个table数组，存储Entry类型的元素，Entry是ThreaLocal弱引用作为key，Object作为value的结构。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; &lt;span&gt;private&lt;/span&gt; Entry[] table;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;散列方法&lt;/p&gt;&lt;p&gt;散列方法就是怎么把对应的key映射到table数组的相应下标，ThreadLocalMap用的是哈希取余法，取出key的threadLocalHashCode，然后和table数组长度减一&amp;amp;运算（相当于取余）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (table.length - &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的threadLocalHashCode计算有点东西，每创建一个ThreadLocal对象，它就会新增&lt;code&gt;0x61c88647&lt;/code&gt;，这个值很特殊，它是&lt;strong&gt;斐波那契数&lt;/strong&gt;  也叫 &lt;strong&gt;黄金分割数&lt;/strong&gt;。&lt;code&gt;hash&lt;/code&gt;增量为 这个数字，带来的好处就是 &lt;code&gt;hash&lt;/code&gt; &lt;strong&gt;分布非常均匀&lt;/strong&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; HASH_INCREMENT = &lt;span&gt;0x61c88647&lt;/span&gt;;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;nextHashCode&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; nextHashCode.getAndAdd(HASH_INCREMENT);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;15.ThreadLocalMap怎么解决Hash冲突的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可能都知道HashMap使用了链表来解决冲突，也就是所谓的链地址法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocalMap没有使用链表，自然也不是用链地址法来解决冲突了，它用的是另外一种方式——&lt;strong&gt;开放定址法&lt;/strong&gt;。开放定址法是什么意思呢？简单来说，就是这个坑被人占了，那就接着去找空着的坑。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSXqlXgzl4viatlpaKZ2NcpQaKOwODCJicogsE6ico6TOFGicv6GGEJmAbTg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;ThreadLocalMap解决冲突&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，如果我们插入一个value=27的数据，通过 hash计算后应该落入第 4 个槽位中，而槽位 4 已经有了 Entry数据，而且Entry数据的key和当前不相等。此时就会线性向后查找，一直找到 Entry为 null的槽位才会停止查找，把元素放到空的槽中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该槽位Entry对象中的key是否和get的key一致，如果不一致，就判断下一个位置。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;16.ThreadLocalMap扩容机制了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在ThreadLocalMap.set()方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中&lt;code&gt;Entry&lt;/code&gt;的数量已经达到了列表的扩容阈值&lt;code&gt;(len*2/3)&lt;/code&gt;，就开始执行&lt;code&gt;rehash()&lt;/code&gt;逻辑：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (!cleanSomeSlots(i, sz) &amp;amp;&amp;amp; sz &amp;gt;= threshold)&lt;br/&gt;    rehash();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再着看rehash()具体实现：这里会先去清理过期的Entry，然后还要根据条件判断&lt;code&gt;size &amp;gt;= threshold - threshold / 4&lt;/code&gt; 也就是&lt;code&gt;size &amp;gt;= threshold* 3/4&lt;/code&gt;来决定是否需要扩容。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;rehash&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//清理过期Entry&lt;/span&gt;&lt;br/&gt;    expungeStaleEntries();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//扩容&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (size &amp;gt;= threshold - threshold / &lt;span&gt;4&lt;/span&gt;)&lt;br/&gt;        resize();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//清理过期Entry&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;expungeStaleEntries&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Entry[] tab = table;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; len = tab.length;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; len; j++) {&lt;br/&gt;        Entry e = tab[j];&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; e.get() == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            expungeStaleEntry(j);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着看看具体的&lt;code&gt;resize()&lt;/code&gt;方法，扩容后的&lt;code&gt;newTab&lt;/code&gt;的大小为老数组的两倍，然后遍历老的table数组，散列方法重新计算位置，开放地址解决冲突，然后放到新的&lt;code&gt;newTab&lt;/code&gt;，遍历完成之后，&lt;code&gt;oldTab&lt;/code&gt;中所有的&lt;code&gt;entry&lt;/code&gt;数据都已经放入到&lt;code&gt;newTab&lt;/code&gt;中了，然后table引用指向&lt;code&gt;newTab&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSV7Bjxb1CgQ5AIGI4IianWrjsGI6FeU8WkZP88b0HJye0ibdY3lIrcXUw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;ThreadLocalMap扩容&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体代码：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9412568306010929&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSGjqQa74l4ibU9LUxAyiccib1M1ygC69DhiaAY9pLcTsVXh8kB5mG5hAUFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1464&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;ThreadLocalMap resize&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;17.父子线程怎么共享数据？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;父线程能用ThreadLocal来给子线程传值吗？毫无疑问，不能。那该怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候可以用到另外一个类——&lt;code&gt;InheritableThreadLocal&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用起来很简单，在主线程的InheritableThreadLocal实例设置值，在子线程中就可以拿到了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;InheritableThreadLocalTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; ThreadLocal threadLocal = &lt;span&gt;new&lt;/span&gt; InheritableThreadLocal();&lt;br/&gt;        &lt;span&gt;// 主线程&lt;/span&gt;&lt;br/&gt;        threadLocal.set(&lt;span&gt;&quot;不擅技术&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//子线程&lt;/span&gt;&lt;br/&gt;        Thread t = &lt;span&gt;new&lt;/span&gt; Thread() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;super&lt;/span&gt;.run();&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;鄙人三某 ，&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;            }&lt;br/&gt;        };&lt;br/&gt;        t.start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;那原理是什么呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原理很简单，在Thread类里还有另外一个变量：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ThreadLocal.ThreadLocalMap inheritableThreadLocals = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Thread.init的时候，如果父线程的&lt;code&gt;inheritableThreadLocals&lt;/code&gt;不为空，就把它赋给当前线程（子线程）的&lt;code&gt;inheritableThreadLocals&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;        &lt;span&gt;if&lt;/span&gt; (inheritThreadLocals &amp;amp;&amp;amp; parent.inheritableThreadLocals != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.inheritableThreadLocals =&lt;br/&gt;                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Java内存模型&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;18.说一下你对Java内存模型（JMM）的理解？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java内存模型（Java Memory Model，JMM），是一种抽象的模型，被定义出来屏蔽各种硬件和操作系统的内存访问差异。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在&lt;code&gt;主内存&lt;/code&gt;（Main Memory）中，每个线程都有一个私有的&lt;code&gt;本地内存&lt;/code&gt;（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java内存模型的抽象图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSnonAhOvsLyIq9oVniaHbQoBBiabb3icDmUj9QPpwr6JTicxLvUXjkyA5iag/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Java内存模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地内存是JMM的 一个抽象概念，并不真实存在。它其实涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSAc5mhRToS0npoiaVx3X8JlsodFZK6fhurcicHpgRp14WfL8JvicvcOr6A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;实际线程工作模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图里面的是一个双核 CPU 系统架构 ，每个核有自己的控制器和运算器，其中控制器包含一组寄存器和操作控制器，运算器执行算术逻辅运算。每个核都有自己的一级缓存，在有些架构里面还有一个所有 CPU 共享的二级缓存。那么 Java 内存模型里面的工作内存，就对应这里的 Ll 缓存或者 L2 缓存或者 CPU 寄存器。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;19.说说你对原子性、可见性、有序性的理解？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原子性、有序性、可见性是并发编程中非常重要的基础概念，JMM的很多技术都是围绕着这三大特性展开。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;原子性&lt;/strong&gt;：原子性指的是一个操作是不可分割、不可中断的，要么全部执行并且执行的过程不会被任何因素打断，要么就全不执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;可见性&lt;/strong&gt;：可见性指的是一个线程修改了某一个共享变量的值时，其它线程能够立即知道这个修改。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;有序性&lt;/strong&gt;：有序性指的是对于一个线程的执行代码，从前往后依次执行，单线程下可以认为程序是有序的，但是并发时有可能会发生指令重排。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;分析下面几行代码的原子性？&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; j = i;&lt;br/&gt;i++;&lt;br/&gt;i = i + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第1句是基本类型赋值，是原子性操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第2句先读i的值，再赋值到j，两步操作，不能保证原子性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第3和第4句其实是等效的，先读取i的值，再+1，最后赋值到i，三步操作了，不能保证原子性。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原子性、可见性、有序性都应该怎么保证呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;原子性：JMM只能保证基本的原子性，如果要保证一个代码块的原子性，需要使用&lt;code&gt;synchronized&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可见性：Java是利用&lt;code&gt;volatile&lt;/code&gt;关键字来保证可见性的，除此之外，&lt;code&gt;final&lt;/code&gt;和&lt;code&gt;synchronized&lt;/code&gt;也能保证可见性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有序性：&lt;code&gt;synchronized&lt;/code&gt;或者&lt;code&gt;volatile&lt;/code&gt;都可以保证多线程之间操作的有序性。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;20.那说说什么是指令重排？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序，如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSic5DZznpibPK6xYic2ia1qfAvCm2rgjicibgxl13iaib4EIFbCkTuTQibianGebw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;多级指令重排&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们比较熟悉的双重校验单例模式就是一个经典的指令重排的例子，&lt;code&gt;Singleton instance=new Singleton()；&lt;/code&gt;对应的JVM指令分为三步：分配内存空间--&amp;gt;初始化对象---&amp;gt;对象指向分配的内存空间，但是经过了编译器的指令重排序，第二步和第三步就可能会重排序。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSoocg32Q3ch7OlT42qibFohN60RgRYZ7sMAx6iciaHRDictnV8mJjib0Cy7w/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;双重校验单例模式异常情形&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;21.指令重排有限制吗？happens-before了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指令重排也是有一些限制的，有两个规则&lt;code&gt;happens-before&lt;/code&gt;和&lt;code&gt;as-if-serial&lt;/code&gt;来约束。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;happens-before的定义：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照 happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;happens-before和我们息息相关的有六大规则：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSG26AK357jeffoicWUO9hou5heVHIz0ib2Dzk3tz5mcWSWmFUXhGja5Lg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;happens-before六大规则&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;程序顺序规则&lt;/strong&gt;：一个线程中的每个操作，happens-before于该线程中的任意后续操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;监视器锁规则&lt;/strong&gt;：对一个锁的解锁，happens-before于随后对这个锁的加锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;volatile变量规则&lt;/strong&gt;：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;传递性&lt;/strong&gt;：如果A happens-before B，且B happens-before C，那么A happens-before C。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;start()规则&lt;/strong&gt;：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的 ThreadB.start()操作happens-before于线程B中的任意操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;join()规则&lt;/strong&gt;：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作 happens-before于线程A从ThreadB.join()操作成功返回。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;22.as-if-serial又是什么？单线程的程序一定是顺序的吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），&lt;strong&gt;单线程程序的执行结果不能被改变&lt;/strong&gt;。编译器、runtime和处理器都必须遵守as-if-serial语义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;double&lt;/span&gt; pi = &lt;span&gt;3.14&lt;/span&gt;;   &lt;span&gt;// A&lt;/span&gt;&lt;br/&gt;&lt;span&gt;double&lt;/span&gt; r = &lt;span&gt;1.0&lt;/span&gt;;   &lt;span&gt;// B &lt;/span&gt;&lt;br/&gt;&lt;span&gt;double&lt;/span&gt; area = pi * r * r;   &lt;span&gt;// C&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面3个操作的数据依赖关系：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSoicqQts0bjMgrE0ydNavibWlNQ2PoXiadcZBFQoZw1osxvKymibuIqYYSw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;image-20210812200646364&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面（C排到A和B的前面，程序的结果将会被改变）。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以最终，程序可能会有两种执行顺序：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSicLH66iaiaxc40M9Trt5Oibibeh38rTWArPs9lzibbbiar9cZydb3CUjT6zhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;两种执行结果&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器、runtime和处理器共同编织了这么一个“楚门的世界”：单线程程序是按程序的“顺序”来执行的。as- if-serial语义使单线程情况下，我们不需要担心重排序的问题，可见性的问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;23.volatile实现原理了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;volatile有两个作用，保证&lt;strong&gt;可见性&lt;/strong&gt;和&lt;strong&gt;有序性&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;volatile怎么保证可见性的呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比synchronized的加锁方式来解决共享变量的内存可见性问题，volatile就是更轻量的选择，它没有上下文切换的额外开销成本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;volatile可以确保对某个变量的更新对其他线程马上可见，一个变量被声明为volatile 时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存 当其它线程读取该共享变量 ，会从主内存重新获取最新值，而不是使用当前线程的本地内存中的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，我们声明一个 volatile 变量 volatile int x = 0，线程A修改x=1，修改完之后就会把新的值刷新回主内存，线程B读取x的时候，就会清空本地内存变量，然后再从主内存获取最新值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSGcrh3iaF31I0HPWFgCvJwYz9LzdocCsvDwwpTLFcWCib9WDUOXJBSYRw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;volatile内存可见性&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;volatile怎么保证有序性的呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重排序可以分为编译器重排序和处理器重排序，valatile保证有序性，就是通过分别限制这两种类型的重排序。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS2ZQ1DzwFGiao8t8BK6RrXAfZxXKiagoDmcWY2vqxuLKTr7SvlJNyQsRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;volatile重排序规则表&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在每个volatile写操作的前面插入一个&lt;code&gt;StoreStore&lt;/code&gt;屏障&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在每个volatile写操作的后面插入一个&lt;code&gt;StoreLoad&lt;/code&gt;屏障&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在每个volatile读操作的后面插入一个&lt;code&gt;LoadLoad&lt;/code&gt;屏障&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在每个volatile读操作的后面插入一个&lt;code&gt;LoadStore&lt;/code&gt;屏障&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS3M20yZxcKh01sIRcmlfictrIiaFiamFAz6F6heFib3rUNekdic6aBcxQd8A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;volatile写插入内存屏障后生成的指令序列示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSckMwF6bKicicIo4KB8WWUBtxiazY0RYjkaHTPSficTicqFN8T1AJZ1ZHhoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;volatile写插入内存屏障后生成的指令序列示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;锁&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;24.synchronized用过吗？怎么使用？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;synchronized经常用的，用来保证代码的原子性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;synchronized主要有三种用法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;修饰实例方法:&lt;/strong&gt; 作用于当前对象实例加锁，进入同步代码前要获得 &lt;strong&gt;当前对象实例的锁&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;method&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;修饰静态方法&lt;/strong&gt;：也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得当前 class 的锁。因为静态成员不属于任何⼀个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管 new 了多少个对象，只有⼀份）。&lt;/p&gt;&lt;p&gt;如果⼀个线程 A 调⽤⼀个实例对象的⾮静态 synchronized ⽅法，⽽线程 B 需要调⽤这个实例对象所属类的静态 synchronized ⽅法，是允许的，不会发⽣互斥现象，因为访问静态 synchronized ⽅法占⽤的锁是当前类的锁，⽽访问⾮静态 synchronized ⽅法占⽤的锁是当前实例对象锁。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; staic &lt;span&gt;method&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;修饰代码块&lt;/strong&gt; ：指定加锁对象，对给定对象/类加锁。synchronized(this|object) 表示进⼊同步代码库前要获得给定对象的锁。synchronized(类.class) 表示进⼊同步代码前要获得 当前 &lt;strong&gt;class&lt;/strong&gt; 的锁&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;) {&lt;br/&gt; &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;25.synchronized的实现原理？&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;synchronized是怎么加锁的呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用synchronized的时候，发现不用自己去lock和unlock，是因为JVM帮我们把这个事情做了。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;synchronized修饰代码块时，JVM采用&lt;code&gt;monitorenter&lt;/code&gt;、&lt;code&gt;monitorexit&lt;/code&gt;两个指令来实现同步，&lt;code&gt;monitorenter&lt;/code&gt; 指令指向同步代码块的开始位置， &lt;code&gt;monitorexit&lt;/code&gt; 指令则指向同步代码块的结束位置。&lt;/p&gt;&lt;p&gt;反编译一段synchronized修饰代码块代码，&lt;code&gt;javap -c -s -v -l SynchronizedDemo.class&lt;/code&gt;，可以看到相应的字节码指令。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSRr65FWYHibtxk43IlzxZEuO4ibSzXiakqolF1FWDibuWGWRqqF5xG89zTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;monitorenter和monitorexit&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;synchronized修饰同步方法时，JVM采用&lt;code&gt;ACC_SYNCHRONIZED&lt;/code&gt;标记符来实现同步，这个标识指明了该方法是一个同步方法。&lt;/p&gt;&lt;p&gt;同样可以写段代码反编译看一下。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSvZkByFiaSR186ic6tG7tMUaz2gWloo5WpChlWgg0zOkmbzicLQibzBhX2g/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;synchronized修饰同步方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;synchronized锁住的是什么呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;monitorenter、monitorexit或者ACC_SYNCHRONIZED都是&lt;strong&gt;基于Monitor实现&lt;/strong&gt;的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例对象结构里有对象头，对象头里面有一块结构叫Mark Word，Mark Word指针指向了&lt;strong&gt;monitor&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓的Monitor其实是一种&lt;strong&gt;同步工具&lt;/strong&gt;，也可以说是一种&lt;strong&gt;同步机制&lt;/strong&gt;。在Java虚拟机（HotSpot）中，Monitor是由&lt;strong&gt;ObjectMonitor实现&lt;/strong&gt;的，可以叫做内部锁，或者Monitor锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ObjectMonitor的工作原理：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ObjectMonitor有两个队列：_WaitSet、_EntryList，用来保存ObjectWaiter 对象列表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;_owner，获取 Monitor 对象的线程进入 _owner 区时， _count + 1。如果线程调用了 wait() 方法，此时会释放 Monitor 对象， _owner 恢复为空， _count - 1。同时该等待线程进入 _WaitSet 中，等待被唤醒。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ObjectMonitor() {&lt;br/&gt;    _header       = NULL;&lt;br/&gt;    _count        = &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;// 记录线程获取锁的次数&lt;/span&gt;&lt;br/&gt;    _waiters      = &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;    _recursions   = &lt;span&gt;0&lt;/span&gt;;  &lt;span&gt;//锁的重入次数&lt;/span&gt;&lt;br/&gt;    _object       = NULL;&lt;br/&gt;    _owner        = NULL;  &lt;span&gt;// 指向持有ObjectMonitor对象的线程&lt;/span&gt;&lt;br/&gt;    _WaitSet      = NULL;  &lt;span&gt;// 处于wait状态的线程，会被加入到_WaitSet&lt;/span&gt;&lt;br/&gt;    _WaitSetLock  = &lt;span&gt;0&lt;/span&gt; ;&lt;br/&gt;    _Responsible  = NULL ;&lt;br/&gt;    _succ         = NULL ;&lt;br/&gt;    _cxq          = NULL ;&lt;br/&gt;    FreeNext      = NULL ;&lt;br/&gt;    _EntryList    = NULL ;  &lt;span&gt;// 处于等待锁block状态的线程，会被加入到该列表&lt;/span&gt;&lt;br/&gt;    _SpinFreq     = &lt;span&gt;0&lt;/span&gt; ;&lt;br/&gt;    _SpinClock    = &lt;span&gt;0&lt;/span&gt; ;&lt;br/&gt;    OwnerIsThread = &lt;span&gt;0&lt;/span&gt; ;&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以类比一个去医院就诊的例子[18]：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;首先，患者在&lt;strong&gt;门诊大厅&lt;/strong&gt;前台或自助挂号机&lt;strong&gt;进行挂号&lt;/strong&gt;；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;随后，挂号结束后患者找到对应的&lt;strong&gt;诊室就诊&lt;/strong&gt;：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;诊室每次只能有一个患者就诊；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果此时诊室空闲，直接进入就诊；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果此时诊室内有其它患者就诊，那么当前患者进入&lt;strong&gt;候诊室&lt;/strong&gt;，等待叫号；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;就诊结束后，&lt;strong&gt;走出就诊室&lt;/strong&gt;，候诊室的&lt;strong&gt;下一位候诊患者&lt;/strong&gt;进入就诊室。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSiagkLrT13ODJIGtCoqmkaqHAr8ajLSn9yrssSYc4tCuFyFzmtFRW5BA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;就诊-图片来源参考[18]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个过程就和Monitor机制比较相似：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;门诊大厅&lt;/strong&gt;：所有待进入的线程都必须先在&lt;strong&gt;入口Entry Set&lt;/strong&gt;挂号才有资格；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;就诊室&lt;/strong&gt;：就诊室**_Owner**里里只能有一个线程就诊，就诊完线程就自行离开&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;候诊室&lt;/strong&gt;：就诊室繁忙时，进入&lt;strong&gt;等待区（Wait Set）&lt;/strong&gt;，就诊室空闲的时候就从**等待区（Wait Set）**叫新的线程&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSos3QdH4PxYjvib985CQRpnWcRVfjEPUUpNlOS9qdqVcMeiaP45JeH4xg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Java Montior机制&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们就知道了，同步是锁住的什么东西：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;monitorenter，在判断拥有同步标识 ACC_SYNCHRONIZED 抢先进入此方法的线程会优先拥有 Monitor 的 owner ，此时计数器 +1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;monitorexit，当执行完退出后，计数器 -1，归 0 后被其他进入的线程获得。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;26.除了原子性，synchronized可见性，有序性，可重入性怎么实现？&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;synchronized怎么保证可见性？&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程加锁后，其它线程无法获取主内存中的共享变量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程解锁前，必须把共享变量的最新值刷新到主内存中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;synchronized怎么保证有序性？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;synchronized同步的代码块，具有排他性，一次只能被一个线程拥有，所以synchronized保证同一时刻，代码是单线程执行的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为as-if-serial语义的存在，单线程的程序能保证最终结果是有序的，但是不保证不会指令重排。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以synchronized保证的有序是执行结果的有序性，而不是防止指令重排的有序性。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;synchronized怎么实现可重入的呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;synchronized 是可重入锁，也就是说，允许一个线程二次请求自己持有对象锁的临界资源，这种情况称为可重入锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;synchronized 锁对象的时候有个计数器，他会记录下线程获取锁的次数，在执行完对应的代码块之后，计数器就会-1，直到计数器清零，就释放锁了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之所以，是可重入的。是因为 synchronized 锁对象有个计数器，会随着线程获取锁后 +1 计数，当线程执行完毕后 -1，直到清零释放锁。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;27.锁升级？synchronized优化了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解锁升级，得先知道，不同锁的状态是什么样的。这个状态指的是什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java对象头里，有一块结构，叫&lt;code&gt;Mark Word&lt;/code&gt;标记字段，这块结构会随着锁的状态变化而变化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;64 位虚拟机 Mark Word 是 64bit，我们来看看它的状态变化：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSIibOhyPThvSk8jq1BpXuUcrcNfa2M7VEXg5yQn8NCFLLic4zMr8pG8EQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Mark Word变化&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Mark Word存储对象自身的运行数据，如&lt;strong&gt;哈希码、GC分代年龄、锁状态标志、偏向时间戳（Epoch）&lt;/strong&gt; 等。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;synchronized做了哪些优化？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JDK1.6之前，synchronized的实现直接调用ObjectMonitor的enter和exit，这种锁被称之为&lt;strong&gt;重量级锁&lt;/strong&gt;。从JDK6开始，HotSpot虚拟机开发团队对Java中的锁进行优化，如增加了适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等优化策略，提升了synchronized的性能。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;偏向锁：在无竞争的情况下，只是在Mark Word里存储当前线程指针，CAS操作都不做。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;轻量级锁：在没有多线程竞争时，相对重量级锁，减少操作系统互斥量带来的性能消耗。但是，如果存在锁竞争，除了互斥量本身开销，还额外有CAS操作的开销。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;自旋锁：减少不必要的CPU上下文切换。在轻量级锁升级为重量级锁时，就使用了自旋加锁的方式&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;锁粗化：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;锁消除：虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;锁升级的过程是什么样的？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;锁升级方向：无锁--&amp;gt;偏向锁---&amp;gt; 轻量级锁----&amp;gt;重量级锁，这个方向基本上是不可逆的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSFBicqibx89V9xFTHnSrdwBvrxTmdichAPglf9UQtxhNNJYtiamtDxGJRug/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;锁升级方向&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看一下升级的过程：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;偏向锁：&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;偏向锁的获取：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;判断是否为可偏向状态--MarkWord中锁标志是否为‘01’，是否偏向锁是否为‘1’&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果是可偏向状态，则查看线程ID是否为当前线程，如果是，则进入步骤&#x27;5&#x27;，否则进入步骤‘3’&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过CAS操作竞争锁，如果竞争成功，则将MarkWord中线程ID设置为当前线程ID，然后执行‘5’；竞争失败，则执行‘4’&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CAS获取偏向锁失败表示有竞争。当达到safepoint时获得偏向锁的线程被挂起，&lt;strong&gt;偏向锁升级为轻量级锁&lt;/strong&gt;，然后被阻塞在安全点的线程继续往下执行同步代码块&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行同步代码&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;偏向锁的撤销：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;偏向锁不会主动释放(撤销)，只有遇到其他线程竞争时才会执行撤销，由于撤销需要知道当前持有该偏向锁的线程栈状态，因此要等到safepoint时执行，此时持有该偏向锁的线程（T）有‘2’，‘3’两种情况；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;撤销----T线程已经退出同步代码块，或者已经不再存活，则直接撤销偏向锁，变成无锁状态----该状态达到阈值20则执行批量重偏向&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;升级----T线程还在同步代码块中，则将T线程的偏向锁&lt;strong&gt;升级为轻量级锁&lt;/strong&gt;，当前线程执行轻量级锁状态下的锁获取步骤----该状态达到阈值40则执行批量撤销&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;轻量级锁：&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;轻量级锁的获取：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;进行加锁操作时，jvm会判断是否已经时重量级锁，如果不是，则会在当前线程栈帧中划出一块空间，作为该锁的锁记录，并且将锁对象MarkWord复制到该锁记录中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;复制成功之后，jvm使用CAS操作将对象头MarkWord更新为指向锁记录的指针，并将锁记录里的owner指针指向对象头的MarkWord。如果成功，则执行‘3’，否则执行‘4’&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更新成功，则当前线程持有该对象锁，并且对象MarkWord锁标志设置为‘00’，即表示此对象处于轻量级锁状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更新失败，jvm先检查对象MarkWord是否指向当前线程栈帧中的锁记录，如果是则执行‘5’，否则执行‘4’&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表示锁重入；然后当前线程栈帧中增加一个锁记录第一部分（Displaced Mark Word）为null，并指向Mark Word的锁对象，起到一个重入计数器的作用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表示该锁对象已经被其他线程抢占，则进行&lt;strong&gt;自旋等待&lt;/strong&gt;（默认10次），等待次数达到阈值仍未获取到锁，则&lt;strong&gt;升级为重量级锁&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大体上省简的升级过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSUdHGNFiaN1E2Zr5MxUCOLXzsmdazwmo4icmdbDt1Trq3jnKPMuJ7jia9g/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;锁升级简略过程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整的升级过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSkjvnRAc4TnSIA1U2icO3p0LuvwqOjhxmPUuNkUXf1joULVyycxHeu8A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;synchronized 锁升级过程-来源参考[14]&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;28.说说synchronized和ReentrantLock的区别？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以从锁的实现、功能特点、性能等几个维度去回答这个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;锁的实现：&lt;/strong&gt; synchronized是Java语言的关键字，基于JVM实现。而ReentrantLock是基于JDK的API层面实现的（一般是lock()和unlock()方法配合try/finally 语句块来完成。）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;性能：&lt;/strong&gt; 在JDK1.6锁优化以前，synchronized的性能比ReenTrantLock差很多。但是JDK6开始，增加了适应性自旋、锁消除等，两者性能就差不多了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;功能特点：&lt;/strong&gt; ReentrantLock 比 synchronized 增加了一些高级功能，如等待可中断、可实现公平锁、可实现选择性通知。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;synchronized与wait()和notify()/notifyAll()方法结合实现等待/通知机制，ReentrantLock类借助Condition接口与newCondition()方法实现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ReentrantLock需要手工声明来加锁和释放锁，一般跟finally配合释放锁。而synchronized不用手动释放锁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面的表格列出出了两种锁之间的区别：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSYVosAF4icCeqKaSzMCOibQBHniaPwlicAVUiapic0M78KCQsoH8NkkGDibTicA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;synchronized和ReentrantLock的区别&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;29.AQS了解多少？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AbstractQueuedSynchronizer 抽象同步队列，简称 AQS ，它是Java并发包的根基，并发包中的锁就是基于AQS实现的。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;AQS是基于一个FIFO的双向队列，其内部定义了一个节点类Node，Node 节点内部的 SHARED 用来标记该线程是获取共享资源时被阻挂起后放入AQS 队列的， EXCLUSIVE 用来标记线程是 取独占资源时被挂起后放入AQS 队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AQS 使用一个 volatile 修饰的 int 类型的成员变量 state 来表示同步状态，修改同步状态成功即为获得锁，volatile 保证了变量在多线程之间的可见性，修改 State 值时通过 CAS 机制来保证修改的原子性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取state的方式分为两种，独占方式和共享方式，一个线程使用独占方式获取了资源，其它线程就会在获取失败后被阻塞。一个线程使用共享方式获取了资源，另外一个线程还可以通过CAS的方式进行获取。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果共享资源被占用，需要一定的阻塞等待唤醒机制来保证锁的分配，AQS 中会将竞争共享资源失败的线程添加到一个变体的 CLH 队列中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSHibmXuU9fNatvbDvmliawbRgKe1N7ThtQPKaJicIVTnY6jfgp0KzwktWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;先简单了解一下CLH：Craig、Landin and Hagersten 队列，是 &lt;strong&gt;单向链表实现的队列&lt;/strong&gt;。申请线程只在本地变量上自旋，&lt;strong&gt;它不断轮询前驱的状态&lt;/strong&gt;，如果发现 &lt;strong&gt;前驱节点释放了锁就结束自旋&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSb1rsYZx0s7UfGico3DU3xL4vVWuopBj5fE9jJPyMutQkFgOom8phllA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;CLH队列&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AQS 中的队列是 CLH 变体的虚拟双向队列，通过将每条请求共享资源的线程封装成一个节点来实现锁的分配：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTShod0nzG9dWkP9pgooxqstkWOSmtiahqPMdIp9FGicaujPkWFyuEHb7Fw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;AQS变种CLH队列&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AQS 中的 CLH 变体等待队列拥有以下特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;AQS 中队列是个双向链表，也是 FIFO 先进先出的特性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 Head、Tail 头尾两个节点来组成队列结构，通过 volatile 修饰保证可见性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Head 指向节点为已获得锁的节点，是一个虚拟节点，节点本身不持有具体线程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取不到同步状态，会将节点进行自旋获取锁，自旋一定次数失败后会将线程阻塞，相对于 CLH 队列性能较好&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ps:AQS源码里面有很多细节可问，建议有时间好好看看AQS源码。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;30.&lt;strong&gt;ReentrantLock&lt;/strong&gt;实现原理？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReentrantLock 是可重入的独占锁，只能有一个线程可以获取该锁，其它获取该锁的线程会被阻塞而被放入该锁的阻塞队列里面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看看ReentrantLock的加锁操作：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;// 创建非公平锁&lt;/span&gt;&lt;br/&gt;    ReentrantLock lock = &lt;span&gt;new&lt;/span&gt; ReentrantLock();&lt;br/&gt;    &lt;span&gt;// 获取锁操作&lt;/span&gt;&lt;br/&gt;    lock.lock();&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 执行代码逻辑&lt;/span&gt;&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception ex) {&lt;br/&gt;        &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 解锁操作&lt;/span&gt;&lt;br/&gt;        lock.unlock();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;new ReentrantLock()&lt;/code&gt;构造函数默认创建的是非公平锁 NonfairSync。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;公平锁 FairSync&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU 唤醒阻塞线程的开销比非公平锁大&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;非公平锁 NonfairSync&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU 不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认创建的对象lock()的时候：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果锁当前没有被其它线程占用，并且当前线程之前没有获取过该锁，则当前线程会获取到该锁，然后设置当前锁的拥有者为当前线程，并设置 AQS 的状态值为1 ，然后直接返回。如果当前线程之前己经获取过该锁，则这次只是简单地把 AQS 的状态值加1后返回。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果该锁己经被其他线程持有，非公平锁会尝试去获取锁，获取失败的话，则调用该方法线程会被放入 AQS 队列阻塞挂起。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSxW4UK7CjYTOdRgwfib67w89iay9r7m4vhSzZQ24LXNFaKqtFyq8ibHu9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;ReentrantLock 非公平锁加锁流程简图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;31.ReentrantLock怎么实现公平锁的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;new ReentrantLock()&lt;/code&gt;构造函数默认创建的是非公平锁 NonfairSync&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    sync = &lt;span&gt;new&lt;/span&gt; NonfairSync();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时也可以在创建锁构造函数中传入具体参数创建公平锁 FairSync&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ReentrantLock lock = &lt;span&gt;new&lt;/span&gt; ReentrantLock(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;--- ReentrantLock&lt;br/&gt;&lt;span&gt;// true 代表公平锁，false 代表非公平锁&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt;&lt;span&gt;(&lt;span&gt;boolean&lt;/span&gt; fair)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    sync = fair ? &lt;span&gt;new&lt;/span&gt; FairSync() : &lt;span&gt;new&lt;/span&gt; NonfairSync();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FairSync、NonfairSync 代表公平锁和非公平锁，两者都是 ReentrantLock 静态内部类，只不过实现不同锁语义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;非公平锁和公平锁的两处不同：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSCS1z5onhYJcWagbrTJI5rcWrKribFQ5S3j7lMibJfwJY9z2vL2BDx6zg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;公平锁tryAcquire&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;32.CAS呢？CAS了解多少？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAS叫做CompareAndSwap，⽐较并交换，主要是通过处理器的指令来保证操作的原⼦性的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAS 指令包含 3 个参数：共享变量的内存地址 A、预期的值 B 和共享变量的新值 C。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有当内存中地址 A 处的值等于 B 时，才能将内存中地址 A 处的值更新为新值 C。作为一条 CPU 指令，CAS 指令本身是能够保证原子性的 。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;33.CAS 有什么问题？如何解决？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAS的经典三大问题：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSCmW9YFZQxA82BH87mhNickMyP1GtHDUTQoTO5ajoPfvKeNgBfI9U0iaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;CAS三大问题&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;ABA 问题&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发环境下，假设初始条件是A，去修改数据时，发现是A就会执行修改。但是看到的虽然是A，中间可能发生了A变B，B又变回A的情况。此时A已经非彼A，数据即使成功修改，也可能有问题。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;怎么解决ABA问题？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次修改变量，都在这个变量的版本号上加1，这样，刚刚A-&amp;gt;B-&amp;gt;A，虽然A的值没变，但是它的版本号已经变了，再判断版本号就会发现此时的A已经被改过了。参考乐观锁的版本号，这种做法可以给数据带上了一种实效性的检验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java提供了AtomicStampReference类，它的compareAndSet方法首先检查当前的对象引用值是否等于预期引用，并且当前印戳（Stamp）标志是否等于预期标志，如果全部相等，则以原子方式将引用值和印戳标志的值更新为给定的更新值。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;循环性能开销&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自旋CAS，如果一直循环执行，一直不成功，会给CPU带来非常大的执行开销。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;怎么解决循环性能开销问题？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java中，很多使用自旋CAS的地方，会有一个自旋次数的限制，超过一定次数，就停止自旋。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;只能保证一个变量的原子操作&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAS 保证的是对一个变量执行操作的原子性，如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;怎么解决只能保证一个变量的原子操作问题？&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可以考虑改用锁来保证操作的原子性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以考虑合并多个变量，将多个变量封装成一个对象，通过AtomicReference来保证原子性。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;34.Java有哪些保证原子性的方法？如何保证多线程下i++ 结果正确？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSzoU0PfIVzIW6XOxevaHvDKTibuysDUZaDOibBElaM77pMYIM7kAKd43A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Java保证原子性方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用循环原子类，例如AtomicInteger，实现i++原子操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用juc包下的锁，如ReentrantLock ，对i++操作加锁lock.lock()来实现原子性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用synchronized，对i++操作加锁&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;35.原子操作类了解多少？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当程序更新一个变量时，如果多线程同时更新这个变量，可能得到期望之外的值，比如变量i=1，A线程更新i+1，B线程也更新i+1，经过两个线程操作之后可能i不等于3，而是等于2。因为A和B线程在更新变量i的时候拿到的i都是1，这就是线程不安全的更新操作，一般我们会使用synchronized来解决这个问题，synchronized会保证多线程不会同时更新变量i。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实除此之外，还有更轻量级的选择，Java从JDK 1.5开始提供了java.util.concurrent.atomic包，这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为变量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSQDecO0hWicHCSFaxnibCBlyH2bxBGvEeZr4cmYIiavD4D7o9YSlSfk67w/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;原子操作类&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Atomic包里的类基本都是使用Unsafe实现的包装类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用原子的方式更新基本类型，Atomic包提供了以下3个类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicBoolean：原子更新布尔类型。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicInteger：原子更新整型。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicLong：原子更新长整型。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过原子的方式更新数组里的某个元素，Atomic包提供了以下4个类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicIntegerArray：原子更新整型数组里的元素。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicLongArray：原子更新长整型数组里的元素。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicReferenceArray：原子更新引用类型数组里的元素。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicIntegerArray类主要是提供原子的方式更新数组里的整型&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicReference：原子更新引用类型。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicReferenceFieldUpdater：原子更新引用类型里的字段。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference（V initialRef，boolean initialMark）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下3个类进行原子字段更新：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AtomicLongFieldUpdater：原子更新长整型字段的更新器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的 ABA问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;36.AtomicInteger 的原理？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一句话概括：&lt;strong&gt;使用CAS实现&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以AtomicInteger的添加方法为例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getAndIncrement&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; unsafe.getAndAddInt(&lt;span&gt;this&lt;/span&gt;, valueOffset, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过&lt;code&gt;Unsafe&lt;/code&gt;类的实例来进行添加操作，来看看具体的CAS操作：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getAndAddInt&lt;/span&gt;&lt;span&gt;(Object var1, &lt;span&gt;long&lt;/span&gt; var2, &lt;span&gt;int&lt;/span&gt; var4)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; var5;&lt;br/&gt;        &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;            var5 = &lt;span&gt;this&lt;/span&gt;.getIntVolatile(var1, var2);&lt;br/&gt;        } &lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;this&lt;/span&gt;.compareAndSwapInt(var1, var2, var5, var5 + var4));&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; var5;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;compareAndSwapInt 是一个native方法，基于CAS来操作int类型变量。其它的原子操作类基本都是大同小异。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;37.线程死锁了解吗？该如何避免？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSJZBWAeMMS4QmWpfWhuUf9hmricZSX2fE9hRjatRjNVCoMXxbwDN9GxA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;死锁示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么为什么会产生死锁呢？死锁的产生必须具备以下四个条件：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSLvMeyd8aibH7WpmtvvqgVnricnFQEEA0waM0CytWbM53yGcr4jOlHxFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;死锁产生必备四条件&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;互斥条件：指线程对己经获取到的资源进行它性使用，即该资源同时只由一个线程占用。如果此时还有其它线程请求获取获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;请求并持有条件：指一个 线程己经持有了至少一个资源，但又提出了新的资源请求，而新资源己被其它线程占有，所以当前线程会被阻塞，但阻塞 的同时并不释放自己已经获取的资源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不可剥夺条件：指线程获取到的资源在自己使用完之前不能被其它线程抢占，只有在自己使用完毕后才由自己释放该资源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;环路等待条件：指在发生死锁时，必然存在一个线程——资源的环形链，即线程集合 {T0，T1，T2,…… ，Tn} 中 T0 正在等待一 T1 占用的资源，Tl1正在等待 T2用的资源，…… Tn 在等待己被 T0占用的资源。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该如何避免死锁呢？答案是&lt;strong&gt;至少破坏死锁发生的一个条件&lt;/strong&gt;。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;其中，互斥这个条件我们没有办法破坏，因为用锁为的就是互斥。不过其他三个条件都是有办法破坏掉的，到底如何做呢？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;对于“请求并持有”这个条件，可以一次性请求所有的资源。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;对于“不可剥夺”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;对于“环路等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后就不存在环路了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;38.那死锁问题怎么排查呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用jdk自带的命令行工具排查：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用jps查找运行的Java进程：jps -l&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用jstack查看线程堆栈信息：jstack -l  进程id&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本就可以看到死锁的信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还可以利用图形化工具，比如JConsole。出现线程死锁以后，点击JConsole线程面板的&lt;code&gt;检测到死锁&lt;/code&gt;按钮，将会看到线程的死锁信息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSZaDcxh51tkQdYyOk2Mj56hV8d1c3L1HAdzZ0MREJXicxXicrWj0rlGdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;线程死锁检测&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;并发工具类&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;39.CountDownLatch（倒计数器）了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CountDownLatch，倒计数器，有两个常见的应用场景[18]：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;场景1：协调子线程结束动作：等待所有子线程运行结束&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CountDownLatch允许一个或多个线程等待其他线程完成操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，我们很多人喜欢玩的王者荣耀，开黑的时候，得等所有人都上线之后，才能开打。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSDeuziaia9bUbDlgkVXZuy3Tn8mhsbfV0cHY6Y44VGXblHuzxDpibwibLng/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;figcaption&gt;王者荣耀等待玩家确认-来源参考[18]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CountDownLatch模仿这个场景(参考[18])：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建大乔、兰陵王、安其拉、哪吒和铠等五个玩家，主线程必须在他们都完成确认后，才可以继续运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这段代码中，&lt;code&gt;new CountDownLatch(5)&lt;/code&gt;用户创建初始的latch数量，各玩家通过&lt;code&gt;countDownLatch.countDown()&lt;/code&gt;完成状态确认，主线程通过&lt;code&gt;countDownLatch.await()&lt;/code&gt;等待。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        CountDownLatch countDownLatch = &lt;span&gt;new&lt;/span&gt; CountDownLatch(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        Thread 大乔 = &lt;span&gt;new&lt;/span&gt; Thread(countDownLatch::countDown);&lt;br/&gt;        Thread 兰陵王 = &lt;span&gt;new&lt;/span&gt; Thread(countDownLatch::countDown);&lt;br/&gt;        Thread 安其拉 = &lt;span&gt;new&lt;/span&gt; Thread(countDownLatch::countDown);&lt;br/&gt;        Thread 哪吒 = &lt;span&gt;new&lt;/span&gt; Thread(countDownLatch::countDown);&lt;br/&gt;        Thread 铠 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;// 稍等，上个卫生间，马上到...&lt;/span&gt;&lt;br/&gt;                Thread.sleep(&lt;span&gt;1500&lt;/span&gt;);&lt;br/&gt;                countDownLatch.countDown();&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException ignored) {}&lt;br/&gt;        });&lt;br/&gt;&lt;br/&gt;        大乔.start();&lt;br/&gt;        兰陵王.start();&lt;br/&gt;        安其拉.start();&lt;br/&gt;        哪吒.start();&lt;br/&gt;        铠.start();&lt;br/&gt;        countDownLatch.await();&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;所有玩家已经就位！&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;场景2. 协调子线程开始动作：统一各线程动作开始的时机&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;王者游戏中也有类似的场景，游戏开始时，各玩家的初始状态必须一致。不能有的玩家都出完装了，有的才降生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以大家得一块出生，在&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS5ibDQ2dibUe6icuZLpE6FxA33gtJ4f86g1BgCSOiaDHl5hwEO29gXOJhBA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;figcaption&gt;王者荣耀-来源参考[18]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个场景中，仍然用五个线程代表大乔、兰陵王、安其拉、哪吒和铠等五个玩家。需要注意的是，各玩家虽然都调用了&lt;code&gt;start()&lt;/code&gt;线程，但是它们在运行时都在等待&lt;code&gt;countDownLatch&lt;/code&gt;的信号，在信号未收到前，它们不会往下执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        CountDownLatch countDownLatch = &lt;span&gt;new&lt;/span&gt; CountDownLatch(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        Thread 大乔 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; waitToFight(countDownLatch));&lt;br/&gt;        Thread 兰陵王 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; waitToFight(countDownLatch));&lt;br/&gt;        Thread 安其拉 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; waitToFight(countDownLatch));&lt;br/&gt;        Thread 哪吒 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; waitToFight(countDownLatch));&lt;br/&gt;        Thread 铠 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; waitToFight(countDownLatch));&lt;br/&gt;&lt;br/&gt;        大乔.start();&lt;br/&gt;        兰陵王.start();&lt;br/&gt;        安其拉.start();&lt;br/&gt;        哪吒.start();&lt;br/&gt;        铠.start();&lt;br/&gt;        Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;        countDownLatch.countDown();&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;敌方还有5秒达到战场，全军出击！&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;waitToFight&lt;/span&gt;&lt;span&gt;(CountDownLatch countDownLatch)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            countDownLatch.await(); &lt;span&gt;// 在此等待信号再继续&lt;/span&gt;&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;收到，发起进攻！&quot;&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CountDownLatch的&lt;strong&gt;核心方法&lt;/strong&gt;也不多：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;await()&lt;/code&gt;：等待latch降为0；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;boolean await(long timeout, TimeUnit unit)&lt;/code&gt;：等待latch降为0，但是可以设置超时时间。比如有玩家超时未确认，那就重新匹配，总不能为了某个玩家等到天荒地老。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;countDown()&lt;/code&gt;：latch数量减1；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;getCount()&lt;/code&gt;：获取当前的latch数量。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;40.CyclicBarrier（同步屏障）了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一 组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它和CountDownLatch类似，都可以协调多线程的结束动作，在它们结束后都可以执行特定动作，但是为什么要有CyclicBarrier，自然是它有和CountDownLatch不同的地方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你听没听过一个新人UP主小约翰可汗，小约翰生平有两大恨——“想结衣结衣不依,迷爱理爱理不理。”我们来还原一下事情的经过：小约翰在亲政后认识了新垣结衣，于是决定第一次选妃，向结衣表白，等待回应。然而新垣结衣回应嫁给了星野源，小约翰伤心欲绝，发誓生平不娶，突然发现了铃木爱理，于是小约翰决定第二次选妃，求爱理搭理，等待回应。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSwJOkr0nM9chATLIqHc3Kx2uzViaulDeWk3mibsmm18gOx4SXSLJzsu0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;想结衣结衣不依,迷爱理爱理不理。&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们拿代码模拟这一场景，发现CountDownLatch无能为力了，因为CountDownLatch的使用是一次性的，无法重复利用，而这里等待了两次。此时，我们用CyclicBarrier就可以实现，因为它可以重复利用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSHRdvLYeibZpliby0H0hu1h1PCRRlCyS7oECAVv2YDPDH77RGiaRWMESJw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;小约翰可汗选妃模拟代码&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSvgPTibpiaM3TBarbGDCRo20hXlQEulasJQj6CHHWP8yP6I1BibVylAqQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;运行结果&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CyclicBarrier最最核心的方法，仍然是await()：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果当前线程不是第一个到达屏障的话，它将会进入等待，直到其他线程都到达，除非发生&lt;strong&gt;被中断&lt;/strong&gt;、&lt;strong&gt;屏障被拆除&lt;/strong&gt;、&lt;strong&gt;屏障被重设&lt;/strong&gt;等情况；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的例子抽象一下，本质上它的流程就是这样就是这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSTv4BWvMFc29kVvm9L8UcuZ2AL8EiauGxSV4TJbht7b3lhkLqibC8S6WA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;CyclicBarrier工作流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;41.CyclicBarrier和CountDownLatch有什么区别？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两者最核心的区别[18]：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;CountDownLatch是一次性的，而CyclicBarrier则可以多次设置屏障，实现重复利用；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CountDownLatch中的各个子线程不可以等待其他线程，只能完成自己的任务；而CyclicBarrier中的各个线程可以等待其他线程&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它们区别用一个表格整理：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;CyclicBarrier&lt;/th&gt;&lt;th&gt;CountDownLatch&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;CyclicBarrier是可重用的，其中的线程会等待所有的线程完成任务。届时，屏障将被拆除，并可以选择性地做一些特定的动作。&lt;/td&gt;&lt;td&gt;CountDownLatch是一次性的，不同的线程在同一个计数器上工作，直到计数器为0.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CyclicBarrier面向的是线程数&lt;/td&gt;&lt;td&gt;CountDownLatch面向的是任务数&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;在使用CyclicBarrier时，你必须在构造中指定参与协作的线程数，这些线程必须调用await()方法&lt;/td&gt;&lt;td&gt;使用CountDownLatch时，则必须要指定任务数，至于这些任务由哪些线程完成无关紧要&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CyclicBarrier可以在所有的线程释放后重新使用&lt;/td&gt;&lt;td&gt;CountDownLatch在计数器为0时不能再使用&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;在CyclicBarrier中，如果某个线程遇到了中断、超时等问题时，则处于await的线程都会出现问题&lt;/td&gt;&lt;td&gt;在CountDownLatch中，如果某个线程出现问题，其他线程不受影响&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;42.Semaphore（信号量）了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;听起来似乎很抽象，现在汽车多了，开车出门在外的一个老大难问题就是停车 。停车场的车位是有限的，只能允许若干车辆停泊，如果停车场还有空位，那么显示牌显示的就是绿灯和剩余的车位，车辆就可以驶入；如果停车场没位了，那么显示牌显示的就是绿灯和数字0，车辆就得等待。如果满了的停车场有车离开，那么显示牌就又变绿，显示空车位数量，等待的车辆就能进停车场。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSwY9aohegYwwHF0CEfDEPSLu1W083XZxJ3SibjK9FMLmXicEib480apbYw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;figcaption&gt;停车场空闲车位提示-图片来源网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们把这个例子类比一下，车辆就是线程，进入停车场就是线程在执行，离开停车场就是线程执行完毕，看见红灯就表示线程被阻塞，不能执行，Semaphore的本质就是&lt;strong&gt;协调多个线程对共享资源的获取&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSdbG4FgP1SvkcndmuCC0qznN86KtYm62Gia2JLBI0ncbadspaAFfBCOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;figcaption&gt;Semaphore许可获取-来源参考[18]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看一个Semaphore的用途：它可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SemaphoreTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; THREAD_COUNT = &lt;span&gt;30&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Semaphore s = &lt;span&gt;new&lt;/span&gt; Semaphore(&lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; THREAD_COUNT; i++) {&lt;br/&gt;            threadPool.execute(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;                &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        s.acquire();&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;save data&quot;&lt;/span&gt;);&lt;br/&gt;                        s.release();&lt;br/&gt;                    } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            });&lt;br/&gt;        }&lt;br/&gt;        threadPool.shutdown();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在代码中，虽然有30个线程在执行，但是只允许10个并发执行。Semaphore的构造方法&lt;code&gt;Semaphore（int permits&lt;/code&gt;）接受一个整型的数字，表示可用的许可证数量。&lt;code&gt;Semaphore（10）&lt;/code&gt;表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用 Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;43.Exchanger 了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSjKoOWuWQEY5yjvDU7GY5lUTia7rd8xUD90pULvzAS2KarJeBCRs2FRQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;figcaption&gt;英雄交换猎物-来源参考[18]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个线程通过 exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。Exchanger也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ExchangerTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Exchanger&amp;lt;String&amp;gt; exgr = &lt;span&gt;new&lt;/span&gt; Exchanger&amp;lt;String&amp;gt;();&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService threadPool = Executors.newFixedThreadPool(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        threadPool.execute(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    String A = &lt;span&gt;&quot;银行流水A&quot;&lt;/span&gt;; &lt;span&gt;// A录入银行流水数据 &lt;/span&gt;&lt;br/&gt;                    exgr.exchange(A);&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        threadPool.execute(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    String B = &lt;span&gt;&quot;银行流水B&quot;&lt;/span&gt;; &lt;span&gt;// B录入银行流水数据 &lt;/span&gt;&lt;br/&gt;                    String A = exgr.exchange(&lt;span&gt;&quot;B&quot;&lt;/span&gt;);&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;A和B数据是否一致：&quot;&lt;/span&gt; + A.equals(B) + &lt;span&gt;&quot;，A录入的是：&quot;&lt;/span&gt;&lt;br/&gt;                            + A + &lt;span&gt;&quot;，B录入是：&quot;&lt;/span&gt; + B);&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        threadPool.shutdown();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用&lt;code&gt;exchange(V x, long timeOut, TimeUnit unit)&lt;/code&gt;设置最大等待时长。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;线程池&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;44.什么是线程池？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程池：&lt;/strong&gt; 简单理解，它就是一个管理线程的池子。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSf2k5phoelUUlI70EgtQd1y511gbMT2dHibsoT2AWrxicQvEj4JK4f7hA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;管理线程的池子&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;它帮我们管理线程，避免增加创建线程和销毁线程的资源损耗&lt;/strong&gt;。因为线程其实也是一个对象，创建一个对象，需要经过类加载过程，销毁一个对象，需要走GC垃圾回收流程，都是需要资源开销的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;提高响应速度。&lt;/strong&gt; 如果任务到达了，相对于从线程池拿线程，重新去创建一条线程执行，速度肯定慢很多。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;重复利用。&lt;/strong&gt; 线程用完，再放回池子，可以达到重复利用的效果，节省资源。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;45.能说说工作中线程池的应用吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前我们有一个和第三方对接的需求，需要向第三方推送数据，引入了多线程来提升数据推送的效率，其中用到了线程池来管理线程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSus2LEXwloZbsTicqwu3iaSnkicgOb9GCM00Du50GkZ6IIicG1C8fMppOPA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;业务示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要代码如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.9267578125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSfo2EaKMOdxA6kFLib00aJjkXhVow9WibVZlk5rDtFXXb8DPpguXyVKeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2048&quot;/&gt;&lt;figcaption&gt;主要代码&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整可运行代码地址：https://gitee.com/fighter3/thread-demo.git&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池的参数如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;corePoolSize：线程核心参数选择了CPU数×2&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;maximumPoolSize：最大线程数选择了和核心线程数相同&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;keepAliveTime：非核心闲置线程存活时间直接置为0&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;unit：非核心线程保持存活的时间选择了 TimeUnit.SECONDS 秒&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;workQueue：线程池等待队列，使用 LinkedBlockingQueue阻塞队列&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时还用了synchronized 来加锁，保证数据不会被重复推送：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;synchronized&lt;/span&gt; (PushProcessServiceImpl&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ps:这个例子只是简单地进行了数据推送，实际上还可以结合其他的业务，像什么数据清洗啊、数据统计啊，都可以套用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;46.能简单说一下线程池的工作流程吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用一个通俗的比喻：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一个营业厅，总共有六个窗口，现在开放了三个窗口，现在有三个窗口坐着三个营业员小姐姐在营业。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老三去办业务，可能会遇到什么情况呢？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;老三发现有空间的在营业的窗口，直接去找小姐姐办理业务。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSjpvyfZib7ew5ZVdU4sdQZkj8rxzXxO5mCMw17VvoCd3bibYzpYq29SCg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;直接办理&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;老三发现没有空闲的窗口，就在排队区排队等。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSic6ichibZ4noB72VhkLQNNaUZbfuTa2fwcDEZVahvk1dcC7pVMibKnI9CA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;排队等待&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;老三发现没有空闲的窗口，等待区也满了，蚌埠住了，经理一看，就让休息的小姐姐赶紧回来上班，等待区号靠前的赶紧去新窗口办，老三去排队区排队。小姐姐比较辛苦，假如一段时间发现他们可以不用接着营业，经理就让她们接着休息。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSPzDkc95d4iaibp28VMlfdEibFLCngcsMmgEWiaXZ1n4lYZ3ngPDnqHjicLg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;排队区满&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;老三一看，六个窗口都满了，等待区也没位置了。老三急了，要闹，经理赶紧出来了，经理该怎么办呢？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS1ehibUjaq5qHicxgMjd9CZbd7Q4dZuGKNUwl5gnQgC3mbqSVNMQ9z2Rw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;等待区，排队区都满&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;我们银行系统已经瘫痪&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;谁叫你来办的你找谁去&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;看你比较急，去队里加个塞&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;今天没办法，不行你看改一天&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的这个流程几乎就跟 JDK 线程池的大致流程类似，&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;营业中的 3个窗口对应核心线程池数：corePoolSize&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;总的营业窗口数6对应：maximumPoolSize&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;打开的临时窗口在多少时间内无人办理则关闭对应：unit&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;排队区就是等待队列：workQueue&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;无法办理的时候银行给出的解决方法对应：RejectedExecutionHandler&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;threadFactory 该参数在 JDK 中是 线程工厂，用来创建线程对象，一般不会动。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们线程池的工作流程也比较好理解了：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当调用 execute() 方法添加一个任务时，线程池会做如下判断：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会根据拒绝策略来对应处理。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSibgvbJBh08S7ZeC4ULW8dRucYedq5XCGW0dicJMw5m12561icGetUb2xQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;线程池执行流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当一个线程完成任务时，它会从队列中取下一个任务来执行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;47.线程池主要参数有哪些？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSpl3zNLric81KibgVWibibDkrjusELR26w8EmFsUm6tSWgAb8KicmXulBMPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;线程池参数&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池有七大参数，需要重点关注&lt;code&gt;corePoolSize&lt;/code&gt;、&lt;code&gt;maximumPoolSize&lt;/code&gt;、&lt;code&gt;workQueue&lt;/code&gt;、&lt;code&gt;handler&lt;/code&gt;这四个。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;corePoolSize&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此值是用来初始化线程池中核心线程数，当线程池中线程池数&amp;lt; &lt;code&gt;corePoolSize&lt;/code&gt;时，系统默认是添加一个任务才创建一个线程池。当线程数 = corePoolSize时，新任务会追加到workQueue中。&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;maximumPoolSize&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;maximumPoolSize&lt;/code&gt;表示允许的最大线程数 = (非核心线程数+核心线程数)，当&lt;code&gt;BlockingQueue&lt;/code&gt;也满了，但线程池中总线程数 &amp;lt; &lt;code&gt;maximumPoolSize&lt;/code&gt;时候就会再次创建新的线程。&lt;/p&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;keepAliveTime&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非核心线程 =(maximumPoolSize - corePoolSize ) ,非核心线程闲置下来不干活最多存活时间。&lt;/p&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;unit&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池中非核心线程保持存活的时间的单位&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;TimeUnit.DAYS;天&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TimeUnit.HOURS;小时&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TimeUnit.MINUTES;分钟&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TimeUnit.SECONDS;秒&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TimeUnit.MILLISECONDS;  毫秒&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TimeUnit.MICROSECONDS;  微秒&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TimeUnit.NANOSECONDS;  纳秒&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol start=&quot;5&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;workQueue&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池等待队列，维护着等待执行的&lt;code&gt;Runnable&lt;/code&gt;对象。当运行当线程数= corePoolSize时，新的任务会被添加到&lt;code&gt;workQueue&lt;/code&gt;中，如果&lt;code&gt;workQueue&lt;/code&gt;也满了则尝试用非核心线程执行任务，等待队列应该尽量用有界的。&lt;/p&gt;&lt;ol start=&quot;6&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;threadFactory&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等。&lt;/p&gt;&lt;ol start=&quot;7&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;handler&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;corePoolSize&lt;/code&gt;、&lt;code&gt;workQueue&lt;/code&gt;、&lt;code&gt;maximumPoolSize&lt;/code&gt;都不可用的时候执行的饱和策略。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;48.线程池的拒绝策略有哪些？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类比前面的例子，无法办理业务时的处理方式，帮助记忆：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSEialhu9UoRSTBT2grUaJdmGflo3ORHhHEE2pQZptibgqDjAg8nJxrq2g/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;四种策略&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;AbortPolicy ：直接抛出异常，默认使用此策略&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CallerRunsPolicy：用调用者所在的线程来执行任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DiscardOldestPolicy：丢弃阻塞队列里最老的任务，也就是队列里靠前的任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DiscardPolicy ：当前任务直接丢弃&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想实现自己的拒绝策略，实现RejectedExecutionHandler接口即可。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;49.线程池有哪几种工作队列？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的阻塞队列主要有以下几种：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSPNoYnf7B8TtrxRXCOfgkLXxmKEuqqfuJZKVPArLOJCIrLgLUxmuIWA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;线程池常用阻塞队列&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ArrayBlockingQueue：ArrayBlockingQueue（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue：LinkedBlockingQueue（可设置容量队列）是基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；newFixedThreadPool线程池使用了这个队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DelayQueue：DelayQueue（延迟队列）是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PriorityBlockingQueue：PriorityBlockingQueue（优先级队列）是具有优先级的无界阻塞队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SynchronousQueue：SynchronousQueue（同步队列）是一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，newCachedThreadPool线程池使用了这个队列。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;50.线程池提交execute和submit有什么区别？&lt;/span&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;execute 用于提交不需要返回值的任务&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;threadsPool.execute(&lt;span&gt;new&lt;/span&gt; Runnable() { &lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;br/&gt;        &lt;span&gt;// TODO Auto-generated method stub } &lt;/span&gt;&lt;br/&gt;    });&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个 future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Future&amp;lt;Object&amp;gt; future = executor.submit(harReturnValuetask); &lt;br/&gt;&lt;span&gt;try&lt;/span&gt; { Object s = future.get(); } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) { &lt;br/&gt;    &lt;span&gt;// 处理中断异常 &lt;/span&gt;&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (ExecutionException e) { &lt;br/&gt;    &lt;span&gt;// 处理无法执行任务异常 &lt;/span&gt;&lt;br/&gt;} &lt;span&gt;finally&lt;/span&gt; { &lt;br/&gt;    &lt;span&gt;// 关闭线程池 executor.shutdown();&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;51.线程池怎么关闭知道吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过调用线程池的&lt;code&gt;shutdown&lt;/code&gt;或&lt;code&gt;shutdownNow&lt;/code&gt;方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;shutdown() 将线程池状态置为shutdown,并不会立即停止&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;停止接收外部submit的任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内部正在跑的任务和队列里等待的任务，会执行完&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;等到第二步完成后，才真正停止&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;shutdownNow() 将线程池状态置为stop。一般会立即停止，事实上不一定&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;和shutdown()一样，先停止接收外部提交的任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;忽略队列里等待的任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;尝试将正在跑的任务interrupt中断&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回未执行的任务列表&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;shutdown 和shutdownnow简单来说区别如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;shutdownNow()能立即停止线程池，正在跑的和正在等待的任务都停下了。这样做立即生效，但是风险也比较大。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;shutdown()只是关闭了提交通道，用submit()是无效的；而内部的任务该怎么跑还是怎么跑，跑完再彻底停止线程池。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;52.线程池的线程数应该怎么配置？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程在Java中属于稀缺资源，线程池不是越大越好也不是越小越好。任务分为计算密集型、IO密集型、混合型。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;计算密集型：大部分都在用CPU跟内存，加密，逻辑操作业务处理等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;IO密集型：数据库链接，网络通讯传输等。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS911XXzD3vbwfoTaWB8BduS0zvR0ky7JFAFlia3eHgwpTq7dTj2alMcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;常见线程池参数配置方案-来源美团技术博客&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般的经验，不同类型线程池的参数配置：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;计算密集型一般推荐线程池不要过大，一般是CPU数 + 1，+1是因为可能存在&lt;strong&gt;页缺失&lt;/strong&gt;(就是可能存在有些数据在硬盘中需要多来一个线程将数据读入内存)。如果线程池数太大，可能会频繁的 进行线程上下文切换跟任务调度。获得当前CPU核心数代码如下：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Runtime.getRuntime().availableProcessors();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;IO密集型：线程数适当大一点，机器的Cpu核心数*2。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;混合型：可以考虑根绝情况将它拆分成CPU密集型和IO密集型任务，如果执行时间相差不大，拆分可以提升吞吐量，反之没有必要。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，实际应用中没有固定的公式，需要结合测试和监控来进行调整。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;53.有哪几种常见的线程池？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试常问，主要有四种，都是通过工具类Excutors创建出来的，需要注意，阿里巴巴《Java开发手册》里禁止使用这种方式来创建线程池。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSndSYswbkly8nx1qibaD0AtnyjnxUypp15Cyf5ibJssbkYB8TXHPFf8NQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;四大线程池&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;newFixedThreadPool  (固定数目线程的线程池)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;newCachedThreadPool (可缓存线程的线程池)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;newSingleThreadExecutor (单线程的线程池)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;newScheduledThreadPool (定时及周期执行的线程池)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;54.能说一下四种常见线程池的原理吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前三种线程池的构造直接调用ThreadPoolExecutor的构造方法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;newSingleThreadExecutor&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService &lt;span&gt;newSingleThreadExecutor&lt;/span&gt;&lt;span&gt;(ThreadFactory threadFactory)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; FinalizableDelegatedExecutorService&lt;br/&gt;            (&lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;                                    &lt;span&gt;0L&lt;/span&gt;, TimeUnit.MILLISECONDS,&lt;br/&gt;                                    &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(),&lt;br/&gt;                                    threadFactory));&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程池特点&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;核心线程数为1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最大线程数也为1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;阻塞队列是无界队列LinkedBlockingQueue，可能会导致OOM&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;keepAliveTime为0&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSoPO2yic7w1Pupakc9GeQzCw0mkURCNHptnmRE3vfiaVQLTyIicnbAUIgA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;SingleThreadExecutor运行流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作流程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;提交任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程池是否有一条线程在，如果没有，新建线程执行任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果有，将任务加到阻塞队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当前的唯一线程，从队列取任务，执行完一个，再继续取，一个线程执行任务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;适用于串行执行任务的场景，一个任务一个任务地执行。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;newFixedThreadPool&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService &lt;span&gt;newFixedThreadPool&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; nThreads, ThreadFactory threadFactory)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(nThreads, nThreads,&lt;br/&gt;                                      &lt;span&gt;0L&lt;/span&gt;, TimeUnit.MILLISECONDS,&lt;br/&gt;                                      &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(),&lt;br/&gt;                                      threadFactory);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程池特点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;核心线程数和最大线程数大小一样&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有所谓的非空闲时间，即keepAliveTime为0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;阻塞队列为无界队列LinkedBlockingQueue，可能会导致OOM&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSQQBIZZBy7dwTtTUpmbraicYVEJvbaDsiamZDMuFKY2kTPWcyYOYeBS1g/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;FixedThreadPool&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作流程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;提交任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果线程数少于核心线程，创建核心线程执行任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果线程数等于核心线程，把任务添加到LinkedBlockingQueue阻塞队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果线程执行完任务，去阻塞队列取任务，继续执行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;使用场景&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FixedThreadPool 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;newCachedThreadPool&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService &lt;span&gt;newCachedThreadPool&lt;/span&gt;&lt;span&gt;(ThreadFactory threadFactory)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;0&lt;/span&gt;, Integer.MAX_VALUE,&lt;br/&gt;                                      &lt;span&gt;60L&lt;/span&gt;, TimeUnit.SECONDS,&lt;br/&gt;                                      &lt;span&gt;new&lt;/span&gt; SynchronousQueue&amp;lt;Runnable&amp;gt;(),&lt;br/&gt;                                      threadFactory);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程池特点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;核心线程数为0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最大线程数为Integer.MAX_VALUE，即无限大，可能会因为无限创建线程，导致OOM&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;阻塞队列是SynchronousQueue&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非核心线程空闲存活时间为60秒&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当提交任务的速度大于处理任务的速度时，每次提交一个任务，就必然会创建一个线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSVC6RoUUiabxbQibKjhtjC6UfvNiawscicuj8MYfmdQlct3enazyicQxzENQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;CachedThreadPool执行流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作流程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;提交任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;因为没有核心线程，所以任务直接加到SynchronousQueue队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;判断是否有空闲线程，如果有，就去取出任务执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果没有空闲线程，就新建一个线程执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行完任务的线程，还可以存活60秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于并发执行大量短期的小任务。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;newScheduledThreadPool&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ScheduledThreadPoolExecutor&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; corePoolSize)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(corePoolSize, Integer.MAX_VALUE, &lt;span&gt;0&lt;/span&gt;, NANOSECONDS,&lt;br/&gt;              &lt;span&gt;new&lt;/span&gt; DelayedWorkQueue());&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程池特点&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;最大线程数为Integer.MAX_VALUE，也有OOM的风险&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;阻塞队列是DelayedWorkQueue&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;keepAliveTime为0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;scheduleAtFixedRate() ：按某种速率周期执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;scheduleWithFixedDelay()：在某个延迟后执行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSpLIibSktN1W8Y63icicLw6WNSlVc3yeFyuibJq7Gkkj4MibxCJ1Qznvwe5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;ScheduledThreadPool执行流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;工作机制&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程从DelayQueue中获取已到期的ScheduledFutureTask（DelayQueue.take()）。到期任务是指ScheduledFutureTask的time大于等于当前时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程执行这个ScheduledFutureTask。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程修改ScheduledFutureTask的time变量为下次将要被执行的时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程把这个修改time之后的ScheduledFutureTask放回DelayQueue中（DelayQueue.add()）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSgGFneaLl3DOo26lX6mr6PBWGmx6XSFLK5ibzzxf3I2ZsBGuia68awLFg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;ScheduledThreadPoolExecutor执行流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;使用场景&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;周期性执行任务的场景，需要限制线程数量的场景&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;使用无界队列的线程池会导致什么问题吗？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如newFixedThreadPool使用了无界的阻塞队列LinkedBlockingQueue，如果线程获取一个任务后，任务的执行时间比较长，会导致队列的任务越积越多，导致机器内存使用不停飙升，最终导致OOM。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;55.线程池异常怎么处理知道吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用线程池处理任务的时候，任务代码可能抛出RuntimeException，抛出异常后，线程池可能捕获它，也可能创建一个新的线程来代替异常的线程，我们可能无法感知任务出现了异常，因此我们需要考虑线程池异常情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的异常处理方式：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSITic450VQC8zhvBae0x7bLCQU2BlmnEsMe1Ww18Kh4vf0zIVibP6Jr1g/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;线程池异常处理&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;56.能说一下线程池有几种状态吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池有这几个状态：RUNNING,SHUTDOWN,STOP,TIDYING,TERMINATED。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   &lt;span&gt;//线程池状态&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; RUNNING    = -&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; COUNT_BITS;&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SHUTDOWN   =  &lt;span&gt;0&lt;/span&gt; &amp;lt;&amp;lt; COUNT_BITS;&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; STOP       =  &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; COUNT_BITS;&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TIDYING    =  &lt;span&gt;2&lt;/span&gt; &amp;lt;&amp;lt; COUNT_BITS;&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TERMINATED =  &lt;span&gt;3&lt;/span&gt; &amp;lt;&amp;lt; COUNT_BITS;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池各个状态切换图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSCmytA2eBOib4TUlWRjmQ0WlIHdlH5d0IXHPiae8xHkyVfqF2nImX1zmA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;线程池状态切换图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;RUNNING&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;该状态的线程池会接收新任务，并处理阻塞队列中的任务;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用线程池的shutdown()方法，可以切换到SHUTDOWN状态;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用线程池的shutdownNow()方法，可以切换到STOP状态;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;SHUTDOWN&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;队列为空，并且线程池中执行的任务也为空,进入TIDYING状态;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;STOP&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程池中执行的任务为空,进入TIDYING状态;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;TIDYING&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;该状态表明所有的任务已经运行终止，记录的任务数量为0。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;terminated()执行完毕，进入TERMINATED状态&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;TERMINATED&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;57.线程池如何实现参数的动态修改？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池提供了几个  setter方法来设置线程池的参数。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSavbupJDShuicur1MP6r55ANkIbmzhkoSYn6yRGOrcrPBExbtd9cgGPw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;JDK 线程池参数设置接口来源参考[7]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里主要有两个思路：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSLrfjLDicA55ZfCzjAaicbk47vicbGUs88z1U3xD478zQAckYQkGCVtUlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;动态修改线程池参数&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在我们微服务的架构下，可以利用配置中心如Nacos、Apollo等等，也可以自己开发配置中心。业务服务读取线程池配置，获取相应的线程池实例来修改线程池的参数。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果限制了配置中心的使用，也可以自己去扩展&lt;strong&gt;ThreadPoolExecutor&lt;/strong&gt;，重写方法，监听线程池参数变化，来动态修改线程池参数。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;线程池调优了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池配置没有固定的公式，通常事前会对线程池进行一定评估，常见的评估方案如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS911XXzD3vbwfoTaWB8BduS0zvR0ky7JFAFlia3eHgwpTq7dTj2alMcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;线程池评估方案 来源参考[7]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上线之前也要进行充分的测试，上线之后要建立完善的线程池监控机制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事中结合监控告警机制，分析线程池的问题，或者可优化点，结合线程池动态参数配置机制来调整配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事后要注意仔细观察，随时调整。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSjlUdjTG0hA2bQABkZ1KFYK5RUfrumweRprdxzwErgJrTMYNHJnx46g/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;线程池调优&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的调优案例可以查看参考[7]美团技术博客。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;58.你能设计实现一个线程池吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;⭐这道题在阿里的面试中出现频率比较高&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池实现原理可以查看 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247488521&amp;amp;idx=1&amp;amp;sn=66b0ae23ef24ba47f4487aa8a3646886&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;要是以前有人这么讲线程池，我早就该明白了！&lt;/a&gt;  ，当然，我们自己实现， 只需要抓住线程池的核心流程-参考[6]：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS6pnG8oPaia0Kicic8DhQ08mkzn8iaGEJk8whPYZ4E3sGYf2gUGoDfUW5Hg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;线程池主要实现流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们自己的实现就是完成这个核心流程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程池中有N个工作线程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;把任务提交给线程池运行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果线程池已满，把任务放入队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后当有空闲时，获取队列中任务来执行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现代码[6]：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS9pA3JJZyEsgepVkQ9M2prjsiamJ8cBKb8MCWnX9l6jsn1aNyQuH2vpw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;自定义线程池&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，一个实现了线程池主要流程的类就完成了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;59.单机线程池执行断电了应该怎么处理？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;我们可以对正在处理和阻塞队列的任务做事务管理或者对阻塞队列中的任务持久化处理，并且当断电或者系统崩溃，操作无法继续下去的时候，可以通过回溯日志的方式来撤销&lt;code&gt;正在处理&lt;/code&gt;的已经执行成功的操作。然后重新执行整个阻塞队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，对阻塞队列持久化；正在处理任务事务控制；断电之后正在处理任务的回滚，通过日志恢复该次操作；服务器重启后阻塞队列中的数据再加载。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;并发容器和框架&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于一些并发容器，可以去看看 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247488788&amp;amp;idx=1&amp;amp;sn=01875e3e45515c2d57593cb7a01d0b6b&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;面渣逆袭：Java集合连环三十问  &lt;/a&gt;，里面有&lt;code&gt;CopyOnWriteList&lt;/code&gt;和&lt;code&gt;ConcurrentHashMap&lt;/code&gt;这两种线程安全容器类的问答。。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;60.Fork/Join框架了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Fork/Join框架是Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要想掌握Fork/Join框架，首先需要理解两个点，&lt;strong&gt;分而治之&lt;/strong&gt;和&lt;strong&gt;工作窃取算法&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;分而治之&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Fork/Join框架的定义，其实就体现了分治思想：将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS6J3czqIO12fQuCQKZZWHQdd6Egdjia4ertvp8Ap80Zx3BZ4mkeTsvJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Fork/Join分治算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;工作窃取算法&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大任务拆成了若干个小任务，把这些小任务放到不同的队列里，各自创建单独线程来执行队列里的任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了，有的线程干活块，有的线程干活慢。干完活的线程不能让它空下来，得让它去帮没干完活的线程干活。它去其它线程的队列里窃取一个任务来执行，这就是所谓的&lt;strong&gt;工作窃取&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作窃取发生的时候，它们会访问同一个队列，为了减少窃取任务线程和被窃取任务线程之间的竞争，通常任务会使用双端队列，被窃取任务线程永远从双端队列的头部拿，而窃取任务的线程永远从双端队列的尾部拿任务执行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSMU4VPDmKLHgz7FU8UKgQOvmpH9oDI7fOiboDYQz7nhwIAjdE1Y2NZicg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;工作窃取&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一个Fork/Join框架应用的例子，计算1~n之间的和：1+2+3+…+n&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;设置一个分割阈值，任务大于阈值就拆分任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;任务有结果，所以需要继承RecursiveTask&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CountTask&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;RecursiveTask&lt;/span&gt;&amp;lt;&lt;span&gt;Integer&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; THRESHOLD = &lt;span&gt;16&lt;/span&gt;; &lt;span&gt;// 阈值&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; start;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; end;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;CountTask&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; start, &lt;span&gt;int&lt;/span&gt; end)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.start = start;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.end = end;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; Integer &lt;span&gt;compute&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; sum = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;// 如果任务足够小就计算任务&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; canCompute = (end - start) &amp;lt;= THRESHOLD;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (canCompute) {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = start; i &amp;lt;= end; i++) {&lt;br/&gt;                sum += i;&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// 如果任务大于阈值，就分裂成两个子任务计算&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; middle = (start + end) / &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;            CountTask leftTask = &lt;span&gt;new&lt;/span&gt; CountTask(start, middle);&lt;br/&gt;            CountTask rightTask = &lt;span&gt;new&lt;/span&gt; CountTask(middle + &lt;span&gt;1&lt;/span&gt;, end);&lt;br/&gt;            &lt;span&gt;// 执行子任务&lt;/span&gt;&lt;br/&gt;            leftTask.fork();&lt;br/&gt;            rightTask.fork(); &lt;span&gt;// 等待子任务执行完，并得到其结果&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; leftResult = leftTask.join();&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; rightResult = rightTask.join(); &lt;span&gt;// 合并子任务&lt;/span&gt;&lt;br/&gt;            sum = leftResult + rightResult;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; sum;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ForkJoinPool forkJoinPool = &lt;span&gt;new&lt;/span&gt; ForkJoinPool(); &lt;span&gt;// 生成一个计算任务，负责计算1+2+3+4&lt;/span&gt;&lt;br/&gt;        CountTask task = &lt;span&gt;new&lt;/span&gt; CountTask(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;); &lt;span&gt;// 执行一个任务&lt;/span&gt;&lt;br/&gt;        Future&amp;lt;Integer&amp;gt; result = forkJoinPool.submit(task);&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            System.out.println(result.get());&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (ExecutionException e) {&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ForkJoinTask与一般Task的主要区别在于它需要实现compute方法，在这个方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果比较大，就必须分割成两个子任务，每个子任务在调用fork方法时，又会进compute方法，看看当前子任务是否需要继续分割成子任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会等待子任务执行完并得到其结果。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;big&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;span&gt;[1]. 《Java并发编程的艺术》&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[2]. 《Java发编程实战》&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[3]. 个人珍藏的80道多线程并发面试题（1-10答案解析）:https://juejin.cn/post/6854573221258199048&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[4]. 艾小仙 《我想进大厂》&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[5]. Java并发基础知识，我用思维导图整理好了:https://fighter3.blog.csdn.net/article/details/113612422&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[6] . 极客时间 《Java并发编程实战》&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[7]. 《Java并发编程之美》&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[8]. 万字图文 | 聊一聊 ReentrantLock 和 AQS 那点事（看完不会你找我）:https://juejin.cn/post/6896278031317663751&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[9]. 《深入理解Java虚拟机》&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[10]. 如何实现阻塞队列 :https://juejin.cn/post/6977948393272246285&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[11]. 讲真 这次绝对让你轻松学习线程池:https://mp.weixin.qq.com/s/dTMH1TdxiCKy5yotQ7u7cA&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[12]. 面试必备：Java线程池解析:https://juejin.cn/post/6844903889678893063&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[13]. 面试官问：“在项目中用过多线程吗？”你就把这个案例讲给他听！:https://juejin.cn/post/6936457087505399821&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[14]. 小傅哥 《Java面经手册》&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[15]. Java线程池实现原理及其在美团业务中的实践:https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[16]. 面试官：小伙子，听说你看过ThreadLocal源码？（万字图文深度解析ThreadLocal）:https://juejin.cn/post/6844904151567040519&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[17].面试官问我什么是JMM:https://zhuanlan.zhihu.com/p/258393139&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[18]. 《王者并发课》:https://juejin.cn/column/6963590682602635294&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[19]. synchronized锁升级详细过程:https://www.cnblogs.com/suixing123/p/13996479.html&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d5fbd1e0352f4c6e4f93efa17720d94e</guid>
<title>[推荐] 浅谈缓存最终一致性的解决方案</title>
<link>https://toutiao.io/k/mgym1lv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：clareguo，腾讯 CSIG 后台开发工程师&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;46&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;到底是更新缓存还是删除缓存? 到底是先更新数据库，再删除缓存，还是先删除缓存，再更新数据库?&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1 引言&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于互联网业务来说，传统的直接访问数据库方式，主要通过数据分片、一主多从等方式来扛住读写流量，但随着数据量的积累和流量的激增，仅依赖数据库来承接所有流量，不仅成本高、效率低、而且还伴随着稳定性降低的风险。鉴于大部分业务通常是读多写少（读取频率远远高于更新频率），甚至存在读操作数量高出写操作多个数量级的情况。因此，在架构设计中，常采用增加缓存层来提高系统的响应能力，提升数据读写性能、减少数据库访问压力，从而提升业务的稳定性和访问体验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据 CAP 原理，分布式系统在可用性、一致性和分区容错性上无法兼得，通常由于分区容错无法避免，所以一致性和可用性难以同时成立。对于缓存系统来说，如何保证其数据一致性是一个在应用缓存的同时不得不解决的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要明确的是，缓存系统的数据一致性通常包括持久化层和缓存层的一致性、以及多级缓存之间的一致性，这里我们仅讨论前者。持久化层和缓存层的一致性问题也通常被称为双写一致性问题，“双写”意为数据既在数据库中保存一份，也在缓存中保存一份。对于一致性来说，包含强一致性和弱一致性，强一致性保证写入后立即可以读取，弱一致性则不保证立即可以读取写入后的值，而是尽可能的保证在经过一定时间后可以读取到，在弱一致性中应用最为广泛的模型则是最终一致性模型，即保证在一定时间之后写入和读取达到一致的状态。对于应用缓存的大部分场景来说，追求的则是最终一致性，少部分对数据一致性要求极高的场景则会追求强一致性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2 保证最终一致性的策略（ Cache Policy ）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了达到最终一致性，针对不同的场景，业界逐步形成了下面这几种应用缓存的策略。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 Cache-Aside&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Cache-Aside 意为旁路缓存模式，是应用最为广泛的一种缓存策略。下面的图示展示了它的读写流程，来看看它是如何保证最终一致性的。在读请求中，首先请求缓存，若缓存命中（ cache hit ），则直接返回缓存中的数据；若缓存未命中（ cache miss ），则查询数据库并将查询结果更新至缓存，然后返回查询出的数据（ demand-filled look-aside ）。在写请求中，先更新数据库，再删除缓存（write-invalidate）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5924050632911393&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEy8knbFcMB7NoiajEYjxo04ww5kmKIOyicbnpbMD0kz3N57EzT4H46xkQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1580&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.1 为什么删除缓存，而不是更新缓存？&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Cache-Aside 中，对于读请求的处理比较容易理解，但在写请求中，可能会有读者提出疑问，为什么要删除缓存，而不是更新缓存？站在符合直觉的角度来看，更新缓存是一个容易被理解的方案，但站在性能和安全的角度，更新缓存则可能会导致一些不好的后果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先是性能，当该缓存对应的结果需要消耗大量的计算过程才能得到时，比如需要访问多张数据库表并联合计算，那么在写操作中更新缓存的动作将会是一笔不小的开销。同时，当写操作较多时，可能也会存在刚更新的缓存还没有被读取到，又再次被更新的情况（这常被称为缓存扰动），显然，这样的更新是白白消耗机器性能的，会导致缓存利用率不高。而等到读请求未命中缓存时再去更新，也符合懒加载的思路，需要时再进行计算。删除缓存的操作不仅是幂等的，可以在发生异常时重试，而且写-删除和读-更新在语义上更加对称。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次是安全，在并发场景下，在写请求中更新缓存可能会引发数据的不一致问题。参考下面的图示，若存在两个来自不同线程的写请求，首先来自线程 1 的写请求更新了数据库（ step 1 ），接着来自线程 2 的写请求再次更新了数据库（ step 3 ），但由于网络延迟等原因，线程 1 可能会晚于线程 2 更新缓存（ step 4 晚于 step 3 ），那么这样便会导致最终写入数据库的结果是来自线程 2 的新值，写入缓存的结果是来自线程 1 的旧值，即缓存落后于数据库，此时再有读请求命中缓存（ step 5 ），读取到的便是旧值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5852130325814536&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwErd8vgtqGLMcj2zkhqt4sO4mwic32ZU0wrlRP2reBh4K48X5jEVBooEA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1596&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.2 为什么先更新数据库，而不是先删除缓存？&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，有读者也会对更新数据库和删除缓存的时序产生疑问，那么为什么不先删除缓存，再更新数据库呢？在单线程下，这种方案看似具有一定合理性，这种合理性体现在删除缓存成功，但更新数据库失败的场景下，尽管缓存被删除了，下次读操作时，仍能将正确的数据写回缓存，相对于 Cache-Aside 中更新数据库成功，删除缓存失败的场景来说，先删除缓存的方案似乎更合理一些。那么，先删除缓存有什么问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题仍然出现在并发场景下，首先来自线程 1 的写请求删除了缓存（ step 1 ），接着来自线程 2 的读请求由于缓存的删除导致缓存未命中，根据 Cache-Aside 模式，线程 2 继而查询数据库（ step 2 ），但由于写请求通常慢于读请求，线程 1 更新数据库的操作可能会晚于线程 2 查询数据库后更新缓存的操作（ step 4 晚于 step 3 ），那么这样便会导致最终写入缓存的结果是来自线程 2 中查询到的旧值，而写入数据库的结果是来自线程 1 的新值，即缓存落后于数据库，此时再有读请求命中缓存（ step 5 ），读取到的便是旧值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3954659949622166&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEgctQjMRGQglE3wyEmDWxGefpPfdZmcsgz1El5qL5icCdroGYcSTrI5Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1588&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，先删除缓存，由于缓存中数据缺失，加剧数据库的请求压力，可能会增大缓存穿透出现的概率。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.3 如果选择先删除缓存，再更新数据库，那如何解决一致性问题呢？&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了避免“先删除缓存，再更新数据库”这一方案在读写并发时可能带来的缓存脏数据，业界又提出了延时双删的策略，即在更新数据库之后，延迟一段时间再次删除缓存，为了保证第二次删除缓存的时间点在读请求更新缓存之后，这个延迟时间的经验值通常应稍大于业务中读请求的耗时。延迟的实现可以在代码中 &lt;code&gt;sleep&lt;/code&gt; 或采用延迟队列。显而易见的是，无论这个值如何预估，都很难和读请求的完成时间点准确衔接，这也是延时双删被诟病的主要原因。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5082382762991128&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEtpFBnmv9rhKJULmmAIrGjcqnnXSInT1UMTntXVntpZWPuf8Oaicfb4w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1578&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.4 那么 Cache-Aside 存在数据不一致的可能吗？&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Cache-Aside 中，也存在数据不一致的可能性。在下面的读写并发场景下，首先来自线程 1 的读请求在未命中缓存的情况下查询数据库（ step 1 ），接着来自线程 2 的写请求更新数据库（ step 2 ），但由于一些极端原因，线程 1 中读请求的更新缓存操作晚于线程 2 中写请求的删除缓存的操作（ step 4 晚于 step 3 ），那么这样便会导致最终写入缓存中的是来自线程 1 的旧值，而写入数据库中的是来自线程 2 的新值，即缓存落后于数据库，此时再有读请求命中缓存（ step 5 ），读取到的便是旧值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种场景的出现，不仅需要缓存失效且读写并发执行，而且还需要读请求查询数据库的执行早于写请求更新数据库，同时读请求的执行完成晚于写请求。足以见得，这种不一致场景产生的条件非常严格，在实际的生产中出现的可能性较小。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4068010075566751&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEy1XuQ2xxVFFdNZgibhhSJUnR0sViasGl6xzLgNMcP3wxC1bJJ59CZ0icQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1588&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，在并发环境下，Cache-Aside 中也存在读请求命中缓存的时间点在写请求更新数据库之后，删除缓存之前，这样也会导致读请求查询到的缓存落后于数据库的情况。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38944723618090454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEuKSPArRcuQPbIob0MBaBWgKYyrZBZuNUvBR7DYNeNm67EmAbOwsuKA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1592&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然在下一次读请求中，缓存会被更新，但如果业务层面对这种情况的容忍度较低，那么可以采用加锁在写请求中保证“更新数据库&amp;amp;删除缓存”的串行执行为原子性操作（同理也可对读请求中缓存的更新加锁）。加锁势必会导致吞吐量的下降，故采取加锁的方案应该对性能的损耗有所预期。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4292929292929293&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwExt0GUt5zySf0MYCib3Wbg3jibkIwvQNicERf8PKC2wFTJfAtLBjiaODpxg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1584&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6914212548015365&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEicojwkV1Uh0nDTWGFTd3ncLQbibB2eZiccTnm4BOjILRvawDvx4qqhsMw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1562&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 补偿机制&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在上面提到了，在 Cache-Aside 中可能存在更新数据库成功，但删除缓存失败的场景，如果发生这种情况，那么便会导致缓存中的数据落后于数据库，产生数据的不一致的问题。其实，不仅 Cache-Aside 存在这样的问题，在延时双删等策略中也存在这样的问题。针对可能出现的删除失败问题，目前业界主要有以下几种补偿机制。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2.1 删除重试机制&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于同步重试删除在性能上会影响吞吐量，所以常通过引入消息队列，将删除失败的缓存对应的 &lt;code&gt;key&lt;/code&gt; 放入消息队列中，在对应的消费者中获取删除失败的 &lt;code&gt;key&lt;/code&gt; ，异步重试删除。这种方法在实现上相对简单，但由于删除失败后的逻辑需要基于业务代码的 trigger 来触发 ，对业务代码具有一定入侵性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45132743362831856&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEkNJlDa9w1r2icXT7YGQtpuZq66BIDuFaCe79Whl5gDeOu1EyqEibB03A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1582&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2.2 基于数据库日志（ MySQL binlog ）增量解析、订阅和消费&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;鉴于上述方案对业务代码具有一定入侵性，所以需要一种更加优雅的解决方案，让缓存删除失败的补偿机制运行在背后，尽量少的耦合于业务代码。一个简单的思路是通过后台任务使用更新时间戳或者版本作为对比获取数据库的增量数据更新至缓存中，这种方式在小规模数据的场景可以起到一定作用，但其扩展性、稳定性都有所欠缺。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个相对成熟的方案是基于 MySQL 数据库增量日志进行解析和消费，这里较为流行的是阿里巴巴开源的作为 MySQL binlog 增量获取和解析的组件 canal （类似的开源组件还有 Maxwell、Databus 等）。canal sever 模拟 MySQL slave 的交互协议，伪装为 MySQL slave ，向 MySQL master 发送 dump 协议，MySQL master 收到 dump 请求，开始推送 binary log 给 slave （即 canal sever ），canal sever 解析 binary log 对象（原始为 byte 流），可由 canal client 拉取进行消费，同时 canal server 也默认支持将变更记录投递到 MQ 系统中，主动推送给其他系统进行消费。在 ack 机制的加持下，不管是推送还是拉取，都可以有效的保证数据按照预期被消费。当前版本的 canal 支持的 MQ 有 kafka 或者 RocketMQ 。另外， canal 依赖 zookeeper 作为分布式协调组件来实现 HA ，canal 的 HA 分为两个部分：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为了减少对 MySQL dump 的请求压力，不同 canal server 上的 instance 要求同一时间只能有一个处于运行状态，其他的 instance 处于 standby 状态；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为了保证有序性，对于一个 instance 在同一时间只能由一个 canal client 进行 get/ack 等动作；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6923076923076923&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEByTHKnOZ2yJDa8ciamnK6GsqkWm8CMcViaPHXdvhtSPV2wunkXcnrP0A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1560&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，针对缓存的删除操作便可以在 canal client 或 consumer 中编写相关业务代码来完成。这样，结合数据库日志增量解析消费的方案以及 Cache-Aside 模型，在读请求中未命中缓存时更新缓存（通常这里会涉及到复杂的业务逻辑），在写请求更新数据库后删除缓存，并基于日志增量解析来补偿数据库更新时可能的缓存删除失败问题，在绝大多数场景下，可以有效的保证缓存的最终一致性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外需要注意的是，还应该隔离事务与缓存，确保数据库入库后再进行缓存的删除操作。比如考虑到数据库的主从架构，主从同步及读从写主的场景下，可能会造成读取到从库的旧数据后便更新了缓存，导致缓存落后于数据库的问题，这就要求对缓存的删除应该确保在数据库操作完成之后。所以，基于 binlog 增量日志进行数据同步的方案，可以通过选择解析从节点的 binlog，来避免主从同步下删除缓存过早的问题。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2.3 数据传输服务 DTS&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据传输服务（ Data Transmission Service，简称 DTS）是云服务商提供的一种支持 RDBMS（关系型数据库）、NoSQL、OLAP 等多种数据源之间进行数据交互的数据流服务。DTS 提供了包括数据迁移、数据订阅、数据同步等在内的多种数据传输能力，常用于不停服数据迁移、数据异地灾备、异地多活(单元化)、跨境数据同步、实时数据仓库、查询报表分流、缓存更新、异步消息通知等多种业务应用场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对于上述基于 canal 等开源组件自建系统，DTS 的优势体现在对多种数据源的支持、对多种数据传输方式的支持，避免了部署维护的人力成本。目前，各家云服务商的 DTS 服务已 针对云数据库，云缓存等产品进行了适配，解决了 Binlog 日志回收，主备切换等场景下的订阅高可用问题。在大规模的缓存数据一致性场景下，优先推荐使用 DTS 服务。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 Read-Through&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Read-Through 意为读穿透模式，它的流程和 Cache-Aside 类似，不同点在于 Read-Through 中多了一个访问控制层，读请求只和该访问控制层进行交互，而背后缓存命中与否的逻辑则由访问控制层与数据源进行交互，业务层的实现会更加简洁，并且对于缓存层及持久化层交互的封装程度更高，更易于移植。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7479224376731302&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEMibwZEPeCZE1icibze89CLf9h8aPkgcJ0NUWlvJjd0IcMa6Yib4ziamibic1w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1444&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 Write-Through&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Write-Through 意为直写模式，对于 Write-Through 直写模式来说，它也增加了访问控制层来提供更高程度的封装。不同于 Cache-Aside 的是，Write-Through 直写模式在写请求更新数据库之后，并不会删除缓存，而是更新缓存。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49111675126903553&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEbcBG5HIc4pohTLg9sMgRNDlAR3xPmYHS2HlMbz3Gv57bTeRJsmicKAA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1576&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式的优势在于读请求过程简单，不需要查询数据库更新缓存等操作。但其劣势也非常明显，除了上面我们提到的更新数据库再更新缓存的弊端之外，这种方案还会造成更新效率低，并且两个写操作任何一次写失败都会造成数据不一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要使用这种方案，最好可以将这两个操作作为事务处理，可以同时失败或者同时成功，支持回滚，并且防止并发环境下的不一致。另外，为了防止缓存扰动的频发，也可以给缓存增加 TTL 来缓解。站在可行性的角度，不管是 Write-Through 模式还是 Cache-Aside 模式，理想状况下都可以通过分布式事务保证缓存层数据与持久化层数据的一致性，但在实际项目中，大多都对一致性的要求存在一些宽容度，所以在方案上往往有所折衷。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Write-Through 直写模式适合写操作较多，并且对一致性要求较高的场景，在应用 Write-Through 模式时，也需要通过一定的补偿机制来解决它的问题。首先，在并发环境下，我们前面提到了先更新数据库，再更新缓存会导致缓存和数据库的不一致，那么先更新缓存，再更新数据库呢？这样的操作时序仍然会导致下面这样线程 1 先更新缓存，最后更新数据库的情况，即由于线程 1 和 线程 2 的执行不确定性导致数据库和缓存的不一致。这种由于线程竞争导致的缓存不一致，可以通过分布式锁解决，保证对缓存和数据库的操作仅能由同一个线程完成。对于没有拿到锁的线程，一是通过锁的 &lt;code&gt;timeout&lt;/code&gt; 时间进行控制，二是将请求暂存在消息队列中顺序消费。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.410941475826972&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEB0ibpwSfY0CJJgyibXEVJ6xCKUjvZ72PI39SQWDEUz3bjCYUGrJQhkUg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1572&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在下面这种并发执行场景下，来自线程 1 的写请求更新了数据库，接着来自线程 2 的读请求命中缓存，接着线程 1 才更新缓存，这样便会导致线程 2 读取到的缓存落后于数据库。同理，先更新缓存后更新数据库在写请求和读请求并发时，也会出现类似的问题。面对这种场景，我们也可以加锁解决。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3883984867591425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEXvn8hXIzibTmpt4R8LEuwMUN0aLDJug0kGtXicPmTgfnNSic7XLbIn5Eg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1586&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另在，在 Write-Through 模式下，不管是先更新缓存还是先更新数据库，都存在更新缓存或者更新数据库失败的情况，上面提到的重试机制和补偿机制在这里也是奏效的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5 Write-Behind&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Write behind 意为异步回写模式，它也具有类似 Read-Through/Write-Through 的访问控制层，不同的是，Write behind 在处理写请求时，只更新缓存而不更新数据库，对于数据库的更新，则是通过批量异步更新的方式进行的，批量写入的时间点可以选在数据库负载较低的时间进行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48984771573604063&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEfl7FaXmIwmgNPoUOwib2tSWykFoZicIpiaxbHPIpLC51VKyFazLkKEaeQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1576&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Write-Behind 模式下，写请求延迟较低，减轻了数据库的压力，具有较好的吞吐性。但数据库和缓存的一致性较弱，比如当更新的数据还未被写入数据库时，直接从数据库中查询数据是落后于缓存的。同时，缓存的负载较大，如果缓存宕机会导致数据丢失，所以需要做好缓存的高可用。显然，Write behind 模式下适合大量写操作的场景，常用于电商秒杀场景中库存的扣减。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.6 Write-Around&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一些非核心业务，对一致性的要求较弱，可以选择在 cache aside 读模式下增加一个缓存过期时间，在写请求中仅仅更新数据库，不做任何删除或更新缓存的操作，这样，缓存仅能通过过期时间失效。这种方案实现简单，但缓存中的数据和数据库数据一致性较差，往往会造成用户的体验较差，应慎重选择。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在解决缓存一致性的过程中，有多种途径可以保证缓存的最终一致性，应该根据场景来设计合适的方案，读多写少的场景下，可以选择采用“ Cache-Aside 结合消费数据库日志做补偿”的方案，写多的场景下，可以选择采用“ Write-Through 结合分布式锁”的方案 ，写多的极端场景下，可以选择采用“ Write-Behind ” 的方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;最近其他好文：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649766734&amp;amp;idx=1&amp;amp;sn=b23d539c9daedbf8a6ab8993505e3641&amp;amp;chksm=becca83589bb2123c21a187be11e064ba5e5154ceded1eef0b95d3ba3e4f9e8140adadfff0de&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;最近大火的 NFT 数字藏品是什么？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;最近大火的 NFT 数字藏品是什么？&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649766668&amp;amp;idx=1&amp;amp;sn=bc8d55f637fe8b00ce5404cfcfb8b7fc&amp;amp;chksm=becca87789bb216125125fdb6f5d883048a6346937f0c6707ea527df429040b508a759362de9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2021 腾讯技术十大热门文章&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;2021 腾讯技术十大热门文章&lt;/a&gt;&lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649766668&amp;amp;idx=1&amp;amp;sn=bc8d55f637fe8b00ce5404cfcfb8b7fc&amp;amp;chksm=becca87789bb216125125fdb6f5d883048a6346937f0c6707ea527df429040b508a759362de9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2021 腾讯技术十大热门文章&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649766638&amp;amp;idx=1&amp;amp;sn=031eaf1fdd40222568eb40a9b6a399fb&amp;amp;chksm=becca99589bb2083ae4a361707339fc343bfe2d604c7cbcb6de582e878bc275849e52d0b9f68&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;服务器开发设计之算法宝典&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;服务器开发设计之算法宝典&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;3.72125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvatkTw3ahJGNlXdrVzdl0yxFvsAzUia48cP7KRgP46ZoZHANttHd1ZXKgWia8wm4TdWcNsrib1oSwaiaMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.587962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvatPyBdU42Pibe0fLSj0H232CGFzpFGdr8BenFo7oRWoAaecicibla1KEFW6KPrRStATLSwQ1hGJOUeEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_live_iframe&quot; data-pluginname=&quot;videosnap&quot; data-headimgurl=&quot;https://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;将在01月12日 19:30 直播&quot; data-intro=&quot;对谈CoDesign程序媛，听听“文艺女青年”的前端旅行&quot; data-noticeid=&quot;finderlivenotice-v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder-1641525666664055-1293066808&quot; data-type=&quot;live&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5ODYwMjI2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasvpPfMrktl2xvC9A325p8Qa9dFeEzxZmZ2O1XuFGsVXyQhG9Dia8J8nTXVtzNcHozr0umH3R4iboXg/0?wx_fmt=png&quot; data-nickname=&quot;腾讯技术工程&quot; data-alias=&quot;Tencent_TEG&quot; data-signature=&quot;腾讯技术官方号。腾讯技术创新、前沿领域发布解读平台。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5312f2f6b6089c2a33ecea5695ba8a9b</guid>
<title>[推荐] 服务探活的五种方式</title>
<link>https://toutiao.io/k/1wuwmui</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;几个月前，我在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI5NjE2MDQwNg==&amp;amp;mid=2247485634&amp;amp;idx=1&amp;amp;sn=31722e2343e8ff9d56300133c2011237&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《4个实验，彻底搞懂TCP连接的断开》&lt;/a&gt;这篇文章中给自己挖了个坑：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.09038901601830664&quot; data-type=&quot;png&quot; data-w=&quot;1748&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0Sc6x9H0p6efiaPVFAuxHOicSL84fF5SVSpaiaUFHK31slByEnTF28298l4ffyLpqHG9aASvlzwEw3NQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文中提到的&lt;code&gt;实际问题&lt;/code&gt;就是服务探活，今天来填上这个坑。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在微服务架构下，服务提供方（Provider）的节点一般不止一个，消费方（Consumer）根据负载均衡算法挑选一个&lt;code&gt;健康&lt;/code&gt;的节点进行调用。识别Provider节点是否健康，这便是&lt;strong&gt;服务探活&lt;/strong&gt; 要讨论的内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;健康的节点&lt;/code&gt;可定义为能正常响应Consumer请求的节点，不健康自然是不能正常响应Consumer请求的节点&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;不健康&lt;/code&gt;的原因可能是物理上的断电、断网、硬件故障，也可能是网络延迟、进程异常退出或进程无法处理请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总之一句话总结起来就是Provider节点没有摘除流量前，就无法处理请求了。可以分为三类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;系统异常：如断电、断网、其他硬件故障、或操作系统异常退出&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;进程异常退出：进程异常退出，端口挂掉，如有注销机制但没来得及注销，如执行了kill -9&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;进程无法处理请求：端口还在，但服务无法正常响应，如Full GC期间&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个Provider节点的状态只有健康和不健康，由健康到不健康称之为&lt;code&gt;探死&lt;/code&gt;，由不健康到健康称之为&lt;code&gt;探活&lt;/code&gt;，一般我们不分这么细，统一叫&lt;code&gt;探活&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于是谁来探，可能是Consumer，也可能是注册中心，甚至是某个单独的探活组件。我们就从探活的发起者来列举目前主流的探活方式。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Consumer被动探活&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最简单的是在Consumer侧进行探活，如果Consumer调用Provider报错，则Consumer将该Provider剔掉，为了防止偶发的网络抖动或其他干扰，可设置一个时间窗口，窗口内失败达N 次则剔除，当过了这段时间，再把这个Provider重置为正常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式的典型代表是Nginx，Nginx可配置多长时间内，失败多少次则认为该Provider不可用，其失败可以是连接失败、也可以是某些http状态码（如4xx，5xx）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方案的缺点很明显，需要真实流量去检测，如果配置了失败继续转发给下一个Provider，则时间窗口的开始的一段时间内耗时上升，未配置则直接报错，所以无论怎么配置，对服务都是有影响的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Consumer主动探活&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Consumer被动健康检查的主要问题在于使用了真实流量检测，其实只要稍微改一改，使用旁路的方式去检测即可避免。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阿里的Tengine开源了一个&lt;code&gt;nginx_upstream_check_module&lt;/code&gt;模块来做主动健康检查。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个旁路可以一直去探测Provider，当检测到异常时，将其标记为不可用状态，请求不再发往该Provider，若检测到Provider 健康时，再将其标记为健康。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Consumer侧的探活在RPC框架实现的比较少，不知道是基于怎样的一种考虑，其实有些企业内会在Consumer侧已经加入了探活机制，比如&lt;code&gt;爱奇艺&lt;/code&gt;在Dubbo的Consumer侧增加了探活机制，其实我所在的公司内部RPC框架也是有Consumer侧的服务探活。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;参考《爱奇艺在 Dubbo 生态下的微服务架构实践》https://developer.aliyun.com/article/771495&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但Dubbo官方没有集成，至于为什么，我也去github上问过，不过没人回复~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Provider上报心跳&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当有一个注册中心时，探活这项任务就可以交给注册中心了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最简单的，我们想到了心跳保持这个策略，Provider注册成功后，一直向注册中心发送心跳包，注册中心定时检查Provider，如果长时间未发送心跳包，就将其置为不可用，并告知Consumer，如果心跳恢复，则将其恢复并通知。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;某些组件也支持这种&lt;code&gt;续约&lt;/code&gt;的特性，如etcd、redis等都可以构建类似的系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式的代表是Nacos 1.x 版本中的&lt;code&gt;临时实例&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;慢慢你会发现这种方式摘除故障节点的时效性和资源的使用成正相关，如果你想要更好的时效性，就必须缩短心跳间隔，从而会增加心跳请求量，每次心跳得更新每个节点的&lt;code&gt;上次心跳时间&lt;/code&gt;，占用了大量资源。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Provider与注册中心会话保持&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决心跳请求占用大量资源的问题，我们想到了TCP 连接不是一个天然的健康检查机制吗？如果仅仅依靠TCP连接可以吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是之前文章埋下的坑，再次总结一下这篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI5NjE2MDQwNg==&amp;amp;mid=2247485634&amp;amp;idx=1&amp;amp;sn=31722e2343e8ff9d56300133c2011237&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《4个实验，彻底搞懂TCP连接的断开》&lt;/a&gt;中关于TCP连接断开的场景：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果是进程终止、无论是正常或者是异常，只要操作系统还在，TCP连接就会正确断开&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果是断电、断网或其他因素导致操作系统挂掉，则网络不一定能正确断开，还得分情况&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果此时注册中心有往Provider发送数据，那么是能及时感知到Provider的异常，并断开连接的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果注册中心没有往Provider发送数据，是不能及时感知连接的断开，即使配置了TCP的KeepAlive，也需要大概2小时才能感知到&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2小时肯定不能接受，为了防止这种情况，光靠TCP是不够的，还得在应用层实现一个心跳检测，为了节省资源，可以将心跳包设计的很小，发送频率不需要那么高，通常1分钟内能感知即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为只有断电、断网或硬件故障才会导致无法感知连接的断开，这个比例很小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以参考下图，虽然图中的数据是我杜撰的，但八九不离十吧，可以看到系统异常只占1%，这1%中未发数据可能更少，所以可以认为这个概率很小。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6687402799377916&quot; data-type=&quot;png&quot; data-w=&quot;1286&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0Sc6x9H0p6efiaPVFAuxHOicSdHrJavc2xKK0StoRsvMwtJMISs0xs0iaCxGj8lHhsGvu6icGlmFLzD1A/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式比较常见，像Dubbo使用的Zookeeper，Nacos 2.x版本（gRPC）的临时实例，SOFARegistry等等都用了这这种方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中SOFARegistry比较有意思，它提出了一种&lt;code&gt;连接敏感&lt;/code&gt;的长连接，乍一看以为用了什么黑科技，后来看了代码发现就是TCP连接加应用层的心跳检测，这些被他们封装在&lt;code&gt;SOFABolt&lt;/code&gt;通信框架中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40308988764044945&quot; data-type=&quot;png&quot; data-w=&quot;1424&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0Sc6x9H0p6efiaPVFAuxHOicSDJbAx8Xll4F5pjqh5Mg7yNR3rvUZQ2Yd6RHmumatKyMicGvUA9NpohQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;参考《海量数据下的注册中心 - SOFARegistry 架构介绍》https://mp.weixin.qq.com/s/mZo7Dg6gfNqXoetaqgwMww&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这个方式也有一个明显的缺点，如果网络状况不好的情况下，TCP连接比较容易断开，会导致节点频繁上下线。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;注册中心主动探测&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了上述的方式，还有一种注册中心（甚至是一个单独的组件）主动探测Provider的方式，与Consumer主动探测类似，只不过把探测任务移交给了注册中心或一个单独的组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主动探测有个最大的优势是可以扩展非常丰富的探测方式，比如最常见的探测端口是否存活，又或者探测Provider的一个http接口返回是否符合预期，甚至可以扩展为MySQL、Redis等等协议的探测。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是种能解决服务假死的探活方式，Nacos中的&lt;code&gt;永久实例&lt;/code&gt;探活就是采用的这种方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这种方式在实际使用的时候要考虑主动探测组件的高可用，高可用就得存在副本，可采取主备方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果单机存在性能瓶颈，还得分布式探活，主备可能就不适合，得有一个分布式协调者，这要说又得长篇大论。但这里你知道有这么个事儿就可以了。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考量探活的指标有三个：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;能不能探出来？——功能性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么时候探出来？——时效性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;会不会探错了？——稳定性&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;功能上最强的是带语义的主动探测，时效性最强的要属长连接会话保持。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;稳定性不好说谁强谁弱，但一般会给一个集群设置一个探活摘除的比例，比如最多摘除50%机器，防止探活错误导致节点全部下线，这也算是一种兜底策略吧。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;搜索关注微信公众号&quot;捉虫大师&quot;，回复关键字「Nacos」送你一本《Nacos架构与原理》电子书，Dubbo资料也在准备中，不想错过可以点个关注。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;另外我也准备组建一个技术交流群，但现在也不知道会有多少人，所以大家先加我微信 &lt;strong&gt;MrRoshi&lt;/strong&gt;，备注加群，一起交流技术，超过一定人数我就拉一个~&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0da1155c5a03b45ce44d3f834361c69a</guid>
<title>[推荐] 关于代码质量退化的思考</title>
<link>https://toutiao.io/k/zzaz6vu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body cnblogs-markdown&quot;&gt;
&lt;p&gt;一个软件项目从探索阶段到发展方向明确阶段，会经历从简单到复杂的一个过程，需求的不断叠加，会让系统越来越庞大，功能繁多，公司业务的扩展也让软件系统的生命周期变的更长。在业务变复杂软的过程中，各种原因的驱使，代码质量会退化，维护和开发新功能的成本也会相应的变高，推倒重新开发的成本也是高的吓人。&lt;/p&gt;
&lt;h2 id=&quot;代码质量退化的步骤&quot;&gt;代码质量退化的步骤&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;大多情况下编码设计质量最高的时候是根据第一版需求进行编码实现的时候&lt;/strong&gt;，但只要需求一变更，就会打乱原来的编码设计，软件质量也就会越来越差。或者就没有了设计。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/342595/202201/342595-20220107144131123-305134580.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到了项目中期，有新的功能或者bug的修复，老板就给我了一天时间，让我写好处理代码？逾期是要被骂的；这个没用的功能，做了也没人用，随便写吧，早点结束，早去干别的；我手上现在这么多活，你又插进来个新功能，我只能乱搞了，团队内人员水平的不同写的代码更是天差地别，等等，这都是我们实际工作中会遇到的问题。责任心让我们也会想先这样写，以后再重构，&lt;strong&gt;一般以后重构表示永远不会重构&lt;/strong&gt;。&lt;br/&gt;
上面说的这些都会让我们增加糟糕的代码，混乱的业务逻辑分布在我们系统的各个地方，部门人员变动，新的员工更不可能理解那些杂乱无章的东西，再接着推糟糕的代码，想要理清楚一个业务逻辑，非常容易在混乱的代码中迷路。最直接的后果就是这些混乱的代码会增加新功能的开发周期，领导层问为啥现在开发个功能这么慢？是不是人手不够，再招几个人吧。这杂乱的项目，不是新员工能理的清的，你会发现，&lt;strong&gt;虽然员工变多了。但开发效率还是上不去。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/342595/202201/342595-20220107144221410-1475304617.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那我们重新来做一个新的系统完全替代这个老项目吧，我们可以用最新的框架，更好的实现方式去完成这个系统，这种天真的想法会在团队成员的脑海里无数次出现，旧的系统业务很复杂，新的系统在兼容旧系统逻辑的同时，旧的系统也在更新需求，增加功能，在新系统完全可以抗衡旧系统之前，旧的系统会一直运行。如果你的新系统开发的时间过长，等完成的时候，可能员工都已经不知道换了几批了，代码又乱成了一锅粥，周而复始。&lt;/p&gt;
&lt;p&gt;软件的退化变的越来越严重的过程中，我们也在思考和改变现有的系统，如何才能让系统的在拥有更长的生命周期的同时，提高代码的质量，不让其退化，并拥有更好的可维护性和扩展性？那就是根据需求的变化去调整架构、代码，不断的打破原来的设计，保持清晰，而不是让他烂在那里。&lt;/p&gt;
&lt;h2 id=&quot;渐进式架构&quot;&gt;渐进式架构&lt;/h2&gt;
&lt;p&gt;大多数人能想到的最直接的方案是从架构入手，引入多维度的架构，微服务化，领域驱动模型(DDD)等等&lt;br/&gt;
从顶层设计出发引入新的架构模型，或者说根据需求的变动不断的调整代码的分层和模块，加上理论知识的应用，会让业务代码在结构归属上更清晰。分层的严密能让整体的&lt;strong&gt;业务边界&lt;/strong&gt;更明确，前提是我们要从多维度去审视系统的构架，思考如何去现有的架构做出合理的改动。&lt;/p&gt;
&lt;h3 id=&quot;从不同的角度去分析和改进现有架构&quot;&gt;从不同的角度去分析和改进现有架构&lt;/h3&gt;
&lt;p&gt;比如在项目初期业务比较简单，最简单的分层架构就实现了项目需求，观察我们的架构可能是这样子的，从上而下的松散分层架构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/342595/202201/342595-20220107144305648-1556510597.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后来又加入了缓存，又加入了消息队列，业务的不断扩张又加入了不同的数据库nosql,业务的升级有了v2.0,v3.0,新业务要兼容旧功能等等，如果还是原来的分层结构，很快就会出现逻辑代码堆积的问题，业务层之间引用杂乱，一个代码文件几千行代码，需求变动时牵一发动全身，及时调整架构的必要性就体现出来了。&lt;br/&gt;
一定要复用好&lt;strong&gt;依赖倒置原则&lt;/strong&gt;,层与层之间不应该依赖实现，要依赖于抽象，比如我们的基础设施层要为其他三层提供支持，基础设施层可以实现其他层定义的接口来进行抽象，从这个角度来开的话我们的基础设施层应该在最上面，也可以是左边或者右边&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/342595/202201/342595-20220107144331003-1956239261.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;应用依赖倒置后，我们调用的是抽象接口，你会发现层的概念没有了，层的概念被打破了，我们可以更激进一点把基础设施层剥离出去用各种适配器去接入各种组件，把层的关系拉平，把架构调整为&lt;strong&gt;六边形构架&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/342595/202201/342595-20220107144346648-1137144759.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不要固化自己的思维，根据业务和系统的发展去调整你的系统架构，能让系统能更高的可扩展和可维护性。&lt;br/&gt;
对于非常老的项目调整架构是痛苦的，一定要得到管理层充分的支持下再去做改造，这样的工作只能是从上往下推进，痛苦的过程终会换来后期维护的喜悦。&lt;/p&gt;
&lt;h2 id=&quot;代码层面&quot;&gt;代码层面&lt;/h2&gt;
&lt;p&gt;在团队内除了要有代码规范，所有人都要遵守，这样代码的风格才能更统一，和使用Lint工具去检查代码，各种语言lint工具，能在早期查检出你代码中不合理的地方。还有下面一些办法&lt;/p&gt;
&lt;h3 id=&quot;功能模块化&quot;&gt;功能模块化&lt;/h3&gt;
&lt;p&gt;程序员最喜欢的就是编码实现具体的功能，在这里才是我们真正秀内功的地方，可以应用各种模式把代码和逻辑写的很漂亮，但是放到整个项目结构里，被调用和使用的过程又感觉那么的不协调，根源是我们模块划分不正确，模块之间的依赖耦合性太强。&lt;br/&gt;
这就是典型的&lt;strong&gt;写的很优雅，使用的很粗糙&lt;/strong&gt;。依赖倒置原则，依然适用于模块间的划分，模块与模块之间的依赖是倒置的，用依赖注入的方式去解耦，模块对外暴露出尽可能少的接口，之间的调用依赖于接口。抽象的好处能让你把模块的边界定义的更明确。&lt;/p&gt;
&lt;h3 id=&quot;对象之间是协作关系不是纠缠&quot;&gt;对象之间是协作关系，不是纠缠&lt;/h3&gt;
&lt;p&gt;业务越复杂，需要操作的对象也就越多，对象的边界不明确就会出现纠缠不清的情况，要不就是一个对象负责的东西过多；要不就是几个对象同时做一件事，逻辑杂乱。&lt;br/&gt;
当你发现你的对象之前不再是协作关系时就要停下来，从高处去看你组织的代码，把大对象分解，职责界线理清楚也就是&lt;strong&gt;功能单一原则&lt;/strong&gt;，很多同学不知道如何确定一个对象的职责，不清楚一个属性是不是属于某个对象，最简单的方法就是，判断这个属性的变动会不影响某个对象，如果没有就不属于这个对象。&lt;br/&gt;
还有就是，面对新的业务需求&lt;strong&gt;敢于打破原有的代码设计，不破不立。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;不要过度开发删除没用的代码&quot;&gt;不要过度开发，删除没用的代码&lt;/h3&gt;
&lt;p&gt;定期要检查和删除没用的代码。少写或者不写感觉未来可能会用到的方法，这些多出来的代码会成为将来重构的绊脚石，会浪费精力在这些没有用到的代码上，查找有没有地方在使用他。&lt;/p&gt;
&lt;h3 id=&quot;solid-原则&quot;&gt;SOLID 原则&lt;/h3&gt;
&lt;p&gt;不能不提的，就是Bob大叔（Robert C. Martin）的SOLID编码原则，他是设计模式的基石，要不断的去应用和实践。&lt;br/&gt;
随着编码时间的增长，越来越感觉SOLID真的是一盏明灯，当你在黑暗中找不到方向的时候，指引你回归正确的道路。&lt;br/&gt;
如果你对SOLID原则应用的比较熟练，我上面说的几项完全都可以忽略。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单一职责原则(Single Responsibility Principle)&lt;br/&gt;
每个对象只有一个职责，明确对象的边界,文章上面说的对象之间是协作关系，不是纠缠里就说过如何确定一个属性是否属于某个对象。&lt;/li&gt;
&lt;li&gt;开闭原则(Open Closed Principle)&lt;br/&gt;
即可扩展(extension)，不可修改(modification)原则，抽取出代码中不变的逻辑，封装可变的代码，&lt;br/&gt;
策略模式就很好的表达这个原则的模式，可以查看之前的博客: &lt;a href=&quot;https://www.cnblogs.com/li-peng/archive/2013/02/18/2915594.html&quot; target=&quot;_blank&quot;&gt;策略模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;里氏替换原则(Liskov Substitution Principle)&lt;br/&gt;
继承必须确保超类所拥有的性质在子类中仍然成立，里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。关于里氏替换原则的例子，最有名的是“正方形不是长方形&lt;/li&gt;
&lt;li&gt;接口隔离原则(Interface Segregation Principle)&lt;br/&gt;
尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含调用方感兴趣的方法，这也是我们把复杂功能分模块的应用法则。&lt;br/&gt;
接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，但两者是不同的：&lt;br/&gt;
单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。&lt;br/&gt;
单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。&lt;/li&gt;
&lt;li&gt;依赖倒置原则(Dependence Inversion Principle)&lt;br/&gt;
抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对抽象（接口）编程，而不是针对实现细节编程。上面在说改进架构的时候有说这个原则&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体的代码示例这篇帖子就不写了。&lt;br/&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/342595/202201/342595-20220107144429253-693163030.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;被bob大叔指到的你，一定能写出更完美的代码&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;重构代码&quot;&gt;重构代码&lt;/h3&gt;
&lt;p&gt;新功能的开发的同时要重构之前逻辑，坚持开闭原则，能达到事半功倍的效果。&lt;br/&gt;
工作闲暇时间去浏览现有的代码逻辑，我们每天都在成长，对系统的认知也在改变，思维方式也在不断的变化，用现在的眼光去审视旧的代码逻辑，大多数是能找可以优化的地方，或者隐藏的bug，重构他，不要以为这些只是一些挤牙膏式的调优，所有的事情都有一个从质变到量变的过程。&lt;/p&gt;
&lt;h2 id=&quot;代码评审code-review&quot;&gt;代码评审(code review)&lt;/h2&gt;
&lt;p&gt;代码评审在团队里还是很有必要的，代码评审不是口水战，也不是批斗大会，如果只是走形式code review的意义也就不存在了。&lt;br/&gt;
你写的代码是需要让团队的成员能看明白的，将来也是会有新的员工来维护你写的功能的，code review是一个能让团队内的其他成员快速了解新代码意图的办法。&lt;br/&gt;
大多数团队里程序员的水平参差不齐的，对业务和系统的理解深度也是不一样的，让团队内不同的人去code review能及时发现代码中的不足之处，哪些地方逻辑上有问题，哪里的业务没有考虑全面。&lt;br/&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/342595/202201/342595-20220107144445467-1134347927.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当一次提交的代码太多时，一下子是看不完，也可能理解不了，就要很评审整体思路，再review实现主干逻辑，最后才是实现细节。&lt;br/&gt;
需说明一下的是，&lt;strong&gt;code review 并不能完全发现代码中隐藏的bug，不要把找bug的任务和他混在一起。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;学习多少构架或者框架知识，都不能阻止我们写烂代码。但当你沉下心来去打磨产品或者认真去实现一个功能时，你会在意你写的代码，会主动去写更清晰的逻辑，并改变和想办法去并处理糟糕的代码，希望这篇帖子有能帮助到你的地方。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>