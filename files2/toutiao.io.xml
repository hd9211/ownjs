<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b93b512443ed8f91b10007c6fa41f47e</guid>
<title>秋天的第一份 IT 技术周刊 | 码农周刊第 320 期</title>
<link>https://toutiao.io/k/9ew44gv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;秋天的第一份 IT 技术周刊 | 码农周刊第 320 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第320期（2020-09-29）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3200&quot; target=&quot;_blank&quot;&gt;秋天的第一份 IT 技术周刊，请查收！&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3200&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_320.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;思考和实践&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;由 JavaScript 之父 Brendan Eich 与 ES6 规范首席作者 Allen Wirfs-Brock 联合编写，详细记载和解读了自 1995 年语言诞生到 2015 年 ES6 规范制定为止，共计 20 年的 JavaScript 语言演化经历。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;支持 mp4, flv, m3u8 及 rtmp 协议的直播，支持移动端，PC 端。&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;利器&lt;/p&gt;
        
        &lt;p&gt;实打实的干货&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;容易踩的坑&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;细致分析&lt;/p&gt;
        
        &lt;p&gt;方案和思路&lt;/p&gt;
        
        &lt;p&gt;一些实践和工具&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;报告详情&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;深入探讨&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;java相关技术分享&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 444692 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 444414 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 435415 即可&lt;/p&gt;
        
        &lt;p&gt;不定期更新一些机器学习算法，方便大家浏览，然后一起学习，一起进步&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 104739 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 99181 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;本书深入地讲解了 Go 语言常见特性的内部机制和实现方式，大部分内容源自对 Go 语言源码的分析，并从中提炼出实现原理。欢迎到&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;兑换阅读。&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;值得推荐&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;无代码开发平台&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3be627fb58945f3f4e5b2dc36291db87</guid>
<title>缓存击穿导致 golang 组件死锁的问题分享</title>
<link>https://toutiao.io/k/f2baq90</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;  &lt;span mpa-is-content=&quot;t&quot;&gt;大纲&lt;/span&gt;  &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;思路排查&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Dump 堆栈很重要&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;关键思路&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;终于找到你&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;思路整理&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;发现蛛丝马迹&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;完整的推理流程&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;思考总结&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分享一个线上遇到的死锁问题，什么， golang 也会有死锁？&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;  &lt;span mpa-is-content=&quot;t&quot;&gt;思路排查&lt;/span&gt;  &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;Dump 堆栈很重要&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;线上某个环境发现 S3 上传请求卡住，请求不返回，卡了30分钟，长时间没有发现有效日志。一般来讲，死锁问题还是好排查的，因为现场一般都在。类似于 c 程序，遇到死锁问题都会用 pstack 看一把。golang 死锁排查思路也类似（golang 不适合使用 pstack，因为 golang 调度的是协程，pstack 只能看到线程栈），我们其实是需要知道 S3 程序里 goroutine 的栈状态。golang 遇到这个问题我们有两个办法：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;方法一：条件允许的话，gcore 出一个堆栈，这个是最有效的方法，因为是把整个 golang 程序的内存镜像 dump 出来，然后用 dlv 分析；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;方法二：如果你提前开启 net/pprof 库的引用，开启了 debug 接口，那么就可以调用 curl 接口，通过 http 接口获取进程的状态信息；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;需要注意到，golang 程序和 c 程序还是有点区别，goroutine 非常多，成百上千个 goroutine 是常态，甚至上万个也不稀奇。所以我们一般无法在终端上直接看完所有的栈，一般都是把所有的 goroutine 栈 dump 到文件，然用 vi 打开慢慢分析。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;调试这个 core 文件，意图从堆栈里找到些东西，由于堆栈太多了，所以就使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;gorouties -t -u&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  这个命令，并且把输出 dump 到文件；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;curl xxx/debug/pprof/goroutine&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;关键思路&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;成千上万个 goroutine ，直接显示到终端是不合适的，我们 dump 到文件 test.txt，然后分析 test.txt 这个文件。&lt;strong&gt;去查找发现了一些可疑堆栈，那么什么是可疑堆栈？重点关注加锁等待的堆栈，关键字是 &lt;/strong&gt;&lt;strong&gt;&lt;code&gt;runtime_notifyListWait&lt;/code&gt; 、&lt;code&gt;semaphore&lt;/code&gt; 、&lt;code&gt;sync.(*Cond).Wait&lt;/code&gt; 、&lt;code&gt;Acquire&lt;/code&gt;  这些阻塞场景才会用到的，如果业务堆栈上出现这个加锁调用，就非常可疑。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;划重点&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;留意阻塞关键字 &lt;/span&gt;&lt;code&gt;&lt;span&gt;runtime_notifyListWait&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 、&lt;/span&gt;&lt;code&gt;&lt;span&gt;semaphore&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 、&lt;/span&gt;&lt;code&gt;&lt;span&gt;sync.(*Cond).Wait&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 、&lt;/span&gt;&lt;code&gt;&lt;span&gt;Acquire&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;业务堆栈（非 runtime 的一些内部堆栈）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2344944774851317&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChPvYG5CqzKLibTDPC61D7Z7mRMAJiaxsZkialT2VhJyvKeuQSyz8QCxC9jt9Lrw4Zc5L7ibFYXJXklr0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1177&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;统计分析发现，有 11 个这个堆栈都在这同一个地方，都是在等同一把锁 &lt;/span&gt;&lt;code&gt;&lt;span&gt;blockingKeyCountLimit.lock&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，所以基本确认了阻塞的位置，就是这个地方阻塞到了所有的请求，但是这把锁我们使用 defer 释放的，使用姿势如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;lock.Acquire(key)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;defer&lt;/span&gt; lock.Release(key)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;blockingKeyCountLimit 是我们封装针对 key 操作流控的组件。举个例子，如果 limit == 1，key为 &quot;test&quot; 在 g1 上 Acquire 成功，g2 acquire(&quot;test&quot;) 就会等待，这个可以算是我们优化的一个逻辑。如果 limit == 2，那么就允许两个人加锁到，后面的人都等待。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从代码来看，函数退出一定会释放的，但是偏偏现在锁就卡在这个地方，所以就非常奇怪。我们先找哪个 goroutine 占着这把锁不释放，看看能不能搞清楚怎样导致这里抢不到锁的原因。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过审查业务代码分析，发现可能的源头函数（这个函数是向后端请求的函数）：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sh&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;api.(*Client).getBytesNolc&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;确认是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;getBytesNolc&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  这个函数执行的操作，那么大概率就是卡在这个地方了。用这个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;getBytesNolc&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 字符串搜索堆栈，找下是哪个堆栈 ？搜索到这个堆栈 &lt;/span&gt;&lt;code&gt;&lt;span&gt;goroutine 19458&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.28203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChPvYG5CqzKLibTDPC61D7Z7mGuDUCia2SWjhfXJznNKLy4oAx3txjUhibUyjOiczU8fVMHbDsa9TRvamA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大概率就是第 1 个堆栈了，也就是其他的 11 个 goroutine 都在等这 &lt;/span&gt;&lt;code&gt;&lt;span&gt;goroutine 19458&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  来放锁，仔细看这个堆栈。那么为啥这个堆栈不放锁呢？这里有个细节要注意下，这里是卡到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;gihub.com/golang/groupcache/singleflight/singleflight.go:48&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 这一行：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5752508361204013&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChPvYG5CqzKLibTDPC61D7Z7mLtg6p9VePicLmbNNbjgJTKHibQkAvweT9afp9DcWUkWfxcBJX4ntK4Xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;897&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;终于找到你&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这是一个开源库，singleflight 实现了缓存防击穿的功能。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;简单减少下 singleflight 的功能，这是一个非常有效的工具。在缓存大量失效的场景，如果针对同一个 key ，其实只需要有一个人穿透到后端请求数据，其他人等待他完成，然后取缓存结果即可。这个就是 singleflight 实现的功能。具体实现就是：来了请求之后，把 key 插入到 map 里，后面的请求如果发现同名 key 在 map 里面，那么就等待它完成就好；&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;截屏显示卡到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;c.wg.Wait()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  这一行，那么说明 map 里面肯定有已经存在的 key，说明 &lt;/span&gt;&lt;code&gt;&lt;span&gt;goroutine 19458&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  不是第一个人？但是外面还有一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;blockingKeyCountLimit&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的互斥呢，按道理其他的人也进不来（因为 limit == 1），这里这么讲来肯定要是源头才对？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;思路整理&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;伪代码显示如下&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;xxx&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    limitLocker.Acquire( key )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;defer&lt;/span&gt; limitLocker.Release( key )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    getBytesNolc( key , ...)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;getBytesNolc&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ret, err = x.Group.Do(id, &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    })&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;图示显示当前的现状&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.65234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChPvYG5CqzKLibTDPC61D7Z7mQrribV3oQPtonTYjfpIcIJSLwrMgEIf1SWMcZgviaFAh4TsiaU7Te8AQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;span/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现状小结：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;大量的协程都在等 &lt;/span&gt;&lt;code&gt;&lt;span&gt;blockingKeyCountLimit&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 这把锁释放；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;协程 &lt;/span&gt;&lt;code&gt;&lt;span&gt;goroutine 19458&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 持有 &lt;/span&gt;&lt;code&gt;&lt;span&gt;blockingKeyCountLimit&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 这把锁；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;协程 &lt;/span&gt;&lt;code&gt;&lt;span&gt;goroutine 19458&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  却在等一个相同 key 名字的任务的完成（ singleflight 一个防击穿的库，同一时间相同 key 只允许放到一个后端去执行），却永远没等到，协程因此呈现死锁；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当前的疑问就是第一个 key 的任务为啥永远完不成，堆栈也找不到了，去哪里了？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;发现蛛丝马迹&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们再仔细审一下 singleflight 的代码：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(g *Group)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Do&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(key &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;, fn &lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;) &lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    g.mu.Lock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; g.m == &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        g.m = &lt;span class=&quot;code-snippet__built_in&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;]*call)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; c, ok := g.m[key]; ok {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        g.mu.Unlock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        c.wg.Wait()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; c.val, c.err&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    c := &lt;span class=&quot;code-snippet__built_in&quot;&gt;new&lt;/span&gt;(call)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    c.wg.Add(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    g.m[key] = c&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    g.mu.Unlock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    c.val, c.err = fn()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    c.wg.Done()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    g.mu.Lock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;delete&lt;/span&gt;(g.m, key)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    g.mu.Unlock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; c.val, c.err&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;发现有个线索，我们的 S3 服务程序一个 http 请求对应一个协程处理，为了提高服务端进程的可用性，在框架里会捕捉 panic，这样确保单个协程处理不会影响到其他的请求。基于这个前提，我们假设：如果 &lt;/span&gt;&lt;code&gt;&lt;span&gt;fn()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 执行异常，panic 掉了，那么就不会走 &lt;/span&gt;&lt;code&gt;&lt;span&gt;delete(g.m, key)&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的代码，那么 key 就永远都残留在 map 里面，而进程却又还活着。恍然大悟。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;完整的推理流程&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一个协程 g1 来了，加了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;blockingKeyCountLimit&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  锁，然后准备穿透到后端，调用函数 &lt;/span&gt;&lt;code&gt;&lt;span&gt;getBytesNolc&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  获取数据，并走进了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;singlelight&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ，添加了一个 key：x， 准备干活；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;干活发生了一些不可预期的异常（后面发现是配置的异常），nil 指针引用之类的， panic 堆栈了，panic 导致后面 delete key 操作没有执行；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;虽然 g1 现在 panic 了，但是由于在函数 func xxx 里面 &lt;/span&gt;&lt;code&gt;&lt;span&gt;blockingKeyCountLimit&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是 defer 执行的，所以这把锁还是，但是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;singlelight&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的 key 还存在，于是残留在 map 里面；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;但是由于我们服务程序为了高可用是 recover 了 panic 的，单个请求的失败不会导致整个进程挂掉，所以进程还是好好的；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;goroutine 19458&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  协程来了，&lt;/span&gt;&lt;code&gt;&lt;span&gt;blockingKeyCountLimit&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  加锁，然后走到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;singlelight&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  的时候，发现有 key: x 了，于是就等待；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;并且等待的是一个永远得不到的锁，因为 g1 早就没了；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;后续的 11 个 协程来了，于是被 &lt;/span&gt;&lt;code&gt;&lt;span&gt;blockingKeyCountLimit&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  阻塞住，并且永远不能释放；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实锤：后续基于这个猜想，再去搜索一遍日志，发现确实是有一条 panic 相关的日志。这个时间点后面的请求全部被卡住。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;  &lt;span mpa-is-content=&quot;t&quot;&gt;思考总结&lt;/span&gt;  &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一般来讲 c 语言写程序容易出现死锁问题，因为各种异常逻辑可能会导致忘记放锁，从而导致抢一个永远都不可能得到的锁。&lt;strong&gt;golang 为了解决这个问题，一般是用 defer 机制来实现&lt;/strong&gt;，使用姿势如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    mtx.Lock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;defer&lt;/span&gt; mtx.Unlock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;golang 的 defer 机制是一个经过经验沉淀下来的有效功能。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我们必须要合理使用。defer 实现原理是和所在函数绑定，保证函数 return 的时候一定能调用到（ panic 退出也能），所以 golang 加锁放锁的有效实践是写在相邻的两行。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实思考下，&lt;strong&gt;singleflight 作为一个通用开源库，其实可以把 delete map key 放到 defer 里，这样就能保证 map 里面的 key 一定是可以被清理的&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;还有一点，&lt;strong&gt;其实 golang 是不提倡异常-捕捉这样的方式编程&lt;/strong&gt;，panic 一般不让随便用，如果真是严重的问题，挂掉就挂掉，这个估计还好一些。当然这是要看场景的，还是有一些特殊场景的，毕竟 golang 都已经提供了 panic-recover 这样的一个手段，就说明还是有需求。这个就跟 unsafe 库一样，你只有明确知道自己的行为影响，才去使用这个工具，否则别用。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;精彩推荐&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;amp;mid=2247484698&amp;amp;idx=1&amp;amp;sn=22c169cb21335cdf783ba257da31aec8&amp;amp;chksm=eb310495dc468d83a3791ddca2ae98112af324e4d4f3a29d39f083ff784216b530b780638c40&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Docker 镜像分析利器 dive&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;amp;mid=2247484598&amp;amp;idx=1&amp;amp;sn=ea91646ad078518e9ffbc39994abe424&amp;amp;chksm=eb310539dc468c2f81bc79f2ff55e3e8e314506137746ed6bb785420d9ee49f1a289a67897d6&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Go语言 | 基于channel实现的并发安全的字节池&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;amp;mid=2247484563&amp;amp;idx=1&amp;amp;sn=eb82f5596c2938fd9e94b030e3a9e436&amp;amp;chksm=eb31051cdc468c0a88ed0066eef48d77fe40b89b94651a29ae2071af02e261f0bb1d0f4bfc8d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Go语言 | 从并发模式看channel使用技巧&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;amp;mid=2247483773&amp;amp;idx=1&amp;amp;sn=e893cfca13b7edc0b1eeda0e343a82b5&amp;amp;chksm=eb3100f2dc4689e4dea21d7e3143acc52f775e2603efe2eb2f45371d6104242c4912b24dcbe0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《Go语言实战》笔记(十六) | Go并发示例-Pool&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;amp;mid=2247483771&amp;amp;idx=1&amp;amp;sn=52d0d44ecad893f0c3d7f59b15d62a62&amp;amp;chksm=eb3100f4dc4689e2681300b0830977193f3a35ca20e6c9ab758085c7e7679e764a367f3b2c22&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《Go语言实战》笔记(十五) | Go并发示例-Runner&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;amp;mid=2247483767&amp;amp;idx=1&amp;amp;sn=abb360ced1c969aed2aaa7fcc31ce275&amp;amp;chksm=eb3100f8dc4689eeccb7cf9b3cd2274be938fc3f65a40c9b445eb51e646a8da553f8cee2b371&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《Go语言实战》笔记(十三) | Go 并发资源竞争&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3649122807017544&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yGKTjJdYkkvuj8z0lDLzibibzK119ljw0Aq61ZDMUp0U6LG9Fhqo9c3rlrGUDGqfosib1ptkqYBDV4uYlOUEktQAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1710&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>db296051e3d4bd75fb9ce3089fce4847</guid>
<title>[译] 使用 Paging 3 实现分页加载</title>
<link>https://toutiao.io/k/xbgx43m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;&lt;i&gt;作者 / Florina Muntenescu&lt;/i&gt;&lt;/p&gt;&lt;p&gt;Paging 库可以帮助您优雅地渐进加载大型数据集合，同时也可以减少网络的使用和系统资源的消耗。基于您的反馈我们得知，Paging 2.0 API 还不能满足开发者们的需求——开发者们希望以更简便的方式处理错误；以更灵活的方式实现列表数据的转换操作，例如 map 和 filter；以及支持分割符、页眉和页脚。基于以上反馈，我们推出了 Paging 3.0。这是一个完全使用 Kotlin 协程重写的库 (依然支持 Java 用户)，它将为您提供您所要求的功能。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Paging 3 亮点&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Paging 3 的 API 对分页加载时可能需要实现的常见功能提供了支持:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;跟踪获取前一页或后一页所需要的参数；&lt;/li&gt;&lt;li&gt;当用户滚动到现有数据的末尾时，自动请求正确的下一页；&lt;/li&gt;&lt;li&gt;确保不会同时触发多个请求；&lt;/li&gt;&lt;li&gt;跟踪加载状态，并支持您在 RecyclerView 的列表项或者界面中的其他地方展示它。为失败的加载提供简便的重试功能；&lt;/li&gt;&lt;li&gt;无论您是否使用 Flow、LiveData、RxJava Flowable 或 Observable，都可以对需要展示的列表使用 map 或 filter 这类常见的操作；&lt;/li&gt;&lt;li&gt;提供实现列表分隔符的简便方法；&lt;/li&gt;&lt;li&gt;简化了数据缓存，确保不会让您在每次配置更改时都执行数据转换。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们还让 Paging 3 的一些组件向后兼容 Paging 2.0。因此，如果您已经在应用中使用了 Paging，则可以逐步 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/topic/libraries/architecture/paging/v3-migration&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;迁移至 Paging 3&lt;/a&gt;&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;在您的应用中使用 Paging 3&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;假设我们正在实现一个展示所有狗狗的应用。狗狗的数据从 GoodDoggos API 获得，该 API 支持基于索引的分页。让我们研究下需要实现的 Paging 组件，以及如何将 Paging 集成到现有的应用架构。接下来的例子将使用 Kotlin 及其协程功能编写，如果您需要使用 LiveData/RxJava 实现的 Java 编程语言示例，请参阅 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/topic/libraries/architecture/paging/v3-overview&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Android 开发者文档 | Paging 3 库概述&lt;/a&gt;&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;下图为您应用的各个层级中推荐直接接入 Paging 的 Android 应用架构:&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9bd724bce134d49281f92753e59f0804_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1600&quot; data-rawheight=&quot;445&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-9bd724bce134d49281f92753e59f0804_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1600&quot; data-rawheight=&quot;445&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-9bd724bce134d49281f92753e59f0804_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-9bd724bce134d49281f92753e59f0804_b.jpg&quot;/&gt;&lt;figcaption&gt;Paging 组件及其在应用架构的集成&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;&lt;b&gt;定义数据源&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;数据源的定义取决于您从哪里加载数据。您仅需实现 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/paging/PagingSource&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PagingSource&lt;/a&gt;&lt;/b&gt; 或者 PagingSource 与 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/paging/RemoteMediator&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;RemoteMediator&lt;/a&gt;&lt;/b&gt; 的组合:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如果您从 &lt;b&gt;单个源&lt;/b&gt; 加载数据，例如网络、本地数据、文件等，实现 PagingSource 即可，如果您使用了 &lt;b&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/111267510&quot; class=&quot;internal&quot;&gt;Room&lt;/a&gt;&lt;/b&gt;，从 2.3.0-alpha 开始，它将默认为您实现 Paging Source，请参见:&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/data-storage/room/accessing-data%23paging-integration&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt; Android 开发文档｜使用 Room DAO 访问数据&lt;/a&gt;&lt;/b&gt;；&lt;/li&gt;&lt;li&gt;如果您从一个 &lt;b&gt;多层级数据源&lt;/b&gt; 加载数据，就像带有本地数据库缓存的网络数据源那样。那么您需要实现 RemoteMediator 来合并两个数据源到一个本地数据库缓存的 PagingSource 中。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;PagingSource&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/paging/PagingSource&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PagingSource&lt;/a&gt;&lt;/b&gt; 可以定义一个分页数据的数据源，以及从该数据源获取数据的方式。PagingSource 应当为资源库层的一部分。您可以实现 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/paging/PagingSource%23load&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;load()&lt;/a&gt;&lt;/b&gt; 函数来从数据源获取分页数据，并返回加载好的数据和加载前后页的参数信息。load() 是一个挂起函数，您可以在这里调用其他的 &lt;b&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/145001592&quot; class=&quot;internal&quot;&gt;挂起函数&lt;/a&gt;&lt;/b&gt;，例如网络请求:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;class DoggosRemotePagingSource(
    val backend: GoodDoggosService
) : PagingSource&amp;lt;Int, Dog&amp;gt;() {
  override suspend fun load(
    params: LoadParams&amp;lt;Int&amp;gt;
  ): LoadResult&amp;lt;Int, Dog&amp;gt; {
    try {
      // 未定义时加载第 1 页
      val nextPageNumber = params.key ?: 1
      val response = backend.getDoggos(nextPageNumber)
      return LoadResult.Page(
        data = response.doggos,
        prevKey = null, // 仅向后翻页
        nextKey = response.nextPageNumber + 1
      )
    } catch (e: Exception) {
        // 在此块中处理错误
        return LoadResult.Error(exception)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;PagingData 与 Pager&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;分页数据的容器被称为 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/paging/PagingData&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PagingData&lt;/a&gt;&lt;/b&gt;，每次刷新数据时，都会创建一个 PagingData 的实例。如果要创建 PagingData 数据流，您需要创建一个 Pager 实例，并提供一个 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/paging/PagingConfig&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PagingConfig&lt;/a&gt;&lt;/b&gt; 配置对象和一个可以告诉 Pager 如何获取您实现的 PagerSource 的实例的函数，以供 Pager 使用。&lt;/p&gt;&lt;p&gt;您要在 ViewModel 中构造 Pager 对象并向 UI 暴露一个 Flow。Flow 有一个方便的 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/paging/package-summary%23cachedin&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;cachedIn()&lt;/a&gt;&lt;/b&gt; 方法，该方法使得数据流可以被共享，也让您可以在 CoroutineScope 中缓存 Flow 的内容。这样一来，如果您在数据流中实现了任何转换操作，当 Activity 被重建并使得您从 flow 中获取数据时，不会再次触发这些操作。由于我们希望数据在配置产生变化后仍然存在，缓存应当尽可能靠近 UI 层，但又不能在 UI 层中，那么最好的位置便是在 &lt;b&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/143346337&quot; class=&quot;internal&quot;&gt;ViewModel&lt;/a&gt;&lt;/b&gt; 中，并使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/lifecycle/package-summary%23viewmodelscope&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;viewModelScope&lt;/a&gt;&lt;/b&gt;:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;val doggosPagingFlow = Pager(PagingConfig(pageSize = 10)) {
  DogRemotePagingSource(goodDoggosService)
}.flow.cachedIn(viewModelScope)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;PagingDataAdapter&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;为了将 RecyclerView 与 PagingData 联系起来，您需要实现一个 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/paging/PagingDataAdapter&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PagingDataAdapter&lt;/a&gt;&lt;/b&gt;:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;class DogAdapter(diffCallback: DiffUtil.ItemCallback&amp;lt;Dog&amp;gt;) :
  PagingDataAdapter&amp;lt;Dog, DogViewHolder&amp;gt;(diffCallback) {
  override fun onCreateViewHolder(
    parent: ViewGroup,
    viewType: Int
  ): DogViewHolder {
    return DogViewHolder(parent)
  }

  override fun onBindViewHolder(holder: DogViewHolder, position: Int) {
    val item = getItem(position)
    if(item == null) {
      holder.bindPlaceholder()
    } else {
      holder.bind(item)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来，在您的 &lt;code&gt;Activity/Fragment&lt;/code&gt; 中，您需要收集 &lt;code&gt;Flow&amp;lt;PagingData&amp;gt;&lt;/code&gt; 并将其提交给 &lt;code&gt;PagingDataAdapter&lt;/code&gt;。下面是一个在 &lt;code&gt;Activity&lt;/code&gt; 的 &lt;code&gt;onCreate()&lt;/code&gt; 函数中实现该操作的示例:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;val viewModel by viewModels&amp;lt;DoggosViewModel&amp;gt;()

val pagingAdapter = DogAdapter(DogComparator)
val recyclerView = findViewById&amp;lt;RecyclerView&amp;gt;(R.id.recycler_view)
recyclerView.adapter = pagingAdapter

lifecycleScope.launch {
  viewModel.doggosPagingFlow.collectLatest { pagingData -&amp;gt;
    pagingAdapter.submitData(pagingData)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;分页数据转换&lt;/b&gt;&lt;/h3&gt;&lt;figure data-size=&quot;small&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-94292e2cec2fc62945baabca0f8019e6_b.jpg&quot; data-size=&quot;small&quot; data-rawwidth=&quot;668&quot; data-rawheight=&quot;1314&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-94292e2cec2fc62945baabca0f8019e6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;668&quot; data-rawheight=&quot;1314&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-94292e2cec2fc62945baabca0f8019e6_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-94292e2cec2fc62945baabca0f8019e6_b.jpg&quot;/&gt;&lt;figcaption&gt;展示一个过滤后的列表&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;转换 PagingData 流与您在其他数据流中所做的同类操作相似。举例来说，如果我们只想要展示 Flow&amp;lt;PagingData&amp;gt; 中那些调皮的狗狗，我们可能需要映射 Flow 对象并过滤 PagingData:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;doggosPagingFlow.map { pagingData -&amp;gt;
        pagingData.filter { dog -&amp;gt; dog.isPlayful }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure data-size=&quot;small&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ee9eac1129aed9f3955ddae7004ce397_b.jpg&quot; data-size=&quot;small&quot; data-rawwidth=&quot;668&quot; data-rawheight=&quot;1318&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-ee9eac1129aed9f3955ddae7004ce397_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;668&quot; data-rawheight=&quot;1318&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-ee9eac1129aed9f3955ddae7004ce397_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-ee9eac1129aed9f3955ddae7004ce397_b.jpg&quot;/&gt;&lt;figcaption&gt;有分隔符的列表&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;向列表中添加 &lt;b&gt;分隔符&lt;/b&gt; 同样是分页数据转换，这里我们通过转换 PagingData 向列表中插入分隔对象。举例来说，我们可以为狗狗的名字插入字母分隔符。当使用分隔符时，您需要自己实现 UI 模型类以支持新的分隔项。当您修改 PagingData 并插入分隔符时，您会用到 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/paging/PagingData%23insertseparators&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;insertSeparators&lt;/a&gt;&lt;/b&gt; 转换:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;pager.flow.map { pagingData: PagingData&amp;lt;Dog&amp;gt; -&amp;gt;
  pagingData.map { doggo -&amp;gt;
    // 将数据流中的项目转换为 UiModel.DogModel。
    UiModel.DogModel(doggo)
  }
  .insertSeparators&amp;lt;UiModel.DogModel, UiModel&amp;gt; { before: Dog, after: Dog -&amp;gt;
      return if(after == null) {
       // 我们到了列表的末尾
          null
      } else if (before == null || before.breed != after.breed) {
          // 上下品种不同，显示分隔符
          UiModel.SeparatorItem(after.breed)
      } else {
          // 无分隔符
          null
      }
    }
  }
}.cachedIn(viewModelScope)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;就像前面一样，我们会在数据到达 UI 层之前使用 cachedIn，这样便可以缓存所有已经加载的数据以及数据转换的结果。当配置发生改变时，这些缓存就会被复用。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;使用 RemoteMediator 进行高级分页操作&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;当您从一个 &lt;b&gt;多层级数据源&lt;/b&gt; 加载数据时，应当实现一个 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/paging/RemoteMediator&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;RemoteMediator&lt;/a&gt;&lt;/b&gt;。举例来说，在此类的实现中，您应当从网络请求数据并存入数据库。每当数据库中没有数据可以被展示时，就会触发 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/paging/RemoteMediator%23load&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;load()&lt;/a&gt;&lt;/b&gt; 方法。基于 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/paging/PagingState&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PagingState&lt;/a&gt;&lt;/b&gt; 和 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/paging/LoadType&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;LoadType&lt;/a&gt;&lt;/b&gt;，我们可以构造下一页的数据请求。&lt;/p&gt;&lt;p&gt;由于 Paging 库并不知道您的 API 是怎样的，所以定义如何构造和获取前一页和下一页的远程数据的工作便需要由您自己来完成。举例来说，您可以将您从网络接收到的每个项目与远程关键字关联起来并存入数据库。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;override suspend fun load(loadType: LoadType, state: PagingState&amp;lt;Int, Dog&amp;gt;): MediatorResult {

   val page = ...  // 基于 loadType 和 state 进行计算

   try {
       val doggos = backend.getDoggos(page)
       doggosDatabase.doggosDao().insertAll(doggos)

       val endOfPaginationReached = emails.isEmpty()
       return MediatorResult.Success(endOfPaginationReached = endOfPaginationReached)
   } catch (exception: Exception) {
       return MediatorResult.Error(exception)
   } 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果您从网络请求数据并存入数据库，那么数据库才是屏幕上所展示数据的真正数据源——这意味着 UI 会展示从数据库获取的数据，所以您需要为您的数据库实现 PagingSource。如果您正在使用 Room，那么您只需要向您的 DAO 添加一个返回 PagingSource 的查询:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@Query(&quot;SELECT * FROM doggos&quot;)
fun getDoggos(): PagingSource&amp;lt;Int, Dog&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种情况下 Pager 的实现略有不同，您还需要传入 RemoteMediator 实例:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;val pagingSourceFactory = { database.doggosDao().getDoggos() }

return Pager(
     config = PagingConfig(pageSize = NETWORK_PAGE_SIZE),
     remoteMediator = DoggosRemoteMediator(service, database),
     pagingSourceFactory = pagingSourceFactory
).flow
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;您可以参阅文档了解 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/topic/libraries/architecture/paging/v3-network-db&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;使用 RemoteMediator&lt;/a&gt;&lt;/b&gt; 的详细信息。如果您需要 RemoteMediator 在应用中的完整实现，可以参阅 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//codelabs.developers.google.com/codelabs/android-paging/%2314&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Paging codelab&lt;/a&gt;&lt;/b&gt; 和 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/googlecodelabs/android-paging/blob/step13-19_network_and_database/app/src/main/java/com/example/android/codelabs/paging/data/GithubRemoteMediator.kt&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Paging 相关代码&lt;/a&gt;&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;我们将 Paging 3 设计为一个帮您涵盖简单和复杂情形下的分页加载的库。它可以让您更方便地使用大规模数据集合，无论数据来自网络、数据库、内存缓存还是上述几种情况的组合。Paging 库基于 &lt;b&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/140314207&quot; class=&quot;internal&quot;&gt;协程和 Flow&lt;/a&gt;&lt;/b&gt; 实现，使得它可以很简单地调用挂起函数并且处理数据流。&lt;/p&gt;&lt;p&gt;Paging 3 仍然处于 alpha 版本，我们需要您帮助我们进一步优化！请参阅以下资源开始使用 Paging:&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5ec8974ab1c60144c83aca23006d67ba</guid>
<title>初识 Linux 网络栈及常用优化方法</title>
<link>https://toutiao.io/k/xb2yc4g</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;文章简介&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于 ping 流程窥探 Linux 网络子系统，同时介绍各个模块的优化方法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ping 基本原理&lt;/span&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Client 端发送 ICMP ECHO_REQUEST 报文给 Server&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Server 端回应 ICMP ECHO_REPLY 报文给 Client&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这其中涉及基本的二三层转发原理，比如：直接路由、间接路由、ARP 等概念。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这部分不是本文重点，最基本的网络通信原理可以参考这篇文章：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ping 报文发送流程&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;系统调用层&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;sendmsg 系统调用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据目标地址获取路由信息，决定报文出口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ip_append_data()&lt;/code&gt; 函数构建 skb（这时才将报文从用户态拷贝到内核态），将报文放入 socket buffer&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;ip_push_pending_frames()&lt;/code&gt;，进入 IP 层处理&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;IP 层&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;填充 IP 头&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据 neighbour 信息，填充 MAC 头，调用 &lt;code&gt;dev_queue_xmit()&lt;/code&gt; 进入网络设备层&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;网络设备层&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;选择发送队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;__dev_xmit_skb()&lt;/code&gt; 尝试直接发送报文，如果网卡繁忙就将报文放入目标发送队列的 qdisc 队列，并触发 NET_TX_SOFTIRQ 软中断，在后续软中断处理中发送 qdisc 队列中的报文&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;驱动层发包函数，将 skb 指向的报文地址填入 tx descriptor，网卡发送报文&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发送完成后触发中断，回收 tx descriptor（实际实现中一般放在驱动 poll 函数中）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;优化点&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;socket buffer&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;应用程序报文首先放入 socket buffer，socket buffer 空间受 wmem_default 限制，而 wmem_default 最大值受 wmem_max 限制。&lt;/p&gt;&lt;p&gt;调整方法：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sysctl -w net.core.wmem_max=xxxxxx -- 限制最大值&lt;br/&gt;sysctl -w net.core.wmem_default=yyyyyy&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;qdisc 队列长度&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;经过网络协议栈到达网络设备层的时候，报文从 socket buffer 转移至发送队列 qdisc。&lt;/p&gt;&lt;p&gt;调整方法：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ifconfig eth0 txqueuelen 10000&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;qdisc 权重&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;即一次 NET_TX_SOFTIRQ 软中断最大发送报文数，默认64。&lt;/p&gt;&lt;p&gt;调整方法：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sysctl -w net.core.dev_weight=600&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;tx descriptor 数量&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;即，多少个发送描述符。&lt;/p&gt;&lt;p&gt;调整方法：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ethtool -G eth0 rx 1024 tx 1024&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;高级特性：TSO/GSO/XPS&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;TSO（TCP Segmentation Offload）：超过 MTU 大小的报文不需要在协议栈分段，直接由网卡分段，降低 CPU 负载。&lt;/p&gt;&lt;p&gt;GSO（Generic Segmentation Offload）：TSO 的软件实现，延迟大报文分段时机到 IP 层结束或者设备层发包前，不同版本内核实现不同。&lt;/p&gt;&lt;p&gt;开启方法：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ethtool -K eth0 gso on&lt;br/&gt;ethtool -K eth0 tso on&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;XPS（Transmit Packet Steering）：对于有多队列的网卡，XPS 可以建立 CPU 与 tx queue 的对应关系，对于单队列网卡，XPS 没啥用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开启方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;内核配置CONFIG_XPS&lt;br/&gt;建立cpu与发送队列映射：&lt;br/&gt;   &lt;span&gt;echo&lt;/span&gt; cpu_mask &amp;gt; /sys/class/net/eth0/queues/tx-&amp;lt;n&amp;gt;/xps_cpus&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ping 报文收取过程&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;驱动层&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;网卡驱动初始化，分配收包内存（ring buffer），初始化 rx descriptor&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网卡收到报文，将报文 DMA 到 rx descriptor 指向的内存，并中断通知 CPU&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CPU 中断处理函数：关闭网卡中断开关，触发 NET_RX_SOFTIRQ 软中断&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;软中断调用网卡驱动注册的 poll 函数，收取报文（著名的 NAPI 机制）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;驱动 poll 函数退出前将已经收取的 rx descriptor 回填给网卡&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;协议栈层&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;驱动层调用 &lt;code&gt;napi_gro_receive()&lt;/code&gt;，开始协议栈处理，对于 ICMP 报文，经过的处理函数：&lt;code&gt;ip_rcv()&lt;/code&gt; -&amp;gt; &lt;code&gt;raw_local_deliver()&lt;/code&gt; -&amp;gt; &lt;code&gt;raw_rcv()&lt;/code&gt; -&amp;gt; &lt;code&gt;__sock_queue_rcv_skb()&lt;/code&gt;&lt;/p&gt;&lt;p&gt;现在内核都使用 GRO 机制将驱动层 skb 上送协议栈，GRO 全称 Generic Receive Offload，是网卡硬件的 LRO 功能（Intel 手册使用 RSC 描述）的软件实现，可以将同一条流的报文聚合后再上送协议栈处理，降低 CPU 消耗，提高网络吞吐量。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;送入 socket buffer&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;基于 poll/epoll 机制唤醒等待 socket 的进程&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;应用读取报文&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从 socket buffer 的读取文，并拷贝到用户态&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;优化点&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;rx descriptor 长度&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;瞬时流量太大，软件收取太慢，rx descriptor 耗尽后肯定丢包。增大 rx descriptor 长度可以减少因为瞬时流量大造成的丢包。但是不能解决性能不足造成的丢包。&lt;/p&gt;&lt;p&gt;调整方法：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;查看 rx descriptor 长度：ethtool -g eth0&lt;br/&gt;调整 rx descriptor 长度：ethtool -G eth0 rx 1024 tx 1024&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;中断&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;为了充分利用多核 CPU 性能，高性能（现代）网卡一般支持多队列。配合底层 RSS（Receive-Side Scaling）机制，将报文分流到不同的队列。每个队列对应不同的中断，进而可以通过中断亲和性将不同的队列绑定到不同的 CPU。&lt;/p&gt;&lt;p&gt;PS：只有 MSI-X 才支持多队列/多中断。&lt;/p&gt;&lt;p&gt;调整方法：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;中断亲和性设置：&lt;span&gt;echo&lt;/span&gt; cpu_mask &amp;gt; /proc/irq/&amp;lt;irq_no&amp;gt;/smp_affinity&lt;br/&gt;查看队列数：ethtool -l eth0&lt;br/&gt;调整队列数：ethtool -L eth0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进阶：队列分流算法设置&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;NAPI&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;网卡中断中触发 NET_RX_SOFTIRQ 软中断，软中断中调用驱动 poll 函数，进行轮询收包。NAPI 的好处在于避免了每个报文都触发中断，避免了无意义的上下文切换带来的 Cache/TLB miss 对性能的影响。&lt;/p&gt;&lt;p&gt;但是 Linux 毕竟是通用操作系统，NAPI 轮询收包也要有限制，不能长时间收包，不干其他活。所以 NET_RX_SOFTIRQ 软中断有收包 budget 概念。即，一次最大收取的报文数。&lt;/p&gt;&lt;p&gt;收包数超过 netdev_budget（默认300）或者收包时间超过2个 jiffies 后就退出，等待下次软中断执行时再继续收包。驱动层 poll 收包函数默认一次收64个报文。&lt;/p&gt;&lt;p&gt;netdev_budget 调整方法：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sysctl -w net.core.netdev_budget=600&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;驱动层 poll 函数收包个数只能修改代码。一般不需要修改。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;开启高级特性 GRO/RPS/RFS&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;GRO（Generic Receive Offload）：驱动送协议栈时，实现同条流报文汇聚后再上送，提高吞吐量。对应 &lt;code&gt;napi_gro_receive&lt;/code&gt; 函数。&lt;/p&gt;&lt;p&gt;开启方法：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ethtool -K eth0 gro on&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RPS（Receive Packet Steering）：对于单队列网卡，RPS 特性可以根据报文 hash 值将报文推送到其它 CPU 处理（把报文压入其它 CPU 队列，然后给其它 CPU 发送 IPI 中断，使其进行收包处理），提高多核利用率，对于多队列网卡，建议使用网卡自带的 RSS 特性分流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RFS（Receive Flow Steering）：RFS 在 RPS 基础上考虑了报文流的处理程序运行在哪个 CPU 上的问题。比如报文流 A 要被运行在 CPU 2 的 APP A 处理，RPS 特性会根据报文 hash 值送入 CPU 1，而 RFS 特性会识别到 APP A 运行在 CPU 2 信息，将报文流 A 送入CPU 2。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;PS：&lt;/strong&gt; RFS 的核心是感知报文流的处理程序运行在哪个 CPU，核心原理是在几个收发包函数（&lt;code&gt;inet_recvmsg()&lt;/code&gt;, &lt;code&gt;inet_sendmsg()&lt;/code&gt;, &lt;code&gt;inet_sendpage()&lt;/code&gt;、&lt;code&gt;tcp_splice_read()&lt;/code&gt;）中识别并记录不同报文流的处理程序运行在哪个CPU。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RPS 开启方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;echo&lt;/span&gt; cpu_mask &amp;gt; /sys/class/net/eth0/queues/rx-0/rps_cpus&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RFS 设置方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sysctl -w net.core.rps_sock_flow_entries=32768&lt;br/&gt;&lt;span&gt;echo&lt;/span&gt; 2048 &amp;gt; /sys/class/net/eth0/queues/rx-0/rps_flow_cnt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;PS：&lt;/strong&gt; RFS 有些复杂，这里只说举例配置，不讲述原理（其实就是不会。。。）&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;socket buffer&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;__sock_queue_rcv_skb()&lt;/code&gt; 中会将 skb 放入 socket buffer，其中会检查 socket buffer 是否溢出。所以要保证 socket buffer 足够大。&lt;/p&gt;&lt;p&gt;设置方法：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sysctl -w net.core.rmem_max=xxxxxx -- 限制最大值&lt;br/&gt;sysctl -w net.core.rmem_default=yyyyyy&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考文档&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;scaling:&lt;/span&gt; &lt;span&gt;👉&lt;/span&gt;&lt;span&gt;https://github.com/torvalds/linux/blob/v3.13/Documentation/networking/scaling.txt&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;monitoring-tuning-linux-networking-stack-receiving-data:&lt;/span&gt; &lt;span&gt;👉&lt;/span&gt;&lt;span&gt;https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;monitoring-tuning-linux-networking-stack-sending-data: &lt;/span&gt;&lt;span&gt;👉&lt;/span&gt;&lt;span&gt;https://blog.packagecloud.io/eng/2017/02/06/monitoring-tuning-linux-networking-stack-sending-data/&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0cf1baa37ab6bcbbbc78788828335c11</guid>
<title>从提高 Elasticsearch 搜索体验说开去</title>
<link>https://toutiao.io/k/wdj0okk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、实战问题&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;112&quot; data-source-title=&quot;来自：死磕 Elasticsearch 知识星球&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;球友提问：怎么搜索才能使得结果是最好的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我这边一个搜索功能，实现做法就是将用ik分词器配合multi查询实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;中途也追加了客户所在领域相关词汇字典。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是客户一直反馈搜索体验不好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想要提高搜索体验还能从那些方面入手呢？&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;blockquote_info js_blockquote_source&quot; data-json=&quot;%7B%22type%22%3A%22out%22%2C%22source%22%3A%22url%22%2C%22digest%22%3A%22%22%2C%22digestLen%22%3A112%2C%22text%22%3A%22%E7%90%83%E5%8F%8B%E6%8F%90%E9%97%AE%EF%BC%9A%E6%80%8E%E4%B9%88%E6%90%9C%E7%B4%A2%E6%89%8D%E8%83%BD%E4%BD%BF%E5%BE%97%E7%BB%93%E6%9E%9C%E6%98%AF%E6%9C%80%E5%A5%BD%E7%9A%84%E5%91%A2%EF%BC%9F%E6%88%91%E8%BF%99%E8%BE%B9%E4%B8%80%E4%B8%AA%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%81%9A%E6%B3%95%E5%B0%B1%E6%98%AF%E5%B0%86%E7%94%A8ik%E5%88%86%E8%AF%8D%E5%99%A8%E9%85%8D%E5%90%88multi%E6%9F%A5%E8%AF%A2%E5%AE%9E%E7%8E%B0%E7%9A%84%E3%80%82%E4%B8%AD%E9%80%94%E4%B9%9F%E8%BF%BD%E5%8A%A0%E4%BA%86%E5%AE%A2%E6%88%B7%E6%89%80%E5%9C%A8%E9%A2%86%E5%9F%9F%E7%9B%B8%E5%85%B3%E8%AF%8D%E6%B1%87%E5%AD%97%E5%85%B8%E3%80%82%E4%BD%86%E6%98%AF%E5%AE%A2%E6%88%B7%E4%B8%80%E7%9B%B4%E5%8F%8D%E9%A6%88%E6%90%9C%E7%B4%A2%E4%BD%93%E9%AA%8C%E4%B8%8D%E5%A5%BD%E3%80%82%E5%A6%82%E6%9E%9C%E6%83%B3%E8%A6%81%E6%8F%90%E9%AB%98%E6%90%9C%E7%B4%A2%E4%BD%93%E9%AA%8C%E8%BF%98%E8%83%BD%E4%BB%8E%E9%82%A3%E4%BA%9B%E6%96%B9%E9%9D%A2%E5%85%A5%E6%89%8B%E5%91%A2%EF%BC%9F%22%2C%22article%22%3A%7B%7D%2C%22hasReportOverSize%22%3Afalse%2C%22editorReportData%22%3A%5B%5D%2C%22from%22%3A%22%E6%9D%A5%E8%87%AA%EF%BC%9A%E6%AD%BB%E7%A3%95%20Elasticsearch%20%E7%9F%A5%E8%AF%86%E6%98%9F%E7%90%83%22%7D&quot;&gt;&lt;span class=&quot;blockquote_other&quot;&gt;来自：死磕 Elasticsearch 知识星球&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题非常有代表性，我在实际产品开发中也遇到过。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、从几个例子说搜索体验&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;示例一：“慕X网”输入“触发器”的搜索截图。&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.8138888888888889&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9aEhSIWhfQzVuauReLweZ7UEIHs3xIpeZM0bwdyZ37rBxJwzbIFaTHV6Ib8sicE79215k28qtKVRNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：我输入的是“触发器”，返回结果第一条没有问题，其他几条有关：“触”、“发”的，可以说和我的搜索没有关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;站在用户体验的角度，我认为：体验很差，返回了很多不相关的数据。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;示例二：某题库APP，不支持跳转翻页。&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下所示，题库共1703题，包含：判断题、选择题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.7861111111111112&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9aEhSIWhfQzVuauReLweZ7UfRpibkPDNshPmIAN2FqiaRUkvj7846AQKUwwkgibAhGq9CbXVYS2khddQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只支持：点击：上一题、下一题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际场景：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当做了100道、200道的时候，只有选择题；到底多少选择题？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当退出后，需要点击几百下进入自己上次做到的最后一道题.....&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这不是用户体验差，这是没有用户体验，开发者完全没有动脑子的设计，用户会&quot;怀疑人生&quot;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.904&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9aEhSIWhfQzVuauReLweZ7UicyEm483jQ1Gv6WFiar0iaPzxBrbiajjQ7nVXMEG6Oicgs6mLhUSFol1RHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;250&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;示例三：电商搜索“秋天第一条秋裤”，该返回什么？&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.49789251844046367&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9aEhSIWhfQzVuauReLweZ7U9qdI5566mKa2b5gHibRRslmGcSOsPzcQ7rZxCQYibGQJGfBrTm6thdEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1898&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;放大&lt;/span&gt;&lt;span&gt;查看图片，亮点自现&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是个见仁见智的问题，究竟返回什么，各个电商公司都有自己的评判。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但，单纯站在用户的角度，高下立判。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;铭毅一句话点评：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“活该你发展快”，的确返回结果就是预期结果，且友好的推荐了所在地域的“秋裤”信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;中规中矩，至少能返回“秋裤”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没有找到商品，为你推荐“秋裤”，“干嘛推荐，直接返回不就完了”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好家伙！推荐的都是“秋天”的商品。你是用户，你咋想？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;......&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本上可以得出结论：公司发展速度和搜索体验成正比。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、有数据的地方，就有搜索&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;信息泛滥和爆炸的今天，搜索无处不在。基本可以形象的概括为：“&lt;strong&gt;有数据的地方，就有搜索&lt;/strong&gt;“。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;搜索可能是用户最常用到的功能之一，学习、工作、衣食住行等各个环节都离不开搜索。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输入关键词，搜索靠谱的免费或付费网络资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;遇到错误码，通过Google 搜索获得答案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;搜索微信聊天记录，看看之前都聊的某个关键有价值信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网上购买衣服，实际就是搜索、选择的过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日常中午订外卖，选择外卖的过程，就是搜索的过程，离公司近+评价高=下单几率大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出差订酒店，搜一下，对比选择个性价比高的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;十一自驾游，出行前高德导航，输入目的地搜索结果，根据返回结果，选择合适路线。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如：搜索体验的分析文章指出：“搜索框的设计及其可用性问题其实是一个不容忽视的要点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个好的搜索体验也许并不能让用户对你的产品产生特别的好感，但是&lt;strong&gt;一个不好的搜索体验却能给你的产品带来致命的打击&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以无论是为了给用户提供更好的服务，还是避免用户产生消极的体验感受，&lt;strong&gt;做好搜索的体验对一个内容型产品来说都是至关重要的&lt;/strong&gt;。“&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;判定搜索体验好不好，搜索结果满足用户需求已是最低门槛要求，以下内容都是能带来良好搜索体验的考察点、用户关注点：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）在视觉上突出搜索框、搜索框与放大镜icon配合使用；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）将搜索框置于用户预期的位置；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3）提供搜索按钮；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4）合适的尺寸&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;毫不客气的说：“&lt;strong&gt;在导航栏最显眼位置放置搜索框是对用户最起码的尊重&lt;/strong&gt;”！&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.10896551724137932&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9aEhSIWhfQzVuauReLweZ7UfomMP2Ndpey1w0u11ZHTBsIYiaXCS293e19RCO64QWFAzbmm8gOfrxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;725&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.11979166666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9aEhSIWhfQzVuauReLweZ7Uu4qWxia8x1ksibtmNHiael3kZ2cM6ziajJTNS2EfwibibTeIcW5FBMiaGzW9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1344&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4796195652173913&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9aEhSIWhfQzVuauReLweZ7UA29J8Kuq6zicGfgmHpceibtS4WQiaxTXicHkM7icEMPicARwl1NItpHvDZibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;736&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;智能推荐或匹配可以节省用户的输入成本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;普通用户不太善于组织搜索语言：在这种情况下如果他们没有在第一步就表达清楚问题，那么接下来也很难成功找到合适的搜索结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当智能匹配发挥作用后，它就能帮助用户表达清楚搜索的问题，进而找到满意的答案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一句话，好的搜索体验就是好的用户体验，而好的用户体验自然和用户留存、甚至公司发展挂钩。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4、用户搜索的五个核心环节拆解&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“搜索就像是用户与 App 或者网站之间的对话，用户通过提问表达信息需求，App 或者网站通过展示结果来作为回应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户期待流畅的搜索体验，并且基于搜索结果的质量用户通常会对一个 App 的价值形成一个快速的判断。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在搜索的过程中，用户的经历大致可以分为五个部分，分别是：发现搜索、输入关键词、等待结果、查看结果、完成搜索，每个步骤的体验都是整体体验的一部分，将对用户最终对搜索体验产生影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;2.789272030651341&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9aEhSIWhfQzVuauReLweZ7Uut4lBoKQnxlU24IhdYdmGrnr7zR6RntjXOWnaBUaJbHG7lmBBeYYzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;261&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.1 发现搜索&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如前所述，搜索框要醒目，搜索栏甚至会独立于头部并且会在UI界面中占据视觉焦点的位置，用户很容易就能找到。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.2 输入关键词&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;要能提示用户，输入什么关键词。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;能根据用户输入的某几个关键，给出“搜索提示”，如前谷歌搜索截图。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;复杂组合搜索，类似谷歌【高级搜索】，要有辅助控件，筛选日期、排除关键词设置、排序方式、与或非表达式等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.3 等待结果&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;响应要快，用户的忍耐是有限度的，超过3秒不返回，估计用户就流失了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果的确响应慢，可以有响应动画或者提示信息友好提示。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;能识别用户输入，必要结果用户历史搜索习惯，整合后返回最优TOP N结果。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.4 查看结果&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户根据搜索返回，筛选的过程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果没有结果，建议不要直接返回“0”条结果，可以有其他推荐信息，比如：提示用户换关键词等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.5 完成搜索&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;有满足需求结果，搜索结束。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有满足用户的结果，用户会换关键词继续搜，或者用户流失去别的APP或者网站了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若要完善用户体验，这几个步骤缺一不可、都得下功夫。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5、Elasticsearch 搜索的底层逻辑&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;明白下面两个过程，就能很好的理解 Elasticsearch 搜索。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7225201072386059&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9aEhSIWhfQzVuauReLweZ7UVsibsHia9SkzEHd2ZH3r23P4ARUaSia9Ie9bkXQaBe1yuJTwFKI2HL8XQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;746&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下仅针对：text的全文检索的文本类型。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;5.1 写入索引化过程&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;文档写入 Elasticsearch 不是直接写入，而是根据你Mapping定义的分词器（默认：standard）分词，构建倒排索引后写入。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;分词器的选型，决定分词的粒度，分词的粒度决定后续的检索指标是否能达标。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;5.2 数据检索过程&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;检索环节，不是输入什么就检索什么，而是不同的检索语句，会有不同的检索机制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;检索环节，选择什么检索类型，结果也会完全不一致。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：“match”细粒度检索和“match_phrase”粗粒度短语匹配，将是截然不同的搜索结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;match：会首先把你输入的关键词进行切分后再检索。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;match_phrase：会把你输入的词当做短语进行检索。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6、Elasticsearch 搜索体验可量化的指标&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户体验是感官反应，但感觉的搜索结果需要量化下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何量化？实际本质指标就是：查准率（精确率）、查全率（召回率）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;6.1 召回率&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义：本次搜索结果中包含的相关文档占整个集合中所有相关文档的比率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;衡量检索结果的查全率。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;6.2 精确率&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义：本次搜索结果中相关文档所占的比例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;衡量检索结果的查准率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体可以根据混淆矩阵来理解，&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;相关&lt;/th&gt;&lt;th&gt;不相关&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;返回&lt;/td&gt;&lt;td&gt;真正例（tp）&lt;/td&gt;&lt;td&gt;伪正例（fp）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;未返回&lt;/td&gt;&lt;td&gt;伪反例（fn）&lt;/td&gt;&lt;td&gt;真反例（tn）&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;已知上述矩阵，那么准确率和召回率可以按如下方法计算:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;召回率：= tp / (tp + fn) * 100%;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;精确率：= tp / (tp + fp) * 100%&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果还不好理解，知乎上通俗解释：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;召回率：正样本有多少被召回了（召回了多少）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;精确率：你认为的正样本，有多少猜对了（猜的准确性如何）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7 、如何改进 Elasticsearch 搜索体验&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面也提到了，搜索五环节环环相扣。&lt;strong&gt;搜索体验是：设计、前端、后端、决策层、管理层都要考虑的事情&lt;/strong&gt;，不能简单的理解为是技术问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文仅对 Elasticsearch 后端技术实现层面做下解读：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;7.1 根据业务场景选择合适的分词器&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，没有最好的分词器、没有适合所有业务场景的通用分词器，需要结合业务场景择优选择。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果要求细粒度，只要存在就要召回，那 ngram 分词适合或者 7.9+ 新推出的 wildcard 数据类型优先考虑。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;需要提前做下切词对比，以验证不同分词器是否满足业务。中文选择：IK、结巴、ansj或者其他。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;切词对比核心 API ：analyzer 要活学活用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;POST _analyze&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;text&quot;&lt;/span&gt;:&lt;span&gt;&quot;提供全球卓越的云计算服务_助力企业无忧上云&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;analyzer&quot;&lt;/span&gt;: &lt;span&gt;&quot;ik_smart&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;选型 IK，要区分：ik_smar 与 ik_max_word。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ik_smart是粗粒度的分词（返回尽可能少，逼近贴合人工分词）；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ik_max_word是细粒度的分词（返回尽可能多）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;7.2 注意词典的选择与更新&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“巧妇难为无米之炊“，“巧妇“是分词器，词典是“米”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分词器再牛逼，没有靠谱的词典也是徒劳。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，词典选择的好，分词才会越准确。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建议：在基础词库相对全的前提下，需要结合业务场景添加属于自己的行业词库、领域词库等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即便添加了行业、领域词典，也涵盖不全新词怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：新的网络词汇、行业领域词汇不能面面俱到导致分词不正确，用户体验差怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于分词器作为插件，原始词典一旦配置，是不支持动态更新的，需要借助第三方机制实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：IK 词典的动态更新实现机制：结合修改 IK 分词器源码 + 动态更新 mysql 词条达到更新词典的目的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;7.3 重视 Mapping 环节数据建模&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;text 类型的 fielddata是内存耗费大户，除非必须，不建议开启。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据是否需要排序或者聚合决定是否启用 keyword 类型。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;不需要索引的字段，“index”设置为“false”。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;不需要存储的字段，“store”设置为“false”。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;大文本如 word，pdf 文本信息，考虑切分成小的片段后存储。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;7.4 根据业务场景，选择合适的搜索类型&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如前所述：match 和 match_phrase 适用场景不同、高下立判。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;match应对的是：查全率高，召回率高但准确率低。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;match_phrase则是：短语匹配，查准率高、召回率低。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;wildcard 模糊匹配，除非必须，不建议使用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，还有其他检索类型，如：query_string, fuzzy等，需要结合业务场景做出选择。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;7.5 追求极致响应速度，要做取舍权衡&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户的忍耐时间非常有限, 不要让用户等。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;加大数据节点的内存和堆内存的配比&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;_source 字段非必要不返回&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不在检索返回阶段做复杂的业务处理&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;包含但不限于:&lt;/p&gt;&lt;p&gt;1）二重以上聚合&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）wildcard 或者 regex 正则检索&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3）自定义高亮&lt;/p&gt;&lt;p&gt;注意：当文件&amp;gt;1MB(大文件）时候，尤其适合&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDY1MTA3OQ==&amp;amp;mid=2247483695&amp;amp;idx=2&amp;amp;sn=d662a6b680c8071dd8577854c081a3d7&amp;amp;chksm=eaa82907dddfa01176f7a295ad63289f47b73278b09cbbb5360a220a45ff0108dd9ec7d215d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot; fvh 高亮&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt; &lt;span&gt;fvh &lt;/span&gt;高亮&lt;/a&gt;方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：默认 from，size 深度分页10000条够了，如果产品经理不同意，需要讨论说服之。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：聚合结果不准确是 Elasticsearch 默认机制，要接受或者做其他方案选型（比如：clickhouse），不纠结细节。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;7.6 使用智能推荐/匹配机制&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;简单的搜索框推荐实现 可以借助：prefix 前缀搜索实现。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;GET kibana_sample_data_ecommerce/_search&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;_source&quot;&lt;/span&gt;: &lt;span&gt;&quot;customer_full_name&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;query&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;prefix&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;customer_full_name.keyword&quot;&lt;/span&gt;: &lt;span&gt;&quot;Ed&quot;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;复杂点的推荐实现，需要辅助纠错功能的，借助：Suggester实现。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;POST /blogs/_search&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;suggest&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;my-suggestion&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;text&quot;&lt;/span&gt;: &lt;span&gt;&quot;lucne rock&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;term&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;suggest_mode&quot;&lt;/span&gt;: &lt;span&gt;&quot;missing&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;field&quot;&lt;/span&gt;: &lt;span&gt;&quot;body&quot;&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;篇幅原因，关于 Suggester 解读，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐：wood大叔的文章：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://elasticsearch.cn/article/142&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个优秀的推荐引擎更趋向于个性化推荐，它可以通过收集用户有价值的数字足迹（如：人口统计、事务细节、交互日志、购买记录、交易记录、浏览记录）和关于产品的信息（例如：规格、用户反馈、与其他产品比较等），来完成推荐之前的数据分析。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8、小结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;搜索体验决定用户体验，用户体验决定的产品的用户率进而决定的产品的成败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;著名产品人梁宁老师在《产品思维30讲》提到“我们看到很多新的互联网公司，系统能力不如传统企业，但是可以从传统企业那里抢夺大量用户，靠的就是用户体验。在体量差异这么大的情况下，用户体验能成为核心竞争力；同维度竞争的时候，用户体验更是最核心的竞争力”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;搜索是流量入口，是“兵家“（各APP、网站）用户体验必争之地。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;搜索体验的迭代是没有终点的&lt;/strong&gt;&lt;/span&gt;，研究的多深、做的多仔细都不为过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家有好的思路和建议也欢迎补充交流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;http://www.woshipm.com/ucd/1037490.html&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;https://zhuanlan.zhihu.com/p/60826371&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;https://www.jianshu.com/p/677742838595&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;http://www.chanpin100.com/article/103633&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;https://www.uisdc.com/search-experience-process-summary&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;http://www.oreilly.com.cn/radar/?p=28&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;《自己动手做推荐引擎》&lt;hr/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>