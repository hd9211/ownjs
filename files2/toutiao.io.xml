<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e38b5ea3240565f70ebe64ea60e3adcd</guid>
<title>尤娜系统的第一次飞行中换引擎的架构垂直拆分改造</title>
<link>https://toutiao.io/k/193vnpj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;转眼离上次尤娜系统削峰填谷的改造已经过去4个月了。小B又来找尤娜，说她还有几个客户想对接B系统，尤娜系统对接的不错，所以希望这些客户都直接对接尤娜，小B会给利润分成。这是件双方都受益的好事，尤娜一口答应了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;未来需求预测&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;尤娜请我喝咖啡，我们一起聊到尤娜系统未来可能的业务。尤娜说她还有几个朋友，也苦于和各个公司开展业务，对接成本高。尤娜出马一定可以说服他们用尤娜作为通道代理，各方受益。尤娜还说到虽然现在短期可以不考虑成本，长期希望作为代理公司可以盈利。另外，现在对接的不多，利润分成可以线下打款，以后业务做大了，估计还需要系统来完成整个业务闭环。让我好好考虑一下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;我其实有点迷茫了：现在设计到哪一步是才是合理的呢？找到了&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486665&amp;amp;idx=1&amp;amp;sn=fa111f7d20c805488d51c2f6cafb2aef&amp;amp;chksm=fafde667cd8a6f71164e1da5b79dad16946bdad26f0ae642ba96c91c9a21707763092f234424&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《M*N个策略造成类爆炸怎样重构？》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《M*N个策略造成类爆炸怎样重构？》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;这篇文章，里面提到：&lt;span&gt;架构和代码&lt;/span&gt;&lt;span&gt;不是设计出来的，是演进出来的。我觉得有道理，先把现在相对确定的需求设计完成：&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;1&amp;gt;B接新业务&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2&amp;gt;新公司接新业务&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3&amp;gt;考虑成本&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4&amp;gt;做新业务的同时保证老业务的稳定性&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;架构设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9335180055401662&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlib9yJ6ORVmdtlUH8PNRESkw9sTclVY7vo8VtxBCLCRuwJG2bLumiaOEgROEiaeNK0VrvKoVI2c6Z1CA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;361&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前尤娜系统是这样的，我们买了一个域名，绑定到一台nginx反向代理服务器。nginx是24核128G高配物理机。目前线上高峰时刻2000TPS，尤娜系统调用B系统平均耗时300ms，TP99是800ms(99%的请求在800ms内完成)。加上kafka全链路高峰时刻加上排队，TP99要2分钟。由于kafka削峰填谷，给B公司的请求并发量不超过500TPS。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;尤娜系统使用了24台4核8G的机器来运行，目前容量满足需求，有一定的冗余，但具体多少还没有压测过。web容器我用的是jetty。网上说建议worker线程数设置为100或者200。我设置成了5000，似乎工作的挺好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是从成本的角度，新业务仍然使用像A系统这样同步调用的模式有很大的性能问题。性能问题全靠堆机器来支撑，所以目前的模式，公司是在做赔本的买卖。开展新业务可以从一开始就规定使用异步的模式，这样可以避免2分钟请求处理不完，一直占用线程，打满线程池的问题。所以单独从新业务的角度，架构是这样的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9682539682539683&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlib9yJ6ORVmdtlUH8PNRESkwDNab1tHibVSMPTyUm2piaQwp9E1RkWZ9uKs66GznvGm6AGSrz9arN4dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;441&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但这是个理想化的模型，客户未必会认可。如果客户要同步调用我们也需要支持。那就需要对这个同步的模型做一个改造：也拆分成两个。老模型改造后的架构是这样的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8522954091816367&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlib9yJ6ORVmdtlUH8PNRESkwg0rQOfq5N7BLKapAKYB4YKBPbXWUr5IYrIDfsJ5picg6yHIxZsfYbWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;501&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在就面临一个问题：老系统和新系统有复用的模块，也有不同的模式。是分开建设还是代码统一维护？是分开部署还是部署在一起？就这个问题我列了优缺点对比及相应的解决方案，请尤娜老板来做决议。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.24444444444444444&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlib9yJ6ORVmdtlUH8PNRESkw0eicDDNvibsBiaLlm8vvQl98fibtria2VOTOzxLicfXpZYSgYcXrcaDa7ltA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;495&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;复用方案从稳定性上偏弱，我参考了&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485188&amp;amp;idx=1&amp;amp;sn=3618568ba3bf9c396195d8e2c4e6723d&amp;amp;chksm=fafdedaacd8a64bca74024452fb88a56ff99aa6bcd9ae841fca1b91cbff40d4dd78698b09dcc&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《服务的容灾与容错》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《服务的容灾与容错》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;分析可以采用线程池隔离的方案，又通过&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485474&amp;amp;idx=1&amp;amp;sn=df22866d7a0b096e7169a5bef81a3058&amp;amp;chksm=fafde28ccd8a6b9a0157fb4e2600a71c8a5db6db7eea37dfdbd6f25e6d3b38b6ab92c4d1f9e3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《hystrix线程池隔离的原理与验证》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《hystrix线程池隔离的原理与验证》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;和&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485666&amp;amp;idx=1&amp;amp;sn=281374a2c8b286fe9c993e2f4698a261&amp;amp;chksm=fafde24ccd8a6b5ad998f2e893045bb387b3e26b9c7e20802b12b8a2fb2f32dca3db1c2fcf51&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《Java线程池总结》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《Java线程池总结》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;找到了具体的实施方法。最终尤娜采纳了复用方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以最终的架构方案是这样的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7907407407407407&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlib9yJ6ORVmdtlUH8PNRESkw5HY52K74iaQMfeM5LTvXCXb80a2HbtEibqKGdJicuydTe0xVH3x23XZsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;540&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;系统迁移方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;尤娜系统要垂直拆分：一拆二。从&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485181&amp;amp;idx=1&amp;amp;sn=df4568317a038fcff3b77cd66d0b7bb6&amp;amp;chksm=fafdec53cd8a654573d4210e755fac7c95b5145aa8a5c76cb3df64478a44da0446945ef04c19&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《服务治理的技术血脉》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《服务治理的技术血脉》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;这篇文章我了解到垂直拆分是服务治理的开始，以后事情会越来越多。目前首要的事情是要平滑进行拆分后的迁移。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，我按照尤娜的建议，定义了标准的接入规范。对外暴露两种接入方式：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;同步调用&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;异步调用&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;异步调用接口/asyn/b&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;异步回调接口，由接入方提供&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时规定这些接口必须透传一个18位的请求编号，这个请求编号是做全链路跟踪用的。因为在和A对接时没有这个号，所以我做了兼容，如果没有传，我就自己生成一个。生成方法我参考的是&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486291&amp;amp;idx=1&amp;amp;sn=c6a52233e35571c6531bbef005139981&amp;amp;chksm=fafde1fdcd8a68ebf2e6c1f3edc53cff7c8a622dd8520d2e98cf9b99976e29096a3bd9d79604&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《惊艳面试官-Java中关于随机数生成8种方式的思考》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《&lt;span&gt;惊艳面试官-Java中关于随机数生成8种方式的思考》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;里的随机数生成，18位基本上可以保证每天千亿级别请求量的情况下不重复。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;异步部分是新逻辑，该在哪个工程代码下开发就在哪里开发。老逻辑，从消费端可以将逻辑迁移到新系统，外部不感知。因为消费端是真正的逻辑处理部分，所以我将这部分叫做“尤娜系统逻辑处理”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在完全迁移之前，老系统保持不动。尤娜系统逻辑处理订阅kafka消息，需要灰度来承接流量。为此，我选择在凌晨1点到5点的低峰期上线，这个时间段，1分钟只有几笔请求。但这是一次大升级，还是需要和小A的公司、小B的公司打声招呼。最好他们也能一起升级把跟踪号加上。并请小A的公司出人一起确认业务状态。尤娜出面轻松的帮我搞定了小A公司的事项。小B的公司不同意做任何变更，这个也不是必需的，所以这个作罢。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;凌晨1点，我准时启动了一台新的逻辑处理服务。过了十几分钟，终于有个请求被这台机器消费了。我通过跟踪日志、数据库数据确认处理和老逻辑完全一致。请小A公司的人确认请求结果符合预期。打算第二天再部署一台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我的打算是因为逻辑处理服务耗时TP99是800ms，最高请求并发量是500TPS。按单台并发量是200来算，3台4C8G足够。留有一定冗余容灾，部署6台。灰度发布，3天部署完。之后老尤娜系统，也就是新的尤娜系统api网关，会每天停止一台的消费，只做生产者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这就是尤娜系统的第一次飞行中换引擎的垂直拆分改造过程。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;复盘&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整个过程给我印象最深的是沟通问题。阿里黑话叫：拉通、对齐。&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486632&amp;amp;idx=1&amp;amp;sn=7b443147ff6b4d10ab0c09ee6e1e1d73&amp;amp;chksm=fafde606cd8a6f109870d9ad2c47cc42497de5a0f18d84bcdb174d3bf13e49efe8b6bf1a27d2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;领域驱动设计DDD&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;领域驱动设计DDD&lt;/a&gt;里叫通用语言。这些都在说沟通的问题。现在很多事情，技术不是难题，关键是沟通。和领导的沟通，和外部的沟通。沟通要放在第一位。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么网上说建议worker线程数设置为100或者200。我设置成了5000，似乎工作的挺好？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先上使用spring boot设置方法的代码：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;@Configuration&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public class &lt;/span&gt;JettyConfig {&lt;br/&gt;    &lt;span&gt;@Bean&lt;br/&gt;    &lt;/span&gt;&lt;span&gt;public &lt;/span&gt;ConfigurableServletWebServerFactory webServerFactory()&lt;br/&gt;    {&lt;br/&gt;        JettyServletWebServerFactory factory = &lt;span&gt;new &lt;/span&gt;JettyServletWebServerFactory();&lt;br/&gt;        factory.setPort(&lt;span&gt;9000&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// Tweak the connection config used by Jetty to handle incoming HTTP&lt;br/&gt;        // connections&lt;br/&gt;        &lt;/span&gt;&lt;span&gt;final &lt;/span&gt;QueuedThreadPool threadPool = &lt;span&gt;new &lt;/span&gt;QueuedThreadPool();&lt;br/&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默&lt;/span&gt;&lt;span&gt;认&lt;/span&gt;&lt;span&gt;最大&lt;/span&gt;&lt;span&gt;线&lt;/span&gt;&lt;span&gt;程&lt;/span&gt;&lt;span&gt;连&lt;/span&gt;&lt;span&gt;接数&lt;/span&gt;&lt;span&gt;200&lt;br/&gt;        &lt;/span&gt;threadPool.setMaxThreads(&lt;span&gt;5000&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默&lt;/span&gt;&lt;span&gt;认&lt;/span&gt;&lt;span&gt;最小&lt;/span&gt;&lt;span&gt;线&lt;/span&gt;&lt;span&gt;程&lt;/span&gt;&lt;span&gt;连&lt;/span&gt;&lt;span&gt;接数&lt;/span&gt;&lt;span&gt;8&lt;br/&gt;        &lt;/span&gt;threadPool.setMinThreads(&lt;span&gt;20&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默&lt;/span&gt;&lt;span&gt;认线&lt;/span&gt;&lt;span&gt;程最大空&lt;/span&gt;&lt;span&gt;闲时间&lt;/span&gt;&lt;span&gt;60000ms&lt;br/&gt;        &lt;/span&gt;threadPool.setIdleTimeout(&lt;span&gt;60000&lt;/span&gt;);&lt;br/&gt;        factory.setThreadPool(threadPool);&lt;br/&gt;        &lt;span&gt;return &lt;/span&gt;factory;&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;设置maxThreads主要是两点考虑和限制：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1&amp;gt;JVM设置时有Xss参数代表每个线程分配的内存资源大小。我设置为128K。这样，最大5000*128K占不到1G内存。堆内存设置为3G。内存共8G，还有足够的内存可以使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2&amp;gt;线程数多会影响上下文切换，如果CPU密集型处理可能会影响响应速度。但是目前线程主要是在等待IO，也没有很强的时效性要求，所以设置成5000问题不大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;编者按&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我打算写这样一个系统故事是因为也是咱们用户群里提到&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486857&amp;amp;idx=1&amp;amp;sn=c95685a190e6e7d3fa6b8b9c7b5b5df9&amp;amp;chksm=fafde727cd8a6e31c2e6b2f00ca606135789545ebc46d029419cb3444f98c157749388e95d2f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《弹力设计三大纪律，怎样让稳定性KPI高大上？》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《弹力设计三大纪律，怎样让稳定性KPI高大上？》&lt;/a&gt;这样的文章对实操帮助不大，实际中还是不知道怎么做，希望我可以出一些实战性的文章。大家希望我写什么样的文章也可以加我微信 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;brmayi &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，注明：入群。一起进群讨论。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;关于设计和架构，我是这么理解：做架构是一个在不同阶段做不同权衡的过程，任何一个决策都有其背景。首先我想把实际工作的内容做输出需要授权，也和咱们不同人遇到的问题不一定契合。而如果我能通过一个系列，这个系列的系统是慢慢孵化的，其实可以覆盖系统演进过程中的很多场景。大家可以代入性思考，这个问题自己会怎么去解决，而别人是怎么解决的，都有哪些考虑点。这样经过几次思考，慢慢强化架构意识，还可以感受到架构在其中的作用。也建议大家在读文章的时候注意里面的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，帮好朋友做招聘。铁哥们，人超好~~&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;3.3817567567567566&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlib9yJ6ORVmdtlUH8PNRESkwEspESaUaZiauwZicLL6C5q59qvrMAv5dmG2PvLibZUmtdAROQjEw97MCQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;888&quot;/&gt;&lt;/p&gt;&lt;p&gt;给朋友的联系方式来张大图，&lt;br/&gt;也可以直接发送简历到朋友邮箱：&lt;br/&gt;&lt;strong&gt;&lt;span&gt;houjinxuan@meituan.com&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;636&quot; data-backw=&quot;358&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.7781531531531531&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlib9yJ6ORVmdtlUH8PNRESkwJMGsthUO1cJjSEn78ohzib8TOychicDfO5O7g71ibIgea8icsUF8zcickZA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;888&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bece664f344551f749ad9e82ac2562e5</guid>
<title>开源｜用Rust编写的，闪电般快速且功能强大的代码编辑器</title>
<link>https://toutiao.io/k/3jfuqw9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;用Rust编写的，闪电般快速且功能强大的代码编辑器。它的UI使用Druid，使用Xi编辑器的Rope Science技术进行文本编辑，并使用Wgpu进行渲染。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1407&quot; data-ratio=&quot;2.026666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicfPd8Edwf3ZGdEfC3lV26bhaeGxutrTmdGpfZEbA5WU9o1yibBRhAFn7fFb8VwlSGdiatxp8CoMOGQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>78009d37888bc585a094ab42e93a644e</guid>
<title>基于 KubeVela 的机器学习实践</title>
<link>https://toutiao.io/k/zgqdeze</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：Tianxin Dong，KubeVela 团队&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在机器学习浪潮迸发的当下，AI 工程师除了需要训练、调试自己的模型之外，还需要将模型进行部署上线，从而验证模型的效果（当然，有的时候，这部分工作由 AI 系统工程师来完成）。这一部分工作对于 AI 工程师们来说是繁琐、且消耗额外精力的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在云原生时代，我们的模型训练和模型服务也通常在云上进行。这样做不仅提高了可扩展性，还能够提升资源的利用率。这对于需要消耗大量计算资源的机器学习场景来说，是十分有效的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是 AI 工程师要想使用云原生的能力通常比较困难。随着时间的推移，云原生的概念已经越来越复杂。想要在云原生之上部署一个简单的模型服务，可能对于 AI 工程师来说，需要额外学习数种概念：比如 Deployment、Service、Ingress 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 KubeVela 作为一个简单、易用、且高可扩展的云原生应用管理工具，能让开发人员方便快捷地在 Kubernetes 上定义与交付应用，无需了解任何底层云原生基础设施相关的细节。KubeVela 拥有着丰富的可扩展性，其 AI 插件提供了模型训练、模型服务、A/B 测试等功能，覆盖了 AI 工程师的基本需求，能够帮助 AI 工程师快速在云原生环境中进行模型训练和模型服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要介绍如何使用 KubeVela 的 AI 插件，来帮助工程师更便捷地完成模型训练及模型服务。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;KubeVela AI 插件&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;KubeVela AI 插件分为模型训练和模型服务两个插件，模型训练插件基于 KubeFlow 的 training-operator，能够支持如 TensorFlow、PyTorch、MXNet 等不同框架的分布式模型训练。而模型服务插件基于 Seldon Core，可以便捷地使用模型启动模型服务，同时也支持流量分发，A/B 测试等高级功能。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.353125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJweicVVUrFniaXxx3wnLvnXvF5saZnLI8icHexjck4E02jTUJVX1juQOheRd1hhmeJyxLlxgntW8ULAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 KubeVela AI 插件，可以大大简化模型训练任务的部署以及模型服务的部署，同时，可以将模型训练、模型服务等过程与 KubeVela 本身的工作流、多集群等功能相结合，从而完成生产可用的服务部署。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注：你可以在 &lt;span&gt;KubeVela Samples&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt; 中找到所有的源码和 YAML 文件。如果你想使用在这个例子中预训练的模型，文件夹中的 &lt;code&gt;style-model.yaml&lt;/code&gt; 和 &lt;code&gt;color-model.yaml&lt;/code&gt; 会将模型复制到 PVC 中。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;模型训练&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先启动模型训练和模型服务的两个插件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;vela addon &lt;span&gt;enable&lt;/span&gt; model-training&lt;br/&gt;vela addon &lt;span&gt;enable&lt;/span&gt; model-serving&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;模型训练中包含 &lt;code&gt;model-training&lt;/code&gt; 和 &lt;code&gt;jupyter-notebook&lt;/code&gt; 两个组件类型， 模型服务中包含 &lt;code&gt;model-serving&lt;/code&gt; 这个组件类型。可以通过 &lt;code&gt;vela show&lt;/code&gt; 命令来查看这三个组件中的具体参数。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;你也可以选择查阅 &lt;span&gt;KubeVela AI 插件文档&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;, 来获取更多信息。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;vela show model-training&lt;br/&gt;vela show jupyter-notebook&lt;br/&gt;vela show model-serving&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来训练一个简单的使用 TensorFlow 框架的模型，这个模型的效果是能够将灰色的图片变成彩色的。部署如下 YAML 文件：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注：模型训练的源码来源于：&lt;span&gt;emilwallner/Coloring-greyscale-images&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;core.oam.dev/v1beta1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Application&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;training-serving&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;namespace:&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;components:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;# 训练模型&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;demo-training&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;type:&lt;/span&gt; &lt;span&gt;model-training&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;properties:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;# 训练模型的镜像&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;image:&lt;/span&gt; &lt;span&gt;fogdong/train-color:v1&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;# 模型训练的框架&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;framework:&lt;/span&gt; &lt;span&gt;tensorflow&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;# 声明存储，将模型持久化。此处会使用集群内的默认 storage class 来创建 PVC&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;storage:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;&quot;my-pvc&quot;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;mountPath:&lt;/span&gt; &lt;span&gt;&quot;/model&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时， KubeVela 将拉起一个 &lt;code&gt;TFJob&lt;/code&gt; 进行模型训练。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仅仅是训练模型很难看出效果，我们修改一下这个 YAML 文件，将模型服务放到模型训练的步骤之后。同时，因为模型服务会直接启动模型，而模型的输入输出不太直观（ndarray 或者 Tensor），因此，我们再部署一个测试服务来调用服务，并将结果转换成图像。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;部署如下 YAML 文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;core.oam.dev/v1beta1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Application&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;training-serving&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;namespace:&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;components:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;# 训练模型&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;demo-training&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;type:&lt;/span&gt; &lt;span&gt;model-training&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;properties:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;image:&lt;/span&gt; &lt;span&gt;fogdong/train-color:v1&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;framework:&lt;/span&gt; &lt;span&gt;tensorflow&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;storage:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;&quot;my-pvc&quot;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;mountPath:&lt;/span&gt; &lt;span&gt;&quot;/model&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;# 启动模型服务&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;demo-serving&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;type:&lt;/span&gt; &lt;span&gt;model-serving&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# 模型服务会在模型训练完成后启动&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;dependsOn:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;demo-training&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;properties:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;# 启动模型服务使用的协议，可以不填，默认使用 seldon 自身的协议&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;protocol:&lt;/span&gt; &lt;span&gt;tensorflow&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;predictors:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;model&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;# 模型服务的副本数&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;replicas:&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;graph:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;# 模型名&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;my-model&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;# 模型框架&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;implementation:&lt;/span&gt; &lt;span&gt;tensorflow&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;# 模型地址，上一步会将训练完的模型保存到 my-pvc 这个 pvc 当中，所以通过 pvc://my-pvc 指定模型的地址&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;modelUri:&lt;/span&gt; &lt;span&gt;pvc://my-pvc&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;# 测试模型服务&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;demo-rest-serving&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;type:&lt;/span&gt; &lt;span&gt;webservice&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# 测试服务会在模型训练完成后启动&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;dependsOn:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;demo-serving&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;properties:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;image:&lt;/span&gt; &lt;span&gt;fogdong/color-serving:v1&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;# 使用 LoadBalancer 暴露对外地址，方便调用&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;exposeType:&lt;/span&gt; &lt;span&gt;LoadBalancer&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;env:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;URL&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;# 模型服务的地址&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;value:&lt;/span&gt; &lt;span&gt;http://ambassador.vela-system.svc.cluster.local/seldon/default/demo-serving/v1/models/my-model:predict&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 测试服务的端口&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;3333&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;expose:&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;部署之后，通过 &lt;code&gt;vela ls&lt;/code&gt; 来查看应用的状态：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ vela ls&lt;br/&gt;&lt;br/&gt;training-serving       demo-training       model-training         running healthy Job Succeeded 2022-03-02 17:26:40 +0800 CST&lt;br/&gt;├─                   demo-serving        model-serving          running healthy Available     2022-03-02 17:26:40 +0800 CST&lt;br/&gt;└─                   demo-rest-serving   webservice             running healthy Ready:1/1     2022-03-02 17:26:40 +0800 CST&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，应用已经正常启动。通过 &lt;code&gt;vela status &amp;lt;app-name&amp;gt; --endpoint&lt;/code&gt; 来查看应用的服务地址。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ vela status training-serving --endpoint&lt;br/&gt;&lt;br/&gt;+---------+-----------------------------------+---------------------------------------------------+&lt;br/&gt;| CLUSTER |     REF(KIND/NAMESPACE/NAME)      |                     ENDPOINT                      |&lt;br/&gt;+---------+-----------------------------------+---------------------------------------------------+&lt;br/&gt;|         | Service/default/demo-rest-serving | tcp://47.251.10.177:3333                          |&lt;br/&gt;|         | Service/vela-system/ambassador    | http://47.251.36.228/seldon/default/demo-serving  |&lt;br/&gt;|         | Service/vela-system/ambassador    | https://47.251.36.228/seldon/default/demo-serving |&lt;br/&gt;+---------+-----------------------------------+---------------------------------------------------+&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该应用有三个服务地址，第一个是我们的测试服务的地址，第二个和第三都是原生模型的地址。我们可以调用测试服务来查看模型的效果：测试服务会读取图像的内容，并将其转成 &lt;code&gt;Tensor&lt;/code&gt; 并请求模型服务，最后将模型服务返回的 &lt;code&gt;Tensor&lt;/code&gt; 转成图像返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们选择一张黑白的女性图片作为输入：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJweicVVUrFniaXxx3wnLvnXvFZJ4iaNOhzhTB2Ox3WzIkSf5gJXSKYUut8VhTVW2gj2BGmIibLs6DT5pQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求后，可以看到，输出了一张彩色图片：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.98828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJweicVVUrFniaXxx3wnLvnXvFEPDAgtIHKoDAG9pTkp62oK3kiaCf0KZpM7cjSP7XnQiah56gRo67PmHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;模型服务：灰度测试&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了直接启动模型服务，我们还可以在一个模型服务中使用多个版本的模型，并对其分配不同的流量以进行灰度测试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;部署如下 YAML，可以看到，v1 版本的模型和 v2 版本的模型都设置为了 50% 的流量。同样，我们在模型服务后面部署一个测试服务：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;core.oam.dev/v1beta1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Application&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;color-serving&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;namespace:&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;components:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;color-model-serving&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;type:&lt;/span&gt; &lt;span&gt;model-serving&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;properties:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;protocol:&lt;/span&gt; &lt;span&gt;tensorflow&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;predictors:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;model1&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;replicas:&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;# v1 版本的模型流量为 50&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;traffic:&lt;/span&gt; &lt;span&gt;50&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;graph:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;my-model&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;implementation:&lt;/span&gt; &lt;span&gt;tensorflow&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;# 模型地址，在 color-model 这个 pvc 中 /model/v1 路径下存放了我们的 v1 版本模型，所以通过 pvc://color-model/model/v1 指定模型的地址&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;modelUri:&lt;/span&gt; &lt;span&gt;pvc://color-model/model/v1&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;model2&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;replicas:&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;# v2 版本的模型流量为 50&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;traffic:&lt;/span&gt; &lt;span&gt;50&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;graph:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;my-model&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;implementation:&lt;/span&gt; &lt;span&gt;tensorflow&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;# 模型地址，在 color-model 这个 pvc 中 /model/v2 路径下存放了我们的 v2 版本模型，所以通过 pvc://color-model/model/v2 指定模型的地址&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;modelUri:&lt;/span&gt; &lt;span&gt;pvc://color-model/model/v2&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;color-rest-serving&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;type:&lt;/span&gt; &lt;span&gt;webservice&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;dependsOn:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;color-model-serving&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;properties:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;image:&lt;/span&gt; &lt;span&gt;fogdong/color-serving:v1&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;exposeType:&lt;/span&gt; &lt;span&gt;LoadBalancer&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;env:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;URL&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;value:&lt;/span&gt; &lt;span&gt;http://ambassador.vela-system.svc.cluster.local/seldon/default/color-model-serving/v1/models/my-model:predict&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;3333&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;expose:&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当模型部署完成后，通过 &lt;code&gt;vela status &amp;lt;app-name&amp;gt; --endpoint&lt;/code&gt; 查看模型服务的地址：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ vela status color-serving --endpoint&lt;br/&gt;&lt;br/&gt;+---------+------------------------------------+----------------------------------------------------------+&lt;br/&gt;| CLUSTER |      REF(KIND/NAMESPACE/NAME)      |                         ENDPOINT                         |&lt;br/&gt;+---------+------------------------------------+----------------------------------------------------------+&lt;br/&gt;|         | Service/vela-system/ambassador     | http://47.251.36.228/seldon/default/color-model-serving  |&lt;br/&gt;|         | Service/vela-system/ambassador     | https://47.251.36.228/seldon/default/color-model-serving |&lt;br/&gt;|         | Service/default/color-rest-serving | tcp://47.89.194.94:3333                                  |&lt;br/&gt;+---------+------------------------------------+----------------------------------------------------------+&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用一张黑白的城市图片请求模型：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJweicVVUrFniaXxx3wnLvnXvFAhy2E3UpiaUP3AibmyaBliaialWoBdx92kjs2DrYWNaCfwEmhTNKjUemEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，第一次请求的结果如下。虽然天空和地面都被渲染成彩色了，但是城市本身还是黑白的：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.871875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJweicVVUrFniaXxx3wnLvnXvFXhTAYibT0uAJtic5ia14ZvN1tw6qg7Wibpgc9w7YEYicxaaLra9NDsOgKGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再次请求，可以看到，这次请求的结果中，天空、地面和城市都被渲染成了彩色：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.84375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJweicVVUrFniaXxx3wnLvnXvFWBNJKPZekIyd8JAzHWjJ7sHsNkymDViaAaL7mpiaF43oBppLTmriaRyCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过对不同版本的模型进行流量分发，可以帮助我们更好地对模型结果进行判断。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;模型服务：A/B 测试&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样一张黑白的图片，我们既可以通过模型将其变成彩色的，也可以通过上传另一张风格图片，对原图进行风格迁移。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于用户来说，究竟是彩色的图片好还是不同风格的图片更胜一筹？我们可以通过进行 A/B 测试，来探索这个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;部署如下 YAML，通过设置 &lt;code&gt;customRouting&lt;/code&gt;，将 &lt;code&gt;Header&lt;/code&gt; 中带有 &lt;code&gt;style: transfer&lt;/code&gt; 的请求，转发到风格迁移的模型。同时，使这个风格迁移的模型与彩色化的模型共用一个地址。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注：风格迁移的模型来源于 &lt;span&gt;TensorFlow Hub&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;core.oam.dev/v1beta1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Application&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;color-style-ab-serving&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;namespace:&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;components:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;color-ab-serving&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;type:&lt;/span&gt; &lt;span&gt;model-serving&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;properties:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;protocol:&lt;/span&gt; &lt;span&gt;tensorflow&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;predictors:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;model1&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;replicas:&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;graph:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;my-model&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;implementation:&lt;/span&gt; &lt;span&gt;tensorflow&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;modelUri:&lt;/span&gt; &lt;span&gt;pvc://color-model/model/v2&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;style-ab-serving&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;type:&lt;/span&gt; &lt;span&gt;model-serving&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;properties:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;protocol:&lt;/span&gt; &lt;span&gt;tensorflow&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;# 风格迁移的模型需要的时间较长，设置超时时间使请求不会被超时&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;timeout:&lt;/span&gt; &lt;span&gt;&quot;10000&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;customRouting:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 指定自定义 Header&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;header:&lt;/span&gt; &lt;span&gt;&quot;style: transfer&quot;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 指定自定义路由&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;serviceName:&lt;/span&gt; &lt;span&gt;&quot;color-ab-serving&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;predictors:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;model2&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;replicas:&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;graph:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;my-model&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;implementation:&lt;/span&gt; &lt;span&gt;tensorflow&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;modelUri:&lt;/span&gt; &lt;span&gt;pvc://style-model/model&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;ab-rest-serving&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;type:&lt;/span&gt; &lt;span&gt;webservice&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;dependsOn:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;color-ab-serving&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;style-ab-serving&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;properties:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;image:&lt;/span&gt; &lt;span&gt;fogdong/style-serving:v1&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;exposeType:&lt;/span&gt; &lt;span&gt;LoadBalancer&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;env:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;URL&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;value:&lt;/span&gt; &lt;span&gt;http://ambassador.vela-system.svc.cluster.local/seldon/default/color-ab-serving/v1/models/my-model:predict&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;3333&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;expose:&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;部署成功后，通过 &lt;code&gt;vela status &amp;lt;app-name&amp;gt; --endpoint&lt;/code&gt; 查看模型服务的地址：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ vela status color-style-ab-serving --endpoint&lt;br/&gt;&lt;br/&gt;+---------+---------------------------------+-------------------------------------------------------+&lt;br/&gt;| CLUSTER |    REF(KIND/NAMESPACE/NAME)     |                       ENDPOINT                        |&lt;br/&gt;+---------+---------------------------------+-------------------------------------------------------+&lt;br/&gt;|         | Service/vela-system/ambassador  | http://47.251.36.228/seldon/default/color-ab-serving  |&lt;br/&gt;|         | Service/vela-system/ambassador  | https://47.251.36.228/seldon/default/color-ab-serving |&lt;br/&gt;|         | Service/vela-system/ambassador  | http://47.251.36.228/seldon/default/style-ab-serving  |&lt;br/&gt;|         | Service/vela-system/ambassador  | https://47.251.36.228/seldon/default/style-ab-serving |&lt;br/&gt;|         | Service/default/ab-rest-serving | tcp://47.251.5.97:3333                                |&lt;br/&gt;+---------+---------------------------------+-------------------------------------------------------+&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个应用中，两个服务各自有两个地址，但是第二个 &lt;code&gt;style-ab-serving&lt;/code&gt; 的模型服务地址是无效的，因为这个模型服务已经被指向了 &lt;code&gt;color-ab-serving&lt;/code&gt; 的地址中。同样，我们通过请求测试服务来查看模型效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，在不加 header 的情况下，图像会从黑白变为彩色：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJweicVVUrFniaXxx3wnLvnXvFMxXkXgHQUbDQ63RWP2ZDJfOPnko9wnyzpP7UaXt9tH0LJVBtzwTE2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们添加一个海浪的图片作为风格渲染：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5538793103448276&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/GpkQxibjhkJweicVVUrFniaXxx3wnLvnXvFY2gV2pNJMtx4PL61ncibuGmvXJvFNrWFDPqlpRyibyW4ffa8loPDObPQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;928&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们为本次请求加上 &lt;code&gt;style: transfer&lt;/code&gt; 的 Header，可以看到，城市变成了海浪风格：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.9515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJweicVVUrFniaXxx3wnLvnXvFicjY8q2kOdF1ibSH6TdBicVCsD4zusn7MJgyOVF0nF7vf3xLvu8ibibibicGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还可以使用一张水墨画的图片作为风格渲染：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/GpkQxibjhkJweicVVUrFniaXxx3wnLvnXvFVVwb1C5hiaVnKT737F5OAFrqp12ib3sW9n1hEVO4veibI6Gm5wVvY7nyA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，这次城市变成了水墨画风格：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.9734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJweicVVUrFniaXxx3wnLvnXvFmzRFmJam1u111HSSbt74rd40a8yoibNE0guGUDEjLAuzrZ7soYrRRow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 KubeVela 的 AI 插件，可以帮助你更便捷地进行模型训练与模型服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，通过与 KubeVela 的结合，我们还能将测试完效果的模型通过 KubeVela 的多环境功能，下发到不同的环境中，从而实现模型的灵活部署。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;KubeVela Samples: &lt;em&gt;https://github.com/oam-dev/samples/tree/master/11.Machine_Learning_Demo&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;KubeVela AI 插件文档: &lt;em&gt;https://kubevela.io/zh/docs/next/reference/addons/ai&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;emilwallner/Coloring-greyscale-images: &lt;em&gt;https://github.com/emilwallner/Coloring-greyscale-images&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;TensorFlow Hub: &lt;em&gt;https://tfhub.dev/google/magenta/arbitrary-image-stylization-v1-256/2&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1ea34e50f48a9abbb95c092446b90d10</guid>
<title>浏览器缓存库设计总结（localStorage/indexedDB）</title>
<link>https://toutiao.io/k/v4pmufa</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5539906103286385&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibOKteqIF9YgCvq0sOFJdYlZkx88icktcNibiaaKBHa3SLWHlj2icm0ticUXficmSdbj1vQeP600iaEOmnlw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1278&quot;/&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading-0&quot;&gt;前言&lt;br/&gt;&lt;/h2&gt;&lt;section&gt;浏览器缓存设计一直是web性能优化中非常重要的一个环节,也是SPA应用盛行的今天不得不考虑的问题.作为一名优秀的前端工程师,为了让我们的应用更流畅,用户体验更好,我们有必要做好浏览器缓存策略.&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;每个Web应用体验都必须快速，对于渐进式 Web 应用更是如此。快速是指在屏幕上获取有意义内容所需的时间，要在不到 5 秒的时间内提供交互式体验。并且，它必须真的很快。很难形容可靠的高性能有多重要。可以这样想: 本机应用的首次加载令人沮丧。已安装的渐进式 Web 应用必须能让用户获得可靠的性能。&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;本文会介绍一些笔者曾经做过的Web性能优化方案以及浏览器缓存的基本流程,并会着重介绍如&lt;span&gt;何利用浏览器缓存API封装适合自己团队的前端缓存库&lt;/span&gt;来极大地提高应用性能,并&lt;span&gt;为公司省钱&lt;/span&gt;.&lt;/p&gt;&lt;h2 data-id=&quot;heading-1&quot;&gt;你将收获&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;熟悉浏览器缓存的基本过程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Web性能优化基本方案以及缓存策略为公司带来的价值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基于localStorage的缓存方案设计以及库的封装(vuex/redux数据持久化解决方案)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基于indexedDB的缓存方案设计以及库的封装&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;结合http请求库(axios/umi-request)进行更细粒度的缓存代理层设计&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-id=&quot;heading-2&quot;&gt;正文&lt;/h2&gt;&lt;h3 data-id=&quot;heading-3&quot;&gt;&lt;strong&gt;1.浏览器缓存的基本过程&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;首先要想设计一个优秀的缓存策略,一定要了解浏览器缓存的流程,接下来是笔者总结的一个基本的流程图:&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;1280&quot; data-ratio=&quot;1.0322916666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/dFTfMt0114ibOKteqIF9YgCvq0sOFJdYlkmWCzBR7JP1FyMKw1pWoA3wYPoLT2gfwDesqoc9OzbQoO1CibvtTBRw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;960&quot; data-width=&quot;1240&quot;/&gt;&lt;/section&gt;&lt;p&gt;上图展示了一个基本的从浏览器请求到展示资源的过程,我们的缓存策略一部分可以从以上流程出发来做优化.我们都知道页面的缓存状态是由header决定的,下面具体介绍几个概念:&lt;/p&gt;&lt;h4 data-id=&quot;heading-4&quot;&gt;&lt;strong&gt;1. ETag&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;由服务端根据资源内容生成一段 hash 字符串，标识资源的状态,用户第一次请求时服务器会将ETag随着资源一起返回给浏览器, 再次请求时浏览器会将这串字符串传回服务器，验证资源是否已经修改，如果没有修改直接使用缓存.具体流程可以是如下情景:&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;624&quot; data-ratio=&quot;0.4875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/dFTfMt0114ibOKteqIF9YgCvq0sOFJdYlj59T40N93PsFia4ZViaW6MZN56O1ByPic7ic0924aeghOetaAW3rWKnCvQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1280&quot; data-width=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section&gt;基于内容的hash往往会比Last-modified更准确.&lt;/section&gt;&lt;h4 data-id=&quot;heading-5&quot;&gt;&lt;strong&gt;2. Last-modified&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;服务器端资源最后的修改时间，必须和 cache-control 共同使用，是检查服务器端资源是否更新的一种方式。当浏览器再次进行请求时，会向服务器传送 If-Modified-Since 报头，询问 Last-Modified 时间点之后资源是否被修改过。如果没有修改，则返回 304，使用缓存；如果修改过，则再次去服务器请求资源，返回200，重新请求资源。&lt;/p&gt;&lt;h4 data-id=&quot;heading-6&quot;&gt;&lt;strong&gt;3. Expires&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和 Last-modified 结合使用. Expires 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。&lt;/p&gt;&lt;h4 data-id=&quot;heading-7&quot;&gt;&lt;strong&gt;4. Cache-Control的max-age&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;单位为秒,指定设置缓存最大的有效时间。当浏览器向服务器发送请求后，在 max-age 这段时间里浏览器就不会再向服务器发送请求了。以上就是浏览器缓存几个基本的概念,更多知识可以在wiki中学习,这里就不一一介绍了.接下来我们具体看看如何优化web应用以及缓存策略给公司带来的价值.&lt;/p&gt;&lt;h3 data-id=&quot;heading-8&quot;&gt;&lt;strong&gt;2.Web性能优化基本方案以及缓存策略为公司带来的价值&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Web性能优化又是老生常谈的问题了,几年前就一直在探讨这个问题,笔者大致盘点一下性能优化的几个常用的方向:&lt;/p&gt;&lt;h4 data-id=&quot;heading-9&quot;&gt;&lt;strong&gt;1.资源的合并与压缩.&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;比如我们常用的gulp或者webpack这些打包工具, 可以帮我们压缩js,css,html代码,并且将不同页面模块的js,css打包合并到一个文件中,好处就是减少了http请求,降低了资源的体积,使得响应更快.但是仍然存在一个缺陷,就是合并代码会导致一次请求的资源体积会比之前分包的要大,所以会一定程度的影响页面渲染时间,所以这里需要做一个权衡,或者部分采用按需加载的方式.&lt;/p&gt;&lt;h4 data-id=&quot;heading-10&quot;&gt;&lt;strong&gt;2.图片压缩&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;一个网站往往更占资源的是媒体文件,比如图片,视频,音频等,对于图片在发布到线上时最好是需求提前压缩一下, 为了减少图片请求几年前常用的做法是雪碧图,也就是几张图片合成一张大图,通过背景定位来显示不同的图片,不过目前貌似用的不多了,现在更多的采用字体图标,svg,或者webp,所以我们需要根据不同的场景使用不同的策略,当然目前主流的云平台支持对象存储,对媒体资源有不错的优化,有条件的可以采用这种方案,比如七牛云,阿里的对象存储oss.&lt;/p&gt;&lt;h4 data-id=&quot;heading-11&quot;&gt;&lt;strong&gt;3. 合理规划html代码结构&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;这个优化主要是为了提高页面渲染时间,我们都知道css和js的加载一般都是阻塞的, css不会阻塞js和外部脚本的加载,但是会阻塞js的执行, 如果我们把css放到body最底部,那么我们在网络不好的情况下可能会看到先展示html文本然后才渲染页面样式的窘境,如果我们把js脚本放到head内,那么将会阻塞后面内容的渲染,并且造成一些应dom还未生成的导致的错误, 虽然我们可以采用async、defer让script变成异步的,但是如果不同js文件有依赖关系,那么很可能导致意外的错误,所以我们的最佳实践往往是如下这种结构的:&lt;/p&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&amp;lt;html&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;head&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;title&amp;gt;&lt;/span&gt;趣谈前端&lt;span&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;meta &lt;span&gt;charset&lt;/span&gt;=&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;meta &lt;span&gt;http-equiv&lt;/span&gt;=&lt;span&gt;&quot;X-UA-Compatible&quot;&lt;/span&gt; &lt;span&gt;content&lt;/span&gt;=&lt;span&gt;&quot;IE=edge&quot;&lt;/span&gt;&amp;gt;&amp;lt;meta &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;viewport&quot;&lt;/span&gt; &lt;span&gt;content&lt;/span&gt;=&lt;span&gt;&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;link &lt;span&gt;rel&lt;/span&gt;=&lt;span&gt;&quot;icon&quot;&lt;/span&gt; &lt;span&gt;href&lt;/span&gt;=&lt;span&gt;&quot;/ico.png&quot;&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;image/x-icon&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;link &lt;span&gt;rel&lt;/span&gt;=&lt;span&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span&gt;href&lt;/span&gt;=&lt;span&gt;&quot;/umi.348436c0.css&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;head&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;body&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;div&amp;gt;&lt;/span&gt;...&lt;span&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br/&gt;  // html内容&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;&amp;lt;script &lt;span&gt;src&lt;/span&gt;=&lt;span&gt;&quot;/umi.520.js&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;复制代码&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h4 data-id=&quot;heading-12&quot;&gt;&lt;strong&gt;4.资源的懒加载和预加载&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;资源的懒加载可以极大的降低页面首屏时间, 我们不仅仅可以对图片采用懒加载, 即只给用户展示可视区域内的图片(虽然图片的懒加载意义更加重大),我们还可以对内容进行懒加载,本质上是一种特殊的分页技巧, jquery时代的lazyload是一个很好的例子,当然现在自己实现一个懒加载方案也非常简单,我们只需要使用getBoundingClientRect这个API配合具体业务使用即可,内容型平台用的比较多,比如我们手机滑到某一区域才加载更多内容,笔者之前做的某头条的广告埋点上报机制就是一个很好的例子.大致思路如下:&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;848&quot; data-ratio=&quot;0.6625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/dFTfMt0114ibOKteqIF9YgCvq0sOFJdYlnRPldmOuMOzefJfUyoE2L6VmOgtSIzn7oN1EdyXibeU4ldcOx2Ouia9w/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1280&quot; data-width=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;p&gt;预加载就是提前加载图片，当用户需要查看时可直接从本地缓存中渲染.这种机制和懒加载往往相反,预加载为了带来更加流畅的用户体验,比如漫画网站,我们如果不使用预加载,那么用户频繁切换图片时体验是相当差的,所以我们需要提前将图片加载好,牺牲的代价就是用户可能会等待一定的时间来开启&quot;漫画之旅&quot;.&lt;/p&gt;&lt;h4 data-id=&quot;heading-13&quot;&gt;&lt;strong&gt;5.静态资源使用cdn&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;cdn的好处就是可以突破浏览器同域名下一次最大请求并发数量,从而不用&quot;排队&quot;来提高加载速度.我们都是到同一域名下浏览器最多并发请求6条(不同浏览器之间有差异),超过6条的则会等待前面的请求完成才会继续发起,如果使用cdn,一方面它采用离用户最近的资源来响应,另一方面cdn往往和应用处于不同的域下,所以可以不用等待其他域下的并发数限制,从而加速网站响应.&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2Mzk1NzkwOA==&amp;amp;mid=2247492755&amp;amp;idx=1&amp;amp;sn=d9845f6fc6719247970c9d8edfb2e999&amp;amp;chksm=fc50fd68cb27747e379c74dae587957992f10c236462e169752ecccd7e434695722a1690db2f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5342592592592592&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibNVrke3zbdetTT6KMnfuVic6KUQEk7OibN6KPMme1CTChQYASyuqFgdv5coalmW9BpADns9tIHw8KQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;h4 data-id=&quot;heading-14&quot;&gt;&lt;strong&gt;6.浏览器缓存&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;这一块就是本文上一节中探讨的内容,这里不做过多介绍了,我们还可以采用localStorage, indexedDB来进一步优化缓存,我们下面会详细介绍这一块的内容.&lt;/p&gt;&lt;h4 data-id=&quot;heading-15&quot;&gt;&lt;strong&gt;7.代码层面的优化&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;代码层面往往就是工程师自己对代码掌控的能力,一个优秀的工程师往往会写出代码量更少,性能更好的代码, 比如采用函数式编程来优化代码结构,使用算法来提高js代码执行效率(比如排序,搜索算法),如果想了解更多这方面的知识,可以参考笔者之前写的两篇文章:&lt;/p&gt;&lt;section&gt;所以说在写代码时,请无时无都都提醒自己, 今天的代码跑性能测试了吗?&lt;/section&gt;&lt;h4 data-id=&quot;heading-16&quot;&gt;&lt;strong&gt;8.使用web worker技术并行执行js代码,减少阻塞&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;Web Worker的作用就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。&lt;/p&gt;&lt;p&gt;Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是Worker比较耗费资源，一旦使用完毕，就应该关闭。&lt;/p&gt;&lt;p&gt;知道了这些web性能优化知识,我们还要充分理解为什么要做这些优化.有过内容平台开发经验的朋友可能会知道,内容平台比较耗资源的就是媒体资源,比如图片,视频等,我们为了有更好的用户体验往往会将这些资源放到第三方服务平台存储,这样会有更好的请求性能还不用担心服务器压力,但是唯一缺点就是烧钱.每一个请求都是钱,虽然不多, 但是也抗不了百万千万的ip请求量,所以这些做的好的内容平台每年至少在这块花个几百万很正常,尤其是按请求付费.所以优化好了网站, 一方面可以带来更多的用户,更好的用户体验,也可以帮公司省流量, 进而帮老板省钱!(跪求求一个年终奖o(╥﹏╥)o).&lt;/p&gt;&lt;p&gt;接下里的内容,就教大家如何省钱.&lt;/p&gt;&lt;h3 data-id=&quot;heading-17&quot;&gt;&lt;strong&gt;3.基于localStorage的缓存方案设计以及库的封装(vuex/redux数据持久化解决方案)&lt;/strong&gt;&lt;/h3&gt;&lt;blockquote&gt;&lt;section&gt;localStorage属性允许你访问一个Document 源（origin）的对象 Storage；存储的数据将保存在浏览器会话中。localStorage 类似 sessionStorage，但其区别在于：存储在 localStorage 的数据可以长期保留；而当页面会话结束——也就是说，当页面被关闭时，存储在 sessionStorage 的数据会被清除 。&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;关于localStorage的文章也写了很多,使用方法也很简单, 这里就不做过多介绍了,但是有没有考虑自己封装一个localStorage呢? 大多数人可能会觉得很多余,因为localStorage提供的api已经够简单了,没必要封装,但是你有没有考虑过,localStorage是持久化缓存,不支持过期时间,所以有些业务场景下原生localStorage是满足不了的,所以这种情况下饿哦们需要自己实现具有过期时间的localStorage库, 关于如何实现该功能,笔者之前也写过一篇文章,有详细的介绍,并且可以让localStorage使用起来更强大,感兴趣的可以学习研究一下:&lt;/p&gt;&lt;section&gt;笔者已经将库发布到npm上了,可以通过如下方式安装使用:&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;import&lt;/span&gt; dao &lt;span&gt;from&lt;/span&gt; @alex_xu/dao&lt;/span&gt;&lt;br/&gt;&lt;span&gt;复制代码&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;或者在html标签中直接使用umd文件,github地址: &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2Mzk1NzkwOA==&amp;amp;mid=2247483764&amp;amp;idx=1&amp;amp;sn=736e1e642056fa08b70d31c15e9315a9&amp;amp;chksm=fc53188fcb249199c2a6ece5cf4483c5293d5df119d332dd76d0abf402a4e4e6110c24c6f720&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;基于localStorage封装的可以设置过期时间的库&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;基于localStorage封装的可以设置过期时间的库&lt;/a&gt;&lt;/p&gt;&lt;p&gt;我们常用的vue里的状态管理库vuex,因为状态都是存在内存中的,那么如果要做web离线应用,或者web游戏,我们往往需要考虑持久化缓存, 那么我们也可以借助localStorage来实现状态的持久化功能,但是请记住,localStorage的存储空间在5-10M,如果有更大的需求,可以采用接下来介绍的indexedDB来实现.&lt;/p&gt;&lt;h3 data-id=&quot;heading-18&quot;&gt;&lt;strong&gt;4.基于indexedDB的缓存方案设计以及库的封装&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;IndexedDB主要用于客户端存储大量结构化数据(包括, 文件/ blobs)。该API使用索引来实现对该数据的高性能搜索。虽然 Web Storage 对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB是一个事务型数据库系统，类似于基于SQL的RDBMS。然而，不像RDBMS使用固定列表，IndexedDB是一个基于JavaScript的面向对象的数据库。它允许我们存储和检索用键索引的对象；可以存储结构化克隆算法支持的任何对象。我们只需要指定数据库模式，打开与数据库的连接，然后检索和更新一系列事务。&lt;/p&gt;&lt;p&gt;我们刚刚接触indexedDB时往往觉得它很难懂, 我们首先需要使用open方法打开数据库,因为indexedDB大部分方法都是异步的,所以我们很难管理, 包括创建事务,创建表(一组数据的对象存储区), 添加对象存储等,这里笔者不会介绍如何使用indexedDB的具体使用方法,而是叫大家如何简化操作indexedDB的使用流程,封装成一个简单好用的缓存库.以下的封装都是基于promise,这样使用起来更优雅.以下是封装的思路:&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;610&quot; data-ratio=&quot;0.5820610687022901&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/dFTfMt0114ibOKteqIF9YgCvq0sOFJdYlFhglNCIaZhdwHLW8gCEW0FsPrO4OSv5wEpTJFYp7ht70nT31fCoWVQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1048&quot; data-width=&quot;1048&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;我们工作中处理的indexedDB无非如上几个操作,所以我们需要将其从indexedDB底层API中抽离出来这几个api.具体实现如下:&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;declare global {&lt;br/&gt;  interface Window { xdb: any; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; xdb = (() =&amp;gt; {&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; instance:any = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; dbName = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; DB = &lt;span&gt;function&lt;/span&gt;(args:any) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; cfg = {&lt;br/&gt;      name: args.name || &lt;span&gt;&#x27;test&#x27;&lt;/span&gt;,&lt;br/&gt;      version: args.version || &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;      onSuccess(e:Event) {&lt;br/&gt;        args.onSuccess &amp;amp;&amp;amp; args.onSuccess(e)&lt;br/&gt;      },&lt;br/&gt;      onUpdate(e:Event) {&lt;br/&gt;        args.onUpdate &amp;amp;&amp;amp; args.onUpdate(e)&lt;br/&gt;      },&lt;br/&gt;      onError(e:Event) {&lt;br/&gt;        args.onError &amp;amp;&amp;amp; args.onError(e)&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.dbName = args.name&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.request = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.db = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 打开/创建数据库&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.init = &lt;span&gt;function&lt;/span&gt;() {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;window&lt;/span&gt;.indexedDB) {&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;你的浏览器不支持该版本&#x27;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;let&lt;/span&gt; _this = &lt;span&gt;this&lt;/span&gt;&lt;br/&gt;      &lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.request = &lt;span&gt;window&lt;/span&gt;.indexedDB.open(&lt;span&gt;this&lt;/span&gt;.dbName, cfg.version)&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.request.onerror = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;        cfg.onError(event)&lt;br/&gt;      }&lt;br/&gt;      &lt;br/&gt;      &lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.request.onsuccess = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;        _this.db = _this.request.result&lt;br/&gt;        cfg.onSuccess(event)&lt;br/&gt;      }&lt;br/&gt;      &lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.request.onupgradeneeded = &lt;span&gt;function&lt;/span&gt; (event:any) {&lt;br/&gt;        _this.db = event.target.result&lt;br/&gt;        cfg.onUpdate(event)&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.init()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 添加表&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.createTable = &lt;span&gt;function&lt;/span&gt;(name:string, opts:any = {}) {&lt;br/&gt;      &lt;span&gt;let&lt;/span&gt; objectStore:any&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.db.objectStoreNames.contains(name)) {&lt;br/&gt;        opts = {&lt;br/&gt;          keyPath: opts.keyPath,&lt;br/&gt;          indexs: &lt;span&gt;Array&lt;/span&gt;.isArray(opts.indexs) ? opts.indexs : []&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// indexs = [{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//   indexName: &#x27;name&#x27;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//   key: &#x27;name&#x27;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//   unique: true&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// }]&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        objectStore = &lt;span&gt;this&lt;/span&gt;.db.createObjectStore(name, { keyPath: opts.keyPath })&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(opts.length) {&lt;br/&gt;          opts.indexs.forEach((item:any) =&amp;gt; {&lt;br/&gt;            objectStore.createIndex(item.indexName, item.key, { unique: item.unique })&lt;br/&gt;          })&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; objectStore&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 访问表中数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.get = &lt;span&gt;function&lt;/span&gt;(tableName:string, keyPathVal:any) {&lt;br/&gt;      &lt;span&gt;let&lt;/span&gt; _this = &lt;span&gt;this&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;((resolve, reject) =&amp;gt; {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; transaction = &lt;span&gt;this&lt;/span&gt;.db.transaction([tableName])&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; objectStore = transaction.objectStore(tableName)&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; request = objectStore.get(keyPathVal)&lt;br/&gt;  &lt;br/&gt;        request.onerror = &lt;span&gt;function&lt;/span&gt;(event:Event) {&lt;br/&gt;          reject({status: &lt;span&gt;500&lt;/span&gt;, msg: &lt;span&gt;&#x27;事务失败&#x27;&lt;/span&gt;, err: event})&lt;br/&gt;        }&lt;br/&gt;  &lt;br/&gt;        request.onsuccess = &lt;span&gt;function&lt;/span&gt;(event:Event) {&lt;br/&gt;          &lt;span&gt;if&lt;/span&gt; (request.result) {&lt;br/&gt;            &lt;span&gt;// 判断缓存是否过期&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(request.result.ex &amp;lt; &lt;span&gt;Date&lt;/span&gt;.now()) {&lt;br/&gt;              resolve({status: &lt;span&gt;200&lt;/span&gt;, data: &lt;span&gt;null&lt;/span&gt;})&lt;br/&gt;              _this.del(tableName, keyPathVal)&lt;br/&gt;            }&lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;              resolve({status: &lt;span&gt;200&lt;/span&gt;, data: request.result})&lt;br/&gt;            }&lt;br/&gt;          } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            resolve({status: &lt;span&gt;200&lt;/span&gt;, data: &lt;span&gt;null&lt;/span&gt;})&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 遍历访问表中所有数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.getAll = &lt;span&gt;function&lt;/span&gt;(tableName:string) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;((reslove, reject) =&amp;gt; {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; objectStore = &lt;span&gt;this&lt;/span&gt;.db.transaction(tableName).objectStore(tableName)&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; result:any = []&lt;br/&gt;        objectStore.openCursor().onsuccess = &lt;span&gt;function&lt;/span&gt; (event:any) {&lt;br/&gt;          &lt;span&gt;let&lt;/span&gt; cursor = event.target.result&lt;br/&gt;  &lt;br/&gt;          &lt;span&gt;if&lt;/span&gt; (cursor) {&lt;br/&gt;            result.push(cursor.value)&lt;br/&gt;            cursor.continue()&lt;br/&gt;          } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            reslove({status: &lt;span&gt;200&lt;/span&gt;, data: result})&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        objectStore.openCursor().onerror = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;          reject({status: &lt;span&gt;500&lt;/span&gt;, msg: &lt;span&gt;&#x27;事务失败&#x27;&lt;/span&gt;, err: event})&lt;br/&gt;        }&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 从表中添加一条数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.add = &lt;span&gt;function&lt;/span&gt;(tableName:string, row:any, ex:number) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;((reslove, reject) =&amp;gt; {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; request = &lt;span&gt;this&lt;/span&gt;.db.transaction([tableName], &lt;span&gt;&#x27;readwrite&#x27;&lt;/span&gt;)&lt;br/&gt;          .objectStore(tableName)&lt;br/&gt;          .add(&lt;span&gt;Object&lt;/span&gt;.assign(row, ex ? { ex: &lt;span&gt;Date&lt;/span&gt;.now() + ex } : {}))&lt;br/&gt;&lt;br/&gt;        request.onsuccess = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;          reslove({status: &lt;span&gt;200&lt;/span&gt;, msg: &lt;span&gt;&#x27;数据写入成功&#x27;&lt;/span&gt;})&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        request.onerror = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;          reject({status: &lt;span&gt;500&lt;/span&gt;, msg: &lt;span&gt;&#x27;数据写入失败&#x27;&lt;/span&gt;, err: event})&lt;br/&gt;        }&lt;br/&gt;      })&lt;br/&gt;      &lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 更新表中的数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.update = &lt;span&gt;function&lt;/span&gt;(tableName:string, row:any) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;((reslove, reject) =&amp;gt; {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; request = &lt;span&gt;this&lt;/span&gt;.db.transaction([tableName], &lt;span&gt;&#x27;readwrite&#x27;&lt;/span&gt;)&lt;br/&gt;          .objectStore(tableName)&lt;br/&gt;          .put(row)&lt;br/&gt;&lt;br/&gt;        request.onsuccess = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;          reslove({status: &lt;span&gt;200&lt;/span&gt;, msg: &lt;span&gt;&#x27;数据更新成功&#x27;&lt;/span&gt;})&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        request.onerror = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;          reject({status: &lt;span&gt;500&lt;/span&gt;, msg: &lt;span&gt;&#x27;数据更新失败&#x27;&lt;/span&gt;, err: event})&lt;br/&gt;        }&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 删除某条数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.del = &lt;span&gt;function&lt;/span&gt;(tableName:string, keyPathVal:any) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;((resolve, reject) =&amp;gt; {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; request = &lt;span&gt;this&lt;/span&gt;.db.transaction([tableName], &lt;span&gt;&#x27;readwrite&#x27;&lt;/span&gt;)&lt;br/&gt;          .objectStore(tableName)&lt;br/&gt;          .delete(keyPathVal)&lt;br/&gt;&lt;br/&gt;        request.onsuccess = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;          resolve({status: &lt;span&gt;200&lt;/span&gt;, msg: &lt;span&gt;&#x27;数据删除成功&#x27;&lt;/span&gt;})&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        request.onerror = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;          reject({status: &lt;span&gt;500&lt;/span&gt;, msg: &lt;span&gt;&#x27;数据删除失败&#x27;&lt;/span&gt;, err: event})&lt;br/&gt;        }&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 清空表数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.clear = &lt;span&gt;function&lt;/span&gt;(tableName:string) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;((resolve, reject) =&amp;gt; {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; request = &lt;span&gt;this&lt;/span&gt;.db.transaction([tableName], &lt;span&gt;&#x27;readwrite&#x27;&lt;/span&gt;)&lt;br/&gt;          .objectStore(tableName)&lt;br/&gt;          .clear()&lt;br/&gt;&lt;br/&gt;        request.onsuccess = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;          resolve({status: &lt;span&gt;200&lt;/span&gt;, msg: &lt;span&gt;&#x27;数据表已清空&#x27;&lt;/span&gt;})&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        request.onerror = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;          reject({status: &lt;span&gt;500&lt;/span&gt;, msg: &lt;span&gt;&#x27;数据表清空失败&#x27;&lt;/span&gt;, err: event})&lt;br/&gt;        }&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    loadDB(args:any) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt;(instance === &lt;span&gt;undefined&lt;/span&gt; || dbName !== args.name) {&lt;br/&gt;        instance = &lt;span&gt;new&lt;/span&gt; (DB &lt;span&gt;as&lt;/span&gt; any)(args)&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; instance&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;})()&lt;br/&gt;&lt;br/&gt;&lt;span&gt;window&lt;/span&gt;.xdb = xdb&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; xdb&lt;/span&gt;&lt;br/&gt;&lt;span&gt;复制代码&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;这样就实现了一个基于promise的且支持过期时间的indexedDB库,实现过期时间也非常简单,就是在创建表的行时在底层添加一个过期时间字段,用户需要设置改行过期时间时, 只需要添加过期时间即可,当我们再次获取表格数据时只需要检测改行是否过期,如果过期就清除重新设置即可.&lt;/p&gt;&lt;h3 data-id=&quot;heading-19&quot;&gt;&lt;strong&gt;5.结合http请求库(axios/umi-request)进行更细粒度的缓存代理层设计&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;为了更大程度的发挥indexedDB存储空间的优势,并且进一步优化缓存策略,我们来可以做缓存拦截.我们都知道,一个应用的有些请求不需要频繁获取,比如省市级联数据, 区位地图数据,或者一些不需要经常更新的数据, 如果我们可以做到只请求一次, 下次请求直接使用内存数据,并设置一个过期时间, 到过期时间之后会重新请求数据, 那么是不是对请求又可以做一次优化?我们第一印象可能会写出这样的代码:&lt;/p&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt;(!store.get(&lt;span&gt;&#x27;xx&#x27;&lt;/span&gt;)){&lt;br/&gt;   http.get(&lt;span&gt;&#x27;xxx&#x27;&lt;/span&gt;).then(res =&amp;gt; {&lt;br/&gt;    res &amp;amp;&amp;amp; store.set(&lt;span&gt;&#x27;xx&#x27;&lt;/span&gt;, res, &lt;span&gt;12&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt; * &lt;span&gt;1000&lt;/span&gt;)&lt;br/&gt;  })&lt;br/&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;复制代码&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;这样虽然可以实现功能,但是每一个业务都要写类似的代码, 往往很难受, 所以作为一个有追求的程序员,我们可以在请求上下功夫.我们都有过axios或者fetch库的使用经验,我们也接触过请求/响应拦截器的使用, 那么我们能不能考虑对请求本身也做一层拦截呢?我想实现的效果是我们在业务里还是正常的像之前一样使用请求,比如:&lt;/p&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;req.get(&lt;span&gt;&#x27;/getName?type=xxx&#x27;&lt;/span&gt;).then(res)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;复制代码&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;然而内部已经帮我们做好请求缓存了,我们的req实际上不是axios或者fetch的实例,而是一层代理.&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;1280&quot; data-ratio=&quot;1.16875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/dFTfMt0114ibOKteqIF9YgCvq0sOFJdYlib9a6lsCpfjhjEkaqMuSvneqH0lBe9JWMFxbGas3oTA6MURKodnB4sw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;960&quot; data-width=&quot;1094&quot;/&gt;&lt;/section&gt;&lt;p&gt;通过这种方式我们对原来的请求方式可以不做任何改变, 完全采用代理机制在请求拦截器中和响应拦截器中布局我们的代理即可,关键点就是存到数据库中的内容要和服务器响应的内容结构一致.&lt;/p&gt;&lt;p&gt;以上方式我们可以对所有的get请求做缓存,如果我们只想对部分请求做缓存,其实利用以上机制实现也很简单,我们只需要设置缓存白名单, 在请求拦截器中判断如果在白名单内才走缓存逻辑即可.&lt;/p&gt;&lt;p&gt;这样,我们再次进行某项数据的搜索时,可以不走任何http请求,直接从indexedDB中获取,这样可以为公司节省大量的流量.&lt;/p&gt;&lt;p&gt;关于indexedDB的库的封装,我也发布到npm和github上了,大家可以直接使用或者进行二次开发.&lt;/p&gt;&lt;h2 data-id=&quot;heading-20&quot;&gt;最后&lt;/h2&gt;&lt;section&gt;如果想学习更多&lt;span&gt;H5游戏&lt;/span&gt;, &lt;span&gt;webpack&lt;/span&gt;，&lt;span&gt;node&lt;/span&gt;，&lt;span&gt;gulp&lt;/span&gt;，&lt;span&gt;css3&lt;/span&gt;，&lt;span&gt;javascript&lt;/span&gt;，&lt;span&gt;nodeJS&lt;/span&gt;，&lt;span&gt;canvas数据可视化&lt;/span&gt;等前端知识和实战，欢迎在公号《趣谈前端》加入我们的技术群一起学习讨论，共同探索前端的边界.&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU2Mzk1NzkwOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibpVQtdHw0UaW5glBQ3RRqy8rYolxkF0tOaAqTUGW9MXPIGvLUGAJ7jB2JicLxJd6xvvWicThNSWFgg/0?wx_fmt=png&quot; data-nickname=&quot;趣谈前端&quot; data-alias=&quot;beautifulFront&quot; data-signature=&quot;徐小夕【知乎专栏作家】掘金签约作者，定期分享前端工程化，可视化，企业实战项目知识，深度复盘企业中经常遇到的500+技术问题解决方案。【关注趣谈前端，前端路上不迷茫】&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>602dd2835c93d4a13e54f86265982787</guid>
<title>[推荐] 2万字 + 50 张图，细说 JVM 内存分布、内存对齐、压缩指针！</title>
<link>https://toutiao.io/k/02whm5c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/J0g14CUwaZdwkxf9KpduegYClib9mbvJlw6YSlyXwar1e8wLuxcWPUmRpNOU9tZwdaLPx85rf14z0uXBLsaeASw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天为大家带来一篇 2 万字的硬核技术文章。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3618421052631579&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeaKYVicAZVk1VAnhiamA41gT2ojtuPGEJjia3kBwibBnsR9zTsFUWjwGWQvhAYSI5MhM59te7XE8Kadg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;304&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们将从计算机组成原理的角度详细阐述对象在JVM内存中是如何布局的，以及什么是内存对齐，如果我们头比较铁，就是不进行内存对齐会造成什么样的后果，最后引出压缩指针的原理和应用。同时我们还介绍了在高并发场景下，False Sharing产生的原因以及带来的性能影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信大家看完本文后，一定会收获很多，话不多说，下面我们正式开始本文的内容~~&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2274193548387098&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3ricXgeszzmZ697l6f7qkJF65XDsfCVIyhTiagCtzNVc0qj75ULcmE8GWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;本文概要.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们的日常工作中，有时候我们为了防止线上应用发生&lt;code&gt;OOM&lt;/code&gt;，所以我们需要在开发的过程中计算一些核心对象在内存中的占用大小，目的是为了更好的了解我们的应用程序内存占用的一个大概情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进而根据我们服务器的内存资源限制以及预估的对象创建数量级计算出应用程序占用内存的高低水位线，如果内存占用量超过&lt;code&gt;高水位线&lt;/code&gt;，那么就有可能有发生&lt;code&gt;OOM&lt;/code&gt;的风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以在程序中根据估算出的&lt;code&gt;高低水位线&lt;/code&gt;，做一些防止&lt;code&gt;OOM&lt;/code&gt;的处理逻辑或者发出告警。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那么核心问题是如何计算一个Java对象在内存中的占用大小呢？？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在为大家解答这个问题之前，笔者先来介绍下Java对象在内存中的布局，也就是本文的主题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. Java对象的内存布局&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5758064516129032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r3I5lLLo8slEicxFgVfFAdGqDVOBdRPgVkduFxd2BEe6LplnF30pr72A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Java对象的内存布局.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图所示，Java对象在JVM中是用&lt;code&gt;instanceOopDesc &lt;/code&gt;结构表示而Java对象在JVM堆中的内存布局可以分为三部分：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 对象头（Header）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个Java对象都包含一个对象头，对象头中包含了两类信息：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;MarkWord&lt;/code&gt;：在JVM中用&lt;code&gt;markOopDesc &lt;/code&gt;结构表示用于存储对象自身运行时的数据。比如：hashcode，GC分代年龄，锁状态标志，线程持有的锁，偏向线程Id，偏向时间戳等。在32位操作系统和64位操作系统中&lt;code&gt;MarkWord&lt;/code&gt;分别占用4B和8B大小的内存。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;类型指针&lt;/code&gt;：JVM中的类型指针封装在&lt;code&gt;klassOopDesc &lt;/code&gt;结构中，类型指针指向了&lt;code&gt;InstanceKclass对象&lt;/code&gt;，Java类在JVM中是用InstanceKclass对象封装的，里边包含了Java类的元信息，比如：继承结构，方法，静态变量，构造函数等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在不开启指针压缩的情况下(-XX:-UseCompressedOops)。在32位操作系统和64位操作系统中类型指针分别占用4B和8B大小的内存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在开启指针压缩的情况下(-XX:+UseCompressedOops)。在32位操作系统和64位操作系统中类型指针分别占用4B和4B大小的内存。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果Java对象是一个数组类型的话，那么在数组对象的对象头中还会包含一个4B大小的用于记录数组长度的属性。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;由于在对象头中用于记录数组长度大小的属性只占4B的内存，所以Java数组可以申请的最大长度为：&lt;code&gt;2^32&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 实例数据（Instance Data)&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java对象在内存中的实例数据区用来存储Java类中定义的实例字段，包括所有父类中的实例字段。也就是说，虽然子类无法访问父类的私有实例字段，或者子类的实例字段隐藏了父类的同名实例字段，但是子类的实例还是会为这些父类实例字段分配内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java对象中的字段类型分为两大类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;基础类型：Java类中实例字段定义的基础类型在实例数据区的内存占用如下：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;long | double占用8个字节。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;int | float占用4个字节。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;short | char占用2个字节。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;byte | boolean占用1个字节。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;引用类型：Java类中实例字段的引用类型在实例数据区内存占用分为两种情况：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;不开启指针压缩(-XX:-UseCompressedOops)：在32位操作系统中引用类型的内存占用为4个字节。在64位操作系统中引用类型的内存占用为8个字节。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开启指针压缩(-XX:+UseCompressedOops)：在64为操作系统下，引用类型内存占用则变为为4个字节，32位操作系统中引用类型的内存占用继续为4个字节。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么32位操作系统的引用类型占4个字节，而64位操作系统引用类型占8字节？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java中，引用类型所保存的是被引用对象的内存地址。在32位操作系统中内存地址是由32个bit表示，因此需要4个字节来记录内存地址，能够记录的虚拟地址空间是2^32大小，也就是只能够表示4G大小的内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在64位操作系统中内存地址是由64个bit表示，因此需要8个字节来记录内存地址，&lt;strong&gt;但在 64 位系统里只使用了低 48 位，所以它的虚拟地址空间是 2^48大小，能够表示256T大小的内存&lt;/strong&gt;，其中低 128T 的空间划分为用户空间，高 128T 划分为内核空间，可以说是非常大了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们从整体上介绍完Java对象在JVM中的内存布局之后，下面我们来看下Java对象中定义的这些实例字段在实例数据区是如何排列布局的：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 字段重排列&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实我们在编写Java源代码文件的时候定义的那些实例字段的顺序会被JVM重新分配排列，这样做的目的其实是为了内存对齐，那么什么是内存对齐，为什么要进行内存对齐，笔者会随着文章深入的解读为大家逐层揭晓答案~~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本小节中，笔者先来为大家介绍一下JVM字段重排列的规则:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM重新分配字段的排列顺序受&lt;code&gt;-XX:FieldsAllocationStyle&lt;/code&gt;参数的影响，默认值为&lt;code&gt;1&lt;/code&gt;，实例字段的重新分配策略遵循以下规则：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果一个字段占用&lt;code&gt;X&lt;/code&gt;个字节，那么这个字段的偏移量&lt;code&gt;OFFSET&lt;/code&gt;需要对齐至&lt;code&gt;NX&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;偏移量是指字段的内存地址与Java对象的起始内存地址之间的差值。比如long类型的字段，它内存占用8个字节，那么它的OFFSET应该是8的倍数8N。不足8N的需要填充字节。&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在开启了压缩指针的64位JVM中，Java类中的第一个字段的OFFSET需要对齐至4N，在关闭压缩指针的情况下类中第一个字段的OFFSET需要对齐至8N。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;JVM默认分配字段的顺序为：long / double，int / float，short / char，byte / boolean，oops(Ordianry Object Point 引用类型指针)，&lt;strong&gt;并且父类中定义的实例变量会出现在子类实例变量之前&lt;/strong&gt;。当设置JVM参数&lt;code&gt;-XX +CompactFields &lt;/code&gt;时（默认），占用内存小于long / double 的字段会允许被插入到对象中第一个 long / double字段之前的间隙中，以避免不必要的内存填充。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;CompactFields选项参数在JDK14中以被标记为过期了，并在将来的版本中很可能被删除。详细细节可查看issue：https://bugs.openjdk.java.net/browse/JDK-8228750&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上边的三条字段重排列规则非常非常重要，但是读起来比较绕脑，很抽象不容易理解，笔者把它们先列出来的目的是为了让大家先有一个朦朦胧胧的感性认识，下面笔者举一个具体的例子来为大家详细说明下，在阅读这个例子的过程中也方便大家深刻的理解这三条重要的字段重排列规则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设现在我们有这样一个类定义&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Parent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; l;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Child&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Parent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; l;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;根据上面介绍的&lt;code&gt;规则3&lt;/code&gt;我们知道父类中的变量是出现在子类变量之前的，并且字段分配顺序应该是long型字段l，应该在int型字段i之前。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果JVM开启了&lt;code&gt;-XX +CompactFields&lt;/code&gt;时，int型字段是可以插入对象中的第一个long型字段（也就是Parent.l字段）之前的空隙中的。如果JVM设置了&lt;code&gt;-XX -CompactFields&lt;/code&gt;则int型字段的这种插入行为是不被允许的。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据&lt;code&gt;规则1&lt;/code&gt;我们知道long型字段在实例数据区的OFFSET需要对齐至8N，而int型字段的OFFSET需要对齐至4N。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据&lt;code&gt;规则2&lt;/code&gt;我们知道如果开启压缩指针&lt;code&gt;-XX:+UseCompressedOops&lt;/code&gt;，Child对象的第一个字段的OFFSET需要对齐至4N，关闭压缩指针时&lt;code&gt;-XX:-UseCompressedOops&lt;/code&gt;，Child对象的第一个字段的OFFSET需要对齐至8N。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于JVM参数&lt;code&gt;UseCompressedOops &lt;/code&gt;和&lt;code&gt;CompactFields &lt;/code&gt;的存在，导致Child对象在实例数据区字段的排列顺序分为四种情况，下面我们结合前边提炼出的这三点规则来看下字段排列顺序在这四种情况下的表现。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 -XX:+UseCompressedOops  -XX -CompactFields 开启压缩指针，关闭字段压缩&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23629032258064517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rTn3QqBMZRFMoibE8Z73erHr9SbSXMZXXCUL9yztHqeZSueFdOxQMugA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;偏移量OFFSET = 8的位置存放的是类型指针，由于开启了压缩指针所以占用4个字节。对象头总共占用12个字节：MarkWord(8字节) + 类型指针(4字节)。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据&lt;code&gt;规则3：&lt;/code&gt;父类Parent中的字段是要出现在子类Child的字段之前的并且long型字段在int型字段之前。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;根据规则2：&lt;/code&gt;在开启压缩指针的情况下，Child对象中的第一个字段需要对齐至4N。这里Parent.l字段的OFFSET可以是12也可以是16。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;根据规则1：&lt;/code&gt;long型字段在实例数据区的OFFSET需要对齐至8N，所以这里Parent.l字段的OFFSET只能是16，因此OFFSET = 12的位置就需要被填充。Child.l字段只能在OFFSET = 32处存储，不能够使用OFFSET = 28位置，因为28的位置不是8的倍数无法对齐8N，因此OFFSET = 28的位置被填充了4个字节。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;规则1也规定了int型字段的OFFSET需要对齐至4N，所以Parent.i与Child.i分别存储以OFFSET = 24和OFFSET = 40的位置。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;因为JVM中的内存对齐除了存在于字段与字段之间还存在于对象与对象之间，Java对象之间的内存地址需要对齐至8N&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以Child对象的末尾处被填充了4个字节，对象大小由开始的44字节被填充到48字节。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2  -XX:+UseCompressedOops  -XX +CompactFields 开启压缩指针，开启字段压缩&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1814516129032258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rDUgEBKWWc9ahzQR8rqV39GoH6b2dbub8ViaiaCt5WE5n3pIOsaxFSFbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在第一种情况的分析基础上，我们开启了&lt;code&gt;-XX +CompactFields&lt;/code&gt;压缩字段，所以导致int型的Parent.i字段可以插入到OFFSET = 12的位置处，以避免不必要的字节填充。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据&lt;code&gt;规则2：&lt;/code&gt;Child对象的第一个字段需要对齐至4N，这里我们看到&lt;code&gt;int型&lt;/code&gt;的Parent.i字段是符合这个规则的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据&lt;code&gt;规则1：&lt;/code&gt;Child对象的所有long型字段都对齐至8N，所有的int型字段都对齐至4N。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终得到Child对象大小为36字节，由于Java对象与对象之间的内存地址需要对齐至8N，所以最后Child对象的末尾又被填充了4个字节最终变为40字节。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里我们可以看到在开启字段压缩&lt;code&gt;-XX +CompactFields&lt;/code&gt;的情况下，Child对象的大小由48字节变成了40字节。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 -XX:-UseCompressedOops  -XX -CompactFields 关闭压缩指针，关闭字段压缩&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23306451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rUIwxgUGicbCZ6bkcIT0gnpMSRAm1Ky5MmEkcCticjCaialUgZBqUuxRcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先在关闭压缩指针&lt;code&gt;-UseCompressedOops&lt;/code&gt;的情况下，对象头中的类型指针占用字节变成了8字节。导致对象头的大小在这种情况下变为了16字节。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据&lt;code&gt;规则1：&lt;/code&gt;long型的变量OFFSET需要对齐至8N。根据&lt;code&gt;规则2：&lt;/code&gt;在关闭压缩指针的情况下，Child对象的第一个字段Parent.l需要对齐至8N。所以这里的Parent.l字段的OFFSET  = 16。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;由于long型的变量OFFSET需要对齐至8N，所以Child.l字段的OFFSET
需要是32，因此OFFSET = 28的位置被填充了4个字节。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样计算出来的Child对象大小为44字节，但是考虑到Java对象与对象的内存地址需要对齐至8N，于是又在对象末尾处填充了4个字节，最终Child对象的内存占用为48字节。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4  -XX:-UseCompressedOops  -XX +CompactFields 关闭压缩指针，开启字段压缩&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在第三种情况的分析基础上，我们来看下第四种情况的字段排列情况：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2153225806451613&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rkd3BpQQERqordT5gAdsgiaicyvIqEr9rFyFZmw1MqJjU29eaesHScn8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于在关闭指针压缩的情况下类型指针的大小变为了8个字节，所以导致Child对象中第一个字段Parent.l前边并没有空隙，刚好对齐8N，并不需要int型变量的插入。所以即使开启了字段压缩&lt;code&gt;-XX +CompactFields&lt;/code&gt;，字段的总体排列顺序还是不变的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;默认情况下指针压缩&lt;code&gt;-XX:+UseCompressedOops&lt;/code&gt;以及字段压缩&lt;code&gt;-XX +CompactFields&lt;/code&gt;都是开启的&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 对齐填充（Padding)&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前一小节关于实例数据区字段重排列的介绍中为了内存对齐而导致的字节填充不仅会出现在字段与字段之间，还会出现在对象与对象之间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边我们介绍了字段重排列需要遵循的三个重要规则，其中规则1，规则2定义了字段与字段之间的内存对齐规则。规则3定义的是对象字段之间的排列规则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了内存对齐的需要，对象头与字段之间，以及字段与字段之间需要填充一些不必要的字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如前边提到的字段重排列的第一种情况&lt;code&gt;-XX:+UseCompressedOops -XX -CompactFields&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23629032258064517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rTn3QqBMZRFMoibE8Z73erHr9SbSXMZXXCUL9yztHqeZSueFdOxQMugA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而以上提到的四种情况都会在对象实例数据区的后边在填充4字节大小的空间，原因是除了需要满足字段与字段之间的内存对齐之外，还需要满足对象与对象之间的内存对齐。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 虚拟机堆中对象之间的内存地址需要对齐至8N（8的倍数），如果一个对象占用内存不到8N个字节，那么就必须在对象后填充一些不必要的字节对齐至8N个字节。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;虚拟机中内存对齐的选项为&lt;code&gt;-XX:ObjectAlignmentInBytes&lt;/code&gt;，默认为8。也就是说对象与对象之间的内存地址需要对齐至多少倍，是由这个JVM参数控制的。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是以上边第一种情况为例说明：图中对象实际占用是44个字节，但是不是8的倍数，那么就需要再填充4个字节，内存对齐至48个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上这些为了内存对齐的目的而在字段与字段之间，对象与对象之间填充的不必要字节，我们就称之为&lt;code&gt;对齐填充（Padding）&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 对齐填充的应用&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们知道了对齐填充的概念之后，大家可能好奇了，为啥我们要进行对齐填充，是要解决什么问题吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么就让我们带着这个问题，来接着听笔者往下聊~~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 解决伪共享问题带来的对齐填充&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了以上介绍的两种对齐填充的场景（字段与字段之间，对象与对象之间），在JAVA中还有一种对齐填充的场景，那就是通过对齐填充的方式来解决&lt;code&gt;False Sharing（伪共享）&lt;/code&gt;的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在介绍False Sharing（伪共享）之前，笔者先来介绍下CPU读取内存中数据的方式。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1.1 CPU缓存&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据摩尔定律：芯片中的晶体管数量每隔&lt;code&gt;18&lt;/code&gt;个月就会翻一番。导致CPU的性能和处理速度变得越来越快，而提升CPU的运行速度比提升内存的运行速度要容易和便宜的多，所以就导致了CPU与内存之间的速度差距越来越大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了弥补CPU与内存之间巨大的速度差异，提高CPU的处理效率和吞吐，于是人们引入了&lt;code&gt;L1,L2,L3&lt;/code&gt;高速缓存集成到CPU中。当然还有&lt;code&gt;L0&lt;/code&gt;也就是寄存器，寄存器离CPU最近，访问速度也最快，基本没有时延。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6556451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3ruGeiaJSUicRiboqYgiaAWqhLFI8lDanK1q52jytoe5w9xibl51u246UUmWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;CPU缓存结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个CPU里面包含多个核心，我们在购买电脑的时候经常会看到这样的处理器配置，比如&lt;code&gt;4核8线程&lt;/code&gt;。意思是这个CPU包含4个物理核心8个逻辑核心。4个物理核心表示在同一时间可以允许4个线程并行执行，8个逻辑核心表示处理器利用&lt;code&gt;超线程的技术&lt;/code&gt;将一个物理核心模拟出了两个逻辑核心，一个物理核心在同一时间只会执行一个线程，而&lt;code&gt;超线程芯片&lt;/code&gt;可以做到线程之间快速切换，当一个线程在访问内存的空隙，超线程芯片可以马上切换去执行另外一个线程。因为切换速度非常快，所以在效果上看到是8个线程在同时执行。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;图中的CPU核心指的是物理核心。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中我们可以看到L1Cache是离CPU核心最近的高速缓存，紧接着就是L2Cache，L3Cache，内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;离CPU核心越近的缓存访问速度也越快，造价也就越高，当然容量也就越小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中L1Cache和L2Cache是CPU物理核心私有的（&lt;strong&gt;注意：这里是物理核心不是逻辑核心&lt;/strong&gt;）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而L3Cache是整个CPU所有物理核心共享的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;CPU逻辑核心共享其所属物理核心的L1Cache和L2Cache&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;L1Cache&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;L1Cache离CPU是最近的，它的访问速度最快，容量也最小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中我们看到L1Cache分为两个部分，分别是：Data Cache和Instruction Cache。它们一个是存储数据的，一个是存储代码指令的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过&lt;code&gt;cd /sys/devices/system/cpu/&lt;/code&gt;来查看linux机器上的CPU信息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.10483870967741936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rQDoCpOjBGDjIRQFgYz5PpQvR7WjNkM34wibLLreU7cjhnicMyicyynTow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;/sys/devices/system/cpu/&lt;/code&gt;目录里，我们可以看到CPU的核心数，&lt;strong&gt;当然这里指的是逻辑核心&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;笔者机器上的处理器并没有使用超线程技术所以这里其实是4个物理核心。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们进入其中一颗CPU核心（cpu0）中去看下L1Cache的情况：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU缓存的情况在&lt;code&gt;/sys/devices/system/cpu/cpu0/cache&lt;/code&gt;目录下查看：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.07231920199501247&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rdBic5LNCpCTfiacvTic6bE1vnpvQS8QtdA3okiaNE4BibjicFv6RTgw8IxdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;index0&lt;/code&gt;描述的是L1Cache中DataCache的情况：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1774193548387097&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r5Ztzic9ubE7Yao8kwqDNrE4Th9yFMGbjp02EgsDmWdP5D5NRTDRnz6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;level&lt;/code&gt;：表示该cache信息属于哪一级，1表示L1Cache。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;type&lt;/code&gt;：表示属于L1Cache的DataCache。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;size&lt;/code&gt;：表示DataCache的大小为32K。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;shared_cpu_list&lt;/code&gt;：之前我们提到L1Cache和L2Cache是CPU物理核所私有的，而由物理核模拟出来的逻辑核是&lt;strong&gt;共享L1Cache和L2Cache的&lt;/strong&gt;，&lt;code&gt;/sys/devices/system/cpu/&lt;/code&gt;目录下描述的信息是逻辑核。shared_cpu_list描述的正是哪些逻辑核共享这个物理核。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;index1&lt;/code&gt;描述的是L1Cache中Instruction Cache的情况：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.14965986394557823&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3raUkia8dMPfuZycmq6V3yxPEgsOibdPkXdOcf8jiacjsKibIoZCA0pTYwUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1176&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到L1Cache中的Instruction Cache大小也是32K。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;L2Cache&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;L2Cache的信息存储在&lt;code&gt;index2&lt;/code&gt;目录下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15172413793103448&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rBPG6d6wMicBXC6XNicM4Q4xmwAPvCUVoqicqtegyV1mibEr8gMCOlPjo9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1160&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;L2Cache的大小为256K，比L1Cache要大些。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;L3Cache&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;L3Cache的信息存储在&lt;code&gt;index3&lt;/code&gt;目录下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15411558669001751&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r8EhWk8gMQibcobiaSg6jBXwDYesjukUia4SRXU6d9h9Bf4rm4ZTRMAib4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1142&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里我们可以看到L1Cache中的DataCache和InstructionCache大小一样都是32K而L2Cache的大小为256K，L3Cache的大小为6M。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这些数值在不同的CPU配置上会是不同的，但是总体上来说L1Cache的量级是几十KB，L2Cache的量级是几百KB，L3Cache的量级是几MB。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1.2 CPU缓存行&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边我们介绍了CPU的高速缓存结构，引入高速缓存的目的在于消除CPU与内存之间的速度差距，根据&lt;code&gt;程序的局部性原理&lt;/code&gt;我们知道，CPU的高速缓存肯定是用来存放热点数据的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;程序局部性原理表现为：时间局部性和空间局部性。时间局部性是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某块数据被访问，则不久之后该数据可能再次被访问。空间局部性是指一旦程序访问了某个存储单元，则不久之后，其附近的存储单元也将被访问。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么在高速缓存中存取数据的基本单位又是什么呢？？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上热点数据在CPU高速缓存中的存取并不是我们想象中的以单独的变量或者单独的指针为单位存取的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU高速缓存中存取数据的基本单位叫做缓存行&lt;code&gt;cache line&lt;/code&gt;。缓存行存取字节的大小为2的倍数，在不同的机器上，缓存行的大小范围在32字节到128字节之间。目前所有主流的处理器中缓存行的大小均为&lt;code&gt;64字节&lt;/code&gt;（&lt;strong&gt;注意：这里的单位是字节&lt;/strong&gt;）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1685483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rFp5pibic2ibgK0RhpiaNSzG8LY5TVRjoLibakY8jIicsxTu4EoYgUzGXq7tA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中我们可以看到L1Cache,L2Cache,L3Cache中缓存行的大小都是&lt;code&gt;64字节&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也就意味着每次CPU从内存中获取数据或者写入数据的大小为64个字节，即使你只读一个bit，CPU也会从内存中加载64字节数据进来。同样的道理，CPU从高速缓存中同步数据到内存也是按照64字节的单位来进行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如你访问一个long型数组，当CPU去加载数组中第一个元素时也会同时将后边的7个元素一起加载进缓存中。&lt;strong&gt;这样一来就加快了遍历数组的效率。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;long类型在Java中占用8个字节，一个缓存行可以存放8个long型变量。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上，你可以非常快速的遍历在连续的内存块中分配的任意数据结构，如果你的数据结构中的项在内存中不是彼此相邻的（比如：链表），这样就无法利用CPU缓存的优势。由于数据在内存中不是连续存放的，所以在这些数据结构中的每一个项都可能会出现缓存行未命中（&lt;code&gt;程序局部性原理&lt;/code&gt;）的情况。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;还记得我们在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247483907&amp;amp;idx=1&amp;amp;sn=084c470a8fe6234c2c9461b5f713ff30&amp;amp;chksm=ce77c444f9004d52e7c6244bee83479070effb0bc59236df071f4d62e91e25f01715fca53696&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《Reactor在Netty中的实现(创建篇)》&lt;/a&gt;中介绍Selector的创建时提到，Netty利用数组实现的自定义SelectedSelectionKeySet类型替换掉了JDK利用HashSet类型实现的&lt;code&gt;sun.nio.ch.SelectorImpl#selectedKeys&lt;/code&gt;。&lt;strong&gt;目的就是利用CPU缓存的优势来提高IO活跃的SelectionKeys集合的遍历性能&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 False Sharing（伪共享）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看一个这样的例子，笔者定义了一个示例类FalseSharding，类中有两个long型的volatile字段a，b。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FalseSharding&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; a;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; b;&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字段a，b之间逻辑上是独立的，它们之间一点关系也没有，分别用来存储不同的数据，数据之间也没有关联。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FalseSharding类中字段之间的内存布局如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1282258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rIkusicdpvzH08AqomqdzO2kTIoFr11Zgm4AD8321M6juwibgGibBZeJiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FalseSharding类中的字段a,b在内存中是相邻存储，分别占用8个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果恰好字段a，b被CPU读进了同一个缓存行，而此时有两个线程，线程a用来修改字段a，同时线程b用来读取字段b。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7330645161290322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rp7SqclFcyfHiaq64J2oQgXg8e9ictC2Er2TqjgGygFM9w9ToXhKakSxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;falsesharding1.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;在这种场景下，会对线程b的读取操作造成什么影响呢&lt;/strong&gt;？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道声明了&lt;code&gt;volatile关键字&lt;/code&gt;的变量可以在多线程处理环境下，确保内存的可见性。计算机硬件层会保证对被volatile关键字修饰的共享变量进行写操作后的内存可见性，而这种内存可见性是由&lt;code&gt;Lock前缀指令&lt;/code&gt;以及&lt;code&gt;缓存一致性协议（MESI控制协议）&lt;/code&gt;共同保证的。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Lock前缀指令可以使修改线程所在的处理器中的相应缓存行数据被修改后立马刷新回内存中，并同时&lt;code&gt;锁定&lt;/code&gt;所有处理器核心中缓存了该修改变量的缓存行，防止多个处理器核心并发修改同一缓存行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;缓存一致性协议主要是用来维护多个处理器核心之间的CPU缓存一致性以及与内存数据的一致性。每个处理器会在总线上嗅探其他处理器准备写入的内存地址，如果这个内存地址在自己的处理器中被缓存的话，就会将自己处理器中对应的缓存行置为&lt;code&gt;无效&lt;/code&gt;，下次需要读取的该缓存行中的数据的时候，就需要访问内存获取。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;基于以上volatile关键字原则，我们首先来看第一种影响&lt;/strong&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5919354838709677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r7wY7nnNnOPoKmzuicta6VYXzeUqVyQ80rBPniabpvAhiaTFUqYFDDs4dA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;falsesharding2.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当线程a在处理器core0中对字段a进行修改时，&lt;code&gt;Lock前缀指令&lt;/code&gt;会将所有处理器中缓存了字段a的对应缓存行进行&lt;code&gt;锁定&lt;/code&gt;，&lt;strong&gt;这样就会导致线程b在处理器core1中无法读取和修改自己缓存行的字段b&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;处理器core0将修改后的字段a所在的缓存行刷新回内存中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中我们可以看到此时字段a的值在处理器core0的缓存行中以及在内存中已经发生变化了。但是处理器core1中字段a的值还没有变化，并且core1中字段a所在的缓存行处于&lt;code&gt;锁定状态&lt;/code&gt;，无法读取也无法写入字段b。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上述过程中我们可以看出即使字段a，b之间逻辑上是独立的，它们之间一点关系也没有，但是线程a对字段a的修改，导致了线程b无法读取字段b。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第二种影响&lt;/strong&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7693548387096775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rnB60WxJJOpAyczIn2FuP2j5QgEgr2MNN0qOlBhDVAjFjib9bzo92wpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;faslesharding3.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当处理器core0将字段a所在的缓存行刷新回内存的时候，处理器core1会在总线上嗅探到字段a的内存地址正在被其他处理器修改，所以将自己的缓存行置为&lt;code&gt;失效&lt;/code&gt;。当线程b在处理器core1中读取字段b的值时，发现缓存行已被置为&lt;code&gt;失效&lt;/code&gt;，core1需要重新从内存中读取字段b的值即使字段b没有发生任何变化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从以上两种影响我们看到字段a与字段b实际上并不存在共享，它们之间也没有相互关联关系，理论上线程a对字段a的任何操作，都不应该影响线程b对字段b的读取或者写入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但事实上线程a对字段a的修改导致了字段b在core1中的缓存行被锁定（Lock前缀指令），进而使得线程b无法读取字段b。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程a所在处理器core0将字段a所在缓存行同步刷新回内存后，导致字段b在core1中的缓存行被置为&lt;code&gt;失效&lt;/code&gt;（缓存一致性协议），进而导致线程b需要重新回到内存读取字段b的值无法利用CPU缓存的优势。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于字段a和字段b在同一个缓存行中，导致了字段a和字段b事实上的共享（原本是不应该被共享的）。这种现象就叫做&lt;code&gt;False Sharing（伪共享）&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发的场景下，这种伪共享的问题，会对程序性能造成非常大的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果线程a对字段a进行修改，与此同时线程b对字段b也进行修改，这种情况对性能的影响更大，因为这会导致core0和core1中相应的缓存行相互失效。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.3 False Sharing的解决方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然导致False Sharing出现的原因是字段a和字段b在同一个缓存行导致的，那么我们就要想办法让字段a和字段b不在一个缓存行中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们怎么做才能够使得字段a和字段b一定不会被分配到同一个缓存行中呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候，本小节的主题字节填充就派上用场了~~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java8之前我们通常会在字段a和字段b前后分别填充7个long型变量(缓存行大小64字节)，目的是让字段a和字段b各自独占一个缓存行避免&lt;code&gt;False Sharing&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们将一开始的实例代码修改成这个这样子，就可以保证字段a和字段b各自独占一个缓存行了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FalseSharding&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; p1,p2,p3,p4,p5,p6,p7;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; a;&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; p8,p9,p10,p11,p12,p13,p14;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; b;&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; p15,p16,p17,p18,p19,p20,p21;&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改后的对象在内存中布局如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47580645161290325&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rUI6HrVY89690zicQejoWhiaIguq7jBiaujKzicrbqxjo3RJ53BGb45ozng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到为了解决False Sharing问题，我们将原本占用32字节的FalseSharding示例对象硬生生的填充到了200字节。这对内存的消耗是非常可观的。通常为了极致的性能，我们会在一些高并发框架或者JDK的源码中看到False Sharing的解决场景。因为在高并发场景中，任何微小的性能损失比如False Sharing，都会被无限放大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但解决False Sharing的同时又会带来巨大的内存消耗，所以即使在高并发框架比如disrupter或者JDK中也只是&lt;strong&gt;针对那些在多线程场景下被频繁写入的共享变量&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这里笔者想强调的是在我们日常工作中&lt;/strong&gt;，我们不能因为自己手里拿着锤子，就满眼都是钉子，看到任何钉子都想上去锤两下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rHkkic5QPnrIgdFMNicgPufSU5znYlN8rfUdVey7zP9GWl93fYqkdGO4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;255&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们要清晰的分辨出一个问题会带来哪些影响和损失，这些影响和损失在我们当前业务阶段是否可以接受？是否是瓶颈？同时我们也要清晰的了解要解决这些问题我们所要付出的代价。一定要综合评估，讲究一个投入产出比。某些问题虽然是问题，但是在某些阶段和场景下并不需要我们投入解决。而有些问题则对于我们当前业务发展阶段是瓶颈，我们&lt;strong&gt;不得不&lt;/strong&gt;去解决。我们在架构设计或者程序设计中，方案一定要&lt;code&gt;简单&lt;/code&gt;，&lt;code&gt;合适&lt;/code&gt;。并预估一些提前量留有一定的&lt;code&gt;演化空间&lt;/code&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.3.1 @Contended注解&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java8中引入了一个新注解&lt;code&gt;@Contended&lt;/code&gt;，用于解决False Sharing的问题，同时这个注解也会影响到Java对象中的字段排列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上一小节的内容介绍中，我们通过手段填充字段的方式解决了False Sharing的问题，但是这里也有一个问题，因为我们在手动填充字段的时候还需要考虑CPU缓存行的大小，因为虽然现在所有主流的处理器缓存行大小均为64字节，但是也还是有处理器的缓存行大小为32字节，有的甚至是128字节。我们需要考虑很多硬件的限制因素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java8中通过引入@Contended注解帮我们解决了这个问题，我们不在需要去手动填充字段了。下面我们就来看下@Contended注解是如何帮助我们来解决这个问题的~~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上小节介绍的手动填充字节是在共享变量前后填充64字节大小的空间，这样只能确保程序在缓存行大小为32字节或者64字节的CPU下独占缓存行。但是如果CPU的缓存行大小为128字节，这样依然存在False Sharing的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入@Contended注解可以使我们忽略底层硬件设备的差异性，做到Java语言的初衷：平台无关性。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;@Contended注解默认只是在JDK内部起作用，如果我们的程序代码中需要使用到@Contended注解，那么需要开启JVM参数&lt;code&gt;-XX:-RestrictContended&lt;/code&gt;才会生效。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;br/&gt;&lt;span&gt;@Target&lt;/span&gt;({ElementType.FIELD, ElementType.TYPE})&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;@interface&lt;/span&gt; Contended {&lt;br/&gt;    &lt;span&gt;//contention group tag&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;value&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;@Contended注解可以标注在类上也可以标注在类中的字段上，被@Contended标注的对象会独占缓存行，不会和任何变量或者对象共享缓存行。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;@Contended标注在类上表示该类对象中的&lt;code&gt;实例数据整体&lt;/code&gt;需要独占缓存行。不能与其他实例数据共享缓存行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;@Contended标注在类中的字段上表示该字段需要独占缓存行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;除此之外@Contended还提供了分组的概念，注解中的value属性表示&lt;code&gt;contention group &lt;/code&gt;。属于统一分组下的变量，它们在内存中是连续存放的，可以允许共享缓存行。不同分组之间不允许共享缓存行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来分别看下@Contended注解在这三种使用场景下是怎样影响字段之间的排列的。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;@Contended标注在类上&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Contended&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FalseSharding&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; a;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; b;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; c;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; d;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当@Contended标注在FalseSharding示例类上时，表示FalseSharding示例对象中的&lt;code&gt;整个实例数据区&lt;/code&gt;需要独占缓存行，不能与其他对象或者变量共享缓存行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况下的内存布局：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1870967741935484&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rwE6v9iaC7nRQBSTl61ibVbibmqCUHkVrex4zbnwLMrzbJiblBuuKoUuk3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图中所示，FalseSharding示例类被标注了@Contended之后，JVM会在FalseSharding示例对象的实例数据区前后填充&lt;code&gt;128个字节&lt;/code&gt;，保证实例数据区内的字段之间内存是连续的，并且保证整个实例数据区独占缓存行，不会与实例数据区之外的数据共享缓存行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;细心的朋友可能已经发现了问题，我们之前不是提到缓存行的大小为64字节吗？为什么这里会填充128字节呢&lt;/strong&gt;？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且之前介绍的手动填充也是填充的&lt;code&gt;64字节&lt;/code&gt;，为什么@Contended注解会采用&lt;code&gt;两倍&lt;/code&gt;的缓存行大小来填充呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这里的原因有两个：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;首先第一个原因，我们之前也已经提到过了，目前大部分主流的CPU缓存行是64字节，但是也有部分CPU缓存行是32字节或者128字节，如果只填充64字节的话，在缓存行大小为32字节和64字节的CPU中是可以做到独占缓存行从而避免FalseSharding的，但在缓存行大小为&lt;code&gt;128字节&lt;/code&gt;的CPU中还是会出现FalseSharding问题，这里Java采用了悲观的一种做法，默认都是填充&lt;code&gt;128字节&lt;/code&gt;，虽然对于大部分情况下比较浪费，但是屏蔽了底层硬件的差异。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;不过@Contended注解填充字节的大小我们可以通过JVM参数&lt;code&gt;-XX:ContendedPaddingWidth&lt;/code&gt;指定，有效值范围&lt;code&gt;0 - 8192&lt;/code&gt;，默认为&lt;code&gt;128&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第二个原因其实是最为核心的一个原因，主要是为了防止CPU Adjacent Sector Prefetch（CPU相邻扇区预取）特性所带来的FalseSharding问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;CPU Adjacent Sector Prefetch：https://www.techarp.com/bios-guide/cpu-adjacent-sector-prefetch/&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;CPU Adjacent Sector Prefetch&lt;/strong&gt;是Intel处理器特有的BIOS功能特性，默认是enabled。主要作用就是利用&lt;code&gt;程序局部性原理&lt;/code&gt;，当CPU从内存中请求数据，并读取当前请求数据所在缓存行时，&lt;code&gt;会进一步预取&lt;/code&gt;与当前缓存行相邻的下一个缓存行，这样当我们的程序在顺序处理数据时，会提高CPU处理效率。&lt;strong&gt;这一点也体现了程序局部性原理中的空间局部性特征&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当CPU Adjacent Sector Prefetch特性被disabled禁用时，CPU就只会获取当前请求数据所在的缓存行，不会预取下一个缓存行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在当&lt;code&gt;CPU Adjacent Sector Prefetch&lt;/code&gt;启用（enabled）的时候，CPU其实同时处理的是两个缓存行，在这种情况下，就需要填充两倍缓存行大小（128字节）来避免CPU Adjacent Sector Prefetch所带来的的FalseSharding问题。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;@Contended标注在字段上&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FalseSharding&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Contended&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; a;&lt;br/&gt;    &lt;span&gt;@Contended&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; b;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; c;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; d;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20806451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rYjQZSvYydAafvXRFNYjiciax54q8PDibqKWRPZH4ZCTksjmkAurvXd7sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次我们将 @Contended注解标注在了FalseSharding示例类中的字段a和字段b上，这样带来的效果是字段a和字段b各自独占缓存行。从内存布局上看，字段a和字段b前后分别被填充了128个字节，来确保字段a和字段b不与任何数据共享缓存行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而没有被@Contended注解标注字段c和字段d则在内存中连续存储，可以共享缓存行。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;@Contended分组&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FalseSharding&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Contended&lt;/span&gt;(&lt;span&gt;&quot;group1&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a;&lt;br/&gt;    &lt;span&gt;@Contended&lt;/span&gt;(&lt;span&gt;&quot;group1&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; b;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Contended&lt;/span&gt;(&lt;span&gt;&quot;group2&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;  c;&lt;br/&gt;    &lt;span&gt;@Contended&lt;/span&gt;(&lt;span&gt;&quot;group2&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; d;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20967741935483872&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r31YIiaAib4AemgAaw7rdkMDg478ibd9mt4B70FkK7YvsBEa7Eribqe6Ylg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次我们将字段a与字段b放在同一content group下，字段c与字段d放在另一个content group下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样处在同一分组&lt;code&gt;group1&lt;/code&gt;下的字段a与字段b在内存中是连续存储的，可以共享缓存行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理处在同一分组group2下的字段c与字段d在内存中也是连续存储的，也允许共享缓存行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;但是分组之间是不能共享缓存行的&lt;/strong&gt;，所以在字段分组的前后各填充&lt;code&gt;128字节&lt;/code&gt;，来保证分组之间的变量不能共享缓存行。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 内存对齐&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过以上内容我们了解到Java对象中的实例数据区字段需要进行内存对齐而导致在JVM中会被重排列以及通过填充缓存行避免false sharding的目的所带来的字节对齐填充。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也了解到内存对齐不仅发生在对象与对象之间，也发生在对象中的字段之间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么在本小节中笔者将为大家介绍什么是内存对齐，在本节的内容开始之前笔者先来抛出两个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;为什么要进行内存对齐？如果就是头比较铁，就是不内存对齐，会产生什么样的后果？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Java 虚拟机堆中对象的起始地址为什么需要对齐至 &lt;code&gt;8&lt;/code&gt;的倍数？为什么不对齐至4的倍数或16的倍数或32的倍数呢？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;带着这两个问题，下面我们正式开始本节的内容~~~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1 内存结构&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们平时所称的内存也叫随机访问存储器（random-access memory）也叫RAM。而RAM分为两类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;一类是静态RAM（&lt;code&gt;SRAM&lt;/code&gt;），这类SRAM用于前边介绍的CPU高速缓存L1Cache，L2Cache，L3Cache。其特点是访问速度快，访问速度为&lt;code&gt;1 - 30个&lt;/code&gt;时钟周期，但是容量小，造价高。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;另一类则是动态RAM(&lt;code&gt;DRAM&lt;/code&gt;)，这类DRAM用于我们常说的主存上，其特点的是访问速度慢（相对高速缓存），访问速度为&lt;code&gt;50 - 200个&lt;/code&gt;时钟周期，但是容量大，造价便宜些（相对高速缓存）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存由一个一个的存储器模块（memory module）组成，它们插在主板的扩展槽上。常见的存储器模块通常以&lt;strong&gt;64位为单位（8个字节）&lt;/strong&gt;传输数据到存储控制器上或者从存储控制器传出数据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42318840579710143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rnrSgvb85ibv3U8g3LG5F8RVIA7kRicdROicicYCcnrISY4QFwhgakZhib0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;345&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图所示内存条上黑色的元器件就是存储器模块（memory module）。多个存储器模块连接到存储控制器上，就聚合成了主存。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.582258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rHJU9YqekfN52K1HLNncfs3WqVP9hde7eVPeat9VIddbGgEn7nLyZ6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;内存结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而前边介绍到的&lt;code&gt;DRAM芯片&lt;/code&gt;就包装在存储器模块中，每个存储器模块中包含&lt;code&gt;8个DRAM芯片&lt;/code&gt;，依次编号为&lt;code&gt;0 - 7&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5225806451612903&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rB3u6R4hGOFJRfKU90sxBFYVaR2ia3YBMKsXxxPkRXAibueRUZOZkM0zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;存储器模块.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而每一个&lt;code&gt;DRAM芯片&lt;/code&gt;的存储结构是一个二维矩阵，二维矩阵中存储的元素我们称为超单元（&lt;code&gt;supercell&lt;/code&gt;），每个supercell大小为一个字节（&lt;code&gt;8 bit&lt;/code&gt;）。每个supercell都由一个坐标地址（i，j）。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;i表示二维矩阵中的行地址，在计算机中行地址称为RAS(row access strobe，行访问选通脉冲)。j表示二维矩阵中的列地址，在计算机中列地址称为CAS(column access strobe,列访问选通脉冲)。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图中的supercell的RAS = 2，CAS = 2。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4161290322580645&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rTpkjjIriaZlz2u5aBwkVibNANtyB4fF4X9NxbbUuuCLmwtAeAoY1LsibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;DRAM结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;DRAM芯片&lt;/code&gt;中的信息通过引脚流入流出DRAM芯片。每个引脚携带&lt;code&gt;1 bit&lt;/code&gt;的信号。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图中DRAM芯片包含了两个地址引脚(&lt;code&gt;addr&lt;/code&gt;)，因为我们要通过RAS，CAS来定位要获取的&lt;code&gt;supercell&lt;/code&gt;。还有8个数据引脚（&lt;code&gt;data&lt;/code&gt;）,&lt;strong&gt;因为DRAM芯片的IO单位为一个字节（8 bit）&lt;/strong&gt;,所以需要8个data引脚从DRAM芯片传入传出数据。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意这里只是为了解释地址引脚和数据引脚的概念，实际硬件中的引脚数量是不一定的。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 DRAM芯片的访问&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们现在就以读取上图中坐标地址为（2，2）的supercell为例，来说明访问DRAM芯片的过程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6290322580645161&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r7jkYERTnvHcJ8wQkly8dUiba6vorz5ziaEibDOA22B7QySuibElTW2o2pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;DRAM芯片访问.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;首先存储控制器将行地址&lt;code&gt;RAS = 2&lt;/code&gt;通过地址引脚发送给&lt;code&gt;DRAM芯片&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DRAM芯片根据&lt;code&gt;RAS = 2&lt;/code&gt;将二维矩阵中的第二行的全部内容拷贝到&lt;code&gt;内部行缓冲区&lt;/code&gt;中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;接下来存储控制器会通过地址引脚发送&lt;code&gt;CAS = 2&lt;/code&gt;到DRAM芯片中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DRAM芯片从内部行缓冲区中根据&lt;code&gt;CAS = 2&lt;/code&gt;拷贝出第二列的supercell并通过数据引脚发送给存储控制器。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;DRAM芯片的IO单位为一个supercell，也就是一个字节(8 bit)。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3 CPU如何读写主存&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边我们介绍了内存的物理结构，以及如何访问内存中的DRAM芯片获取supercell中存储的数据（&lt;code&gt;一个字节&lt;/code&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本小节我们来介绍下CPU是如何访问内存的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4443548387096774&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rBuTZIXQof8eoW6ibAYpcULFoibX0dKoES48Y3vG39BQibhEfbPtIuvMdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;CPU与内存之间的总线结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中关于CPU芯片的内部结构我们在介绍false sharding的时候已经详细的介绍过了，这里我们主要聚焦在CPU与内存之间的总线架构上。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.1 总线结构&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU与内存之间的数据交互是通过总线（bus）完成的，而数据在总线上的传送是通过一系列的步骤完成的，这些步骤称为总线事务（bus transaction）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中数据从内存传送到CPU称之为&lt;code&gt;读事务（read transaction）&lt;/code&gt;，数据从CPU传送到内存称之为&lt;code&gt;写事务（write transaction）&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总线上传输的信号包括：地址信号，数据信号，控制信号。其中控制总线上传输的控制信号可以同步事务，并能够标识出当前正在被执行的事务信息：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当前这个事务是到内存的？还是到磁盘的？或者是到其他IO设备的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这个事务是读还是写？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;总线上传输的地址信号（&lt;code&gt;内存地址&lt;/code&gt;），还是数据信号（&lt;code&gt;数据&lt;/code&gt;）？。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;还记得我们前边讲到的MESI缓存一致性协议吗？当core0修改字段a的值时，其他CPU核心会在总线上&lt;code&gt;嗅探&lt;/code&gt;字段a的内存地址，如果嗅探到总线上出现字段a的内存地址，说明有人在修改字段a，这样其他CPU核心就会&lt;code&gt;失效&lt;/code&gt;自己缓存字段a所在的&lt;code&gt;cache line&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，其中系统总线是连接CPU与IO bridge的，存储总线是来连接IO bridge和主存的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;IO bridge&lt;/code&gt;负责将系统总线上的电子信号转换成存储总线上的电子信号。IO bridge也会将系统总线和存储总线连接到IO总线（磁盘等IO设备）上。这里我们看到IO bridge其实起的作用就是转换不同总线上的电子信号。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.2 CPU从内存读取数据过程&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设CPU现在要将内存地址为&lt;code&gt;A&lt;/code&gt;的内容加载到寄存器中进行运算。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4596774193548387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rN11lLbPfeAJzGCk3REBStPEKsvn2pemCqM0ib5C8OKcnNp9IicOq0toA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;CPU读取内存.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先CPU芯片中的&lt;code&gt;总线接口&lt;/code&gt;会在总线上发起读事务（&lt;code&gt;read transaction&lt;/code&gt;）。该读事务分为以下步骤进行：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CPU将内存地址A放到系统总线上。随后&lt;code&gt;IO bridge&lt;/code&gt;将信号传递到存储总线上。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;主存感受到存储总线上的&lt;code&gt;地址信号&lt;/code&gt;并通过存储控制器将存储总线上的内存地址A读取出来。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储控制器通过内存地址A定位到具体的存储器模块，从&lt;code&gt;DRAM芯片&lt;/code&gt;中取出内存地址A对应的&lt;code&gt;数据X&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储控制器将读取到的&lt;code&gt;数据X&lt;/code&gt;放到存储总线上，随后IO bridge将&lt;code&gt;存储总线&lt;/code&gt;上的数据信号转换为&lt;code&gt;系统总线&lt;/code&gt;上的数据信号，然后继续沿着系统总线传递。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CPU芯片感受到系统总线上的数据信号，将数据从系统总线上读取出来并拷贝到寄存器中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是CPU读取内存数据到寄存器中的完整过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是其中还涉及到一个重要的过程，这里我们还是需要摊开来介绍一下，那就是存储控制器如何通过&lt;code&gt;内存地址A&lt;/code&gt;从主存中读取出对应的&lt;code&gt;数据X&lt;/code&gt;的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们结合前边介绍的内存结构以及从DRAM芯片读取数据的过程，来总体介绍下如何从主存中读取数据。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.3 如何根据内存地址从主存中读取数据&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边介绍到，当主存中的存储控制器感受到了存储总线上的&lt;code&gt;地址信号&lt;/code&gt;时，会将内存地址从存储总线上读取出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后会通过内存地址定位到具体的存储器模块。还记得内存结构中的存储器模块吗？？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.582258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rHJU9YqekfN52K1HLNncfs3WqVP9hde7eVPeat9VIddbGgEn7nLyZ6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;内存结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而每个存储器模块中包含了8个DRAM芯片，编号从&lt;code&gt;0 - 7&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5225806451612903&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rB3u6R4hGOFJRfKU90sxBFYVaR2ia3YBMKsXxxPkRXAibueRUZOZkM0zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;存储器模块.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;存储控制器会将内存地址转换为DRAM芯片中supercell在二维矩阵中的坐标地址(&lt;code&gt;RAS&lt;/code&gt;，&lt;code&gt;CAS&lt;/code&gt;)。并将这个坐标地址发送给对应的存储器模块。随后存储器模块会将&lt;code&gt;RAS&lt;/code&gt;和&lt;code&gt;CAS&lt;/code&gt;广播到存储器模块中的所有&lt;code&gt;DRAM芯片&lt;/code&gt;。依次通过(&lt;code&gt;RAS&lt;/code&gt;，&lt;code&gt;CAS&lt;/code&gt;)从DRAM0到DRAM7读取到相应的supercell。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6290322580645161&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r7jkYERTnvHcJ8wQkly8dUiba6vorz5ziaEibDOA22B7QySuibElTW2o2pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;DRAM芯片访问.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道一个supercell存储了&lt;code&gt;8 bit&lt;/code&gt;数据，这里我们从DRAM0到DRAM7
依次读取到了8个supercell也就是&lt;code&gt;8个字节&lt;/code&gt;，然后将这8个字节返回给存储控制器，由存储控制器将数据放到存储总线上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;CPU总是以word size为单位从内存中读取数据，在64位处理器中的word size为8个字节。64位的内存也只能每次吞吐8个字节。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;CPU每次会向内存读写一个&lt;code&gt;cache line&lt;/code&gt;大小的数据（&lt;code&gt;64个字节&lt;/code&gt;），但是内存一次只能吞吐&lt;code&gt;8个字节&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在内存地址对应的存储器模块中，&lt;code&gt;DRAM0芯片&lt;/code&gt;存储第一个低位字节（supercell），&lt;code&gt;DRAM1芯片&lt;/code&gt;存储第二个字节，......依次类推&lt;code&gt;DRAM7芯片&lt;/code&gt;存储最后一个高位字节。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;内存一次读取和写入的单位是8个字节。而且在程序员眼里连续的内存地址实际上在物理上是不连续的&lt;/strong&gt;。因为这连续的&lt;code&gt;8个字节&lt;/code&gt;其实是存储于不同的&lt;code&gt;DRAM芯片&lt;/code&gt;上的。每个DRAM芯片存储一个字节（supercell）。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6540322580645161&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rxuq3wSWAjzItUEATFbumn4CQ3nngGbG9ibK9ymH6xUCFiaicMicPzvBicMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;读取存储器模块数据.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.4 CPU向内存写入数据过程&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们现在假设CPU要将寄存器中的数据X写到内存地址A中。同样的道理，CPU芯片中的总线接口会向总线发起写事务（&lt;code&gt;write transaction&lt;/code&gt;）。写事务步骤如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CPU将要写入的内存地址A放入系统总线上。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过&lt;code&gt;IO bridge&lt;/code&gt;的信号转换，将内存地址A传递到存储总线上。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储控制器感受到存储总线上的地址信号，将内存地址A从存储总线上读取出来，并等待数据的到达。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CPU将寄存器中的数据拷贝到系统总线上，通过&lt;code&gt;IO bridge&lt;/code&gt;的信号转换，将数据传递到存储总线上。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储控制器感受到存储总线上的数据信号，将数据从存储总线上读取出来。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储控制器通过内存地址A定位到具体的存储器模块，最后将数据写入存储器模块中的8个DRAM芯片中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 为什么要内存对齐&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在了解了内存结构以及CPU读写内存的过程之后，现在我们回过头来讨论下本小节开头的问题：为什么要内存对齐？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面笔者从三个方面来介绍下要进行内存对齐的原因：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;速度&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU读取数据的单位是根据&lt;code&gt;word size&lt;/code&gt;来的，在64位处理器中&lt;code&gt;word size = 8字节&lt;/code&gt;，所以CPU向内存读写数据的单位为&lt;code&gt;8字节&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在64位内存中，内存IO单位为&lt;code&gt;8个字节&lt;/code&gt;，我们前边也提到内存结构中的存储器模块通常以64位为单位（8个字节）传输数据到存储控制器上或者从存储控制器传出数据。因为每次内存IO读取数据都是从数据所在具体的存储器模块中包含的这8个DRAM芯片中以相同的(&lt;code&gt;RAM&lt;/code&gt;,&lt;code&gt;CAS&lt;/code&gt;)依次读取一个字节，然后在存储控制器中聚合成&lt;code&gt;8个字节&lt;/code&gt;返回给CPU。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6540322580645161&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rxuq3wSWAjzItUEATFbumn4CQ3nngGbG9ibK9ymH6xUCFiaicMicPzvBicMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;读取存储器模块数据.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;由于存储器模块中这种由8个DRAM芯片组成的物理存储结构的限制，内存读取数据只能是按照地址顺序8个字节的依次读取----8个字节8个字节地来读取数据。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4685483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3ribMl20O9znTgEfP42FRNnCSg4ELsbIIU6r0se5xGJs9cHfLeqWUqibyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;内存IO单位.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;假设我们现在读取&lt;code&gt;0x0000 - 0x0007&lt;/code&gt;这段连续内存地址上的8个字节。由于内存读取是按照&lt;code&gt;8个字节&lt;/code&gt;为单位依次顺序读取的，&lt;strong&gt;而我们要读取的这段内存地址的起始地址是0（8的倍数）&lt;/strong&gt;，所以0x0000 - 0x0007中每个地址的坐标都是相同的（&lt;code&gt;RAS&lt;/code&gt;,&lt;code&gt;CAS&lt;/code&gt;）。所以他可以在8个DRAM芯片中通过相同的（&lt;code&gt;RAS&lt;/code&gt;,&lt;code&gt;CAS&lt;/code&gt;）一次性读取出来。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果我们现在读取&lt;code&gt;0x0008 - 0x0015&lt;/code&gt;这段连续内存上的8个字节也是一样的，&lt;strong&gt;因为内存段起始地址为8（8的倍数）&lt;/strong&gt;，所以这段内存上的每个内存地址在DREAM芯片中的坐标地址（&lt;code&gt;RAS&lt;/code&gt;,&lt;code&gt;CAS&lt;/code&gt;）也是相同的，我们也可以一次性读取出来。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：&lt;code&gt;0x0000 - 0x0007&lt;/code&gt;内存段中的坐标地址（RAS,CAS）与&lt;code&gt;0x0008 - 0x0015&lt;/code&gt;内存段中的坐标地址（RAS,CAS）是不相同的。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;但如果我们现在读取&lt;code&gt;0x0007 - 0x0014&lt;/code&gt;这段连续内存上的8个字节情况就不一样了，由于起始地址&lt;code&gt;0x0007&lt;/code&gt;在DRAM芯片中的（RAS,CAS）与后边地址&lt;code&gt;0x0008 - 0x0014&lt;/code&gt;的（RAS,CAS）不相同，所以CPU只能先从&lt;code&gt;0x0000 - 0x0007&lt;/code&gt;读取8个字节出来先放入&lt;code&gt;结果寄存器&lt;/code&gt;中并左移7个字节（目的是只获取&lt;code&gt;0x0007&lt;/code&gt;），然后CPU在从&lt;code&gt;0x0008 - 0x0015&lt;/code&gt;读取8个字节出来放入临时寄存器中并右移1个字节（目的是获取&lt;code&gt;0x0008 - 0x0014&lt;/code&gt;）最后与结果寄存器&lt;code&gt;或运算&lt;/code&gt;。最终得到&lt;code&gt;0x0007 - 0x0014&lt;/code&gt;地址段上的8个字节。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从以上分析过程来看，当CPU访问内存对齐的地址时，比如&lt;code&gt;0x0000&lt;/code&gt;和&lt;code&gt;0x0008&lt;/code&gt;这两个起始地址都是对齐至&lt;code&gt;8的倍数&lt;/code&gt;。CPU可以通过一次read transaction读取出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是当CPU访问内存没有对齐的地址时，比如&lt;code&gt;0x0007&lt;/code&gt;这个起始地址就没有对齐至&lt;code&gt;8的倍数&lt;/code&gt;。CPU就需要两次read transaction才能将数据读取出来。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;还记得笔者在小节开头提出的问题吗  ？&quot;Java 虚拟机堆中对象的&lt;code&gt;起始地址&lt;/code&gt;为什么需要对齐至 &lt;code&gt;8的倍数&lt;/code&gt;？为什么不对齐至4的倍数或16的倍数或32的倍数呢？&quot;
现在你能回答了吗？？？&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;原子性&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU可以原子地操作一个对齐的word size memory。64位处理器中&lt;code&gt;word size = 8字节&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;尽量分配在一个缓存行中&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边在介绍&lt;code&gt;false sharding&lt;/code&gt;的时候我们提到目前主流处理器中的&lt;code&gt;cache line&lt;/code&gt;大小为&lt;code&gt;64字节&lt;/code&gt;，堆中对象的起始地址通过内存对齐至&lt;code&gt;8的倍数&lt;/code&gt;，可以让对象尽可能的分配到一个缓存行中。&lt;strong&gt;一个内存起始地址未对齐的对象可能会跨缓存行存储，这样会导致CPU的执行效率慢2倍&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中对象中字段内存对齐的其中一个重要原因也是让字段只出现在同一 CPU 的缓存行中。如果字段不是对齐的，那么就有可能出现跨缓存行的字段。也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。这两种情况对程序的执行效率而言都是不利的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外在《2. 字段重排列》这一小节介绍的三种字段对齐规则，&lt;strong&gt;是保证在字段内存对齐的基础上使得实例数据区占用内存尽可能的小&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. 压缩指针&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在介绍完关于内存对齐的相关内容之后，我们来介绍下前边经常提到的压缩指针。可以通过JVM参数&lt;code&gt;XX:+UseCompressedOops&lt;/code&gt;开启，当然默认是开启的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本小节内容开启之前，我们先来讨论一个问题，&lt;strong&gt;那就是为什么要使用压缩指针？？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们现在正在准备将32位系统切换到64位系统，起初我们可能会期望系统性能会立马得到提升，但现实情况可能并不是这样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JVM中导致性能下降的最主要原因就是64位系统中的&lt;code&gt;对象引用&lt;/code&gt;。在前边我们也提到过，64位系统中对象的引用以及类型指针占用&lt;code&gt;64 bit&lt;/code&gt;也就是8个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就导致了在64位系统中的对象引用占用的内存空间是32位系统中的两倍大小，因此间接的导致了在64位系统中更多的内存消耗以及更频繁的GC发生，GC占用的CPU时间越多，那么我们的应用程序占用CPU的时间就越少。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外一个就是对象的引用变大了，那么CPU可缓存的对象相对就少了，增加了对内存的访问。综合以上几点从而导致了系统性能的下降。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从另一方面来说，在64位系统中内存的寻址空间为&lt;code&gt;2^48 = 256T&lt;/code&gt;，在现实情况中我们真的需要这么大的寻址空间吗？？好像也没必要吧~~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;于是我们就有了新的想法：那么我们是否应该切换回32位系统呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们切换回32位系统，我们怎么解决在32位系统中拥有超过&lt;code&gt;4G&lt;/code&gt;的内存寻址空间呢？因为现在4G的内存大小对于现在的应用来说明显是不够的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我想以上的这些问题，也是当初JVM的开发者需要面对和解决的，当然他们也交出了非常完美的答卷，那就是&lt;strong&gt;使用压缩指针可以在64位系统中利用32位的对象引用获得超过4G的内存寻址空间&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.1 压缩指针是如何做到的呢？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还记得之前我们在介绍对齐填充和内存对齐小节中提到的，在Java虚拟机堆中对象的起始地址必须对齐至&lt;code&gt;8的倍数&lt;/code&gt;吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于堆中对象的起始地址均是对齐至8的倍数，所以对象引用在开启压缩指针情况下的32位二进制的后三位始终是&lt;code&gt;0&lt;/code&gt;（因为它们始终可以被8整除）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然JVM已经知道了这些对象的内存地址后三位始终是0，那么这些无意义的0就没必要在堆中继续存储。相反，我们可以利用存储0的这3位bit存储一些有意义的信息，这样我们就多出&lt;code&gt;3位bit&lt;/code&gt;的寻址空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样在存储的时候，JVM还是按照32位来存储，只不过后三位原本用来存储0的bit现在被我们用来存放有意义的地址空间信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当寻址的时候，JVM将这32位的对象引用&lt;code&gt;左移3位&lt;/code&gt;（后三位补0）。这就导致了在开启压缩指针的情况下，我们原本32位的内存寻址空间一下变成了&lt;code&gt;35位&lt;/code&gt;。可寻址的内存空间变为2^32 * 2^3 = 32G。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3604838709677419&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rV5yqCxeLpAbBDYhzdviaBKhfRic98w2ZC93tRwyBMHgg0Ku4iaQdjUicTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;压缩指针.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这样一来，JVM虽然额外的执行了一些位运算但是极大的提高了寻址空间，并且将对象引用占用内存大小降低了一半，节省了大量空间。况且这些位运算对于CPU来说是非常容易且轻量的操作&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过压缩指针的原理我挖掘到了&lt;strong&gt;内存对齐的另一个重要原因&lt;/strong&gt;就是通过内存对齐至&lt;code&gt;8的倍数&lt;/code&gt;，我们可以在64位系统中使用压缩指针通过32位的对象引用将寻址空间提升至&lt;code&gt;32G&lt;/code&gt;.&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;从Java7开始，当maximum heap size小于32G的时候，压缩指针是默认开启的。但是当maximum heap size大于32G的时候，压缩指针就会关闭。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那么我们如何在压缩指针开启的情况下进一步扩大寻址空间呢？？？&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.2 如何进一步扩大寻址空间&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边提到我们在Java虚拟机堆中对象起始地址均需要对其至&lt;code&gt;8的倍数&lt;/code&gt;，不过这个数值我们可以通过JVM参数&lt;code&gt;-XX:ObjectAlignmentInBytes &lt;/code&gt;来改变（默认值为8）。当然这个数值的必须是2的次幂，数值范围需要在&lt;code&gt;8 - 256之间&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正是因为对象地址对齐至8的倍数，才会多出3位bit让我们存储额外的地址信息，进而将4G的寻址空间提升至32G。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的道理，如果我们将&lt;code&gt;ObjectAlignmentInBytes&lt;/code&gt;的数值设置为16呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对象地址均对齐至16的倍数，那么就会多出4位bit让我们存储额外的地址信息。寻址空间变为2^32 * 2^4 = 64G。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过以上规律，我们就能知道，在64位系统中开启压缩指针的情况，寻址范围的计算公式：&lt;code&gt;4G * ObjectAlignmentInBytes = 寻址范围&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是笔者并不建议大家贸然这样做，因为增大了&lt;code&gt;ObjectAlignmentInBytes&lt;/code&gt;虽然能扩大寻址范围，但是这同时也可能增加了对象之间的字节填充，导致压缩指针没有达到原本节省空间的效果。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8. 数组对象的内存布局&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边大量的篇幅我们都是在讨论Java普通对象在内存中的布局情况，最后这一小节我们再来说下Java中的数组对象在内存中是如何布局的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.1 基本类型数组的内存布局&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6774193548387096&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rpzq9LdqXNnfBciatEr9eg01iaTDSTZ4vJNqPBDqKeoXOdLryulBJPPzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;基本类型数组内存布局.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图表示的是基本类型数组在内存中的布局，基本类型数组在JVM中用&lt;code&gt;typeArrayOop&lt;/code&gt;结构体表示，基本类型数组类型元信息用&lt;code&gt;TypeArrayKlass &lt;/code&gt;结构体表示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数组的内存布局大体上和普通对象的内存布局差不多，唯一不同的是在数组类型对象头中多出了&lt;code&gt;4个字节&lt;/code&gt;用来表示数组长度的部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是分别以开启指针压缩和关闭指针压缩两种情况，通过下面的例子来进行说明：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;long&lt;/span&gt;[] longArrayLayout = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;[&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;开启指针压缩 -XX:+UseCompressedOops&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.12016129032258065&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rXQQicaytwdQoSvqrB3XCyoK1odU5kU3pqUFASKOyS4n6kdPgs7nIsGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到红框部分即为数组类型对象头中多出来一个&lt;code&gt;4字节&lt;/code&gt;大小用来表示数组长度的部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为我们示例中的long型数组只有一个元素，所以实例数据区的大小只有8字节。如果我们示例中的long型数组变为两个元素，那么实例数据区的大小就会变为16字节，以此类推................。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;关闭指针压缩  -XX:-UseCompressedOops&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.14919354838709678&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rrKkFvaCtPYvpI7x4FYk4eibF6d4NnXuGr365gsJ7WXXSVXWusuykxUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当关闭了指针压缩时，对象头中的MarkWord还是占用8个字节，但是类型指针从4个字节变为了8个字节。数组长度属性还是不变保持4个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们发现是实例数据区与对象头之间发生了对齐填充。大家还记得这是为什么吗？？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们前边在字段重排列小节介绍了三种字段排列规则在这里继续适用：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;规则1&lt;/code&gt;：如果一个字段占用&lt;code&gt;X&lt;/code&gt;个字节，那么这个字段的偏移量OFFSET需要对齐至&lt;code&gt;NX&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;规则2&lt;/code&gt;：在开启了压缩指针的64位JVM中，Java类中的第一个字段的OFFSET需要对齐至&lt;code&gt;4N&lt;/code&gt;，在关闭压缩指针的情况下类中第一个字段的OFFSET需要对齐至&lt;code&gt;8N&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里基本数组类型的实例数据区中是long型，在关闭指针压缩的情况下，根据规则1和规则2需要对齐至8的倍数，所以要在其与对象头之间填充4个字节，达到内存对齐的目的，起始地址变为&lt;code&gt;24&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.2 引用类型数组的内存布局&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6774193548387096&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rJsDCu7IWm5Lp5iaW2XTDpfRfQq8Fhuf4wGqPcgc2d7agzX7VGZhNxkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;引用类型数组的内存布局.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图表示的是引用类型数组在内存中的布局，引用类型数组在JVM中用&lt;code&gt;objArrayOop&lt;/code&gt;结构体表示，基本类型数组类型元信息用&lt;code&gt;ObjArrayKlass &lt;/code&gt;结构体表示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样在引用类型数组的对象头中也会有一个&lt;code&gt;4字节&lt;/code&gt;大小用来表示数组长度的部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是分别以开启指针压缩和关闭指针压缩两种情况，通过下面的例子来进行说明：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ReferenceArrayLayout&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; a;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; b;&lt;br/&gt;    &lt;span&gt;short&lt;/span&gt; c;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;ReferenceArrayLayout[] referenceArrayLayout = &lt;span&gt;new&lt;/span&gt; ReferenceArrayLayout[&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;开启指针压缩 -XX:+UseCompressedOops&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1782258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rI0EhfK0wH5ZBVhiaeHn6PNB7xIhtpjgIEbGw5yWHstINGM9brJqh2KQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引用数组类型内存布局与基础数组类型内存布局最大的不同在于它们的实例数据区。由于开启了压缩指针，所以对象引用占用内存大小为&lt;code&gt;4个字节&lt;/code&gt;，而我们示例中引用数组只包含一个引用元素，所以这里实例数据区中只有4个字节。相同的到道理，如果示例中的引用数组包含的元素变为两个引用元素，那么实例数据区就会变为8个字节，以此类推......。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后由于Java对象需要内存对齐至&lt;code&gt;8的倍数&lt;/code&gt;，所以在该引用数组的实例数据区后填充了4个字节。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;关闭指针压缩 -XX:-UseCompressedOops&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16129032258064516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rqryHvFaRNvVKp50Hb27F97WroKVW73r2sHr1gxTWHT5bU5WBn8LrKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当关闭压缩指针时，对象引用占用内存大小变为了&lt;code&gt;8个字节&lt;/code&gt;，所以引用数组类型的实例数据区占用了8个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据字段重排列规则2，在引用数组类型对象头与实例数据区中间需要填充&lt;code&gt;4个字节&lt;/code&gt;以保证内存对齐的目的。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文笔者详细介绍了Java普通对象以及数组类型对象的内存布局，以及相关对象占用内存大小的计算方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以及在对象内存布局中的实例数据区字段重排列的三个重要规则。以及后边由字节的对齐填充引出来的false sharding问题，还有Java8为了解决false sharding而引入的@Contented注解的原理及使用方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了讲清楚内存对齐的底层原理，笔者还花了大量的篇幅讲解了内存的物理结构以及CPU读写内存的完整过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后又由内存对齐引出了压缩指针的工作原理。由此我们知道进行内存对齐的四个原因：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;CPU访问性能&lt;/code&gt;：当CPU访问内存对齐的地址时，可以通过一个read transaction读取一个字长（word size）大小的数据出来。否则就需要两个read transaction。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;原子性&lt;/code&gt;：CPU可以原子地操作一个对齐的word size memory。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;尽可能利用CPU缓存&lt;/code&gt;：内存对齐可以使对象或者字段尽可能的被分配到一个缓存行中，避免跨缓存行存储，导致CPU执行效率减半。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;提升压缩指针的内存寻址空间：&lt;/code&gt; 对象与对象之间的内存对齐，可以使我们在64位系统中利用32位对象引用将内存寻址空间提升至32G。既降低了对象引用的内存占用，又提升了内存寻址空间。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本文中我们顺带还介绍了和内存布局相关的几个JVM参数：-XX:+UseCompressedOops&lt;code&gt;,&lt;/code&gt; -XX +CompactFields &lt;code&gt;,&lt;/code&gt;-XX:-RestrictContended &lt;code&gt;,&lt;/code&gt;-XX:ContendedPaddingWidth&lt;code&gt;,&lt;/code&gt; -XX:ObjectAlignmentInBytes。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后感谢大家能看到这里，我们下篇文章再见~~~&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>