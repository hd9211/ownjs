<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f8028b4fcba6fdffdceecadd411cf538</guid>
<title>欢迎加入读者圈子，一起交流！</title>
<link>https://toutiao.io/k/mtrqmru</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎加入读者圈子，一起交流！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;307&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavich3VaNkKeiaAwUhz7TQbQmic4fFsr58X9PAYleYzxqc1K1vZjeBoZDMUsmia0xH67EQYINGRvNOtLmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;圈子剧透&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、600+圈子成员，以中高级程序员为主，更有架构师、CTO坐镇交流；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、1000+优质主题，数十G独家资料，每日分享，精挑细选；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、全年52期专属邮件周报，让你轻松掌握业界资讯、技术干货，提升认知水平；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、全年52本好书共读，让你花最少的时间，获取更好的知识；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;心动不如行动，赶快加入吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f0aabe75dc08dfc39a6687f55bbd3a6b</guid>
<title>异步编程指北</title>
<link>https://toutiao.io/k/k2ezpp7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：michaeywang，腾讯 IEG 运营开发工程师&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;同步、异步，并发、并行、串行，这些名词在我们的开发中会经常遇到，这里对异步编程做一个详细的归纳总结，希望可以对这方面的开发有一些帮助。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.997229916897507&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauOU3MiafJjWoUFmu0xNSBoxa7rZUyzDKsLgdgLo9kawVhtJAy0QicQ3akSUaLChic9ic5ZXj3UxnLXDQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1083&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1 几个名词的概念&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多任务的时候，才会遇到的情况，如：同步、异步，并发、并行。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1 理清它们的基本概念&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发：多个任务在同一个时间段内同时执行，如果是单核心计算机，CPU 会不断地切换任务来完成并发操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并行：多任务在同一个时刻同时执行，计算机需要有多核心，每个核心独立执行一个任务，多个任务同时执行，不需要切换。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同步：多任务开始执行，任务 A、B、C 全部执行完成后才算是结束。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步：多任务开始执行，只需要主任务 A 执行完成就算结束，主任务执行的时候，可以同时执行异步任务 B、C，主任务 A 可以不需要等待异步任务 B、C 的结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发、并行，是逻辑结构的设计模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同步、异步，是逻辑调用方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;串行是同步的一种实现，就是没有并发，所有任务一个一个执行完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发、并行是异步的 2 种实现方式。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2 举一个例子&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7344461305007587&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauOU3MiafJjWoUFmu0xNSBoxyB5k2fZT54ETVng4YrGKDSN9Vic8ukVZJ4DmEXmGwdl8FooGCGlIYug/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;659&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你的朋友在广州，但是有 2 辆小汽车在深圳，需要你帮忙把这 2 辆小汽车送到广州去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同步的方式，你先开一辆小汽车到广州，然后再坐火车回深圳，再开另外一辆小汽车去广州。这是串行的方法，2 辆车需要的时间也就更长了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步的方式，你开一辆小汽车从深圳去广州，同时请一个代驾把另外一辆小汽车从深圳开去广州。这也就是并行方法，两个人两辆车，可以同时行驶，速度很快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发的方式，你一个人，先开一辆车走 500 米，停车跑回来，再开另外一辆车前行 1000 米，停车再跑回来，循环从深圳往广州开。并发的方式，你可以把 2 辆车一块送到朋友手里，但是过程还是很辛苦的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3 思考问题&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你找一家汽车托运公司，把 2 辆车一起托运到广州。这种方式是同步、异步，并发、并行的哪种情况呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2 并发/并行执行会遇到的问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 问题 1：并发的任务数量控制&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauOU3MiafJjWoUFmu0xNSBoxvNBv9I1BnM4bVEPSCRek7ibjt6sLUicxTgeicnk8bC5NmmNOacBtkjbGg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设：某个接口的并发请求会达到 1 万的 qps，所以对接口的性能、响应时长都要求很高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口内部又有大量 redis、mysql 数据读写，程序中还有很多处理逻辑。如果接口内的所有逻辑处理、数据调用都是串行化，那么单个请求耗时可能会超过 100ms，为了性能优化，就会把数据读取的部分与逻辑计算的部分分开来考虑和实现，能够独立的部分单独剥离出来作为异步任务来执行，这样就把串行化的耗时优化为并发执行，充分利用多核计算机的性能，减少单个接口请求的耗时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设的数据具体化，如：这个接口的数据全部是可以独立获取(支持并发)，需要读取来自不同数据结构的 redis 共 10 个，读取不同数据表的数据共 10 个。那么一次请求，数据获取就会启动 10 个 redis 读取任务，10 个 mysql 读取任务。每秒钟 1 万接口请求，会有 10 万个 redis 读取任务和 10 万个 mysql 读取任务。这 21 万的并发任务，在一秒钟内由 16/32 核的后端部署单机来完成，虽然在同一时刻的任务数量不一定会是 21 万(速度快的话会少于 21 万，如果处理速度慢，出现请求积压拥堵，会超过 21 万)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候，会遇到的瓶颈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;内存，如果每个任务需要 500k 内存，那么 210k*0.5M=210*0.5G=105G.&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU，任务调度，像 golang 的协程可能开销还小一些，如果是 java 的线程调度，操作系统会因为调度而空转。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网络，每次数据读取 5k，那么 200k&lt;em&gt;5k=200&lt;/em&gt;5M=1G.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;端口，端口号最多能分配出来 65536 个，明显不够用了。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据源，redis 可以支持 10 万 qps 的请求，但是 mysql 就难以支持 10 万 qps 了。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面可能出现的瓶颈中，通过计算机资源扩容可以解决大部分问题，比如：部署 50 个后端实例，每个实例只需要应对 200 的 qps，压力就小了很多。对于数据源，mysql 可以有多个 slave 来支持只读的请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，如果接口的并发量更大呢？或者某个/某些数据源读取出现异常，需要重试，或者出现拥堵，接口响应变慢，任务数量也就会出现暴增，后端服务的各方面瓶颈又会随之出现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我们需要特别注意和关心后端开启的异步任务数量，要做好异常情况的防范，及时中断掉拥堵/超时的任务，&lt;strong&gt;避免任务暴增导致整个服务不可用&lt;/strong&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 思考问题&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你要如何应对这类并发任务暴增的情况呢？如何提前预防？如何及时干预呢？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3 问题 2：共享数据的读写顺序和依赖关系&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;共享数据的并发读写，是并发编程中的老大难问题，如：读写脏数据，旧数据覆盖新数据等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而数据的依赖关系，也就决定了任务的执行先后顺序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了避免共享数据的竞争读写，为了保证任务的先后关系，就需要用到锁、队列等手段，这时候，并发的过程又被部分的拉平为串行化执行。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4 举个例子&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7616361071932299&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauOU3MiafJjWoUFmu0xNSBoxxNDAfL4jyFxSWOyv9ajJpyQ5ZYCBr8S1XWRjIacslt2qToiaE6aGTWg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1418&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://www.ticketmaster.com/eastern-conf-semis-tbd-at-boston-boston-massachusetts/event/01005C6AA5531A90&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NBA 季后赛，去现场看球，要抢购球票，体育馆最多容纳 1 万人(1 万张球票)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;体育馆不同距离、不同位置的票，价格和优惠都不相同。有单人位、有双人位，也有 3、4 人位。你约着朋友共 10 个人去看球，要买票，要选位置。这时候抢票就会很尴尬，因为位置连着的可能会被别人抢走，同时买的票越多，与人冲突的概率就越大，会导致抢票特别困难。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时，这个系统的开发也很头大，抢购(秒杀)的并发非常大，预计在开始的一秒钟会超过 10 万人同时进来，再加上刷票的机器人，接口请求量可能瞬间达到 100 万的 QPS。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;较简单的实现方式&lt;/strong&gt;，所有的请求都异步执行，订单全部进入消息队列，下单马上响应处理中，请等待。然后，后端程序再从消息队列中串行化处理每一个订单，把出现冲突的订单直接报错，这样，估计 1 秒钟可以处理 1000 个订单，10 秒钟可以处理 1 万个订单。考虑订单的冲突问题，1 万张球票的 9000 张可能在 30 秒内卖出去，此时只处理了 3 万个订单，第一秒钟进来的 100 万订单已经在消息队列中堆积，又有 30 秒钟的新订单进来，需要很久才可以把剩下的 1000 张球票卖出去啊。同理，下单的用户需要等待太久才知道自己的订单结果，这个过程轮询的请求也会很多很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;换一种方案，不使用队列串行化处理订单&lt;/strong&gt;，直接并发的处理每一个订单。那么处理流程中的数据都需要梳理清楚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1 针对每一个用户的请求加锁，避免同一个用户的重入；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2 每一个/组座位预生成一个 key:0，默认 0 说明没有下单；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3 预估平均每一个订单包含 2 个/组座位，需要更新 2 个座位 key；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4 下单的时候给座位 key 执行 INCR key 数字递增操作，只有返回 1 的订单才是成功，其他都是失败；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5 如果同一个订单中的座位 key 有冲突的情况下，需要回滚成功 key(INCR key = 1)重置(SET key 0);&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6 订单成功/失败，处理完成后，去掉用户的请求锁；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7 订单数据入库到 mysql(消息队列，避免 mysql 成为瓶颈);&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上，需要用到 1 个锁(2 次操作)，平均 2 个座位 key(每个座位号 1-2 次操作)，这里只有 2 个座位 key 可以并发更新。为了让 redis 不成为数据读写的瓶颈(超过 100w 的 QPS 写操作)，不能使用单实例模式，而要使用 redis 集群，使用由 10-20 个 redis 实例组成的集群，来支持这么高的 redis 数据读写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;算上 redis 数据读写、参数、异常、逻辑处理，一个请求大概耗时 10ms 左右，单核至少可以支持 100 并发，由于这里有大量 IO 处理，后端服务可以支持的并发可以更高些，预计单核 200 并发，16 核就可以支持 3200 并发。总共需要支持 100 万并发，预计需要 312 台后端服务器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方案比队列的方案需要的服务器资源更多，但是用户的等待时间很短，体验就好很多。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.5 思考问题&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际情况会是怎样呢？会有 10 万人同时抢票吗？会有 100 万的超高并发吗？订票系统真的会准备 300 多台服务器来应对抢票吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3 状态处理：忽略结果&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0940919037199124&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauOU3MiafJjWoUFmu0xNSBox0Kbz8zXyNJsZ1o5TVnZLJMrUCnfJ9icenGphm54Nv0BtvkdiaQ8icypAg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;457&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 使用场景和案例&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用场景，主流程之外的异步任务，可能重要程度不高，或者处理的复杂度太高，有时候会忽略异步任务的处理结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;案例 1：异步的数据上报、数据存储/计算/统计/分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;案例 2：模板化创建服务，有很多个任务，有前后关联任务，也有相互独立任务，有些执行速度很慢，有些任务失败后也可以手动重试来修复。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;忽略结果的情况，就会遇到下面的问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 问题 1：数据一致性&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看下案例 1 的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步的日志上报，是否成功发送到服务端呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步的指标数据上报，是否正确汇总统计和发送到服务端呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步的任务，数据发送到消息队列，是否被后端应用程序消费呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务端是否正常存储和处理完成呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果因为网络原因，因为并发量太大导致服务负载问题，因为程序 bug 的原因，导致数据没能正确上报和处理，这时候的数据不一致、丢失的问题，就会难以及时排查和事后补发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在本地完整记录一份数据，以备数据审查，又要考虑高并发高性能的瓶颈，毕竟本地日志读写性能受到磁盘速度的影响，性能会很差。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3 问题 2：功能可靠性&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看下案例 2 的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建服务的过程中，有创建代码仓库、开启日志采集和自定义镜像中心，CI/CD 等耗时很长的任务。这里开启日志采集和自定义镜像中心如果出现异常，对整个服务的运行没有影响，而且开发者发现问题后也可以自己手动操作下，再次开启日志采集和自定义镜像功能。所以在模板化处理中，这些异步处理任务就没有关注任务的状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题就很明显，模板化创建服务的过程中，是不能保证全部功能都正常执行完成的，会有部分功能可能有异常，而且也没有提示和后续指引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然模板化创建服务的程序，也可以把全部任务的状态都检查结果，只是会增加一些处理的复杂度和难度。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.4 思考问题&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际开发中，有遇到类似上面的两个案例吗？你会如何处理呢？所有的异步任务，都会检查状态结果吗？为什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4 状态处理：结果返回&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1 使用场景和案例&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大部分的异步任务对于状态结果还是很关注的，比如：后续的处理逻辑或者任务依赖某个异步任务，或者异步任务非常重要，需要把结果返回给请求方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;案例 1：模板化创建服务的过程中，需要异步创建服务的 git 代码仓库，还要给仓库添加成员、webhook、初始化代码等。整个过程全部串行化作为一个任务的话，耗时会比较长。可以把创建服务的 git 代码仓库作为一个异步任务，然后得到成功的结果后再异步的发起添加成员、加 webhook、初始化代码等任务。同时，这里的 CI/CD 有配置相关，有执行相关，整个过程也很长，CD 部署成功之后才可以开启日志采集等配置，所以也需要关注 CD 部署的结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;案例 2：各种 webhook、callback 接口和方法，就是基于回调的方式，如：golang 中的 channel 通知，工蜂中的代码 push 等 webhook，监控告警中的 callback 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;案例 3：发布订阅模式，如引入消息队列服务，主程序把数据发送给消息队列，异步任务订阅相应的主题然后处理。处理完成后也可以把结果再发送给消息队列，或者把结果发送给主调程序的接口，或者等待主调程序来查询结果，当然也可能是上面的忽略结果的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上可以总结出来，对于异步任务的状态处理，需要关注结果的话，有两种主要的方法，分别是：轮询查询和等待回调。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2 方法 1：轮询查询&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40265120132560067&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauOU3MiafJjWoUFmu0xNSBox6dftTxnl5e9EQicfaDO6bGJkibialmrR4FDgF6UvDcdSvKdI0upZXZz0w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1207&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的案例 1 中，模板化创建服务的过程很慢，所以整个功能都是异步的，用户大概要等待 10s 左右才知道最后的结果。所以，用户在创建服务之后，浏览器会不断轮询服务端接口，看看创建服务的结果，各个步骤的处理结果，服务配置是否都成功完成了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类似的功能实现应该有很多，比如：服务构建、部署、创建镜像仓库、抢购买票等，把任务执行和任务结果通过异步的方式强制分离开，用户可以等待，但是不用停留在当前任务中持续等待，而是可以去做别的事情，随时回来关注下这个任务的处理结果就好了。大部分执行时间很长的任务都会放到异步线程中执行，用户关注结果的话，就可以通过查询的方式来获取结果，程序自动来返回结果的话，就可以用到轮询查询了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;局限性 1：频率和实时性&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;轮询的方式延时可能会比较高，因为跟定时器的间隔时间有关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;局限性 2：增加请求压力&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为轮询，要不断地请求服务端，所以对后端的请求压力也会比较大。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.3 方法 2：通知回调&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5806451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauOU3MiafJjWoUFmu0xNSBoxBfjM0iarXnKNlMKxOYMRaA2ibyMDMSpB1qhY7ic2ztDtzsaCU1o5WRibuw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;341&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;等待回调几乎是实时的，处理有结果返回就马上通过回调通知到主程序/用户，那么效率和体验上就会好很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这里也有一个前提要求，回调的时候，主程序必须还在运行，否则回调也就没有了主体，也就无效了。所以要求主程序需要持续等待异步任务的回调，不能过早的退出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般程序中使用异步任务，需要得到任务状态的结果，使用等待回调的情况更多一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;特别注意 1：等待超时&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;等待的时间，一般不能是无限长，这样容易造成某些异常情况下的任务爆炸，内存泄露。所以需要对异步任务设置一个等待超时，过期后就要中断任务了，也就不能通过回调来得到结果了，直接认为是任务异常了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;特别注意 2：异常情况&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当主程序在等待异步任务的回调时，如果异步任务自身有异常，无法成功执行，也无法完成回调的操作，那么主程序也就无法得到想要的结果，也不知道任务状态的结果是成功还是失败，这时候也就会遇到上面等待超时的情况了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;特别注意 3：回调地狱&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 nodejs 异步编程的时候，所有的 io 操作都是异步回调，于是就很容易陷入 N 层的回调，代码就会变得异常丑陋和难以维护。于是就出现了很多的异步编程框架/模式，像：Promise,Generator,async/await 等。这里不做过多讲解。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4 思考问题&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际工作中，还有哪些地方需要处理异步任务的状态结果返回呢？除了轮询和回调，还有其他的方法吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5 异常处理&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同步的程序，处理异常情况，在 java 中只需要一个 try catch 就可以捕获到全部的异常。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.1 重点 1：分别做异常处理&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步的程序，try catch 只能捕获到当前主程序的异常，主程序中的异步线程是无法被捕获的。这时候，就需要针对异步线程中的异步任务也要单独进行 try catch 捕获异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 golang 中，开启协程，还是需要在异步任务的 defer 方法中，加入一个 recover() ，以避免没有处理的异常导致整个进程的 panic。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.2 重点 2：异常结果的记录，查询或者回调&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们把异步任务中的异常情况都处理好了，不会导致异步线程把整个进程整奔溃了，那么还有问题，怎么把异常的结果返回给主进程。这就涉及到上面的状态处理了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果可以忽略结果，那么只需要写一下错误日志就好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果需要处理状态，那就要记录下异常信息或者通知回调给到主进程。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.3 思考问题&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际工作中，你会对所有的可能异常情况都做相应的处理吗？异常结果，都是怎么处理的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6 典型场景和思考&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面已经讲到一些案例，总结下来的典型场景有如下几种&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6.1 订阅发布模式，消息队列&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6.2 慢请求，耗时长的任务&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6.3 高并发、高性能要求时的多任务处理&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6.4 不确定执行的时间点，触发器&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;人脑(单核)不擅长异步思考，电脑(多核)却更适合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;编程的时候，是人脑适配电脑，还是电脑服务人脑？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在大部分的编程中，大家都只需要考虑同步的方式来写代码逻辑。少部分时候，就要考虑使用异步的方式。而且，有很多的开发框架、类库已经把异步处理封装，可以简化异步任务的开发和调试工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，对于开发者来说，默认还是同步方式思考和开发，当不得不使用异步的时候，才会考虑异步的方式。毕竟让人脑适配电脑，这个过程还是有些困难的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_live_iframe&quot; data-pluginname=&quot;videosnap&quot; data-headimgurl=&quot;https://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;将在06月01日 19:30 直播&quot; data-intro=&quot;从代码小妹到战略女精英 ：女程序员的寻梦之旅&quot; data-noticeid=&quot;finderlivenotice-v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder-1652417934358061-1352449116&quot; data-type=&quot;live&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAJdALmwIFFwAAAAstQy6ubaLX4KHWvLEZgBPE3KJYZCFwFNuDzNPgMIvTwqTuae_sJAvxWMpNF95a&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7Ym3K77SEULgkiaFtAMAvnQFnwJIH45X3fmgZnhMmIRB5VfOYPcWTS8mlUibyzexQVRODRJHdHPQJxHZXEUjib3OCkAia9bFd8cd5ONg&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SZ&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=x5Y29zUxcibDLHhVDXmosYwGtTF2SCWgTcrD21Cfz4PgtD0vYjqhv9LfUHObTeIZ6QdWeXk7xntk&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;回想起出发前的场景，真的像做了一场热血的梦...&amp;#10;&amp;#10;&quot; data-nonceid=&quot;5900535609353475142&quot; data-type=&quot;video&quot; data-width=&quot;1920&quot; data-height=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>29f2be8102091681c8d02c29e1501e95</guid>
<title>半夜数据库突发宕机，竟是Redis惹的锅？？？</title>
<link>https://toutiao.io/k/8ogtu83</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwOTIxNDQ3OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8YRIaicYx5pzj5Cxwick8DamnOgbTJu96QTibKyHEDZt1815yOV1r27oZ6HgoYTEYWYLRz4jIV4iasHgg/0?wx_fmt=png&quot; data-nickname=&quot;dbaplus社群&quot; data-alias=&quot;dbaplus&quot; data-signature=&quot;围绕Database、BigData、AIOps的企业级专业社群。资深大咖、技术干货，每天精品原创文章推送，每周线上技术分享，每月线下技术沙龙，每季度Gdevops&amp;amp;DAMS行业大会.&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;谁曾想，凌晨 12 点之后，用户量暴增，出现了一个技术故障，用户无法下单，当时老大火冒三丈！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过查找发现 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 报 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;Could not get a resource from the pool&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;获取不到连接资源，并且集群中的单台 Redis 连接量很高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大量的流量没了 Redis 的缓存响应，直接打到了 MySQL，最后数据库也宕机了……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是各种更改最大连接数、连接等待数，虽然报错信息频率有所缓解，但还是持续报错。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;后来经过线下测试，发现存放&lt;/span&gt;&lt;strong&gt;&lt;span&gt; Redis &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;中的&lt;/span&gt;&lt;strong&gt;&lt;span&gt;字符数据很大，平均 1s 返回数据。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以发现，一旦 Redis 延迟过高，会引发各种问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;今天跟大家一起来分析下如何确定 Redis 有性能问题和解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;目录：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;1、延迟基线测量&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、慢指令监控&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;3、网络通信导致的延迟&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、慢指令导致的延迟&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;5、Fork 生成 RDB 导致的延迟&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;6、内存大页（transparent huge pages）&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;7、swap：操作系统分页&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;span&gt;8、AOF 和磁盘 I/O 导致的延迟&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;9、expires 淘汰过期数据&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;10、bigkey&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Redis 性能出问题了么？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;最大延迟是客户端发出命令到客户端收到命令的响应的时间，正常情况下 Redis 处理的时间极短，在微秒级别。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当 Redis 出现性能波动的时候，比如达到几秒到十几秒，这个很明显我们可以认定 Redis 性能变慢了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有的硬件配置比较高，当延迟 0.6ms，我们可能就认定变慢了。硬件比较差的可能 3 ms 我们才认为出现问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section label=&quot;Copyright © 2015 Yead All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;那我们该如何定义 Redis 真的变慢了呢？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;所以，我们需要对当前环境的 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;Redis 基线性能做测量&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，也就是在一个系统在低压力、无干扰情况下的基本性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;当你发现 Redis 运行时时的延迟是基线性能的 2 倍以上，就可以判定 Redis 性能变慢了。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、延迟基线测量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;redis-cli 命令提供了&lt;/span&gt;&lt;strong&gt;&lt;span&gt;–intrinsic-latency &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;选项，用来监测和统计测试期间内的最大延迟（以毫秒为单位），这个延迟可以作为 Redis 的基线性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;redis-cli --latency -h &lt;span class=&quot;code-snippet__string&quot;&gt;`host`&lt;/span&gt; -p &lt;span class=&quot;code-snippet__string&quot;&gt;`port`&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如执行如下指令：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;redis-cli&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;--intrinsic-latency 100&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Max&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;latency so far: 4 microseconds.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Max&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;latency so far: 18 microseconds.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Max&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;latency so far: 41 microseconds.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Max&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;latency so far: 57 microseconds.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Max&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;latency so far: 78 microseconds.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Max&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;latency so far: 170 microseconds.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Max&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;latency so far: 342 microseconds.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Max&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;latency so far: 3079 microseconds.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;45026981&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;total runs (avg latency: 2.2209 microseconds / 2220.89 nanoseconds per run).&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Worst&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;run took 1386x longer than the average latency.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section label=&quot;Copyright © 2015 Yead All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;注意：参数100是测试将执行的秒数。我们运行测试的时间越长，我们就越有可能发现延迟峰值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通常运行 100 秒通常是合适的，足以发现延迟问题了，当然我们可以选择不同时间运行几次，避免误差。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;运行的最大延迟是 3079 微秒，所以基线性能是 3079 （3 毫秒）微秒。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要注意的是，我们要在 Redis 的服务端运行，而不是客户端。这样，可以&lt;/span&gt;&lt;strong&gt;&lt;span&gt;避免网络对基线性能的影响。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以通过 -h host -p port 来连接服务端，如果想监测网络对 Redis 的性能影响，可以使用 Iperf 测量客户端到服务端的网络延迟。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果网络延迟几百毫秒，说明网络可能有其他大流量的程序在运行导致网络拥塞，需要找运维协调网络的流量分配。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、慢指令监控&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section label=&quot;Copyright © 2015 Yead All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;如何判断是否是慢指令呢？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;看操作复杂度是否是&lt;/span&gt;&lt;strong&gt;&lt;span&gt;O(N)&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。官方文档对每个命令的复杂度都有介绍，尽可能使用&lt;/span&gt;&lt;strong&gt;&lt;span&gt;O(1) 和 O(log N)命令&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;涉及到集合操作的复杂度一般为&lt;/span&gt;&lt;strong&gt;&lt;span&gt;O(N)&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，比如集合全量查询&lt;/span&gt;&lt;strong&gt;&lt;span&gt;HGETALL、SMEMBERS&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，以及集合的聚合操作：SORT、LREM、 SUNION等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section label=&quot;Copyright © 2015 Yead All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;有监控数据可以观测呢？代码不是我写的，不知道有没有人用了慢指令。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;有两种方式可以排查到：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;使用 Redis 慢日志功能查出慢命令；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;latency-monitor（延迟监控）工具。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，可以使用自己（top、htop、prstat 等）快速检查 Redis 主进程的 CPU 消耗。如果 CPU 使用率很高而流量不高，通常表明使用了慢速命令。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1）慢日志功能&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;Redis 中的 slowlog 命令可以让我们快速定位到那些超出指定执行时间的慢命令，默认情况下命令若是执行时间超过 10ms 就会被记录到日志。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;slowlog 只会记录其命令执行的时间，不包含 io 往返操作，也不记录单由网络延迟引起的响应慢。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以根据基线性能来自定义慢命令的标准（配置成基线性能最大延迟的 2 倍），调整触发记录慢命令的阈值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以在 redis-cli 中输入以下命令配置记录 6 毫秒以上的指令：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;redis-cli CONFIG &lt;span class=&quot;code-snippet__keyword&quot;&gt;SET&lt;/span&gt; slowlog-&lt;span class=&quot;code-snippet__keyword&quot;&gt;log&lt;/span&gt;-slower-&lt;span class=&quot;code-snippet__keyword&quot;&gt;than&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;6000&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也可以在 Redis.config 配置文件中设置，以微秒为单位。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;想要查看所有执行时间比较慢的命令，可以通过使用 Redis-cli 工具，输入 slowlog get 命令查看，返回结果的第三个字段以微秒位单位显示命令的执行时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假如只需要查看最后 2 个慢命令，输入 slowlog get 2 即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;示例：获取最近2个慢查询命令&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;127.0.0.1:6381&amp;gt; SLOWLOG get 2&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;1) 1) (&lt;span class=&quot;code-snippet__built_in&quot;&gt;integer&lt;/span&gt;) 6&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   2) (&lt;span class=&quot;code-snippet__built_in&quot;&gt;integer&lt;/span&gt;) 1458734263&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   3) (&lt;span class=&quot;code-snippet__built_in&quot;&gt;integer&lt;/span&gt;) 74372&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   4) 1) &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;hgetall&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      2) &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;max.dsp.blacklist&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;2) 1) (&lt;span class=&quot;code-snippet__built_in&quot;&gt;integer&lt;/span&gt;) 5&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   2) (&lt;span class=&quot;code-snippet__built_in&quot;&gt;integer&lt;/span&gt;) 1458734258&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   3) (&lt;span class=&quot;code-snippet__built_in&quot;&gt;integer&lt;/span&gt;) 5411075&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   4) 1) &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;keys&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      2) &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;max.dsp.blacklist&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以第一个 HGET 命令为例分析，每个 slowlog 实体共 4 个字段：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;字段 1：1 个整数，表示这个 slowlog 出现的序号，server 启动后递增，当前为 6。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;字段 2：表示查询执行时的 Unix 时间戳。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;字段 3：表示查询执行微秒数,当前是 74372 微秒,约 74ms。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;字段 4: 表示查询的命令和参数,如果参数很多或很大,只会显示部分参数个数。当前命令是hgetall max.dsp.blacklist。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2）Latency Monitoring&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;Redis 在 2.8.13 版本引入了 Latency Monitoring 功能，用于以秒为粒度监控各种事件的发生频率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;启用延迟监视器的第一步是&lt;/span&gt;&lt;strong&gt;&lt;span&gt;设置延迟阈值(单位毫秒)。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;只有超过该阈值的时间才会被记录，比如我们根据基线性能（3ms）的 3 倍设置阈值为 9 ms。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以用 redis-cli 设置也可以在 Redis.config 中设置；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;CONFIG&lt;/span&gt; SET latency-monitor-threshold &lt;span class=&quot;code-snippet__number&quot;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;工具记录的相关事件的详情可查看官方文档：https://redis.io/topics/latency-monitor&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如获取最近的 latency&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;127&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:6379&lt;/span&gt;&amp;gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;debug&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;sleep&lt;/span&gt; 2&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;OK&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;(2&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.00s&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;127&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:6379&lt;/span&gt;&amp;gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;latency&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;latest&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;1) 1) &quot;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;command&lt;/span&gt;&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   2) (&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;integer&lt;/span&gt;) 1645330616&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   3) (&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;integer&lt;/span&gt;) 2003&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   4) (&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;integer&lt;/span&gt;) 2003&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;事件的名称；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;事件发生的最新延迟的 Unix 时间戳；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;毫秒为单位的时间延迟；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;该事件的最大延迟。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;如何解决 Redis 变慢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;Redis 的数据读写由单线程执行，如果主线程执行的操作时间太长，就会导致主线程阻塞。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一起分析下都有哪些操作会阻塞主线程，我们又该如何解决？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、网络通信导致的延迟&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;客户端使用 TCP/IP 连接或 Unix 域连接连接到 Redis。1 Gbit/s 网络的典型延迟约为 200 us。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;redis 客户端执行一条命令分 4 个过程：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section label=&quot;Copyright © 2015 Yead All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;发送命令－〉 命令排队 －〉 命令执行－〉 返回结果&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;这个过程称为 Round trip time(简称 RTT, 往返时间)，mget mset 有效节约了 RTT，但大部分命令（如 hgetall，并没有 mhgetall）不支持批量操作，需要消耗 N 次 RTT ，这个时候需要 pipeline 来解决这个问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis pipeline 将多个命令连接在一起来减少网络响应往返次数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;708&quot; data-backw=&quot;547&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2943327239488116&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;547&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8YSsoCicUmemajXayphRwU7ajsASBtyrOslrXIZlkrQROj3ah41chvGkkw5MXWbSg9JYI7OqANzVfw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;redis-pipeline&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、慢指令导致的延迟&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;根据上文的慢指令监控查询文档，查询到慢查询指令。可以通过以下两种方式解决：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除此之外，生产中禁用KEYS 命令，它只适用于调试。因为它会遍历所有的键值对，所以操作延时高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、Fork 生成 RDB 导致的延迟&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;生成 RDB 快照&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，Redis 必须 fork 后台进程。fork 操作（在主线程中运行）本身会导致延迟。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis 使用操作系统的多进程写时复制技术 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;COW(Copy On Write) &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;来实现快照持久化，减少内存占用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5952782462057336&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8YSsoCicUmemajXayphRwU7aibunGlN4XMrcrNzJQCDP843wxgib2xbKPcUFsKxhrZyFeCNxxonRfSAQ/640?wx_fmt=png&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;写时复制技术保证快照期间数据可修改&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但 fork 会涉及到复制大量链接对象，一个 24 GB 的大型 Redis 实例需要 24 GB / 4 kB * 8 = 48 MB 的页表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;执行 bgsave 时，这将涉及分配和复制 48 MB 内存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;此外，从库加载 RDB 期间无法提供读写服务，所以主库的数据量大小控制在 2~4G 左右，让从库快速的加载完成。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;6、内存大页（transparent huge pages）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;常规的内存页是按照 4 KB 来分配，Linux 内核从 2.6.38 开始支持内存大页机制，该机制支持 2MB 大小的内存页分配。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis 使用了 fork 生成&lt;strong&gt; RDB 做持久化提供了数据可靠性保证。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当生成 RDB 快照的过程中，Redis 采用**&lt;strong&gt;写时复制&lt;/strong&gt;**技术使得主线程依然可以接收客户端的写请求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也就是当数据被修改的时候，Redis 会复制一份这个数据，再进行修改。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;采用了内存大页，生成 RDB 期间，即使客户端修改的数据只有 50B 的数据，Redis 需要复制 2MB 的大页。当写的指令比较多的时候就会导致大量的拷贝，导致性能变慢。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用以下指令禁用 Linux 内存大页即可：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;echo never &amp;gt; &lt;span class=&quot;code-snippet__regexp&quot;&gt;/sys/kernel&lt;/span&gt;&lt;span class=&quot;code-snippet__regexp&quot;&gt;/mm/transparent&lt;/span&gt;_hugepage/enabled&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;7、swap：操作系统分页&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;当物理内存（内存条）不够用的时候，将部分内存上的数据交换到 swap 空间上，以便让系统不会因内存不够用而导致 oom 或者更致命的情况出现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当某进程向 OS 请求内存发现不足时，OS 会把内存中暂时不用的数据交换出去，放在 SWAP 分区中，这个过程称为 SWAP OUT。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当某进程又需要这些数据且 OS 发现还有空闲物理内存时，又会把 SWAP 分区中的数据交换回物理内存中，这个过程称为 SWAP IN。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;内存 swap 是操作系统里将内存数据在内存和磁盘间来回换入和换出的机制，涉及到磁盘的读写。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section label=&quot;Copyright © 2015 Yead All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;触发 swap 的情况有哪些呢？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于 Redis 而言，有两种常见的情况：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section label=&quot;Copyright © 2015 Yead All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;我要如何排查是否因为 swap 导致的性能变慢呢？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Linux 提供了很好的工具来排查这个问题，所以当怀疑由于交换导致的延迟时，只需按照以下步骤排查。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1）获取 Redis 实例 pid&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;$&lt;/span&gt; redis-cli info | grep process_id&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;process_id:13160&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;进入此进程的 /proc 文件系统目录：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;cd&lt;/span&gt; /proc/13160&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这里有一个 smaps 的文件，该文件描述了 Redis 进程的内存布局，运行以下指令，用 grep 查找所有文件中的 Swap 字段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;$ cat smaps | egrep &#x27;^(Swap|Size)&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;Size:                316 kB&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;Swap:                  0 kB&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;Size:                  4 kB&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;Swap:                  0 kB&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;Size:                  8 kB&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;Swap:                  0 kB&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;Size:                 40 kB&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;Swap:                  0 kB&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;Size:                132 kB&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;Swap:                  0 kB&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;Size:             720896 kB&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;Swap:                 12 kB&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;每行 Size 表示 Redis 实例所用的一块内存大小，和 Size 下方的 Swap 对应这块 Size 大小的内存区域有多少数据已经被换出到磁盘上了。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;如果 Size == Swap 则说明数据被完全换出了。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到有一个 720896 kB 的内存大小有 12 kb 被换出到了磁盘上（仅交换了 12 kB），这就没什么问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis 本身会使用很多大小不一的内存块，所以，你可以看到有很多 Size 行，有的很小，就是 4KB，而有的很大，例如 720896KB。不同内存块被换出到磁盘上的大小也不一样。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;敲重点了！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果 Swap 一切都是 0 kb，或者零星的 4k ，那么一切正常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当出现百 MB，甚至 GB 级别的 swap 大小时，就表明，此时，Redis 实例的内存压力很大，很有可能会变慢。&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2）解决方案&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;8、AOF 和磁盘 I/O 导致的延迟&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;为了保证数据可靠性，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;Redis 使用 AOF 和 RDB 快照实现快速恢复和持久化。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以使用 appendfsync 配置将 AOF 配置为以三种不同的方式在磁盘上执行 write 或者 fsync （可以在运行时使用&lt;strong&gt; CONFIG SET&lt;/strong&gt;命令修改此设置，比如：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;redis-cli CONFIG SET appendfsync no）。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;no：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Redis 不执行 fsync，唯一的延迟来自于 write 调用，write 只需要把日志记录写到内核缓冲区就可以返回。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;everysec：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Redis 每秒执行一次 fsync。使用后台子线程异步完成 fsync 操作。最多丢失 1s 的数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;always：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;每次写入操作都会执行 fsync，然后用 OK 代码回复客户端（实际上 Redis 会尝试将同时执行的许多命令聚集到单个 fsync 中），没有数据丢失。在这种模式下，性能通常非常低，强烈建议使用快速磁盘和可以在短时间内执行 fsync 的文件系统实现。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;我们通常将 Redis 用于缓存，数据丢失完全恶意从数据获取，并不需要很高的数据可靠性，建议设置成 no 或者 everysec。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除此之外，避免 AOF 文件过大， Redis 会进行 AOF 重写，生成缩小的 AOF 文件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以把配置项 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;no-appendfsync-on-rewrite&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;设置为 yes，表示在 AOF 重写时，不进行 fsync 操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也就是说，Redis 实例把写命令写到内存后，不调用后台线程进行 fsync 操作，就直接返回了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;9、expires 淘汰过期数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Redis 有两种方式淘汰过期数据：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;定时删除的算法如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP默认设置为 20，每秒执行 10 次，删除 200 个 key 问题不大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果触发了第二条，就会导致 Redis 一致在删除过期数据去释放内存。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;而删除是阻塞的。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section label=&quot;Copyright © 2015 Yead All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;码哥，触发条件是什么呀？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;也就是大量的 key 设置了相同的时间参数。同一秒内，大量 key 过期，需要重复删除多次才能降低到 25% 以下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;简而言之：大量同时到期的 key 可能会导致性能波动。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1）解决方案&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;如果一批 key 的确是同时过期，可以在 EXPIREAT 和 EXPIRE 的过期时间参数上，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;加上一个一定大小范围内的随机数，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;这样，既保证了 key 在一个邻近时间范围内被删除，又避免了同时过期造成的压力。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;10、bigkey&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;通常我们会将含有较大数据或含有大量成员、列表数的 Key 称之为大 Key，下面我们将用几个实际的例子对大 Key 的特征进行描述：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一个 STRING 类型的 Key，它的值为 5MB（数据过大）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一个 LIST 类型的 Key，它的列表数量为 10000 个（列表数量过多）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一个 ZSET 类型的 Key，它的成员数量为 10000 个（成员数量过多）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一个 HASH 格式的 Key，它的成员数量虽然只有 1000 个但这些成员的 value 总大小为 10MB（成员体积过大）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;bigkey 带来问题如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Redis 内存不断变大引发 OOM，或者达到 maxmemory 设 置值引发写阻塞或重要 Key 被逐出；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Redis Cluster 中的某个 node 内存远超其余 node，但因 Redis Cluster 的数据迁移最小粒度为 Key 而无法将 node 上的内存均衡化；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;bigkey 的读请求占用过大带宽，自身变慢的同时影响到该服务器上的其它服务；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;删除一个 bigkey 造成主库较长时间的阻塞并引发同步中断或主从切换；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1）查找 bigkey&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;使用 redis-rdb-tools 工具以定制化方式找出大 Key。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2）解决方案&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;span&gt;如将一个含有数万成员的 HASH Key 拆分为多个 HASH Key，并确保每个 Key 的成员数量在合理范围，在 Redis Cluster 结构中，大 Key 的拆分对 node 间的内存平衡能够起到显著作用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;span&gt;Redis 自 4.0 起提供了 UNLINK 命令，该命令能够以非阻塞的方式缓慢逐步的清理传入的 Key，通过 UNLINK，你可以安全的删除大 Key 甚至特大 Key。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;如下检查清单，帮助你在遇到 Redis 性能变慢的时候能高效解决问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;获取当前 Redis 的基线性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;开启慢指令监控，定位慢指令导致的问题；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;找到慢指令，使用 scan 的方式；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将实例的数据大小控制在 2-4GB，避免主从复制加载过大 RDB 文件而阻塞；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;禁用内存大页，采用了内存大页，生成 RDB 期间，即使客户端修改的数据只有 50B 的数据，Redis 需要复制 2MB 的大页。当写的指令比较多的时候就会导致大量的拷贝，导致性能变慢。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Redis 使用的内存是否过大导致 swap；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;AOF 配置是否合理，可以将配置项 no-appendfsync-on-rewrite 设置为 yes，避免 AOF 重写和 fsync 竞争磁盘 IO 资源，导致 Redis 延迟增加。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;bigkey 会带来一系列问题，我们需要进行拆分防止出现 bigkey，并通过 UNLINK 异步删除。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;作者丨 码哥字节&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;来源丨公众号： 码哥字节（ID：MageByte）&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;dbaplus社群欢迎广大技术人员投稿，投稿邮箱：&lt;/span&gt;&lt;span&gt;editor@dbaplus.cn&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.3722222149372101&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8YmGrBavBQly11zAgEiahA97ReLiaHtGpsv18aktTYWEwEkU9Rv0dqlgCAn7DY7DkAEa2I4CkvibrRtQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;span&gt;​&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.07734375&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8Zf2jiaBBH3vdgfP4A2rem5YEAHYH074dc4GibhojA5B3lLZrXLDRciaVnficveaHcAUCiaIPoDsTkAduA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f2b9c72488089d97a0c9213ffc4b9baa</guid>
<title>当字节跳动在美国输出中国式 996</title>
<link>https://toutiao.io/k/7dvofem</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;算法爱好者&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;AlgorithmFans&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;算法是程序员的内功！「算法爱好者」专注分享算法相关文章、工具资源和算法题，帮程序员修炼内功。&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>88b69210fc5647648f6098a4839f370b</guid>
<title>微软数据安全防护之Know Your Data</title>
<link>https://toutiao.io/k/1ssfsao</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p cid=&quot;n2&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;微软整个数据安全体系如下：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n97&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://docs.microsoft.com/en-us/microsoft-365/media/powered-by-intelligent-platform.png?view=o365-worldwide&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48830409356725146&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZrnQ9cTzz1XAXia2MicmlwO4fSAWiaTeIibNagNsdIO4eQHyEkIiaPoH6SnzNnwPicQgX9WWVMeAoibkM0wibRfTH2XEZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1026&quot;/&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n101&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;微软提供了两套数据安全基础服务。一个是Azure Information Protection，功能是数据分类，达标，以及防护。另一套是Azure Rights Management，进行权限认证。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n99&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;对于这个体系而言，Know Your Data就是一个很难的事情。这件事的难度在我看来是远高于传统安全中的攻击面分析。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n9&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在Know Your Data部分，包括第一个是数据的识别，要知道哪些文件里面有敏感数据。微软使用了包括内置的常见的敏感信息类型的正则来识别数据类型。还支持机器学习训练分类器来识别敏感数据。众所周知，我大多数情况下对机器学习应用在网络安全防控上的态度都是反对的。但这里用来识别敏感数据，在我看来，这是一个恰当的场景，能够物尽其用。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n19&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在数据识别后，敏感数据会被打上标签。标签有两个，一个是Sensitivity Label，敏感程度标签。这个大家都知道，就是秘密，机密，高度机密之类的。另一个是Retention Label，这个是留存标签，标记数据要留存的时间。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n21&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://docs.microsoft.com/en-us/microsoft-365/media/data_classification_search_tool.png?view=o365-worldwide&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2671428571428571&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZrnQ9cTzz1XAXia2MicmlwO4fSAWiaTeIibNEmYy26rDXTniaAESwibGUnIbAtZyfpprDyO5hMdibIseROFdwHCKibXhLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;h2 cid=&quot;n256&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Retention Label&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n15&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在留存标签中，如果标记特定长时间后删除，则微软会在特定时候后自动删除该数据。如果标记要留存，并且在特定时间后删除，则微软先把特定数据留存，之后在特定时间后再删除原始数据。如果标记永久留存，则微软会把特定数据永久留存。该标签在Office365之外会失效，也就是说该标签的维护完全是由微软Office365这套系统进行维护的。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n42&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;这套动作其实是在设置留存标签时已经就设置好了。由Office365去维护数据存储的生命周期。当然，微软还提供了一种方式，就是只标记，不维护。只设置数据的留存标签，但不让微软去自动维护，避免万一出现了误删除。可以在DLP中基于留存标签去进行数据外发管控。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n44&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;我个人是这么看这个问题的，目前国内的数据安全法，个人信息保护法和网络安全法中，对于信息留存的要求尚未到如此精细化的地步。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n46&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;一个是网络安全法中，要求“ 采取监测、记录网络运行状态、网络安全事件的技术措施，并按照规定留存相关的网络日志不少于六个月 ”。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n49&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;另一个是数据安全法中，“ 从事数据交易中介服务的机构提供服务，应当要求数据提供方说明数据来源，审核交易双方的身份，并留存审核、交易记录 ”。要求“ 国家机关委托他人建设、维护电子政务系统，存储、加工政务数据，应当经过严格的批准程序，并应当监督受托方履行相应的数据安全保护义务。受托方应当依照法律、法规的规定和合同约定履行数据安全保护义务，不得擅自留存、使用、泄露或者向他人提供政务数据 ”。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n52&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当前并不需要通过Retention Label这种形式，进行文件粒度的留存设置。可以只通过对特定数据留存来满足需求。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n24&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;第二个是对这些数据做了啥，这些数据有没有被外发，被拷贝，被压缩。这个叫Activity Explorer。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n17&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;这里Activity包括敏感文件标签相关的Acitivity，包括Sensitivity Label，Retention Label的Activity。有标签应用，标签改变等。以及DLP中的文件删除，创建，拷贝，修改，读，打印，改名，拷贝到共享，不允许的应用访问。&lt;/span&gt;&lt;/p&gt;&lt;h2 mdtype=&quot;heading&quot; cid=&quot;n59&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Sensitivity Label&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n61&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;我认为Sensitivity Label会成为DLP领域的基础设施，就像设备指纹之于业务风控&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n63&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在文件防泄漏中，一直有个特别恶心的事情，如何标记一个文档是机密的？你在公司内网中，可以用公司的管控端，来收集每个文档信息，并且在服务端给该文档打标。但当你这个文件要共享给客户，允许客户内部进行分享，又该怎么办？&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n71&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;这里的核心问题就是文件的机密标签应该是伴随着文件本身被传递的。同时，当文件进行跨应用传递时，其他应用要能识别出该标签。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n73&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;微软的Sensitivity Label是写在文件的meta信息中的。毕竟Office系列的文档格式都是微软自家的。微软提供了一套SDK来监控文件操作，从而识别以及写入标签信息。这里支持Windows， mac，ios和Android。这里说句题外话，微软这个拥抱云化的印度CEO真是牛逼的。这一下子相当于做了个跨平台的DLP基础设施。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n83&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;同时，可以使用它unified Labeling Platform来管理当前Sensitivity Label。这玩意儿给人的感觉类似于做风控时的设备指纹平台，管理所有设备指纹。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n85&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当然，是不是用了Sensitivity Label就万事大吉了？&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n87&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;主要问题在于像文本类文件，例如代码，其实是不支持Sensitivity Label的。还有例如图片，也是没有这个标签的。这个Sensitivity Label对于基础办公需求的文件防护是已经满足了&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n141&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;可以想象一下，一旦企业微信和钉钉以及coremail foxmail等数据外发软件都支持这个标签，会是怎样一种场景。&lt;/span&gt;&lt;/p&gt;&lt;h2 cid=&quot;n131&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;使用Sensitivity Label和企业微信进行数据防护&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n133&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;企业数据的流转一般用企业员工在自己的工作电脑上创建了对应的文件。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n150&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;分发途径会包括上传到网站上（例如上传内网供大家下载），通过企业聊天工具分发（通过企业微信发给对应的同事）。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n154&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;这个过程中涉及了以下应用软件，一个是本地的文件编辑器，包括Office类文件。第二个是浏览器，第三个是企业聊天软件。除此之外，可以对其他应用试图读取敏感文件的行为进行限制。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n178&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Office本身就支持Sensitivity Label。对于浏览器而言，则需要相应的插件来支持。配置浏览器插件，对浏览器读取文件的操作进行监控，以及将浏览器下载的文件进行监控。对于企业聊天软件，需要聊天软件本身使用微软的SDK来支持。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n180&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;这里以企业微信为例。&lt;/span&gt;&lt;span&gt;通过企业微信，其实可以非常好的进行数据安全防护方案设计。因为在里面可以拿到完整的人员组织架构信息，从而可以对文件的共享进行限制。同时，在企业微信端内进行数据流转，对敏感文件，只允许对外共享不允许另存为。避免文件被下发到手机端&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n156&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当然，会有一些其他行为导致泄露检测变得更为复杂。最常见的就是文本复制，文件压缩，截屏。这三个地方需要设计更精细化的方案。&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>