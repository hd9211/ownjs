<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>539e16d7c6c4d5446c27ee1560297471</guid>
<title>如何写出一篇好的技术方案？</title>
<link>https://toutiao.io/k/gl2cth8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naJ4SCMjYtL7aZa0f5Ev5FyiaKmVoXuxJRcrBSp4resCrGBt8eI6cqPiaLX67YND00V16ev401enWPAQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;近期在写某个项目的技术方案时，来来回回修改了许多版，很是苦恼。&lt;/span&gt;&lt;span&gt;于是，将自己之前写的和别人写的技术方案都翻出来看了几遍，产生了一些思考，分享给大家。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;article tabindex=&quot;0&quot;&gt;&lt;section&gt;&lt;span&gt;我们为什么需要写技术方案？&lt;/span&gt;&lt;span&gt;总结下来无非是几点，从不同人的视角来看：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;产品：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;验证技术方案是否能够 match 上产品方案&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;测试：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;验证技术方案对测试方案是否有足够 &amp;amp; 准确的输入&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;同事 &amp;amp; leader：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;参与技术方案评审，验证技术方案的合理性&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;新人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;不单单指新同学也指新接触这一块的同学)：拿到技术方案可以很快对某一块的事情熟悉起来&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;h1 data-cangjie-key=&quot;22&quot; data-cangjie-leaf-block=&quot;true&quot; data-type=&quot;heading-1&quot;&gt;&lt;section&gt;什么样的技术方案是一个好的技术方案&lt;/section&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们都知道技术方案是指导具体开发工作的，可以分别从开发的事前、事中、事后来讨论这个问题。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;事前&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;事中&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;事后&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;一篇好的技术方案可以贯穿整个研发的生命周期，并且能起到很好的指导意义&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，就如同写小说之前作者必须出一个大纲的逻辑是一致的。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h1 data-cangjie-key=&quot;61&quot; data-cangjie-leaf-block=&quot;true&quot; data-type=&quot;heading-1&quot;&gt;&lt;section&gt;如何写好一篇好的技术方案&lt;/section&gt;&lt;/h1&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么，如何写出一篇好的技术方案呢？&lt;/span&gt;&lt;span&gt;下面列举出笔者认为应该做到的一些点。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;清晰的目标&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一份技术文档需要有一个清晰的目标（业务需求建议自己总结而不是 Copy from PRD，技术自发的那肯定得自己总结），那目标怎么来的呢？是从需求里转化过来的。那么，如何将对应的需求转化为一个清晰的目标？我认为最重要的是要尽量定义一个可衡量的标准。需求的种类一般来说就两种，分别是：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;1. 产品类需求——业务方 or 产品方发起提给技术&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，包括但不限于以下几种：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;页面交互：能提升多少的运营操作效率，多少 PV、UV 这种可量化的数字？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务 SOP 调整：带来的业务价值是什么？是能降多少本还是提升多少时效？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据订正：订正能解决什么问题？防止多少钱未结算？又或者是防止多少客诉？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2. 技术类需求——技术自发提出&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，包括但不限于以下几种：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;性能优化：优化多少？20%、30% 还是 50%？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据隔离：隔离的范围是什么，涉及多少张表，多少数据？可以减少当前的什么问题？减少多少？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;各种小工具：没有小工具之前是什么样？有之后是什么样？可以带来什么好处？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;研发效能提升：提升多少？有没有可以量化的指标？而不是为了做而做。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在众多的需求当中还有一些是我们要去辨别的伪需求——不是用户真正想要的需求，如用户想要将一个飞机改造成火箭，但是产品可能提过来的仅仅是把飞机的两个翅膀砍掉，那么砍掉翅膀就能变成火箭了吗？明显不能，所以这种需求一定要注意鉴别。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;大纲图&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有句话叫“不谋全局者不足谋一域”，在技术方案中我想也是如此。在一个技术方案中，一个大纲图是不可或缺的 ，有的人叫它技术架构图，有的人叫它数据流转图，这都不重要，&lt;strong&gt;重要的是我们能从这张图中看到整体的脉络&lt;/strong&gt;，那么这张图需要有哪几个要点呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;图不用很细（比如加工比较复杂我们可以简单写**加工），但是要能看到全貌，具体的每个模块如果需要展开的，那么在对应的详细设计中体现即可，在这里我们关注的是整体；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;接口如有归属不同的应用要标明；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据存储介质不同要标明；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据流转的箭头要清晰明确；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据加工计算的输入和输出要体现，同时要体现加工的运行环境（比如到底是 odps 计算还是内存计算，内存计算的话是在那个应用）。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;459&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7933579335793358&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vz1ttk8KwbTCyRfnRibmWLibiaXe4nL7esYJneTkfjWiaajicczaDzaiaXyAhuOJgG823bsaxYF3X6HIibo8tT1xucqzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;813&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大纲图的逻辑示意参考&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;模型设计&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;讲到数据模型设计，E-R 图是必不可少的，E-R 图应该包含以下信息：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;1. 每个领域对象，如果要持久化，都有表来存储。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我们设计完 ER 图的时候，应该根据这条原则做一番检查，避免漏掉一些表。在大型项目中，漏掉表是很常见的事情，应尽量避免。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2. 领域对象之间的关系，如果要持久化，都要在表结构中体现。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;这种体现，可能是 code 字段，可能是外键，可能是中间表。我们设计完 ER 图的时候，也应该根据这条原则做一番检查，避免漏掉一些关系。在大型项目中，漏掉关系更是司空见惯，应尽量避免。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;3. 清晰定义的表名。设计 ER 图的时候，就要设计出清晰定义的表名。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;清晰定义的表名，可以帮助大家理解 ER 图，可以帮助大家映射回领域对象及其关系。在后续的设计和实施中，将沿用这个表名。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;4. 清晰定义的字段名、字段类型、字段长度和枚举值。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;很多同学容易忽略这点，他们往往清晰定义了表名，却没有重视表的字段。认真去做的时候，会发现，这里面有很多工作。例如，字段名是否合适，用什么类型好，字段长度多少合适，是否有枚举值等等，都需要一一斟酌。如果这点做好了，在实施的时候，可以避免很多麻烦，甚至避免返工。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;对外依赖提前确认&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;技术方案 1：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;需要依赖缓存、分布式调度中间件、消费外部的消息，但是没有把对应的中间件使用方式、数据格式贴出来。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;技术方案 2：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;需要依赖缓存、分布式调度中间件、消费外部的消息，将缓存接入的方法 &amp;amp; 对应的缓存 key-value 设计写清楚，将分布式调度中间件接入所需要准备的依赖项梳理好，将外销消息对应的 topic 和数据格式列清楚。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;两个方案对比好坏其实很明显。如果一开始我们在技术方案里面将外部依赖确定好，那么我们在开发的时候就一马平川，反之如果外部依赖都不确定的情况下就进入到开发，那么返工的概率将大大增加，从而降低我们的工作效率。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么，对外的依赖有哪些以及我们应该要确认什么信息呢？下面列举了一些常见的依赖情况：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;外部 hsf 依赖：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;需要确认对应 hsf 接口的类、方法、version，以及二方包（也可使用泛化调用）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;外部消息依赖：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;需要确认消息的 topic、数据格式；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分布式调度、缓存等中间件：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;当前应用是否接入过该中间件，未接入需要去到官网确认接入文档，接入的话需要确认是否可以复用接入逻辑。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;内部前后模块依赖 &amp;amp; 层次结构&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;模块依赖层次从高到低分为：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们举接口依赖的例子来看：一共三个接口分别是滚存看板查询接口、锁接口、渠道集接口，滚存看板查询接口依赖于锁接口和渠道集接口。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;技术方案 1 目录层次：滚存看板查询接口、锁接口、渠道集接口；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;技术方案 2 目录层次：锁接口、渠道集接口、滚存看板查询接口。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;很明显，技术方案 2 是更加合理的，A 依赖于 B 那么 B 应该先做。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们在写技术方案的时候，要考虑什么应该在前什么应该在后，而不是想一步写一步。要有一个清晰、有序的结构，不然别人看起来就会是杂乱无章的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;一个模块里面应该有啥&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下面列出一个技术方案的模块里面应该要写哪些东西，供参考：&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;1. 具体的接口定义&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;要求：实现一个飞机运力合同查询接口，入参为运力大区&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;技术方案 1：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;入参：&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;area&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;南美&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;出参:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;date&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;***&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;技术方案 2：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;方法名：CapacityService.queryPlan&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;入参：&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;cnArea&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;南美&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;出参:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;date&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;***&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;技术方案 2 是更好的，为什么？测试、前端 、后续要接手该接口的人都能够一下子找到你的接口并清楚知道输入输出是什么。另外，1 和 2 的入参一个 area 一个 cnArea，那么到底哪个更对呢？这里由于系统中在用的都是 cnArea，固沿用 cnArea 是对的（一致性减小沟通成本）。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;这里总结对接口定义有几点要求：&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;2. 详细的时序图&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;要求：实现一个学生信息查询接口。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;技术方案 1：写出查询结果中执行的相关步骤。&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;step1. 入参校验&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;step2. 查询A表&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;step3. 对A标返回结果做校验&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;step4. 查询B表&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;······&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;技术方案 2：在 1 的基础上使用时序图表达出来。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;推荐使用技术方案 2，好处是尽管内容相同但是时序图能够更直观地看到层次、数据流转等信息。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;除了以上比较基础的 2 点，我觉得的还有一些要点：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据加工的详细图（如有）——同样推荐用图的形式可以更直观&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;消息设计（如有），明确消息生产方、消费方、tps、数据结构&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;自测用例（推荐），比较重要的功能点构造一些自测用例&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;······&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;技术选型分析&lt;/strong&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;要求：实现一个定时任务，定期将过期的数据删除。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;技术方案 1：使用 spring 自带的定时器进行数据清除。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;技术方案 2：使用分布式调度中间件（如 schedulerx）进行定时过期数据清除。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;乍一看好像都能实现，但仔细对比两个实现方式之后我认为大部分人还是会选择技术方案 2，为什么？下面列出一些在选择技术方案时考虑的点。&lt;/span&gt;&lt;/section&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;目标是否可达成&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;实现难度&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;可维护性&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;可扩展性&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;技术方案1-spring定时器&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;是&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;易&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;易&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;低&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;技术方案2-分布式调度中间件&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;是&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;易&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;中&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;高&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;安全生产&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;安全生产包括几个部分，包括且不限于下面几个部分&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;我们举一个例子。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;需求：在消费者收货成功时触发对商家的结算。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;技术方案 1：******，写了一堆如何触发结算、如何更好地支持后续的可扩展性；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;技术方案 2：******，写的方案可扩展性没有技术方案 1 高，但是做好了未触发结算的监控、触发结算之后的对账，并设计好了对应的报表防止出现资损。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其实这也是我们在技术方案中可能会忽略的一点——埋头于代码结构如何如何的好，但是有些东西其实是要比单纯的代码更重要。就比如风险控制，完备的监控、不可缺少的对账是保障公司资金安全，更是保障我们自己绩效的工具（此处应有表情）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么对于监控、对账的具体要求是什么呢？我认为有以下几点：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;监控：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;监控目标：写清楚监控的是什么内容&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;监控点：如通过打印日志监控，那么日志打印在哪个类的哪个方法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;监控触发：是通过 sunfire 采集触发还是其它，如果是 sunfire 采集最好能把监控项地址贴出来&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;监控订阅人：监控告警需要的订阅人&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;监控触发后的解决方法：如果发生异常该如何解决？如手工触发结算&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;对账：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;还有其它几个部分也补充说一下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;灰度方案，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;包括但不限于：&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;向前兼容性，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;包括但不限于：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;环境隔离：&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;发布流程，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;包括但不限于：&lt;/span&gt;&lt;/section&gt;&lt;/article&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据分析系统之数据管理与数据仓库&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;点击阅读原文查看详情。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1453e71739857f3304982b7d817bc7f7</guid>
<title>如何设计可落地的重构技术方案——理论篇</title>
<link>https://toutiao.io/k/qnn406d</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、 写在前面&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近重构项目比较多，写了好几个系统重构方案，很多朋友问，写重构技术方案，有没有什么套路或者框架，都需要做哪些调研和准备工作，这篇文章就重点聊一聊，如何设计可落地的重构方案。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、重构有没有套路&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有套路，多年重构经验表明，我重构已经形成了自己的一套固定模式，然后在这套模式之上，根据业务场景不断的变通，可以说，重构是经验的积累。所以在设计重构方案阶段，就能够避免一些后续的坑。当然也不能完全避坑，因为总有你没有考虑到的地方，这个时候我们要做的，就是如何把风险降到最低，这个也是重构方案的一部分(灰度方案)。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、什么是重构&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想必每一个技术开发都深有感触，很多人到一个新的团队，都会吐槽原来的代码写得乱，扩展性难，历史包袱重。想要重构，却不知道如何下手；也有一些说要重构，但是很多在我看来对于重构没有一个正确的认识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我说几点解释一下:&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 重构不是重写&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做过开发的同学都知道，重写很简单，按照产品的需求，实现需求就好了，没有历史包袱。但是重构是在原有的基础上改，有很多限制性，大框架不能改，对外接口不能变，存储结构设计限制等等。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 不要轻易批判前人的代码&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家要相信一点，存在即合理，原来这么设计，一定有它的原因。可能当初调用量不大，可能当初业务场景限制，可能当初资源限制等等，你没有经历过，就不能感同身受。所以不要轻易去批判，
既然直到现在，这个业务场景还在迭代，甚至要面临重构，至少说明该业务场景，甚至是商业场景是成功的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 重构方案先行，落地可分期进行&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们面临的系统大庞大，历史包袱重，不知道从何处下手，或者说做完重构需要很长的时间。即便是这样，我们的方案也一定是设计完备的(甚至要和产品沟通以后可能增加的业务场景)，不仅要考虑到如何解决现在的问题，还要考虑到之后的扩展性问题，然后再任务拆分，分期进行，一期做哪些，二期做哪些。另外一期重构时间不宜过长，要考虑到投入产出比问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 不要过度设计，不要为了重构而重构&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们通过调整参数，调优就能解决的问题，就不需要大动干戈。重构一定是在最后一环，万不得已的情况下进行的。例如: 1、性能瓶颈，无法扩展，2、无法满足现在的业务迭代&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、 写重构技术方案需要做哪些调研&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调研可以说是写重构技术方案非常重要的一个环节，往往能够避免很多不必要的坑。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 历史痛点在哪里&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先要通过一定手段，比如：压测，监控等等， 先找到影响原来性能和问题的原因是什么，痛点是什么。只有知道原来的痛，才能知道如何对症下药。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 调研新的技术方案&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如原来的存储用的Redis，现在想引入Mysql，那么Mysql能不能支持现在的业务场景(可能需要通过写demo压测)，它又有哪些优势(和原来对比)。亦或者本次要引入新的组件，那么组件可能选择性有很多，选择哪一种比较合适需要有横向对比等等。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 梳理业务&amp;amp;影响范围&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如需要梳理出所有的对外接口，这些接口目前线上的高峰期QPS，RT，995耗时是多少，都有哪些调用方。目前系统相关的表是否是独立可控的，SQL语句都需要汇总统计(这个主要是分库分表的时候考虑，因为要考虑到SQL拆分，分库分表的ShardingKey 和 分库分表之后的查询问题)&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;五、设计技术方案&lt;/span&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;先画出整体架构图[重构前(可选)、重构后]，再画出核心流程图&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表结构设计(分库分表)，分表情况下要根据目前线上使用场景对分表shardingKey做一个离散度分析。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;六、设计灰度方案&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;技术方案明确之后，再考虑如何灰度，按流量灰度，还是城市，还是开关控制。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;七、核对方案&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调研阶段梳理的对外接口派上用场了，需要针对每一个对外接口，job脚本，consumer任务等，标注重构改造方案。这个过程也会发现一些细节上的问题，从而完善技术方案。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;八、数据校验方案&lt;/span&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;可以利用目前线上请求的log，流量回放的方式请求新接口，然后对比一下返回数据是否和老的一致。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果对表结构有改造，需要对比新老数据是否一致(排除不需要对比字段)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;灰度阶段可以同时请求新老接口，对比返回数据是否一致。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;九、任务拆分&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对本次改造需求进行拆分，一期做哪些列举出来 和 二期大概规划。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十、技术方案评审&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以先组内小范围评审，先解决内部可能存在的问题。内部沟通完之后，再组织跨部门技术评审会议。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十一、总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章主要讲一下写重构技术方案理论篇，很多都是大家知道的一些道理，但是我想说，这其中有很多细节需要确认，还需要和产品，或者其他组同学沟通。方案是否可落地，除了经验之外，还需要各种测试和调研。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下一篇文章将给大家讲一讲重构技术方案——实战篇，以我们线上真实重构——乘客排队系统重构场景为例，我是如何一步步写重构技术方案以及后续如何落地的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欢迎关注&quot;浅谈架构&quot;公众号、不定期分享原创文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kulR6Bq67WicS8obXBjC9RqxibSJcgOsnicwSlKjFSxuEECwjZjYS8Y9zpmCdyv6z4yeSicSQSDNz2XUzRppBjuGXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                  &lt;p class=&quot;tips_global&quot; aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_title&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                    &lt;p role=&quot;option&quot; aria-labelledby=&quot;js_a11y_reward_qr_word js_a11y_comma js_a11y_reward_qr_title js_a11y_reward_qr_money&quot; aria-describedby=&quot;js_a11y_reward_qr_tips &quot; class=&quot;reward_tips&quot; id=&quot;js_a11y_reward_qr_word&quot;/&gt;
                  &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img alt=&quot;赞赏二维码&quot; class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                  &lt;p aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_tips&quot; class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                &lt;/div&gt;
                                              
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2d57bc7556ed89b51eca0ad82a8efa38</guid>
<title>解决跨海高并发崩溃难题？so easy</title>
<link>https://toutiao.io/k/souekwu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;又拍云&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;upaiyun&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;加速在线业务。为客户提供CDN、PrismCDN、云存储、SSL证书、云处理、直播云、点播云等服务。&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>70cd36b0f2b66942bb330fece1414348</guid>
<title>2022 年值得学习的 Golang 包</title>
<link>https://toutiao.io/k/aqswd9s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;a class=&quot;weui-flex original_primary_card appmsg_card_context wx_tap_card js_wx_tap_highlight&quot; href=&quot;#&quot; id=&quot;copyright_info&quot;&gt;
                  
                  &lt;div class=&quot;weui-flex__item&quot; role=&quot;option&quot;&gt;
                    &lt;strong class=&quot;original_primary_nickname&quot;&gt;幽鬼&lt;/strong&gt;
                                          &lt;span class=&quot;weui-hidden_abs&quot;&gt;.&lt;/span&gt;
                      &lt;p class=&quot;original_primary_desc&quot;&gt;程序员幽鬼！着重关注最新语言和技术，比如 Rust、Golang、Swift、Kotlin、K8S、Docker 和 云原生等。幽鬼，Dota 中的英雄，传统大后期核心，素有最稳后期称号。做一个如她般的程序员！&lt;/p&gt;
                                      &lt;/div&gt;
                  &lt;p class=&quot;weui-flex__ft&quot;/&gt;
                &lt;/a&gt;
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0d960940fe07d58cc898e484edfa06f8</guid>
<title>简述前端包管理工具机制和相关实践</title>
<link>https://toutiao.io/k/fhb99yh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;简述前端包管理工具机制和相关实践&lt;/span&gt;&lt;/h1&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;npm 依赖管理机制&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;区别于 Python 的包管理工具 pip 的全局安装，npm 会安装依赖包到当前项目目录，使不同项目的依赖更成体系，这样做的好处是减轻了包作者的 API 兼容性压力；但是缺陷是如果两个项目依赖了一个相同的库，一般这个库会在这两个项目中各安装一次，即相同的依赖包会被多次安装。&lt;br/&gt;我们先通过一张流程图(源自掘金)来了解下 npm install 的整体流程&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3522920203735144&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pNbVmSmDDfBwSfWVPJ5UJO1UNBR1nzcj1mHwNxK4JkiaLe4GxibEl3VR5EBxGHTibN8DafjbVEibibYLE09LC5QAjrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2356&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到执行 npm install 后依次会进行以下流程&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;检查 package-lock.json&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过和 package.json 对比确定是否远程获取包信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;扁平化构建依赖树&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;添加缓存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;下载包并解压到 node_modules&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生成新的 lock 文件
值得注意的是，早期 npm 版本(v5.0 - v5.4)发现 package.json 和 package-lock.json 不一致时，对依赖的安装方式是不一样的。&lt;strong&gt;所以对于团队而言，最佳实践应该是保持 npm 版本的一致性！&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;缓存机制&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以从流程图中看到，npm install 的流程中会查找和使用缓存，以及下载包后会添加缓存的环节。由于依赖嵌套机制，项目中 node_moudles 占用的磁盘空间无疑是最大的，如果安装时每次都通过网络下载获取，那么时间成本是巨大的。常见的优化方式是“空间换时间”，npm 也通过缓存机制来解决这个问题。&lt;br/&gt;简单了解下缓存的目录的和清除机制。&lt;br/&gt;通过 &lt;code&gt;npm config get cache&lt;/code&gt; 命令可以查询到缓存目录：默认是用户主目录下的 &lt;code&gt;.npm/_cacache 目录。&lt;/code&gt;&lt;br/&gt;&lt;code&gt;npm cache clean --force&lt;/code&gt; 即可强制清除缓存。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;yarn 带来了什么？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;yarn 是于 2016 年诞生的，它的出现解决了历史上 npm 的很多问题，比如缺乏对于依赖的完整性和一致性保障(npm v3 版本还没有 package-lock.json)，以及 npm 安装速度过慢的问题等。npm 目前已经迭代到 v8 版本，在很多方面已经借鉴了 yarn 的优点，但是我们不妨了解下 yarn 诞生时带来的理念。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;确定性。通过 yarn.lock 等机制，保证了确定性，这里的确定性包括但不限于明确的依赖版本、明确的依赖安装结构等。即在任何机器和环境下，都可以以相同的方式被安装。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模块扁平化安装。将依赖包的不同版本，按照一定策略，归结为单个版本，以避免创建多个副本造成冗余。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更快的速度。yarn 采取并行安装的机制进行包的安装任务，提高了性能；yarn 引入的缓存机制使二次安装的速度更快。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更好的语义化。yarn 的命令更加简洁。&lt;strong&gt;解决早期 npm 的依赖管理问题&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章的开始提到 npm 是将依赖放到项目的 node_modules 中，同时如果 node_modules 中的依赖 A 还依赖了其他依赖 B，那么 B 也会被安装到 A 的 node_modules 文件夹，依次递归最终形成非常复杂和庞大的依赖树。&lt;br/&gt;这种依赖管理方式会随着项目的迭代，node_moudles 会变得越来越复杂，从而造成：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;非常深的项目依赖层级，难以排查问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;依赖被重复安装，浪费磁盘，网络等资源，安装速度慢
那么 yarn 是如何解决这个问题的呢？那就是模块扁平化安装机制。假如我们有这样一个文件依赖结构。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;App&lt;br/&gt; -a@2.0&lt;br/&gt;   -b@2.0&lt;br/&gt; -b@2.0&lt;br/&gt; -c@1.0&lt;br/&gt;   -b@2.0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;yarn 在安装依赖时会打平依赖，并对重复依赖进行提升，最终形成的依赖结构如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;App&lt;br/&gt; -a@2.0&lt;br/&gt; -b@2.0&lt;br/&gt; -c@1.0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是需要注意的是：&lt;strong&gt;模块的安装顺序可能影响 node_modules 内的文件结构。&lt;/strong&gt;在 npm v3 版本中，假如 项目一开始依赖了 a@1.0，此时 a@1.0 会被安装在顶层目录；随着迭代，又引入了模块 b@1.0，而 b@1.0 又依赖了 a@2.0，此时 a@2.0 会被安装在 b@1.0 下，因为顶层已经有一个 a@1.0 了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;pnpm: 最先进的包管理工具？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8187830687830688&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pNbVmSmDDfBwSfWVPJ5UJO1UNBR1nzcjRRYt1cI4ibL5IUWYX7UXiccTy51nlMoTQQud3qon3ZuYpS5bWTksIUkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;756&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在各个场景下，pnpm 相比较于 npm(v8)和 yarn(v3)在性能上都有不错的提升。&lt;br/&gt;pnpm 之所以有如此大的性能提升，简单来说 pnpm 是通过全局 store（目录 ${os.homedir}/.pnpm-store）来存储 node_modules 依赖的 hard-links，当在项目文件中引用依赖的时候则是通过 symlink 去找到对应虚拟磁盘目录下(.pnpm 目录)的依赖地址。相比于 npm 和 yarn 会在每个项目中都安装一份 node_moudles, pnpm 的全局 store 则实现了“安装一次，所有项目复用”，这样避免了二次安装带来的时间消耗。&lt;br/&gt;除此之外，pnpm 本身的设计机制解决了 monorepo 的很多痛点，比如 &lt;strong&gt;”幽灵依赖“&lt;/strong&gt; 和 &lt;strong&gt;”依赖重复安装“&lt;/strong&gt;的问题。如图：&lt;img data-ratio=&quot;0.50234375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pNbVmSmDDfBwSfWVPJ5UJO1UNBR1nzcjibpiaZfzP9ib46tpH8VAILaEGcpMFkPZicMbHyLkFAxdSR2viaIFVEo5YSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;下面两小节内容源自：&lt;span&gt; pnpm: 最先进的包管理工具&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;幽灵依赖&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Phantom dependencies 被称之为幽灵依赖，解释起来很简单，即某个包没有被安装(package.json 中并没有，但是用户却能够引用到这个包)。&lt;br/&gt;引发这个现象的原因一般是因为 node_modules 结构所导致的，例如使用 yarn 对项目安装依赖，依赖里面有个依赖叫做 foo，foo 这个依赖同时依赖了 bar，yarn 会对安装的 node_modules 做一个扁平化结构的处理(npm v3 之后也是这么做的)，会把依赖在 node_modules 下打平，这样相当于 foo 和 bar 出现在同一层级下面。那么根据 nodejs 的寻径原理，用户能 require 到 foo，同样也能 require 到 bar。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package.json -&amp;gt; foo(bar 为 foo 依赖)&lt;br/&gt;node_modules&lt;br/&gt;  /foo&lt;br/&gt;  /bar -&amp;gt; 👻依赖&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这里这个 bar 就成了一个幽灵依赖，如果某天某个版本的 foo 依赖不再依赖 bar 或者 foo 的版本发生了变化，那么 require bar 的模块部分就会抛错。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;依赖重复安装&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题其实也可以说是 hoist 导致的，这个问题可能会导致有大量的依赖的被重复安装，举个例子:&lt;br/&gt;例如有个 package，下面依赖有 lib_a、lib_b、lib_c、lib_d，其中 a 和 b 依赖 util_e@1.0.0，而 c 和 d 依赖 util_e@2.0.0。&lt;br/&gt;那么早期 npm 的依赖结构应该是这样的:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;- package&lt;br/&gt;  - package.json&lt;br/&gt;  - node_modules&lt;br/&gt;     - lib_a&lt;br/&gt;       - node_modules &amp;lt;- util_e@1.0.0&lt;br/&gt;     - lib_b&lt;br/&gt;       - node_modules &amp;lt;- util_e@1.0.0&lt;br/&gt;     _ lib_c&lt;br/&gt;       - node_modules &amp;lt;- util_e@2.0.0&lt;br/&gt;     - lib_d&lt;br/&gt;       - node_modules &amp;lt;- util_e@2.0.0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样必然会导致很多依赖被重复安装，于是就有了 hoist 和打平依赖的操作:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;- package&lt;br/&gt;  - package.json&lt;br/&gt;  - node_modules&lt;br/&gt;     - util_e@1.0.0&lt;br/&gt;     - lib_a&lt;br/&gt;     - lib_b&lt;br/&gt;     _ lib_c&lt;br/&gt;       - node_modules &amp;lt;- util_e@2.0.0&lt;br/&gt;     - lib_d&lt;br/&gt;       - node_modules &amp;lt;- util_e@2.0.0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这样也只能提升一个依赖，如果两个依赖都提升了会导致冲突，这样同样会导致一些不同版本的依赖被重复安装多次，这里就会导致使用 npm 和 yarn 的性能损失。&lt;br/&gt;如果是 pnpm 的话，这里因为依赖始终都是存在 store 目录下的 hard links ，一份不同的依赖始终都只会被安装一次，因此这个是能够被彻彻底底的消除的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;项目中的相关场景实践和常见问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;npm link&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;适用场景：本地调试 npm 模块，将模块链接到对应的业务项目中运行
使用方法：假如我们需要把模块 pkg-a 链接到主项目 App 中，首先在 pkg-a 根目录中执行 npm link，然后在 App 根目录中执行 npm link pkg-a 即可。调试完可以使用 npm unlink 取消关联。原理：npm link 通过软连接将 pkg-a 链接到 node 模块的全局目录和可执行文件中，实现 npm 包命令的全局可执行。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;npx&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;适用场景：在 npm 5.2.0 版本之后，npm 内置了 npx 的包。npx 是一个简单的 cli 工具，可以帮助我们快速的调试，还可以让我们在不通过 npm 安装包的前提下执行一些 npm 包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用方法：&lt;br/&gt;&lt;strong&gt;Before:&lt;/strong&gt; 一般情况下，如果我们想使用 es-lint, 会先通过 npm install es-lint, 然后在项目根目录执行
./node_modules/.bin/es-lint your_file.js 或者 通过 package.json 的 npm scripts 调用 eslint。&lt;br/&gt;&lt;strong&gt;After:&lt;/strong&gt; npx es-lint your_file.js&lt;br/&gt;&lt;strong&gt;原理&lt;/strong&gt;：npx 在运行时会自动去 ./node_moudles/.bin 和 环境变量 寻找命令&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;是否提交 lock.json 到代码仓库&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们提到 yarn 带来了 .lock 文件的机制，使得在任何环境下执行 install，都能得到一致的 node_modules 安装结果。但是是否需要提交 lockfiles(package-lock.json/yarn.lock) 到代码仓库呢？&lt;br/&gt;&lt;span&gt; npm 官方文档&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;是建议把 package-lock.json 文件提交到代码仓库的。在多人协作的项目中，这样做确实没有问题。但是如果开发的是库，在 npm publish 的时候最好忽略 lockfiles。因为库一般是被其他项目依赖的，在不使用 lockfiles 的情况下，由于新版 npm 和 yarn 的 hoist 机制，可以复用住项目已经加载过的包，减少依赖重复和体积。&lt;br/&gt;但是存在这样一种现象：即使在一些发布时忽略 lockfiles 的库中，在主项目顶层存在相关依赖包的前提下，最终生成的 lockfile 仍然没复用主项目的包。这是为什么呢？原因是库的依赖包版本和主项目存在的依赖包版本不一致。具体看下图：主项目的 yarn.lock 中显示 browser 这个包依赖了 @babel/runtime@7.0.0&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5176470588235295&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pNbVmSmDDfBwSfWVPJ5UJO1UNBR1nzcjvvL1VTTn7cyLz7f3tic40T0zybiaFibEmKb6I9bNjzYMSUKwDTMVrjRew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;850&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主项目 node_modules 顶层的 @babel/runtime 版本为 7.10.1&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6428571428571429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pNbVmSmDDfBwSfWVPJ5UJO1UNBR1nzcjUmrc2nKgFu3U5VPXyw75JvO6zwlyWobhQEHhu4OEAmDq8NxBviaW9SQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1008&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道了原因，那么如何减少库项目的依赖项呢。到这里，解决方案也就呼之欲出了：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;库项目尽量使用和主项目版本一致的依赖包&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在库项目 package.json 的 “peerDevpendencies” 字段中声明主项目已有的依赖包&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;合入其他分支代码后编译报错&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信很多同学都遇到过和我一样的问题：当自己的 feat 分支代码合入 master 或者业务班车分支的代码时，重新 yarn 时，有时候会编译失败，报大量 &quot;can&#x27;t resolve module xxx&quot;的错误。这种错误有很多情况是依赖版本不一致的问题，但是又极其难以定位，令人头痛。那么此时有另外一个思路，那就是从 master 拉一个最新的分支再进行合入。&lt;br/&gt;但更好的解决方式是：建议在日常开发过程中，定时合入 master 代码，一方面可以合入最新的 feat，另一方面可以避免长时间不合入，最后在上线阶段合入代码，可能出现大量冲突，解决不当或遗漏而造成的编译问题。同时也可以考虑将工具升级为 pnpm，以解决潜在的“幽灵依赖”和“依赖嵌套”问题，同时带来性能上的提升。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;pnpm: 最先进的包管理工具: &lt;em&gt;https://bytedance.feishu.cn/docs/doccngSUrvF0qPVmBE1rq1iPZQf&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;npm官方文档: &lt;em&gt;https://docs.npmjs.com/cli/v7/configuring-npm/package-lock-json&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>