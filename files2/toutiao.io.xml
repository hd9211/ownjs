<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>a3318697cf3415ebc4743cf719c1a490</guid>
<title>赢机酒！直飞北京现场参加 ServerlessDays</title>
<link>https://toutiao.io/k/tykh0r4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7bde04f4daf634219245239d724f1140</guid>
<title>面试官：两个 nil 比较结果是什么？</title>
<link>https://toutiao.io/k/otmhhst</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;背景&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;哈喽，大家好，我是&lt;code&gt;asong&lt;/code&gt;。前几天在一个交流群里看到了一道非常有意思的面试题，今天把它分享出来，我们先来看一下这个道题：&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;fmt.Println(&lt;span&gt;nil&lt;/span&gt;== &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两个&lt;code&gt;nil&lt;/code&gt;的比较结果是什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;true&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;、还是无法编译？大家先思考着，文中揭晓答案。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;写在开始：&lt;strong&gt;建议你们看一下这个视频：https://www.youtube.com/watch?v=ynoY2xz-F8s&lt;/strong&gt;  &lt;strong&gt;需要翻墙哈，看完这个你对&lt;code&gt;nil&lt;/code&gt;会有一个新的理解。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go中&lt;code&gt;nil&lt;/code&gt;的定义&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;Go&lt;/code&gt;官方文档中，对&lt;code&gt;nil&lt;/code&gt;的定义如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// nil is a predeclared identifier representing the zero value for a&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// pointer, channel, func, interface, map, or slice type.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; Type &lt;span&gt;// Type must be a pointer, channel, func, interface, map, or slice type&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;nil&lt;/code&gt;是一个预先声明的标识符，代表指针(&lt;code&gt;pointer&lt;/code&gt;)、通道(&lt;code&gt;channel&lt;/code&gt;)、函数(&lt;code&gt;func&lt;/code&gt;)、接口(&lt;code&gt;interface&lt;/code&gt;)、&lt;code&gt;map&lt;/code&gt;、切片(&lt;code&gt;slice&lt;/code&gt;)。也可以这么理解：指针、通道、函数、接口、map、切片的零值就是&lt;code&gt;nil&lt;/code&gt;，就像布尔类型的零值是&lt;code&gt;false&lt;/code&gt;、整型的零值是&lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;深入理解&lt;code&gt;nil&lt;/code&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;nil&lt;/code&gt;根本不是关键字&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看一段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;nil&lt;/span&gt; := &lt;span&gt;&quot;this is nil&quot;&lt;/span&gt;&lt;br/&gt; fmt.Println(&lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;this is &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那再改成这样呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;nil&lt;/span&gt; := &lt;span&gt;&quot;this is nil&quot;&lt;/span&gt;&lt;br/&gt; fmt.Println(&lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; slice []&lt;span&gt;string&lt;/span&gt; = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; fmt.Println(slice)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;# command-line-arguments&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;6&lt;/span&gt;: cannot use &lt;span&gt;nil&lt;/span&gt; (&lt;span&gt;type&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) as &lt;span&gt;type&lt;/span&gt; []&lt;span&gt;string&lt;/span&gt; in assignment&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译的时候直接报错了，因为这个&lt;code&gt;nil&lt;/code&gt;是一个&lt;code&gt;string&lt;/code&gt;类型，所以从这里确定&lt;code&gt;nil&lt;/code&gt;在&lt;code&gt;Go&lt;/code&gt;语言中并不是关键字，我们可以随意定义变量名为&lt;code&gt;nil&lt;/code&gt;（不过不建议这么用）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;nil&lt;/code&gt;的默认类型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般预声明标识符都会有一个默认类型，比如&lt;code&gt;Go&lt;/code&gt;语言中的&lt;code&gt;itoa&lt;/code&gt;默认类型就是&lt;code&gt;int&lt;/code&gt;，那么&lt;code&gt;nil&lt;/code&gt;的默认类型呢？我们写个例子来看一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;const&lt;/span&gt; val1 = &lt;span&gt;iota&lt;/span&gt;&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;%T\n&quot;&lt;/span&gt;,val1)&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; val2 = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;%T\n&quot;&lt;/span&gt;,val2)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;# command-line-arguments&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;6&lt;/span&gt;: use of untyped &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在编译时就已经报错，编译器告诉我们使用了无类型的&lt;code&gt;nil&lt;/code&gt;，所以我们可以得出结论：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;nil&lt;/code&gt;是没有默认类型的，它的类型具有不确定性，我们在使用它时必须要提供足够的信息能够让编译器推断&lt;code&gt;nil&lt;/code&gt;期望的类型。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;nil&lt;/code&gt;的比较&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;nil&lt;/code&gt;的比较我们可以分为以下两种情况：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看一下&lt;code&gt;nil&lt;/code&gt;标识符的比较，也就是我们开头那一道面试题，先看一下运行结果呢：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;# command-line-arguments&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;8&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: &lt;span&gt;nil&lt;/span&gt; == &lt;span&gt;nil&lt;/span&gt; (operator == not defined on &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过编译结果我们可以看出&lt;code&gt;==&lt;/code&gt;符号对于&lt;code&gt;nil&lt;/code&gt;来说是一种未定义的操作，所以是不可以比较两个&lt;code&gt;nil&lt;/code&gt;的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着我们来看一看&lt;code&gt;nil&lt;/code&gt;的值比较，因为&lt;code&gt;nil&lt;/code&gt;是没有类型的，是在编译期根据上下文确定的，所以要比较&lt;code&gt;nil&lt;/code&gt;的值也就是比较不同类型的&lt;code&gt;nil&lt;/code&gt;，这又分为同一个类型的&lt;code&gt;nil&lt;/code&gt;值比较和不同类型&lt;code&gt;nil&lt;/code&gt;值的比较，分这两种情况我们分别来验证一下。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;// 指针类型的nil比较&lt;/span&gt;&lt;br/&gt; fmt.Println((*&lt;span&gt;int64&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;) == (*&lt;span&gt;int64&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;))&lt;br/&gt; &lt;span&gt;// channel 类型的nil比较&lt;/span&gt;&lt;br/&gt; fmt.Println((&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;) == (&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;))&lt;br/&gt; &lt;span&gt;// func类型的nil比较&lt;/span&gt;&lt;br/&gt; fmt.Println((&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;)&lt;span&gt;(&lt;span&gt;nil&lt;/span&gt;)&lt;/span&gt; == &lt;span&gt;(&lt;span&gt;func&lt;/span&gt;()&lt;/span&gt;)&lt;span&gt;(&lt;span&gt;nil&lt;/span&gt;)&lt;/span&gt;) // &lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; 只能与&lt;span&gt;nil&lt;/span&gt;进行比较&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// interface类型的nil比较&lt;/span&gt;&lt;br/&gt; fmt.Println((&lt;span&gt;interface&lt;/span&gt;{})(&lt;span&gt;nil&lt;/span&gt;) == (&lt;span&gt;interface&lt;/span&gt;{})(&lt;span&gt;nil&lt;/span&gt;))&lt;br/&gt; &lt;span&gt;// map类型的nil比较&lt;/span&gt;&lt;br/&gt; fmt.Println((&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;) == (&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;)) &lt;span&gt;// map 只能与nil进行比较&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// slice类型的nil比较&lt;/span&gt;&lt;br/&gt; fmt.Println(([]&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;) == ([]&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;)) &lt;span&gt;// slice 只能与nil进行比较&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;# command-line-arguments&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;28&lt;/span&gt;: invalid operation: (&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;)&lt;span&gt;(&lt;span&gt;nil&lt;/span&gt;)&lt;/span&gt; == &lt;span&gt;(&lt;span&gt;func&lt;/span&gt;()&lt;/span&gt;)&lt;span&gt;(&lt;span&gt;nil&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;span&gt;func&lt;/span&gt; can only be compared to &lt;span&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt;:&lt;span&gt;36&lt;/span&gt;: invalid operation: (&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;) == (&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;) (&lt;span&gt;map&lt;/span&gt; can only be compared to &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt;:&lt;span&gt;27&lt;/span&gt;: invalid operation: ([]&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;) == ([]&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;nil&lt;/span&gt;) (slice can only be compared to &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从运行结果我们可以看出，指针类型&lt;code&gt;nil&lt;/code&gt;、&lt;code&gt;channel&lt;/code&gt;类型的&lt;code&gt;nil&lt;/code&gt;、&lt;code&gt;interface&lt;/code&gt;类型可以相互比较，而&lt;code&gt;func&lt;/code&gt;类型、&lt;code&gt;map&lt;/code&gt;类型、&lt;code&gt;slice&lt;/code&gt;类型只能与&lt;code&gt;nil&lt;/code&gt;标识符比较，两个类型相互比较是不合法的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; ptr *&lt;span&gt;int64&lt;/span&gt; = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; cha &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt; = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; fun &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; = &lt;span&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; inter &lt;span&gt;interface&lt;/span&gt;{} = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; ma &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt; = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; slice []&lt;span&gt;int64&lt;/span&gt; = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; fmt.Println(ptr == cha)&lt;br/&gt; fmt.Println(ptr == fun)&lt;br/&gt; fmt.Println(ptr == inter)&lt;br/&gt; fmt.Println(ptr == ma)&lt;br/&gt; fmt.Println(ptr == slice)&lt;br/&gt;&lt;br/&gt; fmt.Println(cha == fun)&lt;br/&gt; fmt.Println(cha == inter)&lt;br/&gt; fmt.Println(cha == ma)&lt;br/&gt; fmt.Println(cha == slice)&lt;br/&gt;&lt;br/&gt; fmt.Println(fun == inter)&lt;br/&gt; fmt.Println(fun == ma)&lt;br/&gt; fmt.Println(fun == slice)&lt;br/&gt;&lt;br/&gt; fmt.Println(inter == ma)&lt;br/&gt; fmt.Println(inter == slice)&lt;br/&gt;&lt;br/&gt; fmt.Println(ma == slice)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;# command-line-arguments&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: ptr == cha (mismatched types *&lt;span&gt;int64&lt;/span&gt; and &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt;)&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;15&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: ptr == fun (mismatched types *&lt;span&gt;int64&lt;/span&gt; and &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: ptr == ma (mismatched types *&lt;span&gt;int64&lt;/span&gt; and &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt;)&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: ptr == slice (mismatched types *&lt;span&gt;int64&lt;/span&gt; and []&lt;span&gt;int64&lt;/span&gt;)&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: cha == fun (mismatched types &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt; and &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;22&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: cha == ma (mismatched types &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt; and &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt;)&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;23&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: cha == slice (mismatched types &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt; and []&lt;span&gt;int64&lt;/span&gt;)&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: fun == inter (operator == not defined on &lt;span&gt;&lt;span&gt;func&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;26&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: fun == ma (mismatched types &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;27&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: invalid operation: fun == slice (mismatched types &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; []&lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;./&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;27&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;: too many errors&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从运行结果我们可以得出，只有指针类型和channel类型与接口类型可以比较，其他类型的之间是不可以相互比较的。为什么指针类型、channel类型可以和接口类型进行比较呢？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这个答案，先空着，因为我也没有想明白，不是说/任何类型都实现了interface{}类型吗？这里没想明白，期待你们的解答。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;nil&lt;/code&gt;在不同类型中使用需要注意的问题&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;interface&lt;/code&gt;与&lt;code&gt;nil&lt;/code&gt;比较要注意的一个点&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看一个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; err := Todo()&lt;br/&gt; fmt.Println(err == &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Err &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; err &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Code &lt;span&gt;int64&lt;/span&gt;&lt;br/&gt; Msg &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Todo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;Err&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; res *err&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果是&lt;code&gt;false&lt;/code&gt;，在&lt;code&gt;Todo&lt;/code&gt;方法内我们声明了一个变量&lt;code&gt;res&lt;/code&gt;，这个变量是一个指针类型，零值是&lt;code&gt;nil&lt;/code&gt;，返回的是接口类型，按理说返回值接口类型也应是&lt;code&gt;nil&lt;/code&gt;才对，但是结果却不是这样。这是因为我们忽略了接口类型的一个概念，interface 不是单纯的值，而是分为类型和值。所以必须要类型和值同时都为 &lt;code&gt;nil&lt;/code&gt; 的情况下，&lt;code&gt;interface&lt;/code&gt; 的 &lt;code&gt;nil&lt;/code&gt; 判断才会为 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个新手很容易出现的问题，大家一定要注意这个问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一个&lt;code&gt;nil&lt;/code&gt;的&lt;code&gt;map&lt;/code&gt;读写数据是否会发生&lt;code&gt;panic&lt;/code&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于这种问题，我们直接写个例子测试一下就好：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; m &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt;&lt;br/&gt; fmt.Println(m[&lt;span&gt;&quot;asoong&quot;&lt;/span&gt;])&lt;br/&gt; m[&lt;span&gt;&quot;asong&quot;&lt;/span&gt;] = &lt;span&gt;&quot;Golang梦工厂&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;&lt;span&gt;panic&lt;/span&gt;: assignment to entry in &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;map&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;goroutine &lt;span&gt;1&lt;/span&gt; [running]:&lt;br/&gt;main.main()&lt;br/&gt;        &lt;span&gt;go&lt;/span&gt;/src/asong.cloud/Golang_Dream/code_demo/slice_demo/&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt; +&lt;span&gt;0xed&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据运行结果我们可以看出，一个&lt;code&gt;nil&lt;/code&gt;的&lt;code&gt;map&lt;/code&gt;可以读数据，但是不可以写入数据，否则会发生&lt;code&gt;panic&lt;/code&gt;，所以要使用&lt;code&gt;map&lt;/code&gt;一定要使用&lt;code&gt;make&lt;/code&gt;进行初始化。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;关闭&lt;code&gt;nil&lt;/code&gt;的&lt;code&gt;channel&lt;/code&gt;会引发&lt;code&gt;panic&lt;/code&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; cha &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; &lt;span&gt;close&lt;/span&gt;(cha)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;panic&lt;/span&gt;: &lt;span&gt;close&lt;/span&gt; of &lt;span&gt;nil&lt;/span&gt; channel&lt;br/&gt;&lt;br/&gt;goroutine &lt;span&gt;1&lt;/span&gt; [running]:&lt;br/&gt;main.main()&lt;br/&gt;       /&lt;span&gt;go&lt;/span&gt;/src/asong.cloud/Golang_Dream/code_demo/slice_demo/&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;5&lt;/span&gt; +&lt;span&gt;0x2a&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据运行结果我们可以得出关闭一个&lt;code&gt;nil&lt;/code&gt;的&lt;code&gt;channel&lt;/code&gt;会导致程序&lt;code&gt;panic&lt;/code&gt;，在使用上我们要注意这个问题，还有有一个需要注意的问题：&lt;strong&gt;一个&lt;code&gt;nil&lt;/code&gt;的&lt;code&gt;channel&lt;/code&gt;读写数据都会造成永远阻塞。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一个为&lt;code&gt;nil&lt;/code&gt;的&lt;code&gt;slice&lt;/code&gt;使用注意事项&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; slice []&lt;span&gt;int64&lt;/span&gt; = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; fmt.Println(&lt;span&gt;len&lt;/span&gt;(slice))&lt;br/&gt; fmt.Println(&lt;span&gt;cap&lt;/span&gt;(slice))&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;range&lt;/span&gt; slice{&lt;br/&gt;&lt;br/&gt; }&lt;br/&gt; fmt.Println(slice[&lt;span&gt;0&lt;/span&gt;])&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;panic&lt;/span&gt;: runtime error: index out of &lt;span&gt;range&lt;/span&gt; [&lt;span&gt;0&lt;/span&gt;] with length &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;goroutine &lt;span&gt;1&lt;/span&gt; [running]:&lt;br/&gt;main.main()&lt;br/&gt;        /&lt;span&gt;go&lt;/span&gt;/src/asong.cloud/Golang_Dream/code_demo/slice_demo/&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt; +&lt;span&gt;0xf2&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据这个例子，我们可以得出如下结论：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;一个为&lt;code&gt;nil&lt;/code&gt;的索引，不可以进行索引，否则会引发&lt;code&gt;panic&lt;/code&gt;，其他操作是可以。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;方法接收者为&lt;code&gt;nil&lt;/code&gt;时是否会引发&lt;code&gt;panic&lt;/code&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; m *man&lt;br/&gt; fmt.Println(m.GetName())&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; man &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m *man)&lt;/span&gt;&lt;span&gt;GetName&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;asong&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;asong&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据运行结果我们可以看出，方法接收者为&lt;code&gt;nil&lt;/code&gt;时，我们仍然可以访问对应的方法，但是要注意方法内的写法，否则也会引发&lt;code&gt;panic&lt;/code&gt;。上面的代码改成这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; m *man&lt;br/&gt; fmt.Println(m.GetName())&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; man &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Name &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m *man)&lt;/span&gt;&lt;span&gt;GetName&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; m.Name&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;&lt;span&gt;panic&lt;/span&gt;: runtime error: invalid memory address or &lt;span&gt;nil&lt;/span&gt; pointer dereference&lt;br/&gt;[signal SIGSEGV: segmentation violation code=&lt;span&gt;0x1&lt;/span&gt; addr=&lt;span&gt;0x0&lt;/span&gt; pc=&lt;span&gt;0x10a6ec3&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;goroutine &lt;span&gt;1&lt;/span&gt; [running]:&lt;br/&gt;main.(*man).GetName(...)&lt;br/&gt;        &lt;span&gt;go&lt;/span&gt;/src/asong.cloud/Golang_Dream/code_demo/slice_demo/&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;&lt;br/&gt;main.main()&lt;br/&gt;        &lt;span&gt;go&lt;/span&gt;/src/asong.cloud/Golang_Dream/code_demo/slice_demo/&lt;span&gt;nil&lt;/span&gt;.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt; +&lt;span&gt;0x23&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就是直接引发&lt;code&gt;panic&lt;/code&gt;，所以为了程序健壮性我们要做一次指针判空处理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;空指针是一个没有任何值的指针&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; a = (*&lt;span&gt;int64&lt;/span&gt;)(unsafe.Pointer(&lt;span&gt;uintptr&lt;/span&gt;(&lt;span&gt;0x0&lt;/span&gt;)))&lt;br/&gt; fmt.Println(a == &lt;span&gt;nil&lt;/span&gt;)  &lt;span&gt;//true&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行结果&lt;/span&gt;&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们用了&lt;code&gt;0x0&lt;/code&gt;做了一个小实验，正好证明了空指针就是一个没有指向任何值的指针。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章接近尾声啦，我们来揭晓一下文章开始的答案，用文中&lt;code&gt;nil&lt;/code&gt;比较的知识点正好可以解答这个问题，&lt;code&gt;nil&lt;/code&gt;标识符是没有类型的，所以&lt;code&gt;==&lt;/code&gt;对于&lt;code&gt;nil&lt;/code&gt;来说是一种未定义的操作，不可以进行比较，而这个在&lt;code&gt;python&lt;/code&gt;中是可以比较的，在 &lt;code&gt;python&lt;/code&gt; 中，两个&lt;code&gt;None&lt;/code&gt; 值永远相等，不要弄混了朋友们。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最后建议你们看一下这个视频：https://www.youtube.com/watch?v=ynoY2xz-F8s&lt;/strong&gt;  &lt;strong&gt;需要翻墙哈，看完这个你对&lt;code&gt;nil&lt;/code&gt;会有一个新的理解。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;好啦，这篇文章就到这里啦，素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：加我vx拉你入群，或者公众号获取入群二维码&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;翻译了一份Machinery中文文档，会定期进行维护，有需要的小伙伴们后台回复[machinery]即可获取。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我是asong，一名普普通通的程序猿，让我们一起慢慢变强吧。欢迎各位的关注，我们下期见~~~&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/k5430ljpYPNFVT6F1cSh4LJhic7wX9o3cmPicXrYcyvAxtKDVTg3PzTQicpw8wLIc59lVPs6c0UrWDwr1qnwq67UA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐往期文章：&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>682a8772255876bcc2d08c5f74554ac4</guid>
<title>使用 Go defer 要小心这 2 个雷区</title>
<link>https://toutiao.io/k/ye8mh35</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是煎鱼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 语言中 defer 是一个非常有意思的关键字特性。例子如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; fmt.Println(&lt;span&gt;&quot;煎鱼了&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;脑子进&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;脑子进&lt;br/&gt;煎鱼了&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前几天我的读者群内有小伙伴讨论起了下面这个问题：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6857142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4j5DWNOwFianbpNnjqOghR07YfDzZ9rk5vclcUzSUJJoh1kY5KZORcNIOw9LFxRMicE4RdUYlbhBjwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1330&quot;/&gt;&lt;figcaption&gt;读者群的聊天截图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来讲，&lt;strong&gt;问题就是针对在 &lt;code&gt;for&lt;/code&gt; 循环里搞 defer 关键字，是否会造成什么性能影响&lt;/strong&gt;？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为在 Go 语言的底层数据结构设计上 defer 是链表的数据结构：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6497297297297298&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4j5DWNOwFianbpNnjqOghR07IeOiaSsWAhpwrtjcW6libeoAsnrVibjibQIrgfRy5c5fn2Cqib2Kq2bTxZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;925&quot;/&gt;&lt;figcaption&gt;defer 基本底层结构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家担心如果循环过大 defer 链表会巨长，不够 “精益求精”。又或是猜想会不会 Go defer 的设计和 Redis 数据结构设计类似，自己做了优化，其实没啥大影响？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天这篇文章，我们就来探索循环 Go defer，造成底层链表过长会不会带来什么问题，若有，具体有什么影响？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开始吸鱼之路。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;defer 性能优化 30%&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在早年 Go1.13 时曾经对 defer 进行了一轮性能优化，在大部分场景下 提高了 defer 30% 的性能：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4045734388742304&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4j5DWNOwFianbpNnjqOghR07DDPUAK32entwibdibwhHiahPoc5NGWfFY9zgBibe3OIcwbSXYW9xdw06Bw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2274&quot;/&gt;&lt;figcaption&gt;Go defer 1.13 优化记录&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来回顾一下 Go1.13 的变更，看看 Go defer 优化在了哪里，这是问题的关键点。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;以前和现在对比&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go1.12 及以前，调用 Go defer 时汇编代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    0x0070 00112 (main.go:6)    CALL    runtime.deferproc(SB)&lt;br/&gt;    0x0075 00117 (main.go:6)    TESTL    AX, AX&lt;br/&gt;    0x0077 00119 (main.go:6)    JNE    137&lt;br/&gt;    0x0079 00121 (main.go:7)    XCHGL    AX, AX&lt;br/&gt;    0x007a 00122 (main.go:7)    CALL    runtime.deferreturn(SB)&lt;br/&gt;    0x007f 00127 (main.go:7)    MOVQ    56(SP), BP&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go1.13 及以后，调用 Go defer 时汇编代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; 0x006e 00110 (main.go:4) MOVQ AX, (SP)&lt;br/&gt; 0x0072 00114 (main.go:4) CALL runtime.deferprocStack(SB)&lt;br/&gt; 0x0077 00119 (main.go:4) TESTL AX, AX&lt;br/&gt; 0x0079 00121 (main.go:4) JNE 139&lt;br/&gt; 0x007b 00123 (main.go:7) XCHGL AX, AX&lt;br/&gt; 0x007c 00124 (main.go:7) CALL runtime.deferreturn(SB)&lt;br/&gt; 0x0081 00129 (main.go:7) MOVQ 112(SP), BP&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从汇编的角度来看，像是原本调用 &lt;code&gt;runtime.deferproc&lt;/code&gt; 方法改成了调用 &lt;code&gt;runtime.deferprocStack&lt;/code&gt; 方法，难道是做了什么优化？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们&lt;strong&gt;抱着疑问&lt;/strong&gt;继续看下去。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;defer 最小单元：_defer&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相较于以前的版本，Go defer 的最小单元 &lt;code&gt;_defer&lt;/code&gt; 结构体主要是新增了 &lt;code&gt;heap&lt;/code&gt; 字段：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; _defer struct {&lt;br/&gt; siz     int32&lt;br/&gt; siz     int32 // includes both arguments and results&lt;br/&gt; started bool&lt;br/&gt; heap    bool&lt;br/&gt; sp      uintptr // sp at time of defer&lt;br/&gt; pc      uintptr&lt;br/&gt; fn      *funcval&lt;br/&gt; ...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该字段用于标识这个 &lt;code&gt;_defer&lt;/code&gt; 是在堆上，还是在栈上进行分配，其余字段并没有明确变更，那我们可以把聚焦点放在 &lt;code&gt;defer&lt;/code&gt; 的堆栈分配上了，看看是做了什么事。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;deferprocStack&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func deferprocStack(d *_defer) {&lt;br/&gt; gp := getg()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; gp.m.curg != gp {&lt;br/&gt;  throw(&lt;span&gt;&quot;defer on system stack&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt; &lt;br/&gt; d.started = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; d.heap = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; d.sp = getcallersp()&lt;br/&gt; d.pc = getcallerpc()&lt;br/&gt;&lt;br/&gt; *(*uintptr)(unsafe.Pointer(&amp;amp;d._panic)) = 0&lt;br/&gt; *(*uintptr)(unsafe.Pointer(&amp;amp;d.link)) = uintptr(unsafe.Pointer(gp._defer))&lt;br/&gt; *(*uintptr)(unsafe.Pointer(&amp;amp;gp._defer)) = uintptr(unsafe.Pointer(d))&lt;br/&gt;&lt;br/&gt; return0()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一块代码挺常规的，主要是获取调用 &lt;code&gt;defer&lt;/code&gt; 函数的函数栈指针、传入函数的参数具体地址以及PC（程序计数器），这块在前文 《深入理解 Go defer》 有详细介绍过，这里就不再赘述了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个 &lt;code&gt;deferprocStack&lt;/code&gt; 特殊在哪呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到它把 &lt;code&gt;d.heap&lt;/code&gt; 设置为了 &lt;code&gt;false&lt;/code&gt;，也就是代表 &lt;code&gt;deferprocStack&lt;/code&gt; 方法是针对将 &lt;code&gt;_defer&lt;/code&gt; 分配在栈上的应用场景的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;deferproc&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题来了，它又在哪里处理分配到堆上的应用场景呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func newdefer(siz int32) *_defer {&lt;br/&gt; ...&lt;br/&gt; d.heap = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; d.link = gp._defer&lt;br/&gt; gp._defer = d&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; d&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的 &lt;code&gt;newdefer&lt;/code&gt; 是在哪里调用的呢，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func deferproc(siz int32, fn *funcval) { // arguments of fn follow fn&lt;br/&gt; ...&lt;br/&gt; sp := getcallersp()&lt;br/&gt; argp := uintptr(unsafe.Pointer(&amp;amp;fn)) + unsafe.Sizeof(fn)&lt;br/&gt; callerpc := getcallerpc()&lt;br/&gt;&lt;br/&gt; d := newdefer(siz)&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常明确，先前的版本中调用的 &lt;code&gt;deferproc&lt;/code&gt; 方法，现在被用于对应分配到堆上的场景了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小结&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可以确定的是 &lt;code&gt;deferproc&lt;/code&gt; 并没有被去掉，而是流程被优化了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Go 编译器会根据应用场景去选择使用 &lt;code&gt;deferproc&lt;/code&gt; 还是 &lt;code&gt;deferprocStack&lt;/code&gt; 方法，他们分别是针对分配在堆上和栈上的使用场景。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;优化在哪儿&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要优化在于其 defer 对象的堆栈分配规则的改变，措施是：编译器对 &lt;code&gt;defer&lt;/code&gt; 的 &lt;code&gt;for-loop&lt;/code&gt; 迭代深度进行分析。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// src/cmd/compile/internal/gc/esc.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; ODEFER:&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; e.loopdepth == &lt;span&gt;1&lt;/span&gt; { &lt;span&gt;// top level&lt;/span&gt;&lt;br/&gt;  n.Esc = EscNever &lt;span&gt;// force stack allocation of defer record (see ssa.go)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;break&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 Go 编译器检测到循环深度（loopdepth）为 1，则设置逃逸分析的结果，将分配到栈上，否则分配到堆上。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// src/cmd/compile/internal/gc/ssa.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; ODEFER:&lt;br/&gt; d := callDefer&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; n.Esc == EscNever {&lt;br/&gt;  d = callDeferStack&lt;br/&gt; }&lt;br/&gt; s.call(n.Left, d)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以此免去了以前频繁调用 &lt;code&gt;systemstack&lt;/code&gt;、&lt;code&gt;mallocgc&lt;/code&gt; 等方法所带来的大量性能开销，来达到大部分场景提高性能的作用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;循环调用 defer&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到问题本身，知道了 defer 优化的原理后。那 “循环里搞 defer 关键字，是否会造成什么性能影响？”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最直接的影响就是这大约 30% 的性能优化直接全无，且由于姿势不正确，理论上 defer 既有的开销（链表变长）也变大，性能变差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此我们要避免以下两种场景的代码：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;显式循环：在调用 defer 关键字的外层有显式的循环调用，例如：&lt;code&gt;for-loop&lt;/code&gt; 语句等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;隐式循环：在调用 defer 关键字有类似循环嵌套的逻辑，例如：&lt;code&gt;goto&lt;/code&gt; 语句等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;显式循环&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个例子是直接在代码的 &lt;code&gt;for&lt;/code&gt; 循环中使用 defer 关键字：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt;= &lt;span&gt;99&lt;/span&gt;; i++ {&lt;br/&gt;  &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   fmt.Println(&lt;span&gt;&quot;脑子进煎鱼了&quot;&lt;/span&gt;)&lt;br/&gt;  }()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个也是最常见的模式，无论是写爬虫时，又或是 Goroutine 调用时，不少人都喜欢这么写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这属于显式的调用了循环。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;隐式循环&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个例子是在代码中使用类似 &lt;code&gt;goto&lt;/code&gt; 关键字：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; i := &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;food:&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {}()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; i == &lt;span&gt;1&lt;/span&gt; {&lt;br/&gt;  i -= &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;goto&lt;/span&gt; food&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种写法比较少见，因为 &lt;code&gt;goto&lt;/code&gt; 关键字有时候甚至会被列为代码规范不给使用，主要是会造成一些滥用，所以大多数就选择其实方式实现逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这属于隐式的调用，造成了类循环的作用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然，Defer 在设计上并没有说做的特别的奇妙。他主要是根据实际的一些应用场景进行了优化，达到了较好的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然本身 defer 会带一点点开销，但并没有想象中那么的不堪使用。除非你 defer 所在的代码是需要频繁执行的代码，才需要考虑去做优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;否则没有必要过度纠结，在实际上，猜测或遇到性能问题时，看看 PProf 的分析，看看 defer 是不是在相应的 hot path 之中，再进行合理优化就好。&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓的优化，可能也只是去掉 defer 而采用手动执行，并不复杂。在编码时避免踩到 defer 的显式和隐式循环这 2 个雷区就可以达到性能最大化了。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7753b666c72b0ff72d7fb912ee75d076</guid>
<title>来一起用 Vue3 做个飞机大战游戏（附源码）</title>
<link>https://toutiao.io/k/nn3a1b3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;现在但凡出去面试，面试官几乎必问 &lt;/span&gt;&lt;span lang=&quot;en-US&quot;&gt;Vue3.0 &lt;/span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;。不仅会问一些核心特性，还会问原理层面的问题。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;比如：&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;▶框架层面问题：&lt;/strong&gt;Vue3.0 新特性 Composition API 与 React.js 中 Hooks 的异同点？&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;▶源码、原理层面问题：&lt;/strong&gt; Vue3.0
编译做了哪些优化？Vue3.0是如何变得更快的？&lt;/section&gt;&lt;section&gt; &lt;/section&gt;&lt;section&gt;&lt;span lang=&quot;zh-CN&quot;&gt;也许你会想，面试官现在问 &lt;/span&gt;&lt;span lang=&quot;en-US&quot;&gt;Vue3.0 &lt;/span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;是不是在造火箭？毕竟&lt;/span&gt;&lt;span lang=&quot;en-US&quot;&gt;Vue3.0&lt;/span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;还没有大规模应用，就算面了工作中也用不到。&lt;/span&gt;&lt;/section&gt;&lt;section&gt; &lt;/section&gt;&lt;section&gt;其实不然。&lt;/section&gt;&lt;section&gt; &lt;/section&gt;&lt;section&gt;&lt;span lang=&quot;zh-CN&quot;&gt;第一：现在&lt;/span&gt;&lt;span lang=&quot;en-US&quot;&gt;Vue3.0&lt;/span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;的生态已经逐步完善，各组件库如&lt;span&gt;AntDesign，Vant，Element &lt;/span&gt;已先后宣布支持 &lt;/span&gt;&lt;span lang=&quot;en-US&quot;&gt;Vue3.0&lt;/span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;/span&gt;&lt;span lang=&quot;en-US&quot;&gt;Vue3.0 &lt;/span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;大规模适用指日可待。&lt;/span&gt;&lt;/section&gt;&lt;section&gt; &lt;/section&gt;&lt;section&gt;&lt;span lang=&quot;zh-CN&quot;&gt;第二：面试考量的不仅是你对技术的掌握，更考量你对新技术的敏感度以及学习能力，&lt;/span&gt;&lt;span lang=&quot;en-US&quot;&gt;Vue3.0&lt;/span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;作为受众极广的最新版本框架，自然是面试时必问的内容。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，现在学习 Vue3.0 非常必要，而且要深入原理层面！&lt;/span&gt;&lt;/section&gt;&lt;section&gt; &lt;/section&gt;&lt;section&gt;&lt;span lang=&quot;zh-CN&quot;&gt;不过虽说 &lt;/span&gt;&lt;span lang=&quot;en-US&quot;&gt;Vue &lt;/span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;以功能简洁易上手著称，但 &lt;/span&gt;&lt;span lang=&quot;en-US&quot;&gt;Vue3.0 &lt;/span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;源码的学习、新特性的原理理解并不是看看官方文档就能解决的。这里给大家推荐一个&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前端面试亮点杀器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;——&lt;/span&gt;&lt;span&gt;&lt;strong&gt;《用Vue3.0实现飞机大战游戏&lt;/strong&gt;&lt;strong&gt;》视频课程，&lt;/strong&gt;帮你&lt;/span&gt;&lt;span&gt;通过实战掌握&lt;/span&gt;&lt;span&gt;Vue 3.0&lt;/span&gt;&lt;span&gt;核心新功能，在工作和面试中胜人一筹。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;课程价值699元，我给大家争取到&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;200个免费名额&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，不用转发不用分享，点击链接就能报名：https://wx.kaikeba.com/vip_course/r3b5ldqxsd/h9w4pn02dg?tenant=wx5046bc7413796142&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101125&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hObz0jenxicC8Y9YXickMkOPLWuiaUMHRic8hibfYuzRS4Jjg201Y8ia2G6Oib7uMy5qtMALso58icjDj1BEPwFCbSXFCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-width=&quot;100%&quot; data-ratio=&quot;0.7058823529411765&quot; data-w=&quot;34&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;你将收获：&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;97617&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;289:322&quot;&gt;老师简介&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img border=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;104&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;104&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hObz0jenxicDC59e5sdos6ngicGrMqVYtgMTAM5jzOVHnYgVCtib9dhLdhaBj9nTia1Spj9lXrLckkUUwRbbicd15SQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;483&quot; data-width=&quot;100%&quot; opacity=&quot;&quot; title=&quot;&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p line=&quot;3f4d&quot;&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;崔效瑞&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;老师&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Vue 3.0 Contributor&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p line=&quot;387c&quot;&gt;前好未来，白鹭时代资深前端工程师&lt;/p&gt;&lt;p line=&quot;kPsc&quot;&gt;在H5游戏开发、&lt;span&gt;TDD和重构方向具备丰富实践经验&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;IdNV&quot;&gt;对基础数据结构与算法的使用上有深入理解&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;97617&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;289:322&quot;&gt;知识点大纲&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1451&quot; data-ratio=&quot;2.508&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hObz0jenxicBKYQicibZm5XSTT7F3gDojFyBiadCSYgXWCVjYzSx6GHc0tnsWnhCu0POhHm82Ee0s9II82wGM3oLUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;97617&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;261:260&quot;&gt;特别适合这样的你&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;571&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;553&quot; data-ratio=&quot;0.9705056179775281&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hObz0jenxicA8sbv7wsWsD2ebdicMiaQViaPibyabM3Yt0QRhnCPG6FQyKyKnGhFfHYlPoibhr0rPkhblAlJrObvO2fA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;712&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;97617&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;261:260&quot;&gt;资料截图&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.22529069767441862&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hObz0jenxicA8sbv7wsWsD2ebdicMiaQViaPL2ib6v33zNvlloH3lrABVbFArEnQLJ5zw6GPE3xzRNianorQMykeHibDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;688&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_png/hObz0jenxicA8sbv7wsWsD2ebdicMiaQViaPBvicqwzJiawkCY7rcNWuXN6BgOSicLrgtkdpgT9j2ZTtPp6L8MEQ5782g/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;711.3238434163701&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;281.4590747330961&quot; data-ratio=&quot;0.3952180028129395&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hObz0jenxicA8sbv7wsWsD2ebdicMiaQViaP2UEd0TjcYpp1AjUQzxsgDE8xFUryuuXXTTZqDViaDBCsbibmKYfa5VIw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;711&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.22922636103151864&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hObz0jenxicA8sbv7wsWsD2ebdicMiaQViaPfg0VOPUibXoZJGcYCdbrSnK0u6h8jGcMh69OntqwB7xT9NRg9F8Mb9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;698&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_png/hObz0jenxicA8sbv7wsWsD2ebdicMiaQViaPL9nkg9icqyr7JfYgpOiaPZSyL0LcmZyFAkK61K0J2NUYIvTvkE7RfW1g/0?wx_fmt=png&quot; data-cropx1=&quot;14&quot; data-cropx2=&quot;353&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;102&quot; data-ratio=&quot;0.3&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hObz0jenxicA8sbv7wsWsD2ebdicMiaQViaPhz1EibRKnbz2nCTTxjxv48CejAYbRF2RE6RTrl0Ux4MiaZxfvJPd5RTQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;340&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;↑视频及课件截图↑&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;450 分钟实用干货&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;价值699元&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;前200名免费领！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;点击链接立即领取：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://wx.kaikeba.com/vip_course/r3b5ldqxsd/h9w4pn02dg?tenant=wx5046bc7413796142&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8510d05a79c9efb857c6d8cf8026a0d9</guid>
<title>初识同态加密</title>
<link>https://toutiao.io/k/r1qlgmu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2&gt;一、初识同态加密&lt;/h2&gt;&lt;p&gt;说起同态加密，已经有很长很长很长的一段历史了，不过，仅是在理论研究中。在工业界一直没能发展起来，主要原因是其密集型计算的特性，导致计算效率过低，在工业界无法展开应用。另一方面原因，在2009年之前，全同态加密的研究一直没有突破进展。半同态加密和有限同态加密只能应用在特定场景。&lt;/p&gt;&lt;p&gt;不过，到了2009年，一切不一样了，Gentry 大神在博士论文中，设计出了第一个全同态加密，改变了这个世界。从此，加密的 &quot;圣杯&quot; 出现了。&lt;/p&gt;&lt;p&gt;读到这，如果不是特别了解同态加密的同学可能会有疑问，&quot;同态加密&quot; 为什么可以称为加密界的圣杯呢？好的，带着这个疑问，咱们往下看。&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设有这样一个场景&lt;/span&gt;，有两方 &lt;img data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/XxT9TiaJ1ibf2JpaBtPxibGlWakByoP6NgYcpoZQcgESqOJRXPZNxc5dibwiaWS5EtYxIVpfHkhibJgmVLWFBRagcaC9oCwK2Doxkp/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;36&quot;/&gt; ， &lt;img data-ratio=&quot;1.1333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/XxT9TiaJ1ibf2JpaBtPxibGlWakByoP6NgYNVBY7yiaZKvfftFPGQS1V9wibeibeZ47icqQjyplLvKaa6D8LBy7nPiagdibIhnnZhF8hb/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;15&quot;/&gt; 表示客户端， &lt;img data-ratio=&quot;1.4166666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/XxT9TiaJ1ibf2JpaBtPxibGlWakByoP6NgYtBmWHTXTp6cZYKH3h2uOO8pgvl595hH3kHmF7CBjmBwQZaP0KOJqbXHJesPibLQ5c/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;12&quot;/&gt; 表示服务端。现 &lt;img data-ratio=&quot;1.1333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/XxT9TiaJ1ibf2JpaBtPxibGlWakByoP6NgYNVBY7yiaZKvfftFPGQS1V9wibeibeZ47icqQjyplLvKaa6D8LBy7nPiagdibIhnnZhF8hb/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;15&quot;/&gt; 有大量的数据需要托管给 &lt;img data-ratio=&quot;1.4166666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/XxT9TiaJ1ibf2JpaBtPxibGlWakByoP6NgYtBmWHTXTp6cZYKH3h2uOO8pgvl595hH3kHmF7CBjmBwQZaP0KOJqbXHJesPibLQ5c/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;12&quot;/&gt; 保存，但是 &lt;img data-ratio=&quot;1.1333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/XxT9TiaJ1ibf2JpaBtPxibGlWakByoP6NgYNVBY7yiaZKvfftFPGQS1V9wibeibeZ47icqQjyplLvKaa6D8LBy7nPiagdibIhnnZhF8hb/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;15&quot;/&gt; 担心 &lt;img data-ratio=&quot;1.4166666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/XxT9TiaJ1ibf2JpaBtPxibGlWakByoP6NgYtBmWHTXTp6cZYKH3h2uOO8pgvl595hH3kHmF7CBjmBwQZaP0KOJqbXHJesPibLQ5c/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;12&quot;/&gt; 会窥探自己的数据，因此 &lt;img data-ratio=&quot;1.1333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/XxT9TiaJ1ibf2JpaBtPxibGlWakByoP6NgYNVBY7yiaZKvfftFPGQS1V9wibeibeZ47icqQjyplLvKaa6D8LBy7nPiagdibIhnnZhF8hb/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;15&quot;/&gt; 对数据加密后再传至 &lt;img data-ratio=&quot;1.4166666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/XxT9TiaJ1ibf2JpaBtPxibGlWakByoP6NgYtBmWHTXTp6cZYKH3h2uOO8pgvl595hH3kHmF7CBjmBwQZaP0KOJqbXHJesPibLQ5c/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;12&quot;/&gt;（这里的加密可以简单理解成一个概念，不指任何的具体加密算法）。&lt;/p&gt;&lt;p&gt;&lt;span&gt;需求来了：&lt;/span&gt;若 &lt;img data-ratio=&quot;1.1333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/XxT9TiaJ1ibf2JpaBtPxibGlWakByoP6NgYNVBY7yiaZKvfftFPGQS1V9wibeibeZ47icqQjyplLvKaa6D8LBy7nPiagdibIhnnZhF8hb/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;15&quot;/&gt; 想要对数据做更新或计算，那该怎么办呢？很多小伙伴会想到，把数据下载下来，解密后再处理呗。这样做的确可以，但是，如果在数据量巨大的情况下，那会导致很大的通信开销。那怎么办呢？其实很简单，找到一个密码算法，能够计算密文数据，如此，&lt;img data-ratio=&quot;1.1333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/XxT9TiaJ1ibf2JpaBtPxibGlWakByoP6NgYNVBY7yiaZKvfftFPGQS1V9wibeibeZ47icqQjyplLvKaa6D8LBy7nPiagdibIhnnZhF8hb/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;15&quot;/&gt; 只需要消耗特别少的通信和计算开销，便可以完成数据计算和更新。是的，你想的没错，这个加密算法的确存在，那就是同态加密。&lt;/p&gt;&lt;p&gt;读到这，小伙伴们肯定发现了，这个场景就是咱们每天在使用的云计算环境。同态加密是云计算领域中一个特别重要的研究方向，谁能掌握更轻量级的同态加密技术，谁就能在云计算争分中能够拥有一席之地。这也是为什么像IBM、微软等公司一直在坚持研发和推广同态加密的原因。&lt;/p&gt;&lt;p&gt;好了，是时候揭开同态加密的面纱了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;img data-ratio=&quot;0.599294947121034&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/IkKiaNgEKzNmacO11A9LexyEWjDcSyLbGy4zwPptUib7vpgPjYuib4rlibCUSo7MYFrVxT6WdXmJ1wc4JuGVaHGO0g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;851&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;二、同态加密定义&lt;/h2&gt;&lt;h2&gt;2.1 全同态加密&lt;/h2&gt;&lt;p&gt;同时满足加同态和乘同态性质，可以进行任意多次加和乘运算的加密函数。用数学公式来表达，即&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.06666666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/XxT9TiaJ1ibf2JpaBtPxibGlWakByoP6NgYedaOP9mqaF75Rm0HmEUwyXmzaDv0VRuOj31mCDsmiaa6ibWqSyAHw0icWdLLibecqfUj/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;600&quot;/&gt; 或写成&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.06666666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/XxT9TiaJ1ibf2JpaBtPxibGlWakByoP6NgYTfvLzggTWpOibKGvGS7pQYR2aicQuMYDl3huFHrfia4Kc8ZwJMlSHfnMA7saecMic5ic0/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;600&quot;/&gt; 如果 &lt;img data-ratio=&quot;2&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/XxT9TiaJ1ibf2JpaBtPxibGlWakByoP6NgYfZgjR2SiatSnt8BRUzsJHq422BRPQBB1ibR0GejpD1mCoD3LCjTaLjxy6HL71AMVTia/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;10&quot;/&gt; 是任意函数，称为全同态加密。&lt;/p&gt;&lt;h2&gt;2.2 加法同态加密&lt;/h2&gt;&lt;p&gt;存在有效算法 &lt;img data-ratio=&quot;1.2142857142857142&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/XxT9TiaJ1ibf2JpaBtPxibGlWakByoP6NgYWyUianqHlErgFOfraeNv33ewibFzZmut2Kj1yHbvL5Y6CQib5rseRTnU86Tic1XRRCZ1/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;14&quot;/&gt; ，使得 &lt;img data-ratio=&quot;0.08846153846153847&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/XxT9TiaJ1ibf2JpaBtPxibGlWakByoP6NgYlq4RYkxpEib0eb9UZbBibCKv85JBzIXtYn8pgxP6lDyXGaXlFtXJF8c4bEUje10ARS/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;260&quot;/&gt; 或者 &lt;img data-ratio=&quot;0.08846153846153847&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/XxT9TiaJ1ibf2JpaBtPxibGlWakByoP6NgYQlPDmtJbuPrEj38ahCqec5bYRKjDjT6icg4DAMOd1WcZmyDXDEPGJd2sanN9e3TKW/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;260&quot;/&gt; 成立，并且不泄漏 &lt;img data-ratio=&quot;1.1818181818181819&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/XxT9TiaJ1ibf2JpaBtPxibGlWakByoP6NgYONqCyV5nK0ywAPLQSmZa6GS7rcnBOmse7ayIcia2bQtVwhHTzTuVibFykJ9Fycyq6G/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;11&quot;/&gt; 和 &lt;img data-ratio=&quot;1.7777777777777777&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/XxT9TiaJ1ibf2JpaBtPxibGlWakByoP6NgYpWFUjdkkibKvHibhicRIMckzQcgzRC1nyibHOFSQUjcpysaWRgTQWYYtjGjlHzOGf6K6/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;9&quot;/&gt; 。&lt;/p&gt;&lt;h2&gt;2.3 乘法同态加密&lt;/h2&gt;&lt;p&gt;存在有效算法 &lt;img data-ratio=&quot;1.2142857142857142&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/XxT9TiaJ1ibf2JpaBtPxibGlWakByoP6NgY0MSgTdWp9jOw2rQFnFfiamRsQfBrZmkLiaHRTslVzmjHsElzEzhiabhnJvpQicmHqibcG/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;14&quot;/&gt; ，使得 &lt;img data-ratio=&quot;0.08846153846153847&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/XxT9TiaJ1ibf2JpaBtPxibGlWakByoP6NgY4ciadKXrAMHRCBmkFYBVOrYRhzoia4jTTMmORs4pt2VtecicMHahX6NBicO2gyDPBs5o/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;260&quot;/&gt; 或者 &lt;img data-ratio=&quot;0.08846153846153847&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/XxT9TiaJ1ibf2JpaBtPxibGlWakByoP6NgYPfYLjqExiaPdqsCOw8CPYSvDnQRGfMcTxYeQam2YQDr1ZN9EBakpiaibVapLFIz5iaFw/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;260&quot;/&gt; 成立，并且不泄漏 &lt;img data-ratio=&quot;1.1818181818181819&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/XxT9TiaJ1ibf2JpaBtPxibGlWakByoP6NgYONqCyV5nK0ywAPLQSmZa6GS7rcnBOmse7ayIcia2bQtVwhHTzTuVibFykJ9Fycyq6G/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;11&quot;/&gt; 和 &lt;img data-ratio=&quot;1.7777777777777777&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/XxT9TiaJ1ibf2JpaBtPxibGlWakByoP6NgYpWFUjdkkibKvHibhicRIMckzQcgzRC1nyibHOFSQUjcpysaWRgTQWYYtjGjlHzOGf6K6/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;9&quot;/&gt; 。&lt;/p&gt;&lt;p&gt;上面便是同态加密的一些定义，具体实现方法我会在后续的文章中，以解读经典文章呈现。&lt;/p&gt;&lt;h2&gt;三、同态加密实现&lt;/h2&gt;&lt;p&gt;看完了同态加密的定义，咱们一起来看下，现阶段有哪些同态加密方案和工程实现。&lt;/p&gt;&lt;h2&gt;3.1 理论研究&lt;/h2&gt;&lt;p&gt;现在主流的研究方案包括 FHEW、TFHE、GSW、BGV、BFV、CKKS.&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中 FHEW、TFHE、GSW为布尔电路上的实现，其特性&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;BGV、BFV是算数电路上的实现，其特性&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CKKS则是17年才提出来的，其特性&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;3.2 工程实现&lt;/h2&gt;&lt;p&gt;现阶段已经有非常多的成熟同态加密库，主要包含cuFHE、FHEW、FV-NFLib、HEAAN、HElib、PALISADE、SEAL、TFHE 和 Lattigo。各有其优势。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5179640718562875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/IkKiaNgEKzNmacO11A9LexyEWjDcSyLbGY5Z3h3uFfYRxpq0Y6X8yzX6NJuch5YzuvBqTrpGRnibEicalUKc6EoOg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;668&quot;/&gt;&lt;/p&gt;&lt;p&gt;现在，同态加密已经有了非常多的应用领域，比如&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;img data-ratio=&quot;0.2695167286245353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/IkKiaNgEKzNmacO11A9LexyEWjDcSyLbGqh9J8WzqEnKKpBwNBRqlqg2XUWiaoicg7Covzp9XiaUR4h8SBDFhDuZZQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1076&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;四、总结&lt;/h2&gt;&lt;p&gt;同态加密火的一塌糊涂，其主要原因还是云计算、大数据和数据安全的发展引起的。现在学习同态加密还不晚，等把基础打牢时，全同态加密还不一定能够商用呢，不过未来可期。&lt;/p&gt;&lt;p&gt;最后的最后，我还是要给出大家一些阅读材料的：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Zvika， Brakerski， Craig， et al。(Leveled) Fully Homomorphic Encryption without Bootstrapping[J]。ACM Transactions on Computation Theory (TOCT) - Special issue on innovations in theoretical computer science 2012 - Part II， 2014。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Zvika Brakerski。2012。Fully Homomorphic Encryption without Modulus Switching from Classical GapSVP。868–886。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Cheon J H ， Kim A ， Kim M ， et al。Homomorphic Encryption for Arithmetic of Approximate Numbers[C]// International Conference on the Theory and Application of Cryptology and Information Security。Springer， Cham， 2017。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Liu Gen, Jiang Tianfa. Research on homomorphic encryption technology and the applications of it in IOT [J]. Information Network Security, 2011(5): 61-64 (in Chinese) (刘艮，蒋天发.同态加密技术及其在物联网中的应用研究 [J].信息网络安全，2011(5): 61-64)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;ZDNet. Google to begin offering encrypted search [OL]. [2013-08-20]. &lt;span&gt;www&lt;/span&gt;&lt;span/&gt;. zdnet. co. uk&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Wu Guangyuan, He Pilian, Cao Guihong, et al. Research on word co-occurrence based on vector space model and its application in doucuments [ J]. Computer Applica tions , 2003，23(6): 138-145 (in Chinese) (吴光远，何丕廉，曹桂宏，等.基于向量空间模型的词共现研究及其在文本分类中的应用[J].计算机应用，2003，23(6): 138-145)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Zhou Yongbin. A survey of homomorphic cryptography [G] //The Development Report of the Chinese Cryptology 2010. Beijing: Electronic Industry Press, 2011: 160-1884 (in Chinese) （周永彬. 同态密码学研究进展[G] //中国密码学发展报告. 北京：电子工业出版社，2011 :160-184）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Li Z , Zhu X , Lian Y , et al. Constructing Secure Content-Dependent Watermarking Scheme Using Homomorphic Encryption[C]// IEEE International Conference on Multimedia &amp;amp; Expo. IEEE, 2007.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;同态加密是否准备好向企业提供机密云计算？&lt;span&gt;idcjia.net/m10911.html&lt;/span&gt;&lt;span/&gt;.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;TFHE. Fast Fully Homomorphic Encryption Library over the Torus [EB/OL]. &lt;span&gt;&lt;span&gt;github.com/tfhe/tfhe&lt;/span&gt;&lt;span/&gt;&lt;/span&gt;, 2017-5-2.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Regev O . On Lattices, Learning with Errors, Random Linear Codes, and Cryptography[C]// Proceedings of the 37th Annual ACM Symposium on Theory of Computing, Baltimore, MD, USA, May 22-24, 2005. ACM, 2005.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>