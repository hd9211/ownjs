<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>a3a91c3e38a3b1a4f437680ec48e32cd</guid>
<title>关于项目使用组件版本选择的思考</title>
<link>https://toutiao.io/k/6if9mg1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485934&amp;amp;idx=1&amp;amp;sn=71bc51653cef4a1b3c86e663fb2a3c62&amp;amp;chksm=fafde340cd8a6a5646411696514f350cc1cb00dbac89d6989115f3eeaf1b05d9bb4167b6011e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《项目中怎样做技术选型》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《项目中怎样做技术选型》&lt;/a&gt;中，我介绍了技术选型的一些思考。一旦选定了用什么技术，还涉及到版本的选择。版本不是越高越好，也不是用的越多越好，涉及很多因素。今天从具体实例入手来聊一聊版本选择的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;实例一 servlet版本&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我最近在带一个新项目，因为搭建环境的时候，选择的版本比较新。下游是运行了好多年的老项目，版本相对老一些。其中servlet版本，新项目使用4.0.1版本，它在处理httpHeader时全转成了小写。下游使用3.1.0版本，它是按照原来的大小写原样透传的。这个问题不难处理，下游要兼容一下，做小写转换后再处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;问题是由此引起的思考：新项目很多的版本比较新，是否是最合适的呢？这个问题我没有马上给出结论。而是说这个是个重要不紧急的事情，并不会阻塞开发进度，所以先保持现状不动，我过节有时间好好调研一下再决定。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这是新项目中的使用的一些jar包：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.3338557993730407&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlicSPnJ1lKHwPLDJXqfjpatOj9b3oEEZU9gr4ZmzfOwV5EWbOR1Ws6jClo1G9BR39SWeBj6T0Rwt8Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1276&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这是老项目中使用的一些jar包：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.3338557993730407&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlicSPnJ1lKHwPLDJXqfjpatOuGR7KJb9c4ybdz1z1CIn9AdILHFtj7Ed8z4mGjjARJZhEBmjswqpPQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1276&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;欢迎大家指出使用版本的问题，帮助我们保持系统稳定性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上面总共涉及三个servlet版本：&lt;/p&gt;&lt;p&gt;servlet-api---2.5(实际没有用)&lt;/p&gt;&lt;p&gt;javax.servlet-api---3.1.0&lt;/p&gt;&lt;p&gt;javax.servlet-api---4.0.1&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;分别进行调研结果如下。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;servlet-api---2.5&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;支持配置文件形式注册servlet、listener、filter等&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;javax.servlet-api---3.1.0&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;同时支持注解形式注入&lt;/p&gt;&lt;p&gt;同时支持动态注入&lt;/p&gt;&lt;p&gt;支持扩展插件&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;javax.servlet-api---4.0.1&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;支持&lt;span&gt;从HTTP请求推送生成器等新特性&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;结论&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因为实际我们这个项目用&lt;strong&gt;&lt;span&gt;javax.servlet-api&lt;/span&gt;&lt;/strong&gt;只是要获取http请求信息，别的都用不到。所以更合适使用线上稳定运行的版本&lt;strong&gt;&lt;span&gt;3.1.0&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;实例二 spring-boot版本&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们新项目中spring-boot的版本用的是2.3.2.&lt;span&gt;RELEASE。这个也高于目前项目中使用的2.1.*的版本。我也调研了一下官网。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7717502558853634&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9mx4E8rZzxHXAlN9gOAiaRzjBtOZaV0HNK7BL2AC0f2HteSfoYH0Nf70S20N4ztF56VQMqFhpEdtw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;977&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;2.1.x版本已经在19年停止维护，商业支持(商业支持是要收费的，但是如果发现重大bug问题会公开)也在21年初停止了。如果继续使用这个版本，一旦有问题，得不到官方支持，不建议使用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2.3.x也已经在去年停止维护，商业支持会支持到今年8月份。这表明2.3.x是一个很成熟的版本了。相比而言，虽然免费维护上已经不再支持，但是看下面：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7215909090909091&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9mx4E8rZzxHXAlN9gOAiaRzTVXmODgPoC6WRh5goXbUMPY7T6jNXTkNUspowYnibWicFRT2a5Eabl8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1056&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上面可以看到2.3.x的版本官方还是建议使用的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那在2.3.x中到底使用哪个版本呢？官网中GA(正式版本)建议的是2.3.12.RELEASE。先看一下，各个版本的变更主要变更了什么。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过调研，变更主要是两项：&lt;/p&gt;&lt;p&gt;1&amp;gt;bug修复&lt;/p&gt;&lt;p&gt;2&amp;gt;Spring Framework等框架的版本升级&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;bug修复&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1 itemprop=&quot;name&quot;&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1 itemprop=&quot;name&quot;&gt;Spring Boot 2.3.2 发布，解决 Too many open files 导致的应用宕机问题。&lt;/h1&gt;&lt;h1&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1&gt;Spring Boot 2.3.6 也是一个重要的fix bug版本&lt;/h1&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;修复配置元数据注解处理器可能会对布尔属性使用错误访问器的问题 #24058&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用 Tomcat 时，当 Spring Boot 的等价属性 (equivalent property) 没有设置，通过 javax.net.ssl 系统属性设置的密钥和信任存储密码会被 null 覆盖 #24052&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;@DataJpaTest无法将 H2 和 schema.sql 以及 spring.datasource.schema-username 一起使用 #24023&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;当 Quartz 数据源不是主要数据源时，JdbcStoreTypeConfiguration 会选择主要数据源的事务 #24014&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;修复 TestTypeExcludeFilter 没有实现其超类所需要的 hashCode 和 equals #24012&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;自动配置不应使用@PostConstruct，因为在没有依赖 jakarta-annotation-api 的情况下，它在 Java 11+ 上是被忽略的 #24009&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果配置文件包含一个隐藏的路径元素，则不再加载 #23983&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;当调用 spring-boot-loader 的 JarFileWrapper.stream() 时，出现 &quot;java.lang.IllegalStateException: zip file closed&quot; #23821&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;Spring Boot 2.3.9 BUG修复：&lt;/h1&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;在通过jOOQ ＃25279访问数据库之前，由Flyway或Liquibase执行的迁移可能尚未完成。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Hibernate的新的hibernate-micrometer模块的依赖性管理丢失了＃25277&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;DatabaseDriver无法正确检测到Amazon Redshift ＃25265&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果将bean定义为ConnectionFactory ＃25138，则缺少RabbitMQ指标&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用JPA延迟存储库时，子上下文的ContextRefreshedEvent可能导致死锁＃24966&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Spring Data Solr支持未标记为已弃用 ＃24942&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在MetricsClientHttpRequestInterceptor中记录指标时失败可能会干扰RestTemplate的主要行为＃24753&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;WebMvcTest和WebFluxTest忽略用户提供的Thymeleaf IDialect bean ＃24149&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Spring Framework等框架的版本升级&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们之前线上有用spring boot 2.1.x的版本，对应spring的5.1.x。spring boot 2.3.x的版本对应的主要是spring 5.2.x。看官网怎么说：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6683070866141733&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9mx4E8rZzxHXAlN9gOAiaRzOmKgFJV327Z2RtM0Ov2bzrM94dMPZPLImVS7u9VI0I1Hic7jN3qjyXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1016&quot;/&gt;&lt;/p&gt;&lt;p&gt;5.2.x版本这几年刚刚停止维护，商业维护还有近两年的时间。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7294921875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9mx4E8rZzxHXAlN9gOAiaRztnR2bxDc5yvsziay4huPCwdeDLva0GXbl5sGvEjObIoC2WKv0WhVW0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p&gt;官方推荐学习的正式版本除了最新版外，就是5.2.19.RELEASE。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;spring boot除了spring framework还有一个重要组成netty。官网有介绍2.3.12.RELEASE对应的netty版本是netty4。目前公司已经在推升级组件，其中就涉及netty使用的netty4，与公司要求相符。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.547378104875805&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9mx4E8rZzxHXAlN9gOAiaRzuTfyibcGS7BqZqwA9ibypw7sxnDQR7aTxoDJbQPjnibvWvVJzu0bbHLHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1087&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另外，我查了spring boot 2.3.x明确表示提供对jdk8及以上的支持，并且在jdk8上有全面的测试。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;建议采用 spring boot 2.3.12.RELEASE 版本。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因为2.3.x版本已经非常稳定，而2.3的小版本更新基本上都是在修复bug。而且修复的是linux交互、死锁等相对底层bug。其依赖版本也符合公司要求。&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6d828edbb2f1d67b99cc50ca0cd2ece1</guid>
<title>Apache Flink 2022 新年大礼包</title>
<link>https://toutiao.io/k/p0ew92i</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single js_wx_tap_highlight wx_tap_card&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left js_a11y_comma js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI0OTYwNTQ4Ng==&amp;amp;action=getalbum&amp;amp;album_id=1527102622220992512#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;1527102622220992512&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#Flink&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;50个&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot; aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_title&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p role=&quot;option&quot; aria-labelledby=&quot;js_a11y_reward_qr_word js_a11y_comma js_a11y_reward_qr_title js_a11y_reward_qr_money&quot; aria-describedby=&quot;js_a11y_reward_qr_tips &quot; class=&quot;reward_tips&quot; id=&quot;js_a11y_reward_qr_word&quot;&gt;觉得可以，打赏一元&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img alt=&quot;赞赏二维码&quot; class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_tips&quot; class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a33a2ff093fa43e0d255bd4a7d5a7d25</guid>
<title>非常哇塞的 ES读场景、写场景 性能优化指南！你值得拥有！</title>
<link>https://toutiao.io/k/5pjb28q</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;174&quot; data-backw=&quot;365&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4767123287671233&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/cvQbJDZsKLp6wejHtKTRbqqQyt0wMk9K1wNtuwRqQTJAPOJ1KiaqSeSRbIJRTicVicKpDKRndBodY2DBNN20tvWwA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;365&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原创：小姐姐味道（微信公众号ID：xjjdog），欢迎分享，转载请保留出处。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ES作为NoSQL数据库里非常重要的一员，使用越来越广泛。虽然它因为索引延迟的原因，数据在时效性上有一些缺陷，但其大容量、分布式的优秀设计，使得它在时效性要求并不是特别高的类实时搜索领域，能够大展身手。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据使用场景和用途，ES可以分为写入和读取两种典型的应用方式。比如ELKB，我们就需要额外关注它的&lt;code&gt;写优化&lt;/code&gt;；再比如从MySQL中同步数据到ES的宽表，我们就需要额外关注它的&lt;code&gt;读优化&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;废话不多说，我们直接show一下优化方法。如果你对ES的一些概念还不是很清楚，建议收藏本文慢慢看。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.写入优化&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日志属于写多读少的业务场景，对写入速度要求很高。拿我们其中一个集群来说，单集群日志量达到百TB，每秒钟日志写入量达到10W条。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据写入，主要有三个动作：flush、refresh和merge。通过调整它们的行为，即可在性能和数据可靠性之间进行权衡。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 translog异步化&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，ES需要写一份translog，它类似于MySQL中的redolog，为的是避免在断电的时候数据丢失。ES默认每次请求都进行一次flush，但对于日志来说，这没有必要，可以将这个过程改为异步的，刷盘间隔为60秒。参数如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;curl-H&lt;span&gt;&quot;Content-Type: application/json&quot;&lt;/span&gt;-XPUT&lt;span&gt;&#x27;http://localhost:9200/_all/_settings?preserve_existing=true&#x27;&lt;/span&gt;-d&lt;span&gt;&#x27;{&lt;br/&gt;  &quot;index.translog.durability&quot; : &quot;async&quot;,&lt;br/&gt;  &quot;index.translog.flush_threshold_size&quot; : &quot;512mb&quot;,&lt;br/&gt;  &quot;index.translog.sync_interval&quot; : &quot;60s&quot;&lt;br/&gt;}&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这可以说是最重要的一步优化了，对性能的影响最大，但在极端情况下会有丢失部分数据的可能。对于日志系统来说，是可以忍受的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 增加refresh间隔&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了写translog，ES还会将数据写入到一个缓冲区中。但是注意了！此时，缓冲区的内容是无法被搜索到的，它还需要写入到segment里面才可以，也就是刷新到lucence索引里面。这就是refresh动作，默认1秒。也就是你写入的数据，大概率1秒之后才会被搜索到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是为什么ES不是实时搜索系统的原因，它从数据写入到数据读出，一般是有一个合并过程的，有一定的时间差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过index.refresh_interval可以修改这个刷新间隔。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于日志系统来说，当然要把它调大一点啦。xjjdog这里调整到了120s，减少了这些落到segment的频率，I/O的压力自然会小，写入速度自然会快。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;curl-H&lt;span&gt;&quot;Content-Type: application/json&quot;&lt;/span&gt;-XPUT&lt;span&gt;&#x27;http://localhost:9200/_all/_settings?preserve_existing=true&#x27;&lt;/span&gt;-d&lt;span&gt;&#x27;{&lt;br/&gt;  &quot;index.refresh_interval&quot; : &quot;120s&quot;&lt;br/&gt;}&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3 merge&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;merge其实是lucene的机制，它主要是合并小的segment块，生成更大的segment，来提高检索的速度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因就是refresh过程会生成一大堆小segment文件，数据删除也会产生空间碎片。所以merge，通俗来讲就像是碎片整理进程。像postgresql等，也有vaccum进程在干同样的事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显而易见，这种整理操作，既浪费I/O，又浪费CPU。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的系统merge非常频繁，那么调整merge的块大小和频率，是一个比较好的方法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.读取优化&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 指定路由&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你向ES里写数据，那么它会为你设置一个离散的隐藏ID，落到哪个分片，是不一定的。如果你根据一个查询条件查询数据，你设置了6个shards的话，它要查询6次才行。如果能够在路由的时候就知道数据在哪个分片上，查询速度自然会上升，这就要求我们在构造数据的时候，人工指定路由规则。它的实际运行规则如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;shard = &lt;span&gt;hash&lt;/span&gt;(routing) % number_of_primary_shards&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，一个查询会变成这样。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;GET my-index-000001/_search&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;query&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;terms&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;_routing&quot;&lt;/span&gt;: [ &lt;span&gt;&quot;user1&quot;&lt;/span&gt; ] &lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，如果你的查询维度较多，又对数据的查询速度有非常高的有求，根据routing存放多份数据是一个比较好的选择。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 rollover冷热分离&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;rollover根据索引大小，文档数或使用期限自动过渡到新索引。当rollover触发后，将创建新索引，写别名将更新为指向新索引，所有后续更新都将写入新索引，比如&lt;code&gt;indexname-000001.&lt;/code&gt;这种模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从rollover这个名字可以看出来，它和Java的log日志有一定的相似之处，比如Log4j的RollingFileAppender。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当索引变的非常大，通常是几十GB，那它的查询效率将变的非常的低，索引重建的成本也较大。实际上，很多索引的数据在时间维度上有较为明显的规律，一些冷数据将很少被用到。这个时候，建立滚动索引将是一个比较好的办法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;滚动索引一般可以与索引模板结合使用，实现按一定条件自动创建索引，ES的官方文档有具体的_rollover建立方法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 使用BoolQuery替代TermQuery&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Bool查询现在包括四种子句，must、filter、should和must_not。Bool查询是true、false对比，而TermQuery是精确的字符串比对，所以如果需求相似，BoolQuery自然会快于TermQuery。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 将大查询拆成分段查询&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些业务的查询比较复杂，我们不得不拼接一张非常大的宽表放在ES中，这有两个比较明显的问题。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;宽表的数据往往需要从其他数据源中回查拼接而成，数据更新时对源库或者ES本身都有较大的压力&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务的查询JSON需要书写的非常复杂，查询效率未知，一次查询锁定的内存过高，无法进行深入优化&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，宽表不论在RDBMS中还是ES中，都会与复杂的查询语句有关，其锁定时间都较长，业务也不够灵活。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应对这种场景的策略，通常将复杂的数据查询，转移到业务代码的拼接上来。比如，将一段非常冗长的单条查询，拆分成循环遍历的100条小查询。所有的数据库都对较小的查询请求有较好的响应，其整体性能整体上将优于复杂的单条查询。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这对我们的ES索引建模能力和编码能力提出了挑战。毕竟，在ES层面，互不相关的几个索引，将作为整体为其他服务提供所谓的数据中台接口。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5 增加第一次索引的速度&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多业务的索引数据往往来自于MySQL等传统数据库，第一次索引往往是全量索引，后面才是增量索引。必要的时候，也会进行索引的重建，大量的数据灌入造成了ES的索引速度建立缓慢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了缓解这种情况，建议在创建索引的时候，把副本数量设置成1，即没有从副本。等所有数据索引完毕，再将副本数量增加到正常水平。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，数据能够快速索引，副本会在后台慢慢复制。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.通用优化&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，我们还可以针对ES做一些通用的优化。比如，使用监控接口或者trace工具，发现线程池有明显的瓶颈，则需要调整线程池的大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的优化项如下。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 线程池优化&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新版本对线程池的配置进行了优化，不需要配置复杂的search、bulk、index线程池。有需要配置下面几个就行了：thread_pool.get.size, thread_pool.write.size, thread_pool.listener.size, thread_pool.analyze.size。具体可观测_cat/thread_pool接口暴露的数据进行调整。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 物理冷热分离&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的rollover接口，我们可以实现索引滚动。但是如何将冷数据存放在比较慢但是便宜的节点上？如何将某些索引移动过去？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ES支持给节点打标签，具体方式是在elasticsearch.yml文件中增加一些属性。比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//热节点&lt;/span&gt;&lt;br/&gt;node.attr.temperature: hot &lt;br/&gt;&lt;span&gt;//冷节点&lt;/span&gt;&lt;br/&gt;node.attr.temperature: cold &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;节点有了冷热属性后，接下来就是指定数据的冷热属性，来设置和调整数据分布。ES提供了index shard filtering功能来实现索引的迁移。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，可以对索引也设置冷热属性。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;PUT hot_data_index/_settings&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;&quot;index.routing.allocation.require.temperature&quot;&lt;/span&gt;: &lt;span&gt;&quot;hot&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些索引将自动转移到冷设备上。我们可以写一些定时任务，通过_cat接口的数据，自动的完成这个转移过程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 多磁盘分散I/O&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，可以通过配置多块磁盘的方式，来分散I/O的压力，但容易会造成数据热点集中在单块磁盘上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ES支持在一台机器上配置多块磁盘，所以在存储规模上有更大的伸缩性。在配置文件中，配置path.data属性，即可挂载多块磁盘。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;path.data : /data1, /data2, /data3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得注意的是，如果你是在扩容，那么就需要配合reroute接口进行索引的重新分配。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 减少单条记录的大小&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lucene的索引建立过程，非常耗费CPU，可以减少倒排索引的数量来减少CPU的损耗。第一个优化就是减少字段的数量；第二个优化就是减少索引字段的数量。具体的操作，是将不需要搜索的字段，index属性设置为not_analyzed或者no。至于_source和_all，在实际调试中效果不大，不再赘述。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;End&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ES的使用越来越广泛，从ELKB到APM，从NoSQL到搜索引擎，ES在企业中的地位也越来越重要。本文通过分析ES写入和读取场景的优化，力求从原理到实践层面，助你为ES加速。希望你在使用ES时能够更加得心应手。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常，一个ES集群对配置的要求是较高的，尤其是APM等场景，甚至会占到PaaS平台的1/3资源甚至更多。ES提供了较多的配置选项，我们可以根据应用场景，调整ES的表现，使其更好的为我们服务。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;作者简介：&lt;strong&gt;小姐姐味道&lt;/strong&gt;  (xjjdog)，一个不允许程序员走弯路的公众号。聚焦基础架构和Linux。十年架构，日百亿流量，与你探讨高并发世界，给你不一样的味道。我的个人微信xjjdog0，欢迎添加好友，进一步交流。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e74c68ab5f1eaac8f8f0fdf20abaefe9</guid>
<title>厌倦了C++，CS&amp;amp;ML博士用Rust重写Python扩展，还总结了9条规则</title>
<link>https://toutiao.io/k/rkcg8fm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot; data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; data-style=&quot;white-space: normal; max-width: 100%; letter-spacing: 0.544px; text-size-adjust: auto; background-color: rgb(255, 255, 255); font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__0&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-id=&quot;85660&quot; data-custom=&quot;rgb(117, 117, 118)&quot; data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-id=&quot;85660&quot; data-custom=&quot;rgb(117, 117, 118)&quot; data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-top: 2em; padding-top: 0.5em; padding-bottom: 0.5em; max-width: 100%; border-style: solid none; text-decoration: inherit; border-top-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-top-width: 1px; border-bottom-width: 1px; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__1&quot;&gt;&lt;section&gt;&lt;span&gt;选自medium.com&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;作者：&lt;/strong&gt;&lt;strong&gt;Carl M. Kadie&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;机器之心编译&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;编辑：杜伟、陈萍&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;21&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;效果好不好，试一试就知道了。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;Python 是数据科学家最流行的编程语言之一，其内部集成了高质量分析库，包括 NumPy、SciPy、自然语言工具包等，这些库中的许多都是用 C 和 C++ 实现的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;然而，C 和 C++ 兼容性差，且本身不提供线程安全。有研究者开始转向 Rust，重写 C++ 扩展。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;拥有 CS 与机器学习博士学位的 Carl M. Kadie&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，通过更新 Python 中生物信息学软件包 Bed-Reader，为研究者带来了在 Rust 中编写 Python 扩展的九个规则。以下是原博客的主要内容。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一年前，我厌倦了我们软件包 Bed-Reader 的 C++ 扩展，我用 Rust 重写了它，令人高兴的是，得到的新扩展和 C/C++ 一样快，但具有更好的兼容性和安全性。一路走来，我学会了这九条规则，可以帮助你创建更好的扩展代码，这&lt;/span&gt;&lt;span&gt;&lt;strong&gt;九条规则&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;包括：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1. 创建一个包含 Rust 和 Python 项目的单独存储库&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. 使用 maturin &amp;amp; PyO3 在 Rust 中创建 Python-callable translator 函数&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3. 让 Rust translator 函数调用 nice Rust 函数&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4. 在 Python 中预分配内存&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;5. 将 nice Rust 错误处理翻译 nice Python 错误处理&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;6. 多线程与 Rayon 和 ndarray::parallel，返回任何错误&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;7. 允许用户控制并行线程数&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;8. 将 nice 动态类型 Python 函数翻译成 nice Rust 泛型函数&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;9. 创建 Rust 和 Python 测试&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其中，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;文中提到的 nice 这个词是指使用最佳实践和原生类型创建&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。换句话说：在代码顶部，编写 nice Python 代码；在中间，用 Rust 编写 translator 代码；在底部，编写 nice Rust 代码。结构如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.9965156794425087&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWibdJ4SwsBDZViaEIROvXlfV8ibdG0aoWfGyUE4YvcSFrhe5sUPqjpKagMavQ8eLs86thiaVMzyOBWibPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;287&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上述策略看似显而易见，但遵循它可能会很棘手。本文提供了有关如何遵循每条规则的实用建议和示例。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我在 Bed-Reader 进行了实验，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Bed-Reader 是一个 Python 包&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，用于读取和写入 PLINK Bed Files，这是一种在生物信息学中用于存储 DNA 数据的二进制格式。Bed 格式的文件可以达到 TB。Bed-Reader 让用户可以快速、随机地访问数据的子集。它在用户选择的 int8、float32 或 float64 中返回一个 NumPy 数组。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我希望 Bed-Reader 扩展代码具有以下特点：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;比 Python 快；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;兼容 NumPy；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以进行数据并行多线程处理；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;与执行数据并行多线程的所有其他包兼容；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;安全。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们最初的 C++ 扩展兼具速度快、与 NumPy 兼容，以及使用 OpenMP 进行数据并行多线程等特点。遗憾的是，OpenMP 运行时库 (Runtime library)，存在 Python 包兼容版本问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Rust 提供了 C++ 扩展带来的优势。除此之外，Rust 通过提供没有运行时库的数据并行多线程解决了运行时兼容性问题。此外，Rust 编译器还能保证线程安全。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在 Rust 中创建 Python 扩展需要许多设计决策。根据我使用 Bed-Reader 的经验，以下是我的使用规则。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;规则 1：创建一个包含 Rust 和 Python 项目的单独存储库&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下表显示了如何布局文件：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.43923240938166314&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWibdJ4SwsBDZViaEIROvXlfV8SfnRBXkw0QP94r8AtBribznIg6icGc4zmXRufPcg117TsyFDm5RRRdGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;469&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用 Rust 常用的‘cargo new’命令创建 Cargo.toml 和 src/lib.rs 文件。Python 没有 setup.py 文件。相反，Cargo.toml 包含 PyPi 包信息，例如包的名称、版本号、 README 文件的位置等。要在没有 setup.py 的情况下工作，pyproject.toml 必须包含：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[build-system]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;requires = [&quot;maturin==0.12.5&quot;]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;build-backend = &quot;maturin&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一般来说，Python 设置在 pyproject.toml 中（如果不是，则在 pytest.ini 等文件中）。Python 代码位于子文件夹 bed_reader 中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后，我们使用 GitHub 操作来构建、测试和准备部署。该脚本位于 .github/workflows/ci.yml 中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;规则 2：使用 maturin &amp;amp; PyO3&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;在 Rust 中&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;创建 Python-callable translator 函数&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Maturin 是一个 PyPi 包，可通过 PyO3 构建和发布 Python 扩展。PyO3 是一个 Rust crate，用于在 Rust 中编写 Python 扩展。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在 Cargo.toml 中，包含这些 Rust 依赖项：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[dependencies]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;thiserror = &quot;1.0.30&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ndarray-npy = { version = &quot;0.8.1&quot;, default-features = false }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;rayon = &quot;1.5.1&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;numpy = &quot;0.15.0&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ndarray = { version = &quot;0.15.4&quot;, features = [&quot;approx&quot;, &quot;rayon&quot;] }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pyo3 = { version = &quot;0.15.1&quot;, features = [&quot;extension-module&quot;] }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[dev-dependencies]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;temp_testdir = &quot;0.2.3&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在 src/lib.rs 底部，包含这两行：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;mod python_module;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;mod tests;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;规则 3：Rust translator 函数&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;调用 nice Rust 函数&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在 src/lib.rs 定义了 nice  Rust 函数，这些函数将完成包的核心工作。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;它们能够输入和输出标准 Rust 类型并尝试遵循 Rust 最佳实践。例如，对于 Bed-Reader 包， read_no_alloc 是一个 nice Rust 函数，用于从 PLINK Bed 文件读取和返回值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;然而，Python 不能直接调用这些函数。因此，在文件 src/python_module.rs 中定义 Python 可以调用的 Rust translator 函数，下面为 translator 函数示例：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;#[pyfn(m)]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;#[pyo3(name = &quot;read_f64&quot;)]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fn read_f64_py(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    _py: Python&amp;lt;&#x27;_&amp;gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    filename: &amp;amp;str,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    iid_count: usize,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    sid_count: usize,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    count_a1: bool,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    iid_index: &amp;amp;PyArray1&amp;lt;usize&amp;gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    sid_index: &amp;amp;PyArray1&amp;lt;usize&amp;gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    val: &amp;amp;PyArray2&amp;lt;f64&amp;gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    num_threads: usize,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;) -&amp;gt; Result&amp;lt;(), PyErr&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    let iid_index = iid_index.readonly();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    let sid_index = sid_index.readonly();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    let mut val = unsafe { val.as_array_mut() };&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    let ii = &amp;amp;iid_index.as_slice()?;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    let si = &amp;amp;sid_index.as_slice()?;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    create_pool(num_threads)?.install(|| {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        read_no_alloc(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            filename,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            iid_count,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            sid_count,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            count_a1,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            ii,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            si,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            f64::NAN,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &amp;amp;mut val,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    })?;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   Ok(())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;该函数将文件名、一些与文件大小相关的整数以及两个一维 NumPy 数组作为输入，这些数组指示要读取数据的哪个子集。该函数从文件中读取值并填充 val，这是一个预先分配的二维 NumPy 数组。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;注意&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;将 Python NumPy 1-D 数组转换为 Rust slices，通过：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;let iid_index = iid_index.readonly();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;let ii = &amp;amp;iid_index.as_slice()?;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;将 Python NumPy 2d 数组转换为 2-D Rust ndarray 对象，通过：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;let mut val = unsafe { val.as_array_mut() };&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;调用 read_no_alloc，这是 src/lib.rs 中一个 nice Rust 函数，它将完成核心工作。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;规则 4：在 Python 中预分配内存&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在 Python 中为结果预分配内存简化了 Rust 代码。在 Python 端，在 bed_reader/_open_bed.py 中，我们可以导入 Rust translator 函数：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-class&quot;&gt;.bed_reader&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[...]&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;read_f64&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[...]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;然后定义一个 nice Python 函数来分配内存、调用 Rust translator 函数并返回结果。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;read([...]):&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;[...]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;val&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;np.zeros((len(iid_index), len(sid_index)), order=order, dtype=dtype)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;[...]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;reader&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;read_f64&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;[...]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;reader(&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;str(self.filepath),&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;iid_count&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;self.iid_count,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;sid_count&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;self.sid_count,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;count_a1&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;self.count_A1,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;iid_index&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;iid_index,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;sid_index&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;sid_index,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;val&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;val,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;num_threads&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;num_threads,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;[...]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;val&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;规则 5：将 nice Rust 错误处理翻译 nice Python 错误处理&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了了解如何处理错误，让我们在 read_no_alloc（ src/lib.rs 中 nice Rust 函数）中跟踪两个可能的错误。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;示例错误 1：来自标准函数的错误。如果 Rust 的标准 File::open 函数找不到文件或无法打开文件， 在这种情况下，如下一行中的? 将导致函数返回一些 std::io::Error 值。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;let&lt;/span&gt; mut buf_reader = BufReader::&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt;(File::open(filename)?);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了定义一个可返回这些值的函数，我们可以给函数一个返回类型 Result&amp;lt;(), BedErrorPlus&amp;gt;。我们定义 BedErrorPlus 时要包含所有 std::io::Error，如下所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;use thiserror::Error;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/&lt;span class=&quot;code-snippet__regexp&quot;&gt;//&lt;/span&gt; BedErrorPlus enumerates all possible errors&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/&lt;span class=&quot;code-snippet__regexp&quot;&gt;//&lt;/span&gt; returned by this library.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/&lt;span class=&quot;code-snippet__regexp&quot;&gt;//&lt;/span&gt; Based on &lt;span class=&quot;code-snippet__symbol&quot;&gt;https:&lt;/span&gt;/&lt;span class=&quot;code-snippet__regexp&quot;&gt;/nick.groenen.me/posts&lt;/span&gt;&lt;span class=&quot;code-snippet__regexp&quot;&gt;/rust-error-handling/&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pub enum BedErrorPlus {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    IOError(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    BedError(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ThreadPoolError(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这是 nice Rust 错误处理，但 Python 不理解它。因此，在 src/python_module.rs 中，我们要进行翻译。首先，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;定义 translator 函数 read_f64_py 来返回 PyErr&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;；其次，实现了一个从 BedErrorPlus 到 PyErr 的转换器。转换器使用正确的错误消息创建正确的 Python 错误类（IOError、ValueError 或 IndexError）。如下所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;impl std::convert::From&amp;lt;BedErrorPlus&amp;gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; PyErr {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   fn from(err: BedErrorPlus) -&amp;gt; PyErr {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        match err {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            BedErrorPlus::IOError(_) =&amp;gt; PyIOError::new_err(err.to_string()),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            BedErrorPlus::ThreadPoolError(_) =&amp;gt; PyValueError::new_err(err.to_string()),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            BedErrorPlus::BedError(BedError::IidIndexTooBig(_))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            | BedErrorPlus::BedError(BedError::SidIndexTooBig(_))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            | BedErrorPlus::BedError(BedError::IndexMismatch(_, _, _, _))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            | BedErrorPlus::BedError(BedError::IndexesTooBigForFiles(_, _))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            | BedErrorPlus::BedError(BedError::SubsetMismatch(_, _, _, _)) =&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                PyIndexError::new_err(err.to_string())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            _ =&amp;gt; PyValueError::new_err(err.to_string()),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;示例错误 2：特定于函数的错误。如果 nice 函数 read_no_alloc 可以打开文件，但随后意识到文件格式错误怎么办？它应该引发一个自定义错误，如下所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (BED_FILE_MAGIC1 != bytes_vector[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;]) &lt;span class=&quot;code-snippet__params&quot;&gt;||&lt;/span&gt; (BED_FILE_MAGIC2 != bytes_vector[&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;]) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; Err(BedError::IllFormed(filename.to_string()).into());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;BedError::IllFormed 类型的自定义错误在 src/lib.rs 中定义：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;use thiserror::&lt;span class=&quot;code-snippet__built_in&quot;&gt;Error&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[...]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;#[derive(&lt;span class=&quot;code-snippet__built_in&quot;&gt;Error&lt;/span&gt;, Debug, Clone)]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pub &lt;span class=&quot;code-snippet__keyword&quot;&gt;enum&lt;/span&gt; BedError {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   #[error(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Ill-formed BED file. BED file header is incorrect or length is wrong.&#x27;{0}&#x27;&quot;&lt;/span&gt;)]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   IllFormed(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[...]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其余的错误处理与示例错误 1 中的相同。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后，对于 Rust 和 Python，标准错误和自定义错误的结果都属于带有信息性错误消息的特定错误类型。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;规则 6：多线程与 Rayon 和 ndarray::parallel，返回任何错误&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Rust Rayon crate 提供了简单且轻量级的数据并行多线程。ndarray::parallel 模块将 Rayon 应用于数组。通常的模式是跨一个或多个 2D 数组的列（或行）并行化。面对的一个挑战是从并行线程返回任何错误消息。我将重点介绍两种通过错误处理并行化数组操作的方法。以下两个示例都出现在 Bed-Reader 的 src/lib.rs 文件中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;方法 1：par_bridge().try_for_each&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Rayon 的 par_bridge 将顺序迭代器变成了并行迭代器。如果遇到错误，使用 try_for_each 方法可以尽快停止所有处理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个例子中，我们遍历了压缩（zip）在一起的两个 things：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;然后，按顺序读取二进制数据，但并行处理每一列的数据。我们停止了任何错误。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[... not shown, read bytes &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;code-snippet__type&quot;&gt;DNA&lt;/span&gt; location&#x27;s data ...]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;.&lt;span class=&quot;code-snippet__built_in&quot;&gt;zip&lt;/span&gt;(out_val.axis_iter_mut(nd::&lt;span class=&quot;code-snippet__type&quot;&gt;Axis&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;.par_bridge() &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;.try_for_each(|(bytes_vector_result, mut col)| {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    match bytes_vector_result {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__type&quot;&gt;Err&lt;/span&gt;(e) =&amp;gt; &lt;span class=&quot;code-snippet__type&quot;&gt;Err&lt;/span&gt;(e),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__type&quot;&gt;Ok&lt;/span&gt;(bytes_vector) =&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; out_iid_i &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;..out_iid_count {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              &lt;span class=&quot;code-snippet__keyword&quot;&gt;let&lt;/span&gt; in_iid_i = iid_index[out_iid_i];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              &lt;span class=&quot;code-snippet__keyword&quot;&gt;let&lt;/span&gt; i_div_4 = in_iid_i / &lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              &lt;span class=&quot;code-snippet__keyword&quot;&gt;let&lt;/span&gt; i_mod_4 = in_iid_i % &lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              &lt;span class=&quot;code-snippet__keyword&quot;&gt;let&lt;/span&gt; genotype_byte: u8 = (bytes_vector[i_div_4] &amp;gt;&amp;gt; (i_mod_4 * &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;)) &amp;amp; &lt;span class=&quot;code-snippet__number&quot;&gt;0x03&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              col[out_iid_i] = from_two_bits_to_value[genotype_byte &lt;span class=&quot;code-snippet__keyword&quot;&gt;as&lt;/span&gt; usize];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__type&quot;&gt;Ok&lt;/span&gt;(())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;})?;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;方法 2：par_azip!&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;ndarray 包的 par_azip！宏允许并行地通过一个或多个压缩在一起的数组或数组片段。在我看来，这非常具有可读性。但是，它不直接支持错误处理。因此，我们可以通过将任何错误保存到结果列表来添加错误处理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下面是一个效用函数的例子。完整的效用函数从三个计数和总和（count and sum）数组计算统计量（均值和方差），并且并行工作。如果在数据中发现错误，则将该错误记录在结果列表中。在完成所有处理之后，检查结果列表是否有错误。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[...]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;let&lt;/span&gt; mut result_list: Vec&amp;lt;Result&amp;lt;(), BedError&amp;gt;&amp;gt; = vec![Ok(()); sid_count];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;nd::par_azip!((mut stats_row &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; stats.axis_iter_mut(nd::Axis(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;)),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &amp;amp;n_observed &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; &amp;amp;n_observed_array,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &amp;amp;sum_s &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; &amp;amp;sum_s_array,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &amp;amp;sum2_s &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; &amp;amp;sum2_s_array,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     result_ptr &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; &amp;amp;mut result_list)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  [...some code not shown...]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;});&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;result_list.par_iter().try_for_each(|x| (*x).clone())?;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[...]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Rayon 和 ndarray::parallel 提供了许多其他不错的数据并行处理方法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;规则 7：允许用户控制并行线程数&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了更好地使用用户的其他代码，用户必须能够控制每个函数可以使用的并行线程数。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在下面这个 nice Python read 函数中，用户可以得到一个可选的 num_threadsargument。如果用户没有设置它，Python 会通过这个函数设置它：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;python&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;get_num_threads&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(num_threads=None)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; num_threads &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;None&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; num_threads&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;PST_NUM_THREADS&quot;&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; os.environ:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; int(os.environ[&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;PST_NUM_THREADS&quot;&lt;/span&gt;])&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;NUM_THREADS&quot;&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; os.environ:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; int(os.environ[&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;NUM_THREADS&quot;&lt;/span&gt;])&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;MKL_NUM_THREADS&quot;&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; os.environ:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; int(os.environ[&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;MKL_NUM_THREADS&quot;&lt;/span&gt;])&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; multiprocessing.cpu_count()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;接着在 Rust 端，我们可以定义 create_pool。这个辅助函数从 num_threads 构造一个 Rayon ThreadPool 对象。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pub fn create_pool(num_threads: usize) -&amp;gt; Result&amp;lt;rayon::ThreadPool, BedErrorPlus&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   match rayon::ThreadPoolBuilder::new()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .num_threads(num_threads)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      .build()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      Err(e) =&amp;gt; Err(e.into()),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      Ok(pool) =&amp;gt; Ok(pool),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后，在 Rust translator 函数 read_f64_py 中，我们从 create_pool(num_threads)?.install(...) 内部调用 read_no_alloc（很好的 Rust 函数）。这将所有 Rayon 函数限制为我们设置的 num_threads。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[&lt;span class=&quot;code-snippet__meta&quot;&gt;...&lt;/span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    create_pool(num_threads)?.install(|| {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        read_no_alloc(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            filename,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            [&lt;span class=&quot;code-snippet__meta&quot;&gt;...&lt;/span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     })?;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[&lt;span class=&quot;code-snippet__meta&quot;&gt;...&lt;/span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;规则 8：将 nice 动态类型 Python 函数翻译成 nice Rust 泛型函数&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;nice Python read 函数的用户可以指定返回的 NumPy 数组的 dtype（int8、float32 或 float64）。从这个选择中，该函数查找适当的 Rust translator 函数（read_i8(_py)、read_f32(_py) 或 read_f64(_py)），然后调用该函数。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;read(&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;[...]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;dtype&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;Optional[Union[type, str]] = &quot;float32&quot;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;[...]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;[...]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;dtype == np.int8:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;reader&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;read_i8&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;dtype == np.float64:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;reader&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;read_f64&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;dtype == np.float32:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;reader&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;read_f32&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;else&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;ValueError(&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;span class=&quot;code-snippet__meta&quot;&gt;f&quot;dtype&#x27;{val.dtype}&#x27;not&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;known, only&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;span class=&quot;code-snippet__meta&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&#x27;int8&#x27;, &#x27;float32&#x27;, and &#x27;float64&#x27; are allowed.&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__attr&quot;&gt;reader(&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;span class=&quot;code-snippet__attr&quot;&gt;str(self.filepath),&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;span class=&quot;code-snippet__attr&quot;&gt;[...]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__attr&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;三个 Rust translator 函数调用相同的 Rust 函数，即在 src/lib.rs 中定义的 read_no_alloc。以下是 translator 函数 read_64 (又称 read_64_py) 的相关部分：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;read_f64_py(&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;[...]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;val&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&amp;amp;PyArray2&amp;lt;f64&amp;gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;num_threads&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;usize,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__meta&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;-&amp;gt; Result&amp;lt;(), PyErr&amp;gt; {&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;[...]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;mut val = unsafe { val.as_array_mut() };&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;[...]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;read_no_alloc(&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;[...]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;f64&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;&gt;:NAN,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;&amp;amp;mut&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;val,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__attr&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__attr&quot;&gt;[...]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们在 src/lib.rs 中定义了 niceread_no_alloc 函数。也就是说，该函数适用于具有正确特征的任何类型的 TOut 。其代码的相关部分如下所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;read_no_alloc&amp;lt;TOut: Copy + Default + From&amp;lt;i8&amp;gt; + Debug + Sync + Send&amp;gt;(&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;filename&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&amp;amp;str,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;[...]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;missing_value&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;TOut,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;val&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&amp;amp;mut nd::ArrayViewMut2&amp;lt;&#x27;_, TOut&amp;gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;-&amp;gt; Result&amp;lt;(), BedErrorPlus&amp;gt; {&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;[...]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在 nice Python、translator Rust 和 nice Rust 中组织代码，可以让我们为 Python 用户提供动态类型的代码，同时仍能用 Rust 编写出漂亮的通用代码。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;规则 9：创建 Rust 和 Python 测试&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;你可能只想编写会调用 Rust 的 Python 测试。但是，你还应该编写 Rust 测试。添加 Rust 测试使你可以交互地运行测试和交互地调试。Rust 测试还为你以后得到 Rust 版本的包提供了途径。在示例项目中，两组测试都从  bed_reader/tests/data 读取测试文件。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在可行的情况下，我还建议编写函数的纯 Python 版本，然后就可以使用这些慢速 Python 函数来测试快速 Rust 函数的结果。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后，关于 CI 脚本，例如 bed-reader/ci.yml，应该同时运行 Rust 和 Python 测试。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;原文链接：https://towardsdatascience.com/nine-rules-for-writing-python-extensions-in-rust-d35ea3a4ec29&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;192&quot; data-ratio=&quot;1.77734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicr7bCQicQzg3uKibL9p92bbJcWxMG82TQR0GyDrlMkjhleEev5IJQLx1gbdicjTsZ0daJftAia1krUFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;© THE END &lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;转载请联系本公众号获得授权&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;投稿或寻求报道：content@jiqizhixin.com&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0ce73d20c979971e5169a88acb64b2dc</guid>
<title>Rust社区运营3周年总结</title>
<link>https://toutiao.io/k/iycyu2h</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>