<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>0f097d64e2670b3813365167f7bb43cf</guid>
<title>[推荐] 副业刚需：在 GitHub 上也能年入百万？</title>
<link>https://toutiao.io/k/r9tqaw3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编者荐语：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大家好，我是你们的朋友 耳东双月。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;108&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;转自：机器之心  （张倩、蛋酱）&lt;br/&gt;原文链接：https://calebporzio.com/i-just-hit-dollar-100000yr-on-github-sponsors-heres-how-i-did-it&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;如果提到靠打赏生活的人，我们首先想到的会是主播。但现实情况是，程序员也可以。这位活成主播的程序员名叫 Caleb Porzio。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;见过一个在职的朋友利用业余时间实现小程序矩阵，一个月大概赚了3000多，主要收入来自于小程序中插广告。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么问题来了，个人开发者如何通过小程序变现？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最简单、粗暴的就是做流量主，通过小程序中的插入的广告变现！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;门槛极低，变现难度对于个人开发者几乎没有!&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那些小程序工具抖音去水印、头像制作、星座类的，微信搜索指数就能看出来，有非常巨大的流量入口，垂直工具虽然使用频率不是非常高，但是流量大的“足以发挥想象”啊！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当然“发挥”才是重点！至于怎么发挥，对于程序员来说，流量入口是一定要有的。&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzMDAzMDIwMQ==&amp;amp;mid=2647848911&amp;amp;idx=1&amp;amp;sn=a56e484d8d5bd15a84f65e9948b7c151&amp;amp;chksm=f09ff9d9c7e870cf793e0e7c1a218fb11077ae56eb8b2c3e63caf2a13ba8d7f2d52ed26772d3&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;副业刚需，个人开发者如何通过小程序变现？已经有朋友变现月入4k了！&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Github打赏也能实现副业刚需？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在过去的一年里，他靠 GitHub 项目的打赏赚到了 10 万美元。在他的自述文章中，他分享了自己靠 GitHub 项目赚钱的经历和技巧。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.869684499314129&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;729&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicEm6GtRiaSurkfz9SCTvrQZdowyhHFq7Y2iabdj4argc21taADIyGbE9ZBjs2d2nuf4O68SCzhAxhA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Caleb Porzio 发推庆祝自己靠 GitHub 打赏（GitHub Sponsors）赚到了 10 万美元。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;GitHub Sponsors &lt;/span&gt;&lt;span&gt;是 GitHub 2019 年 5 月份推出的一个功能，允许&lt;/span&gt;&lt;span&gt;开发者通过自己的项目获取报酬/赞赏。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;全职开发转自由职业，是怎样一种体验？以下是 Caleb 的故事。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我要分享一下自己走上自由职业的经历。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2018 年是我做全职开发的最后一年，当时我的年收入大概是 9 万美元。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.30178173719376394&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;898&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicEm6GtRiaSurkfz9SCTvrQZd7uBPLRb6z5lIRPRNBjLrU7Uz5tbT59eJr6vcakbQQESjwGx0bD7UA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;嗯，虽然说现在开发人员的薪资水平比较疯狂，但 9 万美元对我来说也是一笔可观的收入了。再加上我妻子的收入，以及「胡子主义」生活哲学的指导，我们可以省下很多的钱。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2019 年 1 月 11 日，我离开原来的公司开始「休假」，想要换种心情，做自己想做的一切。几个月后，我正式开始了自由职业者的生活。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;「休假」期间，我读到了这篇文章：《Phoenix LiveView: Interactive, Real-Time Apps. No Need to Write JavaScript》，并从中受到启发。我发现自己也可以做出类似的成果。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当时我还发了一条推特：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9406919275123559&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1214&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicEm6GtRiaSurkfz9SCTvrQZM1SiaYoMFxttYbc8nE0BBxuTWic5WmZJ1F2mUmoxY6kvqVzk2DUtkAHA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;「决定开发一个类似 Laravel 的东西。我感觉这可能是个重大改变。」&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在看来，这确实改变了我的生活。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;也是在这一天，我的「休假期」结束了。我完全被这个后来叫做 Livewire 的项目迷住了，并开始全身心地投入于此，这种沉迷一直持续到现在。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我也创建了一个非常流行的 JS 框架，叫做 AlpineJS，目前也是由我在管理和维护。但那是另外一个故事了……&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;做开源软件不能完全养活自己，所以我也接过一些小型的代码指导方面的需求，让 2019 全年的收入维持在一个稳定的状态。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这张图是我 2019 年通过自由职业方式获得的收入：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2609375&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicEm6GtRiaSurkfz9SCTvrQZ260lnByypxYBg3tVa32QH9Iia10RKTtTia5EmlT9VCgU0fm9HAKoWDmQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我的收入减少了 7 万美元，看起来是比较冒险的举动。但我知道，如果此刻不开始做这件事，以后可能就更没有机会了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一路走来，有很多好心人联系我，询问他们是否能够提供项目上的帮助。比如这种：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1359375&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicEm6GtRiaSurkfz9SCTvrQZSzJHCKtlcibUWde9KEa54oChhibVyjJ8yB44ibhrtID3gJyicaDBicDdOgw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;很长一段时间我没有更新 Patreon（一个众筹创作网站），那里会有一些人每个月给我五美元。如此也很好，但对我来说没有意义。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;然后，我发现了 GitHub 的打赏功能，把项目直接托管在 GitHub 上即可。2019 年 12 月 12 日，我成为了 GitHub Sponsors 的一员。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.33578431372549017&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;816&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicEm6GtRiaSurkfz9SCTvrQZ6ekKlFpt5pfmiaUTm8JFB3LtF83wLlwLeDqStKn5P8SGXiadhrdDN1jw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;这是我的第一个打赏者，Brian，谢谢你！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;迄今为止，我已经从 GitHub sponsors 那里收到了 2.5 万美元打赏金。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.39296875&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicEm6GtRiaSurkfz9SCTvrQZZeo77Ek5f4XSeIuRXa00RYbiayBYRYdUwSW2zRp5RIH5VCZJWBUErQw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;直到撰写本文时，我的 GitHub 年度打赏金额已经达到了 112680 美元。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicEm6GtRiaSurkfz9SCTvrQZcyFGh16Pq69z325bGxLUohaYazlHIB8oPRUfoKRkuRSAVUJhSfj8hQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;是运气，还是实力？我有点不敢相信我在开源社区里做开源软件，赚的钱比以往任何时候都多。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;掐我一下，我是在做梦吗？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;是因为我开发的软件太过优秀？让 535 位开发者每个月都打赏我 14 美元。不管怎么说，继续努力吧！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;接下来，我想分享一些过程中的经验，希望能帮到也想从事类似开发工作的人们。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;通过 GitHub 打赏赚钱的三个阶段&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;阶段 1：热心人士&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最初，GitHub Sponsors 是一个让忠实粉丝能够资助他们所支持项目的平台。这些人的数量，和真正使用软件以及从中赚钱的人数比起来，并不算多。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基于开源的前提，人们本来就可以免费获得该软件。所有收入完全是来自那些友善热心肠的人们。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.61015625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicEm6GtRiaSurkfz9SCTvrQZaWONl7ibEtZBuFeKhiaT2uT3NYhxxgWXy2Tqo89AO5UEwYV3rOpvWUKA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先，非常感谢这些人。然后我们谈谈第一个高峰是怎么到来的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;阶段 2：打赏软件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个阶段，事情开始变得奇妙。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8366666666666667&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicEm6GtRiaSurkfz9SCTvrQZ1aVAUn2V9fGuFdYMjannEiaC79OxniagHePWYqrSdPJ1GfPia7BwFQGDQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当时，我和我的兄弟 Daniel 录制了一期《No Plans To Merge》。在思考如何将其变现时，我们想到了一个新颖的想法：「打赏软件」。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;它的工作方式如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;创建一个很棒的软件；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;使其仅对打赏者开放，直到你积累了一定数量的打赏者；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;然后将项目开源给全世界。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这是一种双赢。效果很好，几天之内我的收入就增加了 1.1 万美元。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.61015625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicEm6GtRiaSurkfz9SCTvrQZGvjVHI08mZEXGpCg9XEDCXYLZCsc1JSibXN3dzKHL72IegVlFUV15zA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我另外一位朋友 Nuno Maduro 最近在他的 Pest 项目中复制了这一方法，同样取得了成功：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.77&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicEm6GtRiaSurkfz9SCTvrQZRsJNH4Ptg5kEXBcMHrae95bQ1OicMPiaWqYTRQpJXC5TTyss0Eo2xic5Q/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这种方法很棒，但是需要不断地提供新的想法，所有的这些都将成为我必须持续进行的项目。长远来看，我需要更合理的东西。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;阶段 3：教学视频&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我得到的大部分打赏金都是这个阶段来的：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.61015625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicEm6GtRiaSurkfz9SCTvrQZElf7XRHmbbRXPoibCicd1yDzS48nXn06ovJ8LLTTk1cjjDJnYdibHI3Sg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里边有什么秘诀吗？答案是：录制教学视频。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;构建有用的软件是一回事，但教别人怎么用完全是另一回事。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我尽力创建高质量的文档，但总有人需要更加高级的内容。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了满足这些需求，我录了一系列教学视频。在这之后的三个月里，我的总收入从 4 万美元涨到了 10 万美元以上。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9016666666666666&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicEm6GtRiaSurkfz9SCTvrQZCXfrbpMoHIJHfV0YINCxibX1Dh1fnB3n9hmH3Kfdia1k9moL3mNPSg9A/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我在文档的适当位置嵌入了这些视频的链接，以帮助大家找到它们：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.25625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicEm6GtRiaSurkfz9SCTvrQZZM7hvBBEM2mQFAdI5VKofBlfxZQ6xTHMxMuJI4H6Bxj73oSp6xydPA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;几个星期之后，我又为 GitHub 打赏者专门建立了一个「私有」的视频小组：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5265625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicEm6GtRiaSurkfz9SCTvrQZUib5ewwCrCr5unMsbYxdwbJt6DFP3VkoRbLRfXl2r3ALpgAC2Fbw9Jw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这就是我的秘诀（为了做到以上这些，我利用 GitHub 认证构建了一个 Laravel app 来调用 GitHub API，以验证用户是否为打赏者）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在，那些看免费视频的人自然会遇到这些「私有」视频，如果他们喜欢前面那些免费的内容，他们就会给我打赏来获取后面的视频。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;每次有新特性出现，我都会放出一批新视频。此外，我还会给每位打赏者提供访问每节课源代码的入口。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在 90 天的时间里，我的年收入增长了大约 8 万美元。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在我有了连续的收入，不用再将所有时间都花在课程发布上了。我将用空出来的时间继续开发这个软件，同时放出新的视频。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;如何通过&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;打赏赚更多钱？&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;实力是第一位的&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;要做到靠打赏谋生，首先离不开日益月累的磨练，你做的东西要真正有用才行。我把我所有的一切都投入到工作中，这点没有捷径。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;你可以发现，我在一个开源项目中全职工作了整整一年才看到收入。能得到人们赞助的工作必须是高质量的，而且始终是排在第一位的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;积极寻找用户&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;你可以在网上创建优秀的工具，但如果没有人关注，再出色的工具也无法为你带来收入。因此，找到用户是赚钱的关键。在这方面，你的 Twitter 粉丝和邮件订阅者都是潜在的挖掘对象。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;打赏金额设置不要太保守&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;很多 GitHub 开发者犯的最大的一个错误就是在初级打赏设置中写的钱数太少。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果打赏者能选 1-5 美元 / 月，谁还会选更高的打赏金额。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我很早就意识到，如果我真的想做这件事，只有 5 美元的打赏肯定是不够的，所以我后来涨到了 14 美元。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;给打赏等级取一个好名字&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在给打赏等级取名的时候，记得取一个能描述打赏者类型的恰当名字。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;举个例子，对于一个高级打赏等级来说，它的标签应该是「The Agency（代理）」或其他能够暗示一个公司应该给予高级打赏的标签，而不是「Platinum（白金）」这种模糊的说法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这样一来，人们看到这个标签首先想到的会是：「我的用途到底属于哪一类」，而不是：「我每个月要花多少钱」。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;不要羞于谈钱&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在我的成长过程中，我一直认为谈钱是不礼貌的，但其实这是一个谎言。有一次，我一股脑涨了 1 万美元，因为一个合作者告诉我他们都赚多少钱。在得知他们的收入情况后，我对自己的要价感到心安理得。但如果他们不告诉我这个情况，什么都不会发生。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;透明是一个健康的现象。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我不会隐瞒自己的收入，因为别人也不对我隐瞒他们的收入，这让我从中获利。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;即使他们赚的比我多得多，我也不会感到心痛或想分一杯羹。相反，我只会感到激动和鼓舞。我希望其他人也能保持这种心态。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;直接告诉别人你完全依赖这笔钱生活也没什么不礼貌的，而且这笔钱帮你打造出了人们每天都在用且从中受益的软件。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;不要因为赚了很多钱而感到内疚&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我一直都在提醒自己，我不是一个开发者布道师。如果我的打赏收入超过了平均生活水准，那也不错。我经营的也不是非营利组织。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我的收入和我的软件所带给别人的价值成正比，这没什么问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我做的不是什么神圣的工作，那些软件是企业拿来赚钱的，他们从中牟利，所以我从中赚钱也是 OK 的。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;网友：我也能这么做吗？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Caleb Porzio 的这份经历也引起了许多开发者的关注，讨论最热烈的问题是：在我的国家或者地区，这个方法行得通吗？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3270300333704116&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;899&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicEm6GtRiaSurkfz9SCTvrQZkpRBhHicKQPEIDHibUIiaVaE6ic79PZlvl1nVwUYEwjkYicBmTnV4G0o6Zw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;「看到这些，我为自己国家芬兰的法律而感到难过。我们有一项名为筹款法的法律，其中规定，要想收取捐款（即无任何回报的支付）必须获得许可。这个许可证是付费的，而且不发给个人，只授予非营利活动。」&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这就意味着，如果你在软件项目上看到捐赠按钮，并且该笔资金流向芬兰人，这个过程是违法的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以这位芬兰的开发者表示，他自己托管了一个免费项目，为此不得不成立一家公司（独资经营）并出售一些其他的东西，以便从服务中获利。即便人们有捐赠的意愿，他也不能「合法地」接受这些钱。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3311036789297659&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;598&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicEm6GtRiaSurkfz9SCTvrQZIZw0NtCDqXqKDOyqoXuj3ugYg9iaGTHGgdWOmJD4J36AHBibzXI4bibzw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;有人表示，在大多数西方国家都有类似的规定。因此，对于这些国家的人来说，自由职业虽然「自由」，但也同样需要花费更多的精力去管理琐事。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.453125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;448&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicEm6GtRiaSurkfz9SCTvrQZZo8RStXqNuMSyoO54shJ9z2U7ZQsAvAG1rrXtLISSiaicrRSCOGQAv9Q/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但在美国，这种做法的门槛要低得多。「如果是在美国的话，你可以作为个人接受无偿礼品，也可以作为个体经营者接受营业收入，无需额外注册什么。与往常一样，你需要精确缴纳税费，包括预扣税。」&lt;/span&gt;&lt;/section&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;img data-copyright=&quot;0&quot; data-ratio=&quot;0.12232415902140673&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;981&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/eG8xOx80VBYiaJhD1vUfQVK5y8qBXic4l1O1ticfN6IicXyf73hRGQsOjxVCw7hUGmibjKOtGtADZiawF5sT4RKWSExg/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span data-raw-text=&quot;回&quot; data-textnode-index=&quot;45&quot; data-index=&quot;822&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;回&quot; data-textnode-index=&quot;31&quot; data-index=&quot;639&quot; class=&quot;character&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;回复&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;【关闭】&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span data-raw-text=&quot;】&quot; data-textnode-index=&quot;47&quot; data-index=&quot;828&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;】&quot; data-textnode-index=&quot;37&quot; data-index=&quot;645&quot; class=&quot;character&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span data-raw-text=&quot;学&quot; data-textnode-index=&quot;48&quot; data-index=&quot;829&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;学&quot; data-textnode-index=&quot;38&quot; data-index=&quot;646&quot; class=&quot;character&quot;&gt;学&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;关&quot; data-textnode-index=&quot;48&quot; data-index=&quot;830&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;关&quot; data-textnode-index=&quot;39&quot; data-index=&quot;647&quot; class=&quot;character&quot;&gt;关&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;闭&quot; data-textnode-index=&quot;48&quot; data-index=&quot;831&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;闭&quot; data-textnode-index=&quot;40&quot; data-index=&quot;648&quot; class=&quot;character&quot;&gt;闭&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;微&quot; data-textnode-index=&quot;48&quot; data-index=&quot;832&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;微&quot; data-textnode-index=&quot;41&quot; data-index=&quot;649&quot; class=&quot;character&quot;&gt;微&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;信&quot; data-textnode-index=&quot;48&quot; data-index=&quot;833&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;信&quot; data-textnode-index=&quot;42&quot; data-index=&quot;650&quot; class=&quot;character&quot;&gt;信&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;朋&quot; data-textnode-index=&quot;48&quot; data-index=&quot;834&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;朋&quot; data-textnode-index=&quot;43&quot; data-index=&quot;651&quot; class=&quot;character&quot;&gt;朋&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;友&quot; data-textnode-index=&quot;48&quot; data-index=&quot;835&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;友&quot; data-textnode-index=&quot;44&quot; data-index=&quot;652&quot; class=&quot;character&quot;&gt;友&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;圈&quot; data-textnode-index=&quot;48&quot; data-index=&quot;836&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;圈&quot; data-textnode-index=&quot;45&quot; data-index=&quot;653&quot; class=&quot;character&quot;&gt;圈&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;广&quot; data-textnode-index=&quot;48&quot; data-index=&quot;837&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;广&quot; data-textnode-index=&quot;46&quot; data-index=&quot;654&quot; class=&quot;character&quot;&gt;广&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;告&quot; data-textnode-index=&quot;48&quot; data-index=&quot;838&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;告&quot; data-textnode-index=&quot;47&quot; data-index=&quot;655&quot; class=&quot;character&quot;&gt;告&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span data-raw-text=&quot;告&quot; data-textnode-index=&quot;48&quot; data-index=&quot;838&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;告&quot; data-textnode-index=&quot;47&quot; data-index=&quot;655&quot; class=&quot;character&quot;&gt;&lt;span&gt;&lt;span data-raw-text=&quot;关&quot; data-textnode-index=&quot;48&quot; data-index=&quot;830&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;关&quot; data-textnode-index=&quot;39&quot; data-index=&quot;647&quot; class=&quot;character&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span data-raw-text=&quot;回&quot; data-textnode-index=&quot;45&quot; data-index=&quot;822&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;回&quot; data-textnode-index=&quot;31&quot; data-index=&quot;639&quot; class=&quot;character&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;回复&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;【实战】&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span data-raw-text=&quot;】&quot; data-textnode-index=&quot;47&quot; data-index=&quot;828&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;】&quot; data-textnode-index=&quot;37&quot; data-index=&quot;645&quot; class=&quot;character&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;获取20套实战源码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span data-raw-text=&quot;回&quot; data-textnode-index=&quot;49&quot; data-index=&quot;839&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;回&quot; data-textnode-index=&quot;48&quot; data-index=&quot;656&quot; class=&quot;character&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;回复&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;【被删】&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span data-raw-text=&quot;】&quot; data-textnode-index=&quot;51&quot; data-index=&quot;845&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;】&quot; data-textnode-index=&quot;54&quot; data-index=&quot;662&quot; class=&quot;character&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span data-raw-text=&quot;学&quot; data-textnode-index=&quot;52&quot; data-index=&quot;846&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;学&quot; data-textnode-index=&quot;55&quot; data-index=&quot;663&quot; class=&quot;character&quot;&gt;学&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;查&quot; data-textnode-index=&quot;52&quot; data-index=&quot;847&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;查&quot; data-textnode-index=&quot;56&quot; data-index=&quot;664&quot; class=&quot;character&quot;&gt;查&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;看&quot; data-textnode-index=&quot;52&quot; data-index=&quot;848&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;看&quot; data-textnode-index=&quot;57&quot; data-index=&quot;665&quot; class=&quot;character&quot;&gt;看&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;你&quot; data-textnode-index=&quot;52&quot; data-index=&quot;849&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;你&quot; data-textnode-index=&quot;58&quot; data-index=&quot;666&quot; class=&quot;character&quot;&gt;你&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;哪&quot; data-textnode-index=&quot;52&quot; data-index=&quot;850&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;哪&quot; data-textnode-index=&quot;59&quot; data-index=&quot;667&quot; class=&quot;character&quot;&gt;哪&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;个&quot; data-textnode-index=&quot;52&quot; data-index=&quot;851&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;个&quot; data-textnode-index=&quot;60&quot; data-index=&quot;668&quot; class=&quot;character&quot;&gt;个&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;好&quot; data-textnode-index=&quot;52&quot; data-index=&quot;852&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;好&quot; data-textnode-index=&quot;61&quot; data-index=&quot;669&quot; class=&quot;character&quot;&gt;好&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;友&quot; data-textnode-index=&quot;52&quot; data-index=&quot;853&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;友&quot; data-textnode-index=&quot;62&quot; data-index=&quot;670&quot; class=&quot;character&quot;&gt;友&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;删&quot; data-textnode-index=&quot;52&quot; data-index=&quot;854&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;删&quot; data-textnode-index=&quot;63&quot; data-index=&quot;671&quot; class=&quot;character&quot;&gt;删&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;除&quot; data-textnode-index=&quot;52&quot; data-index=&quot;855&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;除&quot; data-textnode-index=&quot;64&quot; data-index=&quot;672&quot; class=&quot;character&quot;&gt;除&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;了&quot; data-textnode-index=&quot;52&quot; data-index=&quot;856&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;了&quot; data-textnode-index=&quot;65&quot; data-index=&quot;673&quot; class=&quot;character&quot;&gt;了&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;你&quot; data-textnode-index=&quot;52&quot; data-index=&quot;857&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;你&quot; data-textnode-index=&quot;66&quot; data-index=&quot;674&quot; class=&quot;character&quot;&gt;你&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;巧&quot; data-textnode-index=&quot;52&quot; data-index=&quot;858&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;巧&quot; data-textnode-index=&quot;67&quot; data-index=&quot;675&quot; class=&quot;character&quot;&gt;巧&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span data-raw-text=&quot;包&quot; data-textnode-index=&quot;60&quot; data-index=&quot;894&quot; class=&quot;character&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span data-raw-text=&quot;回&quot; data-textnode-index=&quot;57&quot; data-index=&quot;878&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;回&quot; data-textnode-index=&quot;104&quot; data-index=&quot;712&quot; class=&quot;character&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;回复&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;【访客】&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span data-raw-text=&quot;】&quot; data-textnode-index=&quot;59&quot; data-index=&quot;884&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;】&quot; data-textnode-index=&quot;109&quot; data-index=&quot;718&quot; class=&quot;character&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span data-raw-text=&quot;学&quot; data-textnode-index=&quot;60&quot; data-index=&quot;885&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;学&quot; data-textnode-index=&quot;110&quot; data-index=&quot;719&quot; class=&quot;character&quot;&gt;学&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;微&quot; data-textnode-index=&quot;60&quot; data-index=&quot;887&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;微&quot; data-textnode-index=&quot;111&quot; data-index=&quot;720&quot; class=&quot;character&quot;&gt;微&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;信&quot; data-textnode-index=&quot;60&quot; data-index=&quot;888&quot; class=&quot;character&quot;&gt;&lt;span data-raw-text=&quot;信&quot; data-textnode-index=&quot;112&quot; data-index=&quot;721&quot; class=&quot;character&quot;&gt;信&lt;/span&gt;&lt;span data-raw-text=&quot;查&quot; data-textnode-index=&quot;112&quot; data-index=&quot;722&quot; class=&quot;character&quot;&gt;查&lt;/span&gt;&lt;span data-raw-text=&quot;看&quot; data-textnode-index=&quot;112&quot; data-index=&quot;723&quot; class=&quot;character&quot;&gt;看&lt;/span&gt;&lt;span data-raw-text=&quot;朋&quot; data-textnode-index=&quot;112&quot; data-index=&quot;724&quot; class=&quot;character&quot;&gt;朋&lt;/span&gt;&lt;span data-raw-text=&quot;友&quot; data-textnode-index=&quot;112&quot; data-index=&quot;725&quot; class=&quot;character&quot;&gt;友&lt;/span&gt;&lt;span data-raw-text=&quot;圈&quot; data-textnode-index=&quot;112&quot; data-index=&quot;726&quot; class=&quot;character&quot;&gt;圈&lt;/span&gt;&lt;span data-raw-text=&quot;访&quot; data-textnode-index=&quot;112&quot; data-index=&quot;727&quot; class=&quot;character&quot;&gt;访&lt;/span&gt;&lt;span data-raw-text=&quot;客&quot; data-textnode-index=&quot;112&quot; data-index=&quot;728&quot; class=&quot;character&quot;&gt;客&lt;/span&gt;&lt;span data-raw-text=&quot;记&quot; data-textnode-index=&quot;112&quot; data-index=&quot;729&quot; class=&quot;character&quot;&gt;记&lt;/span&gt;&lt;span data-raw-text=&quot;录&quot; data-textnode-index=&quot;112&quot; data-index=&quot;730&quot; class=&quot;character&quot;&gt;录&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;回复&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;【小程序】&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;学获取15套【入门+实战+赚钱】小程序源码&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;回复&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;【python】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;学微获取全套0基础Python知识手册&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;回复&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;【2019】&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;获取2019 .NET 开发者峰会资料PPT&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;回复&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;【加群】加入dotnet微信交流群&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend-list&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend&quot; data-recommend-article-type=&quot;normal&quot; data-recomment-template-id=&quot;1&quot; data-recommend-article-id=&quot;2649759837_1&quot; data-recommend-article-time=&quot;1614089250&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/sz_mmbiz_jpg/TZMx5vHDhKqebJOTCu6TFdnLCjSAGnsh69aibTOs2icrdkdYicwnvCQV7MYQtVjdGEwJavCIqsgOwJObdWcNico9qw/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;@程序员，这笔钱下个月可以领！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjIwNzQ5Mw==&amp;amp;mid=2649759837&amp;amp;idx=1&amp;amp;sn=a2d65aa80773249bfcb1bc2ec9e2fcb5&amp;amp;chksm=8f8819b7b8ff90a1de965aeccd3e4f9e759de34aca17afb34ca8df62585de3e5fe0387081c13#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjIwNzQ5Mw==&amp;amp;mid=2649759837&amp;amp;idx=1&amp;amp;sn=a2d65aa80773249bfcb1bc2ec9e2fcb5&amp;amp;chksm=8f8819b7b8ff90a1de965aeccd3e4f9e759de34aca17afb34ca8df62585de3e5fe0387081c13&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;section data-recommend-type=&quot;normal&quot; data-recommend-tid=&quot;1&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-ratio=&quot;0.425&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/TZMx5vHDhKqebJOTCu6TFdnLCjSAGnsh69aibTOs2icrdkdYicwnvCQV7MYQtVjdGEwJavCIqsgOwJObdWcNico9qw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;@程序员，这笔钱下个月可以领！&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;br/&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend&quot; data-recommend-article-type=&quot;normal&quot; data-recomment-template-id=&quot;1&quot; data-recommend-article-id=&quot;2649759863_1&quot; data-recommend-article-time=&quot;1614173224&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/rbiaHnT7CcvzS9n04VKndkxt6lKhGuSU0WsQfz16Egia45AK63nS33AKZfGDl64xVjJUA4TKqOw9QbxGKBQB6r2w/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;一个程序员的水平能差到什么程度......&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjIwNzQ5Mw==&amp;amp;mid=2649759863&amp;amp;idx=1&amp;amp;sn=9ffd2741e5719fa00a13883480ba52bc&amp;amp;chksm=8f88199db8ff908b63dddc2087a29e769ff86b5d39f11f3651b81f84cb92f949e4bfe0f7862c#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjIwNzQ5Mw==&amp;amp;mid=2649759863&amp;amp;idx=1&amp;amp;sn=9ffd2741e5719fa00a13883480ba52bc&amp;amp;chksm=8f88199db8ff908b63dddc2087a29e769ff86b5d39f11f3651b81f84cb92f949e4bfe0f7862c&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;section data-recommend-type=&quot;normal&quot; data-recommend-tid=&quot;1&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-ratio=&quot;0.4263803680981595&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/rbiaHnT7CcvzS9n04VKndkxt6lKhGuSU0WsQfz16Egia45AK63nS33AKZfGDl64xVjJUA4TKqOw9QbxGKBQB6r2w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;326&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;一个程序员的水平能差到什么程度......&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dd7bd7e4dc8290a8449aa668f55836bd</guid>
<title>[推荐] 做一个很出色的程序员</title>
<link>https://toutiao.io/k/g6xlwp2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;架构师大刘的故事，断更有一段日子了，别着急，今天我们续上：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今年春节大刘响应国家号召，过年没有回老家。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;春节假期里，大刘约了许久不见的、同样也没回老家的小马吃了顿饭。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小马是大刘以前的同事，比大刘小好几岁。小马刚毕业的时候，去了大刘所在的公司，正好进了大刘所在的项目。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当时的小马基本上啥也不会，大刘很是带了他一段时间。小马这人聪明、又努力，进步非常快，后来，小马换了公司，职业生涯一路高飞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小马一直认为大刘对他很好，很照顾他。其实，他不知道，是因为小马本身的出色，让大刘和他搭档非常愉快，这才是大刘非常愿意和他一起做事情的原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;饭桌上，大刘和小马谈了许久，也谈到了一些他们那些曾经的同事。其中，有些同事特别优秀，他们和小马一样，年纪轻轻已经成为了极其出色的程序员，在行业中，也获得了很多的物质报酬和名誉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这次饭桌聊天中，大刘和小马一起总结了这些程序员共同共性。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 拥有旺盛的好奇心，并能转化为求知欲&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;拥有好奇心，就意味着你可能会建立求知欲。&lt;br/&gt; ——大刘&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好奇心是什么东西？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;其实就是人的一种想要探索未知的短暂行为。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有很多程序员或者在工作中偶然碰到了一些新概念，或者自己业余主动探索了一些新概念。然后，觉得这些东西很好玩儿，就兴起了探索的欲望，这玩意儿就是好奇心。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但大刘也见过不少程序员，尤其是年纪大点的，那见了新概念和新技术，就跟给媳妇交公粮一样，避之唯恐不及。这对吗？这不对。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，年轻程序员的好奇心，它就跟围棋建立了先手优势一样，可以不讲武德，有了直线超车老同志的资本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可是，只有好奇心还不够。好奇心这玩意儿就跟普通人看明星八卦一样，是个人有兴趣了，都能追追，没啥门槛。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;有门槛的是什么？求知欲。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这可厉害了，就像普通人追明星八卦觉得不够，于是变身成为狗仔队，直接干成了职业的。狗仔队要追明星隐私很辛苦的，上山爬树，装电线杆子，啥都得干。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;求知欲就类似这种，你得把好奇心转化成一种稳定的认知欲望，需要坚持不懈，需要付出辛苦，这就是门槛。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大刘原来就有个同事，不知道从哪里知道了 go 语言，那时候，go 语言刚出来不久，连个成熟的编辑器也没有。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大刘这同事，人家就有那种好奇心，先去搜了搜概念，然后又研究了下 go 语言的技术文档。顿时，他觉得 go 很有前途，好奇心就变成了求知欲，一路跟着 go 成长。工作中，也是想办法用 go 做点小项目，小工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;得，短短三四年，人家就成了 go 语言领域的大牛，出书，讲座不断。这就是好奇心转化成求知欲的好处。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了好奇心，你可能就有了一个进入新的技术蓝海的机会，而有了求知欲，就意味着你可能有了在蓝海建立自己的话语权的资格。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，大刘的那些后来发展的非常好的前同事们，大多数人都拥有这种鲜明的共性，这个共性，让你的职业生涯很可能将会拥有别人没有的先发优势。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. 勇于尝试新技术并能快速掌握&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个人有了好奇心求知欲就完了吗？那不能，这可不够。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了好奇去探索外，你还得有把探索所得，转化成自己经验的能力。这种能力的外在表现就是勇于尝试新技术，而且还得快速掌握。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再举个大刘另一个同事的例子，这个同事在工作中遇到了一个问题，就是存储海量数据的问题。那时候，还是 2008 年，这人刚毕业不到一年。他知道了 HDFS 这技术，就想着能不能把这东西用到项目上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可是，他只是个小年轻，人微言轻，怎么办？他也有本事，人家利用业余时间，没日没夜花了一周时间，自己搞了环境，又写了 Demo，还写程序模拟了大量数据去测试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后把这些拿给领导看，得，有理有据，最牛的是这哥们儿还弄了个像样的图表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OK，彻底 KO 了领导。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个小伙子后来逐渐成了这个项目中的最懂大数据的人。再后来，小伙子跳槽去了百度搞凤巢，如今人家又去了 Google，再 Transfer 到美国，活得有声有色的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，有了好奇心，有了求知欲，你还得把学到的东西落地，形成自己的独到经验，还得让别人知道你掌握了它，这样这个先发优势就进一步落了地，你的职业生涯可能开始有了自己的小地位了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 用批判性思维批判下&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你有了求知欲，又有了落地的能力，但是要把握好怎么落地？何时落地？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，在我们工作中，如果想应用新技术，就得找到现有方案的不足。有了不足，把不足作为切入点，和领导谈谈，在项目的某些小地方可以先尝试你想搞的新技术。一般来说也没啥问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;除了找现有项目的茬，你还得明白新技术有哪些坑。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新技术一般为了快速推广，往往夸大其词，搞得世界没了它就要灭亡一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候，怎么找到新技术的问题和不足，是至关重要的。找到不足，你既可以把控落地到项目中的风险，也有了去当这项新技术 Commiter 的机会，再不济去提个 Issue 刷刷存在感也是好的。这对将来职业发展都是大有帮助的啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那找新技术的不足就需要批判思维了。这批判性思维的前提，就是要求你能独立思考，独立判断，不是做做样子，找个小问题就行了的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一阵子，大刘的公司项目一直是用的 Spring MVC 搞 Web 项目。有个同事用了觉得很麻烦。为啥？因为在 Spring MVC 需要大量的配置，每次搞一个小项目都需要大量的改动配置。如果再加个 Hibernate，那配置把人要搞疯。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是，这个同事就想到了 SpringBoot。但是在用 SpringBoot 之前，他认为，SpringBoot 也是刚推出不久的，肯定也有自己的问题。于是，他就去 Google 上用 SpringBoot challenge 这种关键字，挖出了不少坑出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时，又发现 SpringBoot 封装的太好了，他又认为封装的太过易用，如果出现了一些底层问题，估计不好解决。他把这些优势和劣势统统搞了个报告，去申请 SpringBoot 试用。申请过后，他又从各方面审视项目的各种不足，不断改进问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;独立思考，以批判的眼光找到现有的不足，以批判性思维找到可以改进的方向，你将在自己的团队中拥有自己的行业话语权，项目前进的方向也可以在你的主导下进行。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4. 现实点，别吹牛逼&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大刘和小马谈到现在行业内存在的一些弊病的时候，不禁摇头叹气。现在行业内，做事飘得多，踏实的少。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;掌握点儿 Docker，就给你吹自己掌握了云技术。了解点儿 SpringBoot、SpringCloud，就告诉你精通了微服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可是，就大刘的经验，真能成功的，那都是脚踏实地的实干者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实干者们对一个项目，有着充分的评估，能在最坏的情况时，拿出早就准备好的方案。能在项目出现延期风险的时候，作出提前而精准的判断。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而这些，可不是那些夸夸其谈的营销类、建立类、PPT 类程序员能搞定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要沉下心来，去了解项目可能出现的问题的每一个核心原因。沉下心了解问题核心，可不仅仅是给项目带来好处。这东西可以直接训练人们处理问题的思路，也能加强对项目风险预测的嗅觉。这两种东西对将来团队管理、项目管理的好处就不言而喻了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做事儿踏实点，错不了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;青铜圣斗士有了第七感能打败黄金圣斗士。你有了敏锐的解决问题思路和预先嗅到风险的感觉，就能踢开阻挡你突飞猛进的拦路虎。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5. 啥都知道点，关心些职责之外的&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大刘、小马身边那些成功的程序员们，做事可不是只闷头做自己眼前这点儿就行了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;人家从小兵子的时候，工作除了拧螺丝，还会关心整个航母。当个后端工程师，人家把前端的活儿也揽过来，把前端框架了解的透透的。写个业务代码，顺便把底层框架摸了个滚瓜烂熟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作态度主动点儿，干好自己手头工作之余，尽可能的去多多了解整个项目。把项目弄的越熟悉，项目就越离不开你，这时候，别人还会把你看成小兵子吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上说了这么多，大刘自己全都做到了吗？没有，知易行难嘛，大刘只是像数学的极限一样，不断地逼近这些特点。大刘期待自己最终也会破茧而出，能变得更加出色。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们下篇大刘的故事见。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我最近建了一个读者交流群，里面大部分是程序员，一起聊技术、工作、八卦。欢迎加我微信，拉你入群。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9852216748768473&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6nbNnibOq5KQibCDibpTo0kqofPehQvDDibibcb3bQUELdY3Knsl4r0RcgsV9l4icr3icmZQfaBXtSFNTxmdQlAZT1OQg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;609&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我准备了一些纯手打的高质量PDF：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;深入浅出Java多线程、HTTP超全汇总、Java基础核心总结、程序员必知的硬核知识大全、简历面试谈薪的超全干货。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一些&lt;span&gt; JVM、算法、MySQL、Redis、Nginx、重构&lt;/span&gt;等经典技术资料。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;领取方式：关注我的公众号，在公众号后台回复：666&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU3MTg3NDYwNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRu19xsskWLWZBk2wEEmTf2kZWAH41Pptb4So66eJGXF0hLGVHWj6fDZ16m4FOicOJ9Iicj1q5xVmrQ/0?wx_fmt=png&quot; data-nickname=&quot;四猿外&quot; data-alias=&quot;si-yuanwai&quot; data-signature=&quot;上市公司技术总监，管理的团队百人以上。把自己的成长故事写成文章，把技术文章写成故事。&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;架构师大刘的其他故事：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247484769&amp;amp;idx=1&amp;amp;sn=e604092f8063829618e52ee3ff1f3628&amp;amp;chksm=fcd8c920cbaf4036c7e36f89b52e9b9602a3a83a66928b6d7c0a9ee911cdff670ea0198c35d1&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;中年架构师，悲催的一天&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247484777&amp;amp;idx=1&amp;amp;sn=977e620df6c3b640985e20345aa80a12&amp;amp;chksm=fcd8c928cbaf403ed6e28e6b8aafaa851cd0a5a1404fbb34ba7eeb25b592b7a593852e9bd002&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;恕我直言，微服务挺好，但不适合你&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247484792&amp;amp;idx=1&amp;amp;sn=37b3953abb879837d3ab24a2f943dba5&amp;amp;chksm=fcd8c939cbaf402f82bc0a580212f410736614cc15f1d2061d24f47ca439fa9ae2c6f22e643f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;架构师说了：不想做背锅侠？生产问题要这样查&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247484826&amp;amp;idx=1&amp;amp;sn=35378fc344195edc643c5a68f896bc40&amp;amp;chksm=fcd8c9dbcbaf40cdcad84dd15b972afed8cf477f584748167ee67dc3a2a3532474497aa4d6c1&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;一个技术总监的忠告：精通那么多技术，你为何还是受不到重用？&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247484862&amp;amp;idx=1&amp;amp;sn=be1f32643415f605da7080f791ed64f9&amp;amp;chksm=fcd8c9ffcbaf40e936ac5aedde29c3b259026a2b2945ea195613087caab036df144f7c2d8937&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;优秀！一鼓作气学会“一致性哈希”，就靠这 18 张图了&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c73e39578e2de72246e1f21acbab9186</guid>
<title>[推荐] Redis 专题：深入解读哨兵模式</title>
<link>https://toutiao.io/k/tm4wyb0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sentinel是Redis在主从复制基础上构建的一套高可用解决方案，本文将从下图几个方面来介绍Redis的Sentinel模式。&lt;img data-ratio=&quot;0.8642745709828393&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mZx0iasykfltK0bScf7icgO0LBaia4PTCO4ejBOgbCLj9QSCvxJqcFCumicOB6cND1mLXOS3DwGfvZqAkfGzMSUCQQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1282&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI0NTE4NDg0NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/mZx0iasykfltUJKaqQlD7oMJoZCwokhwjfJiblpUeuQY6Auvt8vPtFJRWmC1HUfNP2V2UYIVDnkzvSic8NnQy6EcQ/0?wx_fmt=png&quot; data-nickname=&quot;码路印记&quot; data-alias=&quot;&quot; data-signature=&quot;一个后端技术码农的技术笔记，专注互联网后端技术领域，涉及分布式系统、系统架构、微服务、数据库、缓存、搜索、消息队列等话题，欢迎交流！&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;写在前面&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0NTE4NDg0NA==&amp;amp;mid=2247483973&amp;amp;idx=1&amp;amp;sn=20a93510a2981b948de2bd1f0178bce1&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Redis专题：一文搞懂主从复制原理&lt;/a&gt;》我们了解到在主从模式下，主从复制机制使得slave成为与master完全一致的副本，一旦master宕机，我们可以选择一个正常的slave成为新的主节点，实现手动的故障恢复。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，人工干预效率低、易出错，并且故障感知滞后，不具备生产实用性。一个能够自动感知系统故障、自动故障转移的可靠组件，肯定是我们必须的。为此，Redis官方提供一个Redis的高可用方案——哨兵（Sentinel），使用它可以搭建一个即使无人干预也能抵抗某些类型失败的高可用的Redis分布式系统。这篇文章将对Redis的哨兵模式进行详细介绍，现在开始吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哨兵是Redis的一种运行模式，它专注于对Redis实例（主节点、从节点）运行状态的监控，并能够在主节点发生故障时通过一系列的机制实现选主及主从切换，实现故障转移，确保整个Redis系统的可用性。结合Redis的官方文档，可以知道Redis哨兵具备的能力有如下几个：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;监控（Monitoring）&lt;/strong&gt;：持续监控Redis主节点、从节点是否处于预期的工作状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;通知（Notification）&lt;/strong&gt;：哨兵可以把Redis实例的运行故障信息通过API通知监控系统或者其他应用程序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;自动故障恢复（Automatic failover）&lt;/strong&gt;：当主节点运行故障时，哨兵会启动自动故障恢复流程：某个从节点会升级为主节点，其他从节点会使用新的主节点进行主从复制，通知客户端使用新的主节点进行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;配置中心（Configuration provider）&lt;/strong&gt;：哨兵可以作为客户端服务发现的授权源，客户端连接到哨兵请求给定服务的Redis主节点地址。如果发生故障转移，哨兵会通知新的地址。这里要注意：哨兵并不是Redis代理，只是为客户端提供了Redis主从节点的地址信息。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哨兵模式是天然的分布式系统，它被设计为基于一套配置，并在多个哨兵实例的配合下工作。多实例共同协作有以下优势：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;主节点的系统故障是在多个实例共同认可的情况下完成的，大大降低了误报的概率。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;即使不是所有的哨兵实例都正常运行哨兵集群也能正常工作，这大大增加了系统的鲁棒性。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;哨兵集群演示&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说了这么多，不如实践看的直观，先通过一个例子看下Sentinel的高可用表现。由于Sentinel工作原理中需要对其他Sentinel节点和主从节点建立网络连接，其中要使用IP和端口，而Docker下采用的是端口映射或虚拟IP，导致在Docker运行需要一定的配置工作。所以，我这次直接在本地多实例运行。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;搭建集群&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本次实例采用三个哨兵节点、三个数据节点（一主二从）方式搭建，结构下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8179959100204499&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mZx0iasykfltK0bScf7icgO0LBaia4PTCO4tbXaY4oFpibN2D3XvBPlhkKsJN9zI32jXVEXBvmot4xIavRYP6KctxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;978&quot;/&gt;准备三个redis配置文件，对应Redis的一主二从，文件名称及内容如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# redis-6379.conf&lt;/span&gt;&lt;br/&gt;port 6379&lt;br/&gt;daemonize yes&lt;br/&gt;pidfile /var/run/redis-6379.pid&lt;br/&gt;logfile &lt;span&gt;&quot;6379.log&quot;&lt;/span&gt;&lt;br/&gt;dir &lt;span&gt;&quot;/Users/eleme/raysonxin/docker/redis-docker/log&quot;&lt;/span&gt;&lt;br/&gt;dbfilename dump-6379.rdb&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# redis-6380.conf&lt;/span&gt;&lt;br/&gt;port 6380&lt;br/&gt;daemonize yes&lt;br/&gt;pidfile /var/run/redis-6380.pid&lt;br/&gt;logfile &lt;span&gt;&quot;6380.log&quot;&lt;/span&gt;&lt;br/&gt;dir &lt;span&gt;&quot;/Users/eleme/raysonxin/docker/redis-docker/log&quot;&lt;/span&gt;&lt;br/&gt;dbfilename dump-6380.rdb&lt;br/&gt;slaveof 127.0.0.1 6379&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# redis-6381.conf&lt;/span&gt;&lt;br/&gt;port 6381&lt;br/&gt;daemonize yes&lt;br/&gt;pidfile /var/run/redis-6381.pid&lt;br/&gt;logfile &lt;span&gt;&quot;6381.log&quot;&lt;/span&gt;&lt;br/&gt;dir &lt;span&gt;&quot;/Users/eleme/raysonxin/docker/redis-docker/log&quot;&lt;/span&gt;&lt;br/&gt;dbfilename dump-6381.rdb&lt;br/&gt;slaveof 127.0.0.1 6379&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;准备三个Redis Sentinel配置文件，作为三个监控节点，文件及内容如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# sentinel-26379.conf&lt;/span&gt;&lt;br/&gt;port 26379&lt;br/&gt;daemonize yes&lt;br/&gt;dir &lt;span&gt;&quot;/Users/eleme/raysonxin/docker/redis-docker/log&quot;&lt;/span&gt;&lt;br/&gt;logfile &lt;span&gt;&quot;26379.log&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，192.168.11.128代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。&lt;/span&gt;&lt;br/&gt;sentinel monitor mymaster 127.0.0.1 6379 2   &lt;br/&gt;&lt;span&gt;# 判断主节点时间&lt;/span&gt;&lt;br/&gt;sentinel down-after-milliseconds mymaster 10000&lt;br/&gt;sentinel parallel-syncs mymaster 1    &lt;br/&gt;sentinel failover-timeout mymaster 180000&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# sentinel-26380.conf&lt;/span&gt;&lt;br/&gt;port 26380&lt;br/&gt;daemonize yes&lt;br/&gt;dir &lt;span&gt;&quot;/Users/eleme/raysonxin/docker/redis-docker/log&quot;&lt;/span&gt;&lt;br/&gt;logfile &lt;span&gt;&quot;26380.log&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，192.168.11.128代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。&lt;/span&gt;&lt;br/&gt;sentinel monitor mymaster 127.0.0.1 6379 2   &lt;br/&gt;&lt;span&gt;# 判断主节点时间&lt;/span&gt;&lt;br/&gt;sentinel down-after-milliseconds mymaster 10000 &lt;br/&gt;sentinel parallel-syncs mymaster 1    &lt;br/&gt;sentinel failover-timeout mymaster 180000&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# sentinel-26381.conf&lt;/span&gt;&lt;br/&gt;port 26381&lt;br/&gt;daemonize yes&lt;br/&gt;dir &lt;span&gt;&quot;/Users/eleme/raysonxin/docker/redis-docker/log&quot;&lt;/span&gt;&lt;br/&gt;logfile &lt;span&gt;&quot;26381.log&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，192.168.11.128代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。&lt;/span&gt;&lt;br/&gt;sentinel monitor mymaster 127.0.0.1 6379 2   &lt;br/&gt;&lt;span&gt;# 判断主节点时间&lt;/span&gt;&lt;br/&gt;sentinel down-after-milliseconds mymaster 10000 &lt;br/&gt;sentinel parallel-syncs mymaster 1    &lt;br/&gt;sentinel failover-timeout mymaster 180000&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;依次启动三个Redis Server，命令如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;redis-server conf/redis-6379.conf&lt;br/&gt;redis-server conf/redis-6380.conf&lt;br/&gt;redis-server conf/redis-6381.conf&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过客户端连接至&lt;code&gt;127.0.0.1:6379&lt;/code&gt;，输入命令&lt;code&gt;info replication&lt;/code&gt;，可以看到主从复制信息，说明一主二从工作正常。&lt;img data-ratio=&quot;0.47231833910034604&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mZx0iasykfltK0bScf7icgO0LBaia4PTCO4QpOdmUzUYXQRQyvlibLKAiay4CUp0Wba1VGpeUMLvqk8zKrxd5qQyW8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1156&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;依次启动三个Redis Sentinel，命令如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;redis-sentinel conf/redis-26379.conf&lt;br/&gt;redis-sentinel conf/redis-26380.conf&lt;br/&gt;redis-sentinel conf/redis-26381.conf&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过客户端连接至任意Sentinel节点，如&lt;code&gt;127.0.0.1:26379&lt;/code&gt;，输入命令&lt;code&gt;info sentinel&lt;/code&gt;，可以看到哨兵及主节点信息（如下图所示），主节点为6379数据节点，有两个从节点，3个哨兵节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2646616541353383&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mZx0iasykfltK0bScf7icgO0LBaia4PTCO4ibeFl1a50tMsLo6YuR6XwgVTPsYRLs4Nvvhyc3Viax41F0sISa06OGOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1330&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查询当前的主节点，在哨兵客户端输入命令&lt;code&gt;SENTINEL get-master-addr-by-name mymaster&lt;/code&gt;查询主节点，可以发现当前返回的是端口为6379的节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;img data-ratio=&quot;0.15113871635610765&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mZx0iasykfltK0bScf7icgO0LBaia4PTCO4mRuv9MflPicXg7LpyaW2faVU7sia9zZZCOYUoEJ9ztb6n8Q0sDJdlnmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;966&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;模拟主节点宕机&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端连接至主节点，向主节点发送命令&lt;code&gt;debug sleep 30&lt;/code&gt;，它会是的主节点阻塞30秒。然后再次执行查询主节点命令，可以看到主节点切换为端口为6381的节点。&lt;img data-ratio=&quot;0.1324376199616123&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mZx0iasykfltK0bScf7icgO0LBaia4PTCO4Q0ThAPLOqYjVtfO9RNGZ5NTwACSWjLygibmKLDffiba6Ea255d7ibV5xQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1042&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;向6381发送命令&lt;/span&gt;&lt;code&gt;info replication&lt;/code&gt;&lt;span&gt;可以看到6381切换为主节点，6379、6389变为6381的从节点。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4679376083188908&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mZx0iasykfltK0bScf7icgO0LBaia4PTCO4IJbGkHnlVYk6lMhRck1v71M01uBJfZVMhicZfxEicwzP5puEqVDr33ibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1154&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个过程中，哨兵节点26380输出了以下日志内容，以下内容我们暂时不解释，等后面讲解了哨兵工作原理，谜底自然就会揭开。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mZx0iasykfltK0bScf7icgO0LBaia4PTCO4TAnv3HOiam6uQzGlPkzicKC58mnmtj26dFf5pK2EUugicUNHj1g5xV46g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Sentinel工作原理&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哨兵是Redis的一种工作模式，以监控节点状态及执行故障转移为主要工作，哨兵总是以固定的频率去发现节点、故障检测，然后在检测到主节点故障时以安全的方式执行故障转移，确保集群的高可用性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下为哨兵周期性检查的核心逻辑，哨兵模式的原理部分也将以下面的代码为主线进行说明。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/* Perform scheduled operations for the specified Redis instance. */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/* Sentinel模式下，对节点执行的定时操作。属于最核心的函数了，包含节点发现、信息更新、故障检测、故障转移等操作 */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;sentinelHandleRedisInstance&lt;/span&gt;&lt;span&gt;(sentinelRedisInstance *ri)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/* ========== MONITORING HALF ============ */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;/* Every kind of instance */&lt;/span&gt;&lt;br/&gt;    sentinelReconnectInstance(ri);&lt;br/&gt;    &lt;span&gt;/* 定时向主从节点、其他Sentinel节点发送PING、INFO、Hello（仅Sentinel）消息；&lt;br/&gt;     * 以此实现了节点发现、节点信息更新、收集健康检测信息*/&lt;/span&gt;&lt;br/&gt;    sentinelSendPeriodicCommands(ri);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* ============== ACTING HALF ============= */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;/* We don&#x27;t proceed with the acting half if we are in TILT mode.&lt;br/&gt;     * TILT happens when we find something odd with the time, like a&lt;br/&gt;     * sudden change in the clock. */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (sentinel.tilt) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (mstime()-sentinel.tilt_start_time &amp;lt; SENTINEL_TILT_PERIOD) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        sentinel.tilt = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        sentinelEvent(LL_WARNING,&lt;span&gt;&quot;-tilt&quot;&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;&quot;#tilt mode exited&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* 检查节点是否主观下线，这个操作对主从节点、其他Sentinel节点生效 */&lt;/span&gt;&lt;br/&gt;    sentinelCheckSubjectivelyDown(ri);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* Masters and slaves */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (ri-&amp;gt;flags &amp;amp; (SRI_MASTER|SRI_SLAVE)) {&lt;br/&gt;        &lt;span&gt;/* Nothing so far. */&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* 以下操作仅针对主节点 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (ri-&amp;gt;flags &amp;amp; SRI_MASTER) {&lt;br/&gt;        &lt;span&gt;/* 判断主节点是否满足客观宕机条件 */&lt;/span&gt;&lt;br/&gt;        sentinelCheckObjectivelyDown(ri);&lt;br/&gt;        &lt;span&gt;/* 检查是否可以开始故障转移操作 */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (sentinelStartFailoverIfNeeded(ri)) {&lt;br/&gt;            &lt;span&gt;/* 监控该主节点的Sentinel执行选主操作 */&lt;/span&gt;&lt;br/&gt;            sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_ASK_FORCED);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;/* 根据failover_state状态机，逐步执行故障转移操作 */&lt;/span&gt;&lt;br/&gt;        sentinelFailoverStateMachine(ri);&lt;br/&gt;        &lt;br/&gt;        &lt;span&gt;/* 这一步是向监控该主节点的其他Sentinel询问该主节点是否主观宕机，为主观宕机收集选票 */&lt;/span&gt;&lt;br/&gt;        sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_NO_FLAGS);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;节点自动发现&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先说明一下，这里的节点指的是其他哨兵节点及从节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回过头看下上面哨兵的配置文件，会发现我们仅配置了主节点的地址信息（host和port），并没有配置从节点及其他哨兵节点的信息。但是，我们在哨兵节点和主节点客户端通过&lt;code&gt;info replication&lt;/code&gt;或&lt;code&gt;info sentinel&lt;/code&gt;命令时却能够发现它们的存在。这一功能是由哨兵的自动发现机制实现的，我们来了解下。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;先看数据节点&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般情况下，哨兵节点每隔10秒（故障转移时每隔1秒）向主从节点发送&lt;code&gt;INFO&lt;/code&gt;命令，以此获取主从节点的信息。第一次执行时，哨兵仅知道我们给出的主节点信息，通过对主节点执行&lt;code&gt;INFO&lt;/code&gt;命令就可以获取其从节点列表。如此周期性执行，就可以不断发现新加入的节点。&lt;img data-ratio=&quot;0.6581532416502947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mZx0iasykfltK0bScf7icgO0LBaia4PTCO4CZ7aN3WSNzHiaQeo6vkyGkQ4sibU4kkK8nsFd7vN51q13YQ3yialXZp4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1018&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果&lt;code&gt;INFO&lt;/code&gt;命令目标是从节点：哨兵从返回信息中获取从节点所属的最新主节点ip和port，如果与历史记录不一致，则执行更新；获取从节点的优先级、复制偏移量以及与主节点的链接状态并更新。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果&lt;code&gt;INFO&lt;/code&gt;命令目标是主节点：哨兵从返回信息中获取主节点的从机列表，如果从节点是新增的，则将其加入监控列表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;无论目标是主节点还是从节点，都会记录其runId。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果节点的角色发生变化，哨兵会记录节点新的角色及上报时间。若此时哨兵运行在TILT模式下，则什么都不做。否则，会执行主从切换相关的逻辑，我们后面再细说。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;INFO&lt;/code&gt;命令是Redis的管理命令，通过它我们可以了解服务运行的信息。关于&lt;code&gt;INFO&lt;/code&gt;命令的作用及返回值信息，建议大家实操看下，可参考官方文档了解每个信息的含义。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;再来看哨兵节点&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了相互检查可用性及信息交互，哨兵之间是一直保持连接的，但是我们并没有显示的告知它们彼此的存在，它们之间是怎么发现对方并交互的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是这样的：通过刚才的介绍，我们了解到哨兵通过&lt;code&gt;INFO&lt;/code&gt;命令发现了主节点及从节点的地址信息，而Redis提供了一种发布订阅的消息通信模式，即Pub/Sub，哨兵们就是通过一个约定好的通道（channel）发布/订阅hello信息进行通信。结合图示说明一下：&lt;img data-ratio=&quot;0.6801541425818882&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mZx0iasykfltK0bScf7icgO0LBaia4PTCO4VOKTCmatTnlbNx3HBAHK5JXzcHBQWbz7QWia1UP7ASRLIMDETPmrNjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1038&quot;/&gt;如上图所示：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;每隔2秒，每个哨兵会通过它所监控的主节点、从节点向&lt;code&gt;__sentinel__:hello&lt;/code&gt;通道发布一条hello消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个哨兵会通过它所监控的主节点、从节点订阅&lt;code&gt;__sentinel__:hello&lt;/code&gt;通道的消息，以此接收其他哨兵发布的信息。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过Redis客户端直接订阅该channel：连接到其中一个节点，然后输入命令：&lt;code&gt;SUBSCRIBE __sentinel__:hello&lt;/code&gt;，如下图所示：&lt;img data-ratio=&quot;0.4030054644808743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mZx0iasykfltK0bScf7icgO0LBaia4PTCO4YH088n89ibadTrMshAktWX5z6FBAl17qIttSnyeiaJqBStsWk6EmvcdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1464&quot;/&gt;如上图所示，hello信息中包含8个信息，依次是：哨兵ip、哨兵端口、哨兵runId、当前纪元、主节点名称、主节点ip、主节点端口、主节点纪元，除了纪元应该都可以理解。这样每个哨兵发布的消息都会被其他哨兵接收到，从而达到信息交换的目的。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;每个哨兵都会维护其监控的主节点信息，如果它接收到其他哨兵消息后，发现自己维护的信息已经过时，则立即执行更新过程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果哨兵接受到的信息没有在已有的监控列表中，就意味着发现了一个新的哨兵实例，此时会创建一个新的哨兵实例加入监控列表。在处理新增哨兵实例时，如果它与已存在的哨兵实例runId或者ip、port一致，将只保存最新的实例信息。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于其他哨兵节点及从节点的发现过程就介绍到这里了，整体还是比较容易理解的。简单总结一下：对于数据节点采用&lt;code&gt;INFO&lt;/code&gt;命令询问，从一个主节点得到从节点，再通过从节点校验主节点，实现节点发现；对于其他哨兵节点，借助正在被监控的数据节点以类似广播的方式，实现节点的发现。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;故障检测&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;故障检测是哨兵执行故障转移的前提，在知晓需要监控的目标（主从节点）后，哨兵通过&lt;code&gt;PING&lt;/code&gt;命令实现对主从节点的故障检测。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哨兵以集群方式工作，官方建议至少要有三个节点，每个节点都以相同的方式对主从节点进行监控与故障检测。由于网络抖动或者网络分区，单个哨兵对节点的故障检测可能无法代表其真实的状态，为了降低误判，哨兵之间还需要对节点的故障状态进行协商。所以这里需要引入两个概念：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;主观宕机（Subjective Down, SDOWN）：是指一个哨兵实例通过检测发现某个主节点发生故障的一种状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客观宕机（Objective Down, ODOWN）：是指哨兵检测到某个主节点发生故障，通过命令&lt;code&gt;SENTINEL is-master-down-by-addr&lt;/code&gt;与其他哨兵节点协商，并且在指定时间内接收到指定数量的其他哨兵的确认反馈时的一种状态。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;简单来说，SDOWN是哨兵自己认为节点宕机，而ODOWN是不但哨兵自己认为节点宕机，而且该哨兵与其他节点沟通后，达到一定数量的哨兵都认为节点宕机了。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的“一定数量”是一个法定数量（Quorum），是由哨兵监控配置决定的，解释一下该配置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# sentinel monitor &amp;lt;master-name&amp;gt; &amp;lt;master-host&amp;gt; &amp;lt;master-port&amp;gt; &amp;lt;quorum&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 举例如下：&lt;/span&gt;&lt;br/&gt;sentinel monitor mymaster 127.0.0.1 6379 2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这条配置项用于告知哨兵需要监听的主节点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;sentinel monitor：代表监控。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mymaster：代表主节点的名称，可以自定义。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;192.168.11.128：代表监控的主节点ip，6379代表端口。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2：法定数量，代表只有两个或两个以上的哨兵认为主节点不可用的时候，才会把主节点设置为ODOWN状态，然后进行failover操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例子中quorum＝2，也就是说：哨兵检测到主节点故障并设置其状态为SDOWN，然后至少得到一个其他哨兵的认可，即标记该主节点为ODWN状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一个概念：config-epoch，配置纪元，它是维护集群内主从关系信息版本的配置。每次执行故障转移都会加1，用于表明一个新的集群主从关系版本。数值越大，版本越新。它由哨兵节点维护，并在哨兵节点之间相互传播。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;认识以上几个概念后，我们看下Redis是如何实现的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;主观宕机&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis以类似心跳检测的&lt;code&gt;PING&lt;/code&gt;命令对节点进行健康检查，然后根据节点的回复情况进行状态管理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哨兵以字段&lt;code&gt;act_ping_time&lt;/code&gt;维护对节点执行PING命令的时间，并把它作为超时未回复的依据，通过下面的过程了解它的变化：&lt;img data-ratio=&quot;1.0178890876565294&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mZx0iasykfltK0bScf7icgO0LBaia4PTCO4oUnKODibQQQ8O5QUy6ObXOibsM1icUDibNppMSHSk1jebueJJcSFS4jWQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1118&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;默认情况下，每隔1秒哨兵向节点发送一次&lt;code&gt;PING&lt;/code&gt;命令；发送成功后，设置&lt;code&gt;last_ping_time&lt;/code&gt;为当前时间，按如下规则修改&lt;code&gt;act_ping_time&lt;/code&gt;：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;若&lt;code&gt;act_ping_time&lt;/code&gt;为0，则设置为当前时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若&lt;code&gt;act_ping_time&lt;/code&gt;不是0，则不做任何修改。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;若收到节点回复：修改&lt;code&gt;last_pong_time&lt;/code&gt;为当前时间，并检查是否为有效回复，哨兵仅认为&lt;code&gt;+PONG&lt;/code&gt;、-LOADING&lt;code&gt;、&lt;/code&gt;-MASTERDOWN`是有效的，其他回复或未回复都是无效的。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;若为有效回复，则修改&lt;code&gt;last_avail_time&lt;/code&gt;为当前时间，修改&lt;code&gt;act_ping_time&lt;/code&gt;为0；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若为无效回复，不做任何修改&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;每隔100毫秒，哨兵逐个检查节点是否达到SDOWN状态，具体方法在&lt;code&gt;sentinelCheckSubjectivelyDown&lt;/code&gt;，当满足以下条件（两者满足其一）时，哨兵会把节点状态置为SDOWN：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在预设时间范围内哨兵未收到节点对PING命令的有效回复。这个预设时间是由配置项&lt;code&gt;down-after-milliseconds&lt;/code&gt;决定的，默认值是30秒。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;哨兵认为它是主节点，而节点上报它正在切换为从节点，但是在指定时间范围内它没有完成角色切换。这个时间计算公式为：&lt;code&gt;down-after-milliseconds + 2 * SENTINEL_INFO_PERIOD&lt;/code&gt;，默认值是50秒（&lt;code&gt;30 + 2 * 10&lt;/code&gt;）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SDOWN状态是指在&lt;code&gt;down-after-milliseconds&lt;/code&gt;未收到节点的PING命令回复，如果该配置项为30秒，但是哨兵在29秒时收到节点的回复，哨兵也会认为节点是正常工作的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SDOWN无法触发故障转移，仅仅说明是一个哨兵认为节点发生故障（不可用）了，若要触发故障转移，必须达到ODOWN状态。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;客观宕机&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当Sentinel将一个主节点判断为主观下线之后，为了确认这个主服务器是否真的下线 了，它会向同样监视这一主服务器的其他Sentinel进行询问，看它们是否也认为主服务器已经进入了下线状态。当Sentinel从其他Sentinel那里接收到足够数量的已下线判断之后，Sentinel就会将从服务器判定为客观下线，并对主服务器执行故障转移操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;发送&lt;code&gt;Sentinel is-master-down-by-addr&lt;/code&gt;命令。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sentinel使用&lt;code&gt;Sentinel is-master-down-by-addr&lt;/code&gt;命令询问其他Sentinel节点是否已经下线。命令及参数说明如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Sentinel is-master-down-by-addr &amp;lt;ip&amp;gt; &amp;lt;port&amp;gt; &amp;lt;epoch&amp;gt; &amp;lt;runId&amp;gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 既可用于询问其他哨兵主节点是否下线，也可以用于后续故障转移的投票，这里先说第一种情况：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# ip：被Sentinel判断为主观下线主节点的ip；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# port：被Sentinel判断为主观下线主节点的port；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# epoch：Sentinel的配置纪元；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# runId：询问场景中它始终为`*`。&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果被Sentinel判断为主观下线的主节点IP为127.0.0.1，端口号为6379，Sentinel的配置纪元为0，那么Sentinel将向其他Sentinel发送以下命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SENTINEL is-master-down-by-addr 127.0.0.1 6379 0 *&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;接收&lt;code&gt;Sentinel is-master-down-by-addr&lt;/code&gt;命令。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当Sentinel接收到其他Sentinel发过来的&lt;code&gt;Sentinel is-master-down-by-addr&lt;/code&gt;命令后，会解析命令中的主节点的ip和port，检查本地缓存中主节点是否为SDOWN，然后以下三个参数进行回复：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 返回目标Sentinel对主节点的检查结果，1说明为SDOWN，0说明正常。&lt;/span&gt;&lt;br/&gt;1) &amp;lt;down_state&amp;gt;&lt;br/&gt;&lt;span&gt;# 在询问主节点是否下线的场景下，始终为 *&lt;/span&gt;&lt;br/&gt;2) &amp;lt;leader_runid&amp;gt;&lt;br/&gt;&lt;span&gt;# 在询问主节点是否下线的场景下，始终为 0&lt;/span&gt;&lt;br/&gt;3) &amp;lt;leader_epoch&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果接收&lt;code&gt;Sentinel is-master-down-by-addr&lt;/code&gt;命令的Sentinel也认为主节点已经为SDOWN，则回复命令如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1) 1&lt;br/&gt;2) *&lt;br/&gt;3) 0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;处理&lt;code&gt;Sentinel is-master-down-by-addr&lt;/code&gt;回复。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当Sentinel接收到其他Sentinel对&lt;code&gt;Sentinel is-master-down-by-addr&lt;/code&gt;的回复后，会解析其返回的内容，然后设置该Sentinel对询问主节点的在线状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这样，Sentinel就完成了通过其他Sentinel对主节点在线状态的询问过程。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Sentinel的周期性函数中，会检查主节点是否满足客观宕机的条件。判断的过程比较简单：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从字典中取出监控当前主节点的所有Sentinel节点，然后遍历这些Sentinel的主节点状态是否为SDOWN，是就累加。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;遍历完成后，检查累加结果是否大于等于quorum（法定数量）。成立则修改主节点状态为客观宕机（ODOWN），并设置宕机时间；不成立则设置为非客观宕机。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;ODOWN状态仅应用在主节点上，不对从节点及其他哨兵节点应用，但是SDOWN状态对他们都是有效的。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;故障转移&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sentinel判定主节点客观宕机（ODOWN）后，将进入故障转移过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进入故障转移过程有几个前提：主节点为客观宕机状态、当前没有故障转移在执行、上次故障转移已经超时。Sentinel确认可以执行故障转移后，会进行以下几项准备工作：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;设置failover_state：SENTINEL_FAILOVER_STATE_WAIT_START（故障转移等待开始）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置当前主节点标识位：SRI_FAILOVER_IN_PROGRESS（主节点处于故障转移过程中）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置纪元加1，并以此作为故障转移的纪元；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;记录故障转移开始时间及failover_state状态修改时间；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个故障转移过程是依靠Sentinel周期性函数及failover_state状态机来驱动的（具体函数是&lt;code&gt;sentinelFailoverStateMachine&lt;/code&gt;），通过图示来说明：&lt;img data-ratio=&quot;0.9397944199706314&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mZx0iasykfltK0bScf7icgO0LBaia4PTCO4GvAocELQrDz3KWsUricQWMzzjRH0smGx98lOlqUZKGcLbwqde4UiavsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;681&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;如图所示，一个状态对应一个操作步骤。&lt;/span&gt;&lt;span&gt;每次&lt;/span&gt;&lt;code&gt;sentinelFailoverStateMachine&lt;/code&gt;&lt;span&gt;执行时首先判断failover_state，然后选择对应的过程执行，接下来按照上图把核心过程介绍&lt;/span&gt;一&lt;span&gt;下。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Sentinel Leader选举&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个主节点被判断为客观下线时，监控这个主节点的所有Sentinel会进行协商，选举一个Leader对下线的主节点执行故障转移操作。怎么选呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思考一下，我们可以知道：故障检测是多个Sentinel同时执行的，也就是说可能多个Sentinel在相近的时间内都判定主节点客观宕机了，因此Leader的选举过程在Sentinel集群内可能是同步进行的。所以，Sentinel需要在集群内进行“拉票”，“拉票”的依据就是配置纪元及“拉票”的时间。配置纪元越大，优先级越高；“拉票”请求越早，优先级越高。我们来看下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当Sentinel判断主节点客观下线后，会把自己的配置纪元加1，未检测到主节点ODOWN或检测慢的，自然落后于当前纪元；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Sentinel会使用&lt;code&gt;Sentinel is-master-down-by-addr&lt;/code&gt;命令向其他所有Sentinel发起投票请求，与故障检测过程中的“询问“不同，这里的runId将被设置为当前Sentinel的runId，epoch为最新的纪元。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其他Sentinel接收到“投票”请求后，执行以下过程：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;若请求纪元大于自身配置纪元，则更新替换；若监控主节点的配置纪元小于请求纪元，则更新替换，并“投票”给发起请求的Sentinel。这个过程是抢占式的，同一纪元，先到先得。（Redis命令处理是单线程，无并发冲突）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据判断结果，回复“投票”请求：回复内容为该Sentinel选举的Leader的runId。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;Sentinel接收并处理&lt;code&gt;Sentinel is-master-down-by-addr&lt;/code&gt;回复：把投票结果（runId）更新到该Sentinel的节点信息中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“投票”完成后就到了“唱票”环节，该过程是在&lt;code&gt;SENTINEL_FAILOVER_STATE_WAIT_START&lt;/code&gt;状态下执行的。Sentinel会遍历当前主节点下所有的Sentinel节点，把它们的投票信息进行统计；然后判断是否有Sentinel胜出。这里胜出的条件是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Sentinel必须获取集群内大多数Sentinel的选票，即票数大于50%（防止“脑裂“）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Sentinel所获票数必须大于等于法定人数（quorum）；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;举例：监控主节点的Sentinel有5个，quorum为4，投票情况：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果某个Sentinel的获得3票，但是3&amp;lt;4，该Sentinel不能被选为Leader；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果某个Sentinel的获得4票，但是4&amp;gt;=4，该Sentinel可以被选为Leader;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为Sentinel Leader的产生需要半数以上Sentinel的支持，并且每个Sentinel在每个配置纪元里面只能设置一次Leader，所以在一个配置纪元立main，只会出现一个Leader。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在给定时限内，没有一个Sentinel被选举为Leader，那么各个Sentinel将在一段时间后再次进行选择，直到选出Leader为止。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sentinel Leader选举完成，设置failover_state为&lt;code&gt;SENTINEL_FAILOVER_STATE_SELECT_SLAVE&lt;/code&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;新主节点选举&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主节点已经客观宕机，Sentinel Leader会从该主节点存活的从节点中选出一个新的主节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，Sentinel Leader会按照以下条件剔除从节点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;主观宕机（SDOWN）或与处于断线状态的从节点；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最近5秒内未回复过Sentinel Leader INFO命令的从节点；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从节点的优先级为0的从节点，由配置项&lt;code&gt;replica-priority&lt;/code&gt;决定；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;与主节点断开连接超过10倍&lt;code&gt;down-after-milliseconds&lt;/code&gt;的从节点；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;筛选过后，剩下的从节点都是数据比较新、与Sentinel Leader通信正常的，可以保证故障转移后最小的数据丢失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，按照以下规则选择新的主节点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;选择&lt;code&gt;replica-priority&lt;/code&gt;最低的节点。如果存在相同，则继续；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;选择复制偏移量最大的的从节点。如果存在相同，则继续；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;选择runId最小的从节点；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果新主节点选举失败，将等待重试。选举成功，则将此从节点提升，并设置failover_state为&lt;code&gt;SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE&lt;/code&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;配置新主节点&amp;amp;新主节点角色提升&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选出新的主节点之后，Sentinel Leader会向它发送&lt;code&gt;slaveof NO ONE&lt;/code&gt;，把这个从节点转为主节点（这是在从节点自身来看的角色转换）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从节点接收&lt;code&gt;slaveof NO ONE&lt;/code&gt;命令后，会重置其主节点信息，断开与其主节点、从节点的网络连接，重置其复制ID，并执行持久化重写操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发送命令后，Sentinel Leader会设置failover_state为&lt;code&gt;SENTINEL_FAILOVER_STATE_WAIT_PROMOTION&lt;/code&gt;，等待从节点角色提升。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sentinel Leader会向它发送&lt;code&gt;slaveof NO ONE&lt;/code&gt;命令后，每隔一秒发送一次INFO命令（正常是10秒一次），并观察命令回复中的角色信息。当被升级的从节点的角色从原来的slave变为master时，Sentinel Leader就知道该从节点已经升级主节点了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从节点角色提升成功，设置failover_state状态为SENTINEL_FAILOVER_STATE_RECONF_SLAVES。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;配置其他从节点&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新的主节点已经配置完成，接下来就是要让其他存活的从节点以该节点为主节点，然后向该节点发起主从复制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该过程原理比较简单：遍历原主节点的从节点，向这些从节点发送&lt;code&gt;slaveof &amp;lt;ip&amp;gt; &amp;lt;port&amp;gt;&lt;/code&gt;命令，该部分在上一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0NTE4NDg0NA==&amp;amp;mid=2247483973&amp;amp;idx=1&amp;amp;sn=20a93510a2981b948de2bd1f0178bce1&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Redis专题：一文搞懂主从复制原理&lt;/a&gt;》讲过，大家可以自行翻阅。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有从节点配置完成后，就会修改failover_state为&lt;code&gt;SENTINEL_FAILOVER_STATE_UPDATE_CONFIG&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，这一过程受配置项parallel_syncs（同时执行主从复制的节点数量）的影响。由于主从复制过程中从节点数据加载阶段无法对外提供服务，所以，如果同时进行主从复制的从节点数量较多，可能会导致短时间内系统不可用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该配置越小，从节点完成配置的时间越长；反之，时间越短。实际环境中，我们需要根据从节点的数量，系统压力，按照比例合理设置。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;更新配置&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;故障转移过程中，新主节点是以“储君”的身份在工作，其他所有从节点切换至新的主节点后，就要正式把新主节点“立”起来了。简单来说有三步（实现方法在&lt;code&gt;sentinelFailoverSwitchToPromotedSlave&lt;/code&gt;，由周期函数触发）：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;重置新主节点的信息状态、清空从节点、Sentinel节点等，failover_state修改为&lt;code&gt;SENTINEL_FAILOVER_STATE_NONE&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从旧主节点中迁移Sentinel节点、从节点，迁移至新的主节点中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;释放就主节点配置信息。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，故障转移工作完成。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;其他问题&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;主从节点移除&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sentinel从不移除从节点，即使很长时间都不可用。这一点是非常有用的，因为当发生网络分区或者故障后，Sentinel需要正确的对恢复节点进行重新配置。经过故障转移，旧主节点将以从节点的角色加入集群，Sentinel会对他进行重新配置，让它从新的主节点执行主从复制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果需要移除故障节点，需要依次向Sentinel节点发送&lt;code&gt;Sentinel Reset&lt;/code&gt;命令，经过10秒，Sentinel会重新刷新它们的从节点列表，仅保存主节点INFO命令回复内容中的从节点。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;脑裂问题&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;redis的主从模式下脑裂是指因为网络问题，导致redis 主节点跟从节点和Sentinel集群处于不同的网络分区，此时因为Sentinel集群无法感知到 主节点的存在，就会将某一个从节点提升为主节点。此时就存在两个不同的主节点，就像一个大脑分裂成了两个。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;集群脑裂问题中，如果客户端还在基于原来的主节点继续写入数据，那么新的主节点将无法同步这些数据，当网络问题解决之后，Sentinel 集群将原先的主节点降为从节点，此时再从新的主中同步数据，将会造成大量的数据丢失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：Redis 3原来是主节点，Redis 1和2是它的从节点。由于网络分区，Sentinel 1和2提升Redis 1作为新的主节点，而Redis 3在自己所处的网络分区中仍然是主节点。Client B还会持续写入数据，但是当网络恢复后，Redis 3将被重新配置为Redis 1的从节点，Client B写入的数据将会全部丢失。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;            +-------------+&lt;br/&gt;            | Sentinel 1  |----- Client A&lt;br/&gt;            | Redis 1 (M) |&lt;br/&gt;            +-------------+&lt;br/&gt;                    |&lt;br/&gt;                    |&lt;br/&gt;+-------------+     |          +------------+&lt;br/&gt;| Sentinel 2  |-----+-- // ----| Sentinel 3 |----- Client B&lt;br/&gt;| Redis 2 (S) |                | Redis 3 (M)|&lt;br/&gt;+-------------+                +------------+&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于Redis使用异步复制，在这个场景中无法完全解决数据丢失的问题，但是可以通过以下参数把数据损失降低：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;min-replicas-to-write 1&lt;br/&gt;min-replicas-max-lag 10&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;min-replica选项的作用在上一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0NTE4NDg0NA==&amp;amp;mid=2247483973&amp;amp;idx=1&amp;amp;sn=20a93510a2981b948de2bd1f0178bce1&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Redis专题：一文搞懂主从复制原理&lt;/a&gt;》我们也说过了，这一配置要求主节点必须包含一个从节点并且主从之间的最大延迟不能超过10秒，否则主节点会拒绝客户端的写入请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是从故障发生到min-replica选项生效也需要一定的时间，这个过程中的数据丢失是无法避免的，依赖“Redis+Sentinel”的系统必须对数据的丢失有一定的容忍性，否则就需要采用支持强一致的系统了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文详细介绍了Redis Sentinel模式的工作原理，从节点发现、故障检测、故障转移等几个方面深入展开。对我个人来讲，Redis主从模式的运行原理有了更加深入的认识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;希望也能给你带来帮助！码字不易，感谢转发！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;参考文档&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;CSDN《Redis(设计与实现):46---Sentinel之检测服务器、Sentinel下线状态(down-after-milliseconds、quorum、is-master-down-by-addr)》：https://blog.csdn.net/qq_41453285/article/details/103354554&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;官方文档《Redis Sentinel Documentation》：https://redis.io/topics/sentinel&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis源码 tag:6.0.10&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;《Redis Sentinel原理解析》：https://juejin.cn/post/6921279887080849422#heading-9&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9f1d0488097203480faf23e334faa3df</guid>
<title>[推荐] 内存管理设计精要</title>
<link>https://toutiao.io/k/4f2u3c5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;article-content&quot;&gt;&lt;blockquote&gt;&lt;p&gt;系统设计精要是一系列深入研究系统设计方法的系列文章，文中不仅会分析系统设计的理论，还会分析多个实际场景下的具体实现。这是一个季更或者半年更的系列，如果你有想要了解的问题，可以在文章下面留言。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;持久存储的磁盘在今天已经不是稀缺的资源了，但是 CPU 和内存仍然是相对比较昂贵的资源，作者在 &lt;a href=&quot;https://draveness.me/system-design-scheduler/&quot;&gt;调度系统设计精要&lt;/a&gt; 中曾经介绍操作系统和编程语言对 CPU 资源的调度策略和原理，本文将会介绍计算机中常见的另一个稀缺资源 — 内存，是如何管理的。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096642849-system-design-and-memory-management.png&quot; alt=&quot;system-design-and-memory-management&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 1 - 内存系统设计精要&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;内存管理系统和模块在操作系统以及编程语言中都占有着重要的地位，任何资源的使用都离不开申请和释放两个动作，内存管理中的两个重要过程就是内存分配和垃圾回收，内存管理系统如何利用有限的内存资源为尽可能多的程序或者模块提供服务是它的核心目标。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096642881-table-of-content.png&quot; alt=&quot;table-of-content&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 2 - 文章脉络和内容&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;虽然多数系统都会将内存管理拆分成多个复杂的模块并引入一些中间层提供缓存和转换的功能，但是内存管理系统实际上都可以简化成两个模块，即内存分配器（Allocator）、垃圾收集器（Collector）。当然除了这两个模块之外，在研究内存管理时都会引入第三个模块 — 用户程序（Mutator），帮助我们理解整个系统的工作流程。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096642887-mutator-allocator-collector.png&quot; alt=&quot;mutator-allocator-collector&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 3 - 内存管理系统模块&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;用户程序（Mutator）- 可以通过分配器创建对象或者更新对象持有的指针；&lt;/li&gt;&lt;li&gt;内存分配器（Allocator）— 处理用户程序的的内存分配请求；&lt;/li&gt;&lt;li&gt;垃圾收集器（Collector）- 标记内存中的对象并回收不需要的内存；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;上述的三个模块是内存管理系统中的核心，它们在应用程序运行期间可以维护管理内存达到相对平衡的状态，我们在介绍内存管理时也会围绕这三个不同的组件，本节将从基本概念、内存分配和垃圾回收三个方面详细介绍内存管理的相关理论。&lt;/p&gt;&lt;h2 id=&quot;基本概念&quot;&gt;基本概念&lt;/h2&gt;&lt;p&gt;基本概念这一节将介绍内存管理中的基本问题，我们会简单介绍应用程序的内存布局、内存管理中的设计的常见概念以及广义上的几种不同内存管理方式，这里会帮助各位读者从顶层了解内存管理。&lt;/p&gt;&lt;h3 id=&quot;内存布局&quot;&gt;内存布局&lt;/h3&gt;&lt;p&gt;操作系统会为在其上运行的应用程序分配一片巨大的虚拟内存，需要注意的是，与操作系统的主存和物理内存不一样，虚拟内存并不是在物理上真正存在的概念，它是操作系统构建的逻辑概念。应用程序的内存一般会分成以下几个不同的区域：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096642893-memory-layout.png&quot; alt=&quot;memory-layout&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 4 - 内存布局&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;栈区（Stack）— 存储程序执行期间的本地变量和函数的参数，从高地址向低地址生长；&lt;/li&gt;&lt;li&gt;堆区（Heap）— 动态内存分配区域，通过 &lt;code&gt;malloc&lt;/code&gt;、&lt;code&gt;new&lt;/code&gt;、&lt;code&gt;free&lt;/code&gt; 和 &lt;code&gt;delete&lt;/code&gt; 等函数管理；&lt;/li&gt;&lt;li&gt;未初始化变量区（BSS）— 存储未被初始化的全局变量和静态变量；&lt;/li&gt;&lt;li&gt;数据区（Data）— 存储在源代码中有预定义值的全局变量和静态变量；&lt;/li&gt;&lt;li&gt;代码区（Text）— 存储只读的程序执行代码，即机器指令；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;上述五种不同段虽然存储着不同的数据，但是我们可以将它们分成三种不同的内存分配类型，也就是静态内存、栈内存和堆内存。&lt;/p&gt;&lt;h4 id=&quot;静态内存&quot;&gt;静态内存&lt;/h4&gt;&lt;p&gt;静态内存可以最早追溯到 1960 年的 ALGOL 语言&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，静态变量的生命周期可以贯穿整个程序。所有静态内存的布局都是在编译期间确认的，运行期间也不会分配新的静态内存，因为所有的静态内存都是在编译期间确认的，所以会为这些变量申请固定大小的内存空间，这些固定的内存空间也会导致静态内存无法支持函数的递归调用：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096642898-static-allocation-features.png&quot; alt=&quot;static-allocation-features&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 5 - 静态内存的特性&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;因为编译器可以确定静态变量的地址，所以它们是程序中唯一可以使用绝对地址寻址的变量。当程序被加载到内存中时，静态变量会直接存储在程序的 BSS 区或者数据区，这些变量也会在程序退出时被销毁，正是因为静态内存的这些特性，我们并不需要在程序运行时引入静态内存的管理机制。&lt;/p&gt;&lt;h4 id=&quot;栈内存&quot;&gt;栈内存&lt;/h4&gt;&lt;p&gt;栈是应用程序中常见的内存空间，它遵循后进先出的规则管理存储的数据&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。当应用程序调用函数时，它会将函数的参数加入栈顶，当函数返回时，它会将当前函数使用的栈全部销毁。栈内存管理的指令也都是由编译器生成的，我们会使用 BP 和 SP 这两个寄存器存储当前栈的相关信息，完全不需要工程师的参与，不过我们也只能在栈上分配大块固定的数据结构。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096642903-stack-allocation-features.png&quot; alt=&quot;stack-allocation-features&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 6 - 栈内存的特性&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;因为栈内存的释放是动态的并且是线性的，所以它可以支持函数的递归调用，不过运行时动态栈分配策略的引入也会导致程序栈内存的溢出，如果我们在编程语言中使用的递归函数超出了程序内存的上限，会造成栈溢出错误。&lt;/p&gt;&lt;h4 id=&quot;堆内存&quot;&gt;堆内存&lt;/h4&gt;&lt;p&gt;堆内存也是应用程序中的常见内存，与超过函数作用域会自动回收的栈内存相比，它能够让函数的被调用方向调用方返回内存并在内存的分配提供更大的灵活性，不过它提供的灵活性也带来了内存泄漏和悬挂指针等内存安全问题。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096642909-heap-allocation-features.png&quot; alt=&quot;heap-allocation-features&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 7 - 堆内存的特性&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;因为堆上的内存是工程师手动申请的，所以需要在使用结束时释放，一旦用过的内存没有释放，就会造成内存泄漏，占用更多的系统内存；如果在使用结束前释放，会导致危险的悬挂指针，其他对象指向的内存已经被系统回收或者重新使用。虽然进程的内存可以划分成很多区域，但是当我们在谈内存管理时，一般指的都是堆内存的管理，也就是如何解决内存泄漏和悬挂指针的问题。&lt;/p&gt;&lt;h3 id=&quot;管理方式&quot;&gt;管理方式&lt;/h3&gt;&lt;p&gt;我们可以将内存管理简单地分成手动管理和自动管理两种方式，手动管理内存一般是指由工程师在需要时通过 &lt;code&gt;malloc&lt;/code&gt; 等函数手动申请内存并在不需要时调用 &lt;code&gt;free&lt;/code&gt; 等函数释放内存；自动管理内存由编程语言的内存管理系统自动管理，在大多数情况下不需要工程师的参与，能够自动释放不再使用的内存。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096642914-memory-management-approaches.png&quot; alt=&quot;memory-management-approaches&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 8 - 手动管理和自动管理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;手动管理和自动管理只是内存管理的两种不同方式，本节将分别介绍两种内存管理的方式以及不同编程语言做出的不同选择。&lt;/p&gt;&lt;h4 id=&quot;手动管理&quot;&gt;手动管理&lt;/h4&gt;&lt;p&gt;手动管理内存是一种比较传统的内存管理方式，C/C++ 这类系统级的编程语言不包含&lt;strong&gt;狭义上的&lt;/strong&gt;自动内存管理机制，工程师需要主动申请或者释放内存。如果存在理想的工程师能够精准地确定内存的分配和释放时机，人肉的内存管理策略只要做到足够精准，使用手动管理内存的方式可以提高程序的运行性能，也不会造成内存安全问题，&lt;/p&gt;&lt;p&gt;但是这种理想的工程师往往不存在于现实中，人类因素（Human Factor）总会带来一些错误，内存泄漏和悬挂指针基本是 C/C++ 这类语言中最常出现的错误，手动的内存管理也会占用工程师的大量精力，很多时候都需要思考对象应该分配到栈上还是堆上以及堆上的内存应该何时释放，维护成本相对来说还是比较高的，这也是必然要做的权衡。&lt;/p&gt;&lt;h4 id=&quot;自动管理&quot;&gt;自动管理&lt;/h4&gt;&lt;p&gt;自动管理内存基本是现代编程语言的标配，因为内存管理模块的功能非常确定，所以我们可以在编程语言的编译期或者运行时中引入自动的内存管理方式，最常见的自动内存管理机制就是垃圾回收，不过除了垃圾回收之外，一些编程语言也会使用自动引用计数辅助内存的管理。&lt;/p&gt;&lt;p&gt;自动的内存管理机制可以帮助工程师节省大量的与内存打交道的时间，让工程师将全部的精力都放在核心的业务逻辑上，提高开发的效率；在一般情况下，这种自动的内存管理机制都可以很好地解决内存泄漏和悬挂指针的问题，但是这也会带来额外开销并影响语言的运行时性能。&lt;/p&gt;&lt;h3 id=&quot;对象头&quot;&gt;对象头&lt;/h3&gt;&lt;p&gt;对象头是实现自动内存管理的关键元信息，内存分配器和垃圾收集器都会访问对象头以获取相关的信息。当我们通过 &lt;code&gt;malloc&lt;/code&gt; 等函数申请内存时，往往都需要将内存按照指针的大小对齐（32 位架构上为 4 字节，64 位架构上为 8 字节），除了用于对齐的内存之外，每一个堆上的对象也都需要对应的对象头：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096642919-object-header.png&quot; alt=&quot;object-header&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 9 - 对象头与对象&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;不同的自动内存管理机制会在对象头中存储不同的信息，使用垃圾回收的编程语言会存储标记位 &lt;code&gt;MarkBit&lt;/code&gt;/&lt;code&gt;MarkWord&lt;/code&gt;，例如：Java 和 Go 语言；使用自动引用计数的会在对象头中存储引用计数 &lt;code&gt;RefCount&lt;/code&gt;，例如：Objective-C。&lt;/p&gt;&lt;p&gt;编程语言会选择将对象头与对象存储在一起，不过因为对象头的存储可能影响数据访问的局部性，所以有些编程语言可能会单独开辟一片内存空间来存储对象头并通过内存地址建立两者之间的隐式联系。&lt;/p&gt;&lt;h2 id=&quot;内存分配&quot;&gt;内存分配&lt;/h2&gt;&lt;p&gt;内存分配器是内存管理系统中的重要组件，它的主要职责是处理用户程序的内存申请。虽然内存分配器的职责非常重要，但是&lt;strong&gt;内存的分配和使用其是一个增加系统中熵的过程&lt;/strong&gt;，所以内存分配器的设计与工作原理相对比较简单，我们在这里介绍内存分配器的两种类型。&lt;/p&gt;&lt;p&gt;内存分配器只包含线性内存分配器（Sequential Allocator）和空闲链表内存分配器（Free-list Allocator）两种，内存管理机制中的所有内存分配器其实都是上述两种不同分配器的变种，它们的设计思路完全不同，同时也有着截然不同的应用场景和特性，我们在这里依次介绍这两种内存分配器的原理。&lt;/p&gt;&lt;h3 id=&quot;线性分配器&quot;&gt;线性分配器&lt;/h3&gt;&lt;p&gt;线性分配（Bump Allocator）是一种高效的内存分配方法，但是有较大的局限性。当我们在编程语言中使用线性分配器，我们只需要在内存中维护一个指向内存特定位置的指针，当用户程序申请内存时，分配器只需要检查剩余的空闲内存、返回分配的内存区域并修改指针在内存中的位置，即移动下图中的指针：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096642924-bump-allocator.png&quot; alt=&quot;bump-allocator&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 10 - 线性分配器&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;根据线性分配器的原理，我们可以推测它有较快的执行速度，以及较低的实现复杂度；但是线性分配器无法在内存被释放时重用内存。如下图所示，如果已经分配的内存被回收，线性分配器是无法重新利用红色的这部分内存的：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096642930-bump-allocator-reclaim-memory.png&quot; alt=&quot;bump-allocator-reclaim-memory&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 11 - 线性分配器回收内存&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;正是因为线性分配器的这种特性，我们需要合适的垃圾回收算法配合使用。标记压缩（Mark-Compact）、复制回收（Copying GC）和分代回收（Generational GC）等算法可以通过拷贝的方式整理存活对象的碎片，将空闲内存定期合并，这样就能利用线性分配器的效率提升内存分配器的性能了。&lt;/p&gt;&lt;p&gt;因为线性分配器的使用需要配合具有拷贝特性的垃圾回收算法，所以 C 和 C++ 等需要直接对外暴露指针的语言就无法使用该策略，我们会在下一节详细介绍常见垃圾回收算法的设计原理。&lt;/p&gt;&lt;h3 id=&quot;空闲链表分配器&quot;&gt;空闲链表分配器&lt;/h3&gt;&lt;p&gt;空闲链表分配器（Free-List Allocator）可以重用已经被释放的内存，它在内部会维护一个类似链表的数据结构。当用户程序申请内存时，空闲链表分配器会依次遍历空闲的内存块，找到足够大的内存，然后申请新的资源并修改链表：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096642935-free-list-allocator.png&quot; alt=&quot;free-list-allocator&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 12 - 空闲链表分配器&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;因为不同的内存块以链表的方式连接，所以使用这种方式分配内存的分配器可以重新利用回收的资源，但是因为分配内存时需要遍历链表，所以它的时间复杂度就是 &lt;code&gt;O(n)&lt;/code&gt;。空闲链表分配器可以选择不同的策略在链表中的内存块中进行选择，最常见的就是以下四种方式：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;首次适应（First-Fit）— 从链表头开始遍历，选择第一个大小大于申请内存的内存块；&lt;/li&gt;&lt;li&gt;循环首次适应（Next-Fit）— 从上次遍历的结束位置开始遍历，选择第一个大小大于申请内存的内存块；&lt;/li&gt;&lt;li&gt;最优适应（Best-Fit）— 从链表头遍历整个链表，选择最合适的内存块；&lt;/li&gt;&lt;li&gt;隔离适应（Segregated-Fit）— 将内存分割成多个链表，每个链表中的内存块大小相同，申请内存时先找到满足条件的链表，再从链表中选择合适的内存块；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;上述四种策略的前三种就不过多介绍了，Go 语言使用的内存分配策略与第四种策略有些相似，我们通过下图了解一下该策略的原理：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096642956-segregated-list.png&quot; alt=&quot;segregated-list&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 13 - 隔离适应策略&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如上图所示，该策略会将内存分割成由 4、8、16、32 字节的内存块组成的链表，当我们向内存分配器申请 8 字节的内存时，我们会在上图中的第二个链表找到空闲的内存块并返回。隔离适应的分配策略减少了需要遍历的内存块数量，提高了内存分配的效率。&lt;/p&gt;&lt;h2 id=&quot;垃圾回收&quot;&gt;垃圾回收&lt;/h2&gt;&lt;p&gt;垃圾回收是一种自动的内存管理形式&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;，垃圾收集器是内存管理系统的重要组件，内存分配器会负责在堆上申请内存，而垃圾收集器会释放不再被用户程序使用的对象。谈到垃圾回收，很多人的第一反应可能都是暂停程序（stop-the-world、STW）和垃圾回收暂停（GC Pause），垃圾回收确实会带来 STW，但是这不是垃圾回收的全部，本节将详细介绍垃圾回收以及垃圾收集器的相关概念和理论。&lt;/p&gt;&lt;h3 id=&quot;什么是垃圾&quot;&gt;什么是垃圾&lt;/h3&gt;&lt;p&gt;在深入分析垃圾回收之前，我们需要先明确垃圾回收中垃圾的定义，明确定义能够帮助我们更精确地理解垃圾回收解决的问题以及它的职责。计算机科学中的垃圾包括对象、数据和计算机系统中的其他的内存区域，这些数据不会在未来的计算中使用，因为内存资源是有限的，所以我们需要将这些垃圾占用的内存交还回堆并在未来复用&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096642964-garbages.png&quot; alt=&quot;garbages&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 14 - 语义和语法垃圾&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;垃圾可以分成语义垃圾和语法垃圾两种，*语义垃圾（Semantic Garbage）*是计算机程序中永远不会被程序访问到的对象或者数据；*语法垃圾（Syntactic Garbage）*是计算机程序内存空间中从根对象无法达到（Unreachable）的对象或者数据。&lt;/p&gt;&lt;p&gt;语义垃圾是&lt;strong&gt;不会被使用的&lt;/strong&gt;的对象，可能包括废弃的内存、不使用的变量，垃圾收集器无法解决程序中语义垃圾的问题，我们需要通过编译器来一部分语义垃圾。语法垃圾是在对象图中&lt;strong&gt;不能从根节点达到的&lt;/strong&gt;对象，所以语法垃圾在一般情况下都是语义垃圾：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096642969-syntactic-garbage.png&quot; alt=&quot;syntactic-garbage&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 15 - 无法达到的语法垃圾&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;垃圾收集器能够发现并回收的就是对象图中无法达到的语法垃圾，通过分析对象之间的引用关系，我们可以得到图中根节点不可达的对象，这些不可达的对象会在垃圾收集器的清理阶段被回收。&lt;/p&gt;&lt;h3 id=&quot;收集器性能&quot;&gt;收集器性能&lt;/h3&gt;&lt;p&gt;吞吐量（Throughput）和最大暂停时间（Pause time）是两个衡量垃圾收集器的主要指标，除了这两个指标之外，堆内存的使用效率和访问的局部性也是垃圾收集的常用指标，我们简单介绍以下这些指标对垃圾收集器的影响。&lt;/p&gt;&lt;h4 id=&quot;吞吐量&quot;&gt;吞吐量&lt;/h4&gt;&lt;p&gt;垃圾收集器的吞吐量其实有两种解释，一种解释是垃圾收集器在执行阶段的速度，也就是单位时间的标记和清理内存的能力，我们可以用堆内存除以 GC 使用的总时间来计算。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;HEAP_SIZE&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;TOTAL_GC_TIME&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另一种吞吐量计算方法是使用程序运行的总时间除以所有 GC 循环运行的总时间，GC 的时间对于整个应用程序来说是额外开销，这个指标能看出额外开销占用资源的百分比，从这一点，我们也能看出 GC 的执行效率。&lt;/p&gt;&lt;h4 id=&quot;最大暂停时间&quot;&gt;最大暂停时间&lt;/h4&gt;&lt;p&gt;由于在垃圾回收的某些阶段会触发 STW，所以用户程序是不能执行的，最长的 STW 时间会严重影响程序处理请求或者提供服务的尾延迟，所以这一点也是我们在测量垃圾收集器性能时需要考虑的指标。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096642974-maximum-gc-pause.png&quot; alt=&quot;maximum-gc-pause&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 16 - 最大暂停时间&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;使用 STW 垃圾收集器的编程语言，用户程序在垃圾回收的全部阶段都不能执行。并发标记清除的垃圾收集器将可以与用户程序并发执行的工作全部并发执行，能够减少最大程序暂停时间，&lt;/p&gt;&lt;h4 id=&quot;堆使用效率&quot;&gt;堆使用效率&lt;/h4&gt;&lt;p&gt;堆的使用效率也是衡量垃圾收集器的重要指标。为了能够标识垃圾，我们需要在内存空间中引入包含特定信息的对象头，这些对象头都是垃圾收集器带来的额外开销，正如网络带宽可能不是最终的下载速度，协议头和校验码的传输会占用网络带宽，对象头的大小最终也会影响堆内存的使用效率；除了对象头之外，堆在使用过程中出现的碎片也会影响内存的使用效率，为了保证内存的对齐，我们会在内存中留下很多缝隙，这些缝隙也是内存管理带来的开销。&lt;/p&gt;&lt;h4 id=&quot;访问局部性&quot;&gt;访问局部性&lt;/h4&gt;&lt;p&gt;访问的局部性是我们在讨论内存管理时不得不谈的话题，空间的局部性是指处理器在短时间内总会重复地访问同一片或者相邻的内存区域，操作系统会以内存页为单位管理内存空间，在理想情况下，合理的内存布局可以使得垃圾收集器和应用程序都能充分地利用空间局部性提高程序的执行效率。&lt;/p&gt;&lt;h3 id=&quot;收集器类型&quot;&gt;收集器类型&lt;/h3&gt;&lt;p&gt;垃圾收集器的类型在总体上可以分成直接（Direct）垃圾收集器和跟踪（Tracing）垃圾收集器。直接垃圾收集器包括引用计数（Refernce-Counting），跟踪垃圾收集器包含标记清理、标记压缩、复制垃圾回收等策略，而引用计数收集器却不是特别常见，少数编程语言会使用这种方式管理内存。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096642979-garbage-collector-types.png&quot; alt=&quot;garbage-collector-types&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 17 - 垃圾收集器类型&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;除了直接和跟踪垃圾收集器这些相对常见的垃圾回收方法之外，也有使用所有权或者手动的方式管理内存，我们在本节中会介绍引用计数、标记清除、标记压缩和复制垃圾回收四种不同类型垃圾收集器的设计原理以及它们的优缺点。&lt;/p&gt;&lt;h4 id=&quot;引用计数&quot;&gt;引用计数&lt;/h4&gt;&lt;p&gt;基于引用计数的垃圾收集器是直接垃圾收集器，当我们改变对象之间的引用关系时会修改对象之间的引用计数，每个对象的引用计数都记录了当前有多少个对象指向了该对象，当对象的引用计数归零时，当前对象就会被自动释放。在使用引用计数的编程语言中，垃圾收集是在用户程序运行期间实时发生的，所以在理论上也就不存在 STW 或者明显地垃圾回收暂停。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096642985-reference-counting.png&quot; alt=&quot;reference-counting&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 18 - 对象的引用计数&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如上图所示，基于引用计数的垃圾收集器需要应用程序在对象头中存储引用计数，引用计数就是该类型的收集器在内存中引入的额外开销。我们在这里举一个例子介绍引用计数的工作原理，如果在使用引用计数回收器的编程语言中使用如下所示赋值语句时：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;对象 &lt;code&gt;obj&lt;/code&gt; 原来引用的对象 &lt;code&gt;old_ref&lt;/code&gt; 的引用计数会&lt;strong&gt;减一&lt;/strong&gt;；&lt;/li&gt;&lt;li&gt;对象 &lt;code&gt;obj&lt;/code&gt; 引用的新对象 &lt;code&gt;new_ref&lt;/code&gt; 的引用计数会&lt;strong&gt;加一&lt;/strong&gt;；&lt;/li&gt;&lt;li&gt;如果 &lt;code&gt;old_ref&lt;/code&gt; 对象的引用计数归零，我们会释放该对象回收它的内存；&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这种类型的垃圾收集器会带来两个比较常见的问题，分别是递归的对象回收和循环引用：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;递归回收 — 每当对象的引用关系发生改变时，我们都需要计算对象的新引用计数，一旦对象被释放，我们就需要递归地访问所有该对象的引用并将被引用对象的计数器减一，一旦涉及到较多的对象就可能会造成 GC 暂停；&lt;/li&gt;&lt;li&gt;循环引用 — 对象的相互引用在对象图中也非常常见，如果对象之间的引用都是强引用，循环引用会导致多个对象的计数器都不会归零，最终会造成内存泄漏；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;递归回收是使用引用计数时不得不面对的问题，我们很难在工程上解决该问题；不过使用引用计数的编程语言却可以利用弱引用来解决循环引用的问题，弱引用也是对象之间的引用关系，&lt;strong&gt;建立和销毁弱引用关系都不会修改双方的引用计数&lt;/strong&gt;，这就能避免对象之间的弱引用关系，不过这也需要工程师对引用关系作出额外的并且正确的判断。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096642990-strong-and-weak-reference.png&quot; alt=&quot;strong-and-weak-reference&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 19 - 强引用与弱引用&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;除了弱引用之外，一些编程语言也会在引用计数的基础上加入标记清除技术，通过遍历和标记堆中不再被使用的对象解决循环引用的问题。&lt;/p&gt;&lt;p&gt;引用计数垃圾收集器是一种非移动（Non-moving）的垃圾回收策略，它在回收内存的过程中不会移动已有的对象，很多编程语言都会对工程师直接暴露内存的指针，所以 C、C++ 以及 Objective-C 等编程语言其实都可以使用引用计数来解决内存管理的问题。&lt;/p&gt;&lt;h4 id=&quot;标记清除&quot;&gt;标记清除&lt;/h4&gt;&lt;p&gt;标记清除（Mark-Sweep）是最简单也最常见的垃圾收集策略，它的执行过程可以分成&lt;strong&gt;标记&lt;/strong&gt;和&lt;strong&gt;清除&lt;/strong&gt;两个阶段，标记阶段会使用深度优先或者广度优先算法扫描堆中的存活对象，而清除阶段会回收内存中的垃圾。当我们使用该策略回收垃圾时，它会首先从根节点出发沿着对象的引用遍历堆中的全部对象，能够被访问到的对象是存活的对象，不能被访问到的对象就是内存中的垃圾。&lt;/p&gt;&lt;p&gt;如下图所示，内存空间中包含多个对象，我们从根对象出发依次遍历对象的子对象并将从根节点可达的对象都标记成存活状态，即 A、C 和 D 三个对象，剩余的 B、E 和 F 三个对象因为从根节点不可达，所以会被当做垃圾：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096642995-mark-sweep-mark-phase.png&quot; alt=&quot;mark-sweep-mark-phase&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 20 - 标记清除的标记阶段&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;标记阶段结束后会进入清除阶段，在该阶段中收集器会依次遍历堆中的所有对象，释放其中没有被标记的 B、E 和 F 三个对象并将新的空闲内存空间以链表的结构串联起来，方便内存分配器的使用。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096643000-mark-sweep-sweep-phase.png&quot; alt=&quot;mark-sweep-sweep-phase&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 21 - 标记清除的收集阶段&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;使用标记清除算法的编程语言需要在对象头中加入表示对象存活的标记位（Mark Bit），标记位与操作系统的写时复制不兼容，因为即使内存页中的对象没有被修改，垃圾收集器也会修改内存页中对象相邻的标记位导致内存页的复制。我们可以使用位图（Bitmap）标记避免这种情况，表示对象存活的标记与对象分别存储，清理对象时也只需要遍历位图，能够降低清理过程的额外开销。&lt;/p&gt;&lt;p&gt;如上图所示，使用标记清除算法的垃圾收集器一般会使用基于空闲链表的分配器，因为对象在不被使用时会被就地回收，所以长时间运行的程序会出现很多内存碎片，这会降低内存分配器的分配效率，在实现上我们可以将空闲链表按照对象大小分成不同的区以减少内存中的碎片。&lt;/p&gt;&lt;p&gt;标记清除策略是一种实现简单的垃圾收集策略，但是它的内存碎片化问题也比较严重，简单的内存回收策略也增加了内存分配的开销和复杂度，当用户程序申请内存时，我们也需要在内存中找到足够大的块分配内存。&lt;/p&gt;&lt;h4 id=&quot;标记压缩&quot;&gt;标记压缩&lt;/h4&gt;&lt;p&gt;标记压缩（Mark-Compact）也是比较常见的垃圾收集算法，与标记清除算法类似，标记压缩的执行过程可以分成&lt;strong&gt;标记&lt;/strong&gt;和&lt;strong&gt;压缩&lt;/strong&gt;两个阶段。该算法在标记阶段也会从根节点遍历对象，查找并标记所有存活的对象；在压缩阶段，我们会将所有存活的对象紧密排列，『挤出』存活对象之间的缝隙：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096643006-mark-compact.png&quot; alt=&quot;mark-compact&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 22 - 标记压缩算法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;因为在压缩阶段我们需要移动存活的对象，所以这一种 moving 收集器，如果编程语言支持使用指针访问对象，那么我们就无法使用该算法。标记的过程相对比较简单，我们在这里以 Lisp 2 压缩算法为例重点介绍该算法的压缩阶段：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;计算当前对象迁移后的最终位置并将位置存储在转发地址（Forwarding Address）中；&lt;/li&gt;&lt;li&gt;根据当前对象子对象的转发地址，将引用指向新的位置；&lt;/li&gt;&lt;li&gt;将所有存活的对象移动到对象头中转发地址的位置；&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;从上述过程我们可以看出，使用标记压缩算法的编程语言不仅要在对象头中存储标记位，还需要存储当前对象的转发地址，这增加了对象在内存中的额外开销。&lt;/p&gt;&lt;p&gt;标记压缩算法的实现比较复杂，在执行的过程中需要遍历三次堆中的对象，作为 moving 的垃圾收集器，它不适用于 C、C++ 等编程语言；压缩算法的引入可以减少程序中的内存碎片，我们可以直接使用最简单的线性分配器为用户程序快速分配内存。&lt;/p&gt;&lt;h4 id=&quot;复制垃圾回收&quot;&gt;复制垃圾回收&lt;/h4&gt;&lt;p&gt;复制垃圾回收（Copying GC）也是跟踪垃圾收集器的一种，它会将应用程序的堆分成两个大小相等的区域，如下图所示，其中左侧区域负责为用户程序分配内存空间，而右侧区域用于垃圾回收。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096643011-copying-gc.png&quot; alt=&quot;copying-gc&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 23 - 复制垃圾回收&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当用户程序使用的内存超过上图中的左侧区域就会出现内存不足（Out-of memory、OOM），垃圾收集器在这时会开启新的垃圾收集循环，复制垃圾回收的执行过程可以非常以下的四个阶段：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;复制阶段 — 从 GC 根节点出发遍历内存中的对象，将发现的存活对象迁移到右侧的内存中；&lt;/li&gt;&lt;li&gt;转发阶段 — 在原始对象的对象头或者在原位置设置新对象的转发地址（Forwarding Address），如果其他对象引用了该对象可以从转发地址转到新的地址；&lt;/li&gt;&lt;li&gt;修复指针 — 遍历当前对象持有的引用，如果引用指向了左侧堆中的对象，回到第一步迁移发现的新对象；&lt;/li&gt;&lt;li&gt;交换阶段 — 当内存中不存在需要迁移的对象之后，交换左右两侧的内存区域；&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096643016-copying-gc-copy-phase.png&quot; alt=&quot;copying-gc-copy-phase&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 24 - 复制垃圾回收的复制阶段&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如上图所示，当我们把 A 对象复制到右侧的区域后，会将原始的 A 对象指向新的 A 对象，这样其他引用 A 的对象可以快速找到它的新地址；因为 A 对象的复制是『像素级复制』，所以 A 对象仍然会指向左侧内存的 C 对象，这时需要将 C 对象复制到新的内存区域并修改 A 对象的指针。在最后，当不存在需要拷贝的对象时，我们可以直接交换两个内存区域的指针。&lt;/p&gt;&lt;p&gt;复制垃圾回收与标记压缩算法一样都会拷贝对象，能够减少程序中的内存碎片，我们可以使用线性的分配器快速为用户程序分配内存。因为只需要扫描一半的堆，遍历堆的次数也会减少，所以可以减少垃圾回收的时间，但是这也会降低内存的利用率。&lt;/p&gt;&lt;h2 id=&quot;高级垃圾回收&quot;&gt;高级垃圾回收&lt;/h2&gt;&lt;p&gt;内存管理是一个相对比较大的话题，我们在上一小节介绍了垃圾回收的一些基本概念，其中包括常见的垃圾回收算法：引用计数、标记清除、标记压缩和复制垃圾回收，这些算法都是比较基本的垃圾回收算法，我们在这一节中将详细介绍一些高级的垃圾回收算法，它们会利用基本的垃圾回收算法和新的数据结构构建更复杂的收集器。&lt;/p&gt;&lt;h3 id=&quot;分代垃圾收集器&quot;&gt;分代垃圾收集器&lt;/h3&gt;&lt;p&gt;分代垃圾回收（Generational garbage collection）是在生产环境中比较常见的垃圾收集算法，该算法主要建立在弱分代假设（Weak Generational Hypothesis）上 —— 大多数的对象会在生成后马上变成垃圾，只有极少数的对象可以存活很久&lt;sup id=&quot;fnref:5&quot;&gt;&lt;a href=&quot;#fn:5&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;。根据该经验，分代垃圾回收会把堆中的对象分成多个代，不同代垃圾回收的触发条件和算法都完全不同。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096643030-young-and-old-generation.png&quot; alt=&quot;young-and-old-generation&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 25 - 青年代和老年代&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;常见的分代垃圾回收会将堆分成青年代（Young、Eden）和老年代（Old、Tenured），所有的对象在刚刚初始化时都会进入青年代，而青年代触发 GC 的频率也更高；而老年代的对象 GC 频率相对比较低，只有青年代的对象经过多轮 GC 没有被释放才可能被晋升（Promotion）到老年代，晋升的过程与复制垃圾回收算法的执行过程相差无几。&lt;/p&gt;&lt;p&gt;青年代的垃圾回收被称作是 Minor GC 循环，而老年代的垃圾回收被称作 Major GC 循环，Full GC 循环一般是指整个堆的垃圾回收，需要注意的是很多时候我们都会混淆 Major GC 循环和 Full GC 循环，在讨论时一定要先搞清楚双方对这些名词的理解是否一致。&lt;/p&gt;&lt;p&gt;青年代的垃圾回收只会扫描整个堆的一部分，这能够减少一次垃圾回收需要的扫描的堆大小和程序的暂停时间，提高垃圾回收的吞吐量。然而分代也为垃圾回收引入了复杂度，其中最常见的问题是&lt;em&gt;跨代引用（Intergenerational Pointer）&lt;/em&gt;，即老年代引用了青年代的对象，如果堆中存在跨代引用，那么在 Minor GC 循环中我们不仅应该遍历垃圾回收的根对象，还需要从包含跨代引用的对象出发标记青年代中的对象。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096643036-intergenerational-pointer.png&quot; alt=&quot;intergenerational-pointer&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 26 - 跨代引用&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;为了处理分代垃圾回收的跨代引用，我们需要解决两个问题，分别是如何&lt;strong&gt;识别&lt;/strong&gt;堆中的跨代引用以及如何&lt;strong&gt;存储&lt;/strong&gt;识别的跨代引用，在通常情况下我们会使用*写屏障（Write Barrier）&lt;em&gt;识别跨代引用并使用&lt;/em&gt;卡表（Card Table）*存储相关的数据。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;注意：卡表只是标记或者存储跨代引用的一种方式，除了卡表我们也可以使用记录集（Record Set）存储跨代引用的老年代对象或者使用页面标记按照操作系统内存页的维度标记老年代的对象。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;写屏障是当对象之间的指针发生改变时调用的代码片段，这段代码会判断该指针是不是从老年代对象指向青年代对象的跨代引用。如果该指针是跨代引用，我们会在如下所示的卡表中标记老年代对象所在的区域：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096643041-card-table.png&quot; alt=&quot;card-table&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 27 - 卡表&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;卡表与位图比较相似，它也由一系列的比特位组成，其中每一个比特位都对应着老年区中的一块内存，如果该内存中的对象存在指向青年代对象的指针，那么这块内存在卡表中就会被标记，当触发 Minor GC 循环时，除了从根对象遍历青年代堆之外，我们还会从卡表标记区域内的全部老年代对象开始遍历青年代。&lt;/p&gt;&lt;p&gt;分代垃圾回收基于弱分代假说，结合了复制垃圾回收、写屏障以及卡表等技术，将内存中的堆区分割成了青年代和老年代等区域，为不同的代使用不同的内存分配和垃圾回收算法，可以有效地减少 GC 循环遍历的堆大小和处理时间，但是写屏障技术也会带了额外开销，移动收集器的特性也使它无法在 C、C++ 等编程语言中使用，在部分场景下弱分代假说不一定会成立，如果大多数的对象都会活得很久，那么使用分代垃圾回收可能会起到反效果。&lt;/p&gt;&lt;h3 id=&quot;标记区域收集器&quot;&gt;标记区域收集器&lt;/h3&gt;&lt;p&gt;标记区域收集器（Mark-Region Garbage Collector）是 2008 年提出的垃圾收集算法&lt;sup id=&quot;fnref:6&quot;&gt;&lt;a href=&quot;#fn:6&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;，这个算法也被称作混合垃圾回收（Immix GC），它结合了标记清除和复制垃圾回收算法，我们使用前者来追踪堆中的存活对象，使用后者减少内存中存在的碎片。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096643047-mark-region-garbage-collector.png&quot; alt=&quot;mark-region-garbage-collector&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 28 - 标记区域收集器&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Immix 垃圾回收算法包含两个组件，分别是用于标记区域的收集器和去碎片化机制&lt;sup id=&quot;fnref:7&quot;&gt;&lt;a href=&quot;#fn:7&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;。标记区域收集器与标记清除收集器比较类似，它将堆内存拆分成特定大小的内存块，再将所有的内存块拆分成特定大小的线。当用户程序申请内存时，它会在上述内存块中查找空闲的线并使用线性分配器快速分配内存；通过引入粗粒度的内存块和细粒度的线，可以更好地控制内存的分配和释放。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096643052-sequential-allocator-cursor.png&quot; alt=&quot;sequential-allocator-cursor&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 29 - 线性分配器的光标&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;标记区域收集器与标记清除收集器比较类似，因为它们不会移动对象，所以都会面临内存碎片化的问题。如下图所示，标记区域收集器在回收内存时都是以块和线为单位进行回收的，所以只要当前内存线中包含存活对象，收集器就会保留该片内存区域，这会带来我们在上面提到的内存碎片。&lt;/p&gt;&lt;p&gt;Immix 引入的机会转移（Opportunistic Evacuation）机制能够有效地减少程序中的碎片化，当收集器在内存块中遇到可以被转移的对象，它就会使用复制垃圾回收算法将当前块中的存活对象移动到新的块中并释放原块中的内存。&lt;/p&gt;&lt;p&gt;标记区域收集器将堆内存分成了粗粒度的内存块和细粒度的内存线，结合了标记清除算法和复制垃圾回收几种基本垃圾收集器的特性，既能够提升垃圾收集器的吞吐量，还能够利用线性分配器提高内存的分配速度，但是该收集器的实现相对比较复杂。&lt;/p&gt;&lt;h3 id=&quot;增量并发收集器&quot;&gt;增量并发收集器&lt;/h3&gt;&lt;p&gt;相信很多人对垃圾收集器的印象都是暂停程序（Stop the world，STW），随着用户程序申请越来越多的内存，系统中的垃圾也逐渐增多；当程序的内存占用达到一定阈值时，整个应用程序就会全部暂停，垃圾收集器会扫描已经分配的所有对象并回收不再使用的内存空间，当这个过程结束后，用户程序才可以继续执行。&lt;/p&gt;&lt;p&gt;传统的垃圾收集算法会在垃圾收集的执行期间暂停应用程序，一旦触发垃圾收集，垃圾收集器就会抢占 CPU 的使用权占据大量的计算资源以完成标记和清除工作，然而很多追求实时的应用程序无法接受长时间的 STW。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096643058-stop-the-world-collector.png&quot; alt=&quot;stop-the-world-collector&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 30 - 垃圾收集与暂停程序&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;远古时代的计算资源还没有今天这么丰富，今天的计算机往往都是多核的处理器，垃圾收集器一旦开始执行就会浪费大量的计算资源，为了减少应用程序暂停的最长时间和垃圾收集的总暂停时间，我们会使用下面的策略优化现代的垃圾收集器：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;增量垃圾收集 — 增量地标记和清除垃圾，降低应用程序暂停的最长时间；&lt;/li&gt;&lt;li&gt;并发垃圾收集 — 利用多核的计算资源，在用户程序执行时并发标记和清除垃圾；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;因为增量和并发两种方式都可以与用户程序交替运行，所以我们需要&lt;strong&gt;使用屏障技术&lt;/strong&gt;保证垃圾收集的正确性；与此同时，应用程序也不能等到内存溢出时触发垃圾收集，因为当内存不足时，应用程序已经无法分配内存，这与直接暂停程序没有什么区别，增量和并发的垃圾收集需要提前触发并在内存不足前完成整个循环，避免程序的长时间暂停。&lt;/p&gt;&lt;p&gt;增量式（Incremental）的垃圾收集是减少程序最长暂停时间的一种方案，它可以将原本时间较长的暂停时间切分成多个更小的 GC 时间片，虽然从垃圾收集开始到结束的时间更长了，但是这也减少了应用程序暂停的最大时间：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096643063-incremental-collector.png&quot; alt=&quot;incremental-collector&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 31 - 增量垃圾收集器&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;需要注意的是，增量式的垃圾收集需要与三色标记法一起使用，为了保证垃圾收集的正确性，我们需要在垃圾收集开始前打开写屏障，这样用户程序对内存的修改都会先经过写屏障的处理，保证了堆内存中对象关系的强三色不变性或者弱三色不变性。虽然增量式的垃圾收集能够减少最大的程序暂停时间，但是增量式收集也会增加一次 GC 循环的总时间，在垃圾收集期间，因为写屏障的影响用户程序也需要承担额外的计算开销，所以增量式的垃圾收集也不是只有优点的。&lt;/p&gt;&lt;p&gt;并发（Concurrent）的垃圾收集不仅能够减少程序的最长暂停时间，还能减少整个垃圾收集阶段的时间，通过开启读写屏障、&lt;strong&gt;利用多核优势与用户程序并行执行&lt;/strong&gt;，并发垃圾收集器确实能够减少垃圾收集对应用程序的影响：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096643069-concurrent-collector.png&quot; alt=&quot;concurrent-collector&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 32 - 并发垃圾收集器&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;虽然并发收集器能够与用户程序一起运行，但是并不是所有阶段都可以与用户程序一起运行，部分阶段还是需要暂停用户程序的，不过与传统的算法相比，并发的垃圾收集可以将能够并发执行的工作尽量并发执行；当然，因为读写屏障的引入，并发的垃圾收集器也一定会带来额外开销，不仅会增加垃圾收集的总时间，还会影响用户程序，这是我们在设计垃圾收集策略时必须要注意的。&lt;/p&gt;&lt;p&gt;但是因为增量并发收集器的并发标记阶段会与用户程序一同或者交替运行，所以可能出现&lt;strong&gt;标记为垃圾的对象被用户程序中的其他对象重新引用&lt;/strong&gt;，当垃圾回收的标记阶段结束后，被错误标记为垃圾的对象会被直接回收，这就会带来非常严重的问题，想要解决增量并发收集器的这个问题，我们需要了解三色抽象和屏障技术。&lt;/p&gt;&lt;h4 id=&quot;三色抽象&quot;&gt;三色抽象&lt;/h4&gt;&lt;p&gt;为了解决原始标记清除算法带来的长时间 STW，多数现代的追踪式垃圾收集器都会实现三色标记算法的变种以缩短 STW 的时间。三色标记算法将程序中的对象分成白色、黑色和灰色三类&lt;sup id=&quot;fnref:8&quot;&gt;&lt;a href=&quot;#fn:8&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;8&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;白色对象 — 潜在的垃圾，其内存可能会被垃圾收集器回收；&lt;/li&gt;&lt;li&gt;黑色对象 — 活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象；&lt;/li&gt;&lt;li&gt;灰色对象 — 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096643074-tri-color-objects.png&quot; alt=&quot;tri-color-objects&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 33 - 三色的对象&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在垃圾收集器开始工作时，程序中不存在任何的黑色对象，垃圾收集的根对象会被标记成灰色，垃圾收集器只会从灰色对象集合中取出对象开始扫描，当灰色集合中不存在任何对象时，标记阶段就会结束。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096643079-tri-color-mark-sweep.png&quot; alt=&quot;tri-color-mark-sweep&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 34 - 三色标记垃圾收集器的执行过程&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;三色标记垃圾收集器的工作原理很简单，我们可以将其归纳成以下几个步骤：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;从灰色对象的集合中选择一个灰色对象并将其标记成黑色；&lt;/li&gt;&lt;li&gt;将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收；&lt;/li&gt;&lt;li&gt;重复上述两个步骤直到对象图中不存在灰色对象；&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;当三色的标记清除的标记阶段结束之后，应用程序的堆中就不存在任何的灰色对象，我们只能看到黑色的存活对象以及白色的垃圾对象，垃圾收集器可以回收这些白色的垃圾，下面是使用三色标记垃圾收集器执行标记后的堆内存，堆中只有对象 D 为待回收的垃圾：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096643085-tri-color-mark-sweep-after-mark-phase.png&quot; alt=&quot;tri-color-mark-sweep-after-mark-phase&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 35 - 三色标记后的堆&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;因为用户程序可能在标记执行的过程中修改对象的指针，所以三色标记清除算法本身是不可以并发或者增量执行的，它仍然需要 STW，在如下所示的三色标记过程中，用户程序建立了从 A 对象到 D 对象的引用，但是因为程序中已经不存在灰色对象了，所以 D 对象会被垃圾收集器错误地回收。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096643090-tri-color-mark-sweep-and-mutator.png&quot; alt=&quot;tri-color-mark-sweep-and-mutator&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 36 - 三色标记与用户程序&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;本来不应该被回收的对象却被回收了，这在内存管理中是非常严重的错误，我们将这种错误成为悬挂指针，即指针没有指向特定类型的合法对象，影响了内存的安全性&lt;sup id=&quot;fnref:9&quot;&gt;&lt;a href=&quot;#fn:9&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;9&lt;/a&gt;&lt;/sup&gt;，想要并发或者增量地标记对象还是需要使用屏障技术。&lt;/p&gt;&lt;h4 id=&quot;垃圾回收屏障&quot;&gt;垃圾回收屏障&lt;/h4&gt;&lt;p&gt;内存屏障技术是一种屏障指令，它可以让 CPU 或者编译器在执行内存相关操作时遵循特定的约束，目前的多数的现代处理器都会乱序执行指令以最大化性能，但是该技术能够保证代码对内存操作的顺序性，在内存屏障前执行的操作一定会先于内存屏障后执行的操作&lt;sup id=&quot;fnref:10&quot;&gt;&lt;a href=&quot;#fn:10&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;10&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的任意一种：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；&lt;/li&gt;&lt;li&gt;弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径&lt;sup id=&quot;fnref:11&quot;&gt;&lt;a href=&quot;#fn:11&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;11&lt;/a&gt;&lt;/sup&gt;；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096643096-strong-weak-tricolor-invariant.png&quot; alt=&quot;strong-weak-tricolor-invariant&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 37 - 三色不变性&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;上图分别展示了遵循强三色不变性和弱三色不变性的堆内存，遵循上述两个不变性中的任意一个，我们都能保证垃圾收集算法的正确性，而屏障技术就是在并发或者增量标记过程中保证三色不变性的重要技术。&lt;/p&gt;&lt;p&gt;垃圾收集中的屏障技术更像是一个钩子方法，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以将它们分成读屏障（Read barrier）和写屏障（Write barrier）两种，因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以编程语言往往都会采用写屏障保证三色不变性。&lt;/p&gt;&lt;p&gt;我们在这里想要介绍的是以下几种写屏障技术，分别是 Dijkstra 提出的插入写屏障&lt;sup id=&quot;fnref:12&quot;&gt;&lt;a href=&quot;#fn:12&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;12&lt;/a&gt;&lt;/sup&gt;和 Yuasa 提出的删除写屏障&lt;sup id=&quot;fnref:13&quot;&gt;&lt;a href=&quot;#fn:13&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;13&lt;/a&gt;&lt;/sup&gt;，这里会分析它们如何保证三色不变性和垃圾收集器的正确性。&lt;/p&gt;&lt;h5 id=&quot;插入写屏障&quot;&gt;插入写屏障&lt;/h5&gt;&lt;p&gt;Dijkstra 在 1978 年提出了插入写屏障，通过如下所示的写屏障，用户程序和垃圾收集器可以在交替工作的情况下保证程序执行的正确性：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;writePointer&lt;/span&gt;(&lt;span&gt;slot&lt;/span&gt;, &lt;span&gt;ptr&lt;/span&gt;):
    &lt;span&gt;shade&lt;/span&gt;(&lt;span&gt;ptr&lt;/span&gt;)
    &lt;span&gt;*&lt;/span&gt;&lt;span&gt;field&lt;/span&gt; = &lt;span&gt;ptr&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述插入写屏障的伪代码非常好理解，每当我们执行类似 &lt;code&gt;*slot = ptr&lt;/code&gt; 的表达式时，我们会执行上述写屏障通过 &lt;code&gt;shade&lt;/code&gt; 函数尝试改变指针的颜色。如果 &lt;code&gt;ptr&lt;/code&gt; 指针是白色的，那么该函数会将该对象设置成灰色，其他情况则保持不变。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096643101-dijkstra-insert-write-barrier.png&quot; alt=&quot;dijkstra-insert-write-barrier&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 38 - Dijkstra 插入写屏障&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;假设我们在应用程序中使用 Dijkstra 提出的插入写屏障，在一个垃圾收集器和用户程序交替运行的场景中会出现如上图所示的标记过程：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;垃圾收集器将根对象指向 A 对象标记成黑色并将 A 对象指向的对象 B 标记成灰色；&lt;/li&gt;&lt;li&gt;用户程序修改 A 对象的指针，将原本指向 B 对象的指针指向 C 对象，这时触发写屏障将 C 对象标记成灰色；&lt;/li&gt;&lt;li&gt;垃圾收集器依次遍历程序中的其他灰色对象，将它们分别标记成黑色；&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Dijkstra 的插入写屏障是一种相对保守的屏障技术，它会将&lt;strong&gt;有存活可能的对象都标记成灰色&lt;/strong&gt;以满足强三色不变性。在如上所示的垃圾收集过程中，实际上不再存活的 B 对象最后没有被回收；而如果我们在第二和第三步之间将指向 C 对象的指针改回指向 B，垃圾收集器仍然认为 C 对象是存活的，这些被错误标记的垃圾对象只有在下一个循环才会被回收。&lt;/p&gt;&lt;p&gt;插入式的 Dijkstra 写屏障虽然实现非常简单并且也能保证强三色不变性，但是它也有很明显的缺点。因为栈上的对象在垃圾收集中也会被认为是根对象，所以为了保证内存的安全，Dijkstra 必须为栈上的对象增加写屏障或者在标记阶段完成重新对栈上的对象对象进行扫描，这两种方法各有各的缺点，前者会大幅度增加写入指针的额外开销，后者重新扫描栈对象时需要暂停程序，垃圾收集算法的设计者需要在这两者之前做出权衡。&lt;/p&gt;&lt;h5 id=&quot;删除写屏障&quot;&gt;删除写屏障&lt;/h5&gt;&lt;p&gt;Yuasa 在 1990 年的论文 Real-time garbage collection on general-purpose machines 中提出了删除写屏障，因为一旦该写屏障开始工作，它就会保证开启写屏障时堆上所有对象的可达，所以也被称作快照垃圾收集（Snapshot GC）&lt;sup id=&quot;fnref:14&quot;&gt;&lt;a href=&quot;#fn:14&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;14&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;This guarantees that no objects will become unreachable to the garbage collector traversal all objects which are live at the beginning of garbage collection will be reached even if the pointers to them are overwritten.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;该算法会使用如下所示的写屏障保证增量或者并发执行垃圾收集时程序的正确性：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;writePointer&lt;/span&gt;(&lt;span&gt;slot&lt;/span&gt;, &lt;span&gt;ptr&lt;/span&gt;)
    &lt;span&gt;shade&lt;/span&gt;(&lt;span&gt;*&lt;/span&gt;&lt;span&gt;slot&lt;/span&gt;)
    &lt;span&gt;*&lt;/span&gt;&lt;span&gt;slot&lt;/span&gt; = &lt;span&gt;ptr&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述代码会在老对象的引用被删除时，将白色的老对象涂成灰色，这样删除写屏障就可以保证弱三色不变性，老对象引用的下游对象一定可以被灰色对象引用。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2021-02-28-16145096643107-yuasa-delete-write-barrier.png&quot; alt=&quot;yuasa-delete-write-barrier&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 39 - Yuasa 删除写屏障&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;假设我们在应用程序中使用 Yuasa 提出的删除写屏障，在一个垃圾收集器和用户程序交替运行的场景中会出现如上图所示的标记过程：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;垃圾收集器将根对象指向 A 对象标记成黑色并将 A 对象指向的对象 B 标记成灰色；&lt;/li&gt;&lt;li&gt;用户程序将 A 对象原本指向 B 的指针指向 C，触发删除写屏障，但是因为 B 对象已经是灰色的，所以不做改变；&lt;/li&gt;&lt;li&gt;&lt;strong&gt;用户程序将 B 对象原本指向 C 的指针删除，触发删除写屏障，白色的 C 对象被涂成灰色&lt;/strong&gt;；&lt;/li&gt;&lt;li&gt;垃圾收集器依次遍历程序中的其他灰色对象，将它们分别标记成黑色；&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;上述过程中的第三步触发了 Yuasa 删除写屏障的着色，因为用户程序删除了 B 指向 C 对象的指针，所以 C 和 D 两个对象会分别违反强三色不变性和弱三色不变性：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;强三色不变性 — 黑色的 A 对象直接指向白色的 C 对象；&lt;/li&gt;&lt;li&gt;弱三色不变性 — 垃圾收集器无法从某个灰色对象出发，经过几个连续的白色对象访问白色的 C 和 D 两个对象；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Yuasa 删除写屏障通过对 C 对象的着色，保证了 C 对象和下游的 D 对象能够在这一次垃圾收集的循环中存活，避免发生悬挂指针以保证用户程序的正确性。&lt;/p&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;&lt;p&gt;内存管理在今天仍然是十分重要的话题，当我们在讨论编程语言的性能和便利程度时，内存管理机制都是绕不开的。编程语言在设计内存管理机制时，往往需要在手动管理和自动管理之间进行抉择，现代的大多数编程语言为了减少工程师的负担，多数都会选择使用垃圾回收的方式自动管理内存，但是也有少数编程语言通过手动管理追求极致的性能。&lt;/p&gt;&lt;p&gt;想要在一篇文章中详尽展示内存管理的方方面面是不可能的，我们可能需要一本书或者几本书的厚度才能详细地展示内存管理的相关技术，这里更多侧重的还是垃圾回收，Rust 的所有权、生命周期以及 C++ 的智能指针等机制在文章中都没有提及，感兴趣的读者可以自行了解。&lt;/p&gt;&lt;section class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Wikipedia: Static variable &lt;a href=&quot;https://en.wikipedia.org/wiki/Static_variable&quot;&gt;https://en.wikipedia.org/wiki/Static_variable&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Wikipedia: Stack-based memory allocation &lt;a href=&quot;https://en.wikipedia.org/wiki/Stack-based_memory_allocation&quot;&gt;https://en.wikipedia.org/wiki/Stack-based_memory_allocation&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Wikipedia: Garbage collection (computer science) &lt;a href=&quot;https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)&quot;&gt;https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)&lt;/a&gt; &lt;a href=&quot;#fnref:3&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:4&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Wikipedia: Garbage (computer science) &lt;a href=&quot;https://en.wikipedia.org/wiki/Garbage_(computer_science)&quot;&gt;https://en.wikipedia.org/wiki/Garbage_(computer_science)&lt;/a&gt; &lt;a href=&quot;#fnref:4&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:5&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Garbage Collection in Java (1) - Heap Overview &lt;a href=&quot;http://insightfullogic.com/2013/Feb/20/garbage-collection-java-1/&quot;&gt;http://insightfullogic.com/2013/Feb/20/garbage-collection-java-1/&lt;/a&gt; &lt;a href=&quot;#fnref:5&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:6&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Immix: A Mark-Region Garbage Collector with Space Efficiency, Fast Collection, and Mutator Performance. Stephen M. Blackburn. Kathryn S. McKinley. 2008. &lt;a href=&quot;http://www.cs.utexas.edu/users/speedway/DaCapo/papers/immix-pldi-2008.pdf&quot;&gt;http://www.cs.utexas.edu/users/speedway/DaCapo/papers/immix-pldi-2008.pdf&lt;/a&gt; &lt;a href=&quot;#fnref:6&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:7&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;The CS 6120 Course Blog. Siqiu Yao. 2019. &lt;a href=&quot;https://www.cs.cornell.edu/courses/cs6120/2019fa/blog/immix/&quot;&gt;https://www.cs.cornell.edu/courses/cs6120/2019fa/blog/immix/&lt;/a&gt; &lt;a href=&quot;#fnref:7&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:8&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;“Tri-color marking” &lt;a href=&quot;https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking&quot;&gt;https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking&lt;/a&gt; &lt;a href=&quot;#fnref:8&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:9&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;“Dangling pointer” &lt;a href=&quot;https://en.wikipedia.org/wiki/Dangling_pointer&quot;&gt;https://en.wikipedia.org/wiki/Dangling_pointer&lt;/a&gt; &lt;a href=&quot;#fnref:9&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:10&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;“Wikpedia: Memory barrier” &lt;a href=&quot;https://en.wikipedia.org/wiki/Memory_barrier&quot;&gt;https://en.wikipedia.org/wiki/Memory_barrier&lt;/a&gt; &lt;a href=&quot;#fnref:10&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:11&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;P. P. Pirinen. Barrier techniques for incremental tracing. In ACM SIGPLAN Notices, 34(3), 20–25, October 1998. &lt;a href=&quot;https://dl.acm.org/doi/10.1145/301589.286863&quot;&gt;https://dl.acm.org/doi/10.1145/301589.286863&lt;/a&gt; &lt;a href=&quot;#fnref:11&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:12&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;E. W. Dijkstra, L. Lamport, A. J. Martin, C. S. Scholten, and E. F. Steffens. On-the-fly garbage collection: An exercise in cooperation. Communications of the ACM, 21(11), 966–975, 1978. &lt;a href=&quot;https://www.cs.utexas.edu/users/EWD/transcriptions/EWD05xx/EWD520.html&quot;&gt;https://www.cs.utexas.edu/users/EWD/transcriptions/EWD05xx/EWD520.html&lt;/a&gt; &lt;a href=&quot;#fnref:12&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:13&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;T. Yuasa. Real-time garbage collection on general-purpose machines. Journal of Systems and Software, 11(3):181–198, 1990. &lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/016412129090084Y&quot;&gt;https://www.sciencedirect.com/science/article/pii/016412129090084Y&lt;/a&gt; &lt;a href=&quot;#fnref:13&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:14&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Paul R Wilson. “Uniprocessor Garbage Collection Techniques” &lt;a href=&quot;https://www.cs.cmu.edu/~fp/courses/15411-f14/misc/wilson94-gc.pdf&quot;&gt;https://www.cs.cmu.edu/~fp/courses/15411-f14/misc/wilson94-gc.pdf&lt;/a&gt; &lt;a href=&quot;#fnref:14&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;img src=&quot;https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png&quot; alt=&quot;wechat-account-qrcode&quot;/&gt;&lt;h3&gt;转载申请&lt;/h3&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by/4.0/&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; src=&quot;https://img.draveness.me/creative-commons.png&quot;/&gt;&lt;/a&gt;&lt;p&gt;本作品采用&lt;/p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by/4.0/&quot;&gt;知识共享署名 4.0 国际许可协议&lt;/a&gt;&lt;p&gt;进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。&lt;/p&gt;&lt;h3&gt;文章图片&lt;/h3&gt;&lt;p&gt;你可以在 &lt;/p&gt;&lt;a href=&quot;/sketch-and-sketch&quot;&gt;技术文章配图指南&lt;/a&gt;&lt;p&gt; 中找到画图的方法和素材。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5da1976b49486d6cd5fc5c65556570eb</guid>
<title>[推荐] 流量复制方案对比：TCPCopy vs Goreplay</title>
<link>https://toutiao.io/k/cpf8p4q</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;「流量复制」常常应用在准生产环境的测试中，将线上的流量复制到一个准生产环境服务中，测试新功能和服务的承压能力。流量复制可以完全模拟线上的流量，对复杂的业务场景进行真实的服务测试，又不会对生产服务产生任何副作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于复杂的流量复制应用场景和需求，完全可以立项开发一套完整的复制架构，可参考字节团队自研的 &lt;span&gt;ByteCopy&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt; 项目。而对于一些简单的需求，开源的工具基本可以搞定。开源的流量复制工具有很多，常用的有 goreplay、tcpreplay、tcpcopy 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要来探讨下 tcpcopy 和 goreplay 的方案实现，废话不多说开整。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.57&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sM0hH9BhiaDcSWIdf6OZ7OWfWvYuQcJLx8CvnL8kFib9awH0CHQiaJSLt4FmAVnbCb6icYL6js1iatjyDLdCia3hu9qA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot;/&gt;&lt;figcaption&gt;目录&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;tcpcopy 方案实现&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;tcpcopy 简介&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;tcpcopy 由网易技术部&lt;span&gt;王斌&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;等开发，并于 2011 年 9 月开源的。tcpcopy 最新架构如下（来自作者王斌博客：https://blog.csdn.net/wangbin579/article/details/8949315）：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9359165424739195&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sM0hH9BhiaDcSWIdf6OZ7OWfWvYuQcJLxhf6Faic1pY8lx4YDbtxv0m21yCYmotlDHNs3IuwYcSwicWB2AxFNAPMg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;671&quot;/&gt;&lt;figcaption&gt;架构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;tcpcopy 主要有两个组件构成 tcpcopy client 和 intercept 。client 端负责复制流量和转发，intercept 负责对回应流量的拦截和 tcpcopy 的链接处理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;tcpcopy 搭建&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例环境如下，下面来阐述下整个架构的搭建过程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;192.168.33.11 生产服务器，部署 tcpcopy client&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;192.168.33.12 辅助服务器，部署 intercept&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;192.168.33.13 测试服务器&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;各组件可直接从 github 下载源码包，编译安装：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 起压机部署 tcpcopy client 192.168.33.11&lt;/span&gt;&lt;br/&gt;wget https://github.com/session-replay-tools/tcpcopy/archive/1.0.0.tar.gz&lt;br/&gt;tar xvf 1.0.0.tar.gz&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; tcpcopy-1.0.0&lt;br/&gt;./configure --prefix=/opt/tcpcopy&lt;br/&gt;make&lt;br/&gt;make install&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 辅助机部署 intercept 192.168.33.12 , 截获包需要依赖 libpcap 抓包函数库&lt;/span&gt;&lt;br/&gt;yum -y install libpcap-devel&lt;br/&gt;&lt;span&gt;# ubuntu&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# apt install -y libpcap-dev&lt;/span&gt;&lt;br/&gt;https://github.com/session-replay-tools/intercept/archive/1.0.0.tar.gz&lt;br/&gt;tar xvf 1.0.0.tar.gz&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; intercept-1.0.0&lt;br/&gt;./configure --prefix=/opt/tcpcopy/&lt;br/&gt;make&lt;br/&gt;make install&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装完之后，先启动 intercept，运行如下命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/opt/tcpcopy/sbin/intercept -i enp0s8 -F &lt;span&gt;&#x27;tcp and src port 8000&#x27;&lt;/span&gt; -d&lt;br/&gt;&lt;span&gt;# -i，指定网卡 enp0s8&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# -F，过滤，语法和pcap抓包工具一直，如tcpdump&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# -d，以domain的形式启动。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 其他参数可 -h 查看。&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动 intercept 之后，再启动 tcpcopy client 。tcpcopy 启动依赖 intercept ，启动时确保 intercept 启动成功。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/opt/tcpcopy/sbin/tcpcopy -x 8000-192.168.33.13:8000 -s 192.168.33.12 -c 192.168.1.x -n 2 -d&lt;br/&gt;&lt;span&gt;# -x，复制本地8000端口的流量，转发到192.168.33.13机器的8000端口&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# -s，辅助服务器intercept 地址&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# -c，修改转发包的原地址为该地址段的地址，这里也可以是明确的ip。这个ip端用来伪装数据包，方便intercept做路由劫持。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# -n，流量倍数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# -d，以domain的形式运行&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在测试服务器添加拦截路由，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 测试机 192.168.33.13&lt;/span&gt;&lt;br/&gt;route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.33.12&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该路由相当于把到 192.168.1.0 网段的包都走网关 192.168.33.12，对测试服务器的回包做伪地址拦截。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这便是 tcpcopy 的整个架构部署了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;包流向分析&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们抓包看看这个过程中包是如何流动的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我在 tcpcopy client 机器 192.168.33.11 和测试机器 192.168.33.13 使用 &lt;code&gt;python -m SimpleHTTPServer&lt;/code&gt; 分别起了一个 8000 端口的服务用来测试，从我本机 192.168.33.1 发送请求，在三台机器上抓包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;tcpcopy client 机器 192.168.33.11 包信息如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3251231527093596&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sM0hH9BhiaDcSWIdf6OZ7OWfWvYuQcJLxzTB8hE02CLOhqYsJCG2bToEArPXUuFcn8lK9MwDrD2ibwf9WiaPfMicicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1827&quot;/&gt;&lt;figcaption&gt;tcpcopy&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;红色标注块为我本机（192.168.33.1）和 tcpcopy client 机器（192.168.33.11）的正常请求交换，从三次握手，到 http 请求，到最后的断链。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;蓝色标注块则为 tcpcopy 复制的流量，可以看到为了让 intercepter 拦截回包流量，tcpcopy 已将包源 ip 地址替换为我们指定的伪网段（192.168.1.0）的地址，这样在回包时，就会根据测试服务器上的路由将回包指向辅助服务器 intercept，避免对生产流量造成影响。这也是为什么复制流量三次握手和 http 都没有回包的原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看测试服务器 192.168.33.13 的包：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1618685497012493&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sM0hH9BhiaDcSWIdf6OZ7OWfWvYuQcJLx9wt7w3pZWKVZjeFuqbr4gQLCpCcWRn6uKcHSmLUYHPI3QM33dlFEZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1841&quot;/&gt;&lt;figcaption&gt;test server&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试服务器的包和正常流量包一样，三次握手到 http 请求，最后断连。这里和测试服务器 192.168.33.13 交互的源地址 ip 已经被 tcpcopy 替换为伪 ip 192.168.1.1 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看 intercept 192.168.33.12 的包：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23268698060941828&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sM0hH9BhiaDcSWIdf6OZ7OWfWvYuQcJLxgTGadLOqQHMs6cSpdcB7FoVCOhdkbYyytKmfMr5KCIGQEGO0A2eiapg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1805&quot;/&gt;&lt;figcaption&gt;image&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到辅助服务器拦截下来的请求，标注块 1 为复制流量三次握手时的回包，标注块 2 为 http 请求的回包，这便是 intercept 的拦截功能。可以看到在标注块 1、2 之后，辅助服务器（192.168.33.12）和 tcpcopy 服务器（192.168.33.11）进行了数据交换，这部分便是 intercept 的 tcp 处理功能，它把有用的信息返回给 tcpcopy 以便能使 tcpcopy 和测试机的 tcp 链接完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据上边抓包，我们得到了和架构图一样的包流动过程，总结如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;生产流量正常请求，服务正常回应。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tcpcopy 服务在生产机器上复制流量，并修改流量包的源 ip 地址为我们指定的伪网络段(-c 参数指定)，之后将流量转发到测试服务器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;测试服务器，接受到流量，但包的源地址为伪网络段的地址，回包时根据提前配置好的伪路由，将回包导流到辅助服务器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;辅助服务器接收测试服务器的回包，但是并不转发。而是解包，只返回部分必要的信息给 tcpcopy，以便完成 tcpcopy 和测试服务器之间的 tcp 交互。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据官方文档，我们还需要注意几个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;辅助服务器不做包的转发，需要关闭内核参数 &lt;code&gt;ip_forward&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在做测试时，注意上行流量的过滤和测试数据源的隔离，防止对生产数据造成多次操作的影响。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;上边为在线实时的复制模式，tcpcopy 还支持离线方式，具体可查阅&lt;span&gt;文档&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;辅助机需要和测试机在一个网段，以便辅助机作为伪网段的网关使用。这里可以加一次代理，解除这个限制。如使用 nginx 作为测试中转机，将伪路由添加到 nginx 服务器上，测试机只需要向 nginx 注册即可，无需做其他配置。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;goreplay 方案实现&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;goreplay 简介&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Goreplay 是另一个比较常用的流量复制开源工具。与 tcpcopy 相比它的架构更简单，只有一个 gor 组件，如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5818363273453094&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sM0hH9BhiaDcSWIdf6OZ7OWfWvYuQcJLx87DlSNEEbqgdMv15OiaQRKZZxPTNunvEfx8o1d9S6PFsTNnMy6Kbusg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1002&quot;/&gt;&lt;figcaption&gt;image&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需要在生产服务器上启动一个 gor 进程，它负责所有的工作包括监听、过滤和转发。它的设计遵循 Unix 设计哲学：&lt;em&gt;一切都是由管道组成的，各种输入将数据复用为输出&lt;/em&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输入输出通常被成为插件，常见的有下面几种。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可用输入：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;--input-raw 用于捕获 HTTP 流量，您应该指定 IP 地址或接口和应用程序端口。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--input-file 接受流量输出的文件（--output-file），用来离线流量重放。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--input-tcp 如果您决定将来自多个转发器 Gor 实例的流量转发给它，则由 Gor 聚合实例使用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可用输出：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;--output-http 重放 HTTP 流量到给定的端点，接受基础 URL。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--output-file 记录传入的流量到文件。更多关于保存和从文件重播&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--output-tcp 将传入数据转发给另一个 Gor 实例，并与其一起使用--input-tcp。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--output-stdout 用于调试，输出所有数据到 stdout。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以对数据进行限速、过滤、重新，还可以重用中间件实现一些自定义逻辑处理，如私有数据的过滤、认证等个性需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他常用参数：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;--output-http &quot;http://staging.com|10&quot; 输出流量的 10%&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--http-allow-method 根据请求方式过滤。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--http-allow-url url 白名单，其他请求将会被丢弃。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--http-disallow-url 遇上一个 url 相反，黑名单，其他的请求会被捕获到。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文不对中间件做过多描述，仅讨论常用功能，对中间件有需求的可参考&lt;span&gt;中间件文档&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;goreplay 搭建&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Goreplay 是使用 golang 开发的，我们可以直接使用编译好的对应各系统的二进制文件，也可以自己编译，我们这里直接使用二进制文件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;wget https://github.com/buger/goreplay/releases/download/v1.3.0_RC1/gor_1.3_RC1_x64.tar.gz&lt;br/&gt;tar zxvf gor_1.3_RC1_x64.tar.gz&lt;br/&gt;&lt;span&gt;# 解压出二进制文件 gor&lt;/span&gt;&lt;br/&gt;gor&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，直接启动 gor 即可复制流量和转发。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;sudo ./gor --input-raw :8000 --output-http=&lt;span&gt;&quot;http://192.168.33.13:8001&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;复制本地 8000 端口的流量到 http 远端服务&lt;code&gt;http://192.168.33.13:8001&lt;/code&gt;。(复制同端口的流量时，流量会重复。这是 gor 的一个 bug，截止目前 1.3 版本仍可复现，可见&lt;span&gt;issue292&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;goreplay 的流量转发，并不是直接 tcp 包的转发，而是重新组织 http 协议级别的请求，发送到测试服务器。所以它是新的 gor 线程和测试服务器的交互，和监听线程无关，所以无需对流量进行拦截。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;包流向分析&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看下 gor 复制的流量包的流向过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4105720492396814&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sM0hH9BhiaDcSWIdf6OZ7OWfWvYuQcJLxRibWGGxK3ibHs1cy68hGAgv6sKmyft3iaMEibHO3eqwCYRADHCV7utFcgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2762&quot;/&gt;&lt;figcaption&gt;gor&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;红色标注块为正常流量，蓝色标注块为复制的流量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到此处，你可能会有疑问，为什么 gor 不用拦截流量？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家仔细看 tcpcopy 和 gor 复制流量的端口，在生产机和测试机建立连接时，tcpcopy 虽然修改了 tcp 包的源 ip，但端口还是用的请求客户端的端口，是 tcp 数据链路层级别的流量复制。而 gor 这里严格来说并不是复制，而是重新构建了 http 请求。使用新端口来和测试机建连，相对的测试机在回包时，即使包是回到了生产机，但由于是和客户端不同的端口，也不会对生产流量造成影响。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;对比总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到此，我们对流量复制有了些基本的概念和应用了，也对 tcpcopy 和 goreplay 两款开源工具有了一定的认知。两款开源工具各有优缺点，我们来一块总结下。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;tcpcopy 部署架构相对复杂，goreplay 相对简单只需启动一个进程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tcpcopy 支持的协议比较丰富，goreplay 根据架构特点仅支持 http。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tcpcopy 和 goreplay 都支持离线和在线录制回放。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;goreplay 有个中间件模块，可自定义部分过滤逻辑。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单 http 复制 goreplay 完全可以胜任，稍复杂点或应用场景更复杂，那么推荐 tcpcopy。更复杂，要求更高的流量复制，那只能我们自己定制了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，本篇到这结束了，欢迎留言讨论，你觉着最佳流量复制方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是DeanWu，一个努力成为真正SRE的人。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;关注公众号「码农吴先生」, 可第一时间获取最新文章。回复关键字「go」「python」获取我收集的学习资料，也可回复关键字「小二」，加我wx拉你进技术交流群，聊技术聊人生~&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3287037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sM0hH9BhiaDcSWIdf6OZ7OWfWvYuQcJLxC0wYGQ9FOT7AlslkQTMzHKEYKeVjLHMW3rzldm0pRsiayvt4gPgvSmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2592&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;ByteCopy: &lt;em&gt;https://juejin.cn/post/6857688805835866126&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;王斌: &lt;em&gt;https://github.com/wangbin579&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;文档: &lt;em&gt;https://github.com/session-replay-tools/tcpcopy&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;中间件文档: &lt;em&gt;https://github.com/buger/goreplay/tree/master/middleware&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;issue292: &lt;em&gt;https://github.com/buger/goreplay/issues/292&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>