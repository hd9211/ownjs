<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b93b512443ed8f91b10007c6fa41f47e</guid>
<title>秋天的第一份 IT 技术周刊 | 码农周刊第 320 期</title>
<link>https://toutiao.io/k/9ew44gv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;秋天的第一份 IT 技术周刊 | 码农周刊第 320 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第320期（2020-09-29）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3200&quot; target=&quot;_blank&quot;&gt;秋天的第一份 IT 技术周刊，请查收！&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3200&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_320.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;思考和实践&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;由 JavaScript 之父 Brendan Eich 与 ES6 规范首席作者 Allen Wirfs-Brock 联合编写，详细记载和解读了自 1995 年语言诞生到 2015 年 ES6 规范制定为止，共计 20 年的 JavaScript 语言演化经历。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;支持 mp4, flv, m3u8 及 rtmp 协议的直播，支持移动端，PC 端。&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;利器&lt;/p&gt;
        
        &lt;p&gt;实打实的干货&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;容易踩的坑&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;细致分析&lt;/p&gt;
        
        &lt;p&gt;方案和思路&lt;/p&gt;
        
        &lt;p&gt;一些实践和工具&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;报告详情&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;深入探讨&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;java相关技术分享&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 444692 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 444414 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 435415 即可&lt;/p&gt;
        
        &lt;p&gt;不定期更新一些机器学习算法，方便大家浏览，然后一起学习，一起进步&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 104739 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 99181 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;本书深入地讲解了 Go 语言常见特性的内部机制和实现方式，大部分内容源自对 Go 语言源码的分析，并从中提炼出实现原理。欢迎到&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;兑换阅读。&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;值得推荐&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;无代码开发平台&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>404f18efa0f6e1464e82d92e1a1e434d</guid>
<title>外卖客户端容器化架构的演进</title>
<link>https://toutiao.io/k/mrn79ee</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 背景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.1 移动端跨平台技术的介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;移动端的跨平台技术不是一个新话题，早在几年前，WebView容器、React Native、Weex、Flutter、小程序等移动端跨平台框架就风起云涌。为什么跨平台这么有吸引力呢？我们设想一下如果可以做到一次开发，多端复用，那么对于公司来说，就可以降低用人成本。对于开发来说，只需要学习一个框架，就可以在Android和iOS双平台上开发。节约下来的成本，可以投入到产品快速验证、快速上线。这对所有人来说都有着极大的吸引力。本节先针对部分移动端跨平台技术进行一些简要的介绍，以便读者能够更好地理解后面的内容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.1.1 WebView容器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;WebView容器的工作原理是基于Web技术来实现界面和功能，通过将原生的接口封装、暴露给JavaScript调用，JavaScript编写的页面可以运行在系统自带的WebView中。这样做的优势是，对于前端开发者比较友好，可以很快地实现页面跨端，同时保留调用原生的能力，通过搭建桥接层和原生能力打通。但这种设计，跨端的能力受限于桥接层，当调用之前没有的原生能力时，就需要增加桥。另外，浏览器内核的渲染独立于系统组件，无法保证原生体验，渲染的效果会差不少。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.47294117647058825&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKXj0Tz6s8MwOYtfG2RzDUdLziaYAuHnNN322Z5qQJkD1hYot8ibBS8HRAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;850&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.1.2 React Native&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2015年，Facebook推出了React Native，一经推出就备受关注。它的思路是最大化地复用前端的生态和Native的生态，和WebView容器的最大区别在于View的渲染体系。React Native抛弃了低效的浏览器内核渲染，转而使用自己的DSL生成中间格式，然后映射到对应的平台，渲染成平台的组件。相对WebView容器，体验会有一定的提升。不过，渲染时需要JavaScript和原生之间通信，在有些场景可能会导致卡顿。另外就是，渲染还是在Native层，要求开发人员对Native有一定的熟悉度。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5327868852459017&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKXx41X6XwZgZMNd5ZtYg1XPz0aNYeKkdVibWbuFviae89CiaDYggyhVaOlw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1708&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.1.3 Flutter&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2018年Google推出Flutter，通过Dart语言构建一套跨平台的开发组件，所有组件基于Skia引擎自绘，在性能上可以和Native平台的View相媲美。Flutter站在前人的肩膀上，参考了React的状态管理、Web的自绘制UI、React Native的HotReload等特点，同时考虑了与Native通信的Channel机制、自渲染、完备的开发工具链。Flutter与上述Recat Native、WebView容器本质上都是不同的，它没有使用WebView、JavaScript解释器或者系统平台自带的原生控件，而是有一套自己专属的Widget，底层渲染使用自身的高性能C/C++ 引擎自绘。但大部分移动端发展到今天，都已经形成了自己的架构，在现有基础上加上Flutter，会形成原有架构和Flutter双平台共存的问题。目前，对新的App来说，是最被看好的跨端方案。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5859085290482077&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKX0NIEkDTwu50MH7bBvn6KlNFAl6Y2BSeDicS32dkUTYNBZFmia84PS0ibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;809&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.2 美团外卖业务介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作为中国领先的生活服务电子商务平台，美团致力于用科技连接消费者和商家，提供服务以满足人们日常“吃”的需求，并进一步扩展至多种生活和旅游服务。而作为公司最为重要的业务之一，美团外卖从2013年创建以来，已经从单一的品类扩展到附近美食、水果、蔬菜、超市、鲜花、蛋糕等多品类，从早午晚餐，发展到下午茶、宵夜，中餐、西餐、家常菜、小吃、快餐、海鲜、火锅、川菜、蛋糕、烤肉、水果、饮料、甜点等多种类餐饮。美团外卖可以说是当前电商领域，最为复杂的业务之一。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业务的复杂，给系统架构也带来了不小的挑战。美团外卖业务之所以说是当前电商领域最为复杂的业务，主要源于以下几点特征：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;综上所述，可以发现美团外卖不仅仅自身业务比较复杂，而且对外的角色也很复杂。在美团内部，外卖不仅仅是美团平台的一个频道业务，而且自己本身也是一个平台业务，同时美团外卖还承担着新业务发展的平台角色。这意味着想要支持好美团外卖业务的发展是一件非常有挑战的事情。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.3 美团外卖移动端历史架构概述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;好的架构源于不停地衍变而非设计。美团外卖的架构，历史上也是经历了很多次迭代。由于外卖业务形态不断地发生变化，原有的设计也需要不断地跟随业务形态进行演进。在不断探索和实践过程中，我们经历了若干个大的架构变迁。从考虑如何高效地复用代码支持外卖App，逐渐地衍变成如何去解决多端代码复用问题，再从多端的代码复用到支持其他频道业务的平台架构上。在平台化架构建设完成后，我们又开始尝试利用动态化技术去支持业务快速上线的诉求。如今，我们面临着多端复用、平台能力、平台支撑、单页面多业务团队、业务动态诉求强等多个业务场景问题。下文我们针对美团外卖移动端架构的变迁史，做一些简单的概述，以便读者阅读本文时能有更好的延续性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.3.1 组件化架构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;早期阶段，美团外卖作为公司的一个孵化业务，在2013年底完成了美团外卖App的1.0版本。随着外卖业务的验证成功和跑通，订单量也快速增长，在2014年底突破了日订单量100万。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随后在2015年2月，外卖以Native的形式接入美团App，成为美团App的一个业务频道。在接入过程中，我们从美团外卖App拷贝了大量的代码到美团App的外卖频道，两个App上的外卖业务代码也分别由两个独立的团队维护。早期外卖业务变化快，App迭代频繁，写代码的方式也比较粗放，同时美团App也处在一个平台化转变的时期，代码的稳定性和质量都在变化和提升当中。这些因素导致了外卖代码内各子系统之间耦合严重，边界模糊，“你中有我，我中有你”的情况随处可见。这对代码质量、功能扩展以及开发效率都造成很大的影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此时，我们架构重构的目的，就是希望将各个子系统划分为相对独立的组件，建设组件可以直接复用，架构如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7680311890838206&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKX0ibI7eDNKSgVuZjEibRMyg6h80CZLJBLvwH6ogUxMDqpXtbHycF9z7dw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1026&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.3.2 平台化架构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上文所述，大家可以知道美团外卖和美团外卖频道是由不同的团队在维护发展。2015年，公司考虑到业务发展的一致性，将美团外卖频道团队正式归于美团外卖。从组织架构上来说，美团外卖和美团外卖频道，逐渐融合成一个团队，但是两端的差异性，导致我们不得不仍然阶段性地维持原有的两班人马，各自去维护独立外卖App和美团外卖频道。如何解决这个问题？两端代码复用看起来是唯一的途径。另外，随着业务的快速发展，外卖App所承载的业务模块越来越多，产品功能越来越复杂，团队规模也越来越大，如闪购、跑腿等业务想以独立的Native包的形态接入外卖App，还有外卖的异地研发团队的建立，都带来了挑战。这使得我们在2017年开始了第二次架构重构——平台化架构，目标是希望能够支持多端复用和支持不同团队的业务发展。通过抽象出平台能力层、业务解耦、建立壳容器，最终实现了平台化架构，架构如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5802781289506953&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKXH82tsB6fsbxhibUxYGiczJ8yxTv8Pa5suGkQ9D9ic58ebYekZEwSC755w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1582&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.3.3 RN混合架构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在平台化架构之后，美团外卖功能持续增加，美团外卖客户端安装包的体积也在持续增加。回顾2017年和2018年，每年几乎都增长100%。如果没有一个有效的手段，安装包将变得越发臃肿。另外，由于原生应用需要依托于应用市场进行更新，每次产品的更新，必须依赖用户的主动更新，使得版本的迭代周期很长。业务上的这些痛点，不断地督促我们去反思到底有没有一种框架可以解决这些问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在2015年的时候，Facebook发布了非常具有颠覆性的React Native框架，简称RN。从名字上看，就可以清楚的明白，这是混合式开发模式，RN使用Native来渲染，JS来编码，从而实现了跨平台开发、快速编译、快速发布、高效渲染和布局。RN作为一种跨平台的移动应用开发框架，它的特性非常符合我们的诉求。美团也积极地探索RN技术。在RN的基础上，美团在脚手架、组件库、预加载、分包构建、发布运维等方面进行了全面的定制及优化，大幅提升RN的开发及发布运维效率，形成了MRN（&lt;/span&gt;&lt;span&gt;Meituan React Native&lt;/span&gt;&lt;span&gt;）技术体系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从2018年开始，美团外卖客户端团队开始尝试使用MRN框架来解决业务上的问题。使用RN的另一方面的好处是，能逐渐的抹平Android和iOS开发技术栈带来的问题，使用一套代码，两个平台上线，理论上人效可以提升一倍，支持的业务需求也可以提升一倍，架构如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6270543615676359&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKXmCicQiaJmQk3rU8uQ6H8yLruPRVEm3jIpoI9rugQfIEREtxZqXqc5YibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1582&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 美团外卖容器化架构全景图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.1 什么是容器化架构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上文说到，外卖业务已经发展到多App复用、单页面多业务团队开发的业务阶段。要满足这样的业务场景下，寻求一个可持续发展的业务架构是件不容易的事情。经过我们之前架构演进，我们获得了宝贵的经验：在平台化架构的时候，我们将App和业务进行解耦，将App做成壳容器，业务形成独立的业务库，集成到壳容器里面，从而屏蔽了多App的问题，提高了业务的复用度。在RN混合式架构里面，我们引入了RN容器，通过这个容器，使得业务屏蔽了Android和iOS的平台差异。借助这些成功的经验，我们进一步思考，如果我们尝试进一步的细分外卖的业务场景，将不同场景下的基础能力建设成壳容器，业务集成到容器内，是否可以更好的支撑我们多App复用、单页面多业务团队的当前现状呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;容器化架构的愿景是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2 容器化架构的优势&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当我们把承载外卖业务的环境进行了抽象和标准化后，就可以获得以下若干点好处。首先动态化属性提升，我们可以把原有必须在客户端上写的业务放到了远端，业务的动态性得到很大的提升，具备随时上线业务的可能。对于开发过程而言，编译部署的速度也得到了极大提升。如果涉及到客户端的代码改动，那客户端的编译打包，即使是增量的编译，也至少是秒级的编译速度。而容器化后，我们只打包必要的业务，把业务动态下发到容器呈现，客户端代码本身不会有变化，这样就可以从秒级的编译减少到毫秒级的编译。同样，业务动态下发，对减少客户端的包大小也有很大的帮助。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后，容器位于应用之内，我们向应用中引入相同的容器SDK，容器屏蔽了应用之间的差异，对于Android和iOS平台，在设计上，通过容器这一层去尽可能屏蔽平台之间的差异，使业务开发人员只需要认识容器，不需要花费大量的精力去关注应用和平台之间的差异，从而使得开发效率得到了极大的提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次，容器化后，容器对承载的内容是有接口协议要求的，承载的内容只有满足容器定义的协议才能得到容器带来的好处，这促使业务得到了更细粒度的细分，业务开发时候，对模块化的意识得到了保障。另外，容器这一层提供的接口在Android和iOS上是标准化的，业务的开发也因为依赖的标准化，而趋向标准化，双端的业务一致性得到了提升。这些潜在的架构好处，对未来的业务维护和扩展都打下了比较好的地基。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.3 外卖容器化架构全景图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.718320057929037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKXtz5YmZiaRyY7rkGAlLJdK5WOn6p9DIaJrrbd7gBCRTbV0Wrdq7F1yibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1381&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;整个外卖容器化架构可以按照从下到上，从左到右的视角进行解读：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最底层是系统服务，因为我们采用了H5和RN这样跨端的技术栈，使得iOS系统和Android系统成为了最底层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;系统服务之上是集团基于Native建设的基建，全公司通用，覆盖了研发工程中方方面面的基础服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在基建之上是我们定义的容器层。我们尝试用单一技术栈解决所有问题。但经过我们的探索，觉得不太可能实现。好的架构要匹配业务形态，业务的诉求决定了我们不能选择唯一的技术栈去解决所有问题，细分外卖的业务场景可得到以下3个方向的页面分类：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再往上，就是垂直的业务，外卖目前有流量业务、交易业务、商家业务、商品业务、广告业务、营销业务、闪购业务等。业务都是垂直向下依赖，直接可见容器，可见基建，能够很好地获取到各种已经建设的能力去完成业务的需求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最上面是承载的App端，目前有四端，包括外卖、点评、美团、闪购等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;右侧是测试发布和线上监控，相对于常规的移动端App架构而言，容器化架构的测试发布和监控是更为精细化的。不仅仅要关注端本身的可用性，还需要关注容器、容器承载的模块、模块展示的模板，模板里面的样式这些的可用性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.4 容器化的挑战&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;容器化架构相对常规的移动端架构而言，它从管理移动端的代码转变成管理移动端的容器建设代码和业务远端开发代码，多出了容器和业务远端下发。这不仅仅是对技术上的挑战，对长期做客户端开发同学，也需要一个思维转变的跳转。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;一致性的挑战&lt;/strong&gt;：容器需要在多个宿主应用之中运行，宿主应用的环境一致性直接影响了容器的一致性。我们的策略是两手准备，一方面利用外卖业务的优势推动宿主应用的环境对齐；另一方面将容器建设成SDK，通过SDK将长期保持容器的一致性，也通过SDK内部的设计屏蔽应用之间的差异；对于Android和iOS平台，我们通过分层的设计，尽可能屏蔽平台的差异。综上所述，一致性的挑战在于（1）容器运行的宿主应用的环境一致性；（2）不同应用不同版本容器的一致性；（3）Android和iOS平台容器的对业务的一致性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;动态发布的挑战&lt;/strong&gt;：长期以来，客户端同学的开发概念里面只有App版本的概念，而当我们逐渐把业务代码做成远端下发时，将会新增一个线上动态发版的概念。当我们在发布业务的时候，相对以往的工作，多出需要去考虑这个业务的版本，可以运行的容器对应的App上下界版本。另外，发版的周期也会新增业务的发版周期，不仅仅是App的发版周期。这两者在一起将会产生新的火花，业务的版本和App的版本如何适配的问题，业务动态发版的周期和App的发版周期如何适配的问题。外卖这边的解决方式是建设主版本迭代+周迭代的模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;监控运维的挑战&lt;/strong&gt;：以往的移动端架构，我们更加关注的是端本身的可用性，然而当我们演进到容器化架构的时候，仅仅关注端的可用性已经远远不能确定业务是可用的了。我们需要从端的可用性延伸出下载链路、加载链路，使用链路上的可用性，针对每个重要的环境，都做好监控运维。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 外卖跨端容器建设&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.1 MRN容器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.1.1 MRN容器简介&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;React Native框架本身只是一个运行时环境中的渲染引擎，可以将同一套JS代码分别在Android和iOS系统上最终以Native的方式渲染页面，从而为App提供了基础的跨端能力。但从工程化的角度来看，如果想在App中大规模地应用RN技术，除了RN框架本身外，还需要在开发、构建、测试、部署、运维等诸多方面的配合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MRN（&lt;/span&gt;&lt;span&gt;Meituan React Native&lt;/span&gt;&lt;span&gt;）是美团基于React Native框架改造并完善而成的一套动态化方案，在RN的基础上提供了容器化能力、动态化能力、多端复用能力和工程化保障。MRN在开发效率、稳定性、性能体验、动态化和监控运维等多方面进行了能力升级和扩展，满足了美团RN开发工程化的需要。目前，MRN已接入美团40多个App，核心框架及生态工具有超过100位内部代码贡献者，总PV超过4亿。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3620531622364803&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKXVgoQeMMV6DR9a6pb7ibx0JLq7Kx6uX74TrqKbnSrdLbPJvLzaNMIMTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2182&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.1.2 Roo组件库&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面再介绍一下外卖建设的两个UI相关的技术项目，Roo组件库和组件样式动态配置。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Roo组件库：外卖在RN及MRN框架提供的UI组件基础之上，又扩展了适用于外卖业务的标准化UI组件库。UI组件库一方面统一了我们的设计规范和开发规范，提高了UI一致性；另一方面，组件封装也提升了RN页面的开发效率和质量。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;组件样式动态配置：有了标准的Roo组件，我们进一步给标准组件的动态添加了样式动态配置能力。在使用组件时，很多样式是支持动态下发的，例如字体、圆角、背景色等，方便我们进行UI的适配和改版。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKX6k6mXAGo8CZyiaXpg9l9T3xN1Uiaj6qKf1AKIjicM3Bn0Pb8o1t26cmZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;span&gt;外卖在2018年底开始试验MRN容器在外卖业务上的应用，并在2019年上半年进行了大面积的页面落地。&lt;/span&gt;&lt;span&gt;目前，外卖已有近60个RN页面上线，占外卖页面比例超80%，其中包括Tab页面“我的”、提单选择红包页、订单评价页等高PV页面。&lt;/span&gt;&lt;span&gt;MRN容器的接入，给外卖App的容器化、动态化、人效提升、包大小瘦身等方面都做出了不小的贡献。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.2 Titans容器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.2.1 Titans容器简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Titans容器是美团系App统一的Web容器组件，基于苹果提供的WebView组件，将WebView容器化，统一了WebView的UI展示和交互方式，规范了桥协议的使用范式，同时预置了诸多基础能力和业务能力。Titans容器大大提高了Web页面的开发效率和用户体验上的一致性。&lt;/span&gt;&lt;/p&gt;&lt;img data-ratio=&quot;0.3409090909090909&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKXdLWaysPdHhNKF9RYgRVKBmwsoFs0yTOzTOKshb58oHb1jWrOyDoKXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1408&quot; title=&quot;&quot;/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Titans容器在外卖业务中的使用场景非常丰富，其中最重要的使用场景是各种运营页和活动页，例如点击首页顶部Banner的广告落地页、为你优选、限时秒杀等活动运营页等；还有客服页、帮助反馈页、商家入驻页、美团公益页等功能性页面；作为一级入口页面的美团会员页面，也是一个基于Enlight的Titans容器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. 外卖页面容器建设&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;外卖容器化建设，首先需要要区分的是核心页面和非核心页面。外卖业务中对核心页面的定义是页面DAU&amp;gt;美团DAU的5%或者是下单关键路径。为什么要先按照是否为核心页面进行拆分呢？重点就在于改造的成本。核心页面的业务复杂度决定了它不容易做全页面的动态化，它比较适合做局部的动态化方案。核心页面的复杂度在于业务本身复杂，最重要的是核心页面往往会有多个垂直业务团队共同的开发维护，大家各自有重点关注的模块，做全页面的动态化，无法做到有效的物理隔离。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而对于非核心页面，业务功能和交互相对简单，组织关系也较为确定，更适合做标准的MRN和Titans容器化。所以我们的策略是核心页面做到支撑页面模块级别的业务动态和复用，非核心页面可以做到页面级别的动态化和复用。页面容器化的核心含义就是把一个页面划分为若干个模块，每个模块成为一个业务容器，每个容器的填充既可以用Native的方式实现，也可以用Mach实现（&lt;/span&gt;&lt;span&gt;Mach是外卖自研的页面局部动态化技术&lt;/span&gt;&lt;span&gt;），可以支持iOS/Android/小程序三端跨平台运行。页面本身则化身为容器的管理者，负责子容器的编排和布局，并支持其动态化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.1 页面容器化设计思路&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.22083333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKXHoO6hiaFH2Dd2xicHld5G1wkfd8Fd9le2JhRQDUMEjWYYscnfABicUF1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;页面容器化设计中主要分为三个阶段，模块有序化、模块编排化、渐进式业务落地。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.2 业务构建模块标准化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从App页面开发的角度看，一个完整的页面可以按照不同的功能及不同业务属性划分出多个不同的模块。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业务构建泛指由多个业务模块组合拼装为一个业务页面的过程，涉及页面本身（&lt;/span&gt;&lt;span&gt;UIViewController/Activity&lt;/span&gt;&lt;span&gt;）以及各个业务模块的构造过程，前后端业务数据以及页面和业务模块之间的数据交互过程，业务模块内部的数据处理以及视图刷新流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;模块标准化指的将业务构建涉及到的多个过程通过规范化的方式确定下来，形成唯一的标准。模块标准化一方面能够在解决业务共性问题的基础上提供业务难点专项解决方案，另一方面能够在框架基础上形成能力约束，减少重复建设、低质量建设的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业务构建模块标准化中我们抽象了四层，下面将分别进行解读。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.815668202764977&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKXBsu5avKGVZauNYI4r8jphiaMDtyZyMdldmPRNAgvNbO8L6OnqWfh3EA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1302&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最底层是框架能力层，是外卖业务团队自研的符合外卖业务特点的双端模块化框架。框架解决了不同页面场景下的共性问题，对典型的业务痛点也进行了支持。它是一种页面框架设计在iOS、Android双端对齐的实现方案，这种双端对齐的能力为页面容器化设计的双端一致性提供了保障。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;统一接口层是对框架能力层的标准化抽象，它可以保证任一模块调用的能力在各个业务场景下的实现都是一致的，有了这一层抽象任一模块都可以直接在各个场景下复用。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在往上就是App全局的模块复用层，标准化后的模块可以通过唯一标示向模块复用池注册模块，这种中心化的注册方式可以让业务模块在跨业务库的场景下可以灵活地复用。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最上层就是外卖的核心业务场景层，每一个场景都对应了一个标准化的页面容器，页面容器通过实现容器化接口来完成页面容器的构建。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;通过业务构建模块标准化的建设，业务模块已经是标准化的了，可以在跨页面间自由组合，这为页面容器化打下了基础。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在页面容器化中最基础的能力有以下几点：&lt;strong&gt;页面中业务模块可编排能力，动态上线前端AB实验的能力，增量上线动态模块的能力&lt;/strong&gt;。实现这些能力最重要的就是进行前后端数据协议标准化建设。客户端根据数据协议中的模块唯一标识匹配并构造业务模块，在完成模块数据的填充后会根据数据协议中的模块布局信息完成模块的布局。针对Mach动态模块，我们创建了基于模板ID的模块匹配和数据填充流程，可以支持Mach动态模板的增量上线。在数据协议中针对前端AB实验我们预留了AB实验和通参字段，在数据填充阶段通过容器化接口传入动态模块中，用于支持AB实验的动态上线。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在容器化上线的过程中属于接口的大版本升级，为了保证容器的高可用性，客户端从模块级别和API级别实现了两套降级容灾方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;模块级别的降级方案主要针对Mach动态模块，与Native模块不同，Mach动态模块需要预先下载动态模板才能正常地完成模块的载入和渲染。为了保证动态模块的加载成功率，我们一方面在接口上线前利用Eva（&lt;/span&gt;&lt;span&gt;美团内部系统&lt;/span&gt;&lt;span&gt;）对Mach模板的下载进行预热。另一方面，我们设计了动态模块的主动降级方案，针对动态模块的动态上线使用Native模块进行兜底降级，对于跟版动态模块使用App内置模板的方案进行兜底降级。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;API级别的容灾方案主要为了保障客户端在新接口不稳定的情况下可以自行降级到旧接口。针对这个问题，我们对线上老接口设计了数据结构映射方案，在客户端通过配置化的方式可以把老接口的数据结构映射为新接口的数据结构。这样在上层业务无感知的情况下，可以做到容灾方案的上下线。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.3 小结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过页面容器化，使得页面只需要关心页面级的构造方式，而无需关心某一模块内部如何实现动态化的。把页面与页面的模块分离，也符合目前外卖客户端的组织结构，有利于业务组间的协作。同时，页面容器化使得外卖核心页面具备了符合外卖业务场景下的动态能力，渐进式把Native静态模块过渡到具备动态能力的模块，从模块的维度使整个页面具备了动态能力。这种渐进式的迁移方案把容器迁移跟业务模块的迁移分隔开，大大降低了页面容器化改造的风险。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5. 外卖容器化架构的衡量指标&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.1 容器化架构衡量指标的特点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;质量和性能指标是衡量我们App开发质量和用户体验的重要依据，是我们一直都非常关注的重点数据。在非容器化时代，我们大多数的指标都和App的使用环节紧密相关，因为在非容器化时代，逻辑链路相对简单，例如我们打开一个新页面时，我们首先创建页面实例，然后发起网络请求，同时页面会经历一系列生命周期方法，最后渲染。这时我们可能会关注网络请求的成功率和请求时间，页面的渲染时间，和过成功是否发生Crash，这个过程相对更短暂，指标更少，所以监控起来也更容易。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;外卖的容器化大大提升了外卖业务的复用能力、动态能力、模块化和开发效率，但同时也带来了更长的逻辑链路，链路从时间维度上划分是：下载链路、加载链路、使用链路。例如我们在使用MRN容器的时候，会涉及到bundle的启动下载或预热下载，bundle解压缩，MRN容器引擎初始化，bundle加载，JS的加载、执行，页面渲染等步骤，其中的每个步骤都可能存在性能问题和质量风险。因此，我们需要升级我们的衡量指标系统来应对容器化带来的新的挑战。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6621490803484995&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKXtJX5Ln7vfVYsRpante65hibiaCfxmKD76kzDRFX4uyNrXo4t0KS1x9Nw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2066&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.2 链路指标&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.3 关键指标&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为容器化的使用形成了一个串行的链路，所以如果某个关键节点失败，会导致容器功能不可使用，关键指标的任务就是从上述众多的指标当中筛选出这些关键节点。例如在下载链路中bundle下载的成功率和API的成功率，加载链路中bundle加载的成功率和模块匹配的成功率，下载或加载失败都无法再进行链路中的后续步骤，针对上面的成功率指标，我们会添加分钟级别的实时监控告警，做到及时发现，快速响应和紧急修复。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在使用链路中模块渲染的成功率、Native Crash率、JS错误率也属于关键指标，这些任务的失败也会导致容器的不可用，针对这些指标我们也会采用实时监控措施，并且添加降级手段，例如回滚bundle版本，或者把MRN和Mach容器降级为Native容器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;6. 外卖容器化架构的监控运维&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面讲到了容器化架构的各项衡量指标，那么把这些指标具体落到实处的工作就是线上的运维监控工作。工欲善其事，必先利其器，对于监控运维工作，一定要有合适的监控工具辅助配合才能事半功倍，公司内有很多优秀的监控统计工具可供使用，这里的难点就是如何根据监控的需要判断选择合适的工具。还有就是合理的划分监控维度和数据指标的优先级，例如对于能够影响到链路稳定性的关键指标，我们需要做到分钟级的监控，一旦出现问题就能及时收到告警，对于非关键指标，则通过生成日报的方式，方便开发者的统计和分析。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;工具的使用&lt;/strong&gt;上主要分为大盘工具、具体异常工具、灰度降级工具、告警工具等（&lt;/span&gt;&lt;span&gt;以下是美团内部使用的工具&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;业务覆盖维度监控&lt;/strong&gt;可以分为全局监控和局部（&lt;/span&gt;&lt;span&gt;单业务&lt;/span&gt;&lt;span&gt;）监控。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;时间维度监控&lt;/strong&gt;：可以按天、小时、分钟的时间维度。天级别的监控主要是一些非关键路径指标，例如一些性能指标，页面加载时间、页面FPS、JS渲染时间等，我们可以按天维度的生成数据报表，已邮件的数据发送日报。当App灰度上线时，我们会开始小时级别的监控，每过半小时通过IM软件向广播一些关键指标，方便开发者跟踪线上数据的稳定性。分钟级别的监控则是针对关键指标，观察分钟维度上的变化，如果关键指标超过阈值，或者波动过大，就会及时产生告警。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面我们以一个开发者的视角去看一下外卖容器化架构的监控运维系统。从获取信息的方式上可以分为主动查询和被动推送，开发者可以通过监控工具监控全局和局部数据的变化趋势，也可以分析具体异常Case；也可以从IM工具，邮件等收到相关的推送数据，以便及时响应。在控制运维上，开发者可以通过Eva、Horn等美团内部的灰度系统进行灰度发布，当灰度期发现问题的时候，可以及时地通过停止灰度，版本回滚，关闭入口的方式进行降级容灾处理。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.39655172413793105&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKXvEA8p4aa5GLvSYoDgFtIcRCOk6NZeaoAcbCMicZqhqRCA19vCQx5x3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2668&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;7. 外卖容器化架构的发布能力&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;7.1 容器化架构发布体系&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;容器化使外卖业务具备了强大的动态化能力，但动态化能力又和需要相应的发布能力来支持，发布能力是我们业务开发质量和效率的重要保障，也是我们容器化建设工作过程中的重点环节，这一节主要介绍一下外卖容器化的发布能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从发布能力类型的角度看主要可以分为三种类型：（1）容器内容的发布，包括发布整个页面或者发布页面中的局部模块；（2）配置下发，通过API或其他配置平台，下发布局协议、AB测试、样式配置、功能配置、模板配置、容器配置等，大大提高了业务的灵活度和线上验证能力；（3）灰度、降级下发，通过UUID，用户画像等信息做到灰度发布，降级回滚等控制能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从发布资源的的角度看主要分为两种：一种是普通的资源，例如发布一个Web页面，或者通过发布新版API来控制页面局部容器的展示与否和展示的位置，同时我们也可以进行一些AB Test操作；另一种是bundle资源，主要是针对MRN容器和Mach容器，每个MRN容器和Mach容器的资源都会先被打包成一个bundle，然后通过发布系统下发到终端，然后终端解析bundle中的代码和资源，最终渲染页面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从发布阶段的角度看，可以分为测试阶段、上线阶段、灰度阶段和全量阶段，其中上线阶段是最终的环节，我们增加了很多校验和保护手段来尽量保证上线操作的正确性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;7.2 跟版本发布流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然我们具随时备动态发布能力，但正常的版本迭代还是会存在中，所以外卖这边的节奏是周动态迭代+双周版本迭代，这保证了我们的开发工作有个一清晰的周期。在动态发布阶段中最关键的阶段操作上线阶段。以MRN为例，目前外卖业务中应有70多个bundle，再算上测试环境的bundle就有接近150个bundle，只是管理这些bundle就是一个复杂的工作，况且在进行上线操作时还是涉及发布的目标App、App版本的上下界、MRN版本的上下界等，一不小心就会造成操作失误，所以进行上线操作时需要非常谨慎。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们针对操作上线阶段进行了事务流水线，通过流水线建立保护措施，一个bundle的上线要经历一个流水线的若干操作。首先，操作人根据上线SOP手册进行若干检查操作，同时编写标准格式的发布说明，然后周知相关核心人员后在操作系统上发起上线申请，Leader和QA收到申请后会进行检查并审批，审批通过后还要避开App使用的高峰期或节假日上线，上线后通过灰度发布观察各项数据指标，指标正常后全量发布。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.1679604798870854&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKX2kRdVHTHjhTHKWd8ZT8x8O2wZtmUtIQgHOu3JYa41KJHLSVz57ylSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2834&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;7.3 bundle资源发布&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;bundle是我们最常发布的资源类型，这里再结合发布工具讲解一下bundle的发布过程。MRN和Mach都是以bundle的形式下发到设备终端的，我们在发布bundle的时候主要会用到两个工具，打包工具Talos和发布工具Eva（&lt;/span&gt;&lt;span&gt;美团内部工具&lt;/span&gt;&lt;span&gt;）。一个bundle的工程文件主要由三个部分组成：配置文件、源代码和资源文件，其中配置文件用于指导Talos对工程文件进行打包，多个bundle可以共享一份配置文件。当我们准备发布一个bundle时，先找到该bundle在Talos的发布模板，选择发布环境（&lt;/span&gt;&lt;span&gt;测试或线上&lt;/span&gt;&lt;span&gt;），然后进行一键打包，然后Talos会进行一系列流水线操作，包括Clone代码、配置环境、进行Lint检查、构建和上传等。Talos打包完毕后将bundle上传到Eva系统，然后Eva负责bundle的分包、上线、下线、灰度等操作，最终下发到终端设备上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;未来，我们还将引入美团住宿的MRN-DevOps来进一步的屏蔽当前多系统的问题，降低整个周期管理的成本，特别是发布前的人工检查成本，逐渐实现RD在一个平台上操作从研发到发布运维的所有实现。尽可能地减少人工成本，提升自动化。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.12510088781275222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKXFHRkYZAib3bPwa5oXGQZA3wF7ZMOCbHM6ovwyawUmlUb1sX01w3ThDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2478&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;7.4 多种发布能力综合使用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面介绍的是以bundle资源形式的发布流程，过程较为清晰简单。下面再结合外卖首页，介绍一下局部容器化的发布方式。外卖首页是典型的流式列表，在局部容器化的架构下，首页就是由一个个矩形容器以ListView方式布局的，容器分两种，Native容器和Mach容器，Mach容器是一个通用容器，我们可以编写不同的样式模板，下发到终端后交由通用Mach容器来渲染，以此达到只使用通用容器展示不同UI样式的目的，这里涉及了Mach的发布系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首页各子容器相当于一块块积木，它们的位置排布、展示与否、模板的选择等最终交由API控制，API具备了控制首页布局，样式展示的能力，而不再是单纯的数据源。同时，首页也涉及了AB能力、灰度降级策略等其实配置项下发系统。可以看到外卖首页的容器化是由多种发布能力配合支撑的，是外卖发布能力体系的“集大成者”。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2786479802143446&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWeVa3uH5PnFOop5GajBtKXQOuuLzPugQy5tLyDta84ichAafoznWCA4QibBDiaN9Sb245NOEULPYOYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2426&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;8. 总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;好的架构是要随着业务的发展，不断演变去适应业务的发展。美团外卖从一个很小规模，每日单量只有几千的业务，逐渐地走到今天，每日单量峰值超过4000万，组织架构也从一个十几个人的团队，逐渐发展到现在多角色、多垂直业务方向，上千人共同协作的团队。移动端上的架构，为了适应业务的发展要求，也经历了组件化、平台化、RN混合化，再到现在向容器化的变迁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;容器化架构相对于传统的移动端架构而言，充分地利用了现在的跨端技术，将动态化的能力最大化的赋予业务。通过动态化，带来业务迭代周期缩短、编译的加速、开发效率的提升等好处。同时，也解决了我们面临着的多端复用、平台能力、平台支撑、单页面多业务团队、业务动态诉求强等业务问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，容器化架构带来好处的同时，对线上的可用性、容器的可用性、支撑业务的线上发布上提出了更加严格的要求。我们通过监控下载、加载、使用链路上的可用性，来保障线上动态业务的可用性。针对容器，我们利用成熟的测试基建，建设容器的自动化测试来保障容器的可用性。针对发布，我们建设迭代流程，配合发布流水线，将线上的发布变得更为可控。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;截止到目前为止，外卖业务经过了几十个动态化业务上线窗口，累积共发版百次以上。未来半年，我们还将进一步从业务需求入手，将业务需求细分归类，让产品侧逐渐建立容器和动态化需求的概念，能够从源头上，逐渐的将业务进行划分，最终使得每个业务需求，都可以归类抽象成可以动态下发的业务和容器能力建设，从而进一步的完善容器化架构的能力和支持更多的的业务场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;9. 参考资料&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;10. 作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;郭赛，同同，徐宏，均为美团外卖iOS工程师。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>673a566ae612a402f2ebf3437048ae09</guid>
<title>2020 年了 Java 还有前途吗？</title>
<link>https://toutiao.io/k/pqla0uc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今年，Java达到了一个令人难以置信的里程碑，并达到了25岁的高龄。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这让我们开始思考并决定深入研究数据，以一劳永逸地发现Java的普遍状态，并帮助回答您的一些迫切问题。我们发现的某些内容可能不足为奇，但也有一些非常出乎意料的见解。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;开发者分布在哪里&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个问题是：“大多数Java开发人员都在哪里，我们中有多少人呢？” 我们通过结合可以获取的最准确的信息来进行回答，然后进行推断以得出我们认为是很好的猜测。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;市场研究和分析团队&lt;/em&gt;对&lt;em&gt;开发人员估计模型的&lt;/em&gt;最佳估计表明，当今世界上有大约&lt;strong&gt;520万专业Java开发人员&lt;/strong&gt;将Java作为&lt;strong&gt;主要语言&lt;/strong&gt;。但是，如果我们包括主要使用其他编程语言，但同时也使用Java的专业开发人员，那么这个数字可能接近&lt;strong&gt;680万&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于这些Java开发人员的集中地，&lt;strong&gt;亚洲&lt;/strong&gt;居住的Java开发人员数量最多，大约有250万开发人员使用Java作为主要语言。北美和欧洲的数字远不及亚洲。您可能会问，“但是为什么？” 好吧，起初我们有完全相同的想法，所以我们对这些区域进行了更深入的研究，以确切地了解数字的来源。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.53625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JJRW7FxQREwaVxNZg27lQeu6Yria0QOvbgJgwcejO3NlwhFP2MEvSBhoYBxlKgbIx4rlFPn00JPB2gyFVqgPasQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;具体在哪里&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更深入地讲，我们研究了Java开发人员最多的各个国家，然后调查了为什么这些国家在专业开发方面特别喜欢Java而不是其他语言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图显示了每个国家/地区使用Java作为主要语言的开发人员所占的百分比（用于收集此数据的调查受访者最多可以选择3种主要语言）。&lt;strong&gt;中国&lt;/strong&gt;和&lt;strong&gt;韩国&lt;/strong&gt;的数值最高，分别约为51％和50％。数据取自《&lt;span&gt;👉&lt;/span&gt;&lt;em&gt;2020年开发商生态系统状况调查》&lt;/em&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;专家分析&lt;/em&gt;Java在前6个国家中如此受欢迎的原因包括Java的免费使用，政府支持和开源。对于&lt;strong&gt;中国&lt;/strong&gt;，&lt;strong&gt;西班牙&lt;/strong&gt;和&lt;strong&gt;巴西&lt;/strong&gt;尤其如此。它是在&lt;strong&gt;中国&lt;/strong&gt;和&lt;strong&gt;印度&lt;/strong&gt;进行Android移动开发的基础，并且雇用离岸员工以Java构建手机应用程序非常普遍，这可能是&lt;strong&gt;印度&lt;/strong&gt;使用高峰的原因。德国也很高，这可以归因于Java是德国软件工程师最流行的语言，因为它被用于为许多行业构建高度可伸缩的应用程序。大多数企业服务都依靠Java来驱动支持日常业务运行的应用程序，例如工资单，库存管理，报告等。德国还有一个庞大的金融部门，其Java大量用于其自身的技术，例如交易机器人，零售银行系统以及金融业为了保持竞争力而需要的其他应用程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可能曾期望&lt;strong&gt;美国&lt;/strong&gt;的Java用户比例很高，但是从很多方面讲，他们没有。有大量的技术堆栈可供选择，而且很多技术公司通常处于该堆栈的最前沿，因此可能是那里的开发人员不需要Java的功能或稳定性，而是使用允许他们执行以下操作的语言：快速建立并测试。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.685&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JJRW7FxQREwaVxNZg27lQeu6Yria0QOvbSNdY0icejYwAUibM1ox1Rias0iccGiatia8kb3rJ46Ek9ebIosx29o1oe4bA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;行业见解&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据&lt;span&gt;👉&lt;/span&gt;&lt;em&gt;2020年开发人员生态系统状况调查&lt;/em&gt;，超过三分之一的专业开发人员将Java用作主要语言，而Java仍然是仅次于JavaScript的专业开发人员中的第二主要语言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;专家分析&lt;/em&gt;看到JavaScript和Java处于配对状态，这是不足为奇的。使用Java的开发人员经常使用JavaScript编写前端和任何快速脚本。由于机器学习的普及，Python可能排名第三。总的来说，我们希望Web成为开发人员生态系统的重要组成部分，因此JavaScript，HTML和CSS以及PHP将始终保持稳定的地位。SQL也将一直存在，因为并不需要太多容量的数据库。C ++也是一种可靠的语言，因为它用于许多嵌入式应用程序，因此它不会很快消失在图表中。尽管C＃似乎正在逐渐衰落，但我想如果Java高，那么C＃就会低，因为它们在功能方面都非常相似。关于我为什么认为Java在专业发展领域如此之高的原因–与关于德国提到的内容相似。大多数企业业务服务都依赖Java使它们顺其自然。不仅是IT部门-几乎每个公司，无论是在分销，制造还是银行业，都将IT服务作为其基础结构的一部分，而这些服务（例如薪资或库存管理）通常都是在后端使用Java构建的。因此，为这些公司工作的专业开发人员经常使用Java。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JJRW7FxQREwaVxNZg27lQeu6Yria0QOvbAtib24tibxkhQibxwxFibtHL5EYotaajeNeC9vpxs9wD55YicXYwQ5P9ZUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;用Java开发的软件类型&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;快速浏览使用Java开发的软件类型应该可以了解其使用情况统计信息。根据《&lt;span&gt;👉&lt;/span&gt;&lt;em&gt;2020年开发者生态系统状况》&lt;/em&gt;的结果，&lt;strong&gt;Web服务&lt;/strong&gt;是Java最受欢迎的领域，占52％。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;专家分析&lt;/em&gt;令人惊讶的是，Java在商业智能/数据科学/机器学习中如此流行，因为您认为这将是Python的领域。其他Web服务的后端通常是Java，因此并不令人惊讶，因为使用Java编写业务应用程序也很有意义，因为它们也需要与后端和数据库一起工作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JJRW7FxQREwaVxNZg27lQeu6Yria0QOvbGmtLPN0GrVuSIVPllVT0ydp0icjCqZWdIZ8aPicq88nIBaVvea0wicy0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用Java的热门行业&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们知道了为什么许多专业开发人员都使用Java，下面让我们专门研究一下Java的使用行业。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据&lt;span&gt;👉&lt;/span&gt;&lt;em&gt;2020年开发者生态系统调查&lt;/em&gt;，Java程序员主要在&lt;strong&gt;IT服务（42％）和金融与金融科技（44％）中工作，但这并不是说Java不用于其他行业。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;专家分析&lt;/em&gt;金融和金融科技领域主要涉及金融交易所，零售银行系统，创建计算引擎以及开发本地定制工具和服务，以使公司在市场上具有竞争力。Finance和FinTech几乎都是用Java建立的，因此这里并不奇怪。IT服务也是如此，因为许多针对非IT公司的薪资系统和库存管理服务都是基于Java构建的。其他行业虽然很有趣。由于Android，移动开发的速度可能很高，因此以这种方式使用Java。大数据和数据分析非常有趣，因为该行业由Python领导，但是后端可能会使用Java和JVM语言。软件开发工具，当然可以。JetBrains IDE当前使用Java构建。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.475&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JJRW7FxQREwaVxNZg27lQeu6Yria0QOvbyof3ZicKPsH3gR6cb6FaKugqJg0A8qRC4OOw94BFM4bXeYyc5FeV0yw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Java工具&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Java版本&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Java 8&lt;/strong&gt;仍然是最受欢迎的版本。使用Java作为主要语言的专业开发人员中有75％使用了它。下图显示了Java版本的分布情况，假设开发人员在&lt;span&gt;👉&lt;/span&gt;&lt;em&gt;2020开发者生态系统调查中&lt;/em&gt;选择了其中的几个版本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;专家分析&lt;/em&gt;有几个因素导致Java 8如此受欢迎的原因。首先，它具有典型Java开发人员从该语言中所需的一切，它具有lambda和流，并且通常是一个易于使用的好版本。而且，人们真的不愿意使用Java9。Java9引入了一些重大的体系结构更改，人们担心这些更改会破坏他们用Java 8构建的应用程序。最重要的是，Oracle推出了每两年发行一次的版本，并且因此并非所有版本都长期受支持，因此Java 9，Java 10，Java 12和Java 13仅受6个月支持，这可能就是为什么它们都只有这么少用户的原因。Java 13之所以如此之高，是因为当本调查结束时，它是最新版本，因此您可以预期Java 13会在几个月后下降。Java 11于2018年问世，它是具有长期支持的最新版本。许多企业仍未迁移到它，因为他们担心超越Java 9（随着体系结构的更改）会破坏一切，并且&lt;span&gt;👉&lt;/span&gt;Java 11引入了新的许可和新的订阅，因此它更加担心如果您使用错误的版本，以错误的方式，Oracle会罚款您。许多开发人员不升级到Java 11的最后一个主要因素是，它没有许多令人兴奋的新功能，因此语言的功能并未降低升级的风险。Java 17将是具有长期支持的下一个版本，并带有许多新功能，但是从Java 8到Java 17的直接更新将有其自身的问题。我的预测是，我认为下一个长期版本Java 17将比上一个LTS（长期支持版本）Java 11更受欢迎。不过，作为Java 17的准备，我真的不能对此施加太大压力，建议您先将代码库更新为Java 11，然后再更新为Java 17，以避免出现大问题。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.44&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JJRW7FxQREwaVxNZg27lQeu6Yria0QOvbPZicaVYdrHsAPV1c6Gmwu4yyKqTQYW58gpjEicBEq5ETQzutnh9ZL4wA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;流行的应用服务器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在过去的三年中，&lt;strong&gt;Apache Tomcat&lt;/strong&gt;仍然是最受欢迎的应用服务器，而&lt;strong&gt;JBoss EAP&lt;/strong&gt;和&lt;strong&gt;WildFly的使用&lt;/strong&gt;却减少了一半。所提供的数据来自所有使用Java作为主要语言的&lt;em&gt;开发人员&lt;/em&gt; ，这些&lt;em&gt;人员&lt;/em&gt;参加了&lt;span&gt;👉&lt;/span&gt;&lt;em&gt;2018年&lt;/em&gt;和&lt;span&gt;👉&lt;/span&gt;&lt;em&gt;2020年&lt;/em&gt;的&lt;em&gt;Developer Ecosystem Survey&lt;/em&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;专家分析&lt;/em&gt;Jetty位居第二，但确实令人惊讶地低。可能是某些正在使用Spring Boot和其他微服务框架的开发人员可能没有意识到他们在幕后使用的东西–他们可能正在使用Tomcat或Jetty而不了解它们。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.44&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JJRW7FxQREwaVxNZg27lQeu6Yria0QOvbgV2DwTRW4QgmoWKbDDT62IFbicibMLcOiafibSP31hlu3mz73LHgSr5lZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前五名Web框架&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Spring Boot&lt;/strong&gt;在2018年已经和&lt;strong&gt;Spring MVC&lt;/strong&gt;同样流行了 ，现在（2020年）已经更加流行了。给出的数据来自所有使用Java作为主要语言的开发人员。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;专家分析&lt;/em&gt;这基本上只是在确认Spring拥有市场。仍然有人在使用Struts 1几乎可以肯定只在旧版应用程序中使用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.44&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JJRW7FxQREwaVxNZg27lQeu6Yria0QOvbRAu1g11M7xIAzdyaRhxgopQWvXWLm8IMpIQfW9tcqJOysxw638mrdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前五名JVM探查器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该&lt;span&gt;👉&lt;/span&gt;&lt;em&gt;开发者的生态系统国家调查2020&lt;/em&gt;显示，&lt;strong&gt;VisualVM的&lt;/strong&gt;使用由用户的24％，而一半使用没有。给出的数据来自所有使用Java作为主要语言的开发人员。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JJRW7FxQREwaVxNZg27lQeu6Yria0QOvbk99w4uhaHhOEFnexkpvfTQyOiaAeud2pUariaD7bjlvL8mLGL21CGDTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前5名IDE /编辑器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据&lt;em&gt;开发者生态系统调查&lt;/em&gt; &lt;span&gt;👉&lt;/span&gt;&lt;em&gt;2018&lt;/em&gt;和&lt;span&gt;👉&lt;/span&gt;&lt;em&gt;2020的&lt;/em&gt;报告，&lt;strong&gt;IntelliJ IDEA&lt;/strong&gt;的份额从2018年的55％增加到2020年的72％，而其他四个的使用减少了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;专家分析&lt;/em&gt;不过，即使我们对调查结果进行了加权，我们也不否认信息可能会偏斜，因为这是从&lt;span&gt;👉&lt;/span&gt;&lt;em&gt;JetBrains开发者生态系统状况调查&lt;/em&gt;得出的，JetBrains的主要产品之一是IntelliJ IDEA。但是，这并不是说这并非完全不合理，就好像我们在其他调查中看到的一样，IntelliJ IDEA通常是最常用的IDE之一，通常拥有约55-60％的用户份额。VS Code正在增长，这不是从竞争的角度来看，实际上是从对IDE给您的理解上缺乏了解的角度出发。VS Code是一个代码编辑器，具有一些您可以在IDE中找到的功能以及可以提供附加功能的扩展-因此，如果人们转向VS Code进行开发，则可能意味着开发人员不知道什么是功能齐全的功能。IDE可以给他们。在网络空间中，使用编辑器是可以理解的，因为网络开发人员通常使用动态语言，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JJRW7FxQREwaVxNZg27lQeu6Yria0QOvbhrJEKxYYQnMoyToVcHKFMOKiacHKAnsW7ptM0DdgX6gtTdPyPDpvuGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;讨论最多的Java工具和其他语言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java在IT社区中经常被讨论，其中之一就是&lt;em&gt;Stack Overflow&lt;/em&gt;。我们从“ &lt;span&gt;👉&lt;/span&gt;&lt;em&gt;问题与解答”&lt;/em&gt;章节中获取了数据，以找出哪些标签最常出现“java”。纵轴表示Java提及的内容，横轴表示标签出现的总数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;专家分析&lt;/em&gt;该图表可能对想要确保使用正确技术或为他们寻找工具的用户很有用。这些语言很有意思，但这可能是因为人们正在寻找Java与其他语言之间的比较。正则表达式是人们苦苦挣扎的一种利基市场，但他们跻身榜单并不奇怪。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JJRW7FxQREwaVxNZg27lQeu6Yria0QOvbYPhAibibMF4mfoj2AiaxxUlqfdcCdbepR4CMyibuniarfs3PdxTM2V68FZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Java社区中的热门话题&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Java讨论&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们分析了有关&lt;span&gt;👉&lt;/span&gt;&lt;em&gt;“ java” subreddit的&lt;/em&gt;帖子， 并发现Java用户在&lt;em&gt;Reddit&lt;/em&gt;上讨论最多的主题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;专家分析&lt;/em&gt;这些正是我期望看到的主题。例如，用Java编写代码的人总是会对这种语言是否仍然有需求感兴趣，毕竟，这种语言还在发展。我们刚刚庆祝了Java诞生25周年，因此人们希望检查它是否过时和遗留，并且仍然有效。特别是，如果他们刚刚大学毕业，却不知道他们所学的语言是否会为他们提供工作机会。在容器中部署Java是一个非常热门的话题，包括我在内，这是每个人都想知道的东西，但几乎找不到任何信息。我对性能优化这个主题并不感到惊讶，尽管我认为这个主题有点多余，因为大多数应用程序实际上并不需要开发人员进行优化，尽管许多开发人员认为这是一项重要的职业技能。使后端和前端协同工作也可能非常复杂，我可以想象对此存在很多问题。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.295&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JJRW7FxQREwaVxNZg27lQeu6Yria0QOvbkDyfkuPosZLNkbOoIiaibeV0DEAZaic7RSvFgN8QDs6mrXicTsY9uXuHEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8779a7b741dda9b7cfd6c6592574eac8</guid>
<title>Kubernetes 集群升级指南：从理论到实践</title>
<link>https://toutiao.io/k/bn1f6rt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-tools=&quot;新媒体管家&quot; data-label=&quot;powered by xmt.cn&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnMFaOoAklrxdOvPwLJwOS8RYYmSQgS6FFg5RCbbNXgeGsv25m3rF6GDKOAM775U5iaBZy0IHSxZMA/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;730&quot; data-cropy1=&quot;37.88927335640138&quot; data-cropy2=&quot;431.9377162629758&quot; data-ratio=&quot;0.5397260273972603&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yvBJb5IiafvnMFaOoAklrxdOvPwLJwOS8Gg0dtQYSV3z6IwqBe4BFlSdyvFyUZBCVxMBIpZaZd6To5AZcvg3Acg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;730&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作者 | 高相林（禅鸣）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;导读：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;集群升级是 Kubernetes &lt;/span&gt;&lt;span&gt;集群生命周期中最为重要的一环，也是众多使用者最为谨慎对待的操作&lt;/span&gt;&lt;span&gt;之一。&lt;/span&gt;&lt;span&gt;为了更好地理解集群升级这件事情的内涵外延，我们首先会对集群升级的必要性和难点进行阐述；&lt;/span&gt;&lt;span&gt;随后会对集群升级前必须要做的前置检查进行逐一讲解；&lt;/span&gt;&lt;span&gt;接下来会对两种常见的升级方式进行展开介绍；&lt;/span&gt;&lt;span&gt;最后对集群升级的三个步骤进行讲解，帮助读者从理论走入实践。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;2858960&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763309&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;0.45454545454545453&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/US10Gcd0tQGY9ddd5GpbmVRuaRfuaESAUBGE7uHX5G0nxxLSub2QTKZdu538V7GaHXS5jsTCebYCUibaHsjg0ow/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;22&quot; title=&quot;动态黑色音符&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;升级的必要性&amp;amp;难点&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 Kubernetes 领域，得益于活跃的开源社区，Kubernetes 的迭代速度较快，目前保持在每个季度发行一个新版本的节奏。新版本的 Kubernetes 有着更为先进的新特性、更加全面的安全加固和漏洞修复。前一段时间社区刚刚完成了 1.19 版本的正式发布。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于发展如此快速的开源项目，跟上社区的步伐就显得更为重要，而集群升级能力就是帮助我们跟上社区步伐的不二选择。我们可以从以下两个方面对集群升级的必要性进行说明：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;讲完了集群升级的必要性，我们来详细看一下集群升级的难点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前多数 Kubernetes 使用者对集群升级这件事持有着非常保守的态度，害怕集群在升级的过程中出现不可预期的情况，也有使用者将集群升级称之为“给飞行中的飞机换引擎”。那么，使用者对于升级的保守态度主要来源于什么原因呢？我认为有以下几点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“千集群千面”的情况的存在，导致了集群升级需要以一套逻辑完成各种不同情况集群的升级工作，这也正是集群升级的困难之处。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-lake-id=&quot;38fcd854ab2b909adc8d7779a48ac3d5&quot; data-wording=&quot;true&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;2858960&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763309&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;0.45454545454545453&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/US10Gcd0tQGY9ddd5GpbmVRuaRfuaESAUBGE7uHX5G0nxxLSub2QTKZdu538V7GaHXS5jsTCebYCUibaHsjg0ow/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;22&quot; title=&quot;动态黑色音符&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;升级预检&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正如我们前面所说，给正在对外提供服务的 Kubernetes 集群升级，就好比是“给飞行中的飞机换引擎”。因为集群升级面临着众多难点，也使得众多的 Kubernetes 集群维护者对集群升级这件事情比较紧张。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以通过详细的升级预检，来消除集群升级的不确定性。对于上面列举的集群升级的难点，我们也可以分别进行详细的升级预检，对症下药，将难点逐一击破。升级预检主要可以分为三个方面：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;0d2ab228b76b33d96dae1601dc011ec9&quot; data-wording=&quot;true&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3198855&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763310&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;1. 核心组件健康检查&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;说到核心组件健康检查，就不得不剖析一下集群的健康对于集群升级的重要性。一个不健康的集群很可能会在升级中出现各种异常的问题，就算侥幸完成了升级，各种问题也会在后续使用中逐渐凸显出来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有人会说，我的集群看起来挺健康的，但是升级之后就出现问题了。一般来说，之所以会发生这种情况，是因为在集群在升级之前，这个问题已经存在了，只不过是在经历了集群升级之后才显现出来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在了解了核心组件健康检查的必要性之后，我们来看一下都需要对那些组件进行检查：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;7b8e6c7166d0dc53e5f87f2d45f0d8e3&quot; data-wording=&quot;true&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3198855&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763310&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2. 节点配置检查&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;节点作为承载 Kubernetes 的底层元计算资源，不仅运行着 Kubelet、Docker 等重要的系统进程，也充当着集群和底层硬件交互接口的角色。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;确保节点的健康性和配置的正确性是确保整个集群健康性重要的一环。下面就对所需的检查项进行讲解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul data-lake-id=&quot;83da948b57802043181fabbe2ccb7c8a&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;操作系统配置：需要确定基础的系统组件（yum、systemd 和 ntp 等系统服务是否正常）和内核参数是否配置合理；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;kubelet：需要确定 kubelet 的进程健康、配置正确；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Docker：需要确定 Docker 的进程健康、配置正确。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;fe396c84e3106a85ebc64467b8634bfc&quot; data-wording=&quot;true&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3198855&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763310&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;3. 云资源检查&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;运行在云上的 Kubernetes 集群依赖着众多云资源，一旦集群所依赖的云资源不健康或者配置错误，就会影响到整个集群的正常运行。我们主要对下列云资源的状态和配置进行预检：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul data-lake-id=&quot;91c63c10ab13612bab2177e562dfcb66&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;apiserver 所使用的 SLB：需要确定实例的健康状态和端口配置（转发配置和访问控制配置等）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;集群所使用的 VPC 和 VSwitch：需要确定实例的健康状况；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;集群内的 ECS 实例：需要确定其健康状况和网络配置。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-lake-id=&quot;09c91558e40331d436b4e72c53fc32d5&quot; data-wording=&quot;true&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;2858960&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763309&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;0.45454545454545453&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/US10Gcd0tQGY9ddd5GpbmVRuaRfuaESAUBGE7uHX5G0nxxLSub2QTKZdu538V7GaHXS5jsTCebYCUibaHsjg0ow/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;22&quot; title=&quot;动态黑色音符&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;两种常见的升级方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2 data-lake-id=&quot;09c91558e40331d436b4e72c53fc32d5&quot; data-wording=&quot;true&quot;&gt;&lt;span/&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;在软件升级领域，有两种主流的软件升级方式，即原地升级和替换升级。这两种升级方式同样适用于 Kubernetes 集群，它们采用了不同软件升级思路，但也都存在着各自的利弊。下面我们来对这两种集群升级方式进行逐一讲解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;991bf236f53ebf7814bd5582ae57ea4a&quot; data-wording=&quot;true&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3198855&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763310&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;1. 原地升级&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原地升级是一种精细化的、对这个那个集群改动量相对较小的一种升级方式。在升级容器的 worker 节点时，该升级方式会通过在 ECS 上原地替换 Kubernetes 组件的方式（主要为 kubelet 和其相关组件），完成整个集群的升级工作。阿里云容器服务 Kubernetes 为客户提供的集群升级就是基于这种方式的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以将 Kubernetes 的版本从 1.14 升级到 1.16 为例。首先我们会对 ECS A 上的原本为 1.14 的 Kubelet 及其配置升级为 1.16，在完成节点 ECS A 上的组件升级之后，该节点也就被成功的升级到了 1.16。然后我们再对 ECS B 进行相同的操作，将其升级为 1.16，从而完成整个集群的升级工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这个过程中节点保持运行，ECS 的相关配置也不会被修改。如图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fintranetproxy.alipay.com%2Fskylark%2Flark%2F0%2F2020%2Fpng%2F58334%2F1600249199247-85c07260-1108-4a7a-bcad-dcbdb5732dfa.png%22%2C%22originWidth%22%3A1513%2C%22originHeight%22%3A335%2C%22name%22%3A%22image.png%22%2C%22size%22%3A58941%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A140.80586%2C%22y%22%3A146.45074%2C%22width%22%3A78.02655000000001%2C%22height%22%3A27.089709999999997%2C%22text%22%3A%22ECSA%22%7D%2C%7B%22x%22%3A979.28906%2C%22y%22%3A147.32126%2C%22width%22%3A76.7533400000001%2C%22height%22%3A27.74534%2C%22text%22%3A%22ECSA%22%7D%2C%7B%22x%22%3A1294.11%2C%22y%22%3A148.89526%2C%22width%22%3A75.26330000000007%2C%22height%22%3A28.14785999999998%2C%22text%22%3A%22ECSB%22%7D%2C%7B%22x%22%3A456.26514%2C%22y%22%3A149.83342%2C%22width%22%3A72.68876%2C%22height%22%3A28.20248000000001%2C%22text%22%3A%22ECSB%22%7D%2C%7B%22x%22%3A467.05362%2C%22y%22%3A211.25827%2C%22width%22%3A53.818379999999934%2C%22height%22%3A28.97602999999998%2C%22text%22%3A%22%E8%8A%82%E7%82%B9%22%7D%2C%7B%22x%22%3A156.16118%2C%22y%22%3A211.76059%2C%22width%22%3A51.41368%2C%22height%22%3A31.851409999999987%2C%22text%22%3A%22%E8%8A%82%E7%82%B9%22%7D%2C%7B%22x%22%3A992.4329%2C%22y%22%3A212.40195%2C%22width%22%3A52.00420000000008%2C%22height%22%3A25.72739999999999%2C%22text%22%3A%22%E8%8A%82%E7%82%B9%22%7D%2C%7B%22x%22%3A1306.9567%2C%22y%22%3A212.48682%2C%22width%22%3A50.28600000000006%2C%22height%22%3A27.195610000000016%2C%22text%22%3A%22%E8%8A%82%E7%82%B9%22%7D%2C%7B%22x%22%3A161.87132%2C%22y%22%3A241.70822%2C%22width%22%3A42.87254999999999%2C%22height%22%3A27.63012999999998%2C%22text%22%3A%221.14%22%7D%2C%7B%22x%22%3A474.54318%2C%22y%22%3A243.69315%2C%22width%22%3A41.23526000000004%2C%22height%22%3A22.98129%2C%22text%22%3A%221.14%22%7D%2C%7B%22x%22%3A996.7421%2C%22y%22%3A243.78186%2C%22width%22%3A44.226499999999874%2C%22height%22%3A24.151139999999998%2C%22text%22%3A%221.16%22%7D%2C%7B%22x%22%3A1310.9414%2C%22y%22%3A243.86855%2C%22width%22%3A42.52520000000004%2C%22height%22%3A24.407650000000018%2C%22text%22%3A%221.16%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22ECSA%20ECSA%20ECSB%20ECSB%20%E8%8A%82%E7%82%B9%20%E8%8A%82%E7%82%B9%20%E8%8A%82%E7%82%B9%20%E8%8A%82%E7%82%B9%201.14%201.14%201.16%201.16%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A756.5%2C%22height%22%3A168%7D&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;128&quot; data-height=&quot;168px&quot; data-ratio=&quot;0.22109375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yvBJb5IiafvnMFaOoAklrxdOvPwLJwOS8qiaHeIqCFuZ3r7bYiat3G0f29ODXwLd26fLKIYDZPrnsbTXib36OkOPHg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; title=&quot;image.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3454269&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763310&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;1）优点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3454269&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763310&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2）缺点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;a846465925f2b47b2bab4caf6acf7c21&quot; data-wording=&quot;true&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3198855&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763310&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2. 替换升级&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;替换升级又称轮转升级，相对于原地升级，替换升级是一种更加粗狂和原子化的升级方式。替换升级会逐个将旧版本的节点从集群中移除，并用新版本全新的节点来替换，从而完成整个 Kubernetes 集群的升级工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同样以将 Kubernetes 的版本从 1.14 升级到 1.16 为例。使用替代轮转方式的情况下，我们会将集群中 1.14 版本的节点依次进行排水并从集群中移除，并直接加入 1.16 版本的节点。即将 1.14 节点的 ECS A 从节点剔除，并将 1.16 节点的 ECS C 加入集群，再将 ECS B 从集群中删除，最后将 ECS D 加入到集群中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样就完成了所有节点的轮转工作，整个集群就也就升级到 1.16 了。如图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fintranetproxy.alipay.com%2Fskylark%2Flark%2F0%2F2020%2Fpng%2F58334%2F1600249319018-6bc1be81-99fe-4d99-ad7e-7f5e7962d2f6.png%22%2C%22originWidth%22%3A1514%2C%22originHeight%22%3A336%2C%22name%22%3A%22image.png%22%2C%22size%22%3A59810%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A140.81903%2C%22y%22%3A146.58884%2C%22width%22%3A78.34921%2C%22height%22%3A26.886210000000005%2C%22text%22%3A%22ECSA%22%7D%2C%7B%22x%22%3A981.2374%2C%22y%22%3A148.32126%2C%22width%22%3A57.78019999999992%2C%22height%22%3A26.050060000000002%2C%22text%22%3A%22ECS%22%7D%2C%7B%22x%22%3A1295.5504%2C%22y%22%3A150.09784%2C%22width%22%3A77.31939999999986%2C%22height%22%3A27.746220000000022%2C%22text%22%3A%22ECSD%22%7D%2C%7B%22x%22%3A455.75504%2C%22y%22%3A151.16016%2C%22width%22%3A62.874720000000025%2C%22height%22%3A28.14781000000002%2C%22text%22%3A%22ECS%22%7D%2C%7B%22x%22%3A466.87274%2C%22y%22%3A211.01984%2C%22width%22%3A54.076599999999985%2C%22height%22%3A30.543330000000026%2C%22text%22%3A%22%E8%8A%82%E7%82%B9%22%7D%2C%7B%22x%22%3A1306.5538%2C%22y%22%3A210.40399%2C%22width%22%3A52.08600000000001%2C%22height%22%3A29.2363%2C%22text%22%3A%22%E8%8A%82%E7%82%B9%22%7D%2C%7B%22x%22%3A156.3161%2C%22y%22%3A212.31966%2C%22width%22%3A50.562070000000006%2C%22height%22%3A30.056990000000013%2C%22text%22%3A%22%E8%8A%82%E7%82%B9%22%7D%2C%7B%22x%22%3A992.9267%2C%22y%22%3A212.84319%2C%22width%22%3A52.74330000000009%2C%22height%22%3A26.961960000000005%2C%22text%22%3A%22%E8%8A%82%E7%82%B9%22%7D%2C%7B%22x%22%3A161.21388%2C%22y%22%3A243.6078%2C%22width%22%3A42.86334000000002%2C%22height%22%3A25.737450000000024%2C%22text%22%3A%221.14%22%7D%2C%7B%22x%22%3A997.9048%2C%22y%22%3A244.30598%2C%22width%22%3A43.94540000000006%2C%22height%22%3A23.820700000000016%2C%22text%22%3A%221.16%22%7D%2C%7B%22x%22%3A474.73187%2C%22y%22%3A244.34152%2C%22width%22%3A41.46283%2C%22height%22%3A23.09177999999997%2C%22text%22%3A%221.14%22%7D%2C%7B%22x%22%3A1309.5217%2C%22y%22%3A243.77707%2C%22width%22%3A45.63670000000002%2C%22height%22%3A25.055849999999992%2C%22text%22%3A%221.16%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22ECSA%20ECS%20ECSD%20ECS%20%E8%8A%82%E7%82%B9%20%E8%8A%82%E7%82%B9%20%E8%8A%82%E7%82%B9%20%E8%8A%82%E7%82%B9%201.14%201.16%201.14%201.16%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A757%2C%22height%22%3A168%7D&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;128&quot; data-height=&quot;168px&quot; data-ratio=&quot;0.221875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yvBJb5IiafvnMFaOoAklrxdOvPwLJwOS8zlkoL6tgFcG4pLUpfoS1icC49PZRgGbprf1L64tWULyAFcT18oic29ow/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; title=&quot;image.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3454269&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763310&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;1）优点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;替代升级通过将旧版本的节点替换为新版本的节点从而完成集群升级。这个替换的过程相较于原地升级更为原子化，也不存在那么复杂的中间状态，所以也不需要在升级之前进行太多的前置检查。相对应地，升级过程中可能会出现的各种稀奇古怪的问题也会减少很多。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3454269&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763310&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2）缺点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-lake-id=&quot;1c557636f63631642551da53ac3c9d00&quot; data-wording=&quot;true&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;2858960&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763309&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;0.45454545454545453&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/US10Gcd0tQGY9ddd5GpbmVRuaRfuaESAUBGE7uHX5G0nxxLSub2QTKZdu538V7GaHXS5jsTCebYCUibaHsjg0ow/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;22&quot; title=&quot;动态黑色音符&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;集群升级三部曲&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个 Kubernetes 集群主要由负责集群管控的 master，执行工作负载的 worker 和众多功能性的系统组件组成。对一个 Kubernetes 集群升级，也就是对集群中的这三个部分进行分别升级。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;故集群升级的三部曲为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fintranetproxy.alipay.com%2Fskylark%2Flark%2F0%2F2020%2Fpng%2F58334%2F1600249491846-9489d724-1429-434d-a372-724babdfbb6f.png%22%2C%22originWidth%22%3A1561%2C%22originHeight%22%3A216%2C%22name%22%3A%22image.png%22%2C%22size%22%3A26128%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A1390.0098%2C%22y%22%3A97.65796%2C%22width%22%3A68.3001999999999%2C%22height%22%3A17.788650000000004%2C%22text%22%3A%22%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%22%7D%2C%7B%22x%22%3A893.15753%2C%22y%22%3A122.126305%2C%22width%22%3A47.54307000000006%2C%22height%22%3A16.598995000000002%2C%22text%22%3A%22Worken%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%20Worken%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A780.5%2C%22height%22%3A108%7D&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;80&quot; data-height=&quot;108px&quot; data-ratio=&quot;0.13828125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yvBJb5IiafvnMFaOoAklrxdOvPwLJwOS8XdjExtDy2zPSuMBWibKkJiamWeIR3EWY7otC99pkFyVG7wuevsRHp9NA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; title=&quot;image.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面我们来对集群升级三部曲进行详细的讲解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;0508c6da98335e84226966f0bd60002b&quot; data-wording=&quot;true&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3198855&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763310&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;1. 滚动升级 master&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;master 作为集群的大脑，承担了与使用者交互、任务调度和各种功能性的任务处理。集群 master 的部署方式也比较多样，可以通过 static pod 进行部署，可以通过本地进程进行部署，也可以通过 Kubernetes on Kubernetes 的方式在另一个集群内通过 pod 的方式部署。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总而言之，无论 master 为哪种部署方式，想要升级 master 主要就是对 master 中的三大件进行版本升级，主要包括：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要注意，为了保证 Kubernetes apiserver 的可用性不中断，master 中的 kube-apiserver 最少需要有两个，这样才可以实现滚动升级，从而保证 apiserver 不会出现 downtime。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;1347b6d68ab6e3f19486d9534db6d3f6&quot; data-wording=&quot;true&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3198855&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763310&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2. 分批升级 worker&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在完成 master 的升级工作之后，我们才可以开始对 worker 进行升级。Worker 升级主要是对节点上的 kubelet 及其依赖组件（如 cni 等）进行升级。为了保证集群中 worker 不会同时发生大批量的 kubelet 重启，所以我们需要对 worker 节点进行分批升级。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要注意，我们必须要先升级 master，再升级 worker。因为高版本的 kubelet 在连接低版本的 master 时，很可能会出现不兼容的情况，从而导致节点 not ready。对于低版本的 kubelet 连接高版本的 apiserver，开源社区保证了 apiserver 对于 kubelet 两个版本的向后兼容性，即 1.14 的 kubelet 可以连接到 1.16 的 apiserver，而不会发生兼容性问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;833704eb8a02a1f0db11bd4268d79935&quot; data-wording=&quot;true&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3198855&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763310&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;3. 核心系统组件升级&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了保证集群中各个组件的兼容性，我们需要在升级集群的同时对集群中的核心系统组件进行同步升级，主要包括：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;社区的版本兼容矩阵&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：https://github.com/coredns/deployment/blob/master/kubernetes/CoreDNS-k8s_version.md&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;2858960&quot; data-style-type=&quot;undefined&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-id=&quot;2763309&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;0.45454545454545453&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/US10Gcd0tQGY9ddd5GpbmVRuaRfuaESAUBGE7uHX5G0nxxLSub2QTKZdu538V7GaHXS5jsTCebYCUibaHsjg0ow/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;22&quot; title=&quot;动态黑色音符&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;《云原生技术实践公开课》&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;去年，CNCF 与 阿里云联合发布了《云原生技术公开课》已经成为了 Kubernetes 开发者的一门“必修课”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;今天，阿里云再次集结多位具有丰富云原生实践经验的技术专家，正式推出《云原生技术实践公开课》。课程内容由浅入深，专注讲解“ 落地实践”。还为学习者打造了真实、可操作的实验场景，方便验证学习成果，也为之后的实践应用打下坚实基础。课程已经正式上线，欢迎大家观看。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yvBJb5IiafvlGW1gZHxicguU9ibkbQjAa8h6V0l1tBjmeYhiapmcLY0F0k5IEXDnLmqBpicJmib2abN5NBl7Q0tncGXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/6aVaON9Kibf5ibKRPQgZ9XgbVNsIeQUnfKSiaErmr8dtdicicS3A8m6TiavR6ZB0Eah3pD0kjQg8ACyNb1x5ibdqRg2jA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;戳原文，免费观看云原生技术实践公开课！&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fa56808e269d79317d346ec9e7b453a8</guid>
<title>C# 中的 is 真的是越来越强大，越来越语义化</title>
<link>https://toutiao.io/k/drie9rd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一：背景&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 讲故事&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近发现 C#7 之后的 is 是越来越看不懂了，乍一看花里胡哨的，不过当我静下心来仔细研读，发现这 is 是越来越短小精悍，而且还特别语义化，那怎是一个爽字了得😄，这一篇就和大家简单聊一聊。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二：C#7 之前的 is 如何使用&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 类型兼容性检测&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信学过 C# 的朋友都会知道 is 是干嘛的，而且还经常和 as 一起比较，前者一般做兼容性检测，后者一般做兼容性转换，这里我就举个例子吧：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;Main&lt;/span&gt;(&lt;span&gt;&lt;span&gt;string&lt;/span&gt;[] args&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;object&lt;/span&gt; slot = &lt;span&gt;new&lt;/span&gt; Slot() { ClothesName = &lt;span&gt;&quot;上衣&quot;&lt;/span&gt; };&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (slot &lt;span&gt;is&lt;/span&gt; Slot)&lt;br/&gt;            {&lt;br/&gt;                Console.WriteLine(&lt;span&gt;$&quot;slot is &lt;span&gt;{&lt;span&gt;nameof&lt;/span&gt;(Slot)}&lt;/span&gt;&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (slot &lt;span&gt;is&lt;/span&gt; IComparable)&lt;br/&gt;            {&lt;br/&gt;                Console.WriteLine(&lt;span&gt;$&quot;slot is &lt;span&gt;{&lt;span&gt;nameof&lt;/span&gt;(IComparable)}&lt;/span&gt;&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Slot&lt;/span&gt; : &lt;span&gt;IComparable&lt;/span&gt;&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ClothesName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;CompareTo&lt;/span&gt;(&lt;span&gt;&lt;span&gt;object&lt;/span&gt; obj&lt;/span&gt;)&lt;/span&gt; {&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;}&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.25688073394495414&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WhqIIKvibJ9Un3C9hJ9q7OqhNRZnedqwVQsKzYOGicSfuJ5pRT3sEzdKmW9ms8ZhXFX2FGrzHftHe3ne39zEuAaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;327&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这个例子可以看到， object 类型的 slot 和 Slot, IComparable 都是类型兼容的，非常简单。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 遗憾的地方&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而在实际编码中，我相信有很多朋友都会在后续的过程中用到 slot 实例，而上面的这个例子，即使我用 is 检测到了是 Slot 类型，最后我还是要 将 object slot 强转成 Slot类型，做了一次检测，又做了一个强转，这就很奇葩了，如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (slot &lt;span&gt;is&lt;/span&gt; Slot)&lt;br/&gt;            {&lt;br/&gt;                &lt;span&gt;var&lt;/span&gt; query = (Slot)slot;&lt;br/&gt;                Console.WriteLine(&lt;span&gt;$&quot;slot is &lt;span&gt;{&lt;span&gt;nameof&lt;/span&gt;(Slot)}&lt;/span&gt;, ClothesName=&lt;span&gt;{query.ClothesName}&lt;/span&gt;&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除非有毛病才写这样的代码，干嘛不直接用 as 尝试性转换将两步合为一步走呢？修改代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;            &lt;span&gt;var&lt;/span&gt; query = slot &lt;span&gt;as&lt;/span&gt; Slot;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (query != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            {&lt;br/&gt;                Console.WriteLine(&lt;span&gt;$&quot;slot is &lt;span&gt;{&lt;span&gt;nameof&lt;/span&gt;(Slot)}&lt;/span&gt;, ClothesName=&lt;span&gt;{query.ClothesName}&lt;/span&gt;&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.19525065963060687&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WhqIIKvibJ9Un3C9hJ9q7OqhNRZnedqwVfDU6rfrmxLbDfibYicib2G7qzOicKSHoZTawgwfdHp25ZoMrXibuLPSTicDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;379&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就导致很多场景下，is 都被 as 替代了，搞的 is 成了一个空架子，如果 is 能合并 as 的功能，那就🐂👃了，我觉得这个急需增强。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三：C#7 之后的 is 如何使用&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也终于在 C#7 之后对 is 进行了翻天覆地的语法糖改造，导致你初看已经不明白啦😄😄😄，下面我就一一举例来说明吧。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. is 和 复杂类型/简单类型 的结合&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在就来看一下怎么用新is 解决刚才两次转换的问题，如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;            &lt;span&gt;object&lt;/span&gt; slot = &lt;span&gt;new&lt;/span&gt; Slot() { ClothesName = &lt;span&gt;&quot;上衣&quot;&lt;/span&gt; };&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(slot &lt;span&gt;is&lt;/span&gt; Slot query)&lt;br/&gt;            {&lt;br/&gt;                Console.WriteLine(&lt;span&gt;$&quot;slot is &lt;span&gt;{&lt;span&gt;nameof&lt;/span&gt;(Slot)}&lt;/span&gt;, ClothesName=&lt;span&gt;{query.ClothesName}&lt;/span&gt;&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.20059880239520958&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WhqIIKvibJ9Un3C9hJ9q7OqhNRZnedqwVfy95lQCibC8Lh6XdOrWYtK8KAJQmEXTt030MP270ykE8eBdvIzUxPuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;334&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码表面意思是：先用 is 检测 slot 是否为 Slot 类型，如果是就赋值给 Slot 类型的 query 变量，哈哈，有点意思吧，为了验证是否如我所说，用反编译工具看看。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.39552238805970147&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WhqIIKvibJ9Un3C9hJ9q7OqhNRZnedqwVviaNDOtaDdtKUHEbExHLU8nEKBxiadx4mz7OZtdYQPOia5umhjJCIYwJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;804&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.44576719576719576&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WhqIIKvibJ9Un3C9hJ9q7OqhNRZnedqwVetVpQfiaO1Nul1dWJaGKhF40B5lL49NJnryUvGZhoMUibSjJsDpNyCzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;756&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在实操中，编译器都用 as 进行了还原，不过从代码流畅性来看，ILSpy更🐂👃一点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了和类实例比较之外，还可以和 int,string,tuple ...进行比较， 代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;            &lt;span&gt;object&lt;/span&gt; e = &lt;span&gt;150&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;//字符串比较&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;is&lt;/span&gt; &lt;span&gt;&quot;hello&quot;&lt;/span&gt;) { }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;//整形比较&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;is&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;) { }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;//tuple 比较&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;e &lt;span&gt;is&lt;/span&gt; (&lt;span&gt;&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;&lt;/span&gt;))&lt;/span&gt; { }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. is 和 null 的结合&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家在写 sql 的时候判断某一个字段是否为 null，通常都会这样写：&lt;code&gt;username is null&lt;/code&gt; 或者 &lt;code&gt;username is not null&lt;/code&gt; ，哈哈，这种写法也被引入到 C# 中了，有意思吧，上代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;            &lt;span&gt;object&lt;/span&gt; e = &lt;span&gt;150&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;is&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            {&lt;br/&gt;                Console.WriteLine(&lt;span&gt;&quot;e is null&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;is&lt;/span&gt; not &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            {&lt;br/&gt;                Console.WriteLine(&lt;span&gt;&quot;e is not null&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么语义化的写法在C#中看到是不是有点不习惯，那为啥在 sql 中就习以为常呢？其实反编译过来也没啥，就是一个 == 判断，如下代码：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6486486486486487&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WhqIIKvibJ9Un3C9hJ9q7OqhNRZnedqwVqVw0BQUvpGm7oSP00ksujvsmxIbq2OlUseoZAibgEyA50Qfb8Pno0qw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;518&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. is 和 and ，or 的结合&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在大家都看到了 is 通常是放在 if 语句中，既然在 if 语句中，那肯定有很多的逻辑判断，这就需要结合 and，or 构建非常复杂的逻辑关系，不要眼花哦。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;            &lt;span&gt;object&lt;/span&gt; e = &lt;span&gt;150&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;is&lt;/span&gt; &amp;gt;= &lt;span&gt;100&lt;/span&gt; and &amp;lt;= &lt;span&gt;200&lt;/span&gt;)&lt;br/&gt;            {&lt;br/&gt;                Console.WriteLine(&lt;span&gt;$&quot;e=&lt;span&gt;{e}&lt;/span&gt; 果然 大于 100 并且 小于 200&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;is&lt;/span&gt; &lt;span&gt;100&lt;/span&gt; or &lt;span&gt;150&lt;/span&gt; or &lt;span&gt;200&lt;/span&gt;)&lt;br/&gt;            {&lt;br/&gt;                Console.WriteLine(&lt;span&gt;$&quot;e=&lt;span&gt;{e}&lt;/span&gt; 是在 100,150,200 三个数字中&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;is&lt;/span&gt; not &lt;span&gt;null&lt;/span&gt; and not &lt;span&gt;&quot;&quot;&lt;/span&gt;)&lt;br/&gt;            {&lt;br/&gt;                Console.WriteLine(&lt;span&gt;$&quot;e=&lt;span&gt;{e}&lt;/span&gt;，模拟 !string.IsNullOrEmpty 功能&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.26842105263157895&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WhqIIKvibJ9Un3C9hJ9q7OqhNRZnedqwV3yGuibfiaytGoBPuH6WRXZic91BmsgRXLq04pga0mzz9jNWia4gkcOuHuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到最后的: &lt;code&gt;e is not null and not &quot;&quot;&lt;/code&gt; 其实等价于 &lt;code&gt;!string.IsNullOrEmpty&lt;/code&gt;, 是不是有点意思哈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有一点要提醒的是，上面的 e 在编译器层面都是 object 类型，如果你想在 编译器层面使用 int 运作，还是用 例子1 的方式转换一下哈，如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23401360544217686&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WhqIIKvibJ9Un3C9hJ9q7OqhNRZnedqwVLk2FYOd6gxe0z8zGj6o61mibG3z1r4MAc1xblcficKyr3ZDbZlyduwmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;735&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. is 和 var 的结合&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 is 和 var 结合起来就更🐂👃了，可以实现在 if 判断的过程中生成临时变量，如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; e = &lt;span&gt;150&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;is&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; i &amp;amp;&amp;amp; i &amp;gt;= &lt;span&gt;100&lt;/span&gt; &amp;amp;&amp;amp; i &amp;lt;= &lt;span&gt;200&lt;/span&gt;)&lt;br/&gt;            {&lt;br/&gt;                Console.WriteLine(&lt;span&gt;$&quot;e=&lt;span&gt;{i}&lt;/span&gt; 果然 大于 100 并且 小于 200&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面代码中的 i 就是一个临时变量，后面做的一切业务逻辑都是基于 i 这个临时变量的，如果还没有领会到精粹，没关系，我举一个项目中的例子吧。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们公司是搞衣物洗涤自动化，也需要对线下 传输线上的衣服进行自动化上挂，取走和衣物组合搭配，举个例子：&lt;code&gt;找到 刚好挂了一件裤子L &amp;amp;&amp;amp; 一件上衣L &amp;amp;&amp;amp; 总衣服个数=2 的 挂孔号&lt;/code&gt;，要是还没听懂就算了，直接上代码说话。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Program&lt;/span&gt;&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;Main&lt;/span&gt;(&lt;span&gt;&lt;span&gt;string&lt;/span&gt;[] args&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;var&lt;/span&gt; slotList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Slot&amp;gt;()&lt;br/&gt;            {&lt;br/&gt;                &lt;span&gt;new&lt;/span&gt; Slot()  {SlotID=&lt;span&gt;1&lt;/span&gt;, ClothesID=&lt;span&gt;10&lt;/span&gt;,ClothesName=&lt;span&gt;&quot;上衣&quot;&lt;/span&gt;, SizeName= &lt;span&gt;&quot;L&quot;&lt;/span&gt; },&lt;br/&gt;                &lt;span&gt;new&lt;/span&gt; Slot()  {SlotID=&lt;span&gt;1&lt;/span&gt;, ClothesID=&lt;span&gt;20&lt;/span&gt;,ClothesName=&lt;span&gt;&quot;裤子&quot;&lt;/span&gt;, SizeName= &lt;span&gt;&quot;M&quot;&lt;/span&gt; },&lt;br/&gt;                &lt;span&gt;new&lt;/span&gt; Slot()  {SlotID=&lt;span&gt;1&lt;/span&gt;, ClothesID=&lt;span&gt;11&lt;/span&gt;,ClothesName=&lt;span&gt;&quot;皮带&quot;&lt;/span&gt;, SizeName= &lt;span&gt;&quot;X&quot;&lt;/span&gt; },&lt;br/&gt;                &lt;span&gt;new&lt;/span&gt; Slot()  {SlotID=&lt;span&gt;2&lt;/span&gt;, ClothesID=&lt;span&gt;30&lt;/span&gt;,ClothesName=&lt;span&gt;&quot;上衣&quot;&lt;/span&gt;, SizeName= &lt;span&gt;&quot;L&quot;&lt;/span&gt; },&lt;br/&gt;                &lt;span&gt;new&lt;/span&gt; Slot()  {SlotID=&lt;span&gt;2&lt;/span&gt;, ClothesID=&lt;span&gt;40&lt;/span&gt;,ClothesName=&lt;span&gt;&quot;裤子&quot;&lt;/span&gt;, SizeName= &lt;span&gt;&quot;L&quot;&lt;/span&gt; }&lt;br/&gt;            };&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;//找到 刚好挂了一件裤子L &amp;amp; 一件上衣L  &amp;amp; 总衣服个数=2  的 挂孔号&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;var&lt;/span&gt; query = slotList.GroupBy(m =&amp;gt; m.SlotID).Where(m =&amp;gt;&lt;br/&gt;                                                                      m.Where(n =&amp;gt; n.SizeName == &lt;span&gt;&quot;L&quot;&lt;/span&gt;).ToList() &lt;span&gt;is&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; clothesList &amp;amp;&amp;amp;&lt;br/&gt;                                                                      clothesList.Count(k =&amp;gt; k.ClothesName == &lt;span&gt;&quot;裤子&quot;&lt;/span&gt;) &lt;span&gt;is&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp;&lt;br/&gt;                                                                      clothesList.Count(k =&amp;gt; k.ClothesName == &lt;span&gt;&quot;上衣&quot;&lt;/span&gt;) &lt;span&gt;is&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp;&lt;br/&gt;                                                                      m.Key == &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;                                                              )&lt;br/&gt;                                                    .ToDictionary(k =&amp;gt; k.Key, v =&amp;gt; v.ToList());&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Slot&lt;/span&gt;&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SlotID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ClothesID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ClothesName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; SizeName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5110081112398609&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WhqIIKvibJ9Un3C9hJ9q7OqhNRZnedqwVL8WZaNBSUrGs0wSfTDtu1PJpm8ClMct0hGeGJdYdrWYmkCDGnVGn6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;863&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重点在于上面代码的  &lt;code&gt;m.Where(n =&amp;gt; n.SizeName == &quot;L&quot;).ToList() is var clothesList&lt;/code&gt;，这里的 clothesList 就是临时变量，它存放了所有 &lt;code&gt;尺寸L&lt;/code&gt; 的衣物,后续的检索都是基于这个 clothesList，是不是大大提高了检索速度~~~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四：总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我觉得 is 的功能增强早就该出现了，现在终于搞定了，越来越人性化，键盘敲击次数越来越少，头发也不落了，甚至又开始第二春了，总的来说还是那句话，C# 大法🐂👃。&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>