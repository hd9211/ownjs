<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>c1a4e03cba903832391c1105963d472f</guid>
<title>周末过得太快？别荒废啦！</title>
<link>https://toutiao.io/k/uibgt7e</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ca625326f418338874b8957798dee870</guid>
<title>[推荐] 性能优化：如何更快地接收数据</title>
<link>https://toutiao.io/k/vf7kpbe</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;69&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.11875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/OdIoEOgFgUGcibO4v5qxt8aOe6ArwX6qwM3icvwPccBDAjM1eoJTf9QbJ2WcUicIw5QkOiasIKgvNV56qWIXqTcBicg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从网卡到应用程序，数据包会经过一系列组件，其中驱动做了什么？内核做了什么？为了优化，我们又能做些什么？整个过程中涉及到诸多细微可调的软硬件参数，并且相互影响，不存在一劳永逸的“银弹”。本文中又拍云系统开发高级工程师杨鹏将结合自己的的实践经验，介绍在深入理解底层机制的基础上如何做出“场景化”的最优配置。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;文章根据杨鹏在又拍云 Open Talk 技术沙龙北京站主题演讲《性能优化：更快地接收数据》整理而成，现场视频及 PPT 可下拉文末点击阅读原文查看。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;大&lt;/span&gt;&lt;span&gt;家好，我是又拍云开发工程师杨鹏，在又拍云工作已有四年时间，期间一直从事 CDN 底层系统开发的工作，负责调度、缓存、负载均衡等 CDN &lt;/span&gt;&lt;span&gt;的核心组件&lt;/span&gt;&lt;span&gt;，很高兴来跟大家分享在网络数据处理方面的经验和感受。&lt;/span&gt;&lt;span&gt;今天分享的主题是&lt;/span&gt;&lt;span&gt;《&lt;/span&gt;&lt;span&gt;如何更快&lt;/span&gt;&lt;span&gt;地&lt;/span&gt;&lt;span&gt;接收数据&lt;/span&gt;&lt;span&gt;》&lt;/span&gt;&lt;span&gt;，主要介绍加速网络数据处理的方法和实践。&lt;/span&gt;&lt;span&gt;希望能帮助大家更好的了解如何在系统的层面，尽量在应用程序无感的情况下做到极致的优化。&lt;/span&gt;&lt;span&gt;言&lt;/span&gt;&lt;span&gt;归正传，进入主题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首&lt;/span&gt;&lt;span&gt;先需要清楚在尝试做任何优化的时候，想到的第一件事情应该是什么&lt;/span&gt;&lt;span&gt;？&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt;人觉得是衡量指标&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;做任何&lt;/span&gt;&lt;span&gt;改动&lt;/span&gt;&lt;span&gt;或&lt;/span&gt;&lt;span&gt;优化之前，都要明确地知道&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;是怎样的指标反映出了当前的问题。&lt;/span&gt;&lt;span&gt;那么在做了相应的调整或改动之后，也才能通过指标去验证实际效果与作用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对要分享的主题，有一个围绕上面指标核心的基本原则。&lt;/span&gt;&lt;span&gt;在网络层面做优化，归根结底只需要看一点，假如可以做到网络栈的每个层次，加入能监控到对应层次的丢包率，这样核心的指标，就可以明确地知道问题出在哪一层。&lt;/span&gt;&lt;span&gt;有了明确可监控的指标，之后做相应的调整与实际效果的验证也就很简单了。&lt;/span&gt;&lt;span&gt;当然上述两点相对有点&lt;/span&gt;&lt;span&gt;虚&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;接下来就&lt;/span&gt;&lt;span&gt;是比较干的部分&lt;/span&gt;&lt;span&gt;了&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;367&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6354775828460039&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d6ZibspoCcvBZr7f4BSCtZd3dDqykckvQgQST90aIvcpLnUUqsic6XjfJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1026&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上图所示，&lt;/span&gt;&lt;span&gt;当&lt;/span&gt;&lt;span&gt;收到&lt;/span&gt;&lt;span&gt;一个数据&lt;/span&gt;&lt;span&gt;包&lt;/span&gt;&lt;span&gt;，从&lt;/span&gt;&lt;span&gt;进入网卡&lt;/span&gt;&lt;span&gt;，一直到达应用层，总的数据流程&lt;/span&gt;&lt;span&gt;有&lt;/span&gt;&lt;span&gt;很多&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;在当前阶段&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;无需关注每个流程，留意其中几个核心的关键路径即可&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上是三个关键的路径。&lt;/span&gt;&lt;span&gt;上&lt;/span&gt;&lt;span&gt;图中右边的手绘图指的&lt;/span&gt;&lt;span&gt;就是&lt;/span&gt;&lt;span&gt;这三个步骤，并有意区分了两个颜色。&lt;/span&gt;&lt;span&gt;之所以这么区分是&lt;/span&gt;&lt;span&gt;因为&lt;/span&gt;&lt;strong&gt;&lt;span&gt;接下来会按这两部分进行分享，一是上层驱动部分，二是下层涉及到内核的部分。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;当然内核比较多，通篇只涉及到内核网络子系统，更具体来说是内核跟驱动交互部分的内容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;网卡驱动&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;网卡驱动的部分，网卡是硬件，驱动（driver）是软件，包括了网卡驱动部分的大部分。&lt;/span&gt;&lt;span&gt;这部分可简单分四个点，依次是初始化、启动、监控与调优驱动它的初始化流程。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;网卡驱动-初始化 &lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;驱动初始化&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;过程&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;硬件相关，无需过分关注。&lt;/span&gt;&lt;span&gt;但需注意一点就是注册 ethool 的一系列操作，这个工具可以对网卡做各种各样的操作，不止&lt;/span&gt;&lt;span&gt;可以&lt;/span&gt;&lt;span&gt;读取网卡的&lt;/span&gt;&lt;span&gt;配置，&lt;/span&gt;&lt;span&gt;还可以更改网卡的&lt;/span&gt;&lt;span&gt;配置&lt;/span&gt;&lt;span&gt;参数，是&lt;/span&gt;&lt;span&gt;一个&lt;/span&gt;&lt;span&gt;非常强大的工具。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那&lt;/span&gt;&lt;span&gt;它是如何控制网卡的呢&lt;/span&gt;&lt;span&gt;？&lt;/span&gt;&lt;span&gt;每&lt;/span&gt;&lt;span&gt;个网卡的驱动在初始化时，通过接口，去注册支持 ethool 工具的一系列操作。&lt;/span&gt;&lt;span&gt;ethool 是一套很通用的接口，比如说它支持 100 个功能，但每个型号的网卡，只能支持一个&lt;/span&gt;&lt;span&gt;子集&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;所以具体支持哪些功能，会在这一步进行声明。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;322&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5572374645222328&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d6WgANs0IGcV3icPZMicYan6uJSyZZNU4P3mVNzukrJJj2Tsk507y2tETA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1057&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上&lt;/span&gt;&lt;span&gt;图截取的部分，是在初始化时&lt;/span&gt;&lt;span&gt;结构体的赋值。&lt;/span&gt;&lt;span&gt;前面两个可以简单看一下，驱动在初始化的时候会告诉内核，如果想要操作这块网卡对应的回调函数&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;其中最主要的是启动和关闭，有用 ifconfig 工具操作网卡的应该都很熟悉，当用 ifconfig &lt;/span&gt;&lt;span&gt;up/down &lt;/span&gt;&lt;span&gt;一张网卡的时候，调用的都是它初始化时&lt;/span&gt;&lt;span&gt;指定&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;这&lt;/span&gt;&lt;span&gt;几个函数。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;网卡驱动-启动&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;驱动初始化过程之后就是启动（open）中的流程了，一共分为四步：&lt;/span&gt;&lt;span&gt;分配&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;rx/tx&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;队列内存、&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;开启 NAPI、注册中断处理函数、开启中断。&lt;/span&gt;&lt;span&gt;其中注册中断处理函数和开启中断是理所当然的，任何一个硬件接入到机器上都需要做这个操作。&lt;/span&gt;&lt;span&gt;当后面收到一些事件时，它需要通过中断去通知系统，然后开启中断。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二步的 NAPI 后面会详细说明&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;这里先重点关注启动过程中对内存的分配。&lt;/span&gt;&lt;span&gt;网卡在收到数据时，都必须把数据从链路层拷贝到机器的内存里，而这块内存就是网卡在启动时，通过接口向内核、向操作系统申请而来的。&lt;/span&gt;&lt;span&gt;内存一旦申请下来，地址确定之后，后续网卡在收到数据的时候，就可以直接通过 DMA 的机制，直接把数据包传送到内存固定的地址中去，甚至不需要 CPU 的参与。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;407&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7038269550748752&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d62foTz8b7cs9jBILKcttLEYyFHicVwaKmcy0WqXKia7RP81vBap7OH4Tw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;601&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;到队列内存的分配可以看下上图，很早之前的网卡都是单队列的机制，但现代的网卡大多都是多队列的。&lt;/span&gt;&lt;span&gt;好处就是机器网卡的数据接收可以被负载均衡到多个 CPU 上，因此会提供多个队列，这里先有个概念后面会详细说明。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;412&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7127659574468085&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d6aSo4giaGYvwLLic9Dg4ia5gq4dDI37FXd8GP3nLIYL79hVGuKOW3OGFGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;752&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下&lt;/span&gt;&lt;span&gt;面来详细介绍启动过程中的第二步 NAPI，这是现代网络数据包处理框架中非常重要的一个扩展。&lt;/span&gt;&lt;span&gt;之所以现在能支持&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;10G、20G、25G&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;等非常高速的网卡，NAPI 机制起到了非常大的作用。&lt;/span&gt;&lt;span&gt;当然 NAPI 并不复杂，其核心就两点：&lt;/span&gt;&lt;span&gt;中断、轮循。&lt;/span&gt;&lt;span&gt;一般来说，网卡在接收数据时肯定是收一个包，产生一个中断，然后在中断处理函数的时候将包处理掉。&lt;/span&gt;&lt;span&gt;处在收包、处理中断，下一个收包，再处理中断，这样的循环中。&lt;/span&gt;&lt;span&gt;而 NAPI 机制优势在于只需要一次中断，收到之后就可以通过轮循的方式，把队列内存中所有的数据都拿走，达到非常高效的状态。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;网卡驱动-监控&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;接下来就是在驱动这层可以做的监控了，需要去关注其中一些数据的来源。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;sudo ethtool -S eth0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;NIC&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;statistics:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__attr&quot;&gt;rx_packets&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;597028087&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__attr&quot;&gt;tx_packets&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;5924278060&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__attr&quot;&gt;rx_bytes&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;112643393747&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__attr&quot;&gt;tx_bytes&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;990080156714&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__attr&quot;&gt;rx_broadcast&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;96&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__attr&quot;&gt;tx_broadcast&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;116&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__attr&quot;&gt;rx_multicast&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;&gt;20294528&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__meta&quot;&gt;....&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;首先非常重要的是&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;ethool 工具，它可以拿到网卡中统计的数据&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;接收的包数量、处理的流量等等常规的信息，而我们更多的是需要关注到异常信息。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;$ cat /sys/&lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt;/&lt;span class=&quot;code-snippet__title&quot;&gt;net&lt;/span&gt;/&lt;span class=&quot;code-snippet__title&quot;&gt;eth0&lt;/span&gt;/&lt;span class=&quot;code-snippet__title&quot;&gt;statistics&lt;/span&gt;/&lt;span class=&quot;code-snippet__title&quot;&gt;rx_dropped&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;通过 sysfs 的接口，可以看到网卡的丢包数，这就是系统出现异常的一个标志。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;86&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.14858705560619873&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d61dMk5rkAnL9IBXlicPveKc0Ls5aodTRy1XAvRyhWTlubvTS3PzHb5NA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1097&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;三个途径拿到的信息与前面差不多，只是格式有些乱，仅做了解即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;297&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5144270403957131&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d6sZQzK1yMuOwLl49ibFgGic9n1SibIBNmeibyOdgtiaq2h9bkeVvj4nQSAaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1213&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图是要分享的一个线上案例。&lt;/span&gt;&lt;span&gt;当时业务上出现异常，经过排查最后是怀疑到网卡这层，为此需要做进一步的分析。&lt;/span&gt;&lt;span&gt;通过 ifconfig 工具可以很直观的查看到网卡的一些统计数据，图中可以看到网卡的 errors 数据指标非常高，明显出现了问题。&lt;/span&gt;&lt;span&gt;但更有意思的一点是， errors 右边最后的 frame 指标数值跟它完全相同。&lt;/span&gt;&lt;span&gt;因为 errors 指标是网卡中很多错误累加之后的指标，与它相邻的 dropped、overruns 这俩个指标都是零，也就是说在当时的状态下，网卡的错误大部分来自 frame。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然这只是瞬时的状态，上图中下面部分是监控数据，可以明显看到波动的变化，确实是某一台机器异常了。&lt;/span&gt;&lt;span&gt;frame 错误一般是在网卡收到数据包，进行 RCR 校验时失败导致的。&lt;/span&gt;&lt;span&gt;当收到数据包，会对该包中的内容做校验，当发现跟已经存下来的校验不匹配，说明包是损坏的，因此会直接将其丢掉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个原因是比较好分析的，两点一线，机器的网卡通过网线接到上联交换机。&lt;/span&gt;&lt;span&gt;当这里出现问题，不是网线就是机器本身的网卡问题，或者是对端交换机的端口，也就是上联交换机端口出现问题。&lt;/span&gt;&lt;span&gt;当然按第一优先级去分析，协调运维去更换了机器对应的网线，后面的指标情况也反映出了效果，指标直接突降直到完全消失，错误也就不复存在了，对应上层的业务也很快恢复了正常。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;网卡驱动-调优&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;说完监控之后来看下最后的调优。&lt;/span&gt;&lt;span&gt;在这个层面能调整的东西不多，主要是针对网卡多队列的调整，比较直观。&lt;/span&gt;&lt;span&gt;调整队列数目、大小，各队列间的权重，甚至是调整哈希的字段，都是可以的。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;sudo ethtool -l eth0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Channel&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;parameters for eth0:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;Pre-set&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;maximums:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;RX&lt;/span&gt;:   &lt;span class=&quot;code-snippet__string&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;TX&lt;/span&gt;:   &lt;span class=&quot;code-snippet__string&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Other&lt;/span&gt;:    &lt;span class=&quot;code-snippet__string&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Combined&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Current&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;hardware settings:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;RX&lt;/span&gt;:   &lt;span class=&quot;code-snippet__string&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;TX&lt;/span&gt;:   &lt;span class=&quot;code-snippet__string&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Other&lt;/span&gt;:    &lt;span class=&quot;code-snippet__string&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Combined&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;上图是针对多队列的调整。&lt;/span&gt;&lt;span&gt;为了说明刚才的概念，举个例子，比如有个 web server 绑定到了 CPU2，而机器有多个 CPU，这个机器的网卡也是多队列的，其中某个队列会被 CPU2 处理。&lt;/span&gt;&lt;span&gt;这个时候就会有一个问题，因为网卡有多个队列，所以 80 端口的流量只会被分配到其中一个队列上去。&lt;/span&gt;&lt;span&gt;假如这个队列不是由 CPU2 处理的，就会涉及到一些数据的腾挪。&lt;/span&gt;&lt;span&gt;底层把数据接收上来后再交给应用层的时候，需要把这个数据移动一下。&lt;/span&gt;&lt;span&gt;如果本来在 CPU1 处理的，需要挪到 CPU2 去，这时会涉及到 CPU cache 的失效，这对高速运转的 CPU 来说是代价很高的操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么该怎么做呢？&lt;/span&gt;&lt;span&gt;我们可以通过前面提到的工具，特意把 80 端口 tcp 数据流量导向到对应 CPU2 处理的网卡队列。&lt;/span&gt;&lt;span&gt;这么做的效果是数据包从到达网卡开始，到内核处理完再到送达应用层，都是同一个 CPU。&lt;/span&gt;&lt;span&gt;这样最大的好处就是缓存，CPU 的 cache 始终是热的，如此整体下来，它的延迟、效果也会非常好。&lt;/span&gt;&lt;span&gt;当然这个例子并不实际，主要是为了说明能做到的一个效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;内核网络子系统&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;说完了整个网卡驱动部分，接下来是讲解内核子系统部分，这块会分为软中断与网络子系统初始化两部分来分享。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;软中断&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;229&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3969298245614035&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d6dLltHTavYDU2DoR89d3HUQiagpEerpmS7eFM1dFZWl5rgrWiaqic7vgWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;912&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图的 NETDEV 是 linux 网络子系统每年都会开的一个分会，其中比较有意思的点是每年大会举办的届数会以一个特殊字符来表示。&lt;/span&gt;&lt;span&gt;图中是办到了 0X15 届，想必也都发现这是 16 进制的数字，0X15 刚好就是 21 年，也是比较极客范。&lt;/span&gt;&lt;span&gt;对网络子系统感兴趣的可以去关注一下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;448&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7752126366950183&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d6CSXPyicoQ57AjIkoXhCo67o3smyz1dgE17Eb4UsLBicwDnxc9esTjmNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;823&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;言归正传，内核延时任务有多种机制，而软中断只是其中一种。&lt;/span&gt;&lt;span&gt;上图是 linux 的基本结构，上层是用户态，中间是内核，下层是硬件，很抽象的一个分层。&lt;/span&gt;&lt;span&gt;用户态和内核态之间会有两种交互的方式：&lt;/span&gt;&lt;span&gt;通过系统调用，或者通过异常可以陷入到内核态里面。&lt;/span&gt;&lt;span&gt;那底层的硬件跟内核又是怎么交互的呢？&lt;/span&gt;&lt;span&gt;答案是中断，硬件跟内核交互的时候必须通过中断，处理任何事件都需要产生一个中断信号来告知 CPU 与内核。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过这样的机制一般情况下也许没有问题，但是对网络数据来说，一个数据报一个中断，这样会有很明显的两个问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;问题一：&lt;/span&gt;&lt;span&gt;中断在处理期间，会屏蔽之前的中断信号。&lt;/span&gt;&lt;span&gt;当一个中断处理的时间很长，在处理期间收到的中断信号都会丢掉。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;span&gt;如果处理一个包用了十秒，在这十秒期间又收到了五个数据包，但因为中断信号丢了，即便前面的处理完了，后面的数据包也不会再处理了。&lt;/span&gt;&lt;span&gt;对应到 tcp 这边，假如客户端给服务端发了一个数据包，几秒后处理完了，但在处理期间客户端又发了后续的三个包，但是服务端后面并不知道，以为只收到了一个包，这时客户端又在等待服务端的回包，如此会导致两边都卡住了，也说明了信号丢失是一个极其严重的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;问题二：&lt;/span&gt;&lt;span&gt;一个数据包触发一次中断处理的话，当有大量的数据包到来后，就会产生非常大量的中断。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;span&gt;如果达到了 10 万、50 万、甚至百万的 pps，那 CPU 就需要处理大量的网络中断，也就不用干其他事情了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;而针对以上两点问题的解决方法就是让中断处理尽可能的短。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;span&gt;具体来说，不能在中断处理函数，只能把它揪出来，交到软中断机制里。&lt;/span&gt;&lt;span&gt;这样之后的实际结果是硬件的中断处理做的事情就很少了，将接收数据等一些必须的事情交到软中断去完成，这也是软中断存在的意义。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;smp_hotplug_thread&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;softirq_threads&lt;/span&gt; = {&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  .store              = &amp;amp;ksoftirqd,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  .thread_should_run  = ksoftirqd_should_run,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  .thread_fn          = run_ksoftirqd,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  .thread-comm        = “ksoftirqd/%u”,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; _&lt;span class=&quot;code-snippet__function&quot;&gt;init &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;spawn_ksoftirqd&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  regiter_cpu_notifier(&amp;amp;cpu_nfb);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  BUG_ON(smpboot_register_percpu_thread(&amp;amp;softirq_threads));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;early_initcall(spawn_ksoftirqd);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;软中断机制是通过内核的线程来实现的。&lt;/span&gt;&lt;span&gt;图中是对应的一个内核线程。&lt;/span&gt;&lt;span&gt;服务器 CPU 都会有一个 ksoftirqd 这样的内核线程，多 CPU 的机器会相对应的有多个线程。&lt;/span&gt;&lt;span&gt;图中结构体最后一个成员 ksoftirqd/，如果有三个 CPU 对应就会有 /0/1/2 三个内核线程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;274&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.47342995169082125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d6GnpS7VyxdbJJqeSYbnT625efpRlibdcicVfDCNqM64vGJFpkT3VLVugw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1035&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;软中断机制的信息在 softirqs 下面可以看到。&lt;/span&gt;&lt;span&gt;软中断并不多只有几种，其中需要关注的，跟网络相关的就是 NET-TX 和 NET-RX，网络数据收发的两种场景。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;内核初始化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;铺垫完软中断之后，下面来看内核初始化的流程。&lt;/span&gt;&lt;span&gt;主要为两步：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;409&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7073446327683616&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d6uxvJibBrMdU0oBY86Rz0Zhzw3VfLcpILemGYLcDpqoCKRWmeFRJkiaow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;885&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图是手绘的一个数据包的处理流程：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; irqreturn_t &lt;span class=&quot;code-snippet__title&quot;&gt;igb_msix_ring&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; irq, &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; *data)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;igb_q_vector&lt;/span&gt; *&lt;span class=&quot;code-snippet__title&quot;&gt;q_vector&lt;/span&gt; = &lt;span class=&quot;code-snippet__title&quot;&gt;data&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  igb_write_itr(q_vector);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  napi_schedule(&amp;amp;q_vector-&amp;gt;napi);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; IRO_HANDLED;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;上面的代码是 igb 网卡驱动中断处理函数做的事情。&lt;/span&gt;&lt;span&gt;如果省略掉开始的变量声明和后面的返回，这个中断处理函数只有两行代码，非常短。&lt;/span&gt;&lt;span&gt;需要关注的是第二个，在硬件中断处理函数中，只用激活外部 NIPA 软中断处理机制，无需做其他任何事情。&lt;/span&gt;&lt;span&gt;因此这个中断处理函数会返回的非常快。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;NIPI 激活&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;objectivec&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; ____napi_schedule(&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; softnet_data *sd, &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; napi_struct *napi)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  list_add_tail(&amp;amp;napi-&amp;gt;poll_list, &amp;amp;sd-&amp;gt;poll_list);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  _raise_softirq_irqoff(NET_RX_SOFTIRQ);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;NIPI 的激活也很简单，主要为两步。&lt;/span&gt;&lt;span&gt;内核网络系统在初始化的时每个 CPU 都会有一个结构体，它会把队列对应的信息插入到结构体的链表里。&lt;/span&gt;&lt;span&gt;换句话说，每个网卡队列在收到数据的时候，需要把自己的队列信息告诉对应的 CPU，将这两个信息绑定起来，保证某个 CPU 处理某个队列。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除此之外，还要与触发硬中断一样，需要触发软中断。&lt;/span&gt;&lt;span&gt;下图将很多步骤放到了一块，前面讲过的就不再赘述了。&lt;/span&gt;&lt;span&gt;图中要关注的是软中断是怎么触发的。&lt;/span&gt;&lt;span&gt;与硬中断差不多，软中断也有中断的向量表。&lt;/span&gt;&lt;span&gt;每个中断号，都会对应一个处理函数，当需要处理某个中断，只需要在对应的中断向量表里找就好了，跟硬中断的处理是一模一样的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;367&quot; data-backw=&quot;546&quot; data-ratio=&quot;0.6716666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d6KpoG50JeNEVFjOLgQLFeibEOBDYR5UHLj7RmNibmdUicSmZPVUNWqZVQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;数据接收-监控&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;说完了运作机制，再来看看有哪些地方可以做监控。&lt;/span&gt;&lt;span&gt;在 proc 下面有很多东西，可以看到中断的处理情况。&lt;/span&gt;&lt;span&gt;第一列就是中断号，每个设备都有独立的中断号，这是写死的。&lt;/span&gt;&lt;span&gt;对网络来说只需要关注网卡对应的中断号，图中是 65、66、67、68 等。&lt;/span&gt;&lt;span&gt;当然看实际的数字并没有意义，而是需要看它的分布情况，中断是不是被不同 CPU 在处理，如果所有的中断都是被一个 CPU 处理，那么就需要做些调整，把它分散开。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;211&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.36446886446886445&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d6hAtkiaWv5o6CgszfjEC8xCyYm7VtiakzgV824Rhj6PeQmoQXkibWRt2icA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1092&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;数据接收-调优&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;中断可以做的调整有两个：&lt;/span&gt;&lt;span&gt;一是中断合并，二是中断亲和性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;自适应中断合并&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;rx-usecs：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;span&gt;数据帧到达后，延迟多长时间产生中断信号，单位微秒&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;rx-frames：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;span&gt;触发中断前积累数据帧的最大个数&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;rx-usecs-irq：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;span&gt;如果有中断处理正在执行，当前中断延迟多久送达 &lt;strong&gt;CPU&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;rx-frames-irq：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;span&gt;如果有中断处理正在执行，最多积累多少个数据帧&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面列的都是硬件网卡支持的功能。&lt;/span&gt;&lt;span&gt;NAPI 本质上也是中断合并的机制，假如有很多包的到来，NAPI 就可以做到只产生一个中断，因此不需要硬件来帮助做中断合并，实际效果是跟 NAPI 是相同的，都是减少了总的中断数量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;中断亲和性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;$ sudo bash -c ‘echo &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; &amp;gt; &lt;span class=&quot;code-snippet__regexp&quot;&gt;/proc/irq&lt;/span&gt;&lt;span class=&quot;code-snippet__regexp&quot;&gt;/8/smp&lt;/span&gt;_affinity’&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这个与网卡多队列是密切相关的。如果网卡有多个队列，就能手动来明确指定由哪个 CPU 来处理，均衡的把数据处理的负载分散到机器的可用 CPU 上。配置也比较简单，只需&lt;/span&gt;&lt;span&gt;把数字写入到 /proc 对应的这个文件中就可以了。&lt;/span&gt;&lt;span&gt;这是个位数组，转成二进制后就会有对应的 CPU 去处理。&lt;/span&gt;&lt;span&gt;如果写个 1，可能就是 CPU0 来处理；&lt;/span&gt;&lt;span&gt;如果写个 4，转化成二进制是 100，那么就会交给 CPU2 去处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外有个小问题需要注意，很多发行版可能会自带一个 irqbalance 的守护进程&lt;/span&gt;&lt;span&gt;（http://irqbalance.github.io/irqbalance）&lt;/span&gt;&lt;span&gt;，会将手动中断均衡的设置给覆盖掉。这个程序做的核心事情就是把上面手动设置文件的操作放到程序里，有兴趣可以去看下它的代码（&lt;/span&gt;&lt;span&gt;https://github.com/Irqbalance/irqbalance/blob/master/activate.c&lt;/span&gt;&lt;span&gt;），也是把这个文件打开，写对应的数字进去就可以了。 &lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;内核-数据处理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;最后是数据处理部分了。&lt;/span&gt;&lt;span&gt;当数据到达网卡，进入队列内存后，就需要内核从队列内存中将数据拉出来。&lt;/span&gt;&lt;span&gt;如果机器的 PPS 达到了十万甚至百万，而 CPU 只处理网络数据的话，那其他基本的业务逻辑也就不用干了，因此不能让数据包的处理独占整个 CPU，而核心点是怎么去做限制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对上述问题主要有两方面的限制：&lt;/span&gt;&lt;span&gt;整体的限制和单次的限制&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (!list_empty(&amp;amp;sd-&amp;gt;poll_list)){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;napi_struct&lt;/span&gt; *&lt;span class=&quot;code-snippet__title&quot;&gt;n&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; work,weight;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (unlikely(budget &amp;lt;= &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; || time_after_eq(jiffies, time_limit)))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;goto&lt;/span&gt; softnet_break;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;整体限制很好理解，就是一个 CPU 对应一个队列。&lt;/span&gt;&lt;span&gt;如果 CPU 的数量比队列数量少，那么一个 CPU 可能需要处理多个队列。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;weight&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;n-&amp;gt;weight;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;work&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;0;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;(test_bit(NAPI_STATE_SCHED, &amp;amp;n-&amp;gt;state)) {&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;work&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;n-&amp;gt;poll(n,weight);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;trace_napi_poll(n);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;WARN_ON_ONCE(work&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&amp;gt; weight);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;budget&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;-= work;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;单次限制则是限制一个队列在一轮里处理包的数量。&lt;/span&gt;&lt;span&gt;达到限制之后就停下来，等待下一轮的处理。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;softnet_break:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  sd-&amp;gt;time_squeeze++;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  _raise_softirq_irqoff(NET_RX_SOFTIRQ);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;goto&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;而停下来就是很关键的节点，幸运的是有对应的指标记录，有 time-squeeze 这样中断的计数，拿到这个信息就可以判断出机器的网络处理是否有瓶颈，被迫中断的频率高低。&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;124&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.2140625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d6wz7Awj86YEibEDKzp2rOKDbfewgkuCGWjJkjRU3LADzt6hcj5zib907Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图是监控 CPU 指标的数据，格式很简单，每行对应一个 CPU，数值之间用空格分割，输出格式为 16 进制。&lt;/span&gt;&lt;span&gt;那么每一列数值又代表什么呢？&lt;/span&gt;&lt;span&gt;很不幸，这个没有文档，只能通过检查使用的内核版本，然后去看对应的代码。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;seq_printf（seq,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;%08x %08x %08x %08x %08x %08x %08x %08x %08x %08x %08x\n&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     sd-&amp;gt;processed, sd-&amp;gt;dropped, sd-&amp;gt;time_squeeze, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__regexp&quot;&gt;/* was fastroute */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     sd-&amp;gt;cpu_collision, sd-&amp;gt;received_rps, flow_limit_count）;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;下面说明了文件中每个字段都是怎么来的，实际情况可能会有所不同，因为随着内核版本的迭代，字段的数量以及字段的顺序都有可能发生变化，其中与网络数据处理被中断次数相关的就是 squeeze 字段：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; * sd-&amp;gt;processed          处理的包数量（多网卡 bond 模式可能多于实际的收包数量）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; * sd-&amp;gt;dropped             丢包数量，因为队列满了&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; * sd-&amp;gt;time_spueeze      软中断处理 net_rx_action 被迫打断的次数&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; * sd-&amp;gt;cpu_collision       发送数据时获取设备锁冲突，比如多个 CPU 同时发送数据&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; * sd-&amp;gt;received_rps       当前 CPU 被唤醒的次数（通过处理器间中断）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;* sd-&amp;gt;flow_limit_count    触发 flow limit 的次数&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;下图是业务中遇到相关问题的案例，最后排查到 CPU 层面。&lt;/span&gt;&lt;span&gt;图一是 TOP 命令的输出，显示了每个 CPU 的使用量，其中红框标出的 CPU4 的使用率存在着异常，尤其是倒数第二列的 SI 占用达到了 89%。&lt;/span&gt;&lt;span&gt;SI 是 softirq 的缩写，表示 CPU 花在软中断处理上的时间占比，而图中 CPU4 在时间占比上明显过高。&lt;/span&gt;&lt;span&gt;图二则是对应图一的输出结果，CPU4 对应的是第五行，其中第三列数值明显高于其他 CPU，表明它在处理网络数据的时被频繁的打断。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;569&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9850074962518741&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d6PwK8Uy7CwoQyUnFVBCAdGFOJV14BGib8CLHfgbTWYbF1jic0lcKfqQMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;667&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;459&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7935323383084577&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d68sJ3mQYnfImC4exGl5kIEwN3Dj0FeJ5oZajuJkib3Yd9fnvF7trU36Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;804&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对上面的问题推断 CPU4 存在一定的性能衰退，也许是质量不过关或其他的原因。&lt;/span&gt;&lt;span&gt;为了验证是否是性能衰退，写了一个简单的 python 脚本，一个一直去累加的死循环。&lt;/span&gt;&lt;span&gt;每次运行时，把这段脚本绑定到某个 CPU 上，然后观察不同 CPU 耗时的对比。&lt;/span&gt;&lt;span&gt;最后对比结果也显示 CPU4 的耗时比其他的 CPU 高了几倍，也验证了之前的推断。&lt;/span&gt;&lt;span&gt;之后协调运维更换了 CPU，意向指标也就恢复正常了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;以上所有操作都只是在数据包从网卡到了内核层，还没到常见的协议，只是完成了万里长征第一步，后面还有一系列的步骤，例如数据包的压缩（GRO）、网卡多队列软件（RPS）还有 RFS 在负载均衡的基础上考虑流的特征，就是 IP 端口四元组的特征，最后才是把数据递交到 IP 层，以及到熟悉的 TCP 层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总的来说，今天的分享都是围绕驱动来做的，我想强调的性能优化的核心点在于指标，不能测量也就很难去改善，要有指标的存在，这样一切的优化才有意义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现场视频、PPT 以及更多 Open Talk 技术干货，请点击&lt;/span&gt;&lt;span&gt;&lt;strong&gt;↓↓阅读原文↓↓&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;查看&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;h2&gt;&lt;hr/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;快 来&lt;/span&gt;&lt;strong&gt;&lt;span&gt; 找 &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;又&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 小 拍&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h2&gt;&lt;h2&gt;&lt;hr/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;section&gt;&lt;section&gt;&lt;img data-backh=&quot;319&quot; data-backw=&quot;546&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;546&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;319&quot; data-ratio=&quot;0.5833333333333334&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUFAQemPjhnJTKkl7TwPLibto5mn4m21ZrshVQSeibqIYTw6XqhicImzlLxeW0v3BE4ycJbHd84ic5Oiayg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;span&gt;推 荐 阅 读&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&amp;amp;mid=2653586009&amp;amp;idx=1&amp;amp;sn=09aad11a1cc56357be8bb0b2502ff566&amp;amp;chksm=bd1b16d18a6c9fc7fd407aa041c890c7701863f5fe64930a9b68791b3c49a9fbbe543dc55a62&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;273&quot; data-backw=&quot;546&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUElpXebXbjgibum7I6LiboCtK6KV8gcYQ1mFV2XdonnCrOhaQdtBNh71z1u0JNzcdrx5EQRg56zb0IA/0?wx_fmt=jpeg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;546&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;273&quot; data-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUEUylg3O41wsJR8aiasuMebIJsicZ1HyIIL8XbjU22CGg8eV9ZciclQxtibdwcudh6PAicxj2D6ibG3T8mg/0?wx_fmt=jpeg&quot; data-ratio=&quot;0.5007751937984496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUHgQBPeJ4VZoV13ib2HY93ETcX2lcC1BwsQUYfCqhEZ3w6TiaweiaXbtlnYDicZibySnBukq0VdmYMzGjA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;645&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&amp;amp;mid=2653585893&amp;amp;idx=1&amp;amp;sn=a77f524feeabe1d1f203baa5ebc49454&amp;amp;chksm=bd1b156d8a6c9c7bcbe23557e6eb86932dc8a1fddbc20216321148d3719a931456a4348b8370&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;273&quot; data-backw=&quot;546&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUElpXebXbjgibum7I6LiboCtK6KV8gcYQ1mFV2XdonnCrOhaQdtBNh71z1u0JNzcdrx5EQRg56zb0IA/0?wx_fmt=jpeg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;546&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;273&quot; data-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUEUylg3O41wsJR8aiasuMebIJsicZ1HyIIL8XbjU22CGg8eV9ZciclQxtibdwcudh6PAicxj2D6ibG3T8mg/0?wx_fmt=jpeg&quot; data-ratio=&quot;0.5007751937984496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUHgQBPeJ4VZoV13ib2HY93ET3tGzaa4btG0wzrKP7nje8AoEiau9TvicBSdnmVNiaEfEtx7XI6icstH3cQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;645&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&amp;amp;mid=2653585879&amp;amp;idx=1&amp;amp;sn=35cf3079ee61f8326ef624a4c3f99813&amp;amp;chksm=bd1b155f8a6c9c49a48eaac27ea940464e439ffdec153d818bc07d2866c177fad1c57c71a72d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;273&quot; data-backw=&quot;546&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUElpXebXbjgibum7I6LiboCtK6KV8gcYQ1mFV2XdonnCrOhaQdtBNh71z1u0JNzcdrx5EQRg56zb0IA/0?wx_fmt=jpeg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;546&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;273&quot; data-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUEUylg3O41wsJR8aiasuMebIJsicZ1HyIIL8XbjU22CGg8eV9ZciclQxtibdwcudh6PAicxj2D6ibG3T8mg/0?wx_fmt=jpeg&quot; data-ratio=&quot;0.5007751937984496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUHgQBPeJ4VZoV13ib2HY93ETd4zC3JPWxyLQtE1VpofmV5u9fjKdCOZQbr4WJjza6IDttG5iaicicQTRw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;645&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;设为星标&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.9037037&quot; data-type=&quot;png&quot; data-w=&quot;135&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUHbb6jzHdqCC83fulktKZtY2WUNN9vVlgibWSiaR7RDHYbVyTy8icCibHV04APOmEqXhdoJv7GHJDMgvg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;更新不错过&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h2&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7d6614805475d5f64b97b57edcb16027</guid>
<title>[推荐] 聊聊 Spring 事务失效的 12 种场景，太坑了</title>
<link>https://toutiao.io/k/5qng48y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxODkzNTQ3Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uL371281oDHlDcdbjNJic1yCwAu2dmJ9AunIQh9DXdm5JE7v9libnPgJQicoaGs9Eiaee2kPeFGWJxsPkZ9zCQbrIw/0?wx_fmt=png&quot; data-nickname=&quot;苏三说技术&quot; data-alias=&quot;susanSayJava&quot; data-signature=&quot;作者就职于知名互联网公司，掘金月度优秀作者，从事开发、架构和部分管理工作。实战经验丰富，对jdk、spring、springboot、springcloud、mybatis等开源框架源码有一定研究，欢迎关注，和我一起交流。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;大家好，我是苏三，又跟大家见面了。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于从事java开发工作的同学来说，spring的事务肯定再熟悉不过了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在某些业务场景下，如果一个请求中，需要同时&lt;span&gt;写入&lt;/span&gt;多张表的数据。为了保证操作的原子性（要么同时成功，要么同时失败），避免数据不一致的情况，我们一般都会用到spring事务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;确实，spring事务用起来贼爽，就用一个简单的注解：&lt;code&gt;@Transactional&lt;/code&gt;，就能轻松搞定事务。我猜大部分小伙伴也是这样用的，而且一直用一直爽。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果你使用不当，它也会坑你于无形。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们就一起聊聊，事务失效的一些场景，说不定你已经中招了。不信，让我们一起看看。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9913419913419913&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDFI5ibhP1TXOMnqQtJhfb3XCnTbgmpiab2LDA8VVCmg2jMUoeJd70gAJsj7vL2IB0icYxsbsvnKIu9LQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1386&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一 事务不生效&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.访问权限问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，java的访问权限主要有四种：private、default、protected、public，它们的权限从左到右，依次变大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果我们在开发过程中，把有某些事务方法，定义了错误的访问权限，就会导致事务功能出问题，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;         saveData(userModel);&lt;br/&gt;         updateData(userModel);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到add方法的访问权限被定义成了&lt;code&gt;private&lt;/code&gt;，这样会导致事务失效，spring要求被代理方法必须是&lt;code&gt;public&lt;/code&gt;的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说白了，在&lt;code&gt;AbstractFallbackTransactionAttributeSource&lt;/code&gt;类的&lt;code&gt;computeTransactionAttribute&lt;/code&gt;方法中有个判断，如果目标方法不是public，则&lt;code&gt;TransactionAttribute&lt;/code&gt;返回null，即不支持事务。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; TransactionAttribute &lt;span&gt;computeTransactionAttribute&lt;/span&gt;&lt;span&gt;(Method method, @Nullable Class&amp;lt;?&amp;gt; targetClass)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// Don&#x27;t allow no-public methods as required.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (allowPublicMethodsOnly() &amp;amp;&amp;amp; !Modifier.isPublic(method.getModifiers())) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// The method may be on an interface, but we need attributes from the target class.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// If the target class is null, the method will be unchanged.&lt;/span&gt;&lt;br/&gt;    Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// First try is the method in the target class.&lt;/span&gt;&lt;br/&gt;    TransactionAttribute txAttr = findTransactionAttribute(specificMethod);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (txAttr != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; txAttr;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Second try is the transaction attribute on the target class.&lt;/span&gt;&lt;br/&gt;    txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (txAttr != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; ClassUtils.isUserLevelMethod(method)) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; txAttr;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (specificMethod != method) {&lt;br/&gt;      &lt;span&gt;// Fallback is to look at the original method.&lt;/span&gt;&lt;br/&gt;      txAttr = findTransactionAttribute(method);&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (txAttr != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; txAttr;&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;// Last fallback is the class of the original method.&lt;/span&gt;&lt;br/&gt;      txAttr = findTransactionAttribute(method.getDeclaringClass());&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (txAttr != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; ClassUtils.isUserLevelMethod(method)) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; txAttr;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，如果我们自定义的事务方法（即目标方法），它的访问权限不是&lt;code&gt;public&lt;/code&gt;，而是private、default或protected的话，spring则不会提供事务功能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2. 方法用final修饰&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，某个方法不想被子类重新，这时可以将该方法定义成final的。普通方法这样定义是没问题的，但如果将事务方法定义成final，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        saveData(userModel);&lt;br/&gt;        updateData(userModel);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到add方法被定义成了&lt;code&gt;final&lt;/code&gt;的，这样会导致事务失效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你看过spring事务的源码，可能会知道spring事务底层使用了aop，也就是通过jdk动态代理或者cglib，帮我们生成了代理类，在代理类中实现的事务功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果某个方法用final修饰了，那么在它的代理类中，就无法重写该方法，而添加事务功能。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：如果某个方法是static的，同样无法通过动态代理，变成事务方法。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.方法内部调用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候我们需要在某个Service类的某个方法中，调用另外一个事务方法，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        userMapper.insertUser(userModel);&lt;br/&gt;        updateStatus(userModel);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;updateStatus&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        doSameThing();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到在事务方法add中，直接调用事务方法updateStatus。从前面介绍的内容可以知道，updateStatus方法拥有事务的能力是因为spring aop生成代理了对象，但是这种方法直接调用了this对象的方法，所以updateStatus方法不会生成事务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此可见，在同一个类中的方法直接内部调用，会导致事务失效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了，如果有些场景，确实想在同一个类的某个方法中，调用它自己的另外一个方法，该怎么办呢？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 新加一个Service方法&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法非常简单，只需要新加一个Service方法，把@Transactional注解加到新Service方法上，把需要事务执行的代码移到新方法中。具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Servcie&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ServiceA&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;   prvate ServiceB serviceB;&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;save&lt;/span&gt;&lt;span&gt;(User user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;         queryData1();&lt;br/&gt;         queryData2();&lt;br/&gt;         serviceB.doSave(user);&lt;br/&gt;   }&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;@Servcie&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ServiceB&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;(rollbackFor=Exception&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSave&lt;/span&gt;(&lt;span&gt;User&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;       addData1();&lt;br/&gt;       updateData2();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 在该Service类中注入自己&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不想再新加一个Service类，在该Service类中注入自己也是一种选择。具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Servcie&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ServiceA&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;   prvate ServiceA serviceA;&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;save&lt;/span&gt;&lt;span&gt;(User user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;         queryData1();&lt;br/&gt;         queryData2();&lt;br/&gt;         serviceA.doSave(user);&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;@Transactional&lt;/span&gt;(rollbackFor=Exception&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSave&lt;/span&gt;(&lt;span&gt;User&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;       addData1();&lt;br/&gt;       updateData2();&lt;br/&gt;    }&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能有些人可能会有这样的疑问：这种做法会不会出现循环依赖问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：不会。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实spring ioc内部的三级缓存保证了它，不会出现循环依赖问题。但有些坑，如果你想进一步了解循环依赖问题，可以看看我之前文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUxODkzNTQ3Nw==&amp;amp;mid=2247485600&amp;amp;idx=1&amp;amp;sn=0c49b94e7fbd35c88c4470e936023e3e&amp;amp;chksm=f9800e7acef7876ca05ab45ce9420ea140f188e84153f23d0af9d044f475458ad38d49a6546a&amp;amp;token=1641046204&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;spring：我是如何解决循环依赖的？&lt;/a&gt;》。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 通过AopContent类&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在该Service类中使用AopContext.currentProxy()获取代理对象&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的方法2确实可以解决问题，但是代码看起来并不直观，还可以通过在该Service类中使用AOPProxy获取代理对象，实现相同的功能。具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Servcie&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ServiceA&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;save&lt;/span&gt;&lt;span&gt;(User user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;         queryData1();&lt;br/&gt;         queryData2();&lt;br/&gt;         ((ServiceA)AopContext.currentProxy()).doSave(user);&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;@Transactional&lt;/span&gt;(rollbackFor=Exception&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSave&lt;/span&gt;(&lt;span&gt;User&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;       addData1();&lt;br/&gt;       updateData2();&lt;br/&gt;    }&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.未被spring管理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们平时开发过程中，有个细节很容易被忽略。即使用spring事务的前提是：对象要被spring管理，需要创建bean实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下，我们通过@Controller、@Service、@Component、@Repository等注解，可以自动实现bean实例化和依赖注入的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然创建bean实例的方法还有很多，有兴趣的小伙伴可以看看我之前写的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUxODkzNTQ3Nw==&amp;amp;mid=2247488466&amp;amp;idx=1&amp;amp;sn=1e63e6991b5fb47e067d2edf055981d3&amp;amp;chksm=f9801508cef79c1ea208906ceef09593a9f594b3926478eb65b7ef64e0311f13ac5aaf4135ce&amp;amp;token=1641046204&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;@Autowired的这些骚操作，你都知道吗？&lt;/a&gt;》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有一天，你匆匆忙忙的开发了一个Service类，但忘了加@Service注解，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;         saveData(userModel);&lt;br/&gt;         updateData(userModel);&lt;br/&gt;    }    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的例子，我们可以看到UserService类没有加&lt;code&gt;@Service&lt;/code&gt;注解，那么该类不会交给spring管理，所以它的add方法也不会生成事务。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.多线程调用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际项目开发中，多线程的使用场景还是挺多的。如果spring事务用在多线程场景中，会有问题吗？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RoleService roleService;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        userMapper.insertUser(userModel);&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;            roleService.doOtherThing();&lt;br/&gt;        }).start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RoleService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doOtherThing&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;保存role表数据&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的例子中，我们可以看到事务方法add中，调用了事务方法doOtherThing，但是事务方法doOtherThing是在另外一个线程中调用的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样会导致两个方法不在同一个线程中，获取到的数据库连接不一样，从而是两个不同的事务。如果想doOtherThing方法中抛了异常，add方法也回滚是不可能的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果看过spring事务源码的朋友，可能会知道spring的事务是通过数据库连接来实现的。当前线程中保存了一个map，key是数据源，value是数据库连接。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Map&amp;lt;Object, Object&amp;gt;&amp;gt; resources =&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;new&lt;/span&gt; NamedThreadLocal&amp;lt;&amp;gt;(&lt;span&gt;&quot;Transactional resources&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们说的同一个事务，其实是指同一个数据库连接，只有拥有同一个数据库连接才能同时提交和回滚。如果在不同的线程，拿到的数据库连接肯定是不一样的，所以是不同的事务。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;6.表不支持事务&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;周所周知，在mysql5之前，默认的数据库引擎是&lt;code&gt;myisam&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的好处就不用多说了：索引文件和数据文件是分开存储的，对于查多写少的单表操作，性能比innodb更好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些老项目中，可能还在用它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在创建表的时候，只需要把&lt;code&gt;ENGINE&lt;/code&gt;参数设置成&lt;code&gt;MyISAM&lt;/code&gt;即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CREATE TABLE `category` (&lt;br/&gt;  `id` bigint NOT NULL AUTO_INCREMENT,&lt;br/&gt;  `one_category` varchar(&lt;span&gt;20&lt;/span&gt;) COLLATE utf8mb4_bin DEFAULT NULL,&lt;br/&gt;  `two_category` varchar(&lt;span&gt;20&lt;/span&gt;) COLLATE utf8mb4_bin DEFAULT NULL,&lt;br/&gt;  `three_category` varchar(&lt;span&gt;20&lt;/span&gt;) COLLATE utf8mb4_bin DEFAULT NULL,&lt;br/&gt;  `four_category` varchar(&lt;span&gt;20&lt;/span&gt;) COLLATE utf8mb4_bin DEFAULT NULL,&lt;br/&gt;  &lt;span&gt;PRIMARY &lt;span&gt;KEY&lt;/span&gt; &lt;span&gt;(`id`)&lt;/span&gt;&lt;br/&gt;) ENGINE&lt;/span&gt;=MyISAM AUTO_INCREMENT=&lt;span&gt;4&lt;/span&gt; DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;myisam好用，但有个很致命的问题是：&lt;code&gt;不支持事务&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果只是单表操作还好，不会出现太大的问题。但如果需要跨多张表操作，由于其不支持事务，数据极有可能会出现不完整的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，myisam还不支持行锁和外键。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在实际业务场景中，myisam使用的并不多。在mysql5以后，myisam已经逐渐退出了历史的舞台，取而代之的是innodb。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;有时候我们在开发的过程中，发现某张表的事务一直都没有生效，那不一定是spring事务的锅，最好确认一下你使用的那张表，是否支持事务。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7.未开启事务&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，事务没有生效的根本原因是没有开启事务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你看到这句话可能会觉得好笑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开启事务不是一个项目中，最最最基本的功能吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么还会没有开启事务？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，如果项目已经搭建好了，事务功能肯定是有的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果你是在搭建项目demo的时候，只有一张表，而这张表的事务没有生效。那么会是什么原因造成的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然原因有很多，但没有开启事务，这个原因极其容易被忽略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你使用的是springboot项目，那么你很幸运。因为springboot通过&lt;code&gt;DataSourceTransactionManagerAutoConfiguration&lt;/code&gt;类，已经默默的帮你开启了事务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你所要做的事情很简单，只需要配置&lt;code&gt;spring.datasource&lt;/code&gt;相关参数即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果你使用的还是传统的spring项目，则需要在applicationContext.xml文件中，手动配置事务相关参数。如果忘了配置，事务肯定是不会生效的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体配置如下信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;   &lt;br/&gt;&amp;lt;!-- 配置事务管理器 --&amp;gt; &lt;br/&gt;&amp;lt;bean &lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&lt;/span&gt; id=&lt;span&gt;&quot;transactionManager&quot;&lt;/span&gt;&amp;gt; &lt;br/&gt;    &amp;lt;property name=&lt;span&gt;&quot;dataSource&quot;&lt;/span&gt; ref=&lt;span&gt;&quot;dataSource&quot;&lt;/span&gt;&amp;gt;&amp;lt;/property&amp;gt; &lt;br/&gt;&amp;lt;/bean&amp;gt; &lt;br/&gt;&amp;lt;tx:advice id=&lt;span&gt;&quot;advice&quot;&lt;/span&gt; transaction-manager=&lt;span&gt;&quot;transactionManager&quot;&lt;/span&gt;&amp;gt; &lt;br/&gt;    &amp;lt;tx:attributes&amp;gt; &lt;br/&gt;        &amp;lt;tx:method name=&lt;span&gt;&quot;*&quot;&lt;/span&gt; propagation=&lt;span&gt;&quot;REQUIRED&quot;&lt;/span&gt;/&amp;gt;&lt;br/&gt;    &amp;lt;/tx:attributes&amp;gt; &lt;br/&gt;&amp;lt;/tx:advice&amp;gt; &lt;br/&gt;&amp;lt;!-- 用切点把事务切进去 --&amp;gt; &lt;br/&gt;&amp;lt;aop:config&amp;gt; &lt;br/&gt;    &amp;lt;aop:pointcut expression=&lt;span&gt;&quot;execution(* com.susan.*.*(..))&quot;&lt;/span&gt; id=&lt;span&gt;&quot;pointcut&quot;&lt;/span&gt;/&amp;gt; &lt;br/&gt;    &amp;lt;aop:advisor advice-ref=&lt;span&gt;&quot;advice&quot;&lt;/span&gt; pointcut-ref=&lt;span&gt;&quot;pointcut&quot;&lt;/span&gt;/&amp;gt; &lt;br/&gt;&amp;lt;/aop:config&amp;gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默默的说一句，如果在pointcut标签中的切入点匹配规则，配错了的话，有些类的事务也不会生效。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二 事务不回滚&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.错误的传播特性&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，我们在使用&lt;code&gt;@Transactional&lt;/code&gt;注解时，是可以指定&lt;code&gt;propagation&lt;/code&gt;参数的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该参数的作用是指定事务的传播特性，spring目前支持7种传播特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;REQUIRED&lt;/code&gt; 如果当前上下文中存在事务，那么加入该事务，如果不存在事务，创建一个事务，这是默认的传播属性值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;SUPPORTS&lt;/code&gt; 如果当前上下文存在事务，则支持事务加入事务，如果不存在事务，则使用非事务的方式执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;MANDATORY&lt;/code&gt; 如果当前上下文中存在事务，否则抛出异常。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;REQUIRES_NEW&lt;/code&gt; 每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;NOT_SUPPORTED&lt;/code&gt; 如果当前上下文中存在事务，则挂起当前事务，然后新的方法在没有事务的环境中执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;NEVER&lt;/code&gt; 如果当前上下文中存在事务，则抛出异常，否则在无事务环境上执行代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;NESTED&lt;/code&gt; 如果当前上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们在手动设置propagation参数的时候，把传播特性设置错了，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;(propagation = Propagation.NEVER)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        saveData(userModel);&lt;br/&gt;        updateData(userModel);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到add方法的事务传播特性定义成了Propagation.NEVER，这种类型的传播特性不支持事务，如果有事务则会抛异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前只有这三种传播特性才会创建新事务：REQUIRED，REQUIRES_NEW，NESTED。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.自己吞了异常&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务不会回滚，最常见的问题是：开发者在代码中手动try...catch了异常。比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            saveData(userModel);&lt;br/&gt;            updateData(userModel);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            log.error(e.getMessage(), e);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况下spring事务当然不会回滚，因为开发者自己捕获了异常，又没有手动抛出，换句话说就是把异常吞掉了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想要spring事务能够正常回滚，必须抛出它能够处理的异常。如果没有抛异常，则spring认为程序是正常的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.手动抛了别的异常&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使开发者没有手动捕获异常，但如果抛的异常不正确，spring事务也不会回滚。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;             saveData(userModel);&lt;br/&gt;             updateData(userModel);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            log.error(e.getMessage(), e);&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(e);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的这种情况，开发人员自己捕获了异常，又手动抛出了异常：Exception，事务同样不会回滚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为spring事务，默认情况下只会回滚&lt;code&gt;RuntimeException&lt;/code&gt;（运行时异常）和&lt;code&gt;Error&lt;/code&gt;（错误），对于普通的Exception（非运行时异常），它不会回滚。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.自定义了回滚异常&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用@Transactional注解声明事务时，有时我们想自定义回滚的异常，spring也是支持的。可以通过设置&lt;code&gt;rollbackFor&lt;/code&gt;参数，来完成这个功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果这个参数的值设置错了，就会引出一些莫名其妙的问题，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;(rollbackFor = BusinessException&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;UserModel&lt;/span&gt; &lt;span&gt;userModel&lt;/span&gt;) &lt;span&gt;throws&lt;/span&gt; &lt;span&gt;Exception&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       saveData(userModel);&lt;br/&gt;       updateData(userModel);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在执行上面这段代码，保存和更新数据时，程序报错了，抛了SqlException、DuplicateKeyException等异常。而BusinessException是我们自定义的异常，报错的异常不属于BusinessException，所以事务也不会回滚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使rollbackFor有默认值，但阿里巴巴开发者规范中，还是要求开发者重新指定该参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是为什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为如果使用默认值，一旦程序抛出了Exception，事务不会回滚，这会出现很大的bug。所以，建议一般情况下，将该参数设置成：Exception或Throwable。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.嵌套事务回滚多了&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RoleService roleService;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        userMapper.insertUser(userModel);&lt;br/&gt;        roleService.doOtherThing();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RoleService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;(propagation = Propagation.NESTED)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doOtherThing&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;保存role表数据&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况使用了嵌套的内部事务，原本是希望调用roleService.doOtherThing方法时，如果出现了异常，只回滚doOtherThing方法里的内容，不回滚 userMapper.insertUser里的内容，即回滚保存点。。但事实是，insertUser也回滚了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;why?&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为doOtherThing方法出现了异常，没有手动捕获，会继续往上抛，到外层add方法的代理方法中捕获了异常。所以，这种情况是直接回滚了整个事务，不只回滚单个保存点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么样才能只回滚保存点呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RoleService roleService;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        userMapper.insertUser(userModel);&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            roleService.doOtherThing();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            log.error(e.getMessage(), e);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以将内部嵌套事务放在try/catch中，并且不继续往上抛异常。这样就能保证，如果内部嵌套事务中出现异常，只回滚内部事务，而不影响外部事务。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三 其他&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1 大事务问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用spring事务时，有个让人非常头疼的问题，就是大事务问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下，我们会在方法上&lt;code&gt;@Transactional&lt;/code&gt;注解，填加事务功能，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RoleService roleService;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;       query1();&lt;br/&gt;       query2();&lt;br/&gt;       query3();&lt;br/&gt;       roleService.save(userModel);&lt;br/&gt;       update(userModel);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RoleService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RoleService roleService;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;save&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;       query4();&lt;br/&gt;       query5();&lt;br/&gt;       query6();&lt;br/&gt;       saveData(userModel);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但&lt;code&gt;@Transactional&lt;/code&gt;注解，如果被加到方法上，有个缺点就是整个方法都包含在事务当中了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的这个例子中，在UserService类中，其实只有这两行才需要事务：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;roleService.save(userModel);&lt;br/&gt;update(userModel);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在RoleService类中，只有这一行需要事务：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;saveData(userModel);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在的这种写法，会导致所有的query方法也被包含在同一个事务当中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果query方法非常多，调用层级很深，而且有部分查询方法比较耗时的话，会造成整个事务非常耗时，而从造成大事务问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于大事务问题的危害，可以阅读一下我的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUxODkzNTQ3Nw==&amp;amp;mid=2247485262&amp;amp;idx=1&amp;amp;sn=abe19452e4c13876270f329cc6929be7&amp;amp;chksm=f9800194cef78882e5ad4d8eb00b7e3f745a4159aee6afb1858cc16cae599f8889afa330e17b&amp;amp;token=305097496&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;让人头痛的大事务问题到底要如何解决？&lt;/a&gt;》，上面有详细的讲解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2759259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEBCPPbyDJ73OtgGneSbqS4EPv3uEv9HEcX4hevWFJGDG8gPspHNL0abAiaEvxZoGZbBIkTbBQGfHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.编程式事务&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面聊的这些内容都是基于&lt;code&gt;@Transactional&lt;/code&gt;注解的，主要说的是它的事务问题，我们把这种事务叫做：&lt;code&gt;声明式事务&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，spring还提供了另外一种创建事务的方式，即通过手动编写代码实现的事务，&lt;span&gt;我们把这种事务叫做&lt;/span&gt;：&lt;code&gt;编程式事务&lt;/code&gt;。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;   &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; TransactionTemplate transactionTemplate;&lt;br/&gt;   &lt;br/&gt;   ...&lt;br/&gt;   &lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;save&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; User user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;         queryData1();&lt;br/&gt;         queryData2();&lt;br/&gt;         transactionTemplate.execute((status) =&amp;gt; {&lt;br/&gt;            addData1();&lt;br/&gt;            updateData2();&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;         })&lt;br/&gt;   }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在spring中为了支持编程式事务，专门提供了一个类：TransactionTemplate，在它的execute方法中，就实现了事务的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相较于&lt;code&gt;@Transactional&lt;/code&gt;注解声明式事务，我更建议大家使用，基于&lt;code&gt;TransactionTemplate&lt;/code&gt;的编程式事务。主要原因如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;避免由于spring aop问题，导致事务失效的问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;能够更小粒度的控制事务的范围，更直观。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;建议在项目中少使用@Transactional注解开启事务。但并不是说一定不能用它，如果项目中有些业务逻辑比较简单，而且不经常变动，使用@Transactional注解开启事务开启事务也无妨，因为它更简单，开发效率更高，但是千万要小心事务失效的问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bc278608cde602b7933970a95b0803f2</guid>
<title>[推荐] 这 2 个工作流自动化工具  yyds</title>
<link>https://toutiao.io/k/2beczyw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>792107a3060bd0f9a91929c706abd64d</guid>
<title>[推荐] 如何将你的开源项目变成稳定的收入来源</title>
<link>https://toutiao.io/k/rklgzc4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; role=&quot;option&quot; title=&quot;链接&quot; class=&quot;article-tag__list single-tag__wrp js_single&quot; data-len=&quot;1&quot;&gt;
                                            
                                                                                    &lt;span class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI0MDIwNTQ1Mg==&amp;amp;action=getalbum&amp;amp;album_id=1503969356932759554#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;1503969356932759554&quot; data-tag_source=&quot;3&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;#&lt;/span&gt;开源项目&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span class=&quot;article-tag-card__right&quot;&gt;&lt;span class=&quot;weui-hidden_abs&quot;&gt;,&lt;/span&gt;2个&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;你可能会维护几个开源项目，有没有想过从中赚钱？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序员经常将空闲时间花在个人软件开发项目上。许多程序员将他们的实验和创新想法转化为每个人都可以免费使用的开源项目。GitHub 上的大部分开源项目都是由开发人员为开发人员制作的。换句话说，程序员可以通过节省额外的开发时间来将大多数开源项目与其软件项目集成。此外，还有许多开源开发人员工具可以让开发人员的生活更轻松。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序员经常把开源项目作为一种爱好来工作，就像我一样。然而，我们在与开源项目合作的同时，还从事着一份软件工程工作，帮助我们支付账单。因此，毫无疑问，如果这些项目帮助我们支付账单，我们可以将更多时间花在我们的开源项目上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我通过&lt;span&gt;我的开源项目&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;赚了相当多的钱。在这个故事中，我将指导你如何在不失去现有社区的情况下将你的开源项目变成一个收入来源。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;确保你的项目解决了一个问题&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每一个成功的开源项目背后，都有一个每个人都需要解决的工程问题。例如，&lt;span&gt;zx&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt; 项目在三个月内获得了超过 18k 的 GitHub 星星，它引入了一种使用 JavaScript 编写类似 Bash 的 shell 脚本的方法。Bash 脚本语言确实很慢，而且对开发人员不友好。当脚本的逻辑变得复杂时，每个程序员都经常与 shell 脚本斗争，因为 Bash 不是一种通用语言。zx 项目解决了大多数开发者面临的一个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1630310052396&quot; data-category_id_list=&quot;48|26|1|55|47|5|24|37|11|50|54|53|52|42|29|43|16|51|36&quot; data-id=&quot;1630310052396&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在你考虑盈利过程之前，你需要确保你的项目是成功的。开源项目的成功取决于开发人员受众的大小。如果您在开源项目的沟通渠道中经常收到特性请求、反馈和问题，那么恭喜您，您可以继续下一步。否则，请确保您的开源项目解决了大多数开发人员面临的问题。此外，请确保维护一个干净且最新的网站和文档。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;让它做好用于生产准备！&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序员寻找开源框架和库，将其纳入各种项目中。不是所有的程序员都会把你的开源项目和业余项目整合在一起，他们可能经常试图把你的项目和企业软件系统整合在一起。因此，你需要使你的开源项目为生产做好准备，以支持企业的整合。生产就绪指的是设计良好、文档完善、可维护、可扩展、稳定、不易出错和功能齐全的软件模块。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;确保你的开源项目有上述要求。否则，请彻底测试你的项目，重构你的代码库，并增加更多的功能以满足企业级需求。检查以下故事来验证你的编码技能，因为你的开源项目的质量取决于它们。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;提高编程技能的 5 个实践：https://betterprogramming.pub/5-practices-to-improve-your-programming-skills-e2ed9b8463db&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;在不失去社区的情况下实现商业化&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，我将指导你从你的开源项目中获得收入来源。在继续之前，请务必验证以上两点，因为收入流的成功取决于这些关键事实。开源项目有许多盈利方法（也被称为开源商业模式）：付费开发者支持、免费增值(付费服务)、SaaS 订阅(软件即服务)、众筹、众包和基于捐赠的模式。这些模式具有不同的特性，每种模式都有不同的优缺点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我研究了许多开源盈利模式。最后，我发现基于捐赠的模型非常适合我们个人的开源项目。它不会影响你现有的社区。另一方面，其他盈利方法会直接影响到你的社区，因为这些模式会强制玩家付费，即使你的项目是开源的。基于捐赠的模式接受支付，保留你给予社区的确切自由。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你的项目需要对开发者社区产生一些相当大的影响才能获得捐赠。你的项目在第一阶段可能不会得到更多的捐赠。因此，我们需要一个与主要捐赠模式相一致的后备收入流，以保持您的积极性。如果你能将广告等纯粹的被动收入流与基于捐赠的模式结合起来，那就太棒了。这些都是理论方法。我将解释我是如何为我的开源项目创造收入流的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;创造你的收入流&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们知道如何通过广告和捐赠建立一个理论上的收入流，让我们构建一个实用的。首先，你需要选择你要接受捐赠的地方，我选择 Patreon 是因为它的简单性和透明性。将您的捐赠平台链接到项目的网站和代码库，最初，请确保添加一些较低的每月捐赠级别，例如 2 美元、5 美元和 10 美元。原因是任何人都可能倾向于为你的努力捐献这样的金额。始终在你的每一次发布中感谢你的捐赠者，以激励他们继续捐赠订阅。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步是将广告平台整合到你的开源项目的网站上。我们总是使用静态网站生成器来构建开源项目的文档和网站。选择一个静态网站生成器，你可以很容易地放置一些广告块。我选择&lt;span&gt;Docusaurus&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;是因为它的简单性和灵活性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选择一个开源友好的广告平台， Google AdSense 不太适合开源项目的网站。&lt;span&gt;EthicalAds&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt; 和 &lt;span&gt;Carbon Ads&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt; 等平台专为开源项目而设计。我选择 EthicalAds 是因为与 Carbon 平台相比，它提供了更高的收入份额。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我选择基于捐赠的模式来产生收入流，因为我想确保现有开发者社区的自由。世界上最大的开源组织 Apache 软件基金会 (ASF) 也使用基于捐赠的模式来支付其费用。聚集在您的开源项目周围的人每天都做出各种贡献，使它获得成功。有些人可能决定通过捐款来为您的开源项目做出财务贡献。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你需要用你的开源项目赚取收入来源--请确保你解决了一个问题，使它可以生产，接受捐赠，整合一个开源友好的广告平台，并每天不断改进你的项目。使这种收入流发挥作用需要时间，我的开源收入流每月产生的金额接近 100 美元，我希望有一天它会赚更多的钱。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于开源，推荐下面这本书：&lt;/p&gt;&lt;section&gt;&lt;mpcps frameborder=&quot;0&quot; class=&quot;js_editor_cps&quot; data-datakey=&quot;1630309875249_0.010239300739570911&quot; data-uid=&quot;1630309875247&quot; data-type=&quot;1&quot; data-product=&quot;&quot; data-templateid=&quot;list&quot; data-pid=&quot;29160368&quot; data-categoryid=&quot;3&quot; data-appuin=&quot;3084391334&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;文章链接请点击阅读&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;相关阅读&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MDIwNTQ1Mg==&amp;amp;mid=2676497614&amp;amp;idx=1&amp;amp;sn=221622a6d9b168f7e8399d692192cbee&amp;amp;chksm=f362d72dc4155e3bae605fa04c637b7335910653ea4281149abca0a408ee59b2b63531b25ac8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/WYoaOn5t0APeo0PQLLYbmZFl6JutwoPX6hJg6IQiamwZHs180acecgm0DwVawxDjjYVNoyOxLicpibGF4hibatvCTA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MDIwNTQ1Mg==&amp;amp;mid=2676494626&amp;amp;idx=1&amp;amp;sn=566c9e92802dfe0de5e21af2952801aa&amp;amp;chksm=f362dac1c41553d7fb02e21988fb86ac6fefde7138ff673a053176b069ce7a3501a4c198ae50&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/WYoaOn5t0AMDZRHZavLcTB1THMdv74fKKsH0YuLbyqyf2rA2bctxZpDt0PpSbBKwwXiaKqSd5uTmW91jNFuyJuA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;section&gt;&lt;span&gt;原文：https://betterprogramming.pub/how-to-turn-your-open-source-project-into-a-stable-income-stream-4c46b15ed960&lt;br/&gt;&lt;span&gt;作者：Shalitha Suranga&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI0MDIwNTQ1Mg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AN1zVl7Tea9DR1nnHnJKhstY9ibUZsx8PHEXXU6e37qYUDXWVkQTFtcKk84R88icdY0vhbniaSotOiaRw/0?wx_fmt=png&quot; data-nickname=&quot;前端全栈开发者&quot; data-alias=&quot;by-zhangbing-dev&quot; data-signature=&quot;专注分享国内外前端技术、Web全栈开发技术精选文章，大前端技术资讯、优质教程、工具资源等，助力开发者成长。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;猜你喜欢&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;p&gt;&lt;em/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>