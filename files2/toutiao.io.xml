<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>a3c99f4c2ae888083ad383d6ea3b872a</guid>
<title>懂得三境界：使用 Dubbo 时请求超过问题</title>
<link>https://toutiao.io/k/mgynadi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引子&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;刚才下班回家路上，无意中听到大街上放的歌，歌词有这么一句：“毡房外又有驼铃声声响起，我知道那一定不是你”。这一句我似乎听懂了歌者的魂牵梦绕和绝望，如果在十年前我大概只能感受出悠扬的声调里溢出的悲凉吧。&lt;/p&gt;&lt;p&gt;在工作上，我没有十年的时间来把思考能力上升一个等级。对于一个问题，需要在很短的时间反复思考，深层次的弄懂。懂得，有三个初级境界，对应三个方法：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1&amp;gt;字面理解-what、why、how&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2&amp;gt;前因后果-5why&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3&amp;gt;选择最优-SMART&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;回到主线：为什么是初级境界？我自己也不知道更高级别的境界是有什么，因为自己境界没有达到。但是至少有：刻入骨髓 这一境界。&lt;/p&gt;&lt;p&gt;举个例子：十二年前，有次在大街上走，我走过一个【北京银行】的大门，银行二楼的玻璃哗啦啦掉下来。我知道身后有危险，有很多玻璃落到了距离我身后不到十公分的地方。我当时很镇定的继续向前走。等过了危险区，我很想神经质的大叫。因为走路时再多犹豫2秒，可能脑袋上被扎的全是玻璃。所以走路时时时刻刻都会想着离楼房远一些，并且好像感受到了自己脑袋被玻璃扎。我理解这可以算作把楼房玻璃很危险的理解刻入骨髓。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;字面理解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;今天举的这个例子纯粹是技术问题，终于不需要用蹩脚的比喻把事情描述的更难理解来达到脱敏的效果。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;what&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;我们采用的是dubbo服务，这是个稳定成熟的RPC框架。但是我们在某些应用中会发现，只要这个应用一发布(或者重启),就会出现请求超时的问题，如下图所示:&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;252&quot; data-backw=&quot;472&quot; data-ratio=&quot;0.5346097201767305&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9NHC7202k2LDdz4wH8nD5XUgCaGLfRbfSh0TJW5GSH207kcpbI76zc1P2xaVQian8cw4BlMaTLdbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1358&quot;/&gt;&lt;br/&gt;而且都是第一笔请求会报错，之后就再也没有问题了。&lt;span&gt;(上图来源于网络，下面有参考文章。如果可以，我想把这些字调的再小一些)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;why&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;我当时很快就定位了问题，因为在内网wiki上、技术博客上，很多人都写了这个坑。所以不讲排查思路了，直接讲结论：&lt;/p&gt;&lt;p&gt;在server端连接数过多, linux系统有个连接队列溢出了。溢出的连接被丢弃，但是client端不知道，仍然给此server发送消息。连接没有建立自然发送不成功。client发第一笔消息超时，相当于探活失败，client端于是重新建立连接。连接成功建立后开始正常的通信，所以后面都成功了。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;how&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;怎么来解决这个问题呢？四个思路。&lt;/p&gt;&lt;p&gt;第一个是队列溢出了，那就说明队列太小。可以把队列值改大。dubbo使用的是一个写死的默认值：50。可以修改dubbo源码把值改大或者干脆动态获取队列值。&lt;/p&gt;&lt;p&gt;第二个是队列数不变，实际连接数减少。减少server端的连接方，比如有些client端其实没有实际业务调用这个server端了，就双方聊聊把无用的依赖去掉。&lt;/p&gt;&lt;p&gt;第三个是可以让服务端在丢弃连接的同时给client端通知一下，linux有个系统参数/proc/sys/net/ipv4/tcp_abort_on_overflow，默认为0。不会给client端发通知，但是设置为1时会给server端发一个reset请求，客户端收到会重连。&lt;/p&gt;&lt;p&gt;第四个是让client端定时心跳探测。探测发现超时了马上重连，超时的那笔只是探测请求，不影响业务。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlib44sDJUIqssEoeTxDraMgfDmk6rVUuibn8wySzuSicrUaCHeX0kWSsQc7ynWzECDZ6hjiaZCoR1wM7g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;前因后果&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;作为软件工程师，重要的一个软素质是批判性思维。多问几个问题，找到答案，理解就能更进一步。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Q1: &lt;/span&gt;&lt;/strong&gt;提到溢出的队列到底是什么队列？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;A: &lt;/span&gt;&lt;/strong&gt;下图是TCP连接三次握手的示意图。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;367&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.634375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlib44sDJUIqssEoeTxDraMgftETk0CBEtY8ZaMgYicltxFBCX8FO8ibJJic8pjcaIcSmMWudZtEHC5n7w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;一次握手：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;一开始client端和server端都处于closed状态(未建立连接状态)。client端主动向server端发起syn请求建立连接请求，server端收到后将与client端的连接设置为listen状态(半连接状态)。问题来了，server端怎么保存与client端的状态呢？总需要有地方存呀，存的地方就是队列。连接队列又叫backlog队列。到这里，server端与client端的半连接建立了。这里的backlog队列也叫半连接队列。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;二次握手：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;server端返回ack应答+syn请求给client，意思是：ack我收到了你的请求，syn你收到我的了没？client端收到server端响应，将自己的状态设置为established状态(连接状态)。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;三次握手：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;client向server端发送一个ack响应，告诉server端收到。然后server端收到后将与client端的连接设置为established状态(全连接状态)。同样，全连接状态在server端也需要一个backlog队列存储。这里的backlog队列也叫全连接队列。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Q2: &lt;/span&gt;&lt;/strong&gt;backlog队列到底是全连接队列还是半连接队列？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;A: &lt;/span&gt;&lt;/strong&gt;这个问题让我想起别的事情。我大学是东北大学，有次看到校内论坛上有个帖子：“东北大学和东南大学谁更有资格叫东大？”最终没啥结论，东北大学内网再论证自己该叫东大，东南大学内网肯定不认。&lt;/p&gt;&lt;p&gt;但是backlog的问题还是有达成共识的可能的。backlog其实是一个连接队列，在Linux内核2.2之前，backlog包括半连接状态和全连接状态两种队列。在Linux内核2.2之后，分离为两个backlog来分别限制半连接（SYN_RCVD状态）队列大小和全连接（ESTABLISHED状态）队列大小。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;半连接队列：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;队列长度由/proc/sys/net/ipv4/tcp_max_syn_backlog指定，默认为2048。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;全连接队列：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;队列长度由/proc/sys/net/core/somaxconn和使用listen函数时传入的参数，二者取最小值。默认为128。&lt;/p&gt;&lt;p&gt;在Linux内核2.4.25之前，是写死在代码常量 SOMAXCONN ，在Linux内核2.4.25之后，在配置文件/proc/sys/net/core/somaxconn中直接修改，或者在 /etc/sysctl.conf 中配置 net.core.somaxconn = 128 。&lt;/p&gt;&lt;p&gt;想到这里我恍然大悟，东北大学、东方大学、东南大学在自己的地盘都有资格简称东大（这里讲这个插曲是为了澄清一件事情：我昨天下午4点发的文章里标题是一个北大妹子，那篇文章是帮朋友的忙，北大妹子不是我，我是东大妹子）。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Q3: &lt;/span&gt;&lt;/strong&gt;到底是全连接队列还是半连接队列溢出导致了超时？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;A: &lt;/span&gt;&lt;/strong&gt;server端与client端进行二次握手的前提是server端认为自己与client建立连接是没有任何问题的。如果server端半连接队列溢出了，自己这边都没有处于半连接状态，自然不会发送ack+syn给client端。client端做的应该是重新尝试建立连接，不是发送数据。请求会发送到已经建立好连接的server端(server端是多机器多活部署的)不会造成请求超时。&lt;/p&gt;&lt;p&gt;而二次握手一旦完成，进行三次握手时，如果全连接队列已满，服务器收到客户端发来的ACK, 不会将该连接的状态从SYN_RCVD变为ESTABLISHED。但是客户端已经认为连接建立好了开始发送数据了，这时候是有可能造成超时的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Q4: &lt;/span&gt;&lt;/strong&gt;全连接队列满了之后server端是怎么处理的呢？&lt;/p&gt;&lt;p&gt;当全连接队列已满时，则根据 tcp_abort_on_overflow 的值来执行相应动作。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;tcp_abort_on_overflow = 0 处理：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;则服务器建立该连接的定时器，这个定时器是一个服务器的规则是从新发送syn+ack的时间间隔成倍的增加，比如从新了第二次握手，进行了5次，这五次的时间分别是 1s, 2s,4s,8s,16s,这种倍数规则叫“二进制指数退让”(binary exponential backoff)。&lt;/p&gt;&lt;p&gt;给客户端定时从新发回SYN+ACK即重新进行第二次握手，(如果客户端设定的超时时间比较短就很容易出现异常)服务器重新进行第二次握手的次数由/proc/sys/net/ipv4/tcp_synack_retries 这个linux系统参数决定。&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;tcp_abort_on_overflow = 1 &lt;strong&gt;处理：&lt;/strong&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;当 tcp_abort_on_overflow 等于1 时,发送一个reset请求重置连接。客户端收到可以尝试再次从第一次握手开始建立连接或者其他处理。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Q5: &lt;/span&gt;&lt;/strong&gt;怎么验证确实是backlog队列溢出呢？&lt;/p&gt;&lt;p&gt;&lt;span&gt;ss 是 Socket Statistics 的缩写。ss 命令可以用来获取 socket 统计信息&lt;/span&gt;。ss -l 是显示listen状态的数据，如下所示：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[root@localhost ~]&lt;/span&gt;# &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;ss&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-l&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;State&lt;/span&gt;       &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Recv-Q&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Send-Q&lt;/span&gt;        &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Local&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:Port&lt;/span&gt;           &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Peer&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:Port&lt;/span&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;LISTEN&lt;/span&gt;      0      128                       *&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:http&lt;/span&gt;                         *:*       &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;LISTEN&lt;/span&gt;      0      128                       :&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;::ssh&lt;/span&gt;                        :::*       &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;LISTEN&lt;/span&gt;      0      128                        *&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:ssh&lt;/span&gt;                         *:*       &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;LISTEN&lt;/span&gt;      0      100                     &lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;::1&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:smtp&lt;/span&gt;                        :::*       &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;LISTEN&lt;/span&gt;      0      100               127&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:smtp&lt;/span&gt;                         *:*       &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;在LISTEN状态，其中 Send-Q 即为全连接队列的最大值，Recv-Q 则表示全连接队列中等待被server段处理的数量。数量为0，说明处理能力很够；Send-Q =Recv-Q ，满了，再来就丢弃掉了。&lt;/p&gt;&lt;p&gt;但是这是一个实时的数据，一段时间有拥塞，过一会儿就好了怎么查呢？&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以使用netstat -s 可以查看被全连接队列丢弃的数据。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;apache&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[&lt;span class=&quot;code-snippet__attribute&quot;&gt;root&lt;/span&gt;@localhost ~]# netstat -s | grep &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;times the listen queue of a socket overflowed&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;35552&lt;/span&gt; times the listen queue of a socket overflowed&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;strong&gt;&lt;span&gt;补充说明: &lt;/span&gt;&lt;/strong&gt;半连接队列很多文章叫做&lt;span&gt;SYN QUEUE队列。&lt;/span&gt;&lt;span&gt;全连接队列很多文章叫做ACCEPT QUEUE队列。&lt;/span&gt;&lt;span&gt;这是一些研究linux源码的同学根据源码的命名来叫的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1802721088435375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicFPQQW5JXfQVCIb9lGSSj5fw7ypyia2HmibQ3QGUxELbTGZoOF6n5lU14IrNRjTlpWJeFqALibxV6Xg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;294&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;选择最优&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;马云说：“选择比努力重要” 。懂得三境界，第三境界的重点不是懂，而是得。最终要根据懂了的内容决策出最优方案。&lt;/p&gt;&lt;p&gt;除了字面理解里提到的四种思路，前因后果里还提到了重新进行第二次握手的次数由/proc/sys/net/ipv4/tcp_synack_retries 这个linux系统参数决定。&lt;/p&gt;&lt;p&gt;分别来分析一下各个方案的可行性和优缺点：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;方案1：把队列值调大&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这个队列值是指&lt;span&gt;全连接队列&lt;/span&gt;，调大之后，client端的二次握手就在这个队列里排队等待server端真正建立连接。假设队列值调到上限65535。第65535号请求在排队的过程，client端是established状态，数据可能会发送过来，服务端还没有established状态，还不能处理。&lt;/p&gt;&lt;p&gt;到什么时候能处理呢？65535个请求全部处理完需要13s的样子。对一般的服务来说妥妥的超时。所以nginx和redis都是使用的511，让响应时间在100ms内完成。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;方案2：减少连接数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;只要能减少的下来，这是理想的法子。现在server端都过载了，可想而知，接入的client端不再少数，推动他们一个个去梳理和改造，就算大家执行力很强，把改下的下了。可想而知，废弃的也一般不会有多少。不展开了啊，现在已经三千多字了，争取五千字内结束。&lt;/p&gt;&lt;p&gt;还有没有别的方法减少连接数呢？最简单的就是使用分治法。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;划分子集&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;跟同事讨论请教的时候，他给我提供了一个划分子集的思路。让client端只和server端一部分服务器建立连接。有两种分配谁跟谁连接的算法，一个是随机算法。但是server端服务器我最多见过几千台组成一个集群的。对随机(虽然连接数是服务器台数的n倍)来说，样本是很少的，会很不均匀；另外一个是确定性算法，思路也很简单。连接的client端及数量是确定的，那就排个序，按照server端数量分配一下。这样连接数是均匀的，但是就没办法做到请求级别的流量均匀。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;粘滞连接&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;尽可能让客户端总是向同一提供者发起调用，除非该提供者挂了，再连另一台。&amp;lt;dubbo:protocol name=&quot;dubbo&quot; sticky=&quot;true&quot; /&amp;gt;。如果每个client端都只和一个server端建立连接。那server端压力就是原来的(1/机器台数)。不够加机器就行了，横向可扩展。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlicFPQQW5JXfQVCIb9lGSSj5ibugHkicE4Y3vVmicpgmBg9sRk0JjjvsAcQUWkJHnyLFMgdOR5EzHZ2Eg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;208&quot;/&gt;&lt;/p&gt;&lt;p&gt;这种做法最大的问题是高可用和并发请求的问题，对于可用性要求不高、请求量不高的服务(比如后台定时任务定时拉取可重试)其实是可以用的。但是这需要client端的自觉性，而对维护这个client端的人员来讲，他们自身是没有好处的，因为原本也就是只是重启时发生一次超时嘛。所以客户端在可以的情况下愿不愿意这样做就看格局了。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;方案3：服务端通知&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;服务端通知上面&lt;strong&gt;&lt;span&gt;前因后果&lt;/span&gt;&lt;/strong&gt;中有提到可以设置&lt;/p&gt;&lt;p&gt;/proc/sys/net/ipv4/tcp_synack_retries&lt;/p&gt;&lt;p&gt;重新进行几次进行第二次握手。但是这个阶段，client端可能会发数据包过来造成超时；另外，可以设置&lt;/p&gt;&lt;p&gt;/proc/sys/net/ipv4/tcp_abort_on_overflow=1&lt;/p&gt;&lt;p&gt;整个握手直接断掉，client端是closed状态，它会找其他established状态的连接进行数据包发送，不会造成超时。事实上，调研了一些大厂，&lt;/p&gt;&lt;p&gt;tcp_abort_on_overflow=1是作为默认配置的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;方案4：客户端探测&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;客户端探测想自己做的话比较麻烦，比如说把，客户端调了n个服务，每个服务建立了n个连接。资源开销大，还必须要复用这些已经建立的连接，复杂度高。&lt;/p&gt;&lt;p&gt;其实provider 和consumer 有双向心跳(探测)的，那为什么没检测出并进行重连？&lt;/p&gt;&lt;p&gt;这个首先面临的问题：client端认为连接成功了，但server端认为没有成功。那么server端 是不会发送心跳给 client端的。&lt;/p&gt;&lt;p&gt;client端是不是应该发心跳给server端呢？是的，原来使用dubbo2.5.3版本时3分钟client端会发送一个探测，之后把问题连接closed掉。只是dubbo 2.6.9使用了netty4。他们强强联手搞出来一个bug，探测机制楞没生效！&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7559262510974539&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicFPQQW5JXfQVCIb9lGSSj5ops591LdnVaVjIDDNca8t5leL2ejdKia21JNHthANia9hMthhTbyoNxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1139&quot;/&gt;&lt;/p&gt;&lt;p&gt;心跳有个条件，就是lastRead 和 lastWrite 不为空。那就需要看哪里设置了这两个参数。通过代码查到client端连接成功和server端连接成功的时候都会设置。这里只考虑client端情况，对比netty3发现netty4里少了&lt;/p&gt;&lt;p&gt;NettyServerHandler的handler链处理。这个handler链处理就是用来初始化那两个值的。&lt;/p&gt;&lt;p&gt;除了改client端源码，有没有别的方法让client端探测生效呢？其实什么都不用TCP就有keepalive(探活)机制。默认是7200秒，也就是2小时。可以修改：&lt;/p&gt;&lt;h2&gt;/proc/sys/net/ipv4/tcp_keepalive_time &lt;/h2&gt;&lt;h2&gt;单位是秒&lt;/h2&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;好了，解决问题的方法就讲到这里，完结撒花~~&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlicFPQQW5JXfQVCIb9lGSSj5rfdtsiaavV53WDy0biaOsSwyBqRZ08XKOJP58DXwNrnUXUIhTbDy5ibWw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;850&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;咦，说好的SMART原则呢？&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;1&quot; data-url=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484071&amp;amp;idx=1&amp;amp;sn=52157bf558c74a94de69e6fa8f138d51&amp;amp;chksm=fafde809cd8a611f0ec4dd66e40efa74f1f3ce4d69d89c23a2bc243e31dd3442cec8fc0a300d&amp;amp;token=199412102&amp;amp;lang=zh_CN#rd&quot; data-author-name=&quot;编程一生&quot; data-content-utf8-length=&quot;100&quot; data-source-title=&quot;知名互联网公司需要什么样的人才&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;S代表具体的(Specific)&lt;/p&gt;&lt;p&gt;M代表可衡量的(Measurable)&lt;/p&gt;&lt;p&gt;A代表可达到的(Attainable)&lt;/p&gt;&lt;p&gt;R代表与最终目标是相关的(Relevant) &lt;/p&gt;&lt;p&gt;T代表有明确的截止期限(Time-bound)&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;blockquote_info js_blockquote_source&quot; data-json=&quot;%7B%22type%22%3A%22inner%22%2C%22source%22%3A%22url%22%2C%22digest%22%3A%22%3Cp%3ES%E4%BB%A3%E8%A1%A8%E5%85%B7%E4%BD%93%E7%9A%84(Specific)%5CnM%E4%BB%A3%E8%A1%A8%E5%8F%AF%E8%A1%A1%E9%87%8F%E7%9A%84(Measurable)%5CnA%E4%BB%A3%E8%A1%A8%E5%8F%AF%E8%BE%BE%E5%88%B0%E7%9A%84(Attainable)%5CnR%E4%BB%A3%E8%A1%A8%E4%B8%8E%E6%9C%80%E7%BB%88%E7%9B%AE%E6%A0%87%E6%98%AF%E7%9B%B8%E5%85%B3%E7%9A%84(Relevant)%5CnT%E4%BB%A3%E8%A1%A8%E6%9C%89%E6%98%8E%E7%A1%AE%E7%9A%84%E6%88%AA%E6%AD%A2%E6%9C%9F%E9%99%90(Time-bound)%3C%2Fp%3E%22%2C%22digestLen%22%3A103%2C%22text%22%3A%22%22%2C%22article%22%3A%7B%22title%22%3A%22%E7%9F%A5%E5%90%8D%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E9%9C%80%E8%A6%81%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%BA%E6%89%8D%22%2C%22url%22%3A%22https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzUzNjAxODg4MQ%3D%3D%26mid%3D2247484071%26idx%3D1%26sn%3D52157bf558c74a94de69e6fa8f138d51%26chksm%3Dfafde809cd8a611f0ec4dd66e40efa74f1f3ce4d69d89c23a2bc243e31dd3442cec8fc0a300d%26token%3D199412102%26lang%3Dzh_CN%23rd%22%2C%22nickname%22%3A%22%E7%BC%96%E7%A8%8B%E4%B8%80%E7%94%9F%22%2C%22authorName%22%3A%22%E7%BC%96%E7%A8%8B%E4%B8%80%E7%94%9F%22%7D%2C%22hasReportOverSize%22%3Afalse%2C%22editorReportData%22%3A%5B%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2275%22%2C%22len%22%3A1%7D%2C%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2276%22%2C%22len%22%3A1%7D%2C%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2277%22%2C%22len%22%3A1%7D%2C%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2278%22%2C%22len%22%3A1%7D%5D%7D&quot;&gt;&lt;span class=&quot;blockquote_biz&quot;&gt;编程一生，公众号：编程一生&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484071&amp;amp;idx=1&amp;amp;sn=52157bf558c74a94de69e6fa8f138d51&amp;amp;chksm=fafde809cd8a611f0ec4dd66e40efa74f1f3ce4d69d89c23a2bc243e31dd3442cec8fc0a300d&amp;amp;token=199412102&amp;amp;lang=zh_CN#rd&quot; class=&quot;blockquote_article&quot;&gt;知名互联网公司需要什么样的人才&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;方案这么多，哪种是最好的呢？看场景。方案4提到了问题其实是开源组件有bug导致。但改开源组件，看公司规划、开源社区支持，A可行性上有制约；&lt;/p&gt;&lt;p&gt;方案2涉及很多整改和推动，T时效上有制约。方案虽多，排除法排除一下能剩下一个就不错了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8482758620689655&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlicFPQQW5JXfQVCIb9lGSSj57vztCTRsRZwAtbicghze8UsrYMiaFAcde7skbgBKfyCZAp7R8dbb0t4g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;290&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;往期推荐&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考文章：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.cnblogs.com/alchemystar/p/13473999.html&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>62ae1e9f5cfb1652078b64b85e42f30f</guid>
<title>技术团队如何追求高效能</title>
<link>https://toutiao.io/k/nqsycdm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;对于一个技术团队来说，高效能是最大的追求，因为这样团队和产品才更有可能成功，技术不会成为绊脚石。&lt;/p&gt;&lt;p&gt;有些人希望通过优秀的组织结构，或者通过完备的流程，或者寄希望于管理法术，再或者找到一个牛逼的架构，可实际上并没有银弹。&lt;/p&gt;&lt;p&gt;看完了《高效能团队模式》这本书，给了自己很多启发，其他的一些书籍感觉很有用，可又感觉很虚无缥缈，原因有自身的，也有外部的。&lt;/p&gt;&lt;p&gt;但这本书本身就来源于敏捷思想，所以DevOps一流，其中的理论感觉是解剖，有理有据，结合自己工作中遇到的问题，看起来更有收获。&lt;/p&gt;&lt;p&gt;为此按照自己的方式总结了本书，再到明年春暖花开之时，看看自己是否进步了吗？&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;组织结构的思维模式才是最重要的，要专注于全局优化，聚焦于完整的工作流，识别并消灭瓶颈。&lt;/p&gt;&lt;p&gt;每个组织实际上有三种，官方、个体影响、价值创造结构，但大家可能聚焦于官方定义的结构，认为只要采用”正确“的流程和”正确“的工具，就会成功，认为团队是可以替换的个体，实际上个人和团队才是最重要的。&lt;/p&gt;&lt;p&gt;传统或不合适的组织不利于创新，也无法产生稳定高效的团队模式和协作方法，更不利于软件快速流动。&lt;/p&gt;&lt;p&gt;设计组织一定要考虑：是否有合适的理由设计，这个设计背后的开发决策；选择正确的时机；寻找事物偏离轨迹的线索；对未来保持警惕。&lt;/p&gt;&lt;p&gt;康威定律认为，如果一个组织的沟通路径不存在，则最后的系统架构和设计方案就很难落地，也就是说组织架构决定了系统架构。如果希望得到一种系统架构，就要重新思考组织架构来满足它，这就是逆康威定律。&lt;/p&gt;&lt;p&gt;软件架构一定要利于团队之间协作，团队之间一定要能够快速流动，为此可以采取一些良好的最佳实践，比如松耦合和高内聚（怎么哪儿都有它们）。&lt;/p&gt;&lt;p&gt;组织设计有时候要参考专家的意见，避免临时起意的团队设计，也不要轻易频繁调动团队成员，更不要为了一些管理原因进行组织结构的调整，私以为进行调整是为了灵活性，实际上上下文切换成本也很高。&lt;/p&gt;&lt;p&gt;限制非必要沟通，康威定律说明，太多的沟通会产生高度耦合和相互依赖的系统，导致流动阻塞，所以过多的沟通不一定是好事。&lt;/p&gt;&lt;p&gt;一定要有团队优先的思维方式：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;比如小而美的团队更聚焦，更容易决策，更容易产生信任；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;要维持团队的稳定性，布鲁克斯定律表示给一个团队添加新成员并不会立即提升团队的容量；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;软件的每一部分必须有单一的团队负责（并不是为了限制共享，也不是为了划分地盘），而是为了减少混乱；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;团队的成员必须具备团队思维方式，团队需求必须大于个人需求，聚焦团队目标；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;团队中也必须拥抱多样性，不同的员工能激发正能量，不同的员工能让员工和组织受益&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;奖励团队而非个人&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;要意识到团队和个人都是有认知负荷的，所以才要小和美。认知负荷包含三种（固有认知负荷，额外认知负荷，相关认知负荷），负荷一多，就会带来压力，就做不到全局考虑，无法给团队带来最大收益。&lt;/p&gt;&lt;p&gt;过多的认知负荷会导致频繁的切换，从而打消积极性，无法让人自治，精通，目标过多。所以一定要限制团队的认知负荷。&lt;/p&gt;&lt;p&gt;怎么样度量认知负荷？你觉得高效吗？你觉得能响应交代的工作吗？团队心理都有一杆秤。也不能用代码数量等评估，应该用领域复杂度来评估。&lt;/p&gt;&lt;p&gt;每个团队承受的不同复杂度的任务数量都应该是有限的。&lt;/p&gt;&lt;p&gt;团队小而美很好说，那么如何划分呢？必须有一个边界，而软件边界可能是一种比较好的评估方式，选择什么架构，必须考虑所有团队的认知负荷，比如我们也想做SRE，可目前并没有这样的能力，所以只能选择合适目前的架构。&lt;/p&gt;&lt;p&gt;团队边界必须以一种好的方式表现出来，团队API是一种很好的方式，文档、接口契约。&lt;/p&gt;&lt;p&gt;不管是团队优先理论，还是流程优化，必须采用那些被证明过的团队实践，比如持续交付、测试优先的开发，否则很难实现。&lt;/p&gt;&lt;p&gt;设计组织架构，都开始重视变更流程，提倡“低摩擦”的软件交付方式，从而获得快速的交付方式，以及及时得到反馈，精心设计的组织更有可能成功。&lt;/p&gt;&lt;p&gt;DevOps和SRE都是“低摩擦”的软件交付方式，DevOps的关键贡献在于让不同团队意识到对其他团队缺少理解和关心；而SRE让可扩展性成为可能，它是比较动态的一种交付方式，是平衡交付速度和软件可用性，强调布道师的作用。&lt;/p&gt;&lt;p&gt;选择一个团队拓扑，必须考虑几个方面：&lt;/p&gt;&lt;p&gt;说到依赖，主要分为三种：知识依赖，任务依赖，资源依赖。&lt;/p&gt;&lt;p&gt;四类基本团队拓扑：流动式团队，赋能团队，复杂子系统团队，平台团队。&lt;/p&gt;&lt;p&gt;对于稍大规模的组织，这几种团队拓扑都会存在，强调“够用就好“。&lt;/p&gt;&lt;p&gt;团队之间有三种交互模式，也对应了上述集中团队拓扑，分别是协作、服务、促进。&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>08fb886b09f20079cdbdc966176b7a3d</guid>
<title>URI/URL/URN，傻傻分不清？</title>
<link>https://toutiao.io/k/oj7shrp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single js_wx_tap_highlight wx_tap_card&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left&quot; aria-describedby=&quot;js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MTgxODgwNA==&amp;amp;action=getalbum&amp;amp;album_id=1962688186782908417#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;1962688186782908417&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#网络&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;15个&lt;span class=&quot;weui-hidden_abs&quot;&gt;内容&lt;/span&gt;&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote&gt;&lt;p&gt;&lt;em&gt;当我们上网的时候，浏览器地址栏里显示的那一串字符串是什么意思？这串字符叫URL，是URI的一种，还有个兄弟叫URN，这篇文章就带你了解这几个概念。原文：URI vs URL vs URN&lt;span&gt;[1]&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0WOLiabzCIE9qGuFsVHticZr0Hu2ty2HxBqtTZSHAq4cjTHQroP46iaUq1aSefqeGYicOZR7YYAIwarGw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;当我们处理互联网和在线内容时，URI、URL和URN是我们能听到的最熟悉的单词，下面让我们深入了解它们的含义……&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;hr/&gt;&lt;h1&gt;URI - 统一资源识别符（Uniform Resource Identifier）&lt;/h1&gt;&lt;p&gt;URI是标识所有连接到万维网（World Wide Web）的资源的通用术语，是用来标识逻辑资源或者物理资源的字符串序列。换句话说，它可以用来识别互联网上的资源的位置、或名称、或两者兼有。URI有两个主要的子集，即URL和URN。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6276477146042363&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0WOLiabzCIE9qGuFsVHticZr0a9r3EILhmEI83cya7rSmJXugGAjERibn6ibGibkB03eD0JTjyciaN1DlTw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;897&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;URI语法&lt;/span&gt;：scheme:[//[user:password@]host[:port]][/]path[?query][#fragment]&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;URI示例&lt;/span&gt;：foo://example.com:8042/over/there?name=ferret#nose&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Scheme&lt;/span&gt;：URI的起始点，并与URI协议相关。URI schema对大小写不敏感，后面带有一个“:”。尽管在实践中可以使用未注册的schema，但URI schema应该向Internet Assigned Numbers Authority (IANA)注册。几个流行的URI schema的例子：HTTP、HTTPS、FTP和mailto。&lt;/p&gt;&lt;p&gt;&lt;span&gt;Authority（权限）&lt;/span&gt;：Authority字段是位于schema字段之后的第二个条目，以两个斜杠(//)开头。这个字段由多个子字段组成：&lt;/p&gt;&lt;p&gt;&lt;span&gt;Path（路径）&lt;/span&gt;：Path是第三个字段，由斜杠分隔的段序列来表示，用来提供资源的位置。注意，不管authority部分存在或不存在，path都应该以一个斜杠开始，而不是双斜杠(//)。&lt;/p&gt;&lt;p&gt;&lt;span&gt;Query（查询）&lt;/span&gt;：Query是第四个字段，是URI的可选字段，包含一串非结构数据并以“?”和Path隔开。&lt;/p&gt;&lt;p&gt;&lt;span&gt;Fragment（片段）&lt;/span&gt;：Fragment是第五个组成部分，也是一个可选字段，提供指向辅助资源的方向，并以“#”开始。简单来说，Fragment字段可以用于指向HTML页面的特定元素(主资源)。&lt;/p&gt;&lt;hr/&gt;&lt;h1&gt;URL - 统一资源定位符（Uniform Resource Locator）&lt;/h1&gt;&lt;p&gt;如上所述，&lt;span&gt;URL&lt;/span&gt;是&lt;span&gt;URI&lt;/span&gt;的一个子集。&lt;span&gt;URL&lt;/span&gt;是一个给定唯一Web资源的地址，表明了这个唯一的Web资源的位置，用户可以通过&lt;span&gt;URL&lt;/span&gt;浏览互联网。如果我们在任何应用程序中点击任何超链接，它会将我们重定向到相关的&lt;span&gt;URL&lt;/span&gt;，这些&lt;span&gt;URL&lt;/span&gt;也可以很容易的输入到浏览器地址栏中，并可以加载特定的资源。&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;URL语法&lt;/span&gt;：scheme://host:port/path?query-string#fragment-id&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;URL示例&lt;/span&gt;: https://medium.com/p/51b8167cafad&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Scheme&lt;/span&gt;：URL的第一部分，表示浏览器请求资源时必须使用的协议。常见例子有HTTPS(安全版本)和HTTP(非安全版本)。&lt;/p&gt;&lt;p&gt;&lt;span&gt;Authority&lt;/span&gt;：Authority是URL的第二个字段，同样使用“//”开头，包含一些子部分：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;host（主机名）&lt;/span&gt;—分配给主机的域名或IP地址，是主机的本地名称和它的父域名的组合&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;port（端口）&lt;/span&gt;—表示用于访问Web服务器上特定资源的标识，通常80表示HTTP, 443表示HTTPS，这是一个可选字段&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;Path to resource（资源路径）&lt;/span&gt;：路径是URL的第三个字段，是Web服务器上资源的路径&lt;/p&gt;&lt;p&gt;&lt;span&gt;Query（查询）&lt;/span&gt;：查询是URL的第四个字段，由传递给服务器端脚本的数据组成，并在Web服务器上运行。查询将执行带有“?”的搜索参数，参数通常由名字和值对组成的字符串组成，并由“&amp;amp;”分隔。&lt;/p&gt;&lt;p&gt;&lt;span&gt;Fragment Identifier（片段标识符）&lt;/span&gt;：片段是可选字段，用于表示页面中的位置，由“#”标识片段标识符。&lt;/p&gt;&lt;hr/&gt;&lt;h1&gt;URN - 统一资源名（Uniform Resource Name）&lt;/h1&gt;&lt;p&gt;&lt;span&gt;URN&lt;/span&gt;是一种具有静态名称的互联网资源，即使它的数据被移动到另一个位置也仍然有效。&lt;span&gt;URL&lt;/span&gt;在内容被移动后就失效了，与之不同的是，&lt;span&gt;URN&lt;/span&gt;可以始终跟踪Web上某些数据的资源，从而解决了频繁移动数据的问题。&lt;/p&gt;&lt;p&gt;更进一步的，我们可以说，当用户知道唯一资源的位置时，可以使用URL，但URN只需要知道特定资源的名称，而不用指定其位置。&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;URN语法&lt;/span&gt;：scheme:NID: NSS&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;URN示例&lt;/span&gt;：urn:ISSN:0167–6423&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Scheme&lt;/span&gt;：URN的前导部分，以“:”结尾，不区分大小写&lt;/p&gt;&lt;p&gt;&lt;span&gt;NID（Namespace ID）&lt;/span&gt;：URN的第二个字段，是向IANA注册的命名空间标识符。NID后面跟着一个&quot;:&quot;，可以由字母、数字和&quot; - &quot;组成。&lt;/p&gt;&lt;p&gt;&lt;span&gt;NSS（Namespace Specific String）&lt;/span&gt;：NID之后的下一个字段，是一个特定于命名空间的字符串。NID确定NSS的语法解释。NSS可以由ASCII字母、数字、标点符号和特殊字符组成。&lt;/p&gt;&lt;hr/&gt;&lt;h1&gt;区分识别URI、URL和URN的小技巧&lt;/h1&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;URL是一个可以检索网络资源的链接；URN是唯一标识符，但不能创建可单击的链接。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;人们经常用名字作为例子来描述URI和URN。人的名字就像URI，因为它标识了一个人，但并没有告诉你在世界上的哪个地方可以找到这样一个特定的人，甚至也没有告诉你我们谈论的是哪个人。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;简单的名字不能作为URN的例子，因为没有唯一性，世界上有很多人有同样的名字。URN是一个带有全局唯一标识符的名称，如身份证号或社会保险号。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在网络中，URN很容易被发现。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;em&gt;本文到此结束，如果你正好想要了解关于URI、URL和URN的知识，希望这篇文章对你有用。&lt;/em&gt;&lt;/p&gt;&lt;p&gt;感谢阅读本文…!!!🤗🤗🤗&lt;span/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;References:&lt;/span&gt;&lt;br/&gt;[1] https://enlear.academy/uri-vs-url-vs-urn-51b8167cafad&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。&lt;br/&gt;微信公众号：DeepNoMind&lt;/p&gt;&lt;/blockquote&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>622710f9b47382f4627e505d288767ae</guid>
<title>宣布 ScaNN：高效的向量相似性搜索</title>
<link>https://toutiao.io/k/fymfpjt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;p&gt;假设有人想要使用需要精确匹配标题、作者或其他易于机器索引的条件的查询来搜索大型文学作品数据集。这样的任务非常适合使用 SQL 等语言的关系数据库。但是，如果想要支持更抽象的查询，例如“内战诗”，则不再可能依赖朴素的相似度指标，例如两个短语之间的共同词数。例如，查询“科幻”与“未来”的相关性比与“地球科学”的相关性更高，尽管前者与查询相同的词为 0，而后者只有一个。&lt;/p&gt;&lt;p&gt;机器学习 (ML) 极大地提高了计算机理解语言语义并回答这些抽象查询的能力。现代 ML 模型可以将文本和图像等输入转换为嵌入、高维向量训练，以便更多相似的输入聚集在一起。因此，对于给定的查询，我们可以计算其嵌入，并找到嵌入最接近查询的文学作品。通过这种方式，ML 将一项抽象且以前难以指定的任务转变为一项严格的数学任务。然而，一个计算挑战仍然存在：对于给定的查询嵌入，如何快速找到最近的数据集嵌入？对于穷举搜索而言，嵌入集通常太大，并且其高维度使得修剪变得困难。&lt;/p&gt;&lt;p&gt;在我们的ICML 2020论文“使用各向异性向量量化加速大规模推理”，我们通过关注如何压缩数据集向量以实现快速近似距离计算来解决这个问题，并提出了一种新的压缩技术，与之前的工作相比，该技术显着提高了准确性. 这种技术在我们最近开源的向量相似性搜索库(ScaNN) 中得到了利用，使我们能够在ann-benchmarks.com 上测得的性能比其他向量相似性搜索库高两倍。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;em&gt;矢量相似性搜索的重要性&lt;/em&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;基于嵌入的搜索是一种有效地回答依赖语义理解而不是简单的可索引属性的查询的技术。在这种技术中，机器学习模型被训练以将查询和数据库项目映射到公共向量嵌入空间，从而嵌入之间的距离带有语义意义，即相似的项目更接近。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceGm3FEK8jbcQg0lIPlI0hR5q3Vl8DDiaoamo9apLnAhqvHX6tWpZMy9N9bKSbGHbvaibxFG42Yx8hmw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;p&gt;要使用这种方法回答查询，系统必须首先将查询映射到嵌入空间。然后它必须在所有数据库嵌入中找到最接近查询的嵌入；这是最近邻搜索问题。定义查询-数据库嵌入相似度的最常见方法之一是通过它们的内积；这种最近邻搜索称为最大内积搜索(MIPS)。&lt;/p&gt;&lt;p&gt;由于数据库规模很容易达到数百万甚至数十亿，MIPS往往是推理速度的计算瓶颈，穷举搜索是不切实际的。这需要使用近似的 MIPS 算法，该算法将一些准确性交换为比蛮力搜索显着的加速。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;em&gt;一种新的 MIPS 量化方法 MIPS 的&lt;/em&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;几种最先进的解决方案基于压缩数据库项，以便可以在很短的时间内计算出它们的内积的近似值。这种压缩通常是通过学习量化完成的，其中向量的码本是从数据库中训练出来的，用于近似表示数据库元素。&lt;/p&gt;&lt;p&gt;以前的矢量量化方案量化了数据库元素，目的是最小化每个矢量x与其量化形式x̃之间的平均距离. 虽然这是一个有用的指标，但对此进行优化并不等同于优化最近邻搜索精度。我们论文背后的关键思想是，具有更高平均距离的编码实际上可能会导致更高的 MIPS 精度。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们的结果的直觉如下所示。假设我们有两个数据库嵌入x 1和x 2，并且必须将每个嵌入到两个中心之一：c 1或c 2。我们的目标是将每个x i量化为x̃ i使得内积 &amp;lt; q , x̃ i&amp;gt; 尽可能类似于原始内积 &amp;lt; q , x i &amp;gt; 。这可以被可视化为使得突出部的大小X我到q尽可能相似的投影X我到q。在传统的量化方法（左）中，我们会为每个x i选择最近的中心，这会导致两个点的相对排名不正确：&amp;lt; q , x̃ 1 &amp;gt;大于&amp;lt; q , x̃ 2 &amp;gt;，甚至虽然 &amp;lt; q , x1 &amp;gt;小于&amp;lt; q , x 2 &amp;gt;！如果我们改为将x 1分配给c 1并将x 2分配给c 2，我们会得到正确的排名。这如下图所示。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceGm3FEK8jbcQg0lIPlI0hR50hQ90kKsXOdVCY20JRD7NUwl59raHbe2rdJa2wvuiaI4ia1aTibfLKp1g/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;p&gt;事实证明，方向事项以及大小-即使Ç 1是从更远的X 1比Ç 2，c ^ 1从偏移X 1的方向上几乎完全正交于X 1，而c ^ 2的偏移量是平行（对于x 2，同样的情况适用但翻转）。平行方向的误差在 MIPS 问题中危害更大，因为它不成比例地影响高内积，根据定义，这是 MIPS 试图准确估计的内积。&lt;/p&gt;&lt;p&gt;基于这种直觉，我们更严厉地惩罚与原始向量平行的量化误差。由于其损失函数的方向依赖性，我们将我们的新型量化技术称为各向异性矢量量化。这种技术能够用较低内积的增加的量化误差来换取高内积的卓越精度，这是关键创新和其性能提升的来源。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceGm3FEK8jbcQg0lIPlI0hR5QJJ38ib1IXbxZNgPzBz6eq6LEk2Jia1koUDnPrUcU5oaQXuR09tkpfcw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;em&gt;ScaNN 中的&lt;/em&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;各向异性矢量量化 各向异性矢量量化允许 ScaNN 更好地估计可能出现在 top- k MIPS 结果中的内积，从而实现更高的精度。在来自ann-benchmarks.com的glove-100-angular 基准测试中，ScaNN 的表现优于其他 11 个经过精心调整的向量相似性搜索库，在给定精度下每秒处理的查询数量大约是次快库的两倍。*&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceGm3FEK8jbcQg0lIPlI0hR5fnLiaUZicGVuhmXu6JiadKBDhfydWj5TQKHpX8BkXy0mYYc65iatZicOGyg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;p&gt;Recall@k 是最近邻搜索准确度的常用指标，它衡量算法返回的 k 个邻居中存在的真实最近 k 个邻居的比例。ScaNN（上紫色线）在速度-精度权衡的各个点上始终如一地实现了卓越的性能。ScaNN 是开源软件，您可以在GitHub 上自行试用。该库可以通过 Pip 直接安装，并具有用于 TensorFlow 和 Numpy 输入的接口。有关安装和配置 ScaNN 的进一步说明，请参阅 GitHub 存储库。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;em&gt;结论&lt;/em&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;通过修改矢量量化目标以符合 MIPS 的目标，我们在最近邻搜索基准上实现了最先进的性能，这是基于嵌入的搜索性能的关键指标。尽管各向异性矢量量化是一项重要技术，但我们认为这只是通过优化算法以提高搜索精度的最终目标而不是诸如压缩失真等中间目标来实现性能提升的一个例子。&lt;/p&gt;&lt;/ul&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>38a561ff8ae35e08a3cf58efe96b6b9f</guid>
<title>sockfwd：一个数据转发的小工具</title>
<link>https://toutiao.io/k/4dygq68</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;&lt;p&gt;最近在看containerd的代码，上手试的时候才发现它监听的是unix socket，没法从外部访问containerd。&lt;br/&gt;而我要验证的是从远端能不能访问containerd、管理containerd的容器，所以需要一个从远端访问unix socket的工具。&lt;/p&gt;
&lt;p&gt;网上搜了一圈，没有现成的实现，就自己写了 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/robberphex/sockfwd&quot;&gt;sockfwd&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;用法&quot;&gt;用法&lt;/span&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Usage:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  sockfwd [flags]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;Flags:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  -d, --destination string   目的地址，即要转发到的地址&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  -s, --source string        源地址，即接收请求的地址&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  -q, --quiet                静默模式&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2&gt;&lt;span id=&quot;例子&quot;&gt;例子&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;将本地的containerd实例暴露到网络上：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./sockfwd -s tcp://127.0.0.1:8090 -d unix:///var/run/containerd.sock&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将本地的&lt;code&gt;127.0.0.1:8080&lt;/code&gt;端口暴露到&lt;code&gt;0.0.0.0:8090&lt;/code&gt;端口上：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./sockfwd -s tcp://127.0.0.1:8090 -d unix://127.0.0.1:8090&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将本地的服务暴露到网络上，需要格外注意是否有安全隐患！&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;其他碎碎念&quot;&gt;其他碎碎念&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;最近在写golang，发现如果仅仅是处理数据面的话，golang提供的goroute再加channel就能够很优雅地处理数据转发，比如这篇文章写的sockfwd。&lt;/p&gt;
&lt;p&gt;但是如果涉及管控面，比如复杂的状态管理，信息跨线程/goroute同步，那么channel的抽象能力还是不够的，需要写很多额外代码。&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;后续计划&quot;&gt;后续计划&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;可以加上支持tls认证来更加安全地转发数据。&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>