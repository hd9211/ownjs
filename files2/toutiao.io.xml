<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>74ac97a80f1c58ba45a80842d2e3896a</guid>
<title>MySQL 索引连环 18 问</title>
<link>https://toutiao.io/k/x7420rp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-topic-des nc-post-content&quot;&gt;
&lt;p&gt;MySQL作为互联网中非常热门的数据库，现在大厂面试题横竖绕不开MySQL，其中MySQL索引是大厂必考面试题。今天带来了MySQL索引的常考面试题，看看你能答对多少~ &lt;/p&gt; 
&lt;p&gt;这是本期的MySQL索引面试题目录，不会的快快查漏补缺~&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;目录&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752025/image-20210411230042052.png&quot;/&gt;&lt;/p&gt; 
&lt;h2&gt;1. 索引是什么？&lt;/h2&gt; 
&lt;p&gt;索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;索引是一种数据结构。数据库索引，是数据库管理系统中一个&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。而且索引是一个文件，它是要占据物理空间的。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。比如我们在查字典的时候，前面都有检索的拼音和偏旁、笔画等，然后找到对应字典页码，这样然后就打开字典的页数就可以知道我们要搜索的某一个key的全部值的信息了。&lt;/p&gt; 
&lt;h2&gt;2. 索引有哪些优缺点？&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;索引的优点&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 &lt;/li&gt;
 &lt;li&gt;通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;索引的缺点&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率； &lt;/li&gt;
 &lt;li&gt;空间方面：索引需要占物理空间。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;3. MySQL有哪几种索引类型？&lt;/h2&gt; 
&lt;p&gt;1、从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。这里所描述的是索引存储时保存的形式，&lt;/p&gt; 
&lt;p&gt;2、从应用层次来分：普通索引，唯一索引，复合索引。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;普通索引：即一个索引只包含单个列，一个表可以有多个单列索引&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;唯一索引：索引列的值必须唯一，但允许有空值&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;复合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;聚簇索引(聚集索引)：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;非聚簇索引： 不是聚簇索引，就是非聚簇索引&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;3、根据中数据的物理顺序与键值的逻辑（索引）顺序关系： 聚集索引，非聚集索引。&lt;/p&gt; 
&lt;h2&gt;4. 说一说索引的底层实现？&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;Hash索引&lt;/strong&gt; &lt;/p&gt; 
&lt;p&gt;&lt;span&gt;基于&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%93%88%E5%B8%8C%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;哈希表&lt;/a&gt;实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;图片来源：&lt;a href=&quot;https://www.javazhiyin.com/40232.html&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://www.javazhiyin.com/40232.html&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752261/image-20210411215012443.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;B-Tree索引&lt;/strong&gt;（MySQL使用B+Tree）&lt;/p&gt; 
&lt;p&gt;B-Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752112/image-20210411215023820.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;B+Tree索引&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;是B-Tree的改进版本，同时也是数据库索引索引所采用的存储结构。数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。&lt;/p&gt; 
&lt;p&gt;B+tree性质：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;B+ 树中，数据对象的插入和删除仅在叶节点上进行。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752195/image-20210411215044332.png&quot;/&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span&gt;5. 为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E4%BA%8C%E5%8F%89%E6%A0%91&quot; target=&quot;_blank&quot;&gt;二叉树&lt;/a&gt;，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;？&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;B-tree： 从两个方面来回答&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B(B-)树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对&lt;code&gt;IO读写次数就降低&lt;/code&gt;了。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在&lt;code&gt;区间查询&lt;/code&gt;的情况，所以通常B+树用于数据库索引。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;Hash： &lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;虽然可以快速定位，但是没有顺序，IO复杂度高；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;基于Hash表实现，只有Memory存储引擎显式支持哈希索引 ；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;适合&lt;strong&gt;等值查询&lt;/strong&gt;，如=、in()、&amp;lt;=&amp;gt;，不支持范围查询 ；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;因为不是按照索引值顺序存储的，就不能像B+Tree索引一样利用索引完成&lt;a target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;排序&lt;/a&gt; ；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;Hash索引在查询等值时非常快 ；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;因为Hash索引始终索引的&lt;strong&gt;所有列的全部内容&lt;/strong&gt;，所以不支持部分索引列的匹配查找 ；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题 。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E4%BA%8C%E5%8F%89%E6%A0%91&quot; target=&quot;_blank&quot;&gt;二叉树&lt;/a&gt;： 树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;： 树的高度随着数据量增加而增加，IO代价高。&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;6. 讲一讲聚簇索引与非聚簇索引？&lt;/h2&gt; 
&lt;p&gt;在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引，即将数据存储与索引放到了一块，找到索引也就找到了数据。&lt;/p&gt; 
&lt;p&gt;而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引、二级索引。&lt;/p&gt; 
&lt;p&gt;聚簇索引与非聚簇索引的区别：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键（行号） &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;对于InnoDB来说，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为&lt;strong&gt;回表&lt;/strong&gt;。第一次索引一般是顺序IO，回表的操作属于随机IO。需要回表的次数越多，即随机IO次数越多，我们就越倾向于使用全表扫描 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;通常情况下， 主键索引（聚簇索引）查询只会查一次，而非主键索引（非聚簇索引）需要回表查询多次。当然，如果是覆盖索引的话，查一次即可 &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;注意：MyISAM无论主键索引还是二级索引都是非聚簇索引，而InnoDB的主键索引是聚簇索引，二级索引是非聚簇索引。我们自己建的索引基本都是非聚簇索引。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;7. 非聚簇索引一定会回表查询吗？&lt;/h2&gt; 
&lt;p&gt;不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。一个索引包含（覆盖）所有需要查询字段的值，被称之为&quot;覆盖索引&quot;。&lt;/p&gt; 
&lt;p&gt;举个简单的例子，假设我们在学生表的成绩上建立了索引，那么当进行&lt;code&gt;select score from student where score &amp;gt; 90&lt;/code&gt;的查询时，在索引的叶子节点上，已经包含了score 信息，不会再次进行回表查询。&lt;/p&gt; 
&lt;h2&gt;8. 联合索引是什么？为什么需要注意联合索引中的顺序？&lt;/h2&gt; 
&lt;p&gt;MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。&lt;/p&gt; 
&lt;p&gt;具体原因为:&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;MySQL使用索引时需要索引有序，假设现在建立了&quot;name，age，school&quot;的联合索引，那么索引的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;为: 先按照name&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;，如果name相同，则按照age&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;，如果age的值也相等，则按照school进行&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。&lt;/p&gt; 
&lt;h2&gt;9. 讲一讲MySQL的最左前缀原则?&lt;/h2&gt; 
&lt;p&gt;最左前缀原则就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。&lt;br/&gt;mysql会一直向右匹配直到遇到范围查询(&amp;gt;、&amp;lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &amp;gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。&lt;/p&gt; 
&lt;p&gt;=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。&lt;/p&gt; 
&lt;h2&gt;10. 讲一讲前缀索引？&lt;/h2&gt; 
&lt;p&gt;因为可能我们索引的字段非常长，这既占内存空间，也不利于维护。所以我们就想，如果只把很长字段的前面的公共部分作为一个索引，就会产生超级加倍的效果。但是，我们需要注意，order by不支持前缀索引 。&lt;/p&gt; 
&lt;p&gt; 流程是： &lt;/p&gt; 
&lt;p&gt; 先计算完整列的选择性 :&lt;code&gt;select count(distinct col_1)/count(1) from table_1&lt;/code&gt;&lt;/p&gt; 
&lt;p&gt; 再计算不同前缀长度的选择性 :&lt;code&gt;select count(distinct left(col_1,4))/count(1) from table_1&lt;/code&gt;&lt;/p&gt; 
&lt;p&gt; 找到最优长度之后，创建前缀索引 :&lt;code&gt;create index idx_front on table_1 (col_1(4))&lt;/code&gt;&lt;/p&gt; 
&lt;h2&gt;11. 了解索引下推吗？&lt;/h2&gt; 
&lt;p&gt;MySQL 5.6引入了索引下推优化。默认开启，使用SET optimizer_switch = ‘index_condition_pushdown=off’;可以将其关闭。 &lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;有了索引下推优化，可以在&lt;strong&gt;减少回表次数&lt;/strong&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;在InnoDB中只针对二级索引有效&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;官方文档中给的例子和解释如下：&lt;/p&gt; 
&lt;p&gt;在 people_table中有一个二级索引(zipcode，lastname，address)，查询是SELECT * FROM people WHERE zipcode=’95054′ AND lastname LIKE ‘%etrunia%’ AND address LIKE ‘%Main Street%’; &lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;如果没有使用索引下推技术，则MySQL会通过zipcode=’95054’从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastname LIKE ‘%etrunia%’ and address LIKE ‘%Main Street%’来判断数据是否符合条件 &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;如果使用了索引下推技术，则MYSQL首先会返回符合zipcode=’95054’的索引，然后根据lastname LIKE ‘%etrunia%’ and address LIKE ‘%Main Street%’来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;12. 怎么查看MySQL语句有没有用到索引？&lt;/h2&gt; 
&lt;p&gt;通过explain，如以下例子：&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;EXPLAIN SELECT * FROM employees.titles WHERE emp_no=&#x27;10001&#x27; AND title=&#x27;Senior Engineer&#x27; AND from_date=&#x27;1986-06-26&#x27;;&lt;/code&gt;&lt;/p&gt; 
&lt;table&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th&gt;id&lt;/th&gt; 
   &lt;th&gt;select_type&lt;/th&gt; 
   &lt;th&gt;table&lt;/th&gt; 
   &lt;th&gt;partitions&lt;/th&gt; 
   &lt;th&gt;type&lt;/th&gt; 
   &lt;th&gt;possible_keys&lt;/th&gt; 
   &lt;th&gt;key&lt;/th&gt; 
   &lt;th&gt;key_len&lt;/th&gt; 
   &lt;th&gt;ref&lt;/th&gt; 
   &lt;th&gt;filtered&lt;/th&gt; 
   &lt;th&gt;rows&lt;/th&gt; 
   &lt;th&gt;Extra&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt;
  &lt;tr&gt; 
   &lt;td&gt;1&lt;/td&gt; 
   &lt;td&gt;SIMPLE&lt;/td&gt; 
   &lt;td&gt;titles&lt;/td&gt; 
   &lt;td&gt;null&lt;/td&gt; 
   &lt;td&gt;const&lt;/td&gt; 
   &lt;td&gt;PRIMARY&lt;/td&gt; 
   &lt;td&gt;PRIMARY&lt;/td&gt; 
   &lt;td&gt;59&lt;/td&gt; 
   &lt;td&gt;const,const,const&lt;/td&gt; 
   &lt;td&gt;10&lt;/td&gt; 
   &lt;td&gt;1&lt;/td&gt; 
   &lt;td/&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt;
&lt;/table&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;id：在⼀个⼤的查询语句中每个&lt;strong&gt;SELECT&lt;/strong&gt;关键字都对应⼀个唯⼀的id ，如explain select * from s1 where id = (select id from s1 where name = &#x27;egon1&#x27;);第一个select的id是1，第二个select的id是2。有时候会出现两个select，但是id却都是1，这是因为优化器把子查询变成了连接查询 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;select_type：select关键字对应的那个查询的类型，如SIMPLE,PRIMARY,SUBQUERY,DEPENDENT,SNION 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;table：每个查询对应的表名 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;type：&lt;code&gt;type&lt;/code&gt; 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 &lt;code&gt;type&lt;/code&gt; 字段, 我们判断此次查询是 &lt;code&gt;全表扫描&lt;/code&gt; 还是 &lt;code&gt;索引扫描&lt;/code&gt; 等。如const(主键索引或者唯一二级索引进行等值匹配的情况下),ref(普通的⼆级索引列与常量进⾏等值匹配),index(扫描全表索引的覆盖索引) 。&lt;/p&gt; &lt;p&gt;通常来说, 不同的 type 类型的性能关系如下:&lt;br/&gt;&lt;code&gt;ALL &amp;lt; index &amp;lt; range ~ index_merge &amp;lt; ref &amp;lt; eq_ref &amp;lt; const &amp;lt; system&lt;/code&gt;&lt;br/&gt;&lt;code&gt;ALL&lt;/code&gt; 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.&lt;br/&gt;而 &lt;code&gt;index&lt;/code&gt; 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;possible_key：查询中可能用到的索引&lt;em&gt;(可以把用不到的删掉，降低优化器的优化时间)&lt;/em&gt; 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;key：此字段是 MySQL 在当前查询时所真正使用到的索引。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;filtered：查询器预测满足下一次查询条件的百分比 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.&lt;br/&gt;这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;extra：表示额外信息，如Using where,Start temporary,End temporary,Using temporary等。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;13. 为什么官方建议使用自增长主键作为索引？&lt;/h2&gt; 
&lt;p&gt;结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率。&lt;/p&gt; 
&lt;p&gt;插入连续的数据：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;图片来自：&lt;a href=&quot;https://www.javazhiyin.com/40232.html&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://www.javazhiyin.com/40232.html&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752160/java10-1562726251.gif&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;插入非连续的数据：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752674/java8-1562726251.gif&quot;/&gt;&lt;/p&gt; 
&lt;h2&gt;14. 如何创建索引？&lt;/h2&gt; 
&lt;p&gt;创建索引有三种方式。&lt;/p&gt; 
&lt;p&gt;1、 在执行CREATE TABLE时创建索引&lt;/p&gt; 
&lt;pre class=&quot;prettyprint lang-sql&quot; from-niu=&quot;default&quot;&gt;CREATE TABLE user_index2 (
    id INT auto_increment PRIMARY KEY,
    first_name VARCHAR (16),
    last_name VARCHAR (16),
    id_card VARCHAR (18),
    information text,
    KEY name (first_name, last_name),
    FULLTEXT KEY (information),
    UNIQUE KEY (id_card)
);
&lt;/pre&gt; 
&lt;p&gt;2、 使用ALTER TABLE命令去增加索引。&lt;/p&gt; 
&lt;pre class=&quot;prettyprint lang-sql&quot; from-niu=&quot;default&quot;&gt;ALTER TABLE table_name ADD INDEX index_name (column_list);&lt;/pre&gt; 
&lt;p&gt;ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。&lt;/p&gt; 
&lt;p&gt;其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。&lt;/p&gt; 
&lt;p&gt;索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。&lt;br/&gt;3、 使用CREATE INDEX命令创建。&lt;/p&gt; 
&lt;pre class=&quot;prettyprint lang-sql&quot; from-niu=&quot;default&quot;&gt;CREATE INDEX index_name ON table_name (column_list);&lt;/pre&gt; 
&lt;h2&gt;15. 创建索引时需要注意什么？&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值； &lt;/li&gt;
 &lt;li&gt;取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高； &lt;/li&gt;
 &lt;li&gt;索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;16. 建索引的原则有哪些？&lt;/h2&gt; 
&lt;p&gt;1、最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&amp;gt;、&amp;lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &amp;gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。&lt;/p&gt; 
&lt;p&gt;2、=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。&lt;/p&gt; 
&lt;p&gt;3、尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。&lt;/p&gt; 
&lt;p&gt;4、索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。&lt;/p&gt; 
&lt;p&gt;5、尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。&lt;/p&gt; 
&lt;h2&gt;17. 使用索引查询一定能提高查询的性能吗？&lt;/h2&gt; 
&lt;p&gt;通常通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。&lt;/p&gt; 
&lt;p&gt;索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的I* NSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;基于一个范围的检索，一般查询返回结果集小于表中记录数的30%。 &lt;/li&gt;
 &lt;li&gt;基于非唯一性索引的检索。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;18. 什么情况下不走索引（索引失效）？&lt;/h2&gt; 
&lt;h5&gt;1、使用!= 或者 &amp;lt;&amp;gt; 导致索引失效&lt;/h5&gt; 
&lt;h5&gt;2、类型不一致导致的索引失效&lt;/h5&gt; 
&lt;h5&gt;3、函数导致的索引失效&lt;/h5&gt; 
&lt;p&gt;如：&lt;/p&gt; 
&lt;pre class=&quot;prettyprint&quot; from-niu=&quot;default&quot;&gt;SELECT * FROM `user` WHERE DATE(create_time) = &#x27;2020-09-03&#x27;;&lt;/pre&gt;
&lt;p&gt;如果你的索引字段使用了函数，对不起，他是真的不走索引的。&lt;/p&gt; 
&lt;h5&gt;4、运算符导致的索引失效&lt;/h5&gt; 
&lt;pre class=&quot;prettyprint&quot; from-niu=&quot;default&quot;&gt;SELECT * FROM `user` WHERE age - 1 = 20;&lt;/pre&gt;
&lt;p&gt;如果你对列进行了（+，-，*，/，!）, 那么都将不会走索引。&lt;/p&gt; 
&lt;h5&gt;5、OR引起的索引失效&lt;/h5&gt; 
&lt;pre class=&quot;prettyprint&quot; from-niu=&quot;default&quot;&gt;SELECT * FROM `user` WHERE `name` = &#x27;张三&#x27; OR height = &#x27;175&#x27;;&lt;/pre&gt;
&lt;p&gt;OR导致索引是在特定情况下的，并不是所有的OR都是使索引失效，如果OR连接的是同一个字段，那么索引不会失效，反之索引失效。&lt;/p&gt; 
&lt;h5&gt;6、模糊搜索导致的索引失效&lt;/h5&gt; 
&lt;pre class=&quot;prettyprint&quot; from-niu=&quot;default&quot;&gt;SELECT * FROM `user` WHERE `name` LIKE &#x27;%冰&#x27;;&lt;/pre&gt;
&lt;p&gt;当&lt;code&gt;%&lt;/code&gt;放在匹配字段前是不走索引的，放在后面才会走索引。&lt;/p&gt; 
&lt;h5&gt;7、NOT IN、NOT EXISTS导致索引失效&lt;/h5&gt; 
&lt;h2 id=&quot;end&quot;&gt;End&lt;/h2&gt; 
&lt;p&gt;整理不易，点个赞呗！&lt;/p&gt; 
&lt;h2&gt;巨人的肩膀&lt;/h2&gt; 
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ThinkWon/article/details/104778621&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://blog.csdn.net/ThinkWon/article/details/104778621&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.javazhiyin.com/40232.html&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://www.javazhiyin.com/40232.html&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844904039860142088&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://juejin.cn/post/6844904039860142088&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ThinkWon/article/details/104778621&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://blog.csdn.net/ThinkWon/article/details/104778621&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000008131735&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://segmentfault.com/a/1190000008131735&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c972bb51558761f732292c0d3715a45a</guid>
<title>[推荐] 进程和线程这 19 个问题太强了</title>
<link>https://toutiao.io/k/93vqd5f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由于各个进程不共享相同的地址空间，任何一个进程的全局变量在另一个进程中都不可见，所以如果想要在进程之间传递数据就需要通过内核，在内核中开辟出一块区域，该区域对多个进程都可见，即可用于进程间通信。有读者可能有疑问了，文件方式也是进程间通信啊，也要在内核开辟区域吗？这里说的内核区域其实是一段缓冲区，文件方式传输数据也有内核缓冲区的参与（零拷贝除外）。&lt;/p&gt;&lt;section&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;524&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;367&quot; data-ratio=&quot;0.672093023255814&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9lFFFiaKpEr8Pnej5HSUaPCia1zguc4KbhpwgTSdVNZzic70zs5zOicoscMB7QxxSOlAtZriaNDWjOxSiafxSS2gJ9kw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;430&quot;/&gt;&lt;/section&gt;&lt;p&gt;如何开辟这种公共区域来进行进程间通信呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;匿名管道&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;匿名管道就是&lt;strong&gt;&lt;span&gt;pipe&lt;/span&gt;&lt;/strong&gt;，pipe只能在父子进程间通信，而且数据只能&lt;span&gt;&lt;strong&gt;&lt;span&gt;单向流动&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;（半双工通信）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用方式&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1）父进程创建管道，会得到两个文件描述符，分别指向管道的两端；&lt;/p&gt;&lt;section&gt;2）父进程创建子进程，从而子进程也有两个文件描述符指向同一管道；&lt;/section&gt;&lt;p&gt;3）父进程可写数据到管道，子进程就可从管道中读出数据，从而实现进程间通信，下面的示例代码中通过pipe实现了每秒钟父进程向子进程都发送消息的功能。&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; _pipe[&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; ret = pipe(_pipe);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (ret &amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        perror(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;pipe\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;pid_t&lt;/span&gt; id = fork();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (id &amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        perror(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;fork\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (id == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        close(_pipe[&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;]);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt; _mesg[&lt;span class=&quot;code-snippet__number&quot;&gt;100&lt;/span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (j &amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;100&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;memset&lt;/span&gt;(_mesg, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;\0&#x27;&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;sizeof&lt;/span&gt;(_mesg));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            read(_pipe[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;], _mesg, &lt;span class=&quot;code-snippet__keyword&quot;&gt;sizeof&lt;/span&gt;(_mesg));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;%s\n&quot;&lt;/span&gt;, _mesg);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            j++;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        close(_pipe[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;]);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt; *mesg = &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (i &amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;100&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mesg = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;父进程来写消息了&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            write(_pipe[&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;], mesg, &lt;span class=&quot;code-snippet__built_in&quot;&gt;strlen&lt;/span&gt;(mesg) + &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            ++i;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-theme=&quot;default&quot; data-language=&quot;javascript&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;我们平时也经常使用关于管道的命令行：&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ls | less&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;该命令行的流向图如下：&lt;br/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;524&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;266&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9lFFFiaKpEr8Pnej5HSUaPCia1zguc4KbhYxKQXoK9p50n8B2haIEPrLxTfvHVbc4MBApdfddOHF6HKCicxPq5QLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.3908701854493581&quot; data-w=&quot;701&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;1：创建管道&lt;/p&gt;&lt;p&gt;2：为ls创建一个进程，设置stdout为管理写端&lt;/p&gt;&lt;p&gt;3：为less创建一个进程，设置stdin为管道读端&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;高级管道&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过&lt;span&gt;&lt;strong&gt;&lt;span&gt;popen&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;将另一个程序当作一个新的进程在当前进程中启动，它算作当前进程的子进程，高级管道只能用在有亲缘关系的进程间通信，这种亲缘关系通常指父子进程，下面的GetCmdResult函数可以获取某个Linux命令执行的结果，实现方式就是通过popen。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;GetCmdResult&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt; &amp;amp;cmd, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; max_size = &lt;span class=&quot;code-snippet__number&quot;&gt;10240&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt; *data = (&lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt; *)&lt;span class=&quot;code-snippet__built_in&quot;&gt;malloc&lt;/span&gt;(max_size);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (data == &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;malloc fail&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;memset&lt;/span&gt;(data, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, max_size);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; max_buffer = &lt;span class=&quot;code-snippet__number&quot;&gt;256&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt; buffer[max_buffer];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    FILE *fdp = popen((cmd + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot; 2&amp;gt;&amp;amp;1&quot;&lt;/span&gt;).c_str(), &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;r&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; data_len = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (fdp) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (!feof(fdp)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (fgets(buffer, max_buffer, fdp)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; len = &lt;span class=&quot;code-snippet__built_in&quot;&gt;strlen&lt;/span&gt;(buffer);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (data_len + len &amp;gt; max_size) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;data size larger than &quot;&lt;/span&gt; &amp;lt;&amp;lt; max_size;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__built_in&quot;&gt;memcpy&lt;/span&gt;(data + data_len, buffer, len);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                data_len += len;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        pclose(fdp);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(data, data_len)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;free&lt;/span&gt;(data);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; ret;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-theme=&quot;default&quot; data-language=&quot;javascript&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;命名管道&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;匿名管道有个缺点就是通信的进程一定要有亲缘关系，而命名管道就不需要这种限制。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;命名管道其实就是一种特殊类型的文件，所谓的命名其实就是文件名，文件对各个进程都可见，通过命名管道创建好特殊文件后，就可以实现进程间通信。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;可以通过mkfifo创建一个特殊的类型的文件，参数读者看名字应该就了解，一个是文件名，一个是文件的读写权限：&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;mkfifo&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt;* filename, &lt;span class=&quot;code-snippet__keyword&quot;&gt;mode_t&lt;/span&gt; mode)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-theme=&quot;default&quot; data-language=&quot;javascript&quot;&gt;当返回值为0时，表示该命名管道创建成功，至于如何通信，其实就是个读写文件的问题！&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;消息队列&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;队列想必大家都知道，像FIFO一样，这里可以有多个进程写入数据，也可以有多个进程从队列里读出数据，但消息队列有一点比FIFO还更高级，它读消息不一定要使用先进先出的顺序，每个消息可以赋予类型，可以按消息的类型读取，不是指定类型的数据还存在队列中。本质上MessageQueue是存放在内核中的消息链表，每个消息队列链表会由消息队列标识符表示，这个消息队列存于内核中，只有主动的删除该消息队列或者内核重启时，消息队列才会被删除。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;在Linux中消息队列相关的函数调用如下：&lt;br/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;msgget&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;key_t&lt;/span&gt;, key, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; msgflg)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;msgsend&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; msgid, &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; *msg_ptr, &lt;span class=&quot;code-snippet__keyword&quot;&gt;size_t&lt;/span&gt; msg_sz, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; msgflg)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; message_type;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;msgrcv&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; msgid, &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; *msg_ptr, &lt;span class=&quot;code-snippet__keyword&quot;&gt;size_t&lt;/span&gt; msg_st, &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; msgtype, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; msgflg)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;msgctl&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; msgid, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; command, struct msgid_ds *buf)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-theme=&quot;default&quot; data-language=&quot;javascript&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;示例代码如下：&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;sys/msg.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;chrono&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;thread&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;define&lt;/span&gt; BUFFER_SIZ 20&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; msg_type;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt; text[BUFFER_SIZ];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} MsgWrapper;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Receive&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    MsgWrapper data;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; msgtype = &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; msgid = msgget((&lt;span class=&quot;code-snippet__keyword&quot;&gt;key_t&lt;/span&gt;)&lt;span class=&quot;code-snippet__number&quot;&gt;1024&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0666&lt;/span&gt; | IPC_CREAT);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (msgid == &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;msgget error \n&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (msgrcv(msgid, (&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; *)&amp;amp;data, BUFFER_SIZ, msgtype, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) == &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;error &quot;&lt;/span&gt; &amp;lt;&amp;lt; errno &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;read data &quot;&lt;/span&gt; &amp;lt;&amp;lt; data.text &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__built_in&quot;&gt;strlen&lt;/span&gt;(data.text) &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;6&lt;/span&gt;) {  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (msgctl(msgid, IPC_RMID, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) == &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;msgctl error \n&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Receive ok \n&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Send&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    MsgWrapper data;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; msgtype = &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; msgid = msgget((&lt;span class=&quot;code-snippet__keyword&quot;&gt;key_t&lt;/span&gt;)&lt;span class=&quot;code-snippet__number&quot;&gt;1024&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0666&lt;/span&gt; | IPC_CREAT);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (msgid == &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;msgget error \n&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    data.msg_type = msgtype;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;; ++i) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;memset&lt;/span&gt;(data.text, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, BUFFER_SIZ);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt; a = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;a&#x27;&lt;/span&gt; + i;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;memset&lt;/span&gt;(data.text, a, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (msgsnd(msgid, (&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; *)&amp;amp;data, BUFFER_SIZ, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) == &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;msgsnd error \n&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::this_thread::sleep_for(&lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::chrono::seconds(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;memcpy&lt;/span&gt;(data.text, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;1234567&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;7&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (msgsnd(msgid, (&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; *)&amp;amp;data, BUFFER_SIZ, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) == &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;msgsnd error \n&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__function&quot;&gt;thread &lt;span class=&quot;code-snippet__title&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Receive)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    r.detach();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__function&quot;&gt;thread &lt;span class=&quot;code-snippet__title&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Send)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    s.detach();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::this_thread::sleep_for(&lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::chrono::seconds(&lt;span class=&quot;code-snippet__number&quot;&gt;20&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;输出：root@iZuf64idor3ej648ciairaZ:~# ./a.out&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;read data a&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;read data b&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;read data c&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;read data d&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;read data e&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;read data f&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;read data g&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;read data h&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;read data i&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;read data j&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;read data &lt;span class=&quot;code-snippet__number&quot;&gt;1234567&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Receive ok&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;br/&gt;&lt;p&gt;代码中为了演示方便使用消息队列进行的线程间通信，该代码同样用于进程间通信，消息队列的实现依赖于内核的支持，上述代码可能在某些系统（WSL）上不能运行，在正常的Ubuntu上可以正常运行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;消息队列VS命名管道&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;消息队列&amp;gt;命名管道&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1）消息队列收发消息自动保证了同步，不需要由进程自己来提供同步方法，而命名管道需要自行处理同步问题；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;2）消息队列接收数据可以根据消息类型有选择的接收特定类型的数据，不需要像命名管道一样默认接收数据。&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;消息队列&amp;lt;命名管道&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;消息队列有一个缺点就是发送和接收的每个数据都有最大长度的限制。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;共享内存&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;可开辟中一块内存，用于各个进程间共享，使得各个进程可以直接读写同一块内存空间，就像线程共享同一块地址空间一样，该方式基本上是最快的进程间通信方式，因为没有系统调用干预，也没有数据的拷贝操作，但由于共享同一块地址空间，数据竞争的问题就会出现，需要自己引入同步机制解决数据竞争问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;共享内存只是一种方式，它的实现方式有很多种，主要的有mmap系统调用、Posix共享内存以及System V共享内存等。通过这三种“工具”共享地址空间后，通信的目的自然就会达到。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;信号&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;信号也是进程间通信的一种方式，信号可以在任何时候发送给某一个进程，如果进程当前并未处于执行状态，内核将信号保存，直到进程恢复到执行态再发送给进程，进程可以对信号设置预处理方式，如果对信号设置了阻塞处理，则信号的传递会被延迟直到阻塞被取消，如果进程结束，那信号就被丢弃。我们常用的CTRL+C和kill等就是信号的一种，也达到了进程间通信的目的，进程也可以对信号设置signal捕获函数自定义处理逻辑。这种方式有很大的&lt;span&gt;缺点&lt;/span&gt;：只有通知的作用，通知了一下消息的类型，但不能传输要交换的任何数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Linux系统中常见的信号有：&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86261&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86261&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;SIGHUP：该信号在用户终端结束时发出，通常在中断的控制进程结束时，所有进程组都将收到该信号，该信号的默认操作是终止进程；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;SIGINT：程序终止信号，通常的CTRL+C产生该信号来通知终止进程；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;SIGQUIT：类似于程序错误信号，通常的CTRL+\产生该信号通知进程退出时产生core文件；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86261&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86261&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;SIGILL：执行了非法指令，通常数据段或者堆栈溢出可能产生该信号；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;SIGTRAP：供调试器使用，由断电指令或其它陷阱指令产生；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;SIGABRT：使程序非正常结束，调用abort函数会产生该信号；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86261&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86261&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;SIGBUS：非法地址，通常是地址对齐问题导致，比如访问一个4字节长的整数，但其地址不是4的倍数；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;SIGSEGV：合理地址的非法访问，访问了未分配的内存或者没有权限的内存区域；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;SIGPIPE：管道破裂信号，socket通信时经常会遇到，进程写入了一个无读者的管道；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86261&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86261&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;SIGALRM：时钟定时信号，由alarm函数设置的时间终止时产生；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86261&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86261&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;SIGFPE：出现浮点错误（比如除0操作）；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86261&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86261&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;SIGKILL：杀死进程（不能被捕捉和忽略）；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;信号量&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;想必大家都听过信号量，信号量就是一个特殊的变量，程序对其访问都是原子操作，每个信号量开始都有个初始值。最简单最常见的信号量是只能取0和1的变量，也叫二值信号量。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;信号量有两个操作，P和V：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;P：如果信号量变量值大于0，则变量值减1，如果值为0，则阻塞进程；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;V：如果有进程阻塞在该信号量上，则唤醒阻塞的进程，如果没有进程阻塞，则变量值加1&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;93831&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-bcless=&quot;spin&quot; data-bclessp=&quot;120&quot; data-bdopacity=&quot;1%&quot;&gt;&lt;section data-bcless=&quot;spin&quot; data-bclessp=&quot;120&quot; data-bdopacity=&quot;1%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-bcless=&quot;spin&quot; data-bclessp=&quot;120&quot; data-bdopacity=&quot;1%&quot;&gt;&lt;section&gt;Q&lt;/section&gt;&lt;/section&gt;&lt;section data-bcless=&quot;spin&quot; data-bclessp=&quot;120&quot; data-bdopacity=&quot;1%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;信号量和信号有什么关系&lt;/span&gt;？&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-bcless=&quot;spin&quot; data-bclessp=&quot;120&quot; data-bdopacity=&quot;1%&quot;&gt;&lt;section&gt;A&lt;/section&gt;&lt;/section&gt;&lt;section data-bcless=&quot;spin&quot; data-bclessp=&quot;120&quot; data-bdopacity=&quot;1%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;没有任何关系，完全是不同的东西。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;93831&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-bcless=&quot;spin&quot; data-bclessp=&quot;120&quot; data-bdopacity=&quot;1%&quot;&gt;&lt;section data-bcless=&quot;spin&quot; data-bclessp=&quot;120&quot; data-bdopacity=&quot;1%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-bcless=&quot;spin&quot; data-bclessp=&quot;120&quot; data-bdopacity=&quot;1%&quot;&gt;&lt;section&gt;Q&lt;/section&gt;&lt;/section&gt;&lt;section data-bcless=&quot;spin&quot; data-bclessp=&quot;120&quot; data-bdopacity=&quot;1%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;信号量与互斥量有什么区别？&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-bcless=&quot;spin&quot; data-bclessp=&quot;120&quot; data-bdopacity=&quot;1%&quot;&gt;&lt;section&gt;A&lt;/section&gt;&lt;/section&gt;&lt;section data-bcless=&quot;spin&quot; data-bclessp=&quot;120&quot; data-bdopacity=&quot;1%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;互斥量用于&lt;/span&gt;&lt;strong&gt;&lt;span&gt;互斥&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，信号量用于&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同步&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，互斥指的是某一资源同一时间只允许一个访问者访问，但无法限制访问顺序，访问是无序的，而同步在互斥的基础上可以控制访问者对资源的顺序。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;套接字&lt;/span&gt;&lt;/strong&gt;：就是网络传输，不用多说，网络通信都可以多机通信呢，更不用说进程间通信啦，你能看到程序喵的文章也是套接字的功劳。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;文件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;：显而易见，多个进程可以操作同一个文件，所以也可以通过文件来进行进程间通信。&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f47a160e354d1f67c2d3624da57ac34e</guid>
<title>[推荐] Redis 最佳实践：7 个维度 + 43 条使用规范，带你彻底玩转 Redis（附实践清单）</title>
<link>https://toutiao.io/k/kkvemjf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;span&gt;这篇文&lt;/span&gt;&lt;span&gt;章我想和你聊一聊 Redis 的最佳实践。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你的项目或许已经使用 Redis 很长时间了，但在使用过程中，你可能还会或多或少地遇到以下问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;我的 Redis 内存为什么增长这么快？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么我的 Redis 操作延迟变大了？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何降低 Redis 故障发生的频率？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;日常运维 Redis 需要注意什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;部署 Redis 时，如何做好资源规划？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis 监控重点要关注哪些指标？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尤其是当你的项目越来越依赖 Redis 时，这些问题就变得尤为重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，你迫切需要一份&lt;strong&gt;「最佳实践指南」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章，我将从以下七个维度，带你「全面」分析 Redis 的最佳实践优化：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在文章的最后，我还会给你一个完整的最佳实践清单，不管你是业务开发人员，还是 DBA 运维人员，这个清单将会帮助你更加「优雅」地用好 Redis。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;这篇文章干货很多，希望你可以耐心读完。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5761589403973509&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyx7AWsPEBcwibhCgk78ibcYPOJrBMEjvclD1wYHibyjNg0OsKnKFapTBbyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;453&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如何使用 Redis 更节省内存？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们来看一下 Redis 内存方面的优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，Redis 的性能之所以如此之高，原因就在于它的数据都存储在「内存」中，所以访问 Redis 中的数据速度极快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但从资源利用率层面来说，机器的内存资源相比于磁盘，还是比较昂贵的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你的业务应用在 Redis 中存储数据很少时，你可能并不太关心内存资源的使用情况。但随着业务的发展，你的业务存储在 Redis 中的数据就会越来越多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有提前制定好内存优化策略，那么等业务开始增长时，Redis 占用的内存也会开始膨胀。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，提前制定合理的内存优化策略，对于资源利用率的提升是很有必要的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那在使用 Redis 时，怎样做才能更节省内存呢？这里我给你总结了 6 点建议，我们依次来看：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1) 控制 key 的长度&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最简单直接的内存优化，就是控制 key 的长度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开发业务时，你需要提前预估整个 Redis 中写入 key 的数量，如果 key 数量达到了百万级别，那么，过长的 key 名也会占用过多的内存空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，你需要保证 key 在简单、清晰的前提下，尽可能把 key 定义得短一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，原有的 key 为 user:book:123，则可以优化为 u:bk:123。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一来，你的 Redis 就可以节省大量的内存，这个方案对内存的优化非常直接和高效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2) 避免存储 bigkey&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了控制 key 的长度之外，你同样需要关注 value 的大小，如果大量存储 bigkey，也会导致 Redis 内存增长过快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，客户端在读写 bigkey 时，还有产生性能问题（下文会具体详述）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，你要避免在 Redis 中存储 bigkey，我给你的建议是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;String：大小控制在 10KB 以下&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;List/Hash/Set/ZSet：元素数量控制在 1 万以下&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;3) 选择合适的数据类型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 提供了丰富的数据类型，这些数据类型在实现上，也对内存使用做了优化。具体来说就是，一种数据类型对应多种数据结构来实现：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7314974182444062&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyxDPJAlJj31DWQxBtUc4qCyqPt5SEWNpY1JpDyibcJxo1rhVBmqMjIw9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;581&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，String、Set 在存储 int 数据时，会采用整数编码存储。Hash、ZSet 在元素数量比较少时（可配置），会采用压缩列表（ziplist）存储，在存储比较多的数据时，才会转换为哈希表和跳表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者这么设计的原因，就是为了进一步节约内存资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么你在存储数据时，就可以利用这些特性来优化 Redis 的内存。这里我给你的建议如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;String、Set：尽可能存储 int 类型数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Hash、ZSet：存储的元素数量控制在转换阈值之下，以压缩列表存储，节约内存&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;4) 把 Redis 当作缓存使用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 数据存储在内存中，这也意味着其资源是有限的。你在使用 Redis 时，要把它当做缓存来使用，而不是数据库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，你的应用写入到  Redis 中的数据，尽可能地都设置「过期时间」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务应用在 Redis 中查不到数据时，再从后端数据库中加载到 Redis 中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5591647331786543&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyx4t8UZ34WMpePuN9IFbicJlvRyuZFrXTAZSemoQV44KSmZLvt8AYqE7A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;431&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采用这种方案，可以让 Redis 中只保留经常访问的「热数据」，内存利用率也会比较高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;5) 实例设置 maxmemory + 淘汰策略&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然你的 Redis key 都设置了过期时间，但如果你的业务应用写入量很大，并且过期时间设置得比较久，那么短期间内 Redis 的内存依旧会快速增长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不控制 Redis 的内存上限，也会导致使用过多的内存资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于这种场景，你需要提前预估业务数据量，然后给这个实例设置 maxmemory 控制实例的内存上限，这样可以避免 Redis 的内存持续膨胀。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置了 maxmemory，此时你还要设置数据淘汰策略，而淘汰策略如何选择，你需要结合你的业务特点来决定：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;volatile-lru / allkeys-lru：优先保留最近访问过的数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;volatile-lfu / allkeys-lfu：优先保留访问次数最频繁的数据（4.0+版本支持）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;volatile-ttl ：优先淘汰即将过期的数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;volatile-random / allkeys-random：随机淘汰数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;6) 数据压缩后写入 Redis&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上方案基本涵盖了 Redis 内存优化的各个方面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你还想进一步优化 Redis 内存，你还可以在业务应用中先将数据压缩，再写入到 Redis 中（例如采用 snappy、gzip 等压缩算法）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，压缩存储的数据，客户端在读取时还需要解压缩，在这期间会消耗更多 CPU 资源，你需要根据实际情况进行权衡。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是「节省内存资源」方面的实践优化，是不是都比较简单？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看「性能」方面的优化。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如何持续发挥 Redis 的高性能？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你的系统决定引入 Redis 时，想必看中它最关键的一点就是：&lt;strong&gt;性能&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，一个单机版 Redis 就可以达到 10W QPS，这么高的性能，也意味着如果在使用过程中发生延迟情况，就会与我们的预期不符。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，在使用 Redis 时，如何持续发挥它的高性能，避免操作延迟的情况发生，也是我们的关注焦点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这方面，我给你总结了 13 条建议：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1) 避免存储 bigkey&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;存储 bigkey 除了前面讲到的使用过多内存之外，对 Redis 性能也会有很大影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 Redis 处理请求是单线程的，当你的应用在写入一个 bigkey 时，更多时间将消耗在「内存分配」上，这时操作延迟就会增加。同样地，删除一个 bigkey 在「释放内存」时，也会发生耗时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且，当你在读取这个 bigkey 时，也会在「网络数据传输」上花费更多时间，此时后面待执行的请求就会发生排队，Redis 性能下降。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3168469860896445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyx7J5WTib2UYFNWSPaP7UMOulkISC5KQ0syDoibcouL0iaiay0vzLPbNQSJg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;647&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，你的业务应用尽量不要存储 bigkey，避免操作延迟发生。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果你确实有存储 bigkey 的需求，你可以把 bigkey 拆分为多个小 key 存储。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2) 开启 lazy-free 机制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你无法避免存储 bigkey，那么我建议你开启 Redis 的 lazy-free 机制。（4.0+版本支持）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当开启这个机制后，Redis 在删除一个 bigkey 时，释放内存的耗时操作，将会放到后台线程中去执行，这样可以在最大程度上，避免对主线程的影响。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4406196213425129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyxhrumCSKsfLUgVaAWxicFawP6ZbMrCyGSAL6Tas29Wue76gNLSHEIesA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;581&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;3) 不使用复杂度过高的命令&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 是单线程模型处理请求，除了操作 bigkey 会导致后面请求发生排队之外，在执行复杂度过高的命令时，也会发生这种情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为执行复杂度过高的命令，会消耗更多的 CPU 资源，主线程中的其它请求只能等待，这时也会发生排队延迟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，你需要避免执行例如 SORT、SINTER、SINTERSTORE、ZUNIONSTORE、ZINTERSTORE 等聚合类命令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于这种聚合类操作，我建议你把它放到客户端来执行，不要让 Redis 承担太多的计算工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;4) 执行 O(N) 命令时，关注 N 的大小&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;规避使用复杂度过高的命令，就可以高枕无忧了么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是否定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你在执行 O(N) 命令时，同样需要注意 N 的大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一次性查询过多的数据，也会在网络传输过程中耗时过长，操作延迟变大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，对于容器类型（List/Hash/Set/ZSet），在元素数量未知的情况下，一定不要无脑执行 LRANGE key 0 -1 / HGETALL / SMEMBERS / ZRANGE key 0 -1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在查询数据时，你要遵循以下原则：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;先查询数据元素的数量（LLEN/HLEN/SCARD/ZCARD）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;元素数量较少，可一次性查询全量数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;元素数量非常多，分批查询数据（LRANGE/HASCAN/SSCAN/ZSCAN）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;5) 关注 DEL 时间复杂度&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你没看错，在删除一个 key 时，如果姿势不对，也有可能影响到 Redis 性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;删除一个 key，我们通常使用的是 DEL 命令，回想一下，你觉得 DEL 的时间复杂度是多少？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;O(1) ？其实不一定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你删除的是一个 String 类型 key 时，时间复杂度确实是 O(1)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但当你要删除的 key 是 List/Hash/Set/ZSet 类型，它的复杂度其实为 O(N)，N 代表元素个数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;也就是说，删除一个 key，其元素数量越多，执行 DEL 也就越慢！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因在于，删除大量元素时，需要依次回收每个元素的内存，元素越多，花费的时间也就越久！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且，这个过程默认是在主线程中执行的，这势必会阻塞主线程，产生性能问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那删除这种元素比较多的 key，如何处理呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我给你的建议是，分批删除：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;List类型：执行多次 LPOP/RPOP，直到所有元素都删除完成&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Hash/Set/ZSet类型：先执行 HSCAN/SSCAN/SCAN 查询元素，再执行 HDEL/SREM/ZREM 依次删除每个元素&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没想到吧？一个小小的删除操作，稍微不小心，也有可能引发性能问题，你在操作时需要格外注意。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;6) 批量命令代替单个命令&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你需要一次性操作多个 key 时，你应该使用批量命令来处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;批量操作相比于多次单个操作的优势在于，可以显著减少客户端、服务端的来回网络 IO 次数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我给你的建议是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;String / Hash 使用 MGET/MSET 替代 GET/SET，HMGET/HMSET 替代 HGET/HSET&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其它数据类型使用 Pipeline，打包一次性发送多个命令到服务端执行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8656429942418427&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyxjWasaOIYSbt5M6jhuURC6qRiabvsCQa5UwNZL8uk06ulNicxrXVkCNNA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;521&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;7) 避免集中过期 key&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 清理过期 key 是采用定时 + 懒惰的方式来做的，而且这个过程都是在主线程中执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的业务存在大量 key 集中过期的情况，那么 Redis 在清理过期 key 时，也会有阻塞主线程的风险。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.22901849217638692&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyxZicHACvFNPU8gXS3VK2mDhfVJVnuTD5FSo5fTQdOABSrpYVrndge37A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;703&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想要避免这种情况发生，你可以在设置过期时间时，增加一个随机时间，把这些 key 的过期时间打散，从而降低集中过期对主线程的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;8) 使用长连接操作 Redis，合理配置连接池&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你的业务应该使用长连接操作 Redis，避免短连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当使用短连接操作 Redis 时，每次都需要经过 TCP 三次握手、四次挥手，这个过程也会增加操作耗时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时，你的客户端应该使用连接池的方式访问 Redis，并设置合理的参数，长时间不操作 Redis 时，需及时释放连接资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;9) 只使用 db0&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管 Redis 提供了 16 个 db，但我只建议你使用 db0。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么呢？我总结了以下 3 点原因：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在一个连接上操作多个 db 数据时，每次都需要先执行 SELECT，这会给 Redis 带来额外的压力&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用多个 db 的目的是，按不同业务线存储数据，那为何不拆分多个实例存储呢？拆分多个实例部署，多个业务线不会互相影响，还能提高 Redis 的访问性能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis Cluster 只支持 db0，如果后期你想要迁移到 Redis Cluster，迁移成本高&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;10) 使用读写分离 + 分片集群&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的业务读请求量很大，那么可以采用部署多个从库的方式，实现读写分离，让 Redis 的从库分担读压力，进而提升性能。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6519721577726219&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyxjLxTKDdPHc6GLHiaKF4iaialXGwoicYRCjUSLibnqR4GTaGO3yTMMotawng/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;431&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的业务写请求量很大，单个 Redis 实例已无法支撑这么大的写流量，那么此时你需要使用分片集群，分担写压力。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.501466275659824&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyxw0H7LsTOpeAUpREmuyZQBAelbaMGY6oOHzvyf1jKMTyxiagkYYZqCkw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;682&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;11) 不开启 AOF 或 AOF 配置为每秒刷盘&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果对于丢失数据不敏感的业务，我建议你不开启 AOF，避免 AOF 写磁盘拖慢 Redis 的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果确实需要开启 AOF，那么我建议你配置为 appendfsync everysec，把数据持久化的刷盘操作，放到后台线程中去执行，尽量降低 Redis 写磁盘对性能的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;12) 使用物理机部署 Redis&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 在做数据持久化时，采用创建子进程的方式进行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而创建子进程会调用操作系统的 fork 系统调用，这个系统调用的执行耗时，与系统环境有关。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虚拟机环境执行 fork 的耗时，要比物理机慢得多，所以你的 Redis 应该尽可能部署在物理机上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;13) 关闭操作系统内存大页机制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 操作系统提供了内存大页机制，其特点在于，每次应用程序向操作系统申请内存时，申请单位由之前的 4KB 变为了 2MB。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这会导致什么问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 Redis 在做数据持久化时，会先 fork 一个子进程，此时主进程和子进程共享相同的内存地址空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当主进程需要修改现有数据时，会采用写时复制（Copy On Write）的方式进行操作，在这个过程中，需要重新申请内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果申请内存单位变为了 2MB，那么势必会增加内存申请的耗时，如果此时主进程有大量写操作，需要修改原有的数据，那么在此期间，操作延迟就会变大。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9879663056558363&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyxNz0n0fpaMdYViaibYjWb0Kjx1PZ7Cdu651ib4LSHm1TAJGX5UEQLEOMfA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;831&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，为了避免出现这种问题，你需要在操作系统上关闭内存大页机制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，以上这些就是 Redis 「高性能」方面的实践优化。如果你非常关心 Redis 的性能问题，可以结合这些方面针对性优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看 Redis 「可靠性」如何保证。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如何保证 Redis 的可靠性？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我想提醒你的是，保证 Redis 可靠性其实并不难，但难的是如何做到「持续稳定」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我会从「资源隔离」、「多副本」、「故障恢复」这三大维度，带你分析保障 Redis 可靠性的最佳实践。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;1) 按业务线部署实例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提升可靠性的第一步，就是「资源隔离」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你最好按不同的业务线来部署 Redis 实例，这样当其中一个实例发生故障时，不会影响到其它业务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种资源隔离的方案，实施成本是最低的，但成效却是非常大的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;2) 部署主从集群&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你只使用单机版 Redis，那么就会存在机器宕机服务不可用的风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，你需要部署「多副本」实例，即主从集群，这样当主库宕机后，依旧有从库可以使用，避免了数据丢失的风险，也降低了服务不可用的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在部署主从集群时，你还需要注意，主从库需要分布在不同机器上，避免交叉部署。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么做的原因在于，通常情况下，Redis 的主库会承担所有的读写流量，所以我们一定要优先保证主库的稳定性，即使从库机器异常，也不要对主库造成影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且，有时我们需要对 Redis 做日常维护，例如数据定时备份等操作，这时你就可以只在从库上进行，这只会消耗从库机器的资源，也避免了对主库的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;3) 合理配置主从复制参数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在部署主从集群时，如果参数配置不合理，也有可能导致主从复制发生问题：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这方面我给你的建议有以下 2 点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;设置合理的 repl-backlog 参数：过小的 repl-backlog 在写流量比较大的场景下，主从复制中断会引发全量复制数据的风险&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置合理的 slave client-output-buffer-limit：当从库复制发生问题时，过小的 buffer 会导致从库缓冲区溢出，从而导致复制中断&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;4) 部署哨兵集群，实现故障自动切换&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只部署了主从节点，但故障发生时是无法自动切换的，所以，你还需要部署哨兵集群，实现故障的「自动切换」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且，多个哨兵节点需要分布在不同机器上，实例为奇数个，防止哨兵选举失败，影响切换时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上这些就是保障 Redis「高可靠」实践优化，你应该也发现了，这些都是部署和运维层的优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，你可能还会对 Redis 做一些「日常运维」工作，这时你要注意哪些问题呢？&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;日常运维 Redis 需要注意什么？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果你是 DBA 运维人员，在平时运维 Redis 时，也需要注意以下 6 个方面。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;1) 禁止使用 KEYS/FLUSHALL/FLUSHDB 命令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行这些命令，会长时间阻塞 Redis 主线程，危害极大，所以你必须禁止使用它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果确实想使用这些命令，我给你的建议是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;SCAN 替换 KEYS&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;4.0+版本可使用 FLUSHALL/FLUSHDB ASYNC，清空数据的操作放在后台线程执行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;2) 扫描线上实例时，设置休眠时间&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管你是使用 SCAN 扫描线上实例，还是对实例做 bigkey 统计分析，我建议你在扫描时一定记得设置休眠时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;防止在扫描过程中，实例 OPS 过高对 Redis 产生性能抖动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;3) 慎用 MONITOR 命令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时在排查 Redis 问题时，你会使用 MONITOR 查看 Redis 正在执行的命令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果你的 Redis OPS 比较高，那么在执行 MONITOR 会导致 Redis 输出缓冲区的内存持续增长，这会严重消耗 Redis 的内存资源，甚至会导致实例内存超过 maxmemory，引发数据淘汰，这种情况你需要格外注意。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3315972222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyxmZvibuS8oeZibfl9TDvwmAx5mleOmpUtYcprib55awsF3Dh8vTBen7teg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;576&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以你在执行 MONITOR 命令时，一定要谨慎，尽量少用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;4) 从库必须设置为 slave-read-only&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你的从库必须设置为 slave-read-only 状态，避免从库写入数据，导致主从数据不一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，从库如果是非 read-only 状态，如果你使用的是 4.0 以下的 Redis，它存在这样的 Bug：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;从库写入了有过期时间的数据，不会做定时清理和释放内存。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这会造成从库的内存泄露！这个问题直到 4.0 版本才修复，你在配置从库时需要格外注意。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;5) 合理配置 timeout 和 tcp-keepalive 参数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果因为网络原因，导致你的大量客户端连接与 Redis 意外中断，恰好你的 Redis 配置的 maxclients 参数比较小，此时有可能导致客户端无法与服务端建立新的连接（服务端认为超过了 maxclients）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;造成这个问题原因在于，客户端与服务端每建立一个连接，Redis 都会给这个客户端分配了一个 client fd。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;当客户端与服务端网络发生问题时，服务端并不会立即释放这个 client fd。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么时候释放呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 内部有一个定时任务，会定时检测所有 client 的空闲时间是否超过配置的 timeout 值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 Redis 没有开启 tcp-keepalive 的话，服务端直到配置的 timeout 时间后，才会清理释放这个 client fd。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在没有清理之前，如果还有大量新连接进来，就有可能导致 Redis 服务端内部持有的 client fd 超过了 maxclients，这时新连接就会被拒绝。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对这种情况，我给你的优化建议是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不要配置过高的 timeout：让服务端尽快把无效的 client fd 清理掉&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis 开启 tcp-keepalive：这样服务端会定时给客户端发送 TCP 心跳包，检测连接连通性，当网络异常时，可以尽快清理僵尸 client fd&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;6) 调整 maxmemory 时，注意主从库的调整顺序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 5.0 以下版本存在这样一个问题：&lt;strong&gt;从库内存如果超过了 maxmemory，也会触发数据淘汰。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在某些场景下，从库是可能优先主库达到 maxmemory 的（例如在从库执行 MONITOR 命令，输出缓冲区占用大量内存），那么此时从库开始淘汰数据，主从库就会产生不一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要想避免此问题，在调整 maxmemory 时，一定要注意主从库的修改顺序：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;调大 maxmemory：先修改从库，再修改主库&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调小 maxmemory：先修改主库，再修改从库&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直到 Redis 5.0，Redis 才增加了一个配置 replica-ignore-maxmemory，默认从库超过 maxmemory 不会淘汰数据，才解决了此问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，以上这些就是「日常运维」Redis 需要注意的，你可以对各个配置项查漏补缺，看有哪些是需要优化的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们来看一下，保障 Redis「安全」都需要注意哪些问题。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 安全如何保证？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论如何，在互联网时代，安全问题一定是我们需要随时警戒的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可能听说过 Redis 被注入可执行脚本，然后拿到机器 root 权限的安全问题，都是因为在部署 Redis 时，没有把安全风险注意起来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对这方面，我给你的建议是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不要把 Redis 部署在公网可访问的服务器上&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;部署时不使用默认端口 6379&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;以普通用户启动 Redis 进程，禁止 root 用户启动&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;限制 Redis 配置文件的目录访问权限&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;推荐开启密码认证&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;禁用/重命名危险命令（KEYS/FLUSHALL/FLUSHDB/CONFIG/EVAL）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只要你把这些做到位，基本上就可以保证 Redis 的安全风险在可控范围内。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，我们分析了 Redis 在内存、性能、可靠性、日常运维方面的最佳实践优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了以上这些，你还需要做到提前「预防」。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如何预防 Redis 问题？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要想提前预防 Redis 问题，你需要做好以下两个方面：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;合理的资源规划&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;完善的监控预警&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来说资源规划。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在部署 Redis 时，如果你可以提前做好资源规划，可以避免很多因为资源不足产生的问题。这方面我给你的建议有以下 3 点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;保证机器有足够的 CPU、内存、带宽、磁盘资源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提前做好容量规划，主库机器预留一半内存资源，防止主从机器网络故障，引发大面积全量同步，导致主库机器内存不足的问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单个实例内存建议控制在 10G 以下，大实例在主从全量同步、RDB 备份时有阻塞风险&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来看监控如何做。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;监控预警是提高稳定性的重要环节，完善的监控预警，可以把问题提前暴露出来，这样我们才可以快速反应，把问题最小化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这方面我给你的建议是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;做好机器 CPU、内存、带宽、磁盘监控，资源不足时及时报警，任意资源不足都会影响 Redis 性能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置合理的 slowlog 阈值，并对其进行监控，slowlog 过多及时报警&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;监控组件采集 Redis INFO 信息时，采用长连接，避免频繁的短连接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;做好实例运行时监控，重点关注 expired_keys、evicted_keys、latest_fork_usec 指标，这些指标短时突增可能会有阻塞风险&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，总结一下，这篇文章我带你全面分析了 Redis 最佳实践的优化路径，其中包括内存资源、高性能、高可靠、日常运维、资源规划、监控、安全 7 个维度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我画成了思维导图，方便你在实践时做参考。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;491&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.8651419558359621&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyxoZ9Qog3MIZmVibbhozjUdiaAvXZzBQwecWskzfluZ0FWQoiaPDI69NGNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2536&quot;/&gt;&lt;span&gt;我还&lt;/span&gt;&lt;span&gt;把这些实践优化，按照「业务开发」和「运维」两个维度，进一步做了划分。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;并且以「强制」、「推荐」、「参考」3 个级别做了标注，这样你在实践优化时，就会更明确哪些该做，哪些需要结合实际的业务场景进一步分析。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这些级&lt;/span&gt;&lt;span&gt;别的实施规则如下：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;强制：需严格遵守，否则危害极大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;推荐：推荐遵守，可提升性能、降低内存、便于运维&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;参考：根据业务特点参考实施&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你是业务开发人员，你需要了解 Redis 的运行机制，例如各个命令的执行时间复杂度、数据过期策略、数据淘汰策略等，使用合理的命令，并结合业务场景进行优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;568&quot; data-backw=&quot;568&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyx4KzYB53twzEqX99WuDzqTEZcTB2ZPAib4iayicx6woZDKGYF6wtd4DHPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1490&quot;/&gt;&lt;span&gt;如果你是 DBA 运&lt;/span&gt;&lt;span&gt;维人员，你需要在资源规划、运维、监控、安全层面做到位，&lt;span&gt;做到未雨绸缪。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;img data-backh=&quot;656&quot; data-backw=&quot;568&quot; data-ratio=&quot;1.1548582995951417&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gB9Yvac5K3OSCEIQBtroLfFiaMMWzJpyxvHiaHzsZjBhn2KS2Eq2xSrfYZiaCiaGhicruGN6ENHrEpxcmcmlZalGia3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1976&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;后记&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你能耐心地读到这里，应该对如何「用好」Redis 有了新的认识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章我们主要讲的是 Redis 最佳实践，对于「最佳实践」这个话题，我想再和你多聊几句。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果你面对的不是 Redis，而是其它中间件，例如 MySQL、Kafka，你在使用这些组件时，会有什么优化思路吗？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你也可以沿用这篇文章的这几个维度来分析：&lt;/p&gt;&lt;section&gt;你可以思考一下，MySQL 和 Kafka 在这几个维度，需要注意哪些问题。&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，从学习技能的角度来讲，我们在软件开发过程中，要尽可能地去思考和探索「最佳实践」的方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;因为只有这样，我们才会不断督促自己去思考，对自己提出更高的要求，做到持续进步。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;往期推荐&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3ODkzMDA2Mw==&amp;amp;mid=2247483874&amp;amp;idx=1&amp;amp;sn=2fc108a4495ebea67e72ba01f2ea4fea&amp;amp;chksm=fd6c9502ca1b1c14985958ca223ef7d4031a7041464c8131a76499a541da1c92f397790d3902&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;彻底搞懂事件驱动模型 - Reactor&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3ODkzMDA2Mw==&amp;amp;mid=2247483865&amp;amp;idx=1&amp;amp;sn=7f758aa084e30195d32d51f67dacc5d8&amp;amp;chksm=fd6c9539ca1b1c2f322fd00bd683e0ecfdb084b082a632a1011c98790e3a04081298a6417f81&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;如何科学破解慢SQL?&lt;/a&gt;&lt;/p&gt;&lt;p&gt;最后，欢迎大家关注Kaito和铁柱，一起成长。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/bymGBmLC3zGuqeeB9CXfeY68KDuHKbP2e0tu0b3IdRH4xAT5FwcUNoVIIFibkQr1LSahlnw08SCLia9zN6QMVTyw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7cb134268a884dc91ab7b91dbac59260</guid>
<title>[推荐] [译] 七个改变我生活的 Git 小技巧</title>
<link>https://toutiao.io/k/kly6lxt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;Git 是当前最流行最普遍的版本控制系统之一，它被应用于私有系统和公开网站上各种各样的开发工作。不论我变得对 Git 有多熟悉，似乎总有些功能等待着被发掘。下面分享下和 Git 相关的改变我工作方式的一些小技巧。&lt;/p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/B2EfAOZfS1iaS9dgibME2dgeAKXscn7JcaJJbPMBUMmEc4WZHpTcL9yqYTus3C9jRvy6GibnETwghlrBazkGrTj0jYsRM9AHBWI/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;p&gt;1、Git 中的自动纠错&lt;/p&gt;&lt;p&gt;我们每个人都不时在输入时犯拼写错误，但是如果你使能了 Git 的自动纠错功能，你就能让 Git 自动纠正一些输入错误的子命令。&lt;/p&gt;&lt;p&gt;假如你想用命令 &lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxb09d89502b7e2152&quot; data-miniprogram-path=&quot;pages/command?command=git&quot; data-miniprogram-nickname=&quot;Linux&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;git status&lt;/a&gt; 来检查状态，但是你恰巧错误地输入了 &lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxb09d89502b7e2152&quot; data-miniprogram-path=&quot;pages/command?command=git&quot; data-miniprogram-nickname=&quot;Linux&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;git stats&lt;/a&gt;。通常情况下，Git 会告诉你 ‘stats’ 不是个有效的命令：&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; stats&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;‘&lt;/span&gt;&lt;span&gt;stats&lt;/span&gt;&lt;span&gt;’&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;not&lt;/span&gt;&lt;span&gt; a &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; command&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;See&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;‘&lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;help&lt;/span&gt;&lt;span&gt;’.&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;The&lt;/span&gt;&lt;span&gt; most similar command &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;status&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;为了避免类似情形，只需要在你的 Git 配置中使能自动纠错功能。&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; config &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; help&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;autocorrect &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;如果你只想对当前的仓库生效，就省略掉选项 &lt;code&gt;--global&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;这个命令会使能自动纠错功能。在相应的 &lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fgit-scm.com%2Fbook%2Fen%2Fv2%2FCustomizing-Git-Git-Configuration%23_code_help_autocorrect_code&amp;amp;title=Git%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;Git 官方文档&lt;/a&gt; 中可以看到这个命令的详细说明，但是试着敲一下上面的错误命令会使你对这个设置干了什么有个直观的了解：&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; stats&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;‘&lt;/span&gt;&lt;span&gt;stats&lt;/span&gt;&lt;span&gt;’&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;not&lt;/span&gt;&lt;span&gt; a &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; command&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;See&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;‘&lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;help&lt;/span&gt;&lt;span&gt;’.&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;On&lt;/span&gt;&lt;span&gt; branch master&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;Your&lt;/span&gt;&lt;span&gt; branch &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; up to &lt;/span&gt;&lt;span&gt;date&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;with&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;‘&lt;/span&gt;&lt;span&gt;origin&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;master&lt;/span&gt;&lt;span&gt;’.&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;nothing to commit&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; working tree clean&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;在上面的例子中，Git 直接运行了它建议命令的第一个，也就是 &lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxb09d89502b7e2152&quot; data-miniprogram-path=&quot;pages/command?command=git&quot; data-miniprogram-nickname=&quot;Linux&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;git status&lt;/a&gt;，而不是给你展示它所建议的子命令。&lt;/p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/B2EfAOZfS1iaS9dgibME2dgeAKXscn7JcaJJbPMBUMmEc4WZHpTcL9yqYTus3C9jRvy6GibnETwghlrBazkGrTj0jYsRM9AHBWI/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;p&gt;2、对提交进行计数&lt;/p&gt;&lt;p&gt;需要对提交进行计数的原因有很多。例如，一些开发人员利用提交计数来判断什么时候递增工程构建序号，也有一些开发人员用提交计数来对项目进展取得一个整体上的感观。&lt;/p&gt;&lt;p&gt;对提交进行计数相当简单而且直接，下面就是相应的 Git 命令：&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; rev&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;count branch&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;在上述命令中，参数 &lt;code&gt;branch-name&lt;/code&gt; 必须是一个你当前仓库里的有效分支名。&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; rev&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;–&lt;/span&gt;&lt;span&gt;count master&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;32&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; rev&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;–&lt;/span&gt;&lt;span&gt;count dev&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;34&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/B2EfAOZfS1iaS9dgibME2dgeAKXscn7JcaJJbPMBUMmEc4WZHpTcL9yqYTus3C9jRvy6GibnETwghlrBazkGrTj0jYsRM9AHBWI/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;p&gt;3、仓库优化&lt;/p&gt;&lt;p&gt;你的代码仓库不仅对你来说很宝贵，对你所在的组织也一样。通过少数几个惯例你就能使自己的仓库整洁并且保持最新。&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fopensource.com%2Farticle%2F20%2F8%2Fdont-ignore-gitignore&amp;amp;title=%E4%BD%BF%E7%94%A8%20.gitignore%20%E6%96%87%E4%BB%B6&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;使用 .gitignore 文件&lt;/a&gt; 就是这些最好的惯例之一。通过使用这个文件你可以告诉 Git 不要保存一些不需要记录的文件，如二进制文件、临时文件等等。&lt;/p&gt;&lt;p&gt;当然，你还可以使用 Git 的垃圾回收来进一步优化你的仓库。&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; gc &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;prune&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;now &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;aggressive&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;这个命令在你和你的团队经常使用 &lt;code&gt;pull&lt;/code&gt; 或者 &lt;code&gt;push&lt;/code&gt; 操作的时候很有帮助。&lt;/p&gt;&lt;p&gt;它是一个内部工具，能清理掉你的仓库里没法访问或者说“空悬”的 Git 对象。&lt;/p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/B2EfAOZfS1iaS9dgibME2dgeAKXscn7JcaJJbPMBUMmEc4WZHpTcL9yqYTus3C9jRvy6GibnETwghlrBazkGrTj0jYsRM9AHBWI/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;p&gt;4、给未追踪的文件来个备份&lt;/p&gt;&lt;p&gt;大多数时候，删除所有未追踪的文件是安全的。但很多时候也有这么一种场景，你想删掉这些未追踪的文件同时也想做个备份防止以后需要用到。&lt;/p&gt;&lt;p&gt;Git 组合一些 Bash 命令和管道操作，可以让你可以很容易地给那些未追踪的文件创建 zip 压缩包。&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;files &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;others &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;exclude&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;standard &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;z &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;\&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;xargs&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;tar&lt;/span&gt;&lt;span&gt; rvf &lt;/span&gt;&lt;span&gt;~/&lt;/span&gt;&lt;span&gt;backup&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;untracked&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;zip&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;上面的命令就生成了一个名字为 &lt;code&gt;backup-untracked.zip&lt;/code&gt; 的压缩包文件（当然，在 &lt;code&gt;.gitignore&lt;/code&gt; 里面忽略了的文件不会包含在内）。&lt;/p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/B2EfAOZfS1iaS9dgibME2dgeAKXscn7JcaJJbPMBUMmEc4WZHpTcL9yqYTus3C9jRvy6GibnETwghlrBazkGrTj0jYsRM9AHBWI/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;p&gt;5、了解你的 .git 文件夹&lt;/p&gt;&lt;p&gt;每个仓库都有一个 &lt;code&gt;.git&lt;/code&gt; 文件夹，它是一个特殊的隐藏文件夹。&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;…&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;Git 主要通过两个东西来工作：&lt;/p&gt;&lt;section&gt;&lt;section&gt;1. 当前工作树（你当前检出的文件状态）&lt;/section&gt;&lt;section&gt;2. 你的 Git 仓库的文件夹（准确地说，包含版本信息的 &lt;code&gt;.git&lt;/code&gt; 文件夹的位置）&lt;/section&gt;&lt;/section&gt;&lt;p&gt;这个文件夹存储了所有参考信息和一些其他的如配置、仓库数据、HEAD 状态、日志等更多诸如此类的重要细节。&lt;/p&gt;&lt;p&gt;一旦你删除了这个文件夹，尽管你的源码没被删，但是类似你的工程历史记录等远程信息就没有了。删除这个文件夹意味着你的工程（至少本地的复制）不再在版本控制的范畴之内了。这也就意味着你没法追踪你的修改；你没法从远程仓拉取或推送到远程仓了。&lt;/p&gt;&lt;p&gt;通常而言，你需要或者应当对你的 &lt;code&gt;.git&lt;/code&gt; 文件夹的操作并不多。它是被 Git 管理的，而且大多数时候是一个禁区。然而，在这个文件夹内还是有一些有趣的工件，比如说当前的 HEAD 状态在内的就在其中。&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;cat&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;HEAD&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; refs&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;heads&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;master&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;它也隐含着对你仓库地描述：&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;cat&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;这是一个未命名的仓库；通过编辑文件 ‘description’ 可以给这个仓库命名。&lt;/p&gt;&lt;p&gt;Git 钩子文件夹连同一些钩子文件例子也在这里。参考这些例子你就能知道 Git 钩子能干什么了。当然，你也可以 &lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fopensource.com%2Flife%2F16%2F8%2Fhow-construct-your-own-git-server-part-6&amp;amp;title=%E5%8F%82%E8%80%83%E8%BF%99%E4%B8%AA%20Seth%20Kenlon%20%E5%86%99%E7%9A%84%20Git%20%E9%92%A9%E5%AD%90%E4%BB%8B%E7%BB%8D&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;参考这个 Seth Kenlon 写的 Git 钩子介绍&lt;/a&gt;。&lt;/p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/B2EfAOZfS1iaS9dgibME2dgeAKXscn7JcaJJbPMBUMmEc4WZHpTcL9yqYTus3C9jRvy6GibnETwghlrBazkGrTj0jYsRM9AHBWI/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;p&gt;6、浏览另一个分支的文件&lt;/p&gt;&lt;p&gt;有时，你会想要浏览另一个分支下某个文件的内容。这其实用一个简单的 Git 命令就可以实现，甚至都不用切换分支。&lt;/p&gt;&lt;p&gt;设想你有一个命名为 &lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=http%3A%2F%2FREADME.md&amp;amp;title=README.md&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;README.md&lt;/a&gt; 的文件，并且它在 &lt;code&gt;main&lt;/code&gt; 分支上。当前你正工作在一个名为 &lt;code&gt;dev&lt;/code&gt; 的分支。&lt;/p&gt;&lt;p&gt;用下面的 Git 命令，在终端上就行。&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; show main&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;README&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;md&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;一旦你执行这个命令，你就能在你的终端上看到 &lt;code&gt;main&lt;/code&gt; 分支上该文件的内容。&lt;/p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/B2EfAOZfS1iaS9dgibME2dgeAKXscn7JcaJJbPMBUMmEc4WZHpTcL9yqYTus3C9jRvy6GibnETwghlrBazkGrTj0jYsRM9AHBWI/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;p&gt;7、Git 中的搜索&lt;/p&gt;&lt;p&gt;用一个简单的命令你就能在 Git 中像专业人士一样搜索了。更有甚者，尽管你不确定你的修改在哪次提交或者哪个分支上，你依然能搜索。&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; rev&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;all &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;xargs&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;grep&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;F &lt;/span&gt;&lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;例如，假设你想在你的仓库中搜索字符串 &lt;code&gt;“font-size: 52 px;&quot;&lt;/code&gt; ：&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; rev&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;–&lt;/span&gt;&lt;span&gt;all &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;xargs&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;grep&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;F &lt;/span&gt;&lt;span&gt;‘&lt;/span&gt;&lt;span&gt;font&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;52&lt;/span&gt;&lt;span&gt; px&lt;/span&gt;&lt;span&gt;;’&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;F3022&lt;/span&gt;&lt;span&gt;…&lt;/span&gt;&lt;span&gt;9e12&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;HtmlTemplate&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;css&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; font&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;52&lt;/span&gt;&lt;span&gt; px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;E9211&lt;/span&gt;&lt;span&gt;…&lt;/span&gt;&lt;span&gt;8244&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;RR&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Web&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;Content&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;css&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; font&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;52&lt;/span&gt;&lt;span&gt; px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/B2EfAOZfS1iaS9dgibME2dgeAKXscn7JcaJJbPMBUMmEc4WZHpTcL9yqYTus3C9jRvy6GibnETwghlrBazkGrTj0jYsRM9AHBWI/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;p&gt;试试这些小技巧&lt;/p&gt;&lt;p&gt;我希望这些小技巧对你是有用的，或者增加你的生产力或者节省你的大量时间。&lt;/p&gt;&lt;p&gt;你也有一些喜欢的 &lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Facompiler.com%2Fgit-tips%2F&amp;amp;title=Git%20%E6%8A%80%E5%B7%A7&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;Git 技巧&lt;/a&gt; 吗？在评论区分享吧。&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;via: &lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fopensource.com%2Farticle%2F20%2F10%2Fadvanced-git-tips&amp;amp;title=https%3A%2F%2Fopensource.com%2Farticle%2F20%2F10%2Fadvanced-git-tips&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;https://opensource.com/article/20/10/advanced-git-tips&lt;/a&gt;&lt;/p&gt;&lt;p&gt;作者：&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fopensource.com%2Fusers%2Facompiler&amp;amp;title=Rajeev%20Bera&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;Rajeev Bera&lt;/a&gt; 选题：&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fgithub.com%2Flujun9972&amp;amp;title=lujun9972&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;lujun9972&lt;/a&gt; 译者：&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fgithub.com%2FBoosterY&amp;amp;title=BoosterY&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;BoosterY&lt;/a&gt; 校对：&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fgithub.com%2Fwxy&amp;amp;title=wxy&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;wxy&lt;/a&gt;&lt;/p&gt;&lt;p&gt;本文由 &lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fgithub.com%2FLCTT%2FTranslateProject&amp;amp;title=LCTT&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;LCTT&lt;/a&gt; 原创编译，&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Flinux.cn%2F&amp;amp;title=Linux%E4%B8%AD%E5%9B%BD&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5NjQ4MjYwMQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/W9DqKgFsc6ibPlQXlgCmnlaz6glKp60FFhghXwSx3k5JVavk34FiaMu4ztUTl2Fib0DCUqSkRCvoWPDNczKzFefIg/0?wx_fmt=png&quot; data-nickname=&quot;Linux中国&quot; data-alias=&quot;linux-cn&quot; data-signature=&quot;[Linux中国](https://linux.cn/)开源社区官方公众号。专注于开源技术研究、开源思想传播。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/B2EfAOZfS1iaS9dgibME2dgeAKXscn7JcaSlibdzBCLU0WhPzcyiaM881yKtHiaAfwsbKAVJWfCT9ycWraQiazdMxjianJEVSm5vb1m/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;512&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;欢迎遵照 CC-BY-NC-SA 协议规定转载，&lt;/section&gt;&lt;section&gt;如需转载，请在文章下留言 “&lt;span&gt;转载：公众号名称&lt;/span&gt;”，&lt;/section&gt;&lt;section&gt;我们将为您添加白名单，授权“&lt;span&gt;转载文章时可以修改&lt;/span&gt;”。&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>06d5375197d9596a9e5c57f0e5ac1d7b</guid>
<title>[推荐] 后台开发面试必看：后台服务器开发高性能最佳实践</title>
<link>https://toutiao.io/k/w76nnho</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-topic-des nc-post-content&quot;&gt;
&lt;h2&gt;前言&lt;/h2&gt; 
&lt;p&gt;&lt;span&gt;在互联网公司技术面试上，除了&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;和网络、操作系统这种基础之外，还有一类&lt;/span&gt;&lt;strong&gt;系统设计和优化&lt;/strong&gt;的问题。这类问题需要你有一个全局的技术视野，以及熟悉一些常用的系统优化方法论，也就是工程上的一些 &lt;strong&gt;Best Practice&lt;/strong&gt;，而不至于自己临时拍脑袋瞎设计。&lt;/p&gt; 
&lt;p&gt;在互联网公司，经常面临一个“三高”问题：&lt;/p&gt; 
 
&lt;p&gt;这篇文章将总结一下后台服务器开发中有哪些常用的解决“三高”问题的方法和思想。&lt;/p&gt; 
&lt;p&gt;希望这些知识，能够给你一丝启发和帮助，助力你收割 各大公司 Offer~&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;先上本文思维导图:&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;如何解决三高&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873447931_007S8ZIlgy1gifsdthgvpj315p0u0aia.jpg&quot;/&gt;&lt;/p&gt; 
&lt;h2&gt;正文&lt;/h2&gt; 
&lt;h3&gt;一、缓存&lt;/h3&gt; 
&lt;p&gt;什么是缓存？看看维基百科怎么说：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;In computing, a cache is a hardware or software component that stores data so that future requests for that data can be served faster; the data stored in a cache might be the result of an earlier computation or a copy of data stored elsewhere.&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;在计算机中，&lt;strong&gt;缓存&lt;/strong&gt;是存储数据的硬件或软件组件，以便可以更快地满足将来对该数据的请求。 存储在缓存中的数据可能是之前&lt;strong&gt;计算结果&lt;/strong&gt;，也可能是存储在其他位置的&lt;strong&gt;数据副本&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;缓存本质来说是使用&lt;strong&gt;空间换时间&lt;/strong&gt;的思想，它在计算机世界中无处不在， 比如 CPU 就自带 L1、L2、L3 Cache，这个一般应用开发可能关注较少。但是在一些实时系统、大规模计算模拟、图像处理等追求极致性能的领域，就特别注重编写&lt;strong&gt;缓存友好&lt;/strong&gt;的代码。&lt;/p&gt; 
&lt;p&gt;什么是缓存友好？简单来说，就是代码在访问数据的时候，尽量使用缓存命中率高的方式。这个后面可以单独写一篇 CPU 缓存系统以及如何编写缓存友好代码的文章。&lt;/p&gt; 
&lt;h4&gt;1.1 缓存为什么有效？&lt;/h4&gt; 
&lt;p&gt;缓存之所以能够大幅提高系统的性能，关键在于数据的访问具有&lt;strong&gt;局部性&lt;/strong&gt;，也就是二八定律：「百分之八十的数据访问是集中在 20% 的数据上」。这部分数据也被叫做&lt;strong&gt;热点数据。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;缓存一般使用内存作为存储，内存读写速度快于磁盘，但容量有限，十分宝贵，不可能将所有数据都缓存起来。&lt;/p&gt; 
&lt;p&gt;如果应用访问数据没有热点，不遵循二八定律，即大部分数据访问并没有集中在小部分数据上，那么缓存就没有意义，因为大部分数据还没有被再次访问就已经被挤出缓存了。每次访问都会回源到数据库查询，那么反而会降低数据访问效率。&lt;/p&gt; 
&lt;h4&gt;1.2 缓存分类&lt;/h4&gt; 
 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;&lt;strong&gt;2. 分布式缓存:&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;当缓存的数据量增大以后，单机不足以承载缓存服务时，就要考虑对缓存服务做&lt;strong&gt;水平扩展&lt;/strong&gt;，引入缓存集群。&lt;/p&gt; &lt;p&gt;将数据分片后分散存储在不同机器中，如何决定每个数据分片存放在哪台机器呢？一般是采用&lt;strong&gt;&lt;span&gt;一致性 Hash &lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，它能够保证在缓存集群动态调整，不断增加或者减少机器后，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;访问时依然能够根据 key 访问到数据。&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;一致性 Hash &lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;也是值得用一篇文章来讲的，如果暂时还不懂的话可以去搜一下。&lt;/span&gt;&lt;/p&gt; &lt;p&gt;常用的组件有 &lt;strong&gt;Memcache&lt;/strong&gt;、 &lt;strong&gt;Redis Cluster&lt;/strong&gt; 等，第二个是在高性能内存存储 Redis 的基础上，提供分布式存储的解决方案。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;h4&gt;1.3 缓存使用指南&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;1. 适合缓存的场景：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;&lt;strong&gt;读多写少：&lt;/strong&gt; &lt;/p&gt; &lt;p&gt;比如电商里的商品详情页面，访问频率很高，但是一般写入只在店家上架商品和修改信息的时候发生。如果把热点商品的信息缓存起来，这将拦截掉很多对数据库的访问，提高系统整体的吞吐量。&lt;/p&gt; &lt;p&gt;因为一般数据库的 QPS 由于有「ACID」约束、并且数据是持久化在硬盘的，所以比 Redis 这类基于内存的 NoSQL 存储低不少。常常是一个系统的瓶颈，如果我们把大部分的查询都在 Redis 缓存中命中了，那么系统整体的 QPS 也就上去了。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;&lt;strong&gt;计算耗时大，且实时性不高：&lt;/strong&gt;&lt;br/&gt;比如王者荣耀里的全区排行榜，一般一周更新一次，并且计算的数据量也比较大，所以计算后缓存起来，请求排行榜直接从缓存中取出，就不用实时计算了。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;2. 不适合缓存的场景&lt;/strong&gt;：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;写多读少，频繁更新。&lt;/strong&gt; &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;对数据一致性要求严格：&lt;/strong&gt; 因为缓存会有更新策略，所以很难做到和数据库实时同步。 &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;数据访问完全随机：&lt;/strong&gt; 因为这样会导致缓存的命中率极低。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;h4&gt;1.4 缓存更新的策略&lt;/h4&gt; 
&lt;p&gt;如何更新缓存其实已经有总结得非常好的「最佳实践」，我们按照套路来，大概率不会犯错。&lt;/p&gt; 
&lt;p&gt;主要分为两类 &lt;strong&gt;Cache-Aside&lt;/strong&gt; 和 &lt;strong&gt;Cache-As-SoR。&lt;/strong&gt; SoR 即「System Of Record，记录系统」，表示数据源，一般就是指数据库。&lt;/p&gt; 
&lt;h5&gt;1、Cache-Aside：&lt;/h5&gt; 
&lt;p&gt;&lt;img alt=&quot;Cache-Aside架构图&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873447897_007S8ZIlgy1gifjt5j889j31540tuq5x.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;这应该是最容易想到的模式了，获取数据时先从缓存读，如果 &lt;strong&gt;cache hit&lt;/strong&gt; 则直接返回，没命中就从数据源获取，然后更新缓存。&lt;/p&gt; 
&lt;p&gt;写数据的时候则先更新数据源，然后设置缓存失效，下一次获取数据的时候必然 &lt;strong&gt;cache miss&lt;/strong&gt;，然后触发&lt;strong&gt;回源&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;直接看伪代码：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;Cache-Aside 代码示范&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873447891_007S8ZIlgy1gift5f4ajcj30u00wmgvc.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;可以看到这种方式对于缓存的使用者是&lt;strong&gt;不透明&lt;/strong&gt;的，需要使用者手动维护缓存。&lt;/p&gt; 
&lt;h5&gt;2、Cache-As-SoR：&lt;/h5&gt; 
&lt;p&gt;&lt;img alt=&quot;Cache-As-SoR架构图&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873447929_007S8ZIlgy1gifj60t7g9j319w0tuta8.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;从字面上来看，就是把 Cache 当作 SoR，也就是数据源，所以一切读写操作都是针对 Cache 的，由 &lt;strong&gt;Cache 内部自己维护和数据源的一致性。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;这样对于使用者来说就和直接操作 SoR 没有区别了，完全感知不到 Cache 的存在。&lt;/p&gt; 
&lt;p&gt;CPU 内部的 L1、L2、L3 Cache 就是这种方式，作为数据的使用方应用程序，是完全感知不到在内存和我们之间还存在几层的 Cache，但是我们之前又提到编写 “缓存友好”的代码，不是透明的吗？这是不是冲突呢？&lt;/p&gt; 
&lt;p&gt;其实不然，缓存友好是指我们通过学习了解缓存内部实现、更新策略之后，通过调整数据访问顺序提高缓存的命中率。&lt;/p&gt; 
&lt;p&gt;Cache-As-SoR 又分为以下三种方式:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Read Through&lt;/strong&gt;：这种方式和 Cache-Aside 非常相似，都是在查询时发生 cache miss 去更新缓存，但是区别在于 Cache-Aside 需要调用方手动更新缓存，而 Cache-As-SoR 则是由缓存内部实现自己负责，对应用层透明。 &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;Write Through&lt;/strong&gt;： 直写式，就是在将数据写入缓存的同时，缓存也去更新后面的数据源，并且必须等到数据源被更新成功后才可返回。这样保证了缓存和数据库里的&lt;strong&gt;数据一致性&lt;/strong&gt;。 &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;Write Back&lt;/strong&gt;：回写式，数据写入缓存即可返回，缓存内部会异步的去更新数据源，这样好处是&lt;strong&gt;写操作特别快&lt;/strong&gt;，因为只需要更新缓存。并且缓存内部可以合并对相同数据项的多次更新，但是带来的问题就是&lt;strong&gt;数据不一致&lt;/strong&gt;，可能发生写丢失。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;h3&gt;二、预处理和延后处理&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;预先延后&lt;/strong&gt;，这其实是一个事物的两面，不管是预先还是延后核心思想都是将本来该在实时链路上处理的事情剥离，要么提前要么延后处理。&lt;strong&gt;降低实时链路的路径长度，&lt;/strong&gt; 这样能有效提高系统性能。&lt;/p&gt; 
&lt;h4&gt;2.1 预处理&lt;/h4&gt; 
&lt;p&gt;举个我们团队实际中遇到的问题：&lt;/p&gt; 
&lt;p&gt;前两个月支付宝联合杭州市政府发放消费劵，但是要求只有杭州市常驻居民才能领取，那么需要在抢卷请求进入后台的时候就判断一下用户是否是杭州常驻居民。&lt;/p&gt; 
&lt;p&gt;而判断用户是否是常驻居民这个是另外一个微服务接口，如果直接实时的去调用那个接口，短时的高并发很有可能把这个服务也拖挂，最终导致整个系统不可用，并且 RPC 本身也是比较耗时的，所以就考虑在这里进行优化。&lt;/p&gt; 
&lt;p&gt;那么该怎么做呢？很简单的一个思路，&lt;strong&gt;提前将杭州所有常驻居民的 user_id 存到缓存中，&lt;/strong&gt;&lt;span&gt; 比如可以直接存到 Redis。大概就是千万量级，这样，当请求到来的时候我们直接通过缓存可以快速判断是否来自杭州常驻居民。如果不是则直接在这里返回&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%89%8D%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;前端&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;这里通过预先处理减少了实时链路上的 RPC 调用，既减少了系统的外部依赖，也极大的提高了系统的吞吐量。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;预处理在 CPU 和操作系统中也广泛使用，比如 CPU 基于历史访存信息，将内存中的&lt;strong&gt;指令和数据预取&lt;/strong&gt;到 Cache 中，这样可以大大提高&lt;strong&gt;Cache 命中率。&lt;/strong&gt; 还比如在 Linux 文件系统中，预读算***预测即将访问的 page，然后批量加载比当前读请求更多的数据缓存在 page cache 中，这样当下次读请求到来时可以直接从 cache 中返回，大大减少了访问磁盘的时间。&lt;/p&gt; 
&lt;h4&gt;2.2 延后处理&lt;/h4&gt; 
&lt;p&gt;还是支付宝，上栗子：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;集五福活动&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873448256_007S8ZIlgy1gifje6vocvj30iy0s0qhh.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;这是支付宝春节集五福活动开奖当晚，不过，作为非酋的我一般是不屑于参与这种活动的。&lt;/p&gt; 
&lt;p&gt;大家发现没有，这类活动中奖奖金一般会显示 &lt;strong&gt;「稍后到账」&lt;/strong&gt;，为什么呢？那当然是到账这个操作不简单！&lt;/p&gt; 
&lt;p&gt;到账即转账，A 账户给 B 账户转钱，A 减钱， B 就必须要同时加上钱，也就是说不能 A 减了钱但 B 没有加上，这就会导致资金损失。资金安全是支付业务的生命线，这可不行。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;这两个动作必须一起成功或是一起都不成功，不能只成功一半，这是保证数据一致性。&lt;/strong&gt; 保证两个操作同时成功或者失败就需要用到&lt;strong&gt;事务&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;如果去实时的做到账，那么大概率数据库的 &lt;strong&gt;TPS（每秒处理的事务数）&lt;/strong&gt; 会是瓶颈。通过产品提示，将到账操作延后处理，解决了数据库 TPS 瓶颈。&lt;/p&gt; 
&lt;p&gt;延后处理还有一个非常著名的例子，&lt;strong&gt;COW（Copy On Write，写时复制）。&lt;/strong&gt; Linux 创建进程的系统调用 fork，fork 产生的子进程只会创建虚拟地址空间，而不会分配真正的物理内存，子进程共享父进程的物理空间，只有当某个进程需要写入的时候，才会真正分配物理页，拷贝该物理页，通过 COW 减少了很多不必要的数据拷贝。&lt;/p&gt; 
&lt;h3&gt;三、池化&lt;/h3&gt; 
&lt;p&gt;后台开发过程中你一定离不开各种 &lt;strong&gt;「池子」：&lt;/strong&gt; 内存池、连接池、线程池、对象池......&lt;/p&gt; 
&lt;p&gt;内存、连接、线程这些都是资源，创建线程、分配内存、数据库连接这些操作都有一个特征， 那就是&lt;strong&gt;创建和销毁过程都会涉及到很多系统调用或者网络 IO。&lt;/strong&gt; 每次都在请求中去申请创建这些资源，就会增加请求处理耗时，但是如果我们用一个 &lt;strong&gt;容器（池）&lt;/strong&gt; 把它们保存起来，下次需要的时候，直接拿出来使用，避免重复创建和销毁浪费的时间。&lt;/p&gt; 
&lt;h4&gt;3.1 内存池&lt;/h4&gt; 
&lt;p&gt;在 C/C++ 中，经常使用 malloc、new 等 API 动态申请内存。由于申请的内存块大小不一，如果频繁的申请、释放会导致大量的&lt;strong&gt;内存碎片&lt;/strong&gt;，并且这些 API 底层依赖系统调用，会有额外的开销。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;内存池就是在使用内存前，先向系统申请一块空间留做备用，使用者需要内池时向内存池申请，用完后还回来。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;内存池的思想非常简单，实现却不简单，难点在于以下几点:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;如何快速分配内存&lt;/strong&gt; &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;降低内存碎片率&lt;/strong&gt; &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;维护内存池所需的额外空间尽量少&lt;/strong&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;&lt;span&gt;如果不考虑效率，我们完全可以将内存分为不同大小的块，然后用&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;链表&lt;/a&gt;连接起来，分配的时候找到大小最合适的返回，释放的时候直接添加进&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;链表&lt;/a&gt;。如:&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;空闲链表&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873448286_007S8ZIlgy1gifk4wterkj31ii0s6abs.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;当然这只是玩具级别的实现，业界有性能非常好的实现了，我们可以直接拿来学习和使用。&lt;/p&gt; 
&lt;p&gt;比如 Google 的 「tcmalloc」 和 Facebook 的 「jemalloc」。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;限于篇幅我们不在这里详细讲解它们的实现原理，如果感兴趣可以搜来看看，也推荐去看看被誉为神书的 CSAPP（《深入理解计算机系统》）第 10 章，那里也讲到了动态内存分配&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;h4&gt;3.2 线程池&lt;/h4&gt; 
&lt;p&gt;线程是干嘛的？线程就是我们&lt;strong&gt;程序执行的实体&lt;/strong&gt;。在服务器开发领域，我们经常会为每个请求分配一个线程去处理，但是线程的创建销毁、调度都会带来额外的开销，线程太多也会导致系统整体性能下降。在这种场景下，我们通常会提前创建若干个线程，通过线程池来进行管理。当请求到来时，只需从线程池选一个线程去执行处理任务即可。&lt;/p&gt; 
&lt;p&gt;线程池常常和&lt;strong&gt;队列&lt;/strong&gt;一起使用来实现&lt;strong&gt;任务调度&lt;/strong&gt;，主线程收到请求后将创建对应的任务，然后放到队列里，线程池中的工作线程等待队列里的任务。&lt;/p&gt; 
&lt;p&gt;线程池实现上一般有四个核心组成部分:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;管理器（Manager）:&lt;/strong&gt; 用于创建并管理线程池。 &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;工作线程（Worker）:&lt;/strong&gt; 执行任务的线程。 &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;任务接口（Task）:&lt;/strong&gt; 每个具体的任务必须实现任务接口，工作线程将调用该接口来完成具体的任务。 &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;任务队列（TaskQueue）:&lt;/strong&gt; 存放还未执行的任务。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;&lt;img alt=&quot;线程池模型&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873448290_007S8ZIlgy1gifknuico6j31er0u0u0x.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;线程池在 C、C++ 中没有具体的实现，需要应用开发者手动实现上诉几个部分。&lt;/p&gt; 
&lt;p&gt;在 Java 中 &lt;strong&gt;「ThreadPoolExecutor」&lt;/strong&gt; 类就是线程池的实现。后续我也会写文章分析 C++ 如何写一个简单的线程池以及 Java 中线程池是如何实现的。&lt;/p&gt; 
&lt;h4&gt;3.3 连接池&lt;/h4&gt; 
&lt;p&gt;顾名思义，连接池是创建和管理连接的。&lt;/p&gt; 
&lt;p&gt;大家最熟悉的莫过于数据库连接池，这里我们简单分析下如果不用数据库连接池，一次 SQL 查询请求会经过哪些步骤:&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;strong&gt;和 MySQL server 建立 TCP 连接:&lt;/strong&gt;
   &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;MySQL 权限认证：&lt;/strong&gt;
  &lt;ul&gt; 
   &lt;li&gt;Server 向 Client 发送 密钥 &lt;/li&gt;
   &lt;li&gt;Client 使用密钥加密用户名、密码等信息，将加密后的报文发送给 Server &lt;/li&gt;
   &lt;li&gt;Server 根据 Client 请求包，验证是否是合法用户，然后给 Client 发送认证结果 &lt;/li&gt;
  &lt;/ul&gt; &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;Client 发送 SQL 语句&lt;/strong&gt; &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;Server 返回语句执行结果&lt;/strong&gt; &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;MySQL 关闭&lt;/strong&gt; &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;TCP 连接断开&lt;/strong&gt;
   &lt;/li&gt;
&lt;/ol&gt; 
&lt;p&gt;可以看出不使用连接池的话，为了执行一条 SQL，会花很多时间在安全认证、网络IO上。&lt;/p&gt; 
&lt;p&gt;如果使用连接池，执行一条 SQL 就省去了建立连接和断开连接所需的额外开销。&lt;/p&gt; 
&lt;p&gt;还能想起哪里用到了连接池的思想吗？我认为 &lt;strong&gt;HTTP 长链接&lt;/strong&gt;也算一个变相的链接池，虽然它本质上只有一个连接，但是思想却和连接池不谋而合，都是为了复用同一个连接发送多个 HTTP 请求，避免建立和断开连接的开销。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;池化实际上是预处理和延后处理的一种应用场景，通过池子将各类资源的创建提前和销毁延后。&lt;/strong&gt;&lt;/p&gt; 
&lt;h3&gt;四、同步变异步&lt;/h3&gt; 
&lt;p&gt;对于处理耗时的任务，如果采用同步的方式，那么会增加任务耗时，降低系统并发度。&lt;/p&gt; 
&lt;p&gt;可以通过将同步任务变为异步进行优化。&lt;/p&gt; 
&lt;p&gt;举个例子，比如我们去 KFC 点餐，遇到排队的人很多，当点完餐后，大多情况下我们会隔几分钟就去问好了没，反复去问了好几次才拿到，在这期间我们也没法干活了，这时候我们是这样的：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;同步写法&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873448286_007S8ZIlgy1gifvfsljxrj30u018ijyn.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;这个就叫&lt;strong&gt;同步轮训，&lt;/strong&gt; 这样效率显然太低了。&lt;/p&gt; 
&lt;p&gt;服务员被问烦了，就在点完餐后给我们一个号码牌，每次准备好了就会在服务台叫号，这样我们就可以在被叫到的时候再去取餐，中途可以继续干自己的事。&lt;/p&gt; 
&lt;p&gt;这就叫异步,在很多编程语言中有异步编程的库，比如 C++ std::future、Python asyncio 等，但是异步编程往往需要&lt;strong&gt;回调函数（Callback function）&lt;/strong&gt;，如果回调函数的层级太深，这就是&lt;strong&gt;回调地狱（Callback hell）&lt;/strong&gt;。回调地狱如何优化又是一个庞大的话题。。。。&lt;/p&gt; 
&lt;p&gt;这个例子相当于函数调用的异步化，还有的是情况是处理流程异步化，这个会在接下来消息队列中讲到。&lt;/p&gt; 
&lt;h3&gt;五、消息队列&lt;/h3&gt; 
&lt;p&gt;&lt;img alt=&quot;消息队列示意图&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873448360_007S8ZIlgy1gifwp4n129j31880lwmy6.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;这是一个非常简化的消息队列模型，上游生产者将消息通过队列发送给下游消费者。在这之间，消息队列可以发挥很多作用，比如：&lt;/p&gt; 
&lt;h4&gt;5.1 服务解耦&lt;/h4&gt; 
&lt;p&gt;有些服务被其它很多服务依赖，比如一个论坛网站，当用户成功发布一条帖子有一系列的流程要做，有积分服务计算积分，推送服务向发布者的粉丝推送一条消息..... 对于这类需求，常见的实现方式是直接调用：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;直接调用&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873448525_007S8ZIlgy1gifwm2nlw8j313e0k675u.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;这样如果需要新增一个&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90&quot; target=&quot;_blank&quot;&gt;数据分析&lt;/a&gt;的服务，那么又得改动发布服务，这违背了&lt;/span&gt;&lt;strong&gt;依赖倒置原则&lt;/strong&gt;，&lt;strong&gt;即上层服务不应该依赖下层服务，那么怎么办呢？&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;发布订阅模式&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873448603_007S8ZIlgy1gifwo36vdzj319e0k8765.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;引入消息队列作为中间层，当帖子发布完成后，发送一个事件到消息队列里，而关心&lt;strong&gt;帖子发布成功&lt;/strong&gt;这件事的下游服务就可以订阅这个事件，这样即使后续继续增加新的下游服务，只需要订阅该事件即可，完全不用改动发布服务，完成系统解耦。&lt;/p&gt; 
&lt;h4&gt;5.2 异步处理&lt;/h4&gt; 
&lt;p&gt;有些业务涉及到的处理流程非常多，但是很多步骤并不要求实时性。那么我们就可以通过消息队列异步处理。比如淘宝下单，一般包括了&lt;strong&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A3%8E%E6%8E%A7&quot; target=&quot;_blank&quot;&gt;风控&lt;/a&gt;、锁库存、生成订单、短信/邮件通知&lt;/span&gt;&lt;/strong&gt;等步骤。但是&lt;strong&gt;&lt;span&gt;核心的就&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A3%8E%E6%8E%A7&quot; target=&quot;_blank&quot;&gt;风控&lt;/a&gt;和锁库存，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 只要&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A3%8E%E6%8E%A7&quot; target=&quot;_blank&quot;&gt;风控&lt;/a&gt;和扣减库存成功，那么就可以返回结果通知用户成功下单了。&lt;/span&gt;&lt;strong&gt;后续的生成订单，短信通知都可以通过消息队列发送给下游服务异步处理。大大提高了系统响应速度。&lt;/strong&gt; &lt;/p&gt; 
&lt;p&gt;这就是处理流程异步化。&lt;/p&gt; 
&lt;h4&gt;5.3 流量削峰&lt;/h4&gt; 
&lt;p&gt;一般像秒杀、抽奖、抢卷这种活动都伴随着&lt;strong&gt;短时间海量的请求，&lt;/strong&gt; 一般超过后端的处理能力，那么我们就可以在接入层将请求放到消息队列里，后端根据自己的处理能力不断从队列里取出请求进行业务处理。&lt;/p&gt; 
&lt;p&gt;就像最近长江汛期，上游短时间大量的洪水汇聚直奔下游，但是通过三峡大坝将这些水缓存起来，然后匀速的向下游释放，起到了很好的削峰作用。&lt;/p&gt; 
&lt;p&gt;起到了平均流量的作用。&lt;/p&gt; 
&lt;h4&gt;5.4 总结&lt;/h4&gt; 
&lt;p&gt;消息队列的核心思想就是把同步的操作变成异步处理，异步处理会带来相应的好处，比如:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;服务解耦 &lt;/li&gt;
 &lt;li&gt;提高系统的并发度，将非核心操作异步处理，不会阻塞住主流程 &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;但是软件开发没有银弹，所有的方案选择都是一种 &lt;strong&gt;trade-off。&lt;/strong&gt; 同样，异步处理也不全是好处，也会导致一些问题：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;降低了数据一致性，从强一致性变为最终一致性 &lt;/li&gt;
 &lt;li&gt;有消息丢失的风险，比如宕机，需要有容灾机制 &lt;/li&gt;
&lt;/ul&gt; 
&lt;h3&gt;六、批量处理&lt;/h3&gt; 
&lt;p&gt;在涉及到网络连接、IO等情况时，将操作批量进行处理能够有效提高系统的传输速率和吞吐量。&lt;/p&gt; 
&lt;p&gt;在前后端通信中，&lt;strong&gt;通过合并一些频繁请求的小资源可以获得更快的加载速度。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;比如我们后台 RPC 框架，经常有更新数据的需求，而有的数据更新的接口往往只接受一项，这个时候我们往往会优化下更新接口，&lt;/p&gt; 
&lt;p&gt;使其能够接受批量更新的请求，这样可以将批量的数据一次性发送，大大缩短网络 RPC 调用耗时。&lt;/p&gt; 
&lt;h3&gt;七、数据库&lt;/h3&gt; 
&lt;p&gt;我们常把后台开发调侃为「CRUD」，数据库在整个应用开发过程中的重要性不言而喻。&lt;/p&gt; 
&lt;p&gt;而且很多时候系统的瓶颈也往往处在数据库这里，慢的原因也有很多，比如可能是没用索引、没用对索引、读写锁冲突等等。&lt;/p&gt; 
&lt;p&gt;那么如何使用数据才能又快又好呢？下面这几点需要重点关注：&lt;/p&gt; 
&lt;h4&gt;7.1 索引&lt;/h4&gt; 
&lt;p&gt;索引可能是我们平时在使用数据库过程中接触得最多的优化方式。索引好比图书馆里的书籍索引号，想象一下，如果我让你去一个没有书籍索引号的图书馆找《人生》这本书，你是什么样的感受？当然是怀疑人生，同理，你应该可以理解当你查询数据，却不用索引的时候数据库该有多崩溃了吧。&lt;/p&gt; 
&lt;p&gt;数据库表的索引就像图书馆里的书籍索引号一样，可以提高我们检索数据的效率。索引能提高查找效率，可是你有没有想过为什么呢？&lt;strong&gt;&lt;span&gt;这是因为索引一般而言是一个&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;列表，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;意味着可以基于二分思想进行查找，将查询时间复杂度做到 O(log(N))，快速的支持等值查询和范围查询。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;二叉搜索树查询效率无疑是最高的，因为平均来说每次比较都能缩小一半的搜索范围，但是一般在数据库索引的实现上却会选择 B 树或 B+ 树而不用二叉搜索树，为什么呢？&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;这就涉及到数据库的存储介质了，数据库的数据和索引都是存放在磁盘，并且是 InnoDB 引擎是以页为基本单位管理磁盘的，一页一般为 16 KB。AVL 或&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;搜索效率虽然非常高，&lt;/span&gt;&lt;strong&gt;但是同样数据项，它也会比 B、B+ 树更高，高就意味着平均来说会访问更多的节点，即磁盘IO次数！&lt;/strong&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;根据 Google 工程师 Jeff Dean 的统计，访问内存数据耗时大概在 100 ns，访问磁盘则是 10,000,000 ns。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;所以表面上来看我们使用 B、B+ 树没有 二叉查找树效率高，但是实际上由于 B、B+ 树降低了树高，减少了磁盘 IO 次数，反而大大提升了速度。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;这也告诉我们，没有绝对的快和慢，系统分析要抓主要矛盾，先分析出决定系统瓶颈的到底是什么，然后才是针对瓶颈的优化。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;其实关于索引想写的也还有很多，但还是受限于篇幅，以后再单独写。&lt;/p&gt; 
&lt;p&gt;先把我认为索引必知必会的知识列出来，大家可以查漏补缺:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;主键索引和普通索引，以及它们之间的区别&lt;/strong&gt; &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;最左前缀匹配原则&lt;/strong&gt; &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;索引下推&lt;/strong&gt; &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;覆盖索引、联合索引&lt;/strong&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;h4&gt;7.2 读写分离&lt;/h4&gt; 
&lt;p&gt;一般业务刚上线的时候，直接使用单机数据库就够了，但是随着用户量上来之后，系统就面临着大量的写操作和读操作，单机数据库处理能力有限，容易成为系统瓶颈。&lt;/p&gt; 
&lt;p&gt;由于存在读写锁冲突，并且很多大型互联网业务往往&lt;strong&gt;读多写少&lt;/strong&gt;，读操作会首先成为数据库瓶颈，我们希望消除读写锁冲突从而提升数据库整体的读写能力。&lt;/p&gt; 
&lt;p&gt;那么就需要采用读写分离的数据库集群方式，一主多从，主库会同步数据到从库。写操作都到主库，读操作都去从库。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;读写分离&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873448685_007S8ZIlgy1gifs6y545lj317m0tygpu.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;读写分离到之后就避免了读写锁争用，这里解释一下，什么叫读写锁争用：&lt;/p&gt; 
&lt;p&gt; MySQL 中有两种锁: &lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;排它锁( X 锁)：&lt;/strong&gt; 事务 T 对数据 A 加上 X 锁时，&lt;strong&gt;只允许事务 T 读取和修改数据 A。&lt;/strong&gt; &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;共享锁( S 锁)：&lt;/strong&gt; 事务 T 对数据 A 加上 S 锁时，&lt;strong&gt;其他事务只能再对数据 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁。&lt;/strong&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;读写分离解决问题的同时也会带来新问题，比如主库和从库数据不一致&lt;/p&gt; 
&lt;p&gt;MySQL 的主从同步依赖于 binlog，binlog(二进制日志)是 MySQL Server 层维护的一种二进制日志，是独立于具体的存储引擎。它主要存储对数据库更新(insert、delete、update)的 SQL 语句，由于记录了完整的 SQL 更新信息，所以 binlog 是可以用来数据恢复和主从同步复制的。&lt;/p&gt; 
&lt;p&gt;从库从主库拉取 binlog 然后依次执行其中的 SQL 即可达到复制主库的目的，由于从库拉取 binlog 存在网络延迟等，所以主从数据存在延迟问题。&lt;/p&gt; 
&lt;p&gt;那么这里就要看业务是否允许短时间内的数据不一致，如果不能容忍，那么可以通过如果读从库没获取到数据就去主库读一次来解决。&lt;/p&gt; 
&lt;h4&gt;7.3 分库分表&lt;/h4&gt; 
&lt;p&gt;如果用户越来越多，写请求暴涨，对于上面的单 Master 节点肯定扛不住，那么该怎么办呢？多加几个 Master？不行，这样会带来更多的数据不一致的问题，增加系统的复杂度。那该怎么办？就只能对库表进行拆分了。&lt;/p&gt; 
&lt;p&gt;常见的拆分类型有&lt;strong&gt;垂直拆分和水平拆分。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;考虑拼夕夕电商系统，一般有 &lt;strong&gt;订单表、用户表、支付表、商品表、商家表等，&lt;/strong&gt; 最初这些表都在一个数据库里。&lt;br/&gt;后来随着砍一刀带来的海量用户，拼夕夕后台扛不住了! 于是紧急从阿狸粑粑那里挖来了几个 P8、P9 大佬对系统进行重构。&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;p&gt;P9 大佬第一步先对数据库进行垂直分库，&lt;br/&gt;&lt;strong&gt;根据业务关联性强弱，将它们分到不同的数据库，&lt;/strong&gt; 比如订单库，商家库、支付库、用户库。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;第二步是对一些大表进行垂直分表，&lt;strong&gt;将一个表按照字段分成多表，每个表存储其中一部分字段。&lt;/strong&gt; 比如商品详情表可能最初包含了几十个字段，但是往往最多访问的是商品名称、价格、产地、图片、介绍等信息，所以我们将不常访问的字段单独拆成一个表。&lt;/p&gt; &lt;/li&gt;
&lt;/ol&gt; 
&lt;ul&gt; 
 &lt;li&gt;由于垂直分库已经按照业务关联切分到了最小粒度，数据量任然非常大，&lt;strong&gt;P9 大佬开始水平分库，比如可以把订单库分为订单1库、订单2库、订单3库......&lt;/strong&gt;&lt;span&gt; 那么如何决定某个订单放在哪个订单库呢？可以考虑对主键通过哈希&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;计算放在哪个库。 &lt;/span&gt;&lt;/li&gt;
 &lt;li&gt;分完库，单表数据量任然很大，查询起来非常慢，&lt;strong&gt;P9 大佬决定按日或者按月将订单分表，叫做日表、月表。&lt;/strong&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;分库分表同时会带来一些问题，比如平时单库单表使用的主键自增特性将作废，因为某个分区库表生成的主键无法保证全局唯一，这就需要引入全局 UUID 服务了。&lt;/p&gt; 
&lt;p&gt;经过一番大刀阔斧的重构，拼夕夕恢复了往日的活力，大家又可以愉快的在上面互相砍一刀了。&lt;/p&gt; 
&lt;p&gt;(分库分表会引入很多问题，并没有一一介绍，这里只是为了讲解什么是分库分表)&lt;/p&gt; 
&lt;h3&gt;八、具体技法&lt;/h3&gt; 
&lt;h4&gt;8.1 零拷贝&lt;/h4&gt; 
&lt;p&gt;高性能的服务器应当避免不必要数据复制，特别是在&lt;strong&gt;用户空间和内核空间之间的数据复制。&lt;/strong&gt; 比如 HTTP 静态服务器发送静态文件的时候，一般我们会这样写:&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;发送文件&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873448662_007S8ZIlgy1gifp0trcwkj31ix0u0qbr.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;如果了解 Linux IO 的话就知道这个过程包含了内核空间和用户空间之间的多次拷贝：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;IO示意图&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873448748_007S8ZIlgy1gifp2f3hmgj319m0to0vo.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;内核空间和用户空间之间数据拷贝需要 CPU 亲自完成，但是对于这类&lt;strong&gt;数据不需要在用户空间进行处理&lt;/strong&gt;的程序来说，这样的两次拷贝显然是浪费。什么叫 &lt;strong&gt;「不需要在用户空间进行处理」？&lt;/strong&gt; &lt;/p&gt; 
&lt;p&gt;比如 FTP 或者 HTTP 静态服务器，它们的作用只是将文件从磁盘发送到网络，不需要在中途对数据进行编解码之类的计算操作。&lt;/p&gt; 
&lt;p&gt;如果能够直接将数据在内核缓存之间移动，那么除了减少拷贝次数以外，还能避免内核态和用户态之间的上下文切换。&lt;/p&gt; 
&lt;p&gt;而这正是零拷贝（Zero copy）干的事，主要就是利用各种零拷贝技术，减少不必要的数据拷贝，将 CPU 从数据拷贝这样简单的任务解脱出来，让 CPU 专注于别的任务。&lt;/p&gt; 
&lt;p&gt;常用的零拷贝技术:&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;p&gt;&lt;strong&gt;mmap&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;&amp;lt;kbd&amp;gt;mmap&amp;lt;/kbd&amp;gt; 通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数。&lt;/p&gt; &lt;/li&gt;
&lt;/ol&gt; 
&lt;p&gt;&lt;img alt=&quot;mmap&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873448841_007S8ZIlgy1gifpjzd2fqj319b0u0tbk.jpg&quot;/&gt;&lt;/p&gt; 
&lt;ol start=&quot;2&quot;&gt; 
 &lt;li&gt;&lt;p&gt;&lt;strong&gt;sendfile&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;&amp;lt;kbd&amp;gt;sendfile&amp;lt;/kbd&amp;gt; 是 Linux2.1 版本提供的，数据不经过用户态，直接从页缓存拷贝到 socket 缓存，同时由于和用户态完全无关，就减少了一次上下文切换。&lt;/p&gt; &lt;p&gt;在 Linux 2.4 版本，对 sendfile 进行了优化，直接通过 DMA 将磁盘文件数据读取到 socket 缓存，真正实现了 ”0” 拷贝。前面 mmap 和 2.1 版本的 sendfile 实际上只是消除了用户空间和内核空间之间拷贝，而页缓存和 socket 缓存之间的拷贝依然存在。&lt;/p&gt; &lt;/li&gt;
&lt;/ol&gt; 
&lt;h4&gt;8.2 无锁化&lt;/h4&gt; 
&lt;p&gt;在多线程环境下，为了避免 &lt;strong&gt;竞态条件（race condition），&lt;/strong&gt; 我们通常会采用加锁来进行并发控制，锁的代价也是比较高的，锁会导致上线文切换，甚至被挂起直到锁被释放。&lt;/p&gt; 
&lt;p&gt;基于硬件提供的原子操作 &lt;strong&gt;CAS(Compare And Swap)&lt;/strong&gt; 实现一些高性能无锁的数据结构，比如无锁队列，可以在保证并发安全的情况下，提供更高的性能。&lt;/p&gt; 
&lt;p&gt;首先需要理解什么是 CAS，CAS 有三个操作数，内存里当前值M，预期值 E，修改的新值 N，CAS 的语义就是：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;如果当前值等于预期值，则将内存修改为新值，否则不做任何操作&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;用 C 语言来表达就是:&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;CAS&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873448878_007S8ZIlgy1gifr9ideb7j31oo0u0dot.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;注意，上面 CAS 函数实际上是一条原子指令，那么是如何用的呢？&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;假设我需要实现这样一个功能：&lt;/p&gt; 
&lt;p&gt; 对一个全局变量 global 在两个不同线程分别对它加 100 次，这里多线程访问一个全局变量存在 race condition，所以我们需要采用线程同步操作，下面我分别用锁和CAS的方法来实现这个功能。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;CAS和锁示范&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20201120/652587393_1605873448874_007S8ZIlgy1gifrq8av5vj30u014z1dw.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;通过使用原子操作大大降低了锁冲突的可能性，提高了程序的性能。&lt;/p&gt; 
&lt;p&gt;除了 CAS，还有一些硬件原子指令：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Fetch-And-Add，对变量原子性 + 1 &lt;/li&gt;
 &lt;li&gt;&lt;span&gt;Test-And-Set，这是各种锁&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;的核心，在 AT&amp;amp;T/GNU 汇编语法下，叫 xchg 指令，我会单独写一篇如何使用 xchg 实现各种锁。 &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt; 
&lt;h4&gt;8.3 序列化与反序列化&lt;/h4&gt; 
&lt;p&gt;先看看维基百科怎么定义的序列化：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;In computing, serialization (US spelling) or serialisation (UK spelling) is the process of translating a data structure or object state into a format that can be stored (for example, in a file or memory data buffer) or transmitted (for example, across a computer network) and reconstructed later (possibly in a different computer environment). When the resulting series of bits is reread according to the serialization format, it can be used to create a semantically identical clone of the original object. For many complex objects, such as those that make extensive use of references, this process is not straightforward. Serialization of object-oriented objects does not include any of their associated methods with which they were previously linked.&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;我相信你大概率没有看完上面的英文描述，其实我也不爱看英文资料，总觉得很慢，但是计算机领域一手的学习资料都是美帝那边的，所以没办法，必须逼自己去试着读一些英文的资料。&lt;/p&gt; 
&lt;p&gt;实际上也没有那么难，熟悉常用的几百个专业名词，句子都是非常简单的一些从句。没看的话，再倒回去看看？&lt;/p&gt; 
&lt;p&gt;这里我就不做翻译了，主要是水平太低，估计做到「信达雅」的信都很难。&lt;/p&gt; 
&lt;p&gt;扯远了，还是回到序列化来。&lt;/p&gt; 
&lt;p&gt;所有的编程一定是围绕数据展开的，而数据呈现形式往往是结构化的，比如&lt;strong&gt;结构体（Struct）、类（Class）。&lt;/strong&gt; 但是当我们 &lt;strong&gt;通过网络、磁盘等传输、存储数据的时候却要求是二进制流。&lt;/strong&gt; 比如 TCP 连接，它提供给上层应用的是面向连接的可靠字节流服务。那么如何将这些结构体和类转化为可存储和可传输的字节流呢？这就是序列化要干的事情，反之，从字节流如何恢复为结构化的数据就是反序列化。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;序列化解决了对象持久化和跨网络数据交换的问题。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;序列化一般按照序列化后的结果是否可读，可分为以下两类：&lt;/p&gt; 
 
&lt;p&gt;还有 Java 、Go 这类语言内置了序列化方式，比如在 Java 里实现了 Serializable 接口即表示该对象可序列化。&lt;/p&gt; 
&lt;p&gt;说到这让我想起了大一写的的两个程序，一个是用刚 C 语言写的公交管理系统，当时需要将公交线路、站点信息持久化保存，当时的方案就是每个公交线路写在一行，用 &quot;|&quot;分割信息，比如：&lt;/p&gt; 
&lt;pre class=&quot;prettyprint&quot; from-niu=&quot;default&quot;&gt;5|6:00-22:00|大学城｜南山站｜北京站
123|6:30-23:00｜南湖大道｜茶山刘｜世界&lt;/pre&gt;
&lt;p&gt;第一列就是线路编号、第二项是发车时间、后面就是途径的站点。是不是非常原始？实际上这也是一种序列化方式，只是效率很低，也不通用。而且存在一个问题就是如果信息中包含 “｜”怎么办？当然是用转义。&lt;/p&gt; 
&lt;p&gt;第二个程序是用 Java 写的网络五子棋，当时需要通过网络传输表示棋子位置的对象，查了一圈最后发现只需要实现 Serializable 接口，自己什么都不用干，就能自己完成对象的序列化，然后通过网络传输后反序列化。当时哪懂得这就叫序列化，只觉得牛逼、神奇！&lt;/p&gt; 
&lt;p&gt;最后完成了一个可以网络五子棋，拉着隔壁室友一起玩。。。真的是成就感满满哈哈哈。&lt;/p&gt; 
&lt;p&gt;说来在编程方面，已经很久没有这样的成就感了。&lt;/p&gt; 
&lt;h2&gt;总结&lt;/h2&gt; 
&lt;p&gt;这篇文章主要是粗浅的介绍了一些系统设计、系统优化的套路和最佳实践。&lt;/p&gt; 
&lt;p&gt;不知道你发现没有，从缓存到消息队列、CAS......，很多看起来很牛逼的架构设计其实都来源于操作系统、体系结构。&lt;/p&gt; 
&lt;p&gt;所以我非常热衷学习一些底层的基础知识，这些看似古老的技术是经过时间洗礼留下来的好东西。现在很多的新技术、框架看似非常厉害，实则不少都是新瓶装旧酒，每几年又会被淘汰一批。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span&gt;来自我的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%89%9B%E5%AE%A2&quot; target=&quot;_blank&quot;&gt;牛客&lt;/a&gt;博客:&lt;/span&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.nowcoder.net/n/8de2902353c5438eafe95ce8f475cdbd&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;后台服务器高性能架构设计&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h2&gt;最后说一句（求赞）&lt;/h2&gt; 
&lt;p&gt;小伙伴们如果觉得写得不错, 顺便帮我点个赞呗~&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>