<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e87d9a0baea7a3474bbc01cef016aee8</guid>
<title>Chrome 插件，实用且堪称神器</title>
<link>https://toutiao.io/k/kmh5ibc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3740234375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbcYsOZ7OjWQz73Z1RbSUToiaB8BakvciceibyPkT9qzhV4uIfWakyDXU6Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot; title=&quot;&quot;/&gt;&lt;figcaption&gt;Madison龙少&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; 相信很多人都在使用&lt;code&gt;Chrome 浏览器&lt;/code&gt;，其流畅的浏览体验得到了不少用户的偏爱，但流畅只是一方面， Chrome 最大的优势还是其支持众多&lt;code&gt;强大好用的扩展程序（Extensions）&lt;/code&gt;最近为了更好的利用谷歌浏览器，我整理了一些常用的谷歌插件，分享给大家。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; 闲话不多说，直接上推荐的插件，文章的末尾附有插件的安装教程！！！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;通用类插件&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、 &lt;code&gt;OneTab&lt;/code&gt;：将无数 Tab 合并在一个页面&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; 很多时候我们在一个窗口打开太多的tab，每一个tab太小不容易管理，这时候使用OneTab能够把所有tab收起放在一个页面，点击就可打开该tab，非常方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.26714801444043323&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbKHhSxtkJCibqwZyxTepia0NQ1kQ40iahGGhKh9ll2XU6QtKXX012YOA3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、 &lt;code&gt;Momentum&lt;/code&gt;：美到爆表的新标签页&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; 受够了新建页面时候的空白页的话可以试试，&lt;code&gt;Momentum每天都会提供一张高清大图&lt;/code&gt;，都很好看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/momentum/laookkfknpbbblfpciffpaejjkokdgca&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5072202166064982&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMb0Wib1HmrMzdKDiaM0CmuwlWhW9gASdB04SfNUt5PeWicmXPqwYFQQsibEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、&lt;code&gt;markdown here&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; 超好用的一款插件，强烈推荐！！有个它再也不用担心编辑器不支持markdown语法了，写好以后直接一键转换。而且也是一个跨平台神器，比如我们可以把简书写好的文章（带md语法）直接复制到微信公众号，然后一键转换，格式几乎无变化！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:https://markdown-here.com/&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4602888086642599&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMb2IiaNx8uZw5YOiaDxzZVnk69YtZaIC7TGWn2fhdboHILjKia7fUDtP9sA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、 &lt;code&gt;Adblock Plus&lt;/code&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;code&gt;免除广告困扰&lt;/code&gt;只要是使用 Chrome 的人都应该安装的一款扩展应用，可以帮助你屏蔽几乎大部分网页广告，如果存在漏网之鱼，还可以手动添加到屏蔽列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/adblock-plus-free-ad-bloc/cfhdojbkjhnklbpkdaibdccddilifddb?utm_source=chrome-app-launcher-info-dialog&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.628158844765343&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbl04iaLDDUHSRnQpc5xh5lupf73jWtvIKkvHvFtPiaLsqWY0m9hkLBzKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5、&lt;code&gt;LastPass&lt;/code&gt;：密码管理软件&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;code&gt;LastPass&lt;/code&gt;，全球知名在线密码管理工具之一，采用军事级加密算法，支持自动填充网站用户名和密码，与朋友分享登录信息等实用功能，且在全平台同步免费，无需订阅 Premium，即可在手机、网页、电脑端同步你的所有 LastPass 信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/lastpass-free-password-ma/hdokiejnpimakedhajhdlcegeplioahd/related&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5126353790613718&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbvoIOL5ibs6xEOO6iaicRc6wk3wrib9jzP9rL7qvtQzZqTbg5Nrv1CCffpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6、 &lt;code&gt;关灯看视频&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; 有时候网速太差，全屏以后分辨率很低，可以试试这个，可以让周围页面变暗从而达到最好的视觉效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:https://www.turnoffthelights.com/zh-cn/&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.30505415162454874&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbicqCOP1l6tn4GibbEPNdzjnotovUFbFJjiad6OVPgICLeSfxiaYh4LibV7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7、&lt;code&gt;二维码(QR码)生成器&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; 在线的二维码生成器。可以把当前的网页直接生成二维码，进行编辑。还可以把文字生成二维码，这个很重要！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/anything-to-qrcode/calkaljlpglgogjfcidhlmmlgjnpmnmf&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2976744186046512&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbX5zCNEDfUxyvLb4owhbV6aAQeWWnQNYgrIspBgKSyOUybT99v673Gw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;215&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;8、&lt;code&gt;购物党&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; 在线的比价工具，网购的时候可以看价格历史记录，以及各大网站的价格对比，也有查快递的快捷方式。经常剁手的童鞋要注意了~~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/%E8%B4%AD%E7%89%A9%E5%85%9A%E8%87%AA%E5%8A%A8%E6%AF%94%E4%BB%B7%E5%B7%A5%E5%85%B7/jgphnjokjhjlcnnajmfjlacjnjkhleah&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.138783269961977&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbGqe1PxKWDZauAOY0w2vicnO1GqOLIAZUDDPKicOCUib3KgGZRwZ3Fp6iaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;526&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;9、&lt;code&gt;Infinity&lt;/code&gt;：功能强大的新建标签页扩展&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; 功能强大的新建标签页扩展！做的界面很美，每日壁纸质量也很高！有同步笔记、代办事项等，同时，喜欢它的网页图标，提供了很多常用网站的图标，自定义书签时很好看~唯一的缺点，就是感觉启动比较慢~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/infinity-new-tab-producti/dbfmnekepjoapopniengjbcpnbljalfg&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;10、&lt;code&gt;crxMouse Chrome Gestures&lt;/code&gt; 对于国产浏览器自带鼠标手势的功能，真觉得很方便！这款扩展也是必装啊！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/crxmouse-chrome-gestures/jlgkpaicikihijadgifklkbpdajbkhjo?utm_source=chrome-app-launcher-info-dialog&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;11、 &lt;code&gt;Imagus&lt;/code&gt; 图片放大镜的功能！在体验了360浏览器、猎豹浏览器之后，特地去找的扩展！微博党的利器！这个不管能鼠标悬停放大图片，同时，对链接等也有预览。提供很多功能选项进行设置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/imagus/immpkjjlgappgfkkfieppnmlhakdmaab?utm_source=chrome-app-launcher-info-dialog&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48375451263537905&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbmC83JQc6BbkfH3qYAo9eicFlnhOMXB7sPXibWZdnglebawcmxDzicTNog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;12、&lt;code&gt;JSON Viewer&lt;/code&gt; &lt;code&gt;JSONView&lt;/code&gt; 是一个方便查看 Json 结构的插件，展开，折叠，可以非常方便的查看接口返回数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/jsonviewer/gbmdgpbipfallnflgajpaliibnhdgobh/related&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5144404332129964&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbS12zgJFvke6iajdMq72LmYQtm6TlY5s2EyzU4Cmqu6MhdZeFfkEahhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;13、 &lt;code&gt;Postman&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; 相信开发者朋友一定知道这款插件，这是一款强大的 API &amp;amp; HTTP 请求调试工具，它不仅可以调试简单的 HTML、CSS 以及脚本等简单的网页基本信息，这款 Chrome 插件甚至还能发送几乎所有的 HTTP 请求，可谓是 Web 开发者的一大利器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.49097472924187724&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbM6zibeskrvM3d96ibUdsoibxUTpPloMhhACH7qHqgicT41cYWhrJLTraKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;14、&lt;code&gt;Octotree&lt;/code&gt; github上查看代码的时候总是一层层进入再出来，有点麻烦，没关系，有Octotree。安装Octotree之后，浏览托管在Github上的项目，可看到左侧的树形结构，更方便查看代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4711191335740072&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbbCvqoyrNz9a60icRGRDJYm1jMZC18NHk6AcQNvJXdKXeaUrykQKMzDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;15、&lt;code&gt;Tampermonkey&lt;/code&gt; 俗称‘油猴子’，是一款功能非常强大的插件，他包含：方便的脚本管理、脚本概览、设置多样性、脚本自动更新、安全、兼容性、Chrome 同步、CodeMirror 编辑器、JSHint 语法检查、快速开发、卸载等功能。其官方描述只一句 The world’s most popular userscript manager。足见其优秀。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?utm_campaign=en&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.37364620938628157&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbLaibAxP9ibiaW1jRtoiaY7cq3X8mZwW2rcLG3Hib553MXdzwxzYaiafweBiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;16、 Code Cola
 &lt;code&gt;Code Cola&lt;/code&gt;是一个可视化编辑在线页面css样式的chrome插件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/code-cola/lomkpheldlbkkfiifcbfifipaofnmnkn&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4891696750902527&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbRcnaS7EZ1dCKse5Tjh2libMYp9W35kH5QvY0ZBKq7ZnyGdGiaoRbGEjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;17、&lt;code&gt;WEB前端助手&lt;/code&gt; FE助手：包括字符串编解码、图片base64编码、代码压缩、美化、JSON格式化、正则表达式、时间转换工具、二维码生成器、编码规范检测、页面性能检测、栅格检测、JS运行效率分析等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome商店地址:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://chrome.google.com/webstore/detail/fehelper%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8B/pkgccpejnmalmdinmhkkfafefagiiiad&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5812274368231047&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbmySyYUQxmiaic4ZdlD2clp9ZTkYpyYal6Mc6pjRIoO9ChZGQANrR8vaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;插件安装&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;离线安装谷歌插件方法也很简单&lt;/code&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;打开谷歌浏览器输入：chrome://extensions/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;打钩开发者模式&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.05426765015806112&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sriaewibCqS1SdKCktwibu2xFx7KONo8GMbqbFmZfWogu4DicnseQ7iaC8dXzqYhyl68LB6aw6p7RJ2ib9PCnWBF6A1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1898&quot;/&gt;&lt;figcaption&gt;&quot;Madison龙少&quot;&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;考虑到大部分朋友没有不能访问谷歌商店，这边给出两个方法&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;谷歌访问助手访问谷歌商店&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;离线下载全部插件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微信搜索：Madison龙少，分别回复：&lt;code&gt;google访问助手&lt;/code&gt;、&lt;code&gt;chrome插件&lt;/code&gt; 获取资源。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;结束语&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;感谢阅读小生文章。祝大家早日富可敌国，实现财富自由。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整理不易，好几个小时才整理完，
后面如果有新的好玩的插件再补充进来， &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你觉得有用的话&lt;code&gt;写文不易&lt;/code&gt;,一定要&lt;code&gt;点赞、评论、收藏哦&lt;/code&gt;,&lt;code&gt;感谢感谢感谢!!!&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>11a673d4ced52d18eb15cd30cfc20aff</guid>
<title>踩坑 MySQL 索引，看看你真的会用吗？</title>
<link>https://toutiao.io/k/zdnq3fy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h3 data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.33184855233853006&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;898&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgRgzIV2YTLYP1C9K6m6ZesXIGMic8cBk5es1ZicMDfULrExGEw49a51icWhlYkA1pXmib62xNNUDrMgXA/640?wx_fmt=png&quot;/&gt;&lt;/h3&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;关于 MySQL 索引，对于研发同学，尤其是后端研发同学，一定不会陌生。我们工作中经常会用到 MySQL 数据库，就肯定会经常用到性能优化方面的设计和考量，常常用涉及到 MySQL 索引。但是关于 MySQL 索引，你真的用对了么？&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;对了，在开始正式知识点讲解之前，还需要来个不那么正式的自我介绍吧，哈哈哈~&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-type=&quot;blockquote&quot;&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;我多年后端研发经验，“混迹”于多个互联网大厂，专注软件架构技术研究学习，希望能够持续发挥自身多余的热量，将自己工作中的问题和技术总结输出，分享影响到更多的人。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;大家看我的头像图片像是一个陀螺，其实是寓意螺旋式上升，让技术和自我能够不断精进。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z2bVaFK6CgT0JL4BVF6MLv1jGDCTJGyKlCoSbwlXRVYjPkJUqdylM7lCA7lB5Ul5GdibuHNqW6Aib06U65RuG9RA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;接下来，我会通过一个自己工作中真实遇到一个 MySQL 查询应用问题为背景，来逐步剖析分析，见招拆招，以科学理论为依据，分析探究，希望能带大家一起明确索引应用原则，最终将问题探究清楚。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-type=&quot;blockquote&quot;&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;主要原则：问题驱动；&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;主要流程：应用现象-问题分析-疑点跟进-层层探究-结论明晰。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;那接下来，让我们利用约 15min 的时间，让自由的思路飞一会儿吧！&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading0&quot; data-type=&quot;heading&quot;&gt;问题介绍&lt;/h2&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;我们存在这样一张数据表（cities），记录了城市 code 和名称一些基本数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.18781725888324874&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgT0JL4BVF6MLv1jGDCTJGyKy44FdxmFKIMxu6ibKTIX4ribNbgG66lpWjp0dec3hU6kT5oHjEFQSJDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1576&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;有一天，我在执行如下 SQL 的时候（一个是指定了字段 id，另一个未指定查询字段，而是利用了 *），发现两种情况下查询执行结果竟然不一样！&lt;/span&gt;&lt;/p&gt;&lt;pre data-origin=&quot;pm_code_preview&quot; lang=&quot;text&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Case1：select id from cities limit 1;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;code data-type=&quot;codeline&quot;&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;查询结果：&lt;/span&gt;&lt;/p&gt;&lt;p data-align-center=&quot;&quot; data-type=&quot;paragraph&quot;&gt;&lt;span&gt;id：2&lt;/span&gt;&lt;/p&gt;&lt;pre data-origin=&quot;pm_code_preview&quot; lang=&quot;text&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Case2：select * from cities limit 1;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;查询结果：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.09692671394799054&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgT0JL4BVF6MLv1jGDCTJGyKsZ9gGUDIvMehm0vaauWpeLEf8b8BrOMuGLhf57ov7QgmaDicEP76MdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;423&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;这事成功的引起了我的注意，那就继续搞起吧！&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading1&quot; data-type=&quot;heading&quot;&gt;问题分析&lt;/h2&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;按照之前的工作经验告诉我，遇事不要慌，先 explain 解释执行看看吧。&lt;/span&gt;&lt;/p&gt;&lt;pre data-origin=&quot;pm_code_preview&quot; lang=&quot;text&quot;&gt;&lt;code data-type=&quot;codeline&quot;/&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Case1：explain select id from cities limit 1;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-origin=&quot;pm_code_preview&quot; lang=&quot;text&quot;&gt;&lt;span&gt;执行结果：&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.06875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgT0JL4BVF6MLv1jGDCTJGyK9mIv6J8bU66oKH5L4eZDiaoAlpScKyawkiaiaE7N00V4mjISgMoAJa20A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;pre data-origin=&quot;pm_code_preview&quot; lang=&quot;text&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Case2：explain select * from cities limit 1;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;执行结果：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.06875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgT0JL4BVF6MLv1jGDCTJGyK3gFmqoDEzyibqZj5IoiamcrnDzaa9qibfC177njqDjwUAMdlNWhrngKLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;经过上面的执行计划查看，发现 Case1 中的 SQL 应用到了一个名为&#x27;uniq_city_code&#x27;的索引，而第二个走了全表扫描查询。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span data-type=&quot;strong&quot;&gt;问题初步结论：&lt;/span&gt;也就是说两个 SQL 由于查询字段的不同，导致 MySQL 在具体执行时候选取了不同的索引策略，从而导致了查询结果的不同。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading2&quot; data-type=&quot;heading&quot;&gt;疑点跟进&lt;/h2&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;其实经过上面的分析，其实还存在几个疑问点：&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;可能细心的同学也发现了，还有就是 Case2 查询计划中 Extra 字段为 Using index，说明满足了索引覆盖（索引中包含了所有满足查询条件的数据，无需从表中查询），可是 &lt;span data-type=&quot;strong&quot;&gt;uniq_city_code&lt;/span&gt; 这个索引中并没有 id 这个字段，为何能以覆盖索引的方式执行？&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;带着上面的一脸疑问，我们先来一起回顾下 MySQL 引擎索引的实现方式吧。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;如图所示，为 Innodb、以及参考对比的 MyISAM 引擎的索引实现图例。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;1、InnoDB 聚簇索引和辅助索引（非聚簇索引）的对比图示&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.1773700305810397&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgT0JL4BVF6MLv1jGDCTJGyKJ4736GuE6U2kWUYq1ibxRuMz9kZ5rVANRZWaL5Rx1cFFIGQ0URL91Iw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;654&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;&lt;blockquote data-type=&quot;blockquote&quot;&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;同时便于大家理解，我标记黄线、红线分别代表两种引擎方式的数据查询路径，大家可以参照图例，体会对比一下。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;InnoDB 按聚簇索引的形式存储数据，所以它的数据布局有着很大的不同。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;1）聚簇索引中的每个叶子节点包含 primary key 的值，事务 ID 和回滚指针(rollback pointer)——用于事务和 MVCC，和余下的列(如 col2)。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;2）相对于 MyISAM，辅助索引与聚簇索引有很大的不同。InnoDB 的二级索引的叶子包含 primary key 的值，而不是行指针(row pointers)，这减小了移动数据或者数据页面分裂时维护二级索引的开销，因为 InnoDB 不需要更新索引的行指针。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;2、MyISAM 引擎方式索引图示&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.813953488372093&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgT0JL4BVF6MLv1jGDCTJGyKlU9CfZWkKBLibjkSS64brF9Q3sbIrZP6JTaFVvrohZGZga8DYdILx0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;774&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;MyISAM 不支持聚簇索引，索引中每一个叶子节点仅仅包含行号(row number)，且叶子节点按照 col1 的顺序存储。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;在 MyISAM 中，primary key 和其它索引没有什么区别。Primary key 仅仅只是一个叫做 PRIMARY 的唯一，非空的索引而已。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;好了，我们还是回到问题本身。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;我们其实可以得出这样一个&lt;span data-type=&quot;strong&quot;&gt;初步结论：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-origin=&quot;pm_code_preview&quot; lang=&quot;text&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Case1：select id from cities limit 1;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;因为 uniq_city_code 索引中包含 id 字段，此查询可以从 uniq_city_code 索引中直接取得数据，所以优化器选择走 uniq_city_code 索引；&lt;/span&gt;&lt;/p&gt;&lt;pre data-origin=&quot;pm_code_preview&quot; lang=&quot;text&quot;&gt;&lt;code data-type=&quot;codeline&quot;/&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Case2：select * from cities limit 1;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;此查询中 select * 选取了在 uniq_city_code 索引中不包含的列，所以无法使用 uniq_city_code 这个索引。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;为了验证一下我们刚刚得到的初步结论，我们来利用 Case3 验证一下。&lt;/span&gt;&lt;/p&gt;&lt;pre data-origin=&quot;pm_code_preview&quot; lang=&quot;text&quot;&gt;&lt;code data-type=&quot;codeline&quot;/&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Case3：select id, city_code from cities limit 1;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;执行结果：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.06269113149847094&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgT0JL4BVF6MLv1jGDCTJGyKw3HvNawwG6rk3b8ibbrASu8yz4g3gywTmyhOgeiciaFDFxUNfMdF3VXGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;654&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;按照上述的理论依据，Case1（查询 id）与 Case3（查询 id+city_code）执行应用的查询计划应该是一致的。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;通过验证实验我们可以确定一个结论：&lt;span data-type=&quot;strong&quot;&gt;Case1 的查询确实存在索引覆盖情况。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading3&quot; data-type=&quot;heading&quot;&gt;官方辅证&lt;/h2&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;我们再继续追问一下：&lt;span data-name=&quot;orange&quot; data-type=&quot;color&quot;&gt;为什么要用到索引覆盖呢？不用可不可以呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;我们先来看看 MySQL 官方的解释...&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.2141732283464567&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgT0JL4BVF6MLv1jGDCTJGyKFCHUVoZ834tp7LJHeWW1gdZgKw2VMtBnsyNqx1TO6K9RqM0EI4Ksew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;635&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;其实说了这么多，本质就是最后一句，&lt;span data-type=&quot;strong&quot;&gt;这样做可以使查询更快！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;好了，大家可以一起来思考下这个问题：&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span data-name=&quot;orange&quot; data-type=&quot;color&quot;&gt;“&lt;/span&gt;&lt;em data-type=&quot;italic&quot;&gt;&lt;span data-name=&quot;orange&quot; data-type=&quot;color&quot;&gt;既然主键索引包含所有数据列，那么使用主键索引一样可以做到索引覆盖，为什么优化器不选择使用主键索引？”&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;......&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;其实这个问题，就是典型的 MySQL 索引选取原则。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;MySQL 在做全表扫描时，MySQL 会调用 find_shortest_key() 来选取最短的索引来扫描。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;关于 find_shortest_key()函数的解释，我们来看下官方解释，如下所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.45498783454987834&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgT0JL4BVF6MLv1jGDCTJGyKjqzhbjhPZibsbtiayp2sNb6ribZAgB0iaqb3dt4EFD0mvv0fR48U7cqYGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;411&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;所以，上面大家一起思考的这个问题，答案就是：&lt;span data-type=&quot;strong&quot;&gt;索引长度不同，有多个可选索引时，MYSQL 会优先选择较短的索引。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;到现在，那我们可以对整个问题做个总结了：&lt;span data-type=&quot;strong&quot;&gt;因为辅助索引一定是主键索引的子集，从节约 IO 的角度，在全表扫描时优先选择辅助索引。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading4&quot; data-type=&quot;heading&quot;&gt;总结&lt;/h2&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;好了，最后我们一起来对整个分享做下总结吧。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;1）首先我们遇到一个查询问题，由于查询字段的不同导致我们的查询结果数据存在差异；&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;2）我们对问题进行追究，发现根据 select 的字段不同，MySQL 选取的索引策略不同，即结果数据不同；&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;3）对于是否存在索引覆盖问题，我们进行了 Case3 的验证，确认了存在索引覆盖的问题；&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;4）对于 MySQL 为什么会存在这样的索引选取原则，我们最终发现是辅助索引一定是主键索引的子集，从节约 IO 的角度，在&lt;span data-type=&quot;strong&quot;&gt;全表扫描&lt;/span&gt;时优先选择辅助索引。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;重点提炼：&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;不同引擎对于查询实现方式的不同、索引覆盖、MySQL 索引选取原则。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;不同引擎对于查询实现方式的不同、索引覆盖、MySQL 索引选取原则。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;不同引擎对于查询实现方式的不同、索引覆盖、MySQL 索引选取原则。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;重要的问题说三遍，哈哈哈~&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;其实踩坑，也是一种成长！&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;其实面对任何问题，都不要一上来就急于给出结论，可以尝试多做些深入分析，了解本质问题之后再考虑解决办法进行解决，希望大家能够掌握问题分析以及解决的能力，去触类旁通，而不是仅仅了解一招一式，盲目照搬。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.46449704142011833&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z2bVaFK6CgT0JL4BVF6MLv1jGDCTJGyKmbwUws3m4pYKGdadIdRQAXMFfNMZroxaDDIuRyvVgNzCsuxx5aNVoA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;676&quot;/&gt;&lt;/p&gt;&lt;p data-pm-slice=&quot;1 1 []&quot;&gt;&lt;/p&gt;&lt;p data-pm-slice=&quot;1 1 []&quot;&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;作者：架构精进之路，专注软件架构研究，技术学习与个人成长，关注并私信我回复“01”，送你一份程序员成长进阶大礼包，欢迎勾搭。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;往期热文推荐：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98311&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgTqLjdQBs7fV8zqHRaQhA2ibia13fFn6ibS5qr5PpmZoxd8nlhAyJu7d1CjLicAruicOEb7uxibEGM476xg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;87502&quot;&gt;&lt;p&gt;&lt;span&gt;「技术架构精进」专注架构研究，技术分享&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Thanks for reading!&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dbbbfe4a0cbe8fd807b338cc84d8ca22</guid>
<title>探索 Table 组件虚拟化</title>
<link>https://toutiao.io/k/sothdok</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;列表及表格的虚拟优化不是个新鲜的课题，近期，团队发现：业界对于 table 虚拟化竟然没有一个相对一劳永逸的解决方案。这是为什么？又该如何解决？在本文中，我们会循序渐进的介绍在 React+AntDesign 技术栈下，团队内部对 Table 组件虚拟化的不同实践思路，分析可能遇到的难点问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;虚拟化问题阐述&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在列表页、瀑布流、Select 组件中，我们都有可能遇到渲染大数量级列表的场景。在过去，我们总结了一套卓有成效的办法：对于列表，我们通过计算，保证在滚动视窗时，每次只渲染部分元素。这样既减少了首屏压力，也保证长时间加载也不会有更多的性能负担，可以满足上述大部分场景的高性能优化需求。具体做法上，我们利用已知的固定行高和滚动偏移量，计算出滚动到的表格行索引，只渲染出有限视窗内所需要的元素，，并对列表进行相应设置，简述过程如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;计算当前可见区域起始数据的 startIndex&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;计算当前可见区域结束数据的 endIndex&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;计算当前可见区域的数据，并渲染到页面中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;计算 startIndex 对应的数据在整个列表中的偏移位置 startOffset，并设置到列表上&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;计算 endIndex 对应的数据相对于可滚动区域最底部的偏移位置 endOffset，并设置到列表上&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.1092896174863387&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9egR3Y3zQbLecpKVOzHOfJ4D6q3XBzGO8o0VXy1dzwwhVu4fxpd3tsvC5RF4xE8ibGhrBib7AqUm1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;549&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一方案是广泛被大多数开发人员探讨的。我推荐参考&lt;span&gt;浅说虚拟列表的实现原理&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;，他对问题的思路，实现，均有比较详尽的描述。如今，我们的场景来到了 AntDesign 的 Table 组件。我们面对十分类似的问题：业务当中，&lt;strong&gt;Table &lt;/strong&gt;涉及&lt;strong&gt;1000+行 &lt;/strong&gt;&amp;amp; &lt;strong&gt;100+列&lt;/strong&gt;数量级别的渲染时，由于单元格内也具有一定的复杂逻辑，因此页面渲染时长往往需要卡顿 &lt;strong&gt;5000ms &lt;/strong&gt;前后的时间。这显然是不能够接受的。实际上，从长列表到 Table 组件，我们的列表无非是从一维轴线上升到了二维平面。因此，所谓表格虚拟化，无非就是希望表格可以实现：在兼容 &lt;strong&gt;Table&lt;/strong&gt; 现有功能的情况下，实现表格只渲染视窗平面内容，对于视窗外的行、列予以隐藏。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;整理现状&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;AntDesign&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们内部的 React + umi + AntDesign 技术栈是目前前端界较为常见的一种架构基础。AntD 作为业界 react 常用组件库，它提供的 Table 组件，能够方便的帮我们解决诸多常见需求，包括并不仅限于：行选择、行展开、行筛选、数据分页、列固定... 目前 AntDesign 有 AntD@3.26 和 AntD@4.11 两大版本，后者经过一定的重构和优化，是官方推荐的最新内容。AntDesign3 文档中已经删除了对于虚拟化支持的 demo（实际也可以使用），而在 AntDesign4 文档中，能看到官方推荐用户以接入 react-window 的方式解决虚拟化表格问题。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4941360437842064&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9egR3Y3zQbLecpKVOzHOfJ2ptbp61ibickibAqVaGd48SiaxYOcNFV5zx0zrF1ociabBalYrmIrgGMiaSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1279&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从官方的 Demo 来看，AntD 提供了一个 components 属性，通过传入一个对象，在其 body 属性中给到一个 ReactWindow 提供的虚拟化组件，以实现需求&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; ...&lt;br/&gt; &lt;span&gt;// VariableSizeGrid is a component provided by react-window&lt;/span&gt;&lt;br/&gt; &lt;span&gt;const&lt;/span&gt; renderVirtualList = &lt;span&gt;(&lt;span&gt;rawData, { scrollbarSize, ref, onScroll }&lt;/span&gt;)=&amp;gt;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;VariableSizeGrid&lt;/span&gt;&lt;br/&gt;       {&lt;span&gt;...props&lt;/span&gt;}&lt;br/&gt;     /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; ...&lt;br/&gt; &amp;lt;Table&lt;br/&gt;    {...props}&lt;br/&gt;    className=&lt;span&gt;&quot;virtual-table&quot;&lt;/span&gt;&lt;br/&gt;    columns={mergedColumns}&lt;br/&gt;    pagination={&lt;span&gt;false&lt;/span&gt;}&lt;br/&gt;    components={{&lt;br/&gt;      // overwrite the body set by AntD&lt;br/&gt;      body: renderVirtualList,&lt;br/&gt;    }}&lt;br/&gt;  /&amp;gt;&lt;br/&gt;  ...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ReactWindow&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;react-window 是一个广受欢迎的用于解决表格虚拟化问题的开源代码库，它产出了不同特性的虚拟化组件，以便用户聚焦不同虚拟场景的问题解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;react-window 的原理并不复杂，主要就是本文在虚拟化问题阐述中对于虚拟化要求内容的实现。主要是通过监控 onScroll，动态调整表格横轴偏移量，节选适当数量的部分数据，进行可视区内容渲染。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他的前身是 react-virtualized。经过了重构和升级，作者对 table 和 list 两种不同的场景做了更好的抽象，通过重用共通部分的逻辑，实现了更好的性能，代码打包大小也减少到了原先的 20%。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;接入时遇到的问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看上去，AntD 已经给出了一套虚拟化方案。但稍稍深入调查不难发现，在 Github 的 Issue 中，对于官方推荐方案，用户反馈则不甚理想。比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在问题&lt;span&gt;#21022&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;中提出，使用 AntD3 后，展开、多选等功能点缺失。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在问题&lt;span&gt;#20339&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;中提出，使用 AntD4 后，大多数表格功能点都存在缺失。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对上述问题，官方均回复以用户自行解决，因此：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照 &lt;strong&gt;AntD&lt;/strong&gt; 文档使用虚拟化进行配置，虽然可以一定程度实现虚拟化，但会引起多处表格功能缺失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是目前我们主要亟待解决的问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;rc-table&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于官方没有给出很好的虚拟化方案，我们只好深入了解 AntD 内部的架构，寻找问题的切入点。经阅读代码可以了解，在 4.11 的 AntD/Table 代码架构简述如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7363083164300203&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9egR3Y3zQbLecpKVOzHOfJLNrWMoBTl2hqBko8yOdwtjMDcXkRkKIthcaTUYtdkWdlEZrnnJYYYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;986&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在 AntDesign/Table 中：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;初始化表格大小和行列内容&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;初步整理事件和数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;排序、分页、过滤等功能对 data 和 column 的计算逻辑&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用 rc-table 依赖&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在 rc-table 中：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;注册各类行列单元格事件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;完成各种样式需求，如列固定，行展开&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;完成渲染&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，我们可以了解到，AntD 架构本身其实已经对表格逻辑进行了一定程度的划分，与 data 数据的顺序及内容无关的逻辑，已经被单独抽象到了 rc-table 这个库中。大致上我们可以理解为下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4080604534005038&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9egR3Y3zQbLecpKVOzHOfJuHuR82wuHZTEnmRw4KDffuEub3PcZS4CyicvdNpiczXor2IxzAcENx8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;794&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也必须要想清楚：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这三层逻辑，我们分别对他们做保留，改造，还是替换？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如保留，如何解决引入虚拟化逻辑后，虚拟化逻辑对现有框架造成的影响？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如不保留，新的框架如何选择？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;组内方案陈列&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目组内对于 table 的虚拟化工作产生了多种不同思路：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;方案 1：基于 rc-table 不依赖 react-window 和 AntD 实现虚拟化&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在不同业务中，我们需要的表格组件功能点并不一致，极端场景下，我们可能只需要使用少量 AntD 的 Feature，且定制化较高。因此我们可以考虑放弃使用 AntD，直接使用 rc-table 并做一定改造。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实现方式：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;fork 一份稳定版本 rc-table 放入代码库内&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;按照虚拟化原理对 rc-table 完成必要改造&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自己实现排序、选择、列固定等上层功能点&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9362416107382551&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9egR3Y3zQbLecpKVOzHOfJXIichXoXUz3HDp4T1HTicibfW4wdqFPWbgibBBh1bgFia4z3c5Y3RhgeXhg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;596&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;方案优劣：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;丢失了 AntD 的功能基础。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不再需要自己实现基础的表格呈现，这部分有 rc-table 完成，我们只需要针对虚拟化对滚动事件做少量改造。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;外部功能 feature 方便自定制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;方案 2：AntD 中截取显示数据，手动销毁表格外 dom，手动创建占位符。&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当业务重度依赖 AntD 的各个功能，不能直接移除 AntD。我们只能保留整体框架，找到切入点做部分改造。所以改造 antD 内表格 scroll 事件，使用新的 onScroll 逻辑：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;判定 dom 行位置，计算 index&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;setState 动作完成后，手动销毁超出视窗的 dom 内容，同时创建等高空白区域，以维护滚动条位置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对 data 数据内容进行裁切并更新，保证视窗内数据的正确性。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该逻辑下只修改了 AntD 传入的 data 内容，其余操作均基于 jsdom 手动完成，影响面小，完成度高。但需要仔细测试对各个表格功能点的影响。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8609154929577465&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9egR3Y3zQbLecpKVOzHOfJvvOA4jYGoNqDUmG9RMP3ZBGSzUfJ0diasWXFKveBmU9HHHm0jWNSiaLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1136&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;方案优劣：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;需要小心处理改方案对列固定、行展开等特性的影响。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于无法提前获取行高，暂不支持直接定位，等价方案是需要先搜索到对应的数据，然后将结果装入 InfinityTable&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;向前兼容 Antd Table 的配置参数，只需要新增少数 props，改造成本极低&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;直接操控 dom，开发工作除了数据截取，其余大部分不依赖 AntD/rcTable 代码，性能有保障。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;方案 3：重新实现表格&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当项目定制化程度较高时，考虑直接放弃 antd。方案 3 保留了 AntD 的 props 定义，以保证从 AntD 迁移时的便利性，随后利用 react-table 完成大多数功能，虚拟化部分借助了 react-window，底层开发了全新的具有虚拟化功能的基础表格。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.18125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9egR3Y3zQbLecpKVOzHOfJgibOaAODEfj90IzK7cvT20NWWcyB9mGnzM8qRhIhn2klibmlh0YrGb2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方案中引入了 github 上炙手可热的开源 react hook 框架 react-table，这是个数据逻辑 hook 框架，因为排序、选择、等数据逻辑是具有相似性的，所以没必要重写，它帮助节省了数据处理的成本，同时也没有干涉 UI 及虚拟化工作。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;方案优劣：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;表格基础实现的成本高，基础 table 需要结合 react-table 的 api 重新实现，遇到各种坑都需要自己踩&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;深入改造，重构程度高，方便后续做任何扩展，方便性能优化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;利用开源产品实现原 AntD 的开发内容，节省一定成本&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;改造重点问题复盘&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;空白闪烁&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5465686274509803&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9egR3Y3zQbLecpKVOzHOfJMv2K0dDPCA72uChibjxR65HO5k7aD5E4sFUfEc8oPdtyFNgG2Vj8s2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;816&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 react-window 的 README 中，可以看到对此问题的描述。当应用虚拟化后，过快的 scroll 动作会导致占位符尚未更新，只能看到空白内容，需要等少量时间后才加载。当连续快速滚动表格时，呈现不断闪烁空白内容的状态。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;问题解决：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;目前没有较好解决办法，增加预载区大小，且优化单元格渲染内容，可以减缓问题严重性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有同学提出通过监控 scroll 时候的 speed 动态调整预载区大小，不失为一个没实践的思路。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;单元格自适应换行&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当单元格文本内容较长时，希望高度可以自适应。此需求乍一看似乎可以利用 react-window 的不定高组件解决，但实际上，该组件需要提供一个高度函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Returns the size of a item in the direction being windowed.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// For vertical lists, this is the row height.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// For horizontal lists, this is the column width.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;itemSize&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;index: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; number&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当文本变化时，我们也需要 render 后才能获取每一行的高度，所以这个 api 并没有想象中美好。该问题还是必须借助二次渲染后，通过 ref 拿 dom 节点才能解决，但这样会拖慢性能，因此考量后，对此方案不予支持&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;列固定&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9egR3Y3zQbLecpKVOzHOfJ6QNOicOVsNLObc7eUGGaCdIIjspibVg9cKxRvVzwSJT95scFaJu99UzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.668041237113402&quot; data-w=&quot;970&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在方案 3 中，由于使用了 div 的 flex 排版而不是原生 table，为了实现列固定时，我们需要使用三个 table 来做固定效果，因此滚动时，我们需要同时改变多个表格的 scrollTop 以及其数据截取。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;问题解决&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可以使用一个 state 同步多个 table 之间的 scrollTop，但这种实现有可能因为性能，产生表格渲染的先后，进而产生三张表对不齐的问题。（AntD 的 Header 与 body 对齐本身也有此问题）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AntD 不区分三个 table，而是在一个 table 内利用原生 tr/td，以及 css 的 sticky 特性，部分回避了该问题，但没有解决的很好，fixedcolumn 存在的场景下，header 和 body 的同步依旧存有类似问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以将三个表格改为一个表格，然后利用性能最好的 3Dtransform 来解决此问题。下方推荐的开源产品 rsuite-table 比较好的通过此方案解决了问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;列虚拟化&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;问题描述：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;由于目前方案专注于行数据量大的场景，因此当遇到表格列数据量大的场景，依旧存在性能问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果我们引入 react-window 的 Grid 组件进行列虚拟化，会需要兼容子列，列固定等功能，实际实现比想象中复杂。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;问题解决：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;过多的列从产品设计来说是不合理的。建议从产品层面改善数据展示问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;目前暂不支持列虚拟化。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;开源表格组件推荐&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于内部资源不能外部分享，所以没有办法把上述方案的产品对外放出。如果您希望使用带有虚拟化功能的表格，但并不希望做任何开发工作，这里推荐您几款比较不错的开源产品&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;rsuite-table&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;http://rsuite.github.io/rsuite-table/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;虚拟化及表格性能优秀，大多数功能点完备&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表头功能薄弱，没有列筛选，没有拖拽改变列宽&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;react-base-table&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;https://github.com/Autodesk/react-base-table&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自带虚拟化，基本功能齐全，其他功能与 AntD 相比有一定差距&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Table 组件虚拟化从原理上来说，是比较单纯的。即便不借助 react-window，我们也看到了同学们每个人都可以用自己的思路实现相似的功能需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之所以产生方案丛生无法统一的现状，主要还是由于不同项目对表格库的要求不同：有的项目需要低成本，有的项目要求兼容各种不同 feature，有的项目有着繁重的历史包袱。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而一个新的、面面俱到的 Table 库，又会有替换成本、稳定性风险等问题。因此，因地制宜地对自己项目进行改造，实现一套适合自己项目的虚拟化方案反而是最快速的，最被大家接受的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，本文从三个不同场景出发，总结了视野可及范围内，大家解决该问题的不同思路。对于希望开箱即用的同学，也给出了几个横向比较下来值得推荐的开源产品。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓授人以鱼不如授人以渔，希望文中探讨的内容，或多或少在提升表格性能及表格虚拟化方向，能给与读者一些启发，为字节系产品的用户带来更快更好的体验。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;&lt;em&gt;https://github.com/dwqs/blog/issues/70#&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;&lt;em&gt;https://github.com/ant-design/ant-design/issues/21022&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;&lt;em&gt;https://github.com/ant-design/ant-design/issues/20339&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>70288cc26e06cd8e4709bc9e99d3825c</guid>
<title>再谈 synchronized 锁升级</title>
<link>https://toutiao.io/k/8qya0wq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwMTgzOTQ0Ng==&amp;amp;mid=2247485128&amp;amp;idx=1&amp;amp;sn=7fc733a5b958ee4db00879c1e51fe80b&amp;amp;chksm=96e680f1a19109e79b6184e2792da40bf3e40c389f6394dec0f46c8156fcc324c858650b3a3b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;图文详解Java对象内存布局&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;图文详解Java对象内存布局&lt;/a&gt;这篇文章中，在研究对象头时我们了解了&lt;code&gt;synchronized&lt;/code&gt;锁升级的过程，由于篇幅有限，对锁升级的过程介绍的比较简略，本文在上一篇的基础上，来详细研究一下锁升级的过程以及各个状态下锁的原理。本文结构如下：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;1 无锁&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上一篇文章中，我们提到过 jvm会有4秒的偏向锁开启的延迟时间，在这个偏向延迟内对象处于为无锁态。如果关闭偏向锁启动延迟、或是经过4秒且没有线程竞争对象的锁，那么对象会进入&lt;strong&gt;无锁可偏向&lt;/strong&gt;状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;准确来说，无锁可偏向状态应该叫做&lt;strong&gt;匿名偏向&lt;/strong&gt;(&lt;code&gt;Anonymously biased&lt;/code&gt;)状态，因为这时对象的&lt;code&gt;mark word&lt;/code&gt;中后三位已经是&lt;code&gt;101&lt;/code&gt;，但是&lt;code&gt;threadId&lt;/code&gt;指针部分仍然全部为0，它还没有向任何线程偏向。综上所述，对象在刚被创建时，根据jvm的配置对象可能会处于 &lt;strong&gt;无锁&lt;/strong&gt; 或 &lt;strong&gt;匿名偏向&lt;/strong&gt; 两个状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，如果在jvm的参数中关闭偏向锁，那么直到有线程获取这个锁对象之前，会一直处于无锁不可偏向状态。修改jvm启动参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-XX:-UseBiasedLocking&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;延迟5s后打印对象内存布局：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;    User user=&lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;    TimeUnit.SECONDS.sleep(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;    System.out.println(ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.18438003220611915&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5jPV9kGeCzrztTVTTCywic2JYv25iaO8V9UShudOJXAib7mphNQAgicORLeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1242&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，即使经过一定的启动延时，对象一直处于&lt;code&gt;001&lt;/code&gt;无锁不可偏向状态。大家可能会有疑问，在无锁状态下，为什么要存在一个不可偏向状态呢？通过查阅资料得到的解释是：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;JVM内部的代码有很多地方也用到了synchronized，明确在这些地方存在线程的竞争，如果还需要从偏向状态再逐步升级，会带来额外的性能损耗，所以JVM设置了一个偏向锁的启动延迟，来降低性能损耗&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，在无锁不可偏向状态下，如果有线程试图获取锁，那么将跳过升级偏向锁的过程，直接使用轻量级锁。使用代码进行验证：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//-XX:-UseBiasedLocking&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;    User user=&lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;    &lt;span&gt;synchronized&lt;/span&gt; (user){&lt;br/&gt;        System.out.println(ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看结果可以看到，在关闭偏向锁情况下使用&lt;code&gt;synchronized&lt;/code&gt;，锁会直接升级为轻量级锁（&lt;code&gt;00&lt;/code&gt;状态）:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1750599520383693&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5jjjeRg5KL24eT7C96TJ9GNf6QlK8BLQibZKxQoW22h3OBfGKrRl3Gg8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1251&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在目前的基础上，可以用流程图概括上面的过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.41514726507713884&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5jmo5xf4aP9aJpwibvYandh58pAMCU5eaAMrWEMsCG2ibN4SQic2iaAvonPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;713&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;额外注意一点就是匿名偏向状态下，如果调用系统的&lt;code&gt;hashCode()&lt;/code&gt;方法，会使对象回到无锁态，并在&lt;code&gt;markword&lt;/code&gt;中写入&lt;code&gt;hashCode&lt;/code&gt;。并且在这个状态下，如果有线程尝试获取锁，会直接从无锁升级到轻量级锁，不会再升级为偏向锁。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2 偏向锁&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.1 偏向锁原理&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;匿名偏向状态是偏向锁的初始状态，在这个状态下第一个试图获取该对象的锁的线程，会使用CAS操作（汇编命令&lt;code&gt;CMPXCHG&lt;/code&gt;）尝试将自己的&lt;code&gt;threadID&lt;/code&gt;写入对象头的&lt;code&gt;mark word&lt;/code&gt;中，使匿名偏向状态升级为&lt;strong&gt;已偏向&lt;/strong&gt;（Biased）的偏向锁状态。在已偏向状态下，线程指针&lt;code&gt;threadID&lt;/code&gt;非空，且偏向锁的时间戳&lt;code&gt;epoch&lt;/code&gt;为有效值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果之后有线程再次尝试获取锁时，需要检查&lt;code&gt;mark word&lt;/code&gt;中存储的&lt;code&gt;threadID&lt;/code&gt;是否与自己相同即可，如果相同那么表示当前线程已经获得了对象的锁，不需要再使用CAS操作来进行加锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果&lt;code&gt;mark word&lt;/code&gt;中存储的&lt;code&gt;threadID&lt;/code&gt;与当前线程不同，那么将执行CAS操作，试图将当前线程的ID替换&lt;code&gt;mark word&lt;/code&gt;中的&lt;code&gt;threadID&lt;/code&gt;。只有当对象处于下面两种状态中时，才可以执行成功：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对象处于匿名偏向状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对象处于&lt;strong&gt;可重偏向&lt;/strong&gt;（Rebiasable）状态，新线程可使用CAS将&lt;code&gt;threadID&lt;/code&gt;指向自己&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果对象不处于上面两个状态，说明锁存在线程竞争，在CAS替换失败后会执行&lt;strong&gt;偏向锁撤销&lt;/strong&gt;操作。偏向锁的撤销需要等待全局安全点&lt;code&gt;Safe Point&lt;/code&gt;（安全点是 jvm为了保证在垃圾回收的过程中引用关系不会发生变化设置的安全状态，在这个状态上会暂停所有线程工作），在这个安全点会挂起获得偏向锁的线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在暂停线程后，会通过遍历当前jvm的所有线程的方式，检查持有偏向锁的线程状态是否存活：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果线程还存活，且线程正在执行同步代码块中的代码，则升级为轻量级锁&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果持有偏向锁的线程未存活，或者持有偏向锁的线程未在执行同步代码块中的代码，则进行校验是否允许重偏向：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;不允许重偏向，则撤销偏向锁，将&lt;code&gt;mark word&lt;/code&gt;升级为轻量级锁，进行CAS竞争锁&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;允许重偏向，设置为匿名偏向锁状态，CAS将偏向锁重新指向新线程&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完成上面的操作后，唤醒暂停的线程，从安全点继续执行代码。可以使用流程图总结上面的过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48413897280966767&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5jxOd4rmDHPkeutoGa7kiccr9ty2pXJvN12VNJVw71VedAvUjptswF6Ig/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1324&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.2 偏向锁升级&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的过程中，我们已经知道了匿名偏向状态可以变为无锁态或升级为偏向锁，接下来看一下偏向锁的其他状态的改变&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;    User user=&lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;    &lt;span&gt;synchronized&lt;/span&gt; (user){&lt;br/&gt;        System.out.println(ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;    }&lt;br/&gt;    Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (user) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;--THREAD--:&quot;&lt;/span&gt;+ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;    thread.start();&lt;br/&gt;    thread.join();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;--END--:&quot;&lt;/span&gt;+ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看内存布局，偏向锁升级为轻量级锁，在执行完成同步代码后释放锁，变为无锁不可偏向状态：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.599037690457097&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5j3MTc44vCcpgynA4XecCCia1t0Gol23nNel1f5UFDPW1ZghJYNHVnCYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1247&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;    User user=&lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;    Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (user) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;--THREAD1--:&quot;&lt;/span&gt; + ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                user.wait(&lt;span&gt;2000&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;--THREAD END--:&quot;&lt;/span&gt; + ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;    thread.start();&lt;br/&gt;    thread.join();&lt;br/&gt;    TimeUnit.SECONDS.sleep(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;    System.out.println(ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看内存布局，可以看到在调用了对象的&lt;code&gt;wait()&lt;/code&gt;方法后，直接从偏向锁升级成了重量级锁，并在锁释放后变为无锁态：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5888888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5jc32GAdd6pNiapkDTC6FZbfBzwZOhuhDToYb0X8GoKCNEvVm68dLjgow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1260&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是因为&lt;code&gt;wait()&lt;/code&gt;方法调用过程中依赖于重量级锁中与对象关联的&lt;code&gt;monitor&lt;/code&gt;，在调用&lt;code&gt;wait()&lt;/code&gt;方法后&lt;code&gt;monitor&lt;/code&gt;会把线程变为&lt;code&gt;WAITING&lt;/code&gt;状态，所以才会强制升级为重量级锁。除此之外，调用&lt;code&gt;hashCode&lt;/code&gt;方法时也会使偏向锁直接升级为重量级锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面分析的基础上，再加上我们上一篇中讲到的轻量级锁升级到重量级锁的知识，就可以对上面的流程图进行完善了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3389121338912134&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5jybUxYtFCZB3sBx3U9avuy8xU9hYOAiasscQeeub1mGsb5UEz7Fh9mhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;956&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.3 批量重偏向&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在未禁用偏向锁的情况下，当一个线程建立了大量对象，并且对它们执行完同步操作解锁后，所有对象处于偏向锁状态，此时若再来另一个线程也尝试获取这些对象的锁，就会导偏向锁的&lt;strong&gt;批量重偏向&lt;/strong&gt;（Bulk Rebias）。当触发批量重偏向后，第一个线程结束同步操作后的锁对象当再被同步访问时会被重置为可重偏向状态，以便允许快速重偏向，这样能够减少撤销偏向锁再升级为轻量级锁的性能消耗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先看一下和偏向锁有关的参数，修改jvm启动参数，使用下面的命令可以在项目启动时打印jvm的默认参数值：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-XX:+PrintFlagsFinal&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要关注的属性有下面3个：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.10104166666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5jG3sG6sK69bbh7WrQybuAoVbrh5tsDgObnOMpxVCqSYP8NOrjBYqoNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;BiasedLockingBulkRebiasThreshold&lt;/code&gt;：偏向锁批量重偏向阈值，默认为20次&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;BiasedLockingBulkRevokeThreshold&lt;/code&gt;：偏向锁批量撤销阈值，默认为40次&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;BiasedLockingDecayTime&lt;/code&gt;：重置计数的延迟时间，默认值为25000毫秒（即25秒）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;批量重偏向是以&lt;code&gt;class&lt;/code&gt;而不是对象为单位的，每个&lt;code&gt;class&lt;/code&gt;会维护一个偏向锁的撤销计数器，每当该&lt;code&gt;class&lt;/code&gt;的对象发生偏向锁的撤销时，该计数器会加一，当这个值达到默认阈值20时，jvm就会认为这个锁对象不再适合原线程，因此进行批量重偏向。而距离上次批量重偏向的25秒内，如果撤销计数达到40，就会发生批量撤销，如果超过25秒，那么就会重置在[20, 40)内的计数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这段理论是不是听上去有些难理解，没关系，我们先用代码验证批量重偏向的过程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Thread t1,t2;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{      &lt;br/&gt;    TimeUnit.SECONDS.sleep(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;    List&amp;lt;Object&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;40&lt;/span&gt;; i++) {&lt;br/&gt;        list.add(&lt;span&gt;new&lt;/span&gt; Object());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    t1 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; list.size(); i++) {&lt;br/&gt;            &lt;span&gt;synchronized&lt;/span&gt; (list.get(i)) {&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        LockSupport.unpark(t2);&lt;br/&gt;    });&lt;br/&gt;    t2 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;        LockSupport.park();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;30&lt;/span&gt;; i++) {&lt;br/&gt;            Object o = list.get(i);&lt;br/&gt;            &lt;span&gt;synchronized&lt;/span&gt; (o) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (i == &lt;span&gt;18&lt;/span&gt; || i == &lt;span&gt;19&lt;/span&gt;) {&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;THREAD-2 Object&quot;&lt;/span&gt;+(i+&lt;span&gt;1&lt;/span&gt;)+&lt;span&gt;&quot;:&quot;&lt;/span&gt;+ClassLayout.parseInstance(o).toPrintable());&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;    t1.start();&lt;br/&gt;    t2.start();&lt;br/&gt;    t2.join();&lt;br/&gt;&lt;br/&gt;    TimeUnit.SECONDS.sleep(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;Object19:&quot;&lt;/span&gt;+ClassLayout.parseInstance(list.get(&lt;span&gt;18&lt;/span&gt;)).toPrintable());&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;Object20:&quot;&lt;/span&gt;+ClassLayout.parseInstance(list.get(&lt;span&gt;19&lt;/span&gt;)).toPrintable());&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;Object30:&quot;&lt;/span&gt;+ClassLayout.parseInstance(list.get(&lt;span&gt;29&lt;/span&gt;)).toPrintable());&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;Object31:&quot;&lt;/span&gt;+ClassLayout.parseInstance(list.get(&lt;span&gt;30&lt;/span&gt;)).toPrintable());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析上面的代码，当线程&lt;code&gt;t1&lt;/code&gt;运行结束后，数组中所有对象的锁都偏向&lt;code&gt;t1&lt;/code&gt;，然后&lt;code&gt;t1&lt;/code&gt;唤醒被挂起的线程&lt;code&gt;t2&lt;/code&gt;，线程&lt;code&gt;t2&lt;/code&gt;尝试获取前30个对象的锁。我们打印线程&lt;code&gt;t2&lt;/code&gt;获取到的第19和第20个对象的锁状态：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.38735177865612647&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5j0o9znuRpM2D4JzgDv84C6iaD13LRVSGuOWcEr7jC4kzVxwLFMwoJ00g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1265&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程&lt;code&gt;t2&lt;/code&gt;在访问前19个对象时对象的偏向锁会升级到轻量级锁，在访问后11个对象（下标19-29）时，因为偏向锁撤销次数达到了20，会触发批量重偏向，将锁的状态变为偏向线程&lt;code&gt;t2&lt;/code&gt;。在全部线程结束后，再次查看第19、20、30、31个对象锁的状态：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8055555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5j6ziaZvshLMiaicbesTTPIlpVPHhpw8TZzmbhSf3Nxb84PPibVQohWXuVzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1008&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程&lt;code&gt;t2&lt;/code&gt;结束后，第1-19的对象释放轻量级锁变为无锁不可偏向状态，第20-30的对象状态为偏向锁、但从偏向&lt;code&gt;t1&lt;/code&gt;改为偏向&lt;code&gt;t2&lt;/code&gt;，第31-40的对象因为没有被线程&lt;code&gt;t2&lt;/code&gt;访问所以保持偏向线程&lt;code&gt;t1&lt;/code&gt;不变。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.4 批量撤销&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在多线程竞争激烈的状况下，使用偏向锁将会导致性能降低，因此产生了批量撤销机制，接下来使用代码进行测试：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Thread t1, t2, t3;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;    TimeUnit.SECONDS.sleep(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    List&amp;lt;Object&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;40&lt;/span&gt;; i++) {&lt;br/&gt;        list.add(&lt;span&gt;new&lt;/span&gt; Object());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    t1 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; list.size(); i++) {&lt;br/&gt;            &lt;span&gt;synchronized&lt;/span&gt; (list.get(i)) {&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        LockSupport.unpark(t2);&lt;br/&gt;    });&lt;br/&gt;    t2 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;        LockSupport.park();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; list.size(); i++) {&lt;br/&gt;            Object o = list.get(i);&lt;br/&gt;            &lt;span&gt;synchronized&lt;/span&gt; (o) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (i == &lt;span&gt;18&lt;/span&gt; || i == &lt;span&gt;19&lt;/span&gt;) {&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;THREAD-2 Object&quot;&lt;/span&gt;+(i+&lt;span&gt;1&lt;/span&gt;)+&lt;span&gt;&quot;:&quot;&lt;/span&gt;+ClassLayout.parseInstance(o).toPrintable());&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        LockSupport.unpark(t3);&lt;br/&gt;    });&lt;br/&gt;    t3 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;        LockSupport.park();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; list.size(); i++) {&lt;br/&gt;            Object o = list.get(i);&lt;br/&gt;            &lt;span&gt;synchronized&lt;/span&gt; (o) {&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;THREAD-3 Object&quot;&lt;/span&gt;+(i+&lt;span&gt;1&lt;/span&gt;)+&lt;span&gt;&quot;:&quot;&lt;/span&gt;+ClassLayout.parseInstance(o).toPrintable());&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    t1.start();&lt;br/&gt;    t2.start();&lt;br/&gt;    t3.start();&lt;br/&gt;    t3.join();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;New: &quot;&lt;/span&gt;+ClassLayout.parseInstance(&lt;span&gt;new&lt;/span&gt; Object()).toPrintable());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对上面的运行流程进行分析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程&lt;code&gt;t1&lt;/code&gt;中，第1-40的锁对象状态变为偏向锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程&lt;code&gt;t2&lt;/code&gt;中，第1-19的锁对象撤销偏向锁升级为轻量级锁，然后对第20-40的对象进行批量重偏向&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程&lt;code&gt;t3&lt;/code&gt;中，首先直接对第1-19个对象竞争轻量级锁，而从第20个对象开始往后的对象不会再次进行批量重偏向，因此第20-39的对象进行偏向锁撤销升级为轻量级锁，这时&lt;code&gt;t2&lt;/code&gt;和&lt;code&gt;t3&lt;/code&gt;线程一共执行了40次的锁撤销，触发锁的批量撤销机制，对偏向锁进行撤销置为轻量级锁&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一下在3个线程都结束后创建的新对象：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.20449077786688052&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5jSW0ia3q8FD846WBAEzsxAURqAyNvOrT4IgXhjJQCjdGWxxP9R6jaR1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1247&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，创建的新对象为无锁不可偏向状态&lt;code&gt;001&lt;/code&gt;，说明当类触发了批量撤销机制后，jvm会禁用该类创建对象时的可偏向性，该类新创建的对象全部为无锁不可偏向状态。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.5 总结&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;偏向锁通过消除资源无竞争情况下的同步原语，提高了程序在&lt;strong&gt;单线程&lt;/strong&gt;下访问同步资源的运行性能，但是当出现多个线程竞争时，就会撤销偏向锁、升级为轻量级锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们的应用系统是高并发、并且代码中同步资源一直是被多线程访问的，那么撤销偏向锁这一步就显得多余，偏向锁撤销时进入&lt;code&gt;Safe Point&lt;/code&gt;产生&lt;code&gt;STW&lt;/code&gt;的现象应该是被极力避免的，这时应该通过禁用偏向锁来减少性能上的损耗。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3 轻量级锁&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.1 轻量级锁原理&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、在代码访问同步资源时，如果锁对象处于无锁不可偏向状态，jvm首先将在当前线程的栈帧中创建一条锁记录（&lt;code&gt;lock record&lt;/code&gt;），用于存放：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;displaced mark word&lt;/code&gt;（置换标记字）：存放锁对象当前的&lt;code&gt;mark word&lt;/code&gt;的拷贝&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;owner&lt;/code&gt;指针：指向当前的锁对象的指针，在拷贝&lt;code&gt;mark word&lt;/code&gt;阶段暂时不会处理它&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.37664473684210525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5jedw06lQFqRtpKZrm3x4Wo2oz7FdIbEagtRpY63uzRsCqScbsZ4mZbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;608&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、在拷贝&lt;code&gt;mark word&lt;/code&gt;完成后，首先会挂起线程，jvm使用CAS操作尝试将对象的 &lt;code&gt;mark word&lt;/code&gt; 中的 &lt;code&gt;lock record&lt;/code&gt; 指针指向栈帧中的锁记录，并将锁记录中的&lt;code&gt;owner&lt;/code&gt;指针指向锁对象的&lt;code&gt;mark word&lt;/code&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果CAS替换成功，表示竞争锁对象成功，则将锁标志位设置成 &lt;code&gt;00&lt;/code&gt;，表示对象处于轻量级锁状态，执行同步代码中的操作&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3958691910499139&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5jIgcCxmWhWe7SGiaqLiaicg7jR5PMB12wPCHpZrGFRPfUKJibnLRNG20KUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;581&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果CAS替换失败，则判断当前对象的&lt;code&gt;mark word&lt;/code&gt;是否指向当前线程的栈帧：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果是则表示当前线程已经持有对象的锁，执行的是&lt;code&gt;synchronized&lt;/code&gt;的锁重入过程，可以直接执行同步代码块&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;否则说明该其他线程已经持有了该对象的锁，如果在自旋一定次数后仍未获得锁，那么轻量级锁需要升级为重量级锁，将锁标志位变成&lt;code&gt;10&lt;/code&gt;，后面等待的线程将会进入阻塞状态&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、轻量级锁的释放同样使用了CAS操作，尝试将&lt;code&gt;displaced mark word&lt;/code&gt; 替换回&lt;code&gt;mark word&lt;/code&gt;，这时需要检查锁对象的&lt;code&gt;mark word&lt;/code&gt;中&lt;code&gt;lock record&lt;/code&gt;指针是否指向当前线程的锁记录：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果替换成功，则表示没有竞争发生，整个同步过程就完成了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果替换失败，则表示当前锁资源存在竞争，有可能其他线程在这段时间里尝试过获取锁失败，导致自身被挂起，并修改了锁对象的&lt;code&gt;mark word&lt;/code&gt;升级为重量级锁，最后在执行重量级锁的解锁流程后唤醒被挂起的线程&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用流程图对上面的过程进行描述：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9522388059701492&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5jvzP0XKbC4McEaupM2L0bWQRlg9vlSMIjeD6weYQjYQscOQhTTriaFvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;670&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.2 轻量级锁重入&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，&lt;code&gt;synchronized&lt;/code&gt;是可以锁重入的，在轻量级锁的情况下重入也是依赖于栈上的&lt;code&gt;lock record&lt;/code&gt;完成的。以下面的代码中3次锁重入为例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;synchronized&lt;/span&gt; (user){&lt;br/&gt;    &lt;span&gt;synchronized&lt;/span&gt; (user){&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (user){&lt;br/&gt;            &lt;span&gt;//TODO&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;轻量级锁的每次重入，都会在栈中生成一个&lt;code&gt;lock record&lt;/code&gt;，但是保存的数据不同：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首次分配的&lt;code&gt;lock record&lt;/code&gt;，&lt;code&gt;displaced mark word&lt;/code&gt;复制了锁对象的&lt;code&gt;mark word&lt;/code&gt;，&lt;code&gt;owner&lt;/code&gt;指针指向锁对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;之后重入时在栈中分配的&lt;code&gt;lock record&lt;/code&gt;中的&lt;code&gt;displaced mark word&lt;/code&gt;为&lt;code&gt;null&lt;/code&gt;，只存储了指向对象的&lt;code&gt;owner&lt;/code&gt;指针&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8056042031523643&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5jrPBWpctk6Eff1c71hxdJvDrvUdKG6hPuRumkTDQ21k5Bt2ibsMicQWjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;571&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;轻量级锁中，重入的次数等于该锁对象在栈帧中&lt;code&gt;lock record&lt;/code&gt;的数量，这个数量隐式地充当了锁重入机制的计数器。这里需要计数的原因是每次解锁都需要对应一次加锁，只有最后解锁次数等于加锁次数时，锁对象才会被真正释放。在释放锁的过程中，如果是重入则删除栈中的&lt;code&gt;lock record&lt;/code&gt;，直到没有重入时则使用CAS替换锁对象的&lt;code&gt;mark word&lt;/code&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.3 轻量级锁升级&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在jdk1.6以前，默认轻量级锁自旋次数是10次，如果超过这个次数或自旋线程数超过CPU核数的一半，就会升级为重量级锁。这时因为如果自旋次数过多，或过多线程进入自旋，会导致消耗过多cpu资源，重量级锁情况下线程进入等待队列可以降低cpu资源的消耗。自旋次数的值也可以通过jvm参数进行修改：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-XX:PreBlockSpin&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jdk1.6以后加入了&lt;strong&gt;自适应自旋锁&lt;/strong&gt; （&lt;code&gt;Adapative Self Spinning&lt;/code&gt;），自旋的次数不再固定，由jvm自己控制，由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对于某个锁对象，如果自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而允许自旋等待持续相对更长时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于某个锁对象，如果自旋很少成功获得过锁，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面通过代码验证轻量级锁升级为重量级锁的过程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;    User user = &lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;--MAIN--:&quot;&lt;/span&gt; + ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;    Thread thread1 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (user) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;--THREAD1--:&quot;&lt;/span&gt; + ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                TimeUnit.SECONDS.sleep(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;    Thread thread2 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            TimeUnit.SECONDS.sleep(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (user) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;--THREAD2--:&quot;&lt;/span&gt; + ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    thread1.start();&lt;br/&gt;    thread2.start();&lt;br/&gt;    thread1.join();&lt;br/&gt;    thread2.join();&lt;br/&gt;    TimeUnit.SECONDS.sleep(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;    System.out.println(ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的代码中，线程2在启动后休眠两秒后再尝试获取锁，确保线程1能够先得到锁，在此基础上造成锁对象的资源竞争。查看对象锁状态变化：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5911251980982567&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5j2riaJABWj9fZ4zomlKMTysc6K8dBbLoVZndhoEnLqtRZf0r7IHAicAeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1262&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在线程1持有轻量级锁的情况下，线程2尝试获取锁，导致资源竞争，使轻量级锁升级到重量级锁。在两个线程都运行结束后，可以看到对象的状态恢复为了无锁不可偏向状态，在下一次线程尝试获取锁时，会直接从轻量级锁状态开始。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面在最后一次打印前将主线程休眠3秒的原因是锁的释放过程需要一定的时间，如果在线程执行完成后直接打印对象内存布局，对象可能仍处于重量级锁状态。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.4 总结&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;轻量级锁与偏向锁类似，都是jdk对于多线程的优化，不同的是轻量级锁是通过CAS来避免开销较大的互斥操作，而偏向锁是在无资源竞争的情况下完全消除同步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;轻量级锁的“轻量”是相对于重量级锁而言的，它的性能会稍好一些。轻量级锁尝试利用CAS，在升级为重量级锁之前进行补救，目的是为了减少多线程进入互斥，当多个线程交替执行同步块时，jvm使用轻量级锁来保证同步，避免线程切换的开销，不会造成用户态与内核态的切换。但是如果过度自旋，会引起cpu资源的浪费，这种情况下轻量级锁消耗的资源可能反而会更多。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4 重量级锁&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.1 Monitor&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重量级锁是依赖对象内部的monitor（监视器/管程）来实现的 ，而monitor 又依赖于操作系统底层的&lt;code&gt;Mutex Lock&lt;/code&gt;（互斥锁）实现，这也就是为什么说重量级锁比较“重”的原因了，操作系统在实现线程之间的切换时，需要从用户态切换到内核态，成本非常高。在学习重量级锁的工作原理前，首先需要了解一下monitor中的核心概念：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;owner&lt;/code&gt;：标识拥有该&lt;code&gt;monitor&lt;/code&gt;的线程，初始时和锁被释放后都为null&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;cxq (ConnectionList)&lt;/code&gt;：竞争队列，所有竞争锁的线程都会首先被放入这个队列中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;EntryList&lt;/code&gt;：候选者列表，当&lt;code&gt;owner&lt;/code&gt;解锁时会将&lt;code&gt;cxq&lt;/code&gt;队列中的线程移动到该队列中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;OnDeck&lt;/code&gt;：在将线程从&lt;code&gt;cxq&lt;/code&gt;移动到&lt;code&gt;EntryList&lt;/code&gt;时，会指定某个线程为Ready状态（即&lt;code&gt;OnDeck&lt;/code&gt;），表明它可以竞争锁，如果竞争成功那么称为&lt;code&gt;owner&lt;/code&gt;线程，如果失败则放回&lt;code&gt;EntryList&lt;/code&gt;中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;WaitSet&lt;/code&gt;：因为调用&lt;code&gt;wait()&lt;/code&gt;或&lt;code&gt;wait(time)&lt;/code&gt;方法而被阻塞的线程会被放在该队列中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;count&lt;/code&gt;：monitor的计数器，数值加1表示当前对象的锁被一个线程获取，线程释放monitor对象时减1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;recursions&lt;/code&gt;：线程重入次数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用图来表示线程竞争的的过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46338028169014084&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZs9lJF2NoicPJC8HhBeYA5jnlrMjI5uiarlfDxtibBV54hxeia3XpQVW3AKM420Dq5QjPe4szpooHjsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;710&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当线程调用&lt;code&gt;wait()&lt;/code&gt;方法，将释放当前持有的monitor，将&lt;code&gt;owner&lt;/code&gt;置为null，进入&lt;code&gt;WaitSet&lt;/code&gt;集合中等待被唤醒。当有线程调用&lt;code&gt;notify()&lt;/code&gt;或&lt;code&gt;notifyAll()&lt;/code&gt;方法时，也会释放持有的monitor，并唤醒&lt;code&gt;WaitSet&lt;/code&gt;的线程重新参与monitor的竞争。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.2 重量级锁原理&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当升级为重量级锁的情况下，锁对象的&lt;code&gt;mark word&lt;/code&gt;中的指针不再指向线程栈中的&lt;code&gt;lock record&lt;/code&gt;，而是指向堆中与锁对象关联的monitor对象。当多个线程同时访问同步代码时，这些线程会先尝试获取当前锁对象对应的monitor的所有权：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取成功，判断当前线程是不是重入，如果是重入那么&lt;code&gt;recursions+1&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取失败，当前线程会被阻塞，等待其他线程解锁后被唤醒，再次竞争锁对象&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在重量级锁的情况下，加解锁的过程涉及到操作系统的&lt;code&gt;Mutex Lock&lt;/code&gt;进行互斥操作，线程间的调度和线程的状态变更过程需要在用户态和核心态之间进行切换，会导致消耗大量的cpu资源，导致性能降低。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;总结&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在jdk1.6中，引入了偏向锁和轻量级锁，并使用锁升级机制对&lt;code&gt;synchronized&lt;/code&gt;进行了充分的优化。其实除锁升级外，还使用了锁消除、锁粗化等优化手段，所以对它的认识要脱离“重量级”这一概念，不要再单纯的认为它的性能差了。在某些场景下，&lt;code&gt;synchronized&lt;/code&gt;的性能甚至已经超过了&lt;code&gt;Lock&lt;/code&gt;同步锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管java对&lt;code&gt;synchronized&lt;/code&gt;做了这些优化，但是在使用过程中，我们还是要尽量减少锁的竞争，通过减小加锁粒度和减少同步代码的执行时间，来降低锁竞争，尽量使锁维持在偏向锁和轻量级锁的级别，避免升级为重量级锁，造成性能的损耗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后不得不再提一句，在java15中已经默认禁用了偏向锁，并弃用所有相关的命令行选项，虽然说不确定未来的LTS版本会怎样改动，但是了解一下偏向锁的基础也没什么不好的，毕竟你发任你发，我用java8~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cb8f518a3713762f6e14e658a79ac282</guid>
<title>码云 Gitee：高并发大存储下的架构演进之路</title>
<link>https://toutiao.io/k/bi1fr9y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote&gt;&lt;p&gt;码云 Gitee 自2013年推出以来，每年的数据量都是倍增的，截止到2021年3月份，Gitee 上已经有了600万+的开发者，超1500万的仓库，成为了国内首屈一指的研发协作平台。在数据日益增长的过程中，Gitee 的架构也是经过了数个迭代，才能支撑起目前的数据量级。我曾在不少的大会上分享过 Gitee 的架构，也和很多有类似场景的同学一起讨论过，偶然被问起有没有专门的文章来介绍 Gitee 架构的，所以难得假期有时间，将此主题整理成文，以供大家参阅。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.33214709371293&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrI5aLUo959Lia8kib48Gok7BFucxPnl4NkGUjSsMuKX0tW9k2zPNhgcmYicThDjzyEMUuNr2m1BvzKHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1686&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;作为国内发展最快的代码托管平台，Gitee 每天数据都在飞速的增长中，而且随着 DevOps 概念的普及，持续构建也给平台带来更多的请求和更大的并发量，每天需要处理上千万的 Git 操作，Gitee 架构也是在这个过程中逐步迭代发展起来的，回望 Gitee 架构的发展，主要分为5个阶段：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;单机架构&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;分布式存储架构&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;NFS 架构&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;自研分片架构&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Rime 读写分离架构&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;接下来就分享下 Gitee 整个架构的演进史。&lt;/p&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;单机架构&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Gitee 上线于2013年5月份，上线之初就是一个单纯的单体 Rails 应用，所有的请求都是通过这个 Rails 应用进行负载的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4896694214876033&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrI5aLUo959Lia8kib48Gok7BFkeJlicnRbAibcAmL9EHiaqLXgsSVlRYWScxpdic4HC8P1l9xPMuZbYsPfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;968&quot;/&gt;&lt;/p&gt;&lt;p&gt;除了把 Mysql 和 Redis 单独一台机器进行部署之外，跟绝大多数 Web 应用不一样的是 Gitee 需要存储大量的 Git 仓库，无论是 Web 读写仓库还是通过 Git 的方式操作仓库，都是需要应用直接操作服务器上的裸仓库的。这种单体架构在访问量不大的时候还算可以，比如团队或者企业内部使用，但是如果把他作为一个公有云的 SaaS 服务提供出去的话，随着访问量和使用量的增长，压力也会越来越明显，主要就是以下两个：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;存储空间的压力&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;计算资源的压力&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由于开源中国社区的影响力，Gitee 在刚上线之处就涌入了大部分用户，完全不需要担心种子用户的来源。相反，随着社区用户越来越多的使用，首先遭遇的问题就是存储的压力，由于当时使用的是阿里云的云主机，最大的磁盘只能选择2T，虽然后面通过一些渠道实现了扩容，但是云主机后的物理机器也只是一个1U的机器，最多只能有4块硬盘，所以当存储达到接近8T之后，除了外挂存储设备，没有什么更好的直接扩容的方式了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而且随着使用量的增加，每到工作日的高峰期，比如早上9点左右，下午5点左右，是推拉代码的高峰期，机器的IO几乎是满负载的，所以每到这个时候整个系统都会非常缓慢，所以系统扩容的事情刻不容缓。经过讨论，团队决定选择使用分布式存储系统 Ceph，在经过了一系列不算特别严谨的「验证」后（这也是后面出问题的根本原因），我们就采购机器开始进行系统的扩容了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;分布式存储架构&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Ceph 是一个分布式文件系统，它的主要目标是设计成基于POSIX的没有单点故障的分布式文件系统，能够轻松的扩展到数PB级别的容量，所以当时的想法是借助于 Ceph 的横向扩容能力以及高可靠性，实现对存储系统的扩容，并且在存储系统上层提供多组无状态的应用，使这些应用共享 Ceph 存储，从而进一步实现了计算资源扩容的目的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.370757180156658&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrI5aLUo959Lia8kib48Gok7BFYL0Le8X4BhIdEsMRHe8lcqGywiaE7OYE65AeWhwNLoyPp7lfiaPagoWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1532&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;于是在2014年7月份的时候我们采购了一批机器，开始进行系统的搭建和验证，然后挑选了一个周末开始进行系统的迁移与上线。迁移完成后的功能验证一切正常，但是到了工作日，随着访问量的增加，一切开始往不好的方向发展了，整个系统开始变得非常缓慢，经过排查，发现系统的瓶颈在 Ceph 的 IO 上，于是紧急调用了一台 ISCSI 存储设备，将数据进行迁移进行压力的分担。本以为一切稳定了下来，但是更可怕的事情发生了，Ceph RBD 设备突然间被卸载，所有的仓库数据都没了，瞬间整个群和社区都炸开了锅，经过14个小时的分析和研究，终于把设备重新挂载上，然后全速将数据迁往 ISCSI 存储设备，才逐步平息了这场风波。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4095112285336856&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrI5aLUo959Lia8kib48Gok7BF5Cacqf6D3mtEvwwdibvTbZZgfjb6hPRjavZFooeXibohwdacEcRJTLfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1514&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;后来经过研究，才发现分布式存储系统并不适合用在 Git 这种海量小文件的场景下，因为 Git 每一次的操作都需要遍历大量的引用和对象，导致每一次操作整体耗时非常多，Github 之前发过一篇博客，也有提到分布式存储系统不适用于 Git 这种场景。而且在块设备被卸载掉的时候，我们花费了长达14个小时的时间去进行恢复，这也是对工具没有一个深入了解就去贸然使用的后果。经过这次血与泪的教训，我们更加谨慎，更加细心的去做后续所有的调整。&lt;/p&gt;&lt;h3&gt;NFS 架构&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不过，存储压力和计算压力依旧在，是迫在眉睫需要解决的问题，怎么办呢？于是为了临时解决问题，我们采用了相对原始的方案，也就是2014年 Gitlab 官方提供的方案&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5262875536480687&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrI5aLUo959Lia8kib48Gok7BFuUxjBMORBI3qbW8HbRhf1FNOVLNSOwibbVhx19hcO8ly6kKIfrHU6Nw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1864&quot;/&gt;&lt;/p&gt;&lt;p&gt;这个方案主要就是使用 NFS 来进行磁盘的共享，在上游搭建多台应用实例来实现计算资源的扩展，但是由于存储都是走网络，必然会带来性能的损耗，而且在实际应用的过程中，由于 Git 操作的场景比较复杂，会带来一系列的问题&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;内网带宽瓶颈&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;NFS 性能问题导致雪崩效应&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;NFS缓冲文件导致删除不彻底&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;无法方便的横向扩展存储，毫无维护性&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;内网带宽瓶颈&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5387647831800263&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrI5aLUo959Lia8kib48Gok7BF0jkLnUCiaQCYxn9p9A9R8Gy4yol5ICic6mnDas4bybRCnexevWyCqgvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1522&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因为存储都是经过 NFS 进行挂载的，如果有比较大的比如超过 1G 的仓库，它在执行 Clone 的时候将会消耗大量的内网带宽，一般情况下我们的服务器的网口都是 1Gbps 的，所以很容易就会把网卡占满，占满导致的情况就是其它仓库的操作速度被拖慢，进而导致大量的请求阻塞。这还不是最严重的，最严重的情况是内部服务网口被占满，导致 Mysql、Redis 等服务严重丢包，整个系统会非常缓慢，这种情况当时的解决方式就是把核心服务的调用走其它网口来解决，但是 NFS 网口的问题仍然没法解决。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;NFS 性能问题导致雪崩效应&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个就比较好理解了，如果某台 NFS 存储机器的 IO 性能过慢，同时所有的应用机器都有这个存储机器的读写请求，那整个系统就会出问题，所以这个架构下的系统是非常脆弱的，经不起考验。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;NFS缓冲文件导致删除不彻底&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个问题是非常头疼的问题，问题的原因是因为为了提升文件的读写性能，开启了 NFS 内存缓存，所以会出现有些机器删除了 NFS 存储上的一些文件，但是在另外的机器上还存在于内存中，导致应用的一些逻辑判定出问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.37637362637362637&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrI5aLUo959Lia8kib48Gok7BFDkE7rz4ShjamnePoMEbuEzrwJMXhIQQyrsSDEM6KEPk1gEQpkTCykw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1456&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;举个例子，Git 在推送的过程中会产生&lt;code&gt;.lock&lt;/code&gt;文件，为的是防止在分支推送的过程中其它客户端同时推送造成的问题，所以如果我们往&lt;code&gt;master&lt;/code&gt;分支推送代码的时候，服务端会产生&lt;code&gt;master.lock&lt;/code&gt;文件，这样其它客户端就没有办法同时往&lt;code&gt;master&lt;/code&gt;分支上推送代码了。在推送完代码后，Git 会自动的清除掉&lt;code&gt;master.lock&lt;/code&gt;文件，但由于上面我们说的原因，有一些情况下我们在一台应用机处理完推送请求后，明明已经删除掉这个&lt;code&gt;master.lock&lt;/code&gt;文件了，但是在另外一台应用机器的内存里还存在，就会导致无法推送。解决这个问题的方法就是关闭 NFS 内存级别的缓存，但是性能就会受损，还真是难以抉择，好在出现这种问题的情况极少，所以为了性能，只能忍受了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;维护性差&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;还是那句老话，由于历史原因，应用的存储目录结构是固定的，所以我们不得不通过软连接的方式对整个目录进行扩容，而扩容的前提是要把 NFS 存储的设备挂载在目录呀，所以当时整个系统每个应用机器的挂载情况是非常复杂的&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;git@gitee-app1:~$ df -h&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Filesystem                Size  Used Avail Use% Mounted on&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/dev/sda1                184G   15G  160G   9% /&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/dev/sda2                307G   47G  245G  16% /home&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;172.16.3.66:/data    10T     50G  9.9T     1%  /data&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;172.16.30.1:/disk1   10T     50G  9.9T     1%  /disk1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;172.16.30.2:/disk2   10T     50G  9.9T     1%  /disk2&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;172.16.30.3:/disk3   10T     50G  9.9T     1%  /disk3&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;172.16.30.4:/disk4   10T     50G  9.9T     1%  /disk4&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;172.16.30.5:/disk5   10T     50G  9.9T     1%  /disk5&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;172.16.30.6:/disk6   10T     50G  9.9T     1%  /disk6&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;172.16.30.7:/disk7   10T     50G  9.9T     1%  /disk7&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;哇，看到这样的目录结构，运维要哭了，维护起来极其困难，如此下去，失控是早晚的事。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;自研分片架构&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;NFS 这样的方式可以抵挡一阵子，但是并不是长久之计，所以必须寻求改变，在架构上做改进。理想的方式当然是 Github 那种分片架构，通过 RPC 的方式将应用和仓库调用拆离开来，这样无论是扩展和维护都会比较方便&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.44966442953020136&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrI5aLUo959Lia8kib48Gok7BFGDeZAzib2ibgMsgXnOXSJiacC1TXKbuLNxPT7ic8ncpQPqWE2zUn3BGtlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1490&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是这种改造需要对应用进行改造，成本大，周期长，而且鉴于当时的情况，基本没有太多的研发资源投入在架构上，那怎么办呢？当时在做这个架构讨论的时候，我们有一位前端同事（昵称：一只大熊猫）提了一个想法，既然应用无法拆离，那为什么不再网上一层做分片路由呢？&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;题外话：团队内部的「提问」是非常有必要的，而且激发了团队讨论的氛围，我们能够更好的做一些有价值的东西，所以每一个团队成员，尤其是作为一个开发者，永远不要怕说，你的一个小小的想法，对于团队可能是一次非常长远的影响。比如这位熊猫先生的一句话，就直接决定了后续 Gitee 架构的发展方向，有空希望能够再一起吃竹子 ;D&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.36766623207301175&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrI5aLUo959Lia8kib48Gok7BFKfNhqianKoicxmuib3IL1BfVuAsJibmUSHmX4tPCbLnYIgHK0y1PnUMDeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1534&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;于是，第一版本的架构应运而生，我们不改变应用原有的结构，并允许应用是有状态的，也就是应用与仓库捆绑，一组应用对应一批仓库，只要能够在请求上进行辨识，并将其分发到对应的应用上进行处理即可。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从业务角度来讲，Gitee 上的请求分为3类：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;http(s) 请求，浏览仓库以及 Git 的 http(s) 方式操作代码&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;SSH 请求，Git 的 SSH 方式操作代码&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;SVN 请求，Gitee 特性，使用 SVN 的方式操作 Git 仓库&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以我们只需要对这三类请求进行分片路由，从请求中截取仓库信息，根据仓库信息找到对应的机器，然后进行请求的转发即可。由此我们开发了3个组件，分别为这三种请求做路由代理&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4026958719460826&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrI5aLUo959Lia8kib48Gok7BFnYpPfhFf80omLicEqODTMA0U4FOfuH3vbv0L3V8YKdFhibiad2Lb3L5XQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2374&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;Miracle http(s) 动态分发代理&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;组件基于 Nginx 进行二次开发，主要的功能就是通过对 URL 进行截取，获取到仓库的命名空间，然后根据这个命名空间进行 Proxy。比如上图中我们请求了&lt;code&gt;https://gitee.com/zoker/taskover&lt;/code&gt;这个仓库，Miracle 或通过 URL 得知这个请求是请求&lt;code&gt;zoker&lt;/code&gt;的仓库，所以 Miracle 会先去路由 Redis 查找&lt;code&gt;User.zoker&lt;/code&gt;的路由，如果不存在则去数据库进行查找，并在路由 Redis 进行缓存，用来提升获取路由 IP 地址的速度。拿到 IP 之后，Miracle 就会动态的将这个请求 Proxy 对应的后端 App1 上，那么用户就会正确的看到这个仓库的内容。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于路由的分发一定是要保证准确的，如果&lt;code&gt;User.zoker&lt;/code&gt;取到的是一个错误的 IP，那么用户看到的现象就是空仓库，这不是我们所期望的。另外，对于非仓库的请求，也就是跟仓库资源无关的请求，比如登陆，动态等，将会随机分发到任一台后端机器，因为与仓库无关，所以任意一台后端机器均可处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;SSH &amp;amp; SVN 动态分发代理&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;SSHD 组件主要是用来对 Git 的 SSH 请求进行分发代理，使用 LibSSH 进行二开；SVNSBZ 是针对 SVN 请求的动态分发代理。两者实现的逻辑与 Miracle 类似，这里不再赘述。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;遗留问题&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这种架构上线后，无论是从架构负载上，还是从运维维护成本上，都有了极大的改进。但是架构的演进总是无尽头的，没有万金油，当前的架构还是存在一些问题：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因为是以用户或者组织为原子单位进行分片，所以如果一个用户下的仓库过多，体积过大，可能一台机器也处理不完，虽然我们在应用上限制了单个用户可创建的仓库数量以及体积，但是这种场景必定会出现，所以需要提前考虑。而且如果单仓库访问量过大，比如某些热门的开源项目，极端情况下一台机器也可能无法承受住这些请求，依旧是有缺陷的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;此外，Git 请求涉及到鉴权，所有的鉴权还是走的 GiteeWeb 的接口，并且 Git 的 https 操作依旧由 GiteeWeb 处理，并没有像 SSH 那样有单独的组件进行处理，所以耦合性还是太强。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0249110320284698&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrI5aLUo959Lia8kib48Gok7BFTer8RQvdo4VuibNlQg5JyBRpM6wkkwFZSY3JyxjfKDEd2YCVcec2RUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1124&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;基于以上的一些问题，我们进一步对架构进行了改进，主要做了以下改动：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;以仓库为原子单位分片&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Git via https 服务拆离&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;SSH、SVN 相关操作的 Api 拆离&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以仓库分片使路由的原子单位更小，更容易进行管理和扩容，仓库路由主要是以&lt;code&gt;所属空间/仓库地址&lt;/code&gt;为键，类似于&lt;code&gt;zoker/taskover&lt;/code&gt;这种键进行路由&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5825242718446602&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrI5aLUo959Lia8kib48Gok7BFWvIQsHIHI9TUn3ZBahaZTbq1vZQs5hDmBJCOCWacT5nogCOeUWjTFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1442&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;把 Git 的 http(s) 操作拆离出来的主要目的就是为了不让它影响到 Web 的访问，因为 Git 的操作是非常耗时的，场景不一样，放在一起容易出现影响。&lt;/span&gt;&lt;span&gt;而鉴权相关的 Api 的独立也是为了减少 GiteeWeb 的压力，因为推拉这种操作是非常非常多的，所以 Api 的访问也会非常大，把它跟常规的用户 Web 请求混在一起也是非常容易相互影响的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在做完这些拆离之后，GiteeWeb 的稳定性提升了不少，由于 Api 和 Git 操作带来的不稳定下降了 95% 左右。整个架构组件的构成类似于这样&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6589041095890411&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrI5aLUo959Lia8kib48Gok7BF2sIHYHDNzuR8bUJCUMRxQt6UibLRPEwZZfErOnk2xXzdr7j4JIJiam9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1460&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;遗留问题&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;虽然提升了系统整体的稳定性，但是我们还是需要考虑一些极端的情况，比如如果单仓库过大怎么办？单仓库访问量过大怎么办？好在系统能够对单仓库的容量进行限制，但是如果是一个非常热非常火的仓库呢？如果出现那种突然间大并发的访问，该如何适应呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;Rime 读写分离架构&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Gitee 作为国内最大的研发协作平台，也作为首屈一指的代码托管平台，众多的开源项目在 Gitee 上建立了生态，其中不乏热度非常高的仓库，并且在高校、培训机构、黑客马拉松等场景也是作为代码托管平台的首选，经常都可以遇到大并发的访问。但是目前架构主要的问题是机器的备份都是冷备，没有办法有效的利用起来，并且单仓请求负载过大的问题也没有解决。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6211072664359861&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrI5aLUo959Lia8kib48Gok7BF0gvJT7fLbhHqLByRbmbCzfMsrrRGnibcN72cOxC2ywzRUmhXPswGZtA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1156&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;为什么要做 Rime 架构？&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;自从华为入驻 Gitee 之后，我们才开始真正的重视这个问题。2020年开始，华为陆续在 Gitee 平台上开源了 MindSpore、openEuler 等框架，单仓库的压力才逐渐显现出来，为了迎接2020年9月份举世瞩目的鸿蒙操作系统开源，我们在2020上半年继续优化了我们的架构，使其能够多机负载同一个仓库的 IO 操作，这就是我们现在的 Rime 读写分离架构。&lt;/p&gt;&lt;h4&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;实现原理&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;想要实现机器的多读的效果，就必须考虑到仓库同步一致性的问题。试想，如果一个请求被分发到一台备机，刚好主机又刚推送过代码，那么用户在网页上看到的仓库将会是推送前的，这就是一个非常严重的问题，那么该如何保证用户访问备机也是最新的代码呢？或者说如何保证同步的及时性？这里我们采用的如下的逻辑来进行保证&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;写操作写往主机&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;由主机主动发起同步到备机&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;主动维护同步状态，根据同步状态决定路由分发&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7677329624478443&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrI5aLUo959Lia8kib48Gok7BFrsJLx2PjeectjuePeGbPnD7cOp8gmPxAEsO7TFvMWmPb6Dza1YbkOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1438&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如上图所示，我们把仓库的操作分为读和写两种，一般情况下，读可以均等分发到各个的备机，这样一来如果我们有一台主机，两台备机，那么在不考虑其它因素的情况下，理论上仓库的读取能力是增加了3倍的。但是考虑到仓库会有写的情况，那就会涉及到备机的同步，刚刚我们也说过，如果同步不及时，就会导致访问到了老的代码，这显然是一个极大的缺陷。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了解决这个问题，我们利用 Git 的钩子，在仓库被写入之后，同步触发一个同步的队列，这个队列的主要任务有如下几个：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;同步仓库到备机&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;验证同步后的仓库的一致性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;管理变更同步状态&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7850877192982456&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrI5aLUo959Lia8kib48Gok7BF8myD71ONJQFxqoVPKoqpR8jqsW3vqg7mzK0Q5OdiaFLwENBWukt5xNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1368&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当一个仓库有推送之后，会由 Git 钩子触发一个同步任务，这个任务会主动的将增量同步到配置的备机，在同步完成后，会进行引用的一致性校验，这个一致性校验使用的是&lt;code&gt;blake3&lt;/code&gt;哈希算法，通过对&lt;code&gt;refs/&lt;/code&gt;中的内容进行编码，来确认同步后的仓库是否版本完全一致。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于状态管理，当触发任务之后，会第一之间将两台备机的这个仓库状态设置为未同步，我们的分发组件对于读操作，只会分发到主机或者设置为已同步状态的备机，当同步完成并且完成一致性校验之后，会将相关备机的同步状态设置为已同步，那么读操作就又会分发到备机上来了。但是如果同步失败，比如上图中同步到 App1bakA 的是成功的，那么读操作是可以正常的分发到备机的，但是 App1bakB 却是失败的，那么读操作就不会分发到未同步的机器，避免访问上出现不一致的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;架构成果&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过对架构的读写分离的改造，系统对于单仓库访问过大的这种情况也能够轻松应对了。2020年9月10号，华为鸿蒙操作系统正式在 Gitee 上开源，这个备受瞩目的项目一经开放就给 Gitee 带来了巨大的流量以及大量的仓库下载操作，由于前期工作准备充分，并且读写分离架构极大提升了单仓库负载的性能，所以算是完美的为鸿蒙操作系统成功的保驾护航了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4547858276044421&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrI5aLUo959Lia8kib48Gok7BFfehssNxXMicogz0PPOwc7Sdpxq8ezM8JYtS4LtZ1IX9ZEKalPEkf8yw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1891&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;后续优化&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;可能有细心的同学已经想到了，如果一个仓库不同的在写，并且同时伴随着巨大的访问量，那么是不是就变成了单机器要去处理这些所有的请求？答案是 Yes，但是这种场景正常情况下是没有的，一般情况下写操作的频率是远远低于读操作的，如果真的出现了这种情况，只能说明被攻击了，那么我们在组件上也进行了单仓库最大并发的限制，这也是我们维护 Gitee 以来得出的合理的限制条件，完全不会影响到正常用户的使用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是架构的优化是无止境的，对于上面提到的情况，我们依旧是需要进行改良的，目前主要的做法主要是提交的时候同步更新，备机同步成功或者部分备机同步成功才算本次推送成功，这种方式缺点是会加长用户推送的时间，但是能够很好的解决主机单读的问题。目前的架构是多读单写，如果后面这个领域内出现了一些频繁写入的场景，可以考虑变更为多读多写，做好状态和冲突的维护即可。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;未来展望&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;目前的架构最大的问题就是应用和仓库的操作未拆离，这对于架构的扩展性是极为不利的，所以目前或者后续我们正在做的就是对服务进行拆离和其他方面的优化：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;仓库的操作拆离，单独以 RPC 的方式进行调用&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;应用的前后端分离&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;队列、通知等服务的拆离&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;热点仓库的自动按需扩容&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;根据机器的指标进行新仓库的分配&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;...&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Gitee 自2013年上线以来，直到2017年自研架构上线才真正解决了内忧外患，「内」是因为架构无法撑起访问量导致的各种不稳定，「外」是外部的一些 DDOS、CC 攻击等难以招架，好在架构这项内功修炼得当，这些一直以来的问题才能够轻松自如的应对。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有句老话说得好，脱离了一切场景谈技术的行为都是耍流氓，架构亦如是，脱离了背景去谈架构是毫无意义的，很多时候我们做了非常多的工作，可能只是能够解决当前或者未来几年的问题，但是我们需要高瞻远瞩，对后续产品的发展、数据的增长、功能的增强做预估，这样才能更好的改变架构来适应这个高速发展的领域，进而更好的去服务企业和赋能开发者。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3310344827586207&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrI5aLUo959Lia8kib48Gok7BFS9TM2B9IxznuCsRhrPBdfEYODBffDUhgVyykf0ibEGQUhtt9LKdzMIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1885&quot;/&gt;&lt;/p&gt;&lt;p&gt;转载请保留出处：微信公众号「Zoker 随笔」（zokersay）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>