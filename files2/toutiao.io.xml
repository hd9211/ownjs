<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b5bd19e08f8f16c59decd5ccb2a34626</guid>
<title>十一长假干嘛呢？快来吧！</title>
<link>https://toutiao.io/k/8pbs9cx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;34&quot; data-cropselx2=&quot;356&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;425&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ6h6x4EnYInRLic6PibFNWw4zSv28rAxcJu9dumVJF03PwHGOWxOzeJKIsydVa7UJuTo4jOjrct9NZw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b0d3b58380ff0280bb307c3ff1e0081e</guid>
<title>彻底弄懂 base64 的编码与解码原理</title>
<link>https://toutiao.io/k/21wnwdq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-hnrfcf&quot; options=&quot;[object Object]&quot;&gt;&lt;p/&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0e20bc6a360cb9b403f1efa04a99af31_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;319&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-0e20bc6a360cb9b403f1efa04a99af31_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;319&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-0e20bc6a360cb9b403f1efa04a99af31_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-0e20bc6a360cb9b403f1efa04a99af31_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;背景&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;base64的编码原理网上讲解较多，但解码原理讲解较少，并且没有对其中的内部实现原理进行剖析。想要彻底了解base64的编码与解码原理，请耐心看完此文，你一定会有所收获。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;涉及算法与逻辑运算概念&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在探究base64编码原理和解码原理的过程中，我们首先需要了解下面会用到的算法和逻辑运算的概念，这样才能真正的吃透base64的编码原理和解码原理，体会到其中算法的精妙，甚至是在思考的过程中得到意想不到的收获。不清楚base64编码表和ascII编码表的同学可直接前往文末查看。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;短除法&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;短除法运算方法是先用一个除数除以能被它除尽的一个质数，以此类推，除到商是质数为止。&lt;br/&gt;通过短除法，十进制数可以不断除以2得到多个余数。最后，将余数从下到上进行排列组合，得到二进制数，我们以字符n对应的ascII编码110为例。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;    110 / 2  = 55...0
    55  / 2  = 27...1
    27  / 2  = 13...1
    13  / 2  = 6...1
    6   / 2  = 3...0
    3   / 2  = 1...1
    1   / 2  = 0...1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将余数从下到上进行排列组合，得到字符n对应的ascII编码110转二进制为1101110，因为一字节对应8位(bit), 所以需要向前补0补足8位，得到01101110。其余字符同理可得。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;按权展开求和&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;按权展开求和, 8位二进制数从右到左，次数是0到7依次递增, 基数*底数次数，从左到右依次累加，相加结果为对应十进制数。我们以二进制数01101110转10进制为例：&lt;/p&gt;&lt;blockquote&gt;(01101110)2 = 0 * 20 + 1 * 21 + 1 * 22 + 1 * 23 + 0 * 24 + 1 * 25 + 1 * 26 + 0 * 27&lt;/blockquote&gt;&lt;h3&gt;&lt;b&gt;位概念&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;二进制数系统中，每个0或1就是一个位(bit，比特)，也叫存储单元，位是数据存储的最小单位。其中8bit就称为一个字节（Byte）。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;移位运算符&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;移位运算符在程序设计中，是位操作运算符的一种。移位运算符可以在二进制的基础上对数字进行平移。按照平移的方向和填充数字的规则分为三种：&amp;lt;&amp;lt;(左移)、&amp;gt;&amp;gt;(带符号右移)和&amp;gt;&amp;gt;&amp;gt;(无符号右移)。我们在base64的编码和解码过程中操作的又是正数，所以仅使用&amp;lt;&amp;lt;(左移)、&amp;gt;&amp;gt;(带符号右移)两种运算符。&lt;/p&gt;&lt;blockquote&gt;1.左移运算：是将一个二进制位的操作数按指定移动的位数向左移动，移出位被丢弃，右边移出的空位一律补0。&lt;br/&gt;2.右移运算：是将一个二进制位的操作数按指定移动的位数向右移动，移出位被丢弃，左边移出的空位一律补0，或者补符号位，这由不同的机器而定。在使用补码作为机器数的机器中，正数的符号位为0，负数的符号位为1。&lt;/blockquote&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;我们用大白话来描述左移位，一共有8个座位，坐了8个人，在8个座位不动的情况下，现在我让这8个人往左挪2个座位，于是最左边的两个人站了起来，没有座位坐，而最右边空出来了两个座位。移位操作就相当于站起来的人出局，留出来的空位补0.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 左移
    01101000 &amp;lt;&amp;lt; 2 -&amp;gt; 101000(左侧移出位被丢弃) -&amp;gt; 10100000(右侧空位一律补0)
    // 右移
    01101000 &amp;gt;&amp;gt; 2 -&amp;gt; 011010(右侧移出位被丢弃) -&amp;gt; 00011010(左侧空位一律补0)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;与运算、或运算&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;与运算、或运算都是计算机中一种基本的逻辑运算方式。&lt;/p&gt;&lt;blockquote&gt;1.与运算：符号表示为&amp;amp;。运算规则：两位同时为“1”，结果才为“1”，否则为0&lt;br/&gt;2.或运算：符号表示为｜。运算规则：两位只要有一位为“1”，结果就为“1”，否则为0&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;什么是base64编码&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Base64编码是将字符串以每3个8比特(bit)的字节子序列拆分成4个6比特(bit)的字节(6比特有效字节，最左边两个永远为0，其实也是8比特的字节)子序列，再将得到的子序列查找Base64的编码索引表，得到对应的字符拼接成新的字符串的一种编码方式。&lt;/p&gt;&lt;p&gt;每3个8比特(bit)的字节子序列拆分成4个6比特(bit)的字节的拆分过程如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-eb270dec0d0e62bd02176a571f3f4ae7_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;938&quot; data-rawheight=&quot;72&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-eb270dec0d0e62bd02176a571f3f4ae7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;938&quot; data-rawheight=&quot;72&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-eb270dec0d0e62bd02176a571f3f4ae7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-eb270dec0d0e62bd02176a571f3f4ae7_b.png&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;b&gt;为什么base64编码后的大小是原来的4/3倍&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;因为6和8的最大公倍数是24，所以3个8比特的字节刚好可以拆分成4个6比特的字节，3&lt;i&gt;8 = 6&lt;/i&gt;4。计算机中，因为一个字节需要8个存储单元存储，所以我们要把6个比特往前面补两位0，补足8个比特。如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-32b25ec16c8a06bb3659cbf4a3216624_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;73&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-32b25ec16c8a06bb3659cbf4a3216624_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;73&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-32b25ec16c8a06bb3659cbf4a3216624_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-32b25ec16c8a06bb3659cbf4a3216624_b.png&quot;/&gt;&lt;/figure&gt;&lt;p&gt;很明显，补足后所需的存储单元为32个，是原来所需的24个的4/3倍。现在大家明白为什么base64编码后的大小是原来的4/3倍了吧。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;为什么命名为base64呢？&lt;/b&gt;&lt;/h3&gt;&lt;blockquote&gt;因为6位(bit)的二进制数有2的6次方个,也就是二进制数(00000000-00111111)之间的代表0-63的64个二进制数。&lt;/blockquote&gt;&lt;h3&gt;&lt;b&gt;不是说一个字节是用8位二进制表示的吗，为什么不是2的8次方？&lt;/b&gt;&lt;/h3&gt;&lt;blockquote&gt;因为我们得到的8位二进制数的前两位永远是0，真正的有效位只有6位，所以我们所能够得到的二进制数只有2的6次方个。&lt;/blockquote&gt;&lt;h3&gt;&lt;b&gt;Base64字符是哪64个？&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;Base64的编码索引表，字符选用了&quot;A-Z、a-z、0-9、+、/&quot; 64个可打印字符来代表(00000000-00111111)这64个二进制数。即&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;    let base64EncodeChars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;编码原理&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们不妨自己先思考一下，要把3个字节拆分成4个字节可以怎么做？你的实现思路和我的实现思路有哪个不同，我们之间又会碰出怎样的火花？&lt;/p&gt;&lt;h3&gt;&lt;b&gt;流程图&lt;/b&gt;&lt;/h3&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ff904d3eefb58c00ea4c5c440d07ae37_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;430&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-ff904d3eefb58c00ea4c5c440d07ae37_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;430&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-ff904d3eefb58c00ea4c5c440d07ae37_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-ff904d3eefb58c00ea4c5c440d07ae37_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;b&gt;思路&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;分析映射关系：abc -&amp;gt; xyzi。我们从高位到低位添加索引来分析这个过程&lt;/p&gt;&lt;ul&gt;&lt;li&gt;x: (前面补两个0)a的前六位 =&amp;gt; 00a7a6a5a4a3a2&lt;/li&gt;&lt;li&gt;y: (前面补两个0)a的后两位 + b的前四位 =&amp;gt; 00a1a0b7b6b5b4&lt;/li&gt;&lt;li&gt;z: (前面补两个0)b的后四位 + c的前两位 =&amp;gt; 00b3b2b1b0c7c6&lt;/li&gt;&lt;li&gt;i: (前面补两个0)c的后六位 =&amp;gt; 00c5c4c3c2c1c0通过上述的映射关系，我们很容易得到下面的实现思路：&lt;/li&gt;&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;将字符对应的ascII编码转为8位二进制数&lt;/li&gt;&lt;li&gt;将每三个8位二进制数进行以下操作&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;将第一个数右移位2位，得到第一个6位有效位二进制数&lt;/li&gt;&lt;li&gt;将第一个数 &amp;amp; 0x3之后左移位4位，得到第二个6位有效位二进制数的第一个和第二个有效位，将第二个数 &amp;amp; 0xf0之后右移位4位，得到第二个6位有效位二进制数的后四位有效位，两者取且得到第二个6位有效位二进制&lt;/li&gt;&lt;li&gt;将第二个数 &amp;amp; 0xf之后左移位2位，得到第三个6位有效位二进制数的前四位有效位，将第三个数 &amp;amp; 0xC0之后右移位6位，得到第三个6位有效位二进制数的后两位有效位，两者取且得到第三个6位有效位二进制&lt;/li&gt;&lt;li&gt;将第三个数 &amp;amp; 0x3f，得到第四个6位有效位二进制数&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;将获得的6位有效位二进制数转十进制，查找对应base64字符&lt;/li&gt;&lt;p&gt;我们以hao字符串为例，观察base64编码的过程，我们将上面转换通过代码逻辑分析实现吧。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;代码实现&lt;/b&gt;&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 输入字符串
let str = &#x27;hao&#x27;
// base64字符串
let base64EncodeChars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;
// 定义输入、输出字节的二进制数
let char1, char2, char3, out1, out2, out3, out4, out
// 将字符对应的ascII编码转为8位二进制数
char1 = str.charCodeAt(0) &amp;amp; 0xff // 104  01101000
char2 = str.charCodeAt(1) &amp;amp; 0xff // 97  01100001
char3 = str.charCodeAt(2) &amp;amp; 0xff // 111  01101111
// 输出6位有效字节二进制数
6out1 = char1 &amp;gt;&amp;gt; 2 // 26  011010
out2 = (char1 &amp;amp; 0x3) &amp;lt;&amp;lt; 4 | (char2 &amp;amp; 0xf0) &amp;gt;&amp;gt; 4 // 6  000110
out3 = (char2 &amp;amp; 0xf) &amp;lt;&amp;lt; 2 | (char3 &amp;amp; 0xc0) &amp;gt;&amp;gt; 6 // 5  000101
out4 = char3 &amp;amp; 0x3f // 47 101111

out = base64EncodeChars[out1] + base64EncodeChars[out2] + base64EncodeChars[out3] + base64EncodeChars[out4] // aGFv
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;算法剖析&lt;/p&gt;&lt;ol&gt;&lt;li&gt;out1: char1 &amp;gt;&amp;gt; 201101000 -&amp;gt; 00011010&lt;br/&gt;&lt;/li&gt;&lt;li&gt;out2 = (char1 &amp;amp; 0x3) &amp;lt;&amp;lt; 4 | (char2 &amp;amp; 0xf0) &amp;gt;&amp;gt; 4// 且运算&lt;br/&gt;01101000        01100001&lt;br/&gt;00000011        11110000&lt;br/&gt;--------        --------&lt;br/&gt;00000000        01100000&lt;br/&gt;&lt;br/&gt;// 移位运算后得&lt;br/&gt;00000000        00000110&lt;br/&gt;&lt;br/&gt;// 或运算&lt;br/&gt;00000000&lt;br/&gt;00000110&lt;br/&gt;--------&lt;br/&gt;00000110&lt;br/&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;第三个字符第四个字符同理&lt;/p&gt;&lt;p&gt;整理上述代码，扩展至多字符字符串&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 输入字符串
let str = &#x27;haohaohao&#x27;
// base64字符串
let base64EncodeChars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;

// 获取字符串长度
let len = str.length
// 当前字符索引
let index = 0
// 输出字符串
let out = &#x27;&#x27;
while(index &amp;lt; len) {
    // 定义输入、输出字节的二进制数
    let char1, char2, char3, out1, out2, out3, out4
    // 将字符对应的ascII编码转为8位二进制数
    char1 = str.charCodeAt(index++) &amp;amp; 0xff // 104  01101000
    char2 = str.charCodeAt(index++) &amp;amp; 0xff // 97  01100001
    char3 = str.charCodeAt(index++) &amp;amp; 0xff // 111  01101111
    // 输出6位有效字节二进制数
    out1 = char1 &amp;gt;&amp;gt; 2 // 26  011010
    out2 = (char1 &amp;amp; 0x3) &amp;lt;&amp;lt; 4 | (char2 &amp;amp; 0xf0) &amp;gt;&amp;gt; 4 // 6  000110
    out3 = (char2 &amp;amp; 0xf) &amp;lt;&amp;lt; 2 | (char3 &amp;amp; 0xc0) &amp;gt;&amp;gt; 6 // 5  000101
    out4 = char3 &amp;amp; 0x3f // 47 101111

    out = out + base64EncodeChars[out1] + base64EncodeChars[out2] + base64EncodeChars[out3] + base64EncodeChars[out4] // aGFv
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;原字符串长度不是3的整倍数的情况，需要特殊处理&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;    ...
    char1 = str.charCodeAt(index++) &amp;amp; 0xff // 104  01101000
    if (index == len) {
        out2 = (char1 &amp;amp; 0x3) &amp;lt;&amp;lt; 4
        out = out + base64EncodeChars[out1] + base64EncodeChars[out2] + &#x27;==&#x27;
        return out
    }
    char2 = str.charCodeAt(index++) &amp;amp; 0xff // 97  01100001
    if (index == len) {
        out1 = char1 &amp;gt;&amp;gt; 2 // 26  011010
        out2 = (char1 &amp;amp; 0x3) &amp;lt;&amp;lt; 4 | (char2 &amp;amp; 0xf0) &amp;gt;&amp;gt; 4 // 6  000110
        out3 = (char2 &amp;amp; 0xf) &amp;lt;&amp;lt; 2
        out = out + base64EncodeChars[out1] + base64EncodeChars[out2] + base64EncodeChars[out3] + &#x27;=&#x27;
        return out
    }
    ...

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;全部代码&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;function base64Encode(str) {
    // base64字符串
    let base64EncodeChars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;

    // 获取字符串长度
    let len = str.length
    // 当前字符索引
    let index = 0
    // 输出字符串
    let out = &#x27;&#x27;
    while(index &amp;lt; len) {
        // 定义输入、输出字节的二进制数
        let char1, char2, char3, out1, out2, out3, out4
        // 将字符对应的ascII编码转为8位二进制数
        char1 = str.charCodeAt(index++) &amp;amp; 0xff
        out1 = char1 &amp;gt;&amp;gt; 2
        if (index == len) {
            out2 = (char1 &amp;amp; 0x3) &amp;lt;&amp;lt; 4
            out = out + base64EncodeChars[out1] + base64EncodeChars[out2] + &#x27;==&#x27;
            return out
        }
        char2 = str.charCodeAt(index++) &amp;amp; 0xff
        out2 = (char1 &amp;amp; 0x3) &amp;lt;&amp;lt; 4 | (char2 &amp;amp; 0xf0) &amp;gt;&amp;gt; 4 
        if (index == len) {
            out3 = (char2 &amp;amp; 0xf) &amp;lt;&amp;lt; 2
            out = out + base64EncodeChars[out1] + base64EncodeChars[out2] + base64EncodeChars[out3] + &#x27;=&#x27;
            return out
        }
        char3 = str.charCodeAt(index++) &amp;amp; 0xff
        // 输出6位有效字节二进制数
        out3 = (char2 &amp;amp; 0xf) &amp;lt;&amp;lt; 2 | (char3 &amp;amp; 0xc0) &amp;gt;&amp;gt; 6
        out4 = char3 &amp;amp; 0x3f

        out = out + base64EncodeChars[out1] + base64EncodeChars[out2] + base64EncodeChars[out3] + base64EncodeChars[out4]
    }
    return out
}
base64Encode(&#x27;haohao&#x27;) // aGFvaGFv
base64Encode(&#x27;haoha&#x27;) // aGFvaGE=
base64Encode(&#x27;haoh&#x27;) // aGFvaA==
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;解码原理&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;逆向推导，由每4个6位有效位的二进制数合并成3个8位二进制数，根据ascII编码映射到对应字符后拼接字符串&lt;/p&gt;&lt;h3&gt;&lt;b&gt;思路&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;分析映射关系 xyzi -&amp;gt; abc&lt;/p&gt;&lt;ul&gt;&lt;li&gt;a: x后六位 + y第三、四位 =&amp;gt; x5x4x3x2x1x0y5y4&lt;/li&gt;&lt;li&gt;b: y后四位 + z第三、四、五、六位 =&amp;gt; y3y2y1y0z5z4z3z2&lt;/li&gt;&lt;li&gt;c: z后两位 + i后六位 =&amp;gt; z1z0i5i4i3i2i1i0&lt;/li&gt;&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;将字符对应的base64字符集的索引转为6位有效位二进制数&lt;/li&gt;&lt;li&gt;将每四个6位有效位二进制数进行以下操作&lt;/li&gt;&lt;ol&gt;&lt;li&gt;第一个二进制数左移位2位，得到新二进制数的前6位，第二个二进制数 &amp;amp; 0x30之后右移位4位，或运算后得到第一个新二进制数&lt;/li&gt;&lt;li&gt;第二个二进制数 &amp;amp; 0xf之后左移位4位，第三个二进制数 &amp;amp; 0x3c之后右移位2位，或运算后得到第二个新二进制数&lt;/li&gt;&lt;li&gt;第二个二进制数 &amp;amp; 0x3之后左移位6位，与第四个二进制数或运算后得到第二个新二进制数&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;根据ascII编码映射到对应字符后拼接字符串&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;b&gt;代码实现&lt;/b&gt;&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// base64字符串
let str = &#x27;aGFv&#x27;
// base64字符集
let base64CharsArr = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;.split(&#x27;&#x27;)
// 获取索引值
let char1 = base64CharsArr.findIndex(char =&amp;gt; char==str[0]) &amp;amp; 0xff // 26  011010
let char2 = base64CharsArr.findIndex(char =&amp;gt; char==str[1]) &amp;amp; 0xff // 6  000110
let char3 = base64CharsArr.findIndex(char =&amp;gt; char==str[2]) &amp;amp; 0xff // 5  000101
let char4 = base64CharsArr.findIndex(char =&amp;gt; char==str[3]) &amp;amp; 0xff // 47  101111
let out1, out2, out3, out
// 位运算
out1 = char1 &amp;lt;&amp;lt; 2 | (char2 &amp;amp; 0x30) &amp;gt;&amp;gt; 4
out2 = (char2 &amp;amp; 0xf) &amp;lt;&amp;lt; 4 | (char3 &amp;amp; 0x3c) &amp;gt;&amp;gt; 2
out3 = (char3 &amp;amp; 0x3) &amp;lt;&amp;lt; 6 | char4
console.log(out1, out2, out3)
out = String.fromCharCode(out1) + String.fromCharCode(out2) + String.fromCharCode(out3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;遇到有用&#x27;=&#x27;补过位的情况时&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;function base64decode(str) {
    // base64字符集
    let base64CharsArr = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;.split(&#x27;&#x27;)
    let char1 = base64CharsArr.findIndex(char =&amp;gt; char==str[0])
    let char2 = base64CharsArr.findIndex(char =&amp;gt; char==str[1])
    let out1, out2, out3, out
    if (char1 == -1 || char2 == -1) return out
    char1 = char1 &amp;amp; 0xff
    char2 = char2 &amp;amp; 0xff
    let char3 = base64CharsArr.findIndex(char =&amp;gt; char==str[2])
    // 第三位不在base64对照表中时，只拼接第一个字符串
    if (char3 == -1) {
        out1 = char1 &amp;lt;&amp;lt; 2 | (char2 &amp;amp; 0x30) &amp;gt;&amp;gt; 4
        out = String.fromCharCode(out1)
        return out
    }
    let char4 = base64CharsArr.findIndex(char =&amp;gt; char==str[3])
    // 第三位不在base64对照表中时，只拼接第一个和第二个字符串
    if (char4 == -1) {
        out1 = char1 &amp;lt;&amp;lt; 2 | (char2 &amp;amp; 0x30) &amp;gt;&amp;gt; 4
        out2 = (char2 &amp;amp; 0xf) &amp;lt;&amp;lt; 4 | (char3 &amp;amp; 0x3c) &amp;gt;&amp;gt; 2
        out = String.fromCharCode(out1) + String.fromCharCode(out2)
        return out
    }
    // 位运算
    out1 = char1 &amp;lt;&amp;lt; 2 | (char2 &amp;amp; 0x30) &amp;gt;&amp;gt; 4
    out2 = (char2 &amp;amp; 0xf) &amp;lt;&amp;lt; 4 | (char3 &amp;amp; 0x3c) &amp;gt;&amp;gt; 2
    out3 = (char3 &amp;amp; 0x3) &amp;lt;&amp;lt; 6 | char4
    console.log(out1, out2, out3)
    out = String.fromCharCode(out1) + String.fromCharCode(out2) + String.fromCharCode(out3)
    return out
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;解码整个字符串，整理代码后&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;function base64decode(str) {
    // base64字符集
    let base64CharsArr = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;.split(&#x27;&#x27;)
    let i = 0
    let len = str.length
    let out = &#x27;&#x27;
    while(i &amp;lt; len) {
        let char1 = base64CharsArr.findIndex(char =&amp;gt; char==str[i])
        i++
        let char2 = base64CharsArr.findIndex(char =&amp;gt; char==str[i])
        i++
        let out1, out2, out3
        if (char1 == -1 || char2 == -1) return out
        char1 = char1 &amp;amp; 0xff
        char2 = char2 &amp;amp; 0xff
        let char3 = base64CharsArr.findIndex(char =&amp;gt; char==str[i])
        i++
        // 第三位不在base64对照表中时，只拼接第一个字符串
        out1 = char1 &amp;lt;&amp;lt; 2 | (char2 &amp;amp; 0x30) &amp;gt;&amp;gt; 4
        if (char3 == -1) {
            out = out + String.fromCharCode(out1)
            return out
        }
        let char4 = base64CharsArr.findIndex(char =&amp;gt; char==str[i])
        i++
        // 第三位不在base64对照表中时，只拼接第一个和第二个字符串
        out2 = (char2 &amp;amp; 0xf) &amp;lt;&amp;lt; 4 | (char3 &amp;amp; 0x3c) &amp;gt;&amp;gt; 2
        if (char4 == -1) {
            out = out + String.fromCharCode(out1) + String.fromCharCode(out2)
            return out
        }
        // 位运算
        out3 = (char3 &amp;amp; 0x3) &amp;lt;&amp;lt; 6 | char4
        console.log(out1, out2, out3)
        out = out + String.fromCharCode(out1) + String.fromCharCode(out2) + String.fromCharCode(out3)
    }
    return out
}
base64decode(&#x27;aGFvaGFv&#x27;) // haohao
base64decode(&#x27;aGFvaGE=&#x27;) // haoha
base64decode(&#x27;aGFvaA==&#x27;) // haoh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述解码核心是字符与base64字符集索引的映射，网上看到过使用AccII编码索引映射base64字符索引的方法&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;let base64DecodeChars = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1]
// 
let char1 = &#x27;hao&#x27;.charCodeAt(0) // h -&amp;gt; 104
base64DecodeChars[char1] // 33 -&amp;gt; base64编码表中的h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由此可见，base64DecodeChars对照accII编码表的索引存放的是base64编码表的对应字符的索引。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;说起Base64编码可能有些奇怪，因为大多数的编码都是由字符转化成二进制的过程，而从二进制转成字符的过程称为解码。而Base64的概念就恰好反了，由二进制转到字符称为编码，由字符到二进制称为解码。Base64 是一种数据编码方式，可做简单加密使用，我们可以改变base64编码映射顺序来形成自己独特的加密算法进行加密解密。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;编码表&lt;/b&gt;&lt;/h2&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-389e3895fda68d47c1edbc0cb71cfff6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;972&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-389e3895fda68d47c1edbc0cb71cfff6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;972&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-389e3895fda68d47c1edbc0cb71cfff6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-389e3895fda68d47c1edbc0cb71cfff6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b15e05ad7509dfc390e445560196c71e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1227&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-b15e05ad7509dfc390e445560196c71e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1227&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-b15e05ad7509dfc390e445560196c71e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b15e05ad7509dfc390e445560196c71e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>69d4423d12889383b1e1fb5810ee8d98</guid>
<title>or-channel 模式的两种实现</title>
<link>https://toutiao.io/k/4bzmybl</link>
<content:encoded>&lt;div&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;title&gt;or-channel模式的两种实现 | 菜鸟Miao&lt;/title&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,maximum-scale=1&quot;/&gt;&lt;meta name=&quot;google-site-verification&quot; content=&quot;q90Bd4BGjQuSBoXdzK6CUCB8mMUeCEO6MKbaCQS773E&quot;/&gt;&lt;meta name=&quot;keywords&quot; itemprop=&quot;keywords&quot; content=&quot;or-channel-pattern, selectCase&quot;/&gt;&lt;meta name=&quot;description&quot; content=&quot;2-way-of-or-channel-pattern&quot;/&gt;&lt;meta property=&quot;og:type&quot; content=&quot;article&quot;/&gt;&lt;meta property=&quot;og:title&quot; content=&quot;or-channel模式的两种实现&quot;/&gt;&lt;meta property=&quot;og:url&quot; content=&quot;http://blog.newbmiao.com/2021/08/19/2-way-of-or-done-pattern.html&quot;/&gt;&lt;meta property=&quot;og:site_name&quot; content=&quot;菜鸟Miao&quot;/&gt;&lt;meta property=&quot;og:description&quot; content=&quot;2-way-of-or-channel-pattern&quot;/&gt;&lt;meta property=&quot;og:locale&quot; content=&quot;zh_CN&quot;/&gt;&lt;meta property=&quot;og:image&quot; content=&quot;http://media.newbmiao.com/dig101/go/orBenchmark.png&quot;/&gt;&lt;meta property=&quot;article:published_time&quot; content=&quot;2021-08-19T14:08:01.000Z&quot;/&gt;&lt;meta property=&quot;article:modified_time&quot; content=&quot;2021-08-23T13:50:20.101Z&quot;/&gt;&lt;meta property=&quot;article:author&quot; content=&quot;菜鸟Miao&quot;/&gt;&lt;meta property=&quot;article:tag&quot; content=&quot;or-channel-pattern&quot;/&gt;&lt;meta property=&quot;article:tag&quot; content=&quot; selectCase&quot;/&gt;&lt;meta name=&quot;twitter:card&quot; content=&quot;summary&quot;/&gt;&lt;meta name=&quot;twitter:image&quot; content=&quot;http://media.newbmiao.com/dig101/go/orBenchmark.png&quot;/&gt;&lt;meta name=&quot;generator&quot; content=&quot;Hexo 4.2.1&quot;/&gt;&lt;/head&gt;&lt;/html&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>feed9068156efb334f0677bf0b471939</guid>
<title>告别某度？一个开源无广告自托管的搜索引擎</title>
<link>https://toutiao.io/k/r6yulnr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-hnrfcf&quot; options=&quot;[object Object]&quot;&gt;&lt;p&gt;【导语】：自托管、无广告、严格保护隐私的搜索引擎。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;简介&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;Whoogle-search 是一个自托管、免广告的搜索引擎，它不存在 AMP 链、Cookie、IP 追踪等暴露个人隐私的问题。一键即可轻松部署为 Docker 应用程序，拉起来一个免 AD 的搜索服务，用来获取 Google 搜索结果。可作为台式机和移动设备上的主要搜索引擎替代品，快速而简单地实施。&lt;/p&gt;&lt;p&gt;功能特点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;没有广告或赞助内容&lt;/li&gt;&lt;li&gt;没有 JavaScript 脚本&lt;/li&gt;&lt;li&gt;不跟踪/链接个人 IP 地址&lt;/li&gt;&lt;li&gt;没有 AMP 链接&lt;/li&gt;&lt;li&gt;无 URL 跟踪标记&lt;/li&gt;&lt;li&gt;没有引用头&lt;/li&gt;&lt;li&gt;Tor 和 HTTP/SOCKS 代理支持&lt;/li&gt;&lt;li&gt;自动补充/搜索建议&lt;/li&gt;&lt;li&gt;POST 请求搜索和建议查询&lt;/li&gt;&lt;li&gt;主题暗黑模式&lt;/li&gt;&lt;li&gt;随机生成的用户代理&lt;/li&gt;&lt;li&gt;易于安装/部署&lt;/li&gt;&lt;li&gt;可选的基于位置的搜索&lt;/li&gt;&lt;li&gt;可选的 NoJS 模式以禁用搜索结果中的所有 Javascript&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;项目地址：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/benbusby/whoogle-search&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/benbusby/who&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;ogle-search&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;&lt;b&gt;下载安装&lt;/b&gt;&lt;/h3&gt;&lt;h3&gt;&lt;b&gt;依赖关系&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;如果使用 Heroku Quick Deploy，则可以跳过此部分内容，否则请参考：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Docker，仅当打算构建应用程序 Docker 镜像时才需要&lt;/li&gt;&lt;li&gt;Python 3&lt;/li&gt;&lt;li&gt;libcurl4-openssl-dev 和 libssl-dev&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;macOS：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;brew install openssl curl-openssl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Ubuntu：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;sudo apt-get install -y libcurl4-openssl-dev libssl-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Arch：&lt;/p&gt;&lt;h3&gt;&lt;b&gt;安装&lt;/b&gt;&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;Heroku&lt;/li&gt;&lt;/ol&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;https://heroku.com/deploy?template=https://github.com/benbusby/whoogle-search/tree/heroku-app-beta
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;需要 Heroku 账户，Heroku 提供以下功能：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;免费部署应用&lt;/li&gt;&lt;li&gt;免费 HTTPS 网址（https://&amp;lt;应用名称&amp;gt;.herokuapp.com）&lt;/li&gt;&lt;li&gt;一段时间不活动后的停机时间，解决方案：&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;https://github.com/benbusby/whoogle-search#prevent-downtime-heroku-only
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;&lt;li&gt;Repl.it&lt;/li&gt;&lt;/ol&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;https://repl.it/github/benbusby/whoogle-search
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;需要 Replit 账户，Replit 提供以下功能：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;https://repl.it/talk/ask/use-this-pingmat1replco-just-enter/28821/101298
https://repl.it/talk/learn/How-to-use-and-setup-UptimeRobot/9003
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//Fly.io&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;Fly.io&lt;/span&gt;&lt;span class=&quot;invisible&quot;/&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;需要一个 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//Fly.io&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;Fly.io&lt;/span&gt;&lt;span class=&quot;invisible&quot;/&gt;&lt;/a&gt; 账户。安装 CLI：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;curl -L https://fly.io/install.sh | sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;部署应用：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;fly apps create --org personal --port 5000fly deploy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后就可以通过 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//app-name.fly.dev&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;app-name.fly.dev&lt;/span&gt;&lt;span class=&quot;invisible&quot;/&gt;&lt;/a&gt; 访问应用。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;pipx 持久化安装：&lt;/li&gt;&lt;/ol&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;pipx install git+https://github.com/benbusby/whoogle-search.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;沙盒临时安装：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;pipx run --spec git+https://github.com/benbusby/whoogle-search.git whoogle-search
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;&lt;li&gt;pip&lt;/li&gt;&lt;/ol&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;pip install whoogle-search
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;&lt;li&gt;手动安装&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;clone 代码仓库并运行以下命令，在本地环境中启动应用程序：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;git clone https://github.com/benbusby/whoogle-search.git
cd whoogle-search
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt
./run
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以将其添加为系统服务，向 /lib/systemd/system/whoogle.service 文件添加以下内容：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;[Unit]
Description=Whoogle

[Service]
# Basic auth configuration, uncomment to enable
#Environment=WHOOGLE_USER=&amp;lt;username&amp;gt;
#Environment=WHOOGLE_PASS=&amp;lt;password&amp;gt;
# Proxy configuration, uncomment to enable
#Environment=WHOOGLE_PROXY_USER=&amp;lt;proxy username&amp;gt;
#Environment=WHOOGLE_PROXY_PASS=&amp;lt;proxy password&amp;gt;
#Environment=WHOOGLE_PROXY_TYPE=&amp;lt;proxy type (http|https|proxy4|proxy5)
#Environment=WHOOGLE_PROXY_LOC=&amp;lt;proxy host/ip&amp;gt;
# Site alternative configurations, uncomment to enable
# Note: If not set, the feature will still be available
# with default values. 
#Environment=WHOOGLE_ALT_TW=nitter.net
#Environment=WHOOGLE_ALT_YT=invidious.snopyta.org
#Environment=WHOOGLE_ALT_IG=bibliogram.art/u
#Environment=WHOOGLE_ALT_RD=libredd.it
#Environment=WHOOGLE_ALT_TL=lingva.ml
# Load values from dotenv only
#Environment=WHOOGLE_DOTENV=1
Type=simple
User=root
WorkingDirectory=&amp;lt;whoogle_directory&amp;gt;
ExecStart=&amp;lt;whoogle_directory&amp;gt;/venv/bin/python3 -um app --host 0.0.0.0 --port 5000
ExecReload=/bin/kill -HUP $MAINPID
Restart=always
RestartSec=3
SyslogIdentifier=whoogle

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;&lt;li&gt;Docker 部署 通过 Docker Hub：&lt;/li&gt;&lt;/ol&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;docker pull benbusby/whoogle-search
docker run --publish 5000:5000 --detach --name whoogle-search benbusby/whoogle-search:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或使用 docker-compose：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;git clone https://github.com/benbusby/whoogle-search.git
cd whoogle-search
docker-compose up
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或者自行构建镜像运行：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;git clone https://github.com/benbusby/whoogle-search.git
cd whoogle-search
docker build --tag whoogle-search:1.0 .
docker run --publish 5000:5000 --detach --name whoogle-search whoogle-search:1.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;浏览器设置&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;可以在浏览器中设置 Whoogle 作为主要的搜索引擎。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Firefox（桌面版）&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;版本 89+：导航到您应用的网址，右键单击地址栏，然后选择“添加搜索引擎”&lt;/li&gt;&lt;li&gt;之前的版本：导航到应用程序的 url，然后单击地址栏中的菜单。在底部，应该有一个“添加搜索引擎”选项&lt;/li&gt;&lt;li&gt;添加新的搜索引擎后，打开 Firefox 首选项菜单，单击左侧菜单中的“搜索”，然后使用可用的下拉列表从列表中选择“Whoogle”&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;Firefox（iOS）&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;在移动应用设置页面中，点击“常规”部分中的“搜索”。应该有一个标题为“添加搜索引擎”的选项可供选择。提示输入标题和搜索查询 url，使用以下元素填写表单：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Title: &quot;Whoogle&quot;&lt;/li&gt;&lt;li&gt;URL: http[s]:///search?q=%s&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;Firefox（安卓）&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;版本 &amp;lt; 79.0.0：导航到应用程序的网址；长按搜索文本字段；单击“添加搜索引擎”菜单项；选择一个名称，然后单击确定；点击右上角的菜单；导航到设置菜单并选择“搜索”子菜单；选择 Whoogle 并按“设为默认值”；&lt;/li&gt;&lt;li&gt;版本 &amp;gt;= 79.0.0：点击右上角的菜单，导航到设置菜单并选择“搜索”子菜单；点击“添加搜索引擎”；选择“其他”单选按钮，使用以下元素填写表单：&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;名称：&quot;Whoogle&quot;
要使用的搜索字符串：https://\&amp;lt;your whoogle url\&amp;gt;/search?q=%s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;Alfred (Mac OS X)&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;转到 Alfred Preferences &amp;gt; Features &amp;gt; Web Search 并单击 Add Custom Search。然后配置这些设置：&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;搜索网址：`https://&amp;lt;your whoogle url&amp;gt;/search?q={query}
标题：（随意）
关键词：whoogle
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;转到 Default Results 并单击 Setup fallback results 按钮。单击 + 并添加 Whoogle，然后将其拖到顶部。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;基于 Chrome/Chromium 的浏览器&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;自动添加：访问 Whoogle Search 实例的主页。这可能会自动将搜索引擎添加到搜索引擎列表中。如果没有，可以手动添加。&lt;/li&gt;&lt;li&gt;手动添加：在搜索引擎 &amp;gt; 管理搜索引擎 &amp;gt; 添加下，使用 whoogle url/search?q=%s 格式的 URL 手动输入 Whoogle 实例详细信息。&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0694972fc85ed33a1a4ccc942c2213b0</guid>
<title>评估基于视觉模型的强化学习中的设计权衡</title>
<link>https://toutiao.io/k/8yncn8y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;无模型强化学习已在一系列领域得到成功证明，包括机器人、控制、玩游戏和自动驾驶汽车。这些系统通过简单的试错来学习，因此在解决给定任务之前需要进行大量尝试。相比之下，基于模型的强化学习(MBRL) 学习环境模型（通常称为世界模型或动力学模型），使代理能够预测潜在动作的结果，从而减少所需的环境交互量解决一个任务。&lt;/p&gt;&lt;p&gt;原则上，规划所必需的只是预测未来的奖励，然后可以用来选择近乎最优的未来行动。不过，最近许多方法，如梦想家，沛，和简单，还利用预测未来图像的训练信号。但是预测未来的图像真的有必要还是有帮助？有什么好处做视觉MBRL算法实际上是从派生还预测未来的图像？预测整个图像的计算和表示成本相当可观，因此了解这是否真的有用对于 MBRL 研究非常重要。&lt;/p&gt;&lt;p&gt;在“模型、像素和奖励：评估基于视觉模型的强化学习中的设计权衡”中，我们证明预测未来图像提供了巨大的好处，并且实际上是训练成功的视觉 MBRL 代理的关键因素。我们开发了一个新的开源库，称为World Models Library，它使我们能够严格评估各种世界模型设计，以确定图像预测对每个模型返回奖励的相对影响。&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;em&gt;World Models Library&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;World Models Library 专为视觉 MBRL 训练和评估而设计，可以对每个设计决策对跨多个任务的大规模代理的最终性能的影响进行实证研究。该库引入了一个平台无关的视觉MBRL模拟环路和API来无缝地定义新的世界模型，规划者和任务或挑选，并从现有的目录，其中包括剂（例如，选沛），视频模式（例如，SV2P )，以及各种DeepMind Control任务和规划器，例如CEM和MPPI。&lt;/p&gt;&lt;p&gt;使用该库，开发人员可以研究 MBRL 中的变化因素（例如模型设计或表示空间）对代理在一组任务上的性能的影响。该库支持从头开始或在预先收集的一组轨迹上训练代理，以及在给定任务上评估预训练的代理。模型、规划算法和任务可以轻松混合并匹配到任何所需的组合。&lt;/p&gt;&lt;p&gt;为了为用户提供最大的灵活性，该库是使用NumPy接口构建的，该接口允许在TensorFlow、Pytorch或JAX 中实现不同的组件。请查看此 colab以进行快速介绍。&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;em&gt;图像预测的影响&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;使用世界模型库，我们训练了多个具有不同图像预测级别的世界模型。所有这些模型都使用相同的输入（先前观察到的图像）来预测图像和奖励，但它们预测的图像百分比不同。随着代理预测的图像像素数量的增加，由真实奖励衡量的代理性能通常会提高。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceHsictyXWoZdibQVSoT9ibQvx1nbyB4z3nKduVRyWNYJRKFS2qaHA8UcAKMicLpYuR7zgxoSN7juHmXZA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;p&gt;有趣的是，奖励预测准确性和代理性能之间的相关性并不那么强，在某些情况下，更准确的奖励预测甚至会导致代理性能降低。同时，图像重建误差与代理的性能之间存在很强的相关性。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceHsictyXWoZdibQVSoT9ibQvx1ODNiahUSEfCzibGX5IjQIrgSibIe66eCdeGF4gpHmVenGePXMBq1ngDxg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;p&gt;这种现象与探索直接相关， 即当代理尝试更多风险和潜在回报更少的行动以收集有关环境中未知选项的更多信息时。这可以通过在离线设置中测试和比较模型来显示（即，从预先收集的数据集中学习策略，而不是在线RL，后者通过与环境交互来学习策略）。离线设置可确保没有探索，并且所有模型都在相同的数据上进行训练。我们观察到，更适合数据的模型通常在离线设置中表现更好，令人惊讶的是，这些模型可能与从头开始学习和探索时表现最佳的模型不同。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceHsictyXWoZdibQVSoT9ibQvx1voTSLp58qf8TrFWQmqV4Dxj4ib8kTSkibaoCMd4la5ZCTAvicmxCt7xbA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;em&gt;结论&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;我们已经凭经验证明，与仅预测预期奖励的模型相比，预测图像可以显着提高任务性能。我们还表明，图像预测的准确性与这些模型的最终任务性能密切相关。这些发现可用于更好的模型设计，并且对于输入空间是高维且收集数据成本高昂的任何未来设置都特别有用。&lt;/p&gt;&lt;p&gt;如果您想开发自己的模型和实验，请前往我们的存储库和协作实验室，在那里您可以找到有关如何重现这项工作以及如何使用或扩展世界模型库的说明。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>