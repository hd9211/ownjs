<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3cf12a636de5a263b8fb5d6e19b354dc</guid>
<title>Redis 技术专题系列之数据同步持久化机制</title>
<link>https://toutiao.io/k/5wy35j7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                                        &lt;h1&gt;📚背景介绍&lt;/h1&gt; 
&lt;h4&gt;✒️ Redis数据恢复的介绍&lt;/h4&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;通常情况下redis的数据全部存储在内存中，数据库一旦故障发生重启数据会全部丢失&lt;/strong&gt;，&lt;strong&gt;持久化功能在于能够有效地避免因进程退出造成的数据丢失问题&lt;/strong&gt;，&lt;strong&gt;在下次重启时利用之前持久化的文件即可实现数据恢复。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;✒️ Redis高可用的功能基础&lt;/h4&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;即使是在redis cluster或者redis sentinel模式下主从同步数据的恢复仍然需要一段时间。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;✒️ Redis实际场景的分析&lt;/h4&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;开启Redis持久化之后，数据将存放到磁盘中，数据库执行增量同步的时间要远小于全量同步&lt;/strong&gt;。&lt;strong&gt;在生产环境下故障的数据恢复有着非常重要的作用！&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-7747c7fe4ca5a234bc0b46a05d1af84a955.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h1&gt;📚前提概要&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;Redis是出了名的速度快，那是因为在内存中进行数据存储和操作；如果仅仅是在内存中进行数据存储，那就会导致以下问题&lt;/strong&gt;：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;数据随进程退出而消失&lt;/strong&gt;：&lt;strong&gt;当服务器断电或Redis Server进程退出时，内存肯定随之释放，最后数据也会丢失&lt;/strong&gt;；&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;有些小伙伴认为只是作为缓存，数据没有了，重新从数据库中读取放在里面即可，试想，如果是高并发场景，数据库岂不是压力很大；&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;重要数据无法恢复：数据丢失之后无法进行恢复，对于一些重要的数据，只是存在Redis中，而没有存在关系型数据库，如果数据丢失便不可恢复；比如刷礼品排行榜，如果数据丢失，用户肯定不愿意的&lt;/strong&gt;；&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;对于Redis持久化在工作中和面试过程中是一个很重要的技术点，必用必考，接下来详细说说Redis持久化；&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;h1&gt;📚 基本介绍&lt;/h1&gt; 
&lt;h2&gt;✒️ Redis持久化有两种方案&lt;/h2&gt; 
 
&lt;h2&gt;✒️ Redis持久化机制实现&lt;/h2&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;strong&gt;Redis是基于内存进行操作运算，如果不持久化数据再重启服务时会导致数据丢失&lt;/strong&gt;。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;开启Redis持久化功能后，数据会保存到磁盘中。当redis重启后，可以从磁盘中恢复数据。&lt;/strong&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;h3&gt;✒️ RDB快照（snapshot）&lt;/h3&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-d31583957047ebabeb0f96fcd2e348d13ae.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h3&gt;✒️ RDB持久化方式&lt;/h3&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;RDB持久化把当前进程数据生成快照（.rdb）文件保存到硬盘的过程，有手动触发和自动触发。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;✒️ RDB手动触发&lt;/h4&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;手动触发有save和bgsave两命令&lt;/strong&gt;。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h5&gt;✒️ save命令&lt;/h5&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;执行完成时候如果存在老的RDB文件，就把新的替代掉旧的。我们的客户端可能都是几万或者是几十万，这种方式显然不可取。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-a08822d0dbe6a331cfa1f573c50e1251760.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;在执行redis-cli shutdown关闭redis服务时，如果没有开启AOF持久化，自动执行save&lt;/strong&gt;。&lt;/p&gt; 
&lt;h5&gt;✒️ bgsave命令&lt;/h5&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Redis主进程fork一个子进程来创建临时RDB存储文件&lt;/strong&gt;，&lt;strong&gt;创建文件完成后对这个临时文件rename替换原先的RDB文件&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;RDB文件是一个单文件很适合数据的容灾备份与恢复&lt;/strong&gt;，&lt;strong&gt;通过RDB文件恢复数据库耗时较短&lt;/strong&gt;，&lt;strong&gt;通常1G的快照文件载入内存只需20s左右&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-4487fc30e2f75205c44b70c718137d07cca.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h5&gt;✒️ bgsave命令和save命令&lt;/h5&gt; 
&lt;table&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th&gt;命令名称&lt;/th&gt; 
   &lt;th&gt;save&lt;/th&gt; 
   &lt;th&gt;bgsave&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td&gt;IO类型&lt;/td&gt; 
   &lt;td&gt;同步&lt;/td&gt; 
   &lt;td&gt;异步&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;是否阻塞&lt;/td&gt; 
   &lt;td&gt;是&lt;/td&gt; 
   &lt;td&gt;否&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;复杂度&lt;/td&gt; 
   &lt;td&gt;O(n)&lt;/td&gt; 
   &lt;td&gt;O(n)&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;优点&lt;/td&gt; 
   &lt;td&gt;不会耗费额外内存&lt;/td&gt; 
   &lt;td&gt;不阻塞客户端访问&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;缺点&lt;/td&gt; 
   &lt;td&gt;阻塞客户端访问&lt;/td&gt; 
   &lt;td&gt;耗费多余客户端&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p&gt;&lt;strong&gt;在指定时间间隔内将内存中的数据库记录集dump到磁盘上&lt;/strong&gt;，RDB是默认的持久化方式，&lt;strong&gt;这种方式是就是将内存中数据以快照的方式写入到二进制文件中&lt;/strong&gt;,&lt;strong&gt;默认的文件名为dump.rdb&lt;/strong&gt;。&lt;/p&gt; 
&lt;h4&gt;✒️ RDB自动触发&lt;/h4&gt; 
&lt;p&gt;自动触发是由我们的配置文件来完成的，自动触发bgsave。&lt;/p&gt; 
&lt;h5&gt;✒️ 配置方法&lt;/h5&gt; 
 
&lt;h6&gt;✒️ 60秒内至少有10000个键被修改&lt;/h6&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;save 900 1&lt;/strong&gt; #在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;save 300 10&lt;/strong&gt; #在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;save 60 10000&lt;/strong&gt; #在60秒(1分钟)之后，如果至少有10000个key发生变化，dump内存快照。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;关闭RDB方式持久化只需要将所有save保存策略注释掉即可&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h5&gt;✒️ RDB持久化命令&lt;/h5&gt; 
&lt;ul&gt; 
 &lt;li&gt;命令：&lt;strong&gt;config set dir /usr/local&lt;/strong&gt; //设置rdb文件保存路径&lt;/li&gt; 
 &lt;li&gt;备份：&lt;strong&gt;bgsave&lt;/strong&gt; //将dump.rdb保存到usr/local下&lt;/li&gt; 
 &lt;li&gt;恢复：&lt;strong&gt;将dump.rdb放到redis安装目录与redis.conf同级目录，重启redis即可&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;save命令是同步命令，bgsave命令是异步命令，会从redis主进程fork出一个子进程去处理，每次命令执行后会新生成一个rdb文件并覆盖原来的文件。&lt;/strong&gt;&lt;/p&gt; 
&lt;h3&gt;✒️ 修改配置&lt;/h3&gt; 
 
&lt;h2&gt;✒️ RDB的优缺点&lt;/h2&gt; 
&lt;h3&gt;✒️ 优点&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;（恢复速度快，适合大数量恢复机制）&lt;strong&gt;RDB保存的是某一个时间点的内存快照，非常适合灾难恢复。在恢复大数据集时速度快，1G的RDB数据恢复耗时大概20s，比AOF要快的多&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;✒️ 缺点&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;（间隔时间大并且丢失数据较为多）&lt;strong&gt;RDB通过触发某个时间点条件生成快照文件，如果5分钟保存一次的话，一旦发生故障会丢失好几分钟的数据&lt;/strong&gt;，&lt;strong&gt;配置不同的保存点让RDB至少可以保存5分钟的数据&lt;/strong&gt;。因此，如果Redis由于任何原因没有正确关闭而停止工作，你应该做好好丢失最近几分钟的数据&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;（CPU资源占用过大、内存资源占用过多）&lt;strong&gt;fork子进程消耗内存和CPU&lt;/strong&gt;，RDB经常需要 &lt;strong&gt;fork()&lt;/strong&gt; 才能使用子进程在磁盘上持久化。如果数据集很大，&lt;strong&gt;fork()可能很耗时，如果数据集非常大，CPU性能不好&lt;/strong&gt;，&lt;strong&gt;可能会导致Redis停止为客户机服务几毫秒甚至一秒钟。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;✒️ AOF(append-only file)&lt;/h2&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-dff29886ab8ab80fa9edd079cb360ff1ac1.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;由于RDB快照方式的缺点，如果redis由于某些原因导致机器故障时，则会丢失最近几分钟写入的数据，而AOF持久化方式&lt;/strong&gt;，则通过追加的方式将操作命令添加到&lt;strong&gt;appendonly.aof&lt;/strong&gt;文件中，存储的文件是RESP协议指令文件。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-b17e8e5cb10a3fb9b41fd53b2e809e896c2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h3&gt;✒️ 配置方法&lt;/h3&gt; 
 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;配置好后，redis每次修改操作的命令会追加到AOF末尾，当redis重启后会重新执行AOF里的命令达到重建缓存数据集的目的，配置刷命令的频率&lt;/strong&gt;。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;appendfsync always&lt;/strong&gt; ：&lt;strong&gt;每次有新命令追加到AOF文件时就执行一次fsync&lt;/strong&gt;，非常慢但最安全。服务器在每执行一个事件就把AOF缓冲区的内容强制性的写入硬盘上的AOF文件里，保证了数据持久化的完整性，效率是最慢的但最安全的；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;appendfsync everysec&lt;/strong&gt; # &lt;strong&gt;服务端每隔一秒才会进行一次文件同步把内存缓冲区里的AOF缓存数据真正写入AOF文件里，兼顾了效率和完整性，极端情况服务器宕机只会丢失一秒内对Redis数据库的写操作；默认方式&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;appendfsync no&lt;/strong&gt; # &lt;strong&gt;从不fsync&lt;/strong&gt;，&lt;strong&gt;交由操作系统处理，速度快，表示默认系统的缓存区写入磁盘的机制，不做程序强制，数据安全性和完整性差一些。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;hr/&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;bgrewriteaof：后台运作重写机制&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;auto-aof-rewrite-min-size 64mb&lt;/strong&gt; # &lt;strong&gt;aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就很快，重写的意义不大&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;auto-aof-rewrite-percentage 100&lt;/strong&gt; # &lt;strong&gt;aof文件自上一次重写后文件大小增长了100%，则再次触发重写执行bgrewriteaof命令可以手动重写aof文件，AOF重写redis会fork出一个子进程去做，不会对redis正常命令处理有太多影响。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;hr/&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;redis启动时如果既有rdb文件又有aof文件则优先选择aof文件恢复数据，因为aof一般来说数据更全一点。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;全量同步(RDB)：每天定时（避开高峰期）或者采用一个周期实现将数据拷贝到一个地方&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;增量同步(AOF)：比如采用对行为的操作实现对数据的同步。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;增量同步比全量同步更加消耗服务器的内存，但是能够更加的保证数据的同步&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;📚 AOF的优缺点&lt;/h1&gt; 
&lt;h2&gt;✒️ 优点&lt;/h2&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;AOF是通过保存Redis写操作的命令来实现持久化，使用AOF来持久化，Redis数据的安全性将大幅提高，异常宕机情况下最多丢失1s的数据。AOF文件记录了redis的写操作，格式清晰，易于理解和修改，利于数据的重建。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;AOF日志是一个只附加的日志，因此如果断电，就不会出现查找或损坏问题。即使日志由于某种原因（磁盘已满或其他原因）以半写的命令结束，redis check aof工具也可以轻松地修复它。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;当AOF太大时，Redis能够在后台自动重写AOF。重写是完全安全的，因为当Redis继续附加到旧文件时，一个全新的文件会生成，只需创建当前数据集所需的最少操作集，一旦第二个文件就绪，Redis就会切换这两个文件并开始附加到新文件中。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;AOF以易于理解和解析的格式包含所有操作的日志。你甚至可以轻松导出AOF文件。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h2&gt;✒️ 缺点&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;AOF文件通常比相同数据集的等效RDB文件大&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;根据具体的fsync策略，AOF可能比RDB慢。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;使用建议&lt;/h3&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;Redis默认开启了持久化功能，而且是全量RDB的，缺点是服务器宕机后可能会造成数据丢失。 建议最好还是搭配使用aof的everysec，&lt;strong&gt;既能够保证数据的同步,效率也还可以，但是会存在丢失一秒数据的可能性，就算丢失也关系不大&lt;/strong&gt;，因为数据库中已经存在了数据。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h2&gt;混合持久化&lt;/h2&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-51c15feb96051f9791369fc4aec0c0515d6.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;如果开启了混合持久化，AOF在重写时，不再是单纯将内存数据转换为RESP命令写入AOF文件，而是将重写这一刻之前的内存做RDB快照处理，并且将RDB快照内容和增量的AOF修改内存数据的命令存在一起，都写入新的AOF文件，新的AOF文件会原子覆盖掉原来的AOF文件&lt;/strong&gt;。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h3&gt;开启混合持久化命令&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;aof-use-rdb-preamble yes # 开启混合持久化&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;appendonly.aof文件中同时保存着RDB和AOF两种格式的数据&lt;/strong&gt;&lt;/p&gt; 
&lt;h4&gt;RDB、AOF、混合持久化对比&lt;/h4&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-8937fc5d21bbb6eac0d3905d3a66005e120.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ee329d904956a6586a61b8632b65d874</guid>
<title>实时计算框架：Flink 集群搭建与运行机制</title>
<link>https://toutiao.io/k/qf07xgk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h1&gt;&lt;span&gt;一、Flink概述&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、基础简介&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;Flink是一个框架和分布式处理引擎，用于对无界和有界数据流进行有状态计算。Flink被设计在所有常见的集群环境中运行，以内存执行速度和任意规模来执行计算。主要特性包括：批流一体化、精密的状态管理、事件时间支持以及精确一次的状态一致性保障等。Flink不仅可以运行在包括YARN、Mesos、Kubernetes在内的多种资源管理框架上，还支持在裸机集群上独立部署。在启用高可用选项的情况下，它不存在单点失效问题。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBJkwQfW06UITaIeUib3yy1nlcHibGnUbq5VIqSAPm7N7GB7RLEZkmELZ0k6rl8MpLCENQFnmEsJvzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;这里要说明两个概念：&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、应用场景&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Data Driven&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.29375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBJkwQfW06UITaIeUib3yy1nMGCKSuWgIZJY0lb0zHMGdIcSjXxSEhEPULCcJMCibzwmqKibJa4Ub8dQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;事件驱动型应用无须查询远程数据库，本地数据访问使得它具有更高的吞吐和更低的延迟，以反欺诈案例来看，DataDriven把处理的规则模型写到DatastreamAPI中，然后将整个逻辑抽象到Flink引擎，当事件或者数据流入就会触发相应的规则模型，一旦触发规则中的条件后，DataDriven会快速处理并对业务应用进行通知。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Data Analytics&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2578125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBJkwQfW06UITaIeUib3yy1nPh29LjWATr5mVamMl1kUFicZhvznOdp9OBLSYb98XM9wlBGykuhEcPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;和批量分析相比，由于流式分析省掉了周期性的数据导入和查询过程，因此从事件中获取指标的延迟更低。不仅如此，批量查询必须处理那些由定期导入和输入有界性导致的人工数据边界，而流式查询则无须考虑该问题，Flink为持续流式分析和批量分析都提供了良好的支持，实时处理分析数据，应用较多的场景如实时大屏、实时报表。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Data Pipeline&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBJkwQfW06UITaIeUib3yy1ngXfIESX1UGZBYHQFv7oMfec2YwwgJ2cZ3Okwe14j7O332IY1ic2aSIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;与周期性的ETL作业任务相比，持续数据管道可以明显降低将数据移动到目的端的延迟，例如基于上游的StreamETL进行实时清洗或扩展数据，可以在下游构建实时数仓，确保数据查询的时效性，形成高时效的数据查询链路，这种场景在媒体流的推荐或者搜索引擎中十分常见。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、环境部署&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、安装包管理&lt;/span&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;[root@hop01 opt]&lt;/span&gt;# &lt;span&gt;tar&lt;/span&gt; &lt;span&gt;-zxvf&lt;/span&gt; &lt;span&gt;flink-1&lt;/span&gt;&lt;span&gt;.7&lt;/span&gt;&lt;span&gt;.0-bin-hadoop27-scala_2&lt;/span&gt;&lt;span&gt;.11&lt;/span&gt;&lt;span&gt;.tgz&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[root@hop02 opt]&lt;/span&gt;# &lt;span&gt;mv&lt;/span&gt; &lt;span&gt;flink-1&lt;/span&gt;&lt;span&gt;.7&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt; &lt;span&gt;flink1&lt;/span&gt;&lt;span&gt;.7&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;2、集群配置&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;管理节点&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[root@hop01 opt]&lt;span&gt;# cd /opt/flink1.7/conf&lt;/span&gt;&lt;br/&gt;[root@hop01 conf]&lt;span&gt;# vim flink-conf.yaml&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;jobmanager.rpc.address: hop01&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;分布节点&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[root@hop01 conf]&lt;span&gt;# vim slaves&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;hop02&lt;br/&gt;hop03&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;两个配置同步到所有集群节点下面。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、启动与停止&lt;/span&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/opt/flink1.7/bin/&lt;span&gt;start&lt;/span&gt;-cluster.sh&lt;br/&gt;/opt/flink1&lt;span&gt;.7&lt;/span&gt;/&lt;span&gt;bin&lt;/span&gt;/&lt;span&gt;stop&lt;/span&gt;-cluster.sh&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启动日志：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[root@hop01 conf]&lt;span&gt;# /opt/flink1.7/bin/start-cluster.sh&lt;/span&gt;&lt;br/&gt;Starting cluster.&lt;br/&gt;Starting standalonesession daemon &lt;span&gt;on&lt;/span&gt; host hop01.&lt;br/&gt;Starting taskexecutor daemon &lt;span&gt;on&lt;/span&gt; host hop02.&lt;br/&gt;Starting taskexecutor daemon &lt;span&gt;on&lt;/span&gt; host hop03.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;4、Web界面&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;访问：&lt;code&gt;http://hop01:8081/&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBJkwQfW06UITaIeUib3yy1nH54vjEkicM2IC2icxFIAyd3wFdBic71icjUicMprymSoFcpjVj0POnicVZDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、开发入门案例&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、数据脚本&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;分发一个数据脚本到各个节点：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;/var/flink/&lt;span&gt;test&lt;/span&gt;/word.txt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;2、引入基础依赖&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;这里基于Java写的基础案例。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.flink&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;flink-java&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.7.0&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.flink&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;flink-streaming-java_2.11&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.7.0&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;3、读取文件数据&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;这里直接读取文件中的数据，经过程序流程分析出每个单词出现的次数。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WordCount&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 读取文件数据&lt;/span&gt;&lt;br/&gt;        readFile () ;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;readFile&lt;/span&gt; &lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 1、执行环境创建&lt;/span&gt;&lt;br/&gt;        ExecutionEnvironment environment = ExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 2、读取数据文件&lt;/span&gt;&lt;br/&gt;        String filePath = &lt;span&gt;&quot;/var/flink/test/word.txt&quot;&lt;/span&gt; ;&lt;br/&gt;        DataSet&amp;lt;String&amp;gt; inputFile = environment.readTextFile(filePath);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 3、分组并求和&lt;/span&gt;&lt;br/&gt;        DataSet&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; wordDataSet = inputFile.flatMap(&lt;span&gt;new&lt;/span&gt; WordFlatMapFunction(&lt;br/&gt;        )).groupBy(&lt;span&gt;0&lt;/span&gt;).sum(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 4、打印处理结果&lt;/span&gt;&lt;br/&gt;        wordDataSet.print();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 数据读取个切割方式&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WordFlatMapFunction&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;FlatMapFunction&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Tuple2&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Integer&lt;/span&gt;&amp;gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;flatMap&lt;/span&gt;&lt;span&gt;(String input, Collector&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; collector)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;            String[] wordArr = input.split(&lt;span&gt;&quot;,&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (String word : wordArr) {&lt;br/&gt;                collector.collect(&lt;span&gt;new&lt;/span&gt; Tuple2&amp;lt;&amp;gt;(word, &lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4806201550387597&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBJkwQfW06UITaIeUib3yy1n0fOJ6MU6WJAt47WiaNeJTwRibUUvCSnuu4UaWW8v1BJniaiaMckYQ6nMEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;774&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;4、读取端口数据&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;在hop01服务上创建一个端口，并模拟一些数据发送到该端口：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[root@hop01 ~]&lt;span&gt;# nc -lk 5566&lt;/span&gt;&lt;br/&gt;c++,java&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过Flink程序读取并分析该端口的数据内容：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WordCount&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 读取端口数据&lt;/span&gt;&lt;br/&gt;        readPort ();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;readPort&lt;/span&gt; &lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 1、执行环境创建&lt;/span&gt;&lt;br/&gt;        StreamExecutionEnvironment environment = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 2、读取Socket数据端口&lt;/span&gt;&lt;br/&gt;        DataStreamSource&amp;lt;String&amp;gt; inputStream = environment.socketTextStream(&lt;span&gt;&quot;hop01&quot;&lt;/span&gt;, &lt;span&gt;5566&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 3、数据读取个切割方式&lt;/span&gt;&lt;br/&gt;        SingleOutputStreamOperator&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; resultDataStream = inputStream.flatMap(&lt;br/&gt;                &lt;span&gt;new&lt;/span&gt; FlatMapFunction&amp;lt;String, Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt;()&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;flatMap&lt;/span&gt;&lt;span&gt;(String input, Collector&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; collector)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                String[] wordArr = input.split(&lt;span&gt;&quot;,&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;for&lt;/span&gt; (String word : wordArr) {&lt;br/&gt;                    collector.collect(&lt;span&gt;new&lt;/span&gt; Tuple2&amp;lt;&amp;gt;(word, &lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }).keyBy(&lt;span&gt;0&lt;/span&gt;).sum(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 4、打印分析结果&lt;/span&gt;&lt;br/&gt;        resultDataStream.print();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 5、环境启动&lt;/span&gt;&lt;br/&gt;        environment.execute();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;&lt;span&gt;四、运行机制&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.57890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBJkwQfW06UITaIeUib3yy1nt4DVlGFdZjnwnOOp2WKHGaNic26HSvYAgQiboXp43vQ2krznubQyKjuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;FlinkClient&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;客户端用来准备和发送数据流到JobManager节点，之后根据具体需求，客户端可以直接断开连接，或者维持连接状态等待任务处理结果。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;JobManager&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在Flink集群中，会启动一个JobManger节点和至少一个TaskManager节点，JobManager收到客户端提交的任务后，JobManager会把任务协调下发到具体的TaskManager节点去执行，TaskManager节点将心跳和处理信息发送给JobManager。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;TaskManager&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;任务槽（slot）是TaskManager中最小的资源调度单位，在启动的时候就设置好了槽位数，每个槽位能启动一个Task，接收JobManager节点部署的任务，并进行具体的分析处理。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;五、源代码地址&lt;/span&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;GitHub·地址&lt;br/&gt;https:&lt;span&gt;//github.com/cicadasmile/big-data-parent&lt;/span&gt;&lt;br/&gt;GitEE·地址&lt;br/&gt;https:&lt;span&gt;//gitee.com/cicadasmile/big-data-parent&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4Njg0MzYwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBCuF3zfJnqPKpUia4wfn1FUtTHpxxkR5HvbicPgOjibPicX0goMOkny1NdkLAJvBaqrYh3UdwMjiaDQMA/0?wx_fmt=png&quot; data-nickname=&quot;知了一笑&quot; data-alias=&quot;cicada_smile&quot; data-signature=&quot;积累是一个孤独且枯燥的过程&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>798a3c075d50adb791b541e23e944d48</guid>
<title>为什么 Go map 和 slice 是非线性安全的？</title>
<link>https://toutiao.io/k/euwldfo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是煎鱼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初入 Go 语言的大门，有不少的小伙伴会快速的 3 天精通 Go，5 天上手项目，14 天上线业务迭代，21 天排查、定位问题，顺带捎个反省报告。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中最常见的初级错误，Go 面试较最爱问的问题之一：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1726315789473684&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4jmWIKV9zRh7fFAeicnSpYHljzkK4qPzpxlYcPZBWLAQGskD5DIba8PDQgAOiaH4Pol3uVZjkgYJdqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;950&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么在 Go 语言里，map 和 slice 不支持并发读写，也就是是非线性安全的，为什么不支持？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;见招拆招后，紧接着就会开始讨论如何让他们俩 ”冤家“ 支持并发读写？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们这篇文章就来理一理，了解其前因后果，一起吸鱼学懂 Go 语言。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;非线性安全的例子&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;slice&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用多个 goroutine 对类型为 slice 的变量进行操作，看看结果会变的怎么样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; s []&lt;span&gt;string&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;9999&lt;/span&gt;; i++ {&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   s = &lt;span&gt;append&lt;/span&gt;(s, &lt;span&gt;&quot;脑子进煎鱼了&quot;&lt;/span&gt;)&lt;br/&gt;  }()&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;进了 %d 只煎鱼&quot;&lt;/span&gt;, &lt;span&gt;len&lt;/span&gt;(s))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 第一次执行&lt;br/&gt;进了 5790 只煎鱼&lt;br/&gt;// 第二次执行&lt;br/&gt;进了 7370 只煎鱼&lt;br/&gt;// 第三次执行&lt;br/&gt;进了 6792 只煎鱼&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你会发现无论你执行多少次，每次输出的值大概率都不会一样。也就是追加进 slice 的值，出现了覆盖的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此在循环中所追加的数量，与最终的值并不相等。且这种情况，是不会报错的，是一个出现率不算高的隐式问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个产生的主要原因是程序逻辑本身就有问题，同时读取到相同索引位，自然也就会产生覆盖的写入了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;map&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样针对 map 也如法炮制一下。重复针对类型为 map 的变量进行写入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;99&lt;/span&gt;; i++ {&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   s[&lt;span&gt;&quot;煎鱼&quot;&lt;/span&gt;] = &lt;span&gt;&quot;吸鱼&quot;&lt;/span&gt;&lt;br/&gt;  }()&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;进了 %d 只煎鱼&quot;&lt;/span&gt;, &lt;span&gt;len&lt;/span&gt;(s))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;fatal error: concurrent map writes&lt;br/&gt;&lt;br/&gt;goroutine 18 [running]:&lt;br/&gt;runtime.throw(0x10cb861, 0x15)&lt;br/&gt;        /usr/&lt;span&gt;local&lt;/span&gt;/Cellar/go/1.16.2/libexec/src/runtime/panic.go:1117 +0x72 fp=0xc00002e738 sp=0xc00002e708 pc=0x1032472&lt;br/&gt;runtime.mapassign_faststr(0x10b3360, 0xc0000a2180, 0x10c91da, 0x6, 0x0)&lt;br/&gt;        /usr/&lt;span&gt;local&lt;/span&gt;/Cellar/go/1.16.2/libexec/src/runtime/map_faststr.go:211 +0x3f1 fp=0xc00002e7a0 sp=0xc00002e738 pc=0x1011a71&lt;br/&gt;main.main.func1(0xc0000a2180)&lt;br/&gt;        /Users/eddycjy/go-application/awesomeProject/main.go:9 +0x4c fp=0xc00002e7d8 sp=0xc00002e7a0 pc=0x10a474c&lt;br/&gt;runtime.goexit()&lt;br/&gt;        /usr/&lt;span&gt;local&lt;/span&gt;/Cellar/go/1.16.2/libexec/src/runtime/asm_amd64.s:1371 +0x1 fp=0xc00002e7e0 sp=0xc00002e7d8 pc=0x1063fe1&lt;br/&gt;created by main.main&lt;br/&gt;        /Users/eddycjy/go-application/awesomeProject/main.go:8 +0x55&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好家伙，程序运行会直接报错。并且是 Go 源码调用 &lt;code&gt;throw&lt;/code&gt; 方法所导致的致命错误，也就是说 Go 进程会中断。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不得不说，这个并发写 map 导致的 &lt;code&gt;fatal error: concurrent map writes&lt;/code&gt; 错误提示。我有一个朋友，已经看过少说几十次了，不同组，不同人...&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是个日经的隐式问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;如何支持并发读写&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;对 map 上锁&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上我们仍然存在并发读写 map 的诉求（程序逻辑决定），因为 Go 语言中的 goroutine 实在是太方便了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像是一般写爬虫任务时，基本会用到多个 goroutine，获取到数据后再写入到 map 或者 slice 中去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 官方在 Go maps in action 中提供了一种简单又便利的方式来实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; counter = &lt;span&gt;struct&lt;/span&gt;{&lt;br/&gt;    sync.RWMutex&lt;br/&gt;    m &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;br/&gt;}{m: &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;)}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这条语句声明了一个变量，它是一个匿名结构（struct）体，包含一个原生和一个嵌入读写锁 &lt;code&gt;sync.RWMutex&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要想从变量中中读出数据，则调用读锁：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;counter.RLock()&lt;br/&gt;n := counter.m[&lt;span&gt;&quot;煎鱼&quot;&lt;/span&gt;]&lt;br/&gt;counter.RUnlock()&lt;br/&gt;fmt.Println(&lt;span&gt;&quot;煎鱼:&quot;&lt;/span&gt;, n)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要往变量中写数据，则调用写锁：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;counter.Lock()&lt;br/&gt;counter.m[&lt;span&gt;&quot;煎鱼&quot;&lt;/span&gt;]++&lt;br/&gt;counter.Unlock()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是一个最常见的 Map 支持并发读写的方式了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;sync.Map&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前言&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然有了 Map+Mutex 的极简方案，但是也仍然存在一定问题。那就是在 map 的数据量非常大时，只有一把锁（Mutex）就非常可怕了，一把锁会导致大量的争夺锁，导致各种冲突和性能低下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的解决方案是分片化，将一个大 map 分成多个区间，各区间使用多个锁，这样子锁的粒度就大大降低了。不过该方案实现起来很复杂，很容易出错。因此 Go 团队到比较为止暂无推荐，而是采取了其他方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方案就是在 Go1.9 起支持的 &lt;code&gt;sync.Map&lt;/code&gt;，其支持并发读写 map，起到一个补充的作用。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;具体介绍&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言的 &lt;code&gt;sync.Map&lt;/code&gt; 支持并发读写 map，采取了 “空间换时间” 的机制，冗余了两个数据结构，分别是：read 和 dirty，减少加锁对性能的影响：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Map &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; mu Mutex&lt;br/&gt; read atomic.Value &lt;span&gt;// readOnly&lt;/span&gt;&lt;br/&gt; dirty &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;interface&lt;/span&gt;{}]*entry&lt;br/&gt; misses &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其是专门为 &lt;code&gt;append-only&lt;/code&gt; 场景设计的，也就是适合读多写少的场景。这是他的优点之一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若出现写多/并发多的场景，会导致 read map 缓存失效，需要加锁，冲突变多，性能急剧下降。这是他的重大缺点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提供了以下常用方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m *Map)&lt;/span&gt; &lt;span&gt;Delete&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m *Map)&lt;/span&gt; &lt;span&gt;Load&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;(value &lt;span&gt;interface&lt;/span&gt;{}, ok &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m *Map)&lt;/span&gt; &lt;span&gt;LoadAndDelete&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;(value &lt;span&gt;interface&lt;/span&gt;{}, loaded &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m *Map)&lt;/span&gt; &lt;span&gt;LoadOrStore&lt;/span&gt;&lt;span&gt;(key, value &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;(actual &lt;span&gt;interface&lt;/span&gt;{}, loaded &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m *Map)&lt;/span&gt; &lt;span&gt;Range&lt;/span&gt;&lt;span&gt;(f &lt;span&gt;func&lt;/span&gt;(key, value &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m *Map)&lt;/span&gt; &lt;span&gt;Store&lt;/span&gt;&lt;span&gt;(key, value &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Delete：删除某一个键的值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Load：返回存储在 map 中的键的值，如果没有值，则返回 nil。ok 结果表示是否在 map 中找到了值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LoadAndDelete：删除一个键的值，如果有的话返回之前的值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LoadOrStore：如果存在的话，则返回键的现有值。否则，它存储并返回给定的值。如果值被加载，加载的结果为 true，如果被存储，则为 false。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Range：递归调用，对 map 中存在的每个键和值依次调用闭包函数 &lt;code&gt;f&lt;/code&gt;。如果 &lt;code&gt;f&lt;/code&gt; 返回 false 就停止迭代。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Store：存储并设置一个键的值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际运行例子如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; m sync.Map&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;//写入&lt;/span&gt;&lt;br/&gt; data := []&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;煎鱼&quot;&lt;/span&gt;, &lt;span&gt;&quot;咸鱼&quot;&lt;/span&gt;, &lt;span&gt;&quot;烤鱼&quot;&lt;/span&gt;, &lt;span&gt;&quot;蒸鱼&quot;&lt;/span&gt;}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;4&lt;/span&gt;; i++ {&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(i &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   m.Store(i, data[i])&lt;br/&gt;  }(i)&lt;br/&gt; }&lt;br/&gt; time.Sleep(time.Second)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//读取&lt;/span&gt;&lt;br/&gt; v, ok := m.Load(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;Load: %v, %v\n&quot;&lt;/span&gt;, v, ok)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//删除&lt;/span&gt;&lt;br/&gt; m.Delete(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//读或写&lt;/span&gt;&lt;br/&gt; v, ok = m.LoadOrStore(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;吸鱼&quot;&lt;/span&gt;)&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;LoadOrStore: %v, %v\n&quot;&lt;/span&gt;, v, ok)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//遍历&lt;/span&gt;&lt;br/&gt; m.Range(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(key, value &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  fmt.Printf(&lt;span&gt;&quot;Range: %v, %v\n&quot;&lt;/span&gt;, key, value)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; })&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Load: 煎鱼, &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;LoadOrStore: 吸鱼, &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;Range: 0, 煎鱼&lt;br/&gt;Range: 1, 吸鱼&lt;br/&gt;Range: 3, 蒸鱼&lt;br/&gt;Range: 2, 烤鱼&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么不支持&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go Slice 的话，主要还是索引位覆写问题，这个就不需要纠结了，势必是程序逻辑在编写上有明显缺陷，自行改之就好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但 Go map 就不大一样了，很多人以为是默认支持的，一个不小心就翻车，这么的常见。那凭什么 Go 官方还不支持，难不成太复杂了，性能太差了，到底是为什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因如下（via @go faq）：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;典型使用场景：map 的典型使用场景是不需要从多个 goroutine 中进行安全访问。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非典型场景（需要原子操作）：map 可能是一些更大的数据结构或已经同步的计算的一部分。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;性能场景考虑：若是只是为少数程序增加安全性，导致 map 所有的操作都要处理 mutex，将会降低大多数程序的性能。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;汇总来讲，就是 Go 官方在经过了长时间的讨论后，认为 Go map 更应适配典型使用场景，而不是为了小部分情况，导致大部分程序付出代价（性能），决定了不支持。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在今天这篇文章中，我们针对 Go 语言中的 map 和 slice 进行了基本的介绍，也对不支持并发读者的场景进行了模拟展示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时也针对业内常见的支持并发读写的方式进行了讲述，最后分析了不支持的原因，让我们对整个前因后果有了一个完整的了解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你&lt;strong&gt;在日常是否有遇到过 Go 语言中非线性安全的问题呢，欢迎你在评论区留言和大家一起交流&lt;/strong&gt;！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>05c571099af611eb633a2b3e39326e17</guid>
<title>工具 | 字节跳动开源的 Markdown 编辑器</title>
<link>https://toutiao.io/k/jly7bl3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;大家好，我是周刊菌。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MzA0ODkyMA==&amp;amp;mid=2655077223&amp;amp;idx=2&amp;amp;sn=05d40fd92b2ed441b4bfcaaab853a1d2&amp;amp;chksm=bd2913508a5e9a46683351f781991e7e2ad2a4a1c63a4acd499df91a8861e07ba5f713df0f96&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;加入「码农周刊VIP会员」，一起牛起来！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1034&quot; data-ratio=&quot;2.0773333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNav8sWdpfIlOT6UuNeniaROF1iaEZeicOHw3yCI669iaW4qyThgQIBs1Aym2DfjrOBTfvnypibSF1oc1ecow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;322&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;350&quot; data-ratio=&quot;1.318840579710145&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav8pVYfXHFZnJw6GmED4PucZvQd6m3AP8fUG1IKJyBgicmJ3P5ygQjO5r6Bib2x190MFOlb6PwExNQuA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9e99f5021725ea2873a9be416d743ca1</guid>
<title>聊一聊 Linux 的五种 IO 模型</title>
<link>https://toutiao.io/k/a3frc3i</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg4OTQ2OTM2NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/hXEWOsco2BXgSgxdypLmZcRoKW03MY5bN7f9FnsIpGz2m678abibsomJtXnaR9Ho4FfomIBThmMDiaVQT6V2eP1Q/0?wx_fmt=png&quot; data-nickname=&quot;码农StayUp&quot; data-alias=&quot;AcmenStayUp&quot; data-signature=&quot;人生就是一个不断学习的过程，通过学习来充实自己的头脑，让自己更有智慧的生活下去，去探索那未知领域的神秘，去享受成长带来的快乐和惬意。&quot;/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;微信搜索：码农StayUp&lt;br/&gt;主页地址：https://gozhuyinglong.github.io&lt;br/&gt;源码分享：https://github.com/gozhuyinglong/blog-demos&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在日常 Coding 中，多多少少都会接触到网络 IO，就会想要深入了解一下。看了很多文章，总是云里雾里的感觉，直到读了《UNIX网络编程 卷1：套接字联网API》中的介绍后，才豁然开朗。这里就给大家分享一下，如有不对，欢迎指出。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 概念说明&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了便于理解后面的内容，我们先来了解一些概念。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 Socket&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Socket 中文翻译为套接字，是计算机网络中进程间进行双向通信的端点的抽象。一个 Socket 代表了网络通信的一端，是由操作系统提供的进程间通信机制。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在操作系统中，通常会为应用程序提供一组应用程序接口，称为 Socket 接口（Socket API）。应用程序可以通过 Socket 接口，来使用网络 Socket，以进行数据的传输。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;一个 Socket 由IP地址和端口组成，即：Socket 地址 = IP地址 : 端口号。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在同一台计算机上，TCP 协议与 UDP 协议可以同时使用相同的端口（Port），而互不干扰。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;要想实现网络通信，至少需要一对 Socket，其中一个运行在客户端，称之为 Client Socket；另一个运行在服务器端，称之为 Server Socket。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Socket 之间的连接过程可以分为三个步骤：（1）服务器监听；（2）客户端连接；（3）连接确认。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.28193832599118945&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hXEWOsco2BU9huQ60hARKy70SiaQqquPXDHAQQViagSCCvBkSTNDH4mGowctH7oM2wv7A3K4v1RGRvU64tKAVqaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;454&quot;/&gt;&lt;figcaption&gt;Socket&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 Socket 缓冲区&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个 Socket 被创建后，都会在内核中分配两个缓冲区：输入缓冲区和输出缓冲区。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过 Socket 发送数据并不会立即向网络中传输数据，而是先将数据写入到输出缓冲区中，再由 TCP 协议将数据从输出缓冲区发送到目标主机。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过 Socket 接收数据也是如此，也是从输入缓冲区中读取数据，而不是直接从网络中读取。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3277634961439589&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hXEWOsco2BU9huQ60hARKy70SiaQqquPXRica0nCbPMqBQIN36JFvrflb4eTVAsqfa4jiaPfYRMouInWnsymoKqEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;778&quot;/&gt;&lt;figcaption&gt;Socket缓冲区&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3 用户空间、内核空间、系统调用&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作系统的进程空间可以分为用户空间（User Space）和内核空间（Kernel Space），它们需要不同的执行权限。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;大多数系统交互式操作需要在内核空间中运行，比如设备 IO 操作。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;我们的应用程序运行在用户空间，是不具备系统级的直接操作权限的。如果应用程序想要访问系统核心功能，必须通过系统调用（System Call）来完成。比如调用&lt;code&gt;recv()&lt;/code&gt;函数，会将输入缓冲区中的内容拷贝到用户缓冲区。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;系统调用运行在内核空间，是操作系统为应用程序提供的接口。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8203309692671394&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hXEWOsco2BU9huQ60hARKy70SiaQqquPXicSf7KLq2aDCDj2vKsNqVjXnsoiboUQnl7xGWjnXzWf09Rs1FRD5hsdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;423&quot;/&gt;&lt;figcaption&gt;用户空间、内核空间、系统调用&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面列举了一些 Linux 操作系统中的系统调用接口（部分函数后面章节会用到）：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;socketcall socket系统调用&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;socket 建立socket&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;bind 绑定socket到端口&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;connect 连接远程主机&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;accept 响应socket连接请求&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;send 通过socket发送信息&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;sendto 发送UDP信息&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;recv 通过socket接收信息&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;recvfrom 接收UDP信息&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;listen 监听socket端口&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;select 对多路同步IO进行轮询&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;shutdown 关闭socket上的连接&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;sigaction 设置对指定信号的处理方法&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.4 阻塞与非阻塞&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阻塞与非阻塞，用于描述调用者在等待返回结果时的状态。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;阻塞：调用者发起请求后，会一直等待返回结果，这期间当前线程会被挂起（阻塞）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;非阻塞：调用者发起请求后，会立刻返回，当前线程也不会阻塞。该调用不会立刻得到结果，调用者需要定时轮询查看处理状态。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.5 同步与异步&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而同步与异步，用于描述调用结果的返回机制（或者叫通信机制）。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;同步：调用者发起请求后，会一直等待返回结果，即由调用者主动等待这个调用结果。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;异步：调用者发起请求后，会立刻返回，但不会立刻得到这个结果，而是由被调者在执行结束后主动通知（如 Callback）调用者。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 五种 IO 模型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IO 模型是指：用什么样的通道或者说是通信模式进行数据的传输，这很大程序上决定了程序通信的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 系统为我们提供五种可用的 IO 模型：阻塞式 IO 模型、非阻塞式 IO 模型、IO 多路复用模型、信号驱动 IO 模型和异步 IO 模型。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 阻塞式 IO 模型&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阻塞式 IO （Blocking IO）：应用进程从发起 IO 系统调用，至内核返回成功标识，这整个期间是处于阻塞状态的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4975369458128079&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hXEWOsco2BU9huQ60hARKy70SiaQqquPXMhK6Kleq0ppRJAt8K0Go9zKnDzibQIeTICzH87M3u8m0H9bot1HcRPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;609&quot;/&gt;&lt;figcaption&gt;阻塞式 IO 模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 非阻塞式 IO 模型&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非阻塞式IO（Non-Blocking IO）：应用进程可以将 Socket 设置为非阻塞，这样应用进程在发起 IO 系统调用后，会立刻返回。应用进程可以轮询的发起 IO 系统调用，直到内核返回成功标识。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5062937062937063&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hXEWOsco2BU9huQ60hARKy70SiaQqquPXCZFRPgdo3qLQOfJIvAsWVM5lJ7pleDTVMgDoeWpCOmI01A5J26iawCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;715&quot;/&gt;&lt;figcaption&gt;非阻塞式 IO 模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 IO 多路复用模型&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IO 多路复用（IO Multiplexin）：可以将多个应用进程的 Socket 注册到一个 Select（多路复用器）上，然后使用一个进程来监听该 Select（该操作会阻塞），Select 会监听所有注册进来的 Socket。只要有一个 Socket 的数据准备好，就会返回该Socket。再由应用进程发起 IO 系统调用，来完成数据读取。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4978843441466855&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hXEWOsco2BU9huQ60hARKy70SiaQqquPXCo0icuTS9ibaUFqu4RfFxzu7nJbcicZkjsYZH5rbHszSuQ06JQLeDBjYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;709&quot;/&gt;&lt;figcaption&gt;IO 多路复用模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 信号驱动 IO 模型&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;信号驱动 IO（Signal Driven IO）：可以为 Socket 开启信号驱动 IO 功能，应用进程需向内核注册一个信号处理程序，该操作并立即返回。当内核中有数据准备好，会发送一个信号给应用进程，应用进程便可以在信号处理程序中发起 IO 系统调用，来完成数据读取了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hXEWOsco2BU9huQ60hARKy70SiaQqquPXA6UI8JXDhiaG2SkUcoxS3t63tuoGOzb84oQ3ek2E8DYOjr6hLUSSGGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;738&quot;/&gt;&lt;figcaption&gt;信号驱动 IO 模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5 异步 IO 模型&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步 IO（Asynchronous IO）：应用进程发起 IO 系统调用后，会立即返回。当内核中数据完全准备后，并且也复制到了用户空间，会产生一个信号来通知应用进程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5646551724137931&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hXEWOsco2BU9huQ60hARKy70SiaQqquPX3TlRa2xsdrxCwBUykWG0DcjIM1wibI0ib1ISzibiaicRoJib1xeWJFbGkTicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;696&quot;/&gt;&lt;figcaption&gt;异步 IO 模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上述五种 IO 模型可以看出，应用进程对内核发起 IO 系统调用后，内核会经过两个阶段来完成数据的传输：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;第一阶段：等待数据。即应用进程发起 IO 系统调用后，会一直等待数据；当有数据传入服务器，会将数据放入内核空间，此时数据准备好。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;第二阶段：将数据从内核空间复制到用户空间，并返回给应用程序成功标识。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5015479876160991&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hXEWOsco2BU9huQ60hARKy70SiaQqquPXBZl6CTrmB9w31Yiakh7OYvRtGRPNFwPcuIpo0bEw7FGiaETlGRlicgzVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;646&quot;/&gt;&lt;figcaption&gt;五种 IO 模型对比&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前四种模型的第二阶段是相同的，都是处于阻塞状态，其主要区别在第一阶段。而异步 IO 模型则不同，应用进程在这两个阶段是完全不阻塞的。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;IO 模型&lt;/th&gt;&lt;th&gt;第一阶段&lt;/th&gt;&lt;th&gt;第二阶段&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;阻塞式IO&lt;/td&gt;&lt;td&gt;阻塞&lt;/td&gt;&lt;td&gt;阻塞&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;非阻塞式IO&lt;/td&gt;&lt;td&gt;非阻塞&lt;/td&gt;&lt;td&gt;阻塞&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;IO多路程复用&lt;/td&gt;&lt;td&gt;阻塞（Select）&lt;/td&gt;&lt;td&gt;阻塞&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;信号驱动式IO&lt;/td&gt;&lt;td&gt;异步&lt;/td&gt;&lt;td&gt;阻塞&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;异步IO&lt;/td&gt;&lt;td&gt;异步&lt;/td&gt;&lt;td&gt;异步&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6933333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/hXEWOsco2BU9huQ60hARKy70SiaQqquPXicM4sSibKymWZu5NfRh8NNj6DsQx6NMkgALmtdibodUmDUVOW2nwgyHlg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;750&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>