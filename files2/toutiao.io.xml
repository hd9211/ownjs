<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>86f48cb8792d5df8a06fe1dad75dbdbc</guid>
<title>分布式一致性协议：ZAB</title>
<link>https://toutiao.io/k/r6571za</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-content&quot;&gt;&lt;h3 id=&quot;ZAB-背景&quot;&gt;&lt;a href=&quot;#ZAB-背景&quot; class=&quot;headerlink&quot; title=&quot;ZAB 背景&quot;/&gt;ZAB 背景&lt;/h3&gt;&lt;p&gt;学习ZAB，非常有必要聊聊它诞生的背景。因为在paxos的光芒下，还有必要折腾这样类似的算法吗？这个问题是我们初步了解ZAB关键。&lt;/p&gt;
&lt;p&gt;看到这里，我断定大家都使用过zookeeper，并且知道zookeeper的核心就是ZAB协议。如果没有的话，需要先学习下zookeeper。毕竟基础不牢，地动山摇。&lt;/p&gt;
&lt;p&gt;这里多提一句，ZAB的作者说ZAB不是paxos，但是后面我们又把ZAB归纳为paxos。这里我认为啊，这两个说法都对，只是他们描述的时间不一致。在ZAB诞生的时候，它解决了paxos不能保证顺序执行的问题，从某些角度来说ZAB是要paxos优秀的，说它不是paxos也没问题。但是后来随来越来越多分布式算法诞生，例如raft，因为他们都类似paxos执行逻辑，所以将这类算法归纳为paxos的变种。&lt;/p&gt;
&lt;h4 id=&quot;为何不使用paxos来实现zookeeper&quot;&gt;&lt;a href=&quot;#为何不使用paxos来实现zookeeper&quot; class=&quot;headerlink&quot; title=&quot;为何不使用paxos来实现zookeeper&quot;/&gt;为何不使用paxos来实现zookeeper&lt;/h4&gt;&lt;p&gt;回过头来，ZAB诞生的原因，我们先考虑zookeeper能不能直接使用paxos作为分布式一致性算法？答案肯定是否定的，我们举个例子，假设有个客户端需要分别创建目录：/foo, /foo/ofcoder。&lt;/p&gt;
&lt;p&gt;在前文我们学习过了paxos，知道paxos能集群就某个值达成共识，但是却不关心达成共识的值是什么。如果zookeeper直接使用paxos，就会出现在没有创建/foo的时候，创建/foo/ofcoder。显然这就报错了，因为ofcoder的上级目录不存在。为了描述这个问题，我们描述下过程。&lt;/p&gt;
&lt;p&gt;假如有同一个业务请求，因为入参不一样，导致最后要达成共识的值也不一样。例如proposerA，收到请求先后创建/foo, /foo/ofcoder两个节点。proposerB收到请求先后创建/method，/method/far节点。&lt;br/&gt;&lt;img src=&quot;/images/theory/distributed/zab_1.png&quot; alt=&quot;paxos不适合实现zookeeper&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;proposerB先发起paxos的prepare阶段，并获得大多数选票，开始accept阶段。&lt;/li&gt;
&lt;li&gt;在proposerB的accept阶段，只有acceptA接收了提案[1, /method]，其他节点都通过了proposerA的prepare请求。&lt;/li&gt;
&lt;li&gt;根据规定，proposeA的accept的提案应该为[2, /method]，并通过该提案。&lt;/li&gt;
&lt;li&gt;此时proposerB重新开始paxos的两个阶段，得到达成共识的提案是[2, /method]。&lt;/li&gt;
&lt;li&gt;proposerA开始第二个值的paxos过程，即/foo/ofcoder。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;到此为止，可以看到当proposerA开始创建/foo/ofcoder时，则会发现/foo没有创建而导致失败。因为在第一轮paxos在集群中达成共识的值/method。&lt;/p&gt;
&lt;p&gt;通过上面的过程，我们更加论证了，paxos只适合在集群中使某个值达成共识，而不关心达成共识的值是什么。而在zookeeper中，这显然是不能满足业务需求的。&lt;/p&gt;
&lt;h3 id=&quot;ZAB术语科普&quot;&gt;&lt;a href=&quot;#ZAB术语科普&quot; class=&quot;headerlink&quot; title=&quot;ZAB术语科普&quot;/&gt;ZAB术语科普&lt;/h3&gt;&lt;p&gt;ZAB并不像paxos，是一种通用的分布式一致性算法，ZAB是一种专门为zookeeper设计的崩溃可恢复的原子广播协议。相比于paxos，&lt;strong&gt;ZAB主要解决了事务操作的顺序性&lt;/strong&gt;，在ZAB协议中，如果一个事务操作被处理了，那么所有其依赖的事务操作都应该被提前处理了。&lt;/p&gt;
&lt;p&gt;在学习ZAB之前，我们需要先整理几个术语、因为在ZAB的论文中，术语相对比较多，并且概念冗余。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提案（proposal）：进行协商的基本单元，在一些文档中，也有称之为操作（operation）、指令（command）。&lt;/li&gt;
&lt;li&gt;事务（transaction）：也是指提案，常出现在代码中，并非指具有ACID特性的一组操作。&lt;/li&gt;
&lt;li&gt;已提出的Proposal：指广播的第一阶段所提出的Proposal，未提交到状态机的Proposal。&lt;/li&gt;
&lt;li&gt;已提交的Proposal：指广播的第二阶段已提交到状态机的Proposal。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了帮助我们理解，ZAB定义了三个角色、四种节点状态、四种ZAB运行状态、以及两种运行模式。大家别看到我罗列了这么多，就打退堂鼓。从多个角度来归纳，只是为了更好的给大家呈现ZAB内部原理。&lt;/p&gt;
&lt;h4 id=&quot;三个角色&quot;&gt;&lt;a href=&quot;#三个角色&quot; class=&quot;headerlink&quot; title=&quot;三个角色&quot;/&gt;三个角色&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;观察者（observer）&lt;br/&gt;跟paxos中学习者类似，增加observer，可以在不影响集群写性能的情况下，提升读性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;四种节点状态&quot;&gt;&lt;a href=&quot;#四种节点状态&quot; class=&quot;headerlink&quot; title=&quot;四种节点状态&quot;/&gt;四种节点状态&lt;/h4&gt;&lt;p&gt;这是一个容易忽视的点，ZAB虽然规定了三种角色，但是他是通过定义四种状态来描述当前节点所处的角色的。包含以下状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LOOKING，竞选状态，当前集群不存在Leader。该状态下会发起领导者选举。&lt;/li&gt;
&lt;li&gt;FOLLOWING，随从状态，同步Leader状态，参与投票。&lt;/li&gt;
&lt;li&gt;OBSERVING，观察状态，同步Leader状态，不参与投票。&lt;/li&gt;
&lt;li&gt;LEADING，领导者状态，对应Leader角色。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里与角色对应多出来一个状态，是因为ZAB是支持自动Leader选举的，LOOKING是属于选举中的一个过渡状态。&lt;/p&gt;
&lt;h4 id=&quot;四种ZAB运行状态&quot;&gt;&lt;a href=&quot;#四种ZAB运行状态&quot; class=&quot;headerlink&quot; title=&quot;四种ZAB运行状态&quot;/&gt;四种ZAB运行状态&lt;/h4&gt;&lt;p&gt;这里是指ZAB集群的运行状态，因为ZAB除了正常向外部提供服务，还得有故障恢复功能。从整个集群的状态，我们可以了解ZAB的运行过程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ELECTION，选举状态，表明节点正在进行Leader选举&lt;/li&gt;
&lt;li&gt;DISCOVERY，成员发现状态，在选举出新Leader后集群所处的状态，用于节点协商沟通Leader的合法性&lt;/li&gt;
&lt;li&gt;SYNCHRONIZATION，数据同步状态，在确认新Leader后，以Leader的数据为基础，修复各个节点的数据一致性&lt;/li&gt;
&lt;li&gt;BROADCARST，广播状态，集群处于正常运行状态，可向外提供服务&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;两种运行模式&quot;&gt;&lt;a href=&quot;#两种运行模式&quot; class=&quot;headerlink&quot; title=&quot;两种运行模式&quot;/&gt;两种运行模式&lt;/h4&gt;&lt;p&gt;从上述ZAB运行状态中，可以归纳为两种运行模式，即消息广播模式、崩溃恢复模式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;崩溃恢复模式：&lt;br/&gt;在整个服务框架启动过程中、或者Leader服务器出现网络中断、崩溃退出等异常情况时，ZAB协议就会进入崩溃恢复模式并选举新的Leader服务器。当新的Leader服务器在集群中有过半的Follower与其完成成数据同步后，ZAB就会退出崩溃恢复模式。&lt;/li&gt;
&lt;li&gt;消息广播模式：&lt;br/&gt;当集群中已有过半的Follower与Leader完成数据同步，那么整个集群就会进入消息广播模式。此时整个集群才可以对外提供服务，即数据的查询、修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;值得注意是，当一台新的ZAB节点加入集群时，该节点会先进入崩溃恢复模式，找到Leader，并与其进行数据同步，然后一起参与到消息广播流程中。所以崩溃恢复模式还分为两个阶段：发现、同步。具体后文会详细讲解。&lt;/p&gt;
&lt;p&gt;后文讲解思路也是从这两种模式入手，在崩溃恢复模式中，再细分为三个阶段，也就是四种运行状态的前三种（ELECTION、DISCOVERY、SYNCHRONIZATION）。&lt;/p&gt;
&lt;h4 id=&quot;zxid&quot;&gt;&lt;a href=&quot;#zxid&quot; class=&quot;headerlink&quot; title=&quot;zxid&quot;/&gt;zxid&lt;/h4&gt;&lt;p&gt;这里把zxid单独拎出来描述，zxid在ZAB占据很重要的位置。Leader在收到事务请求，将其封装成Proposal时，会为每个Proposal生成对应的zxid。&lt;/p&gt;
&lt;p&gt;在消息广播模式中zxid标志者事务请求的先后顺序，在崩溃恢复模式中zxid是Leader的选举的判断依据，以及在Leader选举后，数据同步中zxid能方便的帮助ZAB抛弃上一个Leader没完成的Proposal。所以在学习下面的内容时，要及时参考zxid的设计逻辑。&lt;/p&gt;
&lt;p&gt;zxid它是一个64位，其中低32位可以看成一个简单的&lt;strong&gt;计数器&lt;/strong&gt;，而高32位则代表了Leader周期的&lt;strong&gt;epoch编号&lt;/strong&gt;。后文中使用&amp;lt;epoch, counter&amp;gt;标示一个zxid，例如&amp;lt;1, 101&amp;gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;epoch，则标示者当前集群所处的周期（年代），或者说当前Leader的周期（年代）。在每一次Leader变更后，新Leader产生的epoch则会在上一任Leader的epoch上进行加1，作为自己的epoch。&lt;/li&gt;
&lt;li&gt;计数器，则是针对客户端每一个事务请求，Leader在产生新的Proposal事务时，都会对该计数器加1。而Leader变更后，该计数器则会重置为0。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样做的好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计数器，可以定义Proposal的先后顺序，保证发送提交事务消息广播顺序。&lt;/li&gt;
&lt;li&gt;epoch+计数器，能有效的避免zxid的冲突，不会出现Leader使用了相同编号的zxid提出了不一样的Proposal。&lt;/li&gt;
&lt;li&gt;能随时获取到最新的Leader周期（epoch），当Leader收到在网络故障后，收到比他大的epoch的Proposal，则证明集群中已有其他Leader，自己则变更为Follower。&lt;/li&gt;
&lt;li&gt;新Leader产生的zxid一定比上一任Leader产生zxid大。当上一任Leader宕机恢复后（以Follower角色）加入集群，如果有尚未提交的事务，则可以对比zxid进行抛弃（回退）那一些Proposal，直到回退到一个确实已经被集群中过半机器Commit的最新Proposal。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第3, 4点如果现在看不明白，在讲述崩溃恢复模式时，我会回过头来再讲讲的。&lt;/p&gt;
&lt;h3 id=&quot;消息广播模式&quot;&gt;&lt;a href=&quot;#消息广播模式&quot; class=&quot;headerlink&quot; title=&quot;消息广播模式&quot;/&gt;消息广播模式&lt;/h3&gt;&lt;p&gt;总的来说，消息广播模式是一个类似于二阶段提交（2PC）过程，针对客户端事务请求，Leader将其生成对应的Proposal，并发给所有的Follower，收集各自的选票后，最后进行事务提交。&lt;strong&gt;与2PC不同的是，ZAB移除了第二阶段的中断逻辑&lt;/strong&gt;。所有的Follower要么接收该Proposal，要么抛弃Leader服务器。这意味着Leader收到过半的Ack响应后就可以提交该事务了，而不需要等待所有的Follower都返回Ack。&lt;/p&gt;
&lt;p&gt;由于ZAB为了严格保证Proposal的因果关系，即事务请求的顺序性，ZAB为每个Proposal生成对应的zxid，并严格按照zxid的顺序，进行消息的广播。具体的，Leader会为了Follower分配一个单独的队列，将消息广播前，先将Proposal按照zxid顺序依次放入这些队列中，并根据FIFO策略进行消息发送。&lt;/p&gt;
&lt;p&gt;Follower在收到事务Proposal之后，都会将其以事务日志的形式写入本地磁盘中，并在写入成功后，返回给Leader一个Ack响应。当Leader服务器收到过半的Follower的Ack响应后，就会广播Commit消息给所有Follower通知其进行事务提交，同时Leader自身也会完成事务的提交。至此整个消息广播模式完成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/theory/distributed/zab_4.png&quot; alt=&quot;消息广播&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端发起事务请求，由Leader进行处理&lt;/li&gt;
&lt;li&gt;Leader将该请求转换为事务Proposal，同时为Proposal分配一个全局的ID，即zxid&lt;/li&gt;
&lt;li&gt;Leader为每个Follower维护一个FIFO队列，将上一步生成的Proposal放入队列中，进行广播&lt;/li&gt;
&lt;li&gt;Follower收到Proposal后，会首先将其以事务日志的方式写入本地磁盘中，写入成功后向Leader反馈一个&lt;/li&gt;
&lt;li&gt;响应消息&lt;/li&gt;
&lt;li&gt;Leader收到过半的Ack响应后，自己完成对该Proposal的提交后，向每个Follower的队列中，写入Commit消息进行广播&lt;/li&gt;
&lt;li&gt;Follower接收到Commit消息后，会将上一条事务提交&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;如何保证事务执行的顺序&quot;&gt;&lt;a href=&quot;#如何保证事务执行的顺序&quot; class=&quot;headerlink&quot; title=&quot;如何保证事务执行的顺序&quot;/&gt;如何保证事务执行的顺序&lt;/h4&gt;&lt;p&gt;此时，我们得回到zxid的构成那部分，ZAB就是通过zxid中计数器，来保证提交顺序的，具体如下：&lt;/p&gt;
&lt;p&gt;在Leader收到客户端&lt;code&gt;set X、set Y&lt;/code&gt;两个请求后，会将其封装成两个Proposal（&amp;lt;1, 101&amp;gt;: X， &amp;lt;1, 102&amp;gt;: Y）进行广播所有的Follower。&lt;br/&gt;&lt;img src=&quot;/images/theory/distributed/zab_5.png&quot; alt=&quot;消息广播&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当Leader收到过半的Ack响应后，则会进行Commit消息的广播。这里需要注意，&lt;strong&gt;Leader提交提案是有顺序性的&lt;/strong&gt;，按照zxid的大小，按顺序提交提案，&lt;strong&gt;如果前一个提案未提交，此时是不会提交后一个提案的&lt;/strong&gt;。因此X一定在Y之前提交。&lt;br/&gt;&lt;img src=&quot;/images/theory/distributed/zab_6.png&quot; alt=&quot;消息广播&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，Leader返回执行成功响应给客户端。完成本次消息广播。&lt;/p&gt;
&lt;h3 id=&quot;崩溃恢复模式&quot;&gt;&lt;a href=&quot;#崩溃恢复模式&quot; class=&quot;headerlink&quot; title=&quot;崩溃恢复模式&quot;/&gt;崩溃恢复模式&lt;/h3&gt;&lt;p&gt;通过上面的了解，我们知道了ZAB其实是一个强领导者模型的协议。消息广播模式，只能在ZAB正常运行中向外部提供服务。这也要求ZAB设计者不得不考虑，当Leader宕机或者失去过半的Follower节点后，如何恢复整个集群。&lt;/p&gt;
&lt;p&gt;为了更好理解崩溃恢复模式原理，通常会把他分为两个阶段或者三个阶段，即（Leader选举、Leader发现）、数据同步。&lt;/p&gt;
&lt;h4 id=&quot;基本约定&quot;&gt;&lt;a href=&quot;#基本约定&quot; class=&quot;headerlink&quot; title=&quot;基本约定&quot;/&gt;基本约定&lt;/h4&gt;&lt;p&gt;在选举新的Leader后，向外部提供服务之前，ZAB还需要保证数据正确性，即上一个Leader崩溃之时，正在处理的事务请求，可能会出现两个数据不一致的隐患。针对这样情况，ZAB保证一下特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ZAB需要确保那些已经在Leader上&lt;strong&gt;提交&lt;/strong&gt;的事务最终被所有服务器都提交&lt;br/&gt;即：ProposalA在Leader上被提出后，收到过半的Follower的Ack响应，但是在将Commit请求广播给所有Follower机器之前，Leader宕机了。&lt;br/&gt;&lt;img src=&quot;/images/theory/distributed/zab_2.png&quot; alt=&quot;ZAB崩溃恢复&quot;/&gt;&lt;br/&gt;在该图中，Leader先后广播了P1, P2, C1, P3, C2。其中Leader在广播C2（P2的Commit请求）之前宕机，ZAB会在崩溃恢复模式中，让所有的服务器都提交C2。&lt;/li&gt;
&lt;li&gt;ZAB需要确保丢弃那些仅仅只在Leader上被&lt;strong&gt;提出&lt;/strong&gt;的事务&lt;br/&gt;即：该约定是指，ZAB会抛弃那些只在Leader上被提出的事务，还没有任何Follower收到该请求。&lt;br/&gt;&lt;img src=&quot;/images/theory/distributed/zab_3.png&quot; alt=&quot;ZAB崩溃恢复&quot;/&gt;&lt;br/&gt;在该场景中，Leader提出P3后宕机，还没有任何Follower收到该请求，则崩溃恢复模式中，整个集群会丢弃P3的事务。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;Leader选举（ELECTION）&quot;&gt;&lt;a href=&quot;#Leader选举（ELECTION）&quot; class=&quot;headerlink&quot; title=&quot;Leader选举（ELECTION）&quot;/&gt;Leader选举（ELECTION）&lt;/h4&gt;&lt;p&gt;Leader的选举，关乎着整个集群的故障容错和集群可用性，是ZAB非常核心的设计之一。而Leader选举说白了，就是对比集群中各节点的信息，选举出最合适的节点当做Leader。而最合适的节点标准是什么，则是理解Leader选举（FastLeaderElection方式）的关键。&lt;/p&gt;
&lt;p&gt;ZAB采用的各节点广播自己所提议的Leader，收到其他节点提议的Leader后，与自己所提议的Leader进行PK，根据PK的规则重新选择提议的Leader，直到有过半的节点都提议某一节点，即结束Leader选举。&lt;/p&gt;
&lt;p&gt;Leader选举PK的规则包含以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任期编号（epoch），优先判断epoch，epoch大的节点当选Leader&lt;/li&gt;
&lt;li&gt;事务标示符（zxid），epoch相同，则比较zxid，zxid大的当选Leader&lt;/li&gt;
&lt;li&gt;节点ID，epoch、zxid都一致，则比较节点ID（在myid文件中指定的值）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为选举规则包含上述三个方面，则每个节点在广播自己所提议的Leader时，选票中都会包含上面三个值。后文使用&amp;lt;proposeLeader, epoch, zxid, node&amp;gt;，来表示一张选票，表明自己所有提议的Leader。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;proposeLeader，表示自己所提议的Leader的节点ID&lt;/li&gt;
&lt;li&gt;epoch，表示所提议的Leader节点所处的任期编号&lt;/li&gt;
&lt;li&gt;zxid，表示所提议的Leader节点拥有的Proposal最大的事务编号&lt;/li&gt;
&lt;li&gt;node，表示本次提议的节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里需要注意的是，这里的zxid是指ZAB在消息广播模式第一阶段的收到Proposal最大的zxid，即：&lt;strong&gt;节点收到被提出的Proposal最大的zxid，而不是已提交的Proposal最大的zxid&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这里需要单独拎出来强调，有的伙计，在看zookeeper源码时，会看到Leader选举时，使用的是dataTree.lastProcessedZxid。而dataTree.lastProcessedZxid表示的是已提交的Proposal最大的zxid。这里没错，在正常运行时dataTree.lastProcessedZxid确实表示的是已提交的Proposal最大的zxid。但是当跟随者检测到异常，退出FOLLOWING状态时，在follower.shutdown()中，会使用lastProcessedZxid表示节点上收到已提出的Proposal的zxid。而后续的Leader选举使用的lastProcessedZxid，即为节点收到被提出的Proposal最大的zxid。&lt;/p&gt;
&lt;h5 id=&quot;算法陈述&quot;&gt;&lt;a href=&quot;#算法陈述&quot; class=&quot;headerlink&quot; title=&quot;算法陈述&quot;/&gt;算法陈述&lt;/h5&gt;&lt;p&gt;集群中存在三个节点A, B, C，各自节点ID依次为1, 2, 3。其中A为Leader，已提交两个Proposal（&amp;lt;1, 101&amp;gt;，&amp;lt;1, 102&amp;gt;），B、C为Follower，B已提交两个Proposal（&amp;lt;1, 101&amp;gt;，&amp;lt;1, 102&amp;gt;），C只提交了&amp;lt;1, 101&amp;gt;&lt;br/&gt;&lt;img src=&quot;/images/theory/distributed/zab_7.png&quot; alt=&quot;Leader选举&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当A节点宕机后，跟随者检测Leader异常，则退出FOLLOWING状态，变更为LOOKING，发起Leader选举。&lt;br/&gt;&lt;img src=&quot;/images/theory/distributed/zab_8.png&quot; alt=&quot;Leader选举&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当Follower开始第一轮提议Leader时，都会推荐自己为Leader，并向所有节点广播自己的提议，即B的选票为&amp;lt;2, 1, 102, B&amp;gt;，C的选票为&amp;lt;3, 1, 101, C&amp;gt;。各自将选票发给其他节点，B的选票发送给B、C，C的选票也发送给B、C。&lt;br/&gt;&lt;img src=&quot;/images/theory/distributed/zab_9.png&quot; alt=&quot;Leader选举&quot;/&gt;&lt;/p&gt;
&lt;p&gt;B, C收到对方的选票后，根据上面描述的规则进行PK，依次比较epoch、zxid、节点ID。B、C首先会收到来自自己的提议的选票，因为收到选票与自己提议的选票相同，只需要接受和保存该选票。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当B收到来自C的选票&amp;lt;3, 1, 101, C&amp;gt;，由于epoch相同，B的zxid大于C的zxid，则B的选票获胜，不需要变更选票信息，保存即可。&lt;/li&gt;
&lt;li&gt;C收到来自B的选票&amp;lt;2, 1, 102, B&amp;gt;，由于epoch相同，C的zxid小于B的zxid，则C的选票落选。需要保存B的选票&amp;lt;2, 1, 102, B&amp;gt;，并变更自己的选票为&amp;lt;2, 1, 102, C&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/theory/distributed/zab_10.png&quot; alt=&quot;Leader选举&quot;/&gt;&lt;/p&gt;
&lt;p&gt;C节点在变更自己的选票信息后，会重新广播选票&amp;lt;2, 1, 102, C&amp;gt;给其他节点。B, C节点都收到来自C的新选票信息&amp;lt;2, 1, 102, C&amp;gt;，根据规则继续PK，结果肯定是B, C都保存两个选票（&amp;lt;2, 1, 102, B&amp;gt;, &amp;lt;2, 1, 102, C&amp;gt;）&lt;br/&gt;&lt;img src=&quot;/images/theory/distributed/zab_11.png&quot; alt=&quot;Leader选举&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，B, C所提议的领导者节点ID为2（即B节点），赢得了过半选票。则B竞选为准Leader，退出LOOKING状态，变更为LEADING，C节点变更状态为FOLLOWING，完成Leader选举。&lt;br/&gt;&lt;img src=&quot;/images/theory/distributed/zab_12.png&quot; alt=&quot;Leader选举&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;逻辑时钟&quot;&gt;&lt;a href=&quot;#逻辑时钟&quot; class=&quot;headerlink&quot; title=&quot;逻辑时钟&quot;/&gt;逻辑时钟&lt;/h5&gt;&lt;p&gt;这里需要补充的是逻辑时钟，逻辑时钟也会影响Leader的选举，单独拎出来是为了描述选举算法时思路更清晰。&lt;/p&gt;
&lt;p&gt;逻辑时钟（logicclock），即选举的轮次，避免接收到旧的选票信息。每进行一轮选举，逻辑时钟变会增加。在选举中，逻辑时钟大的节点不会接收来自逻辑时钟小的节点的选票。&lt;/p&gt;
&lt;p&gt;比如，节点A, B的逻辑时钟分别为1, 2，那么B将拒绝接收来自A的选票信息。即使A的zxid大于B的zxid，B也会拒绝接收该选票。&lt;/p&gt;
&lt;h4 id=&quot;发现（DISCOVERY）&quot;&gt;&lt;a href=&quot;#发现（DISCOVERY）&quot; class=&quot;headerlink&quot; title=&quot;发现（DISCOVERY）&quot;/&gt;发现（DISCOVERY）&lt;/h4&gt;&lt;p&gt;在上一阶段，也就是ELECTION完成后，每个节点都有自己所保存的选票池，当选池中有过半的选票都提议同一节点为Leader时，则进入发现（DISCOVERY）状态。&lt;/p&gt;
&lt;p&gt;本节思路：会先按每一小步介绍过程，后面会画出整个过程的周期，所以每一小步会记作一个标记，方便后面描述整个过程。&lt;/p&gt;
&lt;p&gt;继续上一小节的案例。A, B, C三个节点，A宕机了，B为新选举的准Leader。其中B已提交两个Proposal（&amp;lt;1, 101&amp;gt;，&amp;lt;1, 102&amp;gt;），C只提交了&amp;lt;1, 101&amp;gt;。&lt;/p&gt;
&lt;p&gt;在该状态期间，由Follower会主动联系准Leader，并将自己最后接受的事务Proposal的epoch值发送给准Leader，这里记作FOLLOWERINFO。&lt;br/&gt;&lt;img src=&quot;/images/theory/distributed/zab_13.png&quot; alt=&quot;发现（DISCOVERY）&quot;/&gt;&lt;/p&gt;
&lt;p&gt;准Leader收到来自过半（包含B节点自己）的FOLLOWERINFO消息后，会从这个FOLLOWERINFO中选取最大的epoch值，对其进行加1，作为新的epoch值，并封装成LEADERINFO消息发给这些过半的Follower。&lt;br/&gt;&lt;img src=&quot;/images/theory/distributed/zab_14.png&quot; alt=&quot;发现（DISCOVERY）&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当Follower收到LEADERINFO消息后，会先校验LEADERINFO消息正确性。校验自己的epoch是否小于LEADERINFO消息中的epoch，如果小于，就将LEADERINFO消息中的epoch赋值给自己的epoch。并向准Leader返回Ack响应（ACKEPOCH），并将自己的运行状态变更为SYNCHRONIZATION。&lt;br/&gt;&lt;img src=&quot;/images/theory/distributed/zab_15.png&quot; alt=&quot;发现（DISCOVERY）&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后Leader收到过半的ACKEPOCH消息后，也将自己的运行状态修改为SYNCHRONIZATION。至此完成发现阶段的工作，集群确立Leader的领导关系。&lt;/p&gt;
&lt;h4 id=&quot;数据同步（SYNCHRONIZATION）&quot;&gt;&lt;a href=&quot;#数据同步（SYNCHRONIZATION）&quot; class=&quot;headerlink&quot; title=&quot;数据同步（SYNCHRONIZATION）&quot;/&gt;数据同步（SYNCHRONIZATION）&lt;/h4&gt;&lt;p&gt;进入到数据同步阶段，我们需要先了解三种同步方式（DIFF、TRUNC、SNAP）。Leader会根据每个Follower的最大zxid，采用不同方式处理不一致的数据。&lt;/p&gt;
&lt;p&gt;在ZAB的设计中，Leader为了更高效的将Proposal复制给Follower，会在自己的内存队列中缓存一定数量（默认500）的已提交的Proposal。在内存中的Proposal就有zxid的最大值和最小值，即：maxCommittedZxid和minCommittedZxid。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DIFF：当Follower最大的zxid小于maxCommittedZxid且大于minCommittedZxid&lt;/li&gt;
&lt;li&gt;TRUNC：当Follower最大的zxid大于maxCommittedZxid时，该方式要求Follower丢弃超出的那部分Proposal&lt;/li&gt;
&lt;li&gt;SNAP：当Follower最大的zxid小于minCommittedZxid时，该方式直接同步快照给Follower&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;了解了同步方式，接下来来看看具体怎么交互的吧。该阶段由Leader根据Follower的最大zxid来发送数据同步消息。由于B已提交两个Proposal（&amp;lt;1, 101&amp;gt;，&amp;lt;1, 102&amp;gt;），C只提交了&amp;lt;1, 101&amp;gt;。该情况下Leader会选择DIFF的方式将其封装为NEWLEADER消息发给Follower。&lt;/p&gt;
&lt;p&gt;Follower在收到NEWLEADER消息后，进行修复不一致数据，并返回给Leader响应Ack消息。&lt;br/&gt;&lt;img src=&quot;/images/theory/distributed/zab_16.png&quot; alt=&quot;数据同步（SYNCHRONIZATION）&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Leader在收到过半Ack消息后，则完成数据同步阶段，将自己运行状态修改为BROADCARST（广播状态），并发送UPTODATE消息给过半的Follower，通知他们完成数据同步，修改运行状态修改为BROADCARST。&lt;/p&gt;
&lt;h4 id=&quot;整体回顾&quot;&gt;&lt;a href=&quot;#整体回顾&quot; class=&quot;headerlink&quot; title=&quot;整体回顾&quot;/&gt;整体回顾&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/images/theory/distributed/zab_17.png&quot; alt=&quot;整体回顾&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;与paxos区别&quot;&gt;&lt;a href=&quot;#与paxos区别&quot; class=&quot;headerlink&quot; title=&quot;与paxos区别&quot;/&gt;与paxos区别&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;ZAB采用的是主备模式的系统架构，相比于paxos不同的是，paxos可以同时存在多个提议者进行提案，而ZAB同一时间只允许一个领导者进行提案，这样即解决客户端并发处理，又能规定提案的顺序性。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;思考几个题目吧&quot;&gt;&lt;a href=&quot;#思考几个题目吧&quot; class=&quot;headerlink&quot; title=&quot;思考几个题目吧&quot;/&gt;思考几个题目吧&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;zookeeper提供的最终一致性，任何节点都能处理读请求，但是读到的可能会是旧数据，如果必须要读到最新数据，怎么办？&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;zookeeper提供解决方案就是：&lt;span class=&quot;keyword&quot;&gt;sync&lt;/span&gt;命令。&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;你可以在读操作之前，先执行&lt;span class=&quot;keyword&quot;&gt;sync&lt;/span&gt;命令，这样客户端就能读到最新数据了。&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A, B, C三个节点，A为Leader，B有2个已提交的Proposal(&amp;lt;1, 101&amp;gt;, &amp;lt;1, 102&amp;gt;)，C有3个未提交Proposal(&amp;lt;1, 101&amp;gt;, &amp;lt;1, 102&amp;gt;, &amp;lt;1, 103&amp;gt;)。当A故障后，B和C谁会当选Leader呢？&lt;/p&gt;
&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;答案是C。&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;因为竞选Leader时，使用的是所有已提出的Proposal最大zxid。&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;C最大的zxid为&lt;span class=&quot;number&quot;&gt;103&lt;/span&gt;，而B最大的zxid为&lt;span class=&quot;number&quot;&gt;102&lt;/span&gt;。&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;那么C当选Leader。&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在选举中，会出现选票被瓜分、选举失败的问题吗？&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;不会出现选票被瓜分导致选举失败的情况。&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;因为每个节点的节点ID都是不同的，而节点ID会参与选票的判断。&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;在epoch、zxid都一致情况下，还有节点ID可以兜底来保证选票给哪一个节点。&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有一个Proposal，在广播之前Leader宕机，经过崩溃恢复模式后，该Proposal是否会被提交？&lt;/p&gt;
&lt;figure class=&quot;highlight sqf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;不一定，取决新当选的&lt;span class=&quot;built_in&quot;&gt;Leader&lt;/span&gt;是否包含该Proposal&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;如果上一任&lt;span class=&quot;built_in&quot;&gt;Leader&lt;/span&gt;，在广播第一阶段有个Follower收到了。而新当选的&lt;span class=&quot;built_in&quot;&gt;Leader&lt;/span&gt;又是该Follower&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;则该Proposal会被提交。&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在崩溃恢复后，Leader首先将自己的状态设置为广播，然后再通知其他节点修改。那么这是有写请求进来，会执行成功吗？&lt;/p&gt;
&lt;figure class=&quot;highlight sqf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;会，这就是ZAB设计消息发送队列的原因，在&lt;span class=&quot;built_in&quot;&gt;Leader&lt;/span&gt;为广播状态时即可对外服务。&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;因为新封装的Proposal请求，一定会在通知其他节点数据同步完成的消息（UPTODATE）之后处理&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>52700d0932c1be83fc86d3a0335cfff4</guid>
<title>浅谈 Java 中的 AutoCloseable 接口</title>
<link>https://toutiao.io/k/znohjci</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Closes this resource, relinquishing any underlying resources. This method is invoked automatically on objects managed by the try-with-resources statement.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;While this interface method is declared to throw Exception, implementers are strongly encouraged to declare concrete implementations of the close method to throw more specific exceptions, or to throw no exception at all if the close operation cannot fail.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Cases where the close operation may fail require careful attention by implementers. It is strongly advised to relinquish the underlying resources and to internally mark the resource as closed, prior to throwing the exception. The close method is unlikely to be invoked more than once and so this ensures that the resources are released in a timely manner. Furthermore it reduces problems that could arise when the resource wraps, or is wrapped, by another resource.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Implementers of this interface are also strongly advised to not have the close method throw InterruptedException.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;This exception interacts with a thread&#x27;s interrupted status, and runtime misbehavior is likely to occur if an InterruptedException is suppressed.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;More generally, if it would cause problems for an exception to be suppressed, the AutoCloseable.close method should not throw it.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Note that unlike the java.io.Closeable#close close method of java.io.Closeable, this close method is not required to be idempotent. In other words, calling this close method more than once may have some visible side effect, unlike Closeable.close which is required to have no effect if called more than once.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;However, implementers of this interface are strongly encouraged to make their close methods idempotent.&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>269a06f1eba68f0280b1e96c514087fd</guid>
<title>现代 Web 开发语法基础与工程实践</title>
<link>https://toutiao.io/k/uhz45j5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;logged-out env-production page-responsive&quot; id=&quot;readabilityBody&quot;&gt;
    

    

  &lt;p id=&quot;start-of-content&quot; class=&quot;show-on-focus&quot;/&gt;





    


  

  &lt;include-fragment class=&quot;js-notification-shelf-include-fragment&quot; data-base-src=&quot;https://github.com/notifications/beta/shelf&quot;/&gt;




  &lt;div class=&quot;application-main &quot; data-commit-hovercards-enabled=&quot;&quot; data-discussion-hovercards-enabled=&quot;&quot; data-issue-and-pr-hovercards-enabled=&quot;&quot;&gt;
        &lt;div itemscope=&quot;&quot; itemtype=&quot;http://schema.org/SoftwareSourceCode&quot; class=&quot;&quot;&gt;
    &lt;main id=&quot;js-repo-pjax-container&quot; data-pjax-container=&quot;&quot;&gt;
      

    






  


  &lt;div class=&quot;bg-gray-light pt-3 hide-full-screen mb-5&quot;&gt;

      
          &lt;div class=&quot;d-block d-md-none mb-2 px-3 px-md-4 px-lg-5&quot;&gt;
      &lt;p class=&quot;f4 mb-3&quot;&gt;
        
&lt;g-emoji class=&quot;g-emoji&quot; alias=&quot;books&quot; fallback-src=&quot;https://github.githubassets.com/images/icons/emoji/unicode/1f4da.png&quot;&gt;📚&lt;/g-emoji&gt; 现代 Web 开发语法基础与工程实践，涵盖 Web 开发基础、前端工程化、应用架构、性能与体验优化、混合开发、React 实践、Vue 实践、WebAssembly 等多方面。
      &lt;/p&gt;
      
      
    
    
  &lt;/div&gt;

        
&lt;nav aria-label=&quot;Repository&quot; data-pjax=&quot;#js-repo-pjax-container&quot; class=&quot;js-repo-nav js-sidenav-container-pjax js-responsive-underlinenav overflow-hidden UnderlineNav px-3 px-md-4 px-lg-5 bg-gray-light&quot;&gt;
          

&lt;/nav&gt;
  &lt;/div&gt;


&lt;div class=&quot;container-xl clearfix new-discussion-timeline px-3 px-md-4 px-lg-5&quot;&gt;
  &lt;div class=&quot;repository-content &quot;&gt;

    
      

  &lt;p class=&quot;d-none d-lg-block mt-6 mr-3 Popover top-0 right-0 box-shadow-medium col-3&quot;&gt;
    
  &lt;/p&gt;

    &lt;signup-prompt class=&quot;signup-prompt-bg rounded-1&quot; data-prompt=&quot;signup&quot; hidden=&quot;&quot;&gt;
    &lt;div class=&quot;signup-prompt p-4 text-center mb-4 rounded-1&quot;&gt;
      &lt;div class=&quot;position-relative&quot;&gt;
        &lt;button type=&quot;button&quot; class=&quot;position-absolute top-0 right-0 btn-link link-gray&quot; data-action=&quot;click:signup-prompt#dismiss&quot; data-ga-click=&quot;(Logged out) Sign up prompt, clicked Dismiss, text:dismiss&quot;&gt;
          Dismiss
        &lt;/button&gt;
        &lt;h3 class=&quot;pt-2&quot;&gt;Join GitHub today&lt;/h3&gt;
        &lt;p class=&quot;col-6 mx-auto&quot;&gt;GitHub is home to over 50 million developers working together to host and review code, manage projects, and build software together.&lt;/p&gt;
        &lt;a class=&quot;btn btn-primary&quot; data-ga-click=&quot;(Logged out) Sign up prompt, clicked Sign up, text:sign-up&quot; data-hydro-click=&quot;{&amp;quot;event_type&amp;quot;:&amp;quot;authentication.click&amp;quot;,&amp;quot;payload&amp;quot;:{&amp;quot;location_in_page&amp;quot;:&amp;quot;files signup prompt&amp;quot;,&amp;quot;repository_id&amp;quot;:null,&amp;quot;auth_type&amp;quot;:&amp;quot;SIGN_UP&amp;quot;,&amp;quot;originating_url&amp;quot;:&amp;quot;https://github.com/wx-chevalier/Web-Series?hmsr=toutiao.io&amp;amp;utm_medium=toutiao.io&amp;amp;utm_source=toutiao.io&amp;quot;,&amp;quot;user_id&amp;quot;:null}}&quot; data-hydro-click-hmac=&quot;2aa01dc0717bbde03cc9119841a6e5dc804e93be105b4cd0fe97b284f0e72a5a&quot; href=&quot;/join?source=prompt-code&amp;amp;source_repo=wx-chevalier%2FWeb-Series&quot;&gt;Sign up&lt;/a&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/signup-prompt&gt;



  &lt;div class=&quot;gutter-condensed gutter-lg flex-column flex-md-row d-flex&quot;&gt;

  &lt;div class=&quot;flex-shrink-0 col-12 col-md-9 mb-4 mb-md-0&quot;&gt;
          





      &lt;div class=&quot;file-navigation mb-3 d-flex flex-items-start&quot;&gt;
  



  

  &lt;p class=&quot;flex-auto&quot;/&gt;

  &lt;a class=&quot;btn ml-2&quot; data-hydro-click=&quot;{&amp;quot;event_type&amp;quot;:&amp;quot;repository.click&amp;quot;,&amp;quot;payload&amp;quot;:{&amp;quot;target&amp;quot;:&amp;quot;FIND_FILE_BUTTON&amp;quot;,&amp;quot;repository_id&amp;quot;:229171266,&amp;quot;originating_url&amp;quot;:&amp;quot;https://github.com/wx-chevalier/Web-Series?hmsr=toutiao.io&amp;amp;utm_medium=toutiao.io&amp;amp;utm_source=toutiao.io&amp;quot;,&amp;quot;user_id&amp;quot;:null}}&quot; data-hydro-click-hmac=&quot;a8632c9383f375e28e50f1e7f816a9608ba4caf15df0a8e3703b432097c18203&quot; data-ga-click=&quot;Repository, find file, location:repo overview&quot; data-hotkey=&quot;t&quot; data-pjax=&quot;true&quot; href=&quot;/wx-chevalier/Web-Series/find/master&quot;&gt;
    Go to file
&lt;/a&gt;



    &lt;span class=&quot;d-none d-md-flex ml-2&quot;&gt;
        
&lt;get-repo&gt;
  &lt;details class=&quot;position-relative details-overlay details-reset&quot; data-action=&quot;toggle:get-repo#onDetailsToggle&quot;&gt;
    &lt;summary class=&quot;btn btn-primary&quot; data-hydro-click=&quot;{&amp;quot;event_type&amp;quot;:&amp;quot;repository.click&amp;quot;,&amp;quot;payload&amp;quot;:{&amp;quot;repository_id&amp;quot;:229171266,&amp;quot;target&amp;quot;:&amp;quot;CLONE_OR_DOWNLOAD_BUTTON&amp;quot;,&amp;quot;originating_url&amp;quot;:&amp;quot;https://github.com/wx-chevalier/Web-Series?hmsr=toutiao.io&amp;amp;utm_medium=toutiao.io&amp;amp;utm_source=toutiao.io&amp;quot;,&amp;quot;user_id&amp;quot;:null}}&quot; data-hydro-click-hmac=&quot;e7a67ef4da68ab4cc7aec8498045381abce22dca79ba4b031a0164abd5834fa5&quot;&gt;
      &lt;svg class=&quot;octicon octicon-download mr-1&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.47 10.78a.75.75 0 001.06 0l3.75-3.75a.75.75 0 00-1.06-1.06L8.75 8.44V1.75a.75.75 0 00-1.5 0v6.69L4.78 5.97a.75.75 0 00-1.06 1.06l3.75 3.75zM3.75 13a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5z&quot;/&gt;&lt;/svg&gt;
      Code
      &lt;span class=&quot;dropdown-caret&quot;/&gt;
&lt;/summary&gt;    &lt;div class=&quot;position-relative&quot;&gt;
      &lt;div class=&quot;dropdown-menu dropdown-menu-sw p-0&quot;&gt;
        &lt;div data-target=&quot;get-repo.modal&quot;&gt;
          &lt;div class=&quot;border-bottom p-3&quot;&gt;
            &lt;a class=&quot;muted-link float-right tooltipped tooltipped-s&quot; href=&quot;https://docs.github.com/articles/which-remote-url-should-i-use&quot; target=&quot;_blank&quot; aria-label=&quot;Which remote URL should I use?&quot;&gt;
  &lt;svg class=&quot;octicon octicon-question&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm9 3a1 1 0 11-2 0 1 1 0 012 0zM6.92 6.085c.081-.16.19-.299.34-.398.145-.097.371-.187.74-.187.28 0 .553.087.738.225A.613.613 0 019 6.25c0 .177-.04.264-.077.318a.956.956 0 01-.277.245c-.076.051-.158.1-.258.161l-.007.004a7.728 7.728 0 00-.313.195 2.416 2.416 0 00-.692.661.75.75 0 001.248.832.956.956 0 01.276-.245 6.3 6.3 0 01.26-.16l.006-.004c.093-.057.204-.123.313-.195.222-.149.487-.355.692-.662.214-.32.329-.702.329-1.15 0-.76-.36-1.348-.863-1.725A2.76 2.76 0 008 4c-.631 0-1.155.16-1.572.438-.413.276-.68.638-.849.977a.75.75 0 101.342.67z&quot;/&gt;&lt;/svg&gt;
&lt;/a&gt;



&lt;tab-container&gt;

  

  &lt;div role=&quot;tabpanel&quot;&gt;
    

    &lt;p class=&quot;mt-2 mb-0 f6 text-gray&quot;&gt;
        Use Git or checkout with SVN using the web URL.
    &lt;/p&gt;
  &lt;/div&gt;


  
&lt;/tab-container&gt;

          &lt;/div&gt;
          
        &lt;/div&gt;

        

        

        &lt;div class=&quot;p-3&quot; data-targets=&quot;get-repo.platforms&quot; data-platform=&quot;xcode&quot; hidden=&quot;&quot;&gt;
          &lt;h4 class=&quot;lh-condensed mb-3&quot;&gt;Launching Xcode&lt;span class=&quot;AnimatedEllipsis&quot;/&gt;&lt;/h4&gt;
          &lt;p class=&quot;text-gray&quot;&gt;If nothing happens, &lt;a href=&quot;https://developer.apple.com/xcode/&quot;&gt;download Xcode&lt;/a&gt; and try again.&lt;/p&gt;
          &lt;button type=&quot;button&quot; class=&quot;btn-link&quot; data-action=&quot;click:get-repo#onDetailsToggle&quot;&gt;Go back&lt;/button&gt;
        &lt;/div&gt;

        

      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/details&gt;
&lt;/get-repo&gt;


      
    &lt;/span&gt;
&lt;/div&gt;


      

&lt;div class=&quot;Box mb-3&quot;&gt;
  
  &lt;h2 id=&quot;files&quot; class=&quot;sr-only&quot;&gt;Files&lt;/h2&gt;
  


    &lt;a class=&quot;d-none js-permalink-shortcut&quot; data-hotkey=&quot;y&quot; href=&quot;/wx-chevalier/Web-Series/tree/10c6a899d423e33bc1964169f7b04081057c6323&quot;&gt;Permalink&lt;/a&gt;

  &lt;div class=&quot;include-fragment-error flash flash-error flash-full py-2&quot;&gt;
  &lt;svg class=&quot;octicon octicon-alert&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z&quot;/&gt;&lt;/svg&gt;&lt;p&gt;
  
    Failed to load latest commit information.

&lt;/p&gt;&lt;/div&gt;  &lt;div class=&quot;js-details-container Details&quot;&gt;
    &lt;div role=&quot;grid&quot; aria-labelledby=&quot;files&quot; class=&quot;Details-content--hidden-not-important js-navigation-container js-active-navigation-container d-md-block&quot; data-pjax=&quot;&quot;&gt;
      &lt;div class=&quot;sr-only&quot; role=&quot;row&quot;&gt;
        &lt;p role=&quot;columnheader&quot;&gt;Type&lt;/p&gt;
        &lt;p role=&quot;columnheader&quot;&gt;Name&lt;/p&gt;
        &lt;p role=&quot;columnheader&quot; class=&quot;d-none d-md-block&quot;&gt;Latest commit message&lt;/p&gt;
        &lt;p role=&quot;columnheader&quot;&gt;Commit time&lt;/p&gt;
      &lt;/div&gt;

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    &lt;/div&gt;
    &lt;p class=&quot;Details-content--shown Box-footer d-md-none p-0&quot;&gt;
      &lt;button type=&quot;button&quot; class=&quot;d-block btn-link js-details-target width-full px-3 py-2&quot; aria-expanded=&quot;false&quot;&gt;
        View code
      &lt;/button&gt;
    &lt;/p&gt;
  &lt;/div&gt;




&lt;/div&gt;

  


&lt;/div&gt;
    &lt;div class=&quot;flex-shrink-0 col-12 col-md-3&quot;&gt;
            

      &lt;div class=&quot;BorderGrid BorderGrid--spacious&quot; data-pjax=&quot;&quot;&gt;
        &lt;div class=&quot;BorderGrid-row hide-sm hide-md&quot;&gt;
          &lt;div class=&quot;BorderGrid-cell&quot;&gt;
            &lt;h2 class=&quot;mb-3 h4&quot;&gt;About&lt;/h2&gt;

    &lt;p class=&quot;f4 mt-3&quot;&gt;
      
&lt;g-emoji class=&quot;g-emoji&quot; alias=&quot;books&quot; fallback-src=&quot;https://github.githubassets.com/images/icons/emoji/unicode/1f4da.png&quot;&gt;📚&lt;/g-emoji&gt; 现代 Web 开发语法基础与工程实践，涵盖 Web 开发基础、前端工程化、应用架构、性能与体验优化、混合开发、React 实践、Vue 实践、WebAssembly 等多方面。
    &lt;/p&gt;
    

  &lt;h3 class=&quot;sr-only&quot;&gt;Topics&lt;/h3&gt;
  

  &lt;h3 class=&quot;sr-only&quot;&gt;Resources&lt;/h3&gt;
  

  &lt;h3 class=&quot;sr-only&quot;&gt;License&lt;/h3&gt;
  

          &lt;/div&gt;
        &lt;/div&gt;
          
          
          
          
          
      &lt;/div&gt;

&lt;/div&gt;&lt;/div&gt;

  &lt;/div&gt;
&lt;/div&gt;

    &lt;/main&gt;
  &lt;/div&gt;

  &lt;/div&gt;

          




  &lt;div id=&quot;ajax-error-message&quot; class=&quot;ajax-error-message flash flash-error&quot;&gt;
    &lt;svg class=&quot;octicon octicon-alert&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z&quot;/&gt;&lt;/svg&gt;
    &lt;button type=&quot;button&quot; class=&quot;flash-close js-ajax-error-dismiss&quot; aria-label=&quot;Dismiss error&quot;&gt;
      &lt;svg class=&quot;octicon octicon-x&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M3.72 3.72a.75.75 0 011.06 0L8 6.94l3.22-3.22a.75.75 0 111.06 1.06L9.06 8l3.22 3.22a.75.75 0 11-1.06 1.06L8 9.06l-3.22 3.22a.75.75 0 01-1.06-1.06L6.94 8 3.72 4.78a.75.75 0 010-1.06z&quot;/&gt;&lt;/svg&gt;
    &lt;/button&gt;&lt;p&gt;
    You can’t perform that action at this time.
  &lt;/p&gt;&lt;/div&gt;


  &lt;div class=&quot;js-stale-session-flash flash flash-warn flash-banner&quot; hidden=&quot;&quot;&gt;
    &lt;svg class=&quot;octicon octicon-alert&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z&quot;/&gt;&lt;/svg&gt;
    &lt;span class=&quot;js-stale-session-flash-signed-in&quot; hidden=&quot;&quot;&gt;You signed in with another tab or window. &lt;a href=&quot;&quot;&gt;Reload&lt;/a&gt; to refresh your session.&lt;/span&gt;
    &lt;span class=&quot;js-stale-session-flash-signed-out&quot; hidden=&quot;&quot;&gt;You signed out in another tab or window. &lt;a href=&quot;&quot;&gt;Reload&lt;/a&gt; to refresh your session.&lt;/span&gt;
  &lt;/div&gt;
  &lt;template id=&quot;site-details-dialog&quot;&gt;
  &lt;details class=&quot;details-reset details-overlay details-overlay-dark lh-default text-gray-dark hx_rsm&quot; open=&quot;&quot;&gt;
    &lt;summary role=&quot;button&quot; aria-label=&quot;Close dialog&quot;/&gt;
    &lt;details-dialog class=&quot;Box Box--overlay d-flex flex-column anim-fade-in fast hx_rsm-dialog hx_rsm-modal&quot;&gt;
      &lt;button class=&quot;Box-btn-octicon m-0 btn-octicon position-absolute right-0 top-0&quot; type=&quot;button&quot; aria-label=&quot;Close dialog&quot; data-close-dialog=&quot;&quot;&gt;
        &lt;svg class=&quot;octicon octicon-x&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M3.72 3.72a.75.75 0 011.06 0L8 6.94l3.22-3.22a.75.75 0 111.06 1.06L9.06 8l3.22 3.22a.75.75 0 11-1.06 1.06L8 9.06l-3.22 3.22a.75.75 0 01-1.06-1.06L6.94 8 3.72 4.78a.75.75 0 010-1.06z&quot;/&gt;&lt;/svg&gt;
      &lt;/button&gt;
      &lt;p class=&quot;octocat-spinner my-6 js-details-dialog-spinner&quot;/&gt;
    &lt;/details-dialog&gt;
  &lt;/details&gt;
&lt;/template&gt;

  

    &lt;div class=&quot;js-cookie-consent-banner&quot; hidden=&quot;&quot;&gt;
  &lt;div class=&quot;hx_cookie-banner p-2 p-sm-3 p-md-4&quot;&gt;
    &lt;div class=&quot;Box hx_cookie-banner-box box-shadow-medium mx-auto&quot;&gt;
    &lt;div class=&quot;Box-body border-0 py-0 px-3 px-md-4&quot;&gt;
      &lt;div class=&quot;js-main-cookie-banner hx_cookie-banner-main&quot;&gt;
          &lt;div class=&quot;d-md-flex flex-items-center py-3&quot;&gt;
            &lt;p class=&quot;f5 flex-1 mb-3 mb-md-0&quot;&gt;
              
  We use &lt;span class=&quot;text-bold&quot;&gt;optional&lt;/span&gt; third-party analytics cookies to understand how you use GitHub.com so we can build better products.

              &lt;span class=&quot;btn-link js-cookie-consent-learn-more&quot;&gt;Learn more&lt;/span&gt;.
            &lt;/p&gt;
            &lt;p class=&quot;d-flex d-md-block flex-wrap flex-sm-nowrap&quot;&gt;
              &lt;button class=&quot;btn btn-outline flex-1 mr-1 mx-sm-1 m-md-0 ml-md-2 js-cookie-consent-accept&quot;&gt;Accept&lt;/button&gt;
              &lt;button class=&quot;btn btn-outline flex-1 ml-1 m-md-0 ml-md-2 js-cookie-consent-reject&quot;&gt;Reject&lt;/button&gt;
            &lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class=&quot;js-cookie-details hx_cookie-banner-details&quot; hidden=&quot;&quot;&gt;
          &lt;div class=&quot;d-md-flex flex-items-center py-3&quot;&gt;
            &lt;p class=&quot;f5 flex-1 mb-2 mb-md-0&quot;&gt;
              
  We use &lt;span class=&quot;text-bold&quot;&gt;optional&lt;/span&gt; third-party analytics cookies to understand how you use GitHub.com so we can build better products.

              &lt;br/&gt;
              You can always update your selection by clicking &lt;span class=&quot;text-bold&quot;&gt;Cookie Preferences&lt;/span&gt; at the bottom of the page.
              For more information, see our &lt;a href=&quot;https://docs.github.com/en/free-pro-team@latest/github/site-policy/github-privacy-statement&quot;&gt;Privacy Statement&lt;/a&gt;.
            &lt;/p&gt;
          &lt;/div&gt;

          &lt;div class=&quot;d-md-flex flex-items-center py-3 border-top&quot;&gt;
            &lt;div class=&quot;f5 flex-1 mb-2 mb-md-0&quot;&gt;
              &lt;h5 class=&quot;mb-1&quot;&gt;Essential cookies&lt;/h5&gt;
              &lt;p class=&quot;f6 mb-md-0&quot;&gt;We use essential cookies to perform essential website functions, e.g. they&#x27;re used to log you in. 
                &lt;a href=&quot;https://docs.github.com/en/github/site-policy/github-subprocessors-and-cookies&quot;&gt;Learn more&lt;/a&gt;
              &lt;/p&gt;
            &lt;/div&gt;
            &lt;p class=&quot;text-right&quot;&gt;
              &lt;h5 class=&quot;text-blue&quot;&gt;Always active&lt;/h5&gt;
            &lt;/p&gt;
          &lt;/div&gt;

          &lt;div class=&quot;d-md-flex flex-items-center py-3 border-top&quot;&gt;
            &lt;div class=&quot;f5 flex-1 mb-2 mb-md-0&quot;&gt;
              &lt;h5 class=&quot;mb-1&quot;&gt;Analytics cookies&lt;/h5&gt;
              &lt;p class=&quot;f6 mb-md-0&quot;&gt;We use analytics cookies to understand how you use our websites so we can make them better, e.g. they&#x27;re used to gather information about the pages you visit and how many clicks you need to accomplish a task. 
                &lt;a href=&quot;https://docs.github.com/en/github/site-policy/github-subprocessors-and-cookies&quot;&gt;Learn more&lt;/a&gt;
              &lt;/p&gt;
            &lt;/div&gt;
            
          &lt;/div&gt;

          &lt;p class=&quot;text-right py-3 border-top&quot;&gt;
            &lt;button class=&quot;btn btn-primary js-save-cookie-preferences&quot; type=&quot;button&quot; disabled=&quot;disabled&quot;&gt;Save preferences&lt;/button&gt;
          &lt;/p&gt;
        &lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/div&gt;


  &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ffbe86900a34af7751874448f42a794a</guid>
<title>BigDecimal 的使用</title>
<link>https://toutiao.io/k/qzfxl8x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-body&quot; itemprop=&quot;articleBody&quot;&gt;

      
      

      
        &lt;p&gt;BigDecimal是&lt;code&gt;java.math&lt;/code&gt;包中的一个类，用来对超过16位有效位的数进行精确的运算。一般情况下，我们不需要太精确的数值运算可以直接使用Float和Double处理，但是正常工作中，肯定是需要对数值是精确点的，这时候可以使用BigDecimal。&lt;br/&gt;&lt;a id=&quot;more&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;float和double的精度&quot;&gt;&lt;a href=&quot;#float和double的精度&quot; class=&quot;headerlink&quot; title=&quot;float和double的精度&quot;/&gt;float和double的精度&lt;/h3&gt;&lt;p&gt;在使用BigDecimal先了解float和double的精度问题，float占32位(bit),double占64位，即float占4个字节，double占8个字节。&lt;/p&gt;
&lt;p&gt;float和double的范围是由指数的位数来决定的。float的存储时候1个bit是符号位，8个bit是指数位，剩下的23个bit是有效数字位，double存储的时候1个bit是符号位，11个bit是位指数位，剩下的52个bit是尾数位。精度由尾数决定，float的精度为7~8位有效数字，double的精度为16~17位。&lt;/p&gt;
&lt;p&gt;我们在使用float或者double会出现精度问题&lt;br/&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;float a = 0.05f;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;float b = 0.01f;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(a + b);&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个代码出现的结果不是0.06，而是0.060000002，同样double也会出现这样的问题&lt;br/&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;double c = 0.05d;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;double d = 0.01d;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(c + d);&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;打印结果是0.060000000000000005。&lt;/p&gt;
&lt;p&gt;基于上述会出现的精度丢失的问题，我们有必要使用BigDecimal进行精确的计算。&lt;/p&gt;
&lt;h3 id=&quot;BigDecimal&quot;&gt;&lt;a href=&quot;#BigDecimal&quot; class=&quot;headerlink&quot; title=&quot;BigDecimal&quot;/&gt;BigDecimal&lt;/h3&gt;&lt;h4 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;/&gt;构造函数&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;BigDecimal(int)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;创建一个具有参数所指定整数值的对象&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;BigDecimal(double)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;创建一个具有参数所指定双精度值的对象&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;BigDecimal(long)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;创建一个具有参数所指定长整数值的对象&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;BigDecimal(String)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;创建一个具有参数所指定以字符串表示的数值的对象&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;虽然构造函数支持float、double，但是我们也千万要注意使用string，不然同样会出现精度问题&lt;br/&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;float a = 0.05f;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;float b = 0.01f;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;BigDecimal m = new BigDecimal(a);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;BigDecimal n = new BigDecimal(b);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(m.add(n));&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;结果是0.060000000000000005，因为你以为传入a的值是0.05，但是BigDecimal构造的时候不是0.005，而是其更精确的值。这样就还是会出现精度问题，所以要用string方式构造。&lt;br/&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;BigDecimal s = new BigDecimal(String.valueOf(a));&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;BigDecimal t = new BigDecimal(String.valueOf(b));&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(s.add(t));&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;结果就是0.06&lt;/p&gt;
&lt;h4 id=&quot;常用方法&quot;&gt;&lt;a href=&quot;#常用方法&quot; class=&quot;headerlink&quot; title=&quot;常用方法&quot;/&gt;常用方法&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;add(BigDecimal)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;BigDecimal对象中的值相加，返回BigDecimal对象&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;subtract(BigDecimal)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;BigDecimal对象中的值相减，返回BigDecimal对象&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;multiply(BigDecimal)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;BigDecimal对象中的值相乘，返回BigDecimal对象&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;divide(BigDecimal)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;BigDecimal对象中的值相除，返回BigDecimal对象&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;toString()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;将BigDecimal对象中的值转换成字符串&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;doubleValue()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;将BigDecimal对象中的值转换成双精度数&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;floatValue()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;将BigDecimal对象中的值转换成单精度数&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;longValue()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;将BigDecimal对象中的值转换成长整数&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;intValue()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;将BigDecimal对象中的值转换成整数&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

      
    &lt;/div&gt;
    
    
    

    

    

    

    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8d8153548213bb03070a711f74f91d0b</guid>
<title>Flutter 中的 Tree Shaking 机制初探</title>
<link>https://toutiao.io/k/5qr2uj1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;在闲鱼技术探究Flutter工程一体化的过程中，为了做到最好的开发体验，需要无缝衔接FaaS端代码与业务Flutter代码，一份代码既可以在FaaS部署，也可以直接引入在业务代码主工程中，使之真正做到工程一体。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了实现这一目标我们对两部分代码通过RPC调用的方式实现了代码解耦，而工程解耦依赖于Flutter/Dart在编译过程中的Tree-Shaking机制。为了避免踩坑，我们需要了解，整个Tree-Shaking是怎么起作用的。本篇文章结合Flutter Engine源码对这一过程进行了简单的探究。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前置知识&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;Tree Shaking是一种死代码消除（Dead Code Elimination）技术，这一想法起源于20世纪90年代的LISP。其思想是：一个程序所有可能的执行流程都可以用函数调用的树来表示，这样就可以消除那些从未被调用的函数。该算法最先被应用到Google Closure Tools中的JavaScript中，然后被应用到同样由Google编写的dart2js编译器中。在Flutter中，同样有这样的Tree Shaking机制来减小最终产出的包大小。Flutter提供了三种构建模式，针对每个不同的模式，Flutter编译器对产出的二进制文件有不同优化，Tree-Shaking机制并不会在debug模式中触发。在Profile/Release模式下编译的AOT产物中，有几个比较重要的产物可以让我们更直观地看到Tree-Shaking机制在发挥作用：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;app.dill : 这就是dart代码通过build的产物，为二进制的字节码，可以通过 &lt;code&gt;&lt;span&gt;strings&lt;/span&gt;&lt;/code&gt;看到里面的内容，其实就是我们dart代码的源码。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;snapshot_blob.bin.d : 这个文件里面是所有参与编译的dart文件的集合，包括我们自己的业务代码、 &lt;code&gt;&lt;span&gt;pubspec.yaml&lt;/span&gt;&lt;/code&gt;中定义的三方库的代码、以及我们业务代码中import进来的所有flutter或者dart原生 &lt;code&gt;&lt;span&gt;package&lt;/span&gt;&lt;/code&gt;的代码。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Tree Shaking机制探究&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;最小化Demo初探&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;我们写一个最简单的例子，代码如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;img data-ratio=&quot;0.6029411764705882&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1GgveSJlIib1MicndkpiaraxEhL34NHgXzn8T8FfN9xSqzCQPgouvo0Hw1eo3iaqBXoV9RKNNdTeGicLUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;680&quot;/&gt;&lt;span&gt;代码非常简单，里面包含了一个没有被使用的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;_unused&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法。下面我们在Profile模式下进行编译，通过DevTools来查看最终编译的产物，如下图所示&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.63125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1GgveSJlIib1MicndkpiaraxEhYAxXYZCQCSbx66qIMCSpFItoBZPxfCCqVAPBP9FcqTEIb1mUR2IeHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;span&gt;可以看到，在Funtions中，并没有 &lt;/span&gt;&lt;code&gt;&lt;span&gt;_unused&lt;/span&gt;&lt;/code&gt;&lt;span&gt;方法，说明在编译过程中，这段无用的代码被“摇”掉了。实际上除了Function之外，Flutter编译过程中对于引入的lib，import的dart文件都有相似的Tree-Shaking处理。下面深入代码来看看，这究竟是怎么做到。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;代码解析&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;这里借用Gityuan前辈的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;flutter run&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 命令执行的时序图，整个编译流程会比较长，在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;GenSnapshot.run()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法会调用gen&lt;span&gt;snapshot这个二进制可执行文件（对应的源码在目录third&lt;/span&gt;party/dart/runtime/bin/gen&lt;span&gt;snapshot.cc），生成机器码。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.38263665594855306&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1GgveSJlIib1MicndkpiaraxEhqpdDNHQeK79TOJiccjPVpPibNgxemCPT8lRW2Hzg8iaSwGN3paelOckjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1244&quot;/&gt;用放大镜来看看gen&lt;/span&gt;snapshot内部的执行过程：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;img data-ratio=&quot;0.948892674616695&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1GgveSJlIib1MicndkpiaraxEhQuj5djmza2HESBSyS2td55XdUZiczvcMdhDsxJQwSoULKcnA0ufiaxJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1174&quot;/&gt;&lt;span&gt;tree-shaking机制就发生在其中的编译阶段，即 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CompileAll()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法。下面我们深入到代码去一步一步探究，Flutter编译器是怎么对代码做裁剪的。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;源代码路径是third_party/dart/runtime/vm/compiler/aot/precompiler.cc，读者也可以自行对照查询。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;编译阶段&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;首先是必备的准备工作，需要将对象池保留到AOT编译结束，因此这里必须使用能存活那么久的句柄，使用了StackZone。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;img data-ratio=&quot;0.2848360655737705&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1GgveSJlIib1MicndkpiaraxEhfq6fMmxh6yAf9rWIKiaMAjtfEHI9cF2nyJGRtl3epPw94R5IMstvb7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;976&quot;/&gt;&lt;span&gt;为了使用类层次结构分析 (CHA)，在编译前需要确保类的层次结构稳定，同时确保查找入口点时不会因为函数的类还没有最终确定而漏掉函数。CHA是一种编译器优化，可根据对类层次结构的分析结果，将虚拟调用去虚拟化为直接调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;img data-ratio=&quot;0.5449101796407185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1GgveSJlIib1MicndkpiaraxEhcPCGadRSv8Genya2W4e9aWzVhO4nr2XFhowD1h4rfXJviaD7TrZYu9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1002&quot;/&gt;&lt;span&gt;预编译构造函数，计算优化指令数等信息，可以用于内联函数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;img data-ratio=&quot;0.15517241379310345&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1GgveSJlIib1MicndkpiaraxEh8q1Mwuvc8gthN8wPyxNn5vB8kKAdrLia7eHA7JKEvDDFBvmvuf4B5oQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1508&quot;/&gt;&lt;span&gt;下一步生成桩代码，通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;StubCode::InterpretCall&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 得到的code来获取它的对象池，再利用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;StubCode::Build&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 等一系列方法系列方法获取的结果保存在object_store。收集动态函数的方法名，之后通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;AddRoots()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法，从C++发生的分配和调用的起点添加为根， 同时通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;AddAnnotatedRoots()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法将所有以@pragma（’vm：entry-point’）为标注的也添加为根。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;img data-ratio=&quot;0.3527272727272727&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1GgveSJlIib1MicndkpiaraxEh1x5WR40LQwMicd9D0ro3D3Tacho3x4UmN4WuEJdCEVUXwPLyqIc5lvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;&lt;span&gt;之后，代码开始编译， &lt;/span&gt;&lt;code&gt;&lt;span&gt;Iterate()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是编译最为核心的地方。在这里会以上面找到的根作为目标，遍历添加该目标的调用者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;img data-ratio=&quot;0.7601809954751131&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1GgveSJlIib1MicndkpiaraxEhKc00NWBdfWd2QRt1MsTC06bicX92HhRKLbMCppgsogba2Fpp1xbzNPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;884&quot;/&gt;&lt;span&gt;在该方法内部，主要的调用链如下：&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;ProcessFunction
==&amp;gt; CompileFunction
==&amp;gt; PrecompileFunctionHelper
==&amp;gt; PrecompileParsedFunctionHelper.Compile&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;至此，编译完成之后开始进入Tree-Shaking阶段，对无用代码进行简化。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;Tree shaking阶段&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;在上面的编译过程中，函数/类等调用信息已经进行了输出，根据这些信息，让编译器可以知道，具体哪一些是不必要的代码。这里以对Function的处理为例进行讲解：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这个方法中，取得Library、Class等句柄之后，以Library为单位，对每个包内的代码进行处理，会遍历所有类中的Functions进行处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;img data-ratio=&quot;0.4041916167664671&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1GgveSJlIib1MicndkpiaraxEhbhsiasvJicsJKur99hr5eGGFhOEBic43v4VulrE0t7EpytibEIHOcQb1kQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1336&quot;/&gt;&lt;span&gt;通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;AddTypesOf(constFunction&amp;amp;function)&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法，将调用到的函数添加到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;functions_to_retain_&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 池中，同时对Function中的类型参数做了读取，通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;AddType&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法，将这些类型参数添加到对应的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;typeargs_to_retain_&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 池和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;types_to_retain_&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 池中，用于类型信息的TreeShaking（分别对应DropTypeArguments和DropTypeParameters）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;img data-ratio=&quot;0.5249221183800623&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1GgveSJlIib1MicndkpiaraxEhhBzEulxn8ib425DD6InjSvQicMcPkRpp0qAJ7QqE0icTIysBa1vZramBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1284&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;Class信息在同名方法 &lt;/span&gt;&lt;code&gt;&lt;span&gt;AddTypesOf(constClass&amp;amp;cls)&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中进行处理，处理过程比较类似，这里不做赘述，感兴趣的读者可以自行查阅&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;这个方法里面，会确保在执行Drop方法之前建立用于序列化调度表的条目，因为编译器后续可能会清除对Code对象的引用。同时删除调度表生成器，以确保在这之后不再尝试添加新条目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这个方法里通过声明的匿名内部类 &lt;/span&gt;&lt;code&gt;&lt;span&gt;StaticCallTableEntryFixer&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ，对静态函数调用入口做了替换。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来，会执行一系列的Drop方法。这些方法会去掉多余的方法、字段、类、库等，如下所示：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DropFunctions();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DropFields();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DropTypes();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DropTypeParameters();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DropTypeArguments();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DropMetadata();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DropLibraryEntries();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DropClasses();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DropLibraries();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;具体调用时序如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;img data-ratio=&quot;0.6331428571428571&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1GgveSJlIib1MicndkpiaraxEhUIayr0icbgbeABsV1ssndpRgM9tUZ3ibaCTibGGehtmVb800VHejWGwsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;875&quot;/&gt;&lt;span&gt;由于这些方法的内部实现思路有很多相似之处，这里针对Function的方法 &lt;/span&gt;&lt;code&gt;&lt;span&gt;DropFunctions&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 为例来说明。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在该方法中，核心是通过以上提到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;functions_to_retain_&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 池，对Function是否有根调用者进行判断， 如果池中不包含Function对象，说明这是可以舍弃的Function。之后，将剩下的Function重新写回Class，并更新Class的调用表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在方法内部声明了drop_function函数来“摇掉”Function。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;img data-ratio=&quot;0.6970802919708029&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1GgveSJlIib1MicndkpiaraxEh8d5nEULgw3RvQQzhc3AVKibHxrjufPcolHaE9vYRNs0mvFs0rhaNlOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1096&quot;/&gt;&lt;span&gt;之后使用对所有的代码中的Function进行遍历， 使用上面声明的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;drop_function&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对无用的Function代码进行标记和删除。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;img data-ratio=&quot;0.5763779527559055&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1GgveSJlIib1MicndkpiaraxEhMIYPzss0GbRVBBDcZPJdPpUQ9TO0CU7zfzHPe3vEsvDfjDrfQe0RPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1270&quot;/&gt;&lt;span&gt;将需要被保留的Funtion重新写进所属Class中：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;img data-ratio=&quot;0.2821011673151751&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1GgveSJlIib1MicndkpiaraxEhcqsE4p5ufNicSEBWlvPNEst7SpItXMkcIeXP9c7877lhicE0o0me6v3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1028&quot;/&gt;&lt;span&gt;重新生成类的调用表，同时对调用表中的可能存在的无用Function进行兜底删除：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;img data-ratio=&quot;0.6324921135646687&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1GgveSJlIib1MicndkpiaraxEhDwkmqspnlXPeiasF37ky6BBbWFov2l1ZQonJMKic4uazOg6gzvbLX6uw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot;/&gt;&lt;span&gt;最后是一些内联函数等边界情况的处理，这里不再赘述。在完成Drop阶段之后，可以被丢掉的代码已经进入了删除池中，后面进入编译的收尾阶段，进一步减小二进制文件大小。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;收尾阶段&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;在Tree-Shaking结束之后，进入编译收尾工作，包括代码混淆，垃圾回收等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;img data-ratio=&quot;0.755056179775281&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1GgveSJlIib1MicndkpiaraxEhrPmoOvQ9Bk4CJb2T1Jn6q4f9J80K3EsryCTRJHMHvfjAgCgXdWTaHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;890&quot;/&gt;&lt;span&gt;值得注意的是Dedup这个方法，关键代码代码如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;img data-ratio=&quot;0.7250859106529209&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1GgveSJlIib1MicndkpiaraxEhyHf0emsgNlRicPfCvjUo67ALAv3WAkaIQK3FvSHW6k4AYMDqUbLN8icQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1164&quot;/&gt;&lt;span&gt;在该方法内进行很多重复数据删除工作；在AOT模式下，binder是在Tree Shaking之后运行的，在此期间，所有的目标都已经被编译，因此binder会用对目标的直接调用代替所有的静态调用，进一步减小了编译产物二进制文件。至此所有的编译工作完成，Tree-Shaking完成了他的使命。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;拓展&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;在Flutter 1.20版本，通过Tree-Shaking机制移除在工程中未使用到的icon fonts，进一步缩小了包大小（100KB左右），不过该方法的实现并不在以上说明的编译阶段，而是在build_system里，对assets进行了优化。相关的PR在&lt;/span&gt;&lt;span&gt;github.com/flutter/flutte/pull/49737&lt;/span&gt;&lt;span&gt;可以查看。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;本文主要结合Flutter Engine源代码，从编译阶段出发，探究了在过程中Tree-Shaking的运行机制。由于这样一个机制的存在，为工程解耦提供了理论基础，让工程一体化的实现更为简单，同时对我们进一步优化包大小有启发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.5171875&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1Eojqc694G4ReIf3N1VHTwLkBHVJESIFLiczQ4vDlNtfiaVYRMeOUwXUB9IaFricKteNTWg48zcxmpMA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>